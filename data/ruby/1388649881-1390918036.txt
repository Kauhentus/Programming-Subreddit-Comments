Is that for actual active development or is it just a mirror? I thought they had a hosted SVN on ruby.org so wondering which is used
Finally some order is coming to MRI's development process. Previously, there was no meaning behind major and minor version bumps.
Depends if new features will always be released on Christmas. Might want to clarify this with @hsbt / @_zzak on twitter.
I asked in `#ruby-core` why they are still using SVN. Turns out some of ruby-core still develops on Windows and Git has yet to release a [non-preview version](http://code.google.com/p/msysgit/downloads/list?q=full+installer+official+git) for Windows. As soon as Git releases an official version for Windows ruby-core will begin transitioning to Git. In the long term, we should convince more Rubyists to migrate to Linux/BSD/OSX.
I would recommend reading [Practical Object-Oriented Design in Ruby](http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330).
Lol at the fucking git bandwagoning
I wish I could help just by reading your code but I'm a newbie myself... However these tuts should steer you in the right direction: https://tutsplus.com/course/object-oriented-design-and-refactoring-patterns-in-ruby/ https://tutsplus.com/course/ood-in-ruby-solid-principles/ All the best
I made an honest effort to develop in Ruby and Python on Windows last year and I just don't know how people can put up with that. Vagrant helps considerably, but every terminal emulator I tried for Windows has sucked hard compared to even the most basic terminal emulator in OSX or Linux and there were all sorts of issues with Japanese characters (I live and work in Japan so the ability to properly display Japanese characters in the terminal is pretty important). It would be nice if those hardcore Windows devs focused their efforts on IronRuby instead IMO.
*Refatoring* by Martin Fowler (http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672) is the classic. I also recommend *Working Effectively with Legacy Code* by Michael Feathers (http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052).
I had a very quick look. Mention of the word "tax" immediately made me think "strategy pattern" and given you currently have tax amounts expressed as magic numbers I'd look there first...
Looks good, I'm approaching the same issue with DCI which should result in a slightly different implementation with the same results which is the separation of concerns and having the business logic in a separate, testable gem decoupled from the database. I expect towards the end of the year when people have more experience with Clean Architecture, DCI, and hexagonal we'll see a new architecture emerge that may or may not combine all these. With the clean architecture I wonder what the top level directory structure looks like and if this sits above Rails? 
Hi, I wrote a nice plugin for sublime, the plugin gives a visual and interactive ruby debugger. I hope you will find it useful. Shuky.
ST3 only?
It needs an option to include no Rails docs.
Vanilla ruby is already plenty slow as it is, it would be silly to make it even slower by default. Particularly when nearly every language operates the same way with regards to floating point precision. For most practical purposes, floats are enough. This is why amateurs get away with not knowing about them for so long, and then ultimately are shocked when they find out that math which should be basic isn't as simple as it seems. When floats aren't enough, then you're expected to know what to do and why. A language can't be expected to hold your hand for everything...
I use [rbenv](https://github.com/sstephenson/rbenv) with its [ruby-build plugin](https://github.com/sstephenson/ruby-build#readme). % rbenv install 2.1.0 Downloading ruby-2.1.0.tar.gz... -&gt; http://dqw8nmjcqpjn7.cloudfront.net/9e6386d53f5200a3e7069107405b93f7 Installing ruby-2.1.0... Installed ruby-2.1.0 to /home/meta/.rbenv/versions/2.1.0 % rbenv global 2.1.0 % ruby -v ruby 2.1.0p0 (2013-12-25 revision 44422) [x86_64-linux] Then every now and again I go into ~/.rbenv/versions and delete some old ones.
[and only] on Christmas. I'll ask them.
I don't know what's more disappointing: A. Ruby versioning isn't semantic (read: organized) and isn't likely to ever be, or B. the Ruby leadership is either in denial about it or doesn't understand semantic versioning. Personally, choice B. is by far the most disturbing.
This looks interesting. I'm curious how you handle optimizing one-off database queries with the ActiveRecord methods like #includes or #find_each hidden even from the entity. If I have a view that aggregates data, for instance, that view optimization doesn't really belong to the core application logic but I would be forced to dive into the gem and add a public method on the Repositories::Members::ActiveRecord::Member class. Thoughts?
I guess if Christmas is what gives you meaning, then it's semantic.
I've been seeing this a lot more with Rails and have actually had the displeasure of working with someone like this. You're not writing cleaner code or architecting things better, you're abstracting things that don't need abstractions and make it harder to get any real work done. eg: This guy used presenters to generate an 8 column table using 16 different presenter classes. This isn't even considering his service and form object maze in the main component of the application that made it impossible to access params in an object that was forced to be nested way down in this "maze". All things in moderation is a good rule to apply with things like this.
Well, they do say it's a "Semantic Versioning-type" scheme.
It used to be everyone understood how versioning was supposed to work. We didn't need a global standard (SemVer) until Ruby came along.
The gem is part of the application, so you control it. As for DB optimizations you can write a method on the AR repository that eager loads stuff, etc, etc, and have its in memory counterpart be an alias for the same thing but without optimizations. It's probably not the best solution, but at least you get to add DB specific optimizations and still have everything work despite the persistence mechanism. 
The whole point here is not to have a complex architecture where everything is abstracted and have tons of stuff like J2EE. The main point is to decouple your application from the database and the web, for instance, and that's it, the rest is just the way I managed to do it. But, if you give a closer look or even try to fiddle with a codebase built like this, you'll find that it's actually really simple and has very few extra concepts you need to know apart from PORO... Most of the time you'll be writing pure OO code with blazing fast tests. I have to say that from my experience doing it's been nothing but a pleasure. Obviously you can write good applications following rails MVC, and being completely coupled to the DB by using AR and to the web, because it's RoR. It's a tradeoff. But I think it's good to be aware that you're having that coupling and handle it appropriately. This is the best way I've found of doing so, it is by no means a silver bullet, since there is none. However, I strongly believe this is a great way of building applications that provides enormous flexibility to your code base.
Just picked this up last December! It's an awesome read and it's helping a lot—thanks for the reference. Are there any sections in here that'd you personally recommend? 
I just came across Martin Fowler and I really admire his philosophy towards software development—I'll definitely take the time to check these out thank you ! 
thanks so much man—really appreciate the reference ! 
Thanks so much for tip—I was looking through my calculate.rb file yesterday and noticed how ambiguous those values are in terms of understandability. I'll definitely need to find a way to make it more transparent. Thanks again ! 
wow thank you so much for your comments. I'll definitely take these into consideration and starting implementing them as soon as I get back. I'll keep you posted on any other updates thanks again ! 
@zakk's response to "why not true semver?" 1. https://twitter.com/_zzak/status/418860579025981440 2. https://twitter.com/_zzak/status/418858907960758272 It would help if everyone complaining in this thread would actually DO something and follow up with us, whether on twitter, github, or the issues page. See postmodern's post: http://www.reddit.com/r/ruby/comments/1u6ahv/semantic_versioning_starting_with_ruby_210/cefe6qz
Indeed - as lcowell says other gems create thumbnails etc. on upload. Dragonfly can do that too but the preferred way is on demand (with caching) so sizes are specified in the view. You could also create e.g a resizing server out of it. It's actually been around for 5 years or so - now was a good a time as any to make it 1.0
Well, it happens that I've recently started to learn, but I'm happy that you were born knowing it. 
Thanks for this! Will definitely have to check it out.
Yeah i didn't had time to write it for ST2
If you really want to use this return value you can just reference it at the end e.g. module It class This def that end This end It end I agree that it should just do this by default.
More generally than this, your code doesn't currently have a domain model. Your code should look like parse =&gt; domain model =&gt; output Once you have represented the problem as a domain model you'll be able to unit test the meat of the problem, which is the taxation e.g. Product.new(description: "Book", price: 12.49, tax_exempt: true, imported: false).tax.should == 0 I've used flags to represent the different taxation options here, as you're exploring OO you might consider an inheritance model for the different types of product. 
A little unrelated, but is ST3 a no-brainer to upgrade to at this point? I mean, if you're only targeting it for release I assume you're super happy with it. And it seems like the beta period that will never end. How long have you be on ST3?
I'm not sure what we would want to do with the return value of a constant from class/module definitions. Assign it to something? Well, we don't need to do that because you have a direct reference to the class since it is a constant. If you do want to assign a class/module to a variable then you can use their initializers: foo = Class.new do # class definitions here end
I'm not a purist by any means. There are times to keep things "traditional" and times to separate things into services, form objects, etc. I'm just saying that it's really easy to take it too far and over architect things. From experience it's worse to receive an over architected solution than an under architected one.
I don't understand why it's so wrong to be coupled to the web. You're writing a web application that interacts with a database, it's not something that is easily avoided (coupling to them). Adding abstractions on top of that doesn't make sense to me in most cases. How often will I need that flexibility with my code base when I could just extract it later if I need it?
I was actually thinking of using ParsleyJS for the client-validations, moving towards Angular. Why'd you choose Angular over the other front-end frameworks? What's your testing framework for Angular?
It’s heavier than Angular, but also made for Rails and worth checking out: http://batmanjs.github.io
Wow. Almost none of the install information for Postgres on Ubuntu looks useful. And that's weird, because using Postgres on Ubuntu is dead simple. - It's in the repo. You can install it with apt-get. - By default, Postgres authenticates users by system username. If your username is "bob", you tell postgres your databases are owned by "bob". - You use the system user "postgres" to run admin commands. - The two admin commands that matter are "createuser" and "createdb". These are both simple shell comands. If you want to set up a database server machine there's more steps, but for a local database (e.g. for development), the default setup is awesome.
Cool idea, seems really counterintuitive but it works. At a memory cost. "Misshit" seems more like mis-shit, an unfortunate bathroom accident.
A big +1 for parsley.js. I just used it in a project and it's amazing. 
Indirection that doesn't add value is poorly factored code. Plain and simple. There may be a lot of people cargo culting enterprise design patterns, but that doesn't mean they have no value. What Uncle Bob is talking about is to abstract away details that *get in the way* of building our application. He's not talking about creating abstractions that get in the way of building our application. I would also say that anyone thinking about building out an architecture like this should consider reading Eric Evans' [Domain Driven Design](http://en.wikipedia.org/wiki/Domain-driven_design). You need to make sure all these patterns, objects, and abstractions actually align with your software domain. Otherwise, you're just building a Kingdom of Nouns.
*First paragraph from linked [Wikipedia article](http://en.wikipedia.org/wiki/Domain-driven_design):* --- **Domain-driven design (DDD)** is an approach to developing software for complex needs by deeply connecting the implementation to an evolving model of the core business concepts. The premise of domain-driven design is the following: --- ^[(?)](http://www.reddit.com/r/autowikibot/wiki/index) ^| ^[(CC)](http://creativecommons.org/licenses/by-sa/3.0/) ^| *^This ^bot ^automatically ^deletes ^its ^comments ^with ^score ^of ^-1 ^or ^less.*
Because automated testing a web application through a browser is painful. My experience has corroborated this -- capybara is a great tool, but very hard to write consistent, robust tests against. Uncle Bob suggests putting the brains behind your UI just underneath the framework by building what he calls Interactor objects. Unlike rails controllers, these objects don't have to know/care about requests, responses, HTTP status codes, HTML, etc.
Wow, I actually learned something new in every trick. Pretty nice :)
well I feel enlightened 
Nice. I knew about the % trick once but haven't used it for ages. Should be handy for strings that contain a mixture of single and double quotes - code that generates HTML with Javascript embedded, stuff like that.
You can also call procs with `[]`, like so: # this some_proc.call("arg1", "arg2") # is equivalent to this (as far as I know) some_proc["arg1", "arg2"] However, this syntax may be a little less readable for people not familiar with it.
I can't remember the name and didn't find it with a quick googling but I've read about a project more or less similar that was being worked on. It wasn't a mac app but a web app kinda thing à la wordpress admin interface.
I do *a lot* of testing and I don't exactly see what you're getting at. All the automated testing I do is to test components interactive which is usually multiple controllers or just complex features because it's **integration testing**. I've worked on projects with slow capybara test suites because they used it as a controller spec replacement. It's not and it's slow and painful. If you want to use decorators and test them, perfect. Just make them reasonable and try to keep HTML out of them as much as possible. Services objects? They're awesome, just don't let them take over your application. Use Form objects to keep complex validation logic out of your models. All of the things I just listed are tools that are there to help you. I'm not saying to not use them, I'm saying don't use them like they're the end all be all or like they are there to replace what Rails has already given you. Use them in moderation and in a sane, practical and FLEXIBLE way and you'll get a lot of mileage out of them.
I'll reiterate this again. I'm not saying to not use design patterns or to abstract pieces of your application. I'm saying to be weary of cargo culting into abusing these methods. I worked with a guy who turned EVERYTHING into a pattern. The code was inflexible, he tried to predict the future, and he designed it to where if you wanted any flexibility you'd have to rewrite it because it wasn't "designed for this specific domain problem". There are actually guys like that out there who are lunatics who write ridiculous code and there are those that use it in moderation and use it correctly. All I'm saying is be aware that you aren't that guy. Use these patterns when they make sense, but don't try to force a pattern when there isn't one.
In some domains, a real impedance mismatch can start to emerge between a typical "RESTful" rails controller, and the use cases you build out and expose via the UI. Even if you're dutiful about your functional/controller tests, you may reach a point where the actual unit of work in a controller action, in its' entirety, is very difficult to test because of all the extra dependencies you have to satisfy -- namely, the request/response cycle. This will lead to epic sized test setups that are really hard to maintain, and have a really low signal to noise ratio in terms of how much of the test code is actually checking that your use case is doing what you expect. If you don't encounter this pain, then feel free to ignore what Uncle Bob is talking about. Rails very much bakes a "resource" paradigm into every tier of the framework -- `ActiveRecord::Base`, `ApplicationController`, and `config/routes.rb` are very symmetrical to one another by design. This can be an undeniably well lubricated, high velocity groove for your typical CRUD based rails app. When it works, it works great. I think you're frustrated with programmers who eschew that groove *even when it makes sense.* From that perspective, I totally agree with you.
Thanks all!
Ah neat. What model is it? Would you be willing to share your code? I've had a shot at getting this into the Thing System in one form or another, which might make it even more useful :)
I just got my Jekyll site set up on GitHub where every time I push a new commit, Travis CI builds the site and pushes it to the gh-pages branch, thus updating my site. Since I can create and edit posts via GitHub's website text editor, this gives me a web-based GUI. If I want to work on posts locally, but the system I'm on only has git or a web browser (and not ruby / bower, etc.), I can still push changes that will go live if I want since Travis takes care of the build. Here is a write up: http://evansosenko.com/posts/automatic-publishing-github-pages-travis-ci/
Lol page 112 from the Pickaxe book: Technically, Ruby does not have a class for characters—characters are simply strings of length one. For historical reasons, character constants can be created by preceding the char- acter (or sequence that represents a character) with a question mark: ?a # =&gt; "a" (printable character) ?\n # =&gt; "\n" (code for a newline (0x0a)) ?\C-a # =&gt; "\x01" (control a) ?\M-a # =&gt; "\xE1" (meta sets bit 7) ?\M-\C-a # =&gt; "\x81" (meta and control a) ?\C-? # =&gt; "\x7F" (delete character) Do yourself a favor and immediately forget this section. It’s far easier to use regular octal and hex escape sequences than to remember these ones. Use "a" rather than ?a, and use "\n" rather than ?\n.
Yeah I moved to Parsley from JQueryValidate. My problem though is that I'm unable to link the validations in AR to the validations in parsley. For example I still put `required` in Parsley erb fields. Is this how you also do it?
I always tell people, don't replace bad php written in ruby with bad Java written in ruby.
I really wish people would stop assigning arbitrary percentiles to things in an effort to make it sound exciting. Don't use numbers unless you have something to back it up.
I've ran across Audite, however it doesn't seem to handle remote mp3s (or at least I couldn't find a way to get it to work - suggestions welcome!)
Sooo... uhhh... what is the big win over commiting directly to `gh-pages` and letting github build them for you? This seems to me to be duplicating functionality that github already provides.
This syntax is a ruby idiom used for extracting strings with regexp: str = "bitcoin bitter bite" str[/(bit[^\s]*)/,1] # =&gt; "bitcoin" First argument is a regexp with grouping, second argument is index of substring to extract. See [RubyDoc for Class: String](http://ruby-doc.org/core-2.1.0/String.html#method-i-5B-5D)
I used to love this syntax, but have recemtly started using call() instead since it is easier, or at least friendlier if you want to let someone replace the proc with a custom class.
Your reduce example with symbol to block conversion is missing the &amp;, should be [1, 2, 3].reduce &amp;:+ Also might be worth noting that the temptation to chain comprehensions can almost always be replaced with a single call to reduce. A great explanatory post for beginners! I'll keep this link handy the next time someone asks me what reduce does. Thanks for improving the community.
This is pretty cool. It looks much more extensive then GitHub's built in online editing features.
I think Github pages sort of stands on its own as a host for Jekyll sites because those using Jekyll/Github pages prefer more esoteric, developer-centric tools like Travis CI. What I'm aiming todo here is build an app for those who are technically inclined but prefer a polished GUI environment for blogging/writing.
Actually inject/reduce don't need the &amp; due to historical reasons. It supported a symbol as an argument long before Symbol#to_proc was introduced.
As I said in the end of the article, I follow the famous Ruby Style Guide from bbatsov, which says: "Prefer map over collect, find over detect, select over find_all, reduce over inject and size over length. This is not a hard requirement; if the use of the alias enhances readability, it's ok to use it. The rhyming methods are inherited from Smalltalk and are not common in other programming languages. The reason the use of select is encouraged over find_all is that it goes together nicely with reject and its name is pretty self-explanatory." As asthasr and yxhuvud said, inject is used in no other language but Smalltalk, so I guess reduce is preferred for better readability when people know multiple languages: it is "more standard". Same reasonning goes for other aliases. These aliases are "to avoid", but it is not a hard requirement; otherwise I would have said "aliases to forbid". :-)
What? Your ruby skill ISN'T 10/10?
Fair enough. My history is not via Smalltalk, so I tend to think in terms of `reduce`/`fold`/`filter`.
Totally disagree that aliases "to avoid" is an idea we want in Ruby. In Python there is only one way to do something, not so in Ruby where there is "more than one way to do it". The aliases you picked are arbitrary and happened to be the ones you picked, but if you want to understand the code I write then you'll have to deal with #detect, #inject, #find_all, #collect as well as #find, #reduce, #select, #map I use them interchangeably depending on context [sometimes phrasing a sentence differently might make its meaning clearer](http://c2.com/cgi/wiki?ThereIsMoreThanOneWayToDoIt). Consider Array#count, Array#length, and Array#size. 3 different method names that all do the same thing but are there to help you write more expressive Ruby.
You're right; the social environment around ruby makes TIMTOWTDI the standard practice. However, in my opinion, that applies more to having many options for the way to decompose a problem (such as loops, iterables, recursion, and so on) than aliases that all do the same thing. In this way, the Python approach to having "one and only one obvious way to do it" is actually a lie; in Python there is TIMTOWTDI as much as in Ruby. For example, there is filter(), there are list comprehensions with conditionals, and you can always use for loops. On the other hand, having `foo`, `bar`, and `baz`, all of which do the same thing identically except for their name, just feels like imposing cognitive overhead on the programmer for no good reason.
`#any?` without a block is slower than `#empty?`: Benchmark.measure { 1_000_000.times { [].any? } } =&gt; 0.490000 0.010000 0.500000 ( 0.494860) Benchmark.measure { 1_000_000.times { !([].empty?) } } =&gt; 0.300000 0.000000 0.300000 ( 0.303112) In my opinion, `empty?` is just as readable as `any?`, so I always use the former when I just need to check if the object has anything in it.
Nice! I never even tried it without, that's interesting. I appreciate the correction!
Doesn't do the same thing though: [false].any? =&gt; false !([false].empty?) =&gt; true 
Good point — so, in fact, `any?` is just plain incorrect.
Not really, it just checks for something else than `empty?` does. The author even mentions it in the article, though he could be clearer (emphasis mine): &gt; By the way, I like using the “no block” form of any? to ask if something “has any” **significant** element:
Is that a question for me or SkepticalMartin? I know enough to do web development, read source code, and do figure things out when I'm stuck. I don't think anyone can have 10/10 in any language.
It was sarcasm. I hate the (recent?) trend where people use arbitrary measurements denoting their 'expertise' in a skill set.
You point is valid, but there is nothing at stake here, except borrowing your attention for a minute or two.
My guess is that Ruby creates and discards arrays, and these methods are eager. So you would have to choose between chaining methods (more readability) or using reduce (better performance). As always, it's a tradeoff. It is just a guess, if someone has a real answer that'd be great. Meanwhile I did a [quick benchmark](http://pastebin.com/LbATyQXV) of 2 chained methods vs a single reduce and here is the result in Ruby 2.0.0-p247: ~$ ruby bench.rb user system total real chained methods: 1.860000 0.000000 1.860000 ( 1.862754) only reduce: 1.720000 0.000000 1.720000 ( 1.725537) We can see that using reduce is a bit faster (not that much though).
Ruby 2.0 and higher have [lazy enumeration](http://ruby-doc.org/core-2.0.0/Enumerator/Lazy.html). Edit: Obviously this doesn't make a difference in the given example since the first method called is #select.
It's also a [mathematical term](http://en.wikipedia.org/wiki/Injective_function).
You can do both, using Enumerable's #lazy
It's a shame it doesn't mention each_cons. That one can be very handy in problems where you would be looking ahead in a loop.
I have a lot of code that looks like this: for i in 1..lines.length-1 # process lines[i] end I often need to skip the first line because it is a header row. Sometimes I use for i in 0..lines.length-1 # process lines[i] end because the file doesn't have a header row, but there is a good chance a header will be added later. Is there a better way of doing this? I suppose I could write something like this: lines.each_with_index do |line, i| if i &gt; 0 # process line end end
Looks like a well-put-together gem. Worth adding a code-coverage shield (coveralls.io gets my vote)
you could do: lines.shift lines.each do |line| #process line end 
&gt; Javascript is better and more relevant Javascript is fashionable right now, that's all. It's actually no better than Ruby. And has some nasty warts.
rails is fine. it is just not the cool new thing it once was. all the cool kids want to use nodejs and every other new javascript thing.
Read this article and the comments http://www.reddit.com/r/rails/comments/1u633l/im_tired_by_rails_should_fundamentally_change/ In a nutshell: No, it is not.
Your friend is just a bandwagoner, the same type of person who would declare that flash killed HTML back in 2003
you should also read the comments on the article(not just the reddit one). i left a comment that points out Rails isn't that great when it's the only choice. http://piotrsarnacki.com/2014/01/01/i-am-tired-by-rails-should-fundamentally-change-crowd/#comment-1184059945
I dont get the "There should be other frameworks bit"... There are. Sinatra and the Sinatra based Padrino spring to mind.
they're not viable alternatives to replace what rails is. merb was, but now it doesn't exist. 
As a plain language, Ruby is fantastic - by which I mean its generally very easy to learn, read and do things in. The language ecosystem however is something different. As Rails is the single 'killer app' of Ruby, and most of the Ruby jobs out there are in Rails it has had a big effect on how Ruby is perceived. When it first arrived Rails was a huge success as it did lots of things no framework did before. It is still very good for certain kinds of uses however over time its warts have been exposed and also other web frameworks have been released (many on javascript) which are also very good and have taken away alot of Rails' lustre. Really it depends what you want to do with it - if its just for the programming language - Ruby is great (certainly much better than Javascript). If it is specifically because you want a web-framework, consider whether Rails is the right one for you.
Sounds like an almost impossible requirement "Do what rails does without being rails or doing too much" dev time wise.
great advice. as well as true words.
do what rails does well, and forget everything else. it didn't get everything wrong but what it did get wrong really sucks.
I could not agree more. There is always a newer cooler language on the horizon. Languages don't matter; they are simply tools in your toolbox. If you program for several years you'll end coding in many different ones. Ruby is beautiful language syntactically, which may make it easier to learn. 
I'd use a slice with a range lines[1..-1].each do |line| #line stuff end Substitute the first 1 for 0 if the header's not there. If you don't mind modifying the array the shift suggestion from karmacrash is interesting. lines.shift if header? # iterate on lines Drop (from Enumerable) is the non-destructive version of shift body = lines.drop(1) if header?
I don't think you're going to get an objective answer in this sub-reddit. We subscribe because we love it. I'm sure if you went to /r/javascript and phrased the question as, "Should I learn javascript or X?", you would be told to learn javascript. I enjoy working with both javascript and ruby; though, many of their common design patterns are very different. For what it's worth, I found ruby much easier to understand in the beginning. They don't call it "a programmer's best friend" for nothing.
Thanks. I've added coveralls to project. Thought it would be painless, unlikely 1.8.7 &amp; rubinius didn't like it well :( But finally I managed to fix it and code coverages will be attached from now on (also badge in repo!).
On the other hand, it's not that much easier and the [] syntax allows providing a Hash, which can also be quite useful.
Ruby has almost superseded Perl as a dynamic scripting language. That's saying a lot. And Perl is not going anywhere and neither is Ruby. Javascript is useful, but you can't write an entire application in javascript. Ruby on Rails uses javascript just as every other web framework does. Learn Ruby, then RoR, and you will pick up a bit of javascript as well.
I work at Shopify, we have a Rails and Javascript combo app. It works well really, The JS makes the client side stuff awesome, and ruby is great for backend stuff. I would argue that Rails, and Ruby, are fine as languages. They are easy to organize, verbose to read, have amazing syntax, and works well. I'm not as familiar with the MVC of the JS portion, but it is highly efficient and works well for front-end. To each their own though. Edit: Rails is a framework, not a language... ;)
They are, however, viable alternatives to write web applications in. I use Sinatra *exactly* because of how it does not "replace rails" - if it tried to do what Rails does, I wouldn't be interested in it. 
You should learn both. The more tools you have in your toolbox the better programmer you'll be. If you spend 6 months working with one technology, you'll have enough exposure to see where it's good and where other technologies are better. 
I find using drop et al. more readable than slices or shifting an array for this kind of stuff. Example: line.drop(1).each do |line| # go about your business end
Yes indeed. This is what more developers need to think. Languages are tools. Just get shit done. Developers who ship are more valuable than developers that sing the song of their favorite stack.
This has to be the most hilarious thing I've read all day. Your friend has no idea what he is talking about. The only downside I see to Ruby, is that when you say "Ruby", almost everyone immediately equates it to "Rails", which is not always the case.
So here are some things to consider. Ruby isn't really a very popular language, for whatever reason. It is generally overshadowed by the likes of python and javascript. As some have mentioned, this is probably due to the fact that rails is popular. It has created a weird situation ruby is generally only used by people developing rails, and because of the simplicity of rails in a lot of ways, it has lead to "rockstar" bro-grammer proclaiming themselves as experts. Sadly, the "rails" experts are (from my own personal experience) generally pretty inexperienced developers, and frankly, not that good. So you have that eco-system in place which has, IMO, done a fair bit of harm to the ruby community in general. On top of that, and this is mostly due to rubies non-popularity, ruby is a pretty slow language. Javascript, through the herculean efforts of mozilla and google, has become a pretty fast language. Even python now has super fast jits (PyPy), primarily because of the language popularity. Ruby has had a few attempts made, but they have mostly failed. Currently the most promising fast jit for Ruby is topaz. So those are the downsides to ruby, and IMO, some of the nastier ones. On the other hand, ruby is a very syntactically beautiful language. Pure ruby is a delight to program in and is pretty easy to write some compact and good looking code. It is a pretty well thought out language with few WTFs. Javascript, on the other hand, is a syntactically ugly language. I think it is more shell shock, but there seems to be a weird new revival surrounding javascript "It isn't an ugly language, you just don't understand it!". Javascript offers the programmer little help (for goodness sake, it doesn't really support modularity! Any that has been achieved has been done in the hackiest methods possible). There is always promise that "ECMAScript 6 will fix every problem!" or "Thats scheduled for ECMAScript 7!". But when you realize that ECMAScript 6 has been planned for nearly 10 years and MAY be released this year, it doesn't get your hopes up (And that is just the standard being released. It will be another 10 years before most consumers are using browsers that support it. For heavens sake, a huge portion of browsers today don't support ECMAScript 5). Javascript's biggest boon is that if you have dealt with web development in the slightest, you will have to have learned a little javascript. As a result, it is an old language with large exposure. That has lead to a number of javascript specific innovations (see V8 as an example). Given the choice, I would pick ruby over javascript any day. Heck, I would personally go for ruby over python any day as well. However, like all things programming related you have to choose the right tool for the job. I currently use Java at work for everything because our entire ecosystem is Java based.
Eh, when people compare js to ruby they are comparing node js to ruby. Node JS is pretty good, relatively speedy and has some nice initial library support, but the community is still quite new compared to ruby. If you want a massive suite of libraries, python or ruby fit the bill wonderfully. If you want to javascript until your eyes bleed, node has something for you. 
unrelated to thread, but just wanted to say you guys are amazing. Shopify is one of the coolest rails products I've seen. 
Are you not aware of Node? I'm a huge fan of Ruby, but you can accomplish mostly anything (and more) you'd do in Ruby with Node. It has support for C extensions as well, so there's that.
The primary problem with server-side JavaScript frameworks is... you have to write code in JavaScript. The only reason I ever write in JavaScript is on the client-side where it is unavoidable. Everywhere else, there is no reason to write in JavaScript. The only reason I can think anyone would use JavaScript on the server-side is Stockholm syndrome: they've been so badly abused by it on the client-side, they've come to love it in the same way kidnapping victims come to love their captors.
Thanks! We try to be awesome :D
I'd say its substantiality worse in many ways. While I do like nodejs for what it is, the javascript-or-death crowd are just hilarious.
Twitter's Javascript Implementation was not based on using NodeJS to render pages, that blog actually reflects on how having the client render everything was the poor choice.
I would echo the sentiments of all other commenters. But, I'd be interested to hear what they say on /r/nodejs edit: I just wanted to add that I think ruby is easier to learn than JS.
It's better in that it is event driven, faster, and has a smaller memory footprint. But other than that, it's very similar.
maybe it wasn't clear what I meant by viable. sinatra and to a lesser extent padrino don't let you prototype as quickly as you could with rails. there's a lot of __alternatives__(sinatra, padrino, webmachine-ruby, jellyfish, ramaze, …) but none have been able to stand on the same playing field as rails. sinatra &amp; others don't want to - which is great. a viable alternative to rails is something i'd call a feather. a light stack that can extend itself to something capable of building github.com or some other commercial website. it would also need to support quick prototyping. that's what would be a viable alternative or at least a step in the right direction. i have nothing but love for sinatra and friends. they're just not capable of attracting the same audience and providing the same benefit as rails with ease. 
So Ruby is now the new Java? 
what a surprise that the comment without substance is the top comment on /r/ruby. EDIT: lawl @ downvotes. before you upvote something maybe you should consider reading the paragraphs of text other people write before upvoting a single-sentence sound bite that is full of assumptions and adds nothing useful to any conversation (outside reddit, of course).
I agree on this book. It's not good for learning languages, but it does give you a good overview on the strengths and weaknesses of the different types of languages. http://pragprog.com/book/btlang/seven-languages-in-seven-weeks
With the best will in the world, as stated above, your buddy's talking shite. Ruby is a fine language. It's got plenty to learn. If you learn Ruby, you'll do yourself no harm at all. You know what else is a fine language? Most of the ones you've heard of. They are all created by pretty clever people, and do various things quite well. So, do yourself a favour, and learn it well. Ignore your buddy, and keep on learning other stuff, regardless of trends. I remember thinking how silly it was to learn Lisp... and then oops, look what's back in fashion. I started learning BASIC, which is reasonably rubbish, but even BASIC allowed me to learn Logo slightly easier. And then C, Java, and so on. It's never a problem to know another language. Rails is just a framework, ("just"), but it is. Again it's worth knowing, but it's nothing more than a load of packaged up stuff waiting to be used. 
While Rails is a framework, it does have its own DSL (or many?) for describing how an application functions. Calling it a language isn't that far off.
&gt; that blog actually reflects on how having the client render everything was the poor choice which was my point :) 
Then you're missing that JS has changed since 2008. NodeJS allows rendering templates before they are sent to the client - to the same extent that Ruby does.
it look good at a glance, and you can probably keep the old behavior on top of: &gt;&gt; class OpenStruct &gt;&gt; include OpenStruct::Behavior &gt;&gt; end ` it would be cool to not impede on the superclass(class Foo &lt; OpenStruct) but keeping the OpenStruct as internal state that can be delegated to is another way to work around that. that's not to say it's not cool to have it available as a mixin :)
I'm not mad at all. I'm laughing. here's an upvote, bro.
Well it was implemented so that in astruct: class AltStruct include AltStruct::Behavior end which means you can still do both.
indeed.
Yeah exactly. I especially liked the portion on Io because it forced me into a true prototype mindset for the first time. It's made me a better JS programmer.
You can write event driven ruby, too.
[XForms](http://www.w3.org/MarkUp/Forms/) is the standard, and there are [many implementations](http://www.w3.org/community/xformsusers/wiki/XForms_Implementations).
I also downvoted myself, to help keep the idiocracy alive! (got to help the persistent little guy who went through the effort of down-voting every post i made on this thread - thanks buddy!!). I doubt he read any of it, of course! ruby programmers are smart! too smart to engage in a meaningful conversation to any of the __real__ issues I (and others) brought up.
&gt; also when most people are talking about JavaScript they mean it on the fronted, otherwise they normally refer to it as NodeJS for server JS. I think that when people are looking to 'learn to code' they do not make this distinction. I could be wrong.
The first day a language begins becoming outdated is the day it becomes stable and popular. Just add I liked it before it was cool/popular. Ruby on Rails no longer shiny and new enough to be cool. Too young to be ironic.
brakeman is pretty helpful, both as an audit tool and as a part of your CI infrastructure - http://brakemanscanner.org/
There are tools that can help you get in the right direction but security is such a huge topic. I've been in your position before and it's scary to know you have to be "secure" but knowing where to start can be a pretty daunting task. I would at least take a look at the Brakeman project. It does some vulnerability scans in your code and at least points out some hot spots (http://brakemanscanner.org/). It's also worth mentioning that you should typically not re-invent the wheel when it comes to some commonly solved problems. Rolling out your own authentication library may be a fun weekend project but I would be hesitant to throw that into a production setting. Many libraries exist for those types of situations and the people working on them typically understand the problem more. Security also needs to be considered at different levels. Are you hosting your own severs or are you using something like Heroku? Running your own server configuration can come with a huge stack of concerns that skilled system admins could answer far better than I ever could. But with all that being said you should keep your paranoia in check. It is VERY smart to think of your end users and your employer when it comes to security. You just have to avoid the pitfall of trying to fix everything to be 100% secure (not possible). You still have to move forward. Learn as much as you can and continue to move forward.
Thanks, I did not know about this website. :) I didn't know about brakeman. Re CI (continuous integration, right?) what would you recommend? I was reading the Jenkins docu and it seems over my head now. Anything I should know about CI?
Wow, thanks! I agree with not re-inventing the wheel. We are using Devise and Bcrypt. Do you have any other suggested gems for security purposes? I feel like I take a longer amount than necessary when I'm thinking of gems to include. We are running on a paid Heroku thingie (the other dev did it, he did the back-end first and we're now improving it). Honestly most everything has been over my head, we're both devs who are in school but with no experience actually deploying, most of what we've done are just side projects, so any other advice is valuable. :)
LULZ wasn't me, but have another downvote on this one too, bro.
Ha, that header image is awesome. Here's to MiniTest taking over the world!
I use CanCan for handling resource authorization. It's nice because if you initially set the permissions up correctly for the role and don't override the authorization, it's hard to allow the wrong users to see the wrong things. https://github.com/ryanb/cancan However, I have noticed lately that CanCan is not being updated very often; some people are recommending a migration to pundit (http://blog.carbonfive.com/2013/10/21/migrating-to-pundit-from-cancan/), although it's been a couple months since pundit's been updated either.
Coming from PHP, Ruby was enlightening. Rails was even more so (heck, even SASS was a religious moment). Ruby is a nice language (nicer than JS), and the tools incorporated into Rails are fantastic (especially if Rails is the first one exposing you to them). Then I tried to make a GUI on my own. Rails is designed around your traditional frontend/backend architecture. Great for a lot of situations, but not so much for making an interactive UI like you would in Java, C#, name-a-framework. Here JS &amp; frameworks really shine, and have shown me there is a lot you can do on the frontend (btw, AngularJS is awesome). TL;DR: If you're looking to learn new things, RoR is extremely relevant. If you're looking to build a new webapp *today*, take a look into JS.
CI can go from very simple to very complicated, but at its heart it means: * Check out my code * Run my tests Is this an open source project? Hosted on github? Because if so, you can use https://travis-ci.org/ which integrates very well with github + heroku
We are on Bitbucket.
ruby wasn't hot technology in 1995 either :) i don't disagree with anything you said, however i think the point is missed that there is no one chosen language. i don't know why people bury themselves with one language. I did it for a while and it really has no gain at all. if you can learn ruby and javascript you'll be better off than knowing only ruby or only javascript, especially when you want to "build some stuff". embrace diversity and you'll be better off.
Re the Ajax APIs, is it the same as the ones with the respond_to html? When testing it. Do I get something like POSTman and send requests and see if user is authorized? I also have this thing that I just have to test all of the pertinennt routes in routes.rb, is that right or there's an easier/more complete way to do it?
With devise/bcrypt, you have authentication covered. However, as others already pointed out, check your authorization code as well, and ensure each user is only allowed to access data he actually is supposed to.
I would also comb through the rails cast that have been tagged with security. ( http://railscasts.com/?tag_id=5 ) At least it can give you some ideas on the mindset of where you can look and what to have in the back of your mind while writing some code.
Gotcha, you said you're using heroku, take a look at: https://addons.heroku.com/codeship
Thanks for the thought-out answer. Since the two of us devs are both in different schools and have separate schedules we are not able to talk much about technical stuff. So comments like yours are very appreciated. 100% I agree on features and UX. Re HTTPS our site is https://oursite.com. Is that what that means? No credit cards yet. Re password yup password is encrypted via Bcrypt/Devise gem. Re the captcha, it was a relic from when we started with Michael Hartl's Rails tutorial. You have a good point on the bots thing. We don't have a comment board to spam yet anyway. I'm really not sure what we could fear for spam, too. Can I ask a question about Ajax? I expose the ajax calls in the javascript of the app. Is taht okay? We're on JQuery still so far, but we're keeping an eye on moving to Angular if we need to in the future.
I really have to save Railscasts on my phone for when I go out and commute. Thanks man.
C'mon.. I mean, Ruby could be outdated, sure; but it very much depends how you look at it. For instance, object-oriented seems to be a prog-lang paradigm that less people believe in. Many look towards functional as a possibly "better" paradigm. In this case Haskell may be more "hot" the Ruby. Ruby and Rails are too bloated one may find Go a good alternative. It compiles to native, and therefor very close to the metal. Frameworks are still much in development, so relatively small. But then JavaScript?! I'm sorry, that is not a typical language considered "better" then Ruby, except for the fact that it runs in most browsers (which may-or-may-not make it more relevant). It's a horribly inconsistent, and has many rough edges. It only provides 1 concurrency model, where Ruby (and other general purpose languages) provide many concurrency models, where you can choose the best tool for the job. I think Ruby is a great language, I've used it for fun-and-profit the last 8 years. Though I must admit I'm regularly flirting with Haskell. My advice: learn Ruby and Rails (the web framework with the biggest community), they are super powerful tools, have a good community and focus on "relevant" topics (e.g.: API design, clean code, tests, modularity, re-use, rapid app dev't). Good luck and enjoy! (sometimes I regret knowing how to program already, as learning it was so much fun) 
Checking it out. What's the most overlooked or "underrated" vulnerability in your experience?
yes, https is http over ssl. SSL is the encryption layer. This is important if you fear man in the middle attacks or your users are on unencrypted networks. If you don't have it, it's easy for an attacker to steal a user's session cookie. Facebook was vulnarable to an attack like this until 2010 when they introduced HTTPS for everyone. Google Firesheep, the Firefox plugin. Ajax calls are like every other HTTP request. It shouldn't be possible to delete or change another user's data and private data should be only readable for those participating. Showing HTTP endpoints is no problem.Minification and uglification are more about network performance and securing intelectual property than about security. two more tips I just remembered: - If you display user generated content, make sure to sanitize the input so nobody can deface your site with html. - If you call external programs (e.g, your site has avatars and you use imagemagick) be extra careful and update your Ruby bindings religiously. 
Rails does most things right out of the box. I'd venture that most problems probably surround privilege escalation and some platform gotchas - like using to_sym on user input data. Privilege escalation concerns stuff like the hypothetical following controller code, @user = User.find(params[:user_id]) @group = Group.find(params[:group_id]) if @group == Group::Admin # bad news bears The other issue comes from the code ecosystem. It's really hard to make everyone update their Gemfiles if a vuln was found in upstream code; it was with that in mind that we put together [rubysec](http://rubysec.com/), but we're still figuring out what we can do. We perform security audits as part of our consulting; broadly, people follow the OWASP Top Ten https://www.owasp.org/index.php/Top_10_2013-Top_10 for figuring out what they should most be paying attention to. 
Web App Security dude here. I'd start by checking out the OWASP top 10 (https://www.owasp.org/index.php/Top_10_2013-Top_10). Once you get your head around the main vulnerability classes that are pretty framework/language agnostic, you can check out more rails-specific stuff, like this cheat sheet (https://www.owasp.org/index.php/Ruby_on_Rails_Cheatsheet). There's a lot of good practical advice in the comments on where to start since there's an established code base. In addition to that, I'd say take a step back and look at the architecture. Think about authentication, authorization, logging, and crypto between the various components. In addition, you might think about incorporating static (ex. brakeman, klockwork, hp fortify, etc.) and dynamic analysis (w3af, burp, IBM appscan, hp webinspect, etc) into you development processes. Also, maybe having a good security shop perform a pen test might be a good idea if you want to quickly identify a hit list of high risk issues. I realize that much of the above is probably way outside of your responsibilities and may be cost prohibitive in some cases, but I figured it might be helpful anyway. 
I would definitely recommend reading http://guides.rubyonrails.org/security.html
Try out CodeClimate, it does some of the groundwork for you and also looks for code smells. It doesn't replace the real work you have to do if you're serious about security but it's a good way to get the bases covered. 
&gt; sinatra and to a lesser extent padrino don't let you prototype as quickly as you could with rails I couldn't agree less. I prefer Sinatra *because* it lets me prototype more rapidly. All the cruft that Rails drags with it gets in the way of doing things the way I want them. Rails works for people that are scared of having things look like there's not much there. Then they spend just as long replacing the scaffolding and working around problems caused by the sheer complexity of what Rails pulls in instead of picking the components they need. My prototypes will be simpler, but they are focused on what is actually necessary. It's a very different philosophy to Rails. &gt; a viable alternative to rails is something i'd call a feather To me, Sinatra + a smattering of gems depending on what ORM etc. you prefer, fits that description perfectly. Then again, my first major (1m+ users) web application was written in C++ (many, many years ago), so I'm used to getting my hands in the plumbing. &gt; they're just not capable of attracting the same audience and providing the same benefit as rails with ease. They'll never attract the same audience, because an empty canvas terrifies people. As for benefits, the major benefit of Sinatra is the empty canvas as opposed to starting with a fully painted naturalist painting and then trying to turn it into an impressionist painting - to me, the latter would make it incredibly hard to break free from what is imposed on you by what is already there. 
&gt;Not aware of many people still doing NodeJS on server who haven't switched over to Go Really? eBay, Groupon, LinkedIn...
I'm interested. What in your opinion does rails get wrong?
There gems like cancan out there, but in the end, you still need to define who is allowed to access what. As this is completely application dependent, it is a manual task, yes. You can write tests for it, however.
*yawn*
I recently bought an Android device. I'm excited to play with Ruboto!
TLDR: Your Javascript skills will be useful whichever platform you choose, so Node.js/meteor would be sane choices to get started. However ruby is still popular. Read the job boards. If you're learning to code ruby is still a transferable skill and will still be valuable for a number of years. It may well be at its peak and detractors may be right that for example Rails is just massively bloated and overkill for a lot of scenarios, it all depends on the size and complexity of what you want to build though too. Absolutely learn JavaScript, you're still going to use it in whatever language or platform you develop. It's ubiquitous because it's in every browser/handheld device and every backend framework PHP/Rails/Sinatra etc will also need to deal with JavaScript in some way. Whether or not people like the warts of JavaScript is irrelevant because it's become the defacto language of the web. If I were learning to code right now, I'd probably look at Node.js and meteor. Meteor has it's problems and the node community may well be a bit bandwagon-y whereas Rails and the ruby community may have matured. If you want to build cool things quickly and get the kind of kick out of programming that you might have got during the early Rails days, then meteor (which is js BTW) may be a nice choice. You can also browse job boards and get a feel for expected level of experience, expected salaries and number of opportunities. Checkout itjobswatch to get an idea. Personally, I'm a mostly ruby dev and riding the crest of having a number of years experience, but for a beginner coming into the market, ruby/rails may not be the absolute most profitable/fun/coolest thing to spend your time on. Also remember that in 5-10 years time you'll be experienced in a few languages and tools and may be thinking about how to protect your interests from the cool thing out there, so you may get detractors who just eschew new technologies out of self-preservation/lack of knowledge/pride, whilst at the same time you may meet people who based on experience eschew new technologies because they don't want to waste their time on something that is undocumented, unstable, unscalable and ends up costing far more money to use/work with than the theoretical case for the most productive use case.
we disagree at a fundamental level then. I don't believe sinatra is a viable alternative to rails. (and nothing about me likes rails)
The thing is that most of time it's not an easy thing to extract it later. The main rationale behind this is that software (requirements) will change, thus the more permissive to that change your code is, the better. If you could perfectly predict how the application should end up like, you could add all the coupling you want, no harm done, because it would never change. That is obviously unfeasible.
I agree with 90% of what you said btw. i just don't see a small business turning to sinatra, not that it couldn't be done..
I'm all for allowing flexibility and being permissive. I'm just saying that you should't complicate things and completely separate yourself from Rails (to an extent) just to have it. Even then a lot of people take this idea, try to do it and end up making ridiculous abstractions that they *think* are more flexible and clean code when they end up being very inflexible. Then you're decoupled from Rails AND have code that you have to refactor each time you have a requirement change. In the end it's always down to the developer and they have to make sane decisions with what they have in front of them.
Well, I've done Sinatra apps for small businesses, including one of my own startups. 
(throwaway for personal reasons). There's nothing *wrong* with it. But given how hiring software engineers works these days, it's not surprising that no actual engineers are applying. The market is too good, the job listing market is too disparate (I've never heard of authenticjobs.com before—though that could just be me), and there's nothing that makes this description stand out from the thousands exactly like it. After getting some experience (even two years) and making some connections on LinkedIn, I can't imagine anyone really needs to go looking at job boards in this industry. I get messages from recruiters every day. Literally every day someone is trying to get me a job. And I am not looking. If I *were* looking, the first thing I'd do is ask my friends around the industry what they know about. About the last thing I'd do is go searching through functionally identical job postings at some essentially random job posting site. For what it's worth, my advice: Go to meetups. Reach out to people you've worked with before. Talk to a recruiter for help. Save your $99 next time.
Thanks. Appreciate the feedback. 
He has a point, but in general, some photoshop knowledge (or equivalent) can be very beneficial, so you don't have to go to your designer every time you need to adjust a graphic by 2 px, create a hover version of an icon or such little things.
I imagine that you placed the job description on other recruitment sites, so the only advice I can give is to try to talk more about your company culture and what makes you stand out above the others. You seem to do this with the videos on the jobs section of your site, does the job board you linked to not allow you to place URLs to these videos? PS: Your company's site is a bit frustrating to use. That signup modal has no close button from what I could tell and it turns out that it disables all links on the page itself. This means that when I got rid of it through Chrome's Web Inspector, I couldn't even click on the URL to your site's jobs page! That's quite certain to discourage more than a few engineers trying to find out more about your company only for them to come across a site that immediately wants the visitor's email address and refuses to let them browse otherwise (it certainly leaves a bad taste in my mouth!).
Basically you are looking for a CS Major with strong front-end skills so is everybody else they are called unicorns. Also can you pass the Joel Test if so state it.
Chingu still works, but has been abandoned by its author and is now unsupported.
Any competent Rails developer should be able to lay down some Coffeescript, jQuery or pick up some Javascript MVP framework du jour like Backbone pretty quickly. I don't see with the posting that way
My take? It's boring. Nothing you list there is any different from what any other company lists. Blah blah testing, blah blah git, blah blah pairing, blah blah stocked fridge, blah blah onsite in SF. Yes, of course, these are standard practices. I'd say they're so standard that most of the ad, to me, read like noise. Where's your competitive advantages over other companies? Do you have big engineering challenges to face (migrating your Rails app from Rails 2.3 to Rails 4? Establishing better front end practices? Blowing apart your big Rails app to be more SOA like? Interacting with a "web realtime" service that provides Bog knows what?)? What neat things have your engineers done in the last month or so? For a good example of this, check out [this help wanted ad at a consultancy I used to work at](http://www.greenriver.com/team/join-us/). That reads a lot less like noise to me: there's no standard almost assumed stuff. (I can see the status of or lack of onsite fridge when I get to the in-person interview round) Maybe the challenges are nothing special, but what about the personality of your company? While not everyone likes to have beers with their colleagues on Fridays, maybe there's some competitive Wii Sports play during lunchtimes, or whatever. Or some developer has a MAME cabinet in the office or you've got a LeapMotion hooked up to change the office music by sticking up your hand, or a pretty tricked out hubot. I'm sure there's something that gives your company personality. Also? That big full screen signup circle on your site that doesn't let me do anything - including accessing the "Our Team" section of your website? That's really annoying. No, I don't want to enter my email address to check out your company information, and there's at least 3 different bugs with it. I bet that's not helping your developer conversion rate at all.
some of my reasoning is explained here: http://piotrsarnacki.com/2014/01/01/i-am-tired-by-rails-should-fundamentally-change-crowd/#comment-1184059945
Although you hardly need the power of Photoshop for that. 
i am also highly interested in the answer to this question. I started programming by diving into c++ and c but found it extremely difficult, i think mostly because of how my resources approached the subjects. Learning Ruby has allowed me to understand some of the basics of programming so that when I've gone on to other 'more difficult' languages I have a far better understanding than when I began. Python is what I'd like to learn next so if i find some good python resources i will return to this thread or PM you.
Great advice, thanks!
I'm actually in the hunt for a job right now. I even came across your job posting before this was posted so I'm contributing to your views and not applying. Why? Because I'm not going to relocate to SF. I think you're probably experiencing a relatively normal amount of "noise".
&gt; Setting realistic developer time estimates &gt; Thoroughly reviewing peer’s code &gt; teaching other engineers &gt; Wanting to improve our processes and engineering culture Does not match &gt; 2+ years The description feels like you want to hire a senior engineer and pay him/her a junior salary. 
serious question: would you actually disqualify someone without a cs degree? 
Sometimes you need the power of photoshop to work with PSD files. Edit: re-read this and it sounds inflammatory... so I'll clarify: I'm an experienced Photoshop user. I have Photoshop on my system. If, in my webdev work, I need to update a graphic file, Photoshop is my software of choice. And, graphic files from agencies often come in final asset form and as PSD files, as Photoshop is the industry standard. It may be possible that other tools exist that allow for the opening and editing of PSD files. Still, I would always reach for photoshop as it guarantees proper handling of these files.
You can write the next battlefield game in MIPS, doesn't mean that other languages aren't better-suited to the task.
"Strong front-end skills" means a lot more than slapping down an animation with jquery. It means a level of professionalism and competency not just in JS but also understanding the semantics behind html5 and a very strong grasp of css. It is a lot of knowledge that is mostly discrete from back-end heavy rails work.
Lots of places do, self-taught programmers are a risky hire. So are lots of programmers with CS degrees, but companies have to have a set of qualifications to cut applicants with and this is a pretty common one.
I am pointing out that just because you *can* write event-driven ruby does not mean ruby is necessarily the "best choice" language for such a task. It may be the best for you, and you may be able to make a very fine product indeed in such a fashion. But ruby does not natively support event-driven programming and you are still using a library to do it, where other languages have native support baked in.
I don't think op is being smug merely because he loves ruby and books he's ready about ruby. The python community is very, very different from the ruby community, and the languages themselves are also very different. It can be overwhelming for a rubyist to get into the python community.
You're awesome for mentioning padrino. Love the mvc and choice that comes with it.
Thanks for the suggestions and feedback! In regards to "deep dives", the two most recommended books I've gotten on Python (which led me to post this question) was Dive into Python and Learning Python. Both of which are organized more like the Ruby Pickaxe book than something like "Eloquent Ruby" or "Confident Ruby", which focus less on discrete components (strings, hashes, standard library components) and more on patterns for building up functionality or refactoring. Because I am entering an existing codebase, there are a lot of things that aren't exemplary (like any codebase), so I'm trying to find resources to help me be more pythonic---so not just know the language features but know how to apply them. I don't mean to sound smug though I understand how you're reading it. When I came to Ruby it and the community opened my eyes---after years of writing PHP, Python, and JS---to how much of a mediocre programmer I am and encouraged me to be more aware of the code I am writing. Maybe I just lucked out with the angle I came at Ruby from, but I've been really impressed by how close to the surface things like TDD and design patterns and collaborative coding seem to be. I can completely accept that I suck at finding those same resources in other language communities, but that's why I'm asking the question here. And as a random person on the Internet, you have provided some good looking resources that my colleagues have not told me about. Anyways, thanks again!
It's great to be in an industry where self education is super cheap: $120ish bucks an you can get *The Rails View* and 2-3 books about CSS/JS/HTML 5, all from the same store. There's no excuse not to know these skills.
Try adding a link to your site in the job listing. I've looked at the ad twice and haven't checked out your site yet. Im so lazy when i browse the web on my phone, and can't be bothered to Google your company. Maybe I'll remember to check you out after I get home.... Also, there's a writing tip that says show, don't tell. I feel like you've told me what you're looking for in an engineer, but haven't shown me why I should be interested in your company rather than the hundreds of others in SOMA. I've never heard of e-consignment before reading your ad, and have zero sense of excitement about the opportunity in your space after reading that ad. 
Programmers with a cs degree are a risky hire. Just because they have a degree does not mean they can solve problems effectively in the real world which has time constraints and requires trade-offs. 
The ad asks for a minimum of 2 years experience. How well-rounded do you expect people to be after 2 years on the job? Especially since there is more to front-end than just understanding CSS/JS/HTML5 (because the DOM is a fiery hellscape that takes a lot of practice to get good at manipulating without something breaking on an important browser). You can get a great Rails dev with 2+ years experience. You can get a great front-ender with 2+ years experience. Sometimes, you can even get both in a single person. But a great front-ender with a Rails book, or a great Rails dev with 2-3 frontend books, does not a strong (emphasis here: "strong") full-stack dev make. Or, to cite Peter Norvig: [how to learn programming in 10 years](http://norvig.com/21-days.html). 
This. Having a CS degree does not make you a better programmer than someone self-taught. Why the requirement for a CS degree? You're cutting out a huge number of people who didn't attend college, attended but dropped out, or graduated with a non-CS degree but nonetheless are excellent engineers.
That's what I read. Also they want a back-end engineer with strong front-end skills. Should the applicant also be able to write assembly code and troubleshoot printers?
You're welcome. Actually, sorry for being rude. I read your question along the lines of "I'm asking here since it seems pytonistas are all concerned about data types and have no heart - while you know what cool, soulful programmers need *wink wink*". I got it wrong. Anyway, I just read [this post from a guy with plenty of experience in both languages](http://blog.lerner.co.il/ruby-and-python-and-felix-and-oscar/). It's quite a nice comparison and, in my opinion, a great synthetic explanation of the respective mindsets. I figured you'd find it interesting in your situation.
"Computer science degree" 2001 called it wants its job market back
Totally agree, it's boring. Developers are super hard to hire right now. My experience has been that there are 3 ways you can attract people to a small company that doesn't have tons of name recognition: * You have a personal relationship with people that you can convince to come work with YOU * You are doing something interesting from a business or technology point of view * You can pay You are aiming for the 2nd or 3rd and that job description doesn't do either. You obscure the salary and the day to day work sounds like it could have been from any of a 100 other companies your size. 
You weren't rude. Your response made me reflect on what I was actually asking and it does seem somewhat unclear and overgushing. And that link is awesome (and I dropped the blog in my RSS reader). In terms of my naiveté about the python community, a lot of it is just not knowing where to look. So your reply is very much appreciated.
I have a CS degree and a [GitHub](https://github.com/postmodern) profile. Having a CS degree (from an [ACM](http://www.acm.org/) accredited university) just stats you have basic knowledge of Data Structures, CS Theory, Databases, OS Architecture, Compiler/Language Design and Complexity/Optimization.
&gt; For your information, Ruby also has a for statement (nobody uses it though). As someone very new to Ruby, why is this true? Seems like a very bold statement coming from using languages that use for loops exclusively.
Agreed. You probably wont find a strong back-end that is also great at front-end. He might be good....but I wouldn't call it strong. Thats why there are front-end developers. Unicorns are usually very good at a lot of things but missing a few elements to each of the skills. (generally ones that are rarely used). Source: Im a very rare Unicorn
1. "Computer Science degree" Let's face it you are hiring a Rails developer, not a Systems Architect. CS grads who live near SF are already gainfully employed or moved after graduating. 2. You are not hiring remote. 3. The title says "Full Stack" but you keep mentioning the frontend. 4. You don't share enough about your Company, the work environment, fellow employees or customers. Every SF startup is "revolutionizing $industry", sell the reader on why you are unique.
I would actually recommend that you do some reading of the standard library documentation. The documentation cultures in Ruby and Python are *very* different; there aren't as many books on Python as Ruby, but every major project has copious documentation often written in a narrative style. Even the PEPs are readable. Some things to look at: * [The PEP Index](http://www.python.org/dev/peps/) * [PEP 8 (Style Guide)](http://www.python.org/dev/peps/pep-0008/) * [PEP 20 (Zen of Python)](http://www.python.org/dev/peps/pep-0020/) * [Design and Philosophy FAQ](http://docs.python.org/2/faq/design.html) This cultural difference means that your best and most reliable resource is often actually the documentation itself; the narrative style means that there will often be explanations of *why*, rather, than simply *how*, as you might find in Java documentation. (See, for example, Pyramid's [Defending Pyramid's Design](http://docs.pylonsproject.org/projects/pyramid/en/1.3-branch/designdefense.html) essay.)
Agreed, quite a few Ruby devs don't have CS degrees, the best Ruby dev I know has a Bachelors of Fine Arts.
Someone who has developed for twelve years but doesn't have as degree is a risky hire?
Python rulez!! —[The Tunnel Snakes](http://www.tunnelsnakes.com/)
The site: Is using a 12 month old version of jQuery Has div with id of: nav_left Has div with class of: polka-dots The CSS has hundreds of !important s The CSS files are huge Has several YSlow F grades: * Use a Content Delivery Network (CDN) * Reduce DNS lookups, Is using four domains * Do not scale Images in HTML Style attribute in many HTML elements The UI differs between Chrome and Firefox, Chrome presents a modal popup, fuck that. I didn't look at the js, but I'm guessing jshint would find some big problems. I'd hate to work at a place where I'd be fighting to explain why these are bad practices. 
Looks super cool. Translations however won't have such large impact for average rails app though. But I am going see how something like this affects my Rails application.
&gt;Setting realistic developer time estimates Smells like they have an issue with this, their site code feels rushed.
Those characteristics point to either *really* needing a "full stack Rails developer", or they really don't actually need a "full stack Rails developer" as much as they think they do. Interesting!
I've used the Sequel ORM for a similar task and had success (had to interface with a legacy MS-SQL database and I like Sequel's API much more than AR). I was able to get around some unnecessary verbosity with some method_missing magic. I'll sleep on this a bit and try and revisit this post tomorrow! 
This seems like a good use case for a repository-type pattern. The essential idea is that your data management is split into two components: 1. Service objects that query data and modify data in the database—the repositories 2. Entities that represent data in the database This pattern might help you out by wrapping a database that has complex behaviors behind an interface that you control. The repository would be responsible for constructing instances of your entities, so the logic for constructing entity instances is in one place, addressing your concern about changes to the models. For testing purposes, you might find it is convenient to also build "fake" versions of your repositories, which satisfy the same interface but internally store data in memory. Using fakes like this can be a less verbose/fragile alternative to mocking in some instances. As a design tip, try to avoid naming classes after the pattern you're using. For example, if you will employ the repository pattern, avoid "UserRepository" if a better domain term is available. Remember, repositories are services, so a repository of users would provide methods to look up users by email/ID or secondary indices, and perform data-mutating methods (perhaps by interfacing with the stored procedures). When naming a repository class, think of the services that it provides to your application. Lastly, I prefer to keep entities immutable, and relying on the repository/service object to make changes, returning updated instances. This can pay dividends in concurrent scenarios, but I have also found it leads to well architected applications.
Change the "CS Degree" part to "X years of relevant experience". A lot of good programmers don't necessarily have a computer science degree, nor is one really required for the stuff you guys do.
Maybe the OP should read *The Mythical Man Month*
This isn't tied to ActiveRecord. The data comes back from a database wrapper. The issue is trying to find an elegant solution to map the database column names to the model attribute names which can vary depending on the stored procedure called.
Thank you for you reply. The database is already wrapped. The problem is with the inconsistent column names on the data returned. I also considered some type of mapper factory but the dependency on which mapper to use would have to be inverted, tying the calling code to which stored procedure is called which also will cause problems later on.
Sounds like the database has a very thin wrapping. What I described could be built on top of your existing wrapping.
As Ruby developers are used to iterate through collection methods with *map* etc, it also seems natural to use a collection method for side effect iteration, that is, *each*, rather than *for*. It's the "Ruby way". Also, after browsing the code of private and famous open source projects, I've never seen anyone use for.
You could automagically set the instance variables depending on the returned column names. o = self.class.new # or another class, if you do this in another object result_hash.each_pair do |k,v| o.instance_variable_set "@#{k}", v end return o
Wow, reading back over this, I have no idea what I was thinking last night. Sorry! No more late night reddit posting for me. At least not on a programming subreddit. 
To reduce some of the duplication in the get* class methods, only change the "exception" fields: For .get map = {:user_name =&gt; :username, :fname =&gt; first_name] map.each do |result_field, model_field| results[model_field] = results[result_field] results.delete(result_field) end Each get* would have their own map for that store procedures field names and how they map to the model field names. This would allow for a generic mapping class and you would just need to change the results fields that are different from the model's field. The mapping class would not be part of any hierarchy. It's what some people would call a service object. This would only make sense if there are a large amount of fields that don't change and a smaller amount of "exception" fields which seems to be true in your case.
I don't think we have enough information about the situation. For instance, your say that that column names have inconsistent names, but there must be a reason you aren't just standardizing the names in your attributes. Why not? Are you attempting to provide a middle, translation layer between the DB and some consumers of the data? If so, who are the users of that middle layer? Or are you perhaps trying to abstract things to the point where you're essentially writing a new (but database-specific) ORM?
Using `keys` is *very* bad for performance -- it is O(N) for *all* keys. I realize that the number of keys used in this example would be extremely limited, but it's generally best practice to avoid using the `keys` command *ever*.
And Redis is single threaded, so slow commands will block all other operations.
I would love to see what exactly you consider "strong front-end skills", and then I'd like to know how many hours you think it takes to attain the level of skill (across a wide variety of different subjects) necessary to make something similar to your example, without simply splicing HTML/CSS/JS written by other people. A quick look at the color scheme and typography that you've chosen for [your Tumblr](http://rwilcox.tumblr.com/post/72620660832/full-stack-rails-developer-resources) (or, hell, the fact that you are even using Tumblr for your CMS) lead me to believe that you have absolutely no idea what you are talking about when it comes to front-end expertise. 
The crux of the problem isn't the db procedures, it's that it's not properly normalized. Your first choice to fix this is to fix those procedures, but if that's not possible, your next best is to normalize those fields in ruby. Keeping it out of the constructor would be wise, so my next choice would be a helper method. Something like this (untested): NORMALIZATIONS = {:last_name =&gt; [:lname, :lastname], :first_name =&gt; [:fname, :firstname], :username =&gt; [:user_name, :username], :id =&gt; [:user_id, :id]}.freeze def self.normalized(params) NORMALIZATIONS.reduce({}) do |m, i| key, val = i param_key = val.detect {|v| params.has_key?(v) } m[key] = params[param_key] m end end So you can keep the initializer clean and you would just call: new normalized results
This is more of what I was looking for. Thank you! Yes, I do not have the luxury of changing the procedures, otherwise it would just be a matter of normalizing. 
This is what I ended up coming up with earlier and I think it might be the best. I created a generic mapper class that takes in the hash and a mapping of which column maps to which attribute and then transforms it calling a simple constructor [here](https://gist.github.com/proggybs/734e22a5bcd915376c3a) is a gist better illustrating this.
thank you this was a very useful explanation
GPG is by far the easiest general-purpose crypto software I've seen. What's the alternative? X509? Have you ever even used that and not want to pull your hair out because everything is so confusing and documentation almost nonexistent? I don't think this is a question of whether the crypto software is friendly. Git's interface is extremely complicated but it got popular anyway because people cared to learn it. People don't care about crypto.
Um, you have an update where you changed something headius suggested, which completely changed your results -- but you don't tell us what you actually changed! Please give details!
People don't want easy to use crypto software, they want unobtrusive crypto software. By itself neither GPG nor X.509 PKI fit this requirement. Look at [these instructions](http://www.rubygems-openpgp-ca.org/blog/the-complete-guide-to-signing-the-certificate-authority-keys.html). Instructions like "Just hit enter here" does not inspire confidence. Why is it necessary for me to go through all of these steps by hand? If I'm just following along at home can't the software do it for me? Isn't automating repetitive tasks one of the reasons we invented computers? This is one of the major reasons why nobody cares. It's so difficult to get started it's not worth trying.
&gt; 1) "initialize" is a special class method You probably mean the right thing, but it's called "instance method". 
Sorry, I disagree. Gits interface is fairly well designed, basic tasks are easily accomplished and documentation is excellent. The same is true for GPG, well designed command line interface. But PGP integration into email clients didn't really improve since the nineties (yay pgp/mime!). I think SSH gets it right, ask once for the fingerprint, afterwards report problems only. I don't want to promote the PKI nonesense, but with SMIME you can at least setup a company wide infrastructure. Last time I checked PGP keyservers were severly lacking. But yeah, people don't care about crypto. They won't do it unless it's well integrated and mandatory.
Can you do this multiple times a = nil,b = nil?
He asked what gems weren't working on JRuby so I decided to give it a try and as it turned out, only one important gem needed swapping, the pg one that I mentioned. Also while I was testing JRuby I remembered my VM had only one vcore enabled so the Rubinius benchs were a bit useless. Enabled 4 vcores and re-run all the benchmarks. The thing is that I've tried the same “methodology” on another app and the results were reversed: CRuby 50req/s vs JRuby 38req/s. So the take away is that the perf. is application specific not really much of a suprise, there's no silver bullet yet. I think I'll go deeper to try and find out more details and update along the way.
Ah yes you are right, just a typo.
&gt; Look at these instructions. Instructions like "Just hit enter here" Heck, "just hit page-down seven times to get to the bottom of these instructions" does not inspire enthusiasm. If you want to actually improve Ruby module security, get default signature checking into the standard release (i.e. the one that Linux distros bundle).
You should instead be focusing on having large chunks of JavaScript be exactly the same on each page and then caching it with far futures headers. Doing this causes the client to only download once no matter how many pages they visit, and enables things like turbolinks if you want to pursue that route.
Yes, you can set as many default values as you'd like. 
I'm going to [import TUF support](https://github.com/rubygems/rubygems/pull/719) for 2.3 which will probably be out in February. TUF is a different take than PGP/X.509, unfortunately [its website](https://updateframework.com/projects/project) is down.
Thanks. So +1 also for the big js file (with sprockets I assume)? What happens though if I change some things on the JS and push it to the server, doesn't it get uncached or something?
With Ruby 1.8, you have to require 'rubygems' before requiring any libraries installed as gems. With Ruby 1.9, that is not necessary anymore. &gt;require 'rubygems' &gt;require 'open-uri' &gt;require 'nokogiri' 
Okay, I guess I'm just concerned that as we add stuff in, things get bigger and bigger. For example, we have morrisjs for graphs but it's just used on one controller. 
Hi, first thank you for the response. I include that line and it still returns the same error for nokogiri. 
As you are using bundler make sure you run your script and irb by prefixing them with 'bundle exec' otherwise the paths to the gems you've installed will not be setup correctly.
you are right. The algorithm uses parts of salt+password to encrypt itself and because you can't get back the original unencrypted value, this is called a hash.
Bundler needs to be initialized after you start ruby, so that it can activate the gems that it installed. The easiest way to make sure that happens is to first add `require 'rubygems'` at the top of the file, then `require 'bundler/setup'`. Requiring rubygems is not necessary if you're using ruby 1.9 or above. After that, just require any standard libraries (like open-uri) and any gems that are in your Gemfile, like nokogiri. This should work from irb as well.
Yes, but the need to be at the end of the argument list and when calling the method you can't skip arguments. So `def method(a = nil, b = nil, c)` won't work, and if you need to provide c but not b for the method `def method(a, b="foobar", c=nil)` then you need to call it like this `object.method("foo", "foobar", "bar")` which can get tricky, because the default value needs to be clearly documented and can never change in the future without breaking existing code (if for example you want to get :foobar instead of "foobar" as the default).
Compiling all your JavaScript assets into a single application.js is just fine. One of the great things about sprockets is that you can keep your libraries organized into subdirectories for easier development, but have them concatenated and minified into one file during deployment. One downside to having a single application.js build is that when you make a change to any section of any of the code, it forces all your clients to download the entire file again after you deploy. In that case, it's perfectly fine to use `&lt;%= javascript_include_tag params[:controller] %&gt;` in your layout, and then have separate files such as `app/assets/javascripts/posts.js`. That strategy is mentioned in the Rails Guides for the asset pipeline. When you use `//= require foo`, it will look for `foo.js` in your assets/javascripts paths, but you can alternatively create a subdirectory with an index file, such as `app/assets/javascripts/foo/index.js` without changing the require directive. One more thing, I like to keep external libraries such as parsley.js in `vendor/assets/javascripts/`. You can still require it from your javascript files in `app/`. I don't like to use CDNs because that means your site doesn't work when you don't have an internet connection, even in development or test environments. I've had test suites fail because they were running on a machine that couldn't access the CDN. Sounds like you're on the right track. Edit: I thought it might be good to point out a gotcha with the controller-specific javascript files. If you have `config.assets.initialize_on_precompile` set to false in `config/application.rb` (for example, if you're deploying to Heroku), you'll need to remember to tell Rails to compile them, by adding the individual controller-named javascripts like this: `config.assets.precompile += ['application.js', 'posts.js']` in your `config/application.rb`. (This may have changed in rails v4.1.0, but it's still mentioned in the guides). Otherwise, you'll get an error when you go to pages that have a `javascript_include_tag` for it.
Original author here, and I agree with much of what you say regarding complexity. However, the only steps required for me to get my first metric (that someone downloaded the test gem) was: `gem install rubygems-openpgp` `gem install openpgp_signed_hola --verify` Even those steps had less than 0.1% success rate. And things only go downhill from there.
Try this: page = Nokogiri::HTML.parse(File.open("index.html")) 
Thanks for the complete answer, especially the gotcha. (As of now I'm still in the learning phase for what I'm doing so knowing that I might see that error in Heroku will save me some stress...). Is this basically a "put them together if the app is small, and separate them when the app is large"?
The issue is nokogiri isn't being recognized at the require statement. How will this change that?
Could you post a link to the code?
Ok, a bit confused since this is just a script and you asked for a Mac App. To create an "app" with a full GUI isn't a trivial effort, but a Ruby script will run on the Mac terminal just fine. To create a GUI app with Ruby you'll need to learn some Cocoa and use MacRuby or RubyMotion, or use JRuby and create a Java GUI. I think you can even use Tk to create a UI but I'm not sure if that's distributed with OSX by default. 1) a better choice might be to log to a file instead of STDOUT. You could then 'tail -f' the logfile to get a stream of updates. 2) Read up on [OptionParser](http://ruby-doc.org/stdlib-2.1.0/libdoc/optparse/rdoc/OptionParser.html) 3) Why? If it's the user's own credentials then just prompt for them at start up, keep them in memory and don't worry about storing them, or warn that you are storing them in plaintext. Any effort to obfuscate them will be pretty futile since the code to deobfuscate them will necessarily be shown in your script in order for you to utilize them. 4) I don't understand what you're asking. 5) Refer to OptionParser and just accept a high value as a parameter or add it as a value to your yaml file you're loading. Additionally, your API call might fail, you should probably handle a failure scenario (begin/rescue) and your loop timer should probably be configurable. Requesting an update every 30 seconds is probably not needed for most people. You might also consider converting this to a script that could be configured as a cron job instead. Edit: I don't mean to discourage you, but I wouldn't worry about preventing people from snagging this script. It's like 10 minutes of effort from a seasoned developer in any programming language.
On the log file, are you seeing something like this precede your logged information? D, [2014-01-09T10:30:04.888468 #29754] DEBUG -- : If that's what you're refering to as "time and some code" then you just need to change the [Logger formatting](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/logger/rdoc/Logger.html#class-Logger-label-Format). &gt; The log file will not start writing until about 30 minutes after the program runs if the conditions are not met. Then you can see the output I'm referring to in part 4. I've used the Logger class before for writing actual files and it updates in real-time. I think this is due to the fact that you're mixing log levels. On line 9 of your code, you're declaring your log level to be "INFO". Then in your loop on line 44, you're using `logger.debug` which is a lower log [level](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/logger/rdoc/Logger.html#class-Logger-label-Description) and won't be shown.
In case you are not using these packages for production deployment you are missing out. It has completely replaced need of using rvm or rbenv in production for me.
My bad, I thought you were past that with the require rubygems statement someone else mentioned.
Sadly no, I had mixed ruby versions (1.8.7 and 1.9.1) but have since fixed that and still have the problem at the `require 'nokogiri'` line. Trying to be a good sport and keep my head up but goddamn do I miss Python's `pip` installer so badly right about now... haha
Why is this getting downvoted?
Because the guide you linked to is the guide for *signing* gems. In other words, the guide for gem *authors*. The guide for gem *users* is much simpler: http://www.rubygems-openpgp-ca.org/blog/the-complete-guide-to-verifying-gems-with-rubygems-openpgp.html
Did you install libxml before you ran gem install nokogiri? Personally, I would NEVER use the distro packages and use rvm or rbenv.
If the gem has a command line interface you could execute an os command from another language. 
In general I agree. But consider the case of public_method() which calls three complicated private methods, each with many complicated edge cases. It may be prohibitively complicated to test all private method edge cases through the public method, in which case I have no problem testing private methods via send.
Do you have the proper Ruby version added to your PATH?
What if I start with: def public_method private_method + # more stuff end private # shouldn't test because private def private_method() # implementation end and refactor with [replace method with method object](http://www.refactoring.com/catalog/replaceMethodWithMethodObject.html) to: def private_method() MethodObject.new.call end class MethodObject def call # implementation end end Am I "allowed" to test MethodObject#call because it's public? It is the exact same implementation the rules prohibit me from testing when implemented as a private method. Can I only test it through calls to public_method? 
Yup I successfully installed that and the other prior dependency using `sudo apt-get install libxslt-dev libxml2-dev`. 
Hi, thank you for the response. I tried this out with still no luck, I receive the same error message. 
Hello, thanks for the response. I tried the `bundle exec` prefix with still no luck, I receive the exact same error. 
Why are you limiting to MRI only?
num = num.to_i or num = gets.chomp.to_i Also consider using double quotes where you're interpolating. i.e. "That number is fine but don't you think #{better} is better?"
Thanks alot, That made things abit easier. The script is running how it is supposed to. I guess in programming there's more then a few ways to write things.
I think the guide is meant to let the reader understand what's happening under the hood, rather than blindly running magic commands that magically give security.
As if you needed another reason to not use GoDaddy.
You must not do much hiring.
Nothing seems to thrive when it comes to Sinatra project generators as far as I could find. Padrino seems like the closest thing to what you're looking for that has remained maintained.
First elephants. Now Ruby. What next?
GoDaddy has never been Ruby friendly. They haven't updated RoR since '05. 
Semi-related: What's the best budget VPS provider? I currently use Dreamhost, and read the internet and the internet said it was bad, but didn't provide much help. Using Heroku is not the answer. This is for my personal site. 
[DigitalOcean](https://www.digitalocean.com/)
[Linode](http://www.linode.com/) is cool too
Couldn't have said it better myself.
Hello, So everything in ruby is a method, so x = 1 is actually a specialized method call. Imagine if for every attribute on an object we had a method set_&lt;sttribute&gt; So if had an attribute called name and we wanted to we could say send("set_name", "ken_bingsley") x= is just a special method that gets created when we have attr_writer or attr_accessor, even though it looks like it isn't a method. Does that help?
Yes thank you, that makes sense. :)
Agreed. I've noticed the same thing. As a replacement to Monk, I found a Thor script to generate a minimalist Sinatra application. You can check it out on GitHub: [github/sinatra-thor](https://github.com/jeffharrington/sinatra-thor) It's pretty simple to install and it's worked well for me. 
RamNode!
rubinius provides a mirror of MRI's C API, and to my knowledge, function calls to the C API are wrapped in a lock. 
RackSpace cloud is pretty affordable. Otherwise there's WebbyNode which is cheap as hell too.
Thanks /u/alphabiosx, I'll look into that.
This helped me clear some misconceptions. Seems like I have lot to learn (which is cool). Anyway, this brought to my mind another question: the same application in MRI and in Rubinius won't see much difference in speed if no parallelism or concurrency is used? Also, fork() is costlier to spawn than a thread and there's no shared memory between process; does that mean that memory consumption can become a problem in MRI (or more generally, whenever fork() is used)? Thanks a lot!
So it appears. I guess we'll keep using Monk until some Sinatra update breaks it and then roll our own solution. Padrino is cool but, given that most of the Sinatra sites we build are either simple RESTful facades to another API or basic forms, Padrino is more than we need. Also, it seems to be problematic to deploy to Heroku, so that's an issue too. Thanks, nonetheless. 
This, and the others, all sound great! Question - Why on earth does Dreamhost cost $15/m for 300MB RAM, when DigitalOcean costs $5/m for 512 RAM. Is it just brand name, or is there some hidden caveat?
`send` essentially invokes a method named by the first argument, the remaining arguments are passed to it.
No idea. Digital Ocean is still a fairly young and small company. They probably have really low margins but make up for it with scale. I've been with them awhile and they are perfect for my personal projects.
Awesome! thanks for the detail and time to explain.
Great, so you/they get paid to migrate them.
no prob.
So you have can multiple packages installed, each with a different version? 
+1 for Linode. They are very stable, and have increased their offering over time, without price hikes, to remain competitive. They aren't the absolute cheapest (still pretty cheap, mind), which I find is a positive - scraping the barrel for hosting is never a good idea.
Don't `include Enumerable` unless the class is enumerable is a solid point. `String` is not enumerable. It returns enumerators using `each_byte`, `each_char`, `each_line` and `each_codepoint`.
If you want cheap managed shared hosting that's similar to Dreamhost but much more stable and powerful, [Webfaction](http://www.webfaction.com/) is awesome. That being said, I host stuff on Dreamhost too and if you don't have a problem with it, keep using it. Also, in defense of Heroku, you can run a personal site no problem. 1 dyno (free), hit it with New Relic's (free) uptime monitor to keep it from sleeping, and use the Dev database (free) assuming you have less than 10k rows. Plus small memcached (free) or redis (free) and you're golden. If you don't want to do devops and server maintainance and backups (dear lord, if you have a VPS please have automated backups for your db and files to s3), heroku ain't bad. Though if you can set all of that up, Digital Ocean all the way.
GoDaddy target group is specified since years: people with IQ of Nascar fans. They don't need Ruby anyway, so I don't see any problems here. +1 for DigitalOcean
Yes. Debian and Ubuntu have done that for years: they allow you to install 1.8 and 1.9 in parallel (though you can't choose the exact 1.8/1.9 minor and tiny version: you can only get the latest). The Brightbox packages continue that trend and allow you to install 2.0 and 2.1 in parallel as well.
SemiSemi-related: is there a good VPS provider comparable to Linode and DigitalOcean who is based in the EU (as in: not under the patriot act?)
Honestly, as someone who once tried getting a Rails app running on a shared host that advertised Rails support, discontinuing torturing your customers over a feature you can't possibly support well in a shared environment is a blessing to us all. This is the first time I've ever said "yay goDaddy".
Don't forget SOPA/CISPA!
RVMs future is rbenv.
DigitalOcean's pricing makes more sense given the modern hardware they're using. While most VPS providers are still recouping their investments in now outdated infrastructures, DO are taking advantage of newer, cheaper, and more powerful hardware to beat them all on price and performance. They can build servers with far faster CPUs and disks and more RAM than you could have a few years ago, for half the cost, which means they can fit more users comfortably on the same box, and therefore sell it cheaper.
`x=` can be the name of a method, but it can also be local variable assignment. def x=(a) foo = 10 @bar = 20 self.foo = 30 send("bar=", 40) end Will define a method named `x=`, which when called will assign 10 to a local variable (which in this method won't do anything), assign 20 to the instance variable @bar, call the method `foo=` with parameter 30 and call the method `bar=` with parameter 40. `something.foo=` (the space between the name and = is optional) will always call a method. `foo=` will always assign a local variable.
why don't you do the work for free, and then see what you think it's worth? believe it or not, some people have bills to pay.
Out of curiosity and ignorance, why is rbenv better? It appears to be lightweight and "better" because it uses shims, but does that make a significant enough difference to switch?
Your mileage may vary, but I've run into a lot less issues on both development and production machines. RVM would often give me obscure errors and I would have to do a lot of research to solve them. I also like the simplicity of rbenv versus RVM. RVM documentation was always kind of sketchy to me and left a lot to be desired. rbenv on the other hand is simple enough where I can just run `rbenv help` and have what I need. I do use a few plugins with rbenv installed via homebrew such as ruby-build, rbenv-gemset, and rbenv-gem-rehash.
do what, work without pay as you advocated for the RVM dev team? i don't know why anybody would do that.
the man's asking for a junior developer salary to work on a tool used by thousands of rubyists. whether or not the rewrite is necessary, i don't think $50k for 1 year of development work is outrageous, except if you mean outrageously cheap.
When exactly did I advocate working without pay?
You're implying that I called it outrageous, I did not. I just don't believe we should throw 50k at a rewrite of a project that doesn't need a rewrite. There are plenty of other projects that could use 50k or even less that would provide a lot more value. If people want to donate and think the value is worth it, good for them because it's none of my business. I just don't personally see the value behind it so I'm not backing it. You really should stop taking this conversation offensively.
[RamNode](http://www.ramnode.com/) is great. Nothing but good things to say about them.
Hi thank you again for the reply. `cat $(which bundle) | head -1` returns `#!/usr/bin/ruby1.9.1` `which ruby` returns `/usr/bin/ruby` ---- **side note:** This is a topic of confusion for me, shouldn't it also say ruby1.9.1 if what I installed was `sudo apt-get install ruby1.9.1-dev` ? I even selected version 1.9.1 with the `updates-alternative --config ruby` command but `ruby -v` returns `ruby 1.9.3p0`. `ruby -e 'puts Gem.path'` returns `/var/lib/gems/1.9.1` and `home/stephen/.gem/ruby/1.9.1`. Sorry if I'm overlooking something, I do appreciate the help since I'm noobish to Linux as well as Ruby.
I think perhaps you're reading too much into my comments. I didn't say it was an unfair price; I merely expressed surprise that rewriting 20kLoC costs $50k, and made a tongue-in-cheek remark about how I'd like to be paid that much. That's all. &gt;what do you think is a fair price for this work? I have no idea. That's why I asked; I was hoping someone with more knowledge of RVM would be able to comment. If the project truly *needs* a ground-up rewrite, and this ground-up rewrite will truly take an entire year of development time, and the new version will provide some compelling advantages over both the current version of RVM and rbenv, then $50k is probably reasonable. But that seems like a tall order to me.
&gt; I love the fact that is picks up the Ruby version from the directory you are in. Explain? I assume you mean something other than the .ruby-version since that works with rvm as well.
&gt; You really should stop taking this conversation offensively. You're are right =) Lots of people get paid a lot more to work on stuff that is far less useful (example: http://www.glassdoor.com/Salary/Zynga-Software-Engineer-Salaries-E243552_D_KO6,23.htm). I think it is fair to to pass if you don't care about RVM, but totally unfair to criticize the asking price. Donate or don't, but $50k is a very poor annual salary for software development of any kind. &gt; You're implying that I called it outrageous, I did not. Yep. Sorry about that.
Am I the only one wondering the whole "we will write rvm in ruby" thing will work ? I mean, ruby may not be packaged in all systems, so you'll need to install ruby on your own before being able to use rvm ? 
Good question. MRI refers to the versions listed, but some people have already used "other" to mention JRuby, etc. I could probably have made that distinction clearer. 
Ah okay thank you for the explanation. I'm trying to install RVM now but am getting hit with some errors: sudo-apt-get install ruby-rvm The following packages have unmet dependencies: ruby-rvm: Depends: libsqlite3-dev but it is not going to be installed. So I run `sudo apt-get install libsqlite3-dev` and am told `The following packages have unmet dependencies libsqlite3-dev: Depends: libsqlite3-0 (= 3.7.9-2ubuntu1) but 3.7.9-2ubuntu1.1 is to be installed.` `libsqlite3-0` is already the newest version. I'm real confused by this error... I will have to do some digging/searching for a resolution but if you happen to know what might be wrong off the top of your head you'd be a sorcerer! **edit:** Apparently, from what I've been reading, "*This appears to be a problem with some of the 64-bit packages being out of sync with the 32-bit packages (3.7.9-2ubuntu1 vs. 3.7.9-2ubuntu1.1).*" So this is what I need to resolve/fix before moving forward. **edit #2: ** Finally came across a solution!! http://allelseweretaken.wordpress.com/2012/12/29/ruby-on-rails-installing-on-ubuntu-12-04-success-finally/
See the [Google Document](https://docs.google.com/document/d/1xW9GeEpLOWPcddDg_hOPvK4oeLxJmU3Q5FiCNT7nTAc/edit#heading=h.ojwb1svzqr9w): &gt; **Bootstrapping** &gt; Using ruby should be possible thanks to binary rubies, in worst case we can fallback to static build or use JRuby. The binary Ruby (or static or JRuby) will be installed along with RVM 2 using very simple bootstrapping script written in shell most likely pure SH to provide compatibility with as much systems as possible 
Put it in `~/.rbenv/versions`, or patch `ruby-build` when a new version comes out.
[chruby](https://github.com/postmodern/chruby#readme) allows this. You can add arbitrary installations to `RUBIES` or call `chruby_use path/to/jruby`.
Thanks, that was the part I was searching in the document :) 
At 100 LOC per day, that's 200 working days. At 5 working days per week, that's 40 weeks. So that $50,000 annualizes out to $62,500 per year, assuming 50 working weeks per year.
I use this. Thanks so much for writing it!
I have hired two developers, both do not have CS degrees, but I selected them from a large pool and they were not risky hires. Almost all the other non-CS degreed programmers had major blind spots in algorithmic identification / analysis though. The guys I hired aren't perfect but very competent and willing to learn - biggest pro a non-grad can have is willingness to learn.
It depends on who you're trying to please... There are still legacy apps out there that run on 1.8/1.9. They should be in maintenance (bugfixes, etc) though, not active development. I think its fine to require ruby 2.X for active development, because no one should be actively developing features on an old implementation. Requiring 2.x will help move adaptation of the new implementations forward.
This doesn't answer your question but I can't tell you how highly I recommend going through the Ruby Koans more than once if you are new to Ruby. I've been using Ruby for 2 years or so and I still go back to the Koans every once in a while to keep some of the subtleties fresh. http://rubykoans.com/
It is, but OP is doing string concatenation, OP just left spaces out around '+'.
How do i actually install the plugin? As someone who has never used lighttable before, i have no idea. It only show installation notes for its dependency?
not sure how good it is to look at debian for bleeding edge, relatively up to date, or as a reflection of what's relevant in ruby. i think is a little too soon though. 
I never said that rbenv was perfect and I don't see chruby having a competitive advantage over rbenv either. You also never gave any reason why chruby would be the future of rbenv. I'm not saying that it will never be replaced either. I'm just saying that you calling chruby the future of rbenv is ridiculous and you really don't have anything pointing towards that.
Press Ctrl-Space to open the command manager, search for plugin manager, then click on "Available" and click on it in the list, it will install :) Then you can just follow the instructions in the README to setup a keybinding.
If you want to target ~&gt; 2.0, or even ~&gt; 2, then do so. Let people who want to maintain your gem against older rubies put forth that effort.
Not super clear as to what this is. Your examples can benefit from more readable hash keys.
Is there something that you are doing in you're gem (or it's dependencies) that requires features in 2.x or is this related to the level of testing and support you would provide?
Thank you kindly, I'll take a look into getting some more realistic data after I add rulesets for detecting emails and the like. The current version is far more a proof of concept than anything, and I hope to have it to a fully usable state over the weekend. The general point is that in a Service Oriented Architecture that supplies data to your app as JSON, it can be a pain to repeatedly make new fixtures to test against. With this gem, you can get live service data and have it interpreted into a generator for new fixtures based on whatever data types that response gave back.
Sounds kinda dirty.
It's more a question of what to do when adding new features. For example, if I'm adding a new feature to an existing gem and I want to add a method that takes named parameters, should I use the new 2.0 feature, or should I keep using the old hash trick? To put it in more general terms: do I match the existing code, or do I do things the new way and update the ruby version requirement?
For all of us using jruby for projects, please don't require 2.x just yet! 2.0 support is still in beta and I'm waiting for it to go into the main line before moving my projects.
Thumbs up for Digital Ocean. Had a small problem with them when first starting out (blogged here: http://rubyredbricks.com/blog/2013/12/14/digitalocean-the-good-the-bad-and-well-the-good/) but pretty decent value for money, very easy to set up VMs. 
There's ruby 2.0 too: http://packages.debian.org/sid/ruby2.0
I wonder if that'll make it as the default ruby in Jessie?
what is that?
Your example is interpolation; you're putting a string inside of a string. Concatenating is when you take multiple strings and add/join/concatenate them into one string: "foo" + "bar" =&gt; "foobar" -or- "foo" &lt;&lt; "bar" =&gt; "foobar"
Not to mention they only use SSD's!
I'm kind of surprised this isn't already part of LightTable... Maybe it's more complicated than I thought to implement a REPL
Well, I didn't mean to shift focus to the syntax. This is more of a philosophical question really. When is it a good time to start piecemeal updating of old code to support new language features? Should new features added to old code use new language features? Usually I would use adoption rates to make that sort of decision, but I'm not seeing any such thing for ruby. I knew mentioning the hash syntax would derail the conversation, yet I did it anyway. Silly me. **edited**: for the clarity!
So, 1.9.3 is in security-fix-only as of Feb 2014, and completely end of lifed as of Feb 2015. Personally, I'd wait until Feb 2015 to drop 1.9.3, because I think many people are going to be holding on until the bitter end, and this maximizes compatibility -- some of your users may have _other_ dependencies that don't work or are not yet verified to work in 2.0. Also because it's not very hard to support 1.9.3 as well as 2.0. On the other hand, I suppose it's also not very hard to migrate your app from 1.9.3 to 2.0. As always though, it depends. I'm also curious if you have a particular thing that is motivating you to want to drop 1.9.3 support, if so what it is?
I think there probably isn't actually an abstract philosophical answer, it always depends on specifically what's going on, both adoption rates and what the changes are between the two languages -- both how hard it is for _you_ to keep supporting the old version, and how hard it is for your potential users to upgrade to the new version. These things are contextual and specific, not abstract and philosophical. If supporting 1.9.3 was going to add significant burden to you, and/or add significant performance or maintenance problems to your app, that effects the answer. It's not just philosophical, it really depends on what it is you want to do that supporting 1.9.3 makes harder. 
Are you sure that your ruby-build are up to date? You can see the available versions here: https://github.com/sstephenson/ruby-build/tree/master/share/ruby-build
Why do you still need gemsets when you can use bundler?
yes, thread-safety, and actually in particular thread-safety of _C extensions_ specifically. C extensions would have to be written more carefully, with more ruby-specific calls, to be thread-safe without a GIL. This probably also applies to the MRI source code itself, it would be harder to write it thread-safely without a GIL, and especially hard to retrofit the existing code to be sure it's thread-safe. It's possible that's the real issue. It's to some extent a legacy issue. See: http://merbist.com/2011/10/03/about-concurrency-and-the-gil/
&gt; I am surprised that any experienced developer thinks LoC is a useful measure of value! No experienced developer does. The only scenario in which I'd consider LoC a useful metric is a legacy system that needs to be refactored whilst maintaining the same functionality (in which case a negative LoC is a very good thing). &gt; I am not, however, convinced that what they are planning on doing is actually worthwhile, in the presence of chruby and rbenv. That's the main issue - rbenv is already superior to RVM for the purposes that I (and, I'd imagine, a large portion of the community) use it for.
Is it a library that you want people to use? Then support as many versions of Ruby as you can. Is it an application? Doesn't matter much. Ruby 1.9 would get most people using it, but use whatever you want. But to be honest 2.1 seems a little buggy at the moment...
Ah, I forgot that an EOL date had been set, and that it's only a year away. You're right, it's not very hard to maintain support for 1.9.3, so I'll probably stick with it for awhile longer. The motivator was actually the named parameter syntax. All of my new stuff is using the new hotness, and then I needed to modify an older gem that still has the old syntax. I had a "wtf is this?" moment when I looked at the old code, which got me thinking about all of this again. I also just had a moment where I realized I should have used single quotes because there was nothing to interpolate in the last sentence. I must be getting old, but I'm going to blame it on the cloudy weather.
yeah, I haven't seen a debian ruby stack before, but I'd be surprised if they weren't out there. why wouldn't you compile on the machine yourself, though? 
Using the system ruby for app development isn't something I do or recommend myself, but I work with people who do. The argument is that security patches come through the same route as everything else on the machine, which makes the sysadmins' job easier. Fundamentally it just depends where you draw the dividing line between application and platform. Personally I think the speed with which the ruby community moves (this post being a case in point) simply makes it impractical to stick with the platform ruby for the duration of an OS release, so it makes sense to treat the interpreter as part of the application. However, that does depend on the style of development you're doing.
Howdy, What step is giving you trouble?
What is it that you don't understand about the process?
There's no reason to use a shared hosting provider for any ruby site. Just go with Amazon EC2. Free for 1 year with minimum usage and only $15 a month after that.
What OS are you running? Have you installed Ruby already? Are you familiar with the command line?
No readme or description posted here? No thanks. 
Should one be in one's home folder ~/ or in the root folder / when doing this?
&gt; some of my reasoning is explained here: http://piotrsarnacki.com/2014/01/01/i-am-tired-by-rails-should-fundamentally-change-crowd/#comment-1184059945 gosh the gist of your argument seems to be that it includes too much stuff. I think you really need to think about where rails sits in the web application ecosystem. It's smack bang in the middle of microframeworks (Such as sinatra) and enterprise frameworks (eg. weblogic). yes it includes a fair bit by default. This gives sane defaults for people who are learning. If you don't like something it includes by default, comment it out! I think the defaults it uses are very good for learning.
I think the current version is up to 2.1.0-p0... I ended up just using rvm to do a clean install on a clean system. Some of my stuff is old, and I might want to install 1.8 later. Now rubygems is not installed. That's weird. I thought rubygems was installed with ruby nowadays...
You don't care about 'rubygems' since after ruby 1.8.7. Just install gems with gem install ... 
Yes... $ gem install foo reports that gem is not installed until I run: $ ~/.rvm/scripts/rvm And I don't want to have to run that every time I open a new terminal. I'm going to try turning it off and on again!
Yes, rvm needs to be sourced to work. Put it in your `.bashrc` or `.bash_profile`, as the rvm installer suggests.
Because not everyone uses bash. 
And chruby is even better than rbenv. It's pretty clear to me that chruby is what rbenv was trying to do, but even better. If you're ever at a point where things have to be set up again and it makes sense to consider a switch, i'd recommend considering chruby. 
It's a collection of dotfiles. It's kind of hard to describe because it represents a collection of personal settings. [I have one too.](http://github.com/Karunamon/dotfiles) ..but as neat as exploring these are, it's probably not a good fit for r/ruby because there's very little ruby specific there.
Yeah I have dotfiles too... Just saying with a title like this it'd be nice to have some description as to why/what in particular is so speedy about this individual's configuration. 
It.. does? At least for me, it added these two lines to my dotfiles: PATH=$PATH:$HOME/.rvm/bin # Add RVM to PATH for scripting [[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function* Are you sure it hasn't just added them to a file that isn't being loaded in your setup? e.g. if it's added them to your .profile, that won't be loaded if you have a .bash_profile. Or it's added them to your .bashrc, but you're on OS X where Terminal.app shells are login shells so you need to source .bashrc from .bash_profile or .bashrc won't be run. Or something like that.
Why not just say you're trying to install https://github.com/brighton36/CoinPost? Looks like installing Ruby 1.9.3, the postgres and or sqlite dev headers, bundler, then doing the migrate and seed tasks will work.
That is documentation for the project (which isn't much). You need to look at documentation on the Rails framework. Try something like this: http://guides.rubyonrails.org/getting_started.html Further questions should go in r/rails
postgres in the long run, sqlite if you're just playing around.
Yup, use the [required_rub_version](http://guides.rubygems.org/specification-reference/#required_ruby_version=) variable in the gemspec. I haven't seen it used much, but I may be looking in the wrong places. It seems like something that should be used far more often, but I suspect most people don't take the time to figure out the lowest version they support. Not that I'm one to talk. Now that Mavericks comes with 2.0, I don't actually check that everything still works on 1.9.3 until travis-ci complains.
Specific questions I can help with. When you clone the repo, you'll have the CoinPost dir, that directory is the application root. That's the folder where you'll run all your commands from.
You duplicated quite a bit of stuff found in [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)
&gt; That didn't used to be necessary. Huh? When was the last time you used it?
The last time I *installed* it was quite a while ago. An early version of 2.0, I believe.
I meant rvm, not ruby. I don't recall a time when rvm worked without sourcing, if there ever was one.
Okay. Thank you SEMW. This is a problem with my bash startup, not Ruby. That's a relief! In this case, I had no .bash_profile, and RVM created a .bash_profile: [[ -s "$HOME/.profile" ]] &amp;&amp; source "$HOME/.profile" [[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; source "$HOME/.rvm/scripts/rvm" If this is running on startup, it calls .profile and then sources rvm. Neither .profile not .bashrc source rvm, so I believe that ~/.bash_profile is not running on startup for some reason. For now I have simply stuck: source ~/.rvm/scripts/rvm On to the end of my .bashrc and everything is fine, but it is clumsy and I don't like it. The path was added to BOTH .profile AND .bashrc. I am going to add: [[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; source "$HOME/.rvm/scripts/rvm" to ~/.profile Worst case scenario is that rvm will be sourced twice.
I think this is just a little hiccup in between .bash_profile, .profile, and .bashrc.
Now you will have a monthly cost for a sysadmin and a server. Is that still cheaper?
It's easier to test out if your gemset is production ready with dedicated gemsets imo. Easier to identify gems that aren't installed as part of the project but are being 'required' because they happen to be installed.
I'm not the OP, but I do wonder about the downvotes. 
check out https://freedcamp.com/
I suggest using some sort of templating framework for formatting JSON responses, such as RABL: https://github.com/nesquena/rabl Allows for a lot more flexibility, and in this case, you'd stick all your .json.rabl files in your views folder. Edit: or, if you'd prefer, doing it at the model level using ActiveModel::Serializers: http://railscasts.com/episodes/409-active-model-serializers. In this case, your serializers would be under app/serializers.
Redmine is horrible. Just a heads up. 
Thank you akwok, I watched the Railscasts and I loved it. I have to decide which of the two I will be using. In the meantime, do you use the `respond_to format js`? When is it advisable to use?
You can steal Monk's Thorfile and use that as your base for Thor commands. I did that.
I'm the Redmine admin at my day job. It's far from horrible like maskalor says, but it is an open source project with a vastly smaller community than Rails itself. That means that when you first show up in Redmineland you see the promise of Redmine add ons created by other users scratching their own itches, but in reality most of the time these solutions are half-baked (at best), and tailored for the creators specific use case. Support is non-existent. You'll be learning a lot about sysadmin on Ruby servers, which happens to be something I enjoy but it's a pretty steep climb to start. Overall the Redmine experience is one of trying not to get mired in too much technical debt and being constantly frustrated that shit doesn't work the way you want it to. If you can get into Jira for free like u/preflightsiren says, I'd recommend that very strongly. It's a product supported by a company whose job is to make it work correctly. I wish it were an option for us. Or better yet, don't try to fix the problem unless you absolutely have to.
http://jade-lang.com/
Thanks @ProggyBS, sorry for the late reply. Did I understand it correctly if I say that returning `.js.erb` means "doing a re-doable action"?
&gt; A while back, I noticed our tests were slowing down for no apparent reason ... &gt; factory_girl Hey, I found the problem! Stop using rails shit in your tests. Isolate your business logic away from it and your tests will scream.
I use this library to generate PDFs; it's really quite good. It's missing things like bookmarks and initial view, unfortunately, but it is very handy.
Hey thanks! I'm glad it's been useful to you so far. If there's anything you'd like to see me cover in the future, let me know.
Actually, I already have a server and I've been managing it just fine for the past few years :) The reason we chose to go this route is because we HAVE a server and do not wish to pay to use someone else's.
1) I use a MacBook Pro. Like having a desk, keyboard, external monitor ( i will divide my monitors by code / browser (testing, internet searching) 2) Sometimes I use git in terminal, most of the time I am finding Soutree by Atlassian is a good frontend. 3) I do not use a web editor 4) Use a text editor like Sublime Text, Vim, or for more in depth Aptana 5) Vim 6) I don't use ruby to write many complex algorithms, this is mostly done in ruby on rails models though, sometimes they will or will not be linked to a database. 7) I struggle that else if is called elsif, sometimes ruby on rails concerns, picturing background jobs. Otherwise, sometimes I want to make the front end all javascript, because, well, it can be. 8) Problems, try small changes until it works, look up info on stackoverflow, and otherwise google. Try things that don't work until they do. 9) I learned ruby for a hackathon first, laster for a job 10) Don't use ruby often for my personal life, prefer PHP, nodejs, js. 11) Not really. Messagecarrier has a ruby server side. 12) I have patched gems to get them to work better with 4.0 or to solve an issue, have not yet patched core. 13) Forking is if you take an existing project repository, you want to make it different, so you fork your own copy, write your feature. Your fork can live on its own or you can submit a pull request to the owner of the original repository for them to accept it. It's basically a branch once removed. 14) Wordpress is easy, but needs a lot of resources on a server (unless you use wordpress.org. Jekyll is popular for github pages. http://jekyllbootstrap.com/ 
1. Fedora machine using RVM for management. I like to develop closer to the server type I am deploying to (plus, Macs are overpriced and overrated). 2. I do everything via Terminal except... 3. I use Sublime Text 2 for developing any HTML/CSS... 4. and any code. Well worth the price, IMHO. 5. (I think I mentioned it). 6. Concurrency and speed/memory management. 7. It's a language. Stick to your guns and you can learn any design patterns or algorithms. 8. Too many to list, suffice it to say you will come across many roadblocks that you gotta tear down. 9. Yes and Yes. I don't do Rails (you can learn Rails without necessarily understanding Ruby and vice versa). I use Sinatra as my *VC of choice (That's View/Controller without a Model shoved in...unless you write one yourself or utilize something like Sequel). 10. Yes and No. I write a lot of scripts for home in Ruby but I am moving over to NodeJS more and more these days. Really like the V8 engine... 11. Check out my [github](http://github.com/enroxorz) for all my bullcrap libs and stuff. I am embarrassed by a lot of it but whatever. 12. Yes, but it was in C and it was written ages ago for a CUPS driver and I never found out if it was included or not in a release. 13. Forking is making a copy of someone's repo into your own account so you can muck around, fix it, improve on it, or hell make your own version if you want to. I don't fork often so I'm not your forking dude... 14. Just use Blogger or Wordpress for now. Don't get bogged down with setting up your own blog when someone else can host if for you. Hell, I use tumblr (or at least I was...). Edit: Good luck with your journey. Edit 2: Also, become well versed in a testing suite, like rspec, cucumber, mini_test, or something. TDD/BDD will be your saving grace!
At work, we primarily use [vagrant](http://vagrantup.com) for running the rails app itself. So what we'll do is have the vagrant file in our github repo, and simply use the vagrant commands to download the box. The base box simply has the ruby installation, rubygems, postgres, nginx &amp; unicorn. The gemfile will take care of the rails version, and we will utilize a shell script to run in the provisioning process for anything else required. Outside of that, I use: 1. Sublime Text 3 2. iTerm2 for terminal 3. For algorithms they typically aren't language specific. Most algorithms are done with clever loops and mathematical operators. 4. What I currently struggle with in Ruby is forgetting to use bits of the core API to its advantage. A bigger issue for me is really thinking through all the parts of the application and designing things a bit more modular upfront. 5. Through the above problems, team collaboration and code reviews help a lot actually. Been trying to read the newest version of pick axe to better pickup standard lib. 6. I learned ruby for myself because I enjoyed it, also knowing I could build my skills up to get a job with it eventually. Even in my first job which was doing front end development mostly, having ruby to script and parse data we would get from clients was super handy, rather than doing things manually in excel. 7. I dont really have any ruby side projects going on right now, but i have worked on many in the past. So it's still in my professional life, just not for my job specifically. 8. I was working on a twitter dungeon crawler thing with others at a hack night. But i only touch it for those local hacknights :). 9. Ruby related? I've done some work with Redcar text editor in the past. I also help out with development and bug tracking on attr_encrypted. Javascript related, over the past year I became a core contributor to the MelonJS game engine. 10. No. 11. Um what? Forking is basically copying a project. 12. Wordpress is pretty good at what it does. If i wanted to use a platform today, I'd try out jekkyl or octopress.
Ah well, I'm the Redmine chief as the only ruby enthusiast in an otherwise Drupal-based company, so small world. So, just by way of comparison, the Redmine community is a tiny fraction of a tiny fraction of the size of the Drupal community. Even large plugins in the Redmine world only get a sliver of the attention and community contribution that most standard Drupal modules get. If I can offer any help, feel free to hit me up. If you've never set up a production Ruby webserver before, that can be pretty challenging the first time you do it. Same with everything I guess.. good luck.
Do you know about FatFreeCRM?
I know, but I've been a Linux guy since WAY before my Ruby days and...well...I need an excuse not to join the Mac Hivemind...
[The Well-Grounded Rubyist](http://www.manning.com/black3/)
Can you say more, or link to more information, regarding 2.1 "seeming a little buggy at the moment"?
I use OSX, RubyMine, and git on command line. I work primarily in Ruby/RoR.
Mac Pro 2 x 2.4 quad core 48 gigs of rame Dual 20 inch monitor with one rotated vertical I do my all my git commands in a console except I use the git history browser in RubyMine to track down changes. I use Rubymine for editing code. Beyond the nice editor I use the Go To -&gt; Declaration option often. This is really handy when working in new to me unfamiliar projects. I am writing a plugin for Discourse and it has an interesting codebase* I use postgresql for databases and use pgadmin for looking at the data. I really try to only change the database and bulk change the data via migrations. I use brew for installing software like postgresql and have switched to rbenv for dealing with ruby versions but I still use rvm on the servers as it is already setup and work. I do not use a web editor. Since in rails you use a number of other formats (erb , haml and others) to generate html web editors are not the useful. The same seems to be true for css. Ruby is powerful in processing information in ways that are foreign to some other languages. Learning to use the built in power of Enumerable (part of anything hash or array like). Ruby Koans is good for this. http://rubykoans.com/ For Rails where the data is in a database learn to use the ActiveRecord Query syntax to product SQL that is probably better than what either of us can write in most cases. I learned ruby to generate java code that mimicked something like active record before ORM's were prevalent in Java. It was based on something Ambler wrote I think. I try to focus my activities outside work on physical things like crude woodworking, splitting wood and shooting so I do not code much any more outside work. I did write a first version of an app for recording reloading recipes before I found someone had written something better. I customize a number of apps for an educations environment so it is pretty common that I find edge cases or small improvement and submit patches via github. It is very satisfying. Forking. My thought is there are two reasons to do this. The first and rarer is to bring a dead/abandoned project back to life. The second is to fork via github and make your own dev branch for building a fix or other improvement. Then you do a pull request of that work back to the maintainer that you forked from. Wordpress is what it is. The benefit is that it is cheap and someone else maintains the backend for you. Some people do stuff like this. http://jekyllbootstrap.com/ on github and use someone else to provide a commenting engine. As to your last question about code flowing out I am of two minds. Nature vs Nurture. If it is the first then it is something you are or are not. If it is the latter I think that learning enough languages and styles of languages that it all becomes a matter switch switching syntax and methodologies as needed. Spend some time with functional languages like lisp haskell or erlang. Pick up the Seven Languages in Seven Weeks book. Learn some C. I always wondered how you implement a programming language and switch between functions so I took a C class till we got to function pointers. Understanding how that worked helps me work in other languages. *Discourse is really two apps. The first is the part that runs on the server and maintains all the data. The Second is a javascript based application that runs in the browser and consumes and feeds data back and forth with the servers. Edit: add http://rubykoans.com/
[What is your typical development environment like?] Macbook Air or MacMini, Terminal.app, tmux, vim, irb or pry, ssh etc. [Do you primarily use git clones in terminal?] Yep. [Do you use a web editor (like Coda 2 for HTML/CSS)?] Nah. [Do you use a text editor like (Notepad++)?] vim. [Do you have use something else entirely?] Used other environments for other languages. This works best for me for ruby and lots of other stuff. [Where can I learn about designing algorithms in Ruby?] If you're into books, read 'Designpatterns in ruby' and 'Metaprogramming ruby'. Otherwise, read code. And remember that good algorithms are language agnostic; you could also read a text about datastructures and algorithms for java, e.g., and learn stuff you could then use with ruby. [Did you learn Ruby for a job? Did you learn Ruby for yourself?] Yes and yes. First for myself, then again in more detail for some projects. [Do you often use Ruby in your personal life? If so for what?] I do most of my small scripts in ruby; stuff that needs taking some input from somewhere, do some things with it and spit it out again in any form. I've written scripts to automate the production of pdf catalogues for a friends' shop, to write a web system for selling tickets for theatre productions, to create a small solution that takes excel files with student's names and preferences for some activity and creates 'perfect' groupings such that each student gets to do what he/she likes the most, a(nother) photo gallery that creates static sites from pics exported from iphoto to show my wee one to the rest of the family etc. . Could all be done with other languages, but I feel the happiest when I do this stuff in ruby instead of something else. [I want to be the kind of computer scientist that code just flows out of.] First, computer science is not about writing code; I'm sure you know this. But if you're serious, why not just go and study it? There are excellent lectures online, for free.
1) *) 14) *)
Even Cygwin won't do it. The format of Windows paths, with limitations on directory name length, and backslashes instead of forward slashes causes issues. Lack of support for certain software packages in Cygwin. It's just not possible, and even if you make it work you'll eventually run into a limitation that you can't get past. If you use Windows, you'll need to use a virtual environment such as [VirtualBox](https://www.virtualbox.org/) with Ubuntu, CentOS, or some other Linux distribution. Edit: Or just get a Mac (or hackintosh)
yeah, windows has a lot of weird limitations like that. I also think you can't download a single file greater than 3gb. But yeah I think the directory character limit is like 125 or something seemingly arbitrary haha... Plus, installing some ruby gems are just a disaster for windows most of the time. 
&gt; Isolate your business logic away from it and your tests will scream. That's true. Using `factory_girl` for the few integration tests you have, is probably fine, though. For everything else: Requiring `spec_helper` is a bad idea and either a design smell or you don't know any better\*. \* In both cases, I recommend the DestroyAllSoftware screencasts and Uncle Bob's talk: http://www.youtube.com/watch?v=WpkDN78P884
Yeah, and getting down voted for giving good advice! -_- &gt; Using factory_girl for the few integration tests you have, is probably fine, though I tend to recommend just doing integration tests with cucumber, as it tends to be cleaner imo. Integration tests with rspec tend to get big and hard to understand.
Consider the case of using bundler for two separate projects. One uses a gem e.g. geocoder but the other has no need for it. The first's Gemfile.lock would typically have a geocoder gem listed in it and this gem would typically be automatically required in the project (unless require: false is specified in the Gemfile. No need for gemsets so far. The second project, however, doesn't need geocoder but for some reason a developer wrote a rake task in which he manually required the geocoder gem. This works because the geocoder gem is already installed in the development environment and so can be required by any project within the same (global) gemset. This will fail in production where the two projects might not be installed on the same server and under the same account, thus the second project will have a failing rake task because it assumed (wrongly) that the geocoder gem will be available like it was in dev. The solution is, of course, to add the geocoder gem to the Gemfile with require: false as appropriate. Having two separate gemsets where they both share exactly 0 gems from a parent global gemset and are each independent of each other helps identify this problem even in dev because that rake task will fail to find the geocoder gem in its own gemset. I hope that explains it :-) I fear my explanation might not be clear enough so feel free to ask further. Perhaps I am mistaken in my assumption that gemsets are required here in which case, the questions will help me learn.
My morning routine on my Debian system (Dell XPS 16): $ sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade $ cd ../devs/rails/myproject/ $ git pull $ tmux $ ctrl-b c, ctrl-b c, ctrl-b c $ psql project_development $ ctrl-b 1 $ git status $ emacs spec/controllers/pages_controller_spec.rb $ ctrl-b 3 $ RAILS_ENV=development bin/rails s Go for coffee, reddit. 
Why $ctrl-b, ctrl-b, ctrl-b
&gt; Yeah, and getting down voted for giving good advice! -_- I don't understand the down votes either. You probably came across a bit arrogant or hit some kind of nerve? &gt; Integration tests with rspec tend to get big and hard to understand. That probably depends on the domain. IMO you can achieve fairly readable tests by using some well named helper methods combined with capybara.
oh sorry, it is "ctrl-b c" Opens a new window in tmux. 
Its a HAML/SLIM knockoff in JS
the only viable option for a windows machine
I'm just getting started with Ruby myself. I use a MacBook Pro and [rbenv](https://github.com/sstephenson/rbenv) to manage Ruby versions. Sometimes I'll edit a file in vim, other times I'll have the whole directory open in [TextMate](http://macromates.com/). I find [Railscasts](http://railscasts.com/) to be a pretty good resource--I'm sure you've come across it as it's even in the sidebar for this subreddit. For blogging, I have used Wordpress in the past, but now use [Octopress](http://octopress.org), which sits on top of Jekyll and can be deployed and hosted for free (I use Heroku, but you can even use a GitHub page).
This is exactly what I did when after spending many stress filled hours trying to get it to work on Windows. Works flawlessly (on Ubuntu).
Just learned about iTerm2, coming from a Linux dev environment toa newish mac user this is totally awesome!
I'm not the author but I work at OrgSync. What you're saying is exactly the path we're on. We have a fairly large app and we're in the process of slowly moving toward isolating our business logic (largely after watching those exact videos :) ). We're just not there yet. I suspect a lot of other companies aren't either. In the meantime this is something we tried out recently with some success and we thought we'd share.
**Profession** Full-stack Developer focused on Ruby/Rails/Sinatra (8+ years coding professionally) **Platform** 15" Macbook Pro (2008) with Mac OSX **Package Management** [Homebrew](http://brew.sh/) **Editor** [Sublime Text 2](http://www.sublimetext.com/) with add'l packages installed **Terminal** [iTerm 2](http://www.iterm2.com/) **SCM** [Github](http://github.com) and [Gitlab](http://gitlab.org/) **RDBMS** [Postgres](http://www.postgresql.org/) with pgAdmin **Resources I used for learning Ruby** * [Ruby Koans](http://rubykoans.com/) * [Programming Ruby (The Pickaxe Book)](http://pragprog.com/book/ruby4/programming-ruby-1-9-2-0) by Thomas, Fowler, and Hunt **Resources I used for learning Rails** * [Ruby on Rails Tutorial](http://ruby.railstutorial.org/ruby-on-rails-tutorial-book) by Michael Hartl * [Agile Web Development with Rails](http://pragprog.com/book/rails4/agile-web-development-with-rails-4) by DHH, Thomas, and Ruby * [The Rails Way](http://www.goodreads.com/book/show/18157961-the-rails-4-way) by Obie Fernandez **Additional Info** The tools I listed above are, honestly, what I spend 99% of my time in every day (besides the browser(s), of course). I don't think you need a lot of fancy tools to do Ruby/Rails development. In fact, you will rely more on Ruby Gems to help you be productive. Also, I am not just listing those resources because they are the most popular. I truly read all of those books (cover to cover, excluding reference sections) to learn Ruby and Rails and they are good. I probably learned the most from "The Pickaxe Book" as it provided an explanation of the fundamentals of Ruby that helped me understand how Rails was built. *Edits for formatting*
1. Macbook Pro with an extra monitor, running OS X 10.9, most tools installed with homebrew. 2. I do everything with Git on the command line, but occasionally I'll use gitx for viewing the history and partial commits. 3. I haven't used GUI HTML editors since the days of Dreamweaver MX 4. All editing is done in MacVim, and I'll have a split pane terminal with a command line and guard for running specs 5. I'll work through things in pry / irb 6. Codewars has some good stuff in the way of algorithms 7. The things I still struggle with are TDD - I usually end up writing tests after I think the code is done, unless I'm working on something outside of Rails that really demands it. Also, threads are hard! 8. StackOverflow can be really helpful, and very often browsing source code on GitHub will yield a solution Did you learn Ruby for a job? Did you learn Ruby for yourself? 9. Both. I wanted to get away from PHP (Wordpress, Drupal, Cake) and start contracting independently 10. Other than web apps, I use Ruby every time I need to write a script, or if I need a quick prototype/mockup 11. SXSW 12. No, all my open source contributions have been on github 13. Sure 14. Wordpress and Drupal have their places, but lately I've been using RefineryCMS. I'd also recommend Jekyll for smaller projects.
At the office: - Windows 7 Pro (begrudgingly and not for much longer) - Notepad++ with a few plugins - Use CVS for version control..migrating our codebase to svn - Phusion Passenger for production environment Our codebase is progressively being migrated from perl/cgi to rails, so it gets slightly more complex than that (apache, perl, etc.) At home: 2 Systems.. Slackware 14 on my sandbox and Kubuntu on my main dev box. Both have a similar setup for the most part. - Nano, Kate, or Sublime for text editing - Gimp or Photoshop CS2 (under wine) for artwork - SVN for version control... git once in a while. I personally do all my HTML/CSS by hand, but in my office, we have a design team...they use Dreamweaver. I'm not much for WYSIWYG myself, so i general stay clear of the IDEs and such. I had played with ruby a bit before i started at my job... mostly just basic scripts and such, but i had never touched rails before. I found rails slightly confusing at first, but then one day, it just sort of clicked. It was mostly confusing for me due to the way rails handles MVC, but once it clicked, it was like riding a bike. RubyGems also makes things incredibly convenient. I sometimes find that documentation is lacking for many gems, even ones that have become very popular. This is in contrast to Ruby/Rails themselves, which have tremendous documentation. One last tip is, if you take a test driven approach to rails development, you are likely to have a much better time overall. I learned this lesson a bit late, and it can cause headaches for a variety of reasons if you don't take the time to write good tests for your applications. 
Well said. Kudos on mentioning Pow. I hadn't heard of it. I'd love to know what your deployment strategy is like.
History: I've been writing code since I was 15. How I started writing code is kind of funny. I was in a chat room on AOL and someone came into the room and kicked everyone out. This happened quite a bit so I wanted to learn how they did it so that I could do it to them. Somehow I found a couple of private rooms where these people hung out (prøgs is the only one I remember). This was back in the VB3 days (uuggghh). That started on the MS side of things until PHP came out and then I was jumping back and forth between ASP &amp; PHP. .Net came out and I jumped over there (another uggghh). Eventually, the twisted nightmares that Microsoft induces took its toll and I wanted out of the business (burned out). Then along came Ruby... I was the kid from A Christmas Story after he finally got the BB gun... it was actually fun to code again... Now, I'm a code snob, like most Ruby developers, and I absolutely hate writing code in any other language. iMac Sublime Text 3 (regretfully, as 2 never crashed on me) iTerm2 Git Suggestions: Do NOT use IDEs.... in fact if it has a GUI where every important thing is clickable then stay away from it. I have this argument a million times a week and it gets validated every time one of those IDE users has to work directly on the server. Not to mention that there is nothing more annoying than "Hey, this code isn't testing right" and it turns out that it is their IDE config.... Try to build up your Github history as much as possible. I freelance as a recruiter and almost all of our clients check out the Github account before they look at your resume. One site that you should most definitely check out is codeclimate.com. And... I'm exhausted... 
Virtus: https://github.com/solnic/virtus
Great question! Branch management is pretty straightforward: Master should always be ready to deploy, so don't merge anything that's not fully vetted. (If you push something to master, and it breaks the build, you get a fail trophy.) The actual *act* of deploying varies for me. At work, men more talented than me have written robust [Capistrano](https://github.com/capistrano/capistrano) scripts to handle deploying production, demo, and stage environments with simple command line invocations. I highly recommend it. It is so choice. For my 2 main side projects, I'm learning the ropes on Cap myself (I have successfully deployed with it, but am still green enough to consider myself more of a Capistrano 'script kiddie' than a Capistrano *user*) Smaller, more "hacky" projects are usually hosted on a free Heroku instance, so the Heroku CLI handles the deploys. For projects with scope in between these two extremes, I usually just SSH onto my VPS, and "git pull remote master" directly on the server.
The Mac default terminal is awful. Especially with ncurses applications
You write in nano? Don't you find out it rather restrictive?
It seems like you set up your tmux session by hand every morning? Have you tried [Tmuxinator](https://github.com/aziz/tmuxinator)? I use it both for work and for personal projects and it is excellent.
&gt; I suspect a lot of other companies aren't either. I suspect the same. At least we aren't\* and almost every OSS rails project isn't either. \* I'm preaching against a wall while waiting for our specs to pass. -.- &gt; In the meantime this is something we tried out recently with some success and we thought we'd share. Thanks for sharing! I never knew `factory_girl` could be a major bottle neck, but it makes sense. I'll definitely know where to look next time I have to use it (my comment history).
why not write your own blog with Ruby?
also, no one's mentioned nitrous.io as part of their dev set up. it's essential for me when working from different machines.
A $15 usd a year vps ( secure dragon.net ), ssh, tmux, vim, git. This modest setup allows me to connect from any machine and connect without ever having to close my editor. I can switch from a mac, windows and / or a linux desktop my own or borrowed. Vim takes some time to get used to an you probably would want to install a couple plug ins for rails to be properly recognized. 
&gt; What is your typical development environment like? OS X, Textmate, RVM managing jruby and MRI 2.0, Chrome + Safari + Firefox. Apart from the version numbers, that's mostly unchanged since 2006. &gt; Do you primarily use git clones in terminal? I prefer the command line, and spent the time learning git's CLI but still have to jump over to stackoverflow for a bunch of rare flows (moving HEAD on a branch back to an early commit point is something that should be trivial but is one I *always* need to remind myself over). &gt; Do you use a web editor (like Coda 2 for HTML/CSS)? No, I always use Textmate in one window, browser in another. &gt; Do you use a text editor like (Notepad++)? Textmate, recently upgrade to 2.0-alpha &gt; Where can I learn about designing algorithms in Ruby? Algorithm design is independent of language and a whole subject in itself. Until you know better, learn patterns, do the Ruby Koans and start exploring the insides of gems. &gt; What are the things that you presently struggle with in Ruby? I lack the discipline to write tests first, but that's a problem I've had for years. I doubt I'll ever truly break that bad habit. &gt; What are some of the problems that you have had and how have you solved them? Being a programmer is about starting a day with 10 problems, fixing half of them and ending the day with 15 more. &gt; Did you learn Ruby for a job? Did you learn Ruby for yourself? I was a web developer (back-end) before, but was getting ready to leave the industry and go and do a law degree because I was getting fed up with it. Ruby changed that. &gt; Do you often use Ruby in your personal life? If so for what? It's my first language of choice for all projects, personal and professional. &gt; Can you explain forking? You take somebody else's repo and make a copy of it and now there is there repo and your repo. You make changes to your copy and ask for those changes to be merged to their copy (a pull request). That's it. &gt; Can you recommend a blogging platform? What do most people use? I've recently started to use squarespace. I like it. http://www.p7r.io if you're interested. &gt; Is it more common to write your own page? Do people use wordpress? Should they be using wordpress? If we interested in using the same tools as everybody else, half of /r/ruby would be in /r/php and the other half would be in /r/java - the fact that we like exploring different ways of doing things and understanding that there might be utility in going off the beaten track and using a less-explored route that is a little tougher but pays dividends if you put the effort in is how we ended up here in the first place.
Don't forget [Fedora](http://fedoraproject.org/), it's a stock distro with reasonable up to date packages.
&gt; For example, when I try to read someone else's code, I never know what I'm looking at. It may just be terrible code. Look for things that follow SOLID principles, shun metaprogramming without reason, and whenever you come across a library, think how you'd implement it *without being a jerk*. If the code in question manages to roughly achieve similar goals without being a jerk to you, it's probably OK. 
Im interested in learning! Can you tell me how you would work with people whom have full time schedules?
The idea is that people can work through the exercises at whatever pace/ times suits them. I'll be available on IM/ Skype/ email for when there are questions/ support needed. But there's no specific schedule which has to be followed. I'll suggest a rough timetable at the start which will aimed at people who have full time schedules (I'm guessing most people learning do) but it's entirely optional!
This is really awesome! I'm not your target market but I'll mention you to folks.
Not at all! It does syntax highlighting, is and is very very quick to call up, make a change, save and close. I wouldn't use it as my only editor, unless it was a small project, but its absolutely my most used editor overall.
Cheers, could you drop an email to ben at talkingquickly co uk just so I've got everyone in one place when sending out more info later?
This looks pretty interesting. I have friends who have offered to do pair-programming and such, but they would never take a dime and I've felt that I would be a burden by asking too much of them. I think $50 is very reasonable for someone to put together a short project list and provide support for you while working on it. Out of curiosity, do you know approximately how many hours per week this would require? 
Will you cover test driven development? (Rspec, Capybara, etc.)
Not at this stage no, I think TDD is awesome but too much of a learning curve to start off with. I know quite a few people who started the Hartl rails tutorial and got bogged down with understanding the tests and given up before they'd really made anything. Not criticising the Hartl tutorial, it's awesome and was my first Rails resource but I wasn't a dev/ ruby beginner at that point. Edit: should also clarify I'm not comparing this to the Rails tutorial, there will be very little, if any, Rails focus in this.
I'd guess 3 - 5 hours per week, depending how much (if any) prior experience and what the 7 group chosen exercises end up being. Entirely up to the individual really though :) I think the $50 price point is feasible for something like this if you get to the point where there's actually very little support needed because of the quality of the materials and learning environment. At the moment it'll be a long long way from profitable but should be an interesting experiment! 
Emailed and can't wait to start!
I have been working with Ruby professionally for nearly 6 years. My development environment consists of: 0. A Mac. I deploy to Unix environments and OS X gives me a nice desktop I don't have to screw with all the time. I have other Linux systems but generally I don't develop on them. 1. Textmate 2 2. Terminal 3. Homebrew (for Unix packages) Everything else is application specific. Sometimes I use Sequel Pro for sifting through MySQL data, otherwise I use the terminal for everything else.
But vim does all that and more! :P Sorry, my inter fanboy is showing
is this an interview question?
emailed!
Thaks for Capistrano tutorial, by the way
glad it was useful, really like V3 but was a bit of a learning curve since the docs are still pretty sparse
Firstly, be careful with your terms. 'Interprocess threading' is not a thing -*threads* are multiple concurrent execution contexts within a single *process*. To get you started, here's a stack overflow question about signalling between threads: https://stackoverflow.com/questions/534919/ruby-thread-programming-ruby-equivalent-of-java-wait-notify-notifyall I think the easiest way to do this is to use a shared queue, similar to the one used here: https://stackoverflow.com/questions/6558828/thread-and-queue One thread runs ICMP pings, and writes the site name to the queue if the response is an even number. One thread attempts to pop content from the queue, sleeping when there is none. This is a producer/consumer model, which lends itself well to the problem you're trying to solve. 
Is this for beginners or individuals with a preexisting programming background but just not in Ruby? Thanks!
Oh awesome. I'm a beginner, excellent. Thank you! 
I'm interested
Great stuff, could you drop me an email to the address at the end of the post?
Email just sent. Thanks! 
The potential business here is really interesting. I had a similar idea a number of years back - A consulting firm of engineers who specialize in various fields (specific languages or frameworks, 3rd party services and APIs, cloud infrastructure, application deployment strategies, etc.) and who offer support and guidance for other engineers. There is **a lot** to work out to turn this into a business, and it gets really weird when you start to try to set pricing plans and limitations on how much help is available. Is it based on support hours? Are there things that are outside the scope of the contract? It can very easily turn into just another contracting gig, though your clients would (hopefully) generally be easier to work with considering they'd be engineers themselves.
Linux + Java + JRuby + Vim.
Hey! I sent you an email about this earlier... I'm very interested in this, awesome idea!
It sounds like you've got a sequence of statements that you'd rather have split-up into objects. You seem to already have an overview of the structure - read, process, write. I'd be inclined to draft an API for those objects in a TDD style - i.e. using the objects before you've actually written them. You can then start building-up the implementation as you go. Indeed "refactoring" means changing code without changing it's functionality, without tests it's very difficult to say for certain whether you've done this! Putting constants into YAML allows you to abstract the configuration. If you don't expect to re-use the script with a different config it might be easier to use module/ class constants for now.
Maybe this isn't what you're looking for, but have you considered [Sequel](https://github.com/jeremyevans/sequel) to manager your SQL statements and database connections?
I'm not familiar with how RedmineCRM works as compared to regular Redmine, so my advice is going to be a little handycapped in that regard. As far as getting Yaml into a database, just do some Googling for "parse yaml ruby" and for most data migration jobs I use Sequel gem - http://sequel.jeremyevans.net/. I'm not sure which table these notes would go into (assuming not tickets), and how they might be related to your contacts, so figuring all that out is the job. You can most likely do all of this with one mighty Ruby script. Let me know if that helps. Also, go slow. Managing the connections between whatever records are in that export is the key to this going well and not going well. Take your time to make sure you get that all right.
OS: Linux or OSX. I prefer Debian to anything, but OSX on a laptop in general. Ruby version: I prefer MRI 2.1.0 (latest MRI), although I've used everything from 1.8.7ee, JRuby, etc. JRuby is a good option if you have existing JVM deployment infrastructure / hosting; otherwise, MRI has gotten faster. Rails: 2/3/4, the newer the better. Git: yeah git... command line. Usually I like zsh for my terminal emulator. Also tmux is a must. Editor: vim with a couple plugins (NERDTree, Ctrl-P, Exuberant Ctags, some syntax-specific stuff for ruby/rails, and ruby-focused-unit-test) Testing: rspec usually, or minitest I use ruby personally and professionally. I maintain [stylr](https://github.com/yaaase/stylr), a tool for keeping ruby source aligned with the github ruby style guide. I dig ruby a lot.
Bare SQL statements (create tables, views, ...) I tend to do the simple and obvious. I take them completely out of the ruby and drop them in a .sql file of their own. Nicer to edit (Emacs understands sql and ruby, but not rusbqly.) Easy to understand. Fast. A module of config constants is not a bad idea. Yaml is niceish. But so you have SQL and Ruby and you're planning on adding another almost sort of language, yaml. Ask yourself, do you really need a third language? What does it give you the others don't? Try not to do "everything in one program". Multiple independent programs is sometimes A Good Thing if you have a good dataflow / time boundary point to cut things.
I hope I didn't miss the boat on this -- it looks like it's right up my alley. Email sent!
Hi Ben- Emailed you earlier, just thought I'd post as well for a follow up. 
The following perl will also do it: find . -name \*.\*rb -exec perl -p -i -e 's/([^:]):(\w+)\s*=&gt;/\1\2:/g' {} \; 
I don't think so. At least, he has not mentioned anything on twitter about it.
Damn. I'm interested, but I'm on my last semester at uni and I'm taking a coursera class in android development, on top of a p/t job... I don't think I'll have time.
Too bad ;(
this is one of the very few times I accidentally laughed out very very loud... nearly fell of my chair. true story! 
I want to learn! Is it too late?
Why can't we just use ruby to test ruby instead of using some insane DSL
As you find you find yourself needing to write more and more complicated tests, you find yourself falling into certain patterns. If you study those patterns, you'll find a lot of duplicated code and structures. So you refactor the structures out into their own library and you discover that the remaining interface could be written a lot more efficiently if it was structured as an internal DSL. Thus Rspec. I really like rspec's new `expect` syntax and think it's an accessible starting place for people who want to write assertion-style tests... but then rspec has a lot of power under the hood if you really want to nerd out on it (like composable matchers, which I have to admit kinda excite me because I recognize a lot of the "you've written code like this" that they help make more efficient and readable). That being said, touching some projects that use minitest is a refreshing change of pace.
First of all, nice goal. There are already good input in the previous posts. Of course, it is difficult to help without the code. If it is a personal project, why don't share it as a gist? We could then comment on it. In between: * Externalizing your parameters in a config file is a good idea. Yaml is sort of the de facto standard of Ruby for that, with good parsers and a very easy conversion to Ruby hashes, so go for it. It is a language as much as a property file is a language, so I would not worry about it. At least it is a common format that you don't have to parse yourself. This config can then be stored in a Ruby object that would be passed to your various classes. * Get your IO part separated, meaning: have a MailParser that parse the info out of the mail and output it as Ruby objects, and a DBWriter that get your object and issue the SQL. The code in between is your business logic (if any) that do any kind of conversion of work your datas require * Try to test each part independently. Getting all together will be easy afterward, so get a clear goal about what each part should output and test it. Have fun, don't hesitate to ask more specific questions if needed.
Theres been way more interest that I expected so going to run several groups over the coming months so if you were interested in joining a later group just drop me an email :)
its certainly an alternative even though not that flexible. 
That does not work. The `t.join` causes your main thread to wait for t even when t2 finishes earlier. You should use a construct that allows you to wait for 2 threads simultaneously, not serially.
notbad.jpg
How many different databases are you planning on having? If it is a non-dynamic list then use YAML. Otherwise, just store the path to the db parent folder in a YAML and store the actual file name in your master database. As far as your SQL statements are concerned: If you have a big list then you're going to want to have them organized in a more manageable way. This may be a great time to exercise your meta programming skills in ruby. Store them in a YAML or master level db and categorize them into tags -sql_statements --select ---- email_lists: 'select emails.id, emails.address,...' ---- email_attachments: 'select attachments.id, ....' --update ---- email_list: 'update blahblahblah...' then you can dynamically generate a class based on that yaml and do something along the lines of emails = SqlStatements::Select.email_list(*args) success = SqlStatements::Update.email_list(id, *args)
Neat! Looks a lot like [Mutations](https://github.com/cypriss/mutations), which inspired us at [OrgSync](http://www.orgsync.com) to write [ActiveInteraction](https://github.com/orgsync/active_interaction). Interactor doesn't validate the inputs (the `context` hash), so it seems to me that they are just functions. Organizing them is nice, but a little limited since they can all modify the context.
1. You should add a Gemfile listing the gems that your project requires (bundler) 2. You could add a .ruby-version file to specify which version of ruby your app works with 3. I haven't been able to get the mp3 files to load with gosu, and I think this is a known problem, so I would reccomend converting them to WAV. (Using Gosu 0.7.5 on Linux) /usr/local/rvm/gems/ruby-2.0.0-p353/gems/gosu-0.7.50/lib/gosu/patches.rb:28:in `initialize': File contains data in an unknown format. (RuntimeError) from /usr/local/rvm/gems/ruby-2.0.0-p353/gems/gosu-0.7.50/lib/gosu/patches.rb:28:in `initialize' from /home/eric/proj/starfield/app/classes/ship.rb:19:in `new' from /home/eric/proj/starfield/app/classes/ship.rb:19:in `initialize' from ./starfield.rb:38:in `new' from ./starfield.rb:38:in `initialize' from ./starfield.rb:235:in `new' from ./starfield.rb:235:in `&lt;main&gt;' 
Are you using OSX? If so make sure you terminal is launching bash --login instead of just bash.
Really nice offering! Thanks for open sourcing this. My feedback: It'd be nice to clean up the interface: Fedex::Client vs. Ups::ShipClient, ups.shipment_request vs. fedex.request I'd expect to be able to .send! or .ship! on either client object. Also does this schedule pickups? That's a little unclear. 
I can't upvote this enough. If you want a book that covers Ruby in depth, look no further than this book. It covers stuff thats in Metaprogramming in ruby and Eloquent ruby (to some extent). After that I'd recommend "Design Patterns in Ruby"
Yeah, that was feature request #1. I'm working on it! :)
You willing to post a github link or something? I'd be interested in seeing your code.
Cool! It's worth waiting for interest. You can keep it in mind and deprecate later. With UPS you can schedule a pick up to arrive at your home/office if you don't have regular pick ups. It's part of their workflow on their website. Sounds like it's likely not the norm for the API, probably a different call. 
Neat post, but it didn't really get into the "how" at all, did it?
if you're using Capistrano 3: run_locally do execute 'scp user@host:remote_path local_path' end should work (from memory). Last time I looked at SSHKit &lt;https://github.com/capistrano/sshkit&gt; (which cap 3 is built on) the lack of a download files dsl was on the known issues list. Out of interest why is it necessary to generate the GPG's remotely, then download them and put them into version control? Usually anything that's in git can be generated locally and dealt with by deploy scrips and the reason for generating things remotely is that you don't want them checked into version control (e.g. they should be unique to the servers). Purely out of interest as sounds like you've got a use case I haven't come across before!
Hello, For the connection, don't open/close it each time. Ideally, find a lib to do it properly for you (someone advised Sequel which I never used but heard a lot of good thing from). That could help avoid stupid problem. If you are inserting 10k+ records, normally you should "page" them - insert let's say a page of 500 in one SQL order (check http://sequel.jeremyevans.net/rdoc/classes/Sequel/Dataset.html for example). Inserting one by one would be inefficient (but again, it may work well enough, so keep it simple as long as possible). To know the last email read, don't you have the information in your DB? I would suppose you would store some kind of reference to the email (sented, date, whatever make it unique), to be able to link back to the original email. I would have message having a link to the attachement too (as a file handle). The database could then store the link (file/folder or anything to be able to retreive it. Enjoy,
does that still gel with with this comment by him then? &gt;That's not a problem as long as everyone requires gems using load-path-relative require statements (e.g. `require "my_gem"` rather than `require "path/to/my_gem"`). Ruby's `require` is smart enough to not re-require a file when it has already required a file with that exact name.
Thanks for sharing! Labels would be a great addition
Yes, and no. Unless you want to specify the path to require each of your gems from, which would negate a lot of the benefits of Bundler, you'd still get stuck with regular "require". But frankly, Bundler has all the dependency information to offer alternative ways of loading the gems anyway. I do agree with using require_relative for anything you have direct control over the path for, though. EDIT: Note that regular rubygems is almost, but not quite, as bad. Bundler adds everything to the $LOAD_PATH at once, I believe, while rubygems adds them the first time you require them so you don't pay the cost as early, but many apps still get hit hard. Frankly I consider the way Rubygems and Bundler mangles $LOAD_PATH to be a severe bug. 
Of course you shouldn't use require_relative for the main entry point of the gem. But the gem *should* use require_relative to require its own files. Your app: require 'foo' In foo.rb: require_relative 'foo/database' require_relative 'foo/extensions' require_relative 'foo/version'
I'm worried about this pattern encouraging bad design. The dependencies required for an object to solve a problem should have a strong, cohesive relationship with the problem itself. Need to ship a package? I need an address, a user, a tracking code, and a package. The dependencies flow naturally out of the problem we're solving. Containers like this seem like an easy, low friction way of tacking on a bunch of unrelated objects together to solve a problem. And it seems like they can introduce indirection through container classes whose identity is defined by their role as a container, rather than their responsibility. Reading through this gem example code, it looks like a great way to clean up a lot of the garbage ruby code I've seen, but I see less value when a good design starts to emerge. I'm actually curious as to what this pattern is for? Is it to provide a clean way to introduce things like logging that are a requirement but not really core to the problem?
Call me spoiled, but I came from CVS and SVN. SVN has *the* best interface . Documentation is clear and concise. The commands work exactly like you you expect them to (no `git reset` doing something totally different from `git reset --hard` nonsense, or `git push origin :branch` to delete a branch by "pushing nothing to a remote branch"). No strange, hard-to-grasp terms like "refspec" that require multiple paragraphs of unclear explanation. The interface is well-designed, compared to git which feels like a big wrapper around its implementation details. While the latter is clearly powerful, I would not call it a well-designed interface.
&gt; Out of interest why is it necessary to generate the GPG's remotely Really good question. The problem I ran into was with the gpg --import. I was using Chef to push the keys out, but the problem I ran into was with the import command. It would simply not work because I couldn't figure out how to run gpg in unattended mode. It seems without having an existing .gnupg directory in the user home, the whole thing just breaks. edit: totally open to new suggestions. My logic in my method is probably flawed anyway.
Wow, so it finally happened. Someone wrote an IOC framework for Ruby. Java is dead, all hail Ruby.
Are you asking about what this pattern is for in terms of this particular example, or in terms of IoC containers in general?
Some sites such as [RubyDoc](http://rubydoc.info/) will download copies of gems to generate documentation. My guess is that there are several other types apps that serve documentation, analyze gems, generate statistics, etc. that are contributing to the download counts.
This is kind of what I thought :/ lol
I'm with you. I've had many lost afternoons where something stops building right and after a bunch of grief I discover an explicit require had gone missing (especially in places like spec_helper or someplace where there is a lot of interacting pieces). The common reply of "well just try harder" or "pay attention more" is bad because that's exactly why I build tools and automation: so I have to pay attention less to details and focus more on features and my business goals. I don't care if directory lookups take a long time, because my computer's time is much cheaper than my own. As for startup time, use spork/spring and poke at stuff in Pry. 
I got 30 downloads at each push of my little gem ...
BTW, this is an even better list: https://www.ruby-forum.com/topic/4419918
Rubygems.org has a web hook system for integration with other sites. Every push of a new gem results in hitting those web hooks, which typically go download the gem and analyze it. Thats where you get the initial bump of downloads from.
Book.recommend do Eloquent Ruby end
works great! thanks!
That's just fantastic. I signed up last month, and now I have a $60 credit. woot!
Thanks, just signed up and used the credit.
I must have just missed this, expired for me.
expired :(
I hate how there was only a $5 code when I signed up 
Expired
Worked for me at 5:52pm CST.
Thanks for the recommendations. And you are absolutely correct, it doesn't have to be ruby specific. But I am mostly working within Ruby so if there are ruby tricks, I would want to know. Even if it's just syntax sugar.
I made a site that actually allows me to see which are the open source repos on GitHub that are using (my) gems. http://gigest.herokuapp.com/ It's not real time and works by crawling gemfiles on GitHub, but I haven't run the crawler in a while and so the data is stale. I'll be picking up the project again in Feb and will update the data then.
The official documentation on the Regexp class is very well written. http://www.ruby-doc.org/core-2.1.0/Regexp.html
hmm, interesting, have you tried the batch mode and ask params from here: &lt;http://www.gnupg.org/documentation/manuals/gnupg-devel/GPG-Configuration-Options.html&gt; ? Otherwise I guess maybe you could just have a skeleton generic ~/.gnupg generated by chef?
Expired
Interesting, thanks. And thanks for the issue - fixed and pushed ;)
Dependency injection != using containers like this. A good design manages dependencies well, and ruby, being duck typed, makes it trivial to inject mock objects, openstructs, etc. into the code you're trying to test. Looking at the examples, why couldn't every single use of `needs` be replaced with `attr_accessor`?
Damnit. I applied a $10 credit to my account like 4 months ago. fug DD:
Wat?
&gt; Looking at the examples, why couldn't every single use of needs be replaced with attr_accessor? True. This is why Encase is actually implementated with *attr_accessors* for each of the declared *need*. As I understand it Containers like this are the standard way of doing IOC. This specific implementation is heavily inspired by PicoContainers. And while Ruby does lend itself to easier manual dependency injection, it isn't always suitable to do so.
Seems cool and fun, but I can't find a relevant use.
How do you recommend handling this config file in source control? Seems you'd have to check it in to realize the value of the defaults, but then the production values (possibly sensitive) would be checked in as well. Thoughts?
From the readme: "Settable was created out of the frustration of missing a config setting in an environment file, or constantly duplicating YAML keys for different environments. Settable helps make your config "safe" by always having a default value..." [Dotenv](https://github.com/bkeepers/dotenv) is a fantastic tool for this sorta stuff - you can provide defaults, example files with dummy values (that are checked in), cascading/environment-specific config files, etc. and it encourages proper conventions when it comes to not having to check sensitive data into your project repository. edit: fixed my markdown link
I'm a huge fan of Dotenv. I use it in my rails apps and sinatra apps for exactly this purpose.
I'm interested. Are any slots still available?
I'd be down for that. Nice book, BTW. I'm looking for some samples.. I grok chef at a decent level, but getting into LWRP stuff scares me just a bit. Wasn't doing really that back in with puppet.
&gt; If there is repeating code in your tests means there is repeating code in your application. Have you ever written an application before? Repeating code in your tests can have a number of causes including repeating code and the way your application handles different kinds of objects or input.
I haven't tried dotenv, but I have used Figaro which seems similar (only using a yml file). I'm a huge heroku fan and do really like using ENV for config. This project started a while back when I needed some other data types in my config (things like arrays/hashes) which wasn't possible with what I saw at the time.
No it doesn't actually. I hate to admit it but I didn't know about configatron when I wrote this (and even worse, until now). It is a nice library and my gem does a lot of what this does. And it reminds me of hashie which I like. *edit* As for why switch, theres no great answer, they are very similar. One difference settable has is environment matchers which support any custom logic you may need (overriding by rails env, or by your server ENV, or any other custom logic). Another may be that you can use this in any of your application classes for its own personal config that can be exposed.
it's just for fun!!! remember to have fun!
I do need more fun in my life. the feels Nicely done, bud. 
I tried using an array in the YAML and it came into figaro as a string. It could be because I used ENV and not Figaro.env - I will have to try again with the latest version.
There is a `download!` method in the SSHKit DSL now https://github.com/capistrano/sshkit/blob/v0.0.34/lib/sshkit/backends/netssh.rb#L82
My lord, what a dick. There are so many problems with this. - It's an honest debate about who should provide secure defaults for OpenSSL. The ruby core devs made a strong argument that the upstream library should be fixed, because then *everybody* wins going forward. - This guy seems to be upset that they didn't merge the patch in after 4 days. Ruby is a volunteer project; 4 days is not an unreasonable amount of time for debate. - The ruby devs *agreed* to merge in the patch until such time as OpenSSL fixes up their side of things. What more could you possibly want? I really don't understand the level of butthurt from this guy's email - is he upset that the ruby devs don't agree with him that it's really their problem (despite agreeing to work around a flaw in the upstream libraries)?
What I do is create a "settings.rb.example" file or something of that nature, and putting the actual configuration settings in my .gitignore
Your login with Twitter feature seems to be broken.
I agree with this comment. I think the core devs have very sensible arguments for why they should not be in a rush to apply this guy's patch.
Good find, will submit a pull request to update the known issues
A few quick comments for you: - Instead of your method "is_numeric" just use dimensions.is_a?(Integer). - Would put flickr_config_path in extra_options as currently if you want options but not a flickr_config_path you have to add a nil to call, which is messy. - Instead of 'add_dimensions' (a String) I would use :add_dimensions (a Symbol) so it is clearly a different class of object (and also won't stop you if you really want to put the text "add_dimensions" over it). - You are calling a lot of things with strings, which is a bit messy. Do you need to call it like this? E.g. for dimensions - why not use an Array like [300,400] rather than a string like "300x400". Why pass your 'subject' as "color:f00" when it could be [:color, "f00" ]. Perhaps your subject should be two separate arguments rather than one. - Building on the above point, although its changing things somewhat, the better way to do this whole excercise IMO would be to actually have 3 classes - PixelHolder_Color, PixelHolder_Gradient and PixelHolder_Flickr which can all have their own arguments (although be subclasses of PixelHolder and share functionality). You are making a mountain out of a molehill by trying to have the same arguments for all of them - it could get messy if there are errors.
Thanks heaps. I'll have a greater read into your feedback a little later on this week. A lot of what I have done has been hacked together... The original project I worked on was a Sinatra app which went straight from URL parameters to a generated image and when I went through the code today I kept a lot of the old structure. I'm really excited about learning Ruby and improving my skills as a whole. You rock!
&gt; These are real issues with viable, known-for-many-years attacks against them. then &gt; It's now been 4 days uh...
As a guy with more of a background in crypto than in Ruby (which I've been enjoying for only three years or so now), I agree with Mr Hodges. &gt; The time for private disclosure is over. 1. A problem is known. 2. Feasible, appropriate actions on the part of the ruby-core team would sharply mitigate the vulnerability. 3. Ruby and Ruby-based projects had a very rough 2013 wrt security; being proactive here when techniques and adaptable code are already in the wild would be at least reassuring to management, not all of whom is technical. 4. Other language/platform advocates can point out comparisons of their respective security stances, building on (3) in what is already an uncomfortably fashion-aware industry. I could go on, but why bounce the rubble once it reaches the consistency of sand? (And 4 days is a *long* time in Internet-security years. A competently-tasked botnet should be able to infect a *significant* percentage of susceptible targets in that time; don't those targets zt least deserve to know that there's a relatively fresh bullseye painted on their back?)
Hooks, mirrors, and every push is tweeted to multiple accts.
Aye, the Twitter OAuth is broken for me as well.
Haven't read this book myself but just learned of it yesterday: http://confidentruby.com The description sounds like it can be helpful to you in refactoring your project.
Some ideas somewhat similar to *OstapBenderBey*. * When modelling classes try to use Single Responsibility Principle(SRP). This means ensuring that your classes/objects do one thing only. * Canvas style applications like this tend to work very well by thinking of them as tangible objects * A good way of doing this is by building objects like *Painter*, *ColorPainter*, *GradientPainter*, *ImagePainter*, *TextPainter* etc. Each of these objects would take a paint method like *paint(canvas, options)*. * Regarding configuration/options, another way of going about this is to formalize the options into a *Config* object that contains default properties and *attr_accessors* for changing them. That way it is clear what options the painters take. * Another advantage of using a *Config* object instead of a hash is that the *Painters* can then decide what properties to use from that *Config* object. Eg:- *TextPainter* would lookup a *text* property. * PixelHolder class would then become a bootstrapping class that roughly translates into, class PixelHolder def initialize # create config object # switch case to choose painter and create it # painter.paint(config) end end Breaking things out into such objects helps with things like composability. Eg:- You could decide to paint a border around each of the painters. Instead of changing stuff in every object, you can create a *BorderPainter* that wraps your other painters. * Use [Bundler](http://bundler.io). Bundler is similar to `Composer` in the PHP world. It helps manage dependencies in ruby projects. For Eg:- If *flickr-fu* released a new version that is incompatible with your rubygem, it would also break for all your gem users. Bundler helps lock down these dependencies. 
It'll be hard for folks to submit clean pull requests unless you follow the de-facto ruby standard of two space soft tabs. I would introduce a `Dimensions` object to your class like this: class Dimensions attr_reader :width, :height def initialize(width, height) @width = width @height = height end end You'd be surprised what creating an object like this does for your code design. Little classes like this can become "magnets" for extracting methods out of your main class. And your initializer looks like it could use some method extraction; clocking in at ~75 lines of code, I have a really time following it. Fortunately, creating classes that encapsulate a small amount of related data is so common in ruby that there's a handy tool to do it easily, `Struct`. Rewriting the above `Dimensions` class: Dimensions = Struct.new :width, :height If this is pretty new to you, feel free to stick to the above example rather than the `Struct`. The key here is that you can start to move the logic for parsing your inputs and arriving at a width and height into a class method on `Dimensions` so that the initializer stops being responsible for that messy argument parsing. Also, as another poster alluded to, your initializer goes off on a pretty big, confusing mission when it figures out what to do based on the `background_type`. That suggests that different types of backgrounds ought to be different objects. I'd like to point out some suggestions for how to get there: Turn each of the case statement clauses into a method. So go from: when 'gradient' gradient_colors = subject[1].split(',') if gradient_colors[2].nil? || gradient_colors[2] == 'v' end_x = @width end_y = 0 else end_x = 0 end_y = @height end fill_content = Magick::GradientFill.new(0, 0, end_x, end_y, get_hex(gradient_colors[0]), get_hex(gradient_colors[1])) generate_canvas('000', fill_content) to: when 'gradient' generate_canvas_from_gradient(subject, dimensions) # much later in the file, outside of the #initialize method def generate_canvas_from_gradient(subject, dimensions) gradient_colors = subject[1].split(',') if gradient_colors[2].nil? || gradient_colors[2] == 'v' end_x = dimensions.width end_y = 0 else end_x = 0 end_y = dimensions.height end fill_content = Magick::GradientFill.new(0, 0, end_x, end_y, get_hex(gradient_colors[0]), get_hex(gradient_colors[1])) generate_canvas('000', fill_content) end Notice I also stuck in the `Dimensions` object into the example. This is to show that I was able to use one less parameter, making the method signature a little simpler to understand. Now we've got a method that carries out a single task. I'm still not super thrilled about that subject parameter, which is an `Array` (or maybe `String`?) whose format is completely incomprehensible to me if I'm reading just this method. And that's the key to maintainable code -- help me understand what you're doing in one specific place even when I haven't yet grokked how it all fits together. Once you've got all three of the `case` statement clauses extracted into methods, they're easy candidates to then extract out into objects. The good news is that you've got a nice, simple test suite that will help you break up that big 'ole `#initialize` method confidently, knowing that the gem as a whole still works. Keep making small improvements one at a time, always validating changes against your tests. Strive for shorter methods (10+ LoC methods are a smell), and don't let classes get too bloated. All public instance methods of a class should, when combined together, tell a good story about what your class does. Hope this helps, and thank you for contributing to the community!
Does it work on Windows? That's one thing Bluepill has over God.
Why do ruby programs have the most unimaginative names?
Localhost
Their example is nice, but it shows wrong usage of thin. Thin can run as a cluster: &gt; thin start --servers 5
[Heroku](http://heroku.com) is easy and free for your purposes.
that may be so that eye can monitor each thin process individually. 
Here are a couple of links to her work: Blog Series on Regular Expressions in Ruby: https://www.bluebox.net/insight/blog-article/using-regular-expressions-in-ruby-part-1-of-3 Talk from RubyConf on Regular Expressions in Ruby: http://www.youtube.com/watch?v=JfwS4ibJFDw 
If you're just looking to get your practice web sites up on the internet then you really can't do better than the free tier on heroku. It's quick and easy to get started: - Register at: https://id.heroku.com/signup - Get your first app deployed: https://toolbelt.herokuapp.com/
Eye don't have to monitor each process individually, Thins master manages that just fine.
Yep, pretty much that.
Better? Meh. Is JS an increasingly necessary skill for a web developer? Yes. Absolutely with the rise of thick client web apps and node, etc knowing JS and being able to effectively work with the JS toolkit is very valuable. -- is Ruby/ outdated. Nope. Is Rails bloated? That's a subjective question, it is a huge toolkit that provides me and many people a tremendous amount of value. One can write apps with ember, backbone, angular and have those apps backed by rails on the server and enjoy the best of both worlds as well.
Heroku's free option is undoubtedly the easiest. It's probably a good idea to get an actual server (or VM, or old-computer-in-your-basement) and throw linux on there (ubuntu 12.04 is easy and reliable) and learn how to set it up from the ground up though. It's not terribly hard. If your rails code is in a git repo, just git clone to the server box and install phusion passenger. Then (assuming you're port-forwarding 80 to the box in question from your router, or assuming you're using a bona-fide cloud hosting solution otherwise) you can manage your own server for fun* and profit* and the learning experience of doing it! *not so much fun probably *not so much profit probably
Monit is great, but it can't auto-daemonize processes IIRC.
Great post! You must have put a lot of time and effort to create your own curriculum. Wish you the best of luck! I'm actually doing something similar but with Rails Tutorial, not that great to make my own curriculum :) I'm going to drop this here because I think it's relevant. lmk if you think it's spam i'll delete it from the thread. . http://www.reddit.com/r/learnprogramming/comments/1vjtgf/learn_better_by_forming_study_groups_to_help_each/ 
[process supervision is a solved problem](http://jtimberman.housepub.org/blog/2012/12/29/process-supervision-solved-problem/)
I'm interested. How do we get started?
Further, try to monitor mem use of workers in a DRY fashion. I love monit, but it's bad for this use case.
This is more of a daemonization tool than anything else.
But it can't scale like bulimia.io.
Fun fact: there's a web ui for God called Jesus
PM me who you are and why you want to learn :) I'm excited! I'll give you more direction and steps there.
I knew about the Pathname class, but I continued using Strings out of sheer laziness. I'm *definitely* going to start using Pathnames now, though. The traversal methods alone will be a massive benefit.
Thanks for the write up! I didn't know about the Pathname class. Will definitely be using this the next time I'm working with paths.
Same here. The Pathname class looks very useful. Thanks for sharing! 
Yes! I'm well underway coding up the GUI. I plan to release the app in the second quarter of this year.
Didn't knew about this, looks really powerful! Thanks for sharing!
Pathname is also [slow as balls](https://github.com/sstephenson/sprockets/issues/506). Cutting out some of its slower bits sped up Sprockets by ~25% for me.
Definitely worth thinking about, although that looks like a particularly extreme example.
Well, given that Sprockets is in use in basically every Rails app ever, I don't think it's all that extreme. `Pathname` is substantially slower than similar `File` methods or string munging, and while it's definitely more correct, blind usage of it can end up imposing pretty massive performance penalties. If you're using it just a couple of places, not worth worrying about. But if it's in a lib that's going to be doing a lot of path searching, it might better to optimize a bit and avoid using it.
I agree entirely — just saying that most people aren't going to be calling `Pathname.join` 4,000+ times in their scripts' execution. Sprockets by its very nature is a special case.
Another gem posted, with no context, and a readme that doesn't show any use cases or demos. What's the use case for the gem? Applications which used an older Rails version, then upgraded to a Rails version that broke backwards compatibility with migrations? 
A deployment of an application was running on an old version and it needed to be upgraded. When I tried to run the migrations they failed because they were dependent on code that no longer existed. I wrote this gem to automate the process of finding pending migrations and their respective commit hashes and then running each migration with the repository checked out to the commit it was created in. I thought this was clear from the readme, please let me know how I can improve it :)
Just a tip, try to format your code examples to avoid horizontal scrolling. This should be especially easy since you're using a fixed width layout for your blog. It's really annoying to read when I have to scroll for nearly every code example. Line breaks are your friend.
 dir = nil path.ascend { |f| dir = f and break if f.basename.to_s == "some" } That's actually one of my bigger gripes with `Pathname`... Gee wouldn't it be great if that worked like literally every other iteration method, returning an iterator if no block was passed, and we could use `#first`?
I wrote a gem Statify that gets you mostly there: https://github.com/Spokeo/statify
Yes, absolutely. It's bizarre and annoying, to the point that I'm contemplating writing a gem to fix it!
Only two of the code samples scroll at full-width, and even then not by much — sometimes it's unavoidable, especially when highlighting "what not to do", and especially when you take smaller screen sizes into account (it's a fluid layout).
This is what annoys me about Pathname: irb(main):003:0&gt; Pathname.new( "/tmp" ) + "/foo" =&gt; #&lt;Pathname:/foo&gt; This makes it quite fiddly to replace existing string-based path manipulation for Pathname, because you've got to go through everything and strip any leading slashes out. I can't think why it works that way, but it does.
trying with this gist : https://gist.github.com/raubarede/8520431 with http://4r2r.github.io/opal-robots/#8499891vs8520431 found error in console: NameError: uninitialized constant Object::Gistfile1 index.js:2543 
Thank you! Never heard of TSort before, and it actually solved a long time problem of mine.
Awesome, this completely solves the problem so I no longer need to avoid using models during migrations! Great idea!
Thanks! Please let me know if you run into any issues.
ok, that work !!
I'm so sorry, but I have to respond with a youtube video by the creator of Git. http://www.youtube.com/watch?v=4XpnKHJAok8
Just go here http://www.pairstudying.com/
I ended up getting a vps with ramnode.com and setting it up was definitely a good learning experience, at first it was really confusing haha
I didn't think about that. That was just my thought process, "why don't you make a test-driven railscasts", I plan on changing the name, especially when I launch a dedicated web site.
And what do you think about Opal? Nice or not?
Don't forget the classy ass Padrino logo. Dat glass. Dem cubes.
&gt; Never heard of TSort before You should know that tsort has been available on Unix systems since the 1970s, and so is also in Linux and Mac OS X, and via popular *nix packages like Cygwin (and others), is also available on Windows. The point being that it is handy and available outside of Ruby as well, e.g. for CLI scripts.
I would say it is nice. Sometimes missing methods here and there. Rare syntactic issues like you have to do spaces around the hashrocket or you cannot do something like `FOO, BAR = 1, 2` with constants. But meh, nothing I cannot fix so far.
Ruby 2's stdlib is finally intuitive enough that I rarely need the docs. `to_&lt;goal&gt;` all the things!
Doesn't seem to... y'know... *filter*. Which, when I think about it, is exactly how ActionController before_filters are usually (ab)used anyway: run this shared bit of code before a couple of other methods so that they have an instance variable when they render a template. Very rarely do I see a before_filter that actually could halt processing of a response (the original intention of the feature). All of this says to me that this is an anti-pattern. If it's important that something happens before something else in a method, call it in the method. If you're doing that a lot, it sounds like your class is trying to do too much and should be composed from smaller ones. If half of your methods need one filter and half need the another, that's probably two different classes.
I downvoted for the following: There seems to be an increase on "fluff"[1] blog posts in ruby related subreddits recently. [1] Meaning short, pretty content-light / free, blog posts which basically say "X is good" then link to an established source for X without really going into much depth. 
haha thanks for that :) If you would like to be part of the first learning let me know. I am still looking for 3 more individual for the group.
So what I wound up doing is basically creating different lwrp recipes that granted access based on roles and recipe. So all my nodes have a networking::recipe-name and in the default rb I basically say all nodes that fall under this recipe hAv access to one another based off the rules set per service in the recipe
Great stuff, raw, but great. It might be nice to chop some of the actual writing out, and providing code, people will still be able to follow along.
It could probably just redirect to [semver.org](http://semver.org/).
Actually, the proper name now is #before_action, etc. #before_filter is aliased to that for backwards compatibility. (It still works the same and terminates on render.) https://github.com/rails/rails/blob/master/actionpack/lib/abstract_controller/callbacks.rb
And don't get me wrong, I love Thor. I just based a recent project on it (shameless plug: https://github.com/yock/forte), but writing a new cli app every time I need some bit of project automation just doesn't make sense.
That's right. The other day I realized I wasn't unit testing when I go to the bathroom, so I hooked a raspberry pi up to a mechanical hand positioned exactly where it needs to be to pull the flush handle. Needless to say, once I got ruby installed, I fired up `gem install rspec` and wrote a quick test for my commode. Seriously, folks, if you're not testing *everything*, you're doing it wrong.
I still use rake. Thor seems cool, but advertising it by implying that all the "cool kids" have moved off of rake seems silly. Especially when you're main line of reasoning is that you can't write unit tests for rake tasks. [lewis]I seriously feel like taking a pencil and stabbing into my face[/black]
hmm, the little things you pick-up like checking if a symbol is empty results in string allocations. Didn't know that.
Unfortunately app.to_money doesn't seem to be implemented :(
I'm not sure marketing it using the Railscasts name is a great idea. 1) Railscasts is virtually dead. Still a valuable and known resource, but, he hasn't actually updated the site since June 16, 2013. 2) I second the question of what do you mean keeping Ryan Bates accountable, I know I'm probably in the minority, and I don't know what personal issues or burnout he's fighting, but, he seems to have given up on accountability at this point. 3) Your video is long and seems to lack a clear direction other than possibly 3 words describing what you're building as a link blog app. Given these things, I guess I'm just not your audience. I don't find the voice distracting and honestly tend to suspect you have alternate reasons (shy, hate your voice, etc) for wanting to avoid the running commentary during the video. It'd be helpful if you even just had captions explaining what the purpose of what you were doing next is. Anyone that -knows- what you're doing next, obviously doesn't need your video, and anyone that doesn't know, isn't gonna know it's important until long after you've done it unless you explain why. Overall, I think it's nice that you have a goal and that you're trying to monetize a talent, but, if you wanted me to consider this an option in building my career as a developer you've got a ways to go before you're as useful as Railscasts or Ruby Tapas for example. I wish you the best of luck, but as is, I was not able to gain much out of your video nor was it able to keep me watching to see what you were going to do. Additional comments, I found the video on it's own with lack of direction incredibly hard to follow and pay attention to. There were long unneccessary pauses on parts that didn't seem to matter, but, of course I couldn't know if they mattered because of no commentary or communication during the video. I did -NOT- appreciate that nothing was explained, it's like watching someone paint. It can be fascinating, but only if you have an understanding of the subject in the first place. As something you're pitching as an alternative to Railscasts, that means this fails big time. I was able to anticipate some of the things in the video, but as I've stated before, with a lack of direction or expectation beyond your three word description of the app, it wasn't interesting enough for me to sit there for an hour and a half. (I also get the idea that the video was indeed almost twice as long originally?) Did it occur to me to pause and research more to understand... this one is difficult to answer only because, yes it did, but because of failings in your video offering. You're wanting to charge money to get other people to do all the work for you is the message I get from this. I just want to be in the spotlight, painting, whereas you get the joy of watching me paint. I don't really care to tell you why I'm choosing this brush or these strokes, go look it up. As I said way back, good luck with your offering, but, I will be waiting to see of what comes of this and if there's any particular subject of value or interest to me that would require me to endure one of your videos before I chose this as a source of investment in my skills. 
There's a point where you have to realize TDD borders on religious zealotry. Test what makes sense to test, no more. Pragmatism over Dogma, always. 
After 9 months of development, it’s now time for Codesake::Dawn security source code scanner first major release. Codesake::Dawn is a static analysis security scanner for ruby written web applications. It supports Sinatra, Padrino and Ruby on Rails frameworks. Version 1.0 introduces 142 security checks against public bulletins since 2006, you can use to check the vulnerabilities introduced by third party libraries your web application include in its Gemfile. Writing safe code it’s important, but sometimes security issues are introduced by third party code your application relies on. As example, consider a SQL Injection vulnerability introduced by Ruby on Rails framework. Despite the effort you spend in sanitize inputs, your web application inherits the vulnerability suffering as well. An attacker can easily exploit it and break into your database unless you upgrade the offended gem. There is a comprehensive set of command line flags you can read more by issuing dawn -h flag or by reading project README file. The list of security checks included in version 1.0.0 can be found online at: http://dawn.codesake.com/knowledge-base. You can use facilities provided by github to submit bug reports, product enhancements, new security checks you want to me to add in future releases and even success stories. Now it’s time for you to install Codesake::Dawn version 1.0.0 with the following command and start reviewing your code for security issues: $ gem install codesake-dawn Enjoy it! Paolo - paolo@codesake.com
I've updated the post to try and provide a bit more evidence why I think this is an anti-pattern. First, Rake tasks are code and any code worth writing should have unit tests. If Rake is "just a task runner", why not bypass Rake entirely and *just* execute the desired class? That's *exactly* what Thor is for. Thor tasks are plain old Ruby objects. There is really no reason to add the extra layer of Rake in order to invoke your actual logic.
It's easy to miss, but you're looking for mutating method: `app.profit!`.
Good point. I actually didn't know that, but I think that speaks to acceptance of use-creep. I still think it's a bad pattern.
On a 1680x1050 monitor with chrome filling the display, 6 of your examples scroll horizontally. I assume when you say "full width" what you actually mean is "full width for a desktop monitor". On my phone, this code requires a horizontal scroll to view: path = Pathname("/etc/hosts") Let alone the rest of the lines.
Were you trying to run all migrations from the beginning? This is generally not done, that's not really what migrations are for. Normally I would use: rake db:schema:load Does this gem solve a problem that can't be solved with db:schema:load?
The little information it provides is inaccurate as well, as [Ruby does use semantic versioning now](https://www.ruby-lang.org/en/news/2013/12/21/semantic-versioning-after-2-1-0/).
no, it doesn't unfortunately, at leas not the Semantic Versioning described at [semver.org](http://semver.org) If you read the page you linked to you will see that while they call if Semantic Versioning. It blatantly isn't. Hint: "MINOR: increased every christmas, may be API incompatible" Still better than the old system though and it was *inspired* by Semantic Versioning... but it is not Semantic Versioning and I think they should stop using the name since it is confusing. (Although, to be fair, I do not think Semantic Versioning is the best option for an actual language.)
*sigh* it seems you're right, I hadn't even read the description as I assumed it to be SM. Unfortunately it seems most of the time the ruby core team have no idea of what they're doing, have they not even read the description in semver.org? 
it's expensive, you just can't beat http://lowendbox.com/ :P
Why not just call it Dawn? The gem name is available and it's a much better choice. 
If you have enough functionality in a rake task that it needs tests you're probably doing something wrong. Rake should be used as glue for a library, not as an implementation language for a library. When you separate the interface from implementation you can test the implementation independently of rake. Your rake tests only need to test wirings and dependencies which is very easy. Your implementation tests don't need to worry about rake which is very convenient.
But they're not plain old Ruby objects, they're Thor objects. Ruby objects don't have the same restrictions as Thor objects. Method visibility doesn't matter for plain old Ruby objects. The methods you can and cannot override are more relaxed for plain old Ruby objects. Can you use a Thor library/command line application as easily as a library composed purely of plain old Ruby objects? Probably not due to the way Thor interprets the visibility of your methods. This tells me "skip Thor, go straight to implementing a library, then provide an API for it using Thor or Rake tasks when it works and is tested".
pre-2.1.0: [arr1, arr2, arr3][ rand(3) ]
[Array#sample](http://rubydoc.org/stdlib/core/1.9.2/Array#sample-instance_method) was introduced in 1.9.
I think you're misunderstanding the use case here, but understandably so. It sounds like the actual problem is that folks are using their models in their **schema** migrations to handle **data** migrations at the same time. This means that as their application evolves and their models change, there may be methods or attributes that no longer exist being called on the models in these migrations. Maybe they want to start storing a value that previously was being calculated on request, so they might have something like: add_column :things, :new_col, :integer Thing.all.each do |thing| # they're probably doing something more complex than this thing.new_col = thing.calculate_something # method defined on the model end If someone is cloning and setting up the application for the first time, and that method is no longer defined on the model, or has been renamed, etc., the migration will fail with a `NoMethodError`. Sometimes this data manipulation might make sense in your seeds file, but the better way to handle this in my opinion is to abstract the data migrations into rake tasks, which can be called optionally and only if needed (if you're migrating existing data, vs trying to setup a fresh database with your app's schema). edit: accidentally used github flavored markdown
It's a bad pattern for general use, for sure. It's an unfortunate necessity for Rails controllers, whose public instance methods generally route straight to HTTP endpoints. I would hate working on a project that co-opted before_actions as a design pattern; it was a workaround to begin with! All that magic of `actionpack` definitely doesn't come for free, and sharing behavior between controller actions is one a biggest hidden costs, IMO.
TIL!
We've got some apps running Ruby 1.8.7 and the sample method works there...
these aren't floats, that's just an approximation. They are [Rationals](http://ruby-doc.org/core-1.9.3/Rational.html). e.g. MusicNotes[2] should be Rational(4,3). If you *really* want shorthand, `'4/3'.to_r` would give you shorthand to convert that specific one. `MusicNotes = ['1', '3/2', '4/3', '1', '16/9', '15/16'].map(&amp;:to_r)` or even succincter `MusicNotes = %w(1, 3/2, 4/3, 1, 16/9, 15/16).map(&amp;:to_r)` Then you can do `MusicNotes[2].to_f.round(4)` That answers your immediate question. But if I can give you some design hints, this doesn't look like proper OOD. **MusicNote**s seems to be suggesting there's a hidden object here, maybe a MusicNote object?
You have helped a lot. This is nowhere near proper OOD. I am just trying to write a little script to run a bunch of commands for a program called SoX.
OOD?
Also worth mentioning that arrays do not have a `#split` method.
Something you might find quite useful: decimal literals in Ruby 2.1. note_durations = [1r, 1/2r, 1/4r, 1/8r] These are rationals, so 1/2r + 1/3r would yield 5/6r and not 0.8333(3).
Or maybe it's because we're using REE. I hadn't considered that previously.
It's part of ActiveSupport, so if you're using Rails, that's where it comes from. http://apidock.com/rails/Array/sample FWIW, `Array#choice` existed in 1.8.7 but was renamed to `Array#sample` in 1.9
It already doesn't suck With things like [trollop](https://gitorious.org/trollop)! However this is a good addition since it does things in almost perfect reverse of trollop (minus constraints). More choice is good even if things do not currently suck. 
I used this here: https://github.com/openSUSE/scanny/blob/master/bin/scanny#L7 :)
&gt; the return dictionary will be:: The python is strong in you ..... :-) I remember seeing a python lib that did something similar, like readme driver command opt parsing.... 
By using "r" suffix like in "1/3r", you tell Ruby you want 1/3 stored as "numerator 1, denominator 3" and not a float 0.33333. Then you can do all kinds of arithmetic operations on the rational numbers and get the rational numbers back.
This is a good point. I put all the security related opensource ruby code I wrote in the years under the Codesake namespace. I'm using it to build a saas platform: codesake.com
Personally, I like Trollop.
bingo--that must be it!
Thank you, aldanor. I am actually using these rationals to generate pitch in the just scale rather than the equal tempered scale. You "just" have to always know what scale you are in. I want to see if it makes a difference in the musicality of melodic passages.
&gt; I remember seeing a python lib that did something similar, like readme driver command opt parsing That'd be [docopt](https://github.com/docopt/docopt), the python library this one is inspired by. :) 
Good! I was waiting for docopt to be ported to Ruby, finally somebody stepped up. For my less complex needs I tend to use [Clap](https://github.com/soveran/clap) though, but I'll keep this in mind next time I need to do something CLI-based. :)
It makes sense. I'll consider your suggestion. *UPDATE* And just in case I takeover dawn and dusk rubygems name
[].methods.sort might also be helpful to see what things array has available out of the box.
good point. I was just trying to be descriptive
Is it production ready? I am still thinking about creating MVC library in it.
Because the `1` is an object, the `/` is an arithmetic operator, and the `3` is an object. In your example without the parenthesis, you're calling those methods on the `3`, not on the result of the operation. I'm guessing your confusion comes from the rational making the equation seem like it "should act like it's own object". I'm not 100% clear on how rationals work, but my guess is that it indicates the 3 is a denominator,as opposed to applying to the whole equation, then when the 3 is used in the equation, the rational logic is applied - similar to `1+2.to_f` - which adds the integer `1` to the float `2`, as opposed to adding `1 + 2` then applying `to_f` on the result. Maybe someone else can speak to the inner workings of rationals.
Correct. If you were to break it down, you want something that is evaluated like this: `( (1) / (3r) ).to_f` But without the parenthesis to dictate what you want, you end up with something more like this (I've added parenthesis for illustration): `( (1) / (3r.to_f) )` Again, I'm not totally clear on how the rationals are applied, and someone might be able to correct me, but I think my guess above in my previous comment is pretty sound based on the illustrated behavior. edit: wording
Update: It's at v0.0.8. Messed up and made the dependencies dev instead of runtime.
I'm very tempted to forward you to the Pickaxe book, lol. The dot (method call) in Ruby has the strongest precedence, so a/b.c == a/(b.c) Also, Ruby methods cannot start with a number so 3.7 does not create any sort of ambiguity and (3).7 yields a syntax error.
The Pickaxe book? Is that the book where they write down your name for asking stupid questions and then hit you with a pickaxe?
This looks moderately useful!
Whew, glad I wasn't the only one who used trollop. I'd like to see both of these successfully live on happy and fulfilling lives since they are complements.
I've been very impressed by thor or trollop
Seriously though, I've been learning Ruby for less than a month so I'm no expert but I do know all the stuff you're asking about. Google "Ruby Pickaxe" :)
http://pragprog.com/book/ruby4/programming-ruby-1-9-2-0
Well, I am glad my utter stupidity is making you feel good. :)
I tried Trollop and it was awful. Not sure why. Probably that I'm a python dev trying to code in ruby. lol. 
Take your pick: [RVM](http://rvm.io/), or [rbenv](https://github.com/sstephenson/rbenv), or [chruby](https://github.com/postmodern/chruby).
Just one objection? Few people seem to dislike the fact that there aren't any verbal commentary. Personally, I'll keep it as is.
This can be achieved with [chruby](https://github.com/postmodern/chruby#readme). chruby_use /path/to/installed/custom/ruby Additionally you can build custom rubies with [ruby-install](https://github.com/postmodern/ruby-install#readme): ruby-install -p mypatch.patch ruby 1.9.3 
Chruby is your friend here.
chruby doesn't interfere with rvm right?
From your other comment it looks like you're using RVM. Assuming you're using actual .patch files, you can use RVM's built in patch support: http://rvm.io/rubies/patching
Hey I know this feeling, I would encourage you to step back from "learning mode" and start practicing. Think of some game or program you want to write and write it. You might encounter something along the way that you don't know, so look it up. If your totally void of ideas do some of the suggested "off track" stuff on code academy or learn about the language from another source to solidify your knowledge learnrubythehardway is a good resource
You may want to check out the side bar in /r/rails/ - it has a few good reference/tutorial sites listed.
It's been a while since I launched a new gem, and I was just thinking "geez, I wonder how people are doing it these days". Perfect timing!
I like it. 
Might want to check out [Rails for Zombies](http://railsforzombies.org/), but to echo what /u/jbfbell said don't spend too much time on courses and tutorials. Get a feel for the basics and start working on a project...pick something small that interests you.
Thank you, I'll update everything.
Definitely start with Sinatra first rather than Rails. Really more useful and cooler than the other way around.
Rails for Zombies is a great start. I'd hit http://ruby.railstutorial.org/ after that.
Take a look at Michael Hartl's Rails book. http://ruby.railstutorial.org/
I found that book to be a bit challenging coming straight out of Codecademy. You probably don't know anything about using your own computer for web development (instead of an online compiler) yet. I'd recommend starting with this http://cli.learncodethehardway.org/ Then, you might like this tutorial http://learn-rails.com/learn-ruby-on-rails.html I'm only partway through it so far, so I can't guarantee that it will continue being awesome, but so far it's made much more sense to me, as a beginner, than any other tutorials I've tried. It was designed specifically to be a stepping stone to the Hartl book.
Is there a Ruby scraping library that can handle Javascript?
Capybara or some other browser control tool would work
This looks cool but the last commit on that project was 2 years ago... I think I would still use http://mechanize.rubyforge.org/
Try the "Well grounded rubyist" book. It is great. Not rails though.
Will you promise to share the data on here? If so I'll do it
I am on day 2 of your emails. Excited to complete this weekend. 
I'd have to take it up with the student, I don't imagine there'd be any problems sharing it and it's something I *want* to do. But since the data isn't mine, all I can promise is that I'll try my best to share it, but I don't want to make you a guarantee that I will and end up not being able to uphold it. I'll talk to the student and see how she feels about me sharing the data back to r/ruby. I'll get back to you with her response.
Upvote for Michael Hartl. That guy is doing a huge service to the Rails community by keeping that tutorial free and up to date. The fact that you can view the entire book as a single page makes it a great reference once you finish the tutorial, too. I look back there often to peek at code snippets as a means of refreshing my memory. I think it's best used as a companion to another project instead of just creating the Twitter-esque app he goes through in the book. I got a lot more out of it by adapting Hartl's solutions to fit the needs of an app I was working on at the time.
It already has one https://github.com/opal/vienna#readme
I don't know sorry, I only use it every now and then for simple scraping. 
Great to hear! Let me know how you make out.
I'm commenting here to check later. OP was Bitscraper.
How much is the book?
Does god still suffer from memory leaks? I always preferred to use monit for this kind of stuff
I'll take it 
Why not Zoidberg?
Haven't decided on pricing yet. I'd be interested in your feedback on the subject though.
How does this differ from a tool like active_attr?
Chris has done great work on ActiveAttr and there is some overlap but the approaches differ. ActiveAttr is great for building non-persisted ActiveModel like objects. ActiveInteraction works more like a function. Business logic is placed into the `execute` method and called with `run`. That limited interface is designed to guide you toward writing smaller, more discrete chunks of code.
Ask under r/ruby.
Rails is cool, as jrmehle recommended, use Michael Hartl's Rails book to start, then just try building something. The free-tier hosting over at Heroku should be more than enough to get you started with something basic but fun.
personally i love the free book, paid screencasts model... but with regards to pricing a book, i really have no idea. You could could start cheap in the start/launch and raise the price as time goes forward. That way you might be able to track conversion rates and identify a price point that people are willing to pay.
So the goal is to enforce the pattern? Could one achieve the same thing with a #run method on an ActiveAttr?
You wouldn't get all of the benefits (like transactions and composition), but that would get you about half of the way there.
Ah okay.. Hence the create! in the example, I take it anything that raises in execute will rollback and mark it as invalid?
Got it, thanks for clarifying!
As much as I like Ruby, god always felt kind of strange. To me, monit seems more stable, easier to configure, and easier to debug when processes go wrong. Edit for humor: So, I guess you could say, I don't believe in god.
You can totally get recursion if you use the "stabby lambda" syntax of Ruby 1.9. [Demonstration](https://github.com/threeifbywhiskey/narfnme/pull/1/files).
I don't know why I assumed that Tom's approach would only work if everything were encoded using lambdas, but this totally works, and it's damned cool. I was scratching my head trying to figure out how to get a Fibonacci sequence going using the `seq` approach and an empty array, which is made unfeasible by the fact that all variables get reinitialized for each line. Using recursion, it should be a snap, so thank you for the insight I was looking for. That said, do you reckon there's any way to acquire a Float under the non-alphanumeric constraints? I need a 0.5 to get the square root of 5 for the [closed-form expression](http://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression), but I'm not sure it's possible. Still, I missed the clever solution to FizzBuzz, so perhaps there's something else I've glossed over.
 5 ** (2 ** -1) should give you the square root of 5.
Something to consider in your quest to remove all responsibilities from your `ActiveRecord::Base` models: http://www.martinfowler.com/bliki/AnemicDomainModel.html
i don't know why, but this video makes me sick.
Are these worth it to go to? My work would pay but I would still be using my time.
I've backed the project - I think it's amazing!!! 
I paid $12 for [Everyday Rails Testing with Rspec](http://everydayrails.com/) and it was one of my favorite books of 2013. I paid $15 for [Exceptional Ruby](https://shiprise.dpdcart.com/cart/view?referer=https%3A%2F%2Fshiprise.dpdcart.com&amp;product_id=14808&amp;method_id=13853&amp;__dpd_cart=4a0f709e-387d-4a4c-a53f-317153e9f7ee) and it was also totally worth the money. I spent $25 on the the 2.0 pickax book and haven't looked at since the week I bought it. I'd much rather see a light-ish book that is opinionatedly linear (telling me how *you* do it, not how everyone under the sun does it differently) for under $20 that's followed up with good blog posts and the promise of future books of similar quality. You have a great blog and good writing voice, and the outline looks solid, so take my money (in the $11-$19 range, please).
I agree. The downvote mechanism should be used more heavily in these cases. Also, There is bad advice everywhere on reddit. And honestly this is isn't much of a problem if you just use simple common sense. You should be researching who your authors are, see the code they have contributed to open-source, and see if they are well known among your community. Heck look them up on twitter, and see if they have a decent following. Basically, just use your brain and make good judgements for yourself. If someone is willing to pay for Joe Schmoe's Rails 4.0.2 tutorials without ever hearing about them or doing their own research, well then that's their problem, just like you aren't going to stop grandma from clicking on banner ads for "THESE 5 NATURAL PRODUCTS THAT PROMISE TO CURE CANCER -- ORDER NOW!"
Then please suggest a similar book.
The example does make it look a bit like we're advocating for anemic models. That isn't quite the case. Work that is completely specific to a model can live on the model. Often models collide and in those cases interactions can help tie the two models together without burdening one or both of them. Additionally, there are times where the model changes behavior depending on the context. For example, an model might have different validation depending on the permissions of the person saving it. An admin might have more flexibility than a normal user and thus fewer validations. Handling that on the model can be awkward. Using an interaction to tie a model to a specific context can clean up the situation.
Popularity never means quality, at least to me. Again, if you are using popularity as a metric, instead of doing any form of preliminary research ( as something as simple as typing in the authors into google), then good luck to ya. 
You shouldn't be using the number as a metric at all. There's nothing stopping someone from SAYING they have 10,789 users when really all they have is 2. Whether the number of people is paid subscribers, free code users, trials, or just made up it shouldn't be a basis for the quality of a product.
A fool and his money are easily parted. Caveat emptor.
Right. How about this one. Ever heard this one before? "Product A is 85% *more effective* than when compared to the *leading* brand"
Probably more work-style than opinion. I tend to make heavy use of the Ruby docs directly (via Dash.app) and Google (mostly searching phrases like "jeweler vs bundler" where I'm trying to find an opinionated approach to a problem rather than the nitty gritty details of a component). I really liked the Everyday Rspec book because it was simply "this is how *I* do it", because then I can have an internal dialogue when reading between how I've done it and how they're doing it... Rather than having the author play all those parts and I just read all the "you might do this or that or this" and still end up confused as to which is good enough for my (probably not-unique) situation. Anyways, I don't mean to imply my way of learning and my taste in programming literacy is the only way (or even particularly good taste). I'm working my way thru "Design Patterns in Ruby" but "Confident Ruby" is next! 
Another excellent deduction, of course. I seem to have forgotten my high school math. Still, nobody in #ruby-lang could come up with a way to even get a `Float`, so I don't feel *too* silly. Using your pair of awesome contributions to this adventure of mine, I wrote the [CFE Fibonacci](https://github.com/threeifbywhiskey/narfnme/blob/master/fib_cfe.rb), but of course the numbers get printed as `Float`s. You've helped more than enough already, but I wonder if you could pull a hat trick and figure a way to emulate `#to_i` to remove the decimals. JavaScript has the `~~` trick for flooring, but alas, Ruby doesn't allow bitwise operations on `Float`s.
That being said all self promotional posts are [on thin ice](http://www.reddit.com/wiki/faq#wiki_what_constitutes_spam.3F) on reddit in order to combat spam. Now I don't really have an opinion on the subject, but if you see the posts OP is referring to as equivalent to "THESE 5 NATURAL PRODUCTS THAT PROMISE TO CURE CANCER -- ORDER NOW!" then you should support the ban.
I don't like it when any commercial enterprise comes to a programming reddit looking to make money. It takes the focus off of learning and idea sharing. On the other hand "remove questions that belong on stackoverflow" is dumb, and so wildly open to interpretation that it is better to just let the community decide with their votes rather than try to come up with concrete rules.
I know, but Vienna is only basic. I mean something like Ember or Angular.
Because proficient Rubyists wouldn't need this, and the noobs wouldn't be able to rate the (presumably low) quality of the service adequately?
I completely agree; my comment wasn't about your examples, though, but about this approach in general. I have played with building task oriented user interfaces using this type of command pattern, and it can be really fun when your domain models aren't easy to shoehorn into rails' "resource" paradigm. But if you use it where it doesn't help too much, you end up extracting out all the important meat of your models. An example for when this kind of approach is great: building an e-commerce checkout flow. Consider these requirements: 1. The shopping cart can be updated after the credit card has been authorized, so you may need to re authorize before you purchase. 2. This might be the users' first purchase -- if it is, they can go through the whole checkout anonymously, but enter an email/password at the end. 3. The user has the option to pay with paypal *or* through your own credit card form. Rails has this notion of a "resource," which is kind of a collection of behaviors that you fit your models into. In the above example, you'd have to fit a important logic into janky callbacks, weird special cases, and conditional logic. In this case, it's much nicer to build objects that represent the tasks that the user is trying to carry out, and separate them from the underlying business logic. In fact, I'd go so far as to say that when you start smelling too many callbacks, look to use a command pattern. Same goes for "states." For example, "I only want to apply a free shipping credit when the order is finished authorizing, before we capture the funds." Sometimes those "states" are better represented as different UI tasks. Anyways, I'm bloviating... I did not want to disparage your very cool looking gem, but to point out a flaw that can start to emerge when you abuse the pattern.
From someone who has asked questions before as a beginner, who didn't get help when asked on Stack Overflow, and didn't come up with an answer using the horrible Reddit search function, I apologize for asking a group of Ruby developers a Ruby question on a Ruby forum. I'll try not to let it happen again. I'll stick to posting articles from blogs you probably already read anyway.
How about this then... Open source education. Come up with a curriculum, then have various members of the community teach that lesson, in their words. Create a reddit or stack overflow style upvote system for the best videos for that lesson. Then is a student doesn't get the lesson, they can look at the second most popular video or any of them for that matter. Whats great about this, is that most people don't have time to devote to an entire curriculum, but they could probably chip in on a single 20 min lesson. Thoughts?
I jumped into that book with just codeacademy and did just fine. It was confusing, but once I got the basics and everything really came together once I built something on my own. That is the key. You can read and do tutorials like crazy, but you will never actually understand something until you go and work with it yourself, at least in my experience.
&gt; isn't a forum, it's a discussion board. Splitting hairs much?
As I said, I must have misunderstood what this subreddit was for. Most other subreddits welcome questions from developers, regardless of their experience level, so it should come as no surprise that I thought incorrectly that this was a place where one could come for help. Perhaps I should turn to paying mediocre developers, if the experienced crowd isn't willing to help out.
You may want to look at [Ruby Shoes](http://shoesrb.com/).
I use ocra at work to compile my ruby scripts and their dependencies into an .exe http://ocra.rubyforge.org
This looks great! Any idea if there is something like this for osx?
&gt; On the other hand "remove questions that belong on stackoverflow" is dumb I wouldn't call it "dumb". Stackoverflow is designed for asking and answering questions. Its user base is much larger than this subreddit and stackoverflow posts are usually ranked pretty high on google (in fact: I never found a single reddit post when looking for ruby related content). It feels like a waste of time asking or answering questions here if somewhere else a much larger audience would benefit from it. (I'm talking only about questions which clearly "belong on stackoverflow".)
It is, because: A novice may not know that what he's asking is a common question. It may be phrased in such a way so as to make searching difficult. Also, it's stupid because then you're getting in to a situation where you have to draw the line between what is an acceptable question, and what is an unacceptable question. What criteria defines an acceptable question? Depending on who you talk to, a question can go from "reasonable" to "unreasonable" in a hurry. So, who gets to decide where the bar is set exactly? I realize some questions may feel like they're beneath you, but nobody is holding a gun to your head to answer them. As experienced programmers, we really need to try to keep in mind how much we take for granted compared to the guy who is just getting his feet wet.
Package it as a web app or json-based web service. 
I dunno the right way to do it, but you could test them out with eval, rescue SyntaxError, and set a variable true or false. Then you can do an if/else during method definition. Don't forget about ruby 2.1 required keyword args not available in 2.0. Something like this: https://gist.github.com/benolee/f436b34732cd5201f498 Bad idea?
Fantastic write up. Thanks for this. 
Ah hah, and taking my gist further, here's a cleaner version which conditionally requires the API layer: https://github.com/dogweather/versioned-api
Yep, that's essentially what I did here: https://github.com/dogweather/versioned-api/blob/master/versioned_api.rb#L26-L32
What about tutorials / guides like what Micharl Hartl did with his Rails Tutorial where there is a free HTML version and the paid versions are only if you want ebooks, screencasts, or some other premium?
If you're writing a gem, you can have the gem load different versions of the gem, depending on the ruby version. This is an easy way to do it, but pretty un-dry. It's probably best for legacy projects.
That's a very nice idea. You should remove the `is_` from the method names to be more ruby-style. 
http://macruby.org/
#####&amp;#009; ######&amp;#009; ####&amp;#009; *Here's a bit from linked Wikipedia article about* [***RubyGems***](http://en.wikipedia.org/wiki/RubyGems) : --- &gt; &gt;**RubyGems** is a package manager for the Ruby programming language that provides a standard format for distributing Ruby programs and libraries (in a self-contained format called a "gem"), a tool designed to easily manage the installation of gems, and a server for distributing them. It is analogous to EasyInstall for the Python programming language. RubyGems is now part of the standard library from Ruby version 1.9. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/dwahyudi can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**Summon**: wikibot, what is something?) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/ruby/comments/1w3h96/can_someone_explain_ruby_gems_to_me/ceyeb4c)
some litle correction on your post in iterating array with index section. the printed result should be begin from "0" not "1" . so: 1. Ned 2. Catelyn 3. Robb should be 0. Ned 1. Catelyn 2. Robb thankyou,
You claim that the for loop and the each iterator have an important distinction, but researching the docs tells me it's really the same thing, just syntactic sugar. [source](http://ruby-doc.org/docs/keywords/1.9/) Edit: Found it. It's a matter of scope. For elem in array doesn't create a new elem variable every time the loop is run and attempts to use a local elem variable if it already exists. array.each do {|elem|} makes a new elem variable in the scope of the block no matter what and a new one each time the block is iterated.
Gems can also be standalone executables, just a convenient way of installing a program to use.
Warbler
God was the first ruby monitoring framework I used. Later on, I switched to Bluepill (https://github.com/bluepill-rb/bluepill) and now I'm looking into Eye (https://github.com/kostya/eye). Look into them and decide ;)
Good post and I understand it is for new Rubyists, but including Enumerable in Bookshop is a big no no. [This post (http://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/)](http://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/) does a good job why you should have returned an enumerator.
This is so fucking useless.
I don't know about the GUI, but to package it you can use [omnibus](https://github.com/opscode/omnibus-ruby). It might be a bit overkill in this case though, I don't know you and how quick you can pick up these things.
These sorts of posts are ridiculous. This is a *community* moderated forum. Let the *community* decide. Anything else is just control-freak rage. Sure, it's ok to be frustrated, and your opinion counts, but trying to dictate content is a fool's errand.
If macruby is overkill, there is also [platypus](http://sveinbjorn.org/platypus). Macruby is what you want if you want to make and package an actual GUI app. If you just want to double click and run a shell script, maybe with a simple prompt, platypus will do the job.
Enumerable is why I fell in love with Ruby.
One of the best things I ever did when learning ruby is implementing the highlights of Enumerable. Like given &lt;=&gt; and each implement sort, or reduce, or map, etc.
The point is to be simple. Not everything has to be some grand masterpiece of programming to be useful. On the subject of testing, I can get some up a tad later today.
Try https://github.com/Spooner/releasy for all platforms.
1. Write your program in terms of a Ruby library (`lib/&lt;name&gt;.rb`). 2. Implement `lib/cli.rb`. 3. Add `bin/&lt;name&gt;` and `bin/&lt;name&gt;.bat` with the sole task of calling `ruby &lt;parent&gt;/lib/cli.rb`. 4. Upload to RubyGems. 5. Document how to install the gem, in terms a non-Rubyist would understand, in your README. 6. Push to GitHub. Like so: https://github.com/mcandre/specs
Is ends_with? and end_with? a 1.9x and 2.x distinction?
I'm the author of several code analysis tools and I approve of this message.
I also had a hard time reading this because of the site's layout. Here's the post in comment form instead. **Symbol#to_proc with multiple arguments: A hidden power-feature of Ruby** &gt; In Ruby’s syntax, putting an ampersand (&amp;) before the last parameter in a method call causes a to_proc method to be called on it and the result to be used as the [block](http://phrogz.net/ProgrammingRuby/tut_containers.html#blocksanditerators) for the method invocation. Originally, this was largely used for storing blocks as Procs inside the method, and then turning them back into blocks when calling another method. &gt; Ruby 1.9 added a to_proc instance method to the Symbol class, known as [Symbol#to_proc](http://www.ruby-doc.org/core-1.9.3/Symbol.html#method-i-to_proc). The implementation of this method causes the object yielded to the block to have the method named by the symbol to be invoked on it. For example, let’s say that we have an array of floating-point numbers and we want to find the closest integer value for each: numbers = [ 1.23, 4.56, 7.89 ] # In Ruby 1.8 nearest = numbers.map{ |n| n.round } # In Ruby 1.9 nearest = numbers.map( &amp;:round ) &gt; This allows for code that’s easier to type, easier to read (once you know what you’re looking at), and is generally better. &gt; Today, however, I found out that it is even more powerful. If more than one parameter is passed to your block, the proc created by Symbol#to_proc uses the additional block parameters as parameters to the method call. If you have code that looks like this: some_method do |foo, bar, baz| foo.swizzle( bar, baz ) end &gt; …then you can rewrite it in Ruby 1.9 as just: some_method(&amp;:swizzle) &gt; Where do we often see blocks that yield two parameters? Why, in our good friend [Enumerable#inject](http://www.ruby-doc.org/core-1.9.3/Enumerable.html#method-i-inject)! values = [ 1, 2, 3, 4, 5, 6 ] total = values.inject(0){ |sum, num| sum + num } # This is far too much code total = values.inject(0,&amp;:+) # Sweet! &gt; I have a feeling that this will prove useful beyond [impressively terse code](https://stackoverflow.com/questions/8997428/how-to-traverse-this-hash-within-one-line/8997641#8997641). The one damper on this parade, however, is that you must have two values actually being yielded to your block. Yielding an array that has two values is not good enough: **The Solution** &gt; All is not lost, however. Since all the [Enumerable](http://www.ruby-doc.org/core-1.9.3/Enumerable.html) methods return an [Enumerator](http://www.ruby-doc.org/core-1.9.3/Enumerator.html) if you call them without a block, we can monkeypatch that class to yield all values explicitly: class Enumerator def splatted each{ |a| yield(*a) } end end &gt; With this, we can now do some wonderful things: # Sum each pair of consecutive integers p (1..10).each_cons(2).map.splatted(&amp;:+) #=&gt; [3, 5, 7, 9, 11, 13, 15, 17, 19] # What is the largest integer resulting from raising one single-digit integer to the power of another? p (1..9).to_a.permutation(2).map.splatted(&amp;:**).max #=&gt; 134217728
Why not just use a computer?
Less so than your comment.
I read it on my laptop and I still think it's a bit difficult to read.
I hear you. This website shouldn't win any "design of the year" awards. But not being easy to view on a mobile device doesn't seem to be a reasonable critique of a link posted in a programmer subreddit like /r/ruby.
Well... Have you tried to create a config.ru in said directory? It is a rack config file btw.
I reinstalled all the files, server seems to work again. I had to restore my PC to a earlier date a few days ago and that may have messed up some files. 
Just add this file in your application's root directory: https://gist.github.com/kerberoS/8625290. And replace `run YourAppName::Application` for your rails app name. 
sorry for the inconvenience, btw that is not my site so i can't fix that. i just found a great post and i want to share it to reddit. thankyou,
Nifty, but I would not use this in any serious application. It is not immediately clear what is happening, which I can only see causing confusion for other developers (or when revisiting one's own code).
Added tests, non-passive change from @dogweather's idea below.
Made the change, and added question marks. It's now all_of?, any_of?, none_of?
Cool, but I actually meant the app-level code like this: def is_female? @sex == 'f' end should be: def female? @sex == 'f' end ...according to ruby style. And then your library code should still function with that style of accessor.
I am doing this as well, and I have the exact same issue, at the exact same line of the testing. I suspect it is a typo in the Rspec. I solved it by adding an "it/do" to that line of tests. Did you manage to solve it without changing the Rspec tests? edit: I ended up being able to solve this without changing the Rspec tests. Reading the "explanation" part of this wikipedia article really helped. http://en.wikipedia.org/wiki/Reverse_Polish_notation
Makes a bit more sense. I'll get that one changed then. Thank you kindly for the suggestions!
Good for code golf
PStore is probably okay if you are only using it a little bit. A long time ago (2008) I was using PStore and found it was way too slow. It seems like it has gotten faster than then, but still considerably slower than GDBM, which is what I switched to back then. Storing a 1,000 element array 10000 times (same key though) with Ruby 2.1.0: Rehearsal ------------------------------------------------ pstore write 1.520000 0.070000 1.590000 ( 1.584842) pstore read 1.510000 0.050000 1.560000 ( 1.568631) gdbm write 0.780000 0.000000 0.780000 ( 0.776022) gdbm read 0.450000 0.010000 0.460000 ( 0.459048) --------------------------------------- total: 4.390000sec user system total real pstore write 1.500000 0.060000 1.560000 ( 1.563164) pstore read 1.520000 0.070000 1.590000 ( 1.592354) gdbm write 0.770000 0.010000 0.780000 ( 0.783642) gdbm read 0.440000 0.010000 0.450000 ( 0.458292) Here's the code I used: http://pastebin.com/f4vLBzfR Note that GDBM only stores strings, so the benchmark uses Marshal just like PStore does.
I did resolve this a few months ago. I forgot to mark it resolved. Thanks though
i like it!
[Ruby 1.8 had a Symbol#to_proc method](http://ruby-doc.org/core-1.8.7/Symbol.html#method-i-to_proc).
I can't argue with that. But seriously, this gem isn't good for anything. I mean, you can't even do a real comparison with it. Between, like, two objects or something. It can't even manage a very simple thing like person1.age &gt; person2.age All it can do is simple static checks, and not too flexible even at that. So what's the point?
Thanks! I've fixed that now.
Thanks for reading!
Hmm, I guess I didn't really make the point I wanted to make. `for` is a control structure. `each` is a method on your object. In Ruby, I think we like to prefer methods and objects wherever possible. `each` feels and acts just like any other method in Ruby. `for`, on the other hand, sits outside that way of looking at the world. It feels more procedural. It's also a little harder to change. Let's say I had the following code: users.each { |user| user.name } Because I have a block, I can use `Symbol#to_proc` instead: users.each(&amp;:name) That's a nice short-cut. I could also change the `each` to `each_with_index` easily: users.each_with_index do |user, index| puts "#{user.name} is at index #{index}" end I would have had to rewrite that if I was using `for`. I can also extract the block to reuse it elsewhere: report_name_and_index = -&gt; (object, index) { puts "#{object.name} is at index #{index}" } users.each_with_index(&amp;report_name_and_index) accounts.each_with_index(&amp;report_name_and_index) 
That's a fair point. My goal was to introduce `Enumerable` by itself. I didn't want to introduce too much at once. Some in the audience of this talk had never written a line of Ruby before.
Also would require a sync or remote storage when scaling app to multiple servers. May be overkill, but would rather store nonsensitive data in a cookie or in the database.
Granted that it breaks a certain point of Object orientation when used improperly and warrants a look towards refactoring, then again I have no control over people using things improperly. Nothing can prevent that, I'm just making it easier to do something to clean up my own code.
I'd definitely tackle that one this way: [ user.admin?, user.whitelisted?, user.owns_item?, user.mod? ].any? But at this point I'd be looking for a new object. Something like this: class CanDoWhateverThatChainOfIfsIsAskingFor attr :user def initialize(user) @user = user end def privileged? %i(admin? whitelisted? owns_item? mod?).any? do |query| user.public_send query end end end This would be a kind of baroque, "javaish" interface. Especially for such a small amount of code (more on that in a second). To address the interface, I'd add a class method to make life easier, and more ruby like: def self.privileged?(user) new(user).privileged? end Now anyone who has a `User` can figure out if they have that privilege: CanDoWhateverThatChainOfIfsIsAskingFor.privileged?(@user) What's great is that now that code has to reference the class name, and thus reveal why it's asking for the privilege level. Then I'd start to see if this class became a "magnet" for moving a lot of those conditional methods. Chances are at least a few of them would prefer a new home, where they're not taxing the cohesion of the `User` class. Of course, to each her own, so if you hate this approach, then keep using (and enjoying) your gem. Programming should be fun!
Heh, well if it's just for output, you can just use string manipulation. If $_ is your Float, you can print $_.to_i with $&gt;&lt;&lt;"#$_"[/[^.]+/] If you want to actually get the integer, you can do "."*$_ =~ /$/ The [=~](http://ruby-doc.org/core-2.1.0/String.html#method-i-3D-7E) operator can potentially do a lot of math for you, actually. Without =~, you could also reuse your existing tricks--initialize a variable to 0, and then loop until it's greater than $_, then subtract 1.
I think I wasn't clear about what I meant. What I meant was Bookshop is not a collection. It *has* a collection. If you were to design a model you'd write class Bookstore has_many :books end In the same way, I'd say a Bookstore, by itself, is not an Enumerable. It returns an enumerator, books, that *is* a collection. If you were to extend the class, you could maybe return another enumerator, authors, for a collection of authors. Example of this is the `String` class. It, by itself, is not an Enumerable. It returns returns a few enumerators, `each_byte`, `each_char`, `each_line` etc.
What Rails is doing is making it easy for you to wrap your content with stuff that doesn't change (like a nav bar or a footer). Consider the following example. A user goes to the about.html page for your website. What Rails will do is load the application layout and when it gets to line 13, it says "ok, go grab everything in about.html.erb and put it here" and then it tacks on lines 14, 15, and 16 from the application layout and sends the entire complete html file to the user. I said Rails will load the application layout, and this is true if you don't tell the controller to use a different layout. As for how this works from the perspective of Ruby, yield is a keyword that runs a block associated with a method call. def example_of_yield puts "I'm in the method" yield puts "See how that works?" end example_of_yield { puts "I should be between the other two outputs" } I'm in the method I should be between the other two outputs See how that works? As you can see, it *yielded* back control temporarily to the code block associated with the method call. So basically somewhere in rails you have def build_html_file #load application.html.erb that has a yield in it end build_html_file { #load about.html.erb } This is a gross oversimplification of what Rails is doing in the background, but hopefully it gives you some idea of what's going on.
I believe PStore performance degrades rapidly with the number of keys stored, but you can get round that easily enough by sharding your files. Here's a benchmark comparing standard PStore, a lightly adapted PStore that shards files, and memcached (a fairly uncontroversially "fast" key-value store): http://www.slideshare.net/machu/pstore-and-memcached-benchmark Here's the implementation of PStore called PStoreAdapter2 in that benchmark: https://gist.github.com/machu/199335#file-memchache_bench-rb-L57-L77
Gotcha. That makes more sense.
Do you need them pre-money or post-money? Pre-money you have a choice: * Be the technical co-founder * Convince an experienced developer who trusts you and believes in you already that they should be involved in this project, and hold up your side of the bargain * Offer to brain storm ideas together with somebody you like working with or want to work with who knows how to get stuff done, and again hold up your side of the bargain That's it. There's no other option. Meetups and all that jazz is just not going to work pre-money. Post-money: 1. Meet-ups, job boards and traditional routes to establish candidates 2. Put together a solid package of strong salary, good options and so on 3. Hire somebody you feel can become a friend. Because you're going to need to become friends. Source: I'm a CTO and co-founded several businesses. These are the only paths I'd consider from the other side of the equation.
Save your time. Here's the tl;dr; &gt; I won't deny that Ruby has lost some momentum. But that doesn't mean the language is dead. I think it has matured and that it is a great tool to add to your arsenal as a developer.
It was previously named simply "upnp", not realizing that rubygems was case-sensitive and would collide with the existing "UPnP" 1.8 gem. Renamed to "playful" because typing "UPeeNPee" took more effort. 
Ah yes, the most valuable property of a programming language for the "rockstar" developer: hype. Seriously, let's look at some definitions of hype: 1) Exaggerated or extravagant claims made especially in advertising or promotional material 2) An advertising or promotional ploy 3) Something deliberately misleading; a deception 4) To publicize or promote, especially by extravagant, inflated, or misleading claims Do you really want any of those things in a programming language? I welcome the removal of hype.
Java had been dying for ten years now, c++ even longer. With luck, we can expect Ruby to be dying for 20 years or more.
C has been dying since C++ came out. Think about how laughable that is for a moment
You should add a short description of what "UPnP" is at the top of the readme. While some are familiar that it stands for "Universal Plug n Play", many don't immediately recognize that. Congrats on releasing the gem. It looks well put together!
Great suggestion! Thanks for chiming in!
&gt;when I can't seem to see how they are linked together. It's not really meant to be seen that transparently. Rails is built to abstract away all that "mess". All you need to know is that your Pages controller is in control of what actions load what layouts and files. &gt;Can I use multiple yields? I tried and it just kept putting the same text up. Are you asking if you can have one page grab dynamic html from two different .html.erb sources? Because there's no sense in having your about page info in more than one place. Each of your views should pertain to one action in the related controller. An exception is when two actions share common content, which is what layout helpers are for, but you tell the view which helpers to load inside the view itself, not in the main layout. Can you give a more concrete example of what you're trying to do?
http://i.imgur.com/jQGsavV.jpg http://i.imgur.com/frxpdK6.jpg Sorry for my ignorance by the way, I'm completely new. On my mobile right now so just took a couple pictures before going to work. I'm having trouble understanding how I can edit the different pages in a completely different way. Because as I understand the application file is a sort of general template for the whole project. And I can't seem to understand how yield is related to just the home.html.erb 
For fucks sake. Those among the community who are good at ruby are also good at pretty much any other language they try to learn. What's the big fucking deal? If something actually comes along that is better than ruby, a bunch of us will jump ship. No big deal. Till then I owe the fact that I enjoy my job largely to Matz, who wrote an excellent language for me to program in. I shudder to think about fumbling through nested callbacks in node, or get lost in the sea of Nouns in .NET.
I meant DSLs for tests specifically. I agree with DHH where rspec has has a poorly designed dsl. I think they have improved with the new expect syntax but I have be burned by a few rspec specific errors just to make the DSL nicer. As for template patterns. This is where I disagree with the amount of testing. (And I understand if you want more, just my personal preference) I refuse to test only configuration. I think configuration should be covered by acceptance tests. Having a test for have_many or belongs_to is repetitive. If there is custom logic in your models that is repeated then honestly they should be abstracted to either a base class, a more abstract method, or the newer concern pattern. If they have repeated patterns then you should create code in your tests to signal their duplicity. 
I think there are better ways to avoid repeating code in tests usually by having proper setups or use loops to generate tests with unique patterns. I have created an array of hashes expected inputs and expected outputs and looped over that to create many tests for a single method to guarantee output for many permutations but I refused to right those tests 10 times, or use shared_examples to create these tests. I feel that shared examples obfuscate where the duplication really lies. Tests are meant to ensure reliable output for given input. They should be maintainable, concise, and have appropriate coverage of edge cases based on importance. They should communicate intention of code and if a failure were to occur it should be easy enough to understand where the failure is in your code. One should try to reduce the amount of code/logic in tests to achieve the above goals. But I do not believe abstracting logic behinds DSLs is the best way to achieve said goals. I think test DSLs restrict the way one approaches the writing of tests. I think tests should be as close to metal as possible as it helps us understand the true intention of our code. TLDR: Tests should focus as much as possible on input and output. I think rspec gets in the way of that because so much logic can be added through DSLs simply. We should make tools that encourage good practices not enable bad ones.
How does a DSL restrict your approach? The only main difference is organization and the way you declare tests for the most part. The way it organizes makes test far more readable (name wise at least) and makes it very clear what is going on.
Pry is an amazing REPL but I'd say it's only third best, my second favorite is the Erlang shell and my favorite of all time is writing Lisp in Emacs, being able to evaluate sub-expressions based on cursor location is just awesome. :) Personal opinions aside, this was a great article to help pull the blinders off people caught up in valley PL hype. Thanks for writing it, I thoroughly enjoyed it!
I would really like SciRuby to catch up with Pandas and similar software. If it could, Ruby would stay relevant for me :D
This article gives a great current overview of Ruby. 
props for renaming a project just to make it easier to type. 
I am a huge fan of this already, and all I've done is look at the code. I'll have to try this out when I get home.
It's usually best to avoid class methods and method chaining.
This is a discussion board. Unless you believe something is outright spam, *discuss* it. New ruby programmers would benefit much more from you laying out your concerns about flaky material than us banning it. 
Thought you guys/girls would get a kick out of this too. Such a neat way to teach your kids problem solving and computing at an early age. I'm getting one for myself and my daughter.
I think it restricts mindset. People think tests need to be in a dsl format. A DSL TO SOLVE ALL THE PROBLEMS. There should be less abstraction in tests not more. I've paired a lot with other developers (I used to work for pivotal labs). Ever time I have worked with other developers it always felt like that they were constrained by rspec. They tried to solve all their problems with the DSL even though it may not be the best answer. They attempt to use the shared features with the lets and then use chained expectations. It turns into a million layer cake that looks gorgeous but you have no idea what is going on once one of the tests fails. This gets worse with application age. Your inputs are now split up between each layer(nested describe blocks). Outputs are now in 3 different files (custom matchers, shared examples, after hooks). I have nothing against custom matchers, honestly they are amazing when used well. But so many people abuse it to reduce duplication and only increase magic. Now your tests are about as complex as your code.
I develop locally in Postgres, so I set that up. 
Hey, I think we're actually in kinda violent agreement here. I agree the rspec `should` syntax is pretty bad and also that a lot of configuration specs aren't necessary. I also agree that a lot of _model_ specs are kinda redundant; just at judging what rspec scaffolds generate, I'd agree unreservedly ...but BIG BUT... I have a lot of custom matchers and include/extend helpers and macros that are built off of rspec's patterns; mostly for my "object-oriented rails" classes (I have a huge set of template-pattern classes). I've written these by learning from rspec's documentation and other projects which have really nice and elegant extensions that have dried up my specs and made them more maintainable. I think the *substance* of rspec offers a whole lot in building really nice, literate and maintainable tests even if the base examples are kinda wordy. So while I don't agree entirely with rspec, I think their heart and approach to making tests "better" aligns with my development philosophy. And just to be extra defensive, rspec is an easy place to punch because it's front and center in the "Prime Stack", so I think it's hard to have a reasonable conversation about rspec's drawbacks because it is a very different experience for someone who is just starting out off the scaffold, and someone who has a lot of experience with it. Which I guess applies to anything :-) Anyways, thanks for expanding on the criticism cause I think we agree on the criticism if not on the resulting action.
Switch the database adapter to whatever I'll be using in production, add development gems (better_errors, binding_of_caller, thin, pry), and create a git repo. Before creating any ActiveRecord models, I consider whether I'll be using hstore (for postgres) and add a migration to enable the extension if so. If the app will require authentication and/or web-based administration, I set up Devise, CanCan and ActiveAdmin as needed. After that, I create initial models and routes. I generally don't deploy a staged version of the app until the schema, routes and controllers are set up enough to provide a working system the provides the core functionality of what is required (at the very least).
Okay that makes more sense! Thanks. So is it not possible to have a different look for each page? or is that pretty complicated because you couldn't have a single application layout that is universal across the application. 
Yes. Read http://guides.rubyonrails.org/layouts_and_rendering.html Note that render takes :layout as an option.
draw the models and relationships I need for the system to work as needed, then setup a development environment (gems, db configs, etc), then integrate a css framework (mostly bootstrap) and then start with the models, and an admin section to CRUD while developing...
I agree with this. "We saved hours of planning with weeks of coding." So what happens when you start coding, though? Where do you start?
No problem. There's a lot going on in there, and your first question about yield is one that requires an explanation of Procs and lambdas to be complete. If you'd asked "how do I change the layout based on which view I'm rendering", you might have been pointed to the Rails guides sooner, so pull back a bit: you don't need the detail you think you do. I recommend http://guides.rubyonrails.org/ by the way - none of the guides are particularly long, but are very comprehensive. At the minimum they should give you a vocabulary that gives you a better start when facing Google with a question :-) Good luck, and welcome to the Ruby and Ruby on Rails communities.
&gt; okay, make me a Rails app about this. Why is the client telling you what tech to use? Why does the delivery mechanism have anything to do with what the client wants? Develop your use case code (with tests!) before you even think about touching any kind of delivery framework.
Thanks! Nice to know there are helpful folks on here, even though it isn't r/rubyhelp or something. 
Awesome takeaway, I did not know that. Models + tests first then work your way to the front. Thanks man.
Hehe, thanks. And props to github for making renaming of repos in such a way that doesn't give the shaft to other users that have forked or are using bundler to pull the repo: https://help.github.com/articles/renaming-a-repository. 
Netcraft confirms it: Ruby is dying.
If I find time, I might be able to be a contributor for this if you need some assistance with cleaning it up a bit. I'll send requests for it if I find time. Looks good so far though, went through the code some more; I do see some potential room for changes, but overall it's pretty nice.
Actually what's happening is I'm working on a product-based startup, and it's built on Rails (nothing too big yet). And we're looking to create a services-based company so we can fund the startup ourselves, and ideally it would also be in Rails so we aren't switching languages for the product and the service. We'll advertise ourselves as a Rails shop and I was looking for a few tips from you guys
Sorry for the stupid question, but when you say templates, what exactly do you mean?
This reminds me of [this UncleBob speech at Ruby Midwest a couple years ago](http://www.youtube.com/watch?v=WpkDN78P884), particularly when he gets beyond his opening monologue and gets to talking about the architecture of an application representing its function, not its framework.
If you're often using hstore, you may want to check out the [hstore_accessor](https://github.com/devmynd/hstore_accessor) gem. We've used hstore in a number of our projects so we developed this to help utilize it.
More people need to watch that and actually understand it.
Any special reason?
I've met with success in this subreddit in the past; hired one person from here. :) Although Perl is the dominant language here, we are still looking for a reasonable excuse to use Ruby more extensively in our system, where it might apply best. 
Not a stupid question! I mean [these](http://edgeguides.rubyonrails.org/rails_application_templates.html). 
Thanks, how did I not know about this?
Yeah, time is my problem as well. I used to use this gem at my last job, where we did a bunch of UPnP stuff (and thus had more time to work on it), but have moved on and don't use it as much anymore, thus have less time to improve it. Hence the amount of time it took me to get it this far. :)
Oh, also: add a dashboard controller with an exception-raising button so you can test that the email dispatch is working properly. Later I use the same controller as a status board for pinging any external services I rely on to give me a one-stop integration view. This is incredibly handy if there's any firewall config to stuff up between me and them.
Thanks for the comment! I am not an Erlang expert, but I have being using it for the last 6 months. I think the Erlang shell is really great (reload code, connect to running process, etc). But I would like that it has colors, better tab completion and a way to get access to the documentation. Regarding Lisp in Emacs you are right. I am just in my first steps of learning Emacs and Lisp and I can say it's really great. I will change it on the text. Again thanks for commenting. I really appreciate it.
100% agreed. I have a hard time selling it to my team, though. Creating everything the rails way is definitely faster and easier (but harder to test), so they think I'll just waste their time. -.- Since I already have you here: Do you have any experience with Uncle Bob's architecture in a Ruby application? If so: How did you decouple the business models/entities from the database? AFAIK there aren't any data mapper implementations (ruby object mapper is not yet production ready) and writing my own was rather hard and error-prone.
At my work, we use AWS and have separate staging and production servers (each being a pool of servers in themselves). I personally use [DigitalOcean](https://www.digitalocean.com/?refcode=1d3d75ed4f31), as they provide VPS's for a really good price that are completely customisable and can be created or destroyed in seconds. For my own setup I use a single server for staging and production, but deploy staged apps (and their configs etc) to a separate staging folder. EDIT: I thought I should mention a bit more about staging servers. You always want your staging server to provide the exact environment that your production server does - otherwise you can end up with an app that works fine on staging but doesn't on production due to missing dependencies, different software versions etc. For personal stuff it's generally fine to have both staging and production on the same server, but by having them on separate (but identical) servers you can prevent the environments from interacting adversely with eachother.
Use a Rails template and keep it updated with all the best stuff you find and love to use. Don't stop there. Make the conscious decision as a modern developer and stop doing things by hand. Automate, automate, automate or lose money to a developer that does.
Sorry, just read the thread below and noticed someone else made the same suggestion. "Automate all the things" still applies. Start with your development environment. Build it inside of a VM with Vagrant and Chef or Docker and learn to automate it so you could develop on any machine on the planet by typing a single command. Yes, be that guy.
&gt; Creating everything the rails way is definitely faster and easier (but harder to test) This is only true for either small projects, or the beginning of large ones. &gt; Do you have any experience with Uncle Bob's architecture in a Ruby application? Yup, I've built a few actually. &gt; How did you decouple the business models/entities from the database? We basically use Stuct's for our entities, and use Sequel (just the query builder part, not the ORM) for the database access. The repositories are in their own gem and are isolated from the business logic. The repositories return entities, so they depend on the business logic. This follows the structure you see here: http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html The repository basically lives in the same layer as Rails or Sinatra.
It seems like everybody has watched it.
Always change everything to use slim and sass, get bourbon installed, and then go from there
Paper and pen honestly. You might want to rethink your application is it's too big that you need fancy diagram software.
I start with something similar and use PG as the database as I typically deploy to Heroku. I wrote about the most common gems in my applications (http://brandonhilkert.com/blog/patterns-in-a-rails-gemfile/), so I typically start by adding them. I've been messing around with rails templates, which are interesting and have saved me some time when starting a new app.
I love this. I've been writing Ruby for awhile and have never come across this library. I've done some things here and there and just written to a local file, but because it was just free form text, I had to be concerned with encodiing/decoding the contents. I just updated one of those solutions to use Pstore and it's perfect. Re: performance - I'm not sure it even matters. If you're looking for performance, I highly doubt you'd end up down this road. It's perfect for a small key/value store, valuing convenience over speed. Thanks again for the article. I really enjoyed it!
Delete it, create it again without bundler.
Well, yeah, I do that. Thank you so much for this link - I'm making my first template right now. 
Forget that I've recently rebooted, fire up Alfred and relaunch Postgres.app, followed quickly by the thought of, "I should really set that up as a launch item." Then I don't do that, fire up Sublime instead, and modify my Gemfile to have my other favorite dependencies, like Devise. Very basically pretty up the layout file, lament not switching to haml, and get cracking. 
There's also suspenders: https://github.com/thoughtbot/suspenders and app scrolls: http://appscrolls.org/
It's amazing how many database schemas start on the back of napkins.
Why?
Resist the urge to implement some form of user authentication.
What if you want to collaborate? Like, push it to the Git remote? Thanks.
What if you want to collaborate? Like, push it to the Git remote? Thanks.
I think you miss the point. When it's a bunch of devs sitting around dreaming up ideas over nachos and beer, you'll use whatever is available. Usually that's going to be napkins and a pen you borrowed from the waitress. Obviously this eventually gets translated to a series of SQL tables.
Then I think I phrased the question in the wrong way. I mean, what tool do you use to create that series of SQL tables? Thank you for your time.
fap
As it has been stated, pen and paper is perfectly acceptable. Schemas are often refactored later by means of database migrations. You could probably use a UML diagram tool if you really wanted to, but unless your project is very complex this often isn't needed.
I understand the allure of free but your first few examples seem misguided. The free amazon card certainly offers more value if you never intended to purchase something from amazon. If you spend 7$ to gain 25units worth of something you didn't necessarily want. Then you value yourself at -7$.
&gt;Amazon's free shipping is now on steroids with Amazon Prime. Prime subscribers pay a yearly fee of $79 and get free shipping on all orders over $25. Yeah, that's not how it works.
There's an assumption that you actually want, and will use the gift card. In that case the $25 for $7 is always a better deal. If you don't want the thing, chances are you'll take the free one anyway. If you take the gift card and never intend to use its value is zero, not $10 since gift cards are only valuable when redeemed. 
Can't agree with this more. The early portion of my career was working on java projects with technical architects. In every single case the plan drawn up by the architect caused countless problems. If you're architecting a solution you're basically guessing what you're going to need. Software systems are complex, not least because your users don't know what they need until they start interacting with them. If you put a domain and architecture in place before you start building a system what you end up with is a front end that does what your users want, a backend that your architect wants, and a whole lot of painful transformation work in between. 
Great, thanks :)
Everyone's ready to hop on their high horses =P. Good luck!
... and this: http://www.railsbricks.net/
I think the chocolate example is as well. There's a third population that isn't being considered - the population that wouldn't have paid for either chocolate in the first place. When the Hershey's Kiss goes from 1 cent to free, it suddenly becomes an option to consider.
I use Capybara tests on a daily basis. Cucumber test are nice in that they give you a human readable description of a feature, but you can make your Capy tests just as verbose. Typically, you want a behavior-level test to describe the feature you are implementing, and then write unit-level tests to check features at a more granular level. So, you don't _need_ Cucumber tests, but I would recommend having behavior and unit tests in order to maintain some level of sanity in the project. Having the ability to check if you have broke something with a quick 'rake spec' command is the best thing you could do for yourself, and any future developers that may work on your project. 
Thanks for answering. Re sanity we are slowly and painfully learning that now lol. Do you have any gems or high-level tips for testing?
I would use Capybara for behavior driven development unless your client or non tech people are going to participate in the process. Cucumber only adds a more readable DSL for non tech people. So if the BDD is going to be done by programmers and without non tech people very involved in the process I recommend you to do Rspec + Capybara and you'll be faster and will cover the same at same level. And with Capybara BDD DSL you'll get pretty readable and close to Cucumber specs: https://github.com/jnicklas/capybara *"Finally, Capybara also comes with a built in DSL for creating descriptive acceptance tests"* ... *"feature is in fact just an alias for describe ..., :type =&gt; :feature, background is an alias for before, scenario for it, and given/given! aliases for let/let!, respectively."*
In short: no, you don't. Master a less abstract tool and you'll benefit from it much more.
MySQL Workbench was my favorite tool when I did this in the past. If you're sticking with free tools, yEd, SQL Power Architect, and Dia aren't bad. You could also use graphviz, but I don't think that's ideal. With respect to tools you have to purchase, Erwin is the "king", but it's very expensive and very complex. I've used visio, but I really didn't like it.
Use the 'shoulda' gem for testing Rails model relationships and validations. See the github page for the documentation and some examples. FactoryGirl is great for testing your database, and for creating db fixtures that you can use while writing Capybara tests. factory :user do name 'Sam' email 'sam@gmail.com' password 'secret' end Capybara tests should describe the user's interaction with the website. If you start getting too specific, a unit test is probably in order. Capybara example of a user logging in: feature 'users can log in' do scenario 'a user logs in with valid credentials' do user = FactoryGirl.create(:user) // using the factory described earlier visit root_path fill_in 'Email', with: user.email fill_in 'Password', with: user.password click_on 'Log in' expect(page).to have_content("Login successful.") end end That's fairly easy to read, right? One of the side effects of well written tests is that they can also serve as documentation for how the application should work. Here are some of the gems I add to my Gemfile for testing: group :test, :development do gem 'capybara' gem 'factory_girl_rails' gem 'rspec-rails' gem 'shoulda-matchers' gem 'valid_attribute' end edit: 'too' instead of 'to' 
Awesome, thanks for the verbose answer. Do you/am I supposed to use almost exclusively factories for creating users?
Less abstract = capybara right? What other tools/practices would you recommend? Any advice for us is highly appreciated.
Check out the BBQ gem. Object oriented acceptance testing.
I'm not sure what anyone in this thread is talking about. You CANNOT substitute Capybara for Cucumber. Cucumber *IS NOT* a web testing tool. You *CAN NOT* do BDD with Capybara. You can use Capybara inside of a BDD tool like Cucumber or rspec though. You use cucumber as a BDD tool to communicate with each other and the business owners. I'd HIGHLY recommend picking up the RSpec book and read it about 5 times. It covers all of this stuff. Finally, I'd *highly* recommend that you do not test the majority of your app through the web interface or with the database. It will only get slow, and you will start to think testing is just pointless and sucks.