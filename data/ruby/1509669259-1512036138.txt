Timezones and daylight savings bullshit needs to be outlawed. There needs to be be global time standard (like UTC but for everybody). Then I say 15:00, it's 15:00 in America, Asia and also fucking Africa. Right now it's a fucking mess with those timezones. There are also +- 30/45 minutes timezones. What the fuck. We don't rename July to January for Southern hemisphere just because it's snowing there. Why the fuck time needs to be affected by day/night cycles? 
As an extension, what happens if the user types in something that's not a number? How do you want to handle this?
The code snippets on your website have issues with pipe characters in blocks that makes the code look like it's doing something weird.
Funny you got downvoted. I agred. And everyone‚Äôs complaint when I talk about this is always that then there wouldn‚Äôt be a standard thing like thing like ‚Äúoh businesses open at 8 and close at 5.‚Äù Which first of all is an outdated concept. Second, If we adopted UTC and that meant that 8:00 in morning is now shown as 13:00 or whatever the fuck... who cares! I have to go online and look up the hours I‚Äôm calling anyway, and then at that point, the UTC would be more helpful too.
Only farmers would downvote me. We don't milk cows anymore. This is a global society. Why the fuck do I need to do math if somebody from different country wants to skype me at 8am... What 8am? My morning or his? And when is that anyways? Is it same time difference as it was last month and didn't change due to DTS? This topic makes me angry every time.
Thanks! It subclasses Rack::Session::Cookie and depends on specific implementations of certain methods (including arguments and return values). If I were to completely fork it, it would probably be possible to make it backwards-compatible with Rack 1.x, but that was well beyond the scope of what I wanted to do. I hope that answers your second question as well. What non-Rack contexts are you thinking of?
If you're a beginner Ruby willbe hard, as there will be a lot more to learn then, say,Python
I was surprised that no maintainers had addressed this for so long
https://github.com/cchandler/certificate_authority
What you will say about this? https://www.cleveroad.com/blog/node-js-vs-ruby-on-rails--the-power-behind-technologies
This Rosetta Code link may be useful : https://rosettacode.org/wiki/Determine_if_a_string_is_numeric#Ruby
However, most people would prefer to sleep when it's dark and be awake during daylight hours. You could impose UTC on the entire world, but someone in the UK Skyping New Zealand or California would still need to check that they're not likely to be tucked up in bed :)
Unfortunately this won't happen: https://twitter.com/yukihiro_matz/status/916083723589656576
&gt; Let's start with an example when nil might be a good idea. &gt; `(1..10).find { |i| i == 42 }` Returning `nil` to indicate failure is almost never a good idea. Simply because you can't tell a valid result `nil` and the failure case apart. E.g. What's the return value of a JSON parser parsing `null`? `nil`? What's the return value of a JSON parser failing to parse a particular String? `nil`?
&gt; There is a lot that can be done beyond using nil and exceptions, for example with tools like monads or response objects. "or" seems out of place here. The response object would implement the monad interface. Monads don't exist in a vacuum.
Thank you üòä 
Thank you üòä 
And all of us welcome that with open arms, of course.
I think that example is fine. If I say "find this number is this list" I would expect it to either find the number or to say "I found nothing" i.e. nil. If it is literally impossible to search for the number (no find method defined, or my search criterion causes an error during the search), then I would expect an exception. Looking for something and not finding it is a pretty common occurrence. It is literally not exceptional.
Try to implement `array.includes_nil?` using `find` and I think you'll see the problem. As long as `NilClass` is lumped together with all other types you are always in danger of running into ambiguities.
Doesn't mean it can't be attempted again. Especially once String literals become frozen.
I use all kinds of objects as keys for a Hash, not just String or Symbol, so an indifferent access Hash has extra baggage for a special case where I didn't bother to make the right choice for my key type. Also, indifferent access makes a Hash much more expensive to use. One possibility is making two lookups, with and without conversion to figure out the "correct" key type. The other is using multiple keys which effects storage space and adds cost for every operation (to ignore the "duplicate" keys). These are not tradeoffs I want if I can make the right choice at the start (most frequently, "use String")
I imagine the author is referring to a monad that's a built-in type (tuple, array, hash/map) versus a full-blown object.
&gt; Try to implement `Array#include?` (`array.include?(nil)` in particular) using `find` and I think you'll see the problem. It's not that hard. def include?(needle) included = true find(-&gt;{included = false}) { |e| e == n } included end
 (0.1ms) begin transaction Bid Exists (0.3ms) SELECT 1 AS one FROM "bids" WHERE "bids"."lot_id" = ? LIMIT ? [["lot_id", 99], ["LIMIT", 1]] Bid Load (0.2ms) SELECT "bids".* FROM "bids" WHERE "bids"."lot_id" = ? ORDER BY "bids"."id" DESC LIMIT ? [["lot_id", 99], ["LIMIT", 1]] SQL (0.4ms) INSERT INTO "bids" ("lot_id", "amount", "created_at", "updated_at") VALUES (?, ?, ?, ?) [["lot_id", 99], ["amount", 153], ["created_at", "2017-10-27 23:19:35.787067"], ["updated_at", "2017-10-27 23:19:35.787067"]] (1.0ms) commit transaction (0.1ms) begin transaction SQL (0.6ms) INSERT INTO "idempotent_actions" ("idempotency_key", "body", "status", "headers", "created_at", "updated_at") VALUES (?, ?, ?, ?, ?, ?) [["idempotency_key", "5d41d8cd98f00b204e9800998ecf84272"], ["body", "[\"\"]"], ["status", 204], ["headers", "{}"], ["created_at", "2017-10-27 23:19:35.792024"], ["updated_at", "2017-10-27 23:19:35.792024"]] (1.0ms) commit transaction Except this isn't atomic, so you could see the key fail to get saved despite the actual request transaction succeeding.
Include is for horizontal hierarchy, while requires load another file (also, don't put requires inside classes, put them on top of the file outside the class) In your example doing include does nothing, as you made tester a class method instead of an instance method. If you have on othertest.rb you have module Other def tester p "does something" end end You'll need to require the file, include the module into your class and instanciate it. Sorry the crap reply, formatting is hard on the phone 
hmm.. it makes sense. I don't see a need in there to make tester a class method. `class &lt;&lt; self` might not be necessary at all. 
It's not a special case - the fact ActiveSupport::HashWithIndifferentAccess was added is an indication of what a big issue this is. The two lookups solution is fine. People that care will soon learn String is faster - but may choose to use a Symbol anyway in the code with a small penalty. Anyone not understanding the potentially catastrophic difference will not, unknowingly, risk catastrophes. In real world there is a shit-ton of impact from developers mixing String and Symbol keys for hashes. It's the Mars Climate Orbiter metric issue - if you allow two competing conventions then you risk bad things happening. The String/Symbol hash key thing is one of the most un-Ruby things about Ruby right now. Ruby 2.4 set a precedent for breaking changes - they should just fix it.
Hi Enumerable_any, thank you for your comment! When I mentioned response objects I was thinking about something on the lines of a NullObject for example without necessarily being a monad https://robots.thoughtbot.com/rails-refactoring-example-introduce-null-object
The short answer is: `require '/foo'` means "make sure you've read the foo.rb file, 'cause I'm about to use some code that lives there," but it doesn't tell Ruby _what_ to do with that code. It just makes sure Ruby has the contents of that file in mind while it evaluates the rest of the code below. `include Foo` means "combine the functionality of the Foo module into this other module/class," but it doesn't tell Ruby _where_ to find the Foo module.\* It assumes that Ruby already has an understanding of what code might be in the Foo module. You need both to get the desired effect. That is, if you write: require '/foo' class Bar # ... end ... then Bar has none of the behavior of Foo. And if you write: class Bar include Foo # ... end ... then Ruby throws an error because it doesn't know what `Foo` is when you try to include it. But if you write: require '/foo' class Bar include Foo # ... end ... then you're good. ------------ \* Caveat: in practice, a lot of the job that `require` does is often handled by autoloaders, so that you don't have to worry about making sure every possible dependency is required in every file. Ruby has [some built-in support for this](http://ruby-doc.org/core-2.4.0/Module.html#method-i-autoload), but frameworks often bring [their own, more heavyweight solutions](http://guides.rubyonrails.org/autoloading_and_reloading_constants.html). A little googling will tell you more about autoloading. 
I'm not sure what you are referring to, there not a single pipe on the whole page 8)
What challenges are you doing? I have been learning ruby for about 6 months now and I am using project Euler as challenges. Ruby is the my second language. I started with perl which was easier to learn in my opinion because it is more linear. I love the OO of ruby but it adds a layer of complexity for sure. If you decide to try project euler, I would be glad to guide you a bit.
IoC containers aren't a great solution for anything. It's a lot of unnecessary baggage and indirection.
A class/module with a single method `call` should just be a function, there is no need to create such complication. You can create a proc from any method very easily in the rare case you need to pass a method as a callback as in your example. module SomeStuff def self.do_a_thing(a);end end a_callable_object = SomeStuff.method(:do_a_thing)
In the ruby code you link to, there's pipes in the blocks for passing arguments. On your site the snippets don't show those blocks and seem to show quotes or nothing around the block arguments.
I still not get it. I removed `class &lt;&lt; self` and required the module. I removed the include completely and the module still works. If you require a file Bar it has the behavior of Foo. module Foo def Foo.bar puts "Hello" end end If I require it, I can use it as `Foo.bar` without any includes and it makes sense, as the code of Foo is included in the code of Bar. I am not sure what do I miss.
Could you give your reasons why one should "just" use a function? How would you get this function in the code where it is needed? By accessing it via a global variable? One reason for using modules is that a module can be defined in its own file and `autoload`ed just when needed, therefore reducing load time and memory usage. Another reason for using `#call` is that it is an already available abstraction since Method, UnboundMethod and Proc objects implement it. What is the advantage of using `SomeStuff.method(:do_a_thing)` to get the Method object so that I can invoke `#call` on it, when I just as easily and without an extra step invoke `SomeStuff.call`? It certainly doesn't always have to be a module that implements that `#call` method, any object responding to `#call` is fine. However, using modules allows easy definition of the method and easy testing of the implementation.
so whats the point of the blogpost if the most interesting part is "homework".
Can you send it to me as well? Thanks! 
I don‚Äôt think so. We need tools that create the interfaces between the blockchain/mining apps to Ruby DSL. But most apps are not updated for years. 
I don't know a lot about crypto mining, but I do know that you're calculating hashes over and over and over. It would seem that the ideal language for this task would be the "fastest one", since a slower one is going to be burning a lot more CPU for an equivalent amount of hash calculation. In my mind, this is maybe why you wouldn't find a lot of Ruby implementations except maybe as POCs.
Your code looks like it should work, and it does work locally for me. What do you see? Literally nothing printed?
You could look at how the ones developed for Node work and implement the same thing in Ruby. Do you mean you want to build the service that miners connect to, not doing mining itself?
You want to mine cryptocurrency in Ruby? With the best effort in the world, Ruby isn't going to be fast enough for that. You need custom hardware these days to be profitable.
I don't think he's wanting to do the mining in RoR. I think he wants to create the mining pool. I.e., managing verifying a solution, splitting earning over shares, providing the api for miners to connect and get work from the pool. Shouldn't be the worse application of RoR.
Is text.txt I the same directory from which you're running the script?
I forgot to put the text.txt file in !
I forgot to put the text.txt file in !
Hi again! I've been reading over your code and looking a bit more closely at possible options. If this is a single, one-off thing, this next suggestion might be misplaced. However, it seems like this kind of thing could easily evolve into a more general engine for creating this style of game. So, one thing that might be worth looking into is something along the lines of creating your own DSL for describing scenes, skills, inventory items, etc. Think about if you're writing more scenes, what your kind of easy syntax could look like. So, instead of... ChoiceScene.new({ 'number' =&gt; 105, 'text' =&gt; 'You consider further questions for the brothers.', 'next_scenes' =&gt; { 434 =&gt; 'Ask them about Milverton\'s murder.', 449 =&gt; 'Do not ask them anything.' } }) You might have scene "Investigating further..." do text 'You consider further questions for the brothers.' choice 'Ask them about Milverton\'s murder.', :ask_brothers_about_milvertons_murder choice 'Do not ask them anything.', :ask_brothers_nothing end The using slugs for linking rooms is a little bit of an imaginative thing, but, should be doable, if that's a stretch just replace the slug with a number and add something like 'id xxx' to specify a scenes id. Just a thought. :) 
Just curious: What's your slideshow generator / builder of choice? Anyone still using showoff? slidedown? parade? or any other? What's your template of choice? Reveal.js? Shower? or any other? Let us know. Cheers.
If you want to build (mine) your very own blockchains / blocks the [Awesome Blockchains](https://github.com/openblockchains/awesome-blockchains#samples) project has some ruby samples :-) Happy blockchaining / mining.
It sounds like you want OR as well as AND conditions, like this: if ( (a==1 || a==5 || a==6) &amp;&amp; (b % 2 == 0) &amp;&amp; ... ) assuming, "a" is your first number, "b" is your second, etc. that should solve what you want
Why would it be &amp;&amp; if I need it to be 'or'? Doesn't &amp;&amp; mean they all have to be fulfilled? The exercise is just to make sure at least one of the criteria is right.
 [1,5,6].include?(a) &amp;&amp; b.even? &amp;&amp; (2..10).include?(c) &amp;&amp; [0,3].include?(d)
It sounds like the problem statement is wrong. Does it was ANY of the criteria to be fulfilled, or ALL the criteria? The former is what you posted. The latter is the answer above. It‚Äôs either one or the other.
This exactly - I think I was a little quick in reading the post, just replace all the `&amp;&amp;` you see with `||` and you'll get what you need
if the first number is 1,5, or 6, OR the second number is even, OR the third number is between 2 and ten OR the fourth number is 3 or 0, then print accepted
&gt; I tried using ' || ' in between the 3 other conditions, but it wont work. Didn't work. What did work was treating each condition individually, which seems redundant to me. if (a==1 || a==5 || a==6) return accepted elsif...condition 2 return accepted etc etc I was hoping that for something like yours but just using || just gave me errors. I'll try again. Thanks.
No, I don't want to mine. What I want to do is build a mining pool that other miners connect to, and I want to build it in ruby.
Correct, I want to build a mining pool that other miners connect to.
Something like this? return accepted if [1, 5, 6].contains?(a) || b % 2 == 0 || [2..10].contains?(c) || [3, 0].contains? d 
 if [1,5,6].include?(a) || b.even? || [2,10].include?(c) || [0,3].include?(d) # accepted ... end
So, first make sure that your pin parts get split up nicely. Convert it to an array of string characters, and turn those values back into integers. Then just test each condition. The `||` will short circuit -- as soon as it "is true" it will do as it was told. Here's a quickie: def validator(pin) a,b,c,d = pin.to_s.chars.map(&amp;:to_i) puts "accepted" if ([1,5,6].include? a.to_i) || (b.to_i % 2 == 0) || ((2..10).include? c.to_i) || ([3,0].include? d.to_i) end 
won't work, how?
I second this. It would be way easier to read and easier for another developer to hold the logic in their head if each check was it's own discrete method.
A mining pool doesn't hash (or hash very little). It's job is to coordinate lots of miners. The only hashing necessary is to verify the shares (proof of works, hashes that solve an easier challenge than the one for the block). When blocks are found, its value is shared with the miner (once a miner got enough share). This was a very big simplification. The hashing part would be made in a small dedicated binary while the rest is in ruby/rails
I actually did think about writing more of these kinds of games in the future, will definitely explore the DSL option to make a framework for it. thanks for chiming in again.
Why not just match against a regex?
To elaborate on this, you should copy exactly the code you tried, the sample input you gave, the output you received, and the output you expected. 
&gt; third number can be between 2 &amp; 10 Can you clarify how a single digit can be 10?
Can you propose a regex that would fit these requirements? The only one I can think of would be nasty nasty: /([156]\d{3}|\d[02468]\d\d|\d\d[2-9]\d|\d{3}[03])/ If I had to read this code (versus, _e.g.,_ /u/ignurant's `#validator` method), I would fantasize about strangling the person who wrote it.
* `b % 2 == 0` can be rewritten as `b.even?` * `[2..10]` is an array with a single `Range` element. `(2..10).include?` works, though.
Between 2 and 10, so wouldn't it be 3-9 as possibilities? I just copied it from an exercise I was given.
Usually people take "between" to mean inclusive (note that every proposed answer in this thread uses `(2..10).include?`). Even Ruby's `Integer#between?` method (technically [`Comparable#between?`](http://ruby-doc.org/core-2.4.2/Comparable.html#method-i-between-3F)) is inclusive ‚Äî that is, `5.between?(1,5)` returns `true`. Your interpretation is reasonable, but I'd still contend that the exercise is poorly written.
My Ruby is a bit rusty, I should have checked my work in IRB. Oops. 
[removed]
 def validate_pin(pin_code) pin = pin.to_s #make sure input's a string... return false unless [1,5,6].include? pin[0] return false unless pin[1] % 2 == 0 return false unless (2..10).to_a.include? pin[2] return false unless [3,0].include? pin[3] true end Simple, effective, readable. Perhaps gets a bit arduous if you had to validate something longer, but perfect for the use-case IMHO.
I had a problem that I thought would be perfect for a regex. Now I have 2 problems.
Couldn't you just use comments to explain the regex? Genuine question from a noob. Or would this still be considered bad practice?
They'd definitely help ... but regexes can be a total bitch to debug and/or modify later. There are times when regexes are "just the thing" ... in this case it's definitely not the way I'd want to go.
Right on, thanks for elaborating. Good to keep in mind.
 (2..10).include? 10 =&gt; true (2...10).include? 10 =&gt; false So you want the "three dot" range operator. And if it's really supposed to be "between" and exclusive on both ends just do: (3..9).include? 10 =&gt; false (3..9).include? 2 =&gt; false (3..9).include? 3 =&gt; true (3..9).include? 9 =&gt; true
This is pretty clean. However, I'm pretty sure it has to meet _all_ of the criteria, so switch your ||'s to &amp;&amp;'s and it works. ...and if I had to review this code, I'd ask you to reformat. def validator(pin) a,b,c,d = pin.to_s.chars.map(&amp;:to_i) puts "accepted" if ( [1,5,6].include? a &amp;&amp; b % 2 == 0 &amp;&amp; (2..10).include? c &amp;&amp; [3,0].include? d ) end
``` def validate_pin(pin) return false unless pin.length == 4 [1,5,6].include?(pin[0].to_i) || pin[1].to_i.even? || (2...10).include?(pin[2].to_i) || [3, 0].include?(pin[3].to_i) end validate_pin('1111') # =&gt; true validate_pin('0212') # =&gt; true validate_pin('2131') # =&gt; true validate_pin('0100') # =&gt; true validate_pin('0101') # =&gt; false validate_pin('narwhal') # =&gt; false ```
I went all [Fizz Buzz Enterprise Edition](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition): class PinValidator attr_reader :pin def initialize(pin) @pin = pin.to_s.rjust(4, '0') end def valid? length_valid? &amp;&amp; (first_digit_valid? || second_digit_valid? || third_digit_valid? || fourth_digit_valid?) end private def length_valid? @pin.length == 4 end def first_digit_valid? @pin[0] == '1' || @pin[0] == '5' || @pin[0] == '6' end def second_digit_valid? @pin[1].to_i.even? end def third_digit_valid? @pin[2].to_i &gt; 2 &amp;&amp; @pin[2].to_i &lt; 10 end def fourth_digit_valid? @pin[3] == '3' || @pin[3] == '0' end end class String def valid_pin? PinValidator.new(self).valid? end end '1111'.valid_pin? # =&gt; true '0212'.valid_pin? # =&gt; true '2131'.valid_pin? # =&gt; true '0100'.valid_pin? # =&gt; true '0101'.valid_pin? # =&gt; false 'narwhal'.valid_pin? # =&gt; false 
I missed the *any*, it was nicer in my head as [156][02468][2-9][03] 
The other code examples all work (I think), but I would definitely use this one for the coding style. Add a comment before each line or at the end of each line to describe what you're checking as well. I try to write code under the principle of "write so that it's easy to debug 6 months later at 2 AM". When your messaging app is being blown up by the operations team saying "IT DOESN'T WORK ANY MORE!!11!" then it really helps to not have to figure out whether there's an obscure bug in those one liners that other people have written.
That's not the ruby logo, this is https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Ruby_logo.svg/200px-Ruby_logo.svg.png ...?
I'm not a lawyer but I don't think such a plain representation of such a common object / shape as a gem could have trademark enforced outside a very narrow space of direct competition, i.e. where there was a chance of people mistaking one entity from the other. No one's going to get confused and try running bundler in there.
I do apologize for that typo, I see, but this looks like really close version (the vector lines matches). You cannot just copy e.g. Windows logo and change it a bit and say it's not the same, or can you ?
Yes but windows logo is it‚Äôs own thing. Rubies and ruby designs/logos were around well before the language. I highly doubt it‚Äôs a ripoff. There‚Äôs just not a lot of ways to modify a classic image like that
I see, so what you are saying for example this: https://dzkuxpo8tx7lr.cloudfront.net/assets/RubyThursday-Logo-Big-cbd1a6af2df4ee7b022f03eadeac6c736ebb1f0b1593d8e582e0866c967d3950.png they are not using the official Ruby lang logo but just random logo of a ruby. So does that store One thing is for sure, my girlfriend agrees with you. 
hmm I see I got confused as I seen this exact logo with other Ruby related events/companies (e.g. https://dzkuxpo8tx7lr.cloudfront.net/assets/RubyThursday-Logo-Big-cbd1a6af2df4ee7b022f03eadeac6c736ebb1f0b1593d8e582e0866c967d3950.png) I thought it was the official logo. &gt; No one's going to get confused and try running bundler in there. Well you never know, like I said I was walking from a bar yesterday, I could have walk there demanding real multi-threading feature in MRI :) 
Matz said no years ago: https://bugs.ruby-lang.org/issues/7792 He did this because the economic impact of the change you want is much larger than the loss of a Mars probe. He already tried adding the equivalent incompatibility and found it more costly than we can likely estimate. If you risk "catastrophe" because ruby has Symbol and String, perhaps Ruby isn't the best language for your work. There are a number of languages that have better safety guarantees for you.
Triple-dot is certainly an option, but for a beginner who's asking for help getting the `||` operator down, I think it's a distraction from the more foundational lessons (stylistic and syntactic) to be learned here. While we're on the subject, `(2...10).include?(2)` returns `true`, which is not intuitive and definitely worth noting.
Remember also that code may fall "out of sync" with the comments, and with a regular expression, it's especially difficult to catch. There's more than one way to skin a cat; your job should be to know as many of them as you can so that you can choose the best one for a given situation. If you knew about guard clauses (/u/Gnascher's answer) or well-named helper methods (/u/ignurant's answer), you'd be better off with them over a regex.
Ruby Pigeon is one I follow.
It would still be a mess. If you live in America, and have to call your grandmother in Asia, when do you call?
http://rubyblog.pro is a good one
https://tenderlovemaking.com/
It's how you draw a gem, they draw diamonds the same way there's nothing sinister going on here.
You could use regex, but to do it in a way that doesn't make 6-months-later-you and your team insane when you need to make a tiny change would look very similar to other ways of doing it without regex, and would be far more obvious. It's important to keep code obvious and simple rather than "creating a master 1-liner solution". I love me some good one-liners, but only when they are clever. Complicated regex are not clever. Sometimes they are necessary, but stringing simple methods that describe what they do in english are far more clever. The most important lesson I've learned about programming is that requirements change. It's just the reality of providing a solution -- the next natural progression is to think of how that can be improved. That means changing code. With that in mind, consider the method /u/ryanlue proposed above (even with really fantastic comments). A new requirement is that ALL of these rules must be followed (instead of any individual), and we also want all of our numbers to be even, in addition to the previous requirements. Yes, you can change this. But when regex get complicated, it's harder to identify the parts that needs to change. Having smaller, individual lists of rules that you string together is far easier to comprehend more quickly, and will lead to far fewer bugs. With all of this in mind, you could still use regex to solve this in way that is less difficult than a single master one-liner -- but it would look very similar to other proposed solutions, and still be more difficult to grasp. At that point, you might as well just use methods that actually mean something.
Awesome, thank you.
I would image you are right, but I was replying specifically to OPs comment that it was explicitly "or". I'm not against the idea of that format change. It's better than it all on one line. But that's also why I proposed putting the individual parts into their own methods too.
As someone who lives in a regex world (doing web ETL) -- this is so so so true. Sometimes complicated regex are necessary. This is not that time.
Planet Ruby lists 150+ sources, see &lt;http://planetruby.herokuapp.com/sources&gt;
&gt; openssl genrsa -out deviceCert.key 2048 &gt; &gt; openssl req -new -key deviceCert.key -out deviceCert.csr &gt; &gt; openssl x509 -req -in deviceCert.csr -CA sampleCACertificate.pem -CAkey sampleCACertificate.key -CAcreateserial -out deviceCert.crt -days 99999 -sha256 Wow thank you so much! i just got it working using that rdoc. your a life saver
http://www.rubyflow.com/ But anybody can post things there.
This is a good post: https://medium.com/@baweaver/reducing-enumerable-the-basics-fa042ce6806
The Honeybadger blog is pretty good.
Thanks, that was helpful.
Some are aggregated on the aggregator I run, https://rubyland.news/
Can't upvote enough. 
I‚Äôm partial to https://www.schneems.com also https://speedshop.co
i doubt it. do you mean 'Rails' when you say 'ruby'? Ruby as a language and python as a language are pretty comparable. 
I follow and endorse rubyland!
I see know . You are absolutely correct . I think either my spellchecker or code highlighter stripped them off . I‚Äôll fix that . Thank you !!
Now you just need a way to have it load those business rules via XML
Shameless self promotion : http://www.eq8.eu/blogs
&gt; That would completely destroy a lot of Hash use cases. Like what? In all my time writing Ruby I can't recall a single time I wanted to mix string and symbol keys in a hash.
String literals when used in a hash literal are already frozen: my_hash = { 'a' =&gt; 1 } # 'a' is frozen automatically. my_hash['a'] # 'a' is frozen automatically.
Ruby is not js, Hashes can and are keyed by a lot of data structures. You can even key them by Arrays of multiple data types etc. Making Hashes magically have exception like this will completely break use cases like memoization caches etc. This is js tier stuff.
What does JS have to do with this? What do memoized caches have to do with this? The only question as hand is if `"a"` and `:a` hash to the same key. 
If `"a" == :a`, then that sort of makes sense that they hash together, but at this point why even have separate types? Having two values where `"a" != :a`, but they hash to the same one is just js-tier insanity. That's just not how Hashes are supposed to work ever.
&gt; If "a" == :a Not arguing for `==` equality. &gt; That's just not how Hashes are supposed to work ever. It's not uncommon at all, in any language, for value equality to have different semantics than Hash-Map equality. There are plenty of cases in Ruby already, e.g. `1 == 1.0 =&gt; true` but `1.eql? 1.0 =&gt; false` 
&gt; It's not uncommon at all, in any language, for value equality to have different semantics than Hash-Map equality. The difference always goes the other way. Seriously, can you think of any non js-quality language where things can hash-equal, but don't `==`?
Java.
https://www.rubypigeon.com Link for those interested
Java doesn't have `==`. Java `==` is identity operator, not equality operator.
http://iridakos.com
nice piece! :+1: 
I've recently released saharspec 0.0.3. Saharspec is an experimental set of RSpec matchers and addons for DRYer and more concise specs. Version 0.0.3 includes `its_call` and `ret` constructs as discussed previously (at the end of [this blogpost](http://zverok.github.io/blog/2017-11-01-rspec-method-call.html)): subject { object.method(:some_method) } its_call(1) { is_expected.to raise_error } its_call(2) { is_expected.to ret '2' }
I disagree with your premise that this: subject { object.method(:foo) } its_call(:a, :c) { is_expected.to ret [0, 1] } is in any way better than the standard rspec approach: subject { object } it { expect(subject.foo(:a, :c)).to eq [0, 1] } You haven't made the code any shorter; you've just added complexity by introducing an additional custom DSL (and gem dependency). ...In face, I don't understand the `ret` matcher at all.. Why would you use that over `eq`?!
&gt; You haven't made the code any shorter In fact, I did :) In a term of concepts used and their visibility. And it shows itself when you have not one, but several tests with several different arguments. Let's play: subject { [1, 2, 3] } it { expect(subject[0]).to eq [1] } it { expect(subject[0...-1]).to eq [1, 2] } it { expect { subject[:b] }.to raise_error TypeError } Reads as: * subject of testing is some array * we say, that when we call `array[0]` it behaves this way * we say, that when we call `array[1...-1]` it behaves that way * ... What cases are covered buried in the middle of the test. "What we test really" (behavior of `[]` method) buried in the middle of the test. Why those tests are the group is not clear, maybe we should add `it { expect(subject.at(1)).to ...` to the same group, it is accessor too.... Now: subject { [1, 2, 3].method(:[]) } its_call(0) { is_expected.to ret [1] } its_call(1..-1) { is_expected.to ret [1, 2] } its_call(:b) { is_expected.to raise_error TypeError } Reads as: * we test array's method `[]` * ...we specify its behavior for different args (it is pretty well visible on `rspec --format doc`, and in failure messages) * DSL is used to document the structure.
So... service objects then
 a = foo if a.success? b = bar(a.unwrap) ... could be refactored to foo.then do |a| bar(a) end which I think is cleaner than creating a separate class and hiding the control flow behind some "magical" `organize` method. You can clean this up even further if you provide a method for each step: foo.then(&amp;method(:bar)).then(&amp;method(:baz)) (For anyone curious: `then` is the monadic bind `&gt;&gt;= :: m a -&gt; (a -&gt; m b) -&gt; m b` and in Haskell the do notation can be used to escape callback hell)
Fierce. Also totally correct. üôå
Jesus Christ it's 2017 and we're still talking about service objects in Ruby?
I would not comment that at all... the method name says what it is doing well enough to document... and the implementation is pretty straight forward... The 'documentation' would be the test cases... if I found something passing or not passing that should not be... I would add that to the test suite Then I would change the code to make it pass... I am not anal about testing, but this is a poster child for when it should be done... 
I consider that a pretty straight forward regex... and I would use it in code 'only I' was working with or in a very UNIX heavy shop. I would not put heavy regex in a shop that was mainly younger / junior devs regex is SO handy when you know them well... and SO frustrating when you don't btw junior guys... you will never regret getting good at regex.
I bet you write great code... and I know you are being verbose for the junior guys... but I would go all ape shit if I had to wade through 10K lines of that ;) But you DID put it in a class so I would not have to...
via a SOAP / WSDL SOA interface
written in Java
BTW.. this brings up an EXCELLENT teaching point... If your were to wrap your tests in if __FILE__ == $PROGRAM_NAME end You could have your test suite with the code it is testing... I do this quite a bit for small one offs and sometimes use it on bigger code that is Orthogonal
FYI, folks, if you put 4 spaces in front of something it formats as code like this.. print "What's your favorite number?" fnum=gets.chomp if fnum&gt;10 puts "Your favorite number is greater than mine!" elsif fnum&lt;10 puts "Your favorite number is less than mine!" else puts "We have the same favorite number!" end /u/semanticart did a great job of explaining, but just another FYI, you will not see a lot of code like this, we would probably use the [case](https://www.thoughtco.com/case-switch-statement-2907913)
I don't know Haskell, but I was thinking something along the same lines. This `organize` thing looks like it wraps every operation in a promise that only has the "success" branch.
Well played sir 
&gt; This `organize` thing looks like it wraps every operation in a promise that only has the "success" branch. I think this is a good way to think about it: A resolved promise (`Promise.resolve("some result")` in JS) should behave the same as the usual result types (`Maybe`, `Either`, `Result`, `Option`, ...)
Then you got the problem of what to do if a business day stretches across "midnight" in your global time. The number of possible race-conditions is mind boggling if you change the date during shopping hours. And think about literature and culture: You would need to know the heritage of the artist and consult a world map to understand any time mentioned You also still have to remember the offset for different countries around the World: It's 1400 in Greenwich; do you call your engineer in China ? So you'll have to remember the offset between Europe and China, but if you move to the US, you'll have to learn a new set of offsets. Sounds cumbersome ? It is. So to aid your memory, and not to create complete confusion on the internet, you'll come up with a global system of offsets relative to Greenwich. And you'll probably then be giving them nicks like CET, EST, CST etc. as an aid to memorizing them, and then we're basically back to where we started Time *is* a mess. There are no good solutions
Well, `eq_multiline` is nice. 
We are using the interactor pattern in a codebase and I really dislike it. People use awful names (though that's a larger problem) They don't really support keyword arguments. If you call the interactor in 2 places and are missing a key downstream argument it can be annoying to debug/difficult to enforce consistency. They end up in a junk drawer of `app/interactors/`. The `context` becomes cluttered and inconsistent when chaining interactors. The place where they do beat PORO service objects are when you use Organizers to chain interactors. But if any interactors have a one-to-many relationship you can forget about it. Sorry to be salty, they're a cool design pattern for some but not all cases and can be misused.
I need to remember to do this. Thanks for the reminder!
From my recollection, that's how the game often shakes out - the players trade advantage, and because the order is predetermined, you simply get stuck in a holding pattern. Maybe increasing the number of players would lead to a different outcome.
Also, you might want to check how well shuffle randomizes an array, especially with repeated values. 
You're not handling the "war" portion of the game correctly. When the cards match, each player places 3 cards face down and the fourth face up. Repeat if necessary. Winner takes all.
After some reading, apparently the three cards down thing is a variant. Normally you place one card down. Here's an example: class Player attr_accessor :deck attr_reader :name def initialize(name) @name = name @deck = [] end end class Game def initialize(player1, player2) @p1 = player1 @p2 = player2 setup end def setup @starting_deck = Deck.new.shuffle puts "This is the size of the starting deck: #{@starting_deck.length}" @starting_deck.each_with_index do |card, index| if index.even? @p1.deck &lt;&lt; card else @p2.deck &lt;&lt; card end end end def play counter = 1 war_chest = [] until @p1.deck.empty? || @p2.deck.empty? puts "This is loop number #{counter}" puts "This is #{@p1.name}'s deck: #{@p1.deck}, which is #{@p1.deck.length}" puts "This is #{@p2.name}'s deck: #{@p2.deck}, which is #{@p2.deck.length}" p1_card = @p1.deck.shift p2_card = @p2.deck.shift if p1_card &gt; p2_card @p1.deck &lt;&lt; p1_card @p1.deck &lt;&lt; p2_card @p1.deck.concat(war_chest) war_chest = [] puts "#{@p1.name} won" elsif p2_card &gt; p1_card @p2.deck &lt;&lt; p1_card @p2.deck &lt;&lt; p2_card @p2.deck.concat(war_chest) war_chest = [] puts "#{@p2.name} won" else unless @p1.deck.length == 1 war_chest &lt;&lt; p1_card war_chest &lt;&lt; @p1.deck.shift end unless @p2.deck.length == 1 war_chest &lt;&lt; p2_card war_chest &lt;&lt; @p2.deck.shift end puts "WAR!" end counter += 1 end end def result @p1.deck.empty? ? winner = @p2 : winner = @p1 puts "This is #{@p1.name}'s final deck: #{@p1.deck}, which is #{@p1.deck.length} long" puts "This is #{@p2.name}'s final deck: #{@p2.deck}, which is #{@p2.deck.length} long" puts "#{winner.name} is the winner. Please give them a cookie" end end class Deck BASE = [] [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13].each do |number| 4.times do BASE &lt;&lt; number end end def shuffle BASE.shuffle end end player1 = Player.new("Johnny") player2 = Player.new("Sally") game = Game.new(player1, player2) game.play game.result 
That's a pretty cheap, low context, shot. The Honeybadger gem rescues Exception five times, and I suspect Rails is more than seven times larger. (For that matter, I only count 22.)
:) 
&gt; What cases are covered buried in the middle of the test. "What we test really" (behaviour of `[]` method) buried in the middle of the test. Why those tests are the group is not clear, maybe we should add `it { expect(subject.at(1)).to` ... to the same group, it is accessor too.... If you structure the tests together, and keep them simple, it's quite obvious why they belong together (and that `subject.at(1)`does not belong in the group! describe '#[]' do subject { [1, 2, 3] } it { expect(subject[0]).to eq 1 } it { expect(subject[0...-1]).to eq [1, 2] } it { expect { subject[:b] }.to raise_error TypeError } end I can see *some* benefit to your `its_call` method, as it effectively defines the subject to be the method call itself. However, I don't think the benefit it actually as significant as you make out. Especially since you also lose the flexibility to explicitly describe the expected behaviour as the title of each test, e.g. describe '#[]' do subject { [1, 2, 3] } it 'returns the value at a given index' do expect(subject[0]).to eq 1 end it 'returns a list of values between a range on indexes' do expect(subject[0...-1]).to eq [1, 2] end it 'raises TypeError when passed a symbol' do expect { subject[:b] }.to raise_error TypeError end end ...And as I said above, I still don't understand the `ret` matcher. That seems like an unnecessary alias for `eq`. To be honest, I'm quite biases since I'm against the `its` matchers in general; I think they were removed from core `rspec` for good reason. In my opinion, it's better to be a *little* more verbose in the tests, at the cost of having a simplified DSL.
&gt; If you structure the tests together, and keep them simple, it's quite obvious why they belong together (and that subject.at(1)does not belong in the group! Obvious for whom? For your colleague, who adds another method's test in half a year? Nothing stops him from adjusting specs this way: describe '#[]' do subject { [1, 2, 3] } it { expect(subject[0]).to eq 1 } it { expect(subject[0...-1]).to eq [1, 2] } it { expect { subject[:b] }.to raise_error TypeError } end it { expect(subject.at(1).to eq 2 } it { expect(subject.values_at(1, 2).to eq [2, 3] } it { expect { subject[2] = 1 }.to ... Because why not? In fact, in your examples you _do introduce_ DSL, just it is "DSL in text descriptions", which is pretty arbitrary (doesn't bring any value to the programmer, doesn't makes their life easier, introduced just guideline-style, and then neglected). &gt; Especially since you also lose the flexibility to explicitly describe the expected behaviour I believe there are two "schools of thought (about testing)" clashed here. I believe in tests that are easy to write (and therefore we write a whole ton of them), and that doesn't need (in most of the cases) text explanations "what this test does". Therefore I invent a lot of matchers and other tricks to make my code (tests are also code, you know) DRY and expressive, and omit text descriptions. TBH, when I need to write something like this, I became really sad panda: it 'raises TypeError when passed a symbol' do expect { subject[:b] }.to raise_error TypeError end ...because this code is explicitly read as: 1. it raises TypeError when passed a symbol 2. we expect that subject, when passed `[:b]`, raises `TypeError` One of those two statements is not THAT necessary, you know :) I want to have it DRY. I believe that desire to write tests this way came from more verbose languages and frameworks, which has one line description and then 10-lines implementation of the test, but I can't see why I shouldn't just write its_call(:b) { is_expected.to raise_error TypeError } ...and call it a day. &gt; ...And as I said above, I still don't understand the `ret` matcher. That seems like an unnecessary alias for `eq`. expect(1 + 1).to eq 2 expect { 1 + 1 }.to ret 2 &gt; In my opinion, it's better to be a little more verbose in the tests, at the cost of having a simplified/consistent DSL. Two schools, as I've said. My biggest concern is the more verbosity (don't be shy, it is not _a little_ more verbose at all) leads to the fact that people tend to write less and less tests. Tests _is_ code, and anything that leads to more concise and readable code is good. On my experience, typically two opinions "test framework shouldn't be too smart and DSL-y" and "in fact, you don't need to test anything, and TDD/BDD is a failed idea" typically came from the same people ¬Ø\\\_(„ÉÑ)_/¬Ø
&gt; There are some guidelines, like: ‚Äúit should be a PORO (Plain Old Ruby Object)‚Äù ... &gt; But I‚Äôd like to use the example of a more popular gem for handling such objects, the gem interactor. That's a huge contradiction there. And the #1 problem why your "service layer", "interactor pattern" or whatever you call it, grows into its own spaghetti after months of development. &gt; I heard you use a service-layer in your app. What gems do you use for that? We don't. These things are so simple, so generic and so easy that you really don't need a gem for it. A gem comes with some downsides, which is another topic alltogether. In any case: depending on a gem to handle the most simple, three- or four-liners of Ruby is always a bad choice. **You don't need gems for service objects**. If you do, you've made them too complex, too hard and do far too much. You can fill in *factory*, *decorator*, *state-machine* and many more concepts for "service-layer", by the way. Most -if not all- are, in essence so simple, 10, 20 lines of easy ruby, that there is no need at all to depend on a gem for them. 
Is anyone else worried that this falls into the trap of [Execution in the Kingdom of Nouns](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html)?
[removed]
I'm sorry that came across as criticism of Rails, it wasn't meant to be. I'm just illustrating that it is done in rare cases, and error reporting is certainly one of those. As for the number, this is how I got it (it looks like one has been removed since I wrote the article): ``` ‚ûú rails (master) ‚úî grep -r "rescue Exception" . | wc -l 36 ```
Codecademy isn't going to be enough. I recommend you go through a more thorough tutorial. I personally like Hartl's railstutorial.org, but there's other popular ones, like the Odin project.
Should I continue with the codecademy then move on to this or just stop where I am and start these?
I would just start with one of the others. The gap in application is just too large for codecademy to be useful imo.
Thank you. I appreciate it. I am about half way through and I often get stuck on something that was barely touched. Get spretty frustrating sometimes.
Awesome article! It never occurred to me to use views to solve the `insert_returning` issue. Just an FYI, I think there are two different `pg_party` projects out there :( I'm the author of [this one](https://github.com/rkrage/pg_party) (an ActiveRecord extension for PostgreSQL 10 declarative partitioning). I'll have to get in touch with Erkan to figure out this naming conflict.
Interesting, is that what happens when people play War in person? How do they get to a winner? Whats the point of the game then? It seems from what /u/spitlets is saying, I am missing an element of the game.
Ah, he's right: I did forget about what to do if there's a tie. And I did grow up doing the traditional 3 cards down, one card up version. But still, you can end up in those holding patterns like I said.
Check out The Odin Project. Full Ruby and RoR curriculum that teaches everything you need to be employable. Great community as well
I am currently doing the Odin courses. This is great, exactly what I needed. I havent touched a command line in a long time and they require it. Is a nice refresher on everything. It is formatted well. Thanks!
exactly what i was thinking. &gt; Not nice. In fact, it‚Äôs called conditional hell. Enter Organizers. An Organizer is a special kind of Interactor that has one responsibility: to call other interactors in a given sequence. is "noun hell" a thing?
&gt; While working in Toptal, I saw the development culture which allowed 200+ developers being able to work simultaneously and effectively on a large codebase, written in the dynamic language (Ruby), because they have everything covered with specs. How large was that code base and was it 200 independently deployed microservices or one monolithic application? The testing issue aside: How do you even coordinate so many people in the latter case? That's what I'd be interested in reading. The TDD vs BDD or test syntax discussions are kinda uninteresting/irrelevant to be honest.
https://github.com/jonbuda/miro
Get used to it. Rails devs have a console or more open 24/7!
Nice! üëç be sure to stop by the Gitter Chat room if you have any questions. Super friendly people
https://rubygems.org/gems/color Recently did something similar, blog post with background on the problem here: https://www.cronofy.com/blog/calendar-colors/
It's pretty late, but I may have a proper go at this tomorrow... Here's my best leaderboard score so far, on Evil Numbers; I reckon there must be some way to beat this though: puts (0..50).select{|n|n.to_s(2).count('1').even?}
&gt; The TDD vs BDD and syntax discussions seem kinda arbitrary I read the article as: BDD + syntax ‚Üí less testing friction ‚Üí developers write more tests ‚Üí easier to coordinate lots of devs in a single codebase. 
Yes, there is :)
Are you planning to add more holes?
I got it down to 48 from 50: `p *(0..50).reject{|n|n.to_s(2).count('1').odd?}`
That's actually 47! Nice one. I didn't think of using reject like that.
I'm not OP but this is exactly what I needed. Thanks.
My bad! I had an accidental space at the end when I counted it.
/u/JRaspass on Seven Segments hole, what method name should be used to accept the input??
I can flip back and forth on this. I understand your point, and sometimes think that. But sometimes what seems simple can have weird edge cases that you run into and have to deal with, and why do that if you can use someone elses that already figured em out? And especially if you are writing gems (perhaps with a community) that need to work together, it can be very handy to make sure to use an _exactly consistently working_ abstraction in all of them, the same one, so everything works consistently (so developers know what to expect once they've seen it once), and so things can work together if they need to. If the dependency really is as simple as the 'interactor' gem (a few hundred lines of code?), the _cost/risk_ of using it is pretty low too. So, as with everything, I think it depends. If you're reaching for it out of laziness or because you think you couldn't write it yourself, you can easily end up with over-engineered over-abstracted too-much-stuff. You might not need an 'interator' pattern _at all_, indeed. But if you do, say cause you really do need some kind of 'dependency injection' of commands/interactions that can be composed (don't do it ause it seems like it might be handy, just do it when you _really need it_, it's solving some problem you actually have) -- it can be handy to take one off the shelf from someone who has already figured out a simple API that works for actual use case patterns (just cause it's simple doesn't mean it's _easy to design_) and has already figured out the weird edge cases, and then use it consistently everywhere you need such a thing so everything stays consistent and parallel. 
TIL about `fatal`
`'1'` can be shortened to `?1`
Any hole with arguments are supplied in ARGV, so in Seven Segments you will receive a random 10 digit number in ARGV[0]. I probably need to add some FAQ with hints and tips like this, the website is still very young, thanks for the feedback :-)
Here's where I got with Arabic to Roman: ``` D={M:1e3,CM:900,D:500,CD:400,C:100,XC:90,L:50,XL:40,X:10,IX:9,V:5,IV:4,I:1};puts$*.map{|n|D.map{|l,v|a,n=n.to_i.divmod(v);l.to_s*a}*''}-['']``` Or, in a (very slightly) more readable format: D={M:1e3,CM:900,D:500,CD:400,C:100,XC:90,L:50,XL:40,X:10,IX:9,V:5,IV:4,I:1} puts $*.map{ |n| D.map{ |l, v| a,n=n.to_i.divmod(v) l.to_s*a }*'' }-[''] Any help is appreciated! ___ /u/JRaspass, with this hole + ruby, there is an unexpected arg at the beginning. You can see it with 
Ooo, good catch! Code Golf does the equivalent of this when running your code: $ echo 'puts ARGV' | ruby - -- 123 456 -- 123 456 I was trying to be safe by telling the interpreter that no more flags follow, instead I'll just drop the double hyphen and do this: $ echo 'puts ARGV' | ruby - 123 456 123 456
Awesome work! Thanks for the quick response. 
&gt; How large was that code base Pretty large :) Hundreds of thousands of LOC in thousands of files. &gt; and was it 200 independently deployed microservices or one monolithic application? Mostly well-organized monolith. &gt; How do you even coordinate so many people in the latter case? Well, it is pretty interesting story indeed (shortest answer possible: through high internal culture, ton of specs and features, CI, and a lot of freedom for individual teams), but I am absolutely not sure I am authorized to write on this, as I am not working with them now. &gt; The TDD vs BDD and syntax discussions seem kinda arbitrary and uninteresting to me to be honest. Thanks. It is always important to know some people on internetz found your writings uninteresting.
I tried that, but it's the same length: x.odd? x&amp;1==1 However, I've also found a much better way to do it... I'll just need to submit my entry several trillion times until it passes :D p *(0..50).to_a.sample(25)
You are right. As I mentioned aside: whether or not to use a gem for stuff is a whole different conversation. And even here, you *may* want to encapsulate your logic in a gem. However, our BaseService has the following features: * Everything is dependency-injected. Even stuff like `Member.active.find_all is discouraged, instead you go `@member_finder.find_all`. * It can run in database transactions or not, using a silly DSL (`transaction do end`) * It's public API consists of `CreatePost.build` to build with the default dependencies injected, `.new` to inject your own, `#call`to actually run the service, which allows a block: CreatePost.build.call do |status, model| @post = model if status redirect_to @post else render_errors @post.errors end end All this, is placed in a `BaseService` that is approx 50 lines of Ruby, half of which are "fluff" like `class`, `defs` `attr_reader :model` an so on. Sure, at some point it is a good idea to move this into a gem, because that allows nice encapsulation; allows all the BaseServiceTest unit-tests to be moved from the app-unit-tests into a gem-unit tests and so on. But for now: all that overhead is certainly not worth it. 
Ah i so rarely write command line stuff that it didn't occur to me!
Sounds like you're looking to calculate visual color distances. I've used the CIEDE2000 algorithm for this in the past and there are already a couple gems available to do this calculation for you: [RubyGems.org](https://rubygems.org/search?utf8=%E2%9C%93&amp;query=CIEDE2000)
Thanks for responding. That's quite a feat to manage so much Ruby code efficiently! &gt; Thanks. It is always important to know some people on internetz found your writings uninteresting. Sorry, maybe I was too negative. It's just the opinion of some random guy on the internetz, though and according to the upvotes most people seem to be interested. &gt; "I don't want to know your approach, it is just syntax!" That's not what I said. I very much care about what other people's approaches are. However, I find it hard to believe that such a minor change as adding a DSL on top of RSpec has such a huge influence on people's tendency to write/change specs [1]. Personally whether I had to use minitest, JUnit, RSpec, HSpec, ... didn't make a difference. I think the unit under test plays a bigger role. E.g. while I despise writing end-to-end tests through a browser with async JS, I have no issues writing unit tests for pure functions - no matter how verbose the test syntax is. [1] To be fair: I will probably only be convinced if someone sets up a study which forces the control group to use "pure" RSpec.
I'll take a look
The thing I like about having `it` blocks with descriptions it that I also have a textual explanation for what that code is testing, just in case I don't understand the code at first. I think descriptions also decrease that chance that we will accidentally delete a useful test because we don't understand its purpose anymore 3 months later. It's also nice that you're forced to put into words what is it that you are testing. What I don't like about the `it { is_expected.to }` syntax is that it cannot be consistent. Many tests will need to be written into multiple lines, and for that you'll need/want to have descriptions. You'll also need to think about whether the `it { is_expected.to }` assertion generates a good description. It's not good to have tests which have cryptic descriptions. For example, when you're making assertions with test data, then you probably shouldn't let test data values bubble up to the example descriptions, due to the reasons you [linked](https://gist.github.com/myronmarston/4503509). All of this means you'll sometimes be using descriptions and sometimes not. I don't like this inconsistency, because I have to have this additional overhead of choosing which style I should use. At work we agreed to use RSpec instead of Minitest on a new project, but we agreed not to use the `its` DSL. Of course, this is just my preference, I'm not saying that it's wrong to prefer the `its` DSL. As I understood its main pitch is that you can avoid having to write and later read `it` description blocks, but I never found that cumbersome, I always *wanted* to write and read them.
Shouldn't something like this be handled by the reverse proxy/web server already?
&gt; Sorry, maybe I was too negative. Whoops seems like now I should be sorry for unnecessary sarcasm :) Though, I am still not sure what message should be read from communication "Here is a post I wrote about something important to me." -- "No, it is not interesting". But whatever. &gt; I find it hard to believe that such a minor change as adding a DSL on top of RSpec has such a huge influence on people's tendency to write/change specs Now we are talking! But the DSL was not my point. My point was: tests should be treated as code, and programmers should be allowed to make them as short, elegant as DRY as it possible for the human being. And that's the only condition under which programmes will continue to write them on a regular basis. Particular tools, tricks, DSLs and libraries are not that important. I don't think that this _approach_ is a "minor change", and it is deduced from a wide range of experiences, including large distributed teams of professionals, and open-source projects with a lot of inexperienced newcomers.
Depends on how you're serving your webpages. If you're running behind nginx then yes you can configure this behavior there, but it's not on by default. If you're on Heroku, then you need to do it in the app. It might also be useful if you don't have access to modify the server configuration for example if you're on a shared host. 
&gt; The thing I like about having it blocks with descriptions it that I also have a textual explanation for what that code is testing, just in case I don't understand the code at first. Exactly my point, I just look at it from a different perspective :) For many of us, unfortunately, descriptions are an indulgence to not trying to make the test code clear. And, vice versa, when you are not writing descriptions, you try to make the code speak for itself. In my experience (including working with really large business-related codebases and small yet tricky scientific libs), **most** of the tests (like 80% of them) could be done in one self-explaining expression. Typically, you achieved this by using a lot of contexts/let's/before's, custom matchers and other tricks (like shown in the post). In my head, it is close to idea of "what the specification is". For most cases, "what it should do" can and should be explained in exactly one statement in human language (probably with some preconditions, like "Given this and that"), so I always just try to "translate" this statement into RSpec one. I believe (though can not scientifically prove) that this approach produces reasonably good test descriptions "automatically". (And of course it could be all matter of personal preferences, but I believe that entire idea of "sustainable tests" = "minimal, DRY and elegant test code" has some value above "just preferences".)
&gt; For most cases, "what it should do" can and should be explained in exactly one statement in human language (probably with some preconditions, like "Given this and that"), so I always just try to "translate" this statement into RSpec one. But where do you put these preconditions then, if not in the one-liner? For me that's the key thing here, I often cannot express "what it should do" in one line, because it should do that only given a certain setup code. And I don't like to create `context` blocks just so that I can add a `before` block for a single assertion, because that leads to unnecessary nesting for my taste. I think another difference in my approach is that I also like to have multiple assertions per test, because sometimes it doesn't make sense for me to describe each assertion. And that naturally leads to `it` examples with multiple lines.
Great article, I felt exactly the same when reading Avdi's post, he manufactured badly designed and written service objects and scenarios to back his point, if anything, it felt like more of an "I don't understand how to use service objects so they're bad", for example, just pulling your non-http related controller code into a class method isn't the right way to do service objects, but it does give the advantage of de-coupling your procedure from a difficult to construct controller, making it easier to test in isolation. Another problem was that he wasn't properly identifying the responsibilities in his procedure, as far as I could tell, the transaction required `validation`, `logging`, `token creation` and `sending an email` - the last of which should probably be handled in a background job. Each action could be handled by a dependency, making an instance-level method the better option IMHO. The whole point is that you have small, single-responsibility objects that work together to complete a complex task, working this way makes things easier to test in isolation, and easier to reason about their behavior, that is the point of service objects, and Avdi is missing it.
&gt; And I don't like to create context blocks just so that I can add a before block for a single assertion, because that leads to unnecessary nesting for my taste. Well, I am not a big fan of "context for before + one test" either, but here we are completely on a personal preferences ground. I'd prefer it over including precondition into test a test anytime. But most of the time I find some solutions to avoid that (like the `its_call` which the post started with). &gt; I think another difference in my approach is that I also like to have multiple assertions per test, because sometimes it doesn't make sense for me to describe each assertion. Well, even if I do so sometimes (mostly for performance, when `before` or tested operation is expensive), I tend to join them with `.and`, which somehow makes them "one" expression. But in a lot of cases it turned out that some new composite matcher would be better. Like this: # before -- I am overexagerrating, though expect { some_operation }.to change(Post, :count).by(1) expect(Post.last).not_to be_nil expect(Post.last.title).to eq 'Cool post' expect(Post.last.author).to be_a User expect(Post.last.author.name).to eq 'Bob' # after expect { some_operation } .to create_record(Post) .with_attributes( title: 'Cool post', author: instance_of(User).and have_attributes(name: 'Bob') )
&gt; Each action could be handled by a dependency, making an instance-level method the better option IMHO. Just to clarify: Because you could use constructor injection and not put the burden of constructing the dependencies on the caller?
It's quite a world of pain when you serve complex scenarios, as it doesn't inter operate well with Rack::Chunked / streams and other middle wares. And as it is, it's better handled by a proxy, if you can set up one (and you can setup Brotli). Encoding as a middleware was a bad idea. However, for the simple case of buffered responses where you control the order of middlewares and can't setup a proxy, it's good enough.
&gt; With service objects, you have a single IpnProcessor object and one public method to call. I agree with most of the article, but not this. It doesn't happen all the time, but I have no problem with service objects keeping state *regarding the outcome of the process the service provides*, or for that matter, showing different views the outcome.
Yes, exactly that, you could obviously new up the dependencies inline (or use private class methods), but that makes testing in isolation more difficult as you have to monkey-patch the constant's interface to respond how your test expects it to.
Sounds like you want a process object, not this so-called service object bullshit. 
No, seriously. You seem to have confused single-responsibility for single action. Service objects are the single clearest sign that your code is missing a domain concept. Like in this article above with its appalling `AddGroupMember` ‚Äúservice object‚Äù. Shit like this is a travesty of OO. 
Looks like the Ruby community repeats a discussion the Java(?) world had 15 years ago: https://www.martinfowler.com/bliki/AnemicDomainModel.html
Whenever I see a class with only one instance method like `run`, `call`, `execute`, etc. I am immediately reminded of The Kingdom of Nouns and I start to get worried. What is the benefit of inventing a do-nothing noun just for the purpose of escorting the verb around? Let verbs be verbs and put them in a module. I agree that putting them in a top-level module named after your application is a copout, but that doesn't mean it's impossible to have well-organized modules for keeping various utility methods.
You might want to consider some language-specific rules on these. For instance, for challenges where you have to determine prime numbers, it seems kinda cheap to be able to `require 'prime'` and then call `number.prime?` Or maybe not. Maybe once you have more submissions, you could take a look at the top scores per language and see if there's any tactics which could be forbidden. BTW great job on this project! You have us talking about the challenges/solutions instead of website mechanics, which is always a great sign! 
&gt;Service objects are the single clearest sign that your code is missing a domain concept. Like in this article above with its appalling AddGroupMember ‚Äúservice object‚Äù. Would your preference be for a `GroupMember` model to bridge the gap? &gt; attached to false claims about maintainability. You can't call _my experience_ a false claim. Unless you think I'm lying.
This is cool and I can see where it would be useful for some projects. However, for anything serious, I prefer to at least have two or more of the following for a user - Something they know (i.e., password, security question) - Something they have (i.e., 2FA, email confirm access, magic link) - Somewhere they've been (i.e., history of successful login ips) 
&gt; Whenever I see a class with only one instance method like run, call, execute, etc. I am immediately reminded of The Kingdom of Nouns and I start to get worried. It's a fair concern. One could certainly get carried away. &gt; I agree that putting them in a top-level module named after your application is a copout, but that doesn't mean it's impossible to have well-organized modules for keeping various utility methods. Agreed. You're not supposed to replace every method with a service object. As I say, "It‚Äôs not really a toolbox if you only fill it with hammers." I find that service objects do well when they facilitate interaction between objects and/or encapsulate business logic. Models are left to focus on what they do and can stop worrying about the other stuff (like sending emails). For this post I was pointing out what I've seen and what I've personally experienced. Adding in all of the best practices use would have derailed the rest of the article. Maybe I need to do another one on that. üòÑ
Yeah, I'm still working out how to handle the per language features, I imagine I'll try to put more emphasis on language specific leaderboards and less on the overall leaderboards, probably by adding some kind of checkbox system on the homepage where you can hide the languages you're not interested in. I'm glad you like it! That's really nice to hear, I mainly only wrote this site for a few mates and myself, and I'm aware there's a still a lot to do! It's awesome to see Ruby on the homepage though, can't just have that cheeky Perl 6 everywhere with its crazy shorthands :-P If you have any specific ideas for new features/holes/etc, feel free to add them to the github issue page ( https://github.com/JRaspass/code-golf/issues )
This is why non security specialists should not design auth systems. 
I think you've misrepresented Avdi Grimm's point. I don't think you're lying - just painfully misguided. I can't analyse your business domain for you, so any prescription I make regarding what you *should* have used is likely to be incorrect. However, based on the limited information given in the article, I'd *probably* have written a plain old activerecord model for the process joining a group. Which IMO is quite likely where Avdi Grimm is going with his train of thought: treating business processes as just another persisted model, because processes are a domain concept that deserve that level of recognition. You've said in this article that you have a "lot of respect" for Avdi but maybe you should read more of his work, because this is a line of thinking he's published before and that's where it went in subsequent articles. 
Sadly few people take the time to meditate on the writings of Alan Kay or Martin Fowler. 
Ahh, the good old `plain old activerecord models` that definitely don't couple your domain model to your database schema or have more than 1 responsibility irb(main):001:0&gt; class SchemaMigration &lt; ActiveRecord::Base; end =&gt; nil irb(main):002:0&gt; (SchemaMigration.methods - Object.methods).length =&gt; 471 Why not just use service objects and properly normalise your database.
&gt; Why not just use service objects and properly normalise your database. Why not use a proper domain model (different for each bounded context) in pure Ruby and map your database to that?
I‚Äôve never really seen a need to use dependency injection in Ruby. It makes code interfaces hard to work with and with little benefit since it‚Äôs easy enough to just stub things out in tests. Completely different from the Java world I came from a few years ago where you were shunned for using ‚Äúnew‚Äù inside a class.
&gt; I think you've misrepresented Avdi Grimm's point. I don't think you're lying - just painfully misguided. I think you might be misunderstanding my post. :) The service objects that Avdi presented didn't even really sound familiar to me. They aren't how I've used them or how I've seen others use them. I wanted to point out what I saw as wrong and then give my personal take on how they've helped me. I talk about how I saw a positive change in my teams ability to maintain our application. [Avdi's point was](https://avdi.codes/service-objects/#comment-133): &gt; My entire point in writing this article is that in many cases, step 1 (Step 1: Achieve perfect separation of concerns.) is not only out of immediate reach, devoting time to it may actually be waste. And in that case, hiding a procedure behind the fig leaf of a ‚Äúservice object‚Äù that doesn‚Äôt represent any kind of real concept in the business domain does more harm than good. I tried to address this by pointing out that in my experience, it hasn't been a waste. In fact there have been noticeable benefits. &gt; You've said in this article that you have a "lot of respect" for Avdi but maybe you should read more of his work Perhaps you shouldn't assume that I haven't. Avdi and I disagree on some things. It doesn't mean I don't respect him. I signed up for one of his newsletters at the mention of this article being part of it (before it hit Reddit). I wanted to see what he thought precisely because he was likely to disagree with me. I even ended the article saying that while I'm not seeing it, he may yet prove me wrong. Ultimately, he laid out what I saw as a poor representation of service objects which resulted in a poor tear down of them. I countered with how I've seen them used and what the effects of that have been.
Single public method classes help enforce SRP and encourages testing outcomes holistically instead of instance methods.
I‚Äôd be interested in some advice. I have a bunch of these service objects that I use in my codebase. For example, one is called ‚ÄúSignuper‚Äù with one public method, ‚Äúperform‚Äù. It handles redeeming coupons/referral codes, creating the user‚Äôs subscription with Stripe, sending an email, and a few other things. I like having this all encapsulated in a class, as opposed to all living on my user model just because I can have instance variables and it‚Äôs easier to reason about. Sometimes for these classes, I‚Äôll still make a method on the model that just delegates to the service object, eg ‚Äúuser.signup‚Äù, which calls Signuper.new(...).perform. I‚Äôve been happy with this architecture but curious if anyone has a better idea for how to do things like this.
why?
Define _serious_ :) This works with magic links.
&gt; If you're on Heroku, then you need to do it in the app. AFAIK passenger standalone embeds nginx, so deflate/gzip/assets/etc. probably can (and should) be done in the reverse proxy even on Heroku. 
I appreciate that Aaron is trying to relate his experience with service objects, but it seems like he's arguing past Avdi rather than with him. I re-read Avdi's article just now. I would summarize Avdi's position as two things &gt; There is no shame in writing, or extracting procedural code. Especially in the early stages of implementing a new feature, the needed object roles and responsibilities may be unclear. Procedural code is going to happen, but you need to keep an eye on it and move it into the domain model when roles and responsibilities become clear. If that's the point of debate then maybe this is about whether OO is the right way to architect a web application. I think it is, but I'm open to hearing about how why procedural software is a better solution &gt; There‚Äôs a name for this kind of code: a procedure More specifically, business domain service objects are procedural code hidden as objects. In the section "Procedures: Not just for C code", Avdi defines why he thinks it's procedural and it includes the service object he's using as an example. I'm inclined to agree with Avdi's definition of procedural code, but maybe that's where Aaron disagrees? I agree with some of Aaron's points about the exact nature of Avdi's example, but I was waiting for Aaron's article to address the above two major points and I'm not seeing it. It makes sense to me that procedural code should be minimized and Avdi's argument that business services represent procedural code seems sound. I get that Aaron's experience with business services is a positive one, but I don't think that's contrary to what Avdi's getting at.
That's actually not doing the same thing. It's not compressing html pages which is what i'm doing in the article. It would need to compress text/html $ curl -I https://www.codetriage.com # ... Content-Type: text/html; charset=utf-8 
I tend not to upgrade MRI for features so much as for getting the performance improvements. And also for when a CVE comes out, it's nice to be able to bump a minor version rather than having to do a major upgrade. Same goes for Rails; it's helpful to keep current.
Anything that is revenue generating or that can contain personally identifying information. I can see it as a useful extension to something like devise, but I wouldn‚Äôt want it to be the only option.
My mistake (linked to wrong line). Passenger standalone [enables gzip by default](https://github.com/phusion/passenger/blob/c3713a83/resources/templates/standalone/config.erb#L47), and nginx compresses "text/html" by default (regardless of what's in `gzip_types`). So effectively by using passenger standalone you'd get compression by default (not just for html, but for assets too).
Ahh, great! Thanks for the link!
https://www.decksetapp.com/
What do you mean? Slack for example has passwordless logins, I doubt they would have it if it posed an obvious security threat.
Thanks for making this! I'm not using Rails, but I always wanted to add it to [Rodauth](https://github.com/jeremyevans/rodauth), and it's great to have a place to look for inspiration.
&gt;plain old activerecord model that's a new one... 
It has 471 single responsibilities. Now that's what I call SOLID.
More generally, I suppose there's "indirection hell" and "abstraction hell".
If you name the class/module as a verb, and squint your eyes a little bit, it doesn't look so much like The Kingdom of Nouns anymore. module FrazzleWidget def self.call(widget) # ... end end result = FrazzleWidget.(my_widget)
The caller still has the burden of ensuring the proper dependencies are injected, you just happen to define that in a separate file. It doesn't improve isolation at all.
&gt; The whole point is that you have small, single-responsibility objects that work together to complete a complex task That is called Procedural Programming, which isn't bad, use the right tool for the job. But shoehorning it into a forced OO model where each action is a class with a `call` method is really awkward. Just write clean functions and use them.
I don't write 'Service Objects' because they are an unnecessary concept. If some piece of functionality makes sense to break out into separate functions or objects, then do it. Ruby provides a large set of tools for modeling various domains and interactions, use them as unnecessary to model the problem you are faced with. Trying to stuff all problems into a 'callable object' model is no better than fat controllers / models and quickly leads to a similar mess.
Try r/forhire
Agreed, it can be easy to try to use a tool on knows well in inappropriate ways.
Grails makes the same mistake... 
It‚Äôs borrowing from SAM pattern in Java and C#. It isn‚Äôt needed in Ruby, JS, Scala... 
What sector is the project about?
Outside of Ruby I don't think I've ever seen folks designing "service object" with a single generic method named `call`, `run`, `process`, whatever. The paradigm makes sense for the command or chain or responsibility patterns, but otherwise comes off as a smell. 
Have you looked at SciRuby ?
Yes.
Just a quick pointer and thought... The `iodine` Ruby server offers static file service with `gzip` support (for pre-compressed static files) - this means that static files are served directly by the server, before entering the Ruby layer (no need for the `ActionDispatch::Static` middleware). On the other hand, `iodine` doesn't `gzip` on the fly. It seemed to me that `gzip`-ing on the fly might help with small-load performance however... ...I'm not sure the app should spend CPU cycles on compressing the data, as it should be busy doing other staff (I think Google measured 30% of the nginx CPU time was spent on gzipping data). It seems the proxy is the place for this extra computation load. This is something to think about before advocating Rack Deflate. 
Most people who learn a language learn it for a specific reason. Lots of python programmers come to the language specifically because they needed that scientific computing (in a scripting language form). If you already know and can use python, then you don't have the desire to use the same or similar tools in another similar language like Ruby. One benefit of people using tools is they get better. As people have used python's numpy etc. it gets better. Since Ruby's tooling here is lacking fewer people use it and therefore fewer people invest in it. It's a bad feedback loop. 
Different tools for different jobs. We really don‚Äôt need a programming language that fits all situations 
Yeah, I know... 
Oh look. Another idiot who conflates methods with responsibilities. 
https://github.com/clbustos/rinruby
For that task, I prefer https://github.com/clbustos/Rserve-Ruby-client
Haha, pretty cool to hear from you :)
Rinruby is pretty cool for an agnostic type of work, but when you need a rich feature/robust environment, an not so slow, you could go with rserve. rsruby is very fast, but is a little unstable. Look at this for a good review: https://es.slideshare.net/sausheong/rubyand-r 
Good thing you asked then!
Do you mean the title? it was simply a rhetorical question / Rant.
Jruby is nice here. You get access to all the existing Java ecosystem, which has lots of scientific computing packages available.
Yep, the python community made a huge investment in scientific computation early on. Additional contributions came to this code base because these kinds of networks behave in a "rich get richer" manner, for a variety of fairly obvious reasons. Ruby has good/decent scientific programming tools compared with all other scripting languages except python (we'll ignore R and Matlab because they're scientific by nature). But, yes, ruby is playing catch-up in this domain. I used ruby almost exclusively for my scientific programming from 2006 until 2014. That meant that I had to write a bunch of my own tools (which, incidentally, can be published in their own right), but I enjoyed doing that. But the tools that were available were good enough. For instance, narray or sciruby's nmatrix may not be as mature as numpy, but they aren't shabby either. So, you have to accept that if you want to do science in Ruby you may end up writing some of your own software. That takes a lot of time and effort, but you also learn a ton in the process. 
So what's the responsibility of an ActiveRecord model? Is it describing data structure? Is it mapping to your favorite DB? Is it persistence? Is it validation? Or is it, perhaps, JSON serialization? YAML serialization?
Could you explain what you mean by caller? Or by isolation? I don‚Äôt understand your comment: If I call `foo_service.bar` I don‚Äôt need to care how `foo_service` was created? From Wikipedia: &gt; Dependency injection allows a client to remove all knowledge of a concrete implementation that it needs to use. This helps isolate the client from the impact of design changes and defects. It promotes reusability, testability and maintainability
(Disclaimer: I'm one of the current maintainers of SciRuby.) I believe we (as Ruby community) missed the "opportunity window", when Ruby was already known, but yet not known as a "thing under Rails" exclusively. If you look on GitHub (or in deceased RubyForge archive), you'll find all kinds of scientific, statistical, astronomical, NLP, whatever software in Ruby -- all abandoned around 2007-2010. Today, when somebody releases new NLP library they worked on for 2 years, they'll receive 10-20 stars/upvotes; but when some "new and better Rails pagination" released, it would be 100+. So, at some turning point in history Ruby just havent' a good "foundation" for scientific tools (like numpy in Python, which lies underneath all of them), and the rest is history. I am not saying that somebody is "bad" or "dumb", just, unfortunately, Ruby community is mostly web-centric now, and even most of popular "let's not do Rails" efforts are still "let's do the same web, but better" (dry-web, Hanami, Roda). I don't think that situation can not be changed. Daru -- our wannabe pandas -- recently received some good attention, and I hope when we'll finally do new refactored version with a lot of cool shticks even Rails guys would find it useful; other example is Numo library -- that "missing Graal" of numpy, that evolved really well recently. But I am not sure that progress in this area is sustainable at the moment.
A lack of primitives sure doesn't help. 
Lack of primitives is the biggest. A Python array contains one type. A ruby array can contain anything. Primitive arrays are required for any matrix operations and not having them in the language means you are relying on a library to implement that.
&gt; A Python array contains one type. A ruby array can contain anything. That's just not true, you know. Python lists and tuples can contain values of any type. That's exactly why we have numpy arrays.
Well, this kind of "one-size-suits-all" aphorisms are convenient, but not really describe the situation. There are at least two things to consider: 1. Initially, Ruby and Python have taken ~the same niche (scripting + new-born modern web). But Python could also evolve into scientific area (exactly as a general-purpose scripting language, that just "have tools", not as a scientifically-specialized thing like R) 2. Science/statistics is literally everywhere these days. And the thing that even for traditional Rails service, when you try to do some simplistic BI, your _typical_ option would "just switch to Python/R/Scala for this", is not that convenient.
Thanks for highlighting Deckset. Great app. Note, however, as far as I can tell it's a closed source for pay app. Not sure if it is using ruby. Maybe you have some insight? PS: Try Slideshow (S9) ;-) it's free and open source and you can design your own themes (w/ Liquid used by GitHub Pages, Jekyll, etc.) and much more (e.g. [write your own helpers / plugins](https://github.com/slideshow-s9/slideshow-plugins/blob/master/analytics/analytics_helper.rb) in ruby, etc.).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [slideshow-s9/slideshow-plugins/.../**analytics_helper.rb** (master ‚Üí 4c62b48)](https://github.com/slideshow-s9/slideshow-plugins/blob/4c62b481f867d5258c3ef770c469fd7a04feff0f/analytics/analytics_helper.rb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dpkieix.)^.
Can I ask what affect that has? In practice, how often does your array actually have anything more than one single type? Is it an error raising thing? Is it a performance thing? Is it an implicit conversion thing? 
You can address the last point by using the array/multi-argument forms of `spawn` and friends, and/or quoting with Shellwords. As a general observation, I suspect interacting directly with POSIX-specified executables may be amongst the *most* portable ways of going about this. But yeah, your error handling isn't going to be pretty.
You're just looking at the US Ruby community. The Japan Ruby community barely uses Rails at all.
Performance, Ruby arrays have to handle multiple types and are therefore slower.
Yes and no. Being Ukrainian who have recently [spoken on RubyKaigi](http://rubykaigi.org/2017/presentations/zverok.html), I am definitely **not** "just looking at the US Ruby community". But yes, what I've written mostly describes the situation in _international English-language community_. Some of the Japanese community are working on different solutions for scientific libs, like Numo (that I've mentioned, you see), or pycall. Some of that work is not published in any language except Japanese, some is published. Some of it starts to influence things (I've seen some new funny experiments with pycall in RubyWeekly). But situation in English community stays mostly the same.
Instead of using `system` or ``` you can always use [Open3](https://docs.ruby-lang.org/en/2.4.0/Open3.html) (which gives you access to SDTOUT, STDIN and STDERR. Gives you a lot more control and possibilities. We used this in the past for a big project to shell out to ffmpeg and get the progress updates from STDOUT. Mount is exposed through a [C API](http://man7.org/linux/man-pages/man2/mount.2.html) so you could start to write a ruby wrapper with [FFI](https://github.com/ffi/ffi) or a [native extension](https://blog.jcoglan.com/2012/07/29/your-first-ruby-native-extension-c/)
Totally agree. Ruby has become the next PHP. It has just concentrated on the web because of Rails. Now web gets eaten by apps, and due to narrow focus, scientific computing has been missed. Possibly Ruby will soon enter a winter and might fall off from top lists. The positive thing is, it will be loved by people who really love it.
A lack of properly formally grammared, hyperlinked, and TOCed language documentation of the same quality as the Python *language* docs (both the ref guide and the tutorial) would help, though not be the clincher by far.
Open3 is what I ended up using. I considered writing a C extension but Clang is not my forte by any means. Thanks for the advice.
Really, I thought the word `objects` was a pretty strong clue, also an object making use of constructor dependency injection and a single `#call` method is a way of making use of other procedural concepts you may have heard of, such as interfaces (as much as you can in Ruby), DI and Polymorphism.
I wasn't saying that it improves isolation, but that it improves the ability to test in isolation, and the caller doesn't have to supply the dependencies, the default dependencies could be set as the default arguments, if they're easy to construct, or injected from a container if not.
None of those things. The responsibility is whatever you declare it to be modelling. The modules that Rails mixes in to help with that aren‚Äôt relevant to responsibility. They‚Äôre just a toolbox it can use. This is yet more mistaking of the context for the thing. The stench of stupid is just mind-bogglingly strong in this thread. 
I assumed you to be referring to constructor injection though an IoC container rather than 'standard' dependency injection. &gt; If I call foo_service.bar I don‚Äôt need to care how foo_service was created? You need to construct `foo_service`, so you need to know how to setup it's dependencies. If you need to use A, which depends on B which depends on C and D, you have to set all that up somewhere. IoC containers hide that in a separate file but it still exists and you still have to know and care about it. This is especially true since IoC containers tend to be infectious, almost removing the use of `new` and injecting everything. Whomever decides to use A ends up digging into a lot of nested dependency shit to set it up, and you better hope it setup to your other use cases or be prepared to repeat the process. This is also why IoC breaks encapsulation pretty fundamentally. Instead of working just with A, maybe giving it some config options, instead it spills all its guts on the ground (B, C, and D) and tells the user it's their problem now.
&gt; procedural concepts you may have heard of, such as interfaces (as much as you can in Ruby), DI and Polymorphism. Interfaces, DI and polymorphism are object oriented concepts. It doesn't remotely make sense to called them 'procedural concepts' as all three require OO style data + actions objects that aren't part of procedural programming.
The project sounds pretty interesting. Hope I can get some sweet equity and exposure instead of salary though. /s
Put this in `test.rb` #!/usr/bin/env ruby # prople also commonly use... #!/usr/bin/env ruby # Google 'shebang executable ruby' to understand a bit more about that first line require "erb" ERB.new("&lt;%= puts 'foo' %&gt;").run and this this... $ chmod +x test.rb $ ./test.rb One does not usually execute ERB filed directly. They are meant to be rendered by Ruby program.
&gt; Interfaces, DI and polymorphism are object oriented concepts. Exactly, I guess sarcasm is hard to convey in a text-based format. I disagree that they require *OO style data + actions* objects, how does coding to an interface require that your object has state? As for DI, the action is `#call` and the OO style data (read state) is the dependencies.
&gt; how does coding to an interface require that your object has state? There are multiple ways to define 'interface', the OO concept is about an object exposing a defined set of methods. e.g. there are no interfaces in C, you can build your own v-tables or pass around function pointers to get some of the concept but that's it. 'Coding to an interface' is a more general term that could mean a lot of things. &gt; As for DI, the action is #call and the OO style data (read state) is the dependencies. An object with a single method `call` is just an OO wrapper around a procedure, these are called 'functors' in many languages and are a crutch to get around some languages not having procedural constucts. If you're passing all dependencies to a method then that isn't 'OO style data' (instance state), it's a procedural pattern.
From what I understand Ruby cannot lookup the position of an element in an array using arithmetic since an array's memory is not constant per element. So it would need another data type for anything which needs performance.
Yes, not lists or tuples. Arrays. Numpy does have it's own multi dimensional arrays. I don't know how much is shared with the regular python arrays. I just know that a Ruby array is not sufficient for numerical computations. But you are right that if python made something custom for numerical computations, Ruby could as well.
It‚Äôs not the best practice to do partition in rails because you will do a lot monkey patch for the active record. The best way for database partition is to do partition in a database proxy server and let the proxy server fetch all data for active record.
This is of course a hard thing to accurately measure, but ruby has gotten [high on the list of languages people don't want to work with](https://stackoverflow.blog/2017/10/31/disliked-programming-languages/) and relatively low on the activity scale. The winter has already come.
Actually with the introduction of the pycall gem its now pretty easy to integrate with Python tools and libraries inside your ruby application. I wrote a [blog post](https://www.practicalai.io/using-scikit-learn-machine-learning-library-in-ruby-using-pycall/) with an example of how to do it. 
what do you think is holding the scientific ruby environment the most? I sure wish ruby was bigger in this field. Was forced to do python scientific computing for some months and I can say now that I very much prefer ruby.
&gt; They are meant to be rendered by Ruby program This might feel like a stupid question, but why does ruby come with `erb` executable then? I guess I could make it .rb file and put the template into `DATA`, but that would break syntax highlight in editor. I know what shebang is, and I know I could have one .rb to load the template and render it. But I would like to keep this thing to one file and not split it into multiple.
Honestly, I didn't know there's an erb executable. This will run... #!/usr/bin/env erb &lt;%= puts "foo" %&gt; ...but I'm not sure why you'd do that. I've never seen anyone use it. Try `man erb`.
The `erb` executable can be useful for debugging -- the `-x` switch will output the generated Ruby code, for instance, which can be useful for tracking down weird errors like wonky syntax or the like, which can happen in ERB files from time to time. It's also for cases like this, where you want to use ERB to produce HTML backed by Ruby.
I agree with this entirely. If I've got a class, A, then A's class interface had better give me the ability to construct a fully operational instance. I should also be able to vary the dependencies as I see fit. If A's class interface can't accomplish these things, then it's not complete.
Another option would be to simply use a wrapper around the Python libs and you could call them directly from a ruby context. Best... Or worst of both worlds depending on your interpretation.
BTW, Japanese people working on problem promote this approach as a _temporary_ solution: * Use [pycall.rb](https://github.com/mrkn/pycall.rb) for libs we are missing * Use [py2rb](https://github.com/naitoh/py2rb) for fast porting of some libs (with, then, manually "fixing" the library API, leaving algos the same -- AFAIK, numo is developed this way)
Tell that to JavaScript.
I wonder if there's a way to somehow use JRuby with Jython to use python from ruby in the JVM? That sounds like probably a mess though. And I think maybe some of the popular scientific computing stuff in python doesn't actually work in Jython?
I don't think there's anything that makes Python more suitable than ruby for scientific computing, except that it's already got a bunch of really powerful mature scientific computing libraries. (That is a really big thing though! But not an aspect of the language design). Probably likewise for ruby and web. Ruby and python are quite similar languages. (Although their differences are enough to inspire strong feelings in partisans. I would not like to use python). 
woah, I did not know about this! 
Python seems to have beat it out as the "dear christ I'm a grad student who has no time for this shit but I need a goddamned script" language of choice.
We already have pycall :) In JRuby, it is more reasonable to use existing scientif libs for Java (or especially Scala, there are a lot of them, lots of data science guys adore Scala)
In fact, what we need most is _any_ way out of "negative feedback loop" /u/scheems [have mentioned](https://www.reddit.com/r/ruby/comments/7bqp3x/why_does_ruby_lack_so_much_of_scientific/dpk75mm/). E.g. there are a lot of work in different areas, but it is still not sustainable, as "not a lot of known uses ‚Üí not a lot of attention ‚Üí not a lot of enthusiasm to support libraries". So, I believe that what is really necessary is some real "cool" projects that would try to work with existing infrastructure -- and urge this infrastructure's maintainers to do better. I mean, where'd Rails was if there would be no Basecamp to say "we did THIS successful production project with our new shiny thing, you can try too!" I really want to dedicate next SciRuby's Google Summer of Code to this idea.
Oh, are you talking about the [array](https://docs.python.org/3/library/array.html) built-in module? Well, turns out, batteries **are** included. Still, it's a part of the standard library, not really a trait of the language. Writing a simila array library is just a matter of several weekends. So the "python arrays are better" argument is rather weak.
For what it's worth, The Odin Project includes doing Hartl's tutorial.
Huh, TIL.
Can we talk about how the "Service Object" name is horrible? It is usually used for Business Logic, which could be more properly named "Operation", "Action", "Task", etc
Yeah I'll take that whole post with a huge grain of salt. It's not a statistically sound post.
this is cool, but I would personally prefer to just avoid `subject` and say `list = [1,2,3]; `expect(list[0]).to eq(...)` ... doing things behind the scenes is not necessarily more clear IMO especially for such minimal keystroke saving as you have here. That being said, it looks like you've done some neat work, so don't take the criticism the wrong way :D
This is awesome! Thank you!
That's unbelievable. Something is wrong with this stats. It shows F as least disliked language.
A lot of Python can be translated into Ruby almost line-for-line, if one remaps 'pythonic' stuff to their Ruby equivalents. For some dumb reason I ended up writing the same networking script in Python and Ruby, and other than one needing paramiko library to stand in for ssh support, the two scripts read very similarly
My guess is the ERB executable is super duper old and seemed like a good idea when someone added it to like ruby 1.1 or something, but hasn't been used much and hasn't been maintained properly, and should probably be removed or deprecated (or updated). :(
He's probably seen classes that their *author* thought of and described as service objects, but the understanding of those that I've carried around through half-a-dozen languages over the last 25 years is * single public method with no publicly accessible state; * any side effects are by way of dependencies injected into the `.call` method or equivalent; * constructor/initialiser used to inject dependencies that *will not* have state modified directly by the service in question; * given the same input values (including stateful objects in identical state), the returned result data is identical. In MVC frameworks like Rails, I've learned to treat any controller method with logic more intricate than direct HTTP request/response processing or a single failed/succeeded conditional switch as a code smell. I was seriously twisted when I first came to Rails and the "everybody does it" Rails Way swore up and down to me that that was a stupid way to do it, but I'm well along in recovery now, thanks.
What are you doing with ERB anyway? Just wondering.
Java?
Architecting your stuff in advance for various elements of dependency injection _you might not need_ leads to over-complex architecture which is not only harder to understand, but paradoxically can make the code _harder to change or customize_, because it's more complex. If you need it, you need it, and should use it where you need it. But just reflexively putting it _everywhere_ -- YAGNI. And you probably won't be drawing your boundaries and abstractions right. That's what I got from the original post from Avdi. This is most especially true for code in individual applications -- for code in a shared dependency (gem), there is a bit more weight to designing for things you _are pretty confident_ you or someone will need, even if you don't quite yet. Because changes, especially backwards-incompat changes, are a lot more painful in a gem (painful to the various dependers on it). But you still got to be careful, for the same reasons. 
If writing C extensions isn't for you, look into ffi. It's wonderful, easy and (almost) pure ruby. For mount, this should work (out of memory, no guarantees): require 'ffi' module MyLib extend FFI::Library ffi_lib 'c' attach_function :mount, [ :string, :string, :string, :ulong, :string ], :int end res = MyLib.mount '/dev/sda1' '/mnt' 'ext4' 0, 'default'
Hi, thanks for pointing it out. I'll try it out right now:)
Yes, I also did `expect(list[0])` (with RSpec's named subjects) before. But that proposed solution is absolutely, totally not about "keystroke savings", I am not sure how you get to this conclusion after all keystrokes I've spent to explain the reasons.
Nowhere in `man erb` does it say you shouldn't use it. You would use it like this, e.g. because that's also how php works, you just write a html page with some dynamically generated content and hook it up to your CGI handle, no need for an entire rails installation.
was interested so did erb --version, seems pretty up to date. erb.rb [2.1.0 2017-07-10] thats with ruby 2.4.2
https://github.com/ioquatix/synco provides a command line tool which interfaces with mount and umount. It might be a bit too specific for your requirements, but it might also be a good starting point. https://github.com/ioquatix/synco/blob/master/lib/synco/disk.rb for exactly how it works.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ioquatix/synco/.../**disk.rb** (master ‚Üí 8644953)](https://github.com/ioquatix/synco/blob/86449536e04cc8dc68843a61f33bd931f4737cc2/lib/synco/disk.rb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
This was my crazy Friday evening project :D
So basically just a simple wget download with a shitload of boilerplate just for the purpose to invoke it with Rack, cause it is too hard to fire up the app and invoke wget by yourself and then just serve the static content. Also we can't eat tons of memory for a senseless running web app when everything basically gets served by the web server. But maybe I just don't get what the advantage of this is versus a corresponding build step via rake and just serving static content without a running Ruby app. Did I miss something obvious? I mean I just saw a big wrapper around wget. 
I'm learning Japanese and keeping my language log in simple html page, but lot's of constructions keep repeating so I wanted to wrap it in few simple functions. :)
So... I wanted to generate some static sites for github pages... it seemed like a fun thing to implement. It was originally a rake task but I wanted to use it in several different contexts, so it made sense to me to make an actual command to do it and automate the process.
So you were hoping for a circle jerk?
You've seen Java folks habitually designing service objects with a single generic method? 
someone likes tabs over spaces. :)
Here's the crucial bit that stuck out to me: &gt; Indeed often these models come with design rules that say that you are not to put any domain logic in the the domain objects. Instead there are a set of service objects which capture all the domain logic, carrying out all the computation and updating the model objects with the results. These services live on top of the domain model and use the domain model for data. What Fowler was really saying was that the service objects were using the domain model objects as pure bags of data; the domain model objects weren't _encapsulating_ their state. This would indeed be applicable to a rails app if service objects were directly manipulating the attributes on ActiveRecord models, instead of telling the underlying models what they want done. This is usually what I end up finding, in my experience, when I encounter an `app/services` or (gasp) an `app/interactors` directory. Based on how Fowler characterizes the anemic domain model problem, I'll argue that we cause the problem whenever we turn our domain model layer into a dumb data access layer, and have service objects implement the domain logic instead, directly accessing the data from the "domain models" as needed. This is actually _extremely_ similar to stock rails MVC -- the public interface of an ActiveRecord model is dumb data access, and the controllers, like service objects, are treating the "domain model" as a bag of data. The only difference between the the service object approach and The Rails Way is that controllers are _also_ encumbered with HTTP request/response duties, and they're difficult to construct, rendering them somewhat resistant towards TDD. Anyways, the solution to the anemic domain model is the same as it ever was: we have to implement a proper domain model layer -- that is, it's comprised of objects whose interface is _modeled_ after the domain, not the underlying database. So, I think the real elephant in the room is that domain models can't really be made out of ActiveRecord models, because their primary interface is one of data access. This may be a bit controversial, but here's a critique of the rails community: when the rails community started introducing service objects in their codebases, I suspect that most rails devs had never seen what a rich domain model looks like. All they'd ever _known_ was anemic domain models. A novice reader who doesn't yet understand what a rich domain model looks like might conclude that the article is endorsing The Rails Way over service objects. It's not -- it's as damning of The Rails Way as it is of an `app/services` directory.
I think you're selectively re-writing history here. Rails (and others) didn't move away from IoC containers and strict service layers (e.g. EJB) out of ignorance of their existence. Rather they went the direction they did because working with such systems sucked. A more realistic history is something like: * 15 years ago - IoC all the things! Spring auto-wire FTW! EJBs rock! * 10 years ago - This shit sucks, we're taking a different approach * now - IoC all the things! We want service layers and auto wiring everywhere! * 5 years from now - This shit sucks, lets take a different approach 
That's really interesting, actually. Do you post the code somewhere like github?
A to do comment means nothing if you don't actually do the task.
Now, do the people who need this advice read these kinds of articles on self-improvement?
None of these tips mean anything if you don't write code.
Quantity over quality here, but it's OK as food for thought.
I don't, it's just one simple file filled mostly with notes from „Åí„Çì„Åç textbooks (still working through the first one though :/ ). It's nothing interesting from programming point of view so I don't intend to publish it. But if you are really interested, PM me mail or something and I guess I could send it..
Meh. I work on a codebase now that had to do comments in it. The guys that started it were steady working on other features though. Just having a to do comment doesn't mean anything if you don't address it.
Some I'd add: 1) Dogmatic adherence to X principal where X can be SRP, DRY, etc. 2) Premature abstraction - create abstractions only when they become clear and improve readability. This is a bigger problem than premature optimization in my experience. 3) Forcing every problem into a particular box - e.g. forcing a functional problem into an OO model, using a factory pattern because the rule says we use factories everywhere, etc.
well but it's *part* of addressing it. my comment was a tautology: code doesn't get written if code doesn't get written. leaving a TODO comment and moseying on your way is rude to your colleagues, but it's not bad coding.
"Duplicate code is worse than the wrong abstraction" --Sandi Metz
&gt; Duplicate code is worse than the wrong abstraction Her actual quote was: "duplication is far cheaper than the wrong abstraction" or "prefer duplication over the wrong abstraction", both from the same talk. Her thoughts on the topic here: https://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction Not that I think it matters much, appeal to authority and all that...
Gah, fuck! `s/worse/better/`
I'd add Spending the time to name your code. People use certain words because they are lazy to think of anything better. Those words become generic and meaningless over time. Code should self-document. 
It‚Äôs my dirty little secret. :)
Do you think this is a change that should be applied to other public libraries? I know of several other ruby gems that have gendered names (https://rubygems.org/gems/statesman for example) and I'm trying to understand if this makes a meaningful difference to people. At a certain level I feel such sensitivity to words creates the taboo and emotional charge that allows them to hurt people, but am aware that being a man means I'm unable to really experience some of the problems people might have with this.
Alternative title: Things I hate about my client 
Anecdotal: Validation should really happen on the model unless you're only accepting certain params from the form. strong_params is a good example of this. Gitlab has some great examples of service objects and SRPs, even if it's Rails-based. I'd suggest checking it out.
There are a couple of things that evaluate code inline like a Swift playground, though none look as polished as the Walllaby.js service Search for: - ‚Äúseeing is believing‚Äù gem on GitHub - ‚ÄúHydrogen‚Äù gem by nteract on Github Seeing is believing gem is great. Has plugins for Atom etc. I love visual coding tools like this Hydrogen is a bit more involved setting up. It relies on Python/Jupyter notebooks integration. I got it working, but Ruby did not have the strongest support. 
Pretty good list, but I disagree with this one: &gt; 23. Hardcoding values instead of making them configurable &gt; Always be thinking about what changes might come and how to deal with them. Technical debt will grow at a monstrous rate if you don‚Äôt separate the moving pieces from the rest of your work. Use constants and configuration files where appropriate. Trying to guess at future requirements is what the [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it) principle from XP warns about.
**You aren't gonna need it** "You aren't gonna need it" (acronym: YAGNI) is a principle of extreme programming (XP) that states a programmer should not add functionality until deemed necessary. XP co-founder Ron Jeffries has written: "Always implement things when you actually need them, never when you just foresee that you need them." Other forms of the phrase include "You aren't going to need it" and "You ain't gonna need it". *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
The fuck. I‚Äôm not even going to read this shit. One rule. Don‚Äôt piss off your pair, and if you don‚Äôt have a pair, pretend like you do. 
Refusing to write bad code... I lean more toward this side of things than not. I‚Äôve been taught the exact opposite of this.. the reasoning for never writing shitty code is ‚Äúwe are professionals, we should program like professionals.‚Äù That and I‚Äôm sick of seeing terrible code from my coworkers (mostly it‚Äôs the rampant copying and pasting and utter lack of any kind of abstractions) and I really don‚Äôt want to become part of the problem. Isn‚Äôt this against the broken window theory referenced in pragmatic programming?
‚Äòdef Fuck_This_Function_That_Never_Works()‚Äô Meaningful names are more important than non-generic names. 
non-generic = meaningful.
I suppose we can agree to disagree. Meaningful can be generic. Meaningful self-documenting code names should explain what the code does, regardless of whether it's generic. If a function or variable *is* generic, giving it a generic but *descriptive* name is more meaningful than a *non-generic* but ultimate *non-descriptive* name.
Give me an example of something that is both meaningful and generic.
I needed to hear this. Thanks
A non duplicated hardcoded value is perfectly configurable!
Why isn't there some jruby wrappers around java libs?
I believe the reason is same (as my generic answer): nobody cares enough to do some.
&gt; Ideally many believe services should have single-responsibility and only 1 public method I don't think this should be an unthinking default, I think your objects should match what you need to do with them. But I don't think there's anything wrong with the pattern you propose -- if it makes sense for what you need. 
Awesome, thank you for the info. They both look interesting. And for the search record: [seeing is believing](https://github.com/JoshCheek/seeing_is_believing) and [hydrogen](https://github.com/nteract/hydrogen)
also phrased as "[ain't nobody got time for that](https://www.youtube.com/watch?v=bFEoMO0pc7k)"
Really cool. How are you generating the graphs?
That's not unbelievable. These are pulled from Stack Overflow's careers site, where you can list up to 5 (IIRC) things in your profile that you don't want to work with, so that recruiters know to stay away with jobs that use them. F is such an uncommon language that there are very few people who a) have worked with it to know they dislike it, and b) feel the need to specify that they wouldn't like to work with it.
I output `.dat` files of the runtimes (basically just `puts "#{iterations}\t#{time}"`) and then put the results through `gnuplot`. 
This feels a bit like the type of abstraction layer one would write for a workflow management system to allow a user to create workflows using a GUI, integrate custom components via an adapter, etc... Otherwise -while nice- it seems a bit over-engineered 
I shot that video! Thanks for sharing. :)
Love Ruby... but this.
wow, that's awesome! Thanks a lot for sharing this! I'm searching for ways to be less coupled to AR and found this video. I really want to hear what are ppl's opinion on this topic :) Do you guys actually end up using this pattern in production projects? Anything else you learned after the talk? :D
We indeed use a few query objects in order to abstract the complexity of some queries (like search of multiple filtering) outside of the model. That works pretty well, keeping code readable and tidy, while not losing any strength of AR.
Don't you love inconsistent class doc URLs, or a language doc page that kind of looks ugly, and is nothing but a link to some rendered reStructuredText files?
Yes... BUT having said that... it is SOMETHING... we went from the K&amp;R C book which was pretty awesome to the cluster that was C++ docs... (foundation / borland / etc) that was SO dry and often wrong... And that set a precedence for 25 years for things like PHP / HTML / Cold Fusion Then Perl / Python / Ruby started automating from the actual code itself... so while still dry... at least the signatures were correct... pretty big step forward from the comments above that the docs were created from.. that just never seemed to get updated when the code below did... So... yeah.. BUT it does give some entrepreneurial soul the opportunity to create and maintain so kickass online docs with examples with minimal advertising... (maybe for his own consulting company)... Really... just a better homepage for the docs would go a LONG way to making them more useable... with say a dropdown menu or two...
https://www.railstutorial.org/book Still the best way.
And always will be. but to OP: please learn about Ruby and objects first. You'll have a much better time.
There's no fast way. 
Cool, thanks again for sharing! Cookpad seems to have lots of interesting practices and patterns we can learn from :) Plz keep sharing them. Do you have any thoughts or resources on AR that you can point me to? I have been thinking a lot about AR recently. My shop didn't establish any patterns around how to use AR and it's getting a bit out of control now. Like couple model files have thousands of lines and you can see calls to AR all over the places in the app. 
So you understand modern web apps? Http? Databases? If not maybe some general understanding will help. As others said learning ruby is crucial!
 if row == 1 puts outside_letter * width elsif row == height puts outside_letter * width else middle = inside_letter * (width - 2) puts "#{outside_letter}#{middle}#{outside_letter}" end You are missing the end on the if statement. Depending on your style a case when would be easier to read.
Forgot an end statement. What editor are you using? Use one that provides some basic syntax checking. That or do this: ruby -c program.rb. 
So I would simply put another "end" above the one already there? (Again, very, very new...)
You need an `end` tag for your `if` block 1.upto(height) do |row| if row == 1 puts outside_letter * width elsif row == height puts outside_letter * width else middle = inside_letter * (width - 2) puts "#{outside_letter}#{middle}#{outside_letter}" end end 
Ruby on Rails is extreme convention over customization. If you code Rails without fully knowing and understanding its strict connections then you're headed for trouble in the long run. Don't half ass your effort on the conventions.
Problem fixed, will take your suggestion into consideration!
Thank you! 
&gt; I think the real elephant in the room is that domain models can't really be made out of ActiveRecord models, because their primary interface is just data access Imagine how things might've turned out, if ActiveRecord's attribute methods were private by default. When I first learned Rails (from some very experienced and competent people) I was taught to build in the other direction, that is, treating ActiveRecord as a state-persistence toolkit that's been plugged into the domain models *for their internal use*. Calling getters/setters from outside wasn't totally banned, but severely frowned upon and considered a code smell, except in views. We know better now, and the repository pattern is my current first preference for new work, but I'll still take this approach when working on existing stock Rails apps. (For extra irony note that Martin Fowler named and documented the Active Record pattern) 
The fastest way is to get a full-time job that has you working alongside competent, experienced, patient senior developers on one or more existing, moderately sized, well-written Rails apps. 
pretty much this. In general, ship something real to production, with users, many times.
Start with the ruby koans. Then work your way through the Michael Hartl rails tutorial. That should prepare you enough for a junior position at a company where you can grow your skills. Ask questions and seek knowledge. 
hey, what's the fastest way learn to be an auto mechanic? I want to apply for a job, but it requires I know how to fix cars! 
Links of note: * [Medium article](https://sourcediving.com/rails-query-objects-tokyo-rails-meetup-april-2017-d06933b6990b) about the event * [Slide deck](http://courses.cecilitse.org/talks/query-objects-in-rails-apps.html#/) * [Example code](https://github.com/cveneziani/query-objects-example/)
Is there any further context for how these types of objects are used inside a living application? It's not used in the `ArtistsController` to do querying, which may be an oversight. This seems like a very close relative of the Repository pattern. So in the app are all queries running through query objects? Or just complicated ones?
Use something like markdown. Its actually a simple text processor, but you can easily backend it with own plugins/extensions and choose from a plenty one. (Its also the syntax reddit uses). Then you just write a markdown document, and have your ruby methods/classes in a different .rb file and call the markdown interpreter from it (so you have the enviroment you need). Then you can run your own methods. 
Andrew Perkins on YouTube does a full tutorial starting a rails blog with CRUD from scratch. 
Rebuild Facebook. You have two weeks. Go. 
While you're there, you can also call gets.chomp so you don't need to overwrite the variables you're setting. Also if you calculate the middle row text outside the loop you only calculate it once instead of several times over.
If he has web development experience with other MVC frameworks he absolutely can pick up rails relatively quick, not be an expert or guru or something but come on.
From my own experience, you should learn Rails by learning Sinatra first.
Yeah I agree. Writing bad code should be allowed only if you're 100% sure you'll have the time to fix it right after. Otherwise it's much better to refuse those "quick and dirty" solutions that introduce tons of technical debt.
That doesn't mean there isn't a *fastest* way, though, unless there are no ways.
You can memorize each part of Ruby of Rails commands, how the MVC works, the entire API. But what all courses lack, does not matter the framework, is the application design process, the functional specifications, the software development process to choose. Without this, you will feel absolutely lost even after doing a dozen tutorials on RoR and Ruby. Maybe somebody can point out how to approach this. A framework is only that, a mere tool to create something.
yes, you are right! 
Hello, I've rebooted the (default) [S6 Blank (Jekyll-Compatible) Template Pack](https://github.com/slideshow-templates/slideshow-s6-blank) for the [Slideshow (S9) command line tool (and library)](http://slideshow-s9.github.io). What's news? The S6 machinery has now an easy-to-extend microkernel (Bespoke.js-Compatible). Why not build / generate your next talks / slideshows from your notes written in plain text with markdown formatting conventions? Happy publishing with S6 &amp; S9. Cheers.
Firsty, welcome to ruby. Secondly, there is a /r/learnruby subreddit, that you may be interested in. As for actual comments on your code. I would isolate your input and output handling from your actual application logic. Write separate methods/functions to handle those separate concerns.
Thanks for your feedback, it's very appreciated, and for the welcome! Didn't know that subreddit, was clearly more appropriated for this thread, I'm gonna post also there. 
Schemadoc might be another option for documenting your db schema w/ activerecord. See https://github.com/schemadoc/schemadoc Cheers
How does Prometheus compare/contrast to Statsd?
nice it is interesting, one thing I like about the above solution is it is already built into Rails so you don't need any additional gems or tools to add to your toolchain... Embedding it directly with your migration changes makes it feel like just a part of the process.
Using Hash defaults is super handy ‚Äî I really like the use presented here for getting away from case statements.
This is a great feature that is underutilized. Use it! Those that inherit your codebase will thank you. To see comments in MySQL: ``` show full columns from TABLE_NAME ```
Why refactor to yaml if it gets large? Either you keep it in memory, or you load it into memory with yaml right?
They play different roles: Statsd is an aggregator and Prometheus is more like storage/database with data querying and built-in alerting system. They can even be used together, i.e. Prometheus as a Statsd _backend service_ (see https://github.com/prometheus/statsd_exporter). Usually Prometheus is compared to Graphite, for example (https://prometheus.io/docs/introduction/comparison/).
Thank you for your efforts trying to bring scientific computing to Ruby. That said, I just think that what data scientists, computational linguists, etc. need is not a proliferation of languages. Had Ruby been what Python is now for data science, I think it would make little difference for them in the end. Maybe, once in a while, a new language becomes interesting if it offers, say, speed improvements (to wit, Julia). But in the end, most of these people, I think, just want to get stuff done and not get bogged down in details about what programming language is better - that's a concern for library and application developers, but a lot of work in the scientific community is one-off scripts, prototypes, etc. pp. That's why I think that, ultimately, there is no huge incentive to develop an ecosystem of tools in Ruby that mirrors what we have for Python. I work with some NLP stuff and I've just come to accept that when I need anything interesting, I'll have to interface with Python and/or Java. Heck, there's not even a decent (natural language) tokeniser for Ruby.
Good point. Schemadoc could (and should) be extended to add comments from the database. Do you know if the new comments feature works for all database e.g. not only PostgreSQL but also for SQLite, for example? Or as in your write-up is it for PostgreSQL only?
All what you are saying is reasonable (and considered by SciRuby), but there are some counter-arguments, two most important of them I've already mentioned somewhere in the thread: 1. Nowadays, surprisingly, scientists aren't the only people who want to do science. Good statistical and charting tools are almost a must for any web project (BI, performance analysis, and stuff), the same with basic NLP you've mentioned. So, the tools should exist not to compete with Python or R or Julia, just to make Ruby's ecosystem richer (or even "rich enough for 2017"). 2. I still believe (and that's why I am staying engaged and excited) that expressiveness of Ruby could, probably, eventually, produce some new, more interesting tools even in established areas. 
Yeah, definitely some valid points. I mean, I would love to have better tools for these things in Ruby. :) I've just come to accept that the programming world is a polyglot one and that there is no shame in that.
Ruby as a language has also stagnated quite a bit. I mean, I love required keyword arguments as much as anyone, but even languages that used to be ancient and inflexible like Java and JavaScript have added more significant features in the more recent past.
It works for at least PostgresSQL, MySQL, and SQLite... but not sure for other DBs outside of those three.
Yeah. Our motivation never was just "let's repeat all features and libs of other languages in Ruby" :) It is (a bit) more reasonable oen.
Thanks for the update. Great to hear that it works for SQLite (my personal favorite). Will try to add comments to schemadoc with the next update :-). 
Would links have been too much to ask?
It's a very minor point, but instead of: if pools_hr.empty? == true you can just use: if pools_hr.empty?
Hello, the latest and greatest plugin to GitHub Pages (and Jekyll) is Jekyll Remote Themes. Using a simple config entry e.g.: plugins: - jekyll-remote-theme remote_theme: slidekit/jekyll-talks-theme you can "automagically" pull in remote themes (layouts, includes, javascripts, etc). To show off / test the new functionallity I've put together a minimal ready-to-use (fork/clone) setup called [Talk Starter (S6 Blank)](https://github.com/slidekit/talks-starter) that turns your notes in plain text w/ markdown formatting conventions in live web slides (using the S6 blank machinery). See [Blockchains!, Blockchains!, Blockhains!](https://slidekit.github.io/talks-starter/blockchain) [(Source)](https://github.com/slidekit/talks-starter/blob/master/blockchain.md) as example. Happy publishing w/ Ruby and (GitHub Pages, Jekyll and friends). Cheers.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [slidekit/talks-starter/.../**blockchain.md** (master ‚Üí 01480ff)](https://github.com/slidekit/talks-starter/blob/01480fff0e7d7377aaaf169feeeffc0742f2cdcc/blockchain.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Fantastic writeup.
keep in mind this removes the default behavior of the hash which is to return `nil` when a non-existent key is looked up. It's fine as long as you remember to use `if has_key?(key)` instead of `if hash[key]` (this has snagged me in the past)
Yeah, it's literally just a list of gem names with no links or commentary or anything. Total garbage.
It has little to do with proformance improvements and more to do with reducing churn of Ruby files and separating data from logic. If you can make Ruby files unchanging it‚Äôs makes them more stable. When the data needs changing it can be changed independently of the code. If the YAML file was changing all the time I might consider moving that to a database leading to no churn in the repository and in some cases performance improvements. 
Its correct that adding the appropriate index will improve performance under postgis, I would never run that kind of query in anger without indexes. There are also other query functions than ST_Covers which could be used depending on the problem domain, which have different performance implications, eg. ST_ContainsProperly, ST_Within etc.
Great response, thank you. It seems that best practice is for software to support Statsd output and then the user can choose the correct backend for their needs.
Better to use this http://awesome-ruby.com/
Comments like this are what make me feel better about googling when in the back of my mind a little voice is whispering, "c'mon you should know this by now"
Belongs on /r/rails or /r/JavaScript. Nice self promotion tho.
I really liked your analysis here! One fun improvement I might suggest for the blog post would be to do an approach using the Multinomial Theorem, I expect it'll be even faster :)
It belongs right here on /r/ruby. Thanks to Richard Schneeman for posting. Keep it up.
I've never actually heard of the Multinomial Theorem before, but it sounds really interesting! Unfortunately, according to [this stack overflow post](https://stackoverflow.com/questions/26228385/time-complexity-of-recursive-algorithm-for-calculating-binomial-coefficient), calculating the binomial theorem is O(2^N/sqrt(N)), which is fairly slow. I'm not sure if the Multinomial Theorem will be any better, but I suppose it's probably worth a shot! I'll try it out and either make a new post or update the post later. Thanks for the tip!
Since been [reverted](https://github.com/rails/rails/pull/28592).
I'm developing for web with RoR for over 5 years now, never heard of source maps before, that's very neat, great article. Does Sprockets 4 also implement function name mapping? If I understand this correctly, this might be one of the most important aspects of it, but you didn't show it in your example source map. &gt; In production, Sprockets combines files together and minifies them when possible. (...) This cause subtle bugs and confusion where things work locally but not in production I have never encountered a bug that was present on production but not on development because of Sprockets. Can you give an example of that? The only environment-specific bugs I had regarding assets were related to not correctly setting relative paths for prod.
Noticed what looks like a typo: &gt; If there‚Äôs an exception in your JS and it‚Äôs minified, you have short variable names and be all on one line, it‚Äôs impossible to see where the error comes from. Probably: "... you have short variable names which are all on one line ..."
for better or worse, /r/rails has degenerated into beginner questions about rails, and there's plenty of rails on /r/ruby (rails _is_ an element of ruby after all). Yes the sidebar suggests otherwise. It hasn't been enforced ever, and we haven't heard from the reddit mods in years (I've tried to contact em haha). I always appreciate schneems posts. I don't read /r/rails, cause if I wanted newbie questions about rails I'd go to SO. 
Sprockets is used quite a bit outside of Rails. For example I used it to generate assets for this blog via https://github.com/jekyll/jekyll-assets. 
Oops, thanks for the catch. Fixing now.
only from 5.0-stable, looks like it's still in master/5.1.3
I guess I didn't do a great job explaining why it's better in development. There are a few dev/prod problems that show up, but i've fixed most of them if you're using rails. The biggest is if you're trying to use an asset that hasn't been listed as "precompiled". Here's a better description of a bad workflow we're trying to avoid with sprockets: Lets say you have a coffeescript file `foo.coffee` that is has a bug in it. Previously this would be compiled into javascript `foo.js`, and when you get the error, the browser will point out the location of the error in the `foo.js` javascript file. You have to mentally be able to reverse-map that javascript code back to your coffeescript `foo.coffee` code to see where what generated that exception. With source maps, the exception maps back to the line and column in the `foo.coffee` file instead. I'll update the article as well. Thanks for the good question! 
Without an HA story this seems like a non-starter.
&gt; Does Sprockets 4 also implement function name mapping? If I understand this correctly, this might be one of the most important aspects of it, but you didn't show it in your example source map. If you're using something like coffeescript, and coffeescript implemented name mapping, then sprockets will use their map file. The only things sprockets manually generates maps for are files without maps, and for those it simply maps lines since presumably they're being mapped from js -&gt; js (with some concatenation) or css -&gt; css here's the code. https://github.com/rails/sprockets/blob/341fed4f91e0dfd75f9740ee77885488db58aecd/lib/sprockets/preprocessors/default_source_map.rb#L34-L44. Really the work i'm doing isn't so much implementing source maps, as it is wiring up other libraries that generate source maps to play nice with sprockets. It's still a lot harder than it sounds. 
That's not the time cost of the binomial theorem, that's the time cost of bruteforcing it using only recursion and addition. There should be an easy way to apply it in your blog post as O(n*d).
I am not debating on the relevance of sprockets to our community.... I am referring to the fact that since it's primarily an asset/front-end oriented tool, it may be better served by presenting it to the more relevant audiences than a server side language subreddit. I stand by my post. Maybe our community should have kicked 'em out (by that I mean sidebar rules/wiki) to stackoverflow like every other responsible language community? 
Can‚Äôt tell if serious
Talk to the moderators in /r/rails if you can manage to find em. I've tried but never managed to get in touch with the moderators here in /r/ruby, never tried in /r/rails. 
Come on, if you're promoting your own stuff how about a short comment explaining what it is and why we should care.
The only stuff made by ragesoss that this article mention is the "Wiki Education Dashboard".
Thanks for the post I hadn't thought of how easy DeepCover makes it to detect unused scopes.
I was referring to the article itself, this is self-promotion.
I'm curious which of these are abused.
I started learning Rails, got overwhelmed, and then stopped and learned Sinatra before going back to Rails. They have a lot of shared concepts and you'll be doing more pure ruby as opposed to relying on Rails idioms to do everything
I like that a lot, thanks for sharing :) I really like `concurrent-ruby` I really should use it more. I've used it whenever I need a thread pool. One example is when I want to use multiple threads to crawl an API and I don't want to overwhelm the server. `Concurrent::FixedThreadPool.new(concurrency)`
Yes, but it's not really a choice between duplicate code and the wrong abstraction. It's a choice between duplicate code, the wrong abstraction, and a useful abstraction that you haven't thought of yet. If programmers spent more time sitting back and thinking about what they're doing, and less time frantically typing to "ship" features, they'd end up with less duplication and better abstractions.
Well I didn't say it was better or worse than lollipops either. The implication is that in the absence of the right abstraction (which you may not find before you have to commit), those are the two choices.
I prefer the thread pools myself, as one can control the number of threads available. However, this is just the executor context, and if I'm not mistaken, there is a way to assign the executor context to the futures, so your example could be rewritten using it. All that said, it's a great abstraction. 
There indeed is a way to assign your own thread pool configured the way you want. I contributed the top-level docs on thread pools/executors in fact (I didn't write any of it, just the docs). I have many tasks where I instead want to control the parallelism as in the above example. Create N futures (with IO-heavy work) in a batch, then block for them all to finish before proceeding. For that approach, I think a custom thread pool is not neccesary, and possibly not helpful. But thread pools are nice too. I do like combining a custom thread pool with a future or promise given that as an executor, to still get nice future or promise API. 
uh oh, the bad news is concurrent-ruby seems to potentially be having a lack of maintainer problem. https://github.com/ruby-concurrency/concurrent-ruby/issues/585#issuecomment-344730700 It is so useful only if it's maintained, for being a bedrock of solid concurrency primitives that everyone can use, with a consistent dependency. it's not a rails dependency fwiw. I think it's maintained existence is totally helping driving concurrency in ruby forward. That would be really sad if it ends up unmaintained. 
&gt; which you may not find before you have to commit _Have_ to commit? My point is that, barring extreme circumstances, we have to _not_ commit if we've got duplication that we can't justify, but also can't figure out what to do about. In those circumstances, committing code is the last thing we should do. It's where the typing stops and the programming begins. That's our job -- to identify a design that removes it _and_ increases clarity and reinforces concepts.
If your point is to never check in code that has not been refactored or DRYed up to a maximum degree, we'll have to agree to disagree.
Let‚Äôs talk more if you are definitely interested. Thanks 
Governance: Transparency and Accountability. 
I don't fault you for jumping to that conclusion, since the hacker vs. perfectionist dichotomy seems embedded in our profession for good. Duplication is a code smell. Sandi Metz was pointing out that _rushing_ to remove that duplication by introducing a poor abstraction results in a net loss. It costs you more in the long run than it saves. That's very true, and I agree with her wholeheartedly. Every programmer, when faced with some obvious duplication, has a choice. You can decide to leave it as is (probably a hack), introduce a bad abstraction (also a hack), or you can see if further analysis can get you to a better place. My claim is not that you should be prepared to put your whole life in suspended animation while you attempt to arrive at a better design. It's that you should be able to give design issues the attention they _deserve_. In my experience, most web developers faced with a perplexing design problem last less than an hour before they give up. That's just not enough time to do a good job. Our real work isn't typing into a text editor, it's solving these design dilemmas so that the team can continue making progress. So here's my point: don't use Sandi Metz's statement to justify inadequate implementations. Set higher standards, not lower.
I'm here, just left the keynote, about to go over to the after party. 
&gt; If programmers spent more time sitting back and thinking about what they're doing, and less time frantically typing to "ship" features, they'd end up with less duplication and better abstractions. While thinking is clearly a good practice, I don't find it has much to do with the issue at hand here. Until you see how something is going to be used in a few different ways (until you ship some features), it's pretty pointless to dream up abstractions. You don't know the problem you're abstracting against yet.
I wish this event was I'm Seattle :(
&gt; Sandi Metz was pointing out that rushing to remove that duplication by introducing a poor abstraction results in a net loss We don't disagree. In order to be removed, it has to be put in, which is where my comment about checking in comes in.
I am attending and also by myself. Hope to see you around!
Loners for life!
It's unclear if you're passing `puts 0` as the single element of an array (as in the result of evaluating that expression) or if you're passing in two elements, `puts` and `0`.
I‚Äôm here - come to Karaoke tomorrow night!! Or stop by the Engine Yard booth :)
I'm confused why you'd need puts in an array
OP (aka baweaver) here! The Illustrated Guide to Ruby is a current WIP project between me and havenwood to teach Ruby with Lemurs. There's still a lot to do, but it's about time to share a bit of what we're working on! Why Lemurs? Why not!
From my very limited knowledge of the ruby parser, I'd say that's intentional. The difference between `puts 0` and `puts(0)` from the parsers point of view is that `puts 0` is a COMMAND (&lt;- BNF syntax, not concept) and `puts(0)` is a FUNCTION. You can see that nicely with the included ripper: require 'ripper' require 'pp' pp Ripper.sexp('puts 0') will get you [:program, [[:command, [:@ident, "puts", [1, 0]], [:args_add_block, [[:@int, "0", [1, 5]]], false]]]] while pp Ripper.sexp('puts(0)') will get you [:program, [[:method_add_arg, [:fcall, [:@ident, "puts", [1, 0]]], [:arg_paren, [:args_add_block, [[:@int, "0", [1, 5]]], false]]]]] In array literals, you can have ARG which is all kind of stuff with funny operators (ARG + ARG, ...) and PRIMARY. PRIMARY can also be all kind of stuff (including FUNCTION) but *not* COMMAND. So, it's not a bug or a limitation. It's very much by design.
yay
Would you need to write it like `[puts, 0]` then?
define scale
You can drop multiple app servers behind a load balancer and call it a day with either. That'll scale you into the 10s of 1000s+ of users I believe. If you need to scale to millions then you need to talk architecture, not language.
&gt; very limited knowledge I'd say your knowledge is *slightly* higher than what most would consider "very limited" ;)
no love for windows :(
I don't think there's been radio silence from /r/ruby mods for a fair while now. I catch up with the mod inbox every now and then but I know others do as well. I don't see any recent outstanding matters there. Incidentally, this post only got one report, from someone offended by "WTF" üòÇ
&gt; Until you see how something is going to be used in a few different ways (until you ship some features), it's pretty pointless to dream up abstractions. You don't know the problem you're abstracting against yet. That's not a universal truism. In fact, it's a rarity in my experience for a design analysis to conclude that further use cases need to be discovered before proceeding. It does happen, but it's not the norm for me.
Good to know! Now that I know you are a mod who is still involved, I may message you directly in the future, heh. Thank you for adding the link to the sidebar! 
same same, roughly. If you aren't at the point where you can ask more specifically about what you mean, the answer probably doesn't matter. 
No worries. To be fair, most of the mods are "occasionally" active (well, other than James, for obvious reasons) - messages about adding things to the sidebar do tend to get ignored more often though, either because it's a pain to do or because people don't feel comfortable changing a key part of the sub).
Now that I am actually coding, I see the wisdom in starting with what works and not obsessing about what's going to happen 5 years from now. In the event of massive success, you can refactor. But if you overengineer from the outset, you'll never get a product out the door.
Was this inspired by _why's Poignant Guide to Ruby?
In part. It was a combination of a few: Why's Guide, LYAH, adit.io, and others I'm probably forgetting. I mention it over in the introduction chapter as well. Likely I'll double down and put it in a credits section as well. 
I get it. The sidebar could probably use some love though, I think some of the things in it are kind of dated/unmaintained, and there are some newer popular analogous things that might be useful. But I have no idea how many people actually use the sidebar as a reference at all, I suppose removing most of it would be another alternative! 
I'm curious how this compares to "with_lock" http://api.rubyonrails.org/classes/ActiveRecord/Locking/Pessimistic.html Both use row-level locking (for both reading/writing). When would I use one over the other?
While walking through the woods one day, Chris and Martin find something strange...
I might start a thread where people can make suggestions on this actually. It would be neat to get more insights.
I'd probably just store the IPs in an array and then array.each do |ip| to loop over them - but I'm no expert.
This is really cool. I'm not going to tell you what to do. But I can tell you that I published free courses and I wish that I had more reason to keep them up to date. It wasn't a priority so they atrophied until they were no longer nearly as useful. When you get to a state of "done" with the first iteration, If you're not already planning on it. I would find some way to get some income from this. Even if it's putting it behind a "pay what you want" (where an option is zero dollars) paywall. Alternatively you could do like some other places and make content available for free and charge for ebook downloads etc. If you feel bad about taking money, you can use it to hire an editor or pay out other contributors to the project (since it's on github) etc. Though you shouldn't feel bad about making some compensation for your hard work. Anywhoo, great work. Hoping to see updates on this sub in the future. 
What about all of the scan details from multiple applications that I want to store with each IP address?
I had to cut out of the afterparty last night, Where is everyone staying?
I was planning on it :) More than likely I'll put part of whatever pay what you want profits towards something like Rails Girls or similar causes. For now git book is simple and keeps me focused. I may go Leanpub later or try and pull a Learn You a Haskell and see if NoStarch or another publisher is interested. Top thing for me though is keeping a free version out for those who can't afford it and want to learn. Thanks for the tips! 
I'd create a class that is initialized by the IP address and has methods to do the steps you want to perform. It would have attributes to store the results you want to store and methods to build a report out of those results. Then you could just take your array of IPs, #map to initialize an object per IP, run all commands per IP, etc. Then #reduce the array to build the report.
I will finish reading it later, but, I think you have a solid start here. Well done!
[removed]
If you needed to synchronize operations that weren't related to a specific table, this could be a good solution.
The ruby parser can be weird sometimes, it's handling a lot of nearly ambiguous cases. This works too, btw: [(puts 0)] 
I suspect that if it HAD allowed `COMMAND`, it would have introduced some ambiguity in some cases. Rather than matz/someone just deciding "Yeah, you shouldn't be able to use that syntax in an array literal." It's also possible it was an unconsidered oversight. :)
You may have more luck on /r/forhire
Thank you.
I don't have any experience with Express, but if you are developing apps that use RDBMS, nothing else even comes close to power of Sequel. Sequel is a software masterpiece and so is Sinatra, but you can do even better now if you use Roda instead of Sinatra (same author as sequel). Roda is the fastest ruby framework.
In that case it sounds like an object with all the attributes may be best.
Don't worry about scale until you need to scale. Premature optimization is the root of all evil.
Awesome response, thanks!
Any function. `[Math.sqrt x]` doesn't work either.
Now that's a quality answer. Even StackOverflow couldn't figure it out.
Does it keep the access token properly hashed in the db, with the same care you'd use towards a password? It oughta. And the README should reassure us. 
From the postgresql docs: &gt; While a flag stored in a table could be used for the same purpose, advisory locks are faster, avoid table bloat, and are automatically cleaned up by the server at the end of the session. https://www.postgresql.org/docs/9.1/static/explicit-locking.html
Either will get you far enough that you either have the money to go further or the real problem is with your business model.
Did a quick 8x speed of me sketching a few Lemurs: https://youtu.be/DehuhGQYbY8 Most of these ones will show up in the Hash section
Documented also here: https://github.com/CanCanCommunity/cancancan/wiki/Defining-Abilities%3A-Best-Practices
Roda doesn't have good learning stuff.
Victor! I found your blog article on Ruby Weekly and I just wanted to thank you for your work. I think this discussion is fascinating as I agree and disagree with points on both sides. In a way it reminds me of how you could argue for the "proper and sustainable" way to solve, say, an integral calculus problem. There are so many ways to do that and come to the same conclusion! Thanks again!
Neat! Thanks for adding that!
Totally right!
Just a bit of link baiting ;P
Cool, didn't know about that one. Though my list is also a personal preference :)
Updated post with links to both the projects and RubyGems.
"Total garbage". Gee, thanks!
Here's a blog post I wrote on how I handled the user-provided code https://medium.com/@squidarth/running-user-provided-code-6c87b94720a3
Go get your hands around Opal. Using Ruby on the backend and front end will elate you. [Crystal is also ***REALLY*** blowing up right now](https://github.com/opal/opal/issues/1715#issuecomment-345323306) (think Ruby at C speeds and memory usage levels). I've seen Go dev houses say they'd drop Go in a heartbeat if Crystal supported native Windows (which it's coming), but it shows you just how powerful and desirable of a language that Ruby really is. People LOVE Ruby, but they also NEED speed, so yeah, win-win and it's seen with those stats in that link!
welcome my friend! I have been flirting with Ruby also for at least a year now on and off, but a few months ago I fell in love too!
If you hadn't mentioned Crystal I would have never actually read about it. Didn't even know its so much like Ruby, I love this.
I found ruby after a LONG time of trying to learn other languages, and I know how you feel for me. It just clicked for me from the moment i started using it.
Yeah, it's pretty exciting to see Crystal in just one month back in July to August blast out of position #60 to #32 and now within just the last couple months it's at #24 on TIOBE. We're going to see it blast into the top 20 languages imminently. It's already blown by Kotlin, Clojure, Hack, Julia, Erlang, Rust, Lua, D, Scala, etc. **And you can see why**: [Amber](https://github.com/amberframework/amber), a Rails-like framework that's learned from Phoenix, Kemal, etc., is serving up ***968,824.35 requests per second*** on 32 cores at 2.7Ghz. Now couple that with Opal for a full Ruby stack (isomorphic) platform from server to client... WOW, that's super sexy and productive. Even Thoughtbot is getting on board with their own [Lucky Framework](https://github.com/luckyframework/web) now too.
&gt; super sexy and productive hell yes! 
I didn't necessarily *want* to use Ruby for my last couple of projects, but it speeds up the process of getting things done, there is a lot of help out there, and there are a lot of great Gems that can help you over the hump. If you're going to be writing programs that you run in your local terminal, Ruby is a natural. Node, not so much, and not even Java, though I think both have their distinct merits. But for personal projects that run locally, Ruby is very much my No. 1.
For the things I'm working on right now -- local programs that get things done -- Ruby is a natural. 
I like hearing that Crystal is finally blowing up. The one complaint anyone could have about Ruby is that it's slow. 
If you do decide to check out functional programming I recommend Elixir or Elm. Crystal is cool. It‚Äôs like compiled Ruby. One thing I will say is that a lot of people never get beyond a certain level of Ruby. When you get into stuff like metaprogramming it is crazy powerful. 
And unfortunately we also need Windows support, which is why I won't start using Crystal yet (even though I'm usually developing on OS X). Once Crystal gets support for Windows it'll be my goto choice for servers. 
I doubt this is an option, but it does run on WSL (Ubuntu). You may also want to follow this and chime in: https://github.com/crystal-lang/crystal/pull/3582
Amazing! I had a similar revelation (much later than you it seems!) In high school I wanted to be a software engineer, it in grade 11 I tried java an university of Toronto and realized I value happiness over that career. Java turned me away from almost all tech! Then I studied film. I made art, recorded music and thought my life would be about creating art and music. Finally I learned ruby from my coworkers at Shopify, and everything changed. I‚Äôm now at home. Welcome! üôè
I certainly do plan on mastering functional programming, I just can't do it at this level, with school and everything learning my first language and algorithm theory But I will keep those two in mind for sure
This is interesting. Is anyone here using it in production?
A lot of people dump on Ruby because of Rails. Personally, I think it‚Äôs a wonderful programming language. It may not be as performant as some language at some things, but for the projects it‚Äôs a good fit for, it‚Äôs really a wonderful language. 
Also lack of strong typing
Wait till someone with money starts funding it... that will get the attention of all the 'cool kids' and the ruby renaissance will be on... I look forward to it... but quite honestly, I would be sticking with ruby if everyone else on earth dumped it and I had to use 1.8 ;)
The coolest thing about ruby is... the further down the rabbit hole you go... the more in love you will get.
From my understanding Ruby is strongly typed, but is dynamically checked. What did you mean by lack of strong typing?
And to think there's a lot of people using Java. There's a lot of work to do guys. 
ruby is truly a great language to write in. It's a bit hard sometimes to google problems without coming into contact with loads of rails solutions
I've never had a problem with lack of strong typing. The variable is what it is, but I'm far from an expert. I would appreciate any insight.
Ah sorry, I misspoke. I meant static typing. Helps a lot in large code bases
Thanks for the post. I don‚Äôt understand why you‚Äòd need to `eval` the user provided code, though. Doesn‚Äôt Rubocop take a String, parses it and outputs the violated rules?
Sorry, I meant static typing. It helps clear up a lot of bugs and makes it a lot easier in a larger codebase. If the type checking passes, it often just works. It's also a lot more descriptive if you're working with a code base you're unfamiliar with. I write python at a large company and really miss type annotations.
When I first tried out Ruby, it made me so happy. I didn't have to worry about low level abstractions or unnecessary bloat. That freed my mind to focus on the high level implementation instead of low level. Just compare splitting strings in Java and Ruby and you'll realize just how much better Ruby is.
I decided to detour to Ruby before I went to Perl6 because I thought it would be easier to learn OO in ruby. Now, I am not sure I still want to go to Perl6. I am working on Eulerproject.net with Ruby and it is a lot of fun.
Why do you need windows support if you don't use windows? Why would servers make a difference. Don't you deploy with docker on servers? 
I'm biased, as I helped create the framework, but I've put it into several production environments :-)
[removed]
I really like languages with Hindley-Miller type inference. Haskell is built around it, and both Flow and Typescript for Javascript use it. In these systems, you don't have to specify the type of every variable as you do in Java - you might not have to type *anything*. The system can infer what type a variable is based on how it's used, and notify you if there's any conflict.
I'm just guessing, but a lot of people are using Azure and being forced into a Windows environment for that reason
Is the Windows requirement coming from the workstation - side, or the server side? If from the workstation side, why are they developing on Windows? Honest question, I don't use it that much.
I think going from javascript to literally anything would be a breath of fresh air ;)
I‚Äôve been in IT as a sysadmin for 10 years and while I‚Äôm proficient in bash scripting, I haven‚Äôt ever truly learned a programming language. That is, until Ruby came into my view. I took a course on Udemy and it just clicked. I‚Äôve re-written bash scripts in Ruby now and I use it to do powerful things for my job. I recently read an article by Red Hat about using Rust to speed up Python code. Then I thought, I bet you could speed up Ruby with Rust too and sure enough - there are easy ways to use Rust code to speed up intensive operations in Ruby. Programming is cool. 
Wow this is cool - didn‚Äôt know about it!
Truffle's going to eat pure Java usage resistors. 
Definitely look at Racket or straight Lisp first for fn programming. Emacs Lisp deeply influenced Matz for Ruby.
I hope Crystal takes off, but TIOBE is a bad index, wouldn't count on it
Welcome!! I guarantee you‚Äôll fall in love even more :)
What‚Äôs a better one and why would it be better? So far I‚Äôve found this to be an excellent benchmark over the years‚Ä¶
Dude.. It's based on a flawed methodology, a lot more sensible is to follow how many projects on Github use it, activity of community and companies I don't believe in rankings, but redmonk might be better Read the comments for better explanation https://www.reddit.com/r/golang/comments/4ekv8q/why_is_go_doing_so_poorly_in_the_tiobe_index/ https://www.reddit.com/r/rust/comments/3nk4oo/rust_heading_for_world_domination_at_tiobe_index/ https://www.reddit.com/r/programming/comments/69q9fb/tiobe_index_the_pack_is_closing_in_on_java_and_c/ 
There's a variety of links on the right hand side of the page right now...though it's kind of dated, since ruby is now at 2.4. Has Programming Ruby made it past 2.0? 
Web scale 
Crystal != Ruby. To imply that using it gives a full end to end Ruby stack is misleading as hell. Crystal looks superficially like Ruby, but to get the performance you need type annotations and to refrain from a hell of a lot of the "magic" that makes Ruby Ruby. It's perfectly fine to like Crystal, but it's worth noting that despite how they like to present it as looking like Ruby, they often also explicitly play down the similarities and make the point that being as similar to Ruby as possible isn't a goal. 
To me, if static typing makes a big difference to you, it indicates that you either don't write proper tests and/or that you over-rely on type signatures to do things it shouldn't. 
I like Ruby for its expressiveness, intuitiveness and natural way of notation while keeping its internal consistency. But like any other tool, there are task where it is less suitable or even unsuitable for. If you are really interested in functional programming, I wouldn't waste time with toys like Crystal or Elixir but learn some real purely functional language like Haskell with industry-proven implementation (GHC). It sheds some fundamental and different light on programming concept, even improving coding style in Ruby in return.
Finally I decided to choose Ruby as may language of choice. I like it's clean syntax and the cool community behind the language and especially RoR. 
Thanks, I will keep Haskell in mind, but I don't have the mental bandwidth to learn something like that right now. But when the summer hits, I plan to master a couple new languages so I'll check it out then I actually did love Javascript while I was learning it. I hated it at first, but then when I got to the point where I was calling functions within themselves, I started to say how great it is. 
No it hasn't but I think it's still very relevant. Honestly, I haven't seen much published outside the books in the right hand links. Beginning Ruby by Peter Cooper (not listed) might be one of the last Ruby books to have a new edition. 
I‚Äôve got Learn Ruby the Hard Way, which is free on the website but the book comes with a set of videos of the guy doing the lessons with you. Also Head First Ruby.
Yes, learning Haskell requires some serious dedication, esp. when got used to imperative way of thinking about problem algorithmization. Not for the faint of hearth ;)
I went with one mentioned Beginning Ruby by Peter Cooper and for more of the nitty-gritty I've also got Programming Ruby The Pragmatic Programmers Guide. 
If you‚Äôre coming from another language I like Sandi Metz‚Äô ‚ÄúPractical Object-Oriented Design in Ruby‚Äù and ‚Äú99 Bottle of OOP‚Äù since they are quick and built around concepts you may already have familiarity with. If you‚Äôre starting cold I like ‚ÄúLearn to Program with Ruby‚Äù from the Pragmatic Programmers. I would supplement either of these reading paths with this set of hands-on exercises to get you into Ruby code and experimenting with different parts of it: http://rubykoans.com/
Why‚Äôs (poignant) Guide to Ruby is you want to feel crazy while you learn. Otherwise, The Well Grounded Rubyist by David A. Black.
I've taught a lot of beginners, and this is the best suggestion. Though, if you are brand new to programming, Learn Ruby The Hard Way is the best to get started, then Learn to Program for a slightly deeper dive.
This is so useful!
A little off topic: get a subscription of rubytapas.com
Check out [`set_trace_func`](http://ruby-doc.org/core-1.9.3/Kernel.html#method-i-set_trace_func). It lets you hook into all kinds of events (such as method invocations). I‚Äòm not sure about line evaluation, though.
looks promising, thanks!
What I'm trying to figure out is how to structure my programs -- i.e. when and how to use blocks and classes, separate files, etcd. My code is very much "procedural" at this point. I need something that is going to teach me the Ruby "style." -- Is that POODR, or ???
I would look to Eloquent Ruby in that case. It is all about Ruby style and well structured code. POODR gets into that, but not as broadly.
Yeah, I was thinking more about somebody except you :). Anyway, it's good to hear that it's been applied into production already.
+1000 for POODR if structure, modularity, maintainability, and good habits is what you‚Äôre looking for. 
You would be right in that there's not enough tests and not enough documentation. But in code bases with hundreds of thousands of lines written by other people there's not much I can do about that. It can be very hard to figure out all the places a piece of code is being used and thus static typing can catch a lot of errors without having to do a full relaunch. Also didn't help that to test that code it took upwards of 10 minutes to build and deploy to a remote cluster. I used to write a lot of Ruby, but more so in my free time I've been writing in Go. There's definitely things I miss about Ruby, but types make things so much faster to write for me since it's more self documenting.
Azure supports Linux.
Can you provide examples of inputs and outputs?
Individual chars in a string can be replaced using []. I this example you want to do: string[1] = 'g' string[3] = 'g'
A line of code that replaces indices 1 and 3 of the word duck in the letters h such that the output of that single line code will be dhch. Hope that clarifies it.
Head First Ruby
See my edit
On the topic of books, Manning just announced the 3rd edition of "The Well-Grounded Rubyist".
I got this Udemy course and it is what got me into Ruby. Books are great but sometimes it‚Äôs nice to have someone literally show you how to program: https://www.udemy.com/comprehensive-ruby-programming-tutorial/
Thank you all so much for the input. Just to give you guys a little bit of a background, I have a little bit of JS experience and have recently been excepted into a Bootcamp and would like to read this before the program starts and use this as reference during the course. Thanks again!
I love it for both reasons. Ruby itself is so nice to write, and Rails makes me productive af.
"string".sub(/^(.)./, '\1h').sub(/^(...)./, '\1h')
 "string".sub(/^(.)./, '\1h').sub(/^(...)./, '\1h')
 "string".sub(/^(.)./, '\1h').sub(/^(...)./, '\1h') Just swap the h for whatever you want to change it with, but it's stupidly over the top when you can just do str[1] = h and str[3] = h over 2 lines!
I would suggest: * Naming your variables better. (addrs -&gt; addresses, prcnt -&gt; percent, attck -&gt; attack, etc.) * Naming your functions better. (def ph, ph can mean many things, hr for hash rate can also mean many things (human resources e.g.) ) Also, there is a point where your creating an instance varaible `@body` just so you can use that value in a function in another scope. My suggestion is that you rewrite your function so it retuts the value you need, and call that function where you are assigning the value. See example below # turn this def parse(apis) string = open(apis) @body = string.read end parse(addrs[:all_pools]) pools = JSON.parse @body # into this def parse(apis) string = open(apis) string.read end pools = JSON.parse(parse(addrs[:all_pools])) As you can see now the function looks a bit weird because your function is also called parse. This can easily be fixed by making your own parse method make the call to JSON.parse which looks like this. def parse(apis) string = open(apis) body = string.read JSON.parse(body) end pools = parse(addrs[:all_pools]) A good next step for you is to try and split all your functionality into classes. Not necessary but makes it really awesome if you need to maintain it later.
I know onetime use is simple! I want this to be automatically reusable for a random amount of indices.. basically for random words
If you don't have enough tests, type errors is the least of your problems. Consider that errors are likely to be spread throughout the entire code base, so if static typing is catching a lot of errors, there will be a number of errors elsewhere that does not get caught. Without a comprehensive test suite you depend on those bugs being spotted ad hoc, and there is just no way that will work well. &gt; Also didn't help that to test that code it took upwards of 10 minutes to build and deploy to a remote cluster. That, to me, would be the biggest red flag. If your code can't be tested and deployed in smaller modules so that you're only looking at very limited integration tests against the entire system, the architecture is beyond fucked up. 
That code was the glue between multiple systems unfortunately and was very hard to write tests for. Considering it was designed to run large distributed jobs on dozens of servers there's only so fast your can make it. It worked for the most part but was a bitch to change
Sort of off-topic, but if you‚Äôre looking to crack into some theory, you might check out the free MIT CS lectures on YouTube. It‚Äôs not Ruby-specific, but they‚Äôre a pretty solid source of information if you‚Äôre getting into the field. Intro to Algorithms is cool. Just food for thought.
how does it work? I thought that it should output some result but I can't see anything like that https://imgur.com/e1xhmMI
didn't know that, thanks.
Seconded beginning ruby, that's what I used to learn back in the 1.9.1 days
[removed]
You could do something like: string = "Duck" [1,3].each { |i| string[i] = "g" } puts string
Thanks, this is really helpful, will update it as soon as i have time!
[removed]
I would agree here... Don't get all macho and try to sort it all out by yourself... you WANT to get in the habit of regular communication with other coders / customers / etc... 
If you learn sinatra, you will be able to shift to Roda pretty easily. The main difference is the routing tree concept. Roda can get a little verbose, but if you architect based on nested resources, it's hard to beat. There are even some plugins that can make Roda look just like Sinatra syntax-wise. 
I think what you want is to do this. dir_files = [] Dir.foreach("#{directory}") do |f| dir_files &lt;&lt; {:name =&gt; f, :size =&gt; File.size(f)} end 
Could you not just create one hash where the key is the file name and the value is the file size? hash = Hash.new hash[file_name] = file_size Maybe I don't understand your problem but that seems like what you're going for. 
My first thought sadly is that you are asking an [XY Problem](http://xyproblem.info/). The best solution to your problem, to me at least, appears to be to not do what you are doing. You don't need to combine those two hashes together if you do something better in the first place. What I would do: Dir.entries(directory).map { |f| { name: f.to_str, size: f.size } } That will give you an array containing a hash for each file in the dir. That hash will have a key name and a key size, representing the name of the file and it's size respectively. Note: There is no need to string interpolate a variable by itself. If you truly need to stringify directory prior to the call, use #to_s on it. If you truly need a hash, then I'd do something like this: Dir.entries(directory.to_s) .map { |f| { f.to_str =&gt; f.size } } .reduce({}) { |acc, hsh| acc.merge(hsh) } This will give you a single hash, where the keys are the filenames and the values are the size of that file. You could use the Hash#each_pair method to iterate through the hash and get the filename with the size easily.
Also, I presume you are unaware of /r/learnruby That's probably a better place to ask this kind of question.
Thank you, I was unaware of this subreddit. I just started learning ruby in my scripting course so everything is a bit new to me. I apologize for the XY question 
If you have more than one char you want to replace, you can use a range there too: str = "I like dogs a lot" str[7..10] = "elephants" str # =&gt; "I like elephants a lot" I have rarely if ever needed to do this, myself. 
What you want is deep_merge https://apidock.com/rails/v4.2.7/Hash/deep_merge%21 If you're not using Rails, you can expand the source on that page and see what happens in the source code and emulate it. 
I would do it like this dir_files = {} Dir.foreach("#{directory}") do |f| dir_files[f] = File.size(f) end dir_files.each { |k,v| print "#{k}: #{v} bytes\n" } Other solutions in this thread create an array of hashes with two elements, but if that's what you want, then an OpenStruct would be a better option imo.: dir_files = [] Dir.foreach("#{directory}") do |f| dir_files &lt;&lt; OpenStruct.new(:name =&gt; f, :size =&gt; File.size(f)) end dir_files.each { |e| print "#{e.name}: #{e.size}\n" } 
Ask yourself, what is the key, what is the data that you want to store and how do you want to process it. From the description it is not entirely clear what answers to these questions are. You do not even mention what you use as key in either Hashes. I would assume that the file name would be a natural candidate but then it would be odd to have a Hash where key and value are the same.
This question comes up [quite frequently](https://www.reddit.com/r/ruby/search?q=beginner+books+learn&amp;restrict_sr=on&amp;sort=relevance&amp;t=all).
It's nothing to apologize for, I point it out because it's a logical mistake a lot of people make. Ideally, now that you know of it, you can identify when you are yourself doing it. And potentially when others are doing it. Identifying it means you can address it and skip a whole lot of back and forth that is just wasted time.
&gt; f.to_str don't use `to_str` when it should be `to_s`
Yes, there is a subtle difference between the two methods. And, on 2.4.2 at least, the file object has #to_str and #to_s on it.
Okay, you made me check things, because as far as I know while there is a subtle difference between the two it's mostly that you should never call `to_str` yourself. First of all, Dir.entries returns strings, not file objects. So neither `to_s` nor `to_str` is required (and `size` doesn't do what you want). Secondly, on 2.4.0 File objects don't have `to_str` defined and `File#to_s` is not what you want, it gives a string like `"#&lt;File:0x007fdb7c0c21a0&gt;"` (`File#size` on the other hand is what you want).
Does hehestreamskarma's "monkey-patching String" solution (see above) not meet your requirements?
&gt;&gt; And, on 2.4.2 at least, the file object has #to_str and #to_s on it. &gt; Dir.entries returns strings, not file objects. Ah, that explains a lot. Fixed. That's what I get for quick solutions in IRB. &gt; as far as I know while there is a subtle difference between the two it's mostly that you should never call to_str yourself. I've never heard that piece of dogma, and I would reject it without significant explanation. If I shouldn't call it, then it shouldn't be a public method. The difference between the two is that #to_s is defined on Object, where as #to_str is not. #to_s is intended to give a printable version of the object, which is why you see exactly what you listed above. #to_str is defined on the String object and it is defined on objects that exhibit string-like behavior. [Reference](http://marcgg.com/blog/2017/01/23/ruby-to-s-to-str/) &gt; So neither to_s nor to_str is required (and String#size doesn't do what you want). Yep. Fixed.
&gt; I've never heard that piece of dogma, and I would reject it without significant explanation. If I should never call it, then it should not be a public method. Probably because I remembered it wrong, it's more like "be careful to only define to_str if it's not on a string like object", but anyway, even then it's really much less useful to call `to_str`, there is a reason `to_s` is shorter.
Check out TTY::Command, I've found it to make it easier to use ruby as a bash replacement. Now I never go bash anymore. https://github.com/piotrmurach/tty-command
Awesome!! I didn‚Äôt know about it I will try it out today. I like what I‚Äôm seeing so far. 
This feels like it's going to break really easily as there are many languages that use context of surrounding sentences. Also google translation is already really poor this would just make it worse.
If you're updating in real time, just have it translate the full text every 5-10 changes. The rest of the time, just API the changed sentence.
But context will change the meaning of many sentences. Languges are too complex to do a simple find and replace.
I didn't say that though. I was trying to say that if a user edits a text, don't retranslate that whole text, but if they edit a sentence of that text, retranslate that sentence.
That is correct, it's the tradeoff which makes translations cheaper. After some time of real world usage, I can say that it works acceptable for utility texts like product descriptions. 1) in most cases sentence context is enough to produce meaningful translations (for major languages, at least) 2) most of the changes to existing descriptions are related to fix typos/markup/properties, not meaning 3) it is very good idea to have on/off setting for sentence splitting because in general case, descriptions are relatively big blocks scattered over markup, user should decide, thanks for idea.
I think it's important to point to the similarities instead and to help the developers of the language understand that this IS the strength of the language. If they move away from Ruby further or do not push towards Ruby, they are ultimately going to lose their base. The idea of Ruby as fast and compilable is the trump card here. The other things such as types, etc. are ultimately secondary.
I tend to hate this one when I see it in code. Why should each handler have to know about the 'chain' at all? I'd rather have a parent holding them all doing something like: handlers.each do |handler| if handler.can_handle?(whatever) handler.handle(whatever) break end end Instead of telling each handler about it's successor, context it shouldn't have to know about, and relying on it to do a `successor.call` (something it might mess up and not do when it should have). There must be a place for this pattern, since the GoF included it and all... but when I've seen it used like in the example in OP, I've wished it weren't. 
You sir, are an adult. I love Ruby because it fits what 'I' do... I think you like it too... just not for everything. But that was one of the nicest ways of saying it is not for everyone / everything... and that is absolutely correct. It is also one of the big reasons RUST is catching a lot of attention in the systems spaces too... I like Go... the pedigree, the cool things that are being done with it... but long term, the 'borrowing' is going to add another error checking that is just as strong as the type checking and things (systems) will get a LOT more secure. If memory leaks don't end the world first ;)
Agreed on *so* many levels. In particular, his code declares that the order in which potential handlers are checked is meaningful and immutable (because of the inherent OCP violation). You *must not* reorder, add items to, or remove items from the (conceptual) list of handlers. A highly reliable source of annoying bugs.
1000 times yes. Chaining handlers like just that feels horrifically wrong.
This can be achieved by setting the `TZ` ENV variable. Setting ENV['TZ'] = 'UTC' does exactly this
[removed]
Your servers should be set to UTC anyway.
Long story short, tests were passing locally that weren't on CI, reason being, CI Timezone was UTC and locally was set to my timezone because of my system's time
I tend to agree, but at the same time I find Crystal disappointing in that respect. Though I have some sympathy - I've been (very slowly) working on a Ruby compiler, partly as an experiment to figure out how to even make Ruby compilable, and it is a formidable problem (not compiling Ruby per se - a naive approach can be done relatively eaily, but doing so in a way that'll end up giving fast code is very hard), so I understand that it was/is easier to make some of the decisions they've made. On the other and in some cases they've taken decisions that have very clearly and explicitly caused unnecessary divergence. I think they're in a bit of a quandry, where if they remain this close to Ruby, they either need to decisively "win", or they'll forever face the problem that Ruby is so similar and with a larger eco-system that people will write Ruby and maybe look to translate parts to Crystal. On the other hand, they can opt to diverge more and more, but then they do need to be very careful to do so slowly enough that they don't as you say end up losing their base. 
Well, you're explaining why it comes out like this in the current parser, which doesn't really tell us why specifically. I think the Ripper example more clearly demonstrate just how messed up the Ruby grammar is. In general, there are a lot of odd little ambiguities here, and I think the answer in this case is simply that while "puts 0" *could* have been made to work inside an array literal, "puts 0,1" would have been clearly ambiguous, and so the simpler approach is to refuse to accept the paren-less syntax rather than trying to figure out what would be the most intuitive parse. 
Well, yes, the obvious ambiguity is what [puts 0,1] should mean. Special casing single argument methods would be really ugly, and treating the above as [puts(0,1)] would also be really ugly. Better to disallow both. 
If either Express or Sinara is causing you scaling problems, your problem is your architecture, not Express or Sinatra. 
If someone were to make a Ruby compiler that would perform like Crystal then it would categorically kill Crystal. 
The best bet for that currently is probably Truffle. Mine is too far away from production quality (it can't even compile itself yet), needs more code generation targets, and is incomplete, and that's before looking at optimizations. I think long term it's possible, but it takes a *lot* of dirty tricks to make Ruby fast, because while most Ruby code is reasonably well behaved, it needs to protect against some really pathological cases (people overriding really basic methods etc.) and some that just takes a lot of tradeoffs to decide on (what to do about people loading files dynamically based on reading a directory, for example - Ruby doesn't have a distinction between "load/compile time" and runtime, which means a lot of code does stuff that is semantically unclear if you want to compile it) 
Sounds like your tests did what they were supposed to do, and caught a bad behavior. Although proper implementation would probably be to fail locally and work on CI, if the expected behavior is to use UTC.
&gt; There must be a place for this pattern I've seen it used where you have a preexisting chain/hierarchy of objects. For example, on OS X there is NSResponder, which passes commands up through the view hierarchy, to the window and then to the application object. That particular situation can't be replaced with an array of handlers.
It does.
Useless Blog spam. 
But please don't, if your code is to be read by others. It's obscure and confusing
You think? I don't think there's anything wrong with setting 'system time' to UTC. System time has gotta be something. 
If you're running an app with somewhat sensitive data, you should probably consider making a class to deal with time in your application. A time machine, if you please. The idea behind this class is to make things *predictable* by providing context for the time manipulations. Basically, you pass the time machine object around and call `.now` whenever you need to fetch the current time. The design might seem odd, but it comes in handy once you need to make things happen in the future (or in the past). You can make an around wrapper with a similar interface: dmc12.with_time(TimeMath(Time.now).advance(:hour, 2).call) do # the code here will execute in future, yay end You could extend the interface to change the time zone, freeze time, etc. NOTE: the design decision works better when you utilize some DI tools (e.g. dry-auto_inject + dry-container).
The problem is that if you don't see the TZ setting, you make false assumptions about Time.now . It's better to be explicit about it
I believe Engine Yard does
Go to a cloud hosting company e.g. Digital Ocean, get a droplet, install Ubuntu, put whatever you want on it.
awaiting the follow up post of "millions of users receiving our email" where they setup spf, dkim, and don't send from an AWS host.
I like the fact that the order of operations reads naturally, e.g. first to last. However I would prefer to use blocks and static methods. Since you instantiate these classes on a one-off basis and don't use internal state tracking at all, there's no reason they need to be instance as opposed to static methods. 
My company paid for me to attend Big Nerd Ranch's iOS training a couple of years back. Totally awesome. Note that their main focus is mobile training like iOS or Android, not necessarily Rails back end web development. I don't even see any Ruby/Rails training on their site so I'm skeptical why they're posting here.
Hmmmmm. My advice would be, don't. Use a hosted service like mailgun, they will send a million emails for $420 (blaze it.) Email is the biggest pain in the arse ever, let alone sending a million of the damn things in one go.
Hi guys, thanks for the feedback on my article! Yes, in GoF book they chain handlers using a linked list. Each handler knows about its successor. I like the idea of /u/jrochkind with iterations on handlers. As well as I agree that since those handlers are stateless, instance methods could be switched to class methods for the sake of simplicity. A lot of good points here. Thanks for a feedback.
Heroku does. Or like others said just use aws or something and manage it yourself 
&gt; invest a bit of tech time and to go with transactional e-mails instead of using an e-mail marketing platform We used a transactional email platform (multiple actually - they don't all have the same delivery rate according to ISPs)
I just replied to the same concern here https://www.reddit.com/r/ruby/comments/7ei2uu/sending_an_email_to_millions_of_users/dq5cjtu/
which one was the best? mailgun has worked well for me.
oh, i'd keep the handlers stateful. It often makes for much more convenient implementation as it gets more complex. Whether it's stateful or not should be an implementation detail up to the handler, which means it should be an object so it can choose to be stateful. 
If you're going to upgrade - why just go to ruby 2.0 and not upgrade all the way to ruby-2.4?
This would make the most sense, especially with 2.5 coming out in a month. 2.0 released almost 5 years ago. 
Python is kickass for data wrangling (just as much so as R) but it also gives you the flexibility to utilise a whole bunch of other packages. The big data vizpackages seem to largely be based on JavaScript (read:d3) so it's probably worthwhile learning js while you're at it.
Especially since ruby 2.0 and 2.1 are no longer supported.
You stated that sending too many emails would blacklist the sender, so the solution was to throttle down the sending to 100 emails each 30 seconds. You also said such send events were rare and important, so I'm assuming your clients need to receive the email ASAP. If there's always only a single worker sending emails, I calculated that it would take 5.20 days or so to send 1.5M emails. Of course I don't think there was only one worker/server sending, but you didn't mention how many concurrent workers were sending the emails, how many servers, etc. This would be a good bit of information to add to the article.
Those were originally listed in 2.4 but never implemented. Now, what I need is a way to get mtime for Dir. 
Mailgun works great, except for some local ISPs. German and french ISPs have really bad delivery rate on Mailgun so we're using Mandrill at the moment but are in the process of moving to Mailjet.
They're indeed rare and important, one such example is a TOS update but they're not urgent and your maths is good üòÄ. It took about 5 days to send them all without any concurrency. No concurrency was done on on purpose so it's easier to control the rate of delivery.
Ah, fair enough, I was actually wondering how one could manage to send from two different IPs concurrently to save time and avoid blacklist, but I guess you didn't need that.
How has been your experience with Mailjet, with regard to delivery? Asking this since last time I tried (some years back), I had numerous emails marked as spam (while I never got any issue report when using either Mandrill, or more recently Postmark).
Please do not target Ruby 2.0 - it's EOL (end of life), like Ruby 2.1 ([source](https://www.ruby-lang.org/en/downloads/branches/)). You should target either 2.3 or 2.4 now. At least EngineYard &amp; Heroku support Ruby 2.x completely.
I had good experience with Postmark too. About Mailjet, it's not in production yet but they guarantee us some good delivery on french ISPs and with a lot of ours users there that's all we care about. Also, I talked about delivery rate but in our case the culprit is also delivery times to these ISPs. Mailgun can take up to 10mn to deliver to @free.fr, @orange.fr or @gmx.de for instance and this clearly shows on conversion rates ("signup" to "I click on the email validation link"). We'll probably write another article on how we do email routing to different providers from our rails app. I think it might be of some interest to the community. At least it is interesting for me üòá
2.1,2.2,2.3 and 2.4 is in early access as far as I remember. Can't remember the ones earlier than 2.1..
Ugh. I wasted several hours because of this.
Definitely Postmark IMHO.
Entirely functional, no new classes, Command-Query Separation.
I'm not cut out for Ruby programming, and I earn my living from it. :-(
We use Mandrill. Works well and they have a robust API and a Ruby gem.
If I read this right, it's only a problem if you program your site to use huge values in cookies? Either way interesting read
&gt; My hosting provider only supports 1.8 Please name them so we know to never go there... 1.8.7 came out in 2008. It's nine years old. What else have they not bothered to update?
Care to explain why you wouldn't invest in email marketing platform? There are clearly benefits beyond offloading the complexities of mass-email delivery discussed in the blog post. 
Dreamhost does and it's good if you need other things besides an app server.
If your userbase is big (or even bigg-ish) the price are very high (either [by month](https://cl.ly/391r103a2w1v) or [pay as you go](https://cl.ly/1N270T2o4205)). Of course engineering is not free either but it's still cheaper. 
Why would you need this is there is a .entries?
Why not `Dir["*"]`. This is now a clutter in stdlib.
Thanks. Dreamhost looks good. I'll check them out 
Sure, but there are Enterprise solutions that make more sense at such scale. The real issue I could see with rolling it yourself is wasted resources. The benefit of using a marketing platform is that it empowers others in the organization to maintain and execute your email management. If you can anticipate that your business needs will grow to include the need for another department to closely manage all mass-email you've wasted some time spinning your own. If you want to continue development in house you may end up building a complex system that you would have been better off purchasing from the beginning. 
I dunno. Really the only advantage I can think of - and it's a very small one - is that you're passing around dir paths as strings, you won't have to concatenate a `"/*"`.
It's just not for Ruby developers. It's for iOS developers that need to use build tools made in Ruby.
&gt; Please name them so we know to never go there... Yeah, naming and shaming is pretty warranted here. 1.8 has been deprecated for 5 years, and even security support ended 4 years ago. Ungood.
NOTE: MEAP == Manning Early Access Program. From Manning: "In MEAP, you read a book chapter-by-chapter while it's being written and get the final eBook as soon as it's finished. If you pre-order the pBook, you'll get it long before it's available in stores."
Globbing when you just want a listing wastes CPU time.
Thanks for the great news service. Keep it up. PS: If anyone wants to start a news site (planet) you're invited to use the (free, open source) Planet Pluto Feed Reader machinery (in ruby) -&gt; http://feedreader.github.io See the Open Street Map Blogs as a (real-world) live example -&gt; https://blogs.openstreetmap.org
Dir.children doesn't include "." and "..". It corresponds to Dir.entries["*"] - [".", ".."]
Is this book worth it ?
`Dir["*"].each` does not include . and ..
`Dir["*"]` likely is the equivalent of the shell function `ls` which won't include any "hidden files" e.g. any beginning with a `.` The two methods will differ in listings if the directory has e.g. a `.ruby-version` file in it.
It might work to to set `inverse` of on one or both of the associations. With strictly conventional associations Rails can figure it out, but since you are using a custom `class_name`, it may need to be set manually. https://www.viget.com/articles/exploring-the-inverse-of-option-on-rails-model-associations 
tbh, in some cases they have played catchup. I mean, are there many features in ES2017 that you'd want to see in ruby? (I'd like if ruby evolved faster, of course)
Yep, `inverse_of` was my first guess, but it doesn't work. I believe it is because of there are two "unrelated" associations from AR point of view (by different keys: `job.current_revision_id` and `revision.job_id`)
That's a really elegant solution to a typically messy situation. However, for completeness, you should include the submission handling via service object in this article.
proper modules. but that would break so much of the autolading, self-configuring magic (like "if defined?(Rails)") that it's never going to happen.
ah, I see what you mean. Where and to what did you try setting `inverse_of` to?
Thank you! Yeah, I was going to include submission handling, but the post was getting a bit longer than I wanted, so I decided to split it into another post. [Here's](https://github.com/Ch4s3/ink_stream/blob/a6e6fd3ebb80290376c95d87e4e1c9381697950b/app/services/articles/finder.rb) the accompanying service object if you want to take a look .
This is kind of an indirect answer, but usually what I do for relations like this is move the 'current' column onto the `Revision` model and make it a timestamp. e.g. add `current_revision_at` to `Revision` as a timestamp, set it to `Time.now` when a revision is made 'current'. Then `current_revision` could be something like: has_one :current_revision, -&gt; { revisions.where.not(current_revision_at: nil).order(revised_at :desc).first }, inverse_of: :job I'm not sure off the top of my head if this fixes the query issue, but I _think_ it does.
Well, it's only a problem if your cookies exceed a certain size, cause that's the problem, right. You may not have known you were "programming your site to use huge values in cookies" to arrive there. It might not be single huge values, it might also just be _lots_ of values in, for instance, your cookie-persisted sessions. 
An additional note: If it's just the queries you want to do away, then this should work: j = Job.includes(current_revision: :job).find(id) Do note however that without fixing the relation issue, `j` and `j.current_revision.job` would be separate instances in memory, which may cause some confusion.
Thank you for the article! I am really looking for articles on actually using Kafka with Ruby, hope to see more tools for stream processing in Ruby. What we need the most is code examples. The Internet is swarming with "Kafka is awesome, stream processing is cool", but we lack concrete code examples that would help us actually build something. 
Yeah, thanks. `includes` is an obvious solution, but felt somewhat "wrong" :) (Though, in fact, it is more "right" than pretending one association loaded by another one.)
`job`. But it didn't work, obviously :)
`inverse_of :current_revision` or `:revisions` is what you added? You're not helping by not being willing to show what you tried, buddy! I think maybe it's `current_revision` that actually needs an `inverse_of`? I wonder if one of those `belongs_to` should be a `has_one`? It depends on how you've modelled it, I don't quite follow the schema. Maybe it would help to model it differently? You have two relationships on one side, and only one on the other, so they can't exactly be symmetrically `inverse_of`, which is probably the sticking point. I wonder if there's any use to adding another association to `revision`, `is_current_revision_of` as a `has_one`? From a different perspetive, the big picture solution would be the ActiveRecord "Identity Map" -- which was removed in Rails4, cause it was too hard to make work right. So, yeah. 
ah, great example thanks. We've actually had [load(..., true)](https://ruby-doc.org/core-2.4.2/Kernel.html#method-i-load) since forever, which could have been (trivially?) extended to return the wrapped module, but as you say, it seems hard to retrofit the ecosystem now. 
Well it's hard to give abstract code examples without getting a context, that's why there is the part 1 (maybe it should be even called part 0). Each next part of this series will contain more and more code examples, so no worries ;)
There is a way with some ActiveRecord trickery. Maybe something like: class Job #.. def current_revision assoc = association(:current_revision) return super if assoc.loaded? assoc.target = revisions.detect { |revision| revision.id == current_revision_id } end end This isn't a pure optimization, because it changes the semantics very slightly. Still might be what you want. 
We're not vulnerable as long as we know exactly what our code is doing: cool cool
I have nothing but praise for Postmark for transactional email and I'm happy to stump up for their high prices since it keeps our support queries down. However they will kick you off for running marketing campaigns, so use something cheaper for your advertising. 
Rack middleware uses this pattern, so that it can manipulate the input down the chain and manipulate the response as it comes back.
I am not at all a fan of `can_handle?` - it's an example of Ask rather than Tell. With a handler array, I'd rather just `handlers.reduce(whatever) { |whatever, handler| handler.call(whatever) }` 
If you didn‚Äôt notice this is a Ruby sub. The content in the blog post is pretty useless here. It‚Äôs blog spam. 
&gt; What would my limitations be with a minimalistic framework? Nothing, really. Rails is simply a collection of libraries (ActiveSupport, ActiveRecord, ActionController, etc.). It provides standard conventions for the sake of convenience, and it does it very, very well. &gt; I know that I would have to do more things on my own, but is there any important functionality that Rails offers and other frameworks don't? Out of the box you'll spend a lot of time reinventing the wheel, mainly with routing and code structure. &gt; Also, if you've had experience with other languages, would you not recommend Ruby for web development considering its speed? Speed of what? Speed of Ruby itself, or speed of how productive I/you are with Ruby? I don't care about how fast Ruby is or isn't. For 99% of us, we don't need Ruby to be lightning quick. You'll read/hear how "Ruby doesn't scale" blah blah blah. The overwhelming majority of people who say that Ruby doesn't scale haven't done anything but benchmarks on some CRUD todo app without any additional optimisations like server-side caching, app server configs, GC tuning, db tweaks. And by the time you need to scale (99% of all things don't), you'll have enough resources to do it. For new programmers, I always recommend learning about object-oriented design first (there's a ton of resources on the sidebar that are great). Don't go head-first into a framework because you'll only hurt yourself in the long-run. Once you're comfortable with OOP and have familiarised yourself with the Ruby Style Guide, I'd recommend picking up something like Sinatra. It's not comparable to Rails (and those who compare the two are comparing apples to oranges) but it's fundamentally sound and can get you on the web with your Ruby code with ease. 
Why not accept a hash in the `initialize` method, that way you can use strong params (with optional key so that we can also display the form on first load). Coupled with ActiveModel validations, it will act like any ActiveRecord object. Also, for select inputs, I usually have a more explicit method like `options_for_publications`, so that if the logic around changes later, we are not depending on some other value used for other purposes.
I'm not passing a hash because I'm using a service object to validate, perform the search, and handle search caching. As I build this demo app out more, I'll probably refactor it to do just that. I really like the idea behind `options_for_publications`, I'll consider refactoring it to work that way. Thanks for the feedback!
Cool I prefer using active model valuations in the form object because it's more direct control over how errors are presented. Like on form field level, which simple_form can then automatically render for you. 
Yeah, that is a nice pattern.
Gotta love a method called `top_ten` that returns an array with 16 elements.
https://www.youtube.com/watch?v=Q5wOegcVa8E
There are much more minimalistic web frameworks for Ruby. Rails is not the only way. Sinatra is a very lightweight option. Rack is even more lightweight (both Sinatra and Rails run on top of it), in fact it really isn't a framework at all, instead referring to itself as "middleware". If you don't like Rails there are plenty of intermediate libraries that can save you from completely reinventing the wheel.
There's a subtle category error in what you're asking. In the data model as shown, it's possible for the `current_revision` to be a Revision that belongs to a different job. As a result, Revision#job cannot be the automatic inverse of Job#revisions. However here is some simple code that will force the matter; class Job &lt; ApplicationRecord has_many :revisions belongs_to :current_revision, class_name: "Revision" def current_revision return super if association(:current_revision).loaded? super.tap do |revision| revision&amp;.set_association_target(:job, self) end end end class ApplicationRecord #.. def set_association_target(association, target) assoc = association(association) unless assoc.loaded? assoc.target = target assoc.inversed = true end end end 
They can't be inverted. The closest you can get here using inverse_of is adding this on Revision: has_one :job_as_current_revision, inverse_of: :current_revision But then you have to refer to this as `current_revision.job_as_current_revision` which is going to be a wart however you deal with it.
Yeah, sorry I have a poorly named method in a demo project I wrote in my free time for the purpose of writing some blog posts in my free time to help people learn about programming techniques. If I had been doing this for my job, yeah, I‚Äôd have renamed it when I changed the behavior, but it‚Äôs not really central to the topic. A more constructive and less snarky criticism would have even been appreciated. I really dislike when other programmers take snide shots at other people‚Äôs OSS work and blogging. It‚Äôs a bad look and discouraged new people in the community.
In the span of several days supporting net neutrality has become the ‚ÄúSupport Our Troops‚Äù bumper sticker of the internet.
yes
My main objection to "class &lt;&lt; self" is it is not clear that the scope has changed just due to the indent level. In other languages, the "static" keyword often identifies a class method, so you know at a glance. So it *is* harder to read for me, and bizarrely cryptic notation despite knowing what is going on.
Speaking of minimalistic frameworks, you could probably check out [dry-web-roda](https://github.com/dry-rb/dry-web-roda). It has virtually everything you need to get started (except, perhaps, the persistence layer ‚Äî you could use [ROM](http://rom-rb.org/) or plain ol' [Sequel](https://github.com/jeremyevans/sequel)). What makes it great is that it *is* indeed just a set of dry-rb libraries combined with [Roda](https://github.com/jeremyevans/roda) to build web apps. Pretty lightweight with interesting design decisions (just check out the way you fetch ENV variables). Its documentation is rather poor so you'll have to figure out lots of things, all by yourself (maybe with a little help from community).
Agreed, though typically the contents of `class &lt;&lt; self` are indented like a block, and there is an `end`. However, it's very specialized and unique syntax, and inscrutable. Other downsides include extra LoC and indentation, as well as obscuring the scope at a glance. I agree that with `def self.foo`, the `self` acts like a sigil, like `static` in other languages.
You went to all this effort and don't even have an example, while the notation that you don't use, and everyone already knows, does have an example??
The idea was to start with the more common style in order to analyze it in that section and understand what really goes in internally. That is a very raw example, I didn't think it was needed to present the needed notation again afterwards since this is all very minimal.
Let's not miss the fact that it's a code smell in other ways. That is some serious feature envy. `top_ten` should be a method in `Publication`. The article makes an argument that if it were, then a refactoring could break it later. That's indicative of some worrying processes. It suggests this application has no test suite, because all it takes to prevent that regression is a single simple test. It also suggests that developers at this organisation don't know what "refactoring" is, because the whole point of a refactor is to change structure without changing behaviour. That trailing push on the top_ten list also made me twitch; it looks an awful lot like a ghetto substitute for `{ include_blank: true }` in the [options for f.select](http://api.rubyonrails.org/classes/ActionView/Helpers/FormOptionsHelper.html). There's also a ternary there that might be spurious. Instead, consider defaults in the parameter list. These are A Good Thing because they self-document and this is especially great when you autogenerate the class docs. So I think the whole class might boil down to something like class ArticlesSearchForm &lt; FormObject attr_accessor :title, :publications, :search_offset def initialize(title = '', publications = Publication.top_ten, search_offset = 0) @title = title @publications = publications @search_offset = search_offset end end 
My argument is always that you can always grep for "def method_name" to find a method definition in one go. 
because `grep -E 'def method_name|def self\.method_name' is too hard
We just check the .env files into git, so they're present in the repo. Foreman automatically loads them in Rails and for Ruby scripts Dotenv provides the same functionality. Our devs have what they need to be productive as soon as the clone the repo. We host our own instance of GitLab, inside our firewall, so we're not concerned about exposing them by committing them. YMMV. Our applications hosted on Heroku have .env added to the .slugingore file, so they are not deployed. Applications in our own data centers are managed by Chef, so the values are stored in encrypted data bags.
I can only recommend Vault, after using it at my previous job. It's very easy to set up and after that runs very stable, with the only maintenance in the whole year of running it being when I had to exchange the SSL cert. We used the Github integration which was also very straightforward to set up and lets you use your Github teams to determine the permissions (e.g. lead devs get access to production envvars, while junior devs don't). We then had a small script that read out the envvars from Vault and wrote it to .env files for the environment.
Yeah, I am saying in with the indent it is difficult to tell what is a class method and what is not if you are scrolling quickly. Also the "&lt;&lt;" operator is not commonly used for anything other than array or string concatenation, and is just confusing as hell here.
So in Rails 5.2 you gonna have encrypted credentials: https://github.com/rails/rails/pull/30067 Basically you'll have all your api tokens and other password-like stuff commited to the repo. The thing you don't check-in is the `/config/master.key` That's the thing you pass around and make people store it on 1Password or something. Pretty good, I think.
Homework and nothing to do with Ruby
Isn't passing it around outside of something like 1PW not super secure?
+1 for postmark, had lots of delivery issues with mailgun.
rg "def .* method_name"
And now, if/when you decide to stop hosting it yourself and go with a cloud based solution, you're going to have to scrub the git history of all of the env files, or change your env variables and manage them that way, or get rid of all of your git history. This approach doesn't sound great. :-/
&gt; others feel [class methods] are are actually pesky and that they tend to make code harder to read and manage. [...] I embrace Ruby‚Äôs OO nature and I like to think (and read!) in objects. I see this sentiment fairly frequently in the Ruby community‚Äîthat classes aren't _real_ objects‚Äîbut everything is a real object in Ruby. Method calling works the same way on all objects, including classes. Do Rubyists actually like object-oriented code, or do they only like instance-oriented code?
Why would you expect our company to switch to a 3rd party hosting solution for git? You don't know us. That's not how we do things. We have security obligations with our customers that would make that very difficult and/or dumb. 
I usually check in a blank .env.template file so that new devs at least know what env vars they need and the app simply *will not run* until they get them from somewhere.
Hey man, not every one has your security requirements and a lot of people either use or end up using cloud hosted solutions for version control. I think it's a legitimate comment to point out that the solution your company is using has a lot of downsides for that model that people reading your comment should know/think about before going with that solution. Please don't rip my head off for trying to provide a complete picture of what your solution entails for the average dev team.
The problem with `class &lt;&lt; self` is a fairly fundamental one -- you can't tell whether a method is a class or instance method unless you scan up for the contextual cue of `class &lt;&lt; self`. That pretty much makes it a non-starter. On the other hand, I appreciate the author's reasoning and motivation to perfect their craft quite a bit. Cheers!
We're doing the same, wrote this comment to watch this thread, hopefully there is a better way.
In the Codecademy, I was forced to use "next" After a quick glance, I came up with this code: i = 18 loop do i -= 1 break if i &lt; 0 if i % 2 != 0 puts i end end
Fastlane's iOS signing management utility and Cryptex (the Android counterpart) follow the same principle. Keystores and certificates are encrypted then stored in a git repository. Using these tools for my work means developers need both git access (with forced mfa) AND the decryption passphrase (shared over a forced mfa password manager). It allows us to manage access to the keys instead of the keys themself.
Usually in ruby we use `Enumerable` methods on collections instead of "looping", for example: 18.downto(0) .select(&amp;:odd?) .each{ |i| puts i} This will print the correct values: 17 15 13 11 9 7 5 3 1 
/u/hanpanai has a more concise solution. It might be easier to read something that takes advantage of ruby-isms slightly less: (0..18).reverse_each do |i| p i if i % 2 != 0 end Or as a one-liner: (0..18).reverse_each { |i| p i if i % 2 != 0 }
Puts always returns nil, it just prints whatever value you pass it to the console.
That‚Äôs pretty combative for someone who is applying a technique from the ‚Äúworst practices‚Äù playback. Pro tip: firewalls protect networks, not data. And I hope I‚Äôm not one of your customers because damn, that setup would be totally failing in your obligations. 
&gt; inside our firewall, so we're not concerned I lol‚Äôd. Hope I‚Äôm not one of your customers. Firewalls protect networks and data in transit, not data at rest. 
I haven't gotten to Enumerables yet. ...but that code does look really nice. Basically, I'm teaching myself Ruby so I can get into Rails. Learning Swift because I also own an iMac Mini and MacBook Pro. Learning C because I want eventually want to dig deep down to the hardware. I like all the control a dev is given with C...plus I also use Linux, FreeBSD, and OpenBSD so C is nice there...and on Cygwin. Oddly, I've found it more difficult to learn object oriented languages than procedural languages.
Thinking in OO takes time to get your head around. Procedural is very much a-&gt;b-&gt;c, whereas OO can have code executing in different places in an order different that it happens in the source file. It's fine, you'll get it. Ruby has a different feel than C (or Swift), and there is a lot of 'syntactic sugar' that lets you do things like the code above. It takes a bit to learn how to think in Ruby though. 
I love C and I love Ruby... Another Ruby option, by the way: (0..18).to_a.reverse.each {|i| puts i.to_s if i.odd?} In C, consider testing the single bit rather than `%` (the compiler will probably optimize it the same way I do... oh, and the `return` in `main` is optional: #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; int main() { int8_t Counter; for(Counter = 18; Counter &gt; 0; Counter--) if(Counter &amp; 1) printf("%d\n", Counter); } And I love C for the control it offers and Ruby for developments speed... but I dislike Java and C++ because I find them full of potholes (they aren't as kind to developers as they could be). I tried learning Swift when it was younger, ended up returning to C because Swift was (at the time) limited to the Apple domain (and I wasn't working on any Apple products).
The first `puts` *outputs* "`This puts returned:`". It doesn't return it. It's given to `STDOUT` and printed to the console. The return value is nil. The result of the `puts` is assigned to `return_val`. The second `puts` outputs the value of `return_val` which the string representation of `nil`. And that is an empty string. For illustration: If you entered `nil.to_s`, the return value would be `""`.
`loop do break if` is `while`, and that's a pretty faithful copy of your C version -- even in C, `for (a; b; c) d;` is just `a; while (b) { d; c; }`. As other answers show, Ruby has nicer syntax options for common looping constructs too.. but they look different, and you apparently haven't learned them yet. It sounds like you've only learned one Ruby looping construct, but maybe know several in C. Problems get easier to solve (and the solutions get shorter) as you learn more of the language, whichever language you're learning. Perhaps the more interesting question is: what did you have at the 30 minute mark, before you looked at the answer? (Assuming you're looking for advice,) the place to approach from would seem to be which part you were getting stuck on, rather than what the "right" answer was after it was revealed. How close were you? Is there a specific thing that just wasn't clicking?
&gt; My confusion probably has something to do with not fully grasping streams vs returns, and I suspect I may have a terminology problem, but this explanation is tripping me up nonetheless. I'd think of it like this. Your maths teacher puts `1 + 4 - 2 + 10` on the chalkboard and calls you up to solve it. This is a mathematical expression: an expression has multiple values (1, 4, 2, 10), but it boils down into a single value/answer at the end. To get there, you break it into smaller sub-expressions. First you do `1 + 4`. That's 5, so you erase `1 + 4` from the board and write 5 there. Now the board says `5 - 2 + 10`. You wipe `5 - 2` off and write 3 instead, then wipe `3 + 10` off and write 13, and the result is 13. `5 - 2` is an expression, and thinking of the answer then wiping the expression away and replacing it with the answer is called evaluating that expression. Ruby code works the exact same way. `5 - 2` might be written as the Ruby function/method `minus(5, 2)`. When the Ruby interpreter reads that bit of code, it runs `minus`, and replaces it with whatever minus *returns*. Method calls are expressions that evalute to whatever that method returns. When you call a method, it can go off and do as many things as it wants -- open a file, download a song, send an image to the printer, all three -- and then, at the end, it picks one and only one value to return. There are then 3 types of method. Methods that calculate a value to return, and then give it to you, without doing anything else -- like `plus(1, 1)` might be. Methods that go off and *do something* like save files or download links, and then return a value that tells you something about it (like `true` if it succeeded or `false` if it failed, or the name of the new file). And methods that go off and do something, and then return `nil`, because there's nothing useful they can tell you. `puts` is an example of that third type. It writes a message to the screen, and that's it. The expression `puts("Hello")` evaluates to nil/nothing, because what else would you want there? It's a function you only use for its effects, not for its return value. As for streams: streams are a standard feature provided by the operating system. There are three by default: `stdout`, which is a hole you can push text into to have it displayed on the terminal you ran the Ruby program in; `stderr`, which is the same, but flags that the message is an error and not just normal output; and `stdin`, which lets the user type text into that terminal and let the Ruby program read it. As far as Ruby is concerned, these are just holes in the wall through which text can be pushed, or which text will fall through. The streams have various uses when you play with them: for example, you could assign `stderr` to log to a file to keep track of errors, and you could link two programs together by having one program's output piped into another program's input. But you don't have to think about that yet.
I'm not surprised by any of these except for Thor. I guess there are way more ruby-based cli's out there than I thought. Thor is quite great, though is very slow...
Well it is harder. Why complicated things that can be kept simple? 
[removed]
https://infinum.co/the-capsized-eight/hiding-secrets-in-vault
I know you don‚Äôt need a return in main but I‚Äôll like being explicit. Another example is in Swift, you can be implicit when setting up variables as integers, floats/doubles, and strings. I always explicitly tell the compiler what I want to use anyway.
If you haven't gotten to enumerables I wouldn't be worried about objects yet
I wish you luck. I had the same issue with the semi-colon when I was moving between C, Ruby and JavaScript (where the semicolon issue is sometimes quietly ignored and sometimes results in quietly buggy code)... üòÇ but I got over it (although my Ruby code sometimes has a semicolon or two) üòú As for implicit code... I humbly offer you my view on the matter: I think of code as a letter written to future maintainers (and perhaps the compiler). I try to write code assuming the future maintainers aren't very experienced and probably haven't learned all the ins and outs of the project... often I assume I might have to read the code in a year or two, after a long vacation scuba-diving and long after I stopped using the language.... This helps me **focus on readability**. I think this is the most important aspect in code. Code should (must) be readable with minimal attention. I think I read my own code about a hundred times more often than I write it (hunting for bugs, refactoring etc'). This include naming conventions, comments and any other oddities that find their way into the code (although in my comments I'm also a code hoarder, which is a bad habit).
Well if you can write it so well in C why not make a C extension for ruby that does this? /s Kidding kidding, but seriously Ruby thinks a lot differently than C, and it can be hard to wrap your head around things at first, especially when you are only working with the most basic construct in Ruby. Things will really really speed up once you learn more about blocks, procs, lambdas and how they tie into enumerable. Off the topic but, if you know C and you learn Ruby you can make some very speedy things that work in Ruby, Ruby is built on C and supports C extensions so if you stick with it you really can have the best of both worlds. 
maybe you should pick one and stick with it and when you get bored of it you pick another? learning 3 languages at the same time and expecting to get proficient at any of them sounds ridiculously hard.
It sounds to me like your problem isn't with Ruby, but with mathematical logic, etc. Perhaps you should brush up on problem solving in algebra, number theory, and so on.
FYI: You can find an up-to-date ranking at &lt;http://bestgems.org/total&gt;. The website is open source too. &lt;https://github.com/xmisao/bestgems.org&gt;.
I think the closest equivalent to the C version is for i in 0..18 puts i if i % 2 != 0 end This version does in in the opposite order of the wanted solution though (writing 18..0 instead of 0..18 doesn't work), but it is much easier to read and understand for a beginner 
`puts` is just a shorthand for `print x, "\n"`. It always return nil
For me it's much more interesting to talk about gems whose popularity is _growing_, this might be an interesting list to skim through ‚Äì http://bestgems.org/featured.
I'm definitely trying out [hanami-cli](https://lucaguidi.com/2017/10/10/introducing-hanami-cli/) the next time I'll be building a CLI. Other than the advantages listed, I'm pretty sure it's fast too.
These are up to date ranks already, no?
There's almost no reason to use 'loop' in Ruby. It's highly discouraged. You should learn about enumerables because that is one of the best features about the language 
Can‚Äòt make it, will there be some sort of documentation?
I am surprised nobody mentions `Numeric#step`: puts 17.step(0, -2).to_a 17.step(0, -2) {|n| puts n}
I think they mean continuously up to date. The article posted is by definition out of date once posted.
Can confirm; have downloaded all 10 of those many times.
Sure. Was just pointing out that http://bestgems.org/total is a living / live website that ranks more than 10,000+ gems and keeps the ranking up-to-date every day. 
If anyone is interested in blockchains and ruby I've put together some starter code examples (from scratch / zero ) in the [Awesome Blockchains](https://github.com/openblockchains/awesome-blockchains) page. 
FYI: You might also read / browse the (upcoming) Day 1 (December 1st) article - yes, sneek preview :-) - of the Ruby Advent Calendar 2017 that's all about the blockchain-lite library / gem titled "[Build Your Own Blockchains with Crypto Hashes in Ruby (from Scratch)](https://planetruby.github.io/advent2017/01-blockchain-lite)". PS: Disclaimer I'm not associated with the original poster or vienna meetup org.
using methods might be a better way to understand this https://repl.it/repls/VirtuousPertinentCleanerwrasse
Sorry, I'm oversimplifying our network security.
That website needs to improve its mobile design. I can't even read the gem names. [Screenshot](https://i.imgur.com/Z28FsQo.png)
We started out with `.env` files like everybody else, and then found [Chamber](https://github.com/thekompanee/chamber) a couple of years ago. Never accidentally check unencrypted secrets in again, and a joy to use.
Not the most proficient developer, but should user ‚Äúhave many‚Äù goals? So you would need to make a table for goals?
Thank you. Great feedback!. Didnt catch that 
Cool. In my experience, the user table should just have user info üëç
I have a strong interest in blockchain -- primarily ethereum. I assumed that the computational-heavy aspect of blockchains made Ruby less than ideal (and reflected in the limited Ruby support I anecdotally saw when researching ethereum). Seeing this post I must be wrong. What kind of Ruby-based blockchain projects are worth checking out?
Tip: It's easier to understand a database design if it's in ER format :)
How is Diff::LCS that high up and what happened in 03/2017 to make it jump so sharply? http://bestgems.org/gems/diff-lcs
Probably too much for a web course, but if this were production I would have a join table between users and goals/programs/whatever. Goals change, programs change, and you can have some going concurrently. Further, if someone changes his/her mind, you‚Äôll have a history of it (start/end date). 
I like mine in spoken English paragraphs. 
We run Chef so data bags for non-sensitive variables, &amp; encrypted data bags for sensitive data.
I‚Äôd imagine you‚Äôd be able to change your goal/program/etc still though right? Cause otherwise join tables are only needed for many to many relationships I believe. But a user can still modify what their goal is just by editing the foreign key, no?
Does this show anything that https://rubygems.org/stats doesn't already? Which is the source of the data, isn't it?
Of course the source of the data is rubygems. BestGems is a great service / website (Disclaimer: I'm not the developer and do not have any connection and so on) On BestGems.org you can search the stats, for example, I'm a fan of jekyll so I can search for the most downloaded jekyll gems -&lt;http://bestgems.org/search?q=jekyll&gt; and so on. You can browse historical charts etc. It's an open source website and adds value. I congratulate &lt;https://github.com/xmisao&gt; the dev from Tokyo. Cheers. Prost.
Couldn't some exercises hit multiple muscle groups? If so, maybe have the musclegroup_id (in Exercise table) to be a list of IDs? 
The blockchain is just a binary file you can process it with any language you like including ruby, of course :-). About running scripts on the blockchain (e.g. "smart contracts") - why not use ruby? About the computational-heavy stuff e.g. hashing power for the proof-of-work "magic"- it's really just a waste and works great without (see git and friends :-).
Sure, but we‚Äôre talking about the data model, not the app behavior. A goal object might have a user foreign key, and that would be fine. A goal object might then be the join between user and program. Depends how you frame it.
I spent a few years in Ruby and have been doing much more functional programming lately. Now it feels weird to be using methods on objects for things like `select`, `map`, etc
#clearNotClever
Hi any time where `j` and `current_revision.job` would not be the same? I guess if you re-assign `j`a la `j = 'hehe'` somewhere else, but maybe there's another more insidious case or something
That's a quality Martin Fowler article, and some great feedback. I'll make some changes and update the article.
Many to many table would appropriate here. 
1. I second putting this into an Entity Relationship model. I think this could/should be more complex than it currently is. 2. For a start I would subclass the exercises, including only the attributes relevant to each exercise in those subclasses. 3. On relationships that you have, perhaps I‚Äôm not understanding the real world application of the exercise programs but, I‚Äôd imagine that day-musclegroup and musclegroup-exercise could each be many to many relationships. 4. Assuming your User to Program relationship is correct, you should not have user id in the Program table. 5. What are you trying to do with goal type? It can‚Äôt be unique to each user and be a foreign key in program unless each program is unique to each user. In which case User to Program is a 1 to 1 relationship. In that scenario it‚Äôs still redundant data in one of those tables. PS it‚Äôs nearly midnight here and I‚Äôve been coding all day. Forgive me if that‚Äôs all rubbish.
Entity Relationship Diagram (ERD) pls.
It is hard to give really good feedback without understanding the application requirements. Without the requirements, you will only get very general feedback. It is hard to say if your model is too simple or too complex without that context.
You need to learn to think ruby rather than writing C in ruby. 1.upto(18) { |i| puts i if i.odd? } I am still learning ruby so I am not sure if that works but something like that should work and it looks like ruby. I came from perl5 which looks a lot like C. It has taken me a while to start thinking in ruby.
I agree with you on tte OO part. It seems to me that OO is a layer on top of procedural.
I think I was relatively close iirc. I just had some lines mixed around and some improper syntax.
I don't think you're missing anything everyone is doing, I think this is a thing everyone is solving differently, with no common best practice. 
I'd camel case my table Mrs, and looks like goal should be it's own model.
Please listen to this comment before user.rb turns into a 1,000 line God class.
I agree - what do you want to build? What is the most important feature? Start with that. For example, a lot of the schema is devoted to recording data about a program. Is this supposed to track what the user did, or is it a schedule the user is supposed to follow? - If you're tracking progress, you can focus on modelling user activity and simplify your model of what the exercise actually is - If it's more of a schedule, you can probably build something without worrying about user profiles just yet Some general things: - The way things are structured now, everything about the program is personalised (because a program belongs to a user). Is this intentional? If users create the programs themselves to suit their own needs that's fine, but if programs are intended to be shared you will end up duplicating information in a lot of places. - A unique goal type integer on the user doesn't make sense - some users will have the same one. Also, if this is supposed to be a foreign key, it means that a user *has* to have a goal, and they can only have one of them at a time. This might be a valid design decision if it's necessary for your app to work, but it's not obvious just from looking at the schema. - An exercise can be cardio or lifting, but your table allows them to be both or neither. An enum type might be better here. - Your tables are called "exercise" and "musclegroup", but if you wanted to look up a single exercise or a single muscle group, you'll get multiple results. This is a good sign that you're naming things incorrectly and/or your relationships between tables don't make sense. - What would happen if you had a program that increased the intensity of a single exercise over time? The way I understand it you'd have to create multiple musclegroup rows and multiple exercise rows, which means any information about what the exercise actually is gets duplicated. A way of solving this is to split out all the fields about the exercise itself, which don't depend on the program, from the sets/reps information, which does. This leaves you with a many to many table that joins together a program and an exercise. Each record in that table then tells you how much of an exercise to do for a particular program.
The method you're looking for is `#replace`, but because of the immutability of numbers you can't do this. You can do this on strings for example, if it's not frozen. But not `Fixnum`s.
Chamber looks very promising. Thanks!
Would integer dividing by 10 fit your needs?
I'm not sure on the requirements here, but I would probably set it up with Exercises as a table that just contains information about the exercise. You would have a separate table with muscle groups and a many to many relationship table between them (like /u/OneNeptune pointed out). Exercises_Completed would be where the information about the set/duration with a FK of Exercises. This would allow you to pre-populate all of the info for the exercises and have the user select what they were doing, or reuse exercises after they have been created. Here is what the digram wold look like: Day -&lt; Exercises_Completed &gt;- Exercises -&lt; Exercises_To_Muscle_Groups &gt;- Muscle_Groups
Beats my karma-whore reply :)
I'd recommend not mutating things for the most part. It's way easier to introduce weird bugs caused by caching, stale references and objects changing when you don't expect
It applies to everything implicit in Ruby - standalone `public/protected/private` methods visibility changes, modules including/extending, all the metaprogramming techniques esp. dynamic methods definition, method's implicit exception scope, code flow altering statements, way of constants lookup (straight vs nested), implicit return value up to ubiquitous implicit `self` itself. In other words, this way of singleton class referencing does not introduce anything extraordinary or more troublesome then already prevalent in Ruby.
Integer is kind of a special case. Ruby uses an object for each integer. There‚Äôs never multiple instances of 5, for example. If you set two different variables to 5, they will actually reference the same object because there‚Äôs only one 5 object. You can set a variable to a different integer object, but you can‚Äôt change an integer object‚Äôs value. Edit: All numbers in Ruby are immutable, not just integers.
Haha. All valid criticism. Sometimes I feel like I get stuck writing a technical post and need to just get it out the door so it doesn't die in drafts. Occasionally that results in code that needs improvements slipping into the post.
then tell me how using `class &lt;&lt; self` in class A class &lt;&lt; self def foo end end def foo end will you grep just for `foo`? Or just for `self.foo`?
`git grep "def foo"` If it comes from the same file then. ` def foo` &lt; Visually you will see that this is a class method. ` def foo` &lt; you will see that this is an instance method. So don't be a code pig and everything is crystal clear.
if this is your first time learning any programming language, I'd stick with one for a bit, I agree. 
I disagree to the general advice: there are times when immutability is a good solution. But the whole point of OOP is objects whose state changes.
Are you doing this for Spanish -&gt; English? If so, I would love to work on this with you. I started a project in Django two years ago but got lazy and I have been planning to rewrite it in Rails.
This is an interesting project. I‚Äôd be interested in helping!
I'm up for this! Love teaching, hence [this post](https://www.reddit.com/r/ruby/comments/387kaw/anyone_need_a_mentor/)
For my first go, I want to make the app for English speakers who are learning Spanish verb conjugations. I'd be down for making a version for Spanish speakers who are learning English, though. One of the main reasons that I haven't thought about it in serious is that I don't have a source of regular/irregular verbs, and all of the sentence tenses that we use. I haven't ventured into that world of resources for English learners too much. This could work! 
I'm an idiot, I meant English -&gt; Spanish. I already have multiple sources for the verbs - I already did that part in the old app, and augmented another database for another program I was working on with Spanish vocabulary.
Bahaha, no worries. I'll be honest, you had me worried there. I was like "I know I haven't done real math in a few years but dang... Have I really forgotten which way is the correct way to read an arrow? I really need to get into those remedial classes." That's so awesome that you already did that part! I've been taking and charting verbs from SpanishDict. It probably won't be in my first version but I want it to be where the person can choose what tense (or mood) they want to study, but also which verbs in said tense. I want to have "ready to go" study lists of regular and irregular verbs in each tense. And I'm probably way over my head for this part but in the future, I'd like people to be able to save lists of verbs in particular that they want to work on. That's probably something I can do way in the future. But yeah, it'll basically be what the Conjuguemos website *should've been*, and a modern-day Conjugation Nation (which is only available on iOS) for PC/online. What is your preferred method of communication? 
Yeah, that's exactly what I had done. You could choose the tenses you wanted, the verbs you wanted, the person you wanted as well, and it was all saved to your user account. I also had prepopulated verb lists from Duolingo. I have been learning Spanish for a number of years, and I have used conjuguemos (and the other conjugation sites), but I am really stubborn and I don't want to learn any continental Spanish, or focus on verbs not used in South America. I had done the backend in Django and the front end in Angular 1.x, and started on an Ionic app. I don't remember why I stopped tbh, I think I started overthinking the database schema and optimization and moved on to other projects :/. My plan was to redo this in Rails/Angular 5. I was actually thinking about redoing it very recently because I'm planning to move to a Spanish speaking country in the next two months and I need to practice again :/.
&gt; but I am really stubborn and I don't want to learn any continental Spanish, or focus on verbs not used in South America. Exactly! That's the problem with those websites like that. I mean, lucky for me I'm focusing on several dialects however those websites still aren't customize-able enough. They just give you these random verbs (irregular often mixed with regular), you don't even get to pick the pronouns (like no vos or vosotros, or sometimes I just wanted to focus on third person pronouns), and that's that. I was glued to the Conjugation Nation app and am glad that I had it but my iOS device is super old now and it sucks to still be forced to use it because there's nothing similar on any other platform. That was when I learned I shouldn't just sit and wait for it to be done, so here I am today, haha. ___________________ I didn't understand much of the rest of your comment but I suppose that's because I'm a newbie. I'm still learning the lingo and what the actual differences between the popular frameworks are. I'll be darned if I don't learn, though! I will figure this out. 
You can contact me on WhatsApp or skype I guess? Pm me your username
You can come hang out on the DevDungeon.com Discord server and there are plenty of people who will help https://discord.gg/JWsSHJC
The Logging gem [has a handful](https://github.com/TwP/logging/wiki/3rd-Party-Extensions) of 3rd party appenders. 
Well, you have to keep in mind that using object-oriented design does not imply that you have to mutate your object state. Just look at React, Redux and stuff like that. The state changes, yet never mutates. If your state has an array or a hash, it's generally better to treat them as if they were immutable. A simple example: `foo = [*foo, 1]` is not the same as `foo &lt;&lt; 1`. The first snippet does not mutate `foo`, while the last one does.
If you guys are open sourcing this, I would love to help out. 
&gt; Well, you have to keep in mind that using object-oriented design does not imply that you have to mutate your object state. You might notice that there is no contradiction to what I wrote. &gt; Just look at React, Redux and stuff like that. The state changes, yet never mutates. As I said, there are use cases for immutability. Whether it is wise design in these cases I cannot judge on due to lack of insight into these. &gt; If your state has an array or a hash, it's generally better to treat them as if they were immutable. No, not "generally" - definitively not! &gt; A simple example: foo = [*foo, 1] is not the same as foo &lt;&lt; 1. The first snippet does not mutate foo, while the last one does. I think we can assume that everybody here in the discussion is aware what "mutable" means. But let's look at this more closely. Assume @foo is actually a member of an object representing a larger data structure. Now, you haven't changed the Array that @foo pointed to initially but you have change the state ("mutated") of the object owning @foo. If you do not want that you will have to clone the whole object tree that ultimately owns @foo and just exchange this single reference. You can imagine what this does to memory usage and GC - apart from the practical consequences of implementing this. Frankly, immutability seems to have become some kind of hype. While it has interesting properties everything comes at a cost - and to pay that cost is not always wise. That's why advice like "generally do this" are often questionable.
I totally agree with you, except for the "generally" part. Just wanted to discuss why the "avoid mutations at least you really need it" behavior is questionable. I think I get your point. Thank you for the explanation!
Congrats on your Aliyah.
That's right, we've mentioned some, but feel free to add your own recommendations, and I'll add it to the post if you'd agree.
Sorry to say, but I haven't completed it. Two days ago I have heard about it for the very first time - and now I'm collecting information.
PM me.
&gt; standalone public/protected/private methods visibility changes Don't use them. In the rare case that I would, there wouldn't be more than one in a class. &gt; modules including/extending Not related, really. `include SomeModule` tells me explicitly that additional behaviors have been added to the class. And inherited methods are also instance methods, they have the same receiver. `def self.some_method` signals to me that the _receiver_ of the method is unusual, i.e. it's the class, not the instance. &gt; all the metaprogramming techniques esp. dynamic methods definition, method's implicit exception scope, code flow altering statements, way of constants lookup (straight vs nested), implicit return value up to ubiquitous implicit self itself Those are all language features that bestow benefits by their usage. `class &lt;&lt; self` does not; therefore, the "scan-ability" is the only remaining consideration.
This sounds vaguely interesting but I would want more examples for why I want to monitor my data this way.
Good feedback! I built this to scratch an itch I had. A few times per year, a production deploy might go out and break one of my applications in a way that isn't immediately obvious. Perhaps it's untested JavaScript, or a job that fails to queue, or a validation that proves to be a little too strict. It might even be a deliberate change -- a signup flow that slashes conversion rates. I tend to find these issues after a few days, but that's a few days of poor UX/lost sales/missing data. Meerstats watches your data and notifies you as soon as it notices your KPI's change abruptly. Additionally, you receive a daily report so you can spot check all of your KPIs yourself. I'm not very skilled at copywriting, but hopefully that provides you with the angle I'm going for. I'll take another stab at the homepage copy as well.
Won't this spawn two Sidekiq processes, one for each puma worker process? workers ENV.fetch("WEB_CONCURRENCY") { 2 } on_worker_boot do @sidekiq_pid ||= spawn('bundle exec sidekiq -c 2 -t 25') end I'd argue that if you are using a free tier, you should use ActiveJob's :async in-memory adapter which will keep your system simpler and more reliable. Your system will fail silently if Sidekiq crashes, for instance.
It would help if you could post what you have.
For a hobby project, this may be fine, but in any production environment, I prefer to keep my app and worker instances separated. If the worker has a memory leak and the worker is on the same instance as the app, it could cause the app to crash. Especially since a lot of hosted VMs or PaaS solutions has swap disabled. Jobs will still be queued in Redis (which should be set to nonvolatile memory, which would prevent jobs from getting purged from lack of memory resources), and proper monitoring should exist to notify you of memory usage. Monit can be used to monitor the sidekiq process and restart the service if it crashes. This will give you an opportunity to address the issues without the app crashing.
This will be nice to have for the lazy developer that recurses through a directory and forgets about `.` and `..`
If I'm not mistaken, Heroku allows one worker dyno per free plan, so you can run Sidekiq and still not pay for it :)
Need to explain more of what you looking to pass, but you can always find ways to pass stuff (without global or instance variables). Code can be broken up in Sinatra, just make sure to use 'include' or require. Also you might want to consider making the app in the 'module' style. See Sinatrarb for further info. 
I typically separate my code into classes which each have their own file and I have a requires files that includes everything. You can do some magic on which files to include like rails does, but I typically just add entries to the file instead. Then I include the requires file in app.rb. When I have background work, I add it to a redis queue and have sidekiq perform it. My background processor may have a different requires file (thus the reason to avoid splat magic). The redis queue. You should store your data in a database, and logic in your code. You should not rely on variable state.
What I'm most interested in is a discussion of the various approaches to modelling a domain in Ruby when using a distributed and implicitly asynchronous pub/sub message stream. And seeing a useful and persistent system emerge from the composition of objects in that context. (top tip, things to avoid: being a showcase for someone's gem) 
Since you are talking about background work, I suppose you might need a background job processing tool. Take a look at [Sidekiq](https://github.com/mperham/sidekiq). Sidekiq made some of the design decisions for you. If you're not much into Sidekiq and want to implement something yourself, what you need is [message passing](https://en.wikipedia.org/wiki/Message_passing). Basically, you need to run at least two processes: a server and a worker. A server pushes the task to some message queue (Zero MQ, Rabbit MQ; you can also use Redis for the task). Worker then executes the tasks and writes the response to the queue (the database), so your server can run a query to find out if the task has been finished. The thing is, no variables are affected since the applications run independently. You just pass all the necessary data along with the messages. Simple as that! The pattern is pretty common, so you should probably try this out. It works! There is a great book on the concurrency models called [Seven Concurrency Models in Seven Weeks](https://pragprog.com/book/pb7con/seven-concurrency-models-in-seven-weeks). You should totally check it out!
The point is, it's not fundamentally any more secure than secrets committed into git on a "private" third-party repository, in each case you have most of the same threats: network security, application security, access control, client security. You just shove a little bit of application level liability to the network. A developer having all of a production application's security capabilities sitting on his laptop, readable to any malware he might acquire, 24x7, because they engage in development activity which does not require those credentials is plain and simple a violation of the principle of least privilege. Of course that might get deflected by some argument of what's theoretical vs. what is practical but it's perfectly practical to hire and fire people -- not quite as practical to rotate and revoke all your capabilities each time, and it's frequently practical to hire a third party and provide repository access for say a white-box pentest or dev work and not quite as practical to acquire the level of trust your customer (internal or external) should require of those parties given the weight of what they gain access to as a consequence.
Thank you for sharing this, I have a very similar task and knowing these caveats was really helpful
I understand what you're implying but I'd suggest a different phrasing. Perhaps, "state mutation is not a violation of OO principles, and immutable objects are not idiomatic Ruby". I say that because mutability is almost completely orthogonal to OO. You send a message to an object telling it to do a thing; it's none of your business whether the object mutates its own data or not, *even if it appears to do so*. One commonly encountered example is the ActiveRecord model. AR attributes are not implemented as object instance variables. The attribute getters &amp; setters, and the persistence methods, all do their work at a distance by sending messages to other objects. The model object itself is a facade. Ruby is weak when it comes to immutability, so as much as I admire languages (particularly FP languages) where immutability is a treasured concept, Ruby isn't one of them. I'd love to have a OO+FP language where immutability was both essential and easy to work with. It'd probably need some expressive way to handle value-at-time and side-effects. The answer isn't Clojure or Haskell, although those are both interesting ;) 
Seems like an interesting little idea/experiment, but to be honest wouldn't this be pretty trivial to recreate with a daily cron job and a few SQL queries? I think you'll need something *much* more substantial to make this a viable business model, so I'd be interested to know what direction(s) you plan to take this?
I've generally found that havingo everything be immutable and choosing to make something mutable is better than the inverse. In this case, where the OP is trying to mutate an integer I think staying as immutable is by far the better choice.
I disagree with this bit: &gt; Secondly, we don‚Äôt want to stick to exact names in our specs: we want to test a general logic. That seems like the wrong thing to test. The Rack::Rewrite gem presumably already has tests (I imagine you do a brief audit of any production dependencies you bring in to ensure that's the case). Therefore, its rewriting (the general logic) is already under test. What's left in your app is your configuration and app-specific usage of the gem - you want something more like an integration test of the configuration, rather than a unit test of the rewriting capability. 
I agree, but I wanted to launch as soon as possible with the minimum amount I thought people would find useful. Ultimately the users will be driving product development, but I do have a notebook full of ideas for where it could go. For example: - Third-party statistics (SendGrid/GitHub/Honeybadger/Stripe/etc) - Notifications via SMS/Slack/webhooks - Derived statistics
Have you considered cobbling together a proof of concept? In my experience, it's been one of the best ways to explore unfamiliar approaches.
Since you have Ruby experience *and* enough Rails experience to see that the two are not synonymous, I'll repost [the list I posted a few months ago](https://www.reddit.com/r/rails/comments/5tw9gt/what_are_some_recommended_books_to_learn_ruby_for/ddpvsia/). A couple of people argued that the earlier post wasn't appropriate for people new to Ruby. (Thanks, /u/jujubean67 and /u/fantasticoranges!) I'd agree that *GRAAP* and *Eloquent Ruby* probably aren't the best hello-world books, but it doesn't sound like you're in that category. Hope these help. (previous reply's content follows) ---- My recommended list for folks new to Ruby and/or Rails: * [*Principles of Object-Oriented Design in Ruby*](http://www.poodr.com) (POODR), by Sandi Metz; * [*Clean Ruby*](http://clean-ruby.com), by Jim Gay; * [*Eloquent Ruby*](http://eloquentruby.com), by Russ Olsen; and * [*Growing Rails Applications in Practice*](https://pragprog.com/book/d-kegrap/growing-rails-applications-in-practice), by Koch and Eisenbarth. Somewhat "off topic" until you read them * [*Growing Object-Oriented Software, Guided by Tests*](http://www.growing-object-oriented-software.com), by Freeman and Pryce; * [*Working Effectively with Legacy Code*](http://www.informit.com/store/working-effectively-with-legacy-code-9780131177055), by Michael Feathers Each of these are books that I reference and re-read regularly. **Above all,** don't get sucked into the mental vapour-lock that *Ruby* and *Rails* are in any way synonymous. There are at least a dozen perfectly useable, well-architected Web application frameworks out there that have learned from many of the mistakes that Rails is locked into courtesy of its installed base. The ones I've been using and recommending lately are [Roda](http://roda.jeremyevans.net) and [Hanami](http://hanamirb.org).
Thank you for pointing that out. You are right. I opted for Sidekiq as a background job processing library coz I wanted my jobs not to get lost in case of restart or something. Also, this is just an experimental project to learn a few things here and there. And your comment taught me a new thing. P.S: Big thank you for giving us Sidekiq. 
That's a valid point. I just added a note to the post not recommending this setup for production apps. You got my attention to the memory leakage part. I will now go ahead and add NewRelic for some monitoring to keep a watch on the performance. 
&gt; you want something more like an integration test of the configuration, rather than a unit test of the rewriting capability That's exactly what we do ‚Äì integration testing (RSpec request specs). We test our rewrite/redirect rules, we're not testing `rack-rewrite` itself. But we don't to use our production hostnames (actually, they are dynamic), it doesn't matter whether we want rewrite routes from `A` to `B` or from `X` to `Y`. I guess, you don't use your production credentials (e.g. AWS, API keys, etc) in your tests, right? That's the same thing. There is one part of our testing scheme is missing in the article (not enough space)‚Äì_black-box_ testing (or it's better to say verification) against production server by invoking real HTTP requests (i.e. emulating third-party calls). A bit belt-and-braces.
Is this rspec or how to hack around in rails?
Well the subject is really complex and it requires a lot of architectural background, that's why this is going to be a series, not a single article. I'll get there ;)
Is it me or it sounds amazing ? All of these looks like useful right away for production apps
This is a big advantage of using a mature framework. 
Good points! &gt; I say that because mutability is almost completely orthogonal to OO. The "almost" is important: usually object identity plays a certain role in OO contexts. If it wouldn't we would not be talking about mutations because we would not know what mutated. :-) &gt; You send a message to an object telling it to do a thing; it's none of your business whether the object mutates its own data or not, even if it appears to do so. Well, when we talk about changed state we should probably more precisely talk about *observed* changed state. This fits nicely with ADT model, where state representation is out of scope but you can model observed changes in state (e.g. we define that length(list.append(item)) equals length(list) + 1). Or put differently, usually in OO there are methods which change the return value of others. As much as I agree that a language with all immutable objects has some attractive properties the Achilles heel is always garbage collection: if you just update a memory location there is no garbage to collect, but as soon as you create a new instance as effect of every change operation you get loads of garbage that have a price tag. Fortunately GC has seen dramatic improvements over the years, especially in the JVM, and CPUs are becoming faster (and more) all the time. So eventually we might not be far away from a point in time where the additional price tag of GC in an all immutable language does not hurt any more. PS: Why are Elixir, Clojure and Haskell not an answer in your opinion?
It sounds like ActiveStorage is actually tied to ImageMagick via MiniMagick? I've switched to `vips` instead of imagemagick for most of my image transformation needs. It has incredible performance characteristics compared to IM. I typically just use it through a command line shell out (which is what minimagick is doing too), but there's also ruby-vips for actual direct C library use. 
Using Ruby to solve real first world problems. Love it! :)
Did you run the command it told you to run? It gives you the solution right in the listing. When you get errors, you need to read them. 
From a convention over configuration standpoint, I'd imagine the vast majority of users will use mini_magick, what I assume, is a more mature and battle proven library. However, this sounds like an opportunity for a PR to abstract out the image resizing library to make it configurable. 
The idea of "convention _over_ configuration" means configuration is still possible. I think the API for expressing transformations is written _in terms of_ minimagick API, making it hard to abstract without breaking it. I suspect vips is going to be getting more and more popular, and is the future. My impression is over the past couple years it's gotten mature enough to do most everything IM does, and it generally does it a lot better. Plus the release of a new version of ruby-vips making it possible to actually use it as a library rather than a shell-out (which is theoretically possible with IM, but everyone seems to have switched to MiniMagick instead, which does a shell out). 
&gt; The ideal of "convention over configuration" means configuration is still possible. You have to start somewhere. If every feature were configurable from the get-go, releases would never happen. Also, maybe there hasn't been any expressed demand yet? How about a PR to show your desire here?
Sandi couldn't think of any open source projects off the top of her head, most were behind firewalls. But she recommended check out projects with high scores at codeclimete: https://codeclimate.com/oss.
Here you go :D [Three Days with Sandi Metz on Practical Object-Oriented Design ](http://www.sihui.io/sandi-metz-pood/)
Like I said, it would probably require some tricky backwards-incompat changes to the API, since the top-level API seems to be written _in terms of_ MiniMagick api, rather than abstract image transformations. Which, sure, is probably why they didn't do it. Where does this idea come from that one isn't allowed to point out flaws/challenges without a PR? Perhaps my pointing it out will encourage someone else to PR. Perhaps I'll do a PR eventually. Or perhaps I'll just keep using shrine. Perhaps my pointing it out will encourage someone else to try shrine instead of waiting for ActiveStorage. Or perhaps my pointing it out will just encourage someone to keep telling me I should write a PR, which is an even more useless communication than me pointing it out! 
Thanks for the review.
It's mostly RSpec with Rails, but the focus is on learning and practicing Test Driven Development for unit testing and acceptance testing.
thanks!
Whoa, I obviously put you on the defensive. I apologize, that wasn't my intention. You're 100% right on the above points. Building things which others utilize isn't easy. It's hard to get right, when you know what users want, and even harder if you don't know what others need and want. I'm sure this is something you want to see improved (as opposed to just making noise, creating FUD). I don't know if DHH or George Claghorn(authors) hang out on this subreddit, but I doubt it. I was merely surfacing an avenue to improve ActiveStorage as this seems like you were making a valid point. 
Great update. Thanks to everyone working on this. &gt; Note also that this is likely to be the last ‚Äúminor‚Äù (pretty major for a minor, if you ask me!) release of the 5-series. Our next target will be Rails 6.0! What's planned for Rails 6.0? :)
That last sentence isn't true. The point of data structures in an OOP language is to hold state that can change, but data structures are just one style of object. The point of OOP is objects sending each other messages -- tell, don't ask. Meaning, any state held by an object should not accessed by any other collaborating objects.
I'm really interested in taking one of Sandi's courses. If you don't mind me asking how much did it cost &amp; approx how many people in the class? I was wondering about seeing if some uk rubyists would be interested in splitting the costs (if Sandi would be interested in running a course in England that is).
Our class size was 30. The full price was 2.2k. There was an early bird discount. I don't remember how much was it, but you can find out in Sandi's old tweets. From the [course website](https://www.sandimetz.com/work-with-me): &gt;Courses are so hands-on that I bring a second instructor to classes of more than 12 students. I prefer to limit total class size to about 18 but in special circumstances have taught groups as large as 30. Startups and small companies are welcome to combine forces to make up a single class.
The number one thing I've learned from Sandi was design around behavior, not data, and leverage Structs to achieve that. --- If data exists in an array: border_data = [1,2,3,4] Create a struct to make it self documenting and dry: BorderObject = Struct.new( :top, :right, :bottom, :left ) Use the splat operator (\*) to convert the array to your new Struct object: my_border = BorderObject.new( *border_data ) Then referencing the attributes with normal english, instead of by hard-coded magic-number indices my_border.top =&gt; 1 my_border.bottom =&gt; 3
Thanks for the info - much appreciated.
[removed]
yeah, we spent almost an hour in class along the line of "data vs object" and "there is no pure data"
Have you had a chance to read the book?
Also, there's a uncommon syntactic shortcut for `#call` using `.()`: class SayHello def call(name) "Hello, #{name}!" end end h = Hello.new h.('world') # =&gt; "Hello, world!" 
Ruby has too much syntatic sugar. 
https://www.istocknow.com/
I've got POODR but didn't get into it at the time, however I absolutely loved 99 Bottles (and pretty much all of Sandi's talks). Thanks for the reminder though, I'll pull it back off the shelf and give it a proper read :)
&gt; data structures are just one style of object What are the other "styles"? Especially, what are objects which do not have observable state? Put differently: I think there distinction between objects based on the complexity of internal state (if I get your drift properly) is moot. A Fixnum has a number of methods that return various different observable states (#odd?, #even?, #size, #[] etc.) even though the internal representation (or structure) is fairly simple. &gt; Meaning, any state held by an object should not accessed by any other collaborating objects. That is an odd statement. It is true, if you refer to the actual *representation* of state. It is wrong, of course, if you refer to the *observed* state, because then state would not make any sense and all objects would be equivalent.
Do you know why this was chosen over simply making `()` the syntactic sugar for `#call` like Python's `__call__`? Using a dot in between seems a bit odd to me.
Were you not using objects at all before you learned this?
I enjoyed this a lot. This is the kind of stuff that makes me love coding. Enjoy your new iPhone X :)
h(123) is equivalent to h.send(123) h() is equivalent to h.send() h.(123) is equivalent to h.call(123) h.() is equivalent to h.call() Ruby #send is different than #call #send - sends a message #call - calls a block
&gt; h(123) is equivalent to h.send(123) That doesn't seem right. `h.foo(x)` is equivalent to `h.send('foo', x)`.
ah sorry my bad, my bad, yes you right I just wanted to show that it's h.() and it's not h() because it's pretty much same ass h.method() 
Unfortunately, that won't work either. Defining/overriding `#send` in a class does not make the instance 'callable' (i.e. `h(123)` raises `undefined method 'h'`).
ActiveStorage is NIH. I don't know how easy would it be to pull an ActiveJob and wrap already existing solutions, yet here we are, and will be, talking about stuff already supported somewhere else. shrine already supports a vips backend, right? 
&gt; h.(123) is equivalent to h.send(123) # correct h.() is equivalent to h.send() #correct Sorry, that's still not correct. Here's how it works in Ruby: `h.(x)` &lt;-&gt; `h.call(x)` &lt;-&gt; `h.send('call', x)` and `h.()` &lt;-&gt; `h.call()` &lt;-&gt; `h.send('call')`
Ok my point was just that it cannot be `h()` because object expects `.` before chain to another caller (method `()`) =&gt; `h.()` But now that I'm thinking about it this may be wrong too. It seems that `()` is not a method alias: h = -&gt;() { } h.send(:call) # =&gt; nil h.send(:'()') NoMethodError: undefined method `()' for &lt;Proc:0x0000000113e038@(irb): not even: :'()'.to_proc.call(h) NoMethodError: undefined method `()' But it's strange as it's not Ruby literal too * https://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Literals * https://ruby-doc.org/core-2.3.0/doc/syntax/literals_rdoc.html (`.()` is not listed) So, **what sorcery is this** ? If it was Ruby literal then it would be possible to have `h()` and `h.()` and it would be purely a lang design choice. But if `()` was a method alias it has to be `h.()` 
sorry, my bad, I've realized it too late :( Fixed now, thank you for feedback
Wow, $40k for 3 days work seems like a pretty sweet gig.
Shrine supports whatever you want, you just write your own transformations. 
&gt; shrine already supports a vips backend, right? Almost ‚Äì https://github.com/janko-m/image_processing/pull/14 :) What's nice is that ImageProcessing is a generic gem ‚Äì it's just a collection of image processing macros (methods) ‚Äì so it could theoretically be reused in ActiveStorage. I think that would make sense, because image processing has been reimplemented enough times ([Paperclip](https://github.com/thoughtbot/paperclip/blob/7edb35a2a9a80c9598dfde235c7e593c023fc914/lib/paperclip/thumbnail.rb) and [CarrierWave](https://github.com/carrierwaveuploader/carrierwave/blob/1547673a11a6646c401f800d832b6b7c31bce26d/lib/carrierwave/processing/mini_magick.rb) both have their own, Refile's one I [extracted](https://github.com/refile/refile-mini_magick/pull/13)). That way some common rookie mistakes would be avoided, like [loading the whole image into memory](https://github.com/rails/rails/blob/527ad1a32c2baf2a78c73104ac8aa52b39514f1f/activestorage/app/models/active_storage/variant.rb#L84).
Of course, but we found areas where arrays were being passed around and worked to clean them up. These types of code smells start when someone takes a shortcut thinking "this will never need to change", but then something downstream builds on it, and then it snowballs.
&gt; So for symmetry delete_suffix was added This is the most annoying part of Ruby for me: All those aliases ! It seems to me that no one designed the library; instead, it just grew like weed in my garden
This seems like some hipster methods. What was the problem with String#[] ?
&gt; The number one thing I've learned from Sandi was design around behavior, not data This part is entirely correct, but I've got an issue with `my_border.top` and `my_border.bottom` -- they're _still_ designing around data. `#top` isn't _behavior_, it's _data_. It's an "ask," not a "tell," which is usually a signal that object orientation is not happening. An example of behavior: `my_border.move_right(11)`. We "tell" the border to move itself right by 11 units. Here's another example: `my_border.contains?(thing)`. This is an "ask," technically, which might seem like a violation of "tell, don't ask." However, it's the kind of ask that is still object oriented. In this case, the data of the object is encapsulated behind an interface that's operating at a higher level of abstraction, enabling if statements to bind against an interface instead of a data contract. In my experience a lot of rubyists don't realize that spending years in rails, with ActiveRecord objects (data structures) freely exposing their data everywhere, leads to serious subconscious biases that impair OOP design. They're used to thinking in terms of the underlying data model, and assuming that the rest of the system will freely couple to it. The inevitable consequence is extremely limited comfort levels around designing message-passing interfaces, which utterly ignore the data _behind_ the interface.
Ignoring my particular example, Structs have value at the absolute most basic part of your code, if they were any more complicated chances are you'd want to elevate it to model for better modularity, they're simply in place of shuffling data around with magic-number references. Where this pattern is leveraged is at the next level, functions that can reference attributes over array indices: @borders = borderify( data ) def horizontal_impact borders.collect { |border| border.left + border.right } end This is covered in the book *Practical Object-Oriented Design in Ruby*, I should have just used her examples tbh, she uses wheels and diameters of rims vs tires. 
Yes, I'll agree completely. As far as data access goes, `border.left` is a better design than `border[0]`. I was just pointing out that the chief benefits that OOP brings have little to do with moving from raw primitives to data structure objects.
`def self.bark` defines the method on the *class Dog itself*, where as `def bark` defines it on *an instance* of Dog: class Dog def self.bark puts "woof" end end Dog.bark vs class Dog def bark puts "woof" end end rover = Dog.new rover.bark 
nice!
it don't read good
In your example, nothing. Using `self.bark` is explicitly calling it on self, where `bark` implicitly calls it on self. If it were defined as a class method as in /u/fiiiiiine's example, you'd call it from the context of an instance using `self.class.bark` 
In practice, nothing. the `self` in the second example is implicit. In some cases, there is a slight difference. In the first example, ruby will call the method `bark` immediately, since by using `self.` it knows to look for a method. In the second method, it will first look for a local variable `bark`, and failing to find one, will then look for a method. When using assignments, it's important to remember to use (or not) `self.foo = bar` vs `foo = bar` The difference here is `self.foo = bar` attempts to call an assignment method where `foo = bar` assigns a local variable. 
in this example, OP is not talking about class methods vs instance methods
Ah okay thanks. That makes sense.
Awesome Video ! really helpful 
That holds for both the language and the standard library. There‚Äôs no specification, it‚Äôs whatever brain fart Mats (well the core team but mostly Mats) has next. This is what Ruby people call ‚Äòdeveloper happiness‚Äô :)
I think you must first understand the difference between an instance method and a class method. http://culttt.com/2015/06/10/understanding-class-methods-verses-instance-methods-in-ruby/
Another excellent article.
As far as I can tell, we need dots in Ruby before invoking any methods because Ruby's design followed the "Lisp-2" approach, which provides different namespaces for functions and values. See http://ergoemacs.org/emacs/lisp1_vs_lisp2.html for a pretty clear explanation, with Ruby examples. And for more on the Lisp-1 vs Lisp-2 difference: https://hornbeck.wordpress.com/2009/07/05/lisp-1-vs-lisp-2/
...but there are no class methods in this example.
wow, that's great news! &gt; it could theoretically be reused in ActiveStorage. will it though? :) Pragmatically speaking, I think I'm gonna keep using shrine. I prefer the opt-in plugin system instead of the opt-ut rails model, even if it requires a bit more boilerplate in the end. Much more memory efficient and boot time friendly. Also, it supports more features (for now, I predict more feature parity in the future, as rails receives more attention and contributions than other ruby libraries). 
`Model` is also defined as a method on the `Trailblazer::Operation`class. Check out line 2 in the link you posted.
Meh
Apparently the technique Schneems uses (to select for the highest id so far and use client side code to pick a random number between 1 and that number and query again) wouldn't work well for non-incremental IDs. I can see why... I wonder if what would work well for this use case would be to maintain a data structure in memory in the client with all of the ids. Perhaps it would be loaded into memory at startup and then inserted into as more inserts happen. Then, this would be sampled for the random ID. I wonder if this would use too much memory to be feasible.
This is the reason it works better with ids that are closer together: Imagine the scenario where there are 1000 records and the first 999 have ids from 1 to 999 and the last one has an I‚Äôd of 10,000. If we randomly pick a number between 1 and 10,000 and grab the next largest integer then we will pick 10,000 nine times out of ten which isn‚Äôt very random. This is an extreme case but demonstrates potential problems. If you‚Äôre fine skewing your ‚Äúrandom‚Äù values to higher ids then you can still use that technique, but be aware of the implications. And...After typing that I read you understood why already. I think having all the ids in memory isn‚Äôt a great tradeoff unless your table you are randomizing is pretty small. One other option I didn‚Äôt mention is to use random() and select a batch of ids (maybe 100) and then every time you need a random record pop one off. When you run out of random ids then make another query with random(). You‚Äôre still hitting the ‚Äúrandom‚Äù tax, but only once every 100 queries instead of every time. 
Ah, that last option is clever! There's no reason you couldn't take even 1000 every time, 1000 integers or even uuids in memory is pretty cheap. 
It‚Äôs not an alias. 
Thanks for the extra detail in the first paragraph, that was actually something else I hadn't thought of. But actually what I was getting at was IDs like those generated by MongoDB clients. 78627gf2-2378b273d-23d7h etc. Kinda hard to randomly sample for an id like that. xD
It's like Integer() method defined at Kernel A method can have the same name as a Class, but the method does NOT equal that class (if it exists)
If you choose to use fetch, then use the block form, not the default value form. Do this: `fetch(key) {| key | block } ‚Üí obj` Not this: `fetch(key [, default] ) ‚Üí obj` 
To add an example to those comments, [dry-monads](https://github.com/dry-rb/dry-monads/blob/master/lib/dry/monads/maybe.rb#L161-L191) source clearly shows what previous commenters said.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [dry-rb/dry-monads/.../**maybe.rb#L161-L191** (master ‚Üí 12c9d7f)](https://github.com/dry-rb/dry-monads/blob/12c9d7fd332ce1acb177c7a8494b107c36b28265/lib/dry/monads/maybe.rb#L161-L191) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
lets say you have variable `a` which is a Hash. The problem is that by using `a['key']` you assume that `a` is always a Hash. Unfortunately due to the bugs and other unexpected situations `a` might not always be a Hash. Very hard to debug problem could happen when `a` will be a String. ``` &gt; a = {'key' =&gt; 'random text'} &gt; a['key'] =&gt; "random text" &gt; b = 'stringkey' &gt; b['key'] =&gt; "key" &gt; b = 'stringkey' &gt; b.fetch('key') =&gt; NoMethodError: undefined method `fetch' for "stringkey":String ``` Because it is not always easy to find the problem with `b['key']` - most probably error you will get will happen further down in a stack in the place unrelated to b not being the right value in a first place - I always use `fetch` when I want to access a Hash.