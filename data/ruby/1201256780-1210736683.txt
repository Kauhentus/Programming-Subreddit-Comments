great!
This works for me as the first thing I usually do on reddit/programming is scan for Ruby articles. 
I agree with jeem (in the comments): &gt; Fun post, with some good points, &gt; but short names are not a part of DRY, so the "C", "i", etc., are a strawman. 
Did it really take 600 lines of code to build Ta-da List? I'm not very impressed...
Why? You think it should have been less?
It might be nice to find Ruby articles on Reddit, while also being able to have intelligent discussion on the articles without the usual, "ruby sux0rz it so sloooooooooooo!!11!11". 
How do I add it to "My reddits" ?
Version 0.01 of [glTail](http://www.fudgie.org) - a Ruby OpenGL logfile visualizer - came in at 609 lines of code, but I think my initial working prototype was ~300 lines.
And a click away: http://www.indeed.com/jobtrends?q=ruby%2C+java
Sure, when a [full-blown wiki](http://redhanded.hobix.com/bits/batsmansFiveLineWiki.html) can be written in 5 ;)
think of it as an investment, which one would you buy?
Yes ! It took a while but the following, added to config/environment.rb works for me: ActionMailer::Base.smtp_settings = { :address =&gt; 'localhost', :port =&gt; '25', :domain =&gt; 'your-domain-name.com', :user_name =&gt; 'You@your-domain-name.com', :password =&gt; 'your-email-password', :authentication =&gt; :login} ActionMailer::Base.delivery_method = :smtp # ActionMailer::Base.raise_delivery_errors = true 
where it says "other reddits" hit "more", then navigate thru the pages until you reach "ruby reddit", and then click the checkbox
This title is misleading; Thin doesn't come with a load balancer, it just allows you to couple it with your load balancer more closely now. Rather than going back through the request-response process, you can specify Thin using sockets (in your Nginx config, for example). For anyone who reads the article, this will make sense, but when initially seeing this title, one might be lead to think that Thin can be used as both app server and web server/load balancer, which is not the case.
A seasoned investor's answer would differ depending on if the investment were short-term or long-term.
which one is which? java short term and ruby long term? http://www.indeed.com/jobtrends?q=ruby%2C+java%2C+python%2C+rails%2C+php&amp;relative=1
Agreed the title is misleading. The article is worth reading so upmodded nevertheless.
http://rubyforge.org/projects/grism/
Although I think there are a few other spreadsheet/Excel gems, it's nice to see one that is currently being developed. It would be nice to have the ability to write and Excel spreadsheet, but I understand that's a bit more difficult to do. 
e.g. http://jamesgolick.com/2008/1/25/ruby-reddit http://weblog.raganwald.com/2008/01/rubyredditcom.html
I'm seeing a lot of Rails articles... should rails have its own sub-reddit so that it doesn't overwhelm the ruby reddit?
Do we need ruby.reddit.com?
My personal opinion is no. True, there is the issue of front page real estate. But there is also the issue of the comment threads. The "Ruby" community is arguably a superset of the "Rails" community, therefore you are probably going to find that having both in one place adds value to the comments. Whereas, a 'webprogramming" reddit ought to be separate because the "Rails has too much magic" posts would drive all rubyists insane even if they don't do a lot of rails work :-)
Agreed.
I could see the demand for it later, but so far the Rails articles have been pretty good.
It's on Ruby Inside, so that's about as many people in the Ruby community you can hit at one time. Luckily it seems to have paid off!
[True](http://www.rubyinside.com/ruby-gets-its-own-reddit-702.html)! But I still urge folks to blog. It's like anything else, sometimes it takes a few "impressions" before someone clicks through and decides to participate. Maybe they'll see it on your blog and think _Oh yeah, I remember hearing about that, I'll give it a try_ :-)
Matz blogged about it too! http://www.rubyist.net/~matz/20080126.html
Who? Has he written any Rails apps? 'cause if not... how much can he know about Ruby??? [;-)](http://weblog.raganwald.com/2007/01/where-were-you-on-saturday-november-9.html"Where were you on Saturday, November 9, 2002?")
/* Unrelated */ Your book, The Rails Way, rocks Obie. Thanks.
Compile it with: ragel -R example.rl | rlgen-ruby -o example.rb
Uses Rails 2.0, and Amazon s3 to store the photos. Makes it easy to move stuff around and to scale. We're trying to come up with interesting and less-obvious photo contest themes.
I'm actually not sure - some japanese dude. I hear he's like DHH's assistant or something? ;)
Why isn't a ruby reddit written in ruby? I looked for a reddit/digg clone a little while ago and the best one was pligg which is written in PHP. There were a couple of half started projects in ruby but nothing finished. 
You know what would be nice? if the RUBY reddit was named just "Ruby" Not fucking "Reddit for Ruby Hackers" Don't you think people here on reddit are smart enough to fucking figure out that something named "Ruby" on custom reddits is a "reddit for ruby people" Jesus Titty Fucking Christ! - Added to /r/WTF!
Well, that certainly illustrates the many uses of the word and its forms. Thank you.
+1
So _that's_ why I can't understand anything he writes. I figured it was some kind of notation for monads.
I guess we have to wait till version FIVE BAJILLION before we get a simple NEXT/PREV functionality in the "Browse" mode? Perhaps this also belongs in /r/WTF ?
Wow! something actually useful! I think I just came! UPVOTED!!!
If the time that you saved writing significantly shorter but more obtuse code is then lost when trying to read that code later (or someone else trying to read the code), then you didn't save any time. 
jaanix is using ruby on rails, has a lot of ruby and rails links too.
I'm happy to point my three or four readers here. I have some reservations about fragmenting proggit, but those would be allayed if we got our own alien!
Damn -- they scooped me! I was working on a pertified Ruby wrapper for [Apache Poi](http://poi.apache.org/). I wonder if they've looked into this for writing Excel. The downside is that it becomes JRuby only.
Oh yeah, I don't disagree. Even if a lot of people see it, if they see it in more places it'll reinforce that they should give it a go :)
Is the source available?
I'd say no. It's not like the ruby subreddit is flooded with posts. 
+1
&gt; It's always time for Lisp. --MenTaLguY
Hmmm, I would say most interesting. Probably more interesting than the top 10 list that I found and posted to ruby.reddit. I was hoping I could foster more discussion in the comments, as that seems to be lacking in this sub-reddit so far. I'd argue the 'most useful' bit. :-)
Love it! 
Wow, I should have thought of this before. I'd return self in each method so you can chain them like this: User.find_by_login('ov').if_not_nil{ |u| puts u.login }.if_nil{ puts 'user not found' }
not yet
:(
too bad scruffy has stopped in time. it can't even do pie charts. we're far from a decent graph library.
What's this obsession with being the next lisp anyway? Ruby is ruby. It's more popular then lisp, it's got a bigger library, it's got more tools, better IDEs, more and better frameworks, and it's more accessible to the vast majority of programmers. LISP has had fifty years to become useful and it hasn't managed it. 
I doubt that's even close to accurate. There's no way they're only charging $80-90 per developer hour,
 User.find_by_login('ov').if_not_nil{ |u| puts u.login }.if_nil{ puts 'user not found' }
matplotlib + python
I looked at haml but am not using it. * I don't like significant whitespace. If I did I would be using python instead of ruby. * If I need to work with designers I prefer using something that resembles HTML/XML so that they can use their existing tools. * If I am working on something myself I prefer a pure ruby approach like markaby or remarkably. 
This looks a hell of a lot cleaner than the boilerplate we use now.
ruby: http://blog.labnotes.org/feed http://feeds.feedburner.com/errtheblog http://gilesbowkett.blogspot.com/feeds/posts/default http://feeds.feedburner.com/catonmat http://feeds.feedburner.com/HacketyOrg http://feeds.feedburner.com/LoudThinking http://macournoyer.wordpress.com/feed/ http://feeds.feedburner.com/nubyonrails http://blog.zenspider.com/index.rdf non-ruby: codinghorror, raganwald, joel, rands http://blogs.construx.com/blogs/stevemcc/rss.aspx http://feeds.feedburner.com/BugBash http://feeds.feedburner.com/Chadfowlercom http://www.hacknot.info/hacknot/action/postrss-2-0 http://www.lazycoder.com/weblog/index.php/feed/atom/ http://steve-yegge.blogspot.com/feeds/posts/full?alt=rss http://haacked.com/Rss.aspx my blog: internet duct tape: http://feeds.feedburner.com/engtech
* http://daveastels.com/ * http://www.rubyinside.com/ * http://www.ruby-mine.de/ (german) * http://fazibear.blogspot.com/
&gt; codinghorror, raganwald, joel, rands http://www.codinghorror.com/blog/ http://weblog.raganwald.com/ http://www.joelonsoftware.com/ http://www.randsinrepose.com/ 
There is a link to part one at the top of the post. I had been searching for a good post about how to get started with Rails 2.0, and this was the best I came across. I look forward to the next installment.
I was hoping the article would be a bit more than a recollection. It's good to know what so many think about it, but I was looking for a new insight.
Having `if_not_nil` and `if_nil` return the receiver so that you can enchain them looks just fine when the blocks are executed for side effects: `User.find_by_login('ov').if_not_nil{ |u| puts u.login }.if_nil{ puts 'user not found' }` However, you can achieve that _now_ using `returning()` in Rails, Object#tap in Ruby 1.9, or [Object#me](http://weblog.raganwald.com/2008/01/objectandand-objectme-in-ruby.html): returning(User.find_by_login('ov')) { |ov| ov.if_not_nil { |u| puts u.login } }.if_nil { puts 'user not found' } Or my favourite: require 'andand' User.find_by_login('ov').me.if_not_nil { |u| puts u.login }.if_nil { puts 'user not found' } The trouble with having `if_not_nil` return the receiver starts when you want to use the value of the block. Some people use `if_not_nil` the way I use `andand`: @name = User.find_by_login('ov').if_not_nil { |u| u.full_name } If `if_not_nil` returns the receiver, you lose this use case. Of course, Smalltalk gets around this by having keyword methods, so that `#if_not_nil` is one method and `#if_not_nil#if_nil` is another.
Agreed. Those three weeks are not spent exclusively working on the design document. So the number of hours estimated is way too high. At the same time, I doubt the team only works 8 hours a day for those 3 days. My honest question is, for how many clients is 3 days versus, say, 3 week really that important?
It's cool how Scruffy is easy to extend (with a little SVG knowledge), so I'm sure pie charts would be relatively easy to add. Someone in the comments said SVG::Graph was good too: http://www.germane-software.com/software/SVG/SVG::Graph
'Other hot skills, such as JAVA or Linux' -- woo!
http://feeds.feedburner.com/novemberaindotcom http://feeds.feedburner.com/GiantRobotsSmashingIntoOtherGiantRobots http://feeds.feedburner.com/buckblog http://feeds.feedburner.com/TheRailsWay http://feeds.feedburner.com/monkeyonrails http://feeds.feedburner.com/hasmanythrough http://feeds.feedburner.com/therailsist
Sweet excuse to visit Europe
And get hammered.
According to Obie Fernandez Zed is still working full time leading a team of rails developers. If Zed is saying he left ruby one of them is lying.
He says in the podcast he is still using Rails, but he has "left" Ruby in that he his no longer going to be a contributor. Listen to the podcast, he explains his situation.
A very informative article.
Sounds like he has become one of those "blub" programmers who uses technology A at work but would rather use technology B. What a rapid turnaround for ruby heh? Your boss forces you to program in ruby but you'd rather program in some new language like factor. 
I think Zed would say, "just because Rails sucks, doesn't mean there is anything better out there." I think Zed views his continuing use of Rails as pragmatic. I don't think he would allow him to be forced to do anything, but I don't know him that well. Seriously, have you listened to this? He talks about all this in the first 10 minutes.
This is encouraging. I wondered if Ruby Inside might have plateaued, but clearly it has some work cut out!! :) (BTW, for me I don't actively subscribe to many at all, fewer than you guys, but I use a lot of the social bookmarking tools, and ones I remember that I get good leads from.)
I know Zed is a good programmer, and was a valued contributor to Ruby and/or Rails. I respect him for those things. However, at this point, who cares? (Or, maybe more appropriately, why care?) Isn't this old news, now? He has been spending most of his time with Factor for a while now. Then he wrote his rant that was or wasn't a joke, was or wasn't mostly tongue-in-cheek, did or didn't open the door for everyone to trash Ruby and Rails in their blogs nonsensically, haphazardly, and rife with fallacies. Can we just forget about it and write code, now? Have we gotten to that point yet? A portion of his point is that people take blog posts/rants/etc _way too fucking seriously_.
Well... how could they take you seriously now?
&gt;Seriously, have you listened to this? He talks about all this in the first 10 minutes. No I didn't listen to him. I find his web persona rather obnoxious and childish. I really don't care what he thinks about anything. Look at his web page and tell me why I should take anything he says seriously.
Way to see someone practice what they preach. :P This article renders horribly (from a visual standpoint), and also has 57 validation errors.
We start on Friday! :)
Maybe another solution is switching to a lighter framework like Merb and not using AR. Can't wait for Merb-core to be released.
Merb works with AR. Rails works with other ORMs. Sequel looks pretty nice if you are looking for a lighter alternative to AR. Oh and ramaze looks pretty nice too.
I wanted to record this because some folks I know were using the rant as validation that Ruby and Rails were "fads" and the honeymoon was over. So, I wanted to get clarification on what was real about his rant and what wasn't. While this isn't the most exciting podcast ever, I still think its interesting.
Ah, fair enough. I respect the guy. I'm just annoyed by the credence given the purposefully inflammatory rant, and the resulting fallout. Pardon my own short ranting.
http://reddit.com/r/programming/info/67fhg/comments/
Thanks for pointing that out. The article is static HTML, and I recently did some heavy changes to the stylesheet of the site, and forgot that since the article wasn't rendered in a view it wouldn't update when the rest of the site did. I've cleared it up for you.
Datamapper (http://datamapper.rubyforge.org/) is promising too.
+1 Lets focus on more important things.
I think it would be a great opportunity for Open Source Ruby projects to get contributors.
I know this has already been on reddit, but I thought I'd resubmit it in response to [All That Git Talk in The Rails World, What Gives?](http://www.danielfischer.com/2008/02/01/all-that-git-talk-in-the-rails-world-what-gives/)
Thanks for the reply :) You're still failing really hard on the validation via the w3c's validator, but it looks like they're truncating one of your meta tags and that's screwing everything else up.
I want to know what you read, Reg. Sometimes I think you index more than Google.
Always good to see a sexy shot of Marcel Molina.
There are a few of these libraries around. I've used newgem (to great success), but I like [mr. bones](http://codeforpeople.rubyforge.org/bones/) best. YMMV.
Very nice. I like the idea of updating my apps with just an SVN update. I hope there is a way to handle migrations though.
In the linked podcast, he unambiguously says that he is currently working on a Rails project.
I am having problems trying to figure out when he is telling the truth and when he is lying. If he is telling the truth on the podcast he must have been lying on his web site rant. 
Not automagically, you'd still need to run them. But once you had, in theory you could just touch the config file and you'd be all good (or if your timeout is low, do nothing). I guess, in theory, there could be a "pre" setting that runs something /before/ something else in each case, but it might be a bit early for that, as the fundamentals need to be 110% solid first.
How do the java folks hande stuff like that, do you know?
At the day job, "svn co blah blah; ant build". And then prayer. You can also do it by dropping a WAR on the server, though. (Its like a JAR, except with a more unfortunate acronym.) Depends on setup, like most things.
I meant database migrations. 
Uh... reddit? But if I see a few things from the same site, I add the author to my feed reader.
if you just want a simple rubygem scaffold, then the hoe gem (used by newgem) has a cmd 'sow'.
Oh, okay. I thought you might have a big feed list, because I notice that often submit articles that I enjoy to reddit. Anyway, thanks
http://weblog.raganwald.com/2008/02/off-topic-raganwald-names-names.html
Zed says he's a "pragmatist". If Rails fits what he wants then he'll use it if not he'll use something else. Zed just said he won't be working on the Rails framework anymore. Perhaps it's the article's title that is misleading in this case? 
&gt;Zed says he's a "pragmatist". If Rails fits what he wants then he'll use it if not he'll use something else. He says that in one place at one time. In another forum at another time he says it sucks, he will never use it again and that the people who use it are mentally insane. Which one should we believe?
I don't know. I'm not sure what "forum" you're referring to but if your correct it does sound very confusing:)
I think this is most interesting if listened to as a sort of "exit interview". No matter how you feel about the rant, Zed's a remarkable programmer whose contributions have been invaluable. We should look at the reasons why he's leaving and we can be doing to make our platform better. This podcast lays out some good tips on where we should be focusing our efforts, and I'd suggest everyone give it a listen.
By "forum" I meant his own web site.
Looks very promising, but considering it's for Ruby 1.9 it won't see a lot of heavy use for a while.
Can someone who watched to the end tell me whether there was any value in this presentation? "I made Mongrel and got nothing while people have made millions from it. Er... successful open source projects have good websites... er... er... I MADE MONGREL! I GOT NOTHING!"
Interesting changes. I like how the scope has changed in blocks; can't accidentally change an outer variable: good design pattern!
Actually, it was very informative and interesting, at least, I thought. Big things: 1. Performance doesn't matter if you're bottlenecked. 2. Documentation makes and breaks projects. 3. Companies need to work with, rather than against, the economics of open source. Give back patches, docs, free schwag, don't demand, have a sense of humor. 4. Geeks say they hate marketing, but you need to market to succeed. 5. Simplicity is king, both in use and design. Small things done well have a large impact.
The interview's not just about geek drama, though -- Shaw says some interesting things about Rubinius. What the hell, I'll transcribe the interview from 26:00 on: "[To give the Ruby language an acceptable platform, ] They should start ditchin' the one-nine and the Matz based ruby, I think they should put all their muscle behind something like Rubinius or JRuby. In fact, the JRuby guys are kinda puttin' their muscle behind Rubinius -- they're usin' their tests; they're sayin' when Rubinius has most of Ruby written in Ruby, they're just going to adopt it. You know, trim down the virtual machine. And a lot of that is because, you know, they just did it the right way. You implement your virtual machines in your own language. Right? It's proven you can do that. With that in place... because they've got this clean platform... that's where everybody should be targeting their efforts. They should be helping the Rubinius guys get done. ...and I think, if everybody did that, Ruby could actually dominate. I think it could pull out of its crappy-platform days and get on to being a serious contender." How great is that? The JRuby guys are just going to toss their own implementation and port Rubinius to Java, because it's technically superior? You guys are awesome! Shaw makes Factor sound pretty alluring, too -- DB libraries, full GUI kit, bootstrapped implementation just like Rubinius... sign me up. Of course, I've built like six stack-based interpreters since October, so I may be biased.
I'd be happy with: result = (if (u = User.find(3)).nil?; '' else u.login end)
Another part I liked was the new block syntax. At first, I (as well as many others) objected to it, but after a while, I got used to it. It actually doesn't look bad, and it allows for blocks to have the same types of arguments as methods. The block call syntax is good too.
Sure, those are good points. But they're more or less common sense imo.
It sounds like he is not leaving. He says he is still programming in rails and he says rails is the best platform for some things. Of course he could just be lying. He is all over the place.
The issue with this is introducing a variable with scope beyond the one line. You can also use constructs like: result = u.login if u = User.find(3) result = (u = User.find(3)) &amp;&amp; u.login The second is how I used to write it. It became so pervasive in my code that [I refactored it](http://weblog.raganwald.com/2008/01/objectandand-objectme-in-ruby.html) so that I could write: result = User.find(3).andand.login
Fair enough. I will admit to not listening to the podcast, which I'm sure means I should not have commented. The title led me to believe the podcast was more language-civil-war bullshit, quite frankly. I obviously let my frustration with the whole thing get the best of me. I have been curious about Factor. I have a good friend who has been contributing libraries and the like who has been trying to get me to try it. I'm just reluctant, for various mundane reasons. 
How is this faster than the now-default cookies sessions store?
I would like to know how often and under what circumstances you choose to inherit an object rather then just adding the functionality you need to it.
I never inherit a class just to add functionality to it. What would be the point? Just re-open it, or if you want a nice namespace, make a module and mix. Use inheritance when you have a parent-with-many-children domain model. Don't use it for other things.
see kent beck's implementation patterns.
While I like the look of Imp. Patterns (not bought it yet: £££), isn't that book heavy on the Java? I would think that in Java subclassing to add functionality would be something you do far more regularly than in Ruby. Am I wrong?
Be sure to read this article's comments. Good stuff.
I actually tend to inherit a good deal because I'm often wanting to add the SAME functionality over and over again. I will monkey patch for one off solutions, but if I have any inclination that the code might be reusable then 'include' is my friend. 
Testing is very subjective. People have spent a lot of time trying to formalize testing, and all that has really come out of it are lots of definitions (branch coverage, line coverage and so on), and rules of thumb (pairs testing and such). The core problem is that it isn't computer solvable. You can't write a program that will act as an oracle for the questions you throw at the program, since... that would be pretty good as the program itself. Since you can't have an automated oracle, you can't automate the testing, and have to use human brainpower to figure out what is right, and what is wrong, and how to get there. Even then, testing isn't a solvable problem due to the heat death of the universe. A complete testing cycle, of every possible input will take so long it doesn't matter any more. So you come up with ideas like "equivalence classes", and let the testers figure out where those boundaries should be. Testing is way harder than most people give it credit for.
As I posted [here](http://reddit.com/info/67zcb/comments/c0348kr), testing is very hard to do completely. The technical part about writing unit tests is easy, the hard part is WHAT to test. Learn the terms "equivalence class", "code coverage" (in all it's forms), "all pairs", and also go read the Pragmattic Programmer's book on JUnit or similar. Not directly applicable, but Test::Unit is almost the same as JUnit, and it really expands on the WHAT part over the HOW part.
it's got to be something like one inherit for every five monkey patches at the absolute bare minimum for me.
Here's the irony: A good programmer will write more and better test code because they are more aware of what could possibly go wrong; however their code already reflects their awareness of those potential problems, and therefore while the tests help, they are in a way a double-check for something that they've already well covered in their code. On the other hand, a poor or novice programmer will have less awareness of what could possibly go wrong, and therefore won't account for those things in their code, but because they're unaware of them, won't write proper tests that would catch those potential problems. So in either case, the helpfulness of tests is limited; the former because their code is generally good enough without the tests, and the latter because their knowledge is too poor to write good tests, and once they're knowledge increases their code gets better and therefore their need for tests decreases. That doesn't mean tests are not useful. Where I believe they shine is not in catching defective code, but in making sure that a change made to one piece of code doesn't break something somewhere else that may seem unrelated (or that you didn't remember was related), without having to "manually" test the app by running through all the steps. The larger and more complex the app, the more important this becomes and saves countless hours of checking to see if everything still works. 
You either have to subclass in java or you implement an interface. You don't have the choice to do anything else. The latter of course means no code re-use.
That depends upon what you mean by "heavy". He uses Java for the examples, but his recommendations are language agnostic. "Implementation Patterns" and "Smalltalk Best Practice Patterns", have the best treatise on when (and when not) to use inheritance. Stand on the shoulder's of giants ... and IMO Beck is big in our community. I respect his opinion and his work. Those old school Smalltalkers really know their shit.
I tend to use much more mixins and monkey patching than inheritance. It's cleaner in ruby. 
Nah, I'm not really into Pokemon.
But why?
That's the exact reason my eclipse trial didn't last very long. 
Seems like a poor reason to switch languages. There are other Java IDEs. And switching to Ruby to get away from poor memory management is almost ironic.
Blame the IDE, not the language... and try Netbeans instead - http://www.netbeans.org 
I will second that. Every time I talk to my friends who are Java developers they always rant about how great Eclipse is. To me though it just feels painful. Granted I've never tried it for doing Java dev, but I would imagine any of the other languages supported wouldn't be much (if any) slower. I've tried it for Python, Ruby AND PHP and was not happy with it any of those times.
panxor said it best :)
We use netbeans for Ruby and it sucks. Big and bulky and no fun.
I find NB to be quite good for both plain Ruby, and Rails development.
Going further one should be able to share models and controllers between different rails applications too.
This conference sounds great. Now, maybe someone call tell me why "selling out" is the only way to make a website that doesn't make me want to claw out my own eyeballs.
Rubular (http://www.rubular.com/) is also very helpful.
I'm not sure I'd equate Ruby on Rails with Kenny G. It is not exactly mainstream, but whatever. Sounds like a cool conference. Also noticed that Zed Shaw was speaking. I thought he left the Ruby community. 
From the [Unspace post](http://rethink.unspace.ca/2008/2/11/announcing-rubyfringe): &gt; We asked ourselves if we could put on a conference that Zed Shaw would have a good time at. Sure enough, Zed is a confirmed speaker.
Hmm, $650 is a bit steep. Have to see if the boss will spring for it. Sounds excellent though.
Lex and Yacc style parsers have always left me cold. So I was very excited by the Treetop presentation at rubyconf. The parsing expression grammars way of doing things really seemed to click. I was too lazy to follow up on it, but once again the internet has come to my rescue.
I like Netbeans, and find its Ruby support to be excellent. Not sure how anybody could say it sucks, as it pretty much has every Ruby feature one could want: testing support, including rspec, Rails support, the ability to switch the interpreter from MRI to jruby, TextMate style snippets, and more. I mostly use TextMate for Ruby development, but I use Netbeans for experimenting with jruby and I have to say it is nice to work with, runs great on my Macbook, and seems to be adding lots of cool features. As far as this post, Eclipse != Java. 
Lucky you, I am my own boss when it comes to buying conference tickets. And $650 is ridiculous for a "fringe" conference. Wouldn't grassroots conferences be less expensive?
Not if they don't have any corporate sponsors.
Looks useful. I wonder which technology will be "discovered" and made into a rails plugin next?
Very funny and kind of cool.
Summary: Explicit SQL beats the crap out of SQL generated (badly) by an ORM.
I've thought the same thing. Git, and in this case, github, really "democratizes" software. I've found myself forking a lot of projects and indirectly contributing to them where as before I'd just pull down the repo and try to juggle patches on my own. Keeping my changes (for better or for worse) private. Now to just figure out how to intelligently merge upstream changes.
Nothing about this is specific to Ruby.
&gt; I’ve learned that developers who spend most of their time thinking about their project, rather than grueling over mundane tasks and busy work, do better.
I like the Dr. Frankenstein follow up to that as well: &gt;Their counterparts - those who fear the rush of extra web traffic, faulty error handling, and accidently falling into while() loops that never end - live in fear of their creation, dreading the day when it will turn on the parent.
My, hopefully instructive, musings as I worked through a particularly involved query. Includes a hack that gets ActiveRecord to write SQL out to a string that can then be used as a subquerey 
The "Are we down again? Call us!" bit doesn't exactly fill me with confidence...
An interesting abuse of Rails, but why didn't you just write the whole query yourself, rather than using the hidden private method? Seems like you'd then be mostly immune to updated versions of rails breaking your code.
Rails is getting faster all the time as the "many eyes" continue to find ways to tweak it. It's also the best documented of all the ruby frameworks. I figure you need a good reason not to use rails.
You are totally right. Git is a huge innovation in open source social organization.... and Github is the next logical step. My favorite line from the Github home page is the one that encourages would-be users to fork an existing project!
Say what you will about Microsoft, I do like C# (as a language). Even though for a couple reasons I will most often resort to Java when I have to pick one of both, C# has been much more receptive to new features, and I generally find them pretty interesting. Delegates, type inferring, properties... stuff I miss in Java, and which won't likely happen anytime soon. EDIT: yeah, I'm aware of the closures proposals and that properties might appear in Java 7. Though as far as I know they are not confirmed yet, my "anytime soon" comment relates more to the whole set of features, and to Java's glacier pace.
I can attest to these experiences. I wrote all of my code for a computer graphics course in Ruby. The codebase progressed with each assignment over the course of ten weeks. My friend's first part of the assignment, in the first week, was over 1100 lines of C++. My final code base, which incorporated all of the functionality of the previous nine weeks, including several file format parsers, multiple line and polygon drawing techniques, and custom matrix multiplications, was less than a thousand lines of code. My CS friends think I'm a freak when I talk about loving my code. But I can't think of doing any project *not* in Ruby.
That sounds like any half-way decent language though. Some languages do optional parameters to methods or functions nicer too. Not that I disagree.
Judging by the title the poster doesn't know Ruby very well, or atleast the Ruby case control structure. Look here: http://ruby-doc.org/docs/UsersGuide/rg/control.html to see why Ruby's case isn't just like a C case statement. edited for clarity:)
We should make Rubyholics Anonymous. Wait, someone will do it in 5 lines any moment.
um... "Updated: 2005/08/29" 
Java is older, has more users, and is "responsible" to many more corporations, organizations and people. Now that it's an open source project I expect a change in the pace of development and possibly even a fork in the fedora/rhel manner. I would like to see a community version which evolves fast and is considered a playground for new ideas just like C# while the "enterprise" java evolves much more slowly. 
Ooohh, me wants some :)
Troll if I ever saw one. And I'm with chollida1 on this, it's not that Ruby has a case statement, it's specifically how flexible and awesome it is.
This reminds me of Matz's "The Top 10 Reasons the Ruby Programming Language Sucks." It's supposed to be available [here](http://www.slideshare.net/vishnu/the-top-10-reasons-the-ruby-programming-language-sucks/), but the slideshow's not loading. It's officially available as a Keynote presentation or a PowerPoint presentation [here](http://www.ruby-doc.org/whyruby).
Yeah don't install single-handedly. I had to rollback 3 times the following morning :O
The scale is all wrong at [one point](http://www.kikoku.co.uk/post/27187807).
That's almost a reason to buy a mac right there.
"When you look at a language like Java, you see this ponderous, bureaucratic process for language change. Java does not include dangerous features like macros or open classes, and as a result change can only come from the language’s implementation, not from out on the fringe where people are using it and creating their own features to address their own needs." Why pick on the current whipping-boy? You could have used Python as your strawman and had a more relevent comparison. Is it because it is still cool to respect Python? "If it scares the bejeezus out of you, if you start thinking of rules to impose on your team (we will use no more than three of the following seven gems on any one project. You will have an Architect approve any modification to one of the following 132 classes…), then Ruby is not for you." You're not going to catch anything worthwhile with the deck stinking so much ;) 
&gt; Why pick on the current whipping-boy? You could have used Python as your strawman and had a more relevent comparison. Is it because it is still cool to respect Python? I have used Java for ten years, Ruby for six, and I have never used Python. It would be fraudulent for me to compare Ruby to Python. I do not check Google or Reddit for relative popularity and unpopularity before deciding what to write. I simply... write from my own experience. I encourage you to apply your ideas of the correct and incorrect comparisons to draw to your own writing. Your ideas may very well work for you while not working for me. Edit: Here is a draft of a post I wrote a while back making the same point comparing Ruby to Python. I discarded it after deciding I was pulling my understanding of Python out of my ass: --- Another programming language pissing match A &lt;a href="http://lambda-the-ultimate.org/node/1480" title="ruby vs python on Lambda the Ultimate"&gt;pissing match&lt;/a&gt; has erupted between Ruby and Python programmers. I rarely link to such things, much less comment on them: It is usually difficult to read anything in these arguments that hasn&amp;#8217;t already been said about Lisp vs. Fortran or perhaps Snobol vs. APL. One thing caught my eye. On reader asked whether you could define &lt;em&gt;factorial&lt;/em&gt; as a method on the Integer class. The response, naturally, was to suggest that you don&amp;#8217;t want to do this, that open classes are a horrible idea, and the discussion quickly devolved. Without getting into whether &lt;em&gt;factorial&lt;/em&gt; should be a method in the Integer class, the discussion really points out the difference in philosophy between the languages. Python is a strongly opinionated language. The belief is that there should be one obvious way to do things. Other ways to do things are discouraged or outright impossible. Guido has strong opinions about the right thing to do and his language is an expression of his personality. And it is not hard to see why, in 999 out of 1,000 cases, open classes are a horrible idea. Factorial is certainly not the poster child for open classes. Ruby is shamelessly multi-paradigm. The language&amp;#8217;s philosophy seems to be that if programmers are given both freedom and power in equal measure, good things will happen. Ruby&amp;#8217;s creator doesn&amp;#8217;t know which good things: I have yet to read a statement by Matz that he built Ruby to support DSLs or that he had web applications in mind when he built Ruby. Should classes be open? In Python&amp;#8217;s world, the answer is &lt;em&gt;no&lt;/em&gt;. In Python&amp;#8217;s world, questions like this must be considered carefully and the consequences weighed before features are added to the language. In Ruby&amp;#8217;s world, the answer is &lt;em&gt;yes until proven otherwise&lt;/em&gt;. In Ruby&amp;#8217;s world, even if we don&amp;#8217;t have a good use for these things today, we hold out hope that someone will think of a good use in the future that justifies the feature. For example, Symbol#to_proc is an elegant use of open classes. So elegant, it has gone from being an idiom to being &lt;a href="http://eigenclass.org/hiki.rb?Changes+in+Ruby+1.9#l168" title="Changes in Ruby 1.9"&gt;included in the newest language release&lt;/a&gt;. Am I saying that Ruby is better than Python? Of course not. The price of having things like Symbol#to_proc is having programmers write factorial methods for integers, or add an &lt;a href="http://raganwald.com/source/unfold.rb.html" title="unfold.rb"&gt;unfold method&lt;/a&gt; to all objects. Just as the price for significant indentation is that lambdas are far less useful in Python than in other languages. It&amp;#8217;s a trade-off, one that each language makes in a different way. But open classes are a very interesting trade-off, and a very good example of the different philosophies driving Python and Ruby. If you are choosing between the two languages, you could probably make your entire decision by simply asking yourself if you prefer a language wher ethe designers have carefully weighed the pros and cons and decided that important classes like Integer should be closed or if you prefer a language where the designers are prepared to tolerate 999 misuses of open classes if it permits one person to invent something like Symbol#to_proc.
It might have been a mistake to contrast Ruby with Python in this respect, anyway, simply for purposes of trying to get people to read what was written. After all, it's common and popular enough to "whip" Java that people won't raise such a stink about it -- but if you go after Python, *that had better be the reason you wrote the article*. Otherwise, everyone will ignore the main point and focus on the "insult" to Python.
Just some advertising from me, but hopefully you'll learn some tricks :)
I prefer the tawnies, a nice Quinta Do Infantado is sitting at home waiting for me. But god forbid you should finish it in one evening. Please, taste it. Have a nice dessert with it, something with the body to stand up to it, like a nice mocha creme brulee or the like.
Probably saved me at least a half day doing this.
I think (at least in my experience) the big thing is keep it pure ruby till you need the performance. I'd almost rather run memcached than poke at pure SQL all day.
Hmm, I need to look into webby. I have all sorts of interesting nuggets in my head waiting to get out. Thanks for the overview / tricks.
FIST
badass.
Much better with: require 'rubygems' require 'fizzbuzz' rescue `sudo gem install fizzbuzz` puts fizzbuzz
lol, awesome.
The concerns raised about open classes seem very much like those for dynamic typing. The takeaway, though, is that while both are certainly an opportunity for trouble, most people simply do not encounter the sorts of problems the nay-sayers presume will occur. 
how does this compare with caboo.se's spidertest?
inspired by spidertest, goal (partially realized) is to have pluggable subsystems for fuzzing, parsing html, parsing CSS, etc.
There's no way to comment on the blog, so, the resources part is already on rails trunk map.resources :comments, :as =&gt; "comentarios"
You know what else is destroying Ruby? - Showing up late to the movies - Cornrows - Out of network Texting Costs - Ham Sandwich on rye - Hammerhead sharks - Feeling smug - Bar graphs
Is a faster ruby webserver really important? Isn't most of your time usually spent in your framework (Rails, etc) or your own application code? IMHO [Switchpipe](http://switchpipe.org/) is much more interesting than thin. It offers the promise of making the deployment of Ruby web apps as easy as the development of Ruby web apps.
Switchpipe is not a webserver, it's a proxy server. Also the biggest advantage of Thin is not the speed but the scalability. It uses non-blocking IO and can support a lot more then 1024 concurrent connections unlike mongrel and other Ruby servers based on Ruby sockets while using less resources.
curse the gem polishers i say.
tried it today... awesome!
A mildly amusing blog post but its really just adding fuel to the platform holy war flames isn't it? Boring. As it happens, if you are a Ruby/Rails developer, I do believe that Windows is the weakest platform to work on for numerous reasons and OSX is my platform of choice, but honestly who gives a damn?
&gt; Ruby/Rails developer, I do believe that Windows is the weakest platform to work on Are any of those reasons Windows' fault, or does that reflect the attitude of the Rails community? &gt; I do believe that Windows is the weakest platform to work on for numerous reasons and OSX is my platform of choice Douchebag. =) (j/k, me too)
I feel like I have just been called a douchebag by someone who chooses to develop on windows. I wonder if I'll ever get over it? 
Ah yes, written because people got angry at Zed Shaw.
Linux is my platform of choice!
It doesn't matter if its Window's fault, but it does seem like it takes more work to get Rails going on Windows then Linux. Just judging from installation instructions I've seen (for various gems etc). Anyways, as a Linux user the idea that an OS X user feels holier-then-thou is somewhat comical. I do think think Desktop OS choice is a fair factor when employing, one of many.
And we know it'll be maintained, unlike Mongrel. 
Is Thin production ready? I thought it was still in beta. 
DHH is right.
I'd agree on most of his points, ruby is a very fast, easy to use language. But it isn't anywhere near as mature as Java or C#. I think the JRuby and whatever the .net version is will provide the inroads into existing deployments and the opportunity to link with the rest of the existing environment (Ruby on Rails in a .war file deployed on weblogic is much easier for sys admins to understand than them having to install lighttpd and ruby and gem install a bunch of stuff). Really, I think the big hurdle is that people only know one language. That includes programmers, managers, and the people making decisions. They've always used Java, so they always will use Java. They don't see that languages have different strengths, different weaknesses, and you can massively increase productivity and programmer happiness if you just take advantage of the variety.
Why not just name this article: 'Howto: Sharing Code Between Ruby Classes' ?
Because I'm teh n00b, I guess...?
&gt; Ruby on Rails in a .war file deployed on &gt;weblogic is much easier for sys admins to &gt;understand than them having to install &gt;lighttpd and ruby and gem install a bunch of stuff That depends upon where you put your camera. For many of us, mongrel+nginx and couple of "gems" is the easiest thing. Whats more, we can actually vendor those gems and freeze our application to particular set of gems so as we don't have to install those gems on each machine. Also, there are high quality Rails hosting providers like engine yard, joyent or rails machine that do a decent job. I am sure, JRuby will work pretty well for business houses which are already doing java only. Also, whats that b*s on "programmers, managers and other people making decisions* who always use Java. First that includes practically everyone. You, me and Jonny Depp. And you know what, Johhy Depp uses Ruby, trust me. You are practically saying here, that programmers doesn't understand languages have different strengths, weaknesses which is load of crap. Oh reddit.
You should check out switchpipe. You can deploy your rails apps with rsync or git if you want. I hear these "it's hard to deploy" complaints all the time but rails has capistrano which will let you deploy your app to application servers, make schema changes to your database servers, rehup servers if needed all from your desktop with one command. If it goes pear shaped you can roll it back. Rake deploy. How much easier could it be? I don't know of any other toolkit that lets you deploy to multiple servers and intelligently upgrade your database schemas like that. Do you? 
ZSSP: Zed Shaw is a Self Promoter! Pure controversy for controversy's sake... I'm finding it boring. Zed's a great hacker but these types of posts are rather useless and obvious.
Stupid blogspam. Here's matz with the list of changes: http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/15701 
Curry is now a method in ruby 1.9 http://www.ruby-forum.com/topic/142699
I recently started using webby to develop my [ruby tutorial](http://zem.novylen.net/ruby/tutorial/arithmetic-quiz/arith.html). Very pleasant to work with.
Good information on best practices for RoR deployment.
&gt; After discussion with Halorgium on #github, I have pushed a multiengine branch. Use that instead of my master, which has been reset. Can anyone explain why this is desirable?
Null pointer exceptions?
Why what is desirable? A multi engine mephisto? Mephisto has reliance on one anti spam engine. This guy wrote a version which can use multiple anti spam engines. Personally I don't understand why they don't add a captcha but hey to each his own.
And to answer the other possible meaning of the question: "why is publishing this independent branch with Git (or any other dvcs) desirable?" 1: Well, anyone who is already using Mephisto from the trunk can now simply pull another branch and try it out. It'll never cause a problem to Git. 2: If the authors decide to merge it with the main line, they can do so with Git's great merging capabilities. Since the branch has been forked recently, they're likely to have only non-conflicting changes, which Git will handle automatically (since it automatically knows the common ancestor, so it has at much info as if you did a 3-way merge). If there are conflicting changes, they'll have to be resolved, of course. 3: When all of this is merged, everyone following Mephisto with Git will just have a clean repo, with the merge automatically taken care of for them.
Defensio is also more accurate than Akismet and offers nice usability benefits as well, like sorting by spamminess instead of just chronologically (handy when you see "defensio spam (465)"). You can see the accuracy numbers for all users on defensio.com. Disclaimer: I work on Defensio.
I'll take your word for it. I haven't used either one. Personally I would rather have something hosted locally but that's just me.
The concept is good, **as long as your code is aware of it**. From what I've read from all this discussion on the Ruby blogosphere, this is approximately what Objective-C does (in fact it "does nothing", but that has the side effect of possibly unexpected outcome for operations that use a different register for results, like floating-point ops). I can see two problems with the solution offered: * It may break horribly others' code, especially if they rely on something wild like inline `rescue`. * Ruby's `nil` does in fact respond to a few methods, so this approach may eventually give unexpected results. In the end, I'm still in favor of a syntactic solution for the problem.
I'm not saying it's hard given you use the right tools. I'm saying that it is hard to deploy when you have to convince the server czars to install all of your tools, and maintain more software. If you hand them a .war file and say "deploy this on weblogic", they know how to handle that. Basically, when I say hard to deploy, I mean in both the technical sense, and more importantly, the organizational sense. There is a mismatch between the companies we are talking about, I'm talking about HUGE, you are talking about Medium.
Why is metaprogramming preferred to inheritance here? I know that this is how Rails is supposed to be done, but I find it less obvious. For one, class level code is in a magic method, not at the class level. I prefer to inherit first and split out into modules as needed. I use metaprogramming when I have to, but not until then. I haven't seen the point of the Ruby single inheritance restriction that makes metaprogramming necessary. With inheritance, it's easy to see when the implementation gets hairy and should be refactored. With metaprogramming, it's harder to tell. I don't know what most of this Rails magic is doing. I take it that the intention is to give Rails scripters a DSL and prevent them from wanting to know. I don't have extensive Rails experience, I currently use ActiveRecord in a non-Rails project, and to me this just looks like tight coupling. The end result is the same as a big inheritance tree.
Personally, I'd love to see other methods of achieving this same result. I just did things this way because it was the only way I could get it working. 
see also: http://www.rubyinside.com/ebb-web-framework-http-server-786.html
That would make for a good blog article. Try it with pure inheritance and no self.included, and show where it breaks. Metaprogramming probably can't be avoided, you'll need class &lt;&lt; self. Maybe post it to reddit and get comments (and abuse ;). ruby2ruby might help here. My project is not in Rails, so I might be lucking out, but I just do: &gt; class FooTable &lt; ActiveRecord::Base &gt; establish_connection(Dbconfig) &gt; [...] &gt; end &gt; &gt; class Bar &lt; FooTable &gt; set_table_name 'bars' &gt; [...] &gt; end I include/extend modules where needed, but I try to be explicit and put metaprogramming as downstream as possible. set_table_name is a metaprogramming magic method; I never did look up the explicit form for this one :) 
argh, no literal formatting on reddit. "set under table under name".
Captchas don't work anymore. That's especially true for trackbacks and pingbacks. 
&gt; The concept is good, as long as your code is aware of it. Which means that it's unusable, since it monkeypatches a fundamental object (as you noted). Don't make the entire codebase of your project deal with your cleverness. Type out the darn logic and deal with the LOC increase. Or use andand. Or use "foo.bar.baz rescue nil" iff you have unit tests that cover everything that can go wrong with foo.bar.baz (hint: you don't ;).
&gt; &gt; The concept is good, as long as your code is aware of it. &gt; Which means that it's unusable, since it monkeypatches a fundamental object (as you noted). Exactly. While writing the original post, I felt tempted to say the monkey-patching discussion already happened a few days ago.
Yeah, I get what you're saying, and I think we pretty much agree, but just to be clear, things are hard because they're different. To me, setting up a Rails environment, or more importantly, deploying to a Rails environment, is dead simple. I'm far more confused when I'm trying to figure out what the hell I'm looking at in WebSphere, and I've had enough experience with it to know that it's not all sunshine and fairy kisses. But absolutely, everyone's been setting up J2EE servers and deploying war files for years now, so any change is hard change.
It seems to me that we'd be slightly better off if the best practices for deploying a Rails app were stable for long periods of time. Like, say, six months or so. Average product lifecycles are measured in years, people. That's plural. How can I sell my management on getting us to do a project in Rails in March 2008 which will be phased out in March 2017 when I can't be sure that there will be community support for our deployment option in January 2009? Apache proxied to FastCGI! No, mix in Lightspeed! No, FastCGI sucks! Apache proxied to Mongrel! No, Apache hogs the memory, use clusters of mongrel! No, Mongrel can't do static resources well, use Nginx in front of clusters of Mongrel! My brain hurts. (Do PHP developers have to have their brain hurt for this? No -- there is one canonical way to deploy a PHP app and it is Good Enough for You.) It hurts especially hard because the difference between 2k requests per second and 5k requests per second is meaningless for like six nines worth of applications in the world.
No, I meant why have a multiengine branch and reset the master?
I understand why you'd want to use git (or a DVCS in general). Everyone at my work can tell you how much I like git :) What I don't understand is why it's desirable to reset the master branch and create a different branch for the multiengine stuff.
&gt;I'm not saying it's hard given you use the right tools. I'm saying that it is hard to deploy when you have to convince the server czars to install all of your tools, and maintain more software. All you need is fcgi. Sure it would be better if you had full shell access but all you really need is fcgi. &gt;There is a mismatch between the companies we are talking about, I'm talking about HUGE, you are talking about Medium. What kind of HUGE company does not have their own servers? Let me explain to some ways you can deploy rails applications. You have capistrano. This is a very powerful tool which works over ssh. You list your database servers, you list your web servers, you tell it where your code repository is. When you say "cap deploy" it takes your code and checks it out (or exports) on all your application servers, it then restarts your FCGI servers or your mongrel servers. Optionally it can run any code you can write in ruby. It also logs into all your database servers and makes your schema changes including loading data or running update statements. You do all this from your machine. If things go wrong you tell it to rollback and it will revert to the previously deployed version and it will undo all your database changes. It will do this on all your servers. It will do this from your machine with just one command. No other language I know offers this level of deployment ease. If you know of one please let me know. Capistrano was made specifically for HUGE companies. HUGE companies running HUGE applications on dozens of servers each of which has a specific role. Anybody who tells your rails applications are hard to deploy are flat out lying to you. If you don't believe me try it yourself. The other way I mentioned is using switchpipe. This is a proxy to proxies. You tell it what directories your applications are in, how you want to run them (thin, mongrel etc), and it takes care of the rest. It will launch processes for you and proxy requests to those processes. It can keep minimum and maximum number of processes, it can clean up old processes, it can even act as a front end to python or perl applications. You can combine capistrano and switchpipe if you want. After all it's ruby and both frameworks can do anything ruby can do. Trust me that's a lot. So all of you posers please stop with this "rails applications are hard to deploy" crap. If they were so hard to deploy every other framework would not be scrambling as we speak to build their own versions of capistrano and database migrations. 
Or you could just use [Ramaze](http://ramaze.net/) if you're looking for something different.
Hey, that's a slick solution, I approve.
I think you missed my main point. Developers don't have access to servers in big corporations. Not even close. I can't log into a user account on our app servers, much less change the database or deploy anything. You have to convince the people in the data center to do it. And no, there is no way of changing this policy due to SOX. Deploying Rails apps is easy. For medium sized companies that let developers touch the servers. HUGE companies don't do that. They have IT people who's whole job it to maintain their servers and keep them running. Which is an easier sell: 1. "Here is a war file to deploy" 2. "Here is a suite of tools to install, then run this deploy script which is in a language you've not dealt with, and your existing tools don't match up to". Capistrano is awesome, and can automate all sorts of things. My original statement was that JRuby is a great way for ruby to get headway in companies that don't want all the ruby/rails setup and retraining overhead, since it hides the complexity from the deployers.
Incidentally, is Ramaze thread safe?
Or [Sinatra](http://sinatra.rubyforge.org/), which is about the simplest and most "Rubyesque" you can get (IMO). I'm currently experimenting with using Sinatra in combination with [Datamapper](http://datamapper.org/) or [Sequel](http://code.google.com/p/ruby-sequel/), two simple ORM libraries. Compared to Rails and ActiveRecord, these libraries are very simple and easy, they're not something large that's in the way. They let you program in *Ruby*, instead of making you program in *Rails*.
Supposedly yes, though I haven't verified it myself.
&gt;I think you missed my main point. Developers don't have access to servers in big corporations. Not even close. So? Are you telling me that some sysadmin in some big corporation is going to draw a line in the sand and refuse to give a username and passowrd to the developer thereby preventing him from deploying an application? I have never heard of such a thing. Every corporation I have ever worked in would fire any sysadmin who would refuse to allow an application to be deployed. &gt;Deploying Rails apps is easy. For medium sized companies that let developers touch the servers. The developer doesn't have to touch the server. The sysadmin can set up everything and give a username and password to the developer. &gt;"Here is a war file to deploy" Except that this doesn't do half of what I described. Deploying the war file doesn't upgrade your database. It doesn't give a path to rolling back to an earlier version. Deploying applications via a war file is kind of retarded and I would never want to go back to them. &gt;My original statement was that JRuby is a great way for ruby to get headway in companies that don't want all the ruby/rails setup and retraining overhead, since it hides the complexity from the deployers. Deploying via war files is way more complicated than capistrano. You have to deal with manifests, classpaths, tons of configuration files, all kinds of shit that capistrano frees you from. Like I said it also doesn't have half the features of capistrano. Having said all that there is no reason you can't give a zip file to the sysadmin and have HIM type "cap deploy". If he can take a war file and drop it on a half a dozen servers I suppose he can type "cap deploy" too. 
&gt; No having to bend your brain around RDBMS table creation and styles, and then back to objects, and to what can be done in between. Sounds like Og, and DataMapper.
Actually having used the ZODB I have to say that I would love to use a real object database like the it in Ruby/Rails. It is way more than Ogg/Datamapper. It is more like StrokeDB or CouchdDB.
I think lots of the info in this article is false. If you want more accurante info I suggest reading http://www.kegel.com/c10k.html "[a threaded server] Has the disadvantage of using a whole stack frame for each client, which costs memory. Many OS's also have trouble handling more than a few hundred threads" As an example Nginx is an event driven web server and Apache is a process based one, you do the comparison
The author also doesn't mention that languages like erlang can handle concurrency very well with only green threads.
Do you consider zope/zodb to be successful open source products? I guess they are to some extent but let's be honest they didn't catch the world on fire. I tried very hard to like zope. I used it for a couple of years, I developed some apps with it but in the end it was more frustrating than fun. 
I don't see why the choice of application engines would cause you any headaches. They are very easy to swap in and out. You don't have to change your code. Other than maybe cobol or LISP what language, framework or implementation do you think is going to last ten years anyway? Even with cobol things have changed in the last ten years. &gt;It hurts especially hard because the difference between 2k requests per second and 5k requests per second is meaningless for like six nines worth of applications in the world. Mongrel is open source. It hasn't gone away. You can still use it. It's just no longer the best or the fastest option. You should also try switchpipe BTW. 
I have to admit that I'm ignorant enough, on threads &amp; Ruby, that I read these articles and end up agreeing. I checked out the c10k article and it was way over my head. I must also admit that although I love the raw speed of ebb I'm still using Thin for production. It's been very good to me.
I played with it a little. It's really simple and neat. I didn't stick with it because I would have had to re-do a lot of stuff rails gives me out of the box but if I was doing something pretty simple I would probably give it a more serious go
Why not use a "?" like Groovy? I guess because in Ruby a question mark usually returns a boolean? The underscore just isn't as communicative...there has to be a better indicator.
Oh goodness. How ignorant that guy is! I expected something better from Author of a web framework. Okay, to put facts straight: 1. You can't use Ebb with Jruby, because Ebb is implemented on top of libev which is a C library for event driven network programming. 2. Granted one can write stupid code either using Event Driven Programming or threads. But threads are mathematically proven wrong. Search google and you will find couple of papers on how correctness of an algorithm implemented using threads is wrong. I have done LOTS of network programming and I can tell you threads suck, either in Java or Ruby or some other language. They really get out of hand, as complexity of your program increases. Also, Event Driven programming is not only alternative to threads. There are things called Actors which are based on various mathematical constructs. Scala one is based on fork-join. MentalGuy's implementation is based on pi calculus. But perhaps our man confused Actors with Event Driven thingy. Although, He strikes close, but there is subtle differences between Event Driven reactor loops and Actor models. For example, if you are using Event Driven library for network programming, you can't use network librararies that do IO using blocking and threading model ( actually you can do, but you are missing whole point then). But if you are using Actors you can pretty well use either of style. I am working on a Actor and Event Driven networking library for Scala and I love how well Actors and Event Driven loops integrate. 3. Last, he mentions Event Driven programming is not popular in Java ( I don't count PHP ). Again, goodness, did he heard of MINA? 
Aah, well, I don't know :-) you're supposed to be able to pull a remote branch and give it another name. So I have no idea why he'd reset the master and put everything in multiengine...
Man, you don't have to. I still run an app that is very stable under lighttpd.
This is cool, but I'm really curious who needs this. Isn't the limiting factor for most web apps the app rather than the server?
very cool docs could use an "ick in 3 minutes or less" section though that just shows all of the methods being used in the most normal case.
Reasons to do it the Groovy way: * Groovy does it that way. Reasons not to: * Ruby already has a convention for ? at the end of a method name. * Ruby already has the ternary operator using a bare "?". * One advantage `.try()`, `.andand`, and `do_or_do_not` have in common is that they are relatively descriptive and clear about their actions. As a Ruby programmer, if I see `blah.foo_.quux_` I have absolutely no idea what's going on or why some idiot named his methods with trailing underscores. `andand`, and `do_or_do_not` are poorly named (imho) but at least they try. a "_" suffix is just crazy. I like `try` best myself.
I don't agree with the assumption it reads better. In fact, I had to read them several times to figure out what was going on. The first example would read better if it said "num.divisible_by?.either" instead of the other way around. The way it reads is just awkward to me. On the "include" example, I actually like include? better there, but it depends on what you are trying to achieve. If you're just using an array and asking if it includes x to trim down the comparisons you write in code, I like x.either, although it still reads awkward to me in that situation. I also agree with the comment on the blog that "any" and "all" would be better than "either" and "both." The words "either" and "both" correspond to two items, not more than two. (Although we often use "either" to refer to more than two items, [American Heritage Dictionary notes](http://www.answers.com/either&amp;r=67) &gt;The traditional rule holds that either should be used only to refer to one of two items and that any is required when more than two items are involved: However, I think the idea is commendable and if the positioning wasn't awkward to read and there were better words for 3+ argument methods, I'd actually use it. It would be nice to use "either" and "both" for 2 items, and "any" and "all" for more.
To me they both read somewhat similarly ("If x is both divisible by 3 and 5" versus "If x is divisible by both 3 and 5") but there are two reasons why I did (either|both).method versus method.(either|both): First, method first doesn't look as good for operators. For example, string.=~.either /a/, /b/ versus string.either =~ [/a/, /b/]. Secondly, and more importantly, the implementation of that is far more intrusive and complicated. I'm not even sure if it's possible. You would have to move all instance methods from every class into another set of classes and then proxy every method with a method_missing call. I doubt many people would enjoy using something which did that. In reference to any/all I'm torn on whether they read well or not. I think in the (either|both).method convention which I chose they read pretty badly. In method.(either|both) it might actually read pretty well. I also believe it would be highly confused with Enumerable#(any?|all?) which has a different meaning.
Nice! Those erb scaffolds are damn annoying.
I'm thinking about donating to this as it benefits me as a Ruby hacker but also because of the boatloads of time Ruport is going to save me on my current project.
Ruby Central is matching funds donated to Greg up to a total of $5000. Awesome. http://groups.google.com/group/rubymendicant/browse_thread/thread/5c44d12d7cdc7e59
A nice trick. Ahh, I love open classes!
Interesting that things that do not behave as he would like them to are considered a bug or a problem of Ruby that needs to be fixed, as if it were self-evident. For example, that including a module gives you a reference, not a copy, to the methods is real win if you want to ensure that run-time modified behavior is propagated to all concerned parties. Of course whether or not you write code that behaves that way may be a matter of Blub, in which case you may see this shared referencing as a language design mistake. That said, an easy way to include module methods that cannot change is a really good idea and I'm glad someone's giving it some thought.
Somehow I have the feeling I don't get it. What's wrong with instance_eval?
Oh, you're right. You can do pretty much everything with instance_eval, even call a method with parameters. Much more concise, too. But I still love open classes, you can't take that away from me :-) 
 irb(main):001:0&gt; class Test irb(main):002:1&gt; private irb(main):003:1&gt; def foo irb(main):004:2&gt; puts "foo" irb(main):005:2&gt; end irb(main):006:1&gt; end =&gt; nil irb(main):007:0&gt; t = Test.new.send(:foo) foo =&gt; nil
I just tried #send on private methods in Ruby 1.9.0-0 and 1.9.0-1, and it worked in both. Perhaps between November 2nd, 2007 and the first "release" of 1.9 something changed.
I'm just selling one product, and won't need to worry about shipping. Is it ready for prime time?
absolutely its ready. there is even a peepcode on how to use it. http://peepcode.com/products/activemerchant-pdf
ActiveMerchant have been around for a while (though haven't used it). I also heard about Substruct which (http://code.google.com/p/substruct/)
Outdated information.
Or even: class &lt;&lt; @ninja; public :kill; end @ninja.kill(10) 
After they took it over I thought the pace of development might pick up but it hasn't turned out that way. I believe eclipse DLTK is in release candidate now and will probably have a new release very soon. I look forward to trying both of them.
i just implemented it on my site and it's relatively simple to use. fwiw, my product/service also doesn't require shipping (it is emailed to the customer). the nice thing about AM is that there's a relatively uniform syntax for authorizing/capturing payments irrespective of the credit card validation service you use (e.g. Paypal vs Braintree vs Authorize...)
If you want a module to be protected against changes, you could include a copy. class Y include A.dup end If you don't want to include certain methods of a module, you might want to reconsider your modules and split them up. 
It would save you a lot of work :) I hope you will find it useful. Of course, you should first check if Shopify may already do everything you need. Its a lot better and a lot cheaper to use than trying to roll your own in a limited amount of time. Also, if you accept credit cards you will have to get a PCI DSS certification soon, with Shopify this problem does not exist. 
So, according to their the "Feature Comparison" on [this page](http://aptana.com/rails/) they have Rubinius support. I'm curious what they mean by that. Rubinius doesn't run Rails yet, so I'm slightly baffled by that by that feature.
Dang, and I just went through the pain of switching to emacs.
I'm confused, as well. It states it has built-in support for RSpec, yet I have found no enabled options, views, etc. So far, searching has turned up some people stating that it should be in the release, but I cannot find evidence for it. Outside of that, my experience so far is positive. It runs well, and many of the niggles of RDT have been fixed, it seems.
I like this better. Every line of code used to subvert implementation reduces the simplicity of a test. The best tests are usable as documentation. I like having everything public best of all, though :)
Why not link to the [original](http://st-on-it.blogspot.com/2008/03/story-writing-is-fun.html) rather than blogspamming for dzone?
It's one of the oldest plugins around, and [Shopify](http://shopify.com) (the site it was extracted from) is one of the oldest successful rails apps. It **has** had a lot of usage and AFAIK never had any troubles. I haven't done anything but a small test with it, so I can't really give you a honest recommendation.
No. There is no glory. The argument seems to be based on English definitions, not code definitions. But even so, there are some issues with the English: _i.e._, `nil` is not _empty_, `nil` is _emptiness_. Here's some more counterpoint: A `NULL` field in SQL doesn't connote a void, but rather a _blank_, undefined state. `nil.blank?` makes sense and is defined by Rails because those fields can be `NULL` or empty strings, but usually connote the same thing. `@user.name.blank?` makes sense (and should return `true` if `nil` _or_ `""`), `@user.name.empty?` does not. Save `empty?` for things that can be empty: Arrays and Hashes, `[]` and `{}`. Certain methods should return arrays or hashes, empty or "full", and if it's returning `nil`, that's a problem that __should fail__ when `empty?` is called on the object. 
Upvoted for [interrobang](http://en.wikipedia.org/wiki/Interrobang)
I think that the complex Rails applications such as maintained over years tend to have messy config/routes. Today I'd like to introduce a simple way to keep them clean.
"Rails has, of course, incorporated nil.blank? because they’d monkeypatch their grandmothers if they could figure out how." Ew. But this is the best image of the monkeypatch debate yet. Monkeypatching interacts with inheritance similarly to a genetic engineer with a time machine. You want to improve your vision, so you go back and edit your grandmother's eggs, and find out that you haven't been born because your dad passed the army physical and died as a young infantryman instead of being assigned to the typing pool.
Actually, the feature comparison is kind of biased and almost insulting for the netbeans people: http://blogs.sun.com/tor/date/20080313 Check Netbeans too if you are looking for a rails IDE. Their progress has been epic.
I don't get it. Why would anybody want to specifically test a private method? Surely the whole point of private methods is that they are invoked elsewhere in the class, within some public method? Your tests of that public method should act as a sufficient test of a private method. In fact, when writing classes test-first, assuming you are writing a test and doing the simplest thing that works to get that test to pass, everything starts life as a public method. Private methods appear during the refactoring process (extract method) but the tests remain the same. Testing private methods in this way is a pointless violation of encapsulation. Perhaps somebody would like to highlight a good reason for wanting to test private methods.
Phew; I'm not a Rails developer. So I'm spared.
Jeez; will these people ever get a fucking clue and learn what the term "monkey patching" actually means, and stop using it to refer to each and every case of modifying an existing class? Developer ignorance will end up destroying Ruby (or at least destroy newcomers who are introduced to sloppy terminology and bad habits right from the start.) 
I don't know why all of rails isn't based on something like this. Can you put cells inside of cells?
Perhaps you could enlighten them as to its meaning? Both you and Wikipedia seem to say they've got it wrong, but neither of you offer the "correct" definition. &gt;In Ruby, the term monkey patch was misunderstood to mean any dynamic modification to a class and is often (incorrectly) used as a synonym for dynamically modifying any class at runtime.
The clue is the "patching" part. The term comes from "guerrilla patching", a way to patch running code without actually, in fact, replacing the shipped source code with new content. Instead, you replace it at runtime. It's a hack of sorts employed to set something straight until a correct solution ( i.e. a new release) is available. On the other hand, there are times when altering code at run-time is the exact thing you want to do. It's not a patch, it's deliberate dynamic behavior. (There may be more acceptance of this among Rubyists than among Pythonistas, though therm comes from the latter group) Whether this deserves some other goofy catchy name (aside from simply calling it "runtime class modification) is another matter. Certainly there is abuse of this technique, just as there is abuse of global variables or any other programming option. But sweeping every instance into the same (arguably pejorative) category does not help people learn good practices. Indiscriminate use of the phrase ends up rendering it meaningless.
&gt; Create cells within cells and you can quickly build up a repository of rich interface elements... Apparently so, according to the article. Sounds neat.
Ok, so the distinguishing feature is that one might add to a class at runtime, versus actually overwriting some methods in that class. What if I overwrote something that someone else added? I'm not against the practice you described, just trying to play a little devil's advocate.
OK, usual disclaimer about impulse code examples: You have an app they may be run at the command line, or perhaps embedded in something else. From the CLI, calls to STDERR.puts are fine, but if embedded, maybe that's an issue. So, on purpose, you modify that core behavior based on the current operating environment, so that otherwise OK behavior is altered for a particular expected scenario. Not monkey patching. On the other hand, you have an app out in the wild running under Ruby 1.8.4. You need some behavior found in 1.8.6, so you deploy a new version that mods the core behavior. It's a guerrilla patch. You are not actually updating the Ruby installation, just it;s behavior with your app at runtime I'm sure there are countless variations and gradations, but I'll posit these as reasonable examples of making deliberate practical use of a key language feature vs. trying to overcome a code issue in a less than ideal manner. (It's an area ripe for flame wars, though. Hopefully any threads here offer more light than heat.) 
What level of abstraction is it 'okay' to stop learning at?
About a year and a half ago I was a Duplo generation Rails developer. I had less than a 5% understanding of what was going on. Now I create my own generators, roll my own basically everything, and usually only use one plugin - tinymce. There are a ton of guys out there that are just like this article is referring to. In regards to giving back, me and a friend are starting up a how-to website, much like Railscast but geared towards the beginners. I've read almost every RoR book and ran into almost every problem, so I hope this will help others not have to go through the trouble I went through and give ma deeper understanding of the language. I also want to have an area that just deals with errors. All those stupid errors you get, that if you're new, you have to just type into Google and search through 15 pages to find the fix. I think that would be awesome. I'd also like to have a big emphasis on testing, because I know, from my own experience that Duplo-types don't test. Another problem is all of these tutorials out there are either way over your head or hold your hand too much. We need to do like [aidanf](http://www.aidanf.net) does and teach as we go.
Looking forward to it! Please post your link here when it is ready!
Certainly will. I'm on Spring Break so I don't think it'll take too long. 
Sweet. I wonder if these will be able to span other controllers. Like Application level partials if that makes sense? If so that is awesome and really extends the ability of Rails in an area that so desperately needs it.
I had NetBeans just before I switched over to RadRails. I really liked NetBeans, but you just can't be RadRails in my opinion. It's a lot more intuitive for rails than NetBeans is. Although I will say that NetBeans was much easier to setup than RadRails.
&gt;The problem is that a generation of Rubyists has grown up being used to getting everything pre written for them. They haven't yet passed the "Duplo stage" and basically write applications putting a few blocks together, only writing 10 to 20% and barely understand 5%. So each time someone uses GD Library, an IMAP library .. basically any library at all we should feel guilty for not having written it ourselves? Does the author really believe if something has been written and works that it isn't good practice to make use of these rather than re-inventing the wheel? Seems like a fundamental part of programming is to stand on the shoulders of giants. 
This is bullshit. The *real* reason Ruby on Rails cuts development time is because: 1. Ruby is terse and well designed 2. ActiveRecord lets you manage records with relatively little hassle, and in no-time, because of zero-config 3. ActionPack makes it easy to turn records to html output Plugins are great, but people were getting lots of stuff done in no time at all, using Rails, long before there even were any plugins. I started using immediately after release, and one month later I was more productive than ever before. Oh, and I truly do wish Rails was as easy to use as the author claims, unfortunately it isn't because most of the time the ready-made stuff *doesn't* suit your particular need.
&gt; There are a ton of guys out there that are just like this article is referring to. Sure, but most of them are using ASP.NET, not RoR
I don't understand why the article ends up saying use merb. Does merb use rails plug ins?
Dead right. &gt; most of the time the ready-made stuff doesn't suit your particular need. Absolutely. But don't you feel there is a tendancy amongst Rails folk to talk up how "awesome" and "easy" every new plugin is, which obscures the fact that "awesome" and "easy" _when you have the skills to work out how it works_.
Did you not get the memo? Every Ruby/RoR blog post must now reference Merb. It's like a backlash, but lamer. EDIT: Merb is awesome, btw.
I think that's mostly the noobs.
From a business point of view - but not from an intellectual point of view - I would _love_ to be able to only have to write 10% and understand 5%. Productivity would rocket!
I'm finally getting excited about programming thanks to Rails, and now I read that the most I can hope for is to be a "Duplo developer"? Thanks. Thanks a bunch.
To answer your question directly, yes. Merb uses plugins. Most of the stuff that's built into Rails is a plugin in Merb, including the ORM. As for the article, I don't know why he ends up saying, "use Merb". He seems to complain about non-contribution from the community. However, most of the community are people who are new to web development in general, not exactly people I'd look towards for help. IMHO, Rails is for advanced to expert level web developers, not newbies. There's a lot going on that one needs to understand before trying to develop a web app or a website in Rails.
But, that's where the marketing comes in. The tone and wording in the marketing campaign of Rails is such that noobs will be drawn to it.
 render_cell :first, :index, :some_arg =&gt; :some_value render(:partial =&gt; 'shared/first', :locals =&gt; { :some_arg =&gt; :some_value}) I seem to be missing the benefit. 
Check out any Rails forum and you'll see that's not true. &gt;I'm a total Rails n00b. Why does it say you had nil object when you didn't expect it?
bullshit article about a bullshit topic. Libraries are bad mmmkay?
The benefit is that the cell has its own controller, so that that single line of code is all that a view containing a cell needs. The view containing the partial needs to mix in the code to prepare for the rendering of the partial, creating a new dependency.
Precisely. Cells have their own mini-controllers, so they can be used anywhere in the app, like an actual component.
Freakin sah-weet! I'm trying this when I get back home. Lucky for me I happen to be working on an app right now. Thanks for bringing this to my attention. 
I am asking this honestly. What makes it so awesome? It lacks a ton of features rails has. Not just the trivial ones either things like automatic testing and coverage. It can't use any of the rails plug ins (can it?). It's got no documentation. I looked at ramaze for a little bit. I could instantly see it's appeal. It's tiny, tight, has no features but it makes sense and easy as hell to use. Why would I choose merb over rails or ramaze?
I was being slightly tongue-in-cheek. Having said that... I don't know ramaze. You may choose Merb over Rails if you are looking for a Ruby framework like this: * Simpler * Thread-safe * Smaller memory footprint * Agnostic w.r.t. js, ORM etc. But is still: * Extensible with plugins * MVC * Compatibile with ActiveRecord * Similar "enough" to Rails Plus it has some nice touches like Parts, or the way Mailer inherits from AbstractController. If that appeals, and only if, Merb is awesome! EDIT: re testing, there's a rspec merb plugin.
That's not what the article means. What it means is that you should try to be more than a "Duplo developer". Start with duplo blocks and then write your own stuff or even provide the communities with new duplo solutions.
it depends on your knowledge of web development, I would suggest you never stop learning. understanding 5% of an app at first is fine, but hopefully you will learn and understand more really quickly.
I was being socratic, but thanks.
merb has both rspec and test/unit support baked in
they both have a dependency. 
I was surprised Ferret came out so far ahead of the others (except on that one test). I hadn't heard of it being 10x faster than sphinx before this.
How did this make it to front page?
[Read the blog.](http://reddit.com/blog/) They changed reddit to have hot items in your subreddits make it to the front page.
I think ramaze also has all those attributes and is better documented. Having said that.... I don't know why thread safe is important if you are not running it in a threaded environment (and I don't know anybody who is) Rails is constant getting faster and using less memory. Just recently somebody floated a series of patches that drastically reduced the memory footprint of rails. I am very confident those patches will be included in an upcoming release. Rails is pretty agnostic when it comes to ORMS and templating engines. At least all the popular ones have ways you can use them with rails. 
ruby-talk? #ruby-lang? off to their rooms to hack? i have to say i don't understand why you're asking this.
Obviously reddit is extremely hostile to ruby. Is there another web site where ruby coders go where they can talk about their language without being called douchebags and psycopaths? Maybe the mailing lists are enough for people. 
Yes I've noticed it too. When I first began reading reddit most of the language articles were centered around Lisp, with nods to Ruby, Python, Smalltalk and any other interesting language people could learn more about programming by taking a look at. I think this was the influence of Paul Graham, whose articles used to frequently reach the top page. Somewhere along the line the open enquiry of languages has switched to language pissing matches. It seems the community is less inclusive and explorative now. I miss the old reddit where programmers were interested in languages as a whole and weren't so territorial.
reddit was mostly lispers because it was written in lisp. It got re-written in python and attracted python programmers en masse. For a while there there was at least one obscure python library on the front page every day. Python programmers have a lot of hostility towards ruby programmers because ruby seemed to come out of nowhere and displaced their language as the next big thing. Ruby also is the "anti-python" in a lot of ways. It seems too loose, too malleable, too rowdy for the staid "there is only way to do it, submit your request in triplicate to the PEP committee" python community. It reminds me of the old guys complaining about the young whippersnappers and their new fangled rap music. Oooooh look ruby lets you monkeypatch!!!! That's crazy!!!! Oddly enough lisp guys know all about monkeypatching and dynamism. Those crazy mofos write mind bending macros and morph the language in ways that can only be described as an acid trip inside the 'it's a small world' ride in disneyland. 
I only read ruby reddit from time to time but I haven't noticed this at all.
We need our own reddit like site.
Python is a language for pedants. That's exactly why I like it. There's (almost) always one "correct" way of doing something, and when you do it that way, you get that warm glow in your heart that we pedants get when we outsmart someone or something. When it's like when you correct a teacher in class or find a grammar/spelling error in your opponent's message board post. That's why Python is "fun" for us. For Ruby heads, the fun is in solving the problem in some crazy idiosyncratic way that makes sense to you but seems backwards to everyone else. See the insane `andand` thingamajig that Raganwald invented. That's why Ruby includes an `unless` keyword, just in case. That's why Ruby has Why. So yeah, totally different communities for two remarkably similar languages. At that point, it becomes [the narcissism of small differences][1]. [1]: http://en.wikipedia.org/wiki/Narcissism_of_small_differences
Python is easy listening music, ruby is rock and roll. Python is classical music, ruby is jazz. BTW: if you think andand is insane try to read some Paul Graham macros.
Oh I forgot - merb can handle genuine multiple file uploads, too. I'll take a look at Ramaze, thanks. But yes, you're right, not every app or environment is going to feel the benefits of thread-safety! I've never had reason to chose Merb over RoR for a production app.
We are creating a new ruby! Here is what we did: We removed the best features from it and changed some internal implementation details. 
&gt;whereas Ruby often has many alternative ways of accomplishing the same effect, Sapphire aims to have one way of doing one thing. Are they building Python from the Ruby source?
Python is not a major influence. Smalltalk on the other hand.... :-)
Maybe they got sick of the sick proposals for how to gorilla-hack core classes that are posted to the ruby reddit.
And people wonder why Ruby is ”dying”. Simple, it’s becoming increasingly fragmented, with junk like this, referring to itself as ”sort of like Ruby, yet not quite Ruby”. How should a beginning Ruby programmer know where to start? I’m not saying that things like JRuby or Rubinius (the only really interesting implementation nowadays) aren’t good for Ruby, but I can definitely see how crap like this is.
While I have absolutely nothing against python, I would argue that there's often more than one way to "correctly" do something. if true puts 'here' end unless false puts 'here' end Both of these are equally correct; depending on context one will obviously be preferred over the other, but both are correct. I'd certainly argue your generalization that Rubyists want to solve problems in a "crazy idiosyncratic way", and that you could even define what's "backwards to everyone else".
I haven't really noticed this on proggit (heck, raganwald frequently posts ruby-based stuff, and he's one of the more popular bloggers out there), but anyway, the ruby subreddit could function well enough as its own community without attracting hostile posts.
Can I clarify. Sapphire is not Ruby. The syntax is based on Ruby. The methodology owes more to Smalltalk. If you want our guiding design principle encapsulated in a phrase it is: "Ruby the Smalltalk way." All new languages derive from languages which have preceded them. That does not necessarily mean either that all new languages are bad or that they adversely affect the preceding languages. best wishes Huw
Actually, so can rails. The file uploading is handled purely by mongrel, which is threaded and doesn't block the rails process. You only run into problems if you decide to perform some processing on the attachment (converting videos to FLV, uploading to S3). But, that's why there are various approaches to asynchronous queuing, like bj, backgroundrb, beanstalk, starling, etc. Being able to accept the uploads and return some response to the user quickly is a good practice.
no one wonders why ruby is dying, for the simple reason that no one thinks ruby is dying in the first place. perhaps you're thinking of freebsd.
Would it be more correct to say that Merb can handle multiple file uploads out of the box, whereas RoR needs integrating with some asynchoronous queuing system? Although I was aware backgroundrb et. al. was the way to go, I have to say the implementation details scare me. Maybe if someone could come up with an "awesome" and "easy" plugin... Ah crap, this thread has now eaten itself. EDIT: Actually, it's really quite simple isn't it! Anyone have any war stories about this?
Using unless is wrong.
I'm also guilty of thinking that you are trying to recreate Python's philosophy. Could you tell us, what would be the main difference between python and sapphire? I'm talking at philosophy level.
Thanks for your interest. It's a bit complicated to explain here but I'll be writing in depth about this on the Blog over the next few weeks. In short, Python has not been a significant influence on Sapphire. For one thing, Python's version of object orientation is pretty free-and-easy (very loose encapsulation, mixing OOP and procedural programming etc.) and that is not a characteristic of Sapphire. Our main impetus is Smalltalk. What we want to do is to bring the very rigorous version of OOP (for example, with very exacting encapsulation/data-hiding, a consistent message passing mechanism and various other things such as blocks always being objects) and implement this using a Ruby-like syntax. This necessarily means that we have had to jettison the absolute rigour of Smalltalk (for example, we won't insist that 'if' tests are done by sending messages such as ifTrue: and ifFalse: - we'll stick with Ruby's more familiar 'if' tests). Ruby was created primarily as a scripting language and, more recently, for web application logic. What we are doing is creating a language optimized for general purpose application development - that is, a language that can be used for the same sort of development as C#, Java or Delphi. As I say, I'll go into a lot more detail on the blog shortly. If you are interested in some of the ideas of Smalltalk which have motivateed the developmemt of Sapphire, you may like to take a look at a series of articles I wrote - "Ruby The Smalltalk Way" http://www.sapphiresteel.com/Ruby-The-Smalltalk-Way best wishes Huw
unless it's right. :)
Oh, you must mean [hikaru dorodango](http://www.dorodango.com/gallery.html).
From what I can see, instead of polluting every controller that needs to use a particular template with the instance variables that it needs, you can keep them self-contained in the Cell "controller".
looks like [Raganwald](http://weblog.raganwald.com/2008/03/acid-tripping-disneyland-and-special.html) enjoyed your thread :) 
No, but I'd love to hear what you find out, I'm currently building an app that needs to convert WAV to MP3 on the fly, without user interaction.
Which is bad because? Oh, no, let's exclude the new people, that's a successful way to build a software ecosystem.
Perhaps a more pertinent question - why turn Ruby into Smalltalk if you could just use Smalltalk?
yeah, this is even better than ror.reddit
It's faster.
I know the Ruby and Rails communities aren't the same, but ruby.reddit is already pretty low-volume. Is there really a need for another reddit?
This is not quite a case of turning Ruby "into" Smalltalk - but of providing many of the features of Smalltalk in a language with a Ruby-like syntax. Essentially, we want to create a fast, efficient, rigorously object oriented language that uses a syntax with while most programmers feel comfortable. Love Smalltalk though I do, I recognise the fact that its syntax is a huge turnoff for many people... and its uncompomising message-passing paradigmn is a barrier which people coming from other languages never stick around long enough to cross. Moreover, Smalltalk tends to be a world unto itself - living inside its own hermetic environment, saving images of its own state etc. That, on the whole, is simply not what most programmers want. Ruby is much more accessible to most people. However, its flexibility, fluidity, its lack of type assertions and various other features may make it wonderful for the kind of metaprogramming magic that Rails does, but not so great for the sort of applications typically created using a C-like language. Our aim is create a language which retains the accessibility of Ruby, adds type assertions (which, I stress, are *not* type declarations - Sapphire is just as duck-typed as Ruby but it has an additional type verification or 'contract' mechanism to spot potential errors at designtime) and implements additional Smalltalk-like safeguards such as strict encapsulation/data hiding. Put bluntly. I now do most of my development work in C#. I would rather do it in a language with the benefits of Ruby and Smalltalk. That language does not currently exist. So we are creating it :-)
&gt; off to their rooms to masturbate. Fixed that for you.
&gt; Obviously reddit is extremely hostile to ruby. Not true. But Reddit may be extremely hostile to Ruby/RoR fawing and gushing. Just as I am. 
&gt; Ruby was created primarily as a scripting language and, more recently, for web application logic. That sentence makes no sense. Ruby was created for general application dev. Some have chosen to use that for Web dev. Nothing has happen in the Ruby language to favor that interest. In fact, JRuby + Swing means I've been able to develop sweet cross-platform desktop apps with as much ease, and more pleasure, than Delphi or Java.
You misunderstand me. I'm not talking about new people to the Rails ecosystem. I'm talking about people new to web development. You know, the ones that are still coming to grips with HTML &amp; CSS, as well as server-side scripting. They have little or no idea how Rails does what Rails does, but they do know that they can start off a project using **script/generate scaffold**. Such people cannot contribute, for the simple reason that they don't know. They will also complain the loudest, since they expect that the plugins work just as well as the core Rails stuff. What I was saying is that Rails marketing is oriented towards those people. &gt; "Hey, look how easy it is to make a blog with Rails!" Complaining that such people should get off their collective asses and contribute is kinda ludicrous, don't you think?
That's true. I still think it's a good thing.
This might help: http://www.escapegoat.org/2007/8/26/video-conversion
Nifty, thanks. Is that on reddit yet? You should submit it. I'd upmod you.
Never ever going to pass up an upmod! It is now, but my reddit-fu is weak and I don't know how to link directly from here.
I will search it out and punish your karma for your intransigence in not linking it... kidding.
&gt;Not true. very true. &gt;But Reddit may be extremely hostile to Ruby/RoR fawing and gushing. But it is very enamoured of haskell, factor, python and lisp gushing and fawning. &gt;Just as I am. god forbid ruby or rails programmers say something nice about their programming language or framework. Why do you single out ruby fans for scorn? 
it would only be faster (I'm assuming you mean the amount of code you have to write) in the simple case. I often have something like this: render(:partial =&gt; 'shared/top_posts', :object =&gt; Post.top_posts) Using cells would make this more DRY, but what if the initialization is more complicated than? Post.top_posts What if the object the partial needs are generated differently depending on which page you are on? Do you use a big case statement in the cell?
I don't pollute the controller with that stuff. I usually grab it from a static method on the model. Something like render(:partial =&gt; 'shared/topPosts', :object =&gt; Post.topPosts) Let's assume we're talking about a social networking app and we have a partial for showing top-posts. If we are on the home page it shows the top-posts from everything. If we are on a users blog it will show their top posts, and if we are on a tag page it shows the top posts from the tag. How would this be handled with a single cell? This is very easy for me to handle with partials the way they currently work. #homepage render(:partial =&gt; 'shared/topPosts', :object =&gt; Post.topPosts) #users blog render(:partial =&gt; 'shared/topPosts', :object =&gt; @user.topPosts) #tag page render(:partial =&gt; 'shared/topPosts', :object =&gt; @tag.topPosts) This doesn't clutter up my controllers. p.s. - how do you keep code from getting screwed up by reddit?
&gt; god forbid ruby or rails programmers say something nice about their programming language or framework. Not at all. But that's not the whole story, and there is a good amount of tedious naive glee among recent Rubyists. &gt; Why do you single out ruby fans for scorn? Excuse me? I most certainly don't. Your bias is showing. Anyways, Rubyists playing the role of the poor scorned outsider is unbecoming. 
&gt;But that's not the whole story, and there is a good amount of tedious naive glee among recent Rubyists. show me. &gt;Anyways, Rubyists playing the role of the poor scorned outsider is unbecoming. calling people douchebags for not using your language is SO FUCKING AWESOME!!!! just like zed. as I said. show me a couple of posts by rubyists on reddit that got your panties in a wad. i am waiting. 
I never liked Ruby commands. It made me realize that syntax does matter, because it makes functions less than first-class in practice. OTOH, I always assumed that this was just one more duck typing direction that I was being fuddy about (you don't have to care if an attr is a method or a function, no under-under-getattr, etc.). Even more enforced object privacy - that surprises me, because Ruby's enforcement surprises me as a Pythonista. Put another way, how do Java developers write unit tests without Jython? Are your assertions/expectations intended to replace separate unit tests?
&gt; as I said. show me a couple of posts by rubyists on reddit that got your panties in a wad. Oh, the irony. It's why I love Reddit. &gt; i am waiting. Holding your breath, I hope. 
I guess you are unable to come up with any links. i think that makes you a liar.
A very worthwhile post about a worthwhile bit of hacking!
You're always welcome at http://jaanix.com/ruby and http://jaanix.com/rails 
Oh, I'm sorry, people must not like that. Let me fix it. &gt; off to their parents' basements to masturbate. There.
I agree. I would like the communities to stay somewhat separated but unfortunately ruby.reddit doesn't have enough volume to warrant it yet in my opinion.
twitter
Actually, I meant execution time. From the article: &gt; Cells make it simple to embed views within views, while maintaining the ability to have a controller that initializes those views and – very importantly – they are fast. In my testing, Cells rendered about 4 times faster than components and rendering 1,000 Cells within a view still netted sub-second response times in a development environment. So there is a clean code advantage of cells not sharing variables with the view, and then there is a speed difference. I just wish this were compatible with merb.
Still, I like being able to subscribe to the ruby reddit feed and avoid the rails-centric items.
I hack ruby and I find the backlash a little refreshing, really. I still love the language but it does have it's warts.
i read that, and maybe I'm misunderstanding it, but I thought he was saying that they are faster than components and slower than plain partials. components are something no one uses anymore, and were deprecated a while back. 
i've been doing rails fulltime for 3 years and I don't see much benefit in cells. There are a few narrow circumstances where cells are more DRY than partials, but in many other circumstances partials appear to be a cleaner option. You can check my comment above for an example. Maybe I'm missing something, but no one has articulated it yet. Btw, you can put partials inside of partials.
partials are tied to a specific controller no?
I'm already using this for a project. It makes things easy as hell to deal with REST. EDIT: Although it's weird to instansiate a new RestClient object every time you want to look at a new resource, although it's probably a correct interpretation of what's going on under the hood.
they are not. In one of my earlier comments you can see how I pass in the objects the partial needs to render. It seems that a lot of people that haven't used rails much assume you are supposed to setup the data for partials in the controller. You can do that, but you don't have too, and in my experience you don't in most cases.
Thanks for the info. I guess you learn something new every day.
that's what reddit is for :) 
You may be right on that. According to their sourceforge page, cells bring the speed of partials without the tight coupling. I doubt they are actually slower, but they're probably comparable. After looking at the documentation, I think merb has this as what they call parts.
Or, `if not False: print('here')`. I don't see the need for an extra keyword. But again, this is a matter of taste. Python people prefer the elegance of one `if` over the convenience of `if` + `unless`. 
I've wanted something like this for some time.
To create a website as ambitious as the one you described will certainly take longer than a spring break. That said I hope you create the site and I'm looking forward to using it / contributing.
Ruby's encapsulation/data hiding is 95% thorough. It's the other 5% we'll be dealing with :-) Python, in common with most other modern languages (C#, Java, Delphi, C++ etc.) has a variant of OOP that is quite far removed from the original version as implemented in Smalltalk. In Smalltalk, one of the fundamental principles is encapsulation with data-hiding. This is, if you like, the OOP version of modularity (as defined in Modula-2) in which the object data is inaccessible from 'the outside' and can only be manipulated via well-defined interfaces. In Smalltalk that means a message (a method-call plus data) can be sent to an object and the object then responds with 'an answer'. You cannot 'hold on' to any part of the message (for example, there is no equivalent of byref args) so that the implementation details of a method are completely isolated from the world outside the object. Sapphire will implement this kind of encapsulation for a high degree of modularity. Assertions won't necessarily replace tests as assertions will be optional. However, in those cases where there is a critical reliance upon the type of an arg/var/return value or its value within a range (let's say in some case a Fixnum between 1 and 100 is required) then an assertion will verify that value every time the code executes and will report if the value is not met. So that in many cases 'testing' becomes a standard part of the code-and-run process and will not require a separate 'testing cycle'. That doesn't mean that people won't be able to run unit tests etc. - just that most of the 'edge conditions' will have been trapped and fixed long before those tests are run.
Well, I'll give you an opinion and a recommendation both: [news.ycombinator](http://news.ycombinator.com/) is a good reddit-like site for programming discussions, and is generally much more ruby-friendly than proggit My sense as to the reason behind this is the ycombinator site attracts a high amount of people who are running or interested in running startups. Not only are startups these days using ruby a lot, but overall this leads to a fair amount of pragmatism in language choice Proggit seems much more focused on PL-enthusiasts. Not that it's devoid of real-world topics, but there's a real LtU flavor to the discussions. Ruby gets hated on in these discussions for a lot of reasons, many legitimate. Of course not the least of which is the way Rails &amp; its community sucked a lot of the oxygen from the cutting-edge web community for a long time For my money, both are worth a daily read
Yeah, I guess it's just hard for me to imagine anyone saying "I'll go to the beach if not it rains"
I see what you're saying, though maybe some folks would like to avoid rails-specific submissions?
If you're looking to see how Ruby figures out the size of your terminal, and if its output will fit on one screen, this isn't it; 'less' is doing the heavy lifting here.
(1..1000).parallel_map { |i| i * 10 } Just imagine what's going to happen there.
So, will Math.sqrt(-1) return i? And will all math ops with complex numbers be usable out of the box? I think that's kind of cool.
you talk to the programmer who is using the wrong tool for the job? i dunno, i'm not good with these trick questions...
I've subscribed to the blog to monitor your progress. It sounds interesting enough. Another question though: What about IronRuby + normal .NET libraries for writing windows programs? 
We already have a free IDE for the current alpha of IronRuby and will continue to support IronRuby (and our ironRuby IDE will continue to be free). The aim of IronRuby is complete compatibility with standard Ruby. Sapphire, as I've explained, will be a significantly different language. Our implementation of Sapphire will give access to the .NET class library. We haven't yet decided if we will support the IronRuby-specific class library too. That is not a fundamental goal of Sapphire but that decision will, in any case, have to wait until IronRuby itself is closer to completion. The design goals of Sapphire - and the differences between Sapphire and Ruby/IronRuby - should become clearer if you follow the blog over the next couple of months. best wishes Huw
It's not a trick question. I'm just pointing out that this implementation of parallel_map could very easily end up attempting to spawn thousands of threads, which is generally not a good idea.
my only point was similiar to flattening the earth because some one could jump off a cliff.. or removing "rm" because you could "rm -rf *" but i'm of the idea that a programing language should be able to give you enough rope to hang yourself.. so i think for the implementation he listed above, the parallel map makes perfect sense, in your example not so much. does that make it a bad tool? not exactly.. every tool's usefulness breaks down when you extend it beyond it's intended use. it's not a fault of the tool.
I kinda want to go down to the 'parallel map' thread and try to use that trick on rubygems...
The problem with parallel_map isn't that it's done with threads, it's that it's hiding the fact that it's done with threads. Using threads is fine, but it needs to limit the number of concurrent threads at once or some dumb client will end up spawning far too many.
RubyGems is great, and it felt snarky to complain, but indeed the wait while the index is rebuilt has gotten surreal. I pondered a cron job that would simply re-install some random gem in the background just so that the index would stay somewhat current.
I plan to submit a patch now... unless there already is one. Threading the fetches seems to work nicely, it's going through all 11831 gems in a couple of minutes (on my machine, at least!) Edit: Patch submitted. You can use it now: /lib/rubygems/config_file.rb:17: - DEFAULT_BULK_THRESHOLD = 1000 + DEFAULT_BULK_THRESHOLD = 100 Or, if you don't like that for some reason, you can thread the fetches like so (shitty formatting, sorry) /lib/rubygems/source_index.rb:418: def update_with_missing(source_uri, missing_names) progress = ui.progress_reporter(missing_names.size, "Updating metadata for #{missing_names.size} gems from #{source_uri}") missing_names.each do |spec_name| + Thread.new(spec_name) do |new_spec_name| - gemspec = fetch_single_spec(source_uri, spec_name) + gemspec = fetch_single_spec(source_uri, new_spec_name) if gemspec.nil? then - ui.say "Failed to download spec #{spec_name} from #{source_uri}:\n" \ + ui.say "Failed to download spec #{new_spec_name} from #{source_uri}:\n" \ "\t#{@fetch_error.message}" else add_spec gemspec - progress.updated spec_name + progress.updated new_spec_name end + end @fetch_error = nil end progress.done progress.count end
I've already helped Eric apply a patch to speed up gems to "normal" levels by using persistent connections to fetch spec files. I just posted this on reddit because Eric has been sitting on the release, and I wanted to give him a hard time. :-)
Good, mine is a bad hack :)
&gt;it's that it's hiding the fact that it's done with threads. How exactly is it hiding that fact? You can read the source right? If it was trying to hide it, it failed miserably because you, I and everybody who reads this knows.
Do you read the source of every library you use? I don't think so. The problem here is that the API gives no hint that it's a bad idea to call it with a large array. If the method was named #threaded_map I wouldn't have a problem, but it's named #parallel_map. The only way to know that it's a bad idea to call it on a large array is to read the source. That's what I mean by hiding.
You can pass the --no-update-source option if you're OK with not having the latest metadata.
&gt;Do you read the source of every library you use? I don't think so. this is not in the library. It's not available as a gem. The only way to get it is to copy the source code and paste it into your application. &gt;The problem here is that the API gives no hint that it's a bad idea to call it with a large array. What api? It's nine lines of code. &gt;If the method was named #threadedmap I wouldn't have a problem, but it's named #parallelmap. The only way to know that it's a bad idea to call it on a large array is to read the source. That's what I mean by hiding. Or you can read the nine lines of code you just cut and pasted into your application. I am just saying that the ONLY way to know is not the run the code with a million elements. There are other ways of knowing. You know.... BY READING NINE LINES FUCKING OF CODE. 
Yes, fortunately for my sanity and unfortunately for other peoples' enlightenment, that is true. However, when I was figuring out how to make this, mugwump on #git had this to say: &gt; the IOCGWINSZ ioctl is what [less] uses to find out how big the terminal is as controlled via stty(1) and SIGWINCH
Apparently you lack the ability to think about the future. Assuming parallel_map is actually useful, you don't think it will be packaged up as a gem? Once that happens, people will start installing it without ever looking at the source. And once that happens, people will start running it on large arrays, not realizing that they're spawning thousands upon thousands of threads. Always gotta think about what *could* be done with a piece of code, not what the code is now. If everybody did this, there wouldn't be so many buffer overflows and security exploits floating around.
&gt;Apparently you lack the ability to think about the future. Assuming parallel_map is actually useful, you don't think it will be packaged up as a gem? Perhaps you should start whining about that when and if it happens. &gt;nce that happens, people will start installing it without ever looking at the source. And once that happens, people will start running it on large arrays, not realizing that they're spawning thousands upon thousands of threads. Again perhaps this is the wrong time to get your panties in a wad about this. &gt;Always gotta think about what could be done with a piece of code, not what the code is now. If everybody did this, there wouldn't be so many buffer overflows and security exploits floating around. This is an excellent argument for removing threading from all computer languages. 
Because it's not grammatical, not because it's a strange idea. "I'll go to the beach if it doesn't rain." Anyway, `if not` is 6 characters, and `unless` is 6 characters. It's not a debate worth having; it's a philosophy difference. Matz wants options. Guido wants consistency. 
irb(main):001:0&gt; Math.sqrt(-1) Errno::EDOM: Numerical argument out of domain - sqrt irb(main):002:0&gt; require 'complex' irb(main):003:0&gt; Math.sqrt(-1) =&gt; Complex(0, 1.0) 
uber ghetto hack esta aqui: http://s3.amazonaws.com/giles/gems_hack_031908/metadata.gif 
balls. my hack doesn't work.
If you're gonna pull data out of your database in the view, then why bother with an MVC framework at all?
You don't need a list of big companies who use rails. All you need to know how awesome rails is to point at the fact that Zed Shaw leads a team of rails programmers at the investment bank where he is the vice president. think about it. * An investment bank is responsible for hundreds of millions of dollars. They trust ruby and rails with all that money. * Zed Shaw is AWESOME!!!! (he says so right there on his blog) * Zed Shaw hates ruby, hates rails, and hates everybody who uses ruby and rails. * Zed Shaw loves python and factor. So a person who hates ruby and rails uses ruby and rails to conduct business at an investment with hundreds of millions of dollars at stake. The person would much rather use python or factor but is unable to because (obviously) rails is a much better tool for the task. How much more of an endorsement can there be? 
Downmod for describing default timestamps as sexy.
Besides, shouldn't this go to http://reddit.com/r/rails ?
`wget #{urlname} &gt; #{filename}` ?
Boy would I hate to get stuck in an infinite loop in that app.
You can just set the bulk threshold to 1, mate, that'll do the trick.
the data is being pulled out in the model, not the view. Here's an example. Let's say we're talking about a blog and in the controller for showing a post we setup @post Then in the view we do something like: @post.comments.each { |c| ... } Would you not call .comments() in the view because it's "pulling data out of yoru database in the view"? I'm guessing that you wouldn't setup the comments in the controller, and I don't see a different between calling @post.comments vs @tag.topPosts and, I don't think this is breaking mvc
[citation needed]
reddit.com 
God...I love Ruby. I'm pretty much a dynamic language weeny, but I mean, this is just masturbatory self-congratulation. We are Ruby programmers. You know, just saying, we reign supreme. What do you use, Java? You probably never even heard of closures. Like, Ruby would totally be selling out to the mainstream if a lot of people were using it, then it would suck, and we would all move on to something way cooler that you probably never heard of, like Dylan on Dicks. We need to wake up to that it is a *perfectly valid* argument from an IT manager that you don't want to deal with social restrictions on monkeypatching and missing_method, that the runtime sucks, that they want developers who are like interchangeable parts and don't always yammer on about how we should be adopting some new technology with way less tools and support and libraries and application servers &amp;tc. that I have to hire some hotshot pain in the ass programmers to write. The idea that our language is just *too powerful* is not helpful. Isn't the whole idea behind Rails that it makes web development, which is notoriously boring and repetitive, pleasant for everyone? He even cites Yegge on bashing Java. Here's a newsflash -- Yegge spends most of his time programming in Java. He is not allowed to use Ruby or Lisp. Clearly because Google hates powerful languages. All the blubs there like Joshua Bloch and Neil Gafter are only competent enough to use Java...That came out longer than I wanted it to be...
Wow, you should ensure that it's the article you want to comment on before hitting the "comment" button.
To whomever down-voted: Might be better to simply explain why I'm wrong, given that there exists a Rails subreddit and this is a pure-Rails post.
&gt; Simply put, Ruby the language is much too powerful for the mainstream &gt; The reason powerful languages fail is simple. Big enterprise does not want them. &gt; No slight against the top Java developers, but there are millions of Java developers and by definition most of them are average.) &gt; Part of the appeal Ruby and Rails have is that they’re on the cutting edge. The moment there’s an “R2EE” out there will probably mark the beginning of the end for many. Time to look for a new language and framework. &gt; For a hilarious look at Java, check out Steve Yegge’s Execution in the Kingdom of Nouns &gt; "Super star" developers are like property snobs. Once enough "mainstream" programmers get on the Rails bandwagon (if this ever happens), those "super star" developers will engage in a developer variation of "white flight." Nope...that's the article I wanted to reply to, thanks.
"It is important to realize this does not mean that Ferret is fastest overall. It means that Ferret is fastest for small datasets where the constant socket overhead dwarfs the logarithmic actual lookup overhead."
From the moderation level of your comment, it would appear you're trying to push a large rock up a slippery hill.
Thanks for the submission :) 
Umm, it requires the carrier to be known and just sends an email to that carrier's email-&gt;sms gateway. That's not really sending text messages, IMO.
Maybe not, but if it works .... don't fix it!
If you want to use a gateway, check out my article here: http://www.lukeredpath.co.uk/2007/8/29/sending-sms-messages-from-your-rails-application 
Neither of them are re-implementations. [One of them](http://www.sapphire-lang.org/) is a fork and [the other](http://www.sapphiresteel.com/The-Sapphire-Language) is a Smalltalk like language influenced by Ruby.
this is brilliant. please post more!
not exactly the same thing, but... http://pastie.caboo.se/169681 edit: did the pastie link formatting change in the last 2 hours? that link throws an app error now, but this one works: http://pastie.caboo.se/pastes/169681 weird.
Wow. That was awesome! I'll include it in the follow-up :-)
Alright, guys! I'm giving you two days to come up with some awesome haiku :)
sweet, thanks :D 
Not really a Jaiku, but rather rubyish: question = !!(:to_be or not :to_be) - Shakespeare.rb :-)
You should indent it with four spaces :-) question = !!(:to_be or not :to_be)
Or use backticks `so you can do_it in_line.`
heyo, me again. i wrote that thing forever ago. saw your post and thought i would share. well, i started looking at it and, as happens with old code that suddenly becomes shiny again, i thought "i could do that better" (read: more complicated, but cooler because i think so) simple: http://pastie.caboo.se/170102 complicated: http://pastie.caboo.se/170024 so that was a fun. ruby is fun. you can link me http://rubyforge.org/users/whatevan/ if you end up posting it. 
The classic regexp: /bb|[^b]{2}/
 class RubyOnRails has_many :features, :through =&gt; :bugs end ##Haiku model 
I can't believe people still care about crap like this. Rails won. Start making apps already.
Oh... Bear-Stearns'd!
Kinda surprised it couldn't generate GET parameters from a hash for me.
So I have to ask; what's Hoodwink'd?
http://hoodwinkd.hobix.com/
I went there but I can't read anything. I promise I won't tell. Mums the word.
Whoa. Awesome! Thanks man. *Holy crap.
sigh. the internet is terrible at keeping secrets.
 if x then x else x = y end Hmm? Equivalent to the `x or x = y`, yes?
Half the fun is figuring it out.
x or x = y, ftfa, but yea. same thing.
I submit the opposite hypothesis: He updated the repo but did not run the migrations?
On the mac. I guess the title leaves that bit out for dramatic effect.
He didn't figure it out until after posting. It wasn't deliberate.
&gt; I guess the title leaves that bit out for dramatic effect. No, it doesn't. The fact that it was a Mac only issue was discovered a few hours after publishing the initial post. Why is his comment being upvoted? I assume people believe him without even reading the article, but not everything has to be a conspiracy or a deliberate trick.
It's a good article although the conclusion isn't totally correct. I wrote up a quick blog post showing the correct [short circuit expansion](http://procnew.com/ruby-short-circuit-edge-case-response.html).
The repo last updated a year ago...
The post and comments are narrowing in on the changes that seem to have caused the slow down (http://pastie.caboo.se/170751). Yay open source!
Actually, the conclusion is correct; it's just that it didn't mention that the expanded expanded expression is isolated (as if it were surrounded by parenthesis), but really, that is quite the expected. So, a more explicit expansion would be `(x || (x = (y)))`, where `||` and `or` are effectively the same, since no precedence rules are involved. That said, `x || x = y` (literally, without the parenthesis I mentioned above) is not fully correct either, as this simple experiment demonstrates: x = nil y = 1 + x || x = 10 # TypeError: nil can't be coerced into Fixnum y = 1 + x ||= 10 # =&gt; 11
Basically yes, just remember this will evaluate `x` twice in case it is true. This is important when `x` is actually `x[stuff]` or `x.stuff`, as both are full method calls.
Someone suggested resubmitting to the ruby subreddit, which I had no idea existed.
Nice to see a comparison that's not slanted or flame-throwing. Unfortunately, while the presentation prominently features the Admin advantage from Django, it fails to mention that AjaxScaffold (and several others) provide similar (or more) functionality for Rails. Having said that, most sites need a more customized Admin interface than provided by either Django or AjaxScaffold and the like, so the advantage provided by either is more likely to be leveraged only while prototyping or as a "extra".
I was just thinking the same thing. AjaxScaffold and Streamlined save you tons of time not only implementing admin screens but also all parts of your view (if you choose). I think the wealth of plug ins makes a huge difference and I am surprised they didn't get a mention.
No. You can't write COM objects with ruby. Reacting to events raised by COM objects is not documented at all doesn't seem to work all that great. 
Does *anyone* still use Windows? 
Completely agree with you on the plugins. There are quite a few plugins that are much more widely used (and useful) than a basic admin interface. 
There is also a schema evolution tool that works reasonably well for Django. Their conclusion seems right to me -- if you already know Ruby but not Python, just use Rails, and vice versa. You'll probably be much much happier with either of them than anything else you've used to do web development before.
I don't think any of the ruby core comitters use windows. Also many if not most of the library maintainers don't either. I just don't think windows is a priority for them and I don't see anything wrong with that. 
Down-voted for ignorant use of term "monkeypatching".
Agreed. I wouldn't be surpised if JRuby ended up being the best way to use Ruby for Windows.
Are you Paul Graham's puppet account? 
or iron ruby if they ever get it to a usable state. 
oh, i forgot about iron ruby. i think you're right, usable iron ruby will be preferred to jruby for windows.
The pace of development seems glacial on that one though. MS effort seems a little half hearted.
Why does he have to be someone's puppet? Unless your job is writing software specifically for Windows, I'm really not sure why anyone would choose to use a Windows box as there development machine of choice. 
I think time-to-implement would be heavily dependent on the authors experience with the framework. On top of that some coders are just plain faster than others. I appreciate the results but I found the most helpful part to be the conclusions. The time-to-implement is so variable that I can't declare a clear winner.
And there are plenty of people who write software specifically for Windows. Why should they be left out?
As soon as I saw how fat their controllers were compared to their models (in Rails), it pretty much negated any conclusions for me.
that is because ||= is a method, while || is not. so what you were asking it to evaluate is: (1+x) || (x=10), the first half of which throws an error. in order for those two statements to be equivalent, you must say: 1 + (x || x = 10) #=&gt; 11 you are merely re-defining 1+x (a member with a failure) as a substitute for x. 
&gt; that is because ||= is a method, while || is not. Huh? I've never heard of that. Got any related link? &gt; (1+x) || (x=10), the first half of which throws an error. in order for those two statements to be equivalent, you must say: &gt; &gt; 1 + (x || x = 10) #=&gt; 11 …and that's exactly my point: that, once you add the parenthesis, there's no difference at all between using `or` or `||`, making his argument that the conclusion is not correct pointless.
It could have been really good, they are just so very few people on the Ruby subreddit. Oh well, thanks for including my haiku!
i wish i was more creative to come up with something clever &lt;3 ruby anyways
that's not necessarily true. x[stuff] and x[stuff]= are two separate methods, so the x[stuff] is not getting run twice. The same goes for x.stuff and x.stuff=
http://www.zenspider.com/Languages/Ruby/QuickRef.html#22 but i realize only later this doesn't make an explicit statement about ||= at all. so, my claim of method vs. keyword is probably false. &gt; his argument that the conclusion is not correct pointless. i agree with you here. its your experiment i disagree with. i see what you are saying, but think you are comparing two non-equivalent things to draw conclusions about them as if they were equivalent. 
I've read an awful lot of definitions of that term over the past few weeks. I believe my usage is consistent with consensus usage: non-local dynamic class modification, particularly method redefinition. What's your definition?
This is a fairly ancient comparison, at least on the Rails side. They claim Rails 1.1.6 is the latest version in a slide towards the end. Rails 1.2.5 is actually the latest production version of the 1.0 branch and 2.0.2 is really the latest production version. Django, on the other hand, was at 0.95 when these slides were made and now offers a production version of 0.96.1.
I've been wanting this for so long. Suffice to just check if a field has changed or not, that'd be enough for me.
I'm talking about when `x.stuff` *is true*. That results in... if x.stuff then x.stuff else x.stuff = y end See how `x.stuff` is called twice *when the true branch runs*? Not much of a problem for a variable (possibly completely negligible, depending on the implementation), but more serious for methods.
I'm aware they are different, but the whole point was to show *exactly that* to the post I replied to.
IMHO it should be good enough that windows devs who are curious and like to learn new languages (the kind of devs you actually want but seem to be the minority in MS land) get tempted to install it and learn about the culture of Free Software. But it shouldn't be good enough for them to be comfortable staying on that platform. Actually, I suspect that's about where it is now. Problem solved.
Oh, I see the confusion. As you correctly point out in another comment below, the original commenter gave an incorrect expansion. Since the actual implementation is (x || (x = (y))), x is only called once. If x returns nil or false, then x.=(y) is called, also only once.
Not the first (or second) time I've seen a #not method suggested, but this is definitely the best name I've seen for it!
Fixed.
More support for "unless" http://reddit.com/info/6cgyk/comments/c03h5oe
Ruby's standard library RSS parser is *really* poor. Anyone doing real work with feeds would be better off using a real library like feed_normalizer or rfeedparser.
Well I have been told that the next version of Rails 2.1 will include methods to see if something has changed. There is a link to the code in one of the comments. Really this code just grew out of the need to have more optimized UPDATE statements.
Works sometimes, but often I just prefer not having to change the names in the other files. Kind of a trade-off.
Does jruby support OLE? Could test it myself of course. I rely on ruby support for vim. If this connection breaks, I'd rather switch to python. For me, jruby is no full replacement. I'd consider good windows support essential. I personally use cygwin ruby but this doesn't integrate well with other windows apps. 
Don't know about OLE. I use vim for Python but the Netbeans support for JRuby and Ruby is very good so I've been using it more and more.
Plugin that does exactly that, written by a rails core member: http://code.bitsweat.net/svn/dirty/README 
If anyone has comments on this or alternate techniques, please let me know!
For me, it seems like this is something that's best left to a custom finder using SQL. I'd guess that pulling all of the id's into Ruby is doable, but given a large amount of records it could have some performance impact. At the very least, I'd think it would be quicker than this implementation if you just perform a DB-specific random select.
 SELECT .. ORDER BY RAND() LIMIT 1; It has the same time and space complexity as selecting all the ID's (since it generates a random value for each row), but happens entirely in the database, so is probably going to be more effecient. There will be some bias if two rows generate the same random value, but probably not enough to matter. If your table doesn't have holes in it (or the holes give an acceptable level of bias), you can just select MIN/MAX(id) and make a random value in the range. If you do have holes, but don't mind if deletes are expensive, you can have an additional column with an incrementing value, and re-pack them on delete to avoid holes; you can of course delay this if you don't mind a bit of bias.
ORDER BY RAND() is mysql only, IIRC. Anyway, even if it's moving it to the database, ORDER BY RAND() is extremely slow, particularly for large datasets. [Here's a discussion on the diverse methods of selecting random records, with benchmarks](http://jan.kneschke.de/projects/mysql/order-by-rand/)
I haven't done any benchmarking myself, but I remember reading this in a few places. It seemed easier to use Ruby/Rails for the randomization, rather than writing custom SQL for all DBs and (possibly) not getting a performance boost in any case. 
Keep an out for the Ruby Internals talk. The internals talk was true Ruby tech, essential information for grokking Ruby. (Basically, if you understand that, you can skip listening to people preach about dangerous open classes, evil meta-programming, and such, and get on with thinking for yourself and writing the code appropriate to your needs.) 
I think the whole idea of code smells is pretty dumb. I gag a little even saying the phrase. This example is pretty trivial, too.
Maybe the phrase is dumb, but could you explain why the concept it points to is dumb? "Code smells" are basically explicit heuristics which help you figure out what's wrong with your code - could you explain how that's dumb, and what a not-dumb alternative would be?
I just noticed that you posted your comment within a minute of the article being posted. I doubt that you actually read it enough to determine whether the example is "pretty trivial", so I'm downvoting your comment.
Hadn't seen Class#to_proc before. Very cool :)
I second that. The Ruby Internals talk by Patrick Farley was awesome. Everything becomes easier to understand once you start seeing what's under the covers/hood.
I read the code, I looked at his statements. I read around thousand words a minute. Did he write more than a thousand words? This was a boring issue of nomenclature, and he decided it would be better to trade conciseness for accuracy. This is not news.
I'm not saying the idea of heuristics and static analysis (whether human or machine) is dumb, I'm saying the phrase 'Code Smells' makes me vomit a little in the back of my throat. They could call it antipatterns or bad code structure or shitty examples or anything else and it would be good. Another classic example of nomenclature being the problem, rather apropos, really.
my only suggestion would be to move it up into ActiveRecord::Base (or, better yet, a subclass that superclasses your models) and use class.table_name in the query instead of hard-coding
I see what you're saying, in a way it does look like a mundane issue of nomenclature. It did not seem like a conciseness/accuracy tradeoff to me, though. It seemed more about being able to identify a specific, somewhat difficult naming problem, which is when a term strongly *seems* accurate, but actually isn't. (The original name was not chosen for its conciseness, but because it at first seemed like the most appropriate name.) He then gives a name for that kind of problem to help identify the problem, which in my opinion is helpful.
Your solution works for small tables. However, having recently had to pull random records from a table of 800,000, putting all the integers into a ruby array turned out to be a very bad idea and would eat up all the memory on my server in no time. Freeky's second solution is the correct one in my case. Since I dont mind deletes being an expensive operation as they happen infrequently, I created a column called sequential_order and made sure there were never any holes in it. Then its as simple as picking a random number between 0 and size(), and querying the db for the sequential_order match.
Interesting... If you have any example code, please do share. I'm interested in hearing how you make sure there are no holes in the sequential_order column. It also sounds like the sort of thing that would make a great candidate for a plugin...?
This is a really good example of why it scares me that Ruby is so closely associated with Rails, and that DHH and Co. could be seen as being as emblematic as Matz, which is sad, because everything I've seen from Matz says he's a really smart and decent guy. This article though... First off, in Plato you have to have a mystical experience to get 'out of the cave' and whatnot, which seems actually appropriate to the tone a lot of people take when writing about Rails. &gt; as larger and larger numbers of programmers adopt a particular skill, that skill becomes more and more a commodity. Rails development becoming a commodity is really not in the economic interest of any Rails developer. People keep saying this, but last I looked Java programmers, the ultimate commodity skill set, are still getting paid pretty well. &gt; But this means there's actually a very good use for angry outbursts like Obie's, and for taking a confrontational attitude in general. Incompetent programmers are already too common in the Rails community. Laughable. "I'm not an asshole, I'm just trying to protect the integrity of the Rails community from shitty coders." Right. Apparently Rails programmers also know that most clients are not worthy of them and their way of making websites. And they like it that way. If you don't get it, you can just fuck off. No, literally, we'll tell you to fuck off. Because we're not just a bunch of guys with a nice way to make websites, WE'RE ROCK STARS WITH FAT POCKETS. Seriously...just, fuck.
This will be far more interesting when mod_rails is available for actual use. One question that was not answered (that I could see) was whether mod_rails offers the sort of security enhancement that mongrel provides simply by rejecting invalid HTTP requests. I'm not a huge fan of the pile-of-proxied-processes model, but it is a legitimate benefit of Mongrel's. 
Here's the deal. I have a RESTful application. I have nested routes that look like this: map.resources :inventories do |inventories| inventories.resources :images end I'm working on a two-part form the second half of which adds images to inventories. The problem is the id parameter is being passed to the action parameter and all their heads are blowing off. I'm getting the following error: Processing InventoriesController#8 (for 127.0.0.1 at 2008-03-31 13:41:35) [GET] Session ID: BAh7BiIKZmxhc2hJQzonQWN0aW9uQ29udHJvbGxlcjo6Rmxhc2g6OkZsYXNo%0ASGFzaHsABjoKQHVzZWR7AA%3D%3D--2b95097204dc2e1dadb3c940a28f99475762200e Parameters: {"commit"=&gt;"Create", "format"=&gt;"js", "action"=&gt;"8", "id"=&gt;"images", "controller"=&gt;"inventories", "image"=&gt;{"image"=&gt;"images.jpeg"}} ActionController::UnknownAction (No action responded to 8): But here's the thing my routes are right, I checked. inventory_images GET /inventories/:inventory_id/images {:action=&gt;"index", :controller=&gt;"images"} And my form has the following: &lt;% form_for(:image, :url =&gt; inventory_images_path(params[:inventory_id]) + ".js", :html =&gt; { :multipart =&gt; true, :target =&gt; 'upload_frame', :method =&gt; :get}) do |form| %&gt; &lt;%= render(:partial =&gt; '/images/form', :object =&gt; form) %&gt; &lt;% end %&gt; Please help, I'm on the edge of insanity here guys. 
Why not post your question to the RubyOnRails list? Google Groups has a great interface.
I have. I also posted it on workingwithrails and a few other sites. However, I, after a day have yet to receive any response. I understand this isn't what Reddit's for, I just figured I could get an answer faster.
Post your generated source, just curious to see the form action. Are you trying to upload and image using ajax? because you cant do that. 
Why is your form adding the + ".js"? 
But you can fake ajax file upload using the iframe remoting pattern. Some [links](http://del.icio.us/tjstankus/ajax%2Bfile_upload) should help.
Yes I am, but I am using responds_to_parent plugin to get around that. It works when the route isn't nested. *Okay it was in my routes.rb file. The old school mapping was catching my route before my new maps could get to it. Thanks for the help guys.
What I actually *said* was that you should tell *framework developers who lie about you* to fuck off. I didn't say anything about *clients*. You're kind of adding something into it and then calling me an asshole based on this additional thing which I didn't actually *say*. Anyway, in terms of Java developers getting paid well, go to Estonia and India to find out how well Java developers are paid on average. Better yet, watch your job go there *without you*. 
also, I never said I wasn't an asshole. and Obie *was* protecting our community from bad coders. framework developers who don't bother to determine whether or not the remarks which they make about other frameworks are actually even *true* are poisonous to the developer community because they spread *FUD*. if telling a liar to fuck off makes me an asshole, then I'm *happy* to be that asshole. more than happy.
in a table with more then 10,000 rows you can see the lights dim when your run that command
okay fair enough. perhaps i misinterpreted this bit: &gt; If you alienate developers who don't do their due diligence when developing their opinions, you separate yourself from the segment of the market which they dominate. This is a good idea. The segment of the market dominated by programmers who don't bother with due diligence is the segment of the market which serves employers who don't value due diligence. Those are employers to avoid.
Just curious: why not fix/improve mod_ruby?
&gt; Incompetent programmers are already too common in the Rails community. Anything which keeps more of them out is a good thing, and telling them to fuck off is a pretty good way to start a conversation with them. And yet a big selling point for Rails has been that one need not be all that skilled to get up and running; much of the heavy lifting has been done for you. You can't say that something is stupid simple to use, then complain that stupid simple people show up to use it. 
BTW, blogs are often no better than conferences when it comes to narrow world views and chummy commenting. Asking pointed questions on someone's blog about unsubstantiated assertions is rarely met with an effusion of good, stimulating comment threads. 
So let me make sure I follow the logic: we are so productive with Rails that we don't need reasoned discussion, because it's easier to tell people to fuck off? So, instead of having a story about how Rails scales just be abrasive, because after all, being palatable to people who might want to adopt Rails might drive wider adoption of Rails among non-'rock stars', which would commoditize it, and drive all of the Rails work to India and Estonia and such, depressing the wages of all the current Rails programmers. Furthermore, closemindedness and arrogance are bad...but for Rails "you have to be careful when you bring the light of the real world to dwellers inside the Cave", which of course doesn't sound arrogant or closeminded at all... aside from that, before it seemed like you wanted them to stay in the cave where they won't commoditize your business model. Which is it? Or, like Plato, only the few elect who are worthy of contemplating the Form of the Good, er Form of the Rails should be enlightened? 
The average salary for a programmer here in Uruguay is about US $8000 per year. Usually a salary of 25-30k per year is about the most you can aspire to in here, and that usually means you will be leading at least a team. There are the odd few who don't follow that scale, but again, they are odd :)
&gt; So let me make sure I follow the logic: we are so &gt; productive with Rails that we don't need reasoned &gt; discussion, because it's easier to tell people to fuck off? Look, would you rather I just printed a Rohrschach blot with some profanity and allowed you to just pin any random association between Rails and profanity to that Rohrschach blot? I was talking about a specific event where alleged framework experts said things which were poorly reasoned and untrue. Obie bears some responsibility for making the event vituperative but you're really kind of taking things out of context here.
well, in fairness, it was a specific event, and it was more commentary on the event than a general attitude to the world at large. I mean when I said developers who don't do due diligence I was speaking about particular individuals on this panel who really just rose to Obie's bait with uninformed statements. In fairness Obie was picking a fight but I'm glad to take sides in that fight, although today, I'm starting to think the whole thing was a mistake. I think the reason there's such conflict between Rails and J2EE is that Rails is a disruptive technology. Rails is so much more effective than J2EE that it makes a different type of Web app marketplace possible and inevitable. I think the real problem is that comparing Rails to J2EE is comparing horse-drawn buggies to cars, and it's probably a lot better to build an interstate highway system than it is to waste any more time arguing with people who are stuck in the past and unwilling to even back up their criticisms with accurate, up-to-date information. However, at the time, I felt that Obie was justified in the fight he was picking, at least to some extent.
Well yeah. That's the problem with Rails. DHH made an incredible power tool but he marketed it to monkeys.
Getting any kind of intelligent discussion around a controversial subject is a whole art form in itself. In fairness to the panel, most of the criticisms against Rails were not unfounded BS. Some of them were, but some of them were legitimate criticisms. It was an intense discussion, and there were times when it degenerated almost to name-calling, but it was an intelligent discussion as well, and had some worthwhile moments. Or at least I like to remember it that way. ;-)
[Explanation here](http://izumi.plan99.net/blog/index.php/2008/03/27/passenger-and-other-ruby-frameworks/)
Do think that was intentional? I don't; I think the goal was to attract disaffected Javaheads, but it seems that little effort was made to dissuade the hordes of barely-skilled-enough-for-PHP coders and the frothing of fanbois. Basically, the sales pitch came with zero caveats, and there was no expectations management.
Thanks.
Hi Apathy, As you may have already read, that day will come real soon. We're just really waiting for the test results to come in from our beta testers and that shouldn't take too long now. Concerning your question about security, all HTTP requests for Passenger need to pass through the industry standard Apache ;) Needless to say, we've also tested this exhaustively and Apache seems to pass this test with flying colors. That's not to say however about some other popular webservers that we've also tested, and we'll be posting a detailed article on this in the next following days. So be sure to check up. With kind regards we are, Hongli Lai (http://izumi.plan99.net/blog) Ninh Bui (http://ninh.nl/blog) - Phusion.nl
bueno, gracias
no, I don't think it was intentional. but I think the monkeys are kind of a necessary evil, or an unpleasant but tolerable side effect. DHH did a pretty amazing job marketing Rails. the adoption curve is through the freaking roof and went that far almost instantly. (btw I wanted to say hi at MWRC.) anyway - I know I'm contradicting myself here but I think the presence of people who can't code that brilliantly is actually a good thing. I don't mean drawing in programmers who are bad - I mean designers and business types who look at the code, figure it's easy enough for them, and jump in. I don't know if it's intentional or not but I think newbies who build apps in Rails because it's so easy, or appears to be so easy, in that context making things easy is really a very good thing. attracting corner-cutting types is bad; attracting people from other fields who realize they can do at least basic sketch versions of Web apps in Rails probably makes the community pretty healthy. it's good to have that kind of diversity. I can't blame people who are new to coding for being less skillful than people with experience, that's practically a tautology, but I think in the long run the designers and suits sketching their own apps add enough to the community that suffering through the inanities of the PHP monkeys and the fanboys isn't such a terrible ordeal. and honestly I really don't think DHH was *necessarily* selling the fact that you don't need to be skilled to get it going, etc. It's possible that he was selling the fact that you don't have to do anything useless, or repetitive, or trivial and tiresome. When you see somebody selling simple, that isn't really the same thing as selling easy. And Rails doesn't really do a whole lot of the *heavy* lifting for you, as you say above; it's more that it does the *boring* lifting. Writing SQL queries and boilerplate JavaScript is something you hand to a code generator because it's dead-dumb easy, so much so that a computer could do it and should. This is like my talk at MWRC. Nothing in that talk was *actually* complicated. The power comes from *leveraging* it. The technique consists of four things: puts, eval, ERB, and the ability to pipe Unix standard out into a file. Do these things in a particular order and they become quite powerful, but none of them is complex in and of themselves. Boilerplate code of any variety fits code generation really well, but the win isn't that the complexity disappears. What's complex doesn't become easy, but its complexity does become very easy *to manage*. I think this distinction between simple and easy is a pretty subtle distinction. it's pretty natural that advertizing simple gets you a ton of people who were looking for easy. the overabundance of lazy fuckers is certainly annoying, but it could be worse. we could have an overabundance of curly braces. that shit would be murder. 
I'm looking forward to it. One of the things that really turned me off about Rails was how much of a pain in the ass it was to set up Radiant the way I wanted it. Should have been very simple, but it was a pain in the ass, especially since I was hacking on it while learning the setup. Eventually I scrapped it, went with Drupal, and the client was much happier anyways. Every now and then I get an itch to play with Rails for a tightly-defined project, and I think this will push me over the edge, along with a great many other fence-sitters. I like having a number of sharp tools for any given job; right now, Django and Drupal are my favorites, but I can see Rails moving in for some tasks with mod_rails on the horizon. You guys chose a great project to work on. 
&gt;Laughable. "I'm not an asshole, I'm just trying to protect the integrity of the Rails community from shitty coders." Right. There are no bigger assholes than people who shit on frameworks and languages they don't use. 
&gt;So, instead of having a story about how Rails scales just be abrasive, How many articles about scaling rails do you want for god's sake? We have had all kinds of articles showing how real life rails applications can scale up to tens of millions of hits per day. Rails scales period. We don't need the fiftieth article telling us that. Well you do apparently.
Nice intro. Here are a few more reasons Rubinius is cool: Generational GC - This lets OS copy on write magic work (ie after processes fork processes share memory until something changes) Spec Suite &amp; CI - Rubinius and JRuby developers collaborate on a spec suite. After every commit the specs are run and results are sent to the #rubinius IRC channel on Freenode. Currently Rubinius is passing 6266 examples with 22377 individual expectations. Open Commit Bit - Submit a patch that gets into the tree and you get commit rights. It's that simple.
Agreed :-) I'll cover these and a bunch more in the future installments :-)
Cool, I look forward to reading them. I guess I just couldn't wait to let people know :)
noo!
Let's assume, I think it's safe and non-controversial to do so, that some people are under the perception that say, because Twitter crashed and burned during the last Steve Jobs keynote, that Rails doesn't scale. Let's also assume that we want Rails to be more widely adopted instead of wanting to protect our consulting fees. What then, is the appropriate response to that person? Is it more convincing to yell bullshit, tell them to fuck off, that scaling is boring, that rock stars don't need to justify their technology choices to such uninformed lamers or is it better to actually explain Twitter's problems and why they shouldn't worry about them? I mean, why not just say 'Rails doesn't scale, why do you say that?' And then address whatever leads them to that belief? I would think it would be more effective than acting like a bitchy prima nerd, but I could be wrong.
Finally some good April Fools day content
&gt;Validators, now with AJAX! Minus the A, A, and X. ...awesome.
First funny April Fools joke I've come across this year.
as a commenter says on the blog: Mongrel is faster in slow requests because it’s running each request in a thread. The new evented servers are faster for slower requests since they have less overhead, but will end up blocking on longer requests
I'm a little worried that this has actual code...like I don't know much about rails plugins but it looks like this might work http://actsasaspdotnet.googlecode.com/svn/trunk/acts_as_aspdotnet/
I particularly like the non-deterministic patch time.
The sign of a well planned April Fools prank. See [John Resig's jQuery post](http://reddit.com/r/programming/info/6e5v4/comments/).
sigh. Such pranks are funny when they have at least an initial air of plausibility to them.
One more reason: It's run by Evan Phoenix. Evan has a remarkably mature approach to project management. See his talk at the recent MountainWest RubyConf. http://mtnwestrubyconf2008.confreaks.com/ 
Go ninjas go!
now that is a good april fools day post - complete with code samples.
Heh. I recognize that this is a joke, but seriously.... are there any rails plugins, scripts, or pre-made CSS to enhance your Rails application default styles? Improve the formatting of error messages, etc?
maybe you are looking for "streamlined" :)
Yep, it sure does. Check out the routing overrides. It's absolutely absurd... http://actsasaspdotnet.googlecode.com/svn/trunk/acts_as_aspdotnet/lib/acts_as_aspdotnet/routing_overrides.rb
Heh, the validation controls are also completely ridiculous (and seems to work!). http://actsasaspdotnet.googlecode.com/svn/trunk/acts_as_aspdotnet/lib/acts_as_aspdotnet/validation_helpers.rb
Or hobo.
 Items.find(:all).each_with_index do |item, index| # inelegant but much faster (no callbacks or validation should be called) # sql injection not a problem since theres no user input Item.connection.execute("UPDATE items SET sequential_order=#{index} WHERE id=#{item.id}") end I'll factor it into a plugin (acts\_as\_random) if you promise you'll write a blog post about it :-)
&gt;I think it's safe and non-controversial to do so, that some people are under the perception that say, because Twitter crashed and burned during the last Steve Jobs keynote, that Rails doesn't scale. OK. That's a safe presumption. The majority of all people are idiots. I am positive there are thousands of morons who will conclude that. &gt;Let's also assume that we want Rails to be more widely adopted instead of wanting to protect our consulting fees. What then, is the appropriate response to that person? Is it more convincing to yell bullshit, tell them to fuck off, Yes. Sometimes that's the right response. If the person is a fucktard, if the person has no interest in facts, if the person is a troll, if the person is retarded, if the person is saying that simply to feel better about his choice of tools, if the person is a typical proggit poster etc. You can't genuflect to every asswipe who speaks from a position of willfull ignorance. It's a waste of time. Plus it makes you look bad. When an asswipe starts yelling that rails doesn't scale they want to drag your down to their level. They are hoping to drench you in their douchebaggery. The best thing to do is to tell them go fuck themselves and talk to people who are actually willing to listen and are genuinely interested in engaging in a conversation. &gt;I mean, why not just say 'Rails doesn't scale, why do you say that?' And then address whatever leads them to that belief? I would think it would be more effective than acting like a bitchy prima nerd, but I could be wrong. You are presuming the cunt who yells rails doesn't scale is interested in having a sane and rational conversation with you. They are not. They are just being cunts. 
I think being able to have gems bundled with the application is a big win! I know there has been several hacks before, but still. This is good news.
I think that plugin would definitely have an audience, and I'll try to promote it for sure! I'll drop you a private message - maybe I can even help out a bit. 
You can already bundle gems with your app: cd vendor &amp;&amp; gem unpack gemname
Hitler just wouldn't shut up about how much COBOL sucked, that asshole.
Me three. I don't need more people to discover or embrace Rails. We've got a working ecosystem. Right now, developing with RoR is a really big advantage for us, so please — rest of world — don't mind us, just keep churning out that Java code!
Rails scales just like every other LAMP stack scales. This is old news. Have you learned nothing in the last three years?
That's true. DHH shouldn't have marketed the scaffolding functionality as forcefully as he did. That was a mistake, it attracted too many assclowns, and now we're trying to scare them away again. 
Since all Rails users are non-commoditized rock stars, I'm going to assume it's not a reading comprehension problem but a knee-jerk defensiveness about this topic--can you show me where *I* have made any claims about Rails not scaling? I have been talking about the most constructive way to have a conversation about the *perception* of Rails. What you just did there...that's not it.
The whole topic of "how" Rails scales is irrelevant. It scales like a LAMP stack. Even bringing the subject of "how" up at all shows you've failed to understand that there is nothing special at all about how Rails scales.
You people must be willfully obtuse. Look, if someone is not going to adopt Rails because they think it doesn't scale, then it is not irrelevant IF you care about furthering Rails adoption. Is that much clear to you?
I don't care about furthering Rails adoption in general. I welcome people who are capable of thinking for themselves, but those who can't distinguish rumors and fairy tales from fact, I can do very well without.
thanks! i didn't know that!
hobo looks good. their screen casts were informative. suites well to make some quick and dirty (not really dirty) instant apps. thanks!
Suscribed :) seems kinda empty though
I'll post some stuff sooner or later, I'm just 'at work' right now. Decided to poke at seaside and was shocked there was no Smalltalk subreddit.
Interesting that they're going to Github. I've been using it lately and I'm 100% sold - it's very nice. I wonder what the "official" URL is going to be. Most people are using a personal username, so it perhaps it will be github.com/dhh/rails...?
funny... I'm a longtime SVN user and just today I got my github invite... git seems to be amazing, eliding all of the bullshit that I'd got used to with Subversion. goodbye, SVN... it's been fun...
Christ on a stick, what a pain in the ass. Please give me a reason to think that this won't be a massive amount of time and hassle (for me) for little benefit. Why is git so great? 
I second your sentiments. 
Because anything with such a stupid name has to be really great.
It is not just git, it is that people are reliving high school by joining the github clique (by invitation only).
We'll be public with the github rails url just as soon as github launches in the very near future. 
I requested an invite using the huge field on the home page and received an invite soon after. it was a couple weeks ago, but still, you don't need to be in the "clique"
Subversion development went down a rathole for a while, but I think the latest svn release cycle (1.5) is getting back on track. If a centralized model is the right model for your development, subversion is (finally!) starting to get back in the game of fulfilling those needs. What I'm not sure of is how Rails benefits from a distributed model (like git or arch or mercurial) rather than a centralized repository with robust merge tracking features (which should be in svn 1.6). I'm not arguing that the svn to git switch is mistaken; there are a lot of features and energy behind git right now that makes it an excellent choice... But other than being far easier to fork Rails when the next big developer fight can't be resolved amicably, I don't really see the benefit of switching from a central to a distributed model for Rails. Beyond the religious arguments, I'd appreciate any insight into the difference the model is going to make.
Huh?
Merges seem to work a shitload better under the git model. Merges have always been irritating under CVS and SVN; I would say that 90% of my time as a repo administrator has been spent explaining how to do them. Git appears to remove this impediment via the way its underpinnings work. If not, I'll use git-svn to go back. There are plenty of git-to-svn and svn-to-git mirroring tools; if you have a preference that differs from the crowd, use one. I started out using RCS in 1994, then moved to CVS, then SVN, and now I am finding that git suits my style of development (often disconnected, with distributed 'master' repos) better than SVN. That's all. Apparently the Rails people felt the same. 
I did this today (or maybe it was yesterday) and they mailed me an invite in about an hour. It seems to be just high enough a hurdle to weed out people who aren't interested in actually using the service. I already have a local git pull and several SVN repos/wc's and CVS checkouts live on my laptop. I administer a couple more repositories for companies and departments I work with. Until I looked at git's guts, I didn't have much motivation to try anything beyond svn, but if you look at the way it works, you might at least want to give it a whirl or pull a project that interests you, just to see if it's a better fit for the way you develop. It seems to offer enough in the way of benefits that I can foresee more projects moving to it as time goes by. I no longer work without version control; it's the easiest safety net in the world to set up, so I start any significant project by doing so. The only question for me is which style of VC/SCM works best for a given project and a given developer, so I'm willing to try a new one every 5 years or so :-) 
Offline local branches/commits that you can ditch if they don't work out. This feature alone is enough to make git (or hg or any other DVCS I suppose, git's just my weapon of choice) the answer for me. I hear the svn crowd is bringing this sooner or later (1.5?), but I haven't really found myself really missing anything from svn, so it would take something pretty substantial to pull me back. I'm also a fan of git's sexy content-based history tracking. It's nice to be able to ask where every little chunk of code came from in a project.
One of the GSoC projects is to add a subversion-server front-end to git. If they actually gets completed it should be possible to check out rails using either git or svn. Also, unless you had commit bits to rails your life shouldn't change much at all anyway. I suppose if you want to track edge rails you might need git installed, but it should be possible to get nightly tarballs. Old svn:externals will still continue to work (for old releases).
mmmm. Loving the Ruby book bubble!
If you are incapable of finding out for yourself, you should probably stay the hell away from it.
Well that's a good reason, thanks.
Forgot to mention... only works on Leopard
What is the website that is linked?
Personally, I was swayed by this video: http://www.youtube.com/watch?v=4XpnKHJAok8
My favorite part: &gt;I wrote this gem with no known use cases. If you find any, let me know.
http://www.noobkit.com http://www.railsbrain.com I updated the post to make sure to link to the sites I'm referring to.
&gt; If you’re freaking out, calm down. Rails and the developers behind it have snubbed Windows far, far worse in the past :). The original release of the framework didn’t even run on Windows. This move to Git is not a snub. Call it arrogance, but I find this so refreshing. 
the thing is, if somebody says something, and you explain that it's false, and they go on saying it, telling them the real facts won't do you much good if you've already explained the real facts and seen them willfully ignoring those facts. again I really just wanted to address the particular situation I was in on that particular evening. people were abusing their positions on the panel to spread FUD (altho to be fair Obie was baiting them to some extent as well). if people are spreading FUD, call them on it. we all know what FUD is, there's no excuse for it.
Aww, go ahead and snub 'em, a true developer works on a 'nix machine.
I've been doing something like this for years. http://datavision.sourceforge.net/credits.html
Ruby?
So you are giving yourself credit for giving credits?
Hey! You deserve some credit too!
and they wonder why i'm a ruby fanboy...
Not exactly concise, is it?
Git is an subject of interest for people using Ruby/Rails, especially now that Rails announced that they'll be moving from Subversion to git shortly. So, I thought it would be appropriate to share this informative video, since a few people had been asking about it in the comments of other posts around here. My apologies if you don't find it interesting or relevant. Feel free to vote it down. 
Well, I've actually voted it up. It just feels a bit misplaced here in the ruby-reddit without any more context :-)
Looks very useful. Beast (http://beast.caboo.se/) is my favorite Rails forum (and Mephisto my favorite blogging system).
I know what you mean, but it's not like this reddit is overflowing with content anyway. Plus, git is sweet! :)
Gemify 0.2.4 is released, packed and uploaded to RubyForge :-)
So cool. And only 13 days after 0.2.3. How long to go for 0.2.5? Or is the next version 0.2.4.1?
Well, the rewrite for 0.3 is actually done. Needs perhaps some more spec and a little cleanup, but it shouldn't take long.
I personally would prefer though if the proper channels (ruby-talk, raa, rubyforge, freshmeat ...) were used for software announcements. IMHO reddit is not appropriate but opinions may vary.
Awesome idea, it's like Hot or Not for code. My roommate and I were just talking about something like this a few days ago, I'm glad someone made it.
Very promising, but does anyone actually use Jabber?
GTalk is based on jabber... Also, you can talk to almost all other IM services over jabber
The only people I know who use GTalk are other developers. Can you talk to MSN or AIM with Jabber? If that's the case then this could be pretty useful.
We use it at work. Well, looking at the current shared rosters, that's the royal "we", but part of that is that I just announced it last week to half the group.... This was more of a boss says "we need an IM system in place, internally, instead of relying on a 3rd party to keep our info private" thing than anything else. There's also been rumblings higher up in the organizational chain about cutting off access to certain IM protocols, so keeping an internal server (even without server federation enable) will eventually be a Good Thing(tm). Once the devs are introduced to it, I hope there's more wide-spread adoption than there's been so far on the sysadmin/networking/security side. I know NASA is supposedly rolling out an agency-wide Jabber setup, but, as expected, it's behind schedule (from what my former coworkers there tell me). I use it at home, and am actually considering abandoning Pidgin for an XMPP-centric client and just setting up the right gateways on my personal jabber server, as Pidgin's XMPP support is apparently sub-par at best. 
You can definitely talk to aim or MSN thru jabber. I had it setup for my personal acct for a while. The only thing I'm not sure about is adding contacts from other networks programmatically. But I'm pretty sure its possible...
What's great about Reddit is that you can downvote and hide stuff you don't like. But I must warn you: My next post will be related to Gemify too (a little more in depth, though)
Interestingly, the `lambda` and `proc` methods work in exactly the same way with respect to `return`, but like the article says, `Proc.new` is slightly different: def rtest l = lambda { return } p1 = proc { return } [l, p1].each { |b| b.call } puts "You'll see me" p2 = Proc.new { return } p2.call puts "But you won't see me." end
This is changing in Ruby 1.9. 1.9 will have proc and Proc.new having the same behavior and lambda being different, although I do not recall which will have which type of return.
Replacing problematic code at runtime when a proper fix is not a good option. Hence "patching". 
&gt; I think the reason there's such conflict between Rails and J2EE is that Rails is a disruptive technology. That might be more accurate as "NOT J2EE is a disruptive technology." A certain amount of ignorance about other programming communities is natural, but cultivating that ignorance deliberately is a hostile, prejudicial attitude.
Oh, well. I guess I'd better stop using Ruby then. It was fun while it lasted. Seriously though, I think Ruby/Python comparisons are unhelpful. Both are good, complete, mature languages, similar, but different. They both have good web frameworks. Some programmers seem to "click" with one approach more than the other, and that's natural too--our brains don't all work the same. A programmer with experience in one who "tries out" the other will probably be disappointed, and while they can have a helpful fresh perspective and spot issues that need to be corrected, many of their negative reactions generally result from a lack of experience with the new language and familiarity with the old (and therefore largely irrelevant). 
i &lt;3 ruport.. no seriously.. it's great because i feel like a info-mercial host describing all the features.. you got your ActiveRecord integration, you got your eager loading, you got your column renaming, you got your calculated fields... and what if i told you for a limited time you got HTML generation? How much would you expect to pay for that.. $99.99... $59.99... $29.99.... for a low low price of free you get all this.. and if you call right now, you'll get CSV, and PDF generation for free! what an incredible bargin! call now!
Awesome. What does it use for PDF generation? Does it run on windows? 
Last I checked datamapper blew away your data every time you made a change to your table definition. Did they fix that yet?
Surely god already knows everything.
Automigrate will still do that, I *think* that they now have AR-style migrations to avoid data destruction. I dunno, I’ve been playing with [Sequel](http://code.google.com/p/ruby-sequel/) now and am really liking it.
This is a great article, but it's already been posted in the programming subreddit. Does it really need to be posted in the ruby one, too?
I played with sequel too. It's pretty nice although to me it seems like more of a replacement for DBI than AR. The squel support for ADO on windows is dismal though. DBI is a bit better but still pretty bad. 
Just wanted to note that RubyFlow is not putting down Reddit (I'm an ardent Reddit user myself!) but providing a more "edited" experience. This will only suit a certain audience, I imagine.
neither. both are incredibly hard to deploy, intransparent, doing unwanted stuff in the background while preventing me from actually doing stuff I want. And the longer the more, the first response you get to a query is a price list. Like the old ASP days I'm ever as grateful to have left far behind. SCNR - needed to vent.
What do you use now?
I love this site. Excellent work.
mainly a home-grown framework above PHP which abstracts away enough of the HTTP innards to be comfortable to use and less enough for it to still be fast enough and flexible enough. I've laid the groundwork for this in fall of 2003, so well before the rails hype really took off.
I starred the ticket to show my support for ruby... but then unstarred it 10 minutes later after receiving 4 emails notifying me that someone had posted a "+1" comment on the issue.
What a dumb idea.
Pretty much pure awesome - it lets you make fun of whoever is on stage in between shots. Much more interesting (and accessible) than a regular power-hour. Good stuff.
Whee, sanctioned binge drinking. Everybody get an alcohol problem!
It's like a parade of dumbasses, watching more and more people do the +1 thing. FFS.
yeah, that's annoying. mail comments for starred tickets are very easy to turn off ['settings' link in the upper right corner when viewing googlecode pages]. it's on by default, and imho it sucks. 
So this allows us to easily make our own gems IIRC? I have one question; what's the difference betwixt a gem and a plugin?
Plugins are Rails-specific. Gems are packaged Ruby libraries. Though you can make Rails-specific gems, with generators and everything.
Thanks, so I have one more question say I want to make my own generators for parts of sites that I do often and do not want to repeat. Like CMS. Should I make it a plugin or a gem. What if I want to share it with others, plugin or gem?
woot.
Wow, RubyInside was faster than the official GitHub-blog...
You can do either. There are pros and cons either way. My personal preference is gem over plugin.
I was very glad to have found this, and therefore submitted it . . . I have personally seen NOTHING analogous to this, both on or offline, commercial or otherwise. And while I am in no way, shape, or form affiliated with the author, I have also decided that posting a link to his donations page, through paypal, is quite warranted: http://www.brpreiss.com/donate.html His credentials are also pretty impressive. Hope everyone finds it useful, I think it is great. Happy Hacking, Maurice Roman 
Whew! This is long overdue.
I have been wanting to find this for quite some time now. In fact I was just thinking how I'd implement a red black tree in ruby this morning. Very nice find.
I hope this one is kept up better than the Rails Wiki. None of the information on Rails Wiki is relevant and it's all out of order and basically useless. 
Wooooooooooooooooooooooooooooooooooooooooooow! I want it. I'm installing it right now.
Now we have this + switchpipe. I tried switchpipe and will try this over the weekend. Great work.
That's the future of rails too from the sound of it. 
The people who downmodding you probably never had to deploy a rails application before. I feel the same way!
what the fuck is "enterprise ruby" this feels weird. what is happening..
People downmod for all kinds of reasons. It would not surprise me if people hung out that the ruby subreddit just to downmod all ruby articles and comments. Having said that I never had problems with deployment. Capistrano is way cool. To me this is just another way of deploying with capistrano. 
From the website: "Sorry, releasing Phusion Passenger (a.ka. mod_rails) took a lot of energy, so we haven't had the time to release Ruby Enterprise Edition as well. We'll launch the website (with full details) as soon as we can, please stay tuned for updates."
yeah, i mean, i can read. but "enterprise ruby", to use an old robot phrase, does not compute. also, it is scary to me because there is no ruby spec right now, and there are other much more community-developed projects (read: rubinius) that i am really pullin for. also, the site feels like a joke. the whole thing is just weird. don't get me wrong, mod_rails is a potential godsend, im just sayin.. the whole thing seems kinda strange.
I think the rest of rails spoiled me. All so easy. I love migrations. You get your first basic app in no time and then you get to deployment. Yes, I found capistrano and vlad. However, shouldn't it be easier? Most of people thought "it is already easy". Some wondered though. Thank gods someone actually challenged the status quo.
I have said it before. Deploying rails is easier than deploying anything else already. Sure with PHP you can rsync your files over but what about your database changes? What if you need to roll back your change? what if you have three web servers and two database servers? Capistrano makes all that brain dead simple. If anybody has a better deployment system than capistrano tell me about it. Rails has the easiest, best, most robust, most well thought out, most "enterprisey", most flexible deployment system of any language or platform. It's the best and it only gets better with projects like switchpipe and mod_rails. Once again ruby and rails has left everybody else in the dust. 
I'm definitely getting that vibe not only from the site but from the entire project as well. Comments like this: "Allows Ruby on Rails applications to use about 33% less memory, when used in combination with Ruby Enterprise Edition (optional)", give me a really sketchy feeling. also, their [blog](http://izumi.plan99.net/blog/) scares me... 
I don't think you quite understand what Passenger is for. It sounds like they've wrapped it in some kind of deployment setup, but it's basically supposed to make Rails applications running on Apache servers a lot more stable. This has always been my greatest pain with Rails, and I couldn't agree with the parent thread more. Hopefully all the shared hosts like Dreamhost will pick this up quickly.
&gt;I don't think you quite understand what Passenger is for. It sounds like they've wrapped it in some kind of deployment setup, but it's basically supposed to make Rails applications running on Apache servers a lot more stable. It just deals with one aspect of application deployment (the CGI part for all practical purposes). Capistrano deals with all aspects of application development. Capistrano will be very quickly adapted to use this method too.
Their marketing is like a pretty, hipster version of the [Microsoft iPod](http://www.youtube.com/watch?v=aeXAcwriid0), basically making a [hard sell](http://en.wikipedia.org/wiki/Hard_sell), which is pretty weird for open source. With that and all the secrecy leading up to this, I have reservations. Still, I hope this is as cool as people think it could be. It's not for every deployment, but making drop-in deployment easier would be a welcome change.
Yeah it's pretty badass. Kind of feels like cheating. Or maybe I'm getting one of those things like, when I was kid we had to walk 15 miles. 
Passenger's an Apache module.
I'd never heard of it before either. But I found the [RubyForge page](https://rubyforge.org/projects/emm-ruby/) &gt;Ruby Enterprise Edition is a branch of Ruby, which includes an enhanced garbage collector and developer tools. This allows one to reduce memory usage of Ruby on Rails applications by 33% on average. and an [incomplete wiki](http://docs.codehaus.org/display/RUBEE/Home)
thanks, i feel much better now. looks like there could be pretty cool stuff coming our way. 
Yea I know. 
Ditto. I first thought it was a "Zend" type upsell before reading about it. Being on a virtual server, I'm pretty excited about anything that can reduce memory usage. Bad bad name for the project though. "Enterprise Edition" has really negative connotations for an open source project.
Hi l00k. The website you linked to has got nothing to do with our RubyForge page. The official website is www.rubyenterpriseedition.com - Hongli (Phusion.nl)
Hi Evdawg. We're still working on a corporate blog site with a more appropriate look. Because Passenger's release took so much energy, we haven't been able to do that at the same time. Thanks for your understanding. - Hongli (Phusion.nl)
Maybe I just got a bad run, but it seems like they're choosing a string of terrible songs for this entire hour.
Looks pretty nice. 
too bad it's tied to rails, a mod_rack would have been much more useful.
We've been talking with the Github guys for a while and they gave us a precise time to have a scoop. But.. people on Twitter still beat us, lol :)
It wraps around PDF-Writer for its PDF generation.
Is there a programming term "patters" with usage similar to "patterns," or is he just leaving the "n" out over and over again? The frequency of the typo is beginning to wear on me.
lolcat patters
Down-modded for poor title; should have included the name of the particular revision-control tool being discussed. 
"This Account Has Been Suspended" :(
While the Reddit title is certainly poor (the article's though is ok) and the technique used is naïve, I'm upmodding it because the comments taught me about `__git_ps1`. I'm now using the following line on Ubuntu 7.10, with no additional changes needed: PS1='${debian_chroot:+($debian_chroot)}\[\033[38m\]\u@\h \[\033[94m\]\W\[\033[95m\]$(__git_ps1)\[\033[37m\]$\[\033[00m\] '
I like it, but I would appreciate more text on the page to describe what things are. When I visit a site I like there to be some snippet of text written somewhere so I can get immediately what the idea of site is about, instead of clicking a small *About* link. It would really good if there was some small text about each of the sites in their listings on the main page; even just a snippet that I could click to expand or something. There's mouseover text but it doesn't provide enough information. I'm not likely to click through and read about every site that's been added in order to see which ones I'm interested it, and I feel I can't guess properly what each site is and what it does based on its title and a thumbnail screen cap. Having some kind of features matrix for each site would be great too. 
Great suggestions. I'll definitely get this implemented for v0.2 sometime next week. I'm thinking I'll use [Prototip](http://www.nickstakenburg.com/projects/prototip/) to display the full description and author info when hovering over the projects on the main gallery page. 
Sounds like a good idea. I've added my app.
python dictionary syntax? Sweet!
This guy is all wrong, it's WAY easier than that: basename `svn info | grep 'Repository Root' | awk '{print $3}'`
Almost everything made me say, "Wow, that's better" or "wow, that's cool". Great to see the language coming along. 
Can't say I like the new proc literal syntax. Sure I'll get used to it, though.
Oh, just use [vim](http://code.google.com/p/macvim/) already, people! &gt; * auto-complete from all open tabs C-n C-p on a default vim, mine is [bound to tab](http://www.vim.org/tips/tip.php?tip_id=102) &gt; jump to a method, class, or fixture named under the cursor I type "gf" to do that with [rails.vim](http://rails.vim.tpope.net/) &gt; start the debugger on a series of RSpec examples and break at the current line *shrug* debugger alt-tab enter &gt; inspect by highlighting to evaluate to tooltip or clipboard :ruby &gt; fire up a Merb/Rails server or console for your current app :Rserver - bind it to whatever key you like. &gt; tail development.log :!tail log/development.log - why remember another command?
Later, he'll meet the really hot AND smart chick, Ramaze, and there will be wedding bells. :)
That's really not the point here. For those who prefer to use TextMate over vim, this is a useful bundle.
All this stuff and much, much more already exists in Vim, and has already existed for a long time in Vim. "the point here" is that I think Rubyists should at least take a look at vim. I think a lot of people simply don't know that MacVim integrates really well with the OS, and that TextMate is spending a whole bunch of time and energy mostly recreating stuff that already exists.
I hereby condemn all *-fu plugins. Please, stop already. It's not -fu just because you think it's cool.
I use MacVim, after having tried TextMate for a while, and I *still* downmod you. Both Vim and TextMate are excellent pieces of software; I just happen to prefer Vim’s approach. Others are far more comfortable &amp; productive with TextMate. It’s fine to evangelize for your favorite text editor, but don’t expect a positive response if you act exasperated (“Oh, just use vim already, people!”) that others would rather work on improving the solution they prefer.
Does Macvim work with Leopard? I noticed that it hasn't been updated in a year. I could always compile from source but would rather find out if it works first..
It's been updated this week, and a month ago. You were probably looking at the old site, not the google code site I linked above. It works great with Leopard and Tiger; I use one at home and the other at work.
I forgot Internet Lesson #12: never use sarcasm in a textual medium
Rails is sometimes nice to work with, but I'm not sure I would call it "ideal". The architecture is very monolithic and ActiveRecord is cluttered and not designed particularly well. For version 3, I think they'll have to replace some key parts of the framework, or risk being overtaken by other projects.
Rails risk being overtaken? It kinda sounds like you're saying that Rails is somehow a *majority* framework. That being said, I think DataMapper is a promising alternative to ActiveRecord, if the simplicity it provides isn't quite enough.
&gt; Rails risk being overtaken? I mean overtaken in terms of functionality, not popularity. &gt; That being said, I think DataMapper is a promising alternative to ActiveRecord It looks interesting, but I don't think it goes far enough. ActiveRecord and (as far as tell) DataMapper essentially work by creating queries from SQL fragments. It's my opinion that this approach doesn't work very well, except in very simple cases. I suspect that much of the problems I've encountered with ActiveRecord wouldn't have occurred if it used an intermediate AST to build up the queries. String concatenation only really works for simple DSLs.
I tried hard to like it, but it is simply not a very good ruby book. Indeed, is pretty obviously a "Data Structures and Algorithms in Someotherlanguage" minimally translated to ruby with no attempt at writing idiomatic code.
&gt;ActiveRecord is cluttered and not designed particularly well. How does this clutter effect the developer who is using the framework.
Well, it makes plugins a pain for one. ActiveRecord is often tricky to extend, because there are a lot of large methods that aren't divided up very well. If ActiveRecord were better designed, more common functionality could be factored out into generic plugins. There's also functionality in ActiveRecord that would be better separated out. For instance, the code to parse a set of HTTP parameters into a Time object has been put into ActiveRecord, and that doesn't really have anything to do with the ORM layer. It would also be nice if they factored out the validation module into something more generic.
&gt;Well, it makes plugins a pain for one. Are you sure about that? I haven't looked at the code myself but I see a ton of plug ins. It can't be all that hard if there are so many plug ins. Anyway that doesn't really matter to a person using activerecord. &gt;It would also be nice if they factored out the validation module into something more generic. Again as a user it doesn't really matter to me where the code is as long it's there. There is nothing preventing me from using some other validation library or rolling my own and using it instead of the one built into activerecord. 
DataMapper doesn't work that way. It's backend-agnostic.
&gt; Are you sure about that? I haven't looked at the code myself but I see a ton of plug ins. It can't be all that hard if there are so many plug ins. Okay, it makes _some_ plugins a pain :) If you're just adding extra methods to ActiveRecord, then everything's okay; a lot of plugins do just this. But if you want to override any existing methods, you may find yourself in trouble. For example, the composite\_primary\_keys extension has to override a lot of fragile methods for what should be a simple task. &gt; Anyway that doesn't really matter to a person using activerecord. Only for very small, simple projects. All the Rails projects I've been on use a number of custom plugins, even ones that only need three or four months total dev time. ActiveRecord's limitations have bitten us a number of times, because we can't factor out common behaviour in ActiveRecord very well. &gt; There is nothing preventing me from using some other validation library or rolling my own and using it instead of the one built into activerecord. True, and if you happen to know of such a library, I'm all ears. However, you wouldn't have to look for a library, or code your own, if it was just programmed properly in the first place.
Hm, maybe I should take another look. Still, how can code like: @parent = Tree.find(:first, :conditions =&gt; ['name = ?', 'bob']) Be backend-agnostic? The condition argument is clearly an SQL fragment.
That's not DataMapper. Watch this: http://mtnwestrubyconf2008.confreaks.com/04katz.html
I'm about to switch from Rails to Merb, then suddenly, mod_rails came. Now I'm stuck in between....
Being at work with no headphones, I can't watch that screencast, but I did take a look at the source code, and so far I'm very impressed. You're right; it doesn't use SQL fragments. The SQL statements appear to be all constructed entirely in the adapters from an AST of objects, and its done in such a neat and clear way it's extremely readable. Compare this to ActiveRecord, which works by cramming together SQL fragments from all over the place. I don't like making judgements about systems I haven't used, but DataMapper looks extremely promising, especially in comparison to ActiveRecord. I'll look into it some more, but if its as good as what I've read so far seems to indicate, I'm sold!
Sure, for some DataMapper works better. But it's kinda silly to extrapolate your own preferences to somehow become everybody else's preferences as well — ActiveRecord was what drove the great developers towards Rails in the first place (while scaffolding attracted the newbies), it's not as useless as you're implying.
Well, I am sorry to hear that, yours being the second comment along those lines. I personally am learning Ruby basics, thus I have not worked my way through this book. As I mentioned in my initial post, what struck me about it was the fact that - at least to my knowledge - there is nothing analogous to this in Ruby, insofar as Data Structures and Algorithms, and I also found the author's credentials to be impressive. Even though it is a bit disappointing to read the comments to that effect, I appreciate the heads up from you and jamesbritt, I will keep it in mind when I work my way through the book. 
What preferences? Scattering your query building code throughout your library is not as good an approach as factoring it out into a single module. Using strings to store your intermediate query fragments is not as flexible as storing it in an object tree. I don't think these observations are subjective.
well, once you've worked your way through the book and learnt some ruby, it'd be a nice exercise to get a copy of 'the ruby way' as well (a bit advanced, but an excellent *second* ruby book), and see how you can make the programs in the algorithms book more rubyish
Ok, you're right. Nobody likes ActiveRecord, nobody at all. Feel better now?
That's not what I said at all. "AR has major design flaws", is not equivalent to "Nobody at all likes AR". Thanks for getting me to look again at DataMapper, but can you put away the hyperbole and strawman arguments? ActiveRecord does it's job; I use it every day, and it has a number of advantages over writing raw SQL strings. But it's not that well designed internally, and it's monolithic and cluttered architecture has caused us big headaches in the past.
I would suggest displaying the full description directly in the page, without the need to hover. Am I the only one who's sick of web pages that expect me to scrub the page with the mouse?
That sounds like a good idea, I had actually thought about it, it would be a good exercise. Thanks for the suggestion.
I hereby ask for a reward for the set of all people who have not released a "_ fu" plugin / gem.
I'll upvote this if I'm on the list. I promise.
What'd you release?
Well, nothing. but I'm still in the set of all people who have not released such a gem. forall P such that P is in the negation of the set of people who have released a "_ fu" gem
A true hero.
I was just commenting to my wife (non-programmer) that programmers really don't appreciate awards like this, they are too easy to give out and become very cheap. I mean, are you going to put 'Voted Ruby Hero' on your resume?
Why don't you release a gem that removes or inoffensively renames all of them, and call it fufu?
Call me cynical, but it seems like nothing more than self-congratulatory backslapping designed to massage the egos of a select few. Not my cup of tea. Vote for me.
The panel of "community leaders" is bullshit. Some of those people, absolutely, but most are simply members of a Rails clique who have done nothing for the Ruby community at large. This is a Rails thing, and clumsy and embarrassing to boot. acts_as_self_important 
I found the idea to override String#&lt;&lt; funny.
We built this site last weekend for a lark, just as mod_passenger was introduced. It runs Rails, apache and mod_passenger with some tasteful "Girlfriend" kind of images that should be safe for work. Premise... bangmeter.com -- bangable or not bangable. May be a little addictive. 
I have been on this site for an hour. Very nice concept and great pictures! :-) 
Still trying to get used to Lighthouse's interface. I still prefer trac, for some reason.
It would have been better if the \ wasn't stripped out of the code listing.
Well, there actually is a method String#&lt;&lt;. There is also Array#join. I think the author would have been better of by trying to get his original version straight (eg by separating the scanner from the output generater) instead of obfuscating it even more using an obscure technique that has several shortcomings.
Yes there is String#&lt;&lt;. It was modified for this particular instance to append newlines, so the author wouldn't have to write them into the code and therefore make it "ugly".
Uglier maybe. Anyway, I don't know for sure how ruby strings are internally represented. I assume though that Array#join("\n") would be the better choice. 
Doesn't this already exist in the Rails 2.0 bundle? The version that I see in bundle editor is respond_to do |wants| wants.${1:html}${2: { $0 \}} end
Perhaps. It's certainly a possibility.
Ok, you're right. I changed it to use Array#join. Thanks for pointing it out. Edit: BTW, I'm not exactly sure if it's bad reddit etiquette to change articles in response to comments here. Hope no one thinks that is bad form.
oops what?
37signals somehow failed to pay for the domain, and now it's squatted. 
the non-www works fine...?
not for me. it may still work for you 'cause it's cached someplace close to you, but that will expire soon. 
'twas a case of DNS poisoning. Move along, nothing to see here.
no chance its still in the grace period?
those funny words you're using, "dns poisoning"... they probably don't mean what you think they mean. 
Blah, now how am I supposed to get anything done. Browsing RI docs is too slow.
WTF?
[Ruby on Rails Google groups thread](http://groups.google.com/group/rubyonrails-talk/browse_thread/thread/ec81d2cc0f64ab27/7a9ae3413412791e?) 
The .com still works fine http://api.rubyonrails.com/
Moral of the story? Don't work for big business if you can help it.
Seconding TheBobMcCormick above/below, it would be handy if the one-line description of the applications would be displayed on the page (without the need to hover). You could display the whole description on hovering, after clicking [+], or simply when loading the page about the project. But I think hovering to get the description and simply not displaying anything by default is a bit unintuitive/asking to much from the user (constantly moving your mouse is a bit annoying, isn't it?).
Yes. No competitions, no improvements. 
[Rails minor mode](http://dima-exe.ru/rails-on-emacs) was enough competition for me.
It certainly feels that way. It has a certain vista-eseque timeline now. I've switched to about 50/50 between vim and textmate in the eons since the last release. It would be different if there were any timelines, alpha/beta schedule, or 'hey, i've spent 26 months building the xyz feature set, that's where it's been' 
Amen, bro, I don't understand the whole furor about textmate. It's certainly no better than a properly skinned emacs.
i've switched to emacs as well. With ECB and some custom tweaks it's better and aquamacs prints better than textmate. Here is an example of emacs with ECB for rails: http://emacsonrails.drozdov.net/
Too bad Jedit is dead. If it had been kept up a little it would have been a decent competitor. 
&gt; It's certainly no better than a properly skinned emacs. One would be hard pressed to find a better all-around editor than emacs, but I find TextMate to be hard to beat for Ruby, Rails, HTML, CSS. Pretty much any thing you need, there is a bundle for. Rspec, Haml, you're set. The ability to add your own snippets, templates, run scripts, etc. It's all there. And as it is native to OSX, it is more robust than say Eclipse, or someone mentioned JEdit. For Lisp, I use emacs with Slime. For pretty much everything else, TextMate. 
&gt; for Ruby, Rails, HTML, CSS. Pretty much any thing you need, there is a bundle for. Rspec, Haml, you're set. The ability to add your own snippets, templates, run scripts, etc. It's all there. This is as true, if not more so, for emacs. These are available similarly easily for every language one might imagine, with the possible exception of java and the .net languages.
It's too late at my enterprise, where I'm ramming it down their throats.
Actually I've found both the Eclipse stuff and Netbeans stuff to be really good too... If you can tolerate the shitty load times that is... But generally I'm a big fan of eclipse with the rails plugin... 
While i would absolutely agree with you, TextMate has a lower learning curve, no matter what anyone says, C-x C-... into infinity takes it's time to learn if you don't want to write a bunch of macros to replace everything. And personally i think TextMate looks nicer, not that it matters to the coding, but when running OS X and a bunch of beautiful programs everywhere, emacs feels a bit retro.
dead? looks like the latest version came out in march.
The last stable release was August 29, 2004. Three years later they still haven't put out a stable release. That's a dead project. 
From the horses mouth: "What I can say is that a) TM 2 is in a state where I use it myself and b) I do somewhat stringently follow a to-do list to reach a beta milestone, but that to-do list is long and while I plan to keep doing TM 2 as my main work until there is a release, it may still take a long long time." http://tinyurl.com/488dn8 
Honestly, what do you think you need from TM 2.0? I could see that 2.0 may bring some improvements, but the most recent 1.X version (whatever it is I'm using) makes my coding life all that much better. 2.0 will be nice, I'm sure, but it's not like we're waiting for BIG features that were promised and that we're having to do without. Unless I missed some announcement of something great we're not able to use yet.
The one huge thing for me (and I've seen other people ask about it in the forums) is to fix the way Textmate checks files in a project. In a nutshell, every time Textmate gets focus, it does a run through all of the files in a project, looking for updates I presume. If you try to use Textmate on files that are located on a remote drive, it becomes intolerable, because there's about a 15-30 second delay (with spinning beachball) while it goes through this, EVERY time the app gains focus. It's not noticeable when the files are on your hard drive though. Either fix it or give a preference as to how frequently you want Textmate to check the files in a project. Anyone who's tried to use Textmate remotely will know what I'm talking about....unless there is a workaround for this that I'm not aware of.
I see. That does seem like it could be a problem. I've never worked remotely like that before.. kept files locally for editing. Is this behaviour something that is supposed to be addressed in 2.0?
&gt; Is this behaviour something that is supposed to be addressed in 2.0? I really don't know. I pushed hard to find a workaround a few months back and remember reading on the Textmate forums that a bunch of people had the same problem, so I think they're aware of it...but I have no idea whether they will actually fix it.
Can I ask what you use to mount remote filesystems? I've looked into macfuse, but saw this recently on the joyent forums, which looks nice: http://www.magnetk.com/expandrive (sadly, it's not free) I think that's part of the reason I try and work locally at all costs, because of lag over the network that's often associated with it.
I'm not sure if this is ironic or not, but I'm actually giving my local dev environment a tune-up as we speak. I develop locally for rails, but had been developing for LAMP directly on a remote dev server. I have tried a bunch of things with varying degrees of success. I have used the Mac OSX native mounting tools in finder for samba and webdav, and i have even tried something called sshfs, which mounts a drive over ssh (pretty cool). I will check out your suggestion, however. Thanks for the tip. :) I guess I've always preferred the concept of developing remotely on a dev box that closely matches my production environments, but I am actually moving more toward developing locally because of the network lags you speak of and the lack of a decent solution to them.
i'd like to see the subversion status in the file drawer and be able to use the file drawer to interact with subversion. They said something about an api for the file drawer years ago, but I don't think anything came of it. 
aquamacs has decent mac key bindings out of the box. 
Yeah, and TextMate doesn't even have [Tetris](http://www.macosxhints.com/article.php?story=20050103201954271)!
For the former see http://ciaranwal.sh/2007/11/29/svnmate-update
thanks for the link, unfortunately it doesn't work the way I'd expect. Files in my app/controllers/ folder have been modified but it shows that app/ is up to date :/ It shows the right status for /app/controllers but it doesn't seem to propagate up. and as you said, it doesn't let me interact with subversion from the drawer. This file drawer thing is one example of where emacs with ECB is more powerful. 
Sketch Programming: A Precursor to Test Driven Development is an outline of a method of application development I use to help create the specifications that make good test driven development possible. Read it for my thoughts on "back-of-the-envelope" programming techniques.
the hell? Does the infoq website suck this bad where everything in a frame? At least they have the video but the transcript display is ridiculous. 
Honestly, I was kind of bummed that ALA decided to devote both articles in this issue to rails intro pieces. I guess I usually look forward to something a bit more groundbreaking.
Yeah, but if you remember that most of their audience are not programmers, it kinda makes sense. They're opting for the shallow end of the pool to start with.
There is. I found it a few weeks ago when I had the same issue but on a local drive (it'd pause for 2 seconds every time TM got focus). Someone else had had the same problem and had a TextMate plugin that allows you to turn off folder checking on focus. Can't remember how I found it, sorry! (But it exists) (The menu item is called "Disable refresh on gaining focus" but I tried Googling it and no dice.)
Another user just posted the following comment to me (I'm not sure why it's not showing up on this thread?): &gt; Remate. Think this is what you are looking for. http://ciaranwal.sh/2007/11/07/remate-update I just installed the plugin myself -- *exactly* what I had been looking for. Wish I'd seen it ages ago.
Why is this in Ruby?! Yes it's built in Rails but it's a site for Twitters and Flickrs not Ruby programmers. Why can't we like..downvote tags or something.
in the venn diagram of twitters, flickrs and ruby programmers, there is a lot of overlap.
Voted up for the blog's non sequitur name alone.
I found peepcode.com screencasts (rails i and rails ii) very helpful and they are updated for Rails 2. After completing those, you can pick up The Rails Way and be pretty much covered. Plus, sitepoint is releasing Simply Rails 2 on May 15th. Plus, the best way to learn is to really just start developing and checking the API and asking forums for help. October 2008 is way too far away.
Crap. I just spent $32 on the second edition three days ago; should I return it to Barnes and Noble and await #3 or just go with it?
get the 3rd edition. If you need something now get "The Rails Way" by obie fernandez. Basically, you want something that covers rails 2.0.
However. The Rails Way is confusing for someone unfamiliar with Rails and although it says "Rails 2.0" on it. It's pretty much 1.2.6 and then edited for 2.0. (Though the differences are not that big). So your shit up a creek really. I'd suggest reading both unless you can grasp more of The Rails Way then I expect a new coming to.
peepcode.com screencasts are great. So are [Railscasts](http://railscasts.com/)
What forums are best for intermediate developers? I've been on the RoR google group a bit, but is there anything else with relatively short response times?
 #rubyonrails on irc.freenode.net
Stick with the 2nd edition. Download the 1.2.6 release http://rubyforge.org/frs/?group_id=307 and just do the book. Though the libs may change, the basic concepts are all the same. For a newcomer, the basic concepts are what you should be after understanding rather than "goddalaunchmyappin2months".After doing the second edition of the book you'll be in a good position to upgrade to the 2.0 routing changes. 
I like blog post the main part of which is introduced by: &gt; Quoting myself from three weeks ago
proper UTF-8 support would be nice...
What is rack? A quick google was not helpful.
How about googling "ruby rack"?
IDEA: There have been a number of a "essential gem" posts, some linked on reddit. What would be cool is if someone made a simple "ruby-gem" site with all the available gems listed (users could submit ones), and the ability to vote and comment on the gems, or a "I use this" button to which ones are actually most used. Or maybe a "gems" section should be added to agilewebdevelopment.com. Or, perhaps something like this exists and I haven't found it yet. 
I googled rails rack and got nothing useful, ruby rack works.
I found this search VERY useful: http://images.google.com/images?q=nice+rack
In gem v.1.0.x this is now "gem server" and it's helpfully listed in the list of commands. Prior to that, I had no idea that gem_server existed. Very useful. (use --daemon to run as daemon). 
Interesting article, but this title sure misses the point of it.
Does it? (How?)
Yes. The point of this article deals with trying new ideas and understanding new and strange things. The Ruby code is simply an example of this people can possibly relate to.
That's weird, I was just reading about [acl system](http://brainspl.at/articles/2006/02/20/new-plugin-acl_system) for implementing roles in rails from this same blog. Excellent plugin, by the way.
meh... a I the only one around here with a bad feeling about this? github, a commercial entity is gobbling up more and more community things with their closed source application... I know that git is distributed in nature, so no data can be lost in the end, but it still feels.... not-quite-right... 
They aren't "gobbling up" anything at all. They're providing a service - nothing's forcing you to use them. And the fact that some big projects (most notably rails) are going to GitHub should tell you that the open source community as a whole thinks GitHub is a good idea. Sure, they're a commercial entity, but that doesn't mean that they're *bad*. If you don't like them. clone the repos you care about and set up a mirror somewhere else.
I agree it's a good thing. I look at it as a commercial entity giving to the open-source community, while at the same time making money without which they wouldn't be able to host FOSS repos anyway. 
&gt; And the fact that some big projects (most notably rails) are going to GitHub should tell you that the open source community as a whole thinks GitHub is a good idea. No, that tells you that people behind some big projects think GitHub is a good idea. The open source community is likely much, much larger than you think.
what's up with Sun's propaganda? Article simply too biased and bitter to me.
Heh, I just had to roll around in the #nodoc sections of ActionView the other day to figure out how to do _exactly_ this. Pretty gnarly.
Netbeans is definitely my platform of choice when developing ruby or rails projects. It just makes the whole process really easy, and debugging is as easy as clicking a line number. Built in svn support means I can work on any platform, windows, linux and mac os and have the exact same workflow.
FWIW, I've been using Netbeans instead of Eclipse for Java development and am quite fond of their Ruby support too. If faced with the choice, I'd take Netbeans over Eclipse. FWIW though, Komodo Edit is a pretty good free Ruby editor too... 
I agree. Definitively had the "JRuby is the best, biatch" feel to it.
I switch back and forth between aptana (eclipse) and netbeans. I think netbeans is superior in many ways but for whatever reason I do keep opening up aptana once in a while. I would be great if I didn't use two different IDEs though. 
Where did this come from? Is this a part of DBI or what? 
So, most of them? What does something like 'Ruby for Rails' teach you that the pickaxe, The Ruby Way and the Flanagan book combined won't teach you about Ruby? Has Dave's book been updated for Rails 2.0 yet, and if not, what does it add that you won't get from Obie's book? And you read ESR's musings, but don't need a single Javascript book? Wha?
&gt; Well, I’m the guy that buys them for FiveRuns, so here’s a snapshot of our bookshelf. Meaning the developers at FiveRuns are great Ruby/Rails developers? I would expect great developers to be reading far more CompSci-style books. This looks more like "hey, it's on the company dime, so ..." I'd want to know what books developers are paying for out of their own pocket, and which ones they would in turn recommend.
Agile Web Development with Rails has just released the beta of its 3rd edition, which is updated for Rails 2.0. http://pragprog.com/titles/rails3/agile-web-development-with-rails-third-edition 
To be honest, if it aggregates and replaces the million and one flakey personal SVN servers which seems to be the bedrock of the Rails plugin ecosystem then I just don't care. If I did actually care, I'd check the Github T's &amp; C's (http://github.com/site/terms) and see that they hold no IP over whatever you put up on there and are therefore gobbling nothing. It's up to the user to apply the right license (GPL or whatever) to their project which would then be protected by the same laws that help to protect all OS projects. 
I find the release numbers for this package highly amusing.
Nice ad.
Damn. Now i have to switch language :S
Upmodded for the sheer pedantry of it (I'm assuming it's tongue in cheek!).
I don't see how this is any different from people posting stories to reddit about their product launches, or really anything else that might make them money eventually. However, if people are bothered, I'm more than happy to delete it.
____, where's your code? If you put out nearly as much as jamesgolick and you one day start a school, I'll personally post a story about it here for you.
How great would this be if it was serious, and it was used as another reason for people to bitch about Ruby on Reddit? BTW, we all know that Lisp is wrong. They don't even have an official logo!
&gt; I'd like to mention that the MagLev team plans to reach out to and support the Ruby community, and we hope that community members see some compelling reasons to contribute to MagLev. How is the community supposed to contribute if the licensing is supposed to be like GLASS (http://seaside.gemstone.com/) ? This shows huge potential, but the licensing worries me.
I do not speak for GemStone, but: the Ruby libraries used by MagLev will almost certainly be open sourced (and hopefully shared with Rubinius to whatever degree is possible). The Ruby-to-bytecode compiler I am working on most likely will be as well. The only real question is about the licensing of the C code that makes up the VM and persistence architecture, but that's code with a much smaller base of potential contributors.
You didn't post the story about Golick; he posted it himself. Hence, nice ad. 
Ideally, a post should make for a good topic of discussion. What's the discussion topic here?
I think your post is fine James. I like your approach at training. 
Interesting, but there's still plenty of potential for it to become another [Java trap](http://www.gnu.org/philosophy/java-trap.html)
Thanks for pointing out that RubyGems 1.1.1 was available, but you're being far too overdramatic. I had the gems.github.com source added with RubyGems 1.0.1, and I didn't even know I had a problem until today when I ran the `sudo gem sources -r http://gems.github.com` and saw the errors go by as it updated (?) the source before removing it. It obviously didn't break my installation. And if I had noticed this before, the first thing I would have done was look for a way to remove the source. Stop treating your readers like idiots.
This already existed as a well-used plugin, but I just discovered it as a gem, which is much more handy, IMO.
WTF is it? That page was useless...
techno, I do speak for GemStone :). Simply put, we haven't determined the MagLev licensing model for the C virtual machine/persistence code that Avi mentions above. Several options are being considered internally, I'd be interested in hearing your suggestions. 
Which part was useless? The part that explained exactly what it is and how to use it? Or a different part?
I'd really only be interested in it if the whole stack were Free Software. I understand that may not be compatible with your business goals, in which case that's fine; you're allowed to target a different segment of the market than free software hackers--that seems to be a popular pattern in the smalltalk implementor crowd.
This is a great initiative. Gives us regular Joes a change to contribute too :p
Coming in Rails 2.1.
As long as there is a affortable way to build technology prototypes, even for small and starving startups I think the licensing model will be sound. Free up until 2-5gb databases is a model I can definitely see a startup using. 
Very nice. Where are they on thread safety and pooling?
Fantastic move. Nail struck perfectly on head.
Impressive line up: Tim Bray, Sun Microsystems, Inc.; Mark Driver, Gartner; Thomas Enebo, Sun Microsystems, Inc. ; David Koontz, Happy Camper Studios; Rich Manalang, Oracle; Sarah Mei, Independent Programmer; Charles Nutter, Sun Microsystems, Inc.
java.sql.SQLException: Invalid column index Guess it's not a Rails site.
Well, Sun is supporting JRuby, but it's still Sun.
Ever since I saw the [CSS way of menu selection](http://www.therailsway.com/2007/6/28/free-for-all-tab-helper-summary), I've never looked back. 
Your questions still stand but it is worth noting that this is a list of books that "great" developers read. That means no introductory should appear. Texts like The Ruby Way are not introductory (nor the Pickaxe, being a reference).
I don't get it. The two codes are not equivalent. The metaprogramming sample deals with arrays while the non metaprogramming one doesn't. 
&gt; The metaprogramming sample deals with arrays while the non metaprogramming one doesn't. negative ghostrider. The metaprogramming sample accepts key, value pairs from the hash, and if it's an array, sends the second value to the function named by the first. It then creates a function which multiplies self * the product obtained in the first step, and calls the resulting function m_{second, minute, etc...} The second version makes that explicit and removes the m_ prefix. edit: me == wrong! doh.
malcontent is correct: the type checking and multiplication are performed inside the defined functions, every time they're called. I replaced that with a properly precomputed `amount`, and the metaprogramming version became "only" about 50% slower than the vanilla version on MRI. Certainly not ideal, but still an improvement. JRuby (1.1.1) fares a little better, but there's a noticeable difference there too.
It's entirely possible to get identical performance in this case by using eval instead of define_method. Using eval will result in the same exact code as the hand written one. In certain cases it can be more readable, however I would say this isn't one of those cases.
This is pretty weak. "I wrote some code with metaprogramming, and it was slower, therefore avoid using metaprogramming!"
I meant to say that you need to be careful and in general try to avoid metaprogramming if it you can since it might be slower and harder to read. Now, metapprogramming is awesome, I'm not saying: don't use it! ;)
Sweet! I've been waiting endlessly for open source small-group software. Not all of us want to take on MySpace or put all our private information on someone's server with no way to guarantee that it'll be there tomorrow.
100% in agreement with you there. Please do check out the app and let me know if you'd be interested in contributing!
I couldn't agree more with your article. Very aptly written and an enjoy to read. 
Well written, educational, and I'm sure therapeutic for the author. I approve.
he is a sick, sick man.
The alternative is to not use them, duh!
Wow, amazing!
&gt; For most ruby data structures, x.hash == y.hash is implied by x == y, and everything works fine. But, not for Hashes themselves!
This site is addicting as ever!
Thank you! After i read the article i was wondering just this but didn't have the energy to actually look it up.
Merb is sure a great project and there's something useful in this article, but with the author's lack of maturity, I'm not sure if it deserves an upvote.
The author of this article has done more to turn me off to Merb than any missing feature from Rails. If this is what I can expect from the community he was referring to, I have no interest in anything they have to offer.
Yes I've been following Merb eagerly .. but this article didn't tell me anything more than what looking at the site would plus a few self answered questions. Could have done better without the snarky webframework in-fighting attempts. But .. a mod up from me. I really like where Merb is heading. 
Yeah, I'm not a huge fan of the rhetoric in this post, but it's interesting enough to warrant an up-vote. I'm definitely waiting around for Merb to hit the "holy" 1.0 mark before I investigate it - perhaps I'm teh n00b r41lz0r of which he speaks!?
The author of this article failed in more ways than one.
pwned!
The article is basically what the title said, and I found it informative enough in that regard. Honestly, I don't know how the rest of you guys commenting here can bear reddit for more than five minutes if the author's mild snarkiness is enough to offend your sensibilities. 
I like how Michael Klishin, disabled the comments on this post after he got so many objections to his tone.
What a terrible article. It makes me never want to use merb. Here is a serious question for you. Why merb and not ramaze?
FAIL
Because compared to Ramaze, Merb is as 'magical' as Rails.
Good List - If only for pointing me to the grand prize winner's entries. It provides some great info for new Rails users.
I guess they haven't succeeded in trimming down merb enough!.
Why wait? Ramaze, sinatra, and lots of other frameworks are already API stable. 
Why are all those plugins moving to gem lately? I think plugins are a well defined way to extend rails, whereas gems are more like packaging and distributing *ruby* libs. Isn't it? And in this case in special I really prefer having annotate_models as a rake task than yet another binary.
"Are any of those reasons Windows' fault" Okay, let's see how many operating system these days are based on Unix or are POSIX compliant... Ehm... pretty much all of them? Yeah, except Windows. How's any of this *not* Windows's fault?
It's Phusion Passenger ;) Not Passenger Phusion :D Just thought it'd point that out to you hehe. Thanks for the plug!
I'm pretty sure that Dreamhost is in the shared hosting ghetto. I think it is ghetto fabulous that such a cheap Rails hosting option is now available.
Can you tell us if phusion handles files well? That's been one of the weak spots in rails.
Ruby on Rails support sucks on Windows because it's not Unix-based? I find that a hard argument to believe. It seems much more likely to be the case because the community has shunned Windows, by and large.
Just monkeypatch it :o)
If you mean static files, [this section of the troubleshooting docs](http://www.modrails.com/documentation/Users%20guide.html#_static_assets_such_as_images_and_stylesheets_aren_t_being_displayed) indicate: &gt; Static assets are accelerated, i.e. they are served directly by Apache and do not go through the Rails stack. 