I took this harsh reality into my own hands recently. Sometimes depressing, but potentially informative: [BundlerTimer gem](https://github.com/bassnode/bundler_timer)
Yes. It's funny because we've all seen that comic.
Then I will never use Isolate. Not supporting building/using git repos is a major deal-breaker for most of my Bundled projects. Also, telling me that I shouldn't be using Git repos in development does not help me.
ONE BILLION DOLLARS
oooooooh method_missing.
Other than [Railscasts](http://railscasts.com) and this does anyone know of other sites which provide video tutorials for Rails 3? Paid is fine, free is great.
Not free: http://peepcode.com/
I've used the Sobel operator for edge detection but had forgotten the name. The filter was still in my mind... more or less. Thanks for that article.
Is there a modern alternative to ncurses?
cool story bro
railstutorial.org is a free and legendary Rails tutorial that is probably the most comprehensive tutorial to date. you can buy it in screencast form for $85.
what a horrible way to construct a contact form
There is an old ActiveRecord plugin that does much the same thing. http://svn.protocool.com/public/plugins/enumerations_mixin/README_ENUMERATIONS I don't know if it's been kept up to date or not, but I used it in an old Rails2 application, and liked it's semantics. The enumerations_mixin does indeed skip the dummy json stuff and just put it in the database -- and then I ended up writing my OWN dummy yaml layer on top, much like active_finite's approach. And THEN I realized, wait, why do I really need this in the database AT ALL? Esp now with AR being somewhat a somewhat better documented interface than it used to be, I'm thinking I'd rather write my own thing to give you AR-relationsihp like semantics, but just have your enum cached in memory from a yaml, the end. 
Well, I did mention that there are two ways to add a contact form to a Jekyll site. One is shown in the post, the other would be outsourcing the contact form to http://www.foxyform.com/ or similar services, the same way comments are outsourced to Disqus and similar. That way there would be no need to add Sinatra etc. I agree in that it feels a bit weird to have a static site and then add Sinatra for a dynamic contact form, but I prefer this way so to be sure that the messages sent through the contact form are somehow private (I don't know if I would trust 3rd party services for this... they would be able to read what people write privately). In the end the contact form with Sinatra is just a tiny, self contained app, so for me it works.
I guess there are many ways to implement a contact form. Would you mind to say what you find "horrible"? 
anyone got this working with gedit yet?
Or you could just: require 'tempfile'; t = Tempfile.new('seed'); system("vim", t.path); eval t.read
Seriously if you have trouble with FTP or SSH, you really shouldn't be programming anything for anyone. 
The cake is a lie. So someone needs to update the testing libraries to show a cake when all the tests pass. 
Yeah, I really don't understand what problem he solved with this. He was deploying his app by... uploading it to a filesharing site and then downloading it on his server??
You might want to spell out TDD, it took me a while to get it.
I have always wondered about the usefulness of contact forms. Are they really any better than a mailto: link?
Haha, very nice.
Tee Dee Dee. You are welcome.
Playing Portal 2, there was such an emphasis on **testing** that I was thinking of this the entire time. Now, if only normal programmers could get a high on testing like Wheatley did. :) 
Here's a thorough explanation: http://www.igvita.com/2009/02/04/ruby-19-internals-ordered-hash/
Good questions. I've had some time to change some things based on your feedback. &gt;the usage ends up begin a bit verbose. you have to create a dummy table for each enum, and then do another call to populate it. This is a good point. I've changed the implementation of adding enums to automatically create the table if it doens't exist. &gt;then you have to add model code for the places you want to actually use it. This isn't correct, you can use get_table or the newly added all_finite_tables to automatically define your models, no explicit models needed. &gt;also, what's the advantage of creating this dummy enum table rather than using an actual enum (mysql) or a varchar with check constraints (postgres)? You partially answered your own question. Using enum isn't portable between databases. I don't like using a varchar with constraints anyways because you still have duplication of data in the db. &gt; without automagical foreign key constraints (which would be a can of worms to implement), it really doesn't seem that useful. I agree that without foreign keys this is useless. I've built this to be used in combination with [foreigner](https://github.com/matthuhiggins/foreigner)
My use case is that I need the ability for my database to be used easily outside of rails + AR. If I was working with Rails only, I wouldn't mind keeping the enum stuff at the application level. Plus, like I said to jenseng, I think that its bad database design to duplicate this kind of info all through the database. For example, what if want to change 'Male' and 'Female' to 'male' and 'female'? That's much easier to change if Male and Female are only in one place. Now, that was kind of a dumb example, but more compelling is the ability to easily see the members of a paticular enum, instead of having them being implicitly defined throughout other tables. Thanks for pointing out enumerations_mixin. Looking at, the thing I dislike is the similar to what I didn't like about existing plugins: they approach enumerations as something that change at runtime and are on the model, instead of something that changes rarely, and should be part of a migration. Also, I really needed the ability to throw the enums in a data file since I'm working with large sets (&gt; 1000). It's pretty easy to convert them to valid json, but would be a huge pain to add them to a model.
 describe Cake do it "should be a lie" do subject.should be_nil end end
Good read thanks. It's nice to hear about the impact of business requirements, and domain specific challenges instead of pure technical problems/solutions for a change. Too many developers try to live in only the technical world, considering business driven changes interference to their work, instead of the core reason for their work and aligning their efforts to it.
It seems cool. I miss IPython when I'm in IRB.
Thats how i program. First write the Tee, then dee, and dee some more.
+1 will try tonight
I found that I can get a decent, almost pythonic IRB going with a few gems: * Wirble for colorization * ORI for getting the docstrings on a function (like python's help()) * looksee for finding methods available to an object (like python's dir())
The juicy features are 1.9-only. I guess I have some motivation to figure RVM out now.
I've been waiting for you to formally release this. Well done.
no, most features will work in 1.8 in MRI. The cool features rely on Method#source_location, and i wrote a source_location hack for 1.8. The hack works on all platforms except jruby 1.8 (it works fine in rubinius). So you should be fine with just ruby 1.8 ;) (unless your'e using jruby)
This looks great, but I mostly use jruby these days so :(
all features shoudl work in jruby in 1.9 mode, except you wont get colored output. This is due to CodeRay (the syntax highlghter i use) using a regex that is not supported by the jruby regex engine. A patch is coming soon and so jruby in 1.9 mode should be fully supported in the next few days. Jruby in 1.8 mode though will probably never get the full set of features as i can't get a source_location hack to work there.
I'm glad to see more irb alternatives, especially documented ones. For something much lighter, 1/10th the size of pry, see http://github.com/cldwalker/ripl . It's designed to be extendable and thus already has 20+plugins and 5 shells built on top of it.
awesome. I love the direction you're going with this!
fixed link: https://github.com/cldwalker/ripl (period at end gave 404)
Thanks
Cldwalker here, by the way, is the author of Ripl. ...Not that that's something to complain about, I use it everyday and I can vouch for it's wonderfullness. Also, protips: - `alias irb=ripl` - [ripltools](https://github.com/janlelis/ripltools) is great. (`gem install ripltools; echo "require 'ripltools'" &gt;&gt; ~/.riplrc`)
This was such a cool idea, i stole it and put it in Pry, but with a slightly more convenient syntax ;) In Pry you can now go: `edit-method Class#method` to open the method in an editor (using the ri syntax) Or alternatively use `edit-method my_method` for a method that's in scope! It also tries to fast forward the editor to the first line of the method :) very cool, and thanks for the idea! :)
Just added some new and pretty cool functionality (in the just released 0.8.3 gem) based on the `interactive_ruby` post here on reddit: You can now go: `edit-method Class#method` to open the method in an editor (using the ri syntax) Or alternatively use `edit-method my_method` for a method that's in scope! It also tries to fast forward the editor to the first line of the method :)
http://www.humblelittlerubybook.com/
You'll probably get some downvotes for rails-specific question (which would be silly, but d'oh) 1, 2. IIRC, heroku.com provides free hosting for rails sites with low resource usage profiles. Their deployment scheme seems to be very easy to use (git push, basically, or something like that). 3. Scaling is never easy, rails or no rails. You have to know your tools well to scale well, there's no way around that. The internets have a lot of helpful materials on rails scaling, though.
You may want to post to r/rails, you would probably get more concise answers there.
&lt;3 haml and the author of it -- http://hamptoncatlin.com/
Hampton created Haml and helped kick off Sass, but he's hasn't contributed to them for a couple years now. Nathan Wiezenbaum is the lead developer and has been for almost 4 years now.
It's pretty good, I like it, smarter than irb
Hate Haml, but love SCSS! Score!
a former company i worked at had this same picture but we put 'raking' in the bubble. i feel your pain!
who knows, maybe it is a revolutionary idea and bbq will become next cucumber :) it looks very engagingly
cool what's your fave feature
I have no idea.
Well, generally it agrees with the "unix" mindset so for entry level thinkers it's very easy to move around your objects and ask questions about your objects. Pry feels like irb with laser targeting features. Deep digging. I also really like the shell integration `!cat /etc/motd`
What can you do with Ruby?
I will give the author credit for pointing some of the less-known features of one of my favorite programming languages. However, trash like this needs to be erased from the internet: curl -s http://www.gutenberg.org/files/1080/1080.txt | ruby -ne ' BEGIN { $words = Hash.new(0) } $_.split(/[^a-zA-Z]+/).each { |word| $words[word.downcase] += 1 } END { $words.each { |word, i| printf "%3d %s\n", i, word } } ' | sort -rn Where I come from, we call people who do stuff like this a "dick". Why? No comments, pain in the neck to debug, and it's not reusable. The article *should* have ended by telling folks not to be dicks, and the other reason why nobody wants to use awk is because it encourages slop like this. Our hard drives have terabytes of space on them. There's no reason for this sort of thing any more. 
 class Foo def my_method 1 end end f = Foo.new.method(:my_method) f.call #=&gt; 1 f.to_proc.call #=&gt; 1 I'm not sure what he's trying to accomplish by converting a method to a proc and then wrapping it in lambda (yielding... another proc). Maybe he would serve himself well with a book on ruby, or just a copy of irb and ri on his machine. Either way, this is a really silly argument for javascript. Just because they do it different doesn't mean one or the other does it better.
While I certainly wouldn't want to maintain that, it looks an awful lot like a one-off (as are most of my AWK "programs", when I think of it). It could probably be rewritten to be maintainable and have comments, but then it would probably take a lot longer than it was worth, since you almost never need this kind of logic often enough to make it pay off. It's usually just easier to write it again the next time you need it.
I prefer #2 because it saves unnecessary typing. "Save unnecessary typing" is not a hard and fast rule, but it's a good rationalization for why I like #2. Maybe I like #2 because it places fewer restrictions on what book.author can be. In #1, it had better be nil for it to fail. With #2, it can be nil or false in order to fail.
using .blank? (if you're in Rails) will solve the "it must be nil" problem.
I prefer #2. If you're using Rails, you can use the #try method: book.author.try(:name)
I slightly prefer #2 because it is shorter AND more readable, which is good improvement for such a small amount of code. In Rails it might be further improved by book.author.name if book.author.present? or perhaps book.author &amp;&amp; book.author.name perhaps even? book.author.try(:author) In isolation, this looks good, but all of this postfix notation isn't a pattern I'd want to see repeatedly within a method or object (a sign of a flawed design). andand gem does a good job of hiding this kind of code smell. OTOH, we really are picking nits here, so I could go for #3 on throwaway programs.
This is considered a bit of a hack, but there's also book.author.name rescue nil It slurps up any exceptions, which would work nicely in the case of `book` also potentially being `nil`. After being a fan of the "writing less" way of coding Ruby, I now like using Ruby's ability to write descriptive code that reads a bit like English. So, I'd use #1 these days.
By itself I tend to prefer #2, but I use #1 sometimes if I'm testing for multiple conditions, most of which are true, e.g. book.author.name unless book.author.nil? and book.editor=="foo" and book.title=="bar" 
I have to agree here. #2 reads better, but #3 on simple programs. You should look at NullObject/Maybe() as well https://github.com/avdi/cowsay/blob/master/lib/cowsay.rb#L23
one off? book.author.try(:name) more than once? book.author_name
Other options: book.author &amp;&amp; book.author.name book.author ? book.author.name : "No name" If I had to pick from the two supplied, though, #2 all the way.
#2. I find that our brains work better with positive conditions. This means I will use 'if' instead of 'unless'...all things being equal. There are certainly cases where 'unless' is appropriate, of course. Also, #2 is more concise but not more terse.
&gt; It slurps up any exceptions, which would work nicely in the case of book also potentially being nil. And also can be a complete pain to debug if book.author.name throws a meaningful exception that explains your program's bug.
Exactly why I said it was considered a hack, and why I'd use method #1.
Exceptions are also many magnitudes slower than an if statement right now. 
I won't deny that I've used ruby, perl, awk, or whatever to write *simple* filters for messing around with the output of another program. Generally, if I can jam something out and I know for certain it will work in the first shot, I have no problem calling a one off. I'm talking itty bitty things that are no more than 20 characters of code. The example that I pasted in from the article is not a one off. I would challenge that the person who wrote this managed to get it to work in one shot. And, let's be honest, the way that the author wrote that is *not* the way it actually would have been written on the cli. In the real world, when that thing was written, it would have looked more like this: &gt; curl -s http://www.gutenberg.org/files/1080/1080.txt | ruby -ne 'BEGIN { $words = Hash.new(0) };$_.split(/[^ a-zA-Z]+/).each {|word| $words[word.downcase] += 1 }; END {$words.each { |word, i| printf "%3d %s\n", i, word }}' |sort -rn Completely unreadable. If it doesn't work on the first attempt (and it won't), then you probably should have just thrown it into the script. The same person who wrote something like that couldn't tell you what it was doing if s/he had five minutes later. *That's* the objection I was trying to make, so I apologize for not being more clear. I just fear any sort of encouragement for stuff like this, as I feel that it's just bad practice. Some of the most horrible things I've ever witnessed in computing have come in the form of one-line bangers like these (undecipherable 1500 character long sed/awk/perl/sort beasts). 
I'm assuming these are models and associations (likely in rails), and if that's the case, you should be doing: `book.author.name unless book.author_id.nil?` Both of your solutions above are doing a database call for the author, and checking if it was found or not. You can cut this extra request out of your call stack by simply checking the ID.
calm down
I had a bad day.
This really obscures the real purpose of the code... 
book.author.try :name it requires rails though.
#2. Its shorter and its more consistent with the ruby I see written by rubyists who are better computer scientists than I am.
Hmph, don't know why I never thought of that. Thanks.
Holy crap! It's my birthday today. 4 years baby!
I tend to be of the mindset that if you are testing for something positive, use 'if' and if you are testing for something negative, use 'unless.' eg: I would say: if foo ... end If I wanted to say if !foo ... end I would instead say: unless foo ... end That translates into one liners to. As such, I would go with #2
class Object def try self end end class NilClass def try obj = BasicObject.new def obj.method_missing(*) nil end obj end end
Not a fan of try since it invokes method missing in many cases.
There's a gem called "andand" which would make it book.author.andand.name which would just return nil if book.author was nil
I know you said it is a hack, but just to be emphatic; that *will* eventually lead to ver bad bugs in the most unexpected places for instance it might trap a signal by rescuing SignalException and you'll be scratching your head when your server fails to restart... or some other really unexpected behaviour occurs.
i will use delegation in this case
book.author.andand.name
#2
I like this way: Object.instance_eval { def unless_nil; yield self unless self.nil?; end } ... then... book.author.unless_nil(&amp;:name) or 'no name defined'
and _why?
At least for me, things like that get written one piece of the pipeline at a time, and then I munge them together. I'll readily admit I couldn't have written that and had it work on the first go, but I don't consider myself any sort of *nix CLI expert. I completely agree with your final paragraph, though.
Do you use a proxy for connecting to the internet?
I don't think so, however, if I'm using one, what kind of changes do I need to make?
I prefer this approach: class Author def to_s self.name end end book.author #this will either return the name or nil You can also do book.author || "Unknown" Hope that helps
Just a hunch but are you behind a web proxy? If so, you will need to tell gem about it. 
 ignore_nil { book.author.name } https://github.com/ssoroka/ignore_nil It uses the same general idea as Object#try in rails, but I like seeing all of the chained method calls together. But out of your options definitely #2 
I did a trace route and the result: &gt; 1 2 ms 1 ms 1 ms 192.168.2.1 &gt; 2 3 ms 2 ms 2 ms home.gateway [192.168.1.1] &gt; 3 5 ms 7 ms 5 ms 77.42.129.99 &gt; 4 5 ms 7 ms 6 ms 77.42.129.20 am I behind a proxy?
Yeah, I'm having the same issue today. My mac is working fine, but my Ubuntu box is borked. I can get to rubygems.org just fine. They're both RVM systems, I've tried with a number of 1.8.7 builds now. mike@mike-desktop:~/src/tracks$ gem update --system ERROR: While executing gem ... (Gem::RemoteFetcher::FetchError) SocketError: getaddrinfo: Name or service not known (http://rubygems.org/latest_specs.4.8.gz) 
This is sad. So much for learning Rails ffs.
I F'ING HATE Amazon. Take the link and put it in your browser: Firefox can't find the server at production.s3.rubygems.org. 
is there something funky in your /etc/hosts?
This is some sort of wonky DNS issue. One computer here is fine, one is hosed. It's not just for the updates, but for the gemcutter blog as well. Try purging your DNS.
yeah, I saw that like 10 minutes ago (I'm still trying to make it work ;(). Any suggestions?
/etc/hosts as clean as new.
I did the purging as I put DNS as a possible error, but nothing ;(.
Yeah, I'm stumped and am long past my days of troubleshooting DNS issues. It's not you, it's them. I had to reboot for some updates anyway and it's still hosed on one box, not on the other. Same LAN, subnet, DNS servers, etc. 
In your to_s example, book.author will return an instance of Author, not the name (which is ostensibly a String). Therefore, doing this will work: "Author name is #{book.author}" but this will throw an exception: "Author name is " + book.author so it's not exactly comparable to the OP's examples. 
Try production.s3.rubygems.org with 72.21.194.16
thank you, that worked! but now I'm having another error ;( &gt; ERROR: Could not find a valid gem 'rails' (&gt;= 0) in any repository ERROR: Possible alternatives: rails
thank you, that worked! but now I'm having another error ;( &gt; ERROR: Could not find a valid gem 'rails' (&gt;= 0) in any repository ERROR: Possible alternatives: rails
I'd seen this method before, but just didnt think about *why* it was being done. Makes perfect sense- thanks!
Sorry for not being more helpful, but this is really the best tip I can give you: Windows is the problem. You can't learn Ruby on Windows and remain sane. I tried and it's just so hopeless, there's always problems with gems and everything just seems to fall apart whenever you try something. I recommend installing something like Virtualbox and get any variant of Linux (or use something with osx). A *nix-based OS is just so much better to work with when coding Ruby. :-) Saves you a lot of hassle!
I tend to use #1 in this case, although I don't feel strongly about it #2 looks a little bit ambiguous to me, especially depending on the property name I can think of a couple (albeit obscure) situations where this could give you trouble: When using rails, book.author could be a boolean property of book. If the name were more ambiguous than "author" this would make your code less readable Again, not likely with this naming but if you were to change book.author from an object to a boolean, #2 could give you false positives and rase NoMethodError when you try and evaluate author.name
Anthony from DNSimple here, the DNS host for rubygems.org. Could you possibly send an email to support@dnsimple.com with the following information so I can try to troubleshoot it: 1.) OS name and version for the system that is not working. 2.) The IP addresses of your upstream DNS resolvers. 3.) The name of your ISP 4.) The version of Ruby and Rubygems that you are using. Additionally, if you haven't tried it already, you might want to try switching to Google's public resolvers (8.8.8.8 and 8.8.4.4) to see if that resolves the issue.
Two seconds off the startup time for a server app that runs 24/7? Is this what the Rails community obsesses over?
And, while we're discussing nil checking styles, `if book.author_id` would do it, too.
I prefer trpcicm's style of [inspecting the ID](http://www.reddit.com/r/ruby/comments/gyw0c/which_one_do_you_prefer_an_why/c1rbr5v), with a slight tweak to readability: book.author.name if book.author_id.present? 
We recently switched from CruiseControl to Jenkins and are liking it a lot better.
Same here - we switched from CC.rb because patching it every time I've upgraded something on the CI server wasn't fun.
They probably don't care about it so much for starting the production server. Where it's really annoying is in dev. Every time you do something that has to boot up the environment (start a console, run a rake task, tests when you can't use spork, etc) is going to take the hit. It's most annoying if you are having spork troubles and trying to fix an individual test having to wait extra time every time you try and rerun.
Imho `unless ...nil?` is a horrible pattern. It's a double negation, nothing else. There is no point in checking for nil explicitly, since the odds that author is `false` are fairly low ;) I would do this: class Book def author_name author.name if author end end `book.author.name` is a demeter violation, and you'd be better off encapsulating that logic in a method. Rails even includes a nice helper to clean this up a bit, check this out: class Book delegate :name, :age, :to =&gt; :author, :prefix =&gt; true, :allow_nil =&gt; true end Then use it normally like this: book = Book.new book.author_name book.author_age
DNS appears to be fine for me, but the file latest_specs.4.8.gz doesn't exist on production.s3.rubygems.org
There was a change I think in rails 3 or so that caused the slow down. I guess, someone's interest was piqued enough to go investigate.
 $ gem install mongo ERROR: http://gems.rubyforge.org/ does not appear to be a repository ERROR: could not find gem mongo locally or in a repository $ wget http://gems.rubyforge.org/yaml ... 302 ... wget: unable to resolve host address `production.s3.rubygems.org' 
#1 is a double negation of sorts (I see nil?/blank? as negation). I would do one of three other things: book.author.try(:name) book.author &amp;&amp; book.author.name book.author.name if book.author I don't know which one I'd use more often.
Except my Ubuntu and Mac have the same problem. 
Following the DNSimple's advice I switched from our in company servers (these are private, you're not using them) to standby bind instances in my building and I was A-OK. dig'ing with Google's servers works too by the way. I can't explain, nor reproduce the situation where one worked and one didn't. 
You can modify /etc/resolv.conf by adding the Google name servers (above the first one) for 8.8.8.8 and 8.8.4.4. Add these entries above your first nameserver entry. (In my case, I had to comment these entries out after I updated my gems since my local DNS has entries for local hosts that I couldn't see anymore.) Or you could just add the following to your /etc/hosts file: 72.21.202.153 production.s3.rubygems.org # I've also seen some posts pointing to 72.21.211.188 Either way, it seems like some changes haven't propagated to all DNSs yet - once that happens, you can remove the entries from your resolv.conf or hosts file.
I've used CruiseControl.rb in the past, but was hoping Jenkins - or gawds, anything - was better than that :)
Well your hopes should be confirmed then.
I've been very happy with Hudson/Jenkins. It's reliable, and fairly easy to understand, even though the web interface is enterprise-grade ugly. The fact that Jenkins is written Java hasn't been an issue at all. On the other hand, I have nothing but bad memories of CruiseControl.rb.
I took a minute, but: &gt; Aww snap! You can't respond to this poll because Ryan Wilcox disabled web voting.
Thank you all, poll is over (PollEverywhere's response count is limited to certain pay levels) See the results: http://blog.wilcoxd.com/blog/2011/04/28/ci-server-for-rails-projects-poll-results/
Thank you all, poll is over (PollEverywhere's response count is limited to certain pay levels) See the results: http://blog.wilcoxd.com/blog/2011/04/28/ci-server-for-rails-projects-poll-results/
On Mac OS X, it's best to add the DNS server entries to the Network configuration tab, not /etc/resolv.conf, as the system configuration daemons will periodically overwrite unknown entries. System Preferences &gt; Network &gt; (Airport or Ethernet) &gt; Advanced &gt; DNS tab.
Correct, it's only a concern for development. Spork doesn't work for us, still trying to fix that.
book.author.try(:name) || 'No name'
Thanks for that, but then, I still prefer to write it this way: book.author.name if book.author_id
 if (author = book.author) author.name end This way you avoid calling author twice (it might do something intensive).
If you look at the first answer, you can instead do: book.author.name if book.author_id
I pushed out a configuration change last night to try to address this issue. If you have a machine that was not able to connect yesterday could you please try it again today. Alternatively, if the issue occurs again please feel free to email me: support@dnsimple.com 
ok i tried both ripl and pry. i have to say that ripl is nice, it's light modular etc, and the plugins are ok, but, to my mind, it's not really comparable to pry which is really a game changer, it just has so many new and cool ideas. ripl just seems to be a light irb, pry is something totally new and different. just my 2 cents
I'm not so sure about how that reads when looking at an individual test, but I certainly agree on the issues with long/short scenarios in cucumber. Something that I've had in mind for a while is something like the context blocks you can find in shoulda, which allow you to in each test, setup a particular situation (such as, having an book exist), then nest your tests into those that depend on that, and other deeper situations. The one thing I don't like about how shoulda does this, is that it performs the setup block (for each context) before every test, instead of before each context once.
Thanks for this :-) Just today I was looking at some code that gathers data from multiple servers daily and that needed to be converted to a multiprocess or multithread model to increase speed. This is a perfect template! 
Are you going to do a follow up doing the same thing in an evented and forked codebase?
I know I'm late to the party to answer this, but using unless with a .nil? check feels like a double-negative to me. I like unless when called for, this doesn't appeal to me. I would go with #2.
Gary Bernhardt is a pretty cool guy, eh makes cryptic comments on Twitter about software engineering and doesn't afraid of anything.
What does the semaphore on the yield buy you? Since the yielding thread which has just done the pop, (yield-er) has control at that moment as it is the one about to push out the value via yield, does it need a semaphore? Wouldn't it only pop out the value via yield to one thread since it is the caller, not the callee there? If I have this wrong, please explain in as much detail as possible as this is interesting to me.
It does have some value in production, particular in massive shared host environments where you want to shut down an idle app and start an app that's now receiving traffic. Saves you a ton of money compared to assigning dedicated resources for each app.
You might be thinking in terms of fibers where one has control over which fiber is executing. Threads are scheduled by the Ruby runtime- at any moment one can be stopped and another started.
source available? I'm interested in learning MacRuby.
I'm afraid not, I hope to submit it to the Mac App store once I get it out of beta. I posted hit here more to show what MacRuby can do. The learning curve was really shallow, it just took some studying. I recommend the Peepcode screencast even though it is a little out of date, and http://ofps.oreilly.com/titles/9781449380373/
Did you come to MacRuby from Objective-C?
great post and great help...I hope many more rubist do the same...
it's getting enterprisey in here.
Nope, I come primarily from the Ruby side, although I had dabbled in Objective-C a little bit.
I dont want to code with you.
All the benefits, a few of the downsides. Benefits: auto-clustering, background tasks, nice threading, java libs for free. Downsides: large base-case memory usage (although scales ok), jruby != normal ruby in some cases. Jruby takes ages to boot, making rake spec and friends painful. I think it's worth it, but certainly not for all apps.
that's not a bad idea. Any particular request for library/framework?
I don't quite understand you, but I'll try an answer to see if it helps. The semaphore ensures that only one yield happens at any one time, effectively serializing back to a single "thread" to pass back to the calling code. This means that the user of the function doesn't have to know anything about concurrency. As eegreg mentioned, without the semaphore the ruby runtime could switch to another thread when you were half way through the yield.
Evenmachine obviously. Most people understand forks and forks don't cause the same kinds of headaches as thread. After that fibers because most people don't understand fibers either.
I might give it a go. The download is huge!
`dotty` is already name of one of Graphviz tools.
It has 'dottie' as an alternative executable now
Once again we have an excellent example of How To File Bugs: * Write about bug in a blog post * Don't submit bug report * ??? * Bug gets fixed! There's even extra bonus points for the commit on some random github fork!
This is a nice overview for socket implementation but what about other types of concurrency? 
This is a nice overview for socket implementation but what about other types of concurrency? 
Heh, smaller than it used to be! I'm not associated with the team, but I harass them in the irc channel. They're super awesome at helping, so join up (#torquebox) on freenode.
... assuming we are using ActiveRecord. I had the impression the OP was asking a more general question.
Good article, but it would have been nice to see a little deeper coverage; in particular the different reactor implementations and how Windows async is handled (hint: not select()). The blog format doesn't really tend to cope well with longer discussions, so don't get me wrong, this is great. I was just craving something new.
EM is a reactor that has a heavy focus on socket-based communication. There are good overviews of concurrency styles elsewhere, especially around the time apache2, lighttpd, and nginx were under heavy development (they all implement concurrency very differently). The C10k link probably covers it pretty well, too.
Then IMHO author.name if book.author looks better
Actual linguistic analysis content regrettably lacklustre. :( I was thinking linguistic analysis would be involving actual word-by-word or structural analysis, not just readability scores and stuff (which is fine in itself!).
It's in spanish.
If you go the non archive way (like using capistrano to deploy the app to a directory instead of a WAR or whatever), you don't run into this. Good to know if I ever decide to go the archive route, I'll have a way to make it work. I guess this is one of the reasons why .bundle is in .gitignore by default in a Rails 3 app.
Au contraire, hombre, it's in some kind of late Latin dialect.
I dug your Exceptional Ruby talk in Bend; looking forward to picking up the book!
I've been reading it. I endorse and approve of this electronic internet eBook.
This doesn't necessarily solve the problem. You can have author_id set but a variety of scenarios could lead to that ID pointing to a non-existent record.
[Translation](http://translate.google.com/translate?js=n&amp;prev=_t&amp;hl=en&amp;ie=UTF-8&amp;layout=2&amp;eotf=1&amp;sl=auto&amp;tl=en&amp;u=http%3A%2F%2Fgrigio.org%2Fvelocizzare_webapp_template_html_che_funzionano_sia_lato_server_che_client_twitter)
maybe italian? Anyway ruby is ruby also in italian :P
maybe italian?
Yeah, it's Italian. Looked like Spanish on my iPad.
Yeah, I was just checking out the sample on the website earlier today, and it looks really useful. Thanks a bunch. I will definitely check it out. 
Your iPad makes Italian look like Spanish? Cool. 
Your talk was one of the most interesting ones at MagicRuby in Orlando! The book looks great!
http://blog.zenspider.com/2011/05/rubygems-18-is-coming.html for a bit more info (also: http://www.reddit.com/r/ruby/comments/h4c1g/rubygems_18_is_coming/ )
And no mention of turning off rdoc and ri generation by default. As much as I don't /really/ want to reignite that flamewar, the ability of the rubygems maintainers to completely ignore the way the community uses their software is a bit boggling.
Thanks so much!
We didn't mention it because we didn't do it. Not hard to understand, really... As far as doing it goes... DHH's legion of +1 lemmings are not going to be able bully us into a bad idea. If you don't like having documentation at your fingertips, turn it off in your .gemrc. `ri Gem::ConfigFile` for details... oh wait... I guess I should also point out that DHH's +1 lemmings do not equal "the community"... just a very vocal subset. Kinda like the teaparty.
Why would you want to turn off ri and rdoc? They're useful.
Do you guys have any plans to do something like apt-get update apt-get upgrade for gems? In other words a way to fetch the index and store it locally so it doesn't have to hit the internet every time I do a gem search -b 
because they take 1000x longer to install than the gem itself.
I'm looking forward to this also. Thoroughly enjoyed your Confident Code talk at rubynation
TL;DR, but good work bob. Now can you add 1.9 support for RubyParser? :)
 % gem search -V -r hoe *** REMOTE GEMS *** GET http://rubygems.org/latest_specs.4.8.gz 302 Found GET http://production.s3.rubygems.org/latest_specs.4.8.gz 200 OK ... % gem search -V -r hoe *** REMOTE GEMS *** GET http://rubygems.org/latest_specs.4.8.gz 302 Found GET http://production.s3.rubygems.org/latest_specs.4.8.gz 304 Not Modified ... 
Did you _read_ my blog post?
and? If I had to guess, you use bundler... which means you don't value you time to begin with. 
yup, having these lines on my .gemrc really helps for quick documentation. gem: --no-ri rdoc: --format=hanna for those who really want to turn it off, do it on your .gemrc it'll only take 1 menit of your time. 
because you can build and read them later with gem server &amp; yard. Building the docs when you install really does waste time if you aren't going to need them 99% of the time.
Thanks for the update on how rubygems is coming along. I think you're right that a lot of the backlash from the community is unjustified, and due largely to poorly implemented, or out of date gems. My impression is that the many gems being stuck using out of date gem methods is in part due to the low barrier to entry of releasing a gem (which should be a good thing), and in part to to the long amount of time that rubygems went unchanged until the recent burst of activity. It sounds like it won't be too long before we're through a bit of a pain period, and rubygems and the ruby community will be all the better off for having gone through it.
minute*, 'menit' was a really really bad attempted jeez
How do you manage gems and their dependencies in your projects? We've relied on bundler pretty heavily for a while, but you're right, I've wasted at least a few day's time fetching the rubygems index...
no lol, u use bundler i use isolate
We use isolate throughout all our projects.
Do you have any numbers to back up the claim that most people want the defaults to stay, or is it just a hunch? (I don't really care either way, but I like hard data)
If you're still seeing this behavior after running `gem pristine` then something is most likely wrong. If necessary we can try to diagnose here, but it'll be a lot quicker if you can catch drbrain or me on irc.freenode.net in #rubygems.
Can we also get an option not to reach out to the net at all?
Thanks for the encouragement... It is my hope that the increased velocity on the project will get things set right. Most of the problem that I've seen is not in poorly implemented or old gems, but in abuses to rubygems by bundler. It was especially difficult because it always looks like rubygems is causing the problem when all we're doing is inadvertently breaking a monkey-patch. We're working on getting that all fixed up in bundler too, so hopefully in the next release or two (by both projects--synchronized) will clear almost all of that up.
I don't think that `gem:` line does anything at all for you. ETA: and the `rdoc:` line will have hardly any effect on speed... Most of rdoc time is spent (painfully) parsing. 
Definitely need to give that a try. Just perusing through the codebase gives me the warm fuzzy, whereas the same trip through bundler is... mind-melting. Thanks!
Nice FUD. How about some numbers? % rm -rf tmp; time gem i -i tmp minitest ... real 0m5.720s % rm -rf tmp; time gem i -i tmp minitest --no-ri --no-rdoc ... real 0m1.631s So, an extra 4.09 seconds or 3.5x slower... _Hardly_ 1000x slower. Granted, minitest is a lithe well-written project (with 100% doco) that's probably very easy for rdoc to parse. I'm sure it is worse on larger or uglier projects, but it will never approach 1000x. Even rails is only 9.3x slower. With such a complicated set of libraries, having doco readily on hand seems more than worth it... **Especially for those that need it most: people new to rails**. If the documentation was off by default, it'd only be that much harder.
Do note that Isolate is also using some of that deprecated API so it is a bit crufty right now. We're hoping to get that cleaned up soon.
Fucking hell. Do you have any idea the kind of grief you're causing ruby developers?
zenspider didn't make that claim (at least in this discussion)
heh yes, I was trying and failing to be funny ;)
please, never `gem install` anything again then. 
Do you mean like: `gem search -l` `gem list -l` ? Or, if you've got the source of a gem locally, you can always `gem build` it.
You're welcome to stop using rubygems at any point in time. 
I too am having the same problem after running "gem pristine ..." Some of the notifications disappeared, but I still am getting: NOTE: Gem::Specification#default_executable= is deprecated with no replacement. It will be removed on or after 2011-10-01. Gem::Specification#default_executable= called from /Users/Ciobi/.gem/ruby/1.8/specifications/json_pure-1.5.1.gemspec:10. NOTE: Gem::Specification#default_executable= is deprecated with no replacement. It will be removed on or after 2011-10-01. Gem::Specification#default_executable= called from /Users/Ciobi/.gem/ruby/1.8/specifications/rest-client-1.6.1.gemspec:10. NOTE: Gem::Specification#default_executable= is deprecated with no replacement. It will be removed on or after 2011-10-01. Gem::Specification#default_executable= called from /Users/Ciobi/.gem/ruby/1.8/specifications/showoff-io-0.2.9.gemspec:10. 
I've had the same problem. Using `gem pristine --all` without the `--no-extensions` seemed to do the trick. Edit: If you are using rvm, you may have to repeat the action for each gemset.
I am offended, good sir. We do not like being compared to the tea party.
I noticed there's been a lot of updates this year already and I couldn't see it anywhere so just wondered where you are headed with all the recent changes? Is it just a bit of needed refactoring or is there a specific goal you guys have in mind? Do you have a roadmap somewhere? Thanks
Glad to hear it. I'll admit that I was certainly one of the ones rather annoyed by all the breakages recently, though this post has restored some faith in me that the recent activity is all around cleaning things up. Working together with bundler will be key, though great to see some progress going on :)
While it's not an ideal answer, if you install RVM, it will install a whole new ruby in another place, so you can use that and avoid using your (broken) system ruby.
I also have installed RVM, and that may be whats causing some issues (system vs RVM) My goal is to get back to just system ruby, and build it back properly. How can I nuke RVM and my gems?
I run linux and I'm pretty sure that all I have to do is remove .rvm/ in my home folder.
I'm not a huge fan of RubyParser's output, and I'm not too familiar with the source, but I thought it used racc. If that's the case... it's just a matter of painstakingly switching the rules used to the new rules in the 1.9 Bison grammar. Except... the lexer. Ugh. Since Ruby has a custom, complex lexer switching RubyParser's lexer to a 1.9 compatible one may be an annoying issue. The best path would be to just write a C extension wrapping the 1.9 lexer, or use `Ripper.lex` from Loren Segal's 1.8.7-compatible Ripper gem.
it's obviously hyperbolic. also minitest? are you a child? you really pick something known for its brevity for your comparison? something that will never ever run in production? sure it's great when you're building a shopping cart for aunt fanny's homespun diaper emporium and you can look up the minitest assertions you can use on your tdd fun-runs. but for those of us that wear big boy pants and have to spin up half a dozen jruby nodes with multiple isolated app environments, this is a real pain. it's shit like this, ruby, that makes our ops story so horrifying. all these claims of knowing the *true* community (lol ur still on rubyforge) and claiming to be improving and fixing rubygems by breaking old packages is stupid. do you realize people think of rubygems' direction as analogous to the intelligent design movement because of the whack track you're on? 
except a C extension would defeat the purpose of a 'pure ruby parser' ;) A pure ruby parser would work without a hitch on all ruby implementations. We need it :) I'll send a hundy ($100) your way if you write it
does that take care of gems and the like as well?
I don't think you should go back to system ruby. Go RVM all the way. Take the time to read RVM docs. Make an RVM ruby yr system default. With RVM it easy to nuke any particular install and start fresh with a new one.
Ah, It slipped that RubyParser would work with pure Ruby (since racc always uses C for me). You would need a pure-ruby version of the lexer, too. Rough.
Thank you! May I quote you?
I believe so. I managed to screw up my installs the same way you did a while back. Gems installed using RVM live here: ~/.rvm/gems 
Yeah, RVM is entirely contained in your .rvm folder. It's nice like that! RVM should be completely different to your system ruby though - if you're having issues with the two clashing it's probably because you haven't got all the right RVM stuff in your path. Make sure you've followed the instructions about what you need to put in your profile and make sure you're using an RVM ruby - 'which ruby' and 'rvm info' are important commands for figuring out where you are :) I'm no expert, but hopefully this helps get you somewhere.
Agreed. I only use system ruby now for production servers.
What about rubygem installed gems? And thanks to everyone. Slowly but surely nukeing it all. 
It seems that you already need a pretty decent working knowledge of Ruby going into the course.
As others have said, RVM is probably the better option. However, if you want to nuke it all it's pretty simple. This is what I've done the few times I've had to do it - I really dislike RVM. Delete the .rvm folder from your $HOME and remove all the extra lines from the bash profile file, I can't remember what this is on Mac but try .bashrc .bash_profile and .profile. Close and restart Terminal for it to take effect. Then you can download and install the ruby of your choice (or use something like [Homebrew](https://github.com/mxcl/homebrew) to do it). Once that's done, you can install the latest Rails by 'gem install rails', this will ensure the 'rails' command is Rails 3. If your system rails is already 3, it won't do anything so it's safer to check. If you already have a Rails app in the works, then consider deleting everything in the Vendor folder and doing a complete rebuild with 'bundle install --path vendor', I don't know if this is strictly necessary but it's what I do just to clear everything out. I hope that helps you. It's probably worthwhile learning more about how RVM works but personally I really dislike it and much prefer working directly with the system.
Ya, of course! Do you want a more "professional" quote, or just this one?
rvm implode is probably a better and more complete option here.
Try following the instructions here: http://lists.rubyonrails.org/pipermail/rails/2006-May/038251.html Let me know how it goes.
Let me guess… You use Rails and it is OK by you for rails to change API. Why isn't RubyGems allowed to do the same?
Interesting idea, web based mentoring. Could be cool. 
~$ rvm system At the prompt will set your current ruby to system
Half a dozen jruby nodes! My goodness! You _do_ wear big boy pants! At that point, you went from a fairly good troll attempt to pathetically dick-wagging. Have fun with that.
As I said in my blog comments recently, we have no real road map at this point other than a vague going from "mostly sucks" to "partially sucks" to "partially rocks". I'm simply identifying those areas of the design that were bad to start and improving it. Deprecations are a natural consequence if we don't want to get totally tied down.
His point is that he wants to do remote searches with cached data. We _do_ use cached data, but he doesn't even want to check if it is stale or not. I'm leaning towards "no" simply because of the amount complexity (a fair amount) that will entail vs the benefit received (not that much). I just verified that remote searches work just fine if you have the cached data and you're not on the network. I still don't really see the point, but there ya go.
see my comment to MarquisdeBad
Normally I'd upvote a suggestion to use isolate, but it is clear from your comments throughout reddit that you're just a troll.
you're free to turn it off.
Then stop blindly following the likes of Glen Beck and DHH.
This looks like a legitimate bug somehow. If you could jump on IRC or file a ticket that'd be great. Thanks. 
I should add... If a little extra temporary noise is causing you "grief", maybe you're not cut out for this line of work.
**PLEASE NOTE** Using `gem pristine --all` without `--no-extensions` will cause problems with any binary gems you installed with build args (the mysql gem is the most common culprit). Until we build in the ability for rubygems to record and reuse how you installed a gem, please use `--no-extensions` and then individually do the rest.
AFAIK, not that much has changed lexically... and I've done a lot to clean up my lexer. All I really need is someone to donate failing tests and I can pretty much do the rest... or at least ping pong it back closer.
btw... as a total aside, you don't need to keep update-rubygems once you've upgraded. Feel free to delete that one.
rubygem installed gems should only be related to your system ruby.. RVM sets up a fully sandboxed ruby environment totally independent of your system ruby and system rubygems.. if it is RVM thats screwed up, as astjohn said: rm -rf ~/.rvm And do a fresh install of RVM
All the comments about removing .rvm and all subdirs are OK, but if you want to get back to bare OSX system and only the gems that come with system ruby, you need to delete ~/.gem (if it exists) as well after nuking rvm. The existence of this dir may be causing you troubles as well. See if you have .gemrc and delete it if it exists. Once you do all that, log out and back in and see where 'which gem' and 'which ruby' point. Ought to be your system path and not to a ~/bin/ directory or somewhere else in your home folder. (I can't recall if rubygem and thus t he gem binary comes with vanilla OSX or not) Same for other ruby/rails/gem related executables: If you installed rails, see if 'which rails' still points anywhere. if it does you have stale paths and need to clean these up before trying to reinstall. This all assumes you cleaned up the stuff in your profiles that rvm adds. I personally have found rvm very easy to use, only one rule if you use rvm NEVER run 'sudo {anything related to ruby or gems}' While I use homebrew for many things, I personally have found rvm the way to go for managing ruby, even if you only want one version and don't use gemsets. You know exactly where stuff is and it's very easy to start over from scratch if needed. HTH
It's not the warnings I object to. It's the general attitude of aggression and willingness to break existing code. 102k google results for "gem update --system broke": http://www.google.com/search?q=%22gem+update+--system%22+broke Like it or not, it's not your own little project anymore. The entire ruby ecosystem depends on your packager working, and every time you release a minor version, major gems (e.g., rails 2.3.x) break. This is a really bad thing. In my opinion, the best feature you can give the ruby world is to leave it alone and only fix critical bugs.
If you want to run old stagnant code, you're welcome to go back to 1.3.5, dated 2009-07-21. But I'd guess you probably bitched about that too. Sorry, no. I'm going to fix the code. It needs it. Badly. Rails 2.3.x broke because they ignored our deprecation warnings. They were nice and noisy too, but apparently nobody believed that we'd remove it. They had all the time in the world to fix it, but chose to ignore it instead. So now we're being very vocal that in order to move forward, we need to kill things off. If you don't like that, don't upgrade. Nobody's forcing you.
Hey look! Your FUD was almost reasonable! That is, until I saw that the top hit was from 2009... Filter for the last year and you only get 227 hits: http://www.google.com/search?q=%22gem+update+--system%22+broke&amp;tbs=qdr:y 
i wonder if you can use this to sync midi timing events across computers.. I've been looking for a decent cross platform way to do this for ages...
IT WAS A JOKE
weird, that's actually exactly what I'm working on now. I'll get in touch when I have it in respectable shape
&gt;His point is that he wants to do remote searches with cached data. We do use cached data, but he doesn't even want to check if it is stale or not. Yea basically like apt does. It never searches remotely it only searches using the local index. A separate command exists to update the local index.
Build a Linux virtual machine. End of story 
You should really be using --single-transaction on that mysqldump. That way its one nice consistent state during your backup process. Of course, that requires you to be using InnoDB. The option for MyISAM tables would be --lock-tables, but it is a terrible ideas as it locks them one at a time. You *are* using InnoDB, right?
Gotcha... in that case, no. We have no plans to move in that direction.
How about a tender, loving quote?
Having a not-fucked system ruby is still important. I agree, use RVM for all development, but there are some cases where software demands a system ruby exist and function as expected (like installing Command-T in Vim on Ubuntu...go ahead, try that with RVM)
Same issue, after doing the gem pristine stuff, I know people are hopping on IRC, I don't have access to it right now if the solution or link to it could be posted here that would be amazing. Thanks MacBook-Pro:~ john$ gem list NOTE: Gem::Specification#default_executable= is deprecated with no replacement. It will be removed on or after 2011-10-01. Gem::Specification#default_executable= called from /Users/john/.rvm/gems/ruby-1.9.2-p180@global/specifications/rake-0.8.7.gemspec:10. *** LOCAL GEMS *** NOTE: Gem::Specification#default_executable= is deprecated with no replacement. It will be removed on or after 2011-10-01. Gem::Specification#default_executable= called from /Users/john/.rvm/gems/ruby-1.9.2-p180@global/specifications/rake-0.8.7.gemspec:10. rake (0.8.7 ruby) rubygems-update (1.8.0)
Well in this case, as stated in the blog post, rake will continue to do it because it explicitly uses that parameter.
OK thanks, just wanted to be sure I'd done everything correctly. I can live with the warnings
highlevel language noob.
awesome, i use subsonic heavily, will give it a try update: connects to server fine, but can't play music
I fixed it only when I deleted all my local gems and then reinstalled them.
works with OSX now
helpful...
Interesting, tho why not just use https://github.com/hagenburger/lemonade ?
I believe this is coming as part of core Rails in the near future - I wonder how they'll implement it.
lemonade looks interesting. I must have missed it when I started the sprite-factory gem. I'll have to go take a closer look. Is it tied to Sass or can it be used with normal css ? I also wanted an excuse to play around with a bin packing algorithm instead of always generating horizontal/vertical strips. Its not in the first version, but I'm going to add it [soon](http://codeincomplete.com/posts/2011/5/7/bin_packing/). ( yup. another programmer reinventing the wheel !) 
awesome! that is so fantastic :) thank you for such an awesome project.
Your mom wants to code with him.
dup
"Definitely not as fast as Thin or even WEBrick, but not too bad considering its pure-Ruby." Then what's the point of using it even in development?
The point of net-http-server was to write a HTTP Server in far fewer lines than WEBrick, that could be read/contributed-to-by average Ruby developers. WEBrick's HTTP Parser is heavily optimized hand-written code, that is not documented. [Parslet](http://kschiess.github.com/parslet/) is still relatively new, and could definitely use further optimization, which would benefit net-http-server and other Parslet libraries.
i prefer passenger all the way. Harder to configure, yes, but you get a good development environment that is really close to what you get in production.
Nginx + unicorn is good too.
&gt; Harder to configure i see you've never configured sendmail before 8) 
absolutely, thanks!!
For the same reason, ruby, and rubygems would be effed if someone ran around deprecating malloc and free because they didn't feel like the implementation of C was clean enough, or if each OS were to change how files work each month. Lower level subsystems need stability more than they need pretty code and new features. Especially subsystems that frankly have been working well, and are pretty feature complete, like Rubygems. Updates like these waste thousands, maybe millions, of man-hours just to keep your working software still-working. The farther down the chain a program is, the more it needs stability to allow people to build upon it. Unfortunately, the rubygems folks are on about pretty code and the new hotness, not stability. The "big rewrite" and "breaking compatibility" when you can't *coherently explain any actual benefits* to anything other than your aesthetic and ego, are quite frankly, rookie moves. The current Rubygems maintainers would probably be happier and provide greater benefit working on a newer project where an aggressive approach and rapid evolution will be a benefit, like node.js, or even rails itself. 
I just add `local.myservice.com` into my `/etc/hosts`. Facebook API accepts subdomains as well.
Most of the so called breakage is a case of "you broke my monkey patch" as the removed features are used by less that 5% of users. If you want stability and maintainability then is needs to be implemented cleanly and stably which it was not. We're interested in stability in terms of lack of bugs and easy of extensibility not keeping around clumsy API. No, actually we wouldn't and we both have many, many newer projects of our own to work on. Also, we eat lunch with a rails core team member every day and it's worse than RubyGems, not better.
amen for this on production. As far as development web servers, passenger stand-alone or webrick will do.
I would not call passenger hard to configure anymore. You can just run "passenger start" within your app and works :]
@konstantinhaase correctly pointed out that GServer spawns new threads per connection, this is what degraded the performance of net-http-server. With only one connection I get decent benchmark numbers: https://gist.github.com/963589 I will implement my own ThreadPool in net-http-server 0.2.0.
Logger is ancient and either needs to be updated or ditched.
WEBrick creates a new thread per connection also, but supports persistent connections which I can't find in net-http-server.
Yep it's on the TODO list. But no HTTP Server should trust the client to keep the connection open. Ideally, it should handle the worst case scenario of one connection per request.
It's the server's job to make the request persistent, not the client. The client simply behaves appropriately according to the Connection header.
Right. But if the client is malicious, trying to exhaust Server Resources, the HTTP Server should not perform worse. net-http-server 0.2.0 will have a ThreadPool, probably using SizedQueue to prevent an explosion of Threads. I'll try to add Persistent Connections in 0.2.0 or 0.3.0.
Details on how to actually contribute might help.
&gt; To do my part, if you assign documentation patches to me on the Ruby 1.9 tracker on redmine I will commit them. I'll also keep writing documentation to fill in the gaps. To be fair, for those not familiar with Ruby, this still might sound a bit rough. Basically, I'd fork on github, write something up, use git-format-patch, open a ticket, assign it to him, done. Is this complicated enough to warrant some kind of blog post? Maybe I'll do it and write one up, if this is helpful.
Am I the only one that thinks that it seems a bit early for another release? Though, looking back at it, it seems that the minor/patch version is bumped about every year (1.9.1 on 30 Jan 2009 and 1.9.2 on 10 aug 2010). So my revised question, do you, a member of the ruby community, think that we should back down just a bit to stabilise things? 18 months? 24 months? or is 12 good?
Ya, I *think* sending a pull request is enough. I just don't know how github and redmine are integrated.
I've updated with a paragraph including a link to a coverage report ([here](http://segment7.net/projects/ruby/documentation_coverage.txt)) I spoke to Steve and I think he'll be writing up a how-to-contribute document which I'll link to.
drbrain just told me that a pull request is fine, but he can't merge it then, so Redmine means it's faster for him.
Thanks for the coverage report.
If you do end up writing a blog post, a few quick ideas on what might be useful: - A link to an official style guide, if there is one - How to (re-)generate docs to preview your work
Will do! Part of doing this is realizing that the official guide is pretty out of date. :( :( :(
Personally, I'd rather have frequent releases than slow ones.
Ditto.
why?
I'd like the rails team to make 3.1 work only with 1.9 to give everybody a shove in the right direction. 
Is there a way to set the default so rails s uses passenger (or mongrel or whatever) by default?
For mongrel (or thin), all you need to do is include the gem in your Gemfile then run `rails server mongrel || thin || webrick`. This unfortunately doesn't work for passenger so you still have to run `passenger start`. Hopefully this will change.
Why what? Why is it old? Why it needs to be updated? How about because it does not support syslog? How about the fact that you have to monkeypatch in order to do anything meaningful with it? 
Idem, I appreciate frequent releases.
Old does not mean not useful anymore...Logger is written in about 300 lines of clean code. Its aim is not to do something "meaningful", but to provide a simple general-purpose way of logging. What's the problem of using log4r or stdlib's syslog for more advanced needs like syslog support?
Redmine is the way to go so that it doesn't get lost. And even then you'll probably have to send a couple of reminders, unfortunately. Personally I pull the latest changes with bzr, write my documentation, and then use bzr diff to produce a patch which I post to Redmine.
I've been thinking for a while of having an alternative to the Google Summer of Code--The ATH0 Summer of Documentation. "Because we already have enough undocumented code." I don't have any money for big prizes, but perhaps we could have a leaderboard for lines of documentation accepted? :-)
This is more of what I was thinking. I really really like 1.9, but Heroku uses ree-1.8.7 still (1.9 is an option though), as well as most Linux and BSD distros pull 1.8.7 in when installing a generic "ruby" package (1.9 has to be specified). There needs to be a convincing reason to move to it though.
This is awesome -- very simple to use. I use it on eyeonmajors.com
Steve's tutorial on how to contribute is here: http://blog.steveklabnik.com/contributing-to-rubys-documentation
That was exactly what I was looking for. Thanks!
If you want to use syslog, Ruby has a perfectly good syslog library. It would certainly be nice to see logger have an option to use syslog, but I don't see the lack of one as being a deal-killer.
Glad to help. :)
the noob mayor of noobcity
The author starts off by talking about tests that pass because of mistakes. This is addressed by the TDD mantra: Red - Green - Refactor. Write your test first, **make sure it fails**, then make it pass, then clean up and repeat.
You can also use [FFI](http://github.com/ffi/ffi#readme) to wrap C libraries in Ruby, without having to write any C. Good example, [ffi-msgpack](http://github.com/postmodern/ffi-msgpack#readme).
A couple minutes later, [ffi-upskirt](http://github.com/postmodern/ffi-upskirt) is stubbed out.
FFI is of limited use when the library you're wrapping uses a lot of macros, as many do. Also, you're left with a Ruby API that maps very closely to the underlying C one, and so is likely very ugly. Further FFI wrapped libs are slow as all hell, a pure C extension is significantly faster - and the likely reason you're binding to the C lib in the first place is for speed. Also the rationale behind FFI in the first place (to allow multiple implementations to use the code) is obviated or about to be as many implementations such as rbx and jruby get increasing support for MRI C extensions.
* Just rewrite the macros as Ruby functions. They are macros, and are supposed to be simple. The macros will not change (hopefully) until a major version bump. * FFI is not that ugly, FFI has types for all the common ANSI C typedefs (like `size_t`). Also you can also easily define typedefs, enums, callbacks, Unions and Structs. * FFI is not that slow. You want to use FFI to interface to C libraries that perform the majority of the work in C, after you call an API entry-point function. That way the only performance hit is calling into C. That's the whole point of having a C library that processes Markdown, you make one call with the Markdown source, and it returns HTML. * Another reason your binding to C libraries, is because those libraries perform low-level actions, or implement very complex tasks (like `libmount` or `libelf`) that are not trivially reimplemented in Ruby. * FFI bindings work perfectly on MRI and JRuby. Rubinius is the only Ruby implementation that does not that have a fully compliant FFI API, because they cannot include the upstream FFI code due to their Licensing. Upstream FFI is working on splitting apart the C extensions to `libffi` from the Ruby API.
&gt;If you want to use syslog, Ruby has a perfectly good syslog library. Ruby has a perfectly good X library for whatever X is. Does that mean that the standard library should never be improved or never changed? 
I thought speed would be a good reason but people are sticking with ree because apparently memory usage is a more compelling reason. If they enabled tail call optimization and copy on write in 1.9 and get rid of the GIL maybe that would be enough.
http://imgur.com/a2VuX Seriously, though, never heard about pow before. Thanks for bringing it up.
If you wanted to improve logger to have an option to also send to syslog, I'm sure the patch would be welcomed.
"I suggest and use threading even though I don't know anything about it" - seriously? This is what I hate about some programmers these days, using code and concepts without knowing anything about it.
1) if $20 is expensive then your only real option is heroku. their paid services are pretty expensive, but you can get pretty far with free for a low traffic app. 2) i don't know your pain tolerance here. capistrano is pretty straight forward. since heroku deploys are about as complex as a "git push" it might be another +1 for them. 3) even people who understand their stack have a hard time scaling. it's a universal constant. also depends on what scale you are talking about. most people get by wonderfully with a properly indexed data store and fragment or page caching. tl;dr sign up with heroku
I admit, I LOL'd. Have your upvote, sir.
Here are issues I've had using FFI for real world projects (nokogiri (libxml2), nfc (libnfc), csspool (libcroco)). * If struct layouts ever change, you're screwed. If you were using a compiler, it is a non issue. * All decisions must be made at runtime. This means that if you have different code paths depending on the lib, you must make that decision every time you run, rather than testing macros at compile time. This makes things slow and difficult to test. * Debugging is more difficult in gdb. Get a nil pointer, or weird struct setup? Good luck debugging. These were killer problems that made me shy away from FFI except for when wrapping the smallest of C libraries. Don't get me wrong, if your C library has few entry points, FFI seems fine. But once you start wrapping larger C libraries, FFI will become more pain than it's worth. As such, nokogiri is dropping FFI, and I've dropped FFI from the other gems listed above.
What postmodern said. Also, of course you're not limited to using the c lib directly. Most ffi based libs out there have a nice OO wrapper built around them. The user of the library never has to know. shameless plug: my own ffi-based lib [net-snmp](http://github.com/mixtli/net-snmp) 
btw, mr. modern, i noticed i can't use ffi-libc out of the box on my shiny mac. It bitches about clearenv and a couple other functions I'll never use not existing ;( 
* Changing struct/union layouts are ABI breaks, and will require any code that links to that library, also be recompiled. Hopefully the authors of the C library never break the ABI on minor version bumps. * Can't really argue with that, Ruby is not a compiled language. Usually what FFI libraries end up having to do, is perform introspection at load-time. * I find debugging FFI libraries somewhat easier, that is until I hit a segfault. With FFI I can get pointers to Structs and dump out their raw layout or deref pointers, all from the comfort of `irb`. I might try to write FFI bindings for libcroco or libnfc, provided I have the spare cycles.
... and fixed in [ffi-libc 0.0.5](http://rubygems.org/gems/ffi-libc/versions/0.0.5). Kind of surprised OSX's `libc` doesn't have `stdin`, `stdout`, `stderr` global `FILE *` variables.
The problem is that if they *ever* change the ABI, you have to detect that at runtime. Some libraries don't even provide version info at runtime, so you have to jump through fun hoops to guess which version you're running against and adjust your struct layouts at runtime. Yuck. Give me a compiler any day. :-(
this update spams me with deprecation messages :(
Most projects are receptive to asking them to adding a `_version` function or freeze their ABI. I got [msgpack](https://github.com/msgpack/msgpack) and just now [upskirt](https://github.com/tanoku/upskirt) to add `_version` functions. Writing FFI bindings is generally not that painful. In fact I just got [ffi-upskirt](http://github.com/postmodern/ffi-upskirt) rendering HTML. However, if a library is breaking their ABI frequently, it probably has other problems, and should be avoided until it settles down.
RubyGems: pioneering Deprecation Driven Development
nice! yeah, seemed odd to me too
Wrong sub.
You can get the source code on GitHub: https://github.com/mikbe/chicken_little Also RubyGems 1.8.2 appears to be broken in Ubuntu 10.10
If you want to get rid of the deprecation warnings try my Chicken Little hack `gem install chicken_little` then just run `chicken_little install`. To use Chicken Little install the gem then run the app: $ gem install chicken_little $ chicken_little The problem is RubyGems 1.8.2 seems to be broken for Ubuntu 10.10, it doesn't work for me, so if you already updated you're going to have to manually uninstall RubyGems and go back to an older version. Source code: https://github.com/mikbe/chicken_little Rubygem: https://rubygems.org/gems/chicken_little 
Q: Did you file a bug? A: No. 
Despite having the time and inclination to mention that rubygems is broken on ubuntu no less than 4 different places, you have yet to file a ticket. Thanks.
`gem pristine --all --no-extensions` should clear up a vast majority of those deprecations. `--no-extensions` skips any binary gems you have built because we don't (yet) know what, if any, command-line args you used to build it. If you know that your binary gems are built with no args, you can drop it and get it all in one fell swoop.
The bug has already been reported. Did you bother to look it up? No. Thanks.
Q. Did you bother to look and see that the bug had already been reported? A. No.
Unfortunately fixing some of the problem doesn't much help. Try running a continuous test system like autotest with even a few "bad" gems and you end up with a virtually unusable mess. What you need to do is stop yelling at your users because they're telling you you made a bad decision. Stop taking it personally and just fix it. I understand you're probably feeling ganged up on and unappreciated but the only reason people are so vocal is because they love what you created.
It's full of stars.
I am sure it would not be welcomed. That's why there are so many other loggers out there. 
The problem is that those few gems are going to break in some future version of rubygems so either you need to replace them or they need to be fixed. 
Actually I did... there is nothing that I can see that is ubuntu specific.
How many "bad" gems do I have? 0. I wrote autotest. Of course I'm using it. How many "bad" gems does tenderlove have (who has several _hundred_ gems installed--the fool)? 0 Why? `gem pristine`. 
Thank you, using gem was starting to make my eyes bleed.
2005 called, they want their article back
I've been working with Rails since 2005, I put my resume out there and my phone is now literally ringing off the hook. Glad I listened to that bug in my ear to quit my Microsoft-only job back then ;)
You aren't using Rake? Or are you using beta versions? Here are just a few mainstream gems that have the deprecation warnings which are not fixed by `gem pristine --all --no-extensions`: rake-0.8.7 gherkin-2.3.7 json-1.5.1 nokogiri-1.4.4 rdiscount-1.6.8 spork-0.8.4 Even with just those few you get multiple warnings per gem so your screen quickly fills with sadness. Your comment reminds me of the old adage that the worst person to proofread something is the person who wrote it. They'll read over their own mistakes because they know what they meant to say. So too a programmer is the worst person to QA their own code because they know how to use it without causing errors where a user will just use it. I mentioned autotest specifically **because** you wrote it... 
The bugs I had, invalid date and name method not found, might not be Ubuntu specific but they do not occur in OS X. They have been reported before though. Since the change log did not mention they were fixed I did not think it was appropriate to open a duplicate bug report. My bad. Here's the link to the date bug: http://help.rubygems.org/discussions/problems/575-invalid-gemspec-with-invalid-date-format-in-specification And here's the link the name error on line 277 of specification.rb: http://rubyforge.org/tracker/?func=detail&amp;atid=575&amp;aid=29181&amp;group_id=126
I think the number of other loggers is more to do with the Ruby community's insistence on wheel-reinvention.
Broken in Ubuntu 10.10 using what version of Ruby? If you're using Ubuntu's distribution of Ruby then breakage is expected, the Debian packagers knowingly break RubyGems.
Yeah, was using Ubuntu's distro. I'm manually installing 1.9.2p180 now.
RVM. I really wish the Debian maintainers wouldn't ship broken Ruby packages, but I don't think it's a battle that can be won.
That's debian's perogative. Their goal is to make sure all libraries conform with their system, so that if you know how to administer one package on debian, you can do it with any package on debian. Critics of that policy would like knowledge of administering ruby on redhat (or osx, or whatever) to be the same as administering it on debian. Personally, I'm happy that debian policy encourages debian administrators, rather than ruby administrators.
I think it would be better to not ship Ruby than to ship it broken.
Does Debian have a ruby maintainer? Fedora's ragequit a while back and only recently have they found a replacement.
According to the rubygems crew, you're supposed to tell the authors of their gems to fix their stuff. I guess they do all their development when seriously, seriously high.
FTFA: &gt; In the past, when users in a company pined for a new application to take advantage of market opportunities and trends, they had to first present a formal request to their boss. This turned into a formal request to the IT department, which was then reviewed by a board for budget approval. Once the budget was approved, equipment and personnel skills had to be evaluated. Six months later, the project might begin. RoR doesn't, in itself, remove or improve ANY of this :/
I think RoR has peaked for sure if you're getting articles like this. What's the new hotness? node.js? Haskell on Wires? COBOL on Cogs?
You can always turn down the volume of your ringer if it's becoming a problem. 
Does this not work? $ gem pristine --all It removed all the warnings for me.
Basically it's alpha-quality and you may as well stick with 1.6.0 until hell freezes over. Not even rvm is this buggy or bad.
Send to voicemail with on/off button. ;)
thank you sir.
I was pretty skeptical about using pry until watching these screencasts.
I had problems with the method suggested at the bottom for replacing IRB as Rails' console, so I tweaked it a bit: http://burkelibbey.posterous.com/using-pry-instead-of-irb-for-rails-console Pry is fantastic.
The difference between an editing and a programming is that programming is objective and testable: % sudo update_rubygems _1.3.7_ --no-rdoc --no-ri &amp;&gt; /dev/null; gem -v 1.3.7 % sudo gem install rake --no-rdoc --no-ri Successfully installed rake-0.8.7 1 gem installed % sudo update_rubygems _1.8.0_ --no-rdoc --no-ri &amp;&gt; /dev/null; gem -v NOTE: Gem::Specification#default_executable= is deprecated with no replacement. It will be removed on or after 2011-10-01. Gem::Specification#default_executable= called from /Library/Ruby/Gems/1.8/specifications/rake-0.8.7.gemspec:10. 1.8.0 OK. Cool. Here we have a repro. I installed rake back on 1.3.7 and upgraded to 1.8.0 and we can see the warnings. So let's pristine it: % sudo gem pristine rake NOTE: Gem::Specification#default_executable= is deprecated with no replacement. It will be removed on or after 2011-10-01. Gem::Specification#default_executable= called from /Library/Ruby/Gems/1.8/specifications/rake-0.8.7.gemspec:10. NOTE: Gem::Specification#default_executable= is deprecated with no replacement. It will be removed on or after 2011-10-01. Gem::Specification#default_executable= called from /Library/Ruby/Gems/1.8/specifications/rake-0.8.7.gemspec:10. Restoring gems to pristine condition... Restored rake-0.8.7 % gem -v 1.8.0 And now you can't see any warnings. There was a bug in 1.8.0/1.8.1 where multiple repos (like with using rvm) wouldn't pristine correctly (everything would re-install into GEM_HOME), but that was addressed in 1.8.2. Nokogiri and json are binary gems. You skip those with `--no-extensions` so that we don't break them inadvertently (in case they take build args). You still need to pristine them as well.
Running `$ gem pristine --all --no-extensions`, `$ gem pristine --all`, and then `$ gem pristine --all` again did get rid of all the warning messages. Except of course you get the warning while you're running those commands too so it makes it hard to seen any actual errors. Commenting out the deprecation hooks for :default_executable and :default_executable= let see what was going. Also using RVM I had to switch to the global gemset and run it there too to stop Rake from complaining. Thanks for the help and for all you guys do. I needed a quick fix to get it to stop spamming me so I could see what was happening. With all the warning spam it was like trying to balance an egg on the tip of your nose while someone screams in your ear and smashes garbage can lids together. 
I can confirm that this app is unnecessary but you have to run a combination of: `$ gem pristine --all --no-extensions` And then repeatedly run this until the errors go away: `$ gem pristine --all` You may also need to run `$ gem pristine --all --no-extensions` several times too. I think it's important to point out this isn't what has been being promoted as a fix. Developers like ZenSpider are saying to just run `$ gem pristine --all --no-extensions` and because he's probably run it multiple times it works for him. But the average user upon running the command once still gets the errors, they have no idea they need to also run `$ gem pristine --all` multiple times until all the warnings go away. So, try the gem pristine thing a few times and only then if the errors don't go away try to use Chicken Little. The app was written in the middle of the night by a very frustrated developer, me, that was annoyed at a bad decision to spam warning messages. 
Thanks. Running the pristine command several times did finally get rid of all the messages. Rake was giving me a fit till I realized I had to switch to the global gemset in RVM and run it there too. I've updated my link with the information that my app is unnecessary and describing that you need to run pristine several times. That's obviously the proper and preferred way to do it but at 4am with a screen full of warning spam I just wanted it to work so I took a big old ax out and inelegantly hacked it up to stop the misery. 
lol! No problem! Though, I didn't actually do anything. Next time you're doing these balancing tricks, you should attach pics! ;-)
You shouldn't have to run pristine repeatedly. If you do, that's probably a bug. Unfortunately your ax only addresses symptoms (our deprecations), not actual core issues (like problems with `gem pristine` or rails or...). It's not actually helping and in fact is doing damage by masking real issues. Of course, nobody has filed a single ticket against any issues on `gem pristine`. Hopefully we've addressed them all with 1.8.2, but who knows. With everyone being passive-aggressive instead of just talking to us we can only guess.
You're absolutely welcome.
Have you [filed a ticket](http://rubyforge.org/tracker/?atid=575&amp;group_id=126&amp;func=browse)? 
"The bug" is wonderfully vague, isn't it? You have yet to point to any existing tickets in any of these comment streams. There are **no** tickets filed about ubuntu.
To Summarize: You're using someone else's rubygems that is well-documented as being _intentionally broken_ and you're blaming **us** for it. 
As I said ... somewhere ... You shouldn't have to do repeated calls to `gem pristine` (for the same gem). If you do, it's a bug. Please [file a ticket](http://rubyforge.org/tracker/?atid=575&amp;group_id=126&amp;func=browse).
 I have a problem where some of my gems have been installed with compilation flags (it's on a solaris machine that has very non-linux-standard directories). The problem is, I upgraded rubygems and all those break, and finding the flags/recompiling is a time consuming process.. At present, I just reverted rubygems. 
They do this for a very good reason. Many gems require system libraries before they can be installed. Unfortunately these gems are also the most popular gems like mysql, pg, , sqlite, rmagick etc. What debian does is to install all the -dev libraries before it installs the gem so you don't have any problems. If you are going to install those gems by hand you need to know what libraries you need and install them yourself. IMHO at a minimum rubygems should tell you what packages you need to install or it should borrow some code from chef, automateit or puppet and install the packages itself. 
Here's another solution I just came up with, in your .irbrc to use Pry everywhere: require 'pry' Pry.start exit And if it's in a rails project with rvm, you'll most likely need something like this so you can install Pry in your global gemset instead of the project's Gemfile: # Add all gems in the global gemset to the $LOAD_PATH so they can be used even # in places like 'rails console'. if defined?(::Bundler) global_gemset = ENV['GEM_PATH'].split(':').grep(/ruby.*@global/).first if global_gemset all_global_gem_paths = Dir.glob("#{global_gemset}/gems/*") all_global_gem_paths.each do |p| gem_path = "#{p}/lib" $LOAD_PATH &lt;&lt; gem_path end end end 
Write a gem to do it 
One idea for docx could be to use an xml parser. docx is a zip file, so u would have to unzip it, look for the document.xml and then parse through it for the information you need. If you are using jruby there's a library called Aspose out there. You might be able to get away with Apache's POI library as well.
Here's the link to the date bug: http://help.rubygems.org/discussions/problems/575-invalid-gemspec-with-invalid-date-format-in-specification And here's the link to bug report for the name error on line 277 of specification.rb. You were assigned to this: http://rubyforge.org/tracker/?func=detail&amp;atid=575&amp;aid=29181&amp;group_id=126 Neither of these happen when the gem is run on OS X but they do when the bug is run on Ubuntu. 
I'm trying to see if I can get my system back into a state where I can replicate the issue then will file a bug report.
You reverted, I reverted, lots of people are reverting, tons more will when they find out this unholy hell that they're going to go through. What was the plan again? 
Since it takes a good chunk of my life to deal with filing tickets, I do only what I can. It's like they think this warning nonsense is a *good* thing. I say much more of this and I'll deal with the node.js assholes instead of the ruby jerks.
This has nothing to do with ubuntu vs osx and everything to do with syck vs psych. You probably have the library you need on ubuntu and not on osx.
I had to do this like 5 years ago and I'm pretty sure I just used Win32OLE using some instructions from rubygarden.org. I see that rubygarden is gone now though but you might be able to find some of the stuff scattered around the intertubes. Win32OLE will let you access pretty much any of the office file formats you have support for on your machine. Here's some references: http://www.ruby-forum.com/topic/99742 http://rubyonwindows.blogspot.com/2007/04/automating-word-with-ruby-document.html The only problem with that though is you're going to need to run this on Windows. Truth be told, there's not a lot of support for .doc format because it was never an open format. There's lots of MS provided stuff in .Net and Windows native libraries but not much else. Another solution if you're working with Unix is to use catdoc and just scrape the text from the Word documents and calculate estimated pages from that. http://wagner.pp.ru/~vitus/software/catdoc/ Using Heroku in your case is going to be tough because parsing Word documents isn't an easy thing outside of Windows. Doing it in pure ruby is pretty much impossible given what's out there. The files are just a bunch of proprietary garbage. You're probably better off throwing up a cheap VPS somewhere and working off that. Parsing files like this is best left to background workers and with 2 workers and 1 dyno, you're looking at $72/mo on Heroku. A VPS w/ 1gb of RAM and 45gb of storage will run you $40/mo on Webbynode and that should be more than capable of running several background workers, your application, and database.
This sounds good for docx files. When I widened my search a bit I came across a solution using rubyzip and nokogiri, so I'll be looking into that. Thanks.
Thanks for the detailed response; this is more or less what I expected for doc files. I guess it's back to convincing the client that this is far more trouble than it's worth. Catdoc looks really interesting though. I'll have to give that a look. 
This might not satisfy your "too much trouble" requirement (depends on your level of experience), but one thing you can do is open a few word docs yourself, in a hex editor, and look for a page delimiter. You might even be able to find the byte code online or check the POI source to see how they do it. Once you have the binary format under control, it should be easy finding the page elements in the newer xml style docs.
Chicken Little is now updated to use the proper, sanctioned method for fixing the deprecation warnings. In addition I've fixed the errors in Ubuntu so you can properly upgrade from RubyGems 1.6 to 1.8.2. 
are you and zenspider besfrens now?
I didnt believe you were right about `NameError::message` actually being a nested class under `NameError` (i figured they'd just messed with the `#name` or `#to_s` methods), however i found this line in error.c: `rb_cNameErrorMesg = rb_define_class_under(rb_eNameError, "message", rb_cData);` Pretty lulzy.
I like the [name](http://ChickenLytle.blogspot.com/).
Doc/word is not a layout program format. You'll find every now and then a document that's exactly 2 pages on one machine, then +/- 1 line, sometimes pushing it to 3 pages. The apachie poi project has API for office format stuffs. Perhaps there's something in there. G'luck!
A few days ago, when I realized 1.8+ was out, I upgraded and went into deprecation 'hell'. So had the initial 'upset' reaction. Then found the 'gem pristine --all --no-extensions' recommendation which did fix most things but I found spork borked and was still stuck in 'upset' mode ;) But I did file a bug and see you kindly fixed it. I just reversed my 1.6.2 downgrade to 1.8.2 and everything's working nicely. It works nicely when both parties do their bit. Users included. Thank you!
You might also want to look at ripl 
I say we have a cage match to sort out what the best practices are.
So this is only for 1.8? Any 1.9 love planned?
How about using docsplit? http://documentcloud.github.com/docsplit/ 
This is for **RubyGems** 1.8 not Ruby 1.8. It's for Ruby 1.9.2.
I played a bit with ripl, and it's nothing like pry. ripl seems to be aiming for 'lightweight irb' whereas pry is heading more into 'ipython/slime/smalltalk' territory. I think they both have their place and do not necessarily compete, nonetheless pry is more my style.
That's not why they do it, actually. They do it because they refuse to allow RubyGems to install compiled code. And they won't participate in any work to integrate RubyGems with APT, so what you're asking for from RubyGems is unlikely to happen.
Debian's ragequit too, but he came back on the list to berate people, so maybe he changed his mind.
I doubt it. He probably thinks, and rightly so, that you should just do it yourself. That this app is an unnecessary abstraction that hides the solution from a user when they should know how to do it for themselves. But I like it because it fixes all of my RVM ruby versions and gemsets at once (at least it will in 0.2.1).
Okay well then lacking any documentation, how is it supposed to work? I installed it and the warnings were still there.
It appears when building on OS X my metadata file contains a date with decimal places on the seconds. e.g. date: 2011-05-13 00:00:00.000000000Z Where on Ubuntu the date format is: date: 2011-05-13 00:00:00 Z If I edit the metadata file manually to the Ubuntu format, or build on Ubuntu, it works on both OS X and Ubuntu. I'm trying to figure out how to force it to use the more generic version now. Since this seems like an issue with time implementation on the different systems I'm guessing this shouldn't be a bug report for RubyGems. 
Sorry, I should have explained that you have to run the app too not just install the gem. $ gem install chicken_little $ chicken_little You can also see all of the available options by running: $ chicken_little help 
You must also run the app, not just install it. I'm guessing that's why there are so many down votes. My bad for not explaining that, how would anyone know they need to run it too? $ gem install chicken_little $ chicken_little 
To use Chicken Little install the gem then run the app: $ gem install chicken_little $ chicken_little
Aha so there is documentation (conveniently, found behind the "documentation" link on the page you linked to). I was looking for rdoc before I posted my other comment. I tried running it but it fails on a gem I have developed for myself. I've already done the pristine command that they recommended when 1.8 was released and the only deprecation warnings I get now are from rake so I'm not going to worry too much about it. Thanks for the help.
The complaints I read were many and seemingly legitimate. Language barrier, an offensive level of indifference to actual users, and a laisez-faire attitude towards pushing out badly broken software made for a hell of a workload. I'm not sure how the rvm guy does it, and now he's targeting Windows? Someone's clearly a masochist.
Are you using RVM? If so you need to switch to your global gemset and run the pristine command there too. For instance with 1.9.2: $ rvm 1.9.2@global $ gem pristine --all Then switch back to the generic gemset: $ rvm 1.9.2 That'll fix it. My app should do that for you for the currently set Ruby version. When I get home I'm going to change it so it works for all gemsets and Ruby versions.
Indifference to users and pushing out badly broken software... sounds like the Debian Ruby maintainers, frankly.
I like how Fedora was stuck with 1.8.6 for an eternity because according to the packager 1.8.7 would potentially cause trouble. Ironically Fedora always updates to the latest shiny new thing even when it makes no sense, like selinux for instance. So you've got a bleeding edge 2004-era build of Ruby.
It's actually not the fractional value, it's the lack of a space before the 'Z'. :/ If you had libyaml on OSX when you built your ruby you'd see the same thing there. You can force it down to syck via: YAML::ENGINE.yamler = 'syck' or require 'yaml' before rubygems. ETA: and I finally cajoled tenderlove into releasing psych as a gem specifically to fix this issue, so now you can do: gem 'psych' before rubygems and it'll work too
YAY! Thanks! 
What broke when you upgraded rubygems?
So you have no problem taking a good chunk of your life sniping at us left and right on reddit, but filing a ticket is beyond you. Sounds like _you_ are the jerk/asshole.
As I said before, you shouldn't need to run `gem pristine` multiple times. If you do, then there is a bug. Have you [filed a bug](http://rubyforge.org/tracker/?atid=575&amp;group_id=126&amp;func=browse)? Of course not. Instead you mask the problem with your equivalent of `5.times do system "gem pristine --all" end`. Which will also **break** any gem that needed to pass arguments to their binary gems to build. Sanctioned indeed. Are you going to support that? No... they'll come to us saying _we_ fucked up their gems.
"what keeps you in boulder?" haha, nobody who's ever lived here would ask that. =P
Actually what I do is test to see if the warnings show up and only if they do then do I run `$ gem pristine --all --no-extensions`. I then check again to see if the warnings are still occurring. If and only if the warning still happens do I try running `$ gem pristine --all`. Again I check to see if the warnings are still occurring. Then and only then do I run `$ gem pristine --all`. For a fourth time I check to see if the warnings are still showing up and if they are I try `$ gem pristine --all --no-extensions` again. And finally I check again to see if the warnings are still showing up. If they are I try a final time to run `$ gem pristine --all`. At any time in this loop if the errors stop showing up I stop running the fix. You said to run `$ gem pristine --all --no-extensions` to fix it. Aaron Patterson said to run `$ gem pristine --all` to fix it. I've had to run both of these to get it to stop giving errors. So my app runs those until the error goes away or until it's tried a total of five times. Would you agree a bug report that says, "X happens but I can't show you how to replicate it." is almost useless? So, instead of spending my off time writing the "fun" code I want to write I'm working on backing up my laptop and restoring earlier version of the gems I had installed so I can test what's happening. I'm doing this so I can give you a repeatable test. Something that will actually point to the problem instead of posting a bug report that less useful than, "Does not work in O.F.F. position." If you "yell" at people trying to provide you with information don't be surprised if they don't want to provide you with information anymore...
Yeah, well, I take my inspiration from the finest. If there's one thing that the ruby community has it's amazing marketing and PR, but when it comes to customer service it's pretty lacking. I'm being a jerk, maybe an asshole, sure, but I'm just venting how I feel. Maybe I could make a Zed Shaw inspired blog where I just piss and moan about everything all the time, but that sounds more involving than simply bitching here. There's nothing that wrecks my day more than finding out that someone's gone and arbitrarily switched up the game on a core piece of infrastructure and everything all gone to hell. Ruby on Rails is a serious offender in this regard, where in a minor point release they'll go and rejig something huge just because it seemed like a good idea at the time. Then comes the questions as to why the example in a brand new book doesn't even come close to working. I'm not asking for stasis. I'm asking for expectations management and communication. I'm asking for detailed release notes documenting what changed and how it impacts users. A blog post is not documentation. A conversation in IRC is not documentation. A mailing list is not documentation. Sourceforge is not documentation. Rdoc, ironically, is not documentation, it's just a reference. Documentation is included with the software itself. Documentation shows up on the software's site. Maybe I'm guilty of the very same things I go on about right here, it's true, I won't deny it, but I'm also not releasing a critical piece of infrastructure used by *virtually every Ruby developer in the world*. I've got another six tickets I need to file for, but you know what, I'm going to take my time, make sure it's a legitimate issue, and only then will I go about the process of seeing if someone else has posted it already, then, after that, *defend* my position as it seems like my problems are simply an irritation and life would be a whole lot better off without those pesky users. 
Well done and thanks for spending your time to help other!
After spending time to figure out the problem instead of just posting a bug report and leaving you to do all the work I found out my copy of RVM had rubygems 1.8.1 embedded in it. It looks like RVM's version of Ruby 1.9.2 has RubyGems 1.8.1 embedded in it. Now aren't you glad I did a little research myself before posting a bug report about something that had already been fixed? I'm going to go out on a limb and say probably not...
Care to explain why pristine fixes it (and yes, it did it)? According to its description: &gt; The pristine command compares the installed gems with the contents of the cached gem and restores any files that don't match the cached gem's copy. I had an empty gem set with only rake installed and I was getting these warnings, but pristine --all fixed it, but why!?
Rake is a gem too of course and when rake was first installed you were using an older version of RubyGems. That version of RubyGems copied the now deprecated default_executable= line from the rake gem's metadata file to rake's gemspec file in the gem cache. Then when you ran RubyGems 1.8.x it was reading that old gemspec file with the deprecated method so it threw a warning. When you next ran `$ gem pristine --all` it used the new RubyGems code to replace the gemspec and uncompressed Ruby code in the gem cache . The new code ignored the default_executable= line in the metadata file so it wasn't put into the gemspec file. Since now there isn't a default_executable= line in the gemspec file in the gem cache RubyGems 1.8 doesn't throw the warning.
Number of times I've ever used rdoc or ri: Zero. Number of times I've ever thought about trying: Zero. I'll crack open rdoc.info if I want docs. Most documentation is so garbage that you may as well just open the source code in an editor anyway. I keep trying to turn off ri and rdoc but they keep turning back on *somehow*.
I'm not sure why this isn't getting through your skull. I don't know how many times I've said this _directly_ to you. % gem install mysql -- args-needed-to-build % chicken_little Oh look... mysql is now broken.
Just one more time should do it...
I just tried your example and MySQL still worked fine. * I started with gems 1.6.2 * Installed mysql gem with required switches to get it to build * Created test database, table, and row data * Ran db_test.rb to print the table (worked) * Installed gems 1.8.2 (got deprecation warnings) * Ran db_test.rb (worked) * Installed chicken_little * Ran db_test.rb (worked) * Ran chicken_little (warnings gone) * Ran db_test.rb (worked) I understand what you're saying but it's just not proving true in real world testing. That's not to say it wouldn't hold true with another gem. 
Using Native extensions without a very good reason makes system admins who have to deploy all this shit hate you.
Thanks for the explanation. All of a sudden another problem popped up for me: running rvm gemdir always shows lots of warnings while my current gem set is empty. The warnings are related to gem sets installed for ruby-1.8.7, but I am in ruby-1.8.7@foo, for example.
wut
&gt;That's not why they do it, actually. They do it because they refuse to allow RubyGems to install compiled code. They specifically said that's why there are doing it. &gt;And they won't participate in any work to integrate RubyGems with APT, so what you're asking for from RubyGems is unlikely to happen. Because they don't want you to use rubygems. See above. Using rubygems is not sufficient, rubygems does not handle system dependencies. 
I see a "fork" button on github. I think it's just a matter of time before someone takes this project away from Ryan.
&gt; Using rubygems is not sufficient, rubygems does not handle system dependencies. But when the Ruby developers tried to work with the Debian maintainers to integrate RubyGems and APT, the Debian maintainers refused. So as I say, it's Debian's fault that it's broken, and RubyGems inability to handle dependencies is just an excuse they are using to deflect the blame.
Chicken Little does not currently fix multiple ruby versions or gemsets, only your current one and the global one for the Ruby version you're currently using. You have to switch to those other sets and Rubies manually and run chicken_little to fix them. (I'm adding the feature to do this for you automatically but got sucked into minecraft again last night...) I have no idea why gemdir is doing that but if you run chicken_little against those versions it might stop.
As the author of ripl, perhaps I can clarify ripl's aim. ripl is aiming to be a modular, extendable shell. There's a reason there are 20+ plugins and a number of shells ([websockets shell](http://github.com/cldwalker/nirvana), [javascript shell](http://github.com/cldwalker/ripl-johnson), [pseudo-system shell](http://github.com/janlelis/fresh)) built around ripl. Neither irb or pry have shown any intention of providing an api for plugins. Can you extend those shells to customize how you print errors, print results, handle control-C and ask for input? Nope. Ripl does as it's designed to offer almost every aspect of a shell for extension. As for being more ipython/slime like, that has nothing to do with the ruby shell you use. Why pry chose to offer its commands( cd, ls, show-method, ...) in a new shell is puzzling to me. They are just top-level methods (irbrc sugar) and could just as well have been packaged up for irb users to use as [irbtools](https://github.com/janlelis/irbtools) and [utility_belt](https://github.com/gilesbowkett/utility-belt) have done. The reinvention/discovery of the cd command (in irb it's called irb) is also puzzling. Perhaps it would do ruby users well to learn what [irb already offers](http://tagaholic.me/2009/05/11/demystifying-irb-commands.html). Edit: Per banister below, pry has plugins in development, it's commands aren't methods and it can be configured to do the above customizations but not extended (perhaps one day with plugins). Whether pry's commands are methods or not, doesn't puzzle me any less. I guess to make a ruby shell look and feel useful one has to choose commands and a command framework for users. For those who do want choices, there are plenty of [command frameworks out there](http://www.delicious.com/tag/gem:type=task).
I was really pissed off with how hard it was to simply make a gem in the first place until gem push came around and fixed that, but from what I've come to understand, that's not even really rubygems doing that, but the gemcutter people.
But why does it complain about a gem set that is not the current/active gem set?
This is really fantastic, I found three presentations on Hackety Hack I'm going to take a look at sometime soon. :)
author of pry here :) I do not want to get into an argument about this, but `show-method` and `ls` and so on are not 'just top-level methods' (as you say), in fact they're not methods at all. This is for two reasons. 1. Pry is designed to be invoked at run-time so monkey-patching Object with a whole bunch of functionality is a very bad idea. 2. Commands allow a much more convenient syntax, see `ls -mli --grep hello`. 3. Commands can do things methods can't even dream of doing, such as using `hist`ory to [reach in and change a single line of code within a (potentially) long method](https://gist.github.com/972057); and a bunch of other things. Also, Pry is quite a new project, but a Plugin API is already in my local `dev` branch and will be available in the next release. Further, even in the _current_ version of Pry you can [easily customize](http://rdoc.info/github/banister/pry/master/file/wiki/Customizing-pry.md) how you print errors and print results and ask for input...did you [read the docs](http://rdoc.info/github/banister/pry/master/file/wiki/Customizing-pry.md)? It's as simple as this: `Pry.print = proc { |output, value| output.puts "=&gt; #{value.inspect}" }`. A lot of other aspects are also configurable, including the prompt, the error handler, the commands themselves, `input` and `output` objects, and so on. Also, no, the `cd` command and the `irb` method are different. Not only in that `cd` allows a syntax that maps more closely to the shell `cd` command (`cd ..`, `cd /` and soon to be supported: `cd @ivar1/@ivar2/MyConst`) but also in terms of power. IRB's `irb` method can not move into certain kinds of objects such as immediate values, and objects without access to top-level constants, such as the `BasicObject` class. Pry's `cd` command on the other hand can start a session on nearly everything. Again, I could not/did not want to just hack on IRB and offer something like `irbtools`. I would have to hack the IRB source to pieces; but most importantly i wanted a nice and flexible 'command API' (again commands are not just top-level methods). I looked at using RIPL but i found it much too barebones for my taste, I wanted to design something with 'batteries included' that kept all the basic functionality (`show-method` to me is basic functionality) in the same place, not scattered through lots of little plugins. Heck, even multi-line input in RIPL (which to me is absolutely fundamental) is a *plugin* in RIPL, this is really strange to my mind - this level of decoupling is excessive. The Pry core is fairly complete at this point, from now on i expect most new functionality will be implemented by way of plugins, such as the up-coming plugin to provide better git integration. 
&gt;But when the Ruby developers tried to work with the Debian maintainers to integrate RubyGems and APT, the Debian maintainers refused. It's not as simple as you make it out to be. You are convinced debian maintainers are demons who are out to destroy the ruby community but that's not the case at all. Rubygems does not and will never support system dependencies. Period. Until it does the debian maintainers want no part of it because the value of debian is apt and the reputation they have for making an stable system. You can install rubygems and then install your Rmagick, sqlite, mysql2, pg etc gem and manually install all the dependent -dev packages (or from source) if you want. They just want no part of it. The two projects can not work together because they have differing goals. Rubygems doesn't care one bit if the latest -dev source code it needs to run paperclip will break your system. Debian does. &gt;RubyGems inability to handle dependencies is just an excuse they are using to deflect the blame. It's an absolute fact that rubygems does not handle system dependencies. Until it does neither debian, fedora, nor suse deal with it. There is too much at stake.
I'm glad you liked it. :)
Good to hear about some of pry's innards. Not so good to hear that commands aren't methods. Having written [a command framework](http://github.com/cldwalker/boson) that let's methods act as a commands, you're missing out by not letting commands communicate via ruby. As for pry's customization, I'm glad it's able to customize most of the above via accessors. But unfortunately, it's configuration, not extension. What happens when a plugin wants to add to #print and a user wants to modify #print even more? It's one anonymous lambda on top of another. What happens when a user wants to reuse pry's #print in their #print? A local variable dance. Customization via configuration is fine as long as you don't expect others to build on top of your functionality and reuse parts of it. If a nice and flexible command API was most important to you, I don't know why you were looking at ripl. Ripl isn't a command framework. You should've been looking at thor, boson and [a dozen other such gems](http://www.delicious.com/tag/gem:type=task). As for evaluating your commands in a shell, you could've used ripl but it seems you're more interested in writing your own shell than requiring a couple of files. As for a specific command like show-method, that has nothing to do with designing a shell. If I distribute my [400+ commands](http://github.com/cldwalker/irbfiles) as a gem, I'm not designing anything. Notice that since those commands are methods, they can be used in any ruby shell including pry. But can pry's commands be used in other ruby shells? Is that good design?
I thought i explained why commands weren't methods? 1. Using methods pollutes `Object` with methods that may conflict with methods in the running program or current context (`cd context`) 2. I prefer the syntax of commands to methods - quoting isn't required and neither are commas to separate arguments. 3. Commands have the power to do things that methods cannot do You may not prefer this, it's entirely up to you. Regarding 'extension', your extension approach using module inclusion and calling super is really not so different to method decoration approaches. Pry plugins can of course decorate Pry's core methods. Yes Pry commands *can* be used in other ruby shells, again, did you read the docs? Given that you didn't know that commands weren't methods, you assumed `print` and `input` couldn't be redefined, and in general seem to know very little about Pry I really don't think you should be [hijacking nearly every thread on Pry](http://news.ycombinator.com/item?id=2478724) and writing disparaging comments about it. Note, that I never posted a single comment on RIPL-related threads. Why? out of respect. You also may know back when Pry was only a runtime thing I recommended people use RIPL as a full IRB-alternative, and linked to your page. Let's not continue this any further. Also, do not lecture me on design. 
Check syntax... how? The README never specifies. Does it check if the file is proper Ruby syntax? Does it check if the file follows specific stylistic guidelines?
Yeah I'm pretty unclear on what this actually does.
I have read the docs again and there is no mention of how you would pull off 'ls -Mp --grep pa' in another ruby shell. Since it's not ruby, no surprise it won't just work. Since my commands are just ruby methods, "ls '-Mp --grep pa'" would just work in any ruby shell. It's strange that you talk about respect right after accusing me of hijacking. I'm sorry if pointing out pry's size is disparaging but it's also true. When a new gem comes out, it is appropriate to compare and contrast against existing alternatives. Too often the ruby community reinvents the same old wheel. Notice that [ripl](http://github.com/cldwalker/ripl) has always respectfully linked to all known irb alternatives and pry links to no one. I've been trying to *discuss* design with you and pry is the better for it: you're creating plugins and keeping bloat out of pry core.
This gem needs a huge does of readme-driven-development. Even then, would it be useful though? We could be fairly certain that our syntax is correct even with a minimal test coverage.
Really cool. One small suggestion though: an index so one doesn't need to go through every page to see what is available.
The README file != [docs](http://rdoc.info/github/banister/pry/master/Pry). Commands can be executed from outside a session using [Pry.run_command](http://rdoc.info/github/banister/pry/master/Pry#run_command-class_method). If you were sincerely just trying to have a discussion with me you would have learned a bit about Pry before spreading misinformation like 'commands are just top-level methods' (a method called show-method? really?), and stating that input and print results were not customizable. Also it is totally disingenuous to do a line count comparison of RIPL to Pry - RIPL is a raw read-eval-print-loop and doesn't even have multi-line input support! Do a line count of RIPL + all plugins necessary to implement Pry features, then we'll talk. Let's not continue this thread, neither of us are getting anything out of it, and i'm sure it looks ridiculous to outsiders. 
It's a work in progress. I had a single index with everything but this was causing issues because of the number of Adobe Flash objects being rendered. Pagination solved the problem. I'm thinking of adding tags to the presentations and allowing people to drill down into the tags.
*Ahem*: `bundle exec autotest`
&gt; Someone's clearly a masochist. I'll just leave this here: https://bdsm.beginrescueend.com/
it check syntax automatically when you are trying to do git commit. Or you can run checker manually. 
this doesn't check your js files for syntax errors, or haml.
This is true for most of your controllers and models. But what about views? Are you testing it either? JS? Also Don't you have a situation when you need to do a very very quick hotpatch to prod and you don't have time to run all tests, or you are changing smth that no covered with tests, and you write some extra "}" or smth like that. You push it to the server and booom, 10m downtime, 10000$ lost. Another common situation is when your customer became thinking he knows ruby also, and start practicing writing some code. booom. There are 2 key features to use this gem: 1) it won't allow you to commit bad code 2) it checks js as well. (coffeescript is coming soon)
for those who don't 'green' before commits :p
&gt; But what about views? For views you have view specs &gt; very very quick hotpatch to prod Why are files with fault syntax making it to production? Consider setting up a smoke/staging environment. &gt; you don't have time to run all tests You should have time to test when developing, even if it's an emergency you should still run your test suite so no regression occurs. &gt; this doesn't check your js files for syntax errors [Capybara helps solve this problem](http://openmonkey.com/2010/04/09/javascript-testing-with-cucumber-capybara/) &gt; common situation is when your customer became thinking he knows ruby I don't even... Your customer/client should ** *never* ** touch the code. This is wrong on so many levels.
I didn't mean to be abrasive. Now that you've mentioned it, I do somewhat see a use for it. Front-end testing, while important, is of less priority than say testing models. Simply put, we get higher ROI over testing models and controllers. Your gem can be sort of a safety net of sorts, that guarantees a minimum quality for front-end code perhaps? That being said, I agree with what ViralInfection mentioned.
yea. And i think there are a lot of people doing that :) 
 Everything you wrote here is correct :) our customer/client should never touch the code. - Agree, but sometimes this happens. Capybara helps solve this problem. - Sometimes you just don't have time for testing views, and also supporting views testing costs too much, if you have lots of resources to support cucumber tests you are lucky. Why are files with fault syntax making it to production? Consider setting up a smoke/staging environment. - Sometimes this happens, for past 4 years it was only once with me, but was. For views you have view specs - waste of time.
&gt; You are convinced debian maintainers are demons who are out to destroy the ruby community but that's not the case at all. I don't think they're out to destroy the Ruby community. They just won't work with it. &gt; Rubygems does not and will never support system dependencies. Yes, but you have to ask *why* that is, and it's because the Debian maintainers won't work with the Ruby maintainers. The Ruby folk were interested in integrating Gems and .debs. The Debian folk refused.
Checkout the [other videos](http://skillsmatter.com/event/home/cukeup) from that conference too.
That's just plain freaky, but thanks for the, ah, informative link.
Is this a 30 minute joke?
"Trying to fix a performance bug in Ruby 1.9's require" would have been a much fairer title.
Yes! Give me a high five...
I'm at ignite right now. Message me on Twitter and lemme know where you are thinking of going. I'm going to go to the bar after ignite for a bit.
Where and when?
We're at ignite right now, not sure if we want to go to Maxs
It's gonna be crazy. 
Details to follow
I'm at Max's. Where are you
hi, so here's that library which should allow you to sync tempo http://github.com/arirusso/midi-eye and I created sort of a rough example that uses tempo messages https://github.com/arirusso/midi-eye/blob/master/examples/arpeggios.rb i'm still planning on doing a sort of swiss army knife high level library for dealing with tempo but this may be enough to get you going. I'll probably post it as a regular link on reddit in a couple of days after i clean it up a little bit
No shenanigans were found :( Maybe tomorrow night?
Start by getting an up-to-date (e)book?
Max's was debacherous
crap, i just bought textmate
This is what I'm using on my projects (doesn't work with rails, but works fine with sinatra): https://gist.github.com/975509 It just takes a list of gems from a rvm's gemset file and links everything to a common directory. I then run my app with that directory as the first thing on the load path (-I./deps/lib), and with that I avoid having require search on a long list of directories for each require (because rubygems makes your load path much bigger, and thats a killer for require on 1.9) There is also http://github.com/jeremyevans/zozo which does something pretty similar, but by loading your app and inspecting the load path changes instead of getting the list of gems from a gemset file. Edit: to get an idea, an app that loads in 9s without the linking, loads in 1.5s after the files have been linked to a common directory. Also, I use this only on dev mode, not on production.
+1 you're going to hurt yourself otherwise. You can try uncommenting the second to last line in config/routes.rb which looks like this: # match ':controller(/:action(/:id(.:format)))' read the comment above. Hope that helps. But seriously get an updated book.
+1 you're going to hurt yourself otherwise. You can try uncommenting the second to last line in config/routes.rb which looks like this: # match ':controller(/:action(/:id(.:format)))' read the comment above. Hope that helps. But seriously get an updated book.
+1 you're going to hurt yourself otherwise. You can try uncommenting the second to last line in config/routes.rb which looks like this: # match ':controller(/:action(/:id(.:format)))' read the comment above. Hope that helps. But seriously get an updated book.
I thought ironruby was abandoned.
Ruby In Steel supports Ruby 1.8, 1.9 ad JRuby. It is not aimed at IronRuby.
I thought ironruby was abandoned.
I thought ironruby was abandoned.
Are you saying you thought ironruby was abandoned?
David Black's *The Well-Grounded Rubyist* is quite good: http://www.amazon.com/dp/1933988657 Oh, and look on the sidebar here in /r/ruby - there's a list of books there as well.
see right
Could you recommend one for me?
Okay thank you :) Could you recommend a better beginner book?
Strange, I had the same inexplicable feeling!
If only the graphical data produced wasn't so unreliable.
Hi presjordan, you can try changing greeting.rhtml to greeting.html.erb However, you'll probably be better off getting a rails3 how to book instead since what ever you are reading is probably pre rails 2.2. I haven't read any of these yet, but you can check out The Rails 3 Way, Rails3 in Action, and Agile Development with Rails (4th ed). If you have a question feel free to send me a message and I'll try to help.
I'm reading [Beginning Ruby: From Novice to Professional](http://amzn.com/1430223634) right now. Here's a good list of other books: [The Best Ruby Books - ProgrammingZen.com](http://programmingzen.com/ruby-and-rails-recommended-books/)
There's a meme gem?
The XML is totally horrible. Open up one of those docs and take a look... gad Damn it makes u sad on the inside. ;/
[Yep](http://rubygems.org/gems/meme_generator).
Why doesn't the meme gem work? Why didn't you submit a patch to it?
It would probably help if you posted a link to the site.
These ones, and read in this order (IMO): * the ruby programming language * eloquent ruby * design patterns in ruby * refactoring: ruby edition And if you're a total noob to programming read chris pine's 'learn to program' first.
meme gem does not work, because it was based on memegenerator.net which changed recently and does not provide image urls anymore. See html source of any page there. I did not submit a patch because memegenerator has plenties of memes and I only aimed to fix yuno.
How so?
I opened this thread hoping someone had suggested this.
That's boss! I wonder why no one's patched it yet. I'm going to see what I can do, but my Ruby skills are pretty novice at this point.
Do it! I just blogged this the other day: http://thechangelog.com/post/5367356233/you-yes-you-should-contribute-to-open-source
No timezone support: https://img.skitch.com/20110429-h9acdtfqnwssr8ganteitys6t.jpg Inconsistant metrics and graphs. Look at the maximum Y-values for the curves in the following graphs (ignore the vertical red bars): (Apr 1 to Apr 28 Max ~320) https://img.skitch.com/20110429-8jdhtuk4qash9a3bsj94qdydam.jpg (Apr 22 to Apr 28 Max &gt; 400) https://img.skitch.com/20110429-k8c37dc2y2567gwhtxscic4ukn.jpg
I've wanted to get into contributing since forever. After reading your article, I think I'm going to take the plunge. :) Thank you!
Awesome!
This is the worst thread ever.
+1 for Eloquent Ruby
FUCK! that's why my [bot](https://github.com/chrisledet/memebot) wasn't working :[ BRB writing a better meme generator site! /serious
and why is that a bad thing? textmate rox!
sadly, i was one of them who **did** in a previous life.
I'll refer it to the UI folks :) We do actually support timezones, but all data is recorded in UTC. I'm not sure why you're seeing no differences, it's probably a bug in the user interface. "Unreliable" to me meets a different standard. Did we bring down your app? Did you lose data? Did it not report an outage?
Updated my previous messages to be more clear about my complaint.
Ran into similar problems recently and ended up simply doing a Hash in my controller that I'd convert to JSON. Feels like a dirty approach though, looking into porting our API to this.
the difference textmate isn't a full blown ide. but yes, textmate does rock.
Yeah there's a similar approach where you build manual hashes in the model or in a presenter. Manual hashes are a lot more flexible than to_json obviously but I think you'll find RABL to be a good middle ground giving you flexibility but also keeping the api declarative and terse. Let us know what you think!
I've cracked open both doc and docx, and this is exactly the problem. The concept of a 'page' is not represented internally. The files represent content and formatting, and the different pages are simply a product of the rendering. 
Fair enough. You've got to recognize that the 'inconsistent ymax' is by design, though. That's intentional, because different applications have different (for example) throughputs.
Compare 2nd graph with the corresponding time period in the 1st graph (ignore the red bars). Those 2 curves, though representing the exact same period of time, look nothing like each other.
This is nice. I might use this. I've been playing around with midi input aswell, https://github.com/aalin/march/blob/master/demos/midi_input.rb
Put # encoding: UTF-8 on the second line of your program and it'll do the right thing most of the time. ([Except regexps](http://redmine.ruby-lang.org/issues/show/4386), which may be a bug.)
tldr: author didn't know what ! was used for, so he looked it up
PStore uses plain #commit rather than #commit! I think Rails is just wrong to put an ! on #save. Even given the redefinition of ! it doesn't make sense, in what way is the behavior of save! unexpected?
I've been waiting for something open source and easy to use. Right timing too, I need this now. 
A list compiled by me - http://batsov.com/Ruby/Books/2011/05/17/recommended-ruby-books.html
Thanks! I like where you're going with the music theory classes in march. I would use that.
Thank you. I hope to get further in june!
__.save__ returns true for success, false for failure. __.save!__ returns true for success, raises exception for failure. As I view it, the 'unexpected' part comes from the return varying from boolean to exception. Also, in my experience, exceptions in rails ecosystem are reserved for unexpected failures that have no part in your everyday workflow (as opposite for, say Java libraries that very often convey every negative outcome as different exception, and expect all calls to them to live in their own try/catch blocks.
It's not a bug, read the comments and documentation they reference. If the design causes you problems then you should give feedback, but noone has. 
I like the fact that caching seems easier since you can fragment cache the views, yes?
Except that item 3 is bad, or incomplete, advice. default_internal is used when retrieving data from the OS, filesystem or console. When used to retrieve data via File#read or CSV you have the option of providing an explicit encoding to transcode to. Blindly transcoding to default_internal can destroy data or cause unrecoverable errors. Only transcode when you give your user the option to choose.
Yes.
What does it do differently? It looks like it's just taking RubyGems and slimming it down whenever possible. Is there a list of what they have done so far to speed it up?
I'd be interested to know in more detail how or why this is better than RubyGems.
It's just people being butthurt over warning messages. EDIT: after looking at this, it appears to be a bit more than that. Performance improvements, etc. EDIT2: this was based on the readme, didn't look at the code.
Maybe you can help [this guy?](https://github.com/mmb/meme_captain)
OK, that makes some sense then.
But why not just contribute those performance improvements back to rubygems? Do we really need 2 package managers? =/
Why not contribute to rubygems instead of trying to fragment the community?
Maybe there is a cultural problem with the rubygems core commiters?
Dude. You don't know how hard it is to update some gems. It'll be MUCH easier to maintain our own fork of rubygems instead!
Entirely possible I guess. I've never tried to contribute to rubygems so I'm not sure. If that's the case, more power to slimgems.
"Loren, get off this ticket" sums it up nicely: http://rubyforge.org/tracker/index.php?func=detail&amp;aid=29176&amp;group_id=126&amp;atid=575
Yes, especially when taken completely out of context. Sums it up quite well indeed.
Because, from what I can tell, Rubygems is not really interested in anyone helping out. From the outside, the community there seems a bit closed off.
I'd be interested in seeing what the performance improvements are... but the majority of this effort can be summed up as _"you broke my monkeypatch"_.
I think the short answer is "nothing": &gt; **What Do I Have to do Differently to Use SlimGems?** &gt; Nothing. We maintain the same install paths, APIs and overall runtime environment that RubyGems had. The only difference is that we have no intention on changing this environment in future upgrades. You can upgrade safely knowing that the newer versions of SlimGems will still be compatible with all of your code. Which basically means he's stuck with our mess from 6 months ago and can't ever improve.
&gt; _SlimGems is a RubyGems fork of RubyGems 1.3.7 and a limited set of backports from 1.5.2. SlimGems is maintained by Loren Segal and others. SlimGems will provide continual improvements with a stable API._ Doesn't this imply that it is incompatible with bundler? Bundler has moved forward with us since 1.5.2 (and have been happy to do so because we've made things a lot cleaner).
Oh, I think a lot of people will be happy to help him improve; I'm sure there's stuff that can be defactored out of the legacy rubygems code. It's unfortunate the rubygems maintainers have such a cultural problem here. Oh wait -- that's you.
To be honest, I hadn't thought about caching at the view layer but there's no reason that wouldn't be possible since now the JSON is being created as a template. Good point, would be interesting to explore and expand RABL to support that out of the box. Thanks for the suggestion.
sour grapes
Sour grapes? Of what exactly? I don't really care that he forked rubygems. That he chose to fork it off of 1.3.7 is something I don't envy in the slightest. That codebase was painfully decrepit and he has his work cut out for him. "You broke my monkeypatch" sums up our interactions with Lauren over many months.
Yes, because they're averages. The granularity of the data varies by the length of time you're viewing. I agree with you that we should graph more than a simple mean, but a simple mean is what people prefer if you test it.
I don't think that's the case but _I'd like to know **why** you think that and **how** we can improve_. https://github.com/rubygems/rubygems/pulls As you can see, we've got 14 [edit:that's open count only, the real number is 52] closed pull requests (a mixture of rejected vs accepted--hard to summarize with github). That's just since switching rubygems to git, there were a lot more over the years on rubyforge. We _do_ reject a number of contributions but we do so for good reasons like compatibility, an idea just doesn't fit our design, or it is just as easy to do as a plugin (which we designed in order to allow for more tangental contributions to not be excluded). At the same time, we've taken on regular contributors (qrush, erikh, and um... me) and gotten a lot out of it. P.S. I'll be the first to admit that I don't suffer fools lightly, but I doubt you're referring to my interactions with Trans.
Hubris? What? Where am I shit-talking? I'm quoting and summarizing from his own documentation. He's saying he's going to be API compatible with 1.3.7 from here on out. Entirely his choice. The API from 1.3.7 **is** a mess. What do you think we've been struggling with over the last 8 months?
absolutely _brilliant_
Sorry Ryan, by break I mean spews out the deprecation warnings. It has just made upgrading rubygems go from the 10 minute job (doing it and then running up my apps to test for regressions) to a way longer job - something that I don't have time for in the short term. I appreciate how hard it is for you, as you want to keep moving rubygems forward, but it would be nice to have some flag in .gemrc or something that would turn off the warnings without the need to recompile my gems. On solaris, there are two competing compilers, sun studio and gcc. They don't produce compatible binaries so sometimes you have to do some extremely esoteric things to get the right environment wrapped around rubygems to compile a gem. It's far from perfect, and really ideally our system would be better documented for each gem so I realise some of this is my fault. But the new version of rubygems forces me to clean this up NOW (even though the gems still are compatible) because of a change that rubygems will have to its api in the future. That is extremely annoying. Having a flag in .gemrc would effectively say "I know this is going to be an issue, but i don't want to hear about it yet". 
We plan on addressing some of this pain in the future by having rubygems remember the flags you used to build extensions and reuse them on update/pristine.
Sweet Jesus, they're only *now* using prepared sql statements?
Hey Zen, here's the observation. First, your change to the new behavior was ill thought out. It confuses and punishes people that have no way of fixing the problem, which is suboptimal at best and, you will find, is a strategy no other software uses. Additionally it continues to confuse and punish people over and over every time the code is run, which in ruby development world is a lot. That by itself wouldn't be so bad, but rather than take the criticism, much of your behavior in that ticket, in this thread, and elsewhere has been to ignore, belittle, and/or attack the messenger. Superior as a strategy for deprecating those features: emit one warning message upon first run, noting that there is a problem and warning that within N upgrades from now, the gems will silently break. Include the command to properly update those gems in the warning. Then, in the future, when the 'kill the compatibility' upgrade comes online, run an analysis on attempted install, detect now-completely-incompatible gems, and put up a big alert banner asking what the user would like to do: install the upgrade, or quit and notify the gem owners? A superior communication strategy for open source maintainers: when you detect that there is a significant community grievance, possibly because of unintended excessive behavior that you coded, listen to the community and figure out a way to remediate the problem in such a way that the average, non-ticket-reading user can trivially use; perhaps, for example, by implementing the above, or something like it. Never stoop to 'get out of this ticket' or other such tantrum-like behavior -- at the worst, just say 'hey, appreciate the ticket, still trying to figure out the right direction here.' That way you won't look like a douchebag in public, you don't commit to doing something that you don't want to do, and you provide a positive response to the person who clearly cared enough to comment on your project.
Btw, after looking at your library I was talking to a python programmer/musician friend of mine and he showed me [this](http://web.mit.edu/music21). Pretty amazing stuff...it might be old hat to some but I'm sort of just getting back in to the music theory end of things 
WTF did i just watch!?
both the documented 'convention' and the article are idiotic. 
It's not unexpected to raise an exception if you, you know, read the documentation on what #save! does. In fact, I kind of count on no ruby method doing something 'unexpected', if it does it it's a bug. methods should do what they're documented to do, right? 
Which strategy did Rails use when it released Rails 3.0? Which strategy did Ruby use when it released Ruby 1.9? While RubyGems picked a noisy option we also provided clear direction on how to fix your software so it won't break in the future. I don't think I've seen as much information on how to upgrade your Rails app, or how to upgrade your library to work with Ruby 1.9 as RubyGems has provided on how to upgrade your code to not break in the future. Oh, and we didn't allow things to just break, they just got noisy (unless you were monkey patching internals). I tried the "only warn once" approach with the removal of version_requirements from RubyGems. What happened when version_requirements was finally removed as the warning clearly specified? People became surprised when their code broke! I expect people to be professional about this, I expect them to read the release notes when upgrading and I expect them not to blow things out of proportion. We provided two paragraphs on how to run `gem pristine` to safely upgrade gems. We quickly released a bugfix for `gem pristine` to work well with rvm users. Every other deprecation prints outs which method you should switch to. We worked with bundler to get a new release out which removed more of their monkey patches to maintain compatibility. We provided notice on the rubygems-developers mailing list before 1.8 was released. We're even working to get a new release of Rails 2.3 out to fix any remaining issues. There's a final option here, of course, which is downgrade to RubyGems 1.7 if your software is not yet warning-free. My years of RubyGems maintenance has taught me at least one one thing, people will not read unless you beat them over the head with warnings. Now I've learned a second thing, people will complain no matter what you do. 
or you could just leave it at "Which basically means he's stuck with our mess.". Which so beautifully sums rubygems up.
I was desperately hoping this was a proper replacement for gems. &lt;sigh&gt;
http://pine.fm/LearnToProgram/ I don't care how good you are at programming, that is the best starting book.
You could do it before. It just wasn't automagic.
I appreciate the feedback, but what does any of this do to address the original question. I was asking why he thought "Rubygems is not really interested in anyone helping out" and "[they] seems a bit closed off". Adding deprecations to rubygems has nothing to do with that.
What would make it more proper?
Aaron Patterson's talks are great, I was lucky enough to see him at RubyConf Uruguay last year :) 
That man has one hell of a molestache.
I'm sorry, did you not read my comment? In it, I described your cultural problem explicitly and even went so far as to offer a solution.
I didn't realize until far into it that it's the tenderlove guy ... pretty funny
That middleware stuff was great. Very inspiring.
Of course I read it. Here is how I saw it: &gt; Hey Zen, here's the observation. First, [software problem]. &gt; That by itself wouldn't be so bad, [unfounded claims of my hostility]. &gt; Superior as a strategy for [software problem]. &gt; Then, in the future, [software problem]. &gt; A superior communication strategy for open source maintainers: [good feedback but doesn't address how we're "closed off"]. [bad feedback that takes my actions out of context]. So, a vast minority of it has anything to do with what I asked of bbommarito and even that is a bit tangental. Further to address some of what you did say: Lauren is a developer that we've been wrestling with for quite some time. He has a history of using other people's email and ticket threads to subvert them to his own tangental gripes. All of his gripes are off topic and sum up as "you broke my monkeypatch" (yard heavily monkeypatches rubygems for no good reason, as demonstrated by erikh's [10-line non-monkeypatching rubygems plugin for yard](https://gist.github.com/979914)). My telling him to "get off this ticket" was harsh, yes, but it was apt. Alex's ticket was specifically about deprecations scaring his students (and other gem **users**) and had nothing to do with anything Lauren brought up. Lauren is a big boy. He knows he can file a ticket to air his grievances but instead he stoops to subversion and passive-aggressive behavior time and time again. ETA: &gt; much of your behavior in that ticket, in this thread, and elsewhere has been to ignore, belittle, and/or attack the messenger I obviously have some perception problem because I simply don't see it. Show me in any comment I've made in this post where I'm belittling and/or attacking anyone. The "worst" I can come up with is a sarcastic remark I made about my being quoted out of context and I hardly see that as belittling or attacking. Especially given how belittling and attacking some commenters have been here.
I've read through all of Lauren's commits (made by lauren, not by us and then cherrypicked by lauren) and _none_ of them are performance-oriented.
That's only before noon... After noon it is a full beard.
This talk was awesome! I'd never heard him before and loved every minute.
Well, i am not missing another Railsconf.
His talk at RubyConf in New Orleans was preceded by a 5 minute Rocky style training montage of him preparing for that morning's 5k race. He's hilarious. PS: RubyConf 2011 is in New Orleans again!
Most queries are prepared by default, it's just that they weren't caching the prepared statements. They were only caching the SQL.
wait, so you didn't actually want to know the names of ruby books for your own betterment, you just wanted to compile a list of books so you could write a gay blog post about them? btw you missed out 'refactoring: ruby edition'
One thing that would make it a proper replacement for gems (And they did not do this) is some work on the commandline. Why, oh why do you have to type gem search blah -r to look remotely? That makes no sense, and really needs to be fixed (Either by default or via configuration) to be more like dpkg or yum, where it looks both local and remote. Heck, given 2 hours, I could probably implement the configuration side of that with testing, but I doubt anyone wants to see that fix.
More talks should use ragefaces and memes. What are nerdy jokes for if not telling them to rooms full of programmers? Also, this was a pretty good talk
Whoa, that looks really interesting :)
Gems conflates 3 different concepts into one thing: a loader; the actual package itself and remote managing of packages. Compare it to dpkg/apt (at least for the last two points), dpkg manages files, scripts, depencies, etc but it has no idea how to resolve those dependencies. apt on the other hand does, it also maintains a local cache that can be queried quickly and efficiently. So, as a packing system it's ok, there's nothing wrong with the way gems are packed up. It's simple and that's all it needs to be. The higher level management is atrocious. For example if run gem install --local /tmp/gems/a /tmp/gems/b and a depends on b it fails. This is rubbish. It's got all the information it needs but chooses not to use it. You might say well don't do this, but I think it demonstrates that just how badly thought out gems are. Another point is that there is no central location for gems. So, for example, I have four versions of ruby 1.8.7, 2 * 1.9.2 &amp; rubinius, for which I require a *full* copy of all gems for each installation of ruby. There is no sharing whatsoever, not even the cache directory. This would be comedic if it wasn't so ridiculous. My view, which I will point out is shared by others is that gems were developed from a developers perspective and not a sysadm or devops perspective. Package management is largely a solved problem and there are numerous examples of *very* good package management systems dpkg/apt being the most obvious (for me at least), and there are others. Why didn't rubygems model itself on one of these instead of reinventing a very flawed and broken system. And finally my last gripe: I upgraded my rubygems install and it broke a number of programs. WTF? Why is a program loader built into the package management system? Could you imagine if I upgraded dpkg and ls stopped working.
My personal favorite tenderlovism was at Railsconf 2010 (I think) when he got a question involving Rubinius, so he skyped Evan Phoenix and put him up on the projector to answer the question for him. Evan, of course, was in the adjacent hall doing a talk of his own.
FWIW, people using Rails along with DB2 have been using prepared statements for a long time. (The DB2 adapter for Rails supports this feature.)
I think I see the problem. &gt; I learned from the removal of `#version_requirements` that people will ignore deprecation warnings if you only output them once. This is quite believable. **People will ignore things that are printed out once.** &gt; … so for this release we decided to print warnings every time you use deprecated functionality. This is a logical conclusion. &gt; Run `gem pristine --all --no-extensions` to regenerate your gem specifications safely. This is the solution to the deprecation warnings. &gt; These instructions were printed when you ran `gem update --system` **People will ignore things that are printed out once.** It seems to me that running `gem pristine --all --no-extensions` automatically on upgrade would be the sensible thing to do. But then they'll miss the deprecation warnings, won't they? Then again, if *everyone* runs `gem pristine` after update, who's going to notice the deprecation warnings? Personally, I'm not convinced of the value of deprecation warnings over just cleanly breaking code: deprecation warnings always end up being ignored, but broken code gets fixed.
Making signing easier and actively encouraging (possibly at a later date requiring) gems uploaded to rubygems.org to be signed.
I'm afraid I don't understand how this works. Isn't caching prepared statements a function of the database server?
For those of us without the time to watch the whole thing, can someone provide a short synopsis of who won, and why? I checked rubyheroes.com but I didn't see a way to list present or past winners.
I was looking at some different tutorials on Ruby because I was very interested in learning it and stumbled across this little gem of a site, its definitely a fun way for me to learn, just about done lesson 1 and loving it!
I have 3 years of experience in Rails, so I didn't feel like I needed to do zombies. I did pay for Rails Best Practices because who knows what best practices I've been missing out on? Whilst I knew a lot of the material they uncovered, I got a couple of useful tricks out of it. All in all, I recommend doing them if you are a learning it because it is a really guided approach that requires you to apply what you've learnt right away, and you are forced to validate what you've learnt. I'm probably not the brightest programmer, so I had to go through a lot of trial and error whilst learning.
If you saw the presentation you probably noticed MySQL didn't get much of an advantage out of it. I think prepared statement caching is a function of er... better databases like PostgreSQL and the various commercial databases available out there. edit: since MySQL didn't see much of an advantage from it I figure they didn't focus on it since it wasn't _that_ critical considering most rails stacks use MySQL.
You speak truth. I don't even remember seeing anything about running `gem pristine --all --no-extensions` after running `gem update --system`.
&gt; RubyConf 2011 is in New Orleans again! You know this for sure? 
Have you been living under a rock? It's been mentioned on a few Twitter discussions, a bug ticket, and in an IRC channel! 
It depends on which version you upgraded from. If you upgraded to RubyGems 1.8.0 it was shown [like this](http://paste.segment7.net/md.html). If you upgraded to the later 1.8.1 and 1.8.2 it was not as only the release notes for 1.8.1 and 1.8.2 respectively were shown. As I mentioned in the blog post, future releases RubyGems will show all release notes for the versions you're upgrading through, so if you upgraded from 1.7.2 to 1.8.2 you would see 1.8.0, 1.8.1 and 1.8.2 release notes.
&gt; People will ignore things that are printed out once. Oh, eternal irony! I added printing the release notes on RubyGems update long ago when I made an upgrade where people needed to read the release notes to fix some problem. They haven't really helped, but I'm still trying to beat into people's heads the idea of reading the release notes first before running around screaming like the sky is falling. It hasn't helped. I like the idea of cleanly breaking code, but if RubyGems did that people would be even more upset as all of a sudden their gems disappeared and they got even scarier, larger messages (the entire spec gets dumped out when it can't be loaded). We're pretty much damned no matter how we try to communicate changes.
Well, not under a rock, but I've been rather distracted, and I don't utilize those tools as much as I should. Though, who's to say I didn't update today, not notice the message after running `gem update --system`, run my server, notice all the error messages, use those resources to find the fix and then go and apply it? The fact remains, in the post, he says in the post people ignore something if you only have it show up once, and then proceeds to do just that.
http://rubyconf.org/
I totally agree. The command side of things is the cruftiest aspect of rubygems right now. We need better test coverage (which we've improved! It is finally (fairly) sane to write commandline tests!) and then we need to beat the crap out of that code. ETA: Can you [file a bug](http://rubyforge.org/tracker/?atid=575&amp;group_id=126&amp;func=browse) so you can track this?
I couldn't find any official announcement other than that video, but here's a [list of the winners' twitter handles](https://twitter.com/#!/rbates/status/70640637740982275).
Yeah. I noticed that yesterday. I've overlooked it because Hoe makes it so easy to sign I've forgotten about it. We do need to take it a step further because right now we're not doing enough to verify the signed gems. grosser was putting out an autotest gem _as me_ but nobody could tell it wasn't actually my release. Something to link up the email address to an additional verification would have been nice.
I was using 1.7.x (I forget which version exactly) and upgraded to 1.8.2, so I guess I ran into the issue where only 1.8.2's release notes were printed. I definitely like that all release notes will be shown from now on.
Uh... false. I'm gonna go with false.
I'm being sarcastic. This deprecation issue has been a big problem for me both on a waste-of-my-time level and by seeing so many other developers get stung with exactly the same confusing thing. Although the changes to the Gem API are good, the arbitrary switch with no release candidate and seemingly zero feedback from end-users before making the decision seems reckless. It would be nice if changes this radical were properly documented and advertised *before* they were pushed out to the unsuspecting public.
Okay. I was a little worried there... I'm just glad the issue has been addressed. Though, like you said, this change is pretty radical, and imo almost worth saving for RubyGems 2.0.
Hey! I do indeed plan on buying Rails Best Practices after I complete the zombie one, I also Learn to Program by Chris Pine which was very informative and actually made up my mind that Ruby was indeed the language I wanted to start with. I am by trade a server/cisco guy (cisco mainly) and really wanted to pickup a language I could use as a sort of side job and hopefully a new career venue if I enjoy it enough (which I am greatly enjoying) but I am like you, going to be lots of trial and error haha.
Darcy Laycock, Jonas Nicklas, Ryan Bigg, Loren Segal, Steve Klabnik, Michael Hartl. What their contributions are I couldn't say.
Watch the video and find out! ;)
Anyone get this working with the Rails3 console? I get LoadErrors even though the gem is installed. The README wants me to add it to the Gemfile, but I don't want to make the project depend on this lib.
You can use JRuby and Mongrel under Win.
Anyone else think the stack problem is more of a Ruby problem than a Rails problem? Rails may be much easier to change though.
I'm not going to get into rubygems vs other package managers. WRT Central location of gems, that's entirely intentional (and not ridiculous--please refrain from editorializing) as well as entirely controllable by you. Imagine those 2 1.9.2 installs having completely different configurations (eg 32 bit vs 64 bit). Their compile flags are used to compile extensions so you'd wind up with gemX being compiled differently for each ruby install. By default, each gem repo is relative to the ruby install and this would prevent disaster in this scenario. If, however, you know that's not a problem, you can always set GEM_HOME and share your gems across the board. `gem help env` for more info. Everything else you complain about sounds legit: local install dependency resolution, upgrading breaking your gems, etc... Have you [filed a bug](http://rubyforge.org/tracker/?atid=575&amp;group_id=126&amp;func=browse)? We can't improve things if we don't know about them.
http://www.thirdside.ca/2011/02/23/rails-3-on-windows-with-thin/
I have a hard time keeping up when it's gone from 1.5 to 1.6 to 1.7 and now 1.8 where each step of the way new improvements are introduced without any notification whatsoever. As a user I can hardly see anything better between the various versions even if the internals have changed radically. I don't see the need for such an aggressive release schedule. Iterating like this in a strictly RC or beta environment is fine, though. If people are prepared for errata, they'll be more wary. 
Here's the list of past winners: http://rubyheroes.com/heroes
From past experience when a bunch of changes get piled together it's much harder to make a release and much harder to support. The complicated interaction of the various parts of RubyGems along with the massive piles of legacy code make RubyGems a very tiring project to maintain. The aggressive release cycle makes it easier to figure out if we've broken something terribly and to work to fix those breakages (as in bundler's monkey patches). Iterating in a vacuum is no good for anyone.
Well, do you think that perhaps a patch to implement automatic remote lookup (Either configuration or by default) might be entertained? I am more than willing to sit down and work on it if it would be looked at when done.
I read the release notes, but still didn't see anything about running gem pristine --all --no-extensions Maybe it was there but just wasn't emphasized enough. As it was, I had several days of deprecation spam, including [deprecation spam generated by code in RubyGems itself](https://gist.github.com/980036). Yes, people ignore messages that are printed once... but they also ignore messages that are repeated over and over again. Especially if those messages are verbose. A more sane deprecation warning might have looked like: Warning, the following Gems use deprecated RubyGems API calls, and will break in RubyGems 1.7: rake, rubygems_update, crunchy_bacon I think that would have infuriated a lot fewer people.
I hear you, and while on one hand I'm enthused to see big changes being made, it would be a lot better to have a Rails-style release cycle where people can have a kick at the new version before it's unleashed. Every time you deprecate something in Gem then that makes a mountain of work for people who need to write gems that support multiple versions of rubygems. You're just passing the buck for legacy support. If you're going to introduce something shiny, new and better, there should be a way for older apps to work with the new Gem, as well as new apps to work with older versions of Gem. I'm not even sure where to start other than to try building gems against multiple versions of ruby and rubygems just to be sure. As hagerty9009 said, what's the rush? Why not bundle this all up for Gem 2.0 which would make a clean break with a lot of old, unwanted conventions, and also give people a chance to catch up. Also, as gem builders are identified in the .gemspec file, maybe it'd be better to harass those people directly instead of subjecting *everyone else* to endless warnings. 
Absolutely! Feel free to: * Simply file a bug * copy/paste/tweak a similar test (assuming a similar test exists) and submit that to us as a failing test and we'll make it pass. * submit a working impl tweak w/o a test and we'll figure out the test to go with it. * go whole hog on it.
Even after reading the entire ticket thread, it still seems unwarranted to me. I can understand that you've probably had enough poo flung in your direction over this that you were tetchy, but to me at least Loren seemed to be polite and trying to help.
This has been a long time coming. Nick Quaranto and co have put some awesome work into these guides. They're pretty fantastic. If anyone wants to see the slides from Nicks Railsconf talk, check them out [here](http://www.scribd.com/doc/55824468/Cutting-your-own-RubyGems).
Your first sentence is debatable so I'll leave it be. I completely agree with your last sentence. But... One of the things I've learned over the years working with passive-aggressives (sometimes even on the same team) is that they _always_ seem polite and look like they're trying to help. That's just how it works (or doesn't, depending on which end you're on).
It's right at the top of [1.8.0's release notes](http://rubygems.rubyforge.org/rubygems-update/History_txt.html) &gt; After installing RubyGems 1.8.0 you will see deprecations when loading your exsting gems. Run `gem pristine –all –no-extensions` to regenerate your gem specifications safely. &gt; &gt; Currently RubyGems does not save the build arguments used to build gems with extensions. You will need to run `gem pristine gem_with_extension – –build-arg` to regenerate a gem with an extension where it requires special build arguments. The release notes are organized in terms of importance from highest to lowest. Since the notice comes right at the top I don't know how I can emphasize it more. Due to the [halting problem](http://en.wikipedia.org/wiki/Halting_problem), you can't actually determine if a gem uses deprecated code or not. Maybe it's guarded by a version check, maybe it's in a separate file that is only loaded when compatibility with old versions is needed so you can't easily see the version check, maybe it's simply using legacy code. Writing a heuristic to guess would create false positives and I would be upset if my software experienced a false positive. 
&gt; go whole hog on it. Then that is the option I shall take. Probably a little weekend project, and with wanting to get into open source, this is the perfect place to start: Adding a feature to something I use nearly daily, that I have wanted to see for 2 years or more.
I didn't really feel like I knew Ruby until I started reading *Metaprogramming Ruby*. It's written in such an accessible way with so many examples that you can understand it even though you're not completely comfortable with Ruby.
Hmm. I think "you will see deprecations when loading your exsting gems" didn't communicate the likely scale of the problem to me. I was expecting a warning message if I explicitly loaded a gem that used the deprecated API from my code. I wasn't expecting multiple warning messages every time I used the gem command or irb. I wasn't suggesting solving the halting problem; just that if you would normally have output a message saying file X from gem G calls deprecated method M, you should instead have just output all values of G in one message, with no information about X or M unless gem was run with some kind of --verbose flag.
Well, maybe there are other threads that lead you to suspect Loren was being passive-aggressive. But I don't see it from that thread alone. And yes, that's a matter of opinion, I'm just saying how it looks to an outsider who doesn't have any particular position or enmity in this battle. And on the other hand, that's the only reply of yours that I've seen that seems somewhat unreasonable to me.
In the past the Rails release cycle has included breaking things intentionally without including details in the release notes and without providing deprecations. Since Rails 3 it seems that they've gotten better at this. Even still, not every release of Rails is perfect, and when prereleases of RubyGems have been made in the past they've rarely caught major issues. I've released many, many gems and rarely due I support usage of all versions of my dependencies. It's simply not worth the time or effort and trying to do so would certainly create a mountain of work. Rarely does a gem I release need a particular version of RubyGems. For the few that do, RubyGems 1.3.6 or newer is sufficient (for Gem.find_files). I don't see anything we've changed that necessitates backwards-compatibility code being added to even 1‰ of all gems (24 gems)… and I'd be surprised if it's even half that. (For gems under active development I can name isolate, bundler, maybe chef, which is 1.25‱ can you name more nine more?) What we've provided a window where features are deemed legacy but operational, given an explicit sunset date when features will be removed and added an incentive for change in the form of warnings. I'm not sure what you mean by "legacy support" but it seems that we've provided it. If you mean legacy support without warnings then what would the incentive for change be? If we waited N months then turned on warnings people would complain saying there wasn't enough time. If we waited M months and deleted the legacy code people would complain even more saying there still wasn't enough time. The historic slow release pace fostered resentment about RubyGems not fixing bugs fast enough. Now we're fostering resentment about moving too fast. I'd rather be moving quickly and fixing bugs than piling up changes and tell people "we fixed it, but we're not going to release for six months, just be patient". (Also, RubyGems doesn't pay enough for me to even attempt multi-branch development.) PS: For gems I release I support ruby 1.8.7, 1.9.1, 1.9.2 and newer. I use `rake multi` from hoe to test on 1.8.7-p330, 1.9.1-p378, 1.9.2-p136, 1.9.2-p180. I also test on Apple's ruby in 10.6. I perform primary development on ruby trunk, (but I don't recommend that). I hear rvm can be used to perform similar testing. (Also, about 3% of ruby installs are using 1.8.6 or 1.9.1, so I'll probably drop 1.9.1 support after 1.9.3 is released.) 
How often do you run with --verbose or ruby -w? Most users would never notice the warnings and then be confused and understandably angry when their gems no longer appear six months down the road. I've experienced this before with RubyGems and there's really no easy answer.
&gt; We're pretty much damned no matter how we try to communicate changes. Sadly, yes. However, on the upside, everyone knows the solution now :-) (I haven't been hit by the deprecations yet, possibly because I've only installed 1.8.2 on clean systems. But if I do see them, I'll know what to do. So maybe the noisy deprecation strategy *did* work after all.)
No, you misunderstand. Still output an abbreviated 2-line warning all the time, but don't bother listing the specific files and methods (which users don't care about) unless --verbose is selected.
We're almost always in IRC (via dircproxy) tho we're sketchier on the weekends. Feel free to pop in to #rubygems on freenode.
*nod* Of course you don't see it from one thread... You see it over the course of months and months over many mediums.
Ah, that would work if I were more confident in people reading instead of ignoring warning messages, which I am not ☹
99% of the warnings I get are about default_executable, which is something of dubious utility in the first place. Still not sure why you can't just eat this and ignore it. As a developer what I'd want (ideally) is a rigorous "gem check" kind of routine just like "bundle check" that can, if I want, give me a detailed list of all the deprecation problems that may exist. What I don't want is all this screaming and wailing about things that *are not my problem*. Introducing a facility in an application and later revoking it should be done with great care and caution. I understand the need for forward progress, but whenever possible the "old" way should be maintained even if it just aliases one method to another. One problem I'm seeing a lot of in the Ruby world is that although releases are generally "bug free", internally consistent, they break a lot of other things outside the scope of the application or library itself. I've started to make use of Gem to the extent of providing friendly warnings and helpful suggestions of required components are not installed. Unfortunately I'm using the "old" way and none of that works any more. I'm left wondering how long this new way will last, or maybe if it's just some short-term fad that will be switched up again later. 
AFAIK, Bundler requires you to have stuff like this in your Gemfile if you intend to use it in the app. You could set up a "development" group, which is only loaded in the development environment, to load things like irbtools, pry, ruby-debug, or any other gems that are only generally useful to developers. Make sure when you install the bundle on a production machine that you "bundle install --without development".
I'm not sure why I'm answering you when you've proven to be a troll on reddit... but this needs to be answered: &gt; As hagerty9009 said, what's the rush? Why not bundle this all up for Gem 2.0 which would make a clean break with a lot of old, unwanted conventions, and also give people a chance to catch up. Ruby 1.9.3 for one.
With "modeling after apt" do you mean that RubyGems should match apt's behavior or that it should use apt? If you meant the latter then the reason for not doing so is obvious: apt is not easily usable on non-Debian systems and there are *tons* of Rubyists on OS X. But even apt has flaws compared to RubyGems. Apt provides no way to install multiple versions of software and everything is installed into the same filesystem namespace. Library authors kind of work around this by installing their files into version-specific directories, e.g. /usr/include/gtk vs /usr/include/gtk-2. RubyGems on the other hand takes care of versioning too. This is something that Apt cannot do without major modifications. Apt works well if you only need to install one version of everything but is a huge pain when dealing with multiple versions.
ok, so I'm sure it is amateurish and I know I don't follow convention all the time, I am still getting used to ruby and OO. I am not a computer scientist, and I'm sure it shows. But I made a serious effort to document my code and write unit tests. It is still in it's early stages, but it is functional as long as you are using 1.9, I hadn't even thought about coding for older version's of ruby until I had a friend try it out on 1.8.7. Take it for what it is I guess, I don't expect anyone to be excited, but I would still love to know what you think.
Don't forget [Top Ruby Jobs](http://toprubyjobs.com/) Appears to be $195 for 30 day post.
I'm not sure why this has been downvoted so heavily. I completely agree - more security that the gem you installed is the gem you intended to install would be fantastic.
Ahh yeah that's what I was worried about. I work with a small team on a single project, so if I were to add this to the Gemfile, everyone would also have to get it. I just can't justify that. 
oDesk!
who is andrew?
Have you ever hired someone from oDesk? I fear outsourcing. Plus I don't think we can do it here. Employee #4 for a startup. We think they should be local.
Sorry it was a joke. 
What doesn't work any more? I haven't seen a single ticket that claims any deprecation has removed functionality. If you can show any functionality that doesn't work anymore please file a ticket so it can be fixed. And no, we're not into fads.
Is there an aggregator of all of these job sites?
"We're making big changes to Gem in preparation for Ruby 1.9.3 and to avoid problems with older interfaces that are proving difficult to support" would have given people some context to understand where you're coming from. Instead I get "Post a ticket" or "Please post a ticket" or the old chestnut "You probably haven't posted a ticket". If you think I'm a troll it's because I'm upset and have the audacity to have an opinion. If I'm upset it's because I have a hard time believing these changes are necessary and urgent, and further, that they couldn't have been handled in a more forgiving manner. If no functionality is being removed, if it's simply being relocated, why not map the old methods through to the new ones? Why break the API? Further, if this API isn't really exercised by more than a handful of applications, why the fuss in the first place? As far as I can tell these deprecation warnings originated with rubygems in the first place. Why place the responsibility on the developer to fix them? You made the mess. You clean it up. What am I supposed to tell people when they upgrade gem and find themselves drowning in a sea of deprecation warnings? That they need to pristine or recompile every gem they have installed? I'll just tell them to install chicken_little and in a minute they can get on with life. I've had to do a lot of pot banging to get people to get their gems Ruby 1.9 clean, and I keep having to do it. Still, every time I file a ticket, and I do, I get a response along the lines of "Oh, sorry, I didn't know that" or "The next release should address those problems". I do not get "It's not my problem". When later versions of Rails 1.2 started kicking out a ton of warnings about soon to be deprecated features, it did not go over well. Yes, these were in preparation for the upcoming 2.0 release. Yes, they were things that had to go. It was still not the place to badger people about versions they're not yet using. The Rails 3.0 team has taken a significantly more mature approach in this regard and make an effort to maintain interfaces for the same base version. Simply putting a useful "gemspec" version in the file would have side-stepped a ton of this and allowed older interfaces to be supported as well as can be expected with newer versions of rubygems. This is common practice for a lot of software. 
Previously: Gem installed gems. Currently: Gem installs gems, whines incessantly about things that make no sense, requires time-consuming pristine repair mode to "fix" most but not all of the warnings. Current version of Bundler gets called out for using older methods that are not fixed by pristining. There is a ticket for this issue. It is, apparently, not a priority.
Here's hoping!
in your ass?
Again, what is broken? Does Gem::SourceIndex no longer work as it did before? Does Gem::GemPathSearcher no longer work as it did before? Does Gem.source_index no longer return what it did before? Does Gem.searcher no longer return what it did before? If it was one of these things, or something like it, that you are having a problem with then it is broken. Please file a ticket. If it is only the deprecation warnings you are experiencing then you have two solutions. Downgrade to RubyGems 1.7.2 or upgrade your code. By now you've spent more time arguing about it than it would have taken to upgrade your code.
Bring it to Seattle!
indeed.ca isn't bad. Not sure if they index those sites, but it gets a bunch ton of sites.
[RubyJobs.ru](http://rubyjobs.ru/). It's absolutely free. When you are looking for Ruby/Rails developers from Russia.
[Github Job Board](http://jobs.github.com/) $300 for 30 days.
A while back, I had thought from the proliferation of tools to help one manage building and deploying gems that it would be a complicated process. At one point it may have been, but these days all you need to do is look at a [sample gemspec](http://guides.rubygems.org/specification-reference/), copy and modify, gem build, and gem push. Hopefully these guides help clarify how simple it is to make gems.
Local Ruby meetup.
Is anyone else using this in production yet? I'm thinking about running it as my default ruby on my dev system for a few weeks to see how it does.
1. It's not my code that's broken, it's other gems with .gemspec files generated by rubygems. I'd be less irritated if this problem didn't originate with *rubygems itself*. 2. Why bother upgrading rubygems when your advice is to downgrade? Why not call 1.7.2 the end of the line and we can get on with life? 3. Is there going to be a heads up on any other surprises going forward? 
madness they missed this gem...
Wouldn't it be easier to submit a patch than to depend on yet ANOTHER gem?
i did submit a patch, https://github.com/rails/rails/pull/1130, it was rejected because in 3.2 they might want to refactor the way they do processors. Hence the gem.
Say wha? There's also mod_rack/Passenger, fcgi, or proxying to thin, mongrel, unicorn, etc.
on Windows? no.
mongrel + mongrel_service
link?
On Windows, the only one you lose is Passenger.
http://itunes.apple.com/us/app/pc-load-letter/id438375689?mt=12
Awesome. I've been using a Perl script to do this forever. I used the last code in the list.
hence why i said only way to deploy your Rails app directly under apache is via cgi or (fast cgi)
Thanks PatrickTulskie, I can't believe I forgot the link!
YES PLEASE!
Perl? Eww. The last code has been marked off the list.
Why not just use Ruby 1.9?
My app has gem and API dependencies that rely on 1.8.7. Using REE is a cheap way to get a boost in performance without doing much work. If Kiji is better then that's great. Re-writing huge chunks of the app to get on Ruby 1.9 right now would be far too expensive in terms of programmer time and money. Some parts of the infrastructure run on Rails 3 and Ruby 1.9 but the core app doesn't and I don't see that changing any time in the near future. Twitter is running on 1.8.7 for this exact same reason.
I'll answer my own question... it has some incompatibilities. When I booted up my app it kept crashing because of trying to modify frozen hashes. I'm not sure what's up with that but for the time being I'll stick with REE.
I just used JHWWEXP6H7LJ. This is awesome.
Seriously need to get a hang of this Reddit thing.
The dbms may do caching. If I understand correctly, Rails is now caching the prepared statement handles. 
So many smart people working on so many projects that attempt to do the same thing which is to make ruby faster and take up less RAM. I realize they are all scratching their own itches but man it seems like such a huge waste of time. We have ruby1.8, ruby1.9, ree, Rubinious, macruby, jruby, maglev, and kiji. All of them are in some way incompatible iwith others too. No wonder nobody is moving off of 1.8. It's just too much of a minefield when you can never be sure which of your gems is not going to work with the ruby you are choosing. Maybe Charles has the right idea. Maybe it's time to work on a ruby successor like mirah instead of trying to push this cart with weirdly shaped wheels forward. Why don't all these people get together to put out ruby 2.0 or whatever. Take away the cruft and the huge stack, clean up a syntax a little, and maybe add some type hints or some perl like strict levels or something and call it a day. Think about how many man hours have gone into the projects I mentioned and how utterly brilliant the people who put those hours in are. Such a mountain of talent with a single purpose would put out the best language EVAR!!! ok end of my rant. Now back to working on my apps still using 1.87 because well who knows if anything else will actually work with all the gems I need in order to make this app run. 
I'll tell you why, because each implementation has a clear purpose. JRuby is clearly focused on Java integration. MacRuby is clearly focused on OS X/Cocoa integration. You're more confused than you should be. Ruby 1.8, REE and Kiji all belong in the same category. In fact REE is synchronized with Ruby 1.8 once in a while and patches in Kiji can flow back to REE or to Ruby 1.8. All people working on the same thing only works in a world where everybody has the same goal and nobody runs existing things in production. It looks Utopian from the outside but it'll almost never work in reality; if it works out then it probably means nobody's using your stuff.
Kiji has many interesting patches and it'll be good to eventually merge them back to REE.
erm... how do you use promocodes?
 Time before RAPTURE! [==============================================09:05:33============================================= ]
&gt;You're more confused than you should be. Ruby 1.8, REE and Kiji all belong in the same category. In fact REE is synchronized with Ruby 1.8 once in a while and patches in Kiji can flow back to REE or to Ruby 1.8. Saying patches can flow doesn't mean anything. The fact is that we have three different implementations of 1.8 for no good reason. Three different teams, working on three different projects with the same goal of making a faster ruby which uses less ram. Also as the article states kiji is not fully compatible with 1.8 It seems like a waste. &gt;All people working on the same thing only works in a world where everybody has the same goal and nobody runs existing things in production. Most people working on these projects have the same goal. Build a faster ruby that uses less ram. 
In the Mac App Store, go to Featured &gt; Quick Links &gt; Redeem
Rapturize any site! https://github.com/crystalcommerce/Rapturize
Man, I meant to upgrade my system's gems and accidentally upgraded RubyGems. Didn't understand what all the talk was about until I upgraded and now everything I do in the console has to flood me with deprecation messages. Not sure how anyone can consider this usable. Possessing only moderate experience with Ruby, I don't know much about the intricacies of things like gems. The appeal of gems was always that they just work. Reading the related fallout about new RubyGems, it seems like the onus is on me and the developers of the gems I use to stop the deprecation messages. the 'pristine' commands don't fix anything for me. Not everyone using RubyGems is an experienced developer, and I'm certain a small minority has even ever posted an issue on an issue tracker before. I'll [try to] try SlimGems out. dan@crunchbang$ sudo gem install slimgems ERROR: Could not find a valid gem 'slimgems' (&gt;= 0) in any repository ERROR: Possible alternatives: allgems, plugems, singem, sitges, slippers dan@crunchbang$ gem sources *** CURRENT SOURCES *** http://rubygems.org/ http://gems.github.com Anyone know why slimgems can't be found? 
link?
russian progrmmers are pieces of shit, they not only make your website they also drink all yoru vodka and fuck your wife
Maybe he went to this talk: http://en.oreilly.com/rails2011/public/schedule/detail/19572
Thanks! :)
&gt; The fact is that we have three different implementations of 1.8 for no good reason. No. 1.8, REE and Kiji are not three different implementations. They are relatively small variations of the same implementation. They are best described as branches of each other. &gt; Most people working on these projects have the same goal. Build a faster ruby that uses less ram. No. JRuby's main goal is Java integration. MacRuby's main goal is Cocoa integration. REE's and Kiji's goals are to make Ruby faster *while at the same time remaining compatible with 1.8*. 1.9's goal is to make Ruby faster without caring too much about compatibility. "Building a faster Ruby that uses less RAM" is only a superficial and oversimplified goal. Where did you read that Kiji is not fully compatible with 1.8? REE *is* fully compatible with 1.8, it's based on 1.8 and does not change the language or binary compatibility. Kiji pretty much only changes the GC stuff.
&gt;No. 1.8, REE and Kiji are not three different implementations. They are relatively small variations of the same implementation. They are best described as branches of each other. Why pick that nit. They are three different implementions ruby 1.8. It's a waste of effort to continue to develop three competing implementations of the same spec. Why can't they all work on the same project. Actually you are leaving out rubinius and maglev. &gt;REE's and Kiji's goals are to make Ruby faster while at the same time remaining compatible with 1.8. Same with rubinius and maglev. &gt;.9's goal is to make Ruby faster without caring too much about compatibility. "Building a faster Ruby that uses less RAM" is only a superficial and oversimplified goal. Nonsense. That's the main selling point of both ree and kiji. &gt;Where did you read that Kiji is not fully compatible with 1.8? For fucks sake learn to read. I never said they were compatible. I specifically said they were not compatible. &gt;Kiji pretty much only changes the GC stuff. WHY?????? Why not just change the GC stuff in 1.8? Why not change the GC stuff in rubinious or ree? Why fork it and change the GC stuff for your private project?
&gt; Why pick that nit. They are three different implementions ruby 1.8. I only consider them different implementations if they're radically different from each other, which they're not. If I fork Firefox and only changed the way its Settings dialog looks like then I have not created an entirely new browser. &gt; It's a waste of effort to continue to develop three competing implementations of the same spec. They're not competing. Kiji does things REE does not and I'm looking at merging their changes back to REE eventually. Whether MRI merges the changes back is up to them. Neither REE nor Kiji reimplements the core language libraries, the parser, the interpreter, etc. They reuse the existing implementation. &gt; Why can't they all work on the same project. So if Kiji lives on the REE Github repository instead of their own, with no other (organizational) changes, then everything has become magically okay in your mind? &gt; Same with rubinius and maglev. No, definitely not Maglev. Maglev is built on top of Gemstone which is a Smalltalk runtime. It doesn't even try to be compatible with MRI C extensions last time I checked. &gt; Nonsense. That's the main selling point of both ree and kiji. No. Neither REE nor Kiji try to implement 1.9 features like ordered hashes or kernel threads. &gt; For fucks sake learn to read. I never said they were compatible. I specifically said they were not compatible. Uh yeah, and I never said you said they were compatible. &gt; WHY?????? &gt; Why not just change the GC stuff in 1.8? Why not change the GC stuff in rubinious or ree? &gt; Why fork it and change the GC stuff for your private project? They *have* changed the GC stuff in REE. They're just publishing their changes in their own repository. They're basically giving you the chance to try their work before I'm done reviewing their work and possibly merging their patches back in REE. The alternative is that they publish their work on the REE Github repository but that would neither change the REE release schedule nor make any other practical difference, other than making the situation *appear* less messy in your head. Why work on their own repository instead of on ours? Because it saves communication overhead. They don't have go through us first before they can start writing code. I'm all for this decentralized development approach where they just do their thing and letting us decide when it's an appropriate time to merge back, while at the same time giving people the choice to try their in-progress work.
Thanks that would be spectacular. :)
Why do people keep improving MRI 1.8.7? It is definitely the most widely deployed version of Ruby, but ruby-core has already decided there will be no 1.8.8 and 1.9.3 is being prepped for release. JRuby even supports a `--1.9` mode.
doesnt yard do this?
srsly, dnt even bother talking to malcontent he's a well known reddit moron
About ⅓ of rubyists use Ruby 1.9.2 and ⅔ use 1.8.7. There's about 1.5% on 1.8.7 and 1.9.1 each, so your assertion that nobody is moving off 1.8 is false.
If I remember correctly they first did this with Perl at a BlackHat talk in 2001 or 2002... Cool regardless - used the Y4J code
Nerd drama... But seriously, sometimes original maintainers do something so fucking retarded and refuse to even admit it's a problem. It happens a lot and there aren't many good ways to handle such cases. Complain? Ignored. White patch? Ignored. Fork? OMG you're breaking the community. etc.
&gt; Complain? Ignored. The issues at hand have been discussed at length. Nobody was ignored that contributed something to the discussion. &gt; White patch? Ignored. If you read the article, you'll see no patches were ever submitted pre-fork.
I just used LYE4MEXLR7T6 Thanks.
This is really nice. I've been noticing myself how clean the whole process can be from writing a gem to getting it pushed to rubygems, and figuring out some best practices for code organisation too. Great to see some documentation coming out around this :)
You know, I never quite understood why RubyGems added deprecation messages for `default_executable`. I don't think anyone ever used `default_executable` as Eric Hodel stated [it was designed for a feature, that was never implemented](http://blog.segment7.net/2011/05/18/rubygems-deprecations). Perhaps making `Gem::Specification#default_executable=` a no-op could have avoided creating that previous drama storm?
I've been thinking about this whole end user noisy warnings thing and trying to figure out whether I support it or not. I think the main utility of it is to drag inactive maintainers out of the woodwork, who might not be trying to build new versions of their gems regularly (and so wouldn't see gem build side errors / warnings). It seems to me that this will be effective at getting the word out about the changes, but it does seem heavy handed at best and misguided at worst, there are other ways this message could have been spread. But no matter what, my emphasis is on the *way* the community interacts with the gem maintainers, not the actual consequences.
Haha. Wow. I just ended up reverting RubyGems. 
Were any projects actually effected? If the number of projects effected was under 20, they could have avoided annoying/angering the majority of users (who don't maintain gems and thus don't care about the warnings). I understand what your blog post is addressing, and pretty much agree. I just never heard a solid answer as to why the warnings were necessary; besides "Nerd Rage", which sort of blames the user.
Not sure. Personally I upgraded, saw the warnings, promptly downgraded :)
I saw the warnings, googled, immediately found the "gem pristine --all --no-extensions" answer, ran it, and the issue was solved. All in less than two minutes. The only thing I found strange was: why couldn't "gem update --system" just run "gem pristine" for me? If there's no post-install hook for "update --system" then there should be one.
That's a good question. Maybe file a feature request on RubyForge? http://rubyforge.org/tracker/?atid=578&amp;group_id=126&amp;func=browse 
Given that some people (like taw) have claimed that running `gem pristine` has broken their stuff (without filing any tickets, *sigh*), I'm hesitant to do anything automatically. The only thing worse than "_omg warnings_" nerd-rage is absolutely legitimate "_you broke my shit_" nerd-rage.
Et tu, brute? :P
Giles Bowkett's little "FUCK YOU" was amazingly hilarious, moreso with the ["some context since I blocked you"](https://github.com/rubygems/rubygems/pull/64#issuecomment-1219113) (ooooooOOOOOOOOOOoooooooooooooO).
http://railscoach.com/009-rc-rubygems-and-bundler/
I haven't investigated this one, but every time I've seen such situation, the original maintainer first fucked up something, and then behaved in a way that escalated the problem. glibc comes to mind for a long history of this kind of behaviour.
affected* noob.
I believe `yard server -r` achieves this (the `-r` option is for live reloading)
&gt;About ⅓ of rubyists use Ruby 1.9.2 and ⅔ use 1.8.7. If that's true then it's horrible. It's been years and only 1/3rd penetration? 
&gt;I only consider them different implementations if they're radically different from each other, which they're not. Why would you have this insane criteria? That makes no sense at all. &gt;They're not competing. Kiji does things REE does not and I'm looking at merging their changes back to REE eventually. They are both trying to achieve the same thing so it's waste of time. Why not start by contributing to REE so you don't have to contribute your changes back. Better yet why don't both REE and Kiji teams contribute to 1.8? &gt;So if Kiji lives on the REE Github repository instead of their own, with no other (organizational) changes, then everything has become magically okay in your mind? It's a waste of time. They can and should work on the official 1.8 repo. &gt;They have changed the GC stuff in REE. Again why? Why not just work on the REE project? &gt;The alternative is that they publish their work on the REE Github repository but that would neither change the REE release schedule nor make any other practical difference, other than making the situation appear less messy in your head. It's much messier now. Now you have two different teams working on two different projects. &gt;Why work on their own repository instead of on ours? Because it saves communication overhead. No it doesn't. You think the merge will take place without communication? Also isn't communication good? Why don't these people communicate with each other (I am presuming they are not since you made the bold and outrageous claim that there is no communication overhead). 
For some reason this didn't work for me - I had to downgrade. Of course, this is my second day programming in Ror and second day programming since ADA class in '96 - so I may not know wtf I'm talking about.
The trick above works for libraries that aren't C extensions. But if you have any extensions installed that use the deprecated APIs, they will still complain. I think the reason why you can't get rid of the messages for extensions is that pristine does not work safely on them.
Does YARD live inside the app? This shows the source for the specific versions inside the app, and doesn't show anything that's not loaded in the process.
Just redeemed HA773HXNRXFK , cheers.
This is a self-post.
maybe this link? http://teachmetocode.com/screencasts/acceptance-tests-with-rspec-and-capybara/
Hi r/ruby, thanks for checking out Briquette. Hope you enjoy! :)
I used NJLHPKKFF3N7. I already purchased your app earlier this month, but AppStore wouldn't let me update the app, saying I used a different account to purchase the app (I only have 1 account)... sorry for wasting a promo code, but I wanted to see if it works, and I'm finally on 1.1.3. /rant about AppStore Thanks for making this app, I had been using a Fluid instance before. I didn't really like Propane when I tried it, and Pyro hasn't been updated since 2008. Looking forward to more updates!
Sorry for any inconvenience caused by the App Store! Obviously, it's a new product for Apple too, and they're still ironing out some rough edges. 1.1.3 fixes a ton of edge cases relating to foreign encodings (and an infinitely looping regex - blech), so we're glad you get to update. If that ever happens again, please let us know. We'll make it rain promo codes (and file an issue with Apple). Thanks for using Briquette :)
How about making the warning code say "You might want to run gem pristine to make many warnings go away" at the end of the warnings?
Sorry, we couldn't find what you were asking for. Whoops, maybe someone moved it, deleted it, or misplaced it somewhere. In any case, here are a few other places you could look... 
Wow, glad to see someone actually doing something to mend the fence, and investing quite a solid chunk of time. A scholar and gentlemen indeed.
Sorry, Posterous sucks and is failing intermittently. You can either reload a couple times, or go to the main page of my blog: http://blog.majesticseacreature.com/ 
I tried deleting and recreating and it's still linking back to reddit. Go here http://teachmetocode.com/screencasts/acceptance-tests-with-rspec-and-capybara/
1.9.0 wasn't a production-ready release (Dec 25, 2007) 1.9.1 flushed out usability (Jan 30 2009) 1.9.2 was the first 1.9 release that was ready for general use (Aug 18, 2010) Just under two and a half years, not bad for as big a change as Ruby 1.9 introduced.
One of the tickets says that Jeweler puts a call to one of the deprecated functions in the code it generates. If that's true the number of affected projects was probably well over 20 which would make notifying gem authors and ensuring the projects were upgraded difficult to impossible. 
Exactly.
I spoke with the author of Jeweler at a long-ago RubyConf and said "generating code is bad, you can't update Jeweler to fix problems", primarily because Jeweler was generating code with Rake::GemPackageTask and Rake::RDocTask instead of the modern and better maintained Gem::PackageTask and RDoc::Task. He basically said, "yeah, that's a problem". As far as I know Jeweler still generates code making it hard for users to fix problems by simply upgrading Jeweler like you can with Hoe.
[Leave zenspider alone!!!](http://skitch.com/blowmage/fy6b4/leave-zenspider-alone)
ahahahahha. I should put that on my blog post.
A lot more people used it than you'd think. I just removed explicit `default_executable` lines from rails itself (and all dependencies).
Amended: but if you know your C extensions didn't have anything special about their installs, go ahead and do them too.
Pthththt
Fantastic effort, Greg! This is a great example of problem-solving and teamwork!
&gt;Just under two and a half years, not bad for as big a change as Ruby 1.9 introduced. Two and a half years is forever in IT terms. Look what happened to REE is two and a half years. 
Chrome seems to hate your blog. I don't think it is personal, though.
wat r u wearing, describe it &amp;&amp; IS IT TIGHT
I grabbed XPJYKK737FK6; thanks! I'm a relatively new Campfire user, and I've been looking for an (actively developed) OS X client. Thanks!
Greg is a right awesome chap!
Why are you trying to change directory like that? Can't you just put the whole path in the cp command? I think the shell executes the two piped commands simultaneously, rather than in sequence, and at any rate this isn't how pipes are supposed to be used. You're not passing anything via standard in/out.
I suspect that what you were intending to do is alias cdcp="cd /Volumes/my/custom/path/ &amp;&amp; cp -rf sourcedir destdir/sourcedir" 
Because I want to be in that directory when the command ends. 
Thank you!
Now if only the rubygems maintainers could act like Greg instead of pontificating to one another what the best way to submit a patch is and telling otherwise helpful developers that their contributions are unappreciated.
Sure thing, thanks for checking it out. Let us know how you like it, or if you have any questions / suggetions / complaints!
I used KYY4LXLAFT3W, thanks for the app, this should be fun. How was developing in MacRuby? I would like to hear more about your experience.
Only part of that picture is personality, a big part of it has to do with communicating effectively with users/contributors and also setting the right expectations for community members. This is a vicious cycle for all those involved. Honestly, the reason why I'm qualified to help out here is because I failed hard as a maintainer of the PDF library Prawn by gradually turning into a huge asshole without even realizing it. If the RubyGems maintainers have personally offended you in some way, I don't expect you to accept my word on faith. But if you're like most of us and watching from the sidelines, please just give them a chance to correct these issues. Great technologists can and should be great community leaders. But that is an orthogonal skillset. I can't promise that what I'll do is going to make a big difference, but I do think we should let it run its course and see what happens.
Loving the new update. (and thanks for correcting the styled text in the input box!)
I want to grab TXYNEAHNMKFE , but not sure how?
We hated that one too, you're welcome!
Grabbed TXYNEAHNMKFE. Thanks for the awesome promo!
Open the app store app, then in the right column under "Quick Links" you can click 'Redeem' and enter the code. Looks like that code is taken but there is probably at least one left in the above set!
Quite welcome, hope you get some good use out of it!
What did it accomplish? I can see only one thing, modifying the GC to copy on write. Why doesn't it have any other 1.9 features? Where's the faster VM? Encoding support? YAML 1.2 support? Object memory footprint reduction? Where are upcoming features like improved speed of Date and DateTime? Further improved VM speed? Lazy-sweep garbage collection? I'm not sure what you're saying… is it that REE is a dead end?
I found that development in MacRuby is very nice. It brings the syntactic awesome that Ruby provides, while providing a great interface to Cocoa and Objective-C. There is a learning curve for the Objective-C stuff, but it wasn't too bad. The toolsets are way better than that of Java, intuitive and 'feels right.' If you're doing Desktop development for the Mac and don't already know Objective-C, MacRuby is a no-brainer. 
But how many (rough number) set `default_executable` to something other than the first element in `executables`? I guess it's unfortunate that `Gem::Specification` is used in an explicit manner.
All codes have already been used. =) Bummer.
I don't have an answer for that, but it should be pretty easy to figure out.
Ruby has to be built against libyaml now?
The reason why places like SourceForge sucked was because project maintainers got full of themselves and rejected people's contributions (which were already difficult to make) without any rhyme or reason. I hope what you're doing here pays off. I've had mixed experiences with project maintainers in the past and I hope calling all of this to light helps with the general ecosystem... not just RubyGems.
Questions: 1. Did you try to build this app using cocoa/something else before writing it in MacRuby? 1. What did you like and dislike about building your app using MacRuby? 1. How long did it take to make? 1. If you've developed Rails apps, how does building a thick client compare? 1. What's your favourite music for hackin'? Edited to add feedback: * Not being able to sort/hide rooms is killing me. * No searching also is killing me. * Mapping command+up|down in addition to command+shift+{|} to change rooms would be nice, since the rooms are displayed vertically. * Images displayed inline seem too small. * Font control would be cool. * Yeah, I can see this easily replacing Propane. :D I know some of these are on your getsatisfaction page, so I put some votes on a few things there. Just wanted to say it here, too. Love the program, and am looking forward to future versions!
You'll probably get a better response on StackOverflow.
I suggest to you to see Ryan's screen cast "Authentication from Scratch" http://railscasts.com/episodes/250-authentication-from-scratch I'm already working on a Sinatra application... I use Warden for authentication though.
Good point. Thanks. I've been searching StackOverflow but didn't think to post.
That sounds perfect! Thanks so much.
I edited my comment... you can also add warden as rack auth system... it would be super for sinatra apps.
I'm afraid I can't offer advice on the code - I've only done Rails apps rather than Sinatra. However with this part: &gt; The main concern is how can I securely transfer data between the client and the sinatra app without someone in the middle sniffing the data? You will be wanting an SSL certificate for the web server. You can find various guides via google depending on your set up. If you want, I can PM you the company we use for SSL certificates (27 USD for 3 years if I recall). 
ok thank you. I'm just getting started with all this so I'm unfortunately not familiar with the keywords I need for google-fu. 
That's okay. To securely transfer the data from client to server you want to use HTTPS (HTTP Secure). SSL Certificates are used to set up the encrypted connection between Client and Server. Do you know what web server you'll be using with Sinatra? I've just PM'd you with the link.
what web server? I thought sinatra *was* the webserver?
From the little I know of Sinatra, you can either have Sinatra running as the web server or you can sit it infront of passenger/and or apache. http://stackoverflow.com/questions/3696558/how-to-make-sinatra-work-over-https-ssl The above link has sinatra and SSL working together by using Webrick - the only warning I'd give is that the link I PM'd for the SSL cert is that it doesn't show how you to tell Webrick to use an intermediate certificate.
Sounds like a really lame reason &amp;#3232;\_&amp;#3232; 
Thanks again, so far my searching in SO hadn't found that post. Probably because I didn't think to search for SSL.
Railstutorial.org walks you through creating a secure login while building a twitter clone. It's also a nice intro to TDD. It's not free though.
Look interesting. What is TDD?
He does offer the complete tutorial free in html format. I got about halfway through and found it helpful enough that I bought the book.
It's a waste of time. All that effort could have gone into making the official ruby better.
[Test Driven Development](http://en.wikipedia.org/wiki/Test-driven_development)
[Warden](https://github.com/hassox/warden/wiki/overview) is probably a good bet. Here's a small example of Warden and Sinatra: https://gist.github.com/217362. See also here for more examples and links: https://github.com/hassox/warden/wiki/Examples There's also [Sinatra_Warden](https://github.com/jsmestad/sinatra_warden/) which seems to bundle it all together.
Ah! Right. Should have known that one.
That's a great suggestion. You shouldn't try to implement your own system, security is hard, etc etc
Wish there was a trial as I already own Propane and don't want to go randomly buying potential replacements.
I used warden in a bigger project. Auth_logic isn't bad but I was having problems with testing.
Is auth_logic still around? I've read some posts that it's no longer supported.
Just to add, the one listed "Ruby Jobs" above is really the Ruby Inside Job Board :-) The page that actually explains what's being offered is at http://www.rubyinside.com/post-a-job It's $299 for 60 days and the jobs also get into the Ruby Weekly newsletter (another 5200 subscribers), published in a post on Ruby Inside every month or two, syndicated to RubyFlow, syndicated to Rails Inside, and tweeted out to Ruby Inside's 5000+ Twitter followers. I have to keep putting the price up because I only want a certain number of ads per month (so that the job ads really work for people, as they have been) and sales have been brisk and employers seem to care more about getting good hires through wide audience reach than the price :-)
We're weighing the options for a free, ad-supported version like Sparrow Lite. I'll definitely post back here when there's more news.
This actually sounds looks really good. I'm new to ruby but I was kinda expecting to be able to type :website = secure and the rest would be magic.
authlogic is fine for Rails 2.x, but [Devise](https://github.com/plataformatec/devise) is now recommended as the "default" authentication gem in Rails 3. Devise does use Warden though, which I recommend you build off of. I don't know if it is possible to use Devise in a Rack/Sinatra app though.
Yeah warden is looking really good. 
 begin require 'psych' rescue LoadError warn "#{caller[0]}:" warn "It seems your ruby installation is missing psych (for YAML output)." warn "To eliminate this warning, please install libyaml and reinstall your ruby." end
[OmniAuth](https://github.com/intridea/omniauth) is quite good and easy to use with Sinatra. There is also another gem called Omnisocial I could have sworn to have used with Sinatra but it seems it's a Rails engine now. As for Sinatra being a webserver: Sinatra is a framework application built to handle your application, you typically host it with something like [Unicorn](http://unicorn.bogomips.org/index.html) (which I stronly recommend) or [Mongrel2](http://mongrel2.org/home) behind some sort of webserver. I usually use [nginx](http://nginx.org/) or I just have unicorn running directly behind [Varnish](http://varnish-cache.org) which is a superfast caching frontend. It's always good to think about caching anyway! Sorry to drop so many different names at you, I have no experience with Warden but that looks good as well. As for SSL you will need certificates and Unicorn/nginx/varnish should support ssl without problems (would probably need some configuration). Let me know if you want any help or need me to explain more ! :D
There's also Sorcery https://github.com/NoamB/sorcery which supports Sinatra. You might want to check out the tutorials in the wiki to see if it suits your needs.
No names are awesome. It powers my google-fu. I'm not entirely clear why I need these additional engines. With sinatra alone I'm able to access my app via a web browser. Isn't that all I need? Are these other things (frameworks, systems, modules, ???) just needed to scale up the amount of traffic I can handle? 
I heard about sorcery somewhere, I wasn't sure what it did though. Thanks I'll check it out.
Man, lots of great comments here! (And thanks for adding them to Get Satisfaction too. That site's kinda evil, but it does its job pretty well). Good questions too :) **Did you try to build this app using cocoa/something else before writing it in MacRuby?** Nope! We chose MacRuby to make the project more accessible to team members who weren't experienced with Cocoa, and to allow some shared knowledge/code with our Ruby web projects. It seemed mature enough at the time to give it a go, and we've been really happy with the results. **What did you like and dislike about building your app using MacRuby?** If you've ever had any experience with Cocoa development, you know that it is, almost to a fault, an extremely verbose language. Ruby is actually very similar structurally as a message-passing language. As it turns out, mapping an Objective-C object onto a Ruby object feels pretty comfortable. Ruby even gains some of Objective-C's syntactic sugar, like named method parameters. String concatenation is a great example. This MacRuby code x = "String 1" + "String 2" is equivalent to the following in Cocoa NSString *x = [@"String 1" stringByAppendingString:@"String 2"]; Seriously. Ruby's great syntax and style work great on top of Objective-C, making the Cocoa API even more pleasing to use. I can't count he number of times I've tried to think about something in Objective-C and then realize I could just use a stdlib function in Ruby, or include a gem to solve a problem. It's really wonderful. That said, we are using some 3rd-party Objective-C libraries that proved to be the best solution: * [JAListView](http://cocoacontrols.com/platforms/mac-os-x/controls/jalistview) for the room list * [BWToolKit](http://brandonwalkin.com/bwtoolkit/) for various interface elements, though we're abstracting away from a lot of those now * [ASIHTTPRequest](http://allseeing-i.com/ASIHTTPRequest/) for almost all network activity, because Mac OS X's network stack is infinitely superior to Ruby's. MacRuby also has some rough spots in debugging and deploying. I get *the worst* stack traces back for crash logs; especially when race conditions are involved. This is in development though, and the nightlies are currently about a month ahead of the shipping version, so I'm looking forward to a big framework update soon. Deploying is equally painful at times, though it's also getting better. 'macruby_deploy' is the command line utility to embed the framework in your binary, but there's also Xcode build actions. It was a fight initially to have the Mac App Store accept that I was giving it a valid binary. There also continue to be occasional bugs: passing blocks to Cocoa library functions was broken for a while, strings sometimes are returned as immutable even though they claim to be Ruby strings (backed by NSString instead of NSMutableString though), and various other issues. Nothing game breaking - just inconvenient once in a while. **How long did it take to make?** It's hard to actually say, as it started as a fun experiment and has matured into a real project. But I can give a rough estimate. We built the core app in about a week and a half over the Christmas/New Years holiday (attempting to get it into the App Store for launch day - what folly). That said - it was a pretty rough app back then. Dig this screenshot: http://www.cl.ly/15342O2m130C03120C2I (sorry for the Yo Dawg in there). Lesson learned - don't rush design :) A bunch of work picked up right around then and it got back-burnered for about a month, and now we're going strong on features again. All in all, our time tracker says we've put in roughly ~275 hours between the two of us and the designers. **If you've developed Rails apps, how does building a thick client compare?** You know, that's really difficult to put in perspective for me. I've done Mac and iOS dev before in Cocoa, so I had the advantage of having those structural patterns already in my head. The big difference was relearning to embrace the event loop. In Rails, there is very little work that is done as a background task that delivers a result to the user later (though that could just be specific to my last few Rails projects). When working constantly with a remote API, however, even 100ms responses are too long to lock the interface with it waits for a response on the main thread, and everything had to be refactored into a call-and-response pattern after "alpha". That's pretty basic event-driven programming stuff though. I think that was probably the biggest paradigm shift when switching from web apps. **What's your favourite music for hackin'?** Best question ;) [brettbender](http://reddit.com/user/brettbender) will probably have to jump in with his list too, but I've got some favorites. We work mostly at standing desks now, so I am all about anything that gets me dancing during the day. Upbeat, electronic, bouncy. Lots of Phoenix, Crystal Castles, Minitel Rose and Daft Punk/Justice for me. I've also got a huge crush on French electronic labels - Kitsuné Maison's compilations are a "Best Of" hot European music that makes me happy (and Ever Better - some weird CD I can't even figure out how to buy now). And of course, I gotta have some hometown flavor like Rebirth Brass Band and Dr John.
This is all well and good, but Ryan has a history of obsessing over "code cleanliness" to the point of absurdity. This is clearly coming at the expense of consumers of the rubygems API, who must now rework their code because Ryan got a bug up his ass about "the way things ought to be done" without providing any real tangible benefit that I can see other than "he likes it that way". I'm still trying to figure out why Matz allowed minitest in core. Frankly I think the guy should have his commit privileges revoked. When you combine his terrible management of the project with his abrasive personality, it's clear to me that the project needs to be forked and taken over by someone (or some company) with a better temperament and the wisdom to realize that this is one of the most important projects in the Ruby ecosystem that cannot be altered willy nilly without significant consequences. In short, we're way past "effective communication" at this point. It's time for new leadership.
I got caught up in the questions, but lemme hit some feedback too. Search is def coming in the next version, which is shaping up to be pretty sizable. Sorting/hiding rooms should come soon as well - it has been shockingly inconvenient to do that with the class we're using, but that's no excuse. I really, really want to add multiple mappings for changing rooms. I bound the Apple "default" for switching tabs, but it doesn't fit the paradigm at all. The best way to accept multiple key commands for the same menu item? Subclass NSApplication. I basically avoided it because it seemed like such a hack, but it's time to bite the bullet there. There's a lot of calls for custom styles, so font control is probably wrapped up in that when we figure out an appropriate solution.
Ooh, music. I suppose I should name the big ones I've been coding to recently: MSTRKRFT, Lil Wayne, Daft Punk, Uyama Hiroto. Dominic did a nice job of answering your other questions though :)
Note that he doesn't [use bcrypt](http://codahale.com/how-to-safely-store-a-password/) (for whatever reasons). It's easy to adapt his example to [use bcrypt](http://codahale.com/how-to-safely-store-a-password/) though. As of [Rails 3.1](http://bcardarella.com/post/4668842452/exploring-rails-3-1-activemodel-securepassword) support for security with bcrypt is built-in.
Starting sinatra with something like 'ruby application.rb' will most likely use the standard webrick server. It can handle something like 5 requests per day (a bit more :p). For serving something in a production environment (more than just you using it) it's generally recommended to at least use a application server (like unicorn or mongrel or thin). In front of that it's very common to have a web server to serve out any static files you may have as well as redirect/pass/proxy requests to the ruby application server for your application (this also allows you to have more than one application per server because you can redirect incoming traffic on port 80 based on hostname and so on). With something like Varnish (which is a cache server) it's common to either put that in front of the web server again (like nginx, lighttpd or apache) to cache content. Cached content can be served out much much quicker without the application ever being hit. That is good for things like articles, images, movies and every other kind of static content you can think of. Note that things with session cookies (such as a admin panel and so on) is not cached by Varnish, and due to a bug in how Rack handles sessions there is always a cookie at the moment making some trouble. Anyway depending on how many people are going to be visiting the website I would recommend going with minimum nginx+unicorn to host your application, caching is also important. If it's a internal application with like 10 users caching is less important but I like to cache things anyway :) There are some great videos on youtube explaining (and showing) how Varnish can help improve performance of things. I don't know how much you know about web technologies and caching but the basic principle is like this: Client #1 requests a document from your server hitting the varnish cache server first Client #1 GET /articles/1 Varnish checks if the document is in its cache and if it's not it fetches the document from the backend server (which could be a webserver or the application server(s)). Varnish serves the document to the client and the client displays it Then Client #2 requests the same document Client #2 GET /articles/1 Varnish checks if the document exists in its cache. It does. Varnish serves the document to the client and everybody is happy. The backend servers are never hit at all, until the max-age of the document cache expires and varnish will fetch the document again the next time its requested. This enables tons and tons of clients to visit the website being served the same content without the application having to query databases and execute any code at all, it's just grabbed from memory and served out to visitors. :) I sort of feel I rambled on about Varnish here so feel free to ask anything I forgot or missed or didn't explain. I'm also on IRC if you want to talk. 
Aww, I missed it. Does the App Store not allow for trial versions?
Coming from Rails here, just wanted to add a few things. Omniauth is built on top of Faraday, which is built to handle SSL connections. You have to point the SSL certificate to the right place on your system, but there's wiki's on both github pages for that. ([omniauth](https://github.com/intridea/omniauth/wiki/Setting-up-SSL-certificate-locations-in-Linux), [faraday](https://github.com/technoweenie/faraday/wiki/Setting-up-SSL-certificates)). If you decide to go with Omniauth, there's no need to read the Faraday wiki for setting up SSL as they cover the same thing. Make sure you use some kind of SSL for your AJAX transfers and monitor it with some outside program, like the Firebug plugin for Firefox (visually examine the outgoing/incoming XML requests and see if you can decipher them).
If you haven't already gotten too far in development, allow me to highly recommend Padrino: http://www.padrinorb.com. I think it's a great middle ground between the simplicity of Sinatra (which it runs on top of) and the complicatedness of Rails. It features a built-in authentication system that's super-easy to use. Just style the views under the sessions/ folder as you want, and then anytime you want to see if someone has access you can base it on current_account.role. It also features a really easy system for defining what roles have access to what pages to begin with. Even if you're already well into development, consider giving it a look, since in theory any Sinatra code is valid Padrino code as well.
In order to offer a trial version, we would have to ship a completely separate binary with features removed / limited - currently we aren't offering another version of the software.
I'm not far at all, very much still researching and learning. Thanks, I'll check that out. Edit: wait a minute... are you from microsoft?
Wow, ok thanks. ATM I don't know a whole lot about web technologies. This is just meant to be an internal app used by some of our sales people to access current data. Originally my bosses plan was to build a Lotus Notes database that the sales people would need to fire up on their laptops. I've been reading a lot about Ruby on some of the Blogs I frequent and lurking /r/ruby for awhile. I managed to convince my Boss that I could use Ruby to develop a webapp that the sales people could access on their phones (they all received iPhones earlier). I remember someone linking [this](http://devver.wordpress.com/2008/11/25/building-a-iphone-web-app-in-under-50-lines-with-sinatra-and-iui/) tutorial in /r/ruby once and with that I managed to get an awesome working prototype in a few days. That got me the budget to develop the app and now I'm trying to workout out the details for a security concept which I need to submit for review.
&gt; The main concern is how can I securely transfer data between the client and the sinatra app without someone in the middle sniffing the data? The answer to this question is TLS/SSL. This is an orthogonal concern to authentication and you should be careful not to confuse them. &gt; And how can I ensure that only authorized users are able to pull data from the sinatra server? This seems to contradict your other point about not needing to maintain state. Are you keeping track of users somewhere (e.g. database)? If not, how do you authenticate them? If yes, then what you need is an implementation of some kind of session. This does not have to involve cookies; you could use an auth token on the page for example.
authlogic was recently updated to support rails 3 and still works great.
I would use the [Shield](http://github.com/cyx/shield) gem — the most general-purpose, lean-coded auth library I know yet. Can work with any ORM, and even outside Sinatra.
Haha, no. I've been using this handle since long before their offering existed. I do occasionally get that question now, though.
&gt; This is an orthogonal concern to authentication and you should be careful not to confuse them. Ok. I'll have to google TLS but someone else gave me some links regarding SSL. &gt; This seems to contradict your other point about not needing to maintain state. What I meant is that at the moment if someone goes to site.com they get the default index page with a link to site.com/secretstuff where all the secret stuff is. But people could obviously just visit site.com/secretstuff directly but they shouldn't be able to see anything (at the moment they do). I guess this is session stuff though, sorry I'm just getting started with the terminology.
Ah ok. So far I haven't used rails. For no particular reason other than the first tutorial I worked through used sinatra and that seems to work really well.
Ok thanks. That's a new one but more reading the better.
Ouch, that must have been rough when you found out. It's like watching the news and finding out that the sadistic rapist the police have been hunting all year has the same name as you.
Even if 100% of what you said was true, this isn't the wild west. We can't just take Ryan and Eric out back and shoot them, and tell everyone that there is a new sherrif in town. No matter *what* change happens, it does no good to make decisions in anger. Please give me the benefit of the doubt as I try to at least get some dispassionate information out there for people. I am not trying to *fix* anything, I'm just trying to clearly document what people find wrong on both sides of the fence so that people can be a bit more rational about this and a lot less dramatic.
Devise! It's easy to setup, it's very organized, and is flexible to change. I don't start a project without it! Jose Valim is one of the maintainers, so that's another plus, imo.
5 requests a day! Wow, that's being generous :P
Sorry about that, mate. Fixed.
I didn't want to overdo it but the point is that webrick is by no means suited for anything besides testing when you develop.
Depending on the size of your company and what kind of data you will be presenting you can probably get away without using varnish then (I still use it for my application that has like 300 visitors a month because I like to play with things like that). It's also possible to cache things with something called memcached when using nginx, but I have never used that. A normal setup with nginx and unicorn will work fine for a small webapp for phones. Do you need to use a database?
Cool, I didn't know that. Will have to try that out some time.
I can understand preferring to learn / use technologies that can scale up. (too bad the reddit admins never thought of that amirite? ;) I need to pull data via ldap which I then store in a sqlite3 db. The ldap only needs to be refreshed some time in the middle of the night.
Great, that's a new one. I'll check it out, thanks!
That's quicker than I was expecting an update. Good to know progress is happening, and thanks for keeping your head on your shoulders throughout this process Greg. The ideas posted in the comments there about slower releases of rubygems (potentially syncing releases with ruby versions), and a centrally updated blog/feed for news about releases sound quite positive. The issues around compatibility of third party tools, and other libraries that interact closely with rubygems sound like they'll be a lot tougher to work out, so good luck with those.
This looks really awesome. I especially like the embedded bit. http://wiki.neo4j.org/content/Getting_Started_With_Ruby 
Then caching might not be that vital, but it's still nice to have. When you know exactly how many people will be using the website you can anticipate better, but for a public website you could possibly end up being slashdotted or reddited and suddenly have loads of traffic. Caching is nice then :)
Yes, release management is important and urgent. Interoperability is as important (if not more), but is a sticky topic and will take more research on my part before I even know what to rally for. But it's high up on my list. Thanks for the encouraging words.
Yeah I can see that's a totally different level. Although learning those techniques are still good I think.
I'm not that experienced myself but I find that if I plan and execute my application on a small scale in a way that could easily scale up to a ton of visitors then I'm doing a good job. I think last time I performance checked one of my little web applications it survived something like 8-900 requests per second, and it could probably have gone higher but I didn't have enough clients to test with :)
I agree. My app will never have anything close to that kind of traffic but as a developer I see value in developing that way. Especially if there is no cost other than not-being-lazy.
MY GOD, WHAT HAS HE DONE?
Yeah, isn't RubyForge dead yet? Since RubyGems is part of core Ruby now, I'd expect to find its bug tracking on the main Ruby RedMine system.
It's a hybrid project, both part of Ruby and developed independently. But that's an interesting point, I'll bring it up when I cycle back to bug trackers.
I've gone cross-eyed thinking of what's going to happen here :) What's the difference between mapping a C lib to Ruby through Ruby's C API and doing this? This just seems like madness, although I gotta admit, this is pretty impressive for what it is... 
Well, this allows you to define bindings to C libraries using plain Ruby. The FFI code seems to wrap all the nasty VM-handling stuff up in a nice set of classes that your interfaces can inherit from.
AFAIK ffi has the advantage of being compatible with other ruby implementations such as jruby and rubinius. 
Exactly. There isn't much of a performance hit from doing this either.
This book helped me tremendously.
I thought that was the case, but I wasn't sure so I didn't mention it. I can see how it would work in rubinius, being that it's written in c++, but how would it link with c libraries on jruby?
The title is somewhat misleading, it's actually about how the HAML parser works.
You seem to keep having troubles with making links. This looks like the right URL: http://rubyrogues.com/databases-sql-nosql/
and here is said tempo library http://tx81z.blogspot.com/2011/05/topaz-midi-syncable-tempo-in-ruby.html
What do I do with that link? It's just sitting there all blue.
If you stare at it real hard for long enough it goes red.
Nice. I used to do fresh configure make make install when installing new debian / ubuntu. How about REE?
Java has JNI (http://en.wikipedia.org/wiki/Java_Native_Interface)
Not sure how this article is any better than the official routing guide http://guides.rubyonrails.org/routing.html
This is messed up. You can get this screencast at http://teachmetocode.com/screencasts/many-to-many-associations-in-ruby-on-rails-a-teach-me-to-code-tutorial/
Sounds promising :D. I think, gem2deb is the right way to go solving the general rubygems vs apt issue. Thanks, Lucas
Ruby already has a perfectly good gem manager (`bundler` + `rvm`). It seems like it would behoove the community to use that combination instead of reinventing the wheel.
Once again, good work. :)
much appreciated!
Yes, bundler + rvm FTW, but the package manager needs to be a part of the process too; unless you want to run a slackware-style system you're just asking to enter dependency hell. I'd love it if the debian team handled ruby / rvm the way they handled making java or kernel packages. On the other hand, bootstrapping rvm requires a ruby binary already. What's worked best for me is letting the package manager have the system's default ruby (1.8, "boooo"), and running rvm + bundler as my local user. I pretty much do the same thing with perl / cpan and python / easy_install. I find a separate user is the best way to get the system's package manager and the platform's module manager to play nicely together. And it's far more portable / maintainable.
I still do this out of habit.
This is awesome. He listened! Pity it'll be a while before it hits testing, but I look forward to trying it out.
Bootstrapping `rvm` doesn't require a binary, does it? The script's in `bash`. I think the only dependencies are `curl` and `git`.
Hm, I hope I didn't misspeak - it's been a while since I had to set this up. I remember curl and git, but I thought it also depended on a ruby already being installed for some part. In any case, having the system ruby installed at least tells the package manager that there is **a** ruby on the system, even if that's not the ruby getting hit by the user's PATH.
http://www.metacafe.com/watch/6455357/ruby_on_rails_routing_rails_coach_podcast/
Exactly. Except the other way around.
Bundler + rvm does not handle system dependencies like all the -dev packages you need to install your database driver or rmagick.
&gt; $loaded a global var? is there no better way?
 class A class B def B.hello B.new.speak end def speak puts "Hello" end end end A::B.hello =&gt; "Hello" class B def hello puts "WHAT UP" end end =&gt; nil class A class B def hello puts "Hello" end def B.speak B.new.hello end end end =&gt; nil A::B.speak Hello =&gt; nil I believe you're a victim of scope gates and name lookups by using the nested module-style name in your last class.
Since it's how ruby has apparently been loading files for a while, using the existing variable and structures while netting a significant performance improvement seems like a much better way for the immediate future.
Someone deserves an efficiency award. Hypothetically: 300,000 developers * 5 restarts a day = 1,500,000 restarts 1,500,000 * 5 seconds reduction / 60 / 60 = 2,083 man hours saved per day. 
5 restarts? What about cucumber/spec runs? More like 20-30 loads of the environment per hour!
I was trying to be very conservative, but you have a point...
When you step back, the idea that a web application needs to load *2,200* source files seems a little bit absurd.
Oh come on... nobody can run cucumber 20 times an hour! :P
Rails 3 and especially ActiveSupport 3 were refactored into many small files because people criticized ActiveSupport for being one big monolithic chunk of code that has to be imported entirely even when people don't use everything. Now you can manually pick only the parts that you actually want. In return the number of files have explosively grown. You can't have it both ways.
I can sure as hell try to with this patch ;P
This seems to be broken when requiring files with extra periods in the name (try include thinking-sphinx in your gemfile). I'm trying to figure out the exact cause, but its my first time in the source for ruby itself.
cucumber is the reason why cucumber is slow.
'scope gate' is SUCH a gay term, dont use it.
*Groan*
Maybe it is a stupid question, (I am new at ruby) Is it not possible to have two versions of the "filesystem" onbe for development with those "trillion" of files. And one for production where files are put together in two three or whatever big files?
Check out Ruby Quiz (google it) but most importantly check out http://puzzlenode.com Great puzzles ~~by some of the best Ruby developers out there~~. Oh, and if you solve a few you can sign up for their free school.
RMU is retarded, a repository of mediocre programmers with the only half decent project by that entire crew being 'prawn'. I would not call them 'the best ruby developers out there'. Gregory Brown is good, that's true, everyone else is just average. I recommend [Ruby Koans](http://rubykoans.com/) instead. 
I suppose it is theoretically possible, although with some caveats. active_support/all can be an autogenerated concatenation of all files. The downside is that if someone requires active_support/something_else then Ruby will load something_else because the filename is different, thus resulting in stuff being loaded twice which may or may not cause problems.
Haven't seen this before! I tried pythonchallenge.com just now and I was able to solve the first few puzzles via Ruby. I can give my solutions if you like. Edit: spoke too soon... the pickle one is python-specific. A lot aren't though :)
...** *points to the sidebar* **
@badsex: What have you contributed to the Ruby community? If you are talking about our student projects, 100% of them were originally built out in 3 weeks while the students also focused on four other projects at the same time. Context is important!
@mikbe: It's probably a stretch to call our alumni the 'best Ruby developers out there', though they're certainly headed in that direction and will be in time. But the puzzles are indeed a good place to start. That said, PuzzleNode is still very much in its infancy. It will improve in time.
quite surprised that you aren't banned yet =\
You might enjoy the [Ruby Warrior](https://github.com/ryanb/ruby-warrior). It's "a game designed to teach the Ruby language and artificial intelligence in a fun, interactive way."
I like the [Ruby Koans](https://github.com/renemendoza/ruby_koans) and encourage using autotest to run them. 
Oh, I thought the puzzles were by the founders of RMU. My bad. Still some really good puzzles and I hope to see more of them. It actually got me to try writing some puzzles of my own.
Ruby Koans is really good too, good link. FYI: You don't have to build something up by tearing something else down. Two things can be good without diminishing each other.
It's also confusing to have bug reporting on the RubyGems site and Ruby Forge. Which one do they want used? I would think the newer one on the Ruby Gems site but the Ruby Forge one seems to be the most active.
I wrote two of them and vetted all of them, but a nice thing about writing puzzles is that it's something you can do even if you aren't an expert in something.
The rubygems.org bug reporting is for bugs against Gemcutter, not RubyGems. I think some clarification is needed there, though. 
I was wondering how the Koans weren't the top answer for this -- especially for someone looking to start learning Ruby.
this is fantastic :)
If a problem comes along, you must whip it. With Ruby. Ruby's not the best language for everything, of course, but if you have a little task that needs done, tackle it in Ruby. Reading syntax books, as you've noticed, will only get you so far. 
does this allow editing/modifying the code too? or just displaying it?