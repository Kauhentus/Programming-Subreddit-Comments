This smacks too much of unseen and unexpected side effects to me. Sure to bite you in the ass one day.
&gt;What gem would you like to see that doesn't already exist? &gt; &gt; there doesn't seem to be anything here This makes me immensely happy.
Yes me too even though I was hoping to find a gem to work on. 
A well designed REST interface that would work on top of any SQL database; with the associated awesome.js client. 
I'd like to see more actively maintained gems. I hate it when I see something cool that doesn't work anymore.
Any in particular that you have in mind? Github link appreciated. 
Unmaintained gems are generally due to lack of interest by users. It may also mean that better alternative gems actually exist. Do you have specific examples?
The one that checks your Gemfile and polls rubygems to find out if new versions of gems are available: just like bundle update, but instead of updating gems, just list what's new, possibly with a link to the github page
I feel like there is a non destruction flag for bundle. I'll have to check :-)
This is why I created r/ruby_proposals. However, it doesn't get ANY love, so oh well.
A gem that tells any of my bosses/clients that writing a facebook app for $10 is not feasible ;x Or just a general gem to tell a client that he's been fired and just sets up a small Sinatra app with links to people I hate so he/she can contact *them* ;)
I'd like to see a gem that provides a simple API for multiple shipping carriers (UPS, USPS, FedEX, etc). active_shipping has some of this functionality, but it has limited carrier support, doesn't seem to be too active on accepting pull requests to merge in more carrier support, and is much more focused on providing prices, tracking packages seems to be a low priority.
bundle --help bundle outdated(1) Show all of the outdated gems in the current bundle Alternatively: https://github.com/scoop/bundle_outdated edit: bundler outdated doesn't seem to work for me. Filed a bug: https://github.com/carlhuda/bundler/issues/1401
A gem that can tell me newer, better alternatives for older gems I might be using. It's too easy to get setup with a gem to do something that did what I need and never research it again, only to find out later about a cool new gem that does the same thing and more, and is maintained!
not a gem, but as a service http://rubytracker.com/ (never tried it)
Completely agreed. Once upon a time, I've played with the idea of writing a blog post to ask people to **always** write a "Related Work" section to their README. This way, the inference of "related gem" graphs could be automated so as to help developers to explore alternatives and replace deprecated gems.
REE is mostly useful right now if you want to use passenger, because of the automatic tweaks. Otherwise, 1.9.2 is absolutely the way to go. Rails 3.1 is fully 1.9.2-compatible, Rails 4 will REQUIRE 1.9 (or, maybe, 2.0, since it's supposed to come out at Christmas*), and hopefully Passenger will play nice with 1.9.2 soon. Certainly, it'd be nice to be able to do the same tweaks in 1.9.2 as are possible in REE. I don't know enough to say what is and isn't possible in that area. * Of whatever year
Yeah, I've toyed with similar. I think if the gem spec had a formal way to define other gems that it was: -commonly used with -built as a replacement/alternative for -suggested you use instead since that gem was no longer actively developed rubygems.org, and/or bundler, could build a heck of a graph based on these relationships and help you to upgrade and modernize your gemfile. I guess I should suck it up, write the code, blog about it, and hope it takes off, eh?
A good rails plugin for flot would be pretty sweet. [edit - flotilla is not bad but too basic]
He said that at the last Rubyconf - there is a team working on embedded Ruby, for appliances and such, too. Ah, the future of Ruby. I so look forward to it.
I like this idea, but am unsure of how to find the alternatives and rank them. Supposing that you could find alternatives I guess activity, followers, etc. could be used as a ranking of sorts. 
See my post above, if a given gem spec said "I was built to supersede this" or "I'm superseded by this" it'd be easy to build a graph of these relationships.
Yes. you should. However, I'm not sure that using the gem spec for the "related meta-information" is the best idea (rubygems is already under high pressure; adding new features there is probably not the easiest way). 
Yes, this would be easy todo if the gem spec provided this information. 
I think that if you announce loudly that the graph is extracted from links found from README, people will probably tune it to have their gem correctly indexed. Github API could be used for the ranking.
This makes more sense to me than putting it in the gem spec.
Not a gem, but may do the job of suggesting more active gems (popularity based on # of github watchers &amp; forks): http://ruby-toolbox.com/
Yep, very sound source of meta-information, especially for categories and ranking (I only wish devs could add their projects themselves). Any idea if an API is available for querying the project database there?
A capistrano replacement
Yep. Until all of the REE options are available on 1.9.X, I gotta stick with 1.8.7.
I think putting in the gem spec would lead to great structure, which should include the quality of the graph of gems.
Out of curiosity, why do you "gotta" ? I haven't run performance benchmarks with Rails as far as REE or 1.9.2, and I honestly wouldn't really know how to do a proper complete test, but I really wonder how much worse 1.9.2 could possibly be. Mind you -- if you have done some tweaking of your own, then all bets are off :)
Have you checked out vlad the deployer? I'm firmly affixed to cap, but vlad has about the most awesome name ever.
I'd love to see something that streamlined the process of filtered or narrowed results the way newegg and tons of other retailers do it. [See here](http://www.newegg.com/Store/SubCategory.aspx?SubCategory=22&amp;name=AMD-Motherboards) The links on the left that have price ranges, mfgr, socket type, etc... are what I'm talking about. Let me know if you end up trying this and I may give you a hand.
Memory usage. REE support copy-on-write and 1.9.X doesn't. 1.9.X might be faster than REE but it doesn't matter in the long run if I can't squeeze more concurrent requests out of my app.
I'm mucking around in the network at a pretty low level - ARP, ICMP and such. There doesn't seem to be any decent gems that allow me to craft packets in a easy way. In particular, given an IP address, I'd love a library that allows me to get the MAC address currently associated with that IP. (aka, an ARP library.)
The frustrating thing about 1.9.2 is the ridiculous performance hit with a long load path. 1.9.3 addresses this issue semi-adequately, but ruby-debug doesn't work with 1.9.3 at the moment. I'm using 1.9.2 in production. It's great for that, but the boot times positively blow for development.
1) An Urban::Dictionary API is probably going to remain relatively small. Also you can add Bundler at a later date, _when you actually need it_. Avoid prematurely optimizing your project by adopting dogmatic development practices. 2) Approximate version requirements: `gem 'foo', '~&gt; 1.2'` 3) Bundler is for developers, not end-users. I currently use [ore-tasks](http://github.com/ruby-ore/ore-tasks) (which I'm refactoring into [project-tasks](http://github.com/postmodern/project-tasks)) which provides an `install:deps` rake task. Downsides: 1) It's still another Gem developers still have to install, much like Jeweler or Hoe. 2) Constantly pulling the Spec Index from rubygems.org. 3) Bloats up `$GEM_HOME/cache/bundler/` with Git repository checkouts. 4) Having a `Gemfile` with only `gemspec` in it. 5) `bundle exec` 6) Was never designed for small libraries. Bundler was originally designed for managing the dependencies of medium / large Ruby apps. 7) Non-configurable / non-extendable project generator. Bundler is great for large projects, that often need to use edge-versions from Git repositories. Bundler is not a hammer.
I'm working on [something](http://github.com/postmodern/rack-mapper) like that.
Jruby seems like a good bet these days. Having said that I am hoping rubinious gains more adoption. So much work went into it and I would hate to see it wither.
[deployml](http://github.com/postmodern/deployml#readme)?
It would be great if somebody modified typus to work with jqgrid. It would be great if there was a grid gem like wice grid that didn't want to query the database itself and just let you hand over a "recordset". Apotomo needs wider adoption and more contributors. I kind of wish rails adopted that instead of the asset pipeline. 
* More [FFI](http://github.com/ffi/ffi#readme) bindings. * More Math / Statistics / AI related Gems. * More [Ripl](https://github.com/cldwalker/ripl#readme) plugins. * More Gems with +90% [YARD](http://yardoc.org/) documentation coverage.
There is [PacketFu](http://github.com/todb/packetfu#readme). I almost completed [FFI bindings](http://github.com/sophsec/ffi-libnet) to `libnet` for packet crafting. What would be cool is if there was a Packet Dissector using `FFI::Struct` or [rstruct](https://github.com/emonti/rstruct#readme).
Oh, of course. Duh. Forget I asked :)
My point of view on this involves careful design. What is public is your API. The API is what gets tested. Anything private is behavior that should not be user-facing (and the "user" could be a website, a program, whatever). If it is private, its behavior could change, its name could change, it could disappear. The part where it can get a little strange is that private methods are "helper" methods, and shouldn't you be testing those? My current thought is that if you have a complex private method, then you probably have some object trying to get out, and it's time to take a look at your design.
They are in 1.9.3, 37s is using it in production already.
A Flickr gem that doesn't suck all types of balls would be a very good start. The current state of Flickr gems is appalling.
I use vlad for all of my deployments (6 apps, 3 of them multi-server). It's just simpler and easier to extend.
Can you expand on the "suck all types of balls" part? What exactly is the problem with them? This one interests me because I use flickr a lot and it could be a useful project. 
Huh? Mendicant University is completely free.
have you tried the latest 1.9.3dev? supposedly it has a better tuning story and some of the ree improvements are rolled in
Any good reason to switch from 1.9.1 to 1.9.2? I have a pretty hairy program that does a lot of unicode string stuff, will I see any improvements with 1.9.2 in terms of speed or memory maybe? Just asking in case someone has been there and can save me a few hours of poking around.
I've found Flickr gems to be either outdated, not maintained, badly-designed or sometimes not even working as advertised on the GitHub page (copy and paste of an example and using my credentials that didn't work). Flickraw, the most popular library has all its code in one big file too, kind of scary.
Yep, unfortunately ORM is not what I had in mind. A real, relational-minded (not ORM-minded), REST interface on top of any **legacy** SQL database. That said, nice to hear about your project: I'll watch it.
A mind-reading gem would be very helpful. It would read the customer's mind and automatically implement whatever they want. Call it: jedi_mind_trick.
It's amazing, I was just reading this blog post this morning: http://www.cs.uni.edu/~wallingf/blog/archives/monthly/2011-09.html#e2011-09-08T20_19_25.htm. That would be my (non-)answer to your question: when it comes to development, I've mostly learned what I know from failures.
This looks like the same content as his RubyConf 2010 keynote. This year's is in three weeks, so we'll get to see if there's been any updates. 
Don't study just Ruby. Study compiled languages, study functional languages, study assembly. Study design patterns and algorithms. Most importantly though is to write lots and lots of code. Write procedural code as well as OO, write an application that follows the concepts of the MVC framework without actually using a specific MVC framework. And don't, don't for fuck's sake ever think you now just *get it*, there is always room for improvement. 
Reading the source code of some well known gems is great, but only gets you half way there. My approach has been to write one version, toss it and rewrite it based on what I've learned. It's all about experience and learning from your mistakes.
I Found Steven F. Lott's book to be helpful. http://homepage.mac.com/s_lott/books/oodesign.html#book-oodesign 
One thing they don't teach in OO programming courses (at least, they didn't 15 years ago when I took my C++ class) is the [Single Responsibility Principle](http://en.wikipedia.org/wiki/Single_responsibility_principle). It holds true not only for classes, but can be extrapolated to methods, files and modules as well. Keeping this in mind as you write code really helps with your design.
It's a bit outdated (though not too much), but check out my Ruby Best Practices book. It's free http://rubybestpractices.com I've also posted over 20 articles from my Practicing Ruby newsletter to my blog, which cover some of the topics you're looking to learn. http://blog.rubybestpractices.com
One good thing about DataMapper is that it works great with [legacy schemas](http://datamapper.org/docs/legacy.html). Maybe with [veritas](https://github.com/dkubb/veritas) I could go deeper.
Uncle bob's "Clean Code" and :Agile Software Development" are great books to level up. Or watch his videos on cleancoders.com.
http://destroyallsoftware.com has been very helpful for me.
build big things and watch them fail. you learn the most from your failures.
Books on refactoring can be very helpful. They not only give you a good idea of how to structure things; they show you how to transform existing programs to become that. Good program design is not so much about coming up with the "grand design" for your system at the outset, but rather refactoring as you go, so your code is both manageable and readable.
Agreed. Remember that each new language you learn will change how you think about programming.
1. Keep reading code. 2. Keep writing code. 3. Learn a lot of programming languages 4. GOTO 1
I've nothing to contribute, but I'd just like to say, thanks for introducing me to Pry! It's just what I didn't know I needed :)
&gt; and hopefully Passenger will play nice with 1.9.2 soon What do you mean? Phusion Passenger has been 1.9 compatible for 2 years now. We were one of the first to introduce 1.9 compatibility. Phusion Passenger 3.0.8 specifically fixed a 1.9.3-related file descriptor problem.
&gt; Most importantly though is to write lots and lots of code. I think this is the most important part of learning how to program in general. Most of the advanced concepts you won't pick up until you have a problem that can be solved by them. 
I've learned a lot by refactoring rather than rewriting. Once your individual parts are pretty refactor-proof, you know your design is reasonable.
Then, learn structured programming ;-)
but you've explored much less designs
&gt; Otherwise, 1.9.2 is absolutely the way to go. Unless you [need to run RedMine](http://www.redmine.org/projects/redmine/wiki/RedmineInstall), sadly.
I never learned that in CS courses....
helpers are the worst part of Rails, easily get out of hand on a large project, make complicated gem/engines designed to inject functionality into your app a mess. These are some good ideas. I agree with the complaints about typical "method_missing" use -- at the very least, if you over-ride method_missing, you need to remember to over-ride respond_to? too to match. But there are some additional tools for delegation that work much better in ruby and rails. Pure ruby, stdlib even, the delegate library: http://ruby-doc.org/stdlib/libdoc/delegate/rdoc/index.html Or if you're in rails anyway, even easier and more flexible, rails adds a handy #delegate method: http://www.simonecarletti.com/blog/2009/12/inside-ruby-on-rails-delegate/
If you go find the book "Design Patterns" it is pretty much exactly what you are looking for. It deals mainly with the communication between objects. It markets itself as a collection of techniques that the authors feel most coders will eventually, after lots of work, figure out on their own. There are a few ruby specific books on the topic but learning the more general theory is sure to pay off in the long run. The book does not teach larger program architecture but I have yet to find one book that is as helpful on that subject. The best way to learn about architecture though is definitely coding, like you are already doing. Also learning to identify and understand what techniques other people are using, e.g. if they are using a framework find out which one and why.
A gem for managing an enterprise Google Search Appliance. Unfortunately... I had to start that one today since one doesn't exist. 
frankly I don't see too much problems with as_hash or as_json methods on models. if I want more of a decorator than that I just build a partial. but yea I don't like helpers all that much, rarely use them and end up regretting when I do use them. 
I concur on this. My co-worker and I both subscribe and I've enjoyed seeing how I can improve my workflow and development process. Gary Bernhardt is wicked fast and I usually have to watch a screencast more than once. For $9/mo it's a great deal.
Do you know anyone willing to do pair programming with you?
Note that the cleverly set up gems to do simple things didn't start out cleverly set up; they probably started simple, then slowly were refactored into a smarter design as they accommodated more features.
i, too, concur. My co-worker and I both subscribe as well.
Dang it. I've nowhere left to go. I'm not upvoting this.
But also write lots and lots of code while also figuring out how to write *less* code.
Another thing along this line is to write one version of something which someone else has written. Then, go and see what they did, evaluate their code compared to yours. I think you'll find that their decisions make a lot more sense in light of your enhanced understanding of the domain.
I'm an apprentice at 8th Light, and these two books were the first two assigned to me as part of the curriculum. I got a lot out of both of them.
spell check.
I'll recommend the [RSpec Book](http://www.amazon.com/RSpec-Book-Behaviour-Development-Cucumber/dp/1934356379/ref=sr_1_1?ie=UTF8&amp;qid=1315616542&amp;sr=8-1). The reason is that it is a fantastic introduction to BDD (which is the biggest reason I love [Cucumber](http://cukes.info/)). And the real point isn't even BDD, it's a technique that BDD formalizes: Starting with interface, not implementation. That general idea has dramatically changed how I program, both in terms of being able to complete difficult problems, and in terms of having elegant APIs. I do it all the way down until there is nothing left to abstract. I call methods that don't exist, then when I go to write them, they in turn call methods that don't exist, and so forth, until the implementation is obvious. I found that patterns and APIs emerged without much effort. Of course, I am very familiar with the basics of the language, so I was able to focus very intently on the process without being sidetracked by the syntax or magic. Anyway, since that's had such a profound impact (the paradigm behind BDD, not the RSpec Book in and of itself -- you don't even *need* these tools, they just make it easier to apply), I figure it's worth recommending.
I like implementing SimpleDegelator subclasses (from the Ruby standard library) for my decorator classes. A SimpleDelegator subclass takes an object as an initializer / constructor argument: `my_presenter = UserPresenter.new(current_user)` Any method `my_presenter` does not understand is forwarded to `current_user`.
Cells gem anybody?
If you do decide to pick up "Design Patterns", focus on the part that describes *when* you should use them. Using them because you think you have to use them will just create more problems. 
You'll learn the fundamentals of CS if you major in CS. You won't necessarily learn good program architecture or design. The worst programs I've seen so far have come from CS students. Trailing fairly closely behind that is code that came from professors. A CS degree doesn't seem to be a great indicator of programming ability, in my experience, with good and shitty programmers coming from both the formal and self-taught camps. The problem with CS programs (or at least the one I graduated from) is that you never do anything of any real scale. Architecture doesn't really matter much if you're writing something that's around 100 lines. You probably won't have to maintain it, either, so writing shitty code never bites you that badly in class. When you have to spend several years maintaining the same code base, suddenly architecture shifts to a higher priority. The best advice I can give you, which echoes the opinions of several other commenters, is to write code. Lots of it. Rewrite code. Refactor code. Release something and get people to use it so you're forced to maintain it. Don't just write small applications. The bigger it is, the more obvious poor architecture becomes. Think about some gems and libraries you've used. Pick out some good ones and some not so good ones. What made one good and the other bad? There's absolutely no substitute for experience. There's no book you can read or video you can watch that will show you how to make the right decisions most of the time [1]. So write code, learn from your mistakes, and repeat. In 10 years, you might be halfway decent at it. [1]: That isn't to say writing books or watching videos or reading blogs or talking with other programmers or whatever other way you'd like to get advice on how to design and architecture your applications or libraries isn't helpful. It certainly can be, but a big problem, especially for someone who doesn't have enough experience to understand the *why* behind various design patterns or architecture styles is that you won't know when to use what. That, again, comes from experience. 
You can teach yourself software design if you alternate between getting something working, and cleaning up your code (refactoring). You should have 2 goals while refactoring: removing redundancies, and making your code testable. A majority of software design can be learned by continuously pursuing these 2 goals in your own work. Removing redundancies leads to generalization and abstraction of various kinds. Testability forces your software to have 2 software clients (prod and test)*, and forces you to decouple your software from its dependencies (increasing modularity). While software design can only be learned through experience, reading can definitely accelerate this process... For software design, I think the best place to start on this subject is Martin Fowler's 1999 book "Refactoring". After that you can choose your own adventure, based upon your interests and language choice. However you could do worse than following up with "Design Patterns" and "Refactoring to Patterns". If you want to write professional clean code, I recommend Bob Martin's "Clean Code". While at least 85% of software design is language independent, you do want to learn how to use your language well. I've always like the cookbook format for this, so for Ruby I would suggest perusing the "Ruby Cookbook". In case it is useful, here is the more of my reading list (organized by company function, and ranked by how strongly I would recommend it to someone on my team): https://docs.google.com/spreadsheet/pub?hl=en_US&amp;hl=en_US&amp;key=0AlDn9mOeBVjndGNFaHpxMm9MZjNKcWE5TGZabkVUbFE&amp;output=html *Note: Often all that matters is 0, 1 and infinity, so going from 1 to 2 clients is often hard, while going from 2 to 10 clients is often much easier. 
Not quite sure why you'd want to, but you could do this: last_ran_at = 0 loop do run_time = Time.now if run_time - last_ran_at &gt;= 300 ... do your stuff ... last_ran_at = run_time end end Is there some reason that you can't just use sleep?
http://eventmachine.rubyforge.org/EventMachine/PeriodicTimer.html
Honestly I'm just screwing around with an Irc bot. Having it just stop and hang doing nothing seems wrong. I at some point through you could use a worker thread or something for it but thats overly complex for something I've never worked with before.
You can use the "whenever" gem, which will let you do this: every 5.minutes do puts "something" end More details at https://github.com/javan/whenever 
If you haven't already, check out [Cinch](https://github.com/cinchrb/cinch). It's has support for Timers.
Whenever is for managing cron jobs, so it is not applicable for this use case.
I Just nuked my vim install and re-set it up, and I forgot to turn spellcheck back on. :/
TIL ... Nice! Let's amend the previous statemen to, "hopefully we can do the proper memory customizations in 1.9 soon.. Or at least 2.0".
Read some [principles of OOD](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod).
Isn't what he wants almost exactly like a cron job (periodic work done)? Just internally in his script. I'd like to know why you think it's not applicable in this use case.
Doing nothing while it's doing nothing is actually the right thing to do. Otherwise you are just wasting power (compare CPU usage of a constantly checking loop against using sleep).
The wherever gem is just a ruby layer for unix crontab management. I assume he is trying to output some information regarding the state of the loop every 5 minutes or so. A cronjob would not have that information, nor would it have access to the $stdout of the script.
Ah, I see what the script is doing now. Thanks for the info :)
Well as of right now it does nothing else. I was going to add more functions to it later on.
Oh I was going to, but I really want to work more so on this myself as much as possible. Since I'm not terribly good at ruby or programming in general wanted it for the experience.
I actually have a bunch of AI related ruby laying around, and I'm taking another AI course soon so I'll likely accumulate more. I was thinking of gemifying some of it. The thing is making it generic/better than AI4R..
I still think you should sleep as much as possible. Especially with something like an IRC bot where you really don't need to be checking conditions 14 million times per second (just tested this with a simple loop).
Ah, ok. IRC bots are great for that. I think Cinch uses a separate thread for it. There's probably a gem that'll make your life easier though :)
I might do something like this, depending on the requirements. You do have to worry about thread safety if you do any memory access in there, though. #!/usr/bin/env ruby def every( time ) Thread.new { loop do sleep(time) yield end } end class Numeric def seconds self end def minutes self * 60 end def hours self * 60 * 60 end end # These will hang around until the process exits every( 5.seconds ) { puts "It's been 5 seconds." } every( 2.minutes ) { puts "It's been 2 minutes." } # Do some other processing so it stays alive sleep(1000) 
I wouldn't recommend learning 'pru' instead of the classic tools, as you'll never find pru installed on a unix server anywhere, you'll have to install it yourself, meaning installing ruby first, which can be a big problem on enterprise servers.
that' what i dislike in ruby community: it seems they always reinvent the wheel 'cause they have only ONE dogma. and in a way they disvalue the unix under their bottom.
Terrible idea. The examples are really counter-intuitive and often longer than their unix equivalent. ps -ef | grep foo | grep -v grep ps -ef | pru 'include?("foo") and not include?("pru")' Second, sed, awk, et. al are useful on their own. You can't beat the convenience of awk. cat /var/log/nginx/access_log |awk '$9 ~ 404' It is more useful to learn the "regular" ruby equivalent instead of an obscure script. See: ls -al | pru 'gsub(/5/,"five")' ls -al | ruby -pe 'gsub(/5/, "five")' Or the line count example: ls -al | pru --reduce 'size' ls -al | ruby -ne 'END {puts $.}' You can't count on rubygems being present either, but short of windows sed, awk and friends is.
just tell the truth. + point to github profile if you have something to show
GitHub profile all the way. Any good Ruby shop will care more about what you can deliver than what you've done before. Prove to them you can deliver and you'll be golden.
I actually like the idea, if the goal is just to make my work done faster. If you don't like the idea of making things easier and quicker then why would you use languages like Python or Ruby, when there is already C. But to be honest, I found examples a bit confusing at the moments. Still, this have a potential, and I am very interested where it will go...
pru is targeted at people that know ruby and do not want to learn x new languages of their own just to be able to collect/format data. If you know/like all those tools pru sure seems redundant. But if you do not know them or do not like them pru can be a simple way to do things that would normally require a new script file / irb session. It shines when: - examples get more complex - you do not know the alternative sed/awk/xxx syntax - you do not want to learn how each regex flavor is different in tiny ways / needs to be escaped a bit different ruby -pe can do a lot of stuff pru can do, but pru adds many helpers that get handy when crunching data like group_by / sort_by / grouped / mean / aility to reduce and many more 
pru tries to bring the unix way (piping stuff around) to rubyists, if you mastered sed/awk/... then this may be unnecessary, but if you are a poor fella that only knows his ruby, it can make your life easier
Good luck with your attitude.
i've been quite rude, i know, and I appreciate ruby comm. in many ways; but two more examples: 'whenever' instead of learning 'cron' syntax 'god' instead of for ex. upstart
Now, we can talk. I don't know.., 'god' sounds so much better than f.i. upstart. Enough of jokes, those gems for better or for worse, try to make things just a little bit simpler. This doesn't mean they don't value unix tools. It's your choice. And honestly, you didn't mention rake, another wheel reinvention. Would you really like to use make instead of rake in all your projects? I don't see anything bad in that kind "inventions", you just got more variety of wheels to chose from, which supposed to be a good thing.
Great job, kudos for that. But, there are a lot of reason why this is not a good idea - ruby is slow, for instance. Also, if you look at the examples you've written yourself, they are less concise than the grep equivalent. 
Whoa, I've had to do something involving x12 a while ago and this would have been a godsend. Thanks for writing it.
&gt;'whenever' instead of learning 'cron' syntax You can use cron syntax in whenever if you want. &gt;'god' instead of for ex. upstart God came before upstart. Upstart is not used by all linux distros. God works on Macs. 
It would still take too long for them.
 Thread.new do while true p "Do whatever you want here" sleep(300) end end Not sure if that's what you want though.
most of the examples are longer then the original, since making specialized stuff in a general-purpose language will mostly be longer then in a specialized tool. Pru is not about stuff like "grep foo | grep -v grep", but about e.g. listing all your repos sorted by watches on github ... `ls | pru '[self, `curl --silent "https://github.com/grosser/#{self}"`.match(/&lt;li class="watchers.*?(\d+)\s*&lt;\/a/m)[1].to_i] rescue nil' 'sort_by(&amp;:last).reverse.map{|n,i| "#{n} =&gt; #{i}" }'` its kind of messy, but readable and I wrote it in 3min tops and I have no idea how to do this with awk/sed/grep/xxx :&gt;
Giles Bowkett has a resume package for sale, that has gotten me an interview at any job I applied for. But it's a simple formula, skills first, then jobs and accomplishments, then examples. I put my Github profile, in my header along with my email.
Honestly, if you want to do something as complex as that, you're better off writing a full-fledged script and then execute it (ruby script.rb). It makes no sense to do something as complex as this with a one liner, with either grep or ruby.
Honestly I can't tell the difference in terms of speed.
What does this give over "ruby -n -e 'some expression'"? 
Try with something heavy, like grepping for "te" on the complete contents of your hard drive.
I've said this before, and I'll keep saying it: When writing documentation, use real examples. Real examples may take more time for us readers to understand, but they'll actually help us use the tool, and, more importantly, show how valuable the tool is.
It's a good point. Non-Windows programmers simply have to learn the common Unix commandline tools as part of their job. pru is well-intentioned, but I think it will actually hurt those who use it. Like it or not, we need to know how to use grep and sed.
Fun fact, ruby regex matching is orders of magnitude slower than sed/awk/grep. [The proof is kind of depressing.](http://swtch.com/~rsc/regexp/regexp1.html)
Just admit that you made this for fun and learning and be done with it. It really can't beat sed/awk/grep in any fashion.
oh hoorary let's generalize
The book [Programming Ruby 1.9](http://pragprog.com/book/ruby3/programming-ruby-1-9) introduced me to RVM and I have been using it ever since. Extremely useful and an all around awesome piece of CLI software to use when working with Ruby.
I know of this and rbenv. Pros/cons of using either?
I've always used this order. I think it makes much more sense for programming and web dev jobs. I have a very high applications to interviews jobs ratio, like 4/5, so I recommend it.
I never submitted a resume for my job, but I gave a link to my github and to my website, which is basically a portfolio of my work. All the serious job inquiries I've had did not ask for a resume.
Inline perl (perl -pe "s/\w//" etc) often does what sed won't (easily), but I still use sed. Awk never suited me as it seems to fill exactly the same niche as perl, and grep /egrep will remain go-to tools for parsing logs.
For tips on what to include in your resume, subscribe to a Github job search for "Rails", and see what some cool workplaces are asking for.
[My resume](http://www.planb-security.net/todb/resume.html) is awesome because it's all about me. :) Much more security than Ruby, but I try to stick to one page and lots of links to the public stuff I've done. 
I really doubt that pru will perform in the same order of magnitude in either speed or memory use when compared with sed/awk/find/grep. Some of us are old enough to have learned sed/awk/find/grep in during the Reagan administration. And we got into arguments about sed/awk/find/grep versus **perl** in the Clinton years. This is old hat. 
I'm actually inclined to agree with grosser here. I don't need awk or sed often enough to remember all their syntax from memory, so using pru might work out to be faster for me than the classic awk/sed/grep combination. I'd need to try it out to be certain, however.
Numpy/scipy/scikits.learn in Gem form.
For a while it did look like most of the major distros were adopting it(although I doubt arch/gentoo/slackware would ever use it) but now a bunch of them are switching to systemd with ubuntu sticking with upstart for now(and I'm not sure about debian).
I also forgot to mention that you need to be root manage those types of systems.
The Debian guys are discussing systemd but it's made hard by the fact they now support FreeBSD. systemd only works with Linux and Poettering has said he has no intention of supporting anything else.
yeah, 'cause I do that everyday. Usually before breakfast, it helps me relax knowing which files contain te.
Having used grep/sed/awk/... for the last 15 years or so I actually think this is a nice idea. As a ruby developer and sysadm and I think there's a place for both. You have to remember that not everyone is going to master sed and awk. As incredibly powerful as they are the syntax is arcane (that's no necessarily a bad thing but if you don't use them regularly they can be hard to remember). So I suspect that this find a sweet spot with ruby devs. I for one will be adding to my toolkit.
I'd love to hear how a relational-minded REST interface would look like :)
In principle I agree with you, it is much easier to just use the passphrase as the key. However, if he leaves it as-is, the key verification against any future timing attack vulnerability discovered in AES. This is really a pedantic point though because if AES is good enough for government level encryption, it's good enough for us normal folks.
Rainbow tables are a type of brute force attack that exploit the speed of hashing algorithms and are irrelevant to this discussion because you've chosen bcrypt. The password file is only an attack vector if vulnerabilities are found in bcrypt or the library that you are using for bcrypt.
an output by default, a cleaner call, helper methods for data crunching, reducing, in-file-replacement ... have a look at the readme :)
man, the questions at the top just make me think "most C#/ASP.NET web developers don't know what the hell they're doing." But good on him for providing some education. 
This: http://iamdanryan.com/resume.pdf
Right, bundler is for developers, not end-users. The end-users have the gem spec with it's dependencies. But if any other developer wants to hack on your initially tiny gem, then IMO having bundler there to install dependencies is an aid to them; If the alternative is installing a _different_ gem they've likely never heard of (ore-tasks), then that's equal as far as 'another gem they have to install', but inferior as far as making them learn something new. It can be a matter of personal taste, I'm not saying it's wrong NOT to use Bundler, but it's certainly not obvious to me that it's wrong to use it on a very small project, including a very small gem project. And certainly if you expect no developers other than you to hack on the project, it doesn't much matter at all beyond your personal taste. But bundler won't bloat up anything with git repo checkouts unless you have a dependency pointed at a git repo. You don't even need git _installed_ to install gems from rubygems, with or without bundler. At most it'll bloat something up with an extra copy of the distro'd gem (not the git checkout), if you do a bundle package/vendor, but under default use I don't think it even does that. You can also simply not use bundle exec if you don't want -- if you can get by without bundler at all, you can also get by using bundler for core feature of dependency management but without 'bundle exec'. It's your choice. Likewise, you certainly don't need to use the bundler project generator to use bundler. You are providing critiques of some features of bundler that may be legitimate, but they're mostly all features that you can simply not use if you don't like them, so they don't seem to me to be downsides of using bundler for it's core dependency management features. If you want to hack on a project started by someone else with bundler, the ONLY part of bundler it would be inconvenient not to use is the basic 'bundle install'. But you're right there's no getting around the slowness of pulling the spec index on bundle install, that is, I agree, the worst thing about bundler. 
I'm really more of a devops guy, but I think [my resume](http://conigliaro.org/resume/) is pretty good. File -&gt; Print -&gt; Preview to see the de-HTML-ified paper version.
&gt; I request (but cannot enforce) my name/likeness NOT be used in promoting any websites/books/etc... I do NOT want recognition, so you can (and are encouraged to) hide/bury my name while respecting the GPL and take _all_ the credit for making it presentable to a non-mailing-list-reading audience. :P
What with the quotes and how did you arrive at using the qualifier "most"?
Not so unusual for me to grep my whole filesystem for .sql files. Just sayin'.
Direct link to mailing list: http://librelist.com/browser/usp.ruby/
those need to be read by "most" rails devs too, since "most" of them don't know that ruby and rails are not the same...
Sunspot/Solr and facets can do this. :)
A comprehensive collection of accurate, Rails 3 validators. Email, URLs, Address Info for different countries, Credit Card formats, etc. Would be nice too if they cleaned up the syntax a little too... Instead of `validates :email, :presence =&gt; true, :format =&gt; /email_regex/` `validates :name, :presence =&gt; true, :length =&gt; { :maximum =&gt; 30, :minimum =&gt; 2 }` Something more like... `validate(:email).required.email` `validate(:name).required.max(30).min(2)`
Very cool. I knew about solr, but hadn't heard of sunspot. Thanks.
My side project. Briefly hit #1 on HN!
Very nice, thanks for doing something that actually has social value and not just another bookmarking site or twitter clone. The health insurance space is ripe for innovation.
I have always used https://github.com/chneukirchen/styleguide/blob/master/RUBY-STYLE as my style guide.
Not only that, but you'll likely "learn" a lot of advanced concepts from reading and tinkering, but getting into the thick of it will really make you **learn** those concepts. Speaking from very limited experience.
`config/routes.rb` is the one and only place in a Rails app that determines which controller and action will get called for URL's. Before Rails 3, a default catch-all route was defined but now it's commented out in the initially generated `config/routes.rb` file: # This is a legacy wild controller route that's not recommended for RESTful applications. # Note: This route will make all actions in every controller accessible via GET requests. # match ':controller(/:action(/:id(.:format)))' The line `match ':controller(/:action(/:id(.:format)))'` will cause `/rails_intro/showPrimes` to call `RailsIntroController#showPrimes`. * [API docs for `ActionDispatch::Routing`](http://api.rubyonrails.org/classes/ActionDispatch/Routing.html) * [Rails Guides: _Rails Routing from the Outside In_](http://guides.rubyonrails.org/routing.html)
I dislike the general syntax of Ruby. I myself don't use parantheses whenever I can avoid it, only when the interpreter needs it. Never EVER use variable names such as `e`, `a`, etc. - Always use words that describe the property (and sometimes I find more suitable words to match up with the indentation level of tokens et. al.) Edit: Except for inline blocks, only there is it acceptable. IMHO.
 [1, 2, 3].each { |e| puts e } Nobody ever does it this way, it's always: [1, 2, 3].each{|e| puts e} or [1, 2, 3].each{|e| puts e } People tend to code reasonably well, it's only when you try to extract coding intuitions into strict rules you get crap like that. &gt; Avoid using Perl-style global variables(like $0-9, $`, ...) Protip: They are not global variables. Neither in Ruby nor in Perl.
&gt; Use &amp;&amp;/|| for boolean expressions, and/or for control flow. (Rule of thumb: If you have to use outer parentheses, you are using the wrong operators.) Can someone explain that a bit more?
Actually dkubb from datamapper (a very big project) advocates to space between curly braces. Quite a few people in the github community do in fact do this O_o
&lt;overreaction&gt;It's a horrible idea and he's a horrible human being for even suggesting it.&lt;/overreaction&gt;
 @value = options[:value] || 0.0 Parses to: @value = (options[:value] || 0.0) While: @value = options[:value] or raise("Die in fire") Parses to: unless @value = options[:value] raise("Die in fire") end Doing this is fairly ridiculous: @value = (options[:value] or 0.0)
Ah yer always did that, just never understood "control flow" thanks :)
Why has everybody gotta hate on monkey patching? That's one of the absolute best parts of ruby. For objects that I make which have to_s and to_i methods (think zip codes and ip addresses), I love having the ability to make the inverse. 
You should post this elsewhere. Ignore the technology -- the implications are much, much more wide reaching.
| Avoid return where not required. Actually, coming from Java to ruby-land, not using return has bitten me many times. Often when debugging a method I wrote months back, i might place a debug statement after the last line, which changes the return value. This would never be allowed had a put a return. e.g. def foo # some lines of code bar(x, y, z) end Months later I do: def foo # some lines of code x = bar(x, y, z) $log.debug "got #{x}" end Now the program mysteriously falters at some other place. return bar(x, y, z) makes it clear and helps me avoid such mistakes.
The risk with monkey patching is if a library you are using makes the same monkey patch, but in a slightly different way. Eg if you add a `to_json` method to String, then import a library that also adds `to_json` to `String` but implements it differently, strange things can happen. This doesn't matter so much if you do the monkey patch for an application you are writing (eg a rails app, ruby game). However it does become a problem if you do it in a library, as it is very hard to debug a problem where two libraries do the same monkey patch in different ways.
Why down on ternary?
&gt; Avoid needless metaprogramming Sure, and why don't I just shoot myself right in the balls while I'm at it?
The name is a bit unfortunate considering the login manager [SLiM](http://slim.berlios.de/). 
There is also a diet plan called 'Slim Fast' that has about as much relation to a ruby templating language as a Linux login manager.
I disagree with using logical operators for control flow, when we have trailing conditionals which do the same thing more semantically.
I've been toying with Slim for a hobby project. It's basically HTML without pointy brackets, which is actually really nice. I wouldn't say it's better than HAML but more an equal alternative - well worth a look if you haven't tried it yet.
looks like haml. Give us a quick pro and con vs haml.
I think it's time to combine /r/rails and /r/ruby. There is not enough traffic in either one to justify having two reddits.
i was referring to the title of his post: "Do you have to explicitly define routes in Ruby?" Ruby, the language, does not have "routes" I have no opinion on combining the reddits, in fact i think that most rails posts come here anyway, which i have no problem with really.
I prefer it, easier for my brain to parse I guess.
hrm, check this out, looks like a potentially awesome way to simplify logic in views. Is there anything like in haml? http://slim-lang.com/logic-less.html
Ahh, I guess that does make sense.
No haml doesn't have anything like that but then again I don't know if I like that. 
yeah, I haven't used it to know if I like it either, but it looks interesting, certainly a point of differentiation.
And that's why God invented Namespacing.
The Ruby community like code that is easily readable, and the argument is that the ternary operator isn't quickly readable. I personally disagree, but maybe I'm just better at logic ;)
lol isn't Object Oriented programming necessarily meta?
for c++, js, python &amp; obj-c, google has [their](http://code.google.com/p/google-styleguide/) has style guides 
Have you tried posting it to the LRUG mailing list? (http://lrug.org) - job ads are welcomed as long as they're not filled with recruiter-speak nonsense, and are not repeatedly spammed. Also, github jobs (http://jobs.github.com/), Stack overflow jobs (http://careers.stackoverflow.com/) and Rubynow (http://jobs.rubynow.com/) might be worth a punt, even though they're not London-specific. Good luck
Thank you very much. One of the current team just mentioned a couple of your suggestions in fact! 
The benchmarks claim it's faster to render than haml
I'm apparently very odd; I've always used spaces all over the place, in any language, because I find it much more readable: file = File.new( "test.txt", "w" ) test_array = [ "one", "two", "three" ] result = 4 + ( 3 / 4.to_f ) if ( is_okay and ( no_errors.true? )) Anyone else?
Looks like you just placed an advert in quite a good place. Don't know what the reddit rules on this are though.
Should there be a link with this?
Convention over configuration
Does anyone know why they don't recommend using "then" and "return"? I really like both and people rarely use them.
http://rubysource.com/rails-deep-dive-loccasions-authentication/
love twitter bootstrap!!
The rules are downvote if you don't like it :P
Just a bit of feedback on your spec file, the names should be more general and define what case they actually cover. For example: it "should return dates for 'April 11 to April 20, 2012'" do could be changed to: it "handles a range in the format '&lt;Month&gt; &lt;Day&gt; to &lt;Month&gt; &lt;Day&gt;, &lt;Year&gt;'" do I know it doesn't change the functionality of your tests, but it reads a bit better. I haven't actually used your gem yet, but it looks interesting, great work! **EDIT:** Formatting
That's a really good point, thank you. Pushed to github, will be included in the next release, thanks!
Whenever is really nice and even though I know Cron syntax, I prefer it for readability and codeability. Also, the real advantage of Whenever is making your scheduled jobs part of your code repo instead of having to manage a crontab file external to your repo.
This is for Ruby 1.8.4. It is my understanding that Ruby &gt;1.9 has some significant optimizations.
thanks...I am !smrt 
Suggestions? I'm all ears.
Me too - my design skills are really weak. It's a lifesaver. 
Is there, by chance, a rationale on using spaces instead of tabs? I personally can't *stand* when I have to modify source that used spaces, regardless of language
I like this. Some small feedback: Perhaps keep the value of `@start_date` and `@end_date` once they've been determined, so that successive calls to these methods don't need to process `@date_string` again. It will save a small amount of processing the second time a program refers to them (for example, in your example "Usage", `duration` would calculate that tiny bit quicker). def start_date # if @start_date has already been determined then simply return that value return @start_date if @start_date # we don't know @start_date yet, so # continue with the rest of your code ... end A minor tip - you don't need to explicitly use `return` at the end of a method, since any last expression evaluated will be the value returned. However, in the example above, there is an explicit `return` because that will cause the interpreter to return that value and ignore the rest of the code in the method.
The fact that you have have access to that pertinent information based on some simple information provided -- this should be a real resource for anyone who needs to get private healthcare in the US. I'm just saying that if this were to hit one of the popular subreddits, that it would get a lot more upvotes.
I'm trying to post it to /r/health but they keep flagging it as spam. Want to give it a shot? Other subreddit pointers would be appreciated. Mostly I lurk on the front page and /r/ruby.
Neat! Have you given any thought to just turning the parsed dates into a date range? start_date..end_date IMHO that seems like the most natural data structure to create from the string parsing.
There is always a risk when it comes to running code you don't know. You just have to decide if it's an acceptable risk. Regarding your method of installing gems, I'd highly recommend using rvm or similar.
I find the 80 char limit per line a little silly this days.
In general, Ruby developers are far too trusting.
Send a message to the moderators.
So how would you actually call that? Just have Datesplit.new return an instance of Range? I'm not entirely opposed to the idea but I'm also drawing a blank on other common classes that return an instance of something else when instantiated.
Thanks, this is great advice. I kind of knew in the back of my head that things weren't optimized as well as they could be, I think I'll implement that for 0.0.3 (scheduled release: tomorrow morning)
They flagged asked me to resubmit, this time with the GeekWire article instead of a direct link. Tried that too, same result. Now I'm discouraged. I think people would really like to see it in /r/health, but I can't seem to post it. Thanks for the suggestion, though.
Shameless plug, but you may be interested in EDTF (Extended Date/Time Format) which supports duration strings and more. We've started a Ruby implementation available as a gem ('edtf') or at: https://github.com/inukshuk/edtf-ruby It needs little bit of work still, so if you intend to develop the idea of datesplit further it would be great to join our efforts going forward!
'gem install foo' can run arbitrary code thanks to extconf.rb/Rakefile. But for that matter, 'apt-get install foo' can *also* run arbitrary code thanks to preinstall/postinstall scripts. I don't think there are package managers out there that can take away all the risks for you. If you don't trust it, read the code first.
You could add a class method to Datesplit so it could be used like this: Datesplit::to_range('September 9th-12th, 2012') return a date range. 
You don't know what the job is from here and where to apply? Just asking the very helpful Reddit Ruby community for some advice ;-)
to_hash I generally don't have a problem with. to_json I do, because it's dependent on a non-stdlib serialisation library. I don't especially *like* to_yaml either. I especially have a problem with, for instance, separate to_json_for_web_service and to_json_for_database methods, which I have seen in the wild. That's just *totally* wrongheaded.
&gt;to_hash I generally don't have a problem with. to_json I do, because it's dependent on a non-stdlib serialisation library. I don't especially like to_yaml either. Then write your own I guess. For example there is nothing preventing you from contructing a JSON or a YAML file inside of a view. &gt;That's just totally wrongheaded. Meh. I don't have too much of a problem with it. 
Not quite sure why you're being down voted for that, since it's really evident we are too trusting.
&gt; Then write your own I guess. That's not the point. The point is that, for example, my User object should present an API which is concerned *only* with the functionality required of a User. Not of a serialisation scheme. &gt; For example there is nothing preventing you from contructing a JSON or a YAML file inside of a view. That's pretty much the way I'd think about it, yes - a serialisation is a view of an object, not something the object itself is concerned with. &gt;&gt; That's just totally wrongheaded. &gt; Meh. I don't have too much of a problem with it. What has being a User got to do with knowing how to serialise oneself for a web service? Or a database? Why should a User class know these things exist *at all*?
&gt;Or a database? Why should a User class know these things exist at all? As I said I don't see a huge problem with it. Why shouldn't the user present a subset of it's attributes in a particular format? When you call User.adress_ids for example you are going to get an array. When you call User.addresses you get a collection. These are just formats not that different than JSON or Hash or whatever. 
I'd prefer making it an instance method: Datesplit.new('September 9th-12th, 2012').to_range It's more consistent with the interface. You could then define #each as def each(&amp;block) to_range.each(&amp;block) end Include Enumerable and BAM! You have enumerable date ranges from a text string.
This was the type of thing I was talking about. Datesplit can still be it's own data structure if you'd like, but it seems like the underlying data structure is just a date range. Another example would be def duration range.to_a.size end def start_date range.begin end def end_date range.end end and then initializing the object would just build the two dates and initialize them as a range instance variable.
I've updated the gem and incorporated a lot of the suggestions I got here, thanks everyone! Let me know if any of you get a chance to actually use it. I think this is going to be great for letting users create events that span multiple days, or for searching date-based records. I'm thinking if I can create a companion Javascript library that automatically tells a user if the string they're entering is readable or not it would be a lot faster than getting all clicky clicky on a calendar widget.
The problem is not inherent to Ruby developers or 'gem' for that matter. Any code or executable can potentially do malicious stuff, written in any language. So being too trusting is something that currently would extend to almost anyone using a computer. Who tells you that the OS, browser, games etc. that you install are operating the way you expect them to and don't do anything shady? Even if you download via TLS/SSL or the code gem (or jar or...) is signed by its author - the only thing this ensures is authenticity and integrity, but again - who tells you that the author didn't mean to do harm in the first place? It's all a matter of trust - signed code or executables narrow the trust decision down to the question of trusting the author(s) (granted the mechanism is implemented correctly and/or your code signing certificate-issuing CA does not happen to be DigiNotar...). If you download from unprotected sources (plain http for example) then it's a whole different story, unfortunately. You have no guarantee that what you just downloaded is what you actually expected to download. Most web sites also publish MD5, SHA-1 or SHA-2 family hashes as a form of cryptographically secure checksum. The problem with this is that without having used a secure transport channel (TLS/SSL) you could simply forge the site displaying the checksum, too, without you noticing. The other problem is: How many people really compare these checksums visually?! Personally, I would consider signed code/executables an improvement if you are concerned about code integrity/authenticity since on one hand it allows you to make a trust decision that you are able to do on your own ("Do I trust this guy/these few guys?") and additionally it makes forgery considerably harder. It's just that it should stay optional because improved security almost always leads to decreased usability, setting up your infrastructure in order to successfully validate code signatures may not be worth the trouble - it depends on how much risk you are willing to take.
You should probably inspect the `extconf.rb` file of new gems, as it executes arbitrary Ruby code _during_ installation. Also be cautious of gems containing RubyGems plugins, as they will be loaded every time you run `gem`. Installing the gems as an unprivileged user will give you some protection.
Do you mean a browser-app? if so, you should use a framework that supports multiple applications (I think Rails 3 does this now) which is made for exactly what you're asking, sub-applications. If Rails doesn't support it, I'd like to suggest [padrino](http://padrinorb.com/).
i don't understand the question completly...but..if you wanna create a site using ruby and adapt this to mobile phones the problem is not ruby..you need adapt the css and maybe use a usefull libraries for javascript...now...if you wanna create a mobile app using ruby...the best way I know is titanium (rhodes sounds good too but I'ven't tried it)...with titanium appceleratr you can create an app using html, javascript and ruby..actually you can comunicate ruby code and javascript code with a bridge..very sweet and I've used it and work perfect... 
no it's not.
The '|' is just a delimiter. You would use |var1, var1, ...|
I see, thanks!
If you write it multiline, books.values.each { |rate| ratings[rate] += 1 } ...imagine that the pipes form a chute, and rate is sliding down into the block. Least, I do. I don't recall if this is a _whyism or not.
The chute analogy is definitely a product of _why :)
As these things (database-driven queues), this seems like a decent implementation. The only 2 (easily fixable I'd bet) downsides that I see are: * I don't care for the way jobs are defined, the whole calling a method on a module thing is a little strange to me. Why not instantiate Job classes w/ the supplied data? * This comment is a little disturbing, but could be fixed w/ some kind of processing timeout: &gt; If the Ruby process died, then the job will remain in the queue with a stale lock 
So that stuff lines up for everyone, no matter what their tab width settings are. So that you can look at files using more and still see what's going on.
Why do people who write style guides always forget the most important part -- the rationale for each directive? e.g. &gt;Never use for, unless you know exactly why. This begs as many questions as it answers.
One advantage by calling methods on classes and modules is that you can quickly send jobs to workers without deploying code. The trivial example is calling destroy on a collection of active_record objects. (want to preserve active_record callbacks) QC.enqueue("Account.destroy", X) Regarding your second point: In practice, this happens infrequently. I suppose we could add a feature to clear stale locks, but that means writing more code and more moving parts. The cost is great. That being said, I am open to implementation discussion and pull requests.
It would be the same as writing it like so: books.values.each do |rate| ratings[rate] += 1 end Some of the array methods have two block parameters such as: books.values.each_with_index do |rate, index| ratings[rate] += 1 end In the second example, the first time through, index will be 0. The second time it will be 1, and so on... 
CTRL-F "chute". Was not disappointed. From _why's book indeed.
Why do you use "execute" why not create a new proc for every queue so the stored proc could be optimized by the database. Oh yea and clear stale locks. 
Biggest thing I missed when I moved from WebObjects to Rails. It violates the law of demeter in a huge way, but I love it anyway. 
Seems like an arbitrary list,
And here's an impl (two, in fact) of the same feature (sans the cleaner syntax) that works in any Ruby implementation: https://gist.github.com/1225596 I will grant that Rubinius does have a lovely API for transforming the AST. The same could be exposed in JRuby without a lot of work. Here's a ten-minute patch to JRuby that enables transformations of the various "call" nodes from Ruby code: https://gist.github.com/1225773 But is it useful to have AST and transformation logic that only works on one impl?
**T**hat's **W**hat **S**he **S**aid!
Been using this gem in our campfire bot for months now. It's pretty awesome.
I wasted my time reading this article. Don't waste yours. Author provides no examples to support very questionable views.
It would be good.
Genuine question. What difference would it make to ruby devs? I imagine it might be a selling point that can help enter the enterprise market or something, but can anyone elaborate?
It would make an official specification for the various VMs out there (JRuby, Rubinius, Gemstone, YARV) to adhere to. Any stable release can be labeld as 'ISO 5866' (or whatever the code will be) compliant.
Yeah, basically what skippy said. Previously, there was no official specification, so Rubinius actually spent a fair amount of time developing [RubySpec](http://rubyspec.org/) so that other languages would know if their versions were correct.
what you just typed makes no sense..........how can a LANGUAGE be a fanboy, bitch?
You're illiterate.
Every time I see this, I wonder "why?". RubySpec already works great. I'm afraid this move will result in the language mired in bureaucratic committee nonsense. 
Nice article.
Heh funny how much about Japan this is, I guess maybe the way the publication made it interesting to its readers or something. Many languages don't have an apparent nationality at all.
I'll be there. Looking forward to it.
I just discovered that [JIS:X3017 is actually available in English](http://www.webstore.jsa.or.jp/webstore/Com/FlowControl.jsp?lang=en&amp;bunsyoId=JIS+X+3017%3A2011&amp;dantaiCd=JIS&amp;status=1&amp;pageNo=0) from the Japanese Standards Association (JSA) web store. A bit pricey though so I didn't get a chance to take a look at it.
Great. I'll have my username on my name tag.. As usual :p
A few of us from ideeli are going --- and we're hiring. We're a big Ruby on Rails shop.
I know about ideeli. We consulted for you guys for a little bit (might still be consulting, actually - not quite up to speed on that project). Sorry - too happy with my current company to switch :)
Ah, namecalling. Thank you. Now it's a legitimate ruby discussion!
Does rack 1.2.1 appear anywhere in your Gemfile.lock?
no, but it the system "/usr/lib" version of rack. In Gemfile.lock there is actionpack which requires rack (~&gt; 1.3.2)
You have to install rack into your system's gems (outside of bundler)
[Daily TV Torrents](http://www.dailytvtorrents.org/) [API](http://api.dailytvtorrents.org/) [Blog: API announcement with examples](http://www.dailytvtorrents.org/blog/you-want-it-you-got-it-dailytvtorrents-now-has-an-api--d) 
lock it in Gemfile.lock 
1. I can't install *rack* in the system /usrl/bin because it's a shared hosting 2. I can't lock/force *rack* in Gemfile.lock because actionpack 3.1 requires rack (~&gt; 1.3.2)
Looks like you might want to have a look at maybe monads. (http://pretheory.wordpress.com/2008/02/14/the-maybe-monad-in-ruby/)
Sweet! There is *1.0/shows.search*, how about supporting that too? Users could get the *simple-name* of a show more easily. I've added your client to the API page.
Definitely. My plan is to implement the entire API, so I will be keeping a close eye on it as it evolves. I just started with a few things that I was most interested in, to save some keystrokes as I was using your service. Hopefully I can keep current with the pace at which you add features ! :D
as a developer, who's team is currently implementing 5010, you shall receive my upvote, along with my sincere thanks.
Absolutely. Hope Hippo helps. ^_^
Alarmist hyperbole
I'll admit, this is certainly a great thing to keep in mind if I ever delve into Facebook-centric apps. Sounds wonderfully simple.
Perhaps you meant, testing _Rails apps_ can be expensive?
I still don't believe it. The last Rails app I worked on served one billion requests per week across many data paths and its test suite (while slow by my standards at around one minute) was alarmingly fast compared to what I hear people at conferences say their slow test runtime is. There's no indication from the author about how slow their test suites are, but I imagine they're glacial by my standards and it seems they haven't even bothered to profile anything.
Phusion Passenger has supported Bundler for more than a year now. Your shared host is probably on some old version that didn't support Bundler. Tell them to upgrade Phusion Passenger. If they don't, consider switching.
This is really cool.
Time to start convincing some .NET shops to make the ruby switch
God I do not miss X.12. Nice work.
Agreed, nothing is magically "slow".
16$ ouch ... 
I'll be speaking.
I'm going to be running a series of posts on Ruby Inside going over portions of the material so you'll be able to enjoy that for free :-) I'm also going to be doing a 10 minute "summary" video which will be free too, so the info will be there - you'll just need to reassemble it and research for yourself (essentially that's what I've spent the last few weeks doing).
What happened to the sitting in a tree part?
that's not ruby
Yeah, the lucene API is rather ugly. Checkout out moonstone, it makes lucene ruby like, but it's an older version of lucene. https://github.com/automatthew/moonstone
Another Java/JRuby option might be using Solr on top of lucene, with the SolrJ java api. You could do this without actually running a solr service/process, just as a higher level api (and using whatever version of lucene/solr you wanted, assuming JRuby here for full java access). I haven't actually done anything with either lucene or SolrJ myself, so I'm not sure how much better SolrJ ends up than the lucene api. (I have done things with Solr as a running service with an http api, just not the SolrJ java api). 
Isn't solrj used for talking to a solar server? With lucene you can use it to tokenize a string or get the term frequency of a term. Can you do that with solrj? 
Thank you for the poor fans!
You http://i.imgur.com/3nHaB.jpg
There's a few ways to accomplish this that I've used in the past: * I've verified just the output, by sending in a stringio output and testing that its contents was the full required stanza. * I've used RSpec's ordering semantics ( https://github.com/rspec/rspec-core/blob/master/spec/rspec/core/configuration_options_spec.rb#L32 ) to verify methods were received in the right order. * I forewent testing the specific output entirely and verified that an abstraction like display#challenge or display#greeting was called. This variant may have arisen in a later refactoring, however.
I'm guessing you didn't read it. Funnily enough this slideshow debunks the "reasons" as to why ruby is bad. I bet you also though http://najafali.com/php-is-better-than-ruby.html was a serious article.
If ordering is important, write a case that tests the order. PS Look into before/after block semantics - they will make your world a better place. There's [a cheatsheet](http://cheat.errtheblog.com/s/rspec/), and there are [some more examples](https://github.com/tmikoss/rspec_examples) by yours truly.
This is integration testing, so the entire "story" should be in one place. If you want to unit test, then each specific element should be tested on its own with no dependence on order. As much as being a question about RSpec use, this is really an issue of program design.
SolrJ can be used to talk to a solr/lucene index even without an external Solr process running by using EmbeddedSolrServer Java class. Yes, pretty sure you can use it to tokenize a string or get the term frequency of a term, but I haven't actually used it myself so could be wrong. 
I read it and upvoted it actually.
Better than before/after blocks: use "let" statements. That way the code is lazy-loaded.
I am wondering why people down-voted the link. It's a bit old, but still very relevant. (I am a ruby developer btw).
It's a neat introduction to Ruby. Haters gonna hate, etc etc. I feel like this slideshow is past its time, but maybe I'm just too immersed in the Ruby community to realize what non-Rubyists think of Ruby.
Things I hated that caught my eye: * "Hello World" comparison with other languages - if you're going to compare, do it properly. * Everything's an object - even code blocks. Beep - false. Code blocks are not objects, but can be wrapped into objects by lambda or Proc. * Serve Servlets?!? Maybe JRuby...
Avdi is awesome. I have known this ever since he did the [Ruby Programming Challenge for Newbies #9](http://rubylearning.com/blog/2010/04/29/rpcfn-interactive-fiction-9/) *. It would have been earlier, but I didn't know of him before then. I love reading his code. ______________________ * Come to think of it, I should probably take another stab at solving that challenge now that I know more about Ruby!
I was hoping that this would be a legitimate discussion of Ruby's weaknesses, with perhaps suggestions on how to fix them. :-/
I know it's not what you want, but here's a better way of doing this: module Codebreaker describe Game do describe "#start" do let(:game) { Game.new(output) } let(:output) { double("output") } it "sends a welcome message" do output.should_receive(:puts).with("Welcome to Codebreaker!") game.start end … end end end Regarding your specific question, though, as dennyabraham mentioned, my preferred way of testing this is to use a "smarter" output stream. Something like: class MockIO attr :lines def initialize @lines = [] end def puts(*args) @lines.concat(args) end end And then you can just test that `output.lines.index("Welcome…") &lt; output.lines.index("Enter guess:")`.
Let me show you some of mine.
So... I presume you also think, let's say, the github app is dumb too then. Or maybe the LESS app. Or any GUI wrapper for a command line program? I don't care really. Thanks for showing me this anyway, I like it.
Whenever someone boasts about the language an application was written in in the very first paragraph, I have serious doubts about its potential usefulness. News flash, guys: We don't care that your project was written in "objective-c" (whatever that is). We just care about whether it makes our lives easier.
Hey, at least it's not Java.
Looks like a useful tool for some, while not impacting CLI users (even on the same machine).
This new version add the following evolutions : * Support for oauth authentication (the old method is not supported anymore) * FlickRawOptions method to pass options to the library is not supported anymore FlickRaw is a library to access [flickr api](http://www.flickr.com/services/api/) in a simple way * Small single file: flickraw.rb is less than 400 lines * Minimal dependencies * Complete support of flickr API using instrospection methods to stay up to date * Ruby syntax similar to the flickr api * Flickr authentication * Photo upload * Proxy support * Flickr URLs helpers Github page : http://github.com/hanklords/flickraw 
They've just picked up a bad habit from Apple marketing about masturbating over irrelevant points in their sales copy.
Exactly, I'm a Java Dev and used Rails for 2 of my side projects. And I think that there are heaps of stuff that Java can borrow from Ruby.
I will be testing this sir. Last time I did, a simple copy and paste from your GitHub page and a quick search and replace to stuff my credentials in there resulted in a big ball of fail. Also, I've been wanting to ask for a while now, why a single 400 lines file? To be more positive though: "Complete support of flickr API using introspection methods to stay up to date" &lt;-- THIS is absolutely awesome. EDIT: Just tried again, either I fucked up last time or you've fixed bugs but now it's all working fine and dandy. Good stuff.
&gt; Also, I've been wanting to ask for a while now, why a single 400 lines file? That is a fair question :) You have to note that the project is quite old : at the beginning of 2006, rails was quite new, rubygems were still controversial and not as polished as today, debian was screwing up gem fonctionality (I am told, it is still the case :) ). There was no bundler either. So the prospect of having a single file made deploying easier : just drop the file in your project and that's it. It stayed this way because I still find elegant to have a self-contained single file.
Why do you think it's dumb?
Funny, this is the dumbest post I've ever seen in r/ruby. 
I certainly got a little bit handwavy at the end. It's important to run specs between each thing just to make sure that you've moved things correctly. I loved it into a method, ran the tests, then stubbed out the method call.
Does it have methods like "largest" to help out using the data, or is it still just a very raw version of the API?
That actually looks pretty nifty. Thanks for showing it to me. Too bad that if you worded your title differently you would actually have some upvotes. I still don't understand why you think this is dumb.
Why not start it ? I agree with the documentation part. I still have only the ruby 1.8.6 documentation downloaded whereas I've been using 1.9 for ages. Maybe there's a downloadable doc for 1.9 now. (Ok, i stand corrected. They've finally released docs for 1.9.2!) One thing I remember that bit me badly coming from Java (in brief) was the mutable string. I had sort of expected a "copy on write". I was told to dup() the strings on returning it, which I think is expensive.
| Code blocks are not objects, but can be wrapped into objects by lambda or Proc Are you sure about that? If I pass a block to a method, that method can store the block for later execution.
It is still a raw version of the API. There is no helper beyound what Ruby itself or the API provides.
Objective-C is the language almost all proper OSX apps are written in. A lot of Mac users tend to care if the software is native or not, and it's not so uncommon to say it's written in Obj-C/Cocoa. It's just a way of saying "hey, we did it properly". I always love to see it, it means I most likely won't start it up and cringe at some disaster of a UI that doesn't fit in to OSX at all.
AFAIK, no. When you capture a block, it is converted into a Proc object. Thus, in `def(&amp;block)`, &amp;block will wrap the block into a Proc (i.e. `block.class` will evaluate to Proc). But block itself is not a Proc - blocks don't accept methods (you can't say something like `{ puts "test" }.repeat(3)`), and creating a Proc is much slower than creating a block (the difference being the time spent wrapping the block into a Proc object). [This blog post](http://blog.sidu.in/2007/11/ruby-blocks-gotchas.html) gives a good account of it - in particular try the benchmark test for yourself if not convinced (the code snippet under "The difference - implicit invocation is much faster").
How do you pronounce that?
haha, I seriously have no idea. I did look it up before posting though. It could be pronounced 'huff' or like 'yew'. I was hoping it was pronounced Hoge so that I could title the post "Houghan's Heroes" but alas it was not meant to be.
&gt; I loved it into a method, ran the tests… (This is the best typo I saw this month, period.)
I think I’m as lost as thefool808 – you did stub send\_to\_salmon\_endpoint out, but because you stubbed it out in *all* of the specs there isn’t any code that tests whether it still works; it looks like you could remove its body and the specs would still pass.
The Hough Transform isn't used for edge-detection though, it's used for line-detection. Generally you run a gradient-magnitude-filter on the image to pre-process it and then do a hough-transform on the resulting grayscale image for points above a certain threshold. If that is what you wanted (line-detection) try running an edge-detection filter on it beforehand, it'll give you better results! :3
I had actually dabbled with an implementation of the sobel algorith I found in ruby, I'll probably try what you suggest and see how it differs. Thanks for the input. ^_^
Sorry meant that last post to be a reply, thnx again. ***edit (also I updated the blog to reflect hough transform being for line detection not for edge detection and referenced you in the edit note.)
why you call it slide show? there is nothings to slide ... for promotion go on another site, pls.
The code in your blog has a small error - in `is_dark?`, there's a stray `a`. And a small stylistic thing - you've initialized `@angles` with `||=` which is uneccessary since it appears in `initialize()`, although comparing the blog code with the code on github, I imagine this is simply an artefact of copying and pasting that line into `initialize` where it used to be in `angles`. I like the way you hang on to the values of calculated angles! 
I removed the stray 'a' and credited you in the edit note. That was a really good catch I must have glossed over it when I was formatting. Having only ~600 px to put my code often leads to problems with formatting. Thanks for taking the time to actually look at the code. I had a blast working on it. I was thinking about possibly implementing a rotate function in chunkyPNG that lets you specify in degrees, but until I get the time ImageMagick will have to do. Anyways, thanks. ^_^
Heroku partnering with the evil facebook. Too bad.
Haha, derp.
&gt; Ruby's license changes from dual Ruby + GPLv2 to dual Ruby + 2-clause BSD Oh **hell** yeah. Death to those GPL hippies. 
I didn't realize that Ruby being GPLv2 was an issue with folks.
One of these days I'm going to have to familiarize myself with what the different open source licenses *actually* differ on
I'll be there. My company is one of the ampblock sponsors. It's going to be awesome. Good food and drinks, and some great music. The party's going on literally right outside of our office- I can see the street where it's going to be held from my desk. So when youre down there checking out how awesome New Orleans is, dont forget to check out iSeatz. We're hiring too.
The slideshow linked in the article shows only "?" characters. Anyone else have the same problem.
Ooh. I saw some of your preparatory stuff online. I look forward to it! 
Sweet. Thanks to your company for helping sponsor &amp;block, it looks like it'll be a very good time. I hope to run into you :)
denny, Thanks for the reply. However in the book the author has explicitly mentioned that: &gt; We could combine these tests into a single example, but we like to follow the guideline of "one expectation per example." I have also mentioned in my question that I am looking for ways other than combining the tests into one or using RSpec's ordering semantics as right now it would force combining the examples. In short I am looking for a way to achieve something like this (which doesn't exist yet): module Codebreaker describe Game do let(:output) { double('output') } let(:game) { Game.new(output) } describe "#start", { game.start } do it "sends a welcome message" do output.should_receive(:puts).with('Welcome to Codebreaker!').ordered end and it "prompts for the first guess" do output.should_receive(:puts).with('Enter guess:').ordered end end end end end This would run the two "it" clauses in turn without recreating the game and output each time. Had this been possible, I could have used the ordered method without combining the examples.
This sounds good, but only if there was a way to run the example that tests the ordering after the other two tests as: * First, I want to be sure that the messages are actually printed * Then, to ensure that the order is correct Otherwise the example for testing the ordering could fail due to an error in the start method other than the order of the printed messages.
Correct me if I am wrong, but this doesn't seem to be an integration testing as it's been already done using a Cucumber story. And as I have mentioned in my reply to deny's comment, the author explicitly states that: &gt; We could combine these tests into a single example, but we like to follow the guideline of "one expectation per example."
Thanks, I was just copying the example from the book here. Otherwise the author has then converted the example to use before and then let in the book. But as I've mentioned in my question I am looking for a way other than combining the tests into one.
Simplistic summary: - MIT license is (for the most part) "do whatever you like." - BSD is like MIT, except the license file must be available whenever it's redistributed. - GPL is like BSD, but derivative GPL projects must be GPL (free) as well, meaning it can't be used in proprietary projects. (There are lots more nuances, but that's the most important bullet point.)
Awesome, yeah of course I read your code. I love seeing how people have tackled a problem.
Well, the mocked IO object doesn't expect you to do a single test. let(:output) { MockIO.new } subject { Game.new(output) } it "first says welcome" do subject.start output.lines[0].should == "Welcome to Codebreaker!" end it "then asks for the user's guess" do subject.start output.lines[1].should == "Enter guess:" end
so, Red Hat Linux has no GPL components then?
Their videos don't work in Linux for some reason. 
No, Red Hat has plenty of GPL components, its just that all of the Red Hat branded stuff is under a different license. Hence, CentOS, which takes Red Hat Linux, removes all the Red Hat branded stuff (Logos, Names, etc.) and legally re-distributes it.
I guess the GPL on those components only loosely enforces "can't be used in proprietary projects"
All these licenses have to do with source code and redistribution. This means that if you were to e.g., modify some GPLd code, the result would also be GPLd. If all you do is make use of the compiled code, e.g., using redhat to host your company's website, none of this really comes into play... Also, please keep in mind that this (and previous explanations) are grossly simplified. There are a ton of nuances, especially with the GPL.
when's 1.9.3 coming out?
It seems like functional testing to me, closer to integration testing, but far from unit testing. Yet, it seems you want to structure it using a unit testing approach of doing it piece by piece. Ideally, you'd test the overall "flow" using an integration test, but then set up the "state" of the game each time for multiple tests in a unit testing environment. I'm guessing, though, that your game doesn't allow you to set the state in this way, but if you hit this problem when doing unit testing, it *can be* a sign that your objects are too opaque.
Yeah, but the *first* time I looked at it, it was fine. So I assumed it was a temporary fault. Weird! I'll have to look for another version..
...and it's these nuances that make the various GPLs so aggrivating. I shouldn't need to be a lawyer or the world's greatest detective in order to figure out if I can actually use public software.
That's not all sad... It's just nuanced. MRI has no plans to shed the GIL, but here are good options available (jruby and rubinius).
wow, octopress is awesome. It certainly makes jekyll setup much easier. Are there any other project that are similar?
Ah, you're right. I'm posting another followup soon...
That's the only one I know of at the moment. The idea I was posting about would attempt to make jekyll setup even easier, and allow for people like my mom to use it.
This comes from `ActiveModel::Validations`, which ActiveRecord::Base uses. On a high level, `validates` will look for a subclass of ActiveModel::EachValidator named after each validation key you provide, and instance it with the options hash you pass. Your example could be: validates_with :content, LengthValidator.new(maximum: 140) (I don't remember the exact method/class names, but it's along these lines). Each subclass of ActiveModel::Validator implements a `validate(record)` method, which is called in the validation chain when you call `record.valid?` (this goes through all the validators the model uses, and then calls validate on each of them.) What EachValidator does is implement `validate_each(record, attribute, value)` (I think) which calls `validate` internally. There's a couple good blog posts that explain how to define custom validators for Rails 3 apps, which explain this in good detail. Reading the source for ActiveModel's Validator and Validations will also help you better understand how this stuff works :)
Tell me about it dude... I shipped some boxed software with an LGPLd library about 10 years ago. It took months to get it signed off on, and that was after convincing executives that we weren't pirating the library in the first place. I stuck to my guns, but I did question whether or not I could have saved time just writing my own compression library :/
thanks
Your first sentence is a classic example of "begging the question.' As for your second sentence, you can bet the language used in a product is a lot more important to its programmers than its users. You don't usually have to start up an application to see if the UI's a disaster. That's what screenshots are for. But you have to know a hell of a lot more than whether it uses Cocoa to known whether it will be worth your time.
All it's doing is going into the object "for" you and doing comparisons of different length and regular expressions matches to see if they correspond to the requirements you set in your validates expression. Doing this manually would mean calling up all those objects and then writing Boolean comparisons and regular expressions to see if they match up, a process which can be tedious and get confusing easily. Rails does all of that "for you" in the background, and has a very user-friendly handler that does it in one line.
Well I know *what* it does, and *why*, I'm just asking *how* it does it. Which has been answered satisfactorily.
shared memory threading is overrated. It's not necessary for the majority of problems that many of us work on, and adding it often slows down singled threaded applications considerably (see python GIL history). It's very easy to use processes and something like redis to share data in a backend server environment. It's easy to use async IO for IO bound apps. If you really need threads then there is jruby which works great. 
Uh... sure. All I was trying to point out is, it's what OSX uses. Yeah, it matters more to programmers, but I know a good few non-programmers who still know what Cocoa is. So especially considering this is a tool for programmers using OSX, I find it understandable that they point it out. And yes, you can't instantly tell whether it's worth your time. I never said that. It's just a good sign usually.
I dispute the notion that using multiple processes and message passing is a bad/hard way to utilize multiple cores and that message passing through pipes is error-prone. If you look past the problem of multi-core, you enter the realm of distributed computing where you want to utilize multiple *computers*, not just multiple cores. And pretty much the only way to handle that is through message passing. If you rely only on shared state threading then you will eventually hit an upper limit. Furthermore, multi-process message passing concurrency is very common. Look at pretty much all network-enabled software. MySQL doesn't run in the same address space as Ruby, does it?
guys, guys, guys. https://github.com/imikimi/monotable/blob/master/lib/monotable/xbd.rb#L46-84 is daily WTF shit. I'm guessing you're probably better than that. Generate it at startup, generate it on the fly, whatever. Just don't cut and paste your way to a lookup table unless it's absolutely necessary.
What did Ruby really gain from Native threads over Green threads if there's a GIL? Just curious.
Would a catch/throw solution work here instead? Or do you simply have to ensure that you re-raise the exception whenever using Timeout? It does work as expected if you do that. :)
Easier to implement. Maintaining green threads is *a lot* of work if you want to do it right, especially if you want to make them play well with blocking system calls. By using native threads with GIL you outsource a large part of the problem to the OS. To give you a few examples: Curb, the Ruby binding for libcurl, used to block all Ruby 1.8 threads because curl_perform() blocks until the HTTP request is done. Curb eventually made it preempt nicely by poking into libcurl internal file descriptors through the use of the curl_multi interface; basically they wrote a lot of code to ensure that when curl_perform() is about to block on an I/O operation, it calls the Ruby 1.8 thread scheduler to context switch to another thread until the I/O operation is done. With Ruby 1.9, it is as easy as unlocking the GIL, call curl_perform(), and locking the GIL again when it's done. Saves *a ton* of code. Another example is ruby-zeromq. When waiting for I/O on a ZeroMQ socket, ruby-zeromq will block all Ruby 1.8 threads because the ZeroMQ library doesn't allow poking into its internal states, basically making it impossible for ruby-zeromq to write code to integrate with the Ruby 1.8 thread scheduler. In Ruby 1.9 it's as easy as unlocking the GIL, calling the ZeroMQ code, then locking the GIL again. As far as I know Erlang is the only language implementation that got it right. They put an insane amount of work into getting their green thread implementation work nicely with all the system calls while still being able to utilize multiple cores.
Given Ruby's problems with garbage collection and bloat from large numbers of objects, this kind of seems like a poor fit..
I have had issues with timeout as well. Hopefully they have fixed some of this stuff in 1.9.3 
it's not that bad a fit, but it has been done before and better: https://github.com/dturnbull/ruby-redis which is course is a ruby clone of the very fast, fairly mature, and extremely well-designed Redis in-memory NoSQL data store: http://redis.io which has a pretty solid ruby client library: https://github.com/ezmobius/redis-rb
This https://gist.github.com/1241315 should be a bit faster (using a hashmap)
Not seeing the point of this.
Awesome-o. We're bringing a few guys from isotope11. We're taking a train to NO (the code train). Anyway, looking forward to tracking you down and offering you a beer :) EDIT: Oh yeah, I'm @jadams
catch/throw would not work, since there is no way to inject a throw into another Thread. The upshot is that you rarely should rescue Exception because you're code never wants to handle things like NoMemoryError. A library never should rescue Exception for exactly these reasons.
sweet! Please do track me down. :)
your mom is already using it.
Very groovy. Going to try it with my kids. 
http://paddy3118.blogspot.com/2009/05/on-what-killed-smalltalk-could-kill.html
I've seen this video some time ago. I think it is important to add that smalltalk failed in an area where Java is just much better suited: Big teams of mostly non expert programmers. Java on the other hand is recently being replaced in areas where ruby/python are better suited: Small skilled teams developing and implementing ideas, fast. I can understand the urge to use ONE language for everything, but it's doomed. A hammer just isn't a good tool to cut a slice of cheese and a knife doesn't do well when hitting a nail. I think ruby has a place. It will only "die" in places where people started using it just because it's the only language they know well enough to work with.
I lived through he smalltalk years. Here is what killed smalltak. 1. Expensive as fuck. The average coder could not afford smalltalk and there were plenty of other options. 2. Weird environment that deviated from the normal paradigms people were used to. People were used to files, directories, editors, etc. 3. Deployment headaches. It had nothing to do with any of the things he talks about. You could not get into the game without spending big bucks so nobody did. Same goes for other worthy languages like Eiffel and Dylan. 
I don't think the second point is really true anymore in relation to Ruby. Ruby is used at a few large corporate entities, JP Morgan Chase and Oracle are two that come to mind. 
That's the mistake that open-source implementations "patched", especially with off-shoots like Ruby or, to a degree, Objective-C, but it still leaves them vulnerable to collapse because of the holier-than-thou, detached from reality phenomenon.
In my experience, every language has its holier-than-thou factions that loose track of reality/practicality in some way. There was a post about learning C last week where all the C and Fortran diehards came out of the woodwork. I personally really like seeing developers who feel strongly in favor of their language, whatever it may be. It means that we have languages that are well-suited to people's mental models of computation, which is how things should be.
There's nothing wrong with having opinions or defending your beliefs vigorously, but when you start solving problems that nobody else has you're kind of lost in space. C tends to be pretty pragmatic, it's a very basic tool, and PHP inherits from that. It's those languages that can meta their way from the problem into some abstract space that get into trouble, where Ruby's DSL fetish and Java's factory addiction are key examples. At some point you're not programming in Ruby any more but some meta language built on top of it, and not Java but something that produces things that make Java...somehow. 
What's the problem with a language that can mold itself to better deal with the problem at hand? I think it all boils down to how people think about programming, and language choice can vary from person to person and problem to problem. C sacrifices speed of development and code clarity for speed of execution, resident size, and the ability to better understand what the machine is doing with each instruction. Ruby and Java tend to go the other direction. Neither is right in all cases. It's a trade-off. We don't currently have a language that gives us all those things. Ruby can be every bit as pragmatic as C for a different set of problems. For instance, it's far easier to whip up a one-off Ruby program for many tasks than it would be to use a bash script. For web apps of moderate complexity, I don't think it's clear that PHP is a more pragmatic choice than Ruby (or Python for that matter).
In this case, by "pragmatism" I suppose I really mean "plain", as in you could hire any old PHP developer to maintain your PHP app and they'd get it as much as anyone else. You can have Ruby and Java apps that are such departures from the norm, meta'd up several levels, that knowing Ruby or Java doesn't really help you as it's programmed in something else. It's like how [Neal Stephenson](http://en.wikipedia.org/wiki/Neal_Stephenson) used to write books in English but tends to invent so many new words in his books they end up being something else.
The GIL isn't actually that sad. Even with the GIL, ruby 1.9.x's OS-native threads now work _fine_ for dealing with I/O bound processes. Whether network, disk, or waiting on user input. The article goes on to talk about specialized libraries for each of these cases, but misses the crucial point -- the ONLY time the GIL matters is if you want threading to deal with CPU-bound processes. Ordinary hand-rolled ruby threads will work FINE to help you deal with blocking on I/O, with or without the specialized libraries mentioned. That's not so sad to me at all, since I need concurrency to deal with blocking on I/O a LOT more often than I need it to deal with CPU contention. 
I wrote this above, but the answer is: if a thread is blocked on an OS operation, generally I/O like disk, network, or user input, ruby can switch it out just fine even with the GIL. In theory it could do this with 'green threads' too... but it didn't actually work. Since green threads could only be switched out at certain points, and also end up starving each other out easier. With native threads, even with the GIL, threads blocked on I/O are easily and effectively switched out until whatever they are waiting for comes back. Maybe it's waiting on the database. Maybe it's waiting on an HTTP request. Maybe its' waiting on disk. In all of these cases, the GIL does not not keep a thread from sharing the CPU with other threads who have work they can do immediately. 
[How to run a shell command in a separate thread, terminate it after a time limit, return its output](https://gist.github.com/1032297)
Your first point is definitely true. There are several large codebases out there in proprietary languages because Smalltalk was too expensive to license if you need to ship the development environment with your app, it was cheaper to design and implement your own language.
Even worse is if you have a scope that you want to skip the defaults for. A big enough pain that I find default_scope just not worth using for its troubles. 
I find many Ruby abstractions are well suited to real world problems.
has anyone gotten this to work with RVM yet? I updated RVM to 1.8.4 but when I try to install I get errors trying to download the source.
You can create crazy unreadable code in any language. I've worked on teams using languages ranging from C to Ruby, and I haven't found others' Ruby code to be particularly hard to understand compared to code in other languages. Good Ruby code is concise, predictable, and easy-to-follow, just like good code in other languages. Bad Ruby code (which I've seen my share of) doesn't tend to use crazy metaprogramming tricks that are hard to follow; rather, it tends to just be overly wordy and repetitive. Now that I think about it, it's really striking me how language-agnostic good code and bad code are.
I am a committer to this project, which is its infancy. We got some premature attention to our homepage, which was not clear on the specific use case we are seeking to solve with Monotable. We've updated the README to address most of the questions we received here and on YNews. https://github.com/imikimi/monotable . Thanks for all the feedback and questions.
The lazy GC stuff seems pretty interesting. I know this will contribute to overall performance but no one seems to indicate whether or not this will help with memory consumption. Has it been tested anywhere with big objects? Ruby 1.9 is great for many things and I have several apps running under it. That being said, I do have some apps that rely on copy-on-write for memory savings and that doesn't seem to be anywhere on the roadmap.
Just something I've been working on for my own use. This allows you to access cc radio streams that are intended for the iPhone. Basically, I extracted the sqlite3 database from the iPhone app, and luckily it was in an easy to use format. The radio streams are static and haven't changed since the app rarely updates. Back in the day I had a perl script to extract the asx stream from clear channel stations, but they closed that loophole with adobe flash's proprietary protocol. But it seems they opened up the iPhone streams when the iHeartRadio app came out. You can see the database here: http://ordorica.org/system/radio/TMS.db.sqlite3 You can input the URL to the media player, and the returning content type should load the .pls without you having to download it first. My code: [code] #!/usr/bin/env ruby require "rubygems" require "sqlite3" # "Ruby cc_radio parser" # "by hechacker1@gmail.com\n\n" # "Version 0.2 now with sqlite database and fuzzy matching station_url = [] title = [] call_sign = [] station_id = ARGV[0] index0 = 0 index1 = 0 index2 = 0 if ARGV[0] == nil puts "Content-type:text/html" #this empty line is for apache compliance puts "" puts "Please specify the station call sign." puts "&lt;p&gt;" puts "Example:" puts "&lt;p&gt;" puts "http://ordorica.org/system/radio/cc_radio_sqlite.rb?kiis" puts "&lt;p&gt;" puts "http://ordorica.org/system/radio/cc_radio_sqlite.rb?kfi" puts "&lt;p&gt;" puts "http://ordorica.org/system/radio/cc_radio_sqlite.rb?kggi" puts "&lt;p&gt;" puts "This script returns a playlist (pls) file linking to the stream." exit end puts "Content-type:audio/x-scpls" #this empty line is for apache compliance puts "" db = SQLite3::Database.new "TMS.db.sqlite3" db.execute( "select stream_url from Station WHERE call_letter LIKE '%#{station_id}%'") do |row| station_url[index0] = row index0 = index0 + 1 end db.execute( "select description from Station WHERE call_letter LIKE '%#{station_id}%'") do |row| title[index1] = row index1 = index1 + 1 end db.execute( "select call_letter from Station WHERE call_letter LIKE '%#{station_id}%'") do |row| call_sign[index2] = row index2 = index2 + 1 end puts "[playlist]" puts "" puts "NumberOfEntries=1" print "Title1="; puts call_sign[0] print "File1="; puts station_url[0] puts "Length=-1" puts "Version=2" [/code] Please provide any suggestions to fix up the code and make it more elegant. I'm a ruby noob.
Wait. Is this the Ruby "port" of Zed Shaw's ["Learn Python the Hard Way"](http://learnpythonthehardway.org/) where he went all ballistic when he found out some rubyist decided to rewrite his book for Ruby? 
No. I believe this is from somebody who actually asked for Zed's permission before embarking on taking his work and refitting it for Ruby. You can see Zed's reply to a similar question here: http://news.ycombinator.com/item?id=2846600
This is a his python book translated to ruby. I didn't realize he didn't approve. There are links to the python version and Zed's name is still listed at the bottom of the page. I really liked the python book so I figured the Ruby version would be good. I'm working through it right now so it will be interesting to see how the Ruby style compares to Python.
Lots of important Gem's rely on this Gem as well. One example is https://github.com/datamapper/dm-core/blob/master/Gemfile
[Here's a bit of a reworking of it](http://pastie.org/private/qs3h7hrjzvbchfbi8kd4lg). I commented what I did, hopefully it makes sense. I can't claim to know all too much about the pls format though, so I wasn't sure how to output a blank playlist. Hopefully, just outputting NumberOfEntries=0 does it, if not you'll probably want to change that. A sort of summary: - You need to check if the station actually exists so it doesn't just throw an error - Look out for that SQL injection danger there. The placeholders in the SQLite library help out with it considerably, [here's a guide to using them](http://sqlite-ruby.rubyforge.org/sqlite3/faq.html#538670816). - No offence, but you haven't used SQL much have you? :P You can use the SELECT query to grab multiple columns at once (SELECT column1, column2) so you only perform one query, instead of three. Also, using the LIMIT specifier, you can remove the index*n* variables, and only grab the first row. Only other thing was the last puts. print "Title1="; puts call_sign[0] I replaced that with puts "Title1=#{call_sign}" It just looks so much nicer. You're not doing too bad overall though for a "noob", I still cringe at some of the early mistakes I've made and I didn't see anything quite that bad here. Hopefully all that made sense, and if not, feel free to ask me about any of it :)
Hey thanks. More feedback than I expected. And no, I rarely have crafted sql statements. The code was just quickly hacked together to get it working. As for sql injections, I can easily set the permissions to read only on the sqlite file? It's just to read from. Eventually I'd like to use the other metadata as well to create more queries. For example, query for city = "los angeles" and then create a playlist of those stations. Here's the pls format: http://en.wikipedia.org/wiki/PLS_\(file_format\) Pretty simple format, and most players support it.
Good to know. I pictured Zed Shaw blowing up the internet again. Glad to know I can lower the threat level warning I have on my desk.
No problem, I like helping people with code :D You could set it to read only, but I wouldn't really consider it a substitute for the placeholders, especially considering how simple they are to use. (And if they don't seem like it, try using PHP's prepared statements then come back to this, HAH. I still have nightmares about that) It's good to get in the habit of using them anyway, so you don't forget to do it when making a program that has to write to the db. If you need any more advanced SQL for that, [this is a decent guide](http://www.w3schools.com/sql/default.asp). I'm pretty sure it's how I learnt originally. Simple enough, yes. Seems like my guess wasn't wrong at least.
I'll never understand why they don't tell people on windows to install jruby. They link to rvm in the windows section and no where does it give instructions to install rvm on windows. Does it even work on windows?
At least they link to [rubyinstaller.org](http://rubyinstaller.org/) at the bottom.
true, and I just found the git repo for it. If I get a chance to test it on windows I'll submit a pull requests. No windows machines here though :/
It doesn't seem to be working with the current version of RVM, but you can install it by using the git tag for rc1: [How to install Ruby 1.9.3rc1 with RVM](http://blog.arvidandersson.se/2011/09/24/install-ruby-193-rc1-with-rvm)
I tried LRtHW after many of the samples in W(P)GtR failed to run properly in 1.9, and I was seriously unimpressed. Why got me to *love* ruby, by writing beautiful code that emphasized its expressiveness. Zed wrote ugly code that could have been translated nearly word-for-word into any other language. LRtHW *might* be a better book for people who are new to programming, and it's certainly more to the point, but the book didn't extoll any of Ruby's virtues or say *why* it's a great language. Also, Zed's a sanctimonious ass, so there's that too.
If you think the only reason smalltalk failed was because of the attitude of the developers you are one dumb motherfucker.
Hey, I am the one who submitted the issue + pull request. Although I haven't seen any particular instance where it's exploitable, it doesn't mean instances don't exist. Hopefully this gets fixed soon!
It's an interesting problem, but the downside to a solution like that is that you would have two dependent examples. Moreover, despite each having, ostensibly, just one expectation, together those two examples have an additional implicit expectation wrt their ordering. if you want to adhere to one expectation per test, you'll need to create another rspec example.
No, rvm doesn't work on Windows, it's bash-based.
That's true, although the way we use it in DataMapper is to parse the connection URI the developer configures. If the developer was taking the connection URI from actual user input, and supplying that to DataMapper.setup there would be *way* worse things they could do, even with the fix applied.
Well, fuck you too.
It's a cultural thing, really. It's like how PHP has a copy-paste attitude towards a lot of things, Perl programmers don't seem bothered when their programs turn into regexps glued to other regexps, and C programmers are always one bad pointer reference away from disaster. Different languages end up "bad" in different ways, it's true, but some promote habits that are ultimately, subtly self-destructive.
I've been considering going through this, but after all the comments I probably wont now. May be someone should go through and make it more idiomatic 
Check the domain name. It's his domain.
He approves. Check the domain.
If I recall, he wrote Learn Python the Hard Way because markpilgrim couldn't be bothered to update Dive Into Python which is now a bajillion years old.
It'd be nice to make the bold vs italic library names up to date with the actual level of documentation. (e.g. dbm, bigdecimal.)
compare and contrast with rdoc.info? I hadn't even known about this other one; any reason to prefer one over the other? NEVERMIND, I see ruby-doc.org is theoretically just documentation of ruby stdlib itself, the quasi-official one?
Looking good. Whoever is doing that, keep it up.
Why not the format they're now using over at: http://api.rubyonrails.org/ ?
This guy kinda sounds like a douche. Oh, use a Mac. Maybe Linux. Oh, use zsh, not that ghetto bash. Oh, use rbenv, it's better than that crap rvm. ಠ_ಠ That's about where I stopped reading.
He's opinionated, but I appreciate that opinion. Instead of giving the same old advice, he's pointed me at a number of new techs, which is my whole motivation for clicking the link and reading that article. It's his stack, and he explains why he prefers that stack. I'll stick with RVM and bash for now, but I'm checking out all those alternatives. As an aside, it's nice to see Capistrano is still considered relevant. Out of interest, are there any good alternatives?
this must be a troll...
Can anybody elaborate on why zsh is better than bash? Or vice-versa.
Yeah, so he says in one breath: &gt; "RVM ... is a mess of bash scripts that are far more invasive than I care for" and then in another: &gt; "[rbenv's author] Sam Stephenson has proven with Prototype.js that he is a pragmatic developer that is open to alternatives" So you're OK with Prototype's invasiveness in polluting every object it touches with its own methods, but not when RVM does something similar? 
I'm not sure whether you can do this in bash, but zsh keeps a lot helpful stuff in its history, for example: * I open a new shell * type cd dev/projects/whatever * open new shell in tmux * i have to type cd and than press up arrow to cycle through all recently issued cd commands with different paths (it applies to all command line tools). Also it's more configurable - take a look at [oh-my-zsh theme collection](https://github.com/robbyrussell/oh-my-zsh/wiki/Themes) Zsh has a native hook mechanism, so in bash rvm has to define its own 'cd' function, in zsh you just need to [add a hook](https://github.com/wayneeseguin/rvm/blob/master/scripts/cd#L21) Better vi-like mode, but I haven't used it yet.
I believe what he's saying is that Sam Stephenson didn't get all butthurt about jQuery.
At our consultancy with 50+ Rails devs, almost none of us do. Cucumber is a clever solution in search of a real-world problem. I have yet to run into a client that wanted to read or write in that DSL. And for the devs, it's just a time-suck with no clear benefit over rspec.
Shameless plug ? [Toybox](https://rubygems.org/gems/toybox), if you're using a debian-like distro . Recently released, would like more people to use it to get feedback. It creates a debian package for easy deployment. Also, the benefit of debianization, you can do clean control files and have simpler Puppet/Chef/etc scripts to set up nodes. We are working on an cloud-like architecture at work (recently open-sourced: [enki_cloud](https://github.com/slaught/enki_cloud) [I'm a contributor, not project owner] on github) that this grew out of.
Good point, I can see that.
I feel like I'm having to spend more time managing my test harness(es), yes. Anyone who has had to upgrade 100s of RSpec 1 view and controller specs to RSpec 2: I feel your pain.
One has to remember that RSpec 1 was around for a _long_ time, and RSpec 2 is _mostly_ backwards compatible. Also, MiniTest is a better Test::Unit, you could have been using Test::Unit this entire time; why haven't you? Cucumber is still very young, so maybe there is some risk there. I think it's a good practice to occasionally go through ones tests and update them to the latest best practices or syntax, regardless of testing software. It helps keep your test suite modern and helps you spot bad tests.
Does rbenv still doesn't play well with pow?
&gt; Currently, Rubysource.com is a SitePoint Network site, offering 2.5 unique visitors per month. Wow. 2.5 unique visitors per month? Watch out Facebook! 
So, I take it your not interested? (thanks for pointing out the error.)
Replied. Check http://broadcastingadam.com
No no. Just the opposite. :) was just poking a little fun.
I tried to get this working but had seriously problems with the g2d library. What is your set up?
Complex tests are a sign that your code is poorly factored. 
I like this trend of people writing up their Iteration Zero steps. I find I actually use them when starting new projects.
[Vlad](http://rubyhitsquad.com/) has been around for a while as a more lightweight alternative to Capistrano. Then of course, there's the old `ssh user@myhost.com -- cd app/current &amp;&amp; git pull &amp;&amp; touch tmp/restart.txt` way, which is probably as lightweight as it can get.
you should have at least used a proper debugger, like ruby-debug or Pry for debugging, .NET guys would likely have LOL'd at your use of puts, also...Pry seems pretty impressive
Pry is freaking amazing and super versatile. I use it for everything from rails and Rspec to debugging Buildr plugins at the day job. Seriously one of my favorite new tools. Textmate, Guard, Rspec, Pry and Capybara for Rails dev. Good, good stuff.
Is Pry still crapping out on postgres errors? It was the last time we tried to use it but I'd love to switch back if not...
Pry developer here - I have never had this error reported before - however i don't think this will be an issue due to a refactor in the way errors are handled since version 0.9.5. BTW, if you encounter any problem with Pry **please** [report it](https://github.com/pry/pry/issues). The core team is extremely responsive and we can likely fix the problem and push a new gem within hours (if not minutes) of the bug report. EDIT: Also, if anyone would like to [donate](http://pledgie.com/campaigns/15899) it'd really be appreciated! I'd love to write more documentation but my motivation is starting to lag... :)
And? How does recognizing that help you make it better? No code is perfect, we need strategies for working with imperfection, not reasons why it would all work so much better if only it were perfect. 
I started with RSpec because that's what everyone uses, I use Test Unit now though. I spent more time learning RSpec than Rails.
Thanks for an awesome tool!
I love this dude's blog, but every time I read it I chuckle at his crooked glasses in his pic...I can't tell if he's trolling us all or if that's how he normally looks
Hey thanks for all your work!
at the time i wrote it the gd2 lib seemed like a good idea. i was working with 1.8.7 MRI and Ubuntu back then. today i would rather use rmagick or chunky png. 
Awsome, awesome tool. :) The only issue I've ever had is forgetting that I stuck binding.pry in a controller somewhere and wondering why my app froze. xD ;)
Recognizing a problem is the first step towards fixing it. I'm just saying that it's not the test harness' fault if you have brittle tests and no confidence. I've migrated several multi-hundred test suites between frameworks before, it's not really a big deal. Mostly busy-work.
It's how I normally look. I'm so used to it now that I don't even notice, plus my head is tilted ever-so slightly in a way that emphasizes it. Some people really notice, others have no idea.
Pry is sweet. I'm not averse to debuggers, (i use gdb with c code all the time) I just generally write more tests instead. When I do need to debug something, it's generally simple enough that puts works just fine.
The author would love contributions like that.
The style is fairly non-idiomatic. I haven't found the time to contribute yet. :/
I'm one of the latter would not have noticed the crooked glasses had it not been pointed out. Good post, I've not used twilio but sounds like fun. Also as far as the workflow is concerned I usually spend a half hour or so in irb or some other REPL to figure out what is possible in a non-formal kinda way before I dive into the actual application. Don't know if that qualifies as a step, but sometimes it prevents me from barking up the wrong tree. 
Ah, so this is from a while ago. I thought as much, because the g2d library seems pretty unmaintained. Couple of things I would have changed in your gist, mainly variable names (which is entirely preference) but for the most part cool stuff. Thanks for checking it out and posting back. ^_^
Yeah, REPL-Driven-Development is huge in communities like Lisp and Smalltalk. :)
Well sure. I thought I was the only one crazy enough to build something involving computer vision in Ruby so I had to read that code snippet ;)
He was a bit over the top, especially with RVM which is the de facto standard as far as I can tell. I will say kudos to him for finding stuff that works. After reading this I will definitely look into rbenv. Already use zsh and yeah it has some nice features including oh_my_zsh which is a nice little framework for getting the best features up and running quickly.
all good, I meant no derision. It was one of those "can't be unseen" moments for me when I first saw it, and now that I read every damn thing you post I see it every damn time :) Keep up the blog, good stuff man
yield executes the block passed as a parameter. So you pass the block { |item| result &lt;&lt; item } to many_yields which in turn calls the block four times with four different parameters. Think of that block as a parameter for method many_yields that you "reference" and execute in the method body using yield. 
`yield` is the same as `block.call` — merely syntactic sugar, in fact. ---- Every method receives an invisible block argument. You can specify it explicitly, too (and this is a good habit even if you use yield), by prepending &amp; to the argument name. In other words, by declaring a method like this: def foo(&amp;block) …the method will able to handle the block as an object. Thus, this: def foo yield 1 end is equivalent to: def foo(&amp;block) block.call(1) end In other words, `yield` is just syntactic sugar — a shorthand that reduces typing. ---- Now, what is the data type of the block argument? It's actually a class named `Proc`. When you do just `foo { ... }`, Ruby automatically creates a `Proc` that you don't see. But you can create them explicitly. These are all equivalent: # Proc created using {} syntax foo { |n| puts n } # Proc created with the "proc" keyword. Note &amp; syntax when calling. my_proc = proc { |n| puts n } foo(&amp;my_proc) # Proc created with the "lambda" keyword. Nearly same thing. my_proc = lambda { |n| puts n } foo(&amp;my_proc) # Proc creates with Proc.new my_proc = Proc.new { |n| puts n } foo(&amp;my_proc) ---- So what is a `Proc`, really? It's just an object that implements a method called `call`: my_proc = Proc.new { |n| puts n } my_proc.call(1) # This will output "1"
Wow, extremely thorough answer. Thanks, I understand now!
Thank you, that's very helpful :)
Others have explained what yield does better than I could. I'll tell you how I got it straight in my head. Ruby has LISP-like qualities that some other languages don't have. That means that you can pass actual code around rather than merely passing variables around. So, when you "yield myvarname(s)" you're passing those variables into the code that got passed into whatever function is "yield"ing. Hope this helps. EDIT: I don't mind, but could you at least explain the downvote?
As far as yield without parameters, I use it a lot to abstract any sort of "setup" code. Like the following: def with_debugging self.logger.level = Logger::DEBUG yield self.logger.level = Logger::INFO end def fetch_something with_debugging do self.logger.debug("TEST") # =&gt; Would get logged end end There's other patterns that are useful for it as well, but that's a good example, IMO.
You're welcome. I forgot to mention the handy thing about using an explicit block argument: You can pass it around. For example: def foo(&amp;block) [1, 2, 3].each(&amp;block) end Now you can do: foo { |n| puts n } While this example is silly, it gets very useful in some situations.
Wait till you get into procs and lamdas :-)
Good answer. It might be worth pointing out that Proc and Lambda are *almost* the same - they just handle what happens when you call "return" inside them differently. Generally speaking, it's simplest to say *never call return explicitly inside a proc/lambda* unless you *really* know what you are doing. (and have good unit tests!) i.e. never say: Proc.new { |n| return n + 1 } instead use the fact that the last result in a block is returned : Proc.new { |n| n + 1 } More at [Wikipedia](http://en.wikipedia.org/wiki/Closure_\(computer_science\)#Closure_leaving)
Totally. Thanks. :)
This _is_ the right way to understand the semantics, that was a good explanation. But once you understand that, then you should know that's not _exactly_ what's going on. In fact, MRI ruby 1.8 at least, performs some special optimizations if you use yield and do not include a &amp;block argument in your params -- there is such a thing as a 'block' that actually _isn't_ a Proc, but you can never actually look at it directly, as soon as you try to look at it it turns into a Proc. But it's an optimized special case form. So it may not actually be a great idea to use an explicit block argument, unless you actually plan to use it. I could actually have some of the details wrong here too, it's kind of a mess. But I do know that internal implementation of a block isn't quite the same as of a Proc, and is optimized -- I'm not entirely sure that simply including &amp;block in your arg list defeats that optmiization though. Tried to google for where I had read about this stuff before, but just found a lot of confusing stuff, heh. 
&gt; it gets very useful in some situations. Care to elaborate on this point? Btw your explanation was 110% awesome :D
what's the differences between pry and ruby-debug? does pry have advantages over ruby-debug?
Pry is like a souped up irb, ruby-debug is more like a rubyish gdb.
You are absolutely correct that using yield without an explicit block argument is much faster. Testing with MRI 1.9.2: def explicit(&amp;block); yield 10; end def implicit; yield 10; end Benchmark.realtime { 1000000.times { explicit { } } } # =&gt; 0.85 Benchmark.realtime { 1000000.times { implicit { } } } # =&gt; 0.16 However, the internal behaviour of blocks is an implementation detail. Personally I would never consider the performance implications of using yield vs. explicit block unless I *knew* for sure that some piece of code would be performance-sensitive. And for the record, under JRuby and Rubinius, the difference between the two is actually negligible. The self-documenting effect of using an explicit block argument is worth a lot of milliseconds. This: def transaction(&amp;block) …is self-documenting and obvious, where this: def transaction would require some RDoc to explain itself.
Glad to help! Three examples: ---- **(1)**. This one is simply using the block by passing it on to something you know takes a block: def handle_mail(&amp;block) processor = MailProcessor.new processor.options = {...} processor.handle!(@mail, &amp;block) end Without an explicit block argument, you'd need to do: processor.handle!(@mail) { |data| yield data } ---- **(2)**. The second example involves storing the block: class Builder def initialize @items = [] end def item(&amp;block) @items &lt;&lt; block end def build(n) items = @items.slice!(0, n) s = "These, my friend, are some items:" s &lt;&lt; items.map { |item| item.call } s end end Now you can do: builder = Builder.new builder.item { "Scruffy's gonna die the way he lived. Mmhm." } builder.item { "Scruffy's goin' to get one of them $300 haircuts, this one's lost its pizzazz." } builder.build(1) # Calls only the first block Now, that example is intentionally simple and useless, but you get the point: The blocks (procs, really) are only evaluated when you ask for them. This way you can build up a bunch of potential code to be evaluated, and then evaluate each as needed ("lazily"). --- **(3)**. So as you see, you can use procs this way as a kind of function object, without having to implement a class. Ruby, unlike many other languages, doesn't really support holding references to methods, but procs work just as well and could be considered cleaner. For example, imagine there's a class which wants to "plug in" a formula. It's an elegant class that doesn't want to be sullied by implementing formulas itself; it cares only about the output of the formula. In other words, it wants a pluggable function. We can do that easily with procs: relevance_network = NetworkTopologyGenerator.new relevance_network.compute(data, proc { |a, b| # ... .compute stuff ... }) You could have done it the Java way: class GoldthwaitGutenbergProximityCalculator def compute_proximity(a, b) # ... end end relevance_network = NetworkTopologyGenerator.new relevance_network.compute(data, GoldthwaitGutenbergProximityCalculator.new) But that's often a bit heavy-handed when all you need is to put some numbers together. Note how Ruby's `sort` and `sort_by` can use a proc to do the actual comparisons. That's the same thing on a smaller scale.
*yield executes the block passed as a parameter.* All these years I just avoided using it. Thanks, I knew there was a simple explanation.
you forgot to mention differences under REE Just kidding. Thanks for the very thorough explanations in all of your comments. +1 for covering premature optimization too.
This is definitely a good introductory explanation to the semantics of yield, but yield *is not exactly the same* than block.call. If you define a method like this: def foo(&amp;block) block.call(1) end Then ruby will instantiate the Proc object. This is substantially slower than: def foo yield(1) end If you define a method that takes a block, please try to use yield instead of passing the explicit block (One situation where you can't use yield is if you need to reference the block internally, for example to pass it to another method.)
It's an implementation detail that is not necessarily true for other Ruby implementations. See [my other comment](http://www.reddit.com/r/ruby/comments/kvjrw/ruby_newbie_i_dont_understand_yield/c2nmkrj) addressing the issue.
For example, imagine you have a class that implements a fixed size Array. You can leverage an array for a lot of things, but you don't really want to inherit from it, because you don't want people calling methods that will get around your cap. class FixedSizeArray include Enumerable attr :size def initialize(size) @size = size @array = [] end def each(&amp;block) @array.each(&amp;block) end def push(*els) raise "Too many things!" if els.size + @array.size &gt; size @array.push(*els) end # … etc etc etc, you will implement a few methods here end ary = FixedSizeArray.new(3) ary.push 2, 3, 4 ary.each { |n| puts n } # puts 2, 3, 4 That call to each just passes the block to each and trusts in `@array`'s implementation of it. This is of course a very silly example, but it illustrates the point of where you could pass around a block, for example.
You should use ensure: def with_debugging logger.level = Logger::DEBUG yield ensure logger.level = Logger::INFO end This makes sure that even if the block raises an exception you will still reset the `logger.level` so it doesn't change for the entirety of the program.
Thanks for the explanation! :) I think DataMapper utilized the second example a lot but I'm not 100% sure (building up and then executing). Thank you for taking your time to respond.
huh, ruby-debug has always seemed very much like irb to me, so I still don't quite get it. guess i gotta find time to check out pry to see for myself. 
 def foo # :yields: iterator[item, index] That is actually *MUCH* better than `def foo(&amp;block)`. And you know, writing rdoc (or tomdoc, or any kind of documentation) is actually something you **have** to do.
I love the ruby blocks but for me is more clear when I use javascript many_yields { |item| result &lt;&lt; item } is similar to js anonymous function: many_yields(function (item) {result.append(item);} what is this!!??...simple..you are calling a function named many_yield and pass only a parameter..but this parameter is a function the anonym function is something very useful inside functional languages or languages with functional background (like javascript ruby python)..now you can pass function like parameter to other function and not only values like the usual... your function many_yields convert (or partially convert to) js would be something similar to: function many_yields (yield){ yield(peanut); yield(other-thing); .... or more clear function many_yields (function_like_param){ function_like_param(peanut); function_like_param(otherthing); .... I think it is very clear using javascript...and if you understand it in javascript would undrstand for ruby!... 
You're welcome. Blocks in Ruby are ubiquitous, the better you understand yield, calling blocks, the &amp; operator, currying and all those nifty concepts that make Ruby such a beautiful language, the more efficient you'll get using it (and at reading the source of big Ruby projects) and learning it. You should also consider reading about the oddities and similarities of the three following concepts: lambdas, Procs and blocks, for example [here](http://www.robertsosinski.com/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/), it's a thing that usually trips beginners. The sooner you'll invest in learning about them the better. Also, I would suggest finding a good .irbrc on GitHub, something tweaked and refined for optimal on-the-fly coding and debugging. Finally and of course, #ruby@freenode.net is a very good IRC channel with people answering questions and providing good advice and guidance, it has helped me and continues to help me a LOT.
Check out some screen casts http://railscasts.com/episodes/280-pry-with-rails http://vimeo.com/m/#/26391171
A year back, I tried something called LiveConsole. Is it still around? Is Pry similar to it ? Steve, are u still working on shoes ? IIRC, you had taken it over.
Even better, restore level to what it was earlier: def with_debugging prev, self.logger.level = self.logger.level, Logger::DEBUG yield ensure self.logger.level = prev end
That is some ugly documentation syntax you got there. If the method signature is particularly long, it gets uglier: def handle_stuff(name, subject, scope, parent, options = {)) # :yields: iterator[item, index] Tomdoc is better, but it's still infinitely more verbose than just providing a human-readable signature. Of course one must have documentation, but the beauty of a good signature is that you don't have to look at the docs to understand the method. Hence my phrase "self-documenting".
Yes yes, you're both very smart (and correct, of course), but the point was to illustrate a use for yield without a variable, not show off my knowledge of best practice ruby.
thanks!
I tried using Test Unit, but I found it harder to find quick answers to questions when more complex testing came into play. From my experience, RSpec is more Googleable and newbie friendly. With little experience with either, I actually spent less time learning RSpec.
`&amp;block` doesn't tell me what the block does, or how many arguments it takes, which the RDoc syntax does :)
Indeed you're right, good sir. Have an upboat :)
I got that, but unless making things overly complicated, when you show code samples to someone who wants to learn, please don't cut back on the best practices. This will show him how yield works, and at the same time will illustrate him on how to write a method that needs to do something after the block runs—such as close file descriptors, etc. Worst case scenario you get a "What's that ensure there?" and he learnt two things instead of one :)
Often these things can be inferred from the method. As I said, one must have documentation. But often just a glance at a method will tell me all I need to know.
Fair enough.
Even if I do read the source of most of the libraries I use, please, don't *make* me. :)
I don't know about LiveConsole. Yes! I just announced a release of a Shoes 3.1-beta here at RubyConf! We're working out some last bugs, and 3.1 will be good to go.
I wish it was a bit more smalltalk like.
Prepending unscoped isn't really that painful.
How so?
I'll try to re-produce the problem and file a bug if I can. Really impressed with Pry, btw!
[It's a bit more complicated than that](http://madein75.com/blog/ruby/a-little-gotcha-with-unscoped-in-rails/).
Actually arel is very simple, maybe too simple. The order calls' arguments are added to an array, just like the where calls' are which are then joined with a "," or "AND". If you want to create more complicated expressions you're still on your own like you were in the previous versions of rails. And using with_exclusive_scope or now unscoped with a block is the same pattern as using uncached with one to disable the query cache. BTW: If you just want to get rid of the previously added order arguments from any scope you could abuse reorder(''), which causes two space characters in the generated SQL. As I said this is all very simple, for better or worse.
I find this too, I tend to have to look stuff up for test unit as with rspec it feels more natural. This maybe because I've been using rspec for a while though.
I think(I'm not an expert in either language that) [:n | n + 1] in smalltalk is a BlackClosure object literal that is always passed explicitly as a parameter as opposed to the proc/block distinction.
I see. Well, Ruby 1.9 now has a new syntax which is nearly as good as Smalltalk's: -&gt;(n) { n + 1 } There's also a new way to call procs: f = -&gt;(n) { n + 1 } f.(1) Should have mentioned this new syntax in my other comments, but I had plain forgotten about it. I don't use it myself yet, and I have not seen any libraries using it yet, either, so I guess a lot of people are still trying to be syntax-compatbile with 1.8.
FYI, [MIX](https://secure.wikimedia.org/wikipedia/en/wiki/MIX) is the hypothetical computer used in Donald Knuth's [The Art of Computer Programming](https://secure.wikimedia.org/wikipedia/en/wiki/The_Art_of_Computer_Programming) series. Hopefully the author will implement this into a DSL. Very cool!
Look into Gosu. I wrote [some articles](http://ruby.about.com/od/gosugme/Rapid-Game-Prototyping-With-Gosu.htm) on the subject last year.
*forget* about RubyGame - it's a dead project. Definitely look into [Gosu](http://libgosu.org) or [Ray](https://github.com/mon-ouie/ray)
Ray should make building a mancala game downright easy. I wrote an article about making a simple arcade game in Ray, maybe it'll be helpful: http://practicingruby.com/articles/shared/vbmlgkdtahzd
Thanks… I hadn't seen Ray yet. 
Thanks, I hadn't heard of Ray before today. Thanks.
It's relatively new and somewhat undocumented except for the fairly good guide on its website, and some good examples. But it seems very promising to me.
Check the [Ruby Toolbox](http://ruby-toolbox.com/categories/image_processing.html)
I imagine that mini_magick will work perfectly, as it shells out to the imagemagick binaries which are easy to download separately.
minimagick works perfectly for me on my work win7 x64 computer i use it with paperclip, for image uploads.
Glad you liked it. I wasn't really thinking of it as a DSL, but eventually I would start adding devices and an assembler. Devices would be special files. For example, you could write a MIXAL program and then have that program on a "punch card" that could be loaded into the simulator. 
You could use both: https://github.com/jashkenas/ruby-processing/wiki JRuby + Processing
The notable exception to this list is [RMagick](http://rmagick.rubyforge.org/). Also, just in case it was wasn't clear, ImageMagick itself is not a gem and exists seperately from your Ruby installation. The gems listed on this page are for interfacing with ImageMagick without resorting to the command line. That being said, the [command line interface](http://www.imagemagick.org/script/command-line-tools.php) is pretty straight forward and a good alternative if you're still having problems.
Easy, best answer: use vagrant instead of running on windows. Not as easy, sub-optimal answer: try mini-magick with graphicsmagick instead. If you're using it for file uploads, carrierwave supports this setup and it's fairly simple to get set up. With that said, use vagrant, it's all the wonders of developing on a linux box with the convenience of being able to do it from windows.
If I'd have known just how painful going from rspec 1 to rspec 2 would have been, I very well might have just rewritten the lot of it to use Test::Unit. Was there some kind of deprecation warning release I missed, or did they straight up break a ton of stuff that has been working forever without telling anyone?
you've moved on to 1.9.1? are you nuts? 1.9.1 is a MESS, move straight to 1.9.2 and FORGET 1.9.1
I would really like to use Minitest in a Rails project, but like you said, it's so hard to search for answers when Rspec just dominates the results.
the what?
IIRC there were not tons of deprecation warnings issued by the last 1.x RSpec release, no
Did this page not render correctly for anyone else? Using windows firefox 6.0.2
Works fine here on Fedora with Firefox.
Same here - Ubuntu/FF7
Yes, I was a little shocked to hear that, too.
I saw this on Hacker News, and it seems to me like there's a pretty big leap from "popular system administration software is written in Ruby" to the article title.
The truth (despite the article's projecting of the author's personal experience and work environment onto sysadmins in general) is that some sysadmins use Ruby, some use Python, some use Perl, and some use whatever their infrastructure requires them to use. &gt; But the fact is that we sysadmins need flexibility more than we need raw power or consistency. If you're the type of sysadmin that thinks flexibility is the most important part of your programming language, you're not a sysadmin; you're a programmer.
I once tried to write some distributed backup scripts for windows in (*shudder*) powershell. Close to impossible to read STDOUT / STDERR and act on return codes for anything that wasn't written for powershell already. In fact there were all sorts of issues just parsing powershell's output, as it mixed stderr/stdout. After two weeks I concluded this was nonsense. I switched to Ruby and it's humming along for two years launching remote Oracle data pumps, compressing files on the fly and packing everything along with bfiles into timestamped archives. I will never look at Powershell again. (PS: I was forced to use windows). But, as to Python: Too many people hate compulsory indenting. 
I don't know, consistency is very important for us programmers as well. (Which is why I went to python over ruby.)
Fair enough, I wasn't really knocking programmers or specifying what we need. I was just pointing out the sysadmins half.
As a programming newbie, should I be worried about using uncommon APIs in case they are deprecated in future releases or am I being a bit too paranoid? 
What specifically is wrong with [the documentation for etc](http://www.ruby-doc.org/stdlib/libdoc/etc/rdoc/Etc.html)? I didn't get any feedback when I submitted it.
Did you try this one? http://rubyforge.org/frs/download.php/64917/RMagick-2.12.0-ImageMagick-6.5.6-8-Q8.zip Make sure you install the imagemagick included with this package, and then install the included gem. Works for me, Win 7 1.9.2 MRI (as someone else said, imagemagick is a separate suite that needs to be installed on your machine, whereas rmagick is just a ruby wrapper for it)
The documentation method-by-method looks good. But we are specifically targeting classes/modules which do not have good "overview" documentation, I.e. a description at the top of the class that describes what it is, what you'd use it for, and provides examples of how to use it. Etc has only a one line description, which is why we listed it as "poorly documented" at the top level. By contrast, check out something like PStore or CSV, which includes several paragraphs of explanation along with real usage examples. 
I wouldn't be worried about stuff like `block_given?` or `at_exit`. Anything starting with an underscore should make you think 'do I really need to use it?' ;-)
Oh, right. I assumed that if you were using etc, you'd know what POSIX / Unix etc was.
Not an unreasonable assumption but it should also be possible for folks to browse the API documentation and discover why they'd want to use the libraries rather than just looking them up because they already know what they're for. We want to eventually make a more outside-in index of the core/stdlib functionality that makes it easier to sort of learn Ruby via its API docs. So this is meant to bring us one step closer to that direction.
OK, submitting update...
Awesome, thanks!
Committed!
-1 sick of being lectured to by self-promoting ruby loud mouths about best practices
block_given? is a a less used ruby api? Really? It is so useful.
"-frontpage" is right over there, champ ------&gt;
So is your mom, chump
i can't upvote this enough. apart from some whitespace issues, it's a vast improvement
What I don't understand about the MacRuby project (which this guy contributes to) is that it's made big advances in the VM tech (LLVM backend, no GIL, etc.) and yet it also couples itself tightly to Objective-C, which makes those advances unavailable to all platforms except MacOS X. In other words, I can't take advantage of MacRuby's benefits on a Linux box to run my Rails app. Seems like a missed opportunity to me.
Eh? I can think of a number of reasons to pick Python over Ruby, but consistency isn't one of them. Python has all those inconsistencies from its procedural heritage, like having to include self as an argument in methods when defining them but not when calling them; whereas Ruby is pure OO.
Missed opportunity in what way? As you know, there is plenty of overlap between Ruby developers and Mac users. Also, the name is **Mac**Ruby. It's not confusing or misleading at all. And I'm pretty sure you're allowed to take those "advances" and port them to whatever platform you want, minus all the Obj-C binding. If you wanted to do all that. It's like arguing that MS is missing an opportunity by not letting IE run on Linux or Mac. Or Apple not letting Mac OS X run on generic hardware.
&gt; Missed opportunity in what way? I thought I made myself pretty clear? They have done cool technological stuff that will not run on anything except Macs, *even though the improvements are not Mac-specific*. &gt; As you know, there is plenty of overlap between Ruby developers and Mac users. Irrelevant, as MacOS X is not a common server OS, and most Ruby devs don't deploy their production apps to MacOS X servers. &gt; Also, the name is MacRuby. It's not confusing or misleading at all. What? I did not say it was confusing or misleading. &gt; And I'm pretty sure you're allowed to take those "advances" and port them to whatever platform you want, minus all the Obj-C binding. If you wanted to do all that. I don't, I'm paid to do other stuff. &gt; It's like arguing that MS is missing an opportunity by not letting IE run on Linux or Mac. Or Apple not letting Mac OS X run on generic hardware. No, it's not. It's like if someone made Firefox 10 times faster, but at the same time added some unrelated stuff that made the version only work on Macs, even though those changes were unrelated.
 &gt;No, it's not. It's like if someone made Firefox 10 times faster, but at the same time added some unrelated stuff that made the version only work on Macs, even though those changes were unrelated. Which would make a good analogy **if** FF was originally developed to run only on one platform. Which MacRuby was. &gt;I don't, I'm paid to do other stuff. And the MacRuby team makes this stuff to run on Mac. Not Linux. You're only showing that in your opinion it's a missed opportunity because you can't benefit from this, yet you're quite clear that you wouldn't do any work for it at all. MacRuby is doing just fine. They have a big enough userbase and I don't see them changing their core product just to appease a very small and wholly unrelated market segment. 
&gt; Which would make a good analogy if FF was originally developed to run only on one platform. Which MacRuby was. Nope. MacRuby is a *fork* of Ruby. And they have not offered their generic, non-Mac-based improvements back to the mainline. You are still missing my point. I want to have a modern Ruby VM with an LLVM backend that does not have a GIL — indeed it seems a large number of Ruby devs are desperate to have such a thing. MacRuby has implemented this, but at the same time they have tightly coupled it to Cocoa/ObjC. So now their improvements are tangled with the Mac stuff, and cannot be used for anything other than Mac development. That's why I called it a missed opportunity. &gt; … yet you're quite clear that you wouldn't do any work for it at all. I don't have the time or the energy to work on a Ruby VM. It's my (and anyone's) prerogative to criticize open-source projects without contributing. Not everyone can contribute.
It's a missed opportunity *for whom*? What benefit does the MacRuby team or their users get for doing things your way instead?
You do realize Rubinius is also based on LLVM, and is in the process of removing the GIL? You will get your wish fulfilled pretty soon. 
I know. Rubinius is very slow, however — much too slow for production use. It's made improvements the last few years, but it's not there yet.
It's a missed opportunity to satisfy a huge number of people who wants a LLVM-based, GIL-less VM. &gt; What benefit does the MacRuby team or their users get for doing things your way instead? Oh, they get a nice fuzzy happy feeling know they are pleasing a lot of users. And a lot of gratitude.
&gt; It's a missed opportunity to satisfy a huge number of people who wants a LLVM-based, GIL-less VM. I am not terribly familiar with the intricacies of the MacRuby project. Sounds like you aren't either. And I have no idea how "huge" this number is that you're mentioning. But the big problem you have with the project is, what? That they don't contribute these improvements back to Ruby itself, right? What if they really can't. As you said: &gt; So now their improvements are tangled with the Mac stuff, and cannot be used for anything other than Mac development. Would you be open to the idea that they actually *could not* do things the way you want them to, rather than what sounds like your assumption that they *chose not* to? And yes, as a user, you can complain and criticize all you want. But if you're not actually offering any solutions (which you aren't), or willing to at least help (which you said you aren't), it counts for very little beyond bitching.
I have (unlike you, perhaps?) actually looked at the MacRuby project. The core VM is written in C++ and contains very little that is Mac-specific. They have gutted the string support and delegate its implementation to NSString, done the same thing with IO and hashes, that sort of thing. They use Grand Central Dispatch, but that's been open-sourced by Apple and is cross-platform. It's entirely backportable and implementation-wise it's a bit disappointing that they have not generalized it to be Mac-independent. And *that's* why it's a missed opportunity. &gt; it counts for very little beyond bitching. Ironically, looking at your account, you seem to spend most of your time on Reddit complaining about other people's bitching. I'm sorry I replied now.
Well hopefully in the upcoming months I will have time to make some contributions like this. I've been wanting to get more involved in the Ruby community and this would be a great start.
But the entire goal of the project is to do exactly what you're describing! Tightly integrate Ruby with the Mac NS-stuff. &gt;Ironically, looking at your account, you seem to spend most of your time on Reddit complaining about other people's bitching. I'm sorry I replied now. For the most part, yes. That is a lot of what I do. However, I comment a lot. And they are not all like that. You didn't look very hard, but I appreciate the special attention. I suppose you think I got to 21,000+ comment karma solely by bitching and trolling, huh?
Awesome. If you do, and/or if you have any idiom questions, feel free to email me.
Yeah, how exactly is this “much faster”? The only real change that can have an impact is the change on how files are opened, which is only making the load time a tad faster.
In software development you try to miminize redundancy because it's extremely expensive — logistically and intellectually and so on — to maintain that redundancy. Which is why modularization is an important principle, and a core tenet of the Unix philosophy. You could say that MacRuby violates that principle. Unfortunately, the structure of Ruby's source code makes it difficult or impossible to do what MacRuby does without forking it; however, the VM is actually quite separate from the rest of the stuff and probably deserves to a separate project that's cleanly separated from the Mac stuff. I don't know how you got your karma, and I'm not really that interested. What I do know is that you seem really negatively focused. Cheer up. (And that's enough meta for today.)
I tried rbenv and ruby-build when they first came out. While Bundler in theory makes gemsets unnecessary it's still a nice feature to have. Seeing that Jamis Buck added that ability to rbenv I might need to try it again. Still pretty happy with RVM though and no, I haven't had any issues with my cd command screwing everything up. 
I'm currently using RVM also, I like the ability to benchmark code across multiple rubies easily. But yeah, I think they are both great options.
Depends on the application. A lot of peoples' primary use case is large-ish rails applications. When require is called 2000 times on a load path of 85 elements, this takes boot time from 20 seconds to about 12 seconds, which is indeed "much faster". The only major difference is definitely in require time though; actual performance is largely unaffected.
it doesn't ... i was using 1.9.2, upgraded, got much faster performance
Yup, exactly. At most it would give an advantage when loading workers to serve rails, but if you're gonna scale you're probably gonna run unicorn anyway, which just forks the workers and doesn't need to spawn and require the entire application again.
Or perhaps when you're running tests. 
`rvm ruby test.rb`
I've been using RVM and not faced any problems. What issues are people facing with overriding of 'cd' and 'gem' ?
Already a member. These are pure gold when you're learning Rails.
Spork or autotest make this a non-issue for tests :)
As someone who uses spork and autotest (watchr) in addition to a custom gem that checkpoints the process at a number of different stages to restart from when dependencies change, I can assure you that it remains an issue for sufficiently-large projects. There's also no publicly-distributed way to fork off workers for rake/runner/console/etc. runs. Waiting 25 seconds for a generator to run is hell on earth.
I love railscasts too. I hope lots of people sign up so he can make a living at it. He is very good at what he does.
To his "Take objects, not classes" points, I'd say "take blocks, not (other) objects". There's no excuse to demand an object with a specific method name when you need a single method call as the interface - you can use call, and if you can use call you can usually use yield - in either case you can accept either a Proc or a plain block and the user isn't tied into writing a class where a simple block is sufficient. Take his Roster example. I'd rather be able to pass a block so I'd be able to do roster.print {|participants| puts participants.join } for example, without wrapping it in a class. 
I agree in this particular case, but isn't this more a consequence of trying to keep the examples simple and easy to understand? Imagine cases where the interface has five or more methods that will be used.
Good.
Bad. See how pointless these kinds of comments are? :p
Read farther down the article for examples of the kind of API you're looking for. Inspector.report("Word Length") { |data| WordLengthPlugin.analyze(data) } And it may just be the internets making it hard to judge intent, but "There's no excuse to demand an object..." seems a bit sensationalist to me. We're talking about code, not a hostage situation :)
It's mostly that there was a later point in Mike's original article that encouraged us to "require no interface". I wanted to save an example of that until I got to that point. But it's also because I don't think there is a solid "Thou shalt always use blocks when depending on a single method call" rule. It's a good design, for sure, but not a hard and fast rule.
They're not removing it, just DISCUSSING removing it. Unless I missed something. edit: i'm wrong. most definitely removed.
No.
They were definitely removed in [this commit](https://github.com/cucumber/cucumber-rails/commit/f027440965b96b780e84e50dd47203a2838e8d7d) He's [written](http://aslakhellesoy.com/post/11055981222/the-training-wheels-came-off) about it as well. Also a minor point of order, these belong to cucumber-rails and not cucumber.
First - get a mac - it'll make your life a lot easier. Doing RoR on a PC is a pain in the ass. http://guides.rubyonrails.org/ http://mislav.uniqpath.com/poignant-guide/ http://railsforzombies.org/ I dumped .NET for RoR when it first came out. Much more interesting and flexible work. Really like it's open source (can hackity-hack). 
Cucumber-rails, not cucumber. Also, ultimately a bad decision IMO. This is the rails additions, not cucumber-core, where those things make sense. Also, they didn't test the feature generator after this change.
Agile web development with rails is the book I started with. I'd highly recommend it. Watching railscasts helps a lot because you see everything in action. Figure out a small project to use rails in and try it.
This. I started trying it in windows and even though the EngineYard guys are trying with RailsInstaller, it's just not there. I bought a Mac partly because I wanted to do Ruby.
Try getting a Ubuntu VPS instead. I remote into one from Windows and from OSX.
The best way to get started IMHO is build something. Try to build a blog, even if you don't plan on actually keeping up with it. It will give you a good introduction to the basics of Rails, and having a project will help keep you focused. After you get the basics of the blog done (Posts, comments, authentication, etc) you can start adding features you like to it. It will also help you learn about deployment strategies with Rails. You can push it to heroku first, for free. Then if you want, you can migrate to a VPS like Linode or Slicehost. This will give you some experence with the ops side of a Rails deployment and the conventions that are common. Above all, find something you will have fun building. If you aren't having fun, you probably won't keep up with it. And remember, google is your friend :D
The platform doesn't matter. You can use eclipse on any platform right now. 
I moved from .Net to Rails a couple of years ago. ASP.Net MVC is a great gateway drug, since it's kind of a less flexible half-port of Rails into C#.
I was one of the first to comment on the lack on examples in the article you reference. I like this one better. Thank you!
Coming up with good examples is hard work. It's mostly a coincidence that my design aesthetic seemed to line up with what Mike was describing, so I had some handy. But it's also that I think good examples are so important for having meaningful technical conversations. I'm glad that my approach made the article more enjoyable for you.
You're being downvoted because it has nothing to do with PC vs. Mac. It has to do with UNIX vs. non-UNIX (ie. Windows). "PC" != "Windows". Mac OS X happens to be a UNIX, and it works well for Rails development based on that, not based on anything Mac-specific. There are some nice Mac-specific tools and such that people like, but those are not what Windows is missing in comparison - what Windows is missing is not being a UNIX platform. Linux is just as ideal for Rails development, and after all, is the platform that those Rails apps tend to end up on for production deployment. Ruby is pretty UNIX-centric and there are plenty of gems who just don't expect to be run on a non-UNIX platform and flat out don't work on Windows. And there are a lot of other little annoyances that pop up. At least, this was true in the past. Someone with more recent experience with Ruby on Windows would be in a better position to speak on if the above still holds.
This is the same book I used as well. I had an older app (was in PHP) and I worked to move it into Rails. This helped me figure out the concepts behind REST and the controllers.
[This](http://ruby.railstutorial.org/) is the site I used to get started with Rails. It teaches Rails by having you build a simple Twitter clone and by the end you should be able to get going on whatever project you have in mind. One nice thing about it is that you can get started without really knowing any Ruby and pick up what you need as you go. (It's not hard to pick up the basics, most things should be relatively self-explanatory if you've got any programming experience.) Someone else recommended [RailsCasts](http://railscasts.com/) already but I'll second it. It's a very good resource. For Ruby itself try [Learn Ruby The Hard Way](http://ruby.learncodethehardway.org/).
Step 0. Get a Mac or run Linux, or get a VPS. Get something UNIX for your development environment. It's a command line world indeed. And getting half of the more powerfull gems to run on Windows may perhaps be more complicated than actually installing a linux desktop. Besides proper web development beyond the simplest of tasks, involves some server side configuration. Cron jobs, background jobs, image transformation, pdf generation. The expected ecosystem for production, and therefor development is UNIX. On the other hand, maybe these days there are some great IDE's with Rails support that can take away some of the pain? I wouldn't know. But for the love of god. At least run a virtual machiene, or rent a VPS, and use that for your development server. If not, you are in for a world of pain.
Now, that's the kind of advice I would give somebody that likes Windows, but wants to do Rails. The plus side, is that your development environment and likely production environment will be extremely similar. That's a bunch of headaches gone, right there. 
Bullshit. To properly do rails development you need some type of unix system. Either in a virtual machiene, or whatever.. To properly use Rails, you want to (be able) to use all its gems. Few, if any of those guys are testing their stuff (and/or supporting it on windows). I'm not saying it can't be done. But here's an example scenario: you have an application that uses sphinx to do full-text search. You need to make your site update it's indexes every day, and run a delayed background job. You also allow people to upload images, and want to convert them to the proper dimensions and file format. You don't want public access to those images, so you'll have your webserver send them at specific, authorized urls. We're talking adding three lines to your Gemfile, using a send-file operation in your controller (for the image), and adding some logic to your models. Install sphinx with apt-get and then just run bundle install on linux or mac. Now, imagine the nightmare on windows. Fuck, does Git even support these days? Does the background job gem support it? Can you automate setting up the recurrent tasks in such a way that that effort also translates to your server? Your not a professional rails developer for sure. If you want to work Windows, sure. Get a virtual machiene, or rent a VPS. Eclipse can help you edit ruby language files. It may execute some shell scripts for you. It might have some plugin to help you deal with GIT. But it won't make those shell scripts _work_ on windows, you won't end up with a project you can deploy without zero though to a linux server, and nothing of what you are doing is properly documented or even supported by all those different maintainers all that code. And if you find a bug, that only exists on windows, and you fix it, how you are going give that fix back to the community without proper git integration. Sure, the core rails framework will work. Sort of. But it's about ecosystem. It expects UNIX. You need git, you need BASH, you likely need a proper web server (like apache), etc, etc. etc.
FYI, I code rails on Linux... But if rails needs unix , then there's a pretty serious problem... In a way, developing rails on Windows has some niceties to it - you get rid of all the Linux or OSX specific stuff... 
minor detail but I believe best practice is to use yield over call wherever possible
&gt;But if rails needs unix , then there's a pretty serious problem... No, there isn't. Let's define a platform first. I'm talking operating system, database system, and every other subsystem you may need for your application. &gt; you get rid of all the Linux or OSX specific stuff... There is no 'Linux' or OSX specific stuff in Rails. It just defaults to using a lot of subsystems, that are only (properly) supported on UNIX. Which is a standard, the only actual standard, that is documented and everything. Those subsystems will work on Linux, BSD, OS-X, Solaris and even old commerical unix servers. There are alternative stacks of web-servers, database-systems, etc. But as of today, there is no way, in any language to target them all in a subsystem indifferent way. If anything, Rails goes pretty far, by at least making it as indifferent to what web-server and database-server you are using, as possible. When it comes to Unix, we're talking libc, the gnu tools or equivalent implementations and GCC. There are two other competing platforms: .NET and JAVA. Windows isn't a platform in this sense. It is just a kernel, no web application would use much if anything of the win32 api. So, what platform are you talking about? What should a rails developer be using? .NET libraries? Rails and ruby are supported on different platforms though. You can run them on windows and depend on stuff that is available there. You can run them in the JVM (using JRuby) and use the java ecosystem. (Tomcat, Luscene, etc.) Some of the unix-based subsystems do have ports for Windows. Consider the typical LAMP stack: those few subsystems (apache, mysql,php) have (crappy, not supported on production) windows ports. And you can use those to develop a trivial PHP application on windows. The same is true for Rails. The situation is not worse or better compared to PHP. But all the advanced stuff you may want to do with any web application, are also 'impossible' on windows. Converting images? Sending email? Stuff like that has very specific requirements concerning the server configuration. You can't implement them in a cross platform way. You need to pick a server architecture. And to properly test, you need to run it and develop it on that architecture. When it comes to architecture, there is no 1-on-1 mapping, between the platforms (.NET/IIS, JAVA, UNIX). It is not just a matter of 'porting the tools'. It is a matter of rewriting your application: actually maintain ports of your own application. Why would any one bother? Sure you could port the whole environment: from Bash to GIT, to a UNIX-complient file-system (yes, you need that, and FAT32 or NTFS isn't it) and what you end up with is Unix with a windows kernel. That's just ridiculus. Just install virtualbox, install a linux server, and forward a port to your virtual machiene. But please don't advice anybody to shoehorn Unix dependencies on windows, unless they absolute have to. It is a nightmare, and you are not doing them any favors. So, to summarize: &gt;you get rid of all the Linux or OSX specific stuff... You can't get rid of UNIX for webdevelopment, any more than you can get rid of DirectX requirements for game development. Sure you can use alternatives, like the JVM for web development, or OpenGl for game development, but there is no cross platform solution. There are cross kernel solutions, sure. But a platform is much more than just a kernel.
&gt;And if somebody ports Ruby to .NET then thats' also an option. Pretty sure IronRuby is Ruby ported to .net http://ironruby.codeplex.com/ You may have lost a bit of credibility with me with that one point. Yes with ruby you get all the linux development tools that go with it for compiling libraries. Anything that needs gcc is going to be a pain in the arse. But with Ruby on Rails there isn't a heck of a lot, and if you really want to (not that I've tried it), you can run it within Cygwin (again, I'm a Linux guy, but I see no problem with people developing on Windows. It is very doable)
&gt;You may have lost a bit of credibility with me with that one point. I'm a person you don't known on the internet. A stranger. Why would I have any credibility, and why would that be gone with me not being in the know about all facets of .NET? Why not judge my points on their merits? Sure, I heard about ironRuby &amp; ironPython some time ago. But didn't they die off? Is somebody actually using this in production? They guy that started that project, was initially hired by MS, but as far as I know, he quit and the projects are sort of unmaintained. But that was some time ago, I don't know what the current status is. I fail to see how it is relevant. But from this reaction, i do feel, I still havent' got my point accross: &gt;Yes with ruby you get all the linux development tools that go with it for compiling libraries. Anything that needs gcc is going to be a pain in the arse. It's not just Ruby. The majority of code that actually makes, even a simple site, run is not written in Ruby or part of the ruby stack in any way. That's my argument. Nobody makes a site in Rails. People make sites, for example, in: Ruby, Rails, Bundler, Mysql, Apache, Passenger, Sphinx, ImageMagick, Cron, SSH, GIT, Sendmail, Apache-X-Sendfile, xhtmltopdf And that's just a trivial site, that does some image pre-proccessing, has full-text search and is able to generate a PDF. For how many of those systems can you even _find_ documentation on how to install it on windows? It doesn't mean you wouldn't be able to create the same application for a different platform than rails. But that would be a different application, with different code and different requirements. &gt;But with Ruby on Rails there isn't a heck of a lot, and if you really want to (not that I've tried it), No you haven't tried it. I have spent days trying to make a simple rails site even _work_ on windows. &gt; you can run it within Cygwin (again, I'm a Linux guy, but I see no problem with people developing on Windows. It is very doable) Doable for who? For a c programmer that has extensive knowledge of the linux ecosystem? Sure. For somebody that is so unfamiliar with linux, that they prefer to run things on windows? If you give them this advice, you'll make enemies for life out of them. 
&gt;Mysql, Apache, Yeah because those don't exist for windows... (I'm no windows apologist like I said, but there's nothing wrong with it). 
Yes, those are supported on Windows. At least well enough for development. How about all the other requirements? Creating anything but a trivial web application that is cross-platform (not cross-kernel, but cross platform) is as hard as creating a cross platform desktop application. With the only real difference being that there is never any reason to do so. Since, you control your production environment. But that does mean, you need to rest and develop with that same platform. And yes, same of these subsystems have windows ports that are actually maintained. Some don't. There will be equivalent technologies that are well supported on windows. But generally speaking, for web development, if you do anything complicated (sending mails, generating PDF's, proccessing video's, use a caching layer, sharding, whatever), your development platform and production platform should be similar, if not identical.
&gt;Yes, those are supported on Windows. At least well enough for development. How about all the other requirements? Again, your points simply degrade your credibility of your posts. 
Very interesting and easy to understand read, you're a good writer too.
&gt; End up making libraries harder to understand, since the details of MyLibrary's String are opaque from outside MyLibrary Why's that a problem? Why does the detail of MyLibrary's String matter to those outside MyLibrary if it still behave correctly outside MyLibrary?
&gt;For example, people want optional typing because they've heard it will 'make Ruby faster,' not because they want to use optional typing to write better Ruby code. I disagree with this. I want optional typing in order to write more robust code and I think optional typing will help. Hell give my perl style strict and warn even that would be better than what we have now. I do get his point about tooling but I think without language enhancements it may not be possible to build the tooling.
&gt; I disagree with this. I want optional typing in order to write more robust code and I think optional typing will help. Maybe Ruby isn't the language for you. Duck typing is all you need. Restricting things based on type significantly hinders flexibility. &gt; Hell give my perl style strict and warn even that would be better than what we have now. We have some of this already. -w exists. &gt; I do get his point about tooling but I think without language enhancements it may not be possible to build the tooling. This is fair, but Brian (whose presentation I'm basing some of this on) is a core Rubinius guy, and he seems to think it's quite possible.
Sorry, you're right, this part is really poorly worded. What I mean is this: There's no actual _gain_ for refinements here. Just like with monkey patches, you have to examine all the internals of a library to understand it. The situation is exactly the same. Refinements are a feature based largely on fear.
Using yield makes code far easier to analyze, both by humans and programs.
This refinements business sounds like someone doesn't really get the point of Ruby and should be using another language. There are literally hundreds to choose from for Christ's sake.
Right. Until very recently it was slated to be in ruby 2.0, though, and if you read the list, Matz still thinks it's a good feature.
[Relevant](http://steve-yegge.blogspot.com/2010/07/wikileaks-to-leak-5000-open-source-java.html).
&gt;Maybe Ruby isn't the language for you. Duck typing is all you need. Restricting things based on type significantly hinders flexibility. Maybe you are right. Maybe Ruby is not the language for me. Having said that I said "optional" typing which would give you the freedom to use or not use strong typing. &gt;We have some of this already. -w exists. Not even close. Especially the strict levels. Perl's implementation is much more robust and logical than Ruby's. &gt;This is fair, but Brian (whose presentation I'm basing some of this on) is a core Rubinius guy, and he seems to think it's quite possible. I am all for it if he can come out with a decent lint like thing for ruby. I think it's needed.
&gt; Maybe you are right. Maybe Ruby is not the language for me. Having said that I said "optional" typing which would give you the freedom to use or not use strong typing. That's fine if you're the author of all your code, and also are the code's sole user. But the last thing in the world I would want is to have the ecosystem of libraries I rely on turned into a mismash of typed vs. non-typed Ruby code.
This is one of those great ideas with lots of wicked side-effects that make it poisonous. It is only superficially beneficial. It's the equivalent of a [COMEFROM](http://en.wikipedia.org/wiki/COMEFROM) on a method level. 
&gt;But the last thing in the world I would want is to have the ecosystem of libraries I rely on turned into a mismash of typed vs. non-typed Ruby code. Why not? Currently none of it is typed. What possible harm would it cause if some of it was typed?
What would be a simpler solution, is to make String, Integer, Array, Hash etc sub-classable (I am told that many of the core methods directly call other C methods). If people want to add or override behavior on core Classes, just in the context of their library/app, let them use inheritance.
&gt; Just like with monkey patches, you have to examine all the internals of a library to understand it. When you define "understand it" do you mean * "Understand how it is implemented and work internally", * "Understand how use its API" * "Understand how it affect other class you use". The first two points are always going to be there in any library of any programming languages. And, no, refinement is not going to be a silver bullet that remove the need to ever have to understand how to use a library. The third one is the problem with MonkeyPatching because monkey patching inside the library affects class outside that Library. This is what refinement is supposed to solve, refined behavior is only visible in context of the code that use the refinement. And refinement isn't even supposed to solve every thing about Monkey Patch. There're two reasons to monkey-patch. The first is to override or patch an *existing* functionality of a class. This is not something that can be solved with refinement, because you do want this patch to affect outside your own source code. The second reason is to extend *additional* function to existing class to make intuitive DSL (`1.days.ago`, `string.to_json`, `object.should.be_valid`). This is what refinement is perfect for. You can add `Integer#seconds` if it makes sense in your scope of DSL while still be able to use Rails' `Integer#seconds` in other places where those words is more fitting. Or you can have `Integer#pm` in part of your scheduler DSL but not have it pollutes any where outside that at all. &gt; Refinements are a feature based largely on fear. Ruby's culture has a lot to do with custom DSL to make programming fun and intuitive. Refinement is a perfect way to make sure that such Domain-Specific-Language only stay inside its domain. I would say it's based largely on being able to have nice DSL again.
I agree with everything he says except that unpredictability of conflicts is a 'tooling problem'. I think it is a language problem -- the beauty of ruby is that you _don't need_ any fancy tools to write good code (unless you consider rubygems/bundler tooling, maybe). There ideally ought to be a way to solve this problem with language features. But it's not clear that 'refinements' is the way to do it, it may be a cure worse than the disease.
Because you might have good reason to give a library method an object that isn't typed appropriately, but acts appropriately. Occasional typing restricts that kind of freedom. And even with typing, method lookup is still going to be weird and circuitous. Rack, for example, is powerful not because it restricts what kind of object is returned fot the body by an app's call method, but because it only asks that it responds to #each. If it insisted on an Array, we'd lose wonderful possibilities.
I was going to respond to you above, but I'll just put it here. :) First of all, re-reading my response, I kind of sound like an asshole. My bad. I typed that out pretty quickly. I agree with LegionSB. I don't want to see the proliferation of this either. I think we'd all agree that this method is poorly written: def foo(bar) case bar.class when String then "string" when Array then "array" end end Restricting your code based on types is just bad. It makes things inflexible. Optional typing feels exactly like this. It's not Ruby code, it's something else that's much, much worse. `kind_of?` is a code smell. `is_a?` is a code smell. `responds_to?` is a ... weak smell. But still a smell. It goes against pretty much everything that the language philosophically stands for.
Oh, I love that you don't need any fancy tools to develop in Ruby. I'm quite happy with my vim with only command-T installed... But since people are scared of this kind of conflict, imagine some sort of lint tool that could run some code and say 'yeah, we're like 95% sure that these two libraries won't conflict.' Or maybe a warning mode that's like "Hey, String had this method redefined, you _probably_ don't want that." I think that'd go a long way towards making people feel better about these kinds of things.
I think that overall, monkeypatching is a bad idea. It's not something we should encourage. It's useful at times, but its danger is part of the natural checks and balances that encourages its use. Refinements are a big change, and frankly, I don't think that encouraging people to just add stuff on to classes is a good idea. I _want_ that to be dangerous. It keeps it in check. It's also almost 2am here, so I may not be making a great argument at the moment. ;)
One very common mistake jumped up right in the beginning. In ruby x ||= y does not mean x = x || y. It means x || (x = y)
That only work if you also control the creation of the object. MonkeyPatching and/or Refinement is needed because you want to add functionality to the object that you didn't created.
The code smell you describe exists because of the shortcoming of the language. In other languages you have function overriding or pattern matching so you can do this. def foo(String bar) ... end def foo(Array bar) ... end If you were to use a language with pattern matching you would even get much more sophisticated for example in erlang (stolen from the web) -module(even_prime). -export([is_even_prime/1]). is_even_prime(2) -&gt; % clause 1 is simple true; is_even_prime(N) when is_integer(N) -&gt; % clause 2 has a guard: is_integer(N) false; is_even_prime(Any) -&gt; % clause 3 is simple 'I prefer integer inputs'. There are a couple of old pattern matching gems for ruby http://www.artima.com/rubycs/articles/patterns_sexp_dsls.html http://blog.objectmentor.com/articles/2009/03/16/tighter-ruby-methods-with-functional-style-pattern-matching-using-the-case-gem This is a common enough requirement that most static languages provide a way of overloading methods and most functional languages provide pattern matching of some sort or another. Personally I would love to see this in Ruby. You could even do it like this. def foo (a responds_to :doit) .... end def foo( a responds_to :other) ... end I am no language designer and maybe something like that would be difficult to implement or slow the language down even more but I submit that the need exists which is why most people have written a case statement like you have above. 
&gt;Rack, for example, is powerful not because it restricts what kind of object is returned fot the body by an app's call method, but because it only asks that it responds to #each. If it insisted on an Array, we'd lose wonderful possibilities. Why couldn't the function signature be based on an interface (Iterable) or even a responds_to? That's how other languages work. Why can't there be guards like erlang? Think bigger. Ruby can take the best of other languages if the community sees fit. 
I'm sorry but I dont understand what you are trying to say. 
Not sure that we are experiencing issues as much as, rubyists we are on a constant search for a much sexier, simpler solution. Rbenv nails this on the head. Plus, I never understood gemsets after bundler hit 0.8-stable
Upvoted for having a single sentence definition of monad that actually makes sense.
"And they have not offered their generic, non-Mac-based improvements back to the mainline." This is implying something weird. MacRuby is open source, isn't it? Anyone is free to take their improvements and port to mainline. What they haven't done is spent _their own time_ doing so. This is significant time. They choose to spend their time elsewhere instead, focusing on MacRuby. This is nothing but the common open source complaint: "Someone else is spending their precious time on what's a priority for _them_ instead of on what benefits _me_!" That's just how it goes. You can try to convince them that they could get just as much done with added collateral benefits if only they switched to writing OS-neutral C code instead... but chances of success seem limited, odds are you have a better way to spend _your_ time. 
Of course. What the MacRuby developers do is their prerogative. It is also my prerogative to provide constructive criticism even if I am not directly contributing to the development. All I said (and I don't know why I keep having to repeat myself since I think I've already expressed it quite succinctly) was that it was a missed opportunity to improve the Ruby world for *everyone*. Am I thinking too altruistically? If I forked Ruby and did some improvements that were useful to everyone using Ruby, but I tangled my code with some other stuff so that it could only be used by, say, Windows users, then I would feel pretty stupid. (Not saying *they* are stupid. But *I* would certainly kick myself for doing things that way.)
Your blog is awesome by the way. Keep the goods coming.
Thanks a lot! I've got a few good things coming, but if there's anything you want to hear about, lemme know!
&gt; In other languages you have function overriding or pattern matching so you can do this. Right. But the problem is, writing code like that is _bad_. I don't want to have code that's based on the type of object. _Maybe_ structural typing would be okay. (And I'm actually a big fan of pattern matching in statically typed languages, but _not_ in Ruby.) Here's the problem: def foo(bar) bar.baz end This method works on _anything_ that responds to baz. Restricting it to some arbitrary type makes things inflexible. What happens when I have the case (or even pattern matched) method above, and I want to test it? I can't substitute a mock object, because I've tied the method to the type Array specifically. Maybe this would make for a good blog post.
Nothing specific no. I like the emphasis on the language design and the ways to make things consistent, solid and elegant in general. The bit on presenters especially was very good. I wish Rails would integrate those ideas and get rid of the whole idea of procedural-style helpers altogether. It's really a turd in the sandwich now isn't it?
Totally. We'll see how popular draper gets...
On the other hand, if I tried to make everything I wrote as maximally flexibly abstract as possible to be as useful in as many situations as possible, and as a result never finished anything stable enough to actually use, I'd also feel pretty stupid. Sometimes we don't have the time to do it perfect, or as 'right' as we might like. I figure when something's open source, if you've got someone saying "Okay, I think if you switch to doing things like _X_ then it will still work out nice and maintainably _and_ have these extra benefits for additional contexts, _and_ I've got time to help you do it, look here's a simple patch starting down that path", and the core developers _still_ say no, then you can fault em for it... and then that someone(s) saying that can fork too. So if there was someone offering to spend time making MacRuby code the way you say, or spend time porting things from MacRuby to other implementations, and the developers of MacRuby were uninterested and/or obstructionist, that'd be one thing. But barring that, I'd assume that it's not stupidity or even lack of interest, it's that other people just don't have the extra time to do things the way you'd like. Sort of like Merb and Rails. And then eventually someone had the (serious) time to do something about it (mostly Yehuda, as I understand it) and get the best of both worlds (or at least try to do so in a way that both sides agreed was worth trying and just might work), and Rails 3.0 happened. 
Maybe. I don't know the details, and I'm not going to speculate. I am, again, not criticizing the developers, I am stating (and regretting) the status quo. A comment on the topic of spending time: The Ruby community has always suffered from developers being fickle. Ruby developers love chasing new and pretty things; too little time is spent bringing code to polish; too little time ensuring stability, backwards compatibility, bug fixing, catering to an existing user base. And way too much time spent creating new projects instead of faithfully serving old ones. The process has benefits (lots of interesting and fun invention going on), but the drawbacks are pretty severe (everything is in a flux, everything is unfinished and buggy, goalposts move all the time). So if it's something we can do as a group, it's to spend more time where it's wise to spend time, and less time chasing the shiny.
&gt;Right. But the problem is, writing code like that is bad. Really? It's endemic in Java, C#, C, C++, and just about every functional language. In fact it's probably not possible to write code without function overloading in most languages. Why would you claim it's bad? &gt;Restricting it to some arbitrary type makes things inflexible. What happens when I have the case (or even pattern matched) method above, and I want to test it? I can't substitute a mock object, because I've tied the method to the type Array specifically. Why would you need to test passing non array objects to methods that want an array. Those things are caught at compile time. &gt;This method works on anything that responds to baz. At the cost of unpredictability. What happens when you pass in an object that doesn't respond to baz? Since the language does not prevent you passing in something that doesn't respond to baz maybe you need to put a guard in there. def foo(bar) raise "can't baz #{bar}" unless bar.responds_to? :baz ... end Ooops code smell... For another example take HashWithIndifferentAccess . Here is the default method # File lib/active_support/core_ext/hash/indifferent_access.rb, line 15 15: def default(key = nil) 16: if key.is_a?(Symbol) &amp;&amp; include?(key = key.to_s) 17: self[key] 18: else 19: super 20: end 21: end how about this # File lib/active_support/core_ext/hash/indifferent_access.rb, line 113 113: def convert_value(value) 114: case value 115: when Hash 116: value.with_indifferent_access 117: when Array 118: value.collect { |e| e.is_a?(Hash) ? e.with_indifferent_access : e } 119: else 120: value 121: end 122: end Boom code smell right? The problem is that you want to take advantage of the fact that ruby doesn't check the type of the function params and take different types of objects but since you can't overload the function and since you don't have pattern matching you end up with statements that checks the type. How much nicer would that code be if you could have pattern matching? This is very commonplace in ruby code. &gt;Maybe this would make for a good blog post. Before you make a blog post I would urge you to examine how pattern matching and function overloading works in other languages and how those people test their code. Duck typing fine but one side effect of duck typing is that you have to check your types manually if you want to build robust code that gives sane error messages.
&gt; Really? It's endemic in Java, C#, C, C++, and just about every functional language. Sure. But Ruby is none of those. You're writing Ruby code that feels like Java. That's what I'm trying to say. &gt; Why would you need to test passing non array objects to methods that want an array. Those things are caught at compile time. Mocks, for example. it "baz-es the argument" do arg = double.should_receive(:baz) foo(arg) end Also, any sort of generic operation that works across types. I've written presenters that work on _any_ collection that supports `each`, for example. &gt; What happens when you pass in an object that doesn't respond to baz? You get a NoMethodError. &gt; maybe you need to put a guard in there. Nope. This is fearful coding. Let errors bubble up, and handle them somewhere else. [Confident Code](http://avdi.org/talks/confident-code-railsconf-2011/) is better. &gt; How much nicer would that code be if you could have pattern matching? It wouldn't. Both of these methods are poorly written, in my opinion. &gt; Before you make a blog post I would urge you to examine how pattern matching and function overloading works in other languages and how those people test their code. I have years of experience developing in statically typed languages, I know exactly how it works. This is why I originally said "maybe Ruby isn't the language for you," you're bringing your statically typed mindset into a dynamically typed language, and it limits your ability to write expressive, well-designed Ruby code. It might be awesome Java or C++ code, but it's not good Ruby.
HashWithIndifferentAccess. That's all I have to say actually.
Steve, Bar has a type in the function you've given. That type is the set of all classes in the program's dynamic context which successfully respond to `#baz` with no arguments, either by implementing `#baz` or by overloading `method_missing` to not raise in the case of `:baz`, no args. "Type" is a broader concept than you have allowed for in any of the posts I've seen you make in this thread.
I mentioned structural typing above. Ruby doesn't implement it, but there could be an underlying type, sure. Duck typing and structural typing are very similar.
There *is* an underlying type. It's not enforced *statically* by the Ruby runtime, but there *is* a type. Not "could be an underlying type." And that type is also trivially inferable, and for most real-world programs, meaningful conclusions can be drawn from that inference. I don't propose changing the language at all. It's just sad to see so many Rubyists who don't understand that their programs have types in them already even if they don't write them down in every method signature. It's even more sad to see people reject the potential that real analysis could achieve because of that overwhelming fear of the very idea of types in the Ruby community.
I feel like we're getting into philosophy here. If you could make a type out of it, but the interpreter doesn't know about it, is there really a type? Honestly, I know a lot about type systems. I love Ruby, but my second favorite language is haskell. But removing duck typing creates a language that is _like_ Ruby, but _isn't_ Ruby. Other languages are fine! I use them when they make sense. But duck typing is central to Ruby's identity.
&gt; If you could make a type out of it, but the interpreter doesn't know about it, is there really a type? &gt; &gt; Honestly, I know a lot about type systems. You may know type *systems* but you evidently know the first thing about type *theory* if you think a type might not exist if an interpreter doesn't know about it. It's not philosophical at all. Types are constructions rooted in mathematics/formal logic that do not require a particular programming language or implementation to realize their existence.
so....now your argument is just "we shouldn't allow refinements because that would encourage ppl to monkeypatch, and monkeypatching is bad mmmkay and if they do that they should be punished like they are currently" pretty weak. the whole REASON monkey-patching is bad CURRENTLY is because they have global effect - if we get rid of global effect they're not so bad. Refinements get rid of global effect. Also, if a class uses refinements internally that's an implementation detail to that class - you shouldn't have to 'reason about it' and it should be irrelevant to a consumer of that class whether that class uses refinements or not. THe current situation is shit -- a class leaks its implementation details out to the world by its monkeypatches to core classes having global effect.e
Matz is supporting refinements - so you're saying Matz doesn't get the point of Ruby? What is your specific grievance against refinements? I don't think refinements go against the spirit of Ruby at all, i like them a lot actually.
"If you make it easy people will use it any where" Now that's what I called proposing/refusing features *based on fear*. 
How about optional typing based on 'respond_to?' ?
As I said elsewhere, structural typing and duck typing are very close. But this is a significant change, and if you added it to Ruby, you wouldn't get Ruby anymore. Duck typing is a core part of Ruby's identity.
&gt; now your argument One portion of my argument. &gt; if we get rid of global effect they're not so bad. Right. I want to keep it dangerous. &gt; you shouldn't have to 'reason about it' I do a lot of open source work. I look at other people's classes all the time. Also, within your own codebase, if you have two classes that refine String differently, and you switch back and forth between them, you still have to remember how each was refined there. Refinements don't just let you forget about things. &gt; THe current situation is shit -- a class leaks its implementation details out to the world You don't currently 'leak details out into the world', what we call 'monkeypatching' is a side effect of Ruby's open classes. It's one of the best features of Ruby, and falls out naturally from its object model. Maybe you meant a _library's_ implementation details, but often, libraries expressly _want_ to share those patches with everyone else. Refinements or no, ActiveSupport, for example, doesn't change, and you _still_ have to pay attention to these changes.
&gt; you evidently know the first thing about type theory if you think a type might not exist if an interpreter doesn't know about it. See above where I said I felt like getting into philosophy? This is similar to the 'if you don't compile some source code, is it really a program?' kind of argument. By making types concrete instead of abstract, you change the way that the language works, feels, and how we write code in it. Duck typing is core to Ruby's identity, and changing it to structural typing, while maybe mathematically equivalent (you still couldn't do it statically...), changes the very core of the language. You may get something that looks like Ruby, but it's not Ruby any more.
what was the other portion of your argument? I read your post on ruby-forum and can't see much of an argument (unless you're just referring to your 'it hurts performance' point). If i were you i would wait until Brixen officially makes his case before commenting any further - i'm quite sure that his arguments (whatever they may be) must be significantly stronger than the arguments you've presented. One particular thing curious about is how an object that was refined in one scope (with one definition of String for example) behaves when passed back to another scope with its own (and different) definition of String - i can possibly see some confusion/ambiguity there.
Duck typing still doesn't work if you don't quack like a duck. Optional structural typing can be done at run time as simple as: # x must respond_to? :bar and :baz or this throw Exception when called. def foo(x &lt; [:bar, :baz]) ... If you passed in some x-like object that doesn't respond_to `:bar` and `:baz`, then it's going to fail any way. The only different is this optional check can force fail-fast behavior. This optional structural typing check at run time only help you make sure you quack like a duck, it does nothing un-Ruby or force you to actually be a duck.
Totally. I'm not saying it can't be done at runtime, but it seems like many here want it to be something that's done statically, for 'safety' reasons. I also fail to see the difference between a runtime NotStructurallyTypedException and a NoMethodError. There's no real benefit here.
It's an excellent lay-person way of describing it. Though in the context of Ruby, perhaps Monads are better described as chaining *statements*, as not every computational step in Ruby is a function call like it is in Haskell.
I really don't care what actual Exception class is thrown, it could be NoMethodError if you think that that gives meaningful meaning. The difference should be in *when* the exception is thrown. NoMethodError probably fire when it is used some where in the middle of the method, while NotStructurallyTypedException will be raised before one line of that method is execute at all (which means it's checked when the method is invoke). 
For some reason I thought this too, but it's wrong. Evidence: def xxx; 100; end xxx ||= xxx What do you get? nil. Then define yyy and try: yyy || (yyy = yyy) What do you get? 100 Finally with zzz try: zzz = zzz || zzz() 100. Why? Because ||= creates the binding to xxx (shadowing the function call) *before* evaluating xxx. Ruby knows &amp;&amp;= and ||= are assignment operators and treats them specially.
Corresponding pull request is https://github.com/ruby/ruby/pull/51
I'm sorry, I accidentally a word - you evidently *don't* know the first thing about type theory if you think a type might not exist if an interpreter doesn't know about it. So yeah... no philosophy involved. And types *are* concrete in Ruby right now. All type reasoning in Ruby tools and implementations occurs with respect to the concrete type of values. Surfacing a way to communicate abstractly about these types and reason about them is what I think is a good thing, and to do so doesn't require static enforcement or changing the language at all. Laser presently does all of its analyses based on conservative estimates of concrete types, but small changes to consider these abstractly inferable types would improve its results dramatically when concrete types are completely unknown (e.g. the result of a call to `const_get`). I'm not sure any of what you said really makes any sense to me.
&gt;I also fail to see the difference between a runtime NotStructurallyTypedException and a NoMethodError. There's no real benefit here. You know exactly why NotStructurallyTypedException was raised and you know that it was raised before the method was ran and possibly modified the state of the object. The NoMethodError could have been raised by any line in your method and any number of states could have been impacted. I know what I prefer. 
is this useful to anyone? what's a use case?
??...Do you feel in love??...lol
"Why don't we just generate some happy little models... there we go, happy little models"
The man is a great contributor for the improvement of the careers of many people. Thanks Ryan!
Why isn't loaded_features a constant time lookup data structure, like, oh, I don't know... a hash table? Make the thing a Set and it will be fast and still respond to all the methods the old Array did. Does anything care about the order of loaded_features? Should it?
I'm sure I'm not the only programmer who, when I need a quick jolt of "how does this particular gem/feature work" does not google for the apidoc or for the tutorial or example, but for the Railscast. If you've got an idea for a site, you could bring that site to production with nothing more than Railscasts to teach you. 
I sent him a link to this.
Why thank you, kind sir.
wrong
"Lets put a monkeypatch riiiiggght there... It'll be our little secret."
Erm... who's the guy on the right?! Is he the guy they call "god" in peepshow?
I have no clue who the painter is but assume it is the Ryan Bates of painting so my upvote is to you.
Wow, I read about this in a book. Didn't know it was real.
Due to Bob Ross's seniority in life, I believe that Ryan Bates is the Bob Ross of Rails, rather than Bob Ross being the Ryan Bates of painting. **TL;DR:** Yes.
It would be hard to make loaded_features a hash table or a set, cause it saves full file path (/usr/local/lib/.../gems/tom-1.2/lib/tom/bum.rb) and require could be called without path or extension (`require "tom/bum"`). Binary search is still rather fast: with 100 required already files it does 9 string comparisons, with 1000 required files (small rails application) it does 12 string comparisons, with 10000 files (I think, it is very big application) it do 15 comparisons (instead of ~10000 :) ). That is already huge saving gained by just 84 added lines of code and without any change to underlaying data structure. It seems that no one cares about order of loaded_features. If one does, I will be not able to produce this patch, cause it apply very strange order :) But my rails app load without error, so that all done right, I think. 
Go sign up for Pro. http://railscasts.com/pro The first episode was great and the revisions are nice to have as well. Worth it if you really are serious about Rails.
Bob Ross, and yes.
You've never had an intermittently failing production system, have you?
Oh hey .. it just started .. just one episode? but a new one every week?
how does this thing help with that, just curious (not trying to be rude)
oh my god. you don't know about Bob Ross? Dude had the most relaxing videos of him painting ever. Happy little clouds... Find videos of him, you will be mesmerized
I'm disappointed with the number of people in this thread who don't know who [Bob Ross](http://www.youtube.com/watch?v=raXanYjTF18) is :(
One "regular" episode and one pro episode every Monday, and then revision episodes every so often.
I'm not American
I'm shocked he doesn't charge for his weekly episodes already. I pay for the Destroy All Software screencasts and I now gladly pay Ryan for his Railscasts.
oh. ok. well he's cool lol (although he's RIP)
Yea, I feel the same way. He mentions his 'real' job every so often, so I guess he's doing ok, but these are such a huge help in keeping up to date and aware of everything happening in the field that I'm more than happy to support his efforts. 
Even in Haskell it's sorta glib, but explaining the difference between a computation and a function was a digression I didn't feel like engaging in. 
You're correct, but that only demonstrates how the ruby compiler handles identifiers when it encounters the ||= operator, not how it evaluates the operator, which is the other side of the equation (pun intended). Let's observe the following session in irb: ruby-1.9.2-p290 :007 &gt; h = Hash.new(0) =&gt; {} ruby-1.9.2-p290 :008 &gt; h[:foo] ||= 1 =&gt; 0 ruby-1.9.2-p290 :009 &gt; h =&gt; {} ruby-1.9.2-p290 :010 &gt; h[:foo] || h[:foo] = 1 =&gt; 0 ruby-1.9.2-p290 :011 &gt; h =&gt; {} ruby-1.9.2-p290 :012 &gt; h[:foo] = h[:foo] || 1 =&gt; 0 ruby-1.9.2-p290 :013 &gt; h =&gt; {:foo=&gt;0} See the difference? The ||= operator in x ||= y only executes the assignment if "x" evaluates to non-nil, whereas x = x || y always executes the assignment. In the demonstrated case, the wrong way of interpreting the operator creates a new key in the hash whereas the actual operator doesn't.
Mumbo, perhaps. Jumbo, perhaps not! See answer to previous poster :)
Interesting. I'd honestly call it a bug in ruby though, an attempted optimization that went wrong, if "x ||= y" is not the same thing as "x = x || y". x += 1 ===&gt; x = x+ 1 x ||= 1 =/=&gt; x = x || 1 # bwah? What I think you demonstrate is such odd behavior that I wonder if it is in fact consistent over all ruby implementations. Although I'm having trouble following your code, need to play around with it a bit myself. 
omg i had no idea pry was this awesome
Pry is advancing by leaps and bounds. This is great.
irt? irt it is
Yeah. I suspect that refinements would encourage people to alter core classes, rather than subclassing them.
You can always make your subclass provide a method to convert the superclass, so you can mystring = MyString.new(string) before doing all your work on it.
Pry is awesome .. I met the developers on irc, and they gave me a quick and helpful rundown - sold right there and then and use it daily. Long live pry!
Pry is sick. Personally I love that you can just add require 'pry' binding.pry in any function and you get an awesome syntax highlighted irb session/debugger right there.
Yeah, I didn't get to that. I wish I did, Pry offers some really nice debugging options. Josh Cheek goes over that aspect of Pry in his introductory screencast. Link is at the bottom of the post.
1. That's cumbersome if instead of `string`, it's `x` (think duck typing) that some already have that needed method while some doesn't. You can have a factory that create `MyInt`, `MyString`, `MyHash` depending on type but may be that's getting uglier. 2. That also may not work if your code is only passing along the object to be used somewhere else. 3. It's hard to get right and keep thing consistent if some code still get a hold of the original object while yours have the wrapped one.
Pry is the best REPL I've used, hands down. So much power!
Some synthetic benchmark: https://gist.github.com/1278881
True. Although, it's all moot. All we're doing is using the behavior of ||/&amp;&amp;= to defer evaluation of a statement until a condition passes, lazily and without the extreme overhead of a block.
One thing that was a big hangup for me getting started testing was that every post I seemed to read would add on too many "if's". If you want to...then use rspec. Or if x, then Cucumber is an option. And for mocking objects try this, or this, or this. I just needed someone to sit down with me and say: "This is how to do it" without going into all the different options/frameworks. I finally got that, and I'm not looking back. It's one of the few places in the Ruby/Rails world where there are so many ways of doing it that in the end, the community standards are hazy for newbies.
agreed 100%, this has been a problem for me too, in ruby/rails. 
Maintainer of Pry here, glad to see all the positive feedback! Pry is looking for sponsorship, if your company would be interested in sponsoring Pry please contact me [here](https://github.com/banister). Sponsorship money will primarily go towards improving the website and pushing out new screencasts. 
I'll put that in the post. Thanks for all the hard work. ^_^
&gt; Interesting. I'd honestly call it a bug in ruby though, an attempted optimization that went wrong, if "x ||= y" is not the same thing as "x = x || y". &gt; What I think you demonstrate is such odd behavior that I wonder if it is in fact consistent over all ruby implementations. It is indeed not a bug and is actually required behavior over all ruby implementations. RubySpec [variables_spec.rb](https://github.com/rubyspec/rubyspec/blob/master/language/variables_spec.rb), line 760 (in the current git version) says: describe "Conditional operator assignment 'obj.meth op= expr'" do it "is equivalent to 'obj.meth op obj.meth = expr'" do And again, at line 938: describe "Conditional operator assignment 'obj[idx] op= expr'" do it "is equivalent to 'obj[idx] op obj[idx] = expr'" do (edit: formatting)
I was expecting some content, good initiave anyway.
Tip of the hat to Jesse.
I'm working on it. I wouldn't consider the site quite ready to go yet but I plan on adding content daily. I'd gladly accept pull requests ;-)
Well perhaps not as suitable for intermittently failing, but perhaps for a problem that can't be replicated in dev/staging, due to some sort of environmental problem. Being able to debug running systems on non-local servers has been something that's been very useful in the Java (and I daresay other) worlds for a long time now
You might like [my article on BDD](http://timelessrepo.com/bdd-with-rspec-and-steak).
This is a pretty good quick start for beginning to write your own gems. I did a talk on this a month or so ago, more rubyists should know just how easy it is :)
Thanks. IIRC Yehuta Katz also has written a blog post a year back or so. A couple years back it was difficult to get this out of the docs. I've been using "jeweler" for a year or so and its great. Its tied in with "git". Katz' blog has a lot of links about gems and bundles, so i can't find the link. 
you need s.author in the gemspec as well. Or at least i did with gem 1.8.11
:D I am super happy about this. I'm a SysAdmin at the Engineering school of a public university and we have been looking for something like this for a while for our students. I tried hacking on Gitorious, but it is a *nightmare* to get setup. Seriously, you have made my day.
The "All for what you so love github - on your server!" was incredibly difficult to read for me. Cool product tho. Problem is that you really just want this if you only care about git, not the many features of github. We use pull requests like we breathe air over here, so I'm not sure this would work. They're constantly evolving their product, too bad running GH on your personal servers is cost prohibitive.
Agreed. Pulls and forks.
Why not use the real github on your local network? http://fi.github.com/
All the promise of gitorious with seemingly much less hassle. I'll try it out.
GitHub:FI Subscription Pricing starting at $5,000 per year
Github:FI is proprietary (can't change or fix it to your liking) and costs money. Depending on your point of view that could be an advantage or disadvantage. Some companies don't want to rely on 3rd parties for something as critical to their business as source code.
linode with $30 is enough. Also in some companies policy doesnt allow to host project code on non company servers - it will be a solution
That's why Github:FI exists... For those who can afford it anyway.
Super expensive (as much as I would love to get it).
I see this uses Gitosis. But Gitosis is practically an abandoned project, and many of us who used to use it have moved over to Gitolite, which improves on Gitosis and is actually maintained. I would like to see this updated to use Gitolite.
oh the irony of hosting the source on github...seems like a perfect opportunity to host the code on an install of the code, no?
Trying to figure out if it lets me view and diff branches... when looking at code, there's a popup menu that says "Master" with a second choice "Branches"... but choosing "Branches" causes a spinner and page reload, and nothing else, I still seem to be looking at the same thing I was before, master. ?
i want to rape you and drag you through the grass
Apparently they are self hosting, but just publishing releases to github. Also versions 1.1 is due on 10/22 with a bunch of fixes and stuff. http://twitter.com/#!/gitlabhq
https://github.com/gitlabhq/gitlabhq/issues
Anyone care to elaborate on the scalability of resque that the article misses? In particular a comparison to DelayedJob would be good
When I saw this I was all: http://www.youtube.com/watch?v=Ez7ePZR4S8U&amp;feature=related
You already have a database. Why install another database just to keep track of your background jobs. I don't get it.
Well you could use something like ohm and ditch ActiveRecord, hence going a redis complete backend
Why is this better than Sinatra?
Because databases are not silver bullets. Not even noSQL databases. Each one has a task at which it excels, and Redis was the right choice for a work queue. Specifically, Redis offers built-in support for list and set datatypes, which are exactly what work queues are.
http://news.ycombinator.com/item?id=3113818
In particular, check out [Renee Concept](http://reneerb.com/concept). All of us are big Sinatra fans, but we felt that the concept of a simple DSL could be taken even further. With Renee, we feel that routing is much DRY'er, and that it gets you closer to the "metal" of Rack. Renee allows you to describe your routing in purer Ruby. We have eliminated the need for "filters" and "params" because we use simple blocks and scoped local variables as a more intuitive way to handle requests. We feel this is DRY'er than the Sinatra representation. It also has nice integration with Rack itself. The implementation is very simple, easy to get into. We think the combination of clearer routes, leaner code and url generation makes renee a fun alternative.
&gt;Specifically, Redis offers built-in support for list and set datatypes, which are exactly what work queues are. Postgres also has those. 
The routing is ...one variable arguably dryer, at the cost of an explicit block. No sale.
There's already a community resource for this that explains the whole process more thoroughly: http://guides.rubygems.org/make-your-own-gem/
If all you see from our site is that the syntax is one variable dryer, then we clearly need to improve the site. We've taken an iterative pass on making the site more clear. The idea is that through logical scope and block grouping / nesting, you can express your web routing in a new and much easier way. 
right -- at the cost of an explicit block, you get to make a variable arguably dryer, as I indicated previously. Actually, it's not just the explicit block cost; it's also loss of plugins, frameworks, and documentation. additionally, there's the longer term hidden cost of moving away from a perfectly good framework under constant improvement by a large team and in use by thousands of active web projects, in order to move onto an untested framework with apparently 1-2 active committers. I'm seriously scratching my head why anyone would try to outdo sinatra in the microframework space while changing only enough for existing code to break. Maybe you could use your admirable design chops for good, by solving a problem that has not already been solved?
&gt; Maybe you could use your admirable design chops for good, by solving a problem that has not already been solved? Or maybe they just felt like building the web framework they wanted? Christ dude, there's plenty of room for alternatives in the world; not everybody has to like or want or need the exact things Sinatra offers in the the exact way Sinatra offers them.
Got it; thanks!
Yes, we have all worked extensively with Sinatra and know it very well, have contributed to it, part of the community, etc. I am not sure that working with and appreciating Sinatra precludes us from having some fun, starting with a clean slate, and experimenting with a new style that has some advantages. Since Rack middlewares all still work, I have a hard time finding examples of functionalities that you can't get working with a suitable Rack based library like Renee. Also of course there's a tradeoff in anything, but we don't see the blocks as a significant cost, but as a better way to express logical groupings within a web app. We aren't asking people to abandon Sinatra (far from it, we are all active core committers to Padrino), but there are people like us that like to have some fun, try new libraries, and maybe help contribute back to open source and other projects in the process. Renee exists for this reason. If you don't like this then by all means, feel free to ignore the project.
I think the nesting is potentially better. It provides the right scoping for variables that you want to share between different things. 
Yes I think you are beginning to see why we decided to play with this concept. Basically use blocks, nesting and local variable scope as a way to remove the need for "artificial" constructs like "/:id" in the path, filters, and repeating the same paths over and over. 
{0,} is EXACTLY the same as * in a regex. What you probably want anyway is ? which matches 0 or 1 of the preceding atoms. The way you have it currently, this is valid: I don''''''t always write regexp but when I do they break
Hmmm. Not sure if that still counts but thanks :)
Not valid ruby :( Needs some commas after each meme/regexp for hash syntax, ie @memes = { # "a wild ruby library appears" :pokemon =&gt; /a wild (.*) appears/, # SNIP # soon :soon =&gt; /soon/, # Y U NO? :y_u_no? =&gt; /(.*) Y U NO (.*)?/ }
no prob! I live to correct other people's regular expressions...
Yup. A little disconcerting that the program has clearly never been tested.
Thanks! I'm still just compiling regexps. Not running actual code at this point. I will soon start writing tests when I choose the appropriate testing tool.
Advanced Doing It Wrong with jQuery.
A better title might have been "Hey /r/ruby, I'm putting together a library to identify memes by regexp. Help me expand it!" Managed expectations and all that. re: testing, just choose a tool, and go. This is a low impact of enough library that it's not going to matter a ton which you choose. Heck, forsake testing tools, and make a ruby file that just uses consumes the library and spits out output, and run that.
The original post announcing resque has "great background information":https://github.com/blog/542-introducing-resque on GitHub's experience with various background workers, and how they arrived at resque. Of particular relevance: &gt; We used DJ very successfully for a few months before running into some issues. First: backed up queues. DJ works great with small datasets, but once your site starts overloading and the queue backs up (to, say, 30,000 pending jobs) its queries become expensive. Creating jobs can take 2s+ and acquiring locks on jobs can take 2s+, as well. This means an added 2s per job created for each page load. On a page that fires off two jobs, you're at a baseline of 4s before doing anything else. &gt; &gt; If your queue is backed up because your site is overloaded, this added overhead just makes the problem worse.
That sounds terrible. Are you sure that's all you have to live for? Maybe you need a friend, I'll be your friend! WHOO! RUBY FRIENDS FOREVAR!
What's the right way?
MAN, I am totally not going to use this in production now.
Four-Oh-Four
I'm sort of amazed that you don't see a space between Rails and Sinatra for a new web framework. Rails was written in a pre-REST time, and as such, the RESTfulness of it has always been a little bolted on. The ability to nest routes and controller logic is certainly novel, though entirely doable within the context of Rack. The point of Renee is to make building Rack apps non-tedious. Also this "one variable dryer" bit. I'm not sure where you're coming from. By eliminating the path being repeated three times, that's certainly more dry. Also, your last paragraph, while being gauche also manages to completely miss the point. No one is aiming for backwards compatibility with anything, so I don't see what the "existing code breaking" point you're trying to make is.
It works now and is using rspec thanks mostly to another redditor. I'm thinking about using the meme_generator gem to enable automated meme rendering.
hmmm :( shouldn't have linked directly to the memes.rb file
symbolic link 
I think [kramdown](http://kramdown.rubyforge.org/) can also convert markdown to PDF, although never tried it.
I HAVE NOTHING LEFT /jumps into computer
NO! NOT RUBYFRIEND! NOOO
Error 404; Ruby not found.
I'm glad I could save someone the wasted effort.
Upvoted primarily because I want to have Russ Olsen's baby. It'll have a &amp;block for a head or something, but I will love it just the same. 
Or just do this: PDFKit.new(((Nokogiri::HTML(Redcarpet.new("### Ruby Code\n\n~~~.ruby\nputs \"Hellow World!\"\n~~~", :no_intraemphasis, :fenced_code, :gh_blockcode).to_html, :page_size =&gt; 'Letter')).search("//pre[@lang]").each { |pre| pre.replace CodeRay.scan(pre.text.rstrip, pre[:lang]).div }).to_s).to_pdf Piece of cake, right?
Have a look at here as well: http://programmingzen.com/ruby-and-rails-recommended-books/
Cheers, good article
aw, I'm sorry! What I meant to say is that every framework is precious, and all must have prizes!
&gt; People expect you to use bundler and I don't know any alternative Agreed, I think it's because it makes our lives easier in helping understand and manage your dependencies. &gt; Why is it a separate tool from rubygems ? The difference of role between the two tools is subtle and not easy to understand. I have the impression that there are ego battles occurring and that pisses me off Because it is not rubygems. I see it as distinct enough in its use case that it deserves its own executable. Edit: It isn't a replacement for rubygems. It compliments it with functionality to manage and support sets of gem dependencies for a given project. &gt; It takes over rubygems gem management I don't see it as taking it over, I see it as supplementing and simplifying the process. rubygems is for managing installed libraries and using them within your code. Bundler is for managing sets of libraries for given applications. &gt; This last point is really what cause me problems (maybe because I don't understand something). You cannot have two separate bundler aware applications running under the same ruby process. Because you don't have two separate bundler aware applications running under the same ruby process. You have one application with many requirements. One way for you to handle your Sinatra apps is to package your apps up as gems, with their own set of discrete dependencies. Then "require" them in your rack "dispatcher" application as bundler dependencies... and let bundler figure out the overall gem dependency tree for you.
The only one I can think of (have heard of) is isolate: https://github.com/jbarnette/isolate But I have no experience in using it.
&gt; Because it is not rubygems. I see it as distinct enough in its use case that it deserves its own executable. &gt; Edit: It isn't a replacement for rubygems. It compliments it with functionality to manage and support sets of gem dependencies for a given project. Some of the functionalities could be in rubygems : * install gem from a git repository * Better management of gem versions * Gem sandbox management And bundler would keep : * Application dependency management * Bundle deployment tools * Activation of rubygems sandboxes Today bundler forces the sandbox part and that makes it intrusive with no reason. I began looking at rubygems source, but it is quite a beast... &gt; One way for you to handle your Sinatra apps is to package your apps up as gems, with their own set of discrete dependencies. Then "require" them in your rack "dispatcher" application as bundler dependencies... and let bundler figure out the overall gem dependency tree for you. This is what I was thinking and will probably do, but it will change my straightforward file-based setup to something more complicated just because of bundler. 
It would be nice if rubygems got it together and could do this sort of thing all by itself, but that day may be a long way off. rvm implements gem partitioning one way, bundler another, and isolate even differently. It would be nice if there was a solution to your problem, where multiple "gem sets" could be loaded on demand, but there is a very hairy problem in the middle of that. Resolving dependencies is not easy and the risk of loading a mis-matched version of something is high unless you are able to register all your requirements up front. This is why bundler has support for one Gemfile only. 
Upvoted simply because this made me realize just how many developers out there are not familiar with good development technique.
… ?
&gt; Bundler.setup takes over rubygems require logic. Bundler's command line functionality can be used without `Bundler.setup`. Just use bundler to make sure you have the correct gems installed, then require them all in your application. I personally don't like having Bundler as a runtime dependency but do enjoy how easy `bundle &amp;&amp; rake` makes getting started on a project. Like someone else mentioned, isolate has some similar functionality to bundler, but it is much smaller in scope. If all you're after is making sure you have the correct gems installed, take a look at the gem packager hoe. It includes a rake task (check_extra_deps, I believe) that just makes sure all of the dependencies you list in your gemspec are installed.
hmmm
what is this?
&gt; Bundler's command line functionality can be used without Bundler.setup. Just use bundler to make sure you have the correct gems installed, then require them all in your application. I personally don't like having Bundler as a runtime dependency but do enjoy how easy bundle &amp;&amp; rake makes getting started on a project. If you do that, you lose a big part of bundler functionality. The following stuff won't work : * git or local path gem dependencies * gem fixed versions * bundler/vendor (deployment mode) 
Fix line 146. # never saw an itme out of order Edit: Also, Deck#cut will only work with a full deck of 52 cards. Edit2: Why would you do this: @@suits = Array.new(4) @@suits[0] = "clubs" @@suits[1] = "diamonds" @@suits[2] = "hearts" @@suits[3] = "spades" Over this: @@suits = %w(clubs diamonds hearts spades) Edit3: There's a lot of things in this code I'm having problems with. Let me know if you'd like me to keep going.
I tried it, and it sure is an improvement! Reinstalling one of my app's gems went faster than retrieving from the source index in old Bundler.
Are you asking us to critique your solution? Maybe I'm misunderstanding what it is you're posting, but if this was a problem that a potential employer asked you to solve, and said employer discovered the fact that you posted your solution to reddit for critique, if I were them I'd throw your application in the bin. Be careful with this kind of stuff. They asked *you* to solve a problem to the best of your abilities, they didn't ask the internet.
&gt; ... but it will change my straightforward file-based setup to something more complicated just because of bundler. How do you currently handle different gem versions across your Sinatra apps without bundler? Does each Sinatra app have its own set of dependencies or are the dependencies shared across all of your Sinatra apps manually? I'm not trying to be contradictory, I'm just curious. :) Thanks for the great points!
I would not hire the person who wrote this, nor work for a company that gave this to me as a hiring exercise.
anyone know when to expect bundler 1.1 final release?
It doens't exactly take over rugygems gem management -- by default these days, it'll still install gems into your system rubygems. It just takes care of figuring out what gems satisfy the dependencies for a particular app (for a particular list of dependencies, really, figuring out all their sub-dependencies and how they interact), as well as tracking 'last known good' dependency resolution. Any other tool is also going to be a separate tool to rubygems, of course. Why are they seperate? Mostly, as far as I can tell, just due to organizational history, and that a team other than the rubygems team developed bundler to deal with insufficiencies in rubygems alone that, at the time, it seemed too difficult to solve in rubygems itself, for various reasons including perhaps personalities. There are conveniences to keeping two seperate codebases, but I wouldn't be shocked to see them merged at some point. On the other hand, having them seperate means you don't HAVE to use bundler, which is what you're trying to get out of doing anyhow! But personally, unless there is some specific reason why bundler won't work (I have had trouble figuring out how to use bundler for an app that is included as a utility in another gem, for instance), I'd just use bundler. I don't think you'll find any other solution that's better, bundler is pretty sweet. And WAY better than "rvm gemset" which people used to use before bundler, and is now largely unneccesary. 
&gt; Today bundler forces the sandbox part and that makes it intrusive with no reason. This kind of comes out of experience though. The experience of many developers was that without this 'sandbox' approach, it was impossible to keep your gem dependencies straight. I suspect anyone trying another solution that does not do the kind of 'sandboxing' bundler does is going to run into the same headaches. 
We do something similar, using: https://github.com/mark/asplus_ruby_quiz ... y'all want to run through it and tear it to shreds? :-)
I have ~6 months ruby experience and I would be interested if you could keep going. It is a simple program and to my eyes it seems to do the job quite well but perhaps my inexperience is hiding some of the deeper problems.
Your variable names are supposed to be snake-cased. You're using random camel case in spots. This is a huge red flag to a potential employer that you're really green. Clone is a reserved word in ruby, for cloning objects. I wouldn't override it like you're doing. Your hash creation is awkward in . Also, you are using class instance variables where you should probably be using constants. I'd go get yourself a good Ruby book and go through it if you're really looking for a gig doing Ruby full time. I like "Beginning Ruby: From Novice to Professional." Hope that helps a bit.
Quick answer: You need the *if* part inside the outer while loop. Suggestion: I would change the logic a bit. First, have one loop to get input: while true do message = gets.chomp end Next comes the logic. Inside the loop, you check each condition. First we define when the loop ends: break if message == 'BYE' then (still inside the loop) we check whether the message is all upper case or not: if message == message.upcase then puts 'NO, NOT SINCE #{1930 + rand(21)}!' else puts 'HUH?! SPEAK UP, SONNY!' end So your end result would be while true do message = gets.chomp break if message == 'BYE' if message == message.upcase then puts 'NO, NOT SINCE #{1930 + rand(21)}!' else puts 'HUH?! SPEAK UP, SONNY!' end end Want to fancy it up? Use a ternary operator instead of the if: puts ( message==message.upcase ? 'NO, NOT SINCE #{1930 + rand(21)}!' : 'HUH?! SPEAK UP, SONNY!' ) The logic is the same as the *if/else*, just more compact and with the *puts* outside the *if*. 
I don't like the decorator pattern. Why not use delegates instead, if you need to break out behavior? Otherwise you're making the user assemble your class for you.
&gt; If you do that, you lose a big part of bundler functionality. That's kind of the point. ;)
If it isn't in a .gem file then it isn't a gem and RubyGems can't install it, so RubyGems probably won't be adding installation of software from git. RubyGems improved dependency resolution in RubyGems 1.6, so try removing bundler. If it doesn't Just Work please file a bug. We'll be adding a sandbox feature in the next release of RubyGems, but that's not likely to be out before the end of the year. I know that the RubyGems source seems confusingly big, but it's fairly well segregated into the OK and less than OK parts (much of lib/rubygems/commands is less than OK). If you need help join #rubygems on freenode.
Just to pile on and show off (programmers like to show off) I would do: while( ( message = gets.chomp ) != 'BYE' ) do if message == message.upcase puts "NO, NOT SINCE #{1930 + rand(21)}!" else puts "HUH?! SPEAK UP SONNY!!" end end The complicated bit in the why is broken down like this (order of operations has ()'s way near the top. 1. message = gets.chomp 2. message != 'BYE' 3. while #2 == true I mean, it's functionality equivalent to IUseRhetoric's bit, but I always hate to see while(true) and an explicit break. Sometimes you can't help it, but I personally like to avoid it. 
Challenge accepted :) . I have little passion for !=. Let's make your loop condition prettier: until ( message=gets.chomp ) == "BYE" do puts ( message==message.upcase ? "NO, NOT SINCE #{1930 + rand(21)}!" : 'HUH?! SPEAK UP, SONNY!' ) end
I don't understand why/how their "Long Polling" example will re-use an HTTP connection. After the timeout gap, the poll() function will be called again, which will call $.ajax again... each time that happens, isn't that a new HTTP connection? What magic in there will re-use an http connection? I don't understand why their "Long polling" technique is any different than their "setTimeout" technique -- what am I missing? How does using jQuery $.ajax's "timeout" parameter (the only difference between the two examples, right?) result in HTTP connection re-use? In fact, I don't even see a 'timeout' attribute documented in jQuery Ajax, I'm confused about what it even does -- my initial assumption would be it simply sets a, you know, actual timeout on the server connection, if the server connection takes longer than 'timeout', abort. Which is in fact a completely different thing than they say they are doing, and if it true, would result in _continual_ polling, as soon as the response is received, immediately poll again. Which isn't what they say they watn to do. And still dont' see any reason it would re-use HTTP connections. I find this article deeply suspicious. 
Hopefully, between this new Bundler release and Ruby 1.9.3 my command line development speed will get back to non-glacial speeds. I swear I'm almost ready to purchase a new computer because these things were sooooo slow. I still might get a SSD just because they are fairly cheap (in small doses) and will probably give me more bang than a whole new computer.
I don't think I can get any terser (or any farther away from the OP's question) without moving beyond the realm of feasibility.
What do you think about @@ranks = %w (two, three, four, five, six, seven, eight, nine, ten, jack, queen, king, ace) def Rank.get_rank(rank_name) @@ranks.index rank_name end instead of casting to hash etc... (`lib/rank.rb`)
bannisterfiend, why you always come up with such crazy shit?
hehe this one actually has an application though :) I'm going to use it to automatically open a Pry session at the place that generated the last exception, for Smalltalk style debugging.
It's a fad really. Just use your controllers and views. Why add another layer of indirection?
I remember investigating this after seeing `Factory()` being used to define factories in FactoryGirl.
I might not understand the idea, but don't you end up with a lot of more code, than if you were just using the ruby initializer? It seems weird just to get rid of the .new call.
If you actually made it callable you could do this instead: def MyClass.call(*args, &amp;block) new(*args, &amp;block) end And to invoke: o = MyClass.()
Can't tell if serious or sarcastic.
Using the same approach in modules... module Foo class Bar end def self.Bar Foo::Bar.new end end f = Foo::Bar() puts f.inspect 
Protip: This is why nobody puts you in charge of anything.
I am being serious. It's just a fad. Nobody was talking about decorators six months ago and I guarantee nobody will be talking about it six months from now. This post is especially insane. Really? I am going to create more classes and call them from my views? I am going to jump around even more files? No thanks. Just create some helper methods in your controller and be done with it. That way everything is in one place. 
Yeah, that makes sense from a law of Demeter perspective, too. 
It's this easy. http://teachmetocode.com/articles/ruby-on-rails-accessing-controller-methods-from-your-view/ 
Yeah, I guess I'd argue that's what helper methods are for, so you don't clutter up your controllers with tons of business logic. If your app is so complex that that is not convenient, there are design patterns like facade, delegate and dao that could be used as well. Nothing in Rails is preventing you from breaking things out into separate objects if that's necessary. The article was about creating object behaviors that are easier to test in isolation, though, so having one big method that does it all is contextually inappropriate if that's the original issue.
Here, have a disgusting one-liner for problem one: string.each_char.chunk{|c| c}.map{|elt, copies| [elt, copies.size]}.sort{|a,b|a[1] &lt;=&gt; b[1]}.inject([[],0]){|(chars, max_count), (char, count)| count &gt;= max_count ? [chars &lt;&lt; char, count] : [chars, max_count] }.first.sort Edit: Missed some sorting. Whoops!
Although it gives such nice illusion, you have to keep in mind that that's all it is, an illusion. You don't actually make the class callable. So this piece of work if still going go fail. foo = CallableClass foo() # doesn't work. 
Sure, totally worth pointing out. But don't do it....especially not as a constructor The Integer() method isn't a constructor, it's a special shortcut to a parse method
Not bad, not bad... the best one we've gotten for it involved: string.scan(/((.)\2*)/).group_by{|s, c| s.length}.max.last.map{|s,c| c} Although that might need to be tweaked, since it was submitted when the question was in a slightly different format. That requires 1.9, however. My best solution used the same regex (which gets you really far), but wasn't quite as nice as this, since I didn't have `Array#group_by`.
That stuff's not digitally signed, right? Be careful grabbing those over such a promiscuous network. 
I assume that the OP is just as concerned with this data as he is with anything else he downloads over any public wifi network. I also assume I'm missing some sort of joke.
That's funny, the Starbucks where I like to get my coffee with a side of work has a really fat pipe. I've had similar experiences when I've been working remotely in some middle of nowhere town. I can generally find a decent pipe at a local Starbucks. It's no home cable modem, or fiber to the home, but it's fast enough to keep me from waiting too long. :)
Upgrade to 1.1 its much faster.
 group :development do gem 'porn' end
Starbucks 1.1?
Ok, thanks that worked however what does the while true do bit do? In the tutorial it doesn't cover that but I'm guessing that while is always true so it keeps on looping until you end up typing BYE? BTW on my terminal when it spits out the whole NO, NOT SINCE #{1930 + rand(21)}! part when you type in capitals is that an error in your code or maybe because I'm using a different version of Ruby?
Again that worked but what does the do bit mean at the end of the while loop? 
The while true is an infinite loop, which continues iterating until explicitly terminated by the break statement. On the second part that's my mistake. Use double quotes instead of single ones. 
The do part is just optional syntax in the while loop (I like to make it explicit in my code, but then again my style does not conform to the usual ruby style guidelines) . You will see it more often where blocks are used. 
Thanks I appreciate all your help. I didn't want to just read your solutions though and not come up with my own one so I did: message = '' while message != 'BYE' message = gets.chomp if message != 'BYE' if message == message.upcase number = 1930 + rand(21) puts 'No, NOT SINCE ' + number.to_s + '!' else puts 'HUH?! SPEAK UP, SONNY!' end end end Might be much more lines than your and jmoses one but I'm just happy I managed to come up with my own solution :) Once again thanks to both of you :)
&gt; This last point is really what cause me problems (maybe because I don't understand something). You cannot have two separate bundler aware applications running under the same ruby process. Use [Bundler groups](http://gembundler.com/groups.html). Each app then should use different group name. 
This was very helpful. Now I just need to determine what to patch.
Yes. You are missing the joke.
Excellent! My reputation for missing jokes remains intact. :)
No worries! I miss tons of them, simply because I have kids, a few jobs, and a girlfriend. Not enough time for reddit, it seems. Here's the joke: bundle install invokes the "install" method for the "bundle" command of the "bundler" gem. It's a Ruby dependency-management gem. So, you not only download the gems you need, but all those gems' dependencies, as well. So, it's a joke about running a high-bandwidth operation on a slow network. That's all. Well, I tee-hee'd, at least.
That's the joke? I find myself somewhat unfulfilled. :( Edit: I'm already familiar with bundler, I just thought it was somehow more meta than a normal use case operation. :P
SHIT!! Maybe it is more... fuck, now I'm questioning everything &amp;#3232;\_&amp;#3232; 
I wonder when [EvilGrade](http://www.infobytesec.com/down/isr-evilgrade-Readme.txt) will get RubyGems support...
I suspect there is a nefarious type camping the local Starbucks with a compromised json gem just *waiting* for a fool like him. Muhahaha! Any day now.. they will fall into my trap! I will mangle their JSON like the evil genius I am. 
I wouldn't have gotten this joke a week ago. I have recently gotten into Ruby, and can say that getting ruby 1.9.2 and rails and gems to all behave properly took more than a few tries. 
Thats... the joke?
More correctly &gt; TIL: Ruby method names can start with a capital letter Edit: I'm negative, cute. But that's all this is: methods named with a capital letter, which is extremely rare in Ruby and thus reminds us closely of class names, which as we know, must start with a capital letter.
Starbucks 1.1, Now with more Hipster Barista's.
It's more about the stakes than the low chances that someone might be poisoning your local Starbucks wifi. Who cares if they swap images out in your HTTP transfers, but in this case they would get to load their own software onto your system. 
Don't forget the fixed_speed and ironic_mustache dependencies. 
It's still a smidge bugger. There are ~6 problems which I can neither find, nor have credit for. Everything is marked up as solved. That said, it was pretty intuitive, and the problems were sufficiently interesting (I think) to challenge a beginning student. I'd vote to get it on the sidebar, but perhaps only when it has a little more content.
make sure it's fixed_speed '~&gt; 0.3', the 1.0-head-rc1pre.beta branch is buggy, even though it's alot faster.
Awesome, I've been looking for a way to contribute to rbx. I love using it, and can't wait for 1.9 support!
Well, don't know what to think of this one. On the one hand it enforces better typing but on the other hand it kind of does away with Ruby's ability to be flexible.
The meme where things that aren't memes are incorrectly called memes is *the real meme*!
That's why you have all 149632 gems on your harddisk, and do gem mirror every night.
Using options Hash as the last argument in Ruby is pretty much standard these days. I don't see why we shouldn't have a real kwargs.
The explanations are bad for beginners. Take the lesson "Growing Arrays" for example: text: In Ruby, the size of an array is not fixed. Also, any object of any type can be added to an array, not just numbers. How about appending the word 'woot' to an array? Try using &lt;&lt; - that's the 'append' function - to add it to the array below. Missing to explain that '&lt;&lt;' is an operator nd how those work in the Ruby context Next test is even worse: To append a new element to a given array, you can also use push method on an array. correct solution: [1, 2, 3, 4, 5].push('woot') But the tutorial doesn't explain, that the array definition itself is an object and that functions like .push() can be called on it. 
death to `extract_options!`
I still don't know for sure what is Rubinius and why should I use it :/
Has anyone ever observed or has a POC ever been developed to poison library source code fetching over public networks (specifically in the interpreted code group (ie: Ruby, Python)?). I know debian packages are hashed and mostly signed, FreeBSD port source tarballs are also hashed in the port Makefile, as well as pretty much every other OS library/package management system to some degree which would mitigate such an attack. I just haven't ever heard of the concept of attacking Ruby gems or Python eggs (or node packages, or Perl CPAN archives). Not that it isn't a valid concern, I'm just curious if it has been attempted and what kind of success was observed.
How so? If they're made optional, then no harm done. I don't think anyone is suggesting the Ada route.
Related: [About concurrency and the GIL](http://merbist.com/2011/10/03/about-concurrency-and-the-gil/) [Ruby concurrency explained](http://merbist.com/2011/02/22/concurrency-in-ruby-explained/) [Concurrency &amp; Performance in Ruby](http://ruby.io/)
Now _there's_ a joke I can get behind! Ninjedit: Wait, that came out wrong...
Out of curiosity, what is your development OS?
It's a ruby interpreter written mostly in ruby itself.
Well the first time was on a ubuntu 11.10 server. By just doing apt-get install ruby rubygems. Little did I know of the RVM. and after assuming that the 11.10 repos just didnt have the latest build, went down to 10.10 and had similar issues. Finally I got rvm installed, and have a working 1.9.2.
There's also a reverse_merge method to achieve the same thing.
The whole time I was reading this, I was thinking, "there's no way gathering stats from Gemfile is going to be accurate, because it doesn't include all the dependencies of the gems you do use." But then, they actually come out and say this in the article: &gt; Think about it this way: when you ask for a library and that library depends on ruby_parser, it’s not because you are using ruby_parser when you use that library. You probably never even touch parsing code. Therefore, your code is not using ruby_parser, and it shouldn’t be counted as "used" by your code. I completely disagree with this. If you're using a gem that is built on top of another gem, then you absolutely *are* using that other gem whether you know it or not. The entire reason for looking toward gem usage is to gauge the likelihood that you can use that gem without issues. The more people using the gem, the more bugs have probably been reported and fixed. And this is true whether it's being used directly in a project, or indirectly. If you find a bug in your code, it will be traced back to the gem causing it, and hopefully reported and fixed. Furthermore, it is quite easy to use gems in development or production without using bundler to manage them by simply running `gem install`. Hell, in the rails 1 and 2 days, that's exactly how we did it! For this reason, for my purposes, number of downloads is a much more accurate metric for gem usage than NewRelic's metric of looking at Gemfile.lock, and especially of the Gemfile metric. &gt; In short, GemStats.org asked for your Gemfile, whereas NewRelic collected results from Gemfile.lock. This makes a big difference, because the lock file contains all dependencies of gems you use Exactly! This is why I'd much rather look at NewRelic's Gemfile.lock stats than the Gemfile stats. If a gem is a dependency of 10 other gems I use, then Gemfile.lock will have it listed 10 times, whereas Gemfile may have it listed zero times. But if 10 gems I'm using rely on gem X, you bet your ass it's a popular, well-adopted gem.
Nice job! It's an important learning process for every Ubuntu Rubyist. :) I stole [thoughtbot's laptop setup script](https://github.com/thoughtbot/laptop) and [modified it](https://github.com/coderjoe/laptop) for my own personal setup. It helps me get my Ubuntu based instances and development VMs up and running in minutes. I also borrowed ideas from [ryanb's dotfiles](https://github.com/ryanb/dotfiles) to help me setup and manage my tool configuration. If you haven't given the ideas a look it's worth checking out. :D
That looks reasonable. Hashes work, but that's a hack and probably much slower than actual keyword arguments.
You can pick either interpretation you wish, the problem is that there is no correlation for either data set. The data simply doesn't show your conclusion. Also note that half of the analysis was done with NewRelic's data, so your viewpoint is investigated as well (and again, no correlation is found with this data set).
One thing that has bothered me a long time in the ruby community is the perpetuation of the idea that threading is hard so you should just never do it. I don't deny that it can be challenging, but I don't think it should be verboten... the existence of the GIL is misguided IMO, because it certainly IS possible to write correct threaded code, and for some problems it is a good solution. Anyway, if you want real threads there is JRuby and Rubinius, so it's not all bad news for threads and ruby. Side-note, good related links, OP!
I'm skeptical. He is assuming that the 'real world' gem usage surveys are more accurate than downloads, and looking for other indicators that correspond to the 'real world' usage data assumed accurate. But the 'real world' surveys are a smaller sample size, and not neccesarily a representative sample of all users. The real world surveys include, respectively, only those users using new_relic, or those users who noticed the call for Gemfiles and submitted one. It seems likely that the 'real world' surveys are an unrepresentative group of 'power users'. Then the fact that new_relic/survey is correlated with github forks/watchers is totally expected -- because _both_ are samples of 'power users'. So what I conclude from this is simply that ruby 'power user' gem usage looks different than total ruby gem usage. (Total ruby gem use including people who don't use new_relic, didn't hear about the survey or contribute their Gemfile to it -- and may not even be using bundler). After all, if we assume that download metrics are _not_ representative of use, then this would seem to me to mean that either some people are downloading gems without using them (why?) or using them without downloading them from the authoritative source (how? and why?). Without an expalnation of why this would be so, to me, occam's razor suggests that rather than this being true, the Gemfile survey and new_relic usage instruments simply did not have representative samples. 
To say more, if gem usage is _the same_ amongst, say, people who use Bundler vs who don't, then a random sample of Bundler users might represent "everyone". (Not that we have a random sample here neccesarily, but even if). On the other hand, what if there are huge numbers of people/apps not yet using Bundler, and their gem usage is _entirely different_ than those who do use Bundler? Then any sample of Gemfiles, even a statistically random one (which again we don't have), will not represent the whole. Ruby's old enough now that there may be a whole _bunch_ of 'legacy' ruby apps running that download gems but don't even use Bundler. And maybe gem usage in that community is a very different distribution then gem usage among those using new_relic and those submitting their Gemfiles to the survey. 
it's definitely not long polling in the article. I think what they're doing with their long polling example is making it so that there isn't any overlap between function calls. In the first example, if the AJAX call was lagging, a new function could be called with setTimeout before the previous one finished. This could pile up. With their second example, the next call to poll() won't call until either 1) the current poll() has completed or 2) the timeout has been reached. That way, there's only one instance of poll() running per client. "Simulating a Long Poll in JQuery" is more accurate.
The second example ("long poll") won't run until the current poll has completed _OR_ the timeout has been reached _whichever comes first_. The web page/app will in fact _constantly_ be doing a 'poll' operation, as soon as one completes, it will immediately start the next one. This is not what they imply, and not at all the same semantics as the first approach they say they are doing 'better' than. I also can't see _any_ way that the 'long poll' example would re-uses the same persistent HTTP connection -- if it does, it's because of the browser deciding to keep http 1.1 connections around, and would do so in BOTH examples. I think they're just plain wrong. 
&gt; Then the fact that new_relic/survey is correlated with github forks/watchers is totally expected -- because both are samples of 'power users'. You actually misinterpreted the results, watchers and forks *do not* correlate with newrelic's data. That was the point. I wonder what this says about your theory?
it's definitely not reusing the same http connection. It's simulating it by only allowing one connection at a time. In reality, their solution will hit a server really aggressively whereas at least the first example (which I use all the time) at least only happens every 30 seconds no matter what. I'm definitely not defending them as I would never do their second example, but instead just trying to explain what I think the author meant :)
Eh, I don't think this is a good argument. "If you write thread-unsafe code, then the GIL might save your ass anyway." I think a better argument, and the one I understand Matz to be making, is that the the _c ruby_ code _itself_ (in c) is not written thread-safely if we take away the GIL. And that the ruby development team simply doesn't have the resources/time/interest to make it so, and to then continue maintaining code thread-safely (which is harder than maintaining it with the GIL). _And_ that supporting C extensions without the GIL will make writing C extensions that are thread-safe much harder too. (Also, does the ruby language spec even say which built-in ruby operations are supposed to be atomically thread-safe and which aren't? Do you need that if you get rid of the GIL? Does Java have that?) I think that's quite a reasonable position, is the one I think Matz was actually making, and doesn't require suggesting that the GIL is there to protect actual ruby _users_ from their own poorly written thread-unsafe code. After all, even _with_ the GIL, if you write code like in this example, you could find yourself with bad race conditions, no? The GIL will sometimes save your ass, but I wouldn't count on it. I think the GIL causes a lot less problems than people think too. Especially ruby 1.9 native threads. Now, ruby 1.8 threads were just crap and couldn't be used to do anything non-trivial without horrible performance, and people may have blamed that on the GIL, but it wasn't really about the GIL, it was about green threads. _MANY_ _MANY_ use cases will do fine with native threads even with the GIL, blocking/context-switching while waiting on IO operations (disk and network). 
If you can find a way to gain a wider more generalized population sample, I'd be all ears. This is not a problem specific to this study, of course, it's something all statistical analyses have to deal with-- the accuracy of the sample. In fact, the recommendation was that we should perform more and wider studies like these to confirm / refute the data. That said, I would argue that the sample is large enough, even if you take into account the fact that legacy apps are being omitted. And I'm not sure what your "power user" argument is. Only power users opt into surveys or deploy applications? Then that would mean all surveys are inherently biased.
It's quite possible to write thread safe code with the GIL too, and for some problems it is a good solution. The only thing you lose is making use of multiple cores simultaneously in the same process. For _some_ problems you need that -- but for many others, concurrency with context switching when one thread blocks waiting for IO is sufficient, and the GIL isn't a problem for those. One thing that has bothered me for a long time is people thinking you can't write thread-safe code and use threads in MRI with the GIL. You can! In ruby 1.8, it just performed miserably for reasons other than the GIL (green threads). 
I am suggesting that over the entire universe of ruby users or installed ruby software, even those using _bundler at all_ may not be representative -- let alone those using new_relic, or those who noticed the survey (the whole universe of ruby apps may include only a tiny percentage actively maintained by people who read ruby community websites and listservs where the survey was even advertised, forget the self-selected sample of those who saw the survey advertised and chose to participate). I don't have any ideas for ways to get a more statistically random sample -- beyond the rubygems download statistics. I would assume the rubygems download statistics are _more_ accurate than the other instruments, not less. It is not a quesiton of how _large_ a sample is. If a very large sample is not statistically random, it can still be unrepresentative of the population as a whole. 
&gt; then this would seem to me to mean that either some people are downloading gems without using them (why?) No, it would mean that gems are being downloaded multiple times for a single "use". Keep in mind that when you deploy to cloud services (of which many applications are), the cloud service usually performs a new fresh install which often involves re-downloading the gems. travis-ci does this as well. Also, whenever you bundle install on a new machine, you are re-downloading the gem, but you are not using it any more than you were previously. That means that downloads should actually scale closer with number of deploys and machine installations than actual usage. I run code with the same gems on multiple machines and some VMs within those machines, meaning I've downloaded the same gem probably a good 20-30 times. Does that count as me using it 20 times? No. Does it mean those gems should be 20x more popular because I have a bunch of VMs with the same code? Probably not. ..and it turns out that the numbers actually reflect this kind of a scenario more than an indication of popularity.
&gt; I don't have any ideas for ways to get a more statistically random sample -- beyond the rubygems download statistics. I would assume the rubygems download statistics are more accurate than the other instruments, not less. What is your evidence of this? All data seems to suggest otherwise. Even logical explanation could give you many reasons why download count can be hyper-inflated (single-use multiple-install scenario described above). Even if it *is* unrepresentative of a population as a whole, it should still be representative of these "power users", as you call them. If it makes you feel better, you can conclude that downloads do not correlate with usage for power users, until more data about the rest of the population is acquired. Of course, the better question might be: what is the percentage of Ruby users who are considered "power users"? I would bet that number is higher than you make it seem, and, in fact, this is someplace where we can use download counts to estimate. The download counts on rails 3 vs rails 2 would tell you how many are using Gemfiles. And the download counts on rails itself (the fact that it is vastly more popular than any other gem) will tell you that the vast majority of Ruby users are working with Rails. That should put your mind at ease as to whether the sample is representative or not.
Never mind this, dammit, give us @vars in prototypes! That way, we could get rid of my most-hated code smell of all time, thusly: class Point attr_accessor :x, :y def initialize(@x, @y) end end
Yeah, I like that better. I'm not convinced you need a Rank class at all, though. Also, the syntax for the @@ranks array would be: @@ranks = %w(two three four five six seven eight nine ten jack queen king ace) 
&gt; One thing that has bothered me a long time in the ruby community is the perpetuation of the idea that threading is hard so you should just never do it I absolutely agree. Just because you can get by without more fully featured threading, isn't grounds to dismiss such things as unnecessary, or even undesirable. Just because you don't want to program in a stack/VM the size of java doesn't mean you should have to go without proper threading, this is something I'd really like to see some movement on in upcoming ruby releases
Thank you! I mainly posted these links (and will continue to do so, if I can find more) because I get sad when I see people bashing MRI for having a GIL without really knowing about the background. I can't thank Matt enough for making these excellent posts so that people can realize that the lock is there for good reasons, not only because Ruby core is lazy or wouldn't know how to implement it. They are all great developers and they have good reasons for their decision. Currently with all the non-thread-safe C code and extensions it is simply not possible to make a quick, safe switch. So I just hope that with more blog posts like this the "hate" will hopefully cease and more people realize that nobody has to "flee" to other languages, because the concurrency issue is actually in good hands: JRuby has no GIL, Rubinius will remove it soon, and MRI will come up with MVM to solve it.
Couldn't agree more. I would even say that if it were only the Ruby-internal C code that needed to be fixed then it would probably be doable for the next version, but there is a lot of code deployed in production right now that relies on non-thread-safe C extensions. Now imagine the next Ruby version would simply remove the lock and say "We've done our part, now you go fix your lousy extensions"... That's a process that can't happen over night, unfortunately. I agree that nobody should use the GIL as an excuse to not pay attention to thread safety of their own code. It's not like a panacea that will save you on any occasion, if it did, then you just were lucky - but you should never rely on it ;)