Can confirm!
Interesting side note/tips for the newer friends: Rake is really fantastic for helping organize commands, but if you look at a rails project, you'll see `bin/console` and find that it's just (relatively): #!/usr/bin/env ruby require 'application' require 'pry' Pry.start So, keep in mind that you can just create scripts to execute that launch a few commands, and then drop you into a shell. It's almost like creating your own personal ruby shell. You could keep a couple more interesting versions of these files in your home directory (or somewhere familiar). I have one that loads a handful of company specific FTP configs, database connections, and other tools I use regularly. And, additionally, you can also run from your command line (without any file at all) $ pry -r ./application You can pass `-r` as a flag to starting a pry shell that loads libraries for you. I use this a lot when I'm doing simple scripts that don't live in a full framework, but want to explore my code in progress. Or if I'm about to do some shell based database work. `pry -r csv -r sequel`. And finally, while I'm rambling, don't forget about these awesome pry moves: &gt; ls # Shows the methods available to the current scope &gt; my_obj = SomeThing.new &gt; # =&gt; &lt;object&gt; &gt; cd my_obj # changes the scope to another object, from which you can `ls` again &gt; $ SomeThing.connect # Shows the source code for a specific method &gt; $ my_obj.connect # Same as above: Notice you can either use the module/class, or an existing object(!!!) &gt; ? my_obj.connect # Shows the documentation/comments for the method. You can also reference the module directly Just a few other notes that might be interesting to learn about. They can really boost your productivity, particularly when you're new to Ruby!
[removed]
What if you don't use CI because you don't have any of the problems that CI solves?
You could build something around ruby-graphviz...
&gt; (I am using pry) Turn this: out &lt;&lt; all_headers.map{ |header| row[header] } Into this: out &lt;&lt; all_headers.map do |header| binding.pry if header.class.to_s == 'TrueClass' result = row[header] binding.pry if row[header].class.to_s == 'TrueClass result end
I'd argue a core value of any useful library is a test suite which verifies the functionality on the supported platforms. If a gem doesn't have a test suite or doesn't run it in an automated fashion, is it a good idea to use it in a professional context?
An option maybe be to integrate with draw.io. We've got a module for phpipam that draws our network diagrams in draw.io. Essentially you just provide it XML and it generates the diagram in the iframe.
Somehow you always have my back. Thank you, /u/menge101. I literally just copy and pasted the code again and it somehow passed. Now it doesn't want to output the final file. Until next time space cowboy.
Anger on Rails?
Would gild you if I could!
I certainly wouldn't use a library that didn't have tests, but I don't much care if a CI tool actuates those tests if the authors are diligent about testing their releases. I've never forgotten to run the test suite before releasing any of the libraries I'm either the primary or a co-author of. Keep in mind some people will have release scripts that run the tests before releasing new versions.
Can I also use it to output image files, instead of using it in a web page? I am just planning to feed it a bunch of JSON/XML stuff and get a diagram back, not using rails.
Yeah, that would be the graphing gem to go for.
Hmm, not sure if the API allows that easily. The iframe does have a bottom to print to an image but it would obviously have to be noninteractive.
Normally if you mount a Rack application at the root (`/`), it means that all requests will go to it. And when that mounted app returns a `404 Not Found`, the request won't continue to your router, but it will stop there. This is at least how Rails and Roda work, I'm guessing Hanami does as well. The `Plezi` middleware that you added is probably already handling the routes registered to it, including your `WebsocketSample` controller. So my guess is that you want to remove `mount WebsocketSample.new at: '/'` and keep `middleware.use Plezi`.
So if I remove the `mount WebsocketSample.new at: '/'` and change the `Plezi.route '/' ..` to `Plezi.route '/plezi' ..` I am still able to navigate to `/plezi` and see `'Hello World!'` but any connection attempt made to the port and route `localhost:2300/plezi` don't go through.
Yep, Gitlab's Omnibus packages make installation (and updates!) extremely painless. Setting up Gitlab CI with Docker runners is fairly easy. You'll probably want to run the CI on a different server than your Gitlab instance though, both for performance and security reasons.
`!!` to convert values to boolean
Serve up the current directory with an HTTP server: ruby -run -ehttpd -- --port 3000
We need a `.to_bool` method xD
I have used flask and and it is very similar. The application I built was structured more like a traditional MVC but at their simplest both can be a single file. SQLalchemy is really nice too but ActiveRecord seems to be more pleasant to work with (my opinion ymmv).
nice!
Nice catch. And thank you for reviewing my code!
I run GitLab through a Docker instance at home. It has been fairly painless to setup, though there have been a handful of database migration issues in the past. They've been easily resolved once the developers post resolutions in the issue tracker.
Once upon a time as a junior developer, this threw me for a huge loop. For some reason I was unable to parse it as normal syntax, but interpreted it as its own operator for some reason. ...of course, now I use it all the time &lt;_&lt; I do wish Ruby had Javascript's `Boolean()` constructor, though.
Just set it up. Mine is on bare metal that I have specifically for testing. I've synced my repository to it and that was super easy to do. I'm trying to dig into getting Auto Test set up, and I'm staring at the wall of documentation of docker executor. Daunting.
Quickstart to the rescue [https://docs.gitlab.com/ce/ci/quick\_start/README.html](https://docs.gitlab.com/ce/ci/quick_start/README.html)
Awesome! I haven't used the Auto DevOps yet as that's a very particular set of tools that doesn't match any of my projects., but I've made a lot of use if the .gitlab-ci.yml and the runner working with Docker or the shell.
There are a lot of open source CI tools available, here’s a quick overview of a few of the more well known ones: https://opensource.com/article/18/12/cicd-tools-sysadmins
dockerd is hitting my cpu hard right now and jobs is showing 1 running! Thanks for the encouragement.
GitLab was really a life-changer for me. I'm a huge fan of anything I can self-host. Their quick-start guides are very useful and straight to the point, which I think you've discovered. While I've had minor setbacks with two database migrations, I've elected to have my GitLab container (and others) automatically updated using [Ouroboros](https://github.com/pyouroboros/ouroboros).
\`?\` for character literals is so strange... \`\[\*'a'..'z'\]\` hurts a lot less
Or even ('a'..'z').to_a
This is the Ruby-est option.
More of a personal aesthetic preference, but I really wish that scalar types had something like `.falsy?` or `.truthy?` methods though just for the sake of being able to be a bit more declarative. I've been using Ruby professionally and *still* forget that this works: Status: Downloaded newer image for ruby:2.5-alpine ~/workspace # irb irb(main):001:0&gt; foo = 0 =&gt; 0 irb(main):002:0&gt; if foo irb(main):003:1&gt; puts "doh" irb(main):004:1&gt; end doh =&gt; nil
In-place editing: /tmp &gt;cat &gt; a.txt Foo bar baz /tmp &gt;cat &gt; b.txt Blah blah foo! /tmp &gt;ruby -i.bak -pe'gsub /foo/i, "BAZZZZZ"' *.txt /tmp &gt;ls {a,b}.* a.txt a.txt.bak b.txt b.txt.bak /tmp &gt;cat a.txt b.txt BAZZZZZ bar baz Blah blah BAZZZZZ! /tmp &gt;cat a.txt.bak b.txt.bak Foo bar baz Blah blah foo! This is a sed/perl thing.
I really love using `.tap` for last-minute ops on return values that have no side-effects. Basic example: irb(main):002:0&gt; def my_method(x) irb(main):003:1&gt; (x + 2).tap do |ret| irb(main):004:2* raise "invalid input" if (ret % 2).zero? irb(main):005:2&gt; end irb(main):006:1&gt; end irb(main):010:0&gt; my_method 1 =&gt; 3 irb(main):011:0&gt; my_method 2 Traceback (most recent call last): 5: from /usr/local/bin/irb:11:in `&lt;main&gt;' 4: from (irb):11 3: from (irb):3:in `my_method' 2: from (irb):3:in `tap' 1: from (irb):4:in `block in my_method' RuntimeError (invalid input)
Unless you're building something with C bindings this is possibly the only useful thing from un.
`puts "wtf" if !!??`
####1. Destructuring in assignment and parameter lists. response = ["Horse", 37, [3,-1], foo: :bar] name, age, (x,y), *opts = response # def list((head, *tail)) case tail.length when 0 head when 1 "#{list [head]} &amp; #{list tail}" else "#{list [head]}, #{list tail}" end end list %w(Bob Marge Jill Clover) #=&gt; "Bob, Marge, Jill &amp; Clover" ####2. The implicit === in `when` statements that becomes equality for primitives, match for regex, is_a? for classes, call for procs and so on. def ticket_class(age) case age when nil; "Unknown" when /∞/; "Cthulhu" when String; ticket_class(age.to_i) when 100; "Centenarian" when 18..21; "Young adult" when -&gt;(age) { age &lt; 18 }; "Junior" when -&gt;(age) { age &gt;= 65 }; "Senior" else "Regular" end end ####3. using &amp; with a hash: factorial_cache = Hash.new { |h, n| h[n.to_i] = (1..n).inject(:*) || 1 } 100.times.map(&amp;method(:rand)).map(&amp;factorial_cache) ####4. the arguments pass-through in Symbol#to_proc: class Person # ... def compare_name(b) [self.lastname, self.firstname] &lt;=&gt; [b.lastname, b.firstname] end end people.sort(&amp;:compare_name)
`Object#tap` def create_user(email, tier) user = UserSystem.create(email: email) user.make_admin! if tier == :admin user end becomes def create_user(email, tier) UserSystem.create(email: email).tap do |user| user.make_admin! if tier == :admin end end In this contrived example it's not a huge win ... but hopefully it illustrates the point.
Haha yeah definitely don't disagree with you. I don't have a ton of practical use cases for my example, just think it's an interesting one!
You can accept a variable number of parameters by putting any additional parameters into a [doublesplat param](https://repl.it/repls/ConstantBelovedSoftwaresuite). You can easily convert a Hash into a Struct by "abusing" splats: def hash_to_struct(hash) Struct.new(*hash.keys).new(*hash.values) end (# note: this requires your hash keys are symbols) (# there's a more in depth version but by "tricks" I was thinking more one-liners that could get people thinking) In Ruby 2.6: `&amp;.` is the [safe navigation](http://mitrev.net/ruby/2015/11/13/the-operator-in-ruby/) operator. It basically allows you to call methods that may or may not exist. You're probably used to something like if my_obj &amp;&amp; my_obj.foo Which is generally fine, but what if `my_obj` is a Hash or an MyObj? This would fail for the former but not the latter. if my_obj&amp;.foo puts "myobj has foo method: #{myobj&amp;.foo} elsif my_obj[:foo] puts "myobj jas no foo method" end I recently ran into this with Sequel gem. It seems to return `nil` when a query returns nothing... so dataset.where(title: "My Title").first Would fail with `No method "first" for Nil class`. Which, yea, ok... I didn't want to use a temporary value and test if that was null... This sucks: query_result = dataset.where(title: "My Title") query_result ? query_result.first : nil we can simplify this with `&amp;.`: dataset.where(title: 'My Title')&amp;.first `.then` allows you to pass a block to specify the order of parameters. These are equivalent: # In three steps with temp vars filepath = File.join __dir__, data, 'myfile.txt' file = File.readfilepath json = JSON.parse file # In the standard "method chaining" today JSON.parse(File.read(File.join(__dir__, data, 'myfile.txt'))) # using .then File.join(__dir__, data, 'myfile.txt') .then{ |filepath| File.read filepath } .then{ |file| JSON.parse file }
I agree but I thought we were also golfing :P
Very interesting. Could you say more about who the “end users” are in your case?
If it's not `nil` or `false`, it's truthy. Not very complicated ruleset!
`wait_writable` is super useful. Also, if you've ever done something dumb like `rm`'d your bin directory... some... how... _totally not_ some dumbass move like `rm ${some_var_that_unset}/bin`... and you just so happen to install ruby to `/opt` (or `/usr/bin`) then having a basic set of file utils is super helpful. `un` is basically a [cli interface](https://github.com/ruby/ruby/blob/master/lib/un.rb#L91) to [FileUtils](https://github.com/ruby/fileutils")...
Yes! Love the safe navigation operator &amp; double splat. Also that hash-to-struct example is great!
Here are the zsh wrappers I use for this (place in `~/.zshrc`): serve () { ruby -run -ehttpd -- --port $1 } serveSSL () { ruby -r webrick/https -e " WEBrick::HTTPServer.new( Port: $1, DocumentRoot: '.', SSLEnable: true, SSLCertName: [%w[CN localhost]] ).start " } Then you can just run `serve 9000` or `serveSSL 9001` in any directory.
There's a gem. We use it on my team, and I kinda feel like it should be part of Ruby's core.
Yeah it should be core. If you use ActiveSupport at least you can get away with using `present?`, `blank?` and `presence` which makes things less painful xD
 ruby -e '$&gt;&lt;&lt;"Hello World"' &amp;nbsp; ruby -e '$&gt;&lt;&lt;$&lt;.read' file1 file2 file3 &amp;nbsp; ruby -rpp -e 'pp %w(a a a b c c d e a b c d a)|[]' &amp;nbsp; # replace all lines with comments from `myfile` ruby -pi -e 'gsub! /^#.*$/, ""' myfile # Same as: perl -pi -e 's/^#//' myfile # remove all lines with comments ruby -pi -e 'next if /^#/' myfile perl -pi -e 'next if /^#/' myfile
&gt; # using .then and being less verbose, &gt; # also experimentied with "s" for "self", x, and i &gt; File.join(__dir__, data, 'myfile.txt') &gt; .then{ |ret_val| File.read ret_val } &gt; .then{ |r| JSON.parse filer } &gt; .then{ |r| my_function somevar, r } I'm really looking forward to the addition of the polarizing block positional args to bring this one home! File.join(__dir__, data, 'myfile.txt') .then{ File.read @1 } .then{ JSON.parse @1 } .then{ my_function somevar, @1 }
there's \`nil?\` and \`empty?\`... &amp;#x200B; But otherwise, as jrochkind points out, the only \`false\` values are \`false\` and \`nil\`. &amp;#x200B; \_ALL\_ objects are \`true\`. \`0\` is an object. It's a very specific kind of object which is different than \`'0'\`, but they're all objects.
Wouldn't it be exactly class Object def to_bool !!self end end `#!` is defined on BasicObject so this will return a result for all but the most arcane objects.
&gt; Once upon a time as a junior developer, this threw me for a huge loop. Were you a Perl developer in a past life? It tripped me up initially because 0 is false in Perl, but true in Ruby. &gt; I do wish Ruby had Javascript's `Boolean()` [Why?](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean) &gt; Any object of which the value is not undefined or null, including a Boolean object whose value is false, evaluates to true when passed to a conditional statement. Also, with added, JavaScript WTFs: "including a Boolean object whose value is false, evaluates to true" Ruby automatically does this for you... _EVERYTHING_ is true. So there's no need for a special constructor. Also, `==` is [totally overridable](https://repl.it/repls/FrequentFittingDegree)... class MyClass def initialize @var = 30 end def ==(other) @var == other.value end end c = MyClass.new test_struct = Struct.new(:value, :name) v1 = test_struct.new(20, :twenty) v2 = test_struct.new(30, :thirty) puts "eql #{v1.name}: 20" if c == v1 puts "eql #{v2.name}: 30" if c == v2
Though in idiomatic ruby there's very few times you should actually do this.
Would you use `@1`? Is that not already used for something? So: def my_func 1, 2 end def another_funk(a, b) puts "second from my_funk: #{a}, first_from_my_func: #{b}" end my_func.then { another_funk @2, @1 } (this is a _really_ contrived example)
&gt; It basically allows you to call methods that may or may not exist. No, that's not what the safe navigator does. It allows you not to fail when calling methods on potentially nil objects. You still get the exact same behavior as without it when testing for non-existent methods, so long as the object you call them on is not nil.
Keep in mind you can already do this: File.join(__dir__, data, 'myfile.txt') .then{ &amp;File.method(:read) } .then{ &amp;JSON..method(:parse) }
You are absolutely correct. e.g.: &amp;#x200B; Object.new&amp;.this\_method\_doesnt\_exist &amp;#x200B; Will result in an \`undefined method\` error. &amp;#x200B; What I was trying to say was: "It basically allows you to call methods on an object that may or may not exist."
Hmm, I would recommend that you ask the author of Plezi for help (I think here he goes under /u/BoWild).
Flip Flop operator is super useful when implementing simple parsers lines.each do |line| if line =~ %r{^\s*/\*} .. line =~ %r{^\s*\*/} // Comment line parse operation else // Something else parse operation end end That will read a file line-by-line, and when it comes across the beginning of a comment (`/*`), it will go into a comment mode, parsing each line as a comment, until it runs into an end comment (`*/`) Basically flipflops are any conditional with a range between them. They will evaluate the first condition until the point it turns true, then the whole condition fires as true until such point that the second condition evaluates as true. And there are both "upper-bound" inclusive (`..`) and exclusive (`...`) variants. The inclusive one evaluates the second condition immediately after the first becomes true, the exclusive only evaluates it the next time its called. You can even implement fizzbuzz with flipflops: x = y = z = nil (1..50).each do |num| print num, ?\r, ("Fizz" unless (x = !x) .. (x = !x)), ("Buzz" unless (y = !y) ... !((z = !z) .. (z = !z))), ?\n end
Thanks!! I was totally unaware of that :)
defining constants like this: CONSTANTS = [ CONSTANT_A = 'A', CONSTANT_B = 'B' ] Usually, you see something like CONSTANT_A = 'A' CONSTANT_B = 'B' CONSTANTS = [CONSTANT_A, CONSTANT_B]
Using a range with rand: `rand(10..20)` Shorter syntax for checking presence within a string: `"hello"["elo"]` Quick regex extraction: `"hello 1234"[/\d+/]` Ditto but with a matching group: `"hello 1234"[/[aeiou](.)/, 1]` Shorter interpolation of instance variables: `"hello #@myvar"`
`!()` is shorter to type than `true` as well. Ditto for `!!()` for `false` :-D
1. Did you implement the `on_message` callback in Plezi? Without the `on_message` callback, Plezi will assume that the controller doesn't handle real-time data and will refuse WebSocket connections. 2. Do you use the iodine server with Plezi (or or app)? Real-time with Plezi requires the iodine server. In fact, Plezi is pretty much a convenience layer around iodine's native WebSocket and SSE support. If you're only using WebSockets, you might consider using iodine directly and implementing a simple Middleware that will catch WebSocket connections. Good luck.
According to his logic people don’t need static typing at all but somehow they still use it in languages as different as Haskell, Java and Go
did you test this in irb?
Because it's much more literate than reading `!!a &amp;&amp; !!b` in case you wanted to make it clear that you're looking for `true` and `false`.
isn't a \`raise\` the very definition of a side effect? :D
Speaking of which, you can also do this: [ def hi; puts 'hi'; end, def bye; puts 'bye'; end, ] =&gt; [:hi, :bye]
Yeah, but I don't like how that reads. I think it gets too weird, however thinking about `@1` as an "instance var of this block" is much easier for my brain to cope with. Almost every time I write `items.map(&amp;Class.method(:meth))` I immediately retract it in liue of `items.map{|i| Class.meth I}`. It's shorter and easier to understand. Additionally, &amp;proc doesn't allow more than a single arg, where `@1` can be deposited anywhere. But, thinking of that last statement has me wondering what would happen in nested blocks? `array_of_hashes.map{ @1.transform_keys{ ...@1? ... ?} }`? That doesn't work as well.
They meant to use `()`s instead of `{}`s: File.join(__dir__, data, 'myfile.txt') .then(&amp;File.method(:read)) .then(&amp;JSON.method(:parse))
Yes sorry, i edited original code on my phone :)
Yes, that is how it is proposed, and I don't mind @1, @2 -- I've never assigned a real instance var like that. In fact, I think it's not even valid syntax currently (starts with number instead of letter), so I don't think it is used for anything. Here are some articles on the controversial addition: - https://bugs.ruby-lang.org/issues/4475 - https://medium.com/@baweaver/ruby-2-7-numbered-parameters-3f5c06a55fe4 - https://bugs.ruby-lang.org/issues/15723 The primary arguments against this are: &gt; I have an issue with this new feature: I think it encourages sloppy programming and results in hard to read code. but I would argue it is just another tool, and like any tool, it can be abused (as in your example (_sorry_)). Is the example I used above really so bad? Does that seem like hard to read code? I personally find it really pleasing, and come across this type of code all the time in data processing.
Lemme gently crash the application
In haskell the original example is spelled \`\['a'.. 'z'\]\`, by the way.
I still don't understand the use case of credentials vs regular old tried-and-true environment variables.
You'd probably be better served implementing this client side. Actually, regardless you'll need some client side action to interact asynchronously with the server.
What do you mean by that? Isn't this independent of the server anyway?
replace `raise` with `logger.info` and pretend you didn't see my rushed copy-pasta example haha
true, but it would still be a nice-to-have I guess. for example, I frequently find myself wanting to subconsciously use Rails conventions like `.blank?` for the sake of brevity.
100% agreed! Hence `"doh"`. I hop between 3-4 languages in a given week so there's a bit of `"doh"` time between switching contexts haha
Nope, still should do that.
It's nice to have credentials in source control so they can be deployed along with the code that needs them. Otherwise you have to edit and rebuild your environment before deploying code; at minimum that's an extra step to forget, but depending on your environment can be a huge pain. And of course you should never have unencrypted credentials in source control. Rails credentials is a way to avoid that while still getting the practical advantages.
That is voodoo
Finally. Using a 3rd party gem that does multi-environment thing. Why wasn't this a thing to begin with is beyond me.
JavaScript. The scrollspy action happens all client side. Bootstrap seems to be the JS library that comes with Middleman? [Have a look at this](https://getbootstrap.com/docs/4.0/components/scrollspy/). &gt; Actually, regardless you'll need some client side action to interact asynchronously with the server. What I mean is, you could conceivably implement the business logic client side, and have some JavaScript that makes calls back to the server, and triggers a partial page rerender... But that's convoluted and wrong. It was early and I hadn't had my coffee yet. :)
Yeah I get that, but the issue is middleman takes the markdown file and renders it as a set of header tags and paragraph tags, but I can't figure out a way to attach ID's to those elements so that they can be referenced in the sidenav.
Yeah so [here are the steps I've taken to implementing Plezi](https://github.com/daelynj/typinggame-server/pull/16) You can see I just used the provided Websocket Controller from [Plezi.io](http://www.plezi.io/docs/websockets). I believe my requiring the Plezi gem it begins to use the iodine serve with Plezi in Hanami, as all the server messages change and Iodine is started up etc. If nothing comes of this I will look into creating a middleware, thank you!
thank you, i did PM him and he did arrive here! If you think you might be able to help I put up a [PR with the code I've added](https://github.com/daelynj/typinggame-server/pull/16)
It's old, but have a look at [this blog post](https://willschenk.com/articles/2014/middleman-tricks-and-hacks/) where he talks about tricks he used. He mentions scrollspy exactly once... lol. Unfortunately, it doesn't seem like middleman has a huge userbase so you're probably better off asking on their forums rather than here.
FWIW Rails did add a [boolean cast](https://api.rubyonrails.org/classes/ActiveModel/Type/Boolean.html) method which might be of use
Using ruby in the terminal instead of sed/awk/tail/cut, etc. through a simple use of `instance_eval` : [https://github.com/thisredone/rb](https://github.com/thisredone/rb) `docker ps | rb drop 1 | rb -l split[1]` `find . -type f | rb 'group_by(&amp;File.method(:extname)).map { |ext, o| "#{ext.chomp}: #{o.size}" }'`
Excuse me?
Also not loving how it reads, but the @1 doesn't feel better for me :/
Uhhhhhhhhhhhh Wireshark.
Here's my favorite one: describe "some method" do it "does a thing" do result = literal_reimplementation_of_the_tested_method expect(method).to eq(result) end end
`dataset.where(...)` will always return a dataset in vanilla Sequel, Sequel will not try to evaluate it, until you call `#first` or another Enumerable method, at which point the SQL query gets executed. But I do like the safe navigation operator as well :)
I mostly agree, but in a duck typed language I like to check that my interfaces exists, meaning that it responds to certain methods and quacks appropriately. Notably missing from the article, testing private methods.
What about testing private methods?
Yes, no added value.
Wireshark is great &amp; powerful, but harder to set up for this kind of thing, noisier (you can't just intercept one terminal, you get all traffic from the system), and just gives you the raw data. Automatically decrypting HTTPS requests with wireshark for example is very complicated, and HTTP Toolkit comes with much more powerful tools for exploring the resulting data too.
Yeah, I figured out a way to do it. You have to create a CustomRenderer for red carpet that renders header tags with ID's based on the text inside them, and then you add it to your config.
Sweet! Sorry I wasn't more helpful.
If the private methods aren't working the public methods should break. The public method tests do the work of testing the private methods. It is just a bit further of an extension of the analogy `average_student_gpa` will break if `has_many :students` isn't working
Some argue that testing private methods is bad. I kinda like testing them if there's enough complexity that needs some sanity checks.
All good, I appreciate the help nonetheless. There's not much about middleman out there, and there's no "elegant" solution to this problem, either.
Cool
My opinion is the same. I've written about this [here](https://www.codewithjason.com/testing-private-methods/).
I test private methods, just not directly.
If you're private methods are hiding a lot of complexity they almost always should be in classes of their own.
Indeed! I don't think it has to be either/or though. Test private methods indirectly via the public methods that use them, and if the private methods grow sufficiently complex, refactor them into new classes.
Charles?
This is similar! But modernized &amp; more powerful (Charles hasn't been significantly updated for quite a while), open source &amp; working on platforms other than OSX, and with easier setup (you can intercept one window, not just the whole computer).
Nice, def. going to give it a try. A lot of the devs here at work love Charles, so I sent this around the engineering channel.
Awesome, thanks! Let me know if any of you have any questions or feedback, I'd love to know what you all think.
&gt; (you can't just intercept one terminal, you get all traffic from the system), You can filter by source port, but yet, requires an initial step of getting that port? &gt; Automatically decrypting HTTPS requests with wireshark for example is very complicated Yes, this is a good point. I would make this more prominent as now it's on the 3rd screen.
Except for the fact that you’ll need to transmit the master key to others out of band so that they can use it. We frankly found dotenv the least obtrusive way to organize this as we include a template with fake data and comments documenting what’s being used. Putting any sensitive data in a code repository, even encrypted, just smacks of irresponsibility. I’ve worked with far too many juniors and interns that will push sensitive data, like the master key, to github after being told not to do it, going so far as to edit it out of the gitignore file to do it, that I have no faith in this being a good solution. I can respect why this exists though.
This shorter interpolation of instance variables is a bug or is official ?
From the de-facto official Ruby reference book that Matz co-authored: &gt; When the expression to be interpolated into the string literal is simply a reference to a global, instance or class variable, then the curly braces may be omitted.
Why wouldn't you test the interface implicitly by using the methods? `.to respond_to(:foo)` is satisfied with `def foo; end`. Even the most basic static type checker comes with more guarantees than that (it would check the return type).
This seems like something I am looking for, but I really can't say since the website only has a download button. I can't find documentation anywhere on the site. Also at first glance I thought this was something I could interact with through ruby, not something that just intercepts ruby http traffic. Does this work offline?
Off the top of my head, include via module, concern, monkeypatch, dynamic metaprogramming. I don't really do static checking on ruby past rubocop and vim can only catch so much.
I'd add to this "don't test the framework" I've seen a fair number of people write tests that check things like `.save` worked. Thats fine if you have chances where save could fail, i.e. a callback that interrupts it, but if you don't you're just ensuring Rails works. And Rails has a pretty good test suite already
It's not something you can easily interact with directly from Ruby - it's a desktop application. You download &amp; run it, and it gives you various options for intercepting traffic. If you open a terminal from there, and run any Ruby application, all the traffic will be intercepted (and it then provides various features to explore &amp; understand that traffic). The app does work offline, yes, although your requests will fail of course if you don't have a connection to the HTTP server you're talking to. Is that clearer? Is there some other specific information you're looking for? Happy to answer any questions you have. The download is free, there's no catch, so you're also welcome to just try it out directly if you'd like to know exactly how it works.
Given this is the ruby sub, I thought this was something with ruby bindings. Either way it is something I will try. I've used fiddler, Charles, mitm-proxy for various reasons so I'm sure this will do what I want it too. I just really wish there was more information or documentation on the website. For example I can't figure out if this has its own https certificate, can be configured with one, or only supports CONNECT for https. It definitely looks nice, but everything else I use either has documentation, or an extensive feature/capability list/FAQ. Just my 2 cents
generally you call save to test stuff like custom validation errors raise properly IME
You forgot about #4: static typing.
IMO if they need to be tested, it's a code smell that they shouldn't be private methods. Sandy Metz has more to say about the subject if you google some of her stuff but usually private methods are things that are undeniably true, i.e. 1+1 will always be 2. If you have to test that you have bigger issues, i.e. runaway cowboy coders monkey patching core classes. If it's an omega mess type of private function, it's usually a code smell that you address it through decomposition into another class and test methods appropriately.
I've been using [`wannabe_bool`](https://github.com/prodis/wannabe_bool) for this.
Isn’t there a plan to add Stripe’s typechecker? I feel like I saw that somewhere. Or maybe that’s just something that can be used with Ruby.
Repost: https://www.reddit.com/r/ruby/comments/c1k7bl/im_worried_about_ruby_future/
I'm quite fond of `!!!??` as false.
Two more examples: def drive_service @drive_service ||= Google::Apis::DriveV3::DriveService.new.tap do |ds| ds.client_options.application_name = google_app_name ds.authorization = credentials end end def account_locked_possible_fixes [].tap do |fixes| fixes.push(:try_pin_reset) if unlockable_with_pin_reset? fixes.push(:try_sms_reset) if unlockable_with_sms_reset? fixes.push(:contact_us) end end
Chances are high it's gonna be File.join(__dir__, data, 'myfile.txt') .then { File.read @ } .then { JSON.parse @ } .then { my_function somevar, @ }
Sorbet from Stripe is available now. https://sorbet.org/
PS, I used to mess with all of those, but eventually stumbled upon Burp Suite. It's free, cross platform, and incredibly potent. Consider checking it out, as I was mad I didn't know about it earlier. Top features for me: - cross platform: I use all three main OS, so this part is awesome - the typical request/response tracking/filtering - incredibly potent request replay tools - the usual things, but also easy to automate ranges of vars to test the limits of an API (common case I use is "how many miles will your store locator let me search until your API pukes or hits some coded limit" - awesome diff tools and string decoding (b64, 0x, etc) so you can easily compare several responses after tweaking a request Anyway, you sound like someone that might be interested in this.
Charles is excellent, but there is some pain in the ass gotcha's. For example, having local or remote map of URLs isn't per verb &amp;#x200B; Ie you try and remap a specific URL where your browser makes a request on that URL first, but an OPTIONS request, it will match and forward to what you expected to be a GET request. &amp;#x200B; Not had time to look at the OPs link, but a GTK3 application that was a 'client' proxy to modify requests would be amazing. I looked at [https://tinyproxy.github.io/](https://tinyproxy.github.io/) but wasn't enough.
Hey, Hanami author here. Do you have a gist where that I can look? It isn't clear to me the code you wrote. Thanks!
I'm trying Drone, it's great. It's Docker based, you get started in a few minutes.
Is there a feature here that is not available in CharlieProxy?
&gt; everything else I use either has documentation, or an extensive feature/capability list/FAQ Good suggestion - I'll take a look at adding more details on the internals. It's a difficult balance between talking about the end functionality, for people not familiar with the details, and explaining how it works for those that are, but some separate documentation would definitely help there. &gt; I can't figure out if this has its own https certificate, can be configured with one, or only supports CONNECT for https. It does have it's own certificate (generated on first start up), which you can manually replace with your own if you prefer. It can intercept plain HTTP proxying (GET http://example.com/abc), HTTPS CONNECT tunnelled proxying (CONNECT https://example.com -&gt; GET /abc), and totally transparent proxying (GET /abc, inferring the host from the required Host header) - i.e. it supports pretty much anything :-)
The big one is the setup process. Charles can intercept the whole machine (which means getting a lot of traffic), or you can set things up manually (very fiddly). HTTP Toolkit has a selection of options for automatic setup for individual processes, so you can a browser window or a terminal, and see only traffic that comes from that browser, or from processes run in that specific terminal. There's others too though. HTTP Toolkit gives you: * More powerful tools for exploring the body of the request, using the same internals as Visual Studio Code, complete with highlighting, regex searching, etc etc. * HTTP header docs, for every single standardized header, available directly on the header themselves. * Source information (clear icons &amp; summary info showing who sent every single request, at a glance) * Skimmable requests: the request list is highlighted by content type, status code, and includes the source icon, so it's really quick to find the things you're looking for Those are all free features, there's also a couple of paid Pro features: * Code generation - turn any request into a ready-to-use code snippet for 20+ languages * API integrations for 1400+ APIs, so you get relevant docs &amp; validation for the exact API endpoint, parameters, &amp; body of each matching request * Performance analysis - explanations &amp; validation of the caching &amp; compression behaviour of every request &amp; response, so you can understand exactly what all those cache control settings &amp; headers mean in practice. To be fair, at the moment on the other hand there is one thing Charles has that HTTP Toolkit doesn't: the ability to _rewrite_ requests, not just view them. That's coming very soon though, so watch this space :-). If you're keen, there's a link to sign up for updates near the bottom of the page, or on the page shown after you download the app.
I don't think the Anycable example is very interesting, I would rather want to see how you deal do it with Unicorn and the zero-downtime deploys it offers.
Along the same lines is my favourite: describe 'some method' do it 'does a thing' do allow(subject).to receive(:method).and_return(result) expect(subject.method).to eq(result) end end Mocking makes everything super fast! ;)
My test suite run-time just went from 8 hours on CI to 5 seconds locally. Thanks!
If you have credentials in source code you would have to do a new release for a change. With ENVs you don't have to redeploy the entire application again, you can patch the deploy and have CI handle it. We have it setup to automatically patch the deloy after someone changes an ENV varaible. So it's seemless. You don't notice the 'redeploy'
This is great! Couple of questions: - Does AnyCable work with systemd socket activation? - Are you running AnyCable on its own server? I'm also imagining that it could be run alongside of puma as an additional nginx upstream, routing requests to `/cable` to the anycable process. I'm curious because this past week I've been working on getting nginx and puma set up with systemd and socket activation so I can have perfect zero-downtime deploys... and there are some rough edges.
Hey thank you for showing up! The author of Plezi/Iodine was able to help me out a ton via DM. I ended up using Iodine as the server for Hanami so that I could utilize websockets. [You can see here](https://github.com/daelynj/typinggame-server/pull/17)
[https://github.com/soveran/syro](https://github.com/soveran/syro)
There you go: [https://github.com/ahmgeek/tram\_time/blob/master/api/app.rb](https://github.com/ahmgeek/tram_time/blob/master/api/app.rb)
Looks like something I need to test out, thanks!
I tried both the windows and Deb versions offline and they both just open a blank window
 describe Example do let(:my_example) { Example.new } before do allow(STDIN).to receive(:gets).and_return(3) allow(my_example).to receive(:loop).and_yield end it { expect(my_example.test).to eq('Invalid. Try again: ') } end Give that a shot.
What is all this ?!
You do need to be online the first time you open the app, and then it stores the UI indefinitely, in the background, so after that it should work offline forever. Is that not what you're seeing? Sounds like a bug if so, I'll do some more testing later tomorrow.
That’s so cool!
Okay, not what I meant by does it work offline. Why is the binary so huge if it has to download stuff first?
Ok... but explain the patch. E.g.: [what does this mess do](https://github.com/ruby/ruby/compare/trunk...Jesus:6ae534830d403d7423cea4565fa60fee043eac30#diff-6d840db07406437770b610102b284273R2076)?
Take my upvote
Judging by the non-associative `INCR` and `DECR` names used the parser, I assume that's code for parsing increment and decrement (`++` and `--`), though I could be wrong.
Ah, I see ok. Yeah, it doesn't download everything on first run, just the latest UI. That could be bundled, but since you have to download the installer and debugging HTTP always requires some kind of network connection the vast majority of first runs are online, so it's rarely a problem. Subsequent runs and normal usage are a whole separate beast of course. The download includes the core desktop application itself and the [server component](http://github.com/httptoolkit/httptoolkit-server/), which is where the heavy lifting happens including all of the interception setup, and the proxy implementation itself. The download isn't tiny but it's also not _huge_, e.g. it's 70MB for the debian package. It's hard to get stats on desktop apps nowadays, but as a comparison that's about 1/4 of the size of the iOS apps for any of Facebook, Uber, LinkedIn, Twitter, etc etc etc. I'd like to shrink it of course, but given very limited time and a long list of feature requests etc it can't be my top priority. It is all open source on the other hand, so if you'd like to have a shot at it, dive in: https://github.com/httptoolkit/
&gt;debugging HTTP always requires some kind of network connection I never said I had no network connection, just offline, as in offline from the internet This is the only http interceptor I have ever used that doesn't work offline. You should have an offline version available, just not as the first option. Wish I could give it a try, from the screenshots it looks interesting.
It's often easier and more obvious to directly test the edge cases of the private method than it is to construct a test case that would hit the edge cases of the private method through the public methods.
what what is `/*%%%*/` and why does the next line have `/*% %*/`?! This is really cool, but it raises way more questions than it answers...
thats just [yacc](https://en.wikipedia.org/wiki/Yacc) stuff. the syntax is godawful but its widely used for writing parsers for compilers
There are several typos in the article, and other errors like `i = 1 + 1` where you meant `i = i + 1` -- it could use a good proofreading.
I bet you can’t implement pipe operator...
Ok, sorry about that. I will look into it, and see if there's any quick steps I can take to improve this. I'm very curious though - what situation are you in where you can post on reddit and download an installer, but don't have any internet connection available when the app starts?
Give me a couple of days and I will show you Unicorn example.
1) Yes, it does 2) Sure you should add additional upstream in Nginx and route everything from /cable to it
Thanks that would be very helpful.
Good stuff, tiny improvement lots of work :D
Air gapped network.
Something like that ``` def pack_varint(data) ordinal = ''.b loop do byte = data &amp; 0x7F data = data &gt;&gt; 7 num = data.positive? ? num : 0 ordinal += [byte | num].pack('C*') break if data.zero? end ordinal end ```
I wouldn't shorten a method at the cost of readability just to satisfy an arbitrary cop. For me it looks fine :)
Thanks that is what I was looking for.
You're probably right but I don't like the green squiggly lines in my code and just overriding the cop feels wrong :D
You can also inject an object representing terminal interactions into \`Example\` and then provide a mock when testing. This would allow you to keep implementation details like error messages in \`Terminal\`. For example, instead of \`p "Invalid. Try again:"\` you would call \`@terminal.error(:invalid)\`. This way you would not need to repeat the error message in the tests.
Can't you just tell Rubocop to leave your perfectly valid and readable method alone?
I second the notion on readability, but if you wanted to, you could extract that conditional into its own method, with a signature something like \`sign\_sensitive\_pack(data)\`
Maybe they always want i to equal 2
This is the vid I originally watched to get up and running. It's kind of long, but he goes through some typical setup that can be really valuable in the long run: https://www.youtube.com/watch?v=L4un5IppoY4
While thinking about this concept for these posts, I stumbled into this as well, and think it's much better than `@1, @2`, mostly because I found `@1` tucked inside a nested block jarring. But having `@` made it feel less so, since it doesn't have a ... "name", it's just a symbol. What's your take on the syntax? Are you a lover or hater? (You don't get to be in the middle, this is the internet!)
Yep, that’s what I would do...
Keep in mind sometimes it has to happen. Where I work has an 800 line method
I love the part where all the code we saw doesn't work and then the article ended.
Rubocop is really useful because it alerts you when a you _may_ be writing code that is hard to read, but it does not replace your judgement. There is no harm to add exceptions where it makes sense.
 # rubocop:disable Metrics/MethodLength 10 lines per method is ridiculous.
The _one thing_ Ruby shows restraint on.
Yeah, I'd keep the code as it is. Long methods are a code smell, but this code smells like lilacs.
I know right, I use 5.
This is what Sandi Metz (and I guess some other people too?) call OmegaMess. It's not pretty, it might even break rules, but it works and it doesn't depend on anything else, so it's okay to let it live.
Wow you must be so productive.
Joking aside, [I find 5 to be a good number](https://thoughtbot.com/blog/sandi-metz-rules-for-developers) to force things to stay clean. Rules are meant to be broken though, those are just guidelines, but they do help level up your Object-Oriented Design skills.
I expected a new implementation of Ruby. Clickbaity
but `logger.info` is a side effect also! In fact, `.tap` is married to side effects, there's no point in having code that a) doesn't produce some sort of side effect (or effect in general) like mutation, IO, exception, etc b) doesn't have a return value. Since `.tap` doesn't return anything, it's left with option a. I understand what you meant by "side effect" there, though, sorry for being pedantic :)
I think they're trying to implement it on Ruby 2.7, copying it from elixir
Doesn't i always equal 2?
I'm dealing with the exact same problem, except with Jekyll instead of rails. Luckily the interface with Jekyll is pretty narrowly defined, so I can stub it without too much difficulty. If at all possible, I say stub it. You're not testing rails, you're testing your plugin. That said, I only barely know what I'm doing
You should checkout *Ruby Under a Microscope* then. :)
Thank you for your answer, the problem I'm facing is really nasty, my gem is an authentication gem, so the integration testing with rails and different version of it is required, I am trying to setup a dummy rails application and try to start it in my test setup, I saw this type of approach on some gems but I really don't know how to handle this problem
That doesn't sound fun! I'll be interested to hear how you solve it. I guess a simple rails app is the way to go. Script the setup and various configurations you need to test it properly. Whatever you do, don't just give up and only test manually. I've been doing it that way for awhile and it sucks.
That doesn't sound fun! I'll be interested to hear how you solve it. I guess a simple rails app is the way to go. Script the setup and various configurations you need to test it properly. Whatever you do, don't just give up and only test manually. I've been doing it that way for awhile and it sucks.
&gt; That said, I only barely know what I'm doing 😆
How does your gem interact with Rails? It's not uncommon at all to create a dummy Rails app as part of your test suite.
?? care to say more about what that means and what it implies? the readme is of no value.
Sure - this as just an example of showing ruby running as a unikernel using OPS - [https://ops.city](https://ops.city) / [https://github.com/nanovms/ops](https://github.com/nanovms/ops) \- but the short of it is that it can run your ruby apps as unikernels which means it can inherently run safer than linux and faster - it's one application running as a very small vm instance (no systemd/linux/docker/etc.) so it's just easier to deal with as well.
thank you. looking forward to a discussion from others about this.
[Rails Engines](https://guides.rubyonrails.org/engines.html) have the same requirements around testing as you do. They way they approached it is to create a simple Rails app inside your testing directory. If you follow the tutorial on [how to bootstrap a new Rails engine here](https://guides.rubyonrails.org/engines.html#generating-an-engine), you'll end up with a folder under `test/dummy` (or `spec/dummy` if you are using RSpec) that has a complete Rails app ready for testing. Here's an example on how that folder would look like [in a real project](https://github.com/Shopify/shopify_app/tree/master/test/dummy). Inside this `dummy` directory, you can configure the Rails however you like, integrating it with your gem. I tend to write my gem integration tests inside `test/dummy/test/`, which means that they will behave like a regular Rails application test, loading Rails as it would for the gem user. Keep in mind that you'll have two change your working directory to `test/dummy` to run your set of integration tests this way.
I like it. I would have also liked `@1`, `@2` though. I didn't like `\1`, `\2`, and other proposals were worse (and unimplementable).
If it's end-to-end testing, Capybara (w Selenium if you have JS). If you're just testing the controller, rspec like this: https://thoughtbot.com/blog/how-we-test-rails-applications#controller-specs
I'm afraid the flip-flop operator was deprecated in Ruby 2.6 and is up for removal in 3.0. https://bugs.ruby-lang.org/issues/5400
I’m happy that you figured out.
I maintain the graphviz gem and use it for these kinds of things. It’s super easy to use.
Examples from the README: require 'time_calc' t = Time.parse('2019-03-14 08:06:15') TimeCalc.(t).+(3, :hours) # =&gt; 2019-03-14 11:06:15 +0200 TimeCalc.(t).round(:week) # =&gt; 2019-03-11 00:00:00 +0200 TimeCalc.now.floor(:day) # =&gt; beginning of the today diff = TimeCalc.(t) - Time.parse('2019-02-30 16:30') diff.days # or any other supported unit # =&gt; 11 diff.factorize # =&gt; {:year=&gt;0, :month=&gt;0, :week=&gt;1, :day=&gt;4, :hour=&gt;15, :min=&gt;36, :sec=&gt;15} TimeCalc.wrap(t).+(1, :hour).round(:min).unwrap # =&gt; 2019-03-14 09:06:00 +0200 times = ['2019-06-01 14:30', '2019-06-05 17:10', '2019-07-02 13:40'].map { |t| Time.parse(t) } times.map(&amp;TimeCalc.+(1, :hour).round(:min)) # =&gt; [2019-06-01 15:30:00 +0300, 2019-06-05 18:10:00 +0300, 2019-07-02 14:40:00 +0300] TimeCalc.(t).step(2, :weeks).first(3) # =&gt; [2019-03-14 08:06:15 +0200, 2019-03-28 08:06:15 +0200, 2019-04-11 09:06:15 +0300] [API design justification](https://github.com/zverok/time_calc#api-design)
I love it!!
`.+` is absolutely not idiomatic ruby... in fact, I'd argue you should never call `.+` as it affects order of operations. nor is `TimeCalc.(t)` idiomatic. Which makes no sense to me... you're calling a nameless function? Also, how is this better than DateTime? `Time.now + 3.hours` much more idiomatic and much easier to read. I know you did you don't like numbers with functions, but everything is an object, no reason for numbers to not have functions... (after all `+` is just a function)
I agree wrt to `.+`, it should not be written in Ruby. As for `.(`, it is a very unreadable shorthand for invoking the `#call` method...
Ahhhhhh, gotcha, thanks.
&gt; readable, idiomatic &gt; `TC.(t).+(3, :hours)` Neither very readable nor idiomatic. Compare to ActiveSupport, &gt; `t + 3.hours`
TBH, all of your concerns completely expected, and I even promised to myself I will not try to explain and persuade, but... Let's do it at least for the sake of the future reference. First, I am obviously pushing boundaries of Ruby we are used to write (not only in this library, it is my constant modus operandi, I am still that guy you should blame for `#then`). But I have a firm belief that in all of my experiments I am staying true to language's spirit. Second, people constantly confuse "idiomatic" with "what I am used to" and "readable" with "how I typically write it". In fact, in a spirit of language where "every thing is an object" and "(almost) every operation is a method", and "everything is chainable", `x.+(y)` is more "idiomatic" Ruby than `x + y`. Ruby's design does obvious compromise towards mainstreamness with "regular" math and logical operators and precedence (because every language that refused to do so stayed in "esoteric" camp forever), but it doesn't make `.+(arguments)` less "idiomatic Ruby". In fact, even before `TimeCalc` conception, our codebase made moderate use of this approach in some of the chains: calculate .something .with .clear .flow .+(1) .clamp(MIN, MAX) It is _unusual_ but not _unidiomatic_. On the intention of calling `+` (which is obviously the most recognizable name for "add") with a _tuple_ of arguments, `.+(the, tuple)` is strange from the first sight, but pretty sound compromise. Probably if we'd had (like Python) separate "tuple" concept, I'd end up with just `TimeCalc.(time) + (num, unit)` `callable.(args)` is 12 years-old (since Ruby 1.9.3, for God's sake) idiom of "calling the callable object". "Callable object" is less known, yet existing in the language concept (separate from proc's), which makes everything having `.call` method kinda special. I argue that for "value wrapping", `Type.(value)` (use this type as a callable) is _more_ idiomatic, even if less used, than `Type(value)` -- yes, we have `Array()` and `Integer()` in language core, but it is again, compromises of old era. Now, on `Time.now + 3.hours` -- it is a typical "Railsism" -- it is "just nice" even if does not makes sense, or produces some deeper problems. It doesn't honor the semantic of data (because `3.hours`, or "call operation `hours` on number `3`" is very weird way to produce very weird data type: "something that, being added to Time, increases it"). It doesn't honor language core (requires [redefining](https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/time/calculations.rb#L260) `Time#+`, which means that on every "ActiveSupport-infected" codebase, even if AS was required on some gem, you pay an invisible price on EVERY call of `Time#+(anything)`). In other words, it goes a long way to look "nice" in an eye of a beginner, with usual Rails' disregard for language logic and consistency. That's why I tried to think of another way of doing things. PS: Sadly enough, I have very low hopes of persuading anybody, so I am just explaining the reasoning behind my design decision, but will not do a slightest attempt to fight for them. Feel free to downvote :)
https://www.reddit.com/r/ruby/comments/c9rxni/time_calc_simple_time_arithmetics_in_a_modern/et3bff5/
This looks very promising. Good job! I'm wondering though, why are you using a class-based interface that is a starting point? Have you considered building an API based on a time calculation **object** instead? I reckon with an object-based API you could provide a nicer UX and if you invert the order of args (ie `[:months, 2]` rather than `[2, :months]`), you could have partly applied operations which would be very powerful.
&gt; Have you considered building an API based on a time calculation object instead? Well, if I am understanding correctly, that's more or less what previous iteration ([time_math2](https://github.com/zverok/time_math2)) did. But using it only eventually, I finally understood I still want something "more natural" and easier to remember, e.g. as close to "tm + some period" as possible but without AS-alike "hacks". I think about the current approach (and my similar [hm](https://github.com/zverok/hm) library) as a something loosely resembling "monad": for not core_ext'ing `Time` (or, in hm's case, `Hash`), I am "wrapping" it into something that has all necessary operations, process, unwrap. TBH, I am pretty happy with current UX, but I'd like to see what you have in mind :)
So is NanoOS itself open source?
Yeah I’ll try to come up with a PoC to better explain what I have in mind!
If you want people to use (or maybe you don’t but then I don’t see the point of advertising it) your library, explaining your design choices to them is kind of expected. Now, that’s what you did just after but it would have been inevitable? I like your choices because they feel like a fresh air in how we can read (and write) ruby. Any reasons you won’t fight for what you believe into?
Another more "idomatic" ruby time calculation library / gem - units-time - using a Timestamp and Timedelta class. See &lt;https://github.com/s6ruby/units-time&gt;. Happy programming with ruby.
[https://www.youtube.com/watch?v=6L8yUY-doNc](https://www.youtube.com/watch?v=6L8yUY-doNc)
Sometimes the answer to "how do I test this class/method?" is that you can't (or can't easily, or shouldn't), and that you have to restructure your code in order to make it easily testable. My approach to this would be to separate the code into two parts: one part that's responsible for calculation only, and one part that's responsible for output only. I would write tests for the calculation part, and I would make the output part so "dumb" that I wouldn't worry about testing it. The side benefit is that the resulting code might be easier to understand as well.
&gt; Second, people constantly confuse "idiomatic" with "what I am used to" and "readable" with "how I typically write it". They aren't confused. That's what it means: how a typical Ruby programmer would write something. &gt; x.+(y) is more "idiomatic" Ruby than x + y No it isn't. And initializing an object with `.()` is certainly not idiomatic when `.new` exists. There's nothing wrong with your API, but it isn't idiomatic Ruby.
&gt;I think about the current approach (and my similar hm library) as a something loosely resembling monad": for not core\_ext'ing Time (or, in hm's case, Hash), I am "wrapping" it into something that has all necessary operations, process, unwrap. Why not just use refinements? Then you can have a (probably nicer) API that extends the core classes without infecting the code base of the library's user.
Here's the test code I came up with. (I renamed `test` to `ask_for_number` to avoid confusion.) ```ruby RSpec.describe Example do subject { Example.new } context 'input is greater than 5' do it 'returns true' do expect(subject).to receive(:puts).with('Input an integer 5 or above') expect(subject).to receive(:gets).and_return(6) expect(subject.ask_for_number).to be true end end context 'input is 5' do it 'returns true' do expect(subject).to receive(:puts).with('Input an integer 5 or above') expect(subject).to receive(:gets).and_return(5) expect(subject.ask_for_number).to be true end end context 'input is less than 5' do it 'asks repeatedly' do expect(subject).to receive(:puts).with('Input an integer 5 or above') expect(subject).to receive(:gets).and_return(2) expect(subject).to receive(:puts).with('Invalid. Try again:') expect(subject).to receive(:gets).and_return(3) expect(subject).to receive(:puts).with('Invalid. Try again:') expect(subject).to receive(:gets).and_return(6) expect(subject.ask_for_number).to be true end end end ``` I also wrote a whole blog post for you about this called [How to test methods that involve puts or gets](https://www.codewithjason.com/test-methods-involve-puts-gets/). Hope you find it useful.
This seems like a decent start although I have two issues with this test: 1. By mocking \`loop\`, it seems to me that the behavior of the method is changed fairly fundamentally. 2. It only covers the invalid case, not any valid cases.
&gt; Why not just use refinements? Several reasons. Main, being initially fond of refinements, I found out people typically aren't very happy with gems implemented with them. Second, I am not sure they will seriously help here: because of `1.year` problem (I don't like it not because it is core ext, but because its semantically vague, so even with refinements I'd probably stick with `Time.now.+(1, :year)`); and because of `using Something` in every module where you need just "2 days ago" is not really convenient for small(ish) utility library.
Interesting! Are you doing this for fun or do you have some personal goal with this? Also, is the goal to run Rails with mruby basically and allow new code to be moved into Rust? Or will Rust run Rails? The former probably means no speed up for Rails itself, right?
Can get a bit extreme, though, getting all those little bitty methods doing a single job.
You just need an idea of something to model that is many-to-many? Friends in a social network.
`5.*1+1` is equivalent to 5*(1+1) or `5.*(1+1)`. As soon as you use method syntax (i.e. `.*`) for the multiplication, the rest of the line gets passed to the method as an (un-parenthesized) argument.
I love and hate this. I love that it presents a small but consistent API, but there's a few things that rub me wrong. For me, I'd rename `+` and `-` to `add` and `sub`, replace the `call` hijinx with normal class usage, chain calls automatically (no wrap/unwrap) with an explicit `time` accessor, and make `!` variants of the relevant methods that return the time instead of self. ``` TimeCalc.new(t).add!(3, :months) # =&gt; Time TimeCalc.new(t).add(1, :hour).round(:min).time # =&gt; Time TimeCalc.new(t).add(1, :hour).round!(:min) # =&gt; same as above ``` I like the timezone preservation, and duration (Diff). Sequence is great - it's unclear from the docs if there's a next function that just keeps iterating but I'd assume so.
While I am doing this for fun, ferrocarril would allow a team to gradually pull parts of their application out of Ruby into Rust, which is a safer, more performant language in a backwards compatible way for the rest of their code. I am not aiming to reimplement Rails in Rust. Even so, Rails may run faster by virtue of parts of Ruby core being implemented in Rust. For example, in some cases, ferrocarril's implementation of `String#scan` is [twice as fast as CRuby](https://github.com/lopopolo/ferrocarril/pull/138).
Good points, although my intent was merely to help get the current test working. How it’s improved, other specs that could/should be included, etc was beyond the scope IMO. Had I been doing this as a real PR review, I probably would’ve added a lot more detail. As this seems to be more of a learning exercise, that felt like overkill.
[This](https://launchschool.com/books/oo_ruby) might help with classes. For one-to-many relationships, perhaps an example will be helpful. Suppose you have UPS packages. One address might get many packages, but each package can only have one address. So, you have two tables: Addresses and Packages. How might you set those up?
* `.call`, BTW, is just an alias for `.new`, so you can totally do `TimeCalc.new(t)...` * I am skipping over `+`/`-` love/hate thing, I accept tastes difference (but you can do your own aliases and still have all the parts you like... TBH, I even though about "less extremist" method aliases like `add`/`sub`, but was too lazy to) * `unwrap` (not `time`/`to_time`) is because it works with `Time`, `Date`, `DateTime`, and it would be kinda awkward to say `TimeCalc.new(Date.today).+(3, :months).time` (yes, you can have 3 methods instead of 1, but I prefer to have just _one_ way to say "the same type that was passed to constructor") * `Sequence` is just your normal `Enumerable`, so you can do `enumerator = sequence.each; enmerator.next; enumerator.next` if that's what you want * and as for `!` proposal, it rubs _me_ wrong -- as `Time` in Ruby, weirdly enough, is not 100% immutable (look at `#utc` and `#localtime`), one may expect `TimeCalc.new(t).something!(...)` to _modify initial `t`_
Everything about seems reasonable to me.
how much of this would be reusable or adaptable for a similar integration with gtk/ruby?
Have you considered using blocks for wrapping/unwrapping? Like this ``` TimeCalc.(Time.now) { |t| t.+(1, :day).-(1, :second) } ```
Doctors and patients Products and customers Butts and seats
Yeah, a lot of my comments do wind up as personal taste for sure. Maybe my initial suggestion for bang was backwards from logic, ‘TimeCalc.new(t).thing!’ returning the TimeCalc with a modified internal value, where the non-‘!’ methods do the return would be cleaner? Looks nice regardless, and 100% worth considering outside Rails (inside rails, convention being what it is, consistency trumps a lot).
It seems like a lot of things that exist to make life easier for solving issues in production are being sacrificed in the name of making a fast booting and "secure" vm. If those are really the two driving factors, why use a VM at all?
Right I just need something like many to many User review movies One user has many reviews One movie can have many reviews User has many movies through reviews
Deeply alarming. &gt; Through comparing changelogs of published versions and their source code, they realized that the 0.0.7 version was published on Rubygems.org six months after the last release and with no source code changes published to the GitHub repository. &gt; When scanning through the commits for 0.0.7 version of I don't understand, with no code changes published to github, how did they get a commit history? Or did the OP just mean scanning through the diff between 0.0.7 and previous version?
These stories always makes me feel slightly vindicated, because I know so many people who rag on me for being so gem or node library avoidant. I still use them, but keep to absolute minimum.
I feel like it’s time for everyone to start locking dependencies to explicit versions at all times. Yes, trusting semver is more convenient but we keep seeing the same scenario play out: trusted library receives mysterious update containing exploit that is quietly downloaded by everyone because their packages allowed upgrades.
It's dependencies of dependencies that you don't really have control over. Gotta be conservative with `bundle update`
&gt; Idiomatic means "using, containing, or denoting expressions that are natural to a native speaker." Then ActiveSupport's `3.hours` wasn't idiomatic when it was introduced.
I share your aversion but particularly for node packages. I'm in the habit of auditing the contents of every delta following `bundle update` or `yarn update`, cross-checking revised versions with the github release history, changelog, and diff. With gems, that's not so bad. Most mature gems don't change terribly fast, most gems are self-contained or have relatively few (or very common) dependencies, and most gem authors have adequate RCS hygiene (and one can select out those that don't). The JS ecosystem however is a fragmented nightmare with often very sloppy standards and a thicket of ever-changing dependencies that you didn't opt in to. I find it a dramatically more time-consuming task for node packages.
If you already use nginx as a reverse-proxy, nginx already does the job of a reactor. In this case, are Puma reactors still useful, or just superfluous?
Javascript is the new PHP.
I think within the month it will be yes - stay tuned
many (tech) companies are wedded to the cloud (aws/gce) - the vm is the basic unit of compute there so that's why it's a vm - but it also provides a base security model - for instance there is no intention/desire of ever porting nanos to run on bare metal - it'll always sit on top of the hypervisor &amp;#x200B; as for solving production issues - I'd say it's no less different than other similar "hands-off" models - containers/serverless/heroku/etc.
Rubygems are effectively zip files. You can diff that against the last publicly available version, and snyk is a vulnerability scanning service, so I'd assume they compare against the GitHub repo. It is possible that the gem actually included the git folder, which provides extra context. Perhaps snyk should start a project to diff all gems against their upstreams. Grepping those diffs for eval would find any obviously malicious code like this. A proper solution would be to sign the gem with the source commit hash and publish that on rubygems, to allow anyone to double check that the gem is actually from the latest GitHub version. There is some complexity around this as packaged gems are not snapshots of the git repo, but nothing unfeasible to work around. Providing extra guidance and reducing friction is the only way that will happen though.
Games and Gamers. Artists and Canvases. Workers and Work Orders. I feel like you could make anything up and make it work... Politicians and Lies.
And doubly so about security. I would not accept any security related gems that is not made by someone with reasonable credibility. And that includes for handling jwt, credentials, etc. Its so incredibly easy to think that crypto algorithms just work as they are — they don’t and you should avoid crypto routines like the plague unless a serious cryptographer has validated it.
What's the advantage of this over Charles?
I've been looking for library like this. Thanks !
JavaScript has achieved the improbable: making PHP look secure and well-disciplined in comparison. The fact that world+dog seem intent on pushing JS as The Solution to Everything™ should fill us all with mortal dread, inspiring us to stand up to those promulgating the Official "Wisdom". A casual glance at their background tends to indicate a highly non-technical, business-oriented mindset reminiscent of a joke that was going the rounds a few decades ago: "We will pay any price to cut costs!" That price is too likely to be the industry's viability.
This is why our projects now only install specific versions of Gems before running `bundle install --local` (adding `--frozen` unless Gem versions are known to have changed). It's inconvenient; it's initially rather haphazard; but, until and unless verifiable cryptographic signing of Gems becomes a widespread thing, it's the best defence we have.
&gt;A proper solution would be to sign the gem with the source commit hash and publish that on rubygems Do you mean adding the git hash as a file inside the gem (or in the gemspec) before signing the gem? I usually do it the other way around. I build and push my gems. Then I calc the md5/sha hash of the gem and commit that hash to git. What do you think of that? In either case it requires that you as a user need to look up this info and manually verify the gem. It would be nice if this could be automated somehow. Hm, perhaps this lookup could be done inside a script that is executed on install.
It's absolutely true that you should keep your dependency chain to a minimum because invariably a large portion of them likely have one or few contributors making them quite susceptible to this. On the flip-side when it comes to cryptography and authentication - these domains are often easy to leave holes in your security when you write them yourself. It's best to use a popular - well maintained and tested authentication system (along with auditing it yourself - you can know that it will continue to be maintained).
Again and again. I've been talking about that for a while now: [https://mensfeld.pl/2019/05/how-to-take-over-a-ruby-gem/](https://mensfeld.pl/2019/05/how-to-take-over-a-ruby-gem/) &amp;#x200B; Also you can review DIRECT changes of each of your dependencies before bumping here: [https://diff.coditsu.io](https://diff.coditsu.io) (example: [https://diff.coditsu.io/gems/strong\_password/0.0.5/0.0.6](https://diff.coditsu.io/gems/strong_password/0.0.5/0.0.6)) (I'm close to OSSing that) and get notifications about outdated stuff before bundling/bumping using this: [https://coditsu.io/](https://coditsu.io/) \- here's an example: [https://app.coditsu.io/karafka/builds/validations/f3ce606c-a71a-46d7-809a-c914a65071d7/offenses](https://app.coditsu.io/karafka/builds/validations/f3ce606c-a71a-46d7-809a-c914a65071d7/offenses) &amp;#x200B; I am working towards adding a "mark as safe / mark as unsafe" for each of releases (as I review literally hundreds a month), so we could as a community do a per release sources review. I will probably have it done next week. &amp;#x200B; I'm also working towards releasing ALL of the tools OSS for Ruby community (part already is: [http://github.com/coditsu/](http://github.com/coditsu/)) and I've wanted to integrate the differ with RubyGems as well as build even more sophisticated tools but the speed of reaction of RubyGems is rather slow. &amp;#x200B; ref: [https://github.com/rubygems/rubygems.org/issues/1918](https://github.com/rubygems/rubygems.org/issues/1918) ref: [https://github.com/rubygems/rubygems.org/issues/1853](https://github.com/rubygems/rubygems.org/issues/1853) &amp;#x200B; It seems, the only one that cares about that kind of stuff for Ruby is me ¯\\\\\\\_(ツ)\\\_/¯
Thanks for creating this, I love that you're coming up with fresh solutions for time calculation! One suggestion I have is to alias `TimeCalc#call` to `#TimeCalc#[]`, so that you can do `TC[t].+(3, :hours)`. I would personally prefer that syntax, as it would communicate to me: "this `t` object is a starting point".
On the face of it, that should work just as well. However, it makes it impossible to delegate the act of verification. For example, snyk (or anyone else so inclined) could set up an alternative rubygems source that only distributes gems that have been verified in such a manner. They can then cryptographically sign a certificate of verification, and write an extension to the rubygem client to verify that on download.
So basically the same way SSL certificates work. Interesting!
Can we have two-factor auth on Rubygems soon?
Obviously MFA for the website &amp; cli already exists on rubygems. It does look like both the recent gem hijackings could have been mitigated just by having it enabled. Is there a reason for rubygems not to just set a date, and enforce MFA for all new gem publishing after that?
You are right, I didn't notice that they had MFA, it is very hidden though.
Fair enough!
It's worth mentioning that starting with ruby 2.5 `[]` can take a block parameter so this could also work ``` TC[Time.now] { |t| t.+(3, :hours).-(2, minutes) } ```
Great work with [https://diff.coditsu.io](https://diff.coditsu.io/), that seems pretty handy! &amp;#x200B; I (we at Snyk) care about it too. I'd be thrilled to connect and see what more we can do in the ruby sec space :-)
It's just a tip of the iceberg of my security work that is ruby related. I've PM you with my email.
JavaScript's fine. I just don't use Webpack and friends, avoid npm for frontend, and use my packages the old way. I'll typically have one, maybe two or three libraries included, not 100. (Backend and Node does worry me, since there it's harder to avoid package proliferation.)
These issues come up again and again, yet nearly nobody signs their gems. I'm guilty of this as well. Not sure when the wakeup call will occur for the masses. For me, it may have....
There needs to be an easier way to maintain our own decentralized repos.
There is no rule that every gem published needs to be on github, or a publically accessible repo at all. If it did have to be on github and had a source commit hash, it would really only make the attack somewhat harder -- the attacker would need to compromise github credentials too -- and somewhat easier to spot (as you say, you already have the source code in a ruby gem, ruby isn't a compiled langauge -- a vulnerability scanning service doesn't need to compare against the github repo, just the diff between last version and present version). At least Github has 2-factor auth. Really, the biggest improvement for the cost is probably having rubygems support (or require?) 2-factor auth. Not a magic bullet, but would improve things. They've been talking about that for a while, and rubygems receives Ruby Together funding -- I wish they'd prioritize it.
So *not* getting an update that has a security patch is probably at least as big a risk as getting a rare malicious update. You'd also have to explicitly list all your *indirect* dependencies in your Gemfile, to lock down all your indirect dependencies to explicit specific versions too. Alternatively, rather than explicitly locking down versions in your Gemfile, you could just rarely run `bundle update`, only run it with the `--conservative` flag (so it it won't update indirect dependencies unless it is forced to), and review the `Gemfile.lock` diff to make sure it didn't do anything you didn't expect. You don't need to explicitly lock to specific versions with bundler -- your Gemfile.lock already does lock to specific versions, which only change as a result of a `bundle update`. But I don't think this is a solution. Because, as we started, *not* getting updates with security patches (including in indirect dependencies) will just become a bigger risk then. In all the recent discovered cases of malicious gem releases, I think (correct me if I'm wrong; if not all definitely most) it wasn't the 'real' author who turned bad and released malicious code, but rather their credentials were hacked and someone other than them was able to do a release. I think the biggest improvement would be to security of rubygems accounts, to make it harder for someone to gain unauthorized access to release. I am not sure why Ruby Together-funded rubygems isn't prioritizing this more.
I did not know MFA already existed for rubygems. And I follow ruby news probably more than many. I will go look into it presently. I think it needs to be advertised more widely. I think every time you do a gem release from an account that does not have MFA enabled, it should probably warn you/inform you of the option and risks.
For most of the attacks we've seen, someone unauthorized has gained access to rubygems accounts to do a release. Gem signing would only be an effective protection if the same access they got to rubygems to do a release didn't *also* give them access to register a new public key. I'm not sure I have a handle on the actual systems necessary to make gem signing actually a practical defense here; I am sure that simply turning on a gem-signing feature doesn't neccessarily give you additional security. It's all about how you know which keys are authorized, where you get that information from, and if that source of information is any more secure than the rubygems. Gem signing might work for an attack where someone is MiTM-ing rubygems gem servers (or might not even, depending on how the "what is the public key for this gem author" lookup works) -- but that's not the attacks we've actually seen. I'm not convinced gem signing is the right avenue to be focusing on.
I believe we have seen several malicious gem releases that seem to have been caused by compromised rubygems accounts. Someone else on this thread alerted us to the fact that rubygems does now support (although not require) MFA. Here is the [rubygems guide](https://guides.rubygems.org/setting-up-multifactor-authentication/) on it. Note that it only supports "an authenticator app (like Google Authenticator or Authy)" -- it doesn't support SMS MFA. I am not familiar enough with this area to understand the technical specs on "an authenticator app (like Google Authenticator or Authy)" -- what authenticator standard is that? It would be good to say in the guide. MFA is of course only an option not required. It is clearly alone not sufficient. I can think of some additional features: * Many gems have multiple owners; for open source sometimes distributed across many organizations. It should be possible for a gem owner to set a requirement that *all* owners have MFA set, and/or that releases can only be done with an MFA login. (As well as adding additional owners!) * Right now there is only one level of access to a rubygem 'owner'. It should perhaps be possible to give an account access to do releases, but not add/remove owners. * It should probably record *whether* a gem release was done with MFA, and what account did the release, and make this publicly available from rubygems APIs and web pages. This would make it possible to have a bundler feature "only upgrade a dependency (including indirect) to a version that was released with an MFA login." * On another front, rubygems.org perhaps ought to be checking all accounts using the [haveibeenpwned API](https://haveibeenpwned.com/API/v2) The other problem is that there will probably never be mass adoption of "authenticator app" MFA -- because it's a pain, and keeping the recovery codes around is a pain. I know SMS MFA isn't truly secure (SIM hijacking is a real thing), but I wonder if the increase in adoption would still be a net security gain. (i know, you can say everyone *should* be willing to deal with an 'authenticator app' (does that require a smartphone?) -- but then there's reality. I don't think we've seen statistics on how many rubygems accounts have MFA enabled -- or how many rubygems accounts used to recently release have. I am confident it's not a large portion). I also wonder if there are additional rubygems login protection methods that could be considered. What if the rubygems login (for doing a release -- which is from the command line already) could use ssh keypairs instead of a simple password? And you register the public key similar to how you do with github? AND what if to register a pubic key you needed a one-time link *emailed* to you? Right now I'm not sure rubygems.org even verifies access to the registered email account. Maybe that above suggestion isn't helpful. I'm definitely not a security expert. I think rubygems.org should probably spend more money on security experts to recommend what can be done to *practically* increase security of accounts. MFA that nobody's using isn't it.
Object oriented design often yields methods that are longer than five lines. We don't merely design objects and methods that do one thing, we must also seek to maximize the value delivered by each object and method. Lots of unnecessary indirection is not good OO.
Make the IO device a dependency, and pass in a StringIO in your tests. Then assert on the contents of the string tied to the StringIO instance. Do it this way and you won't need any specialized features from your test framework.
Make the IO device a dependency, and pass in a StringIO in your tests. Then assert on the contents of the string tied to the StringIO instance. Do it this way and you won't need any specialized features from your test framework.
It really depends on the language. Ruby allows for short methods, so does Smalltalk. Java not so much. I agree OOD is more than just short methods, but in Ruby you rarely have the need for long methods if your design is proper. And yes, you do design objects which do just one thing. A lot of refactorings exist just for that...
You didn't understand what I wrote. Note the use of the word "merely." Five lines of code can comingle unrelated concerns. 20 lines of code can perform a single, coherent task. There's little connection between number of lines and design quality. It's a sham metric.
not typing all that in, mate.
That would be what Sandi Metz calls an OmegaMess. They are okay, but not good design. As I've said, you rarely need long methods, long methods are not bad by definition, but 90% of the time they point to a design problem. And even then, sometimes it's convenient for them to just live, but again, that doesn't mean is good design :p
Sorry, I didn't expect anyone to. I just wanted to give an idea of what the test was like. I've gone over the correct answers with a classmate so I have that, I just don't know how what I'm failing to understand.
The idea here is to protect against a supply chain attack, or at least make detecting it easily. The idea is that if you can secure parts of the supply chain, then you're moving the target so the attacker needs to compromise accounts that are easier to detect attacks on, or more heavily secured (2FA, signed commits, HSMs, etc). I think it's better to move the goalposts altogether than to simply "defend them better".
The design has nothing to do with the _contents_ of the method. It has only to do with the _interface_. A good design is substantiated by what it does and how you use it, not by aesthetics (i.e. how the code looks). If you are consistently keeping methods under five lines your are probably harming code readability (which is *not* design but also important) by some combination of avoiding whitespace lines that aid scanning and moving logic to private methods that force the reader to move around the file needlessly.
I think they're suggesting maybe you use something like pastebin or gist if you want to share code.
I'm not sure how to help without knowing what it is you're supposed to be doing. Maybe try using Gist or Pastebin or something to show us your code as well as the README. Did they tell you what you got wrong?
You're getting you're Customer.find_all_by_name method wrong. It's been a while since I used Rails, but I think it should be Customer.select{ etc etc } rather than @first_name.select { etc etc } At the moment it just loops through the single string @name, rather than the entire database of names
the readme might help and are there any comments as to why you failed?
If you want some help I would be happy to call and discuss this over Skype or Discord(DM me) but I would need to know what it is that the test asked of you and what it is that the Bootcamp failed you on. Mainly a python-dev but have worked in Ruby before too so happy to help. There are one or two issues I can see straight away that are middling in size but your understanding of Ruby seems good.
They just said I didn't get enough of the methods correct to pass. The test was on Friday afternoon, so we should be going over it more this week. [Here's a link](https://repl.it/@panda427/DeafeningAmazingFile) with all my code and the ReadMe. The methods that are commented out I got from a classmate after the fact.
They just said I didn't get enough of the methods correct to pass. The test was on Friday afternoon, so we should be going over it more this week. [Here's a link](https://repl.it/@panda427/DeafeningAmazingFile) with all my code and the ReadMe. The methods that are commented out I got from a classmate after the fact.
Thank you, I appreciate the offer! I might DM you about that :) They just said I didn't get enough of the methods correct to pass. The test was on Friday afternoon, so we should be going over it more this week. [Here's a link](https://repl.it/@panda427/DeafeningAmazingFile) with all my code and the ReadMe. The methods that are commented out I got from a classmate after the fact. I feel like I understand the concepts but have a really hard time keeping everything straight when I'm doing it. I had 60 minutes to do this.
What pieces are you struggling with? Let me ask some diagnostic-y sorts of questions: &amp;#x200B; * Do you have a sense of what it means (conceptually) to think in terms of objects and classes of objects? * If your program had only a single class of its own (for example, your \`Customer\` class), would you understand how to: * instantiate/create it (e.g., \`Customer.new\`) * assign an object to a variable (\`my\_customer = Customer.new\`) * understand what happens when that variable gets passed around (\`puts my\_customer.name\`) * Are you struggling with the syntax (e.g., you've seen \`@\` as convention, but aren't sure what it's actually doing?) * Is the coding bootcamp recommending or requiring you use class variables (\`@@\`)? Can you think of an alternative way to keep state from the \`Customer\` class using a class variable for all objects (as you have it)? * If a customer is associated to exactly one restaurant, have you considered storing the list of customers as an instance variable on the \`Restaurant\` itself? &amp;#x200B; The first few of these I suspect you already understand, but I know that when I was learning Ruby, I was making use of constructs I didn't fully grasp (hence, I wasn't making use of the right constructs for a given problem).
Just noticed you don't actually have any relationships.. When you get customer reviews, you shouldn't be doing a map of Customer.all, you should have the relationships automatically set up. https://guides.rubyonrails.org/v5.2/association_basics.html#the-has-many-association That guide explains what you need. Each model should have a relationship defined at the top. So each review belongs to a customer. So at the top of the Review model you need "belongs_to : customer" and at the top of the Customer model you need "has_many : reviews" Now when you do customer.reviews, it will automatically get all the reviews for that customer. You really need to get a handle on object relationships, because they are basically the main underlying logic behind rails! https://youtu.be/5mhuNSkV_vQ
I'm not saying design is the content of methods, but when it happens that methods are too long, it points that out. Code is pretty subjective though so arguing about things like readability it's quite pointless :p
This is a ruby assignment not a rails assignment.
Ok so here is a bit more directed feedback(I had more of a look). &amp;#x200B; I can't see the exact order that you did things but it seems to me that a logical approach would help with the timing issue. I would follow their instruction of &amp;#x200B; &gt; If you are not sketching out your domain, and thinking about single source of truth, you are doing it wrong :( &amp;#x200B; this seems key. I know you can't easily provide a diagram but even doing a basic .md file would help. &amp;#x200B; A tactical logical approach can often save you a lot of time when coding as you know what you will need to create and what it will interact with. Plan each of your classes and what methods they will have, then make the bare bones of them and fill them in logically.
I think I understand classes vs. objects pretty well. I've been thinking of classes as a blueprint or machine for making each object instance. So I know that my_customer is an instance of Customer. I can instantiate a new customer, and assign it to a variable. I did have trouble trying to write my own tests for this exam. Like I was trying to write things like ```restaurant_one = Restaurant.new("Starbucks") p restaurant_one``` Outside of the class, but was getting errors and I couldn't figure out if I was calling the methods incorrectly (outside of scope) or if the rest of my code was incorrect. It's only in the past couple days that I actually figured out a lot of the syntax and overall concepts behind what I'm actually trying to do here. It wasn't until we started learning SQL that some of it clicked. So it's been helpful to think of the classes as SQL tables, and doing something like .map being similar to a SQL command like SELECT * FROM customers They are requiring we use class variables, but only @@all. I know that I can use it so that I can call ClassName.all, and I know the syntax I need to write to make that happen. I know that in the 'review.rb' file, I didn't need to write out longhand methods for all the instance variables that I'd actually already put in the initialize method and given an attr_reader. The README made me feel like they wanted me to write methods with those names, and I didn't realize that's what I'd been doing all along with attr_reader. When I need to do something like list all the reviews a restaurant has, I know I need to access it via the reviews file, but beyond that I feel like I've just been memorizing syntax. You rock :)
What are you trying to do then? Where is the error? P.s. your link is just a blank ruby file
So about 25 minutes into the exam I realized that the customers and restaurants have a relationship through reviews. I'd been thinking that customers and reviews have a relationship through restaurants. I went and changed everything about halfway through the alotted exam time. I read that line about sketching out my domain and figuring out the single source of truth and I realized in that moment that we'd always been able to see in the spec file for every homework project something like, "Artists have many genres, through songs," which told me that 'songs' was the one linking the two (I've been thinking of it as a SQL join table).
It looks like your biggest issue was not implementing everything you were asked to implement. There were a couple places (lengthiest review, for example) where the code could've been more concise. And there were a one or two little careless mistakes like this one: def reviews review.map do |review| review.restaurant end end Here you're looking for reviews but you're returning an array of restaurants. If I find myself forgetting to implement things I usually try to make a list of each thing that needs to be added and then check them off as they're completed. Sometimes I'll just go ahead and stub out all the methods without implementing them and put some type of assertion in there to remind me to implement it. def self.find_all_by_first_name(name) first_name.find { |person| person.name == name } end I suspect here you probably wanted to iterate through each person not 'first_name' which is probably undefined at this level? You're then comparing the 'name' attribute on each customer but your customer class does not have a name, it has first_name and last_name. def self.find_by_name(name) @@all.find { |customer| customer.name == name } end Similarly with the above, you're checking name but there is no name attribute. You can check full_name, though. Customer.all.find { | person| person.full_name == name }
Oh I dunno, I'm not OP, just wanted to clarify that I think he hasn't gotten into rails/db specific stuff yet. I believe he's just starting out and is learning OO/Ruby.
&gt;(I've been thinking of it as a SQL join table). I would avoid that analogy, generally thinking about one concept as some other concept can be misleading. I would think about how things actually connect. For example in this task: Review instances each connect to a Customer and a Restaurant instance, each Review has a rating and a content. A list of reviews contains all Review instances. &amp;#x200B; While it may appear similar to join tables this isn't the same relationship.
Okay, this is really helpful. This is the first time the first and last names had been separated and I think that contributed to me getting confused. I think I should read up more about initializing and using attr_accessor. I wasn't sure if I should only add the variables I did or if I needed more. Maybe I'm not super sure why I'm even doing that. I definitely forgot entire methods I needed to write, but the giant countdown timer on the wall was freaking me out. I'll bring paper next time and make a list of what I need to do. I usually write out def methodname end for everything when I start.
Okay, thank you for that! I was just looking for a way to conceptualize it in my mind. I'll just think of them as instances as you describe. Thanks :)
Yeah, I'm just learning OO Ruby at this point, which is why it's hard to find practice materials online. Everything I find uses Rails or something else. I have the actual homework labs for class, but couldn't find anything extra to practice with. I tried making my own with flight/passenger/ticket, but when the method calls weren't working I wasn't sure if it was the code or the file structure. I had to look up how to make a run file to connect them all.
def method_name # Implement me end Yeah that works too. Sometimes I’ll do something like above. That way I can search for implement me to see if I missed anything.
I don't think it's all that subjective, but if I take that position for a moment, I'm left wondering why we're talking about a Rubocop rule?
Oh, smart. I'll do that. Thank you!
So you're suggesting there be a requirement that rubygems releases must be on Github? Or another public repo? Right now there is no requirement that ruby gems be in a public repo at all (and they could be obfuscated code if someone really tried, or 'compiled' code if someone invented a way).
Without the analogy to artists/songs, or looking at spec files, you should be able to figure this out. For a Review object, do you need to know what Customer made the review? yes. Do you need to know what Restaurant was being reviewed? Yes. So a Review needs to link to both a Customer and a Restaurant -- otherwise, how would you know what customer made the review, and what restaurant they were reviewing?
Yeah, agree with your summaries, I think you have a pretty good grasp on stuff. Collections methods can def be analogous to SQL (C#'s collections can even be queried with SQL-like syntax [called LINQ](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/introduction-to-linq-queries)) &gt; When I need to do something like list all the reviews a restaurant has, I know I need to access it via the reviews file, but beyond that I feel like I've just been memorizing syntax. Gotcha, yeah. How code gets organized with multiple files varies by pretty much every programming language (for example, Java soft-requires that a class called `MyClass` go into `MyClass.java`). In Ruby, it's mostly arbitrary, aside from most engineers following the convention of class-per-snake-cased-filename. You can have many classes in a file, or even no classes in a file (like a `main.rb` entry point that just uses other files' classes). Since I didn't see require statements for the files in your link, if you're having trouble with the mechanics of getting the files loaded (`require` not seeing them), make sure you have your load path set to include the directory with your source files. With pry, you can take a look at your load path with the `$LOAD_PATH` global (and even add to it for experimentation purposes, like `$LOAD_PATH &lt;&lt; File.dirname(__FILE__)`). The interpreter has a `ruby -I` flag to add an additional load path. Alternately, you can use `require_relative` to load whatever file happens to be relative to the file the interpreter is currently running through. I think some experimentation might help give you a spark of insight - you should see if you can get it working how you want with everything all a part of a single file. Once you've got that going, you can move things out piece by piece. Since you want to go from restaurant -&gt; all of its reviews, you'll probably want to start with a particular Restaurant object, and query off of that (which I see you've already got ready in the commented-out "Correct" version in restaurant.rb:36).
If one signs their gem and the person installing it wants to check signatures before installation can succeed they must download the author's cert and add it as trusted. If one advertises where their valid cert is stored (assuming this is not compromised), and the person installing downloads and adds this, how does it not work? What am I missing? Of course the onus is on the person installing.
Just out of curiosity, did you call your methods to see what the output is? Do they teach you about `binding.pry` as a means to step through your code to see what it's doing? Being able to check and step through these things is very key to being a developer.
I try to use binding.pry, and all my classmates do, but I feel like I can never get it to work. I tried calling the methods but wasn't sure what I was doing wrong. Some of them responded but not all of them. I need to practice that.
Not trying to throw more pressure on you, but being able to properly step through and debug code is a massively necessary skill for a developer. I'd work with an instructor or someone who knows how to use binding.pry to figure out how to use it.
Thank you, I'll ask my teacher for a lesson about it!
Hard requirement? No. Soft requirement that adds mandatory warnings on both the server and client side that the gem wasn't able to be verified, absolutely. The entire thing here is that rubygems accounts are being compromised. We can either make them harder to attack, easier to detect such attacks, or do what I'm suggesting: make it don't matter if they're attacked. In a perfect world, you'd do all three, but best bang for the buck comes from the last one. Make it so attacking a rubygems account just doesn't provide anyone with a way to meaningfully attack anyone.
Rubygems has 2 factor support or am I missing something? https://guides.rubygems.org/setting-up-multifactor-authentication/
Giveaway - Follow @driftingruby and retweet this to enter to win a free Dragon Ruby license. Event will end by August 1st, 2019. &amp;#x200B; [https://twitter.com/DriftingRuby/status/1148074922826194949](https://twitter.com/DriftingRuby/status/1148074922826194949)
Awesome! I was just about to roll my own Apexcharts wrapper a few weeks ago but decided on not to do it right now and started working on something else. Will definitely be using this for an upcoming project!
Thanks. Looking forward to your feedback.
&gt; A proper solution would be to sign the gem with the source commit hash and publish that on rubygems, to allow anyone to double check that the gem is actually from the latest GitHub version. If I have access to the rubygems account, I can publish whatever commit hash I want, can't I? I can also change the registration of the public git repo.
Seems interesting but more info, especially a roadmap, would be usful before dropping $40 on a license.
This turned out great. I’m diggin it
Looks awesome. Nice work! One suggestion: add an introduction to the README explaining the connection with apexcharts.js, etc. Right now, it’s super bare. I had to read this Reddit post to fully understand the project... but I should be able to find out everything about this project just from the repo itself.
You're right. I guess I just forgot to do that. :P Really nice input. Thanks. :)
No problem!
That original example is much less readable than the more standard \`('a'..'z').to\_a\`
Pretty much, yeah. Unless you save the public repo at the time for each published version. Public repo changes are probably a breaking change anyways, and in combination with signed tags it may be sufficient. To get around the whole thing you'd need to sign the metadata including the source repo and commit hash, and solve the trust problem. I think the best way to do that is through a trust hierarchy, where the packaging authority (e.g. rubygems.org) can delegate authority with some good defaults and mechanisms around key rollover and renewal. X509 could probably be used as is, although there is probably a place for a better solution (multiple attesting signatures, restricted delegation, etc).
If you’re interested but on the fence, you should get involved in the itch.io forum or slack. The devs are pretty open to questions
I think `then` is a code smell. It's another form of a violation of the Law of Demeter (which I hold loosely, but it is worth considering). More to the point, it results in a long chained statement that is more difficult to follow. It usually indicates there is a hidden object that needs to be extracted into its own class. In this case, the loading of the file into JSON is a different responsibility from whatever \`my\_function\` is part of. class MyData def intialize(filename = 'myfile.txt', path = __dir__) @filename = filename @path = path end def json JSON.parse file end private def file File.read filepath end def filepath File.join @path, @filename end end #call it with instance my_function(somevar, MyData.new.json) #call it with a different filename my_function(somevar, MyData.new('otherfile.txt').json) This encapsulates the job of reading the file and getting the json away from the more interesting stuff of what to do with the data. It also allows for more flexible code to alter the name or location of the file (dependency injection), and it also allows for easy stubbing of the \`json\` in tests to avoid having to load a file in tests at all. &amp;#x200B; Overall, this is is less "clever" but much more readable, maintainable, and testable...
Feel free to DM me if you want a short video call walk thru of your problem. I'm a mentor for some google startup programmes, and just got done helping coach my wife's friend into a UX+coding job following her bootcamp. 10 year Ruby veteran more than willing to help you learn whats going on, and get to grips with Pry/etc... Timezone is europe UTC+0200 if that can work for you. Happy to invest an hour of my time at no cost to you.
Been enjoying following along with these, thanks for doing them!
This is awesome! Thank you.
Thanks for watching! Which parts are interesting to you?
You're welcome.
Nginx will fully buffer the request, so puma will see that it has the full thing in memory and go ahead and start working on the request. It will never touch the reactor. &gt; I guess they can be if you use lots of websocket connections, which can only be handled by the application server (Puma). This is the only case I can think of. This was the original idea, though it is my understanding that anycable etc. already implement their own reactors. In the future we might expose the ability to hook directly into the puma reactor.
&gt; It turned out that any database command running in a thread checks out a database connection from the pool and neglects to put it back. 😱
I have some reservations about this approach. But at the same time it's also possible that I would take the same approach 🙃. I try to avoid method stubbing: it can lead your tests operating on values that do not represent what you'll receive in production. In your example you return an `Integer`, but `gets` returns `String`s ending with a new line. This is a very simple case, so one can see how easy it is for problems to arise when stubbing more complex cases. In the case of gets I think it's better to stub stdout and stderr: no dependencies on implementation methods! Though it can be tricky using `Kernel#gets` as various things can affect what this returns. E.g., running `rspec my_spec_file.rb`. Additionally: 1. the code under test calls `p`, not `puts` 1. `puts` and `gets` are private, so another argument against mocking/stubbing.
All valid points. Incidentally, I don't think I've ever actually used mocks or stubs when testing a real Rails application. Almost nothing I've coded in Rails makes use of `puts` or `gets` since everything just goes into an HTML page.
Yeah I really struggle to see this business model get anywhere close to enough adoption to sustain development
Google Authenticator implements RFC 6238 (Time-based One Time Passwords) and RFC 4226 (HMAC-based One-Time Passwords). [https://tools.ietf.org/html/rfc6238](https://tools.ietf.org/html/rfc6238) [https://tools.ietf.org/html/rfc4226](https://tools.ietf.org/html/rfc4226) [https://github.com/google/google-authenticator](https://github.com/google/google-authenticator) I work in security policy management and I can say that there's quite a bit of interest in these sorts of multi-factor authentication schemes. Many of our clients require their employees to enable MFA whenever it's available as part of their organizational password policy. I don't have the statistics in front of me, but I can say that there's quite a bit of uptake on using tools like Google Authenticator nowadays, at least in the sorts of clients we get, which granted are organizations looking to up their security game.
I'm not sure if that's what you mean specifically but I wrote a script to use Ruby in bash for various tasks regarding text processing and other stuff. [https://github.com/thisredone/rb](https://github.com/thisredone/rb)
OK, right, now we have a "trust hieararchy" involved. This becomes very non-trivial. So we're talking about a pretty complicated system involving X509, requiring code be in a public repo (which it never has before), and source commit hashes advertised in such a way that they can be automatically checked... With the goal being so we can trust Github (or possibly any public code hosting repo) to secure account credentials... so we don't have to trust rubygems to do so? Because we think it seems too hard to just get rubygems accounts to be secured as well as Github's... but we think that above thing seems easier? Why not just focus on rubygems doing the job of securing credentials well in the first place?
interesting, thanks. may take a look
Thanks for confirming schneems!
This is literally the top hit on Google for [Ruby web scraping](https://medium.com/@LindaVivah/the-beginner-s-guide-scraping-in-ruby-cheat-sheet-c4f9c26d1b8c). You’ll probably want to look at the [File](https://ruby-doc.org/core-2.5.0/File.html) docs to figure out how to write the results out to, well, a file. Good luck!
Checkout this video [https://www.youtube.com/watch?v=1UYBAn69Qrk&amp;t=704s](https://www.youtube.com/watch?v=1UYBAn69Qrk&amp;t=704s)
He didn't call it web scraping, so thank you for the article!
On mobile, so apologies if this is a bit unorganized. My end goal is not need to have much trust in rubygems or GitHub, but the developer themselves. The way to get to that point is to add optional fields to the gemspec in a built gem with the source repo location and commit hash. Even defaulting to GitHub or providing convenience shortcuts is a bad idea for this. If the source repo moves, it's a change that should be considered with some suspicion, and with good cause. The next step after that is to allow attestations to be added to a gem after the fact. Snyk (or anyone else) could verify that a published gem really did come from the given commit in the source repo, and further that the source repo hasn't changed. Another provider could add an attestation that the gem was signed by a developer who has confirmed their identity with them, and that ownership hasn't changed from the last version. The real question is where and how to push those into the gem. Are they extra metadata returned by rubygems in a different call? Are they added to the archive and the signature of the gem is computed without some .well_known folder? X509 or opengpg? Assuming nothing goes wrong, the worst an attacker can do is publish an extremely suspicious gem with a bunch of red flags that make it easy to spot. Signing gems already does most of the work, this is just me thinking of ways to easily automate the detection process.
The devs are game designers, so I would imagine this is not their primary source of income, but instead a way to monetize tools they already intend to make
&gt; I don't think I've ever actually used mocks or stubs when testing a real Rails application. Yes, I read that part :)
&gt; Rails 4 stopped truncating database string/text fields This isn't really what happened, and it's pretty important you understand why it's happening because your application may be a bomb waiting to go off. What changed is that Rails 4 enables 'strict mode' in MySQL by default, it was MySQL truncating your strings before, not Rails. MySQL without strict mode commits all sorts of horrific atrocities which you may find you were depending on in various places. It's worth reviewing everything strict mode enables and auditing your tables / queries.
I use Ruby for all of my shell scripts. It's so much nicer than bash! The Ruby standard library includes several utilities that make script-writing much more enjoyable. Take a look at: * [Pathname](https://docs.ruby-lang.org/en/trunk/Pathname.html) for general file manipulation * [CSV](https://docs.ruby-lang.org/en/trunk/CSV.html) for reading / writing CSVs * [Open3](https://docs.ruby-lang.org/en/trunk/Open3.html) for robustly shelling out to other commands Also, a self-plug... I wrote a few gems that I use in most of my scripts. They don't have many stars on GitHub, but I maintain them and use them almost daily. Feel free to give them a look: * [pleasant_path](https://github.com/jonathanhefner/pleasant_path) adds more utilities to Pathname * [dumb_delimited](https://github.com/jonathanhefner/dumb_delimited) is a sugary wrapper around CSV * [mini_sanity](https://github.com/jonathanhefner/mini_sanity) gives you in-line sanity checks so your scripts can fail-fast and not propagate bad data
wow, that's a whole new world. I actually wrote my first bash script earlier. Not too difficult but of course it expectedly can get more complex. Thanks!
http://rubyforadmins.com/ https://www.devdungeon.com/content/enhanced-shell-scripting-ruby
Thanks for making this Will share the series with my friends
I feel like we're not communicating. &gt; The way to get to that point is to add optional fields to the gemspec in a built gem with the source repo location and commit hash If an attacker has access to your rubygems account, they can do a release with whatever source repo location and commit hash they want. We have seen several malicious gem releases due to compromised rubygems.org accounts. So. This seems like a distraction to me. Making rubygems accounts harder to compromise seems the obvious priority to me.
ty!
One tip I would give is keep the actual script small and build with classes and gemify them. Bundler makes this fairly easy. The gems are then requireable in the main script and easily portable/testable. We write a lot of omega scripts at my place and despite my urging no one gemifies making setting up multiple environments much harder. Also pull all your settings out into either a config file or environment variables. Again portability being the gain here.
That's cool that they came up with this solution, found inspiration in Rack, and even put together a thoughtful post about it all, it's a really good read. But I wanted to take a moment to name drop Kiba. It's basically exactly this very thing, for all the same reasons. If this article is interesting to someone because of the nature of this problem, you may also find [this gem](https://github.com/thbar/kiba), and the many articles and presentations from the author useful as well.
Disclaimer: I’m very new to ruby and am actually learning the fundamentals myself, so if someone else comes through with a better answer, follow their advice. Start by making your three classes: Patient, Appointment, and Office. In the Patient class you’ll do has_many :appointments. In the Office class you’ll also put has_many :appointments. For Appointment you’ll do two belongs_to lines, one for Office and one for Patient. Then you can write methods for .create, .find/find_by, etc as needed in the...I think the Appointment class. That’s your single source of truth for the information you’re interacting with.
You're right that securing user accounts on rubygems.org is much easier and it will solve the immediate issue at hand. What I'm trying to say is that we have the option to secure the entire rubygems ecosystem against most supply chain attacks. We already have flags to only allow signed gems to be installed, so there is precedent for choosing to work with a subset of all the gems in existence. If you add a method for third parties to stamp their approval on gems, you can subscribe to some policies that say the gem is reproducible, the gem has a particular license, the gem has always been published by the same author, etc. It's a huge project, but made somewhat simpler because there are potential corporate partners who have a vested interest in selling a security product that could be based on something like this. Do you want to do what's easy and might work today, or do something that solves the entire attack class?
I was looking for something like this... Thanks for your post, will def try this out
You're welcome. Let me know what you think after trying it out.
This is just the classic Chain of Responsibility pattern. The writeup in _Design Patterns_ actually includes an example where a request is transformed along the way. It certainly is a powerful pattern, although for most dynamically configured business rule situations I prefer to use a mediator pattern for looser coupling.
Just an addition here: `#create`, `#find`, `#destroy`, etc. aren't necessary to write as he's using ActiveRecord. Writing a model that inherits from `ActiveRecord::Base` should be enough to give each model the persistence methods necessary.
I know this is a ruby dub but why not python?
Ahhh, that makes the difference, I didn’t know that. Thanks for the heads up, I’ll update the article. I trust you don’t mind if I mention you to give you credit.
ok, being ignored, here's a one-liner ``` TC = -&gt; t, &amp;b { b ? b.(TimeCalc.wrap(t)).unwrap : TimeCalc[t] } TC[Time.now].+(1, :hour) =&gt; 2019-07-09 09:58:27 +0000 TC[Time.now] { |t| t.+(1, :hour).-(1, :minute) } =&gt; 2019-07-09 09:57:45 +0000 ```
I would recommend abstracting the interaction def ask(question, **options) puts question answer = gets.chomp # You could add validation of the answer here via the options. # e.g. sanitation if the input is going to interact with the SQL database end You can use regex on the user's input to determine what they want to do, e.g. str =~ /create.*new appointment/i But that can get complicated, if you don't need it, you can present the user with a list of numbered valid options and restrict the valid user input to a number to select an option, then specify a name or appointment id etc.
https://hashrocket.com/ are another one that come to mind.
The general idea of this cop is not to make the code more compact, but to point potential pitfalls which might be (or might lead to) code smells. On the first glance, this method is not really related to anything else but the input parameter and looks like a typical pure function. Where is this method defined, what is the outer context? Is it a module, class? Are there any other methods in this object? Are they related in any (logical) way? What I would suggest to do in such case is to move this method to its own class. If there are other methods related in a logical way, you could just place them in object nested within the same namespace. If you extract this into a method object it would become very clear, that this is indeed a pure function, it would make test more readable, it would make it harder to actually brake the purity, introduce coupling, etc. Normally the way to reduce amount of code is to extract some part to another method. Some people will tell you that this breaks the flow and makes you jump around. If you keep your classes small too, it's not an issue. Methods require names, so this provides just extra documentation for free. Before you just had a block of lines of code. Now you have to name that block, so when you come back to the code in 3 months you will know exactly whats that about. The worst thing to do when reducing number of lines is to change multiline `if` to tenary operator or swap multiline block to single line ones. It's not about compacting logic into a code golf, but to organize your code in a different way. Let's check what we can do: First just move it to its own class: class DataUtils::PackVarint def self.call(*args) new(*args).call end def initialize(data) self.data = data end def call pack_varint end private attr_accessor :data def pack_varint ordinal = ''.b loop do byte = data &amp; 0x7F self.data = data &gt;&gt; 7 ordinal += if data.positive? [byte | 0x80].pack('C*') else [byte | 0].pack('C*') end break if data.zero? end ordinal end end Add some tests to make sure you wont brake the implementation: require "rails_helper" RSpec.describe DataUtils::PackVarint do let(:service) { described_class.new(data) } describe "#call" do context "with data set #1" do let(:data) { 123_123_443_222 } it "computes expected value" do expect(service.call) .to eq [150, 204, 234, 213, 202, 3].pack("C*") end end context "with data set #2" do let(:data) { 354_322 } it "computes expected value" do expect(service.call) .to eq [146, 208, 21].pack("C*") end end context "with data set #3" do let(:data) { 0 } it "computes expected value" do expect(service.call) .to eq [0].pack("C*") end end end end And now you can try to move some things around. First thing to notice is that you are checking if the data has positive value twice. Maybe you can work around that? Just a quick idea - if you go straight for the line count, use the fact that break can return value from the loop (and then from the method): class DataUtils::PackVarint def self.call(*args) new(*args).call end def initialize(data) self.data = data end def call pack_varint end private attr_accessor :data def pack_varint ordinal = "".b loop do byte = data &amp; 0x7F self.data = data &gt;&gt; 7 next ordinal += [byte | 0x80].pack("C*") if data.positive? break ordinal + [byte | 0].pack("C*") end end end You are looping over something and doing things to the values. Maybe this seems like a good candidate for a more functional approach? The part with the condition for last element is tricky and Ruby is not exactly that functional in the end, but this could work too: class DataUtils::PackVarint def self.call(*args) new(*args).call end def initialize(data) @data = data end def call *head, tail = input_sequence.to_a head.map(&amp;pack).join + pack[tail, 0x00] end private def pack proc do |number, num = 0x80| [number | num].pack("C*") end end def input_sequence (0..) .lazy .map { |x| @data &gt;&gt; 7 * x &amp; 0x7F } .take_while(&amp;:positive?) end end Are any of those examples better than your initial implementation? I don't know. Is recursion more readable than loops? If you switch from say PHP to Haskell it will hurt your eyes in first day, but many projects later it will be as readable as for loop is for you now. People telling you, that 10 or 5 lines per method is crazy are most likely coming from other languages. When switching languages, one often takes all the knowledge and tries to apply old ideas to new environment. It will sort of work for some time, but every languages has its own style, and keeping within that style makes your code more familiar to other members of the community. For me Ruby actually is about short methods and small classes.
How do I I verify if user ‘s name already exists in the database
Thanks
🙏
Wow, that's a really detailed reply. Thanks a lot. This gives me a lot to think about!
true. well, just have extensive training in ruby already, worked on linux command line a lot on production hosts but not for scripting. actually just wrote first bash script yesterday. Gotta learn some syntax but wasn't incredibly difficult... well my script was kinda simple.
The moral is that there is very few definitive answers in this field in the end. I would probably extract many of this logic into separate method objects, but I wouldn't argue hard about that. There are tons of conditionals in methods, which do not relay on anything in the class. They probably require many tests with edge cases, so they would greatly benefit from being separate from the rest (both tests and code). &amp;#x200B; From may experience it depends a lot on your local tooling and environment. If you organize your work place in such way, that jumping around is easy, extracting stuff and creating classes is easy, then there will be very little friction and your overall design will benefit from that.
And what does MessageEncryptir use as its backend crypto solution? OpenSSL? I’d like to see a proper vetting of its solution before encouraging others to try it. Crypto isn’t just another thing to abstract away without diligence.
With very limited development resources and current problems with security, I think it's important to do whatever will have the greatest security impact for the least development. Until we have all the well-established solutions and best practices, that means working on those instead of trying to do R&amp;D innovation in complex systems that have not been proven. Does any other dependency repository implement the kinds of things you are talking about, and can demonstrate *practical* success with them? If there is, it could be a very good guide, and to have that as a model would change the cost-benefit, true. I don't personally know of such. I think you under-estimate the difficulty of getting such a system right (both in technical security ways, and in UX ways such that people are willing to use it in a way that provides actual, not just theoretical, security improvements). I think it would be a mistake to focus on complex innovation in the area, to the detriment of the lower hanging fruit that is not being addressed.
By all means. Roll your own encryption solution. That's never gone badly for anyone.
I am not a security expert but kind of trust Rails on using secure defaults for it's build-in classes . [https://api.rubyonrails.org/v5.2.3/classes/ActiveSupport/MessageEncryptor.html](https://api.rubyonrails.org/v5.2.3/classes/ActiveSupport/MessageEncryptor.html) looks like its OpenSSL with aes-256-gcm under the hood.
You will need to specify more clearly that you only compare byte streams in the :all mode because two different page content streams may contain the same contents. One reason for this is that whitespace can be used freely inside a page content stream. You could use the [diffpdf](http://www.qtrac.eu/diffpdf.html) application instead.
Which begs the question why they aren't using the better NaCl solution by Daniel J. Bernstein (Ruby wrapper: https://github.com/crypto-rb/rbnacl)? The code behind MessageEncryptor also follows a bad practice of allowing developers to set the cipher (something cryptographers direly warn against, which NaCl prohibits, and which is a major early in many JWT implementations). I don't know enough if its use of SHA1 as the default digest method for signing is advisable but I'm sure better solutions exist at this point. The security domain is not one that our typical programmer logic works well with; when you take a single shortcut, you can lose all security. I'd say go with a vetted security solution. Even several underlying Linux security methods (e.g., /dev/urandom) prefer DJB's methods. I understand that the Rails team wanted something anyone could use without another dependency (openssl), but it's not something to brag about.
Awesome comment! Interestingly, this must be one of the design patterns omitted from _Design Patterns in Ruby -- Russ Olson_ (as that's the one I have on my shelf ;) ). While reading the article, I remember thinking "Well, you are sort of composing your final pipeline with a builder" but you've clearly found a much closer analogy. Interesting that this one didn't make the cut in this book with how prevalent and powerful it seems to be. Thanks for sharing your insight!
Thanks for the insightful comment. Would you mind reposting it on a blog itself (anonymous commenting option is available so no need to login etc.) so that people finding the blog post later could find it and take into consideration when choosing their encryption method? Later I will add a disclaimer to the blog post referencing your remarks.
A few years ago DHH misquoted a rule originally about distributed objects and said something to the effect of, "the first rule of distributed systems is don't build a distributed system." It's funny seeing Rails starting to morph itself into a sort of monolithic take on distributed systems.
You clearly only read the title and not the post. It describes how to use ActiveSupport's built-in encryption features conveniently, rather than importing a new gem, with the assumption that built-in rails functionality will have better vetting and be more trustworthy.
This article is less about rolling your own encryption and more about using Rails’ built-in encryption utilities.
So you’re saying the title is a lie?
Not sure what they're using now, but Thoughtworks used a lot of Rails for awhile.
Only if you turn your brain off while you read it.
Wow, I bet you’re fun at parties.
Sure — gimme a day or so. I’ll tone it down a bit and add some helpful links. Reddit is one thing, but I don’t want to be that guy who leaves acerbic comments on other people’s blogs. BTW, thanks for putting the article together – MessageEncryptor is probably better than what a lot of Rails practitioners are using, and its worth a debate.
Platformatec? I mostly know them from their Devise gem, but I've never worked on an app that didn't use Devise as their auth solution.
Or you could use [mechanize](https://github.com/sparklemotion/mechanize) which has all the scraping built right in. Mechanize is the main reason Nokogiri was written.
yup. we've all been there.
Thanks! :)
Testing this out now. Apex charts look much better than kickcharts. There seems to be a bug with turbolinks enabled. I'm getting a type error in turbolinks when I have your gem displaying charts instead of kickcharts. But regardless, nice job man!
&gt; looks like its OpenSSL with aes-256-gcm under the hood. Remember to rotate your keys occasionally: &gt; The [total number of invocations](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf) of the authenticated encryption function shall not exceed 2^32, including all IV lengths and all instances of the authenticated encryption function with the given key. and &gt; [Max bytes for a single key](https://download.libsodium.org/doc/secret-key_cryptography/aead#limitations): 350 GB (for ~16 KB long messages) Might be better to rotate to `chacha20-poly1305`.
&gt; Which begs the question why they aren't using the better NaCl solution MessageEncryptor predates NaCl by about half a decade, and it's nice to be able to just use stdlib instead of needing another binary extension. &gt; The code behind MessageEncryptor also follows a bad practice of allowing developers to set the cipher (something cryptographers direly warn against, which NaCl prohibits, and which is a major flaw in many JWT implementations) NaCl includes multiple ciphers, it's even a TODO for its SecretBox because some environments demand AES. JWT's flaws extend [*far*](https://news.ycombinator.com/item?id=14292223) beyond merely being able to override a default cipher. &gt; Even several underlying Linux security methods (e.g., /dev/urandom) prefer DJB's methods. What?
Are you able to use third party libraries? [tty-prompt](https://github.com/piotrmurach/tty-prompt) is an excellent library for building CLIs. Thor is also very nice
I would recommend using subcommands instead of trying to parse regex. Docker, Git, and similar tools do this. e.g. ``` mycli appointment create mycli appointment delete ...etc... ```
&gt; Ruby lacks the increment operator (i++) which exists in pretty much any other language. This is just not true. There are a lot of modern languages which do not allow `i++`/`++i` and only allow `i += 1`
It's... not a great pattern, IMO demonstrated in use, including in rack.
I would suggest the README include at least a *basic* code example, without having to click on a link to get it. As a developer considering using it, it saves me a lot of time to see basically what it does, to have that on the README. I'm not necessarily willing to navigate links to find code examples.
Sure.
Sure, It's not my gem. I just like it because it's a great example of Ruby shining without having anything to do with a web app. I use it at work quite often for correcting and publishing data. Also, I respect the dude who wrote it, as he is very active in the community and is always cordial.
Arkency comes to mind.
Is this a reasonable way to encrypt big files?
Maybe point out why yes? Unless you need something specific that Ruby cannot offer doing things in Ruby (that you know) is better no?
I don't think so. It's supposed to be used for database column attributes. You could try to use it on a big binary column but I don't think that's the correct way to do it.
&gt; crypto is not something we programmers are competent at. What a fanciful notion. AFAIK nobody is using mechanical or human-backed encryption, so of course programmers lead the way. I'm not sure what on earth you mean by this, but it's nonsense and anyone that disagree's is promoting nonsense that harms both the ruby community and programmers in general
I thought it was common knowledge that python was good/fast at parsing large files and has great libraries for data analysis. Eg [pandas](https://pandas.pydata.org) Of course you should use the tools you are comfortable with and if time is important than definitely can’t waste time learning something under the gun.
Based on my experience, and I've written many terminal related gems([tty-prompt](https://github.com/piotrmurach/tty-prompt)), I would respectfully disagree with the mentioned approach. The tests look cumbersome and brittle. Usually, the tests tell you by being awkward and verbose to write that there is something missing in the design. I tend to take the approach of injecting the stream and then verifying responses on it. This way I don't have to stub and mock every interaction with canned responses.
Based on my experience, and I wrote many terminal related gems(tty-prompt) this is the best approach. It keeps tests simple and maintainable. You avoid mocking and stubbing every IO call and then when your code changes you don't get failures that say `puts` changed to `print` and this is not recognised anymore as stubbed method kind of brittleness.
The two agencies that I've been watching over the years from talks is Test Double (@searls) and Coding Zeal (@adamcuppy)
Thank you for trying it out. You mean chartkick. Yes, please send it to me. If you have a little bit more time I would really appreciate it if you also post an issue on the github page. I will try to fix it as soon as I can. Thanks.
/u/jb3689 suggestion is definitely going to be easier. Just make sure that you separate the functionality. Stick to single responsibility. The user interaction part shouldn't check if a user is valid itself, it should call something else to do it, so if you change your mind and restructure or extend the functionally you don't need to rewrite what you've got. As for how, I don't have experience with ActiveRecord.
Definitely mean chartkick. Yeah I'll post the issue on the GitHub along with testing a bit more so I can give a bit more insight into my problem!
you are misunderstanding my comment. i’m not comparing programmer-led to manual processes. I’m saying that crypto is first and foremost a mathematical discipline and it doesn’t follow the same systems integration logic that programmers are used to. missing one nuance doesn’t make crypto weaker, it breaks it completely. yes, programmers with an even stronger background in cryptography implement it.
&gt; I am not a security expert but kind of trust Rails on using secure defaults for it's build-in classes . Not the best plan...
Second reply. I actually found the problem. It throws an error if no data is passed to the chart. I had a help function that was returning nil because of a bug. Didn't even notice it. Sorry to bother ya! Thanks for the gem. Really appreciated!
Correct me if I'm wrong but isn't generating a static salt entirely defeating the precomputation resistance offered by having a salt?
Thank you.
Oh, okay. No problem.
&gt; it's nice to be able to just use stdlib instead of needing another binary extension I'm not doubting the convenience aspect at all. Installing libsodium is an extra stumbling block, no doubt. &gt; NaCl includes multiple ciphers, it's even a TODO for its SecretBox because some environments demand AES Thanks for pointing that out. So let me be more specific. MessageEncryptor not only allows you to set *any* openssl cipher or hash you want, but, from a cursory look at its code, any mode you wish (CBC/GCM/..how about ECB?). The defaults are good, but even [renowned programmers make terrible mistakes](https://blog.codinghorror.com/why-isnt-my-encryption-encrypting/) when they are allowed to toggle these parameters. Worse yet (and this was a JWT vuln), parameterization opens the door to injection attacks that can downgrade your security. &gt; JWT's flaws extend far beyond merely being able to override a default cipher. Thanks for the link. JWT was the Javascript community's attempt at doing crypto themselves, and I hold it as a case study of why package maintainers should not dabble in crypto. &gt; &gt; Even several underlying Linux security methods (e.g., /dev/urandom) prefer DJB's methods. &gt; What? In 2015, DJB wrote a [critique](http://blog.cr.yp.to/20140205-entropy.html) of how /dev/?random produces entropy. In 2016, Linux maintainers responded by [switching over](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=818e607b57c94ade9824dad63a96c2ea6b21baf3) to DJB's ChaCha20-based CRNG. Again, astute developers get crypto wrong. The greatest achievement of NaCl, imo, was not DJB's more efficient algorithms, but the highly opinionated approach to crypto wherein programmers are not allowed to make decisions on these matters. Fundamentally, the "I trust smart _______ maintainers to know their crypto" has been shown to fail over and over again.
Yes it is and we should ask OP to fix that. /u/pawurb, please pay attention to this. Each value (i.e., each combination of row and column) should have its own salt. reusing the same salt and same password means that same values will have same ciphertext, which gives attackers a very wide opening.
Pry is pretty simple to use. You place a binding.pry in your code where you want it to stop. Then you run the code and in your terminal you can try methods to see what they output. There's probably some YouTube videos that explain it better, but I can also screen share with you if you want to see an example. Granted I've only been programming for about a year and only for a few months with Ruby, but I can try to help.
No, /u/Jdonavan is right. By giving very basic access to openssl, ActiveSupport is making the user make crypto decisions they are not knowledgeable about. For example, how and when to generate salts. From a cursory glance, OP's article gets the implementation wrong. These are not decisions to leave to to programmers.
&gt; The defaults are good, but even renowned programmers make terrible mistakes when they are allowed to toggle these parameters That example's another case of there being no defaults, so the programmer is *forced* to make a decision. I'm not sure merely *allowing* it poses quite the same level of risk, but I get your point. &gt; Worse yet (and this was a JWT vuln), parameterization opens the door to injection attacks that can downgrade your security. That was from the user side, the infamous `alg: "none"` header that turned off signature validation on more than one implementation. That's an argument against *negotiation*, which MessageEncryptor doesn't have - it just tries the algorithms it's been told to by the programmer. &gt; In 2015, DJB wrote a critique of how /dev/?random produces entropy. In 2016, Linux maintainers responded by switching over to DJB's ChaCha20-based CRNG. Again, a set of astute developers got crypto wrong. Shame they didn't feel compelled to fix the semantics of their /dev/?random while they were at it. Blocking /dev/random is cargo-culted nonsense, and non-blocking /dev/urandom goes too far when it spews out unseeded random :(
My doubts of the validity of this library apart, yes, most modern symmetric key crypto is a valid way to encrypt files of any size. just don't reuse nonce or salt.
I think it’s true in that as long as you can avoid a distributed system you should, it’s a part of KISS. But oftentimes you have to build a distributed system, so it’s nice when your tool of choice plays well with that architecture. I’ll continue to use Sidekiq for my jobs. I’m glad the framework is getting more robust in its support for background jobs, but Sidekiq is the my go to for all ruby workers.
[Test Double](https://testdouble.com/)?
[Envy Labs](https://envylabs.com/) is another consultancy with a long-time Ruby history. Code School (Rails for Zombies, Try Ruby, etc) were from the group.
Sometimes some kinds of distribution is unavoidable. ActiveJob is super useful and a great part of Rails; if you got it, might as well do it right, "exactly once" guarantee is great (but I think you probably can already get it with ActiveJob with the right setup?)
Also, `find` only returns the first matching value. If you want them all, as the name of your method implies, you need to use `select`.
&gt; I thought it was common knowledge that python was good/fast at parsing large files Can you point me to a benchmark? It's not to my knowledge that Python is so much faster than Ruby in this, but I am curious to find out. &gt; and has great libraries for data analysis That is true, but the question was in general about Linux administration tasks, no? &gt; Of course you should use the tools you are comfortable with and if time is important than definitely can’t waste time learning something under the gun. That was what I understood from the original question. The poster has some Ruby knowledge... so my answer would be no Python needed :).
The documentation asked for a single restaurant to be returned. Restaurant.find_by_name(name) given a string of restaurant name, returns the first restaurant that matches
Book: The Rails 5 Way by Obie Fernandez Also look at: https://www.reddit.com/r/rails/comments/9u2095/learning_ruby_on_rails_in_2019/
Of course they do! If you are curious about Linux administration tasks, than SUSE's YaST is a Linux operating system setup and configuration tool that was ported to Ruby so maybe there is something to be found in its source code. Then for managing more hosts at once there is Chef, Puppet, Capistrano, Red Hat's Satellite, ... all in Ruby/Rails. Writing a "script" in Ruby is then very easy, just parse basic arguments with option parser, implement anything you want, and use open3 for shelling out. If tou have a specific question, fire up...
You're really looking at two separate chunks of knowledge here, Ruby itself and Rails. The reason I bring this up is that Rails is big enough of a topic that its tutorials don't really cover Ruby itself in great detail.
Op didn’t say if it was time sensitive. And the the task clearly says analyzing log files. Not sure why you seem so argumentative. There are tools for different jobs. Ruby might work but it would y hurt to learn new things. https://zaiste.net/csv_parsing_performance_python_vs_ruby/
Peatio is a Crypto-currency platform written mostly in Ruby. It supports double entry accounting and over 10 currency as gem plugins.
Ho, my case is same as yours , after lots of suggestions i learned the basics of ruby from codeacademy and start learning rails from The Odin Project, i am also pushing my work to github if you are interested to see excercises solutions etc.
Yes, that is understandable. As long as I can understand the syntax and patterns used in Ruby, picking up framework shouldn't be too difficult. Like if you know Decorators and Metaclasses can understand what Pythonic code is, picking up flask . django doesn't take long. So I'm looking for resources along the line of "Ruby and its ecosystem, in depth, and not just the basics." Thanks :D
&gt; from codeacademy and start learning rails from The Odin Project Let me give those a try. &gt; i am also pushing my work to github if you are interested to see excercises solutions etc Well, if you're just starting with Ruby too, I would assume you are starting to learn the design and patterns of Ruby, and are not already an expert on it. I would rather not look at solutions from a non-master, since I need to quickly learn how to write elegant Ruby. I hope you understand (-_-")
I'm not sure I want to dive into the framework before I get comfortable with the language first. Can you please suggest something for the language? Thanks :D
I have 3 years of development experience , i used to work on Laravel, but i git hired in a company which is using Ror, so ruby basics is enough for me to work on rails and understanding ror is easy till now ,
For that, check out these. https://www.theodinproject.com/courses/ruby-programming https://www.codecademy.com/learn/learn-ruby https://www.manning.com/books/the-well-grounded-rubyist-third-edition btw, what's your programming background coming from?
15 years of programming experience. 1 year professionally. Proficient in Python, familiar with Haskell, C++, Java, Matlab, JS ...
Great, you should be fine, since Ruby is influenced from Python (and others). Get yourself familiar with Rails too.
Cool. The contents of "The Well-Grounded Rubyist, Third Edition" look pretty solid. Thanks. :)
It's like I would go answering Python threads at /r/python with "why not Ruby?"... since both are interchangeable for many tasks.
[Design Patterns in Ruby](Design Patterns in Ruby https://www.amazon.com/dp/0321490452/ref=cm_sw_r_cp_apa_i_ZXAjDbSX63YEX) https://learnrubythehardway.org/book/
Just include it in the yaml string as a typical &lt;a&gt; tag, and call `.html_safe` on the `t` call in the view.
Thanks for the comment. Would you mind reposting it on blog ? I could reference it in text and let readers know that the static salt is a potential security hole.
Like this? (still getting an error with this code) &amp;#x200B; [https://i.ibb.co/1MDh2KF/IMG-0039.jpg](https://i.ibb.co/1MDh2KF/IMG-0039.jpg) [https://i.ibb.co/Ct1zRRf/IMG-0038.jpg](https://i.ibb.co/Ct1zRRf/IMG-0038.jpg)
thanks!
You would need to call html_safe on the message in errors.full_messages, right where you display them.
I was in your position last year. I've got nearly a decade of experience in .NET, but I had never touched Ruby before getting a job where the main framework is Rails. If you've used a MVC framework in the past, you'll probably be fine with Rails. The only bits where I've struggled are with models containing logic, as opposed to casting to POCO/PORO, and the sheer amount of syntactic sugar in both Ruby and Rails. As already mentioned, The Rails 5 Way is a fantastic book, and I'd recommend keeping it by your desk for when you need to quickly read about something. From here, just write as much code as you can. As you feel comfortable in the language, I'd start to dig deeper into what makes Ruby a powerful language. Look up the most common design patterns for your code, and maybe look into meta-programming once you feel really comfortable with general use. It's complicated, but if you're implementing something like an API wrapper, using a mixture of memoization and `method_missing?` can make complex code much simpler and DRY.
Try ruby koans
And then Michael Hartl's book on rails, there's a free online version
In ruby you can implement the behavior you want with `method_missing` ([https://www.leighhalliday.com/ruby-metaprogramming-method-missing](https://www.leighhalliday.com/ruby-metaprogramming-method-missing)) With rails you can use `delegate_missing_to` https://api.rubyonrails.org/classes/Module.html#method-i-delegate_missing_to
You could override `method_missing` in `Class B` and check if `Class A` `responds_to?` the method. If so, send the method to `Class A`, if not, `super` it. &amp;#x200B; Or you could call call `@a.class.instance_methods(false)` to return all methods you've defined on `Class A` and pass that to `delegate`. eg. `delegate @a.class.instance_methods(false), to: @a` &amp;#x200B; Probably more, but these spring to mind. Ruby gives you tonnes of ways to skin the same cat.
i’ll do so soon with my earlier comment as well. might i suggest you fix your solution to create, use, and append a dynamic salt to cipher text on every encrypt? unless you find that the library already saves salts with encrypted text. or else, don’t provide code that others will be tempted to use? let me just reiterate: with a fixed salt for all, it’s trivially easy to decrypt someone else’s data *even without knowing the key*. It’s the same as not encrypting.
Cant recommend App Academy enough. Just skip all the beginner stuff.
&gt; Which begs the question why they aren't using the better NaCl I wrote a gem to patch Activesuppor to use libsodium: https://github.com/technion/messagesodium There was never any interest and quite the opposite, I recall the only feedback I got was quite negative.
Great timing, I was just evaluating the choices in this space for a client today. Will take a look!
Have you looked at SimpleDelegator? It's part of the Ruby standard library.
Elegant ruby? How about [Eloquent Ruby?](https://www.oreilly.com/library/view/eloquent-ruby/9780321700308/)
I really liked [https://rubymonk.com/](https://rubymonk.com/) when I was brand new, for getting some ruby under your fingers quickly with a TDD-style approach. &amp;#x200B; Eloquent Ruby by Russ Olsen is a great book for learning the language beyond the basic syntax. It goes on a tour of the language features, looks at examples of how each one is used "in the wild" in open-source libraries and common gotchas. (His book on design patterns is also brilliant.) &amp;#x200B; Practical Object Oriented Design in Ruby by Sandi Metz is also a must-read, and should be helpful in seeing the similarities and differences between OOP in Ruby and languages like Java.
Why does it depend on activesupport? :(
&gt; crypto wherein programmers are not allowed to make decisions on these matters. Fundamentally, the "I trust smart _______ maintainers to know their crypto" has been shown to fail over and over again. Wait, aren't you saying to trust the smart maintainers of NaCL though? Either you do it yourself, or you trust *someone* to do it; there aren't any other options, right? If you're not doing it yourself, the choice is just what to put in the `_______` blank.
You should read up about Sandi Metz and watch some of her conferences
I'm a big fan of tty-prompt. Used it in a project just a couple weeks ago. What exactly do you mean by "injecting the stream"?
A big fan of the odin project, however it is really geared towards beginners. So I don‘t think it is what you need.
I think this is the best path, or ding more details on the project
Yes I’m saying to trust the nacl maintainer because it’s none other than DJB himself, possibly the single most renown active cryptographer. Look at the credentials of your maintainers rather than how popular their gems are. The closer i look at the library posted, the more off-putting it gets. Even OP, with all good intentions, screws up the implementation badly.
what a shame.
Sounds like https://learnxinyminutes.com/docs/ruby/
And then watch https://youtu.be/IRTfhkiAqPw
Ok - cool article - OP not sure if you wrote it, but while this is a great explanation of HOW to set this up, almost totally absent is a clear explanation of WHAT we are setting up or WHY. It looks cool, and I think I get it, but sure would like to see a statement of what problems it solves - specifically right in the first paragraph. Thanks though.
Actually one of the most interesting articles I've seen posted on /r/ruby this year.
You need to use safe html translations: https://guides.rubyonrails.org/i18n.html#using-safe-html-translations
I wrote it, yes. Originally it was an attempt only to prevent pushing bad code to the repo with the help of linters and git hooks (we were playing with a new toy – Lefthook), but afterward, I started to want to run not only rubocop for backend code but also RSpec, but specs are slow. And I added Crystalball to the mix (one more shiny toy). But Crystalball needs updating code execution maps on a regular basis, and I wanted to automate it too and decided to use post-checkout hooks for it. But updating that profiling data requires to have all gems installed, and all migrations applied. And after `git pull` (it also executes post-checkout hook) it is often failing because there are some gems updated or new migrations added. And I added that. And it turned to be so convenient in everyday work so I couldn't not to share this. That's it.
We've a plan to remove it in next minor version update :)
Thank you!
thanks
"exactly once" delivery is impossible in the real world. Kafka claims it but it's being mealy-mouthed; it's really only for a limited time window.
Interesting. I need to spend some time figuring/trying this out. thanks!
A bit old, but one of my favorite references [https://books.google.com/books?id=jcUbTcr5XWwC&amp;printsec=frontcover#v=onepage&amp;q&amp;f=false](https://books.google.com/books?id=jcUbTcr5XWwC&amp;printsec=frontcover#v=onepage&amp;q&amp;f=false)
There is an example application for playing with: [https://github.com/Envek/lefthook-crystalball-example](https://github.com/Envek/lefthook-crystalball-example)
Wherever the relevant error messages are rendered in the view, call `.html_safe` on them.
Personally i learned Sinatra before Rails, it's pretty much the same thing as learning Flask before Django. It's very similar to Rails except without all the boilerplate and all the Rails-specific gems. You wouldn't believe the number of people who approach problems like "how can I do this in Rails" instead of "how can I do this in Ruby and then use that strategy in Rails". Learning idiomatic Ruby will help you learn Rails to some degree. But really they're separate beasts. A lot of people learn basic Rails while still being pretty shitty at idiomatic Ruby. IMO the most important things to Rails are MVC and object-lifecycle callbacks (e.g. functions before save, before destroy, before render which Rails uses on both the model and controller layer). So yeah, I would say focus on a bit on Rails, but probably spend 2/3 of your time with Plain Ruby, and you'll be good.
What I mean is passing in an IO-like object that actually receives puts and gets messages and can be queried for its content. Please see [tty-logger logging example](https://github.com/piotrmurach/tty-logger/blob/master/spec/unit/log_spec.rb#L7). You have inspired me to actually write an article about testing command line interactions.
Hello there, I hope I can help. I do like writing CLI apps. So much that I created a [TTY toolkit](https://ttytoolkit.org/) to make it easier. I would encourage you to use it as it will make your life easier figuring out how to structure the whole application. I would start by installing the `tty` gem. This will give you `teletype` executable. You can scaffold the CLI: ``` $ teletype new your-app-name ``` Let's settle on `appoint` as the app name. Once generated you will be able to run: ``` $ bundle exec appoint ``` Then you can generate all the commands inside your project: ``` $ teletype add create --desc "Create a new appointment" $ teletype add list --desc "List all available appointments" $ teletype add update --desc "Update an appointment" $ teletype add delete --desc "Remove an appointment" ``` This will create all the commands in the `lib/appoint/commands` folder. Then you pick the relevant command and implement your logic, for example, for creating appointments in `lib/appoint/commands/create.rb` in the `execute` method. I would probably use [tty-prompt](https://github.com/piotrmurach/tty-prompt) to ask questions from the user. So inside your `create.rb` command, you can do: ``` def initialize @prompt = TTY::Prompt.new end def execute name = @prompt.ask "Please provide appointment name" Appointment.create(name: name) # The ActiveRecord object Appointment end ``` This command the can be run: ``` $ appoint create ``` The other commands will follow a similar approach. Good luck with your assignment!
No, the team has only categorised the issue as a new feature. Nothing has been announced yet and as far as I knows they do not went more far than keeping an eye on the language (from my chats with the RubiMine team).
&gt;Have you looked at SimpleDelegator? It's part of the Ruby standard library. Great! it is exactly what I was looking for
Thank you very much! I didn't know about \`method\_missing\`, it definitively can solve the problem, After all I will use the SimpleDelegator, but I nice to know that there is this option
Thank you very much! I've start to work with ruby recently and I really surprise how many tool we have to solve the same problem. I will use the SimpleDelegator, but is great to know all this other options!
Awesome!
Currently I have: `doc.css("span.field-content a").text` returning this ^(=&gt; "How We ScoreRead Full Review Big Lake Brewing Lake KingView BeerHow We ScoreRead Full ReviewBig Lake CamperView BeerHow We ScoreRead Full ReviewJammerView BeerHow We ScoreRead Full ReviewTropical JammerView BeerHow We ScoreRead Full ReviewHigher Burnin IPAView BeerHow We ScoreRead Full ReviewBetter SelvesView BeerHow We ScoreRead Full ReviewCitras Maximus India Pale LagerView BeerHow We ScoreRead Full ReviewAwe JuniorView BeerHow We ScoreRead Full ReviewAwe Juice!!!View BeerHow We ScoreRead Full ReviewFearless YouthView BeerHow We ScoreRead Full ReviewLittle Red CapView BeerHow We ScoreRead Full ReviewMoody Tongue Oak Barrel Aged Flanders Red AleView BeerHow We ScoreRead Full ReviewPinwheelView BeerHow We ScoreRead Full ReviewPocketwatchView BeerHow We ScoreRead Full ReviewFoundView BeerHow We ScoreRead Full ReviewFlayrahView Beer")
You're welcome! I also learned about SimpleDelegator in this thread :-P
correct, thank you
I didn't have the energy to understand what the first one did even, but the second was immediately apparent. I'd say if you don't know of any reason to do it, don't do it. Trying to make the code as simple as possible is probably the driving motivation of design. (The trick is knowing how simple is possible to accomplish what you need accomplishing).
&gt; is it just stupid to wrap everything in it's own object this really depends on your implementation. for small scripts it makes sense to do things procedurally. the benefit of OOD is code organization, especially in larger applications. what benefits does your OOD code have right now? well the Credentials class provides fallbacks, perhaps the Connection class could handle setting a proxy as well. tldr this is too simple of an example of ask "is this worth doing OOD"
silly question. Do we have this amount of `news` on elixir subreddit for ruby?
You could look at https://ttytoolkit.org/ - It has a progress-bar gem which may give you a clue.
Here we go. Removed \`activesupport\` [https://github.com/omise/bluepine](https://github.com/omise/bluepine)
Creating objects is a way of protecting yourself against areas of code knowing too much about implementation details. "too much" means that the concerns you have at that point in code are distracted by details that don't matter for the job you want to do. I'd say your first example doesn't really use objects in a helpful way. Why do you process the file and then get the details and pass it into a an object? Why not have an interface like `DTM::DB::Credentials.new('credentials.yaml')`? By doing that, you don't care what happens to get the credentials. Changes to the config file can be managed inside your Credentials object. If your Credentials class loads the details, then the implementation can more easily change to reading a text file, or JSON, or whatever. And that allows you to implement the details of loading credentials from a file in the one place you care about it: `DTM::DB::Credentials` Use objects to create barriers in your code. I agree with /u/jrochkind that the second was immediately apparent, but I think that's only because there was no useful reason to have an object in the first example. If you arrange it so that you initialize credentials with a file and hide the details of getting them there, then you might find it more clear to get a db connection. Likewise, the second example explicitly uses `Sequel
If you 're about to just write a script, it's up to you. I don't see why you should wrap everything in objects. I am using objects for everything as it's not only a choice but also a state of mind, a pattern to organise and think. You know that in Ruby everything's an object, right? :)
Thank you very much. This explained a lot of things I was unsure of.
Unfortunately you are right, I was optimistic without a reason. According to the ticket: \`We don't plan to add support for Crystal in the immediate future.\`
I think The Well-Grounded Rubyist (3rd edition is the latest as of 2019) is one of the best books on the topic. It might not be the best book if you are learning to program, but if you are already experienced in other languages, it will be a piece of cake to work through the book. It's quite in-depth and up to date, it will be more than enough to familiarize yourself with the intricacies of the language.
You depend on your own abstractions when you want to limit intimacy with foreign dependencies. For example, you might be using YAML right now but want to allow things to be in JSON in the future (or even have them typed in via the command line or over HTTP). In those cases you probably don't want to call `YAML` everywhere but want to create your own `Configuration` object that your code depends on When your project is large and your dependencies do not conform to predictable interfaces (JSON and YAML both implement a common dump/load interface) then it is wise to abstract away your dependencies. Abstracting your dependencies is also good for testing (you can just sub in an in-memory mock) as well as good for when you don't want to solve a problem just yet (e.g. "I need some sort of config and I don't care what format it is, so I'm going to just create my own Config class to depend on and figure out how to implement it later")
Since you are loading from a YAML, this is likely a static connection you are only going to invoke once without really any different parameters. In which case you can probably just do this: ```ruby # Connect db = Database.connect # Disconnect db.disconnect ``` Then set up the Database class with a class method that basically just looks like your second code block. Now, if you needed the ability to connect to different Databases, you would modify the class to be able to do so. e.g. ```ruby # Connect db = Database.connect('config/credentials.yaml') ``` or ```ruby db = Database.connect(:main) ``` or ```ruby db = Database.new('config/credentials.yaml').connect ``` Depending on how you want it to work. Classes are a way to encapsulate logic for specific purposes, especially if they are something that gets reused.
this is hard to read on mobile, so sorry if it's a dumb answer, but isn't this stuff covered by the Sequel gem?
That would be great, and please let me know if and when you do so I can link to it in my post.
which means the things you are wrapping are already objects too of course, without you wrapping them in more objects.
Maybe shell out to `sl`? More seriously, that could be a good place to steal the train art from.
You could also take a look to https://github.com/janlelis/whirly. Hope it helps.
The first week I paired, I was physically and mentally exhausted. Just completely spent. It wasn't until six months into, that things started to click and I really enjoyed it. At that time, we were doing a lot of "promiscuous pairing" -- someone new every two weeks. There wasn't a rhyme or reason to it, everyone kinda self-organized. I paired with people that were way senior than me and learned a lot about architectural design and thinking 3-4 chess moves ahead. I paired with a lot of folks that were more junior than myself and got to see how folks with a brand new lens would approach a problem. Pairing is the single weightiest factor that has leveled up my skill. I don't pair much in my current role, but the relationships I made with my pair partners are the strongest relationships I've ever had with co-workers and I've developed lifelong friendships as a result. I'm a big fan.
No, still hate pair programming. I need to be alone to really concentrate.
I think your leveling up is from the promiscuous part of your pairing up. I just started working for a new company after a 10 year stint at my last one. Instantly like 5-10 new people to start bouncing ideas off of, comparing code, collectively deciding what’s the best looking code, sharing different command line and git tricks. Getting a wide range of opinions and thoughts really helps you add new tools to your belt super quickly. I feel like that’s helped me level up even in the two months of being there.
One big value I get out of paid programming, is to just help me make a fucking decision. Anytime I start working on something, I immediately think of 3 or 4 ways of doing it, all with their own pros and cons. I get analysis paralysis and it’s really hard to get out of it. Having someone there to immediately bounce ideas off of is such a huge help with this block. Hell half of the time, I come to the right decision just by repeating it aloud to someone. If they agree then it’s probably the right way to go.
You can see some stats suggesting Ruby future popularity here [https://insights.stackoverflow.com/trends?tags=ruby%2Cpython%2Ctypescript%2Ckotlin](https://insights.stackoverflow.com/trends?tags=ruby%2Cpython%2Ctypescript%2Ckotlin)
I disliked pair programming from the start, until I got teamed up with a colleague with the right mindset. With him, it got to be really fun. Unfortunately, I never teamed up again with someone the likes of him. So I'm back to thinking pair programming sucks.
I love pair programming, but I don't have it that often. I love it the most, when it's a learning experience for both of us. When I learn something and I can teach some tricks. I found that it's much easier to pair with a laptop on a standing desk. With chairs I often have the problem that I'm too far away from the screen. I find pair programming really helps in early phases of the project to implement a structure and shared understanding. And it's good to have someone else to help naming things, to catch typos and avoid bugs. Pairing with the CTO (who is my direct boss) is the most intense experience, because of this incredible typing speed. Sometimes he switches contexts too fast and I can't follow his thoughts, but most of the time I google stuff we both don't know at the top of our heads while he types, so we're really fast together. * * * The most frustrating experiences I have is ad hoc debugging with much more junior developers. I'm German, people in Germany use a German keyboard layout and if you have a Mac, some special chars like `{}[]|` which you use all the time in programming but are hard to reach on a German layout aren't even printed on the Mac keyboard. And if you press `alt+space` it looks like a space, but it's not. This breaks your command line terminal. Therefor I use a US standard keyboard layout exclusively because the people who invented all these programming languages used this too. The guy who wrote vi, used `hjkl` for navigation, because these were the keys with cursor arrows on his keyboard. So, I'm frustrated with their keyboard, I'm frustrated with their lack of typing speed and the most frustration I have with them not speaking the same language as me. A lot of it is due to the XY-Problem, they want to solve problem X but they just need it to be solved because they think that's the answer to problem Y which they really need to get solved.
What tools are you guys using for remote pair programming? I'm just doing a screen share on Mac at the moment, and it's not always very stable or reliable.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/jamiepine] [Have any of you ever hated pair programming, and then liked it?](https://www.reddit.com/r/JamiePine/comments/cc9too/have_any_of_you_ever_hated_pair_programming_and/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Vs code has a great live share feature. Think Google docs where you see the others cursor and all work on the same doc in real time. Supports at least 30 people after some configuration. One downside is it's tied to the hosts computer and won't let you run terminal commands for security reasons . There may be an option to allow that however
I’ve gone in a complete circle. I hated it, then liked it, then hated it again. I don’t think it’s a one size fits all technique, it works better for some tasks/problems and for some people than others .
Heya, no big thing but this is a nicer way of checking a class `binding.pry if row.is_a?(TrueClass)`
Then where you work has a massive issue.....no way that cant be extracted into smaller methods
others have offered a lot of insight. and i would also argue that this could be extracted to its own method. but a simple 'dumb' fix. would be to just use a ternary. Treat rubocop as a guide rather than an absolute though def pack_varint(data) ordinal = ''.b loop do byte = data &amp; 0x7F data = data &gt;&gt; 7 ordinal += data.positive? ? [byte | 0x80].pack('C*') : [byte | 0].pack('C*') break if data.zero? end ordinal end
It all depends who I am working with, and what they focus on. I have some coworkers I can do it all day with- others that 5 minutes is annoying. The ones it’s annoying aren’t bad programmers, just different flow
Have you tried two keyboards and quick switching?
What sort of qualities did this person possess that others did not which you appreciated?
Tuple is about as good as it gets for remote pairing these days, if you can get work to pay for it.
Especially these days
Yeah, getting work to pay for it is the problem!
For the project I'm working on right now, we all develop on a remote server, using SSH. When we pair, we can join into a shared tmux session, so everyone is right there with the code, and has the opportunity to "drive" if they want. Combine this with video chat for remote folks, and you're set!
I'll have to try that. I just find scrolling back in tmux to be excessively difficult.
It's certainly possible, especially if you're willing to build an intelligent installer that behaves differently depending on the windows build it's installing on... but ultimately, ruby seems like a really poor choice given your constraints. If the script you're trying to deploy is for a fairly simple task, you might spend less time just porting it to a language that's designed to compile to a single easily portable binary with a low barrier to entry (go and c#/mono come to mind). If you're dead set on using ruby -- Traveling-ruby looks like your best bet for something that "should work", but obviously test it yourself on the systems you suspect it won't work on. Building it into a .jar with JRuby might be another "easy" option, if having java pre-installed is an acceptable requirement.
Do you remember what made those sessions either free-flowing or annoying? For the sessions where the other person has a different flow, has it been your experience that you could change or influence that flow, or has it been more of a built-in thing, that you can either enjoy or cope with?
Is there a particular thing about Tuple, that makes it better than other options for remote pairing? I've been checking it out; wondering if you've had experience with it yet.
I had a similar experience with typing speed, where one of the people I was pairing with was a Vim master, switching to different panes, splits, and files so fast, that I couldn't keep up!
This is why I don't like to pair 100% of the time. Some things require deep concentration, and some benefit from the collaboration on code.
TLDR; its a static analysis tool for rails apps to help find places where pagination and async rendering would help. That is pretty awesome. I need some async rendering in my life. The setup process was a bit odd. Why do I need to install bootstrap and sass and react reloader?
Any questions?
I hated it, because I was the stupid one. Now I like it, because I am the less stupid one.
Why Sinatra and not Roda or Hanami?
I wish I could hate or love it, never had the opportunity. &amp;#x200B; I reckon it's better to have someone to pair with sometimes than always learning/coding by yourself (my case).
the standard library `delegate` will have SimpleDelegator but it also has DelegateClass. SimpleDelegator works well with instances of other classes where you don't know what methods need to be forwarded. DelegateClass allows you to forward a predefined set of methods and fallback to method_missing and it looks like this: require 'delegate' class A &lt; DelegateClass(B) # extra methods here end some_b = B.new some_a = A.new(some_b) some_a.a_method_defined_in_B There's a performance penalty when you go through method_missing, so if you already know that all the methods from class B will be forwarded directly to that instance I've written about this library here https://www.saturnflyer.com/blog/ruby-delegate-rb-secrets I gave a presentation about this a few years ago that you may find helpful https://confreaks.tv/videos/rubyconf2013-unleash-the-secrets-of-the-standard-library-with-simpledelegator-forwardable-and-more
I used slack remote pairing about everyday for a year, but support for that has just ended, this was the best option before Tuple. I’m saying it’s the best because it gives full, shared control of a desktop. This allows you to properly trade off control of the machine as you would normally experience with an in-person pairing session. Some people get by with an assortment of tools, but for 100% full time pairing, you can’t beat just hitting a single call button. With slack remote sharing dead, Tuple is the only software that offers all of this now, so that makes it better than anything else, given you access to it.
Why not [Sequel](http://ldrive.local:1000/myDocuments/winHTTrack/Sequel/sequel.jeremyevans.net/index-2.html)
&gt; Relations can be seen as partial views on your data, whether it is a SQL Table, a particular CRUD resource on an HTTP backend or some JSON file on your file storage system. Careful. "Microservices" that expose CRUD-over-HTTP endpoints aren't really services, they're databases with an HTTP interface. In other words, they'll lead to an overall architecture that isn't any different than a monolith with a centralized database, except that they have many way more ways of failing than before, and are also many times slower to boot. It's common for web developers to rush in to service architectures with the assumption that services are just HTTP APIs, merely because HTTP APIs are something that web developers _already know_. However, I think most web development teams using ActiveRecord would benefit from exposure to ROM. In conjunction with other approaches to software design, the end results can be a lot better. But using ROM to _abstract away_ the difference between a SQL server and an HTTP API would be a categorical mistake.
At first I was like, what 15-letter industry term starts with H and ends with S?
LOL. I would go with "hazardousnesses" https://www.morewords.com/wordsbylength/15h
OOPS! I searched for 17-letter words. Updated.
So the result is this - they couldn’t manage the architecture, and the only way they saw was fat models. They thought it will change in an instant if they’ll get rid of the frameworks that let them do fat models, even though it’s the developers who chose to approach with fat models. They think that if they will have 3 times more entities, it won’t get dirty this time. Yes, activerecord was the source of the problem. Not the developers.
Did I understand correctly and the solution was to close the listener socket when shutting down?
Correct, the post was a bit long-winded, because otherwise, it would have been a tweet instead of a blog post :) We close the listener socket when as soon as puma gets a SIGTERM so it knows it will not be running for much longer and should not accept new requests. Here's the PR: https://github.com/puma/puma/pull/1808
Look, ActiveRecord is just a library for fetching data from a database. You can do whatever you want with it. If you make a huge interface, add a bunch of complicated interactions through callbacks, and allow dependencies to get out of hand in your application and go every which way - that's on you. That's a design problem. Use more POROs. Use ActiveModel. Cast things into Structs. Use service objects. Actually define layers in your app. Consider using design patterns. Define common interfaces that your app can use for duck-typing Pretty much all of us have inherited _that_ Rails app where everything is tied to everything else and change (and even testing) is really difficult. That's still not an ActiveRecord problem. That's a design problem and - usually, in my opinion - a people problem because the lead dev of the project didn't spend the time to think things through architecturally If ROM is what you need to get there then cool - I think ROM and DDD are well thought out. If it's microservices you need, great too. Whatever gets you to actually split things up and define boundaries is what matters most. I'm just sick of people creating models that are 2000-3000 lines long and have hundreds of methods and having to explain to them that that's not ActiveRecord's fault - that's your fault Don't get me wrong - I have my beefs with ActiveRecord just like anyone else but dependency management is not it. It'd be something more mundane like that I don't like being able to dynamically-load associations, and that's patchable if I really care
There are different types of pair programming: * 2 juniors: this is terrible. Neither really knows what is going on and you both are just going to be less efficient than you would be apart despite the fact that you'll teach each other things. Then again, neither of you knows the right way to do things so you'll probably just have to unlearn things later * junior/senior: this is okay for getting someone up to speed. The senior takes a big hit in productivity but the junior at least gets quality instruction. If the senior needs to work on a deep problem they will probably have to hand-wave the reason to the junior and the junior won't get much out of it * senior/senior: this is the best way to pair. Both programmers can talk at a high-level about a problem and one can think while the other types. There is usually on-the-side chatter about how things _should_ be which leads to building consensus for changes that affect the whole team. There is also two-way skill transfer ("wait you do XYZ? just do ABC", "you can do ABC? wow *thinks to self about hours of wasted time they've wasted hacking around*")
I mean, the Rails community endorsed "fat model, skinny controller" for years.
Sequel::Model is also an [active record](https://en.wikipedia.org/wiki/Active_record_pattern) implementation, so if you've identified that pattern as being problematic in your architecture, it seems like a poor alternative. ROM still uses Sequel, just not its model layer.
That's true. The reason behind that was more of "don't put a ton of stuff in your controller". Many of the Rails 1.x projects I worked on had thousand line methods, and that was good advice in context
&gt; ActiveRecord is just a library for fetching data from a database It would be easier not to bloat it if it was just that, but we know it does much more than that. And what makes it even worse is that everything is in a single class. &gt; Use more POROs. Use ActiveModel. Cast things into Structs. Use service objects. Actually define layers in your app. Consider using design patterns. When I was using ActiveRecord or Sequel, the first design pattern I felt the need for were query objects. However, it's not easy to design them – [this](https://twin.github.io/finder-objects/) was my attempt, but it's not perfect. Since queries are just macros, they should really not live inside of models (because they'll just grow uncontrollably). And that's not use case specific, any sufficiently complex app would benefit from this. So ActiveRecord _not_ having an abstraction for query objects _is_ a limitation of ActiveRecord. &gt; I'm just sick of people creating models that are 2000-3000 lines long and have hundreds of methods and having to explain to them that that's not ActiveRecord's fault - that's your fault. If validations, associations, building queries, and entity logic all go inside the ActiveRecord model (and that's not including Devise and many other Rails gems that add even more things), then I don't see how you could prevent that growth.
To us the main point of ROM is *not* to abstract away whether it is a SQL or HTTP API based Datastore in order that "developer would be able to forget what's under the hood" or anything like that. You're right, it would be a huge mistake. To us, this abstraction is useful mostly in order to be able to build our domain and use cases before even thinking about how we should store data, because it's impossible to know which kind of Datastore would be the best before use cases are properly defined and before we ask ourselves few questions: will the load be high? Do we need strong data consistency? do we need fast responses? etc... (and it may be difficult to find all use cases without any mistake on the paper) The second great point is that if we ever want to change our Datastore for whatever reason (performance issues, infrastructure team requirement... whatever), then it will be easier fo us if we first implemented this kind of structure, because we would *theoretically* need to change only our Relations. Which is not true if we didn't implement this kind of structure *and* if we haven't be careful about separating concerns properly. I'm pretty sure you have already seen tons of Applications with Datastore's details leaking into the Business logic, which means those are tightly coupled, which makes it way harder to change Datastore. And this is **the** thing we want to avoid.
I really like Sequel, it's a big improvement over ActiveRecord. But, it still implements the Active Record pattern, which can still cause complexity problems down the road. Notice that ROM's SQL layer is actually built on top of Sequel, so that's nice.
Keep in mind that this is a graduate student research project, not a commercial tool. I wouldn't expect perfect polish for 22-25yo students.
Great question, actually just for the little story, meanwhile we were building our service with ROM, another team was building its own service for completely different purpose. They actually choosed to use Sequel directly because ROM didn't suit them at that moment (for a reason I don't remember). We were actually encouraged to use it by someone who already worked with it in the past, and it was actually a great idea because we didn't have to invent our own concepts to separate concerns of our persistence layer or make research on which pattern would suit us the most, we just had to understand those that already exist in ROM and that have already been field tested. Plus it comes we functionalities that were really handy to us like Entity mapping or data pipeline features, we could have actually code them by ourselves but it would probably not have been as good as they are already in ROM.
&gt; If validations, associations, building queries, and entity logic all go inside the ActiveRecord model (and that's not including Devise and many other Rails gems that add even more things), then I don't see how you could prevent that growth. There's only two options: it is all in the same place or it isn't. If it is painful to have everything in the same place then you need to move it somewhere else (or scrap it or rethink your design). If you're going to move things out in a new architecture anyways, I don't see why you need to completely rip out your ORM to do that I don't want to advocate that "put everything in your model" is the right way. What I want to advocate is "blindly follow architectural patterns" is the wrong way which I think we could all agree on. I think the right way is "pick a template as a starting point and change it to fit your needs/pains", but it seems like we consistently have problems with that second part. And we're not alone - just look at the front-end world
Sinatra as been choosen by the Architecture team which builds a custom framework that we use for all of our new services, so we didn't make this choice directly. Still it were fine to us on a development perspective and we trust our Architecture team to make best choices on this part. Anyway I'll ask them directly in order to have more precise answer and more interesting insights.
Thank you, I'd like to know the technical reasons since I have my own reasons here to believe your architecture team is not as good as you might believe they are without knowing their actual reasoning.
I bet that you think that this is our opinion because of the title of the article that is... well.. a bit clickbaiting, I can't blame you \^\^' You are actually completely right, ActiveRecord is **not** the problem, developers are the problem. The question is, how to solve this problem? Answer to us is: *Architecture*. I won't learn anything to anyone by saying that could do both dirty and clean code with any language/framework/tool, Architecture is actually more important than the tool you use. We could have keep using ActiveRecord but this time with another architecture with more strict and clear Separation of Concerns, it would have been just fine to us. We could even have used ROM like we were using ActiveRecord before, for instance by: \- accessing Relations or even SQL functions directly in our business layer \- implementing kind of callbacks in our Entities and use a lot of them \- manage Entities life-cycle directly in our repositories or in our Adapters (Controllers, workers, mailers, instead of use cases) \- implement in our entities methods to access/write data directly by using Repositories... The consequences would have been the same: tight coupling between Business logic and Datastore (making it difficult to change only one of those), unexpected behavior because of too many callbacks, less control on when Datastore gets hit etc... We actually decided to use ROM in order to get acquainted with new architecture concepts for managing persistence layer that has already been field tested. The most important to use ROM properly is not understanding its interfaces, to me the most important is actually to understand the concepts and their philosophy in order to keep a good separation of concerns, which is exactly the point of this article.
&gt; expose CRUD-over-HTTP endpoints aren't really services, they're databases with an HTTP interface. A million times this. Rails has a lot to answer for when it comes to bad API design.
&gt;That's a design problem and - usually, in my opinion - a people problem I can't agree more with you, see this other comment in this thread: [https://www.reddit.com/r/ruby/comments/ccbw9b/goodbye\_activerecord\_inside\_aircall\_medium/etmp240?utm\_source=share&amp;utm\_medium=web2x](https://www.reddit.com/r/ruby/comments/ccbw9b/goodbye_activerecord_inside_aircall_medium/etmp240?utm_source=share&amp;utm_medium=web2x)
Hey /u/janko-m just seeing you here and having discussions with you before reminded me to tell you about [https://vlang.io/](https://vlang.io/). It crossed my mind that it will be right up your ally.
Could you develop what you have in mind a little more? This subject is interesting to me, and I have to admit that I have limited knowledge about other web frameworks and their respective perks / drawbacks.
Bit of a late reply, but thanks for this easy to understand example. I noticed on your blog post you make the distinction between a test that "will" occur vs "has" occurred. Do you have on this rspec nuance? Thanks!
We use AnyDesk for mob programming, but I imagine it would be just as fine for pair programming too.
&gt; it { expect(user).to have_one(:profile) } Previously when one wanted to validate the presence of a profile, they'd do belongs_to :profile validates_presence_of :profile it { is_expected.to validate_presence_of(:profile) } Now Rails can validate the presence of the association via the `belongs_to` call: belongs_to :profile. :required =&gt; true But this will not work with: it { is_expected.to validate_presence_of(:profile) } One must use it { is_expected.to belong_to(:profile).required }
As a member of this architecture team, what matters the most for me is that developers working on product and features focus more working on the domain model and use cases. Like Julien said, we use a Hexagonal architecture style for our apps. We chose Sinatra but we actually can change to something else easily. We don't care about this. Sinatra just handles http stuff and we don't have that much http in our services because we want them autonomous. We prefer async communication between services using commands/events. We are using http for some *internal admin/debug* endpoints. We could have used a simple rack app it would have been the same. The delivery mechanism is a detail. The storage system is a detail. We try to defer as long as possible all these things and first focus on service domain and use cases.
The purpose of this article was to share our experience about ROM to ruby other developers. But it would have been hard to talk about all the things we're working at the moment. Thanks for warning us about *distributed monoliths* :). I'm working with Julien and in our tech team we strive to make our services **autonomous** as more as possible by making them handling **commands/requests asynchronously** and then publishing **domain events** for other services that might be interested. We are migrating from a legacy monolith (we inherited) to autonomous services. Our strategy is to identify relevant domains in our business, extract one after the other these domains from the monolith and make them autonomous services. We use Hexagonal as an architectural pattern for our services, SNS/SQS for async communication, Sinatra for HTTP debug/metrics endpoints. The rest is pure ruby code to implement domain models and use cases. We do our best to use TDD effectively to design the domain and use cases layers in our services. We inject what we call *adapters* (repositories, 3rd party api clients, ...) in our use cases through D.I. It's far from being perfect but after 1 year it looks already way better than before :)
I've used ROM in a micro service and to be perfectly honest, I should have used Sequel, like I am in a micro service I'm working on now. It's much better, we don't have to use the repository pattern like ROM forces you to, although we are. It's just simpler to setup and get working. It's also extremely lightweight. ROM is built on top of Sequel after all.
Also executable .jar files are a thing and although it might not be a cakewalk to build one, the warbler gem should be capable of doing that.
Yes, this is why one must think for themselves and don't just blindly accept "community best practices".
I don’t love that I have to go paragraphs down and click a link to find out what ROM stands for for.
I am quite new to ruby, made it in here from php (zend) so it’s really strange to me seeing active record used just everywhere. Seems like it’s because most of the ror projects are mvps with simple business logic- each entity represented in single table and not much of those tables (and databases of course).
Looks cool. Will definitely be checking this out. I used to do a ton of stuff with Java's Hibernate which [does not allow one to access the DB connection in the view layer by default](https://developer.jboss.org/wiki/OpenSessionInView?_sscc=t#jive_content_id_The_problem). Initially I found it odd that Rails allowed one to do this. I think a lot of folks don't realize that the view layer is where most of their queries are executed. Certainly a layer violation but necessary given ActiveRecord's API. Of course one could always end their query with `#to_a`, but this would then prevent one from using most (all?) pagination libraries.
What React?
So far this looks like unnecessary bloat. The only reason I can see to do this as is is if you had a need to 1. Abstract implementation details 1. Provide a concrete interface for `Credentials` throughout your system More info: 1. `Connection`: You wanted to hide underlying DB and/or library. But currently this is not well hidden because caller will just be bound to Sequel's API. _Maybe_ if you then wrapped Sequel with your own API this would make sense. 1. `Credentials`: If you had N (N &gt; 1 or 2) places that needed to access DB credentials and you wanted a well-defined interface (well, as well as Ruby can provide). Or, if you performed some operations on the underlying values. For example: def host # Silly yes... IPSocket.getaddress @host end Otherwise always keep it simple and don't force yourself into bullshit rules like 5 lines per method.
Has this been included in a new release?
I've seen exactly this sort of "Service Oriented Architecture" in production, to the point where not only was every single "microservice" coupled, ~30% the code for each "microservice" was duplicated in EACH client. SoA can be powerful, but the way the average team implements it has me convinced that a well done monolith is the only sensible default for the web.
Does it allow 3d?
No it is a 2D engine
Naw. Only 2D at this time. One day we'll have live-reload of 3D games with a wonderful Ruby DSL. But that's wayyyyy in the future.
Neat!
Fixed, thanks for the feedback!
&gt; we don't have to use the repository pattern like ROM forces you to ROM doesn't force you to use anything, you could use Relations without ROM's flavored Repositories, but it's not something suggested or mentioned in the official documentation. Technically, you can initialize your relation with your adapter's Dataset (like `Sequel::Mysql2::Dataset`). As I said in other comments, Architecture is actually more important than the tool. So if you prefer to use Sequel with your own architecture pattern with a proper separation of concerns, your code can be still perfectly fine. ROM becomes very handy especially when you want to infer schema or deal with legacy schemas, and other stuff, I let you check it out if you're interested: [where ROM shines](https://rom-rb.org/5.0/learn/introduction/active-record/#where-rom-shines).
&gt; ~30% the code for each "microservice" was duplicated in EACH client To me, this is a problem we try to avoid by sharing code through private gems or put it in another service (which already exist or not by the way), if you have shared logic between your services, either it belongs to a shared code repository if it's domain unrelate (like HTTP connections, logging, error reporting...), or it belongs to another service if it's business logic. Monolith is still as fine as microservices to me as long as you split properly the logic in it and if you are able to extract it at any time if you ever realize that would be more efficient to split it. For the little story, we first build one of our new service directly inside our monolith because at that time we didn't have enough resources (time mostly) to extract it right away, so we coded use cases by separating concerns as much as we could, and 3 months later we started to actually extract it which were fairly easy as its logic were almost not coupled to our monolith dependencies or logic. The question is too often asked on the wrong angle I think, whether you choose to do monolith / macro-microlith / microservice (whatever we choose to call them), should be defined by your use cases and company's (or whatever structure) organization. Examples: * You have a state of the art API, lightweight data processing, a high traffic, and your infrastructure team want to use containers in production for this reason, because it will be easier for them to maximize throughtput. Then microservice should be fine for you. Could be a good choice if you have feature teams and if you achieve to standardize properly the code and all the services (which is not easy). * You have simple API, with not so much users but which deals with huge amount of data, with heavy processing? Then monolith could be just fine for you. Could be a good fit if you have only one team and don't plan to scale it in near future. =&gt; Consider situation on a global company scale, a lot of things could influence this choice
If I were to purchase this and I am very much thinking of doing so, (Budget is a little tight since I am a student &gt;.&lt;) is there documentation? Specifically, like how to animate sprites from sprite sheets and stuff like that. Maybe everything comes in the download... Just wondering :)! &amp;#x200B; Great work, looks really awesome!!!
There are a ton of sample apps that’s show all the things. If your budget is tight, email me and I’ll hook you up with a free license.
So, what do you do on the hot reload feature now? Because if I understood correctly, you don't support it anymore
&gt; Of course one could always end their query with #to_a, but this would then prevent one from using most (all?) pagination libraries. Another problem with preloading all your data in the controller is duplicated code: Whenever you need to make decisions based on fetched data you now need to make this decision in two places. (e.g. `&lt;% if user.active? %&gt;&lt;p&gt;&lt;%= fetch_some_content_from_external_api(user.id) %&gt;&lt;/p&gt;&lt;% end %&gt;`). Otherwise you're over-fetching data.
Hasn’t this been released a while ago?
If I have to name one thing: A willingess to concede that his own idea was not a good one (I learned the term 'brainfart' from him), and a gentle, non-judgemental way of criticizing my own stupid ideas. Really, opened my eyes on what collaboration could be like. Of course, on top of all that he was a kick-ass programmer.
thanks will take a look
Early access bits were in the works. This is finally 1.0 quality.
&gt; Look, ActiveRecord is just a library for fetching data from a database. It is also used for Form input validation, entity relationship interactions, and god knows what else.
&gt; Use more POROs. Use ActiveModel. Cast things into Structs. Hmm, if I was not going to deal with the ActiveRecord *model* objects in my business code (instead immediately converting them to some other kind of object like an activemodel, struct, or other)... I don't see I wouldn't just use Sequel or ROM, which do this more naturally and clearly. If they didn't exist, I might try to use AR this way. But since they do? I will also say though that in *fact* in my actual development... I use ActiveRecord. More or less as Rails guides you to do, with models exposed to my code. I think it works quite well for many many kinds of applications. It does not work well for very complex or very large scale applications. Most applications are not that. The story the OP tells where they start with AR and get away with it only when they have a mature, complex, large-scale application... is probably the right story, despite the pain you feel when doing the transition and wishing "why hadn't we done this at the start?" One answer is because doing it at the start would have actually made your getting started much harder/more expensive/time consuming. Another answer is that you're doing a good job of architecting your layers and abstractions now only because you already wrote the app and can use what you learned from it (including what's embedded in the existing code, even if you personally weren't around when it was written) -- if you had tried to do that from the start, you would have been more likely to wind up with an over-engineered over-abstracted mess.
What gives you that impression? If something doesn’t work then please open a ticket with an issue.
This went out in 4.0.0
Nice! I may buy it just to support that cause. Great work!
I appreciate that. I never want to put anyone out financially.
`def method_missing(*args, &amp;block); rand(2).zero?; end`
What returns if you call .class on the value object?
Maybe post some code and we can help from this. From your text I expect you are not saving the text version to a variable so; ahash.to_s ahash.stringmethod Will not work but as ahash will still be Hash class. You need to use it like this text=ahash.to_s text.stringmethod
I figured it out. \`myvar = myhash\[‘hashkey’\]\` &amp;#x200B; Had a total brain fart :D I'm still somewhat new to Ruby from bash
So you're not turning the hash into a string, you're calling a value from the hash using a key, and that value just happens to be a string. Just for future reference.
By autonomous, do you mean that your services don't have to go out and query data from other services in order to carry out their work?
We were using [https://github.com/larsch/ocra](https://github.com/larsch/ocra) with decent success to distribute a Ruby application on Windows. The output is real installer. The thing is it's outdated and actually kind of pain. Unless you need a quick demo I would not recommend it.
Awesome. Thank you.
Finessed, that means domain model. It doesn’t have to mean one-big-model-class. Extracting logic into collaborators is a big part of doing it right.
Sure, we can polish it into something that makes sense, but rich domain models are not very common among rails applications, and a big part of the reason is that the majority of Rails developers started taking code in the controllers and moving it into the ActiveRecord classes. And over the years Rails added features to reinforce their idea of "fat models" -- `accepts_nested_attributes`, for instance.
Recently merged: https://github.com/rails/rails/pull/36388
Ironically, under the bonnet ActiveRecord basically is a repository pattern ORM.
Can it be used to build GUIs? Does it come with a Ruby interpreter or does it work with user installed Ruby interpreter? Does it output native binaries? Is it crossi-platform?
It’s completely self-contained (zero dependencies/requirement for ruby to be installed). It outputs native binaries. The interpreter is within the binary (accessible via the `~` key like the Quake console).
Thanks a lot for your work and for answering so fast :) ! Do you think DragonRuby can also be used as a means for bulding basic GUIs and as a way of deploying native ruby apps to various platforms ? Following this project with a lot of interest... !!!
The goal is to eventually provide full blown UI controls out of the box. You can totally make basic UIs, but it isn’t technically a priority just yet (given that this is game related)
\&gt; The goal is to eventually provide full blown UI controls out of the box. Amazing, I really look forward to that! I hope there's bright future ahead for DragonRuby!
Can I just say this is an excellent example of quality technical writing that makes a hairy, difficult subject matter approachable to a wider audience?
Why can't they stop adding stuff, jfc.
&gt; Also executable .jar files are a thing Would those executable .jar files work on Windows machines without Java installed? The idea is for users to NOT have to install anything extra. It should work with the base Windows installation from unpatched to fully patched. So stuff like .Net/C# is out unless the single exe can somehow run on the different default .Net frameworks out there.
We look for things that meeters. What matters to me is business requirements. How to make the company evolve, maintain hypergrowth without suffering on agility, velocity or modularity. There are set of tradeoffs you need to take under account, system characteristics, team skill level, resources you have, business dynamic, patterns familiarity. Architecture is not about taking the most exotic pattern there is, or more opinionated framework. You asked about why not Roda or Hanami, as many developers where Rails developers we didn't want to introduce the complexity or patterns from the start, we need to maintain the pace. We were able easily to adjust Sinatra to our need to give less experienced developers "rails" like experience, minimal learning curve. But that'sonly framework, part, which developers shouldn't really care, they should care about Domain logic. You need to learn how to walk first to be able to run.
Yes exactly! Services have their own private storage and receive either commands/events containing specific data allowing them to do their job. They can also emit new commands/events. In some cases, we do HTTP calls to access 3rd party APIs because we don't have other choices.
So the benefit here is that in the logs, it's clear what each query is doing? Neat.
Yes, it makes implementing things like [marginalia](https://github.com/basecamp/marginalia) much simpler. This way it's much easier to identify the source of slow queries and such.
In that case, have you looked at [eventide](https://eventide-project.org)? Seems like it'd be right up your alley...
Funny moment, I just realized who you are! I'm following Scott and you on Twitter! We already (quickly) talked together on Twitter by the way : [https://twitter.com/kmatrah/status/1120815678611775489](https://twitter.com/kmatrah/status/1120815678611775489) :) Hope you're fine and getting better! Yes Eventide is a very nice project. I would love to introduce it in our company and I already talked about it with some people. It would require some work and mindset shift for our developers to switch to an event sourced approach. More and more people are willing to look outside of Rails, so it is possible we start using it one day :)
Altogether it looks good. Couple ideas for things that could be added: 1. a config.ru / Procfile and a note for how to deploy it on Heroku 2. Datamapper / ActiveRecord example file 3. Maybe even configuration / example for websockets
Thank you, I will keep that in mind for future updates. :)
Right on! The nice thing about event sourcing for autonomous services is that you don't have to implement persistence for your entities _and then also_ implement pub/sub for events and point-to-point messaging for commands. So, the end result is vastly simpler. Regarding getting developers exposed to event sourcing, we offer training for that, but I'd rather not pollute this discussion with a sales pitch :-)
Datamapper? What is this, the 60s?
Datamapper IMO is more in line with the minimalist Sinatra approach. It's also simpler for beginners, which is the point of this repo here (and it's quicker for prototyping).
Maybe Sequel then?
This is one reason I think it best to avoid use of `default_scope` entirely.
The problem I've had with DataMapper is that there really aren't any good docs out there. Their docs are woefully out of date and lack any meaningful examples, and most examples on the open internet use Ruby 1.9 syntax (which can be difficult for someone new to Ruby). (I mean heck, the repo was archived in 2016... I suppose it could just be that "stable" but I don't think so). I wouldn't recommend anyone who isn't already using DM to start...
I really want to like Sequel, but it just seems like the author went "Ruby syntax, fuck that! We use `[]` for method calls!". I also have a similar complaint about it that I do with DM, in that, it seems like there aren't many good usage examples. I find myself digging through the source a lot to figure out how to do things with Sequel.
The docs here give many examples, and I have no idea idea what you mean by "woefully out of date" (surely you're talking about something more substantial than hashrocket syntax) http://datamapper.org/docs/ it's super similar to activerecord just a bit simpler. Don't need a database.yml, don't need migrations. You are free to advise people not to use it, but I will respectfully disagree. It's so similar to ActiveRecord that it's easy to make the transition from one to the other, or vice versa
DataMapper is no longer in development. It has been showing signs of bit rot for a while now, so it shouldn't be recommended for new projects anymore.
The examples, while plentiful, aren't really practical. It's been over a year since I last tried to use DM, so I don't have any specific examples of what I found wrong with it, but I remember it being nothing but a headache. Add to that the fact that the project seems to be dead and there is no where to get support (or bug fixes, or security patches), means that it's probably a bad idea to be using in production anyway, and therefore not something that someone who is _new_ to the Ruby ecosystem should be wasting their time learning.
Seems like an `enum` would be more appropriate. It's better to be explicit in your queries than trying to deal with the side effects of `default_scope`.
This. I can't think of any good reason to use `default_scope`
Perfect timing Thanks
Yeah, that's the idea of an executable .jar -- everything needed to run it is present. TBH I don't know enough about it to recommend it. I'm guessing it's going to be somewhat bloated compared to a standard executable because it's got to have a cross-platform java bytecode interpreter in it somewhere.
Someone forgot to renew their SSL cert, nice.
How does the template line in the 404 section work? Seems like it references a non existent layout?
the 404 section is its own layout, the “not_found” page is practically its own layout, completely separate from its default layout.erb file to distinguish and show users different ways to use different layout designs
I told them already They are using different certs for blog and TLD + www
The alternative solution proposed by the author would work, but personally I'd use [`ActiveRecord::QueryMethods#unscope`](https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-unscope) such that: author.articles.unscope(where: :published) This would effectively unscope any where conditions set on the `#published` attribute, while still retaining any where conditions required to properly scope the join. Other query components may be unscoped directly as well, including `:select` and `:order`. This isn't a post in defense of `#default_scope`. I think it has a place, surely, but not always when we may think so.
[dry-web-roda](https://github.com/dry-rb/dry-web-roda) is better alternative to Sinatra. You will have Dependency Injection all the way down. If you care about architecture, flexibility and speed, then you may to want to give `dry-web-roda` a try.
Maybe they're two totally different things and this is a silly question, but how is this different from FFI?
To the best of my understanding, one relatively sane usage of it is act_as_paranoid-alike solutions (marking models as deleted instead of really removing row from a table). In this situation, **most** of the time you want to pretend "they aren't here", and only sometimes, on admin/debugging tasks, you unscope it back.
That's a recurrent question. I assume you're talking about C FFI. &amp;#x200B; A very very short answer: Wasm has different promises, like sandboxing and security. Also, your language does need to support C FFI. It is possible to write a program in Rust, C, C++, Go, Zig, AssemblyScript, even Python maybe, compile it to Wasm, and run it inside Ruby. &amp;#x200B; Concretely, it means you don't need to bother with Ruby internals API to boost performance or combine different programs together. You can write a specific algorithm with Rust or AssemblyScript, compile it to Wasm, and profit a nice performance boost (for example, that's not the only usecase, but I said it's a very very short answer ;-)).
[This guy](https://medium.com/@naltun/rust-ruby-and-ffi-programming-6a4ab403020d) uses FFI to run Rust from Ruby, that's why I asked in the first place
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect), [11](https://www.reddit.com/user/felix_presedinte), [12](https://www.reddit.com/user/werner_la_puscarie) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
Thanks for the heads up!
I suspect the main issue is that the `*` operator doesn't produce an array; its main use is to expand an array into individual arguments when calling a method or performing multiple assignments. While you _can_ capture the resulting list into a single variable, which gathers them into an array, during the intermediate steps where you're trying to add parentheses, you don't actually have an array yet. For your consideration: ``` 1 a, b, c = *(1..3) # a = 1, b = 2, c =3 d, e, f = 4, 5, 6 # Also valid, and structurally similar to what the * does above g = (7, 8, 9) # syntax error, same as (*(7..9)), and for the same reason: this is not an array ```
Asterisk operator is not equivalent to `#to_a` method and also requires surrounding context to decide how "expand" its argument. In assignment expression or within an array constructor it does what you are expecting. In your assignment example, enclosing with outer parens you effectively prevent its expansion by separating its context. To join ranges in array by your first example, you may use enclosing array constructor ```ruby [*1..9, *'a'..'z'] ``` or use `Range#chain` method ```ruby a = a = *(1..10).chain('a'..'z') ```
Yep, this Also, `method(*splattable)` parentheses are not the same kind of parentheses as expression parentheses and don’t have the same rules for what goes inside them so `a = (*(1..9))` contains an invalid expression (syntax error) inside the outermost parentheses.
The main issue is that `*` (as splat) is not an operator. All Ruby operators are just methods in disguise; splat is not. It would make as much sense to talk about the `while` looping operator, `#` comment operator, `end` block closing operator.
I'm not sure how or why that happened: 2.5.1 :001 &gt; def cheese(a, b:) 2.5.1 :002?&gt; puts a 2.5.1 :003?&gt; puts b 2.5.1 :004?&gt; end =&gt; :cheese 2.5.1 :005 &gt; cheese('hi', b: {yo: 'sup'}) hi {:yo=&gt;"sup"} =&gt; nil
I'm not sure how or why that happened: 2.5.1 :001 &gt; def cheese(a, b:) 2.5.1 :002?&gt; puts a 2.5.1 :003?&gt; puts b 2.5.1 :004?&gt; end =&gt; :cheese 2.5.1 :005 &gt; cheese({yo: 'sup', b: 'thing'}, b: 'words') {:yo=&gt;"sup", :b=&gt;"thing"} words =&gt; nil
See we were using 2.5.1 until recently at work. Would you mind trying out 2.6.3 to see if it's new behaviour?
 def cheese(a, b:) puts a puts b end a = {yo: 'sup', b: 'thing'} cheese(a, b: 'string') seems to output {:yo=&gt;"sup", :b=&gt;"thing"} string I was in a minitest class calling a setup (terrible interview pairing exercise) class AggregatorTest &lt; Minitest::Test def setup @Aggregator ||= QuotationInterviewCode::Aggregator.new() @QuotationRequest2Covers = { :covers =&gt; { :tires =&gt; 10, :windows =&gt; 50, :engine =&gt; 20, :contents =&gt; 30, :doors =&gt; 15 } } end def test_get_quotation_returns_expectation assert_equal([0, 0, 0], @Aggregator.GetQuotation(@QuotationRequest2Covers)) end end module QuotationInterviewCode class Aggregator include AggregatorInterface def GetQuotation(raw_rfq = nil, insurer_rates: nil) end end end changing `def GetQuotation(raw_rfq = nil, insurer_rates: nil)` to `def GetQuotation(raw_rfq = nil, insurer_rates = nil)` was all that was required to fix. Perhaps I assumed too much about what was happening and why. It complained `ArgumentError: unknown keyword: covers`
 2.6.3 :001 &gt; def cheese(a, b:) 2.6.3 :002?&gt; puts a 2.6.3 :003?&gt; puts b 2.6.3 :004?&gt; end =&gt; :cheese 2.6.3 :005 &gt; cheese({ yo: 'sup', b: 'hi' }, b: 'words') {:yo=&gt;"sup", :b=&gt;"hi"} words =&gt; nil
hmm, I wonder if it is realted to the implicit hash creation in methods. For exmaple you can do some_method(things: 'stuff') and that will implicitly be the same as some_method({ things: 'stuff' }). I'll try some things, and get back to you.
Oh, one thing I do know. You should, as a general rule, not mix keyword args with positional args with defaults. Perhaps this is why.
What I'm looking for is both a solution to do this As mentioned in OP I've modified in a way that follows your advice before posting; but also why and where this is documented.
 2.6.3 :001 &gt; def cheese(a = nil, b: nil) 2.6.3 :002?&gt; puts a 2.6.3 :003?&gt; puts b 2.6.3 :004?&gt; end =&gt; :cheese 2.6.3 :005 &gt; cheese({ yo: 'sup', b: 'thing' }) Traceback (most recent call last): 5: from /Users/nate/.rvm/rubies/ruby-2.6.3/bin/irb:23:in `&lt;main&gt;' 4: from /Users/nate/.rvm/rubies/ruby-2.6.3/bin/irb:23:in `load' 3: from /Users/nate/.rvm/rubies/ruby-2.6.3/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `&lt;top (required)&gt;' 2: from (irb):7 1: from (irb):1:in `cheese' ArgumentError (unknown keyword: yo) There it is. It is mixing defaults on positional and keyword args.
I beleive you. I've seen the same thing. I even tried changing the damn hash to be a variable rather than constant. It seems to have something to do with being a class function / method, and using a class variable / property It's definitely in the weeds. I just like to understand these oddities. changing One char it all works, which almost makes it more confusing, as does the global method approach you've shown and I've tested same RVM, same Gemset
Hey, CODESIGN2, just a quick heads-up: **beleive** is actually spelled **believe**. You can remember it by **i before e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
I appreciate the help
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
delete
The official Ruby docs [disagrees](https://ruby-doc.org/core-2.6.3/doc/syntax/assignment_rdoc.html#label-Implicit+Array+Assignment) with you: &gt; You can use * or the “splat” **operator** or unpack an Array when assigning. AFAIK there is no a strict rule what may or may not be called an *operator*. It can follow a definiton of a non-alphanumeric identifier (from allowed symbols list) which accepts one (unary) or two (binary) arguments. It has nothing to do with method/proc definition or parse/runtime phase resolution.
Thank you for this context! Given some of the comparisons you made, would it be more correct to call splat a keyword when used in this way?
It's only a matter of time before reddit threads are just bots yelling at bots.
Where did you get your sample of ruby or Ruby on Rails projects to look at to determine anything about "most Ruby on Rails projects" or what is used "just everywhere"? Especially if it's not based on your experience because you are new to it, how have you made this determination about what "most" or "just everywhere" things are doing?
;) I kinda welcome the day. At least if we can identify them as bots / paid mouthpieces
Is it practical to have errors in your schema? We did graphql with rails recently. When error happen, we catch the error in graphql controller and render json with errors. In client, this keeps our queries clean and when errors happen, we get them in errors and there the structure is always the same. Im looking for some way to figure out good system for error handling for us. That is why Im asking, if errors in schema do work for you.
That’s simple. 1. Several projects I were and am involved in my company 2. Taking to my ror colleagues 3. Almost every blog, forum, website and post about ror I searched used to talk about active record and very few of them mention data mapper or something else. Maybe I am wrong but it looks like ruby is very tight with rails and rails itself is quite sticked to active record.
I prefer to treat errors as ordinary data. On the client it's convenient when errors are part of your schema. 1. You can see them in graphiql 2. You can automatically generate error types from the schema (it's useful if you are using typescript / flow) 3. It minimizes error handling logic ... and so on (Your errors get all the benefits of being GraphQL type :))
As it mentioned in the post, there are (usually) two types of "errors": exceptions and user-input related errors (e.g., validation errors). The latter should be a part of the schema: clients could use this information to provide more descriptive error messages/states/call-to-actions (i.e., to build _actionable errors_). The former could leave outside. Or you can handle some exceptions at the schema level (e.g., "not found" and authorization exceptions) and other at the controller level (and "show" them to clients as a universal "something went wrong"). _Exceptional_ responses could also be a part of the API (but not the schema): for example, you can add custom meta data to GraphQL errors via \`extensions\`. We use this to add unique error codes and reasons like this: ``` rescue_from(ActiveRecord::RecordNotFound) do |_exp| raise GraphQL::ExecutionError.new("Not found", extensions: {code: :not_found}) end ```
We (EngineYard) are still kicking it with Ruby. While I work for them they we're also my first introduction and reason to learn ruby. While not being a consultancy or agency I feel like GitHub are still great with how they do open source and has supported the ruby community all this time.
I don't know if you're wrong, depends on how you mean it exactly. What aspect of what you've noticed is surprising to you coming "from php (zend)"? I'm not at all familiar with zend, it does not have a similar database/ORM layer?
I don't think I've ever seen that pattern before, if I need to extract methods out I just create a new class and pass the instance to that module/class and call the method there. I'm not aware of anything that does this, but this wouldn't be that hard to implement just need `define_method` and `public_send`: # This could also be done with include or extend # But I thought the using keyword fit better # or you could just monkey patch this method in, # but who would ever monkey patch, Class.... right? module DelegateComposition refine Class do def delegate_via_composition(*delegates) options = delegates.pop delegate_class = options[:using] delegates.each do |delegate| define_method delegate do |*args, &amp;block| instance = delegate_class.new(self) instance.public_send delegate, *args, &amp;block end end end end end class DelegateReciever def initialize(sender) @_self = sender end end class Extracted &lt; DelegateReciever def a priv_a + 2 end def b(baz) priv_b(baz) end private def priv_a 1 end def priv_b(baz) @_self.foo = "#{baz}-bar" end end class Deity using DelegateComposition attr_accessor :foo delegate_via_composition :a, :b, using: Extracted def initialize @foo = "foo" end end obj = Deity.new obj.a # =&gt; 3 obj.foo # =&gt; "foo" obj.b("baz") obj.foo # =&gt; "baz-bar" [REPL](https://repl.it/repls/PreviousCrimsonGlitch)
Not really a keyword either, as keyword typically implies it's a word - as in, if it wasn't a keyword, it'd be a legal identifier. There's nothing wrong with just calling it "the splat", or "the splat syntax" (or "the rest syntax" when it gathers values into an array, rather than dump values into one). MDN typically calls the equivalent \`...\` JavaScript form "spread syntax" (or "rest parameter syntax"), I am totally okay with that.
And I, in turn, disagree with it. My reasoning is based on the syntax and semantics of Ruby. For example, in \`parse.y\`, the character \`\*\` is two different tokens: one is just called \`\*\` and is the multiplication operator, the other is \`tSTAR\`. \`\*\` appears along with pretty much all operators in the definition of \`expr\` (or one of the subsumed nonterminals \`arg\` or \`rel\_expr\`), and (as you say) accept one or two (or three) \`arg\` (arguments). Meanwhile, \`tSTAR\` specifically only appears in very restricted places: \`mlhs\_head\` (multiple assignment LHS), \`args\` (arguments to a function), \`mrhs\` (multiple assignment RHS), \`f\_rest\_arg\`/\`f\_rest\_marg\` (function arguments rest syntax), \`case\_args\` (arguments in a case clause), \`p\_args\`/\`p\_args\_tail\` (places like \`rescue \*bad\_things =&gt; x\`). They are very different; and even if the docs say it's an operator, I'll continue claiming that it is confusing to new learners and dangerous to call it that, because calling it an operator leads people to expect it to \_behave\_ like an operator.
If you can influence the test containers at all - and assuming compilation of stuff isn't part of what is tested - you can grab the post-compile [docker layer](https://medium.com/@jessgreb01/digging-into-docker-layers-c22f948ed612) and reuse it to avoid having to re-run things each time. Also you can run bundler in [explicit parallel](https://philna.sh/blog/2017/06/12/speed-up-bundle-install-with-this-one-trick/) mode.
* if you're not exporting vars, you should make them lower case. e.g.: `CORES` `cores`. * it's better to configure bundler using [bundle config](https://bundler.io/v1.16/bundle_config.html). e.g.: `bundle config jobs $(sysctl -n hw.ncpu 2&gt;/dev/null || nproc)` (you only need to do this once) vs env vars. * I can't think of anything off the top of my head, but I feel like `MAKEFLAGS="-j$CORES"; export MAKEFLAGS` might bite you... maybe not...
Just start writing code again. I work a day job in an unrelated industry and I write code just for fun in hopes that my skills will someday evolve to overtake my dayjob. Install some Linux or BSD and start hacking, is gotta be labor of love. Good luck!
Reading [Ruby Weekly](https://rubyweekly.com) might be a good start to catch up.
Slight correction: `bundle config set --global jobs &lt;num&gt;` The command line without `set` is deprecated, and will tell you this when you run it. Prefering environment vars when available is fine enough I suppose if you want to see how much change this option makes, but as indicated by u/qubitrenegade, it's better to set this permanently in your bundle config file (by default it's in `~/.bundle/config` \- you can edit it by hand if you want). Your method using env vars calls `sysctl` (and potentially `nproc`) on *every* invocation of your shell. Every time your terminal starts, whether you're using bundler or even Ruby - or not. It might not take long, but if you "prefer environment vars" - that time adds up. (Seriously, if you've spent any time optimising your shell startup files, you'll understand why even a few ms is precious.) Setting the jobs value for bundler is smart. Doing it using env vars - not so much. If you can set it once and never have to worry about it again, why not do that? Do you really change your CPU core count frequently? (Even in a Docker or CI environment, do you often change your core count?)
Hey, DecentHumanAttempt, just a quick heads-up: **prefering** is actually spelled **preferring**. You can remember it by **two rs**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
delete
In fact, I would key the layer off of Gemfile.lock, which would only incur the install when the gems actually need to change.
&gt; Slight correction: bundle config set --global jobs &lt;num&gt; No. You must be thinking of some other command. &gt; it's better to set this permanently in your bundle config file No, that's a matter of context and preference. Being a Unix greybeard, my /home directory is a network share mounted by Linux, Mac, and FreeBSD clients and for standalone machines the dotfiles are sync'd via git. Which amongst other things means that hard-coding machine-specific values into it is super wrong. And is also why it's written in Bourne shell not bashisms. &gt; Seriously, if you've spent any time optimising your shell startup files you'll understand why even a few ms is precious Optimising shell scripts is like polishing a turd. &gt; Do you really change your CPU core count frequently? From the point of view of lines in .profile, all the time. See above
/home is a cross-platform network share and my dotfiles are sync'd via git, so it makes sense to evaluate dynamically. Same goes for CI runtime users.
This should win some kind of pedantic award :-)
I know that error message is a wall of text so it's easy to zone out on it but if you look about 4 lines from the bottom it has this suggestion `Make sure that \`gem install jaro_winkler -v '1.5.3' --source 'https://rubygems.org/'\` succeeds before bundling.` so you can copy and paste the part inside the quotes into the command line and see if that fixes the issue. `gem install jaro_winkler -v '1.5.3' --source 'https://rubygems.org/'` You might run into another error but then it's usually just a process of finding the most part of the error message and either following the suggestion or googling the error.
Turns out I needed to install ruby-dev... \`cunting software\`
Yeah Mr Winkler's software package wouldn't install, I had to install ruby-dev and then the package separately as recommended by bundle.
Fine. I forgot I was using bundle 2.1.0.pre.1 (since I'm also using Ruby 2.7pre1). My bad - was trying to be helpful for posterity but ok. So *any version of bundler* except the most recent/bleeding edge version, right? But you're an expert greybeard and could figure that out right? Try that command and see what it tells you with the next version of bundle. Hint - it looks like this: \`\`\` bundle config --global jobs 3 \[DEPRECATED\] Using the \`config\` command without a subcommand \[list, get, set, unset\] is deprecated and will be removed in the future. Use \`bundle config set --global jobs 3\` instead. Your application has set jobs to "3". This will override the global value you are currently setting \`\`\` Goddamn I hate this industry sometimes. &lt;/done&gt;
Somehow related: CircleCI caches the bundle directory between executions. That way, bundler only needs to do its work when a gem is updated. It's another approach to probably solve the same problem.
A few things: 1. Bundler should not be installed with sudo, otherwise it gets unlimited access to your files because it's installed as an admin - which is a security risk. The reason your computer requires sudo to be used to install bundler is because ruby is installed in a location where the gems folder is not owned by your user. 2. Ruby should be installed with something like Chruby (and ruby-install), Rbenv, or RVM to make sure permissions are setup nicely. Once you do this, then bundler will install without `sudo`. 3. When you see something like `Gem::Ext::BuildError: ERROR: Failed to build gem native extension.`, this means that a C extension the gem uses (in this case jaro_winkler) cannot compile due to a system dependency being missing. This is a GCC dump. 4. The line `mkmf.rb can't find header files for ruby at /usr/lib/ruby/include/ruby.h` looks pretty suspect, so I'd google that. This leads me to [this SO post](https://stackoverflow.com/questions/20559255/error-while-installing-json-gem-mkmf-rb-cant-find-header-files-for-ruby), which suggests installing `ruby-dev` (as you've done). 5. I've added these instructions to [my plugin here](https://github.com/jules2689/extended_bundler-errors/commit/1505dc467ca8fd9617be40d7ac2475f7e760c5f8). I'd recommend installing it using `bundler plugin install extended_bundler-errors` which will try to help with these kind of gcc dump errors. I'm also working on eventually building this into Rubygems (where the error comes from). 6. As an aside, `bundle update` may not be what you want to run. Running this command is like deleting your lockfile and running `bundle install`. It will indiscriminately update any and all gems to their latest versions, regardless of how many version changes there are. This can often lead to multiple gems breaking as major API changes happen. I'd recommend running `bundle install` or updating specific gems with `bundle install &lt;GEM NAME&gt;`. Hope this helps!
Google launch4j
You've just validated my preference for environment variables.
Yea, I have helpers like that in a number of projects, I was hoping there was something that was more mainstream so I didn't wind up introducing a new library :/. Draper is... not quite what I'm looking for. I've used it in the past and it's improved it's DSL tremendously; but it's doing a lot more than what I need. This pattern is mostly useful when a change must not change the interface of the object being refactored. In cases where the interface can be changed, (i.e. Class X , Method A is being called in only one place in Class Y) I do what you describe where I pull the methods off of Class X and either into a class nested in Class Y's namespace, or into Class Y itself.
*non sequitur* I'm sorry, but implementation detail does not imply language syntax naming. Either there is a bug in the documentation or you are wrong. It is that simple …
Not ruby specific but I don’t believe there is any way to setcap on any script, it has to be done on the interpreter binary. You could use something like chruby to isolate an interpreter for this if you want.
IMO honestly not too much has changed in ruby in the past 2 years. These have not been 2 years of lots of changes.
&gt; If you could resume in only a few sentences what has changed in the ruby dev over the last two years what would you mention Hype for Ruby 3 and Rails 6. That's pretty much it I don't run a company but I have done a good amount of hiring. You would need to get through a recruiter (they have their own filters) but if you can pass the interview I wouldn't see any reason not to hire you just because you took a break
Generally, you need root permissions to receive raw packets on an interface. This SO post has some pretty awesome explanations: https://stackoverflow.com/questions/9772068/raw-socket-access-as-normal-user-on-linux-2-4
I feel like maybe saying `*` is not a _method_, but it is an _operator_. Some ruby operators are exposed as methods, that you can implement and override. Other ruby operators are not.
You don't need anything but the Ruby standard library. class Deity extend Forwardable def_delegators "Extracted.new(self)", :method_a end although I usually want to pass around the result and have fewer instantiations and habitually write class Deity extend Forwardable def_delegators :extracted, :method_a def extracted @_extracted ||= Extracted.new(self) end end instead. If I'm in Rails land, I'll use [Module#delegate](https://edgeapi.rubyonrails.org/classes/Module.html#method-i-delegate) which is more powerful. And actually, using ActiveSupport as a gem apart from Rails isn't so terrible - in particular, the list of dependencies is very short. &gt; I prefer this to using include or extend because those don't reduce the surface area of the class This actually bugs me a little, and you might not agree, but I've never been convinced this is a desirable objective, not like "write more readable code". It's already a compromised outcome because we don't usually inherit from BasicObject so our instance methods already include the junk drawer of `Kernel`. And writing a module forces you to think it could be included anywhere, which is a mindset leading to very reusable code. Having extra methods because you `include`'d a capability isn't intrinsically a bad thing. It doesn't violate the SRP because the extracted methods are still in a different unit of code, which is what matters. Ruby gives us `include`; why fight the machine when it wants to serve you. My reason to choose extraction into a utility class rather than a mixin is usually to enable passing around of the resulting object, or for substitution e.g. in a strategy pattern.
This is why I love Ruby. Instead of copy/pasting, you could do something like this, where `report.rb` is your local Ruby script: heroku run rails console &lt; report.rb
The most significant con is that a proc written _inline_ within a test file cannot possibly be a test subject, because tests have to test something _outside_ the test. You're blurring the lines between the test subject and the test fixture by putting test code inside the subject.
Are you just looking for stdlib rails `delegate`? I think "delegate via composition" is just what we call... delegation. https://medium.com/@pk60905/using-delegate-in-rails-527332da7f96 But I may be misunderstanding what you're doing -- your code sample quoting got messed up, and I couldn't follow your code totally. (indent FOUR spaces for preformatted code sample on reddit). I'm not totally sure how you'd this without rails; the stdlib "SimpleDelegator" stuff seems to assume you'll only be delegating to _one_ composed object per instance, where you are talking about having two of them (which is not unreasonable). But there might be a way to do it. OR.... the implementation can probably be _almost_ as easy as this: ``` module MyDelegation def delegate(method, to: target_method) define_method method send(target_method).send(method) end end end class Deity extend MyDelegation delegate :method_a, to: :extracted_helper def extracted_helper @extracted_helper ||= ExtractedHelper.new end end ``` ```
How does your `ping.rb` differ from GNU/Linux's default?
Is anything in RSpec not controversial?
You should be able to create the raw socket and `bind` it as root or from an executable with `CAP_NET_RAW`, then drop privileges and `exec` the ruby script "passing" the socket along as an already-open file descriptor and converting it to a ruby Socket object using Socket::for_fd. Unfortunately this means writing a small executable in a compiled language. Also, unfortunately, Net::Ping::ICMP#ping [creates its own socket](https://bitbucket.org/chernesk/net-ping/src/c54ac6a6109f937e130dd2fed8a463154cac60fd/lib/net/ping/icmp.rb#lines-77:81) and doesn't allow you to pass one in so you'd need to modify it to accept an already existing socket.
It's written in Ruby and uses [Net::ICMP::Ping](https://bitbucket.org/chernesk/net-ping/src/c54ac6a6109f937e130dd2fed8a463154cac60fd/lib/net/ping/icmp.rb)
Well, that much I know. Thanks for the insight. But, you're calling `#ping` and not `#ping?`, does this mean you're using the return value? If not, and you just want to know if a host is up, just use `ping`. *nix has already solved this for you via a the set user id permission on the executable.
You can use this logic for 30% of Ruby core, and 80% of Rails
Ruby Core, excellent. Rails extending Ruby Core with incompatible aliases with little benefit causing confusion in the Ruby ecosystem, not excellent.
I'm not OP, I'm not calling anything. If you knew they were using net-ping why wasn't "does this mean you're using the return value?" your original question? As OP stated, OP is aware of `setuid` executables and explicitly doesn't want one for ruby, likely because any setuid-root interpreter is incredibly dangerous to have around. OP also doesn't want to use `ping(8)` if they can avoid it.
I really like how Relish go long lengths to enable prose-like code. You can go buck wild with it if that's your perogative. Personally I like to keep things simple and explicit. More idiot-proof and easier to understand.
Thanks for your answer. I guess that it comes more to the development world in general, and specifically web dev. This industry moves forward so quickly that it's hard to keep on track when you are working. Now imagining how it's going to be after being outside from it for a couple years is pretty daunting ! &amp;#x200B; Maybe Ruby didn't change that much, fortunately, put JS on the otherside seems to have change yet again. React is now everywhere, along with it's own frameworks, and it looks like the trend for functional programming is catching up in the job market. &amp;#x200B; Again, this is just my impression after a few days lurking in the job ads and forums.
An example with a given sample input and output would help visualise the problem.
Why do tests and code need to be separated? Plenty of languages have compile time assertions, others have doctest and other useful systems of putting test cases right next to the code.
Single responsibility principle?
`raise StopIteration`
&gt; Also I'd be interested to hear, for those of you who run a company, how likely would it be to consider hiring someone who's been for that long out of the loop Plenty of folks take a sabbatical. Frankly I'd be interested in hearing what you learned on walkabout.
Sure thing! So I execute the script from a Putty-Shell via "./genericscript.rb" the "generic.log" is filled with paragraphs like this:" &amp;#x200B; &gt;Started GET &gt; &gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis vehicula tellus mattis risus dignissim volutpat. &gt; &gt; Nullam dignissim nisl in orci posuere aliquam. Quisque faucibus vitae lorem fringilla mollis. &gt; &gt; Duis sollicitudin tortor et euismod placerat. Class aptent taciti sociosqu ad litora torquent per conubia nostra, &gt; &gt; per inceptos himenaeos. Duis euismod pharetra neque ac feugiat. Fusce congue in quam in pharetra. &gt; &gt; Suspendisse et varius libero. In feugiat, justo in molestie interdum, enim neque convallis enim, sed lacinia nulla neque at nulla. &gt; &gt; Donec mollis purus id neque ornare, et fermentum tellus imperdiet. Vivamus in dolor at quam venenatis imperdiet. &gt; &gt; Phasellus quis faucibus augue, in ornare nibh. Morbi gravida ligula porta, lobortis nisi ac, volutpat metus. &gt; &gt; Fusce tortor velit, lacinia vitae dolor at, scelerisque consequat lorem. &gt; &gt;Complete I get following output: &amp;#x200B; &gt;\[\[14, 882\], \[896, 1764\], \[1778, 2646\], \[2660, 3528\], \[3542, 4410\]\] &gt; &gt;"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis vehicula tellus mattis risus dignissim volutpat.\\r\\n" &amp;#x200B; Which is the Bytepositions from "f.pos" the starting and ending line respectively in a 2d-array. And the 2nd line of the first paragraph I want to extract. Which I am not quite sure why it is the second, because I was assuming it should get me the first. ( I expect to get "Started GET" instead of "Lorem ipsum")
Just sounds like a big advert for that tool
Doctests still separate code and tests. The tests still exercise _just_ the code, and not some intermediate block. Compile time assertions aren't for software testing. They're in a similar vein, but that's not the same thing.
Because it is one. The author is the knapsack author.
You downvote but this is a legit question. Examples?
Not of fan of the implicit block syntax. It makes the code much harder to follow. I couldn't imagine how frustrating real tests would be to read using that syntax.
Or... Just use the parallel tests gem and not pay anything...
I'm sorry, I thought of this as a rhetorical question. Indeed, RSpec is very flexible and it is so to abuse its numerous features. The main point of the style guide is about letting people know what is a common practice, and what should not be used to avoid confusion amongst other people working with the same code and to avoid pitfalls.
&gt; If you knew they were using net-ping why wasn't "does this mean you're using the return value?" your original question? There could be several reasons why one would use net-ping over the ping executable. OP stated none. Return value can be completely irrelevant. I ended up throwing that out there due to your reply, but off the top of my head I can think of several others. Better to ask than assume. &gt; As OP stated, OP is aware of setuid executables and explicitly doesn't want one for ruby, Is this why he doesn't want to shell-out to ping? Seems like a no. He doesn't want to do this to the script, but otherwise it doesn't say -or, _at least_, it's not clear to me. &gt; likely because any setuid-root interpreter is incredibly dangerous to have around. "Likely". Maybe. Who knows why. This is why I asked. &gt; OP also doesn't want to use ping(8) if they can avoid it. Yes, this is the question: why not? Often people don't want to do something but when their reasoning is vetted and/or the technical merits are explored they realize that they have no good reason not to.
&gt; Yes, this is the question: why not? No, that is not OP’s question. That is your question and is not helpful to OP. Immediately questioning their premise is not respectful of their knowledge or skill.
 a = [*0..9] a.inspect =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
I'm writing a set of scripts to measure various aspects of a server and I want to measure the latency over time. So I do need the return value.
&gt; GitLab CI allows you to run tests much faster Faster than...? This reads like the author is not a native English speaker and couldn't be arsed to proofread. I sound like a broken record, but if you're going to try native advertising, at least ask someone to proofread your copy! Also, I love how the article tries to lure you in and then goes "use our paid product!" Just be honest. I probably would be interested knapsack... but instead of "how to speed up your ruby testing with Knapsack Pro" we get this clumsy attempt to lure you in with a misleading headline, then about half way through drop the "buy our product to solve this problem" so I feel like I've been hoodwinked.
&gt; Immediately questioning their premise is not respectful of their knowledge or skill. That's some conclusion!
Thanks, I know how to do this with the standard lib (I use \`Forwardable\` all over the place) I was hoping there was a more canonical name for refactoring pattern, and that it was semi-codified into a library so that it was easier to communicate about what was going on and why.
I use \`Forwardable\` for this in non-rails environments and the ActiveSupport::Delegation for this in Rails contexts; I am asking more about what do people call this kind of refactor \_and\_ if there is a semi-codified version of it. I.e. "Oh! That's a combo of the Extract Class refactor plus &lt;???&gt;, and we use the library &lt;x&gt; to make it clearer that that is what we are doing in these cases."
Assuming constructor injection is not an option, the simplest option would be to use parameter injection and optionally inject a mock SlackWrapper: def post_to_slack(metric, clusters, slack: SlackWrapper.new("#general")) clusters.each do |cluster_name| metric_data = metric_statistics(metric, cluster_name) msg = "The #{metric} on cluster #{cluster_name} is " \ "#{metric_data["data"]} #{metric_data["unit"]}" slack.post_msg(msg, slack.channel) metric_widget = metric_widget_image(metric, cluster_name) slack.post_img(metric_widget, slack.channel) end end I would try to go a step further and decouple the concerns though: one concern is building the message, the other is transporting the message (in this case via Slack) It's unclear to me how AWS is involved here, but fetching metrics from AWS sounds like another concern (which likely belongs in another class)
&gt; I'm sorry, I thought of this as a rhetorical question It is and it isn't. Establishing a consensus with RSpec is always a chore. For nearly everything one can do, there are length discussions/bikeshedding sessions. I don't think I've ever seen this for a test library —or possibly any library. I think `expect` is not controversial, now. As at one time is was: `expect` vs `should`. But that's all I can think of. And to be clear I definitely did not mean to disrespect your blog post or the style guide. I do enjoy reading them. :)
Thank you for taking the time to help me out. I think I am starting to understand this. If I separate the metrics_data and post_metrics into other classes, how will that change anything if my post_to_slack method will still need to fetch the metric data and post to slack in a single method? Somewhere those 2 method calls will need to happen together.
Fair enough! Personally I wish ruby had Doctests, they're an elegant way to test simple assertions, i.e. @doc """ Makes text sound like it was spoken by spurdo sparde # Examples iex(1)&gt; spurdify("hello there") "hello dere :DDDDD" iex(2)&gt; frobnobulate("god bless") "dog blezz xDDDDD" """ def spurdify(text)...
Cool. Maybe someone else will have other questions, I am unaware of any special name for it, and I'd find some library/gem to make it *less* clear what's going on compared to just writing the pretty simple code with forwardable/delegation.
You'll have smaller methods that are easier to test and reason about.
Great idea! Sometimes I go step by step to make sure everything works as I want, but as soon as everything is fine, this is a neat way of doing it as well. Thanks!
It depends what you want to test. Do you want to test building the message? Put that in a method. Do you want to test things going to Slack? Put that in a method. Hitting AWS? Put that in a method The only thing that is tricky is if you want to test the orchestration layer. Then you have a few options. You can either test the orchestrator in isolation by injecting dependencies and testing message passing via mocks or you can treat it like black box (e.g. have a fake Slack setup at a global level and check what it received). There are other variations of these ideas too (e.g. stubbing particular methods, using VCR to record HTTP interactions then play them back) I personally would skip testing the orchestrator if I felt confident enough that the other pieces worked unless it was a critical path in the application
Yea, I'm leaning in that direction too. The fact that there isn't a name for it + a reference implementation off the top of people's heads means that it's not likely to be a useful communication mechanism.
It's not exactly the same. Parallel test only do local parallelization (on the same machine). Knapsack pro allows to split the work on many different machines. I haven't tried it myself, but I authored something similar a long time ago: https://github.com/Shopify/ci-queue
I don't know why anyone has down-voted this. It's unexpected and a friction point
You can run tests in parallel in gitlab without using whatever this guy is promoting
"Started" and "Completed" sounds like Rails log files. Rather than make two passes, you can simply create a buffer, load the lines for each process into the buffer, then analyze the buffer and aggregate statistics when you reach the end of each process. That's the strategy used in [rails-log-block-grep](https://github.com/kyanny/rails-log-block-grep/blob/master/rails-log-block-grep.rb). That code might give you some ideas.
If you want to test real tcp calls in your code you can use VCR [https://github.com/vcr/vcr](https://github.com/vcr/vcr) &amp;#x200B; It basically stores the result of the first test run, then uses that each time you run your tests, making them super quick.
I don't like *any* use of "it { is_expected.to ...". But I think they are only talking about a specific subset of those uses, involving "block matchers"? Because they have rspec core team saying "pretty obtuse and not something I’d recommend, generally" -- they aren't talking about "it { is_expected.to ..." in general there are they? Or else why do they even support it? But I find "it { is_expected.to ..." generally to be "pretty obtuse", to the point that I can't even really figure out what's being talked about in this issue, because it is all so obtuse. If Rspec doesn't mean to support that weird `it { } ` syntax generally... why did they invent it and still support it without deprecation? I'd totally support getting rid of that whole thing, but I don't *think* that's what's being talked about, just a *particular* use of `it {} `. One using a "block matcher". I don't think anyone's gonna be able to tell which uses are a "block matcher" and which uses aren't.
You could also use a Kubernetes cluster to run your test suite. A bit more complex at first but way more scalable in the end.
&gt; Following the conventions of unit testing, I need to decouple the dependencies on the AWS and Slack API or else the test for this function will be considered an integration test. Don't do this. Test what is important to verify, not what some abstract rule told you to test. Your tests should make sure the thing works, if it's a 'unit' or 'integration' test isn't important.
It's nearly impossible to read your code. Reddit's code formatting tools suck unfortunately, you need to indent it 4 spaces to get it to format correctly. Paste the code into SublimeText, set it to indent by 2 spaces then highlight all of it and hit tab twice, then copy paste back into your question or add as a comment. It sucks but reddit sucks for this.
Is a stupid principle?
Typing and tests have nearly nothing to do with each other. If you are testing types, you're not understanding duck typing.
Measurement actual performance for ALL [rubocop-performance](https://github.com/rubocop-hq/rubocop-performance) codes.
It's funny, i never thought of using Rubocop to provide some sort of optimization of execution. I think of Rubocop as away of optimizing development. Code that is uniform, all things being equal, is more readable and therefore helps with your biggest cost as a software company, developer time: reading, reviewing and maintaining code.
Rubocop is not only for readable-code. Rubocop-performance is cops to point issue about performance. So it's good to know how much the cops are reasonable.
Check out the `bowser` gem for interacting with the DOM. I usually build my front-end Ruby apps with Sprockets (via `clearwater-roda`), but you can also use `opal-rails` if you want to stick with Rails on the back end.
I don't understand what the graphs show.
Well in terms of named refactoring patterns, and assuming that [Fowler](https://www.amazon.com/dp/0134757599) is the canonical dictionary, it's just good old "Extract Class" followed by "Hide Delegate". Wrapping that in class-level declarative-style magic is just plain old metaprogramming, which I wouldn't really describe as a pattern. And as with all metaprogramming it's _very_ easy to obscure the intention of code by being too clever, which is a debuff to maintainability. [Duplication is better than the wrong abstraction](https://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction). Personally I tend to avoid creating more framework unless it's really strongly indicated, so my favoured approach is to use what's already on hand i.e. as above with Forwardable or ActiveSupport for the delegation and the memoizing factory method for the extracted collaborator. But here's another excellent alternative, once again channeling St Sandi Metz. Consider the wonderful OO opportunities afforded by dependency injection with an argument default: class Deity extend Forwardable def_delegators :@priest, :pray def initialize(priest: Priest.new(self)) @priest = priest end end
I/s = instructions per second I guess
Good point. Number is ips (Iteration per second) measured by benchmark-driver. So basically longer bar means faster. You can see the detail of sample by clicking "code".
Yes, it is a Rails log, I did not know, that would make a difference. Looking at your source code, you seem to have done the same thing I want to do? I'm not quite sure, since there is a lot of sourcecode i don't really understand. Would you mind me asking some questions, as I go and try to understand it?
\#!/opt/ruby2/bin/ruby &amp;#x200B; line= "" &amp;#x200B; position1=\[\] &amp;#x200B; position2=\[\] &amp;#x200B; x=0 &amp;#x200B; y=0 &amp;#x200B; [File.open](https://File.open)('generic.log', "r") do |f| &amp;#x200B; f.each\_line do |log| &amp;#x200B; if log.start\_with?("Started") &amp;#x200B; position1\[x\]=f.pos &amp;#x200B; x+=1 &amp;#x200B; end &amp;#x200B; if log.start\_with?("Complete") &amp;#x200B; position2\[y\]=f.pos &amp;#x200B; y+=1 &amp;#x200B; end &amp;#x200B; end &amp;#x200B; end &amp;#x200B; position = [position1.zip](https://position1.zip)(position2) &amp;#x200B; print position &amp;#x200B; puts &amp;#x200B; file = [File.open](https://File.open)('generic.log', "r") &amp;#x200B; bruh= [file.seek](https://file.seek)(position1\[0\]) &amp;#x200B; file.gets &amp;#x200B; p $\_ &amp;#x200B; file.close &amp;#x200B; maybe this helps you out, I didn't see the problem you mentioned, otherwise I would have made it more readable from the getgo... Sorry. Can you help out?
But what is the comparison of with and without rubocop? "good sample" is after it's fixed by rubocop? Then why aren't they side-by-side with the bad samples and why are they not 1:1 examples of the good:bad samples? And a lot of times performance goes down if we are supposed to compare bad sample x to good sample x. But if that is the case, then this layout is very confusing.
Looking for deft application developers... please contact me on victoritodo3@gmail.com if interested. #programmer #developer #crossplatformapplication #gigs #jobs
Looking for deft application developers... please contact me on victoritodo3@gmail.com if interested. #programmer #developer #crossplatformapplication #gigs #jobs
Looking for deft application developers... please contact me on victoritodo3@gmail.com if interested. #programmer #developer #crossplatformapplication #gigs #jobs
It's these: https://github.com/rubocop-hq/rubocop-performance/blob/69ba7f724e4607444b16070c563ad329d7f01bed/lib/rubocop/cop/performance/start_with.rb#L9-L16
OK, thanks for the pointers. As much as I hate to do so, I may just use the system ping command for my needs.
Take this all with a grain of salt though. You can get amazing micro benchmarks when looking at tiny snippets but in an actual full on application it ends up doing little unless it’s a hotspot.
This is not showing performance Technic, This measurement is to confirm we can believe cops recommendation.
This is a really cool project. I think it is something that could potentially be hosted with the rubocop-performance code base to better serve the community. &amp;#x200B; In case anyone was wondering, many of the Performance cops were inspired by the [fast-ruby](https://github.com/JuanitoFatas/fast-ruby) project. &amp;#x200B; Some of your examples could be improved to better show off the performance. For example, the perfromance of Performance/Count is highly dependent on the size of the initial collection. The examples for these cops use arrays of size 3 and 5. As the size of the initial array increases, the cop theoretically becomes more performant. This is because `select` will allocate a temporary array with the new values. Using Ruby 2.6.3 require 'benchmark/ips' SMALL_ARRAY = (1..10).to_a LARGE_ARRAY = (1..1000).to_a Benchmark.ips do |x| x.report('small array select.count') { SMALL_ARRAY.select { |n| n &gt; 5 }.size } x.report('large array select.count') { LARGE_ARRAY.select { |n| n &gt; 500 }.size } x.report('small array count') { SMALL_ARRAY.count { |n| n &gt; 5 } } x.report('large array count') { LARGE_ARRAY.count { |n| n &gt; 500 } } x.compare! end Warming up -------------------------------------- small array select.count 146.056k i/100ms large array select.count 2.526k i/100ms small array count 170.888k i/100ms large array count 3.009k i/100ms Calculating ------------------------------------- small array select.count 2.092M (± 5.7%) i/s - 10.516M in 5.045206s large array select.count 25.886k (± 9.7%) i/s - 128.826k in 5.030648s small array count 2.517M (± 4.5%) i/s - 12.646M in 5.036142s large array count 30.106k (± 5.0%) i/s - 150.450k in 5.011087s Comparison: small array count: 2516607.1 i/s small array select.count: 2092200.4 i/s - 1.20x slower large array count: 30105.7 i/s - 83.59x slower large array select.count: 25886.2 i/s - 97.22x slower
I get that, what I’m saying is it might not even be worth your time to fail a build based on one of these recommendations because making the change might not actually result in any real measurable gain.
I don't understand all the bars though. If the point is rubocop recommendations improved performance, I guess we want to compare pre-recommendation code to post-recommendation code? We seem to be comparing "bad_sample" 1 to 3 with "good_sample 1 and 2". Are some of these pre-commendation and some post-recommendation?
I am not sure that I would dogmatically break this out like I am about to suggest. However, it may demonstrate a testable component distribution that is a little more OO: &amp;#x200B; First: # metric_statistics.rb ... def msg "The #{metric} on cluster #{cluster_name} is " \ "#{metric_data["data"]} #{metric_data["unit"]}" end def widget_image ... end Now there is an object that encapsulates the widget, the metrics, the data, etc. That is unit-testable and helps regressions against the statistics and messaging. It seems trivial but I find this stuff changes a lot before it stabilizes. Next, injecting a slack\_wrapper that is implemented for test is a good idea. But to me, it actually looks like you are writing the slack\_wrapper itself. So you could also use rspec. RSpec.describe SlackWrapper do before :each do allow(SlackClient).to receive(:post_img).and_return(200) end ... end I don't find a lot of usefulness in testing collection iteration -&gt; doing some task. I would rather test the task and build it such that a collection iteration can simply call it as many times as needed. If there is a 'flaw' in your approach it is testing the collection iteration rather than the isolated object and its interactions.
Is this solvable with just grep and awk? I love Ruby but sometimes these things are just easier with subprocesses because you eliminate the memory problems. If this is something in that needs to go into your monolith then yeah, doing it Ruby is probably the right way. If it's one off or manual scripting then I would just go with tools built for this How big are the files once you strip out everything but the started/completed lines? Do they still not fit in memory? If they will I would just filter them down and keep things easy
Good to know. I haven't used it in a while.
Good catch! That was a bug. I've updated the script, but it's worth looking at why that was happening. I'll reference these two versions and the diff throughout: Old version: [https://github.com/kyanny/rails-log-block-grep/blob/39e6156213f50ce8dc2af581ca97b6968dabf7f0/rails-log-block-grep.rb](https://github.com/kyanny/rails-log-block-grep/blob/39e6156213f50ce8dc2af581ca97b6968dabf7f0/rails-log-block-grep.rb) New version: [https://github.com/kyanny/rails-log-block-grep/blob/master/rails-log-block-grep.rb](https://github.com/kyanny/rails-log-block-grep/blob/master/rails-log-block-grep.rb) Commit diff: [https://github.com/kyanny/rails-log-block-grep/commit/32ea89689807c11f7de8d602ff32852e57cd865d](https://github.com/kyanny/rails-log-block-grep/commit/32ea89689807c11f7de8d602ff32852e57cd865d) Let's start with the **old version** and try to understand how the script works, and what went wrong. The script works by reading each line of the input file and detecting the start of a new "block" of text to be searched. We're using something called ARGF to read a file from the argument list. There's an excellent [Thoughtbot article on ARGF](https://thoughtbot.com/blog/rubys-argf) that you should have a look at. First have a look at [lines 82 &amp; 83](https://github.com/kyanny/rails-log-block-grep/blob/39e6156213f50ce8dc2af581ca97b6968dabf7f0/rails-log-block-grep.rb#L82-L83). Here we define two variables: * `block` a string containing multiple lines of text that will be searched for a pattern, and output if a match is found. * `buffer` a string variable used to build chunks of text that will be moved to a `block` when they are complete The script starts reading the input files on [lines 85 &amp; 86](https://github.com/kyanny/rails-log-block-grep/blob/39e6156213f50ce8dc2af581ca97b6968dabf7f0/rails-log-block-grep.rb#L85-L86), passing each line to the into the `each_line` block as the variable `line`. On [line 90](https://github.com/kyanny/rails-log-block-grep/blob/39e6156213f50ce8dc2af581ca97b6968dabf7f0/rails-log-block-grep.rb#L90), the script uses a regular expression to determine if the line begins with the text 'Started'. If it does, the current buffer is assigned to the variable `block`. If the line does not begin with 'Started', we just keep adding lines to our buffer. On [line 97 through 108](https://github.com/kyanny/rails-log-block-grep/blob/39e6156213f50ce8dc2af581ca97b6968dabf7f0/rails-log-block-grep.rb#L97-L108), the script checks the `block` variable to see if it matches our pattern, then colors it and outputs the result. This code fails because the current `buffer` is only transferred to the `block` variable when a line beginning with 'Started' is encountered. The block containing 'Paragraf5' is still in the buffer when the script reaches the end of the file, but is never moved to the `block` variable, thus it is never analyzed for matches. I corrected this in the **new version** by adding code on [lines 90 through 97](https://github.com/kyanny/rails-log-block-grep/blob/32ea89689807c11f7de8d602ff32852e57cd865d/rails-log-block-grep.rb#L90-L97) that transfers the contents of `buffer` to to `block` when the end of the file is encountered. If you try this new version, you can see that it outputs the 'Paragraf5' block as well.
You might also want to have a look at [request-log-analyzer](https://github.com/wvanbergen/request-log-analyzer). That library can compile statistics from Rails log files. At one point it was able to load the request data into a database for later analysis, but I'm not sure if that ever made it to completion.
Thanks! Hide Delegate is what I was looking for! I really should just re-read Fowler's books. It's been a half decade since I last read them; and I'm sure I've forgotten useful stuff that didn't make sense to me at the time.
Unfortunately that is not the convention my team follows
I think you've got it. It also took me a minute to understand. The "bad\_sample" graphs are before applying Rubocop's recomendations and "good\_sample" are the after.
It took me a minute to understand. The "bad\_sample" graphs represent the iterations per second before applying Rubocop's recommendations and the "good\_sample" graphs are iterations per second after.
I don't use RSpec...but this still works the same right?
Most application work is I/O bounded anyways
unless you're running as root, don't run sudo &amp;#x200B; What ruby are you using, you may wish to use rvm or rbenv to isolate your ruby versions and gems instead of relying on system packages.
Listen-3.1.5 is not a gem. Listen is the gem, 3.1.5 is the version. gem 'listen', '~&gt; 3.1.5' This is saying get get listen version 3.1.5 and keep it at that(don't upgrade or downgrade depending on dependencies).
Yeah ... the point is just to use a double / mock to demonstrate the communication as a testable step on the unit component's method.
Is the error output from Netlify or your local machine? You're not supposed to build jekyll on the production at all. You run `jekyll build` locally, and just upload the generated static HTML from `_site` to the host. I'm using this gem - https://github.com/vwochnik/jekyll-deploy - it's old as fuck, but so is rsync over ssh, so whatever. :)
This is error output from netlify. I have built it on local machine and just pushed to remote repo, connected to netlify.
Well it seems like its trying to build it again from the gemfile, which is definitely wrong. Jekyll really is too simple for the modern CI/CD infrastructure - it's not Rails, it doesn't need to be built and tested again on the remote machine before deployment. Don't push the whole repo, just the `_site` directory, that's all you need for the site to run - maybe make it as a git submodule and set up Netlify to use that instead of the main repo.
Netlify tutorial: [https://www.netlify.com/blog/2015/10/28/a-step-by-step-guide-jekyll-3.0-on-netlify/](https://www.netlify.com/blog/2015/10/28/a-step-by-step-guide-jekyll-3.0-on-netlify/) says: &amp;#x200B; &gt;$ bundle install &gt; &gt;This will install the jekyll gem and create a file called Gemfile.lock. This file will ensure that Netlify always uses the same version of Jekyll that you used to build your site, thus avoiding any nasty surprises. &gt; &gt;Finally, open .gitignore in your favorite text editor, and make sure that it includes \_site on one of the lines. With that done, you are ready to push to GitHub. &amp;#x200B; Not sure if I understand that correctly, do I have to ignore \_site or include and push to remote repo?
 On your local machine you have bundler 2.0.2, but Netlify is using bundler 2.0.1. Downgrade your local bundler version to 2.0.1: `gem install bundler -v 2.0.1`. Make sure you are using the correct bundler version: `bundler --version`. Delete your Gemfile.lock and re-run `bundle install` to generate a new Gemfile.lock with bundler version 2.0.1. Commit, push and try again.
Well this sounds like a really roundabout way to accomplish what should be really trivial, because it should involve just copying a bunch of already generated static htmls, styles and so on. There's really no good reason for making anyone do it like this. But fine. They want to have the whole repository and they will generate the _site for you once again, so yeah, it's completely fine to ignore it locally. If you pushed it they will run the build command again on their CD and it will most likely just get rewritten anyway. `9:52:06 PM: Could not find 'bundler' (2.0.2) required by your /opt/build/repo/Gemfile.lock.` This is your problem and this seems to be the solution: https://github.com/netlify/build-image/issues/250#issuecomment-502902255 (or apparently netlify-cli does help, as should upping the Ruby version, but I don't know anything about these really). Sorry for the confusion, I really didn't expect them to try and use jekyll that way, because it really is overcomplicating it greatly, while jekyll, while really cool, is really as simple as a 2x4 with a nail in it.
I did it simple way - manually changed bundler version in lock file, pushed and now it works fine :) At least for now. Thank you for your advice!
IDK, I have no idea about ruby, just looking for simple and cheap solution for blogs. I always thought about wordpress as overcomplicated and overblown solution for probably 99% of blogs, that contain text, one image and few lines of code per post. Making blog post with just markdown seems like ultimate solution for me, also in terms of backup - I keep everything locally and just push to remote after creating new post. Never mind, Netlify is sill more elegant solution IMO for deploying, than gitlab (I wanted to keep repo private, and github requires premium for private repos that are going to be deployed with github pages). I tried to deploy it simply with gitlab pages, but they require some ridicules scripts to do that and I just gave up after few attempts.
The first step seems not quite right based on the test case: Step 1 - Take the corresponding public key generated with it (33 bytes, 1 byte 0x02 (y-coord is even), and 32 bytes corresponding to X coordinate) 0250863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b2352 Step 2 - Perform SHA-256 hashing on the public key 0b7c28c9b7290c98d7438e70b3d3f7c848fbd7d1dc194ff83f4f7cc9b1378e98 . But when I run the hash method online or in ruby I'm getting: require 'digest' Digest::SHA256.hexdigest('0250863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b2352') =&gt; "a9ce83de3a0ff3516b7c50cdd787e9f69f152f227d93c9512774231e7132e925" Am I doing something wrong?
When you run `bundle install` it will overwrite Gemfile.lock. keep that in mind :)
Thx. I will probably don't have need to run this command again.
The person you responded to doesn’t know what netlify is so you can ignore them. Netlify is an automated build and hosting platform which is precisely suitable for your use case.
This is r/ruby not r/rugby :D
Good luck
 luck
Now
Wanted to point out that sequences can be anything that responds to `#next`, so one doesn't always need to use a block and/or convert to a `String`: FactoryGirl.define { sequence(:foo, "0") } 2.times { FactoryGirl.generate :foo } # "0", "1" FactoryGirl.define { sequence(:baz, 0) } 2.times { FactoryGirl.generate :baz } # 0, 1 FactoryGirl.define { sequence(:bar, :a) } 2.times { FactoryGirl.generate :bar } # :a, :b In your case you could even do: FactoryGirl.define { sequence(:uuid, "ENT-000.000.000") } 999.times { FactoryGirl.generate :uuid } FactoryGirl.generate :uuid # "ENT-000.000.999" FactoryGirl.generate :uuid # "ENT-000.001.000" Not sure if this addresses your &gt; 999 parallel problem but folks should know.
Thank you, I will add it to the post.
Yes, you're doing it wrong. Sorry. You have to convert hex string to a binary string first. For a spoiler see https://learnmeabitcoin.com/glossary/public-key-hash160#code
I find this pretty confusing. You're testing a 'UUID' that matches `/^ENT-\d\d\d\.\d\d\d\.\d\d\d$/` and generating them in sequence. Generating them wholly sequence means these are not UUIDs by definition. Perhaps the production code generates them differently but I'm not terribly optimistic of that given the above regex, the generator for something that matches that regex but is somehow still a UUID with a reasonable collision rate seems unrealistic. So you're either testing something that doesn't happen in production (wholly sequential UUIDs) or calling these UUIDs in the code is incorrect and they are just sequential ids with some string format applied. I'm also unclear on how your changes fixed the actual problem. The 'updated code' still doesn't match that regex nor does it contain anything that would prevent collisions during parallel execution (which I take to mean separate processes).
Uuid is not generated in my system, it is a country-wide company id from government. It was called uuid in my system before me, so I called it one in the article, but it may not be actually uuid, I agree on that. I presented a way to test factory bot sequences in my article, not a proper version of code to generate this sequential id in my code(that would be obsolete and not really related to the problem I solved in the article).
My problem with it is that the example is something I would never let pass code review. There is no need to test `sequence(:company_id) { |n| "CMP-#{n}" }`, you're basically testing FactoryBot at that point or at best just copy-pasting a formatting lamda, as can be seen in the example at the end. You're testing the code by literally copy/pasting it into a test. Now _if_ the sequence generation was actually complex enough to warrant testing, then sure, pull it out to a helper method in your support files and test it, but all the Proc wrapping stuff is unnecessary complexity in this case.
Well I don't see you trying to help him at all, so why don't you get off your high horse and bugger off. &gt; Netlify is an automated build and hosting platform which is precisely suitable for your use case. The use case being "I want to host a website generated by jekyll". It's just a bunch of static files. Why would you need a CD/CI for static files?
Then you should tell your team this approach to testing is not productive and if you are uncomfortable doing that, just ask them what would be an acceptable approach. Since you're not actually contributing the quality of the codebase at this point the only good answer is whatever your reviewers will accept. Also - start accepting interview offers from other companies.
"Guys, I have a problem......", response "Kubernetes!"....
I don’t know. Ask GitHub, Gitlab, and Netlify, who all offer such a service successfully and profitably. It’s apparent from the market that this is a service that is in high demand. You use a CI/CD for consistency and automated builds, that’s pretty convenient. And a whole angular project also just compiles to static files so that argument is pretty rubbish.
So, you clearly have no idea how Jekyll works or what it actually is, can't answer a simple question and all you can do is just attack me for no good reason. **Plonk**
[removed]
Share the code and challenge?
op do this
Not 100% sure what you're asking but printing an a value does not equal that value, ie if a function prints an answer it will return nil or NaN depending on the language, not the value it's printing. Again not clear on the question but
1/3rd of hackerrank puzzles are hard because the description is misleading
He is trying to use their garbage interface
This feels like a trap. Loll :P
Yes. Pretty much. Basically I got a coding challenge. I understand the problem. Wrote in my own IDE. Tested. But once I plugged into hackerrank and ran it, the output was nothing.
I'm still salty towards Hackerrank because their garbage interface had overwrite enabled during an interview, which made it impossible.
I've experienced this recently. You push things out in STDOUT, but hackerrank doesn't recognise it properly. In the end, I gave up and just wanted a smoother, consistent experience. I mainly play with code on my machine, which suits me better.
This looks awesome. I use TTY Prompt a lot for building command line tools. Thanks for all your hard work!
Here's an alternate solution, using [a gem](https://github.com/tom-lord/regexp-examples): FactoryBot.define do # ... uuid { /^ENT-\d\d\d\.\d\d\d\.\d\d\d$/.random_example } # ... end
Although as you already know, this isn't actually a UUID... The probability of two randomly generated IDs like above is 1 in `10^9`; whereas if you used an actual UUID it would be about 1 in `10^37`. That's ten million million million million million million times less likely. It might be worth updating the system to use an actual UUID, at some point...
Yeah I am giving up too. It’s unfortunate. I am copying my code over. The company where I applied to work gave me 3 days. It ends tonight. I’ll make comments in hackerranks editor and see if that at least gives me a chance to explain my self. * sigh *
The second way works great. Hashes have constant lookup time, so they are fast to access. And if you just need the array of people, you can call #values on it. For bonus points, you can make a brand new class called PeopleCollection (or Crowd, or Cohort... something descriptive) and encapsulate the hash access, creating methods like #create and #find. Then you can swap out the underlying hash implementation with another data structure if needed.
Nice work! I think this is the sort of solution I didn't know I needed for my CI/CD pipeline at work. This should hopefully save me some time building complex jenkinsfiles+makefiles+dockerfiles
Glad to share!
Thank you guys once again for the feedback here is the new [post](https://www.reddit.com/r/ruby/comments/cg8d92/update_ruby_sinatra_starter_app/).
Given your example, I would do the latter, but like this: my_hash = my_array.map{|name| [name, Person.new(name)]}.to_h
I've experienced this recently. You push things out in STDOUT, but hackerrank doesn't recognise it properly. In the end, I gave up and just wanted a smoother, consistent experience. I mainly play with code on my machine, which suits me better.
Seconded. Although I would personally turn the keys into symbols. my_hash = my_array.map{|name| [name.to_sym, Person.new(name)]}.to_h
It's really not.
Thanks! I will update the post with other question so if you could take a look I would appreciate that.
Thank you!
Also thanks to you :)
Darn, that sucks that they used it to interview.
&gt; It is also used for Form input validation This is done by ActiveModel, not ActiveRecord, and can be easily extracted to a FormObject (or other similar PORO-esque class that validates input data) if you want, just create one and stop using validations in your model.
Why create a Person object if you're going to turn it back into a hash?
Person isn't turned into a hash. The hash contains the instance. `my_hash[:steve]` would return the Person object.
aah I see, sorry about that. FWIW, you've re-implemented #group\_by: &amp;#x200B; class Person def initialize(name) @name = name end def name @name end end [Person.new('jojo'), Person.new('bobo'), Person.new('jojo')].group_by(&amp;:name) aka [Person.new('jojo'), Person.new('bobo'), Person.new('jojo')].group_by{|person| person.name}
To be fair, I just iterated on /u/zieski's example. Your implementation is a bit redundant with [`Person.new`](https://Person.new). This would be a little more DRY. list_of_people = %w[Josh Kate Steve].map { |name| Person.new(name) }.group_by(&amp;:name)
haha yea. Fair enough. I was just writing off the top of my head, not shooting for super-dry.
&gt;class Person def initialize(name) @name = name end def name @name end end \[Person.new('jojo'), Person.new('bobo'), Person.new('jojo')\].group\_by(&amp;:name) If i do it this way then how to I put a class instance as an argument for a method ?
Having read your updated question. What is the actual thing you are trying to accomplish? Because there are many (valid) ways of approaching this. But it depends on your use-case.
With all the understanding of how daring could be the thought of teaching others, I'd really suggest you to take a break and focus on gathering more practical experience and deeper understanding. In their current state, your articles could be harmful for tge reader, sharing very shallow, and at times completely wrong, understanding of the things described.
I think you're missing a foundational piece. Every variable in Ruby is an instance of a class. So when I say something like: [`Person.new`](https://Person.new)`('jojo')` that's sorta like saying `Person.new(`[`String.new`](https://String.new)`('jojo'))` . Instances of classes are just objects like (almost) everything else in Ruby.
Only place I can imagine using this would be if you had to provide grouped hash for another method. But that's edge case for sure.
I mean how do i target an object that is an instance of class Person not an instance variable @name
If you are going to be doing complex queries on your collection of people, then you can keep everyone in a flat array and then use Ruby's Enumerable methods to slice-and-dice the array to find any person or group of people based on their attributes. For example, let's say you have a Person class that accepts the name and age. class Person attr_reader :name, :age def initialize(name, age) @name = name @age = age end end people = [] people &lt;&lt; Person.new('Alice', 69) people &lt;&lt; Person.new('Bob', 420) people &lt;&lt; Person.new('Charlie', 101) alice = people.find { |person| person.name == 'Alice' } # =&gt; returns Alice nobody = people.find { |person| person.name == 'Steve' } # =&gt; returns nil old_people = people.select { |person| person.age &gt; 100 } # =&gt; returns an array of Bob and Charlie toddlers = people.select { |person| person.age &lt; 4 } # =&gt; returns [] Definitely check out [all that Enumerable has to offer](https://ruby-doc.org/core-2.6.3/Enumerable.html).
I need to create mass instances of a class (Person is just an example) and be able to address the instance of that class. So abc = [Person.new](https://Person.new)("something") lets me do some\_method(abc) &amp;#x200B; my\_array = \["abc", ....\] But when I do mass creating using a loop my\_array.each do |x| x = [Person.new](https://Person.new)("whatever") end &amp;#x200B; I can't address it the same way as this x = [Person.new](https://Person.new) returned just the object instance and whatever was an X is not something I can refer to that class instance it created in a loop. It would say that x (in this case abc) was not defined.
I was thinking about doing it this way but i thought that there must be an easier method to get an instance than by searching for it by attribute (other than keep somhwere all the XYZs from xyz = [Person.new](https://Person.new)). But based on the whole of this thread I think that might be a way to go. Thank you.
He did take a break for 2 or so months....
Thank you for your concern !
Well yeah I see where you going wrong here. Let me start with with the loop. Any time you do `array.each do |x|` that `x` is only available **within** that loop. That's because you created x in the **scope** of the loop. When the loop ends, x is gone. **Note:** the following code can be written even shorter and more efficient. But I feel like this presentation will help convey the logic behind it better. Given you class, something like this. class Person def initialize(name) @name = name end def name @name end end We can create a Person instance using #new `joe = Person.new('Joe')` We can see that joe is an object by printing it. `puts joe #&gt; #&lt;Person:0x00007f90da8b5110&gt;` We can also see joe is an object containing the property name `puts joe.inspect #&gt; #&lt;Person:0x00007fd3e30a5050 @name="Joe"&gt;` And we can print joe's name like this `puts joe.name #&gt; Joe` Say you have the following list of people. `trio = ["Bruce Wayne", "Diana Prince", "Clark Kent"]` Now for each of these names we want to create a Person out of it. trio.each do |hero| # If we output the response of Person.new we can see what it does puts Person.new(hero).inspect #&gt; #&lt;Person:0x00007ff4740d8818 @name="Bruce Wayne"&gt; #&gt; #&lt;Person:0x00007ff4740d8750 @name="Diana Prince"&gt; #&gt; #&lt;Person:0x00007ff4740d8688 @name="Clark Kent"&gt; end We can't do anything with this though. `Each` will do something on each of the elements of your array. But it will not change the array. There's two ways to change an array in Ruby. We can put the output into an array on each iteration. new_array = [] old_array.each do |item| new_array &lt;&lt; item end or we can directly modify the array itself using map. new_array = old_array.map do |item| item = "something new" end **Now!** If we apply this to your use-case. trio = ["Bruce Wayne", "Diana Prince", "Clark Kent"] trio = trio.map do |hero| Person.new(hero) end The trio array now contains instances of each of the persons created. If want to do something for each of these people we would do something like the following. trio.each do |hero| puts hero.name end
Awesome. I'll test my thing with that and I let myself come back if somehow I fail to make it work.
I think I'm not able to traverse the level of abstraction you've proposed. You know you can assign variables, right? &amp;#x200B; `my_special_person =` [`Person.new`](https://Person.new)`('wubby')` &amp;#x200B; So far the code you've posted revolves around collections (like Array or Hash) which will inherently have instances of objects as their elements (assuming they're not empty.) If you have Arrays, there are various ways to find objects within them. If you're not dealing with Arrays, you can do assignment as above. &amp;#x200B; \&gt; Lets say I need to target particular class instance of person in a method that changes some attributes for that class instance. &amp;#x200B; I think here's where you're getting confused. Rather than having some external force that changes an instance of Person, you should tell Person to change itself (or better yet, not mutate at all.) So if you have `jojo =` [`Person.new`](https://Person.new)`(args)` rather than passing `jojo` into some other method or object, you should just call `jojo.do_some_stuff` This is kinda the entire point of using OOP. Build small, smart things and send them messages.
group_by gives you a name =&gt; array of Person objects instead of name =&gt; Person object hash
Assuming you don't use the group_by, but instead the other way of building the hash you would do this: my_array = %w[Josh Kate Steve JoJo] person_hash = my_array.map{|name| [name, Person.new(name)]}.to_h person_hash["JoJo"].method_you_want_to_call person_hash["Kate"].some_other_method # and if you want to call method_x on all Person objects you would do: person_hash.values.each(&amp;:method_x)
The variables part... I think my first example does exactly that so I'm not sure what you mean by that. The other thing. the method is just an example of something that shows what kind of way I need to be able to access the object. In your second example jojo.do_some_stuff - I need to know jojo the same way as in my example with the use of method. So my question resolved about creating multiple instances with still knowing that the instance is named jojo and to do that in most optimal way. I'm not sure if your response covers that.
True and that's better, right? Name collisions are pretty common.
The whole scenario is odd and hopefully contrived but if the goal is to call methods on an object by it's name attribute. I would think that no, you would prefer 1 object per name
Ok, I'll try one last time :) If you have an array of Things and Things have a #name method and you want to find one for some reason, you can use Array#find. &amp;#x200B; `iwant="jojo"` `i_found_jojo_or_a_reasonable_fascimile = my_array_of_things.find{|thing|` [`thing.name`](https://thing.name) `== iwant} ||` [`NullThing.new`](https://NullThing.new) &amp;#x200B; This is called the Null Object Pattern. If you're not able to find the particular thing you're looking for, you swap in something with the same API as the thing you were looking for. For real, though: this how thing is way too abstract. I'm happy to keep helping if we can nail down some actual work that needs to be done. The current thought experiment has run its course, I think.
ActiveRecord IS ActiveModel. That's the same as saying that ActiveRecord isn't Rails. Clearly you never tried to use one without the other enough.
ActiveModel is only one part of ActiveRecord, one definitely isn't the other. I don't think it's possible to use ActiveRecord without ActiveModel (`activemodel` is a dependency of `activerecord`), but you can certainly use ActiveModel without ActiveRecord. ActiveRecord **is** Rails, but Rails definitely **isn't** ActiveRecord. I have used `ActiveModel::Model` previously many times, to make use of its `ActiveModel::AttributeAssignment` and `ActiveModel::Validations` modules. If you read [the code for `ActiveModel::Model`](https://github.com/rails/rails/tree/master/activerecord/lib), you'll see that it does define the `persisted?` method, which is used by ActiveRecord, but with a default implementation that always returns `false`, because it's ActiveRecord's job to implement the datastore layer, not ActiveModel's.
I think I missed it - what are you on about?
This is true with almost all of Ruby. The first Rubocops I always set are the parentheses ones because they make it so unambiguous. Also Seattlerb style is trash
Okay.
I like you
excellent, feed me code.
So do I! Isn't it wonderful that we have such a fun tool to work with?
I really, really, really like this programming language.
Yes! This worked perfect. Thanks a lot for updating and your thorough answer! :)
I hold Ruby in the highest regard.
...and I can not lie
&gt;I think I missed it - what are you on about? He just gives his opinion and I just don't mind.. hehe
Allright. However I didn't want to return the [object.name](https://object.name) but the class instance object itself. Finding object by it's attribute wasn't what i searched for however I'm not familiar with this so maybe I should stop searching for other things and just go with what has been already said. Thank you for contribution.
You're beautiful.
Ruby likes me. We're a happy fam-i-ly… 🎶
Posts like these make think Ruby is really a thing of the past.
I recently started learning Ruby as my first language 🔥
You're a thing of the past
I don't like it. I love it.
Top quality post
I tried the code and unfortunately it doesn't change anything because the method I want to use is outside of the loop. So I think it doesn't address what I'm looking for however still a great add If I will need to run a method inside of the loop.
You should be able to target objects outside of your loop (methods and variables). Just not the other way around. Are you able to share the full code?
I just checked your example. I didn't applied it to my code yet. I know that i can target the objects outside of the loop but the question was how. I run the loop the way you wrote it and now i have a method outside of the Person class that just need to do anything with the created class instance so lets say &amp;#x200B; class Person def initialize(name) @name = name end def name @name end end trio = \["Bruce Wayne", "Diana Prince", "Clark Kent"\] trio = trio.map do |hero| Person.new(hero) end def some\_method(hero) do whatever end &amp;#x200B; \#and now i want to run the method some\_method(What exactly I put here to get Clark Kent?)
No you
 class Person def initialize(name) @name = name end def name @name end end trio = ["Bruce Wayne", "Diana Prince", "Clark Kent"] trio = trio.map do |hero| Person.new(hero) end def some_method(person) puts person.name end This should be it. Your method needs to take an argument, in this case I named it person because you will be passing a person instance to it. Now, how you want to address is up to you. You can loop over each person in the array and do the method. trio.each do |hero| some_method(hero) end Alternatively you can address a specific `hero` in the list. some_method(trio[0]) # Using the array index of the person you want to get
The last part - yes that what I wanted to address specific person. Accessing them by array[x] does the job but is it any better than the initial example with hash ?
Just don't let any bad boys inject their python into your ruby
It's slightly faster because you don't have to create a hash first. And it's not something you would really use in a dynamic system. The select offers way more flexibility. The hash approach works, but if you have 2 "johns" in your list the first one will be overwritten in the loop. So it's not an efficient approach I'd use. Given that you have have multiple "Clark Kents" you would be able to select the right one using more than one variable on Person to verify you get the right one. clark = trio.select { |hero| hero.name == "Clark Kent" &amp;&amp; hero.origin == "Krypton" }.first some_method(clark)
Great. Do keeping them in an array is also faster than finding them somehow from ObjectSpace.each_object(class) ?
I like ruby And ruby likes me Like the lemon to the lime Like the bumble to the bee
My Array#find example returns the object, not the name. I'll read your edits when I get a chance.
Why do you like it?
You might want to read the [Ruby API](https://ruby-doc.org/core-2.6.1/ObjectSpace.html) a bit more. &gt;The ObjectSpace module contains a number of routines that interact with the **garbage collection facility** and allow you to traverse **all living objects** with an iterator. It's used for GC operations. Which you are not doing. As well as provide **all** living objects. But Ruby's whole thing is that **everything** is an object. So this isn't something you want to touch unless you're actually doing something GC related. object1 = "string" object2 = Person.new("John") object3 = Person.new("James") All these three would be available in ObjectSpace. So as you would scale up your program, looping over ObjectSpace would become slower. Whilst the array of Persons will only be as big as the amount you manually put into that. Long story short, just store them in an array.
Thanks for explanation.
You are correct - it returns an object not the name variable. I don't know what I was thinking.
Sometimes `@permissions` is `nil`.
Typo in lines 71 &amp; 72. ~~`@permissons`~~ `@permissions`
lol, of course, it had to be something dumb :eye-roll:. Thank you!!
Am I the only one that thinks of Ruby x Python relationship as Gryffindor vs Slytherin houses from Harry Potter? The good "red" vs the evil "snake". Hahaha!
No you :p
Oh I love it when developers talk dirty!
what is your age? why have you decided to do so? I am around 9 years in ruby, but unfortunately less and less people choose it as 1st language
I am 18 and I would like to be a software engineer
I'ts the first language brought up in the course I'm taking called launch school