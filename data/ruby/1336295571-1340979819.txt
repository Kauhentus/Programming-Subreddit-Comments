+1 to Sarcasm :) * Complain about the poor performance of Rails, while still running MRI 1.8.7 and MySQL.
Aka arrays inside hashes. I hope everyone knows you can store any value in a hash.
Link to awesome jQuery plugin - https://github.com/kossnocorp/role
Thanks for the link. It looks very interesting. Can't find any mentor in my area though.
I would say you're certainly hireable as a junior rails dev. You might want to look for a 3 month internship to get your foot in the door, then after that the sky is the limit. Rails devs are in high demand so it's a great skill to pick up. Just always remain dedicated to improving your skill set and responsibilities. I would recommend getting a good grasp of JavaScript/coffeescript to implement ajax functionality, and keep up with the latest rails trends. If you were in Denver I would interview you tomorrow for a paid internship we we have. Good luck and keep it up.
Do you have a github? Do you have pages you've designed available for potential employers to look at? Do you have open-source tools/projects you've worked on? We get the occasional application where I work, invariably what we look for is 1) Contribution to open source (in the form of patches accepted or projects created) 2) Quality contribution to open source (ie, the relative quality of the above) 3) Quantity of contribution (How many projects did you create/contribute to) The Ruby/Rails community puts a great deal of emphasis on Open Source work, and more general on personal achievement in terms of projects and contribution. If you have open source work (be it website design, back-end tools, or even non-work-focused stuff like games or similar) -- and more over they don't necessarily have to be in ruby -- you stand a much better chance of being hired. For reference, I was hired with only a bit more experience than you, but because I had worked on a couple cool projects (A syntax/semantics aware search engine for large bodies (bigger than the linux kernel) of C source code, as well as a Markov-chain based Music Composition Tool) as well as numerous other projects. That, paired with a good interview which demonstrates your interest and passion, and you'll do fine.
Maybe we've got different ideas of "intermediate" or "advanced", but with how I consider 'advanced' Rails user, there's no way to get there without engaging with the source code. Doesn't mean you have to understand _all_ the source code and how it fits together (I sure don't; it's possible there's no one person who does, or only one or two people who do). But pick a slice, and drill all the way up and down and figure out how it works. This will be boring or directionless if you just do it randomly; pick a particular problem or thing you want to do (even if it's completely ridiculous and never something you'd do 'for real'), and dive into the source to figure out how to do it. For that matter, even if you're still at the 'intermediate' point where you aren't ready for the the source, pick something crazy to do and try to make Rails do it. If you can make Rails do it without looking at the source, you'll still have learned something. An example, although one that someone else already solved, and perhaps too confusing for your first attempt, would be figuring out how to make a working rails app start up from a single file. Just to give an idea of one category of 'odd thing' you could try to do. 
Haha, that's really great work. I was on the team that did KittenMash. Unfortunately, it was the first time for any of us doing node.js, so we didn't get it as fleshed out as we'd hoped. Are you accepting pull requests? Support for user-submitted cat facts would be excellent.
Only 9 cat facts? I'm not sure if that's better or worse...
I wish I could upvote you more than once for the Sarcastic stuff!
Thank you for this post! I've also been at it for about 6 months now and by the looks of it we have a similar level of understanding and learning abilities. I also had a lack of confidence in applying for jobs and felt I didn't know enough. But now I'm actually feeling a lot more confident about it. Thanks! :] 
Yes, if it was only for a blog, but I think there is need for a mountable Rails engine. This could be mounted in an already existing Rails app at, say, "/blog" or whatever mount point you want it.
1. Don't patch core classes such as String, Array unless you have a very good reason for it. In your code you're effectively creating an alias to `File.join` but on the String class. DO NOT DO THIS: file handling doesn't belong in the string class. I swear to god that if this is apparently acceptable I will get a pitchfork and torch and hunt a lot of people down until they realize this is stupid. 2. For the love of god, use some reasonable option parser instead of re-inventing the wheel of how to handle STDIN, options, environment variables and everything else related to commandline executables. There are plenty of tools available such as OptionParser (available in the stdlib), [Slop][slop], [Shebang][shebang] (shameless self advertising) and many more. 3. Namespace your code. Even for a simple application such as this you should not define everything in the global scope. Even something simple such as defining it under the module "T" (or something else that resembles your application name) is a much nicer solution. 4. Distribute it as a Gem and use the common Rubygems file structure (bin/, lib/, etc). 5. Document your code 6. Keep your coding "standards" consistent. Right now I'm seeing single line methods as well as multi line methods. There's inconsistent use of whitespace, variables (the `=` signs to be exact) aren't aligned, etc. 7. Don't assume shit about the filesystem. Your code explicitly requires `~/Dropbox` to exist, a directory that only exists on Mac OS X or on systems that use Dropbox (I think?). Files like these should go in a dotfile such as `~/.timer` or w/e. 8. From what I can tell you're using `.csv` as the file extension but you're not actually writing CSV data. What the fuck? 9. Errors such as "No task to resume" should go in STDERR, not STDOUT. Use `abort` to make this easier (e.g. `abort "Ruby, how does it work?!?"`). 10. Don't assume everybody is used to the same date/time formats as you are. You should allow people to customize these. [slop]: https://github.com/injekt/slop [shebang]: https://github.com/YorickPeterse/shebang
True. My mistake...sorry!
Check out this article http://www.naildrivin5.com/blog/2012/04/01/the-nine-facets-of-an-awesome-command-line-app.html and get Dave's book http://pragprog.com/book/dccar/build-awesome-command-line-applications-in-ruby
Looks like our work is done here
Much thanks for the feedback! 1. I suppose I agree with you, and I certainly see the advantages of not unnecessarily monkey patching, though I'm really not a fan of the eventual: `File.open(File.join(...` It feels very un-ruby to me. Ahh well. 2. Excellent tip; I adapted it from an older script and kept the bad habits. I love Shebang's syntax - I'll work on switching to this. 3. Duly noted. Module TimeTracker on its way. 4. Need to learn how to do this... 5. I was afraid you'd say that. 6. I use single line methods if the method is a single statement, else multiline (read in a style guide I can't seem to find). Indentation should be a constant 2 spaces. I've never been a fan of aligning = signs - is this standard? I don't see it in https://github.com/styleguide/ruby and haven't seen it as much in Ruby as in C, C++, Java, etc. 7. I was hoping someone wouldn't call me out on that. Changed to ~/. 8. See description of .csv files in "To View" on https://github.com/christiangenco/t-time-tracker - it's .csv formatted. 9. Where does the line get drawn between STDERR and STDOUT? I think I could justify all of my output except the "list" function going to STDERR. 10. Done (see "Customization" in readme"). Is there a better way to do this?
Impressiveness is relative. If you've designed sites, then you are capable of something I am not, and greatly envy. My front-end chops are minimal (fortunately I have pretty good backend chops). It's all about emphasizing your strengths. It sounds like you have some good front-end experience, and some experience with building applications involving payment services (which is, by no means, trivial experience). The best advice I can give is cribbed from wikipedia -- Be Bold! Damn the torpedos, full speed ahead. Worst case is your patch is rejected, but you've still tried. The only thing that keeps your average person from being truly great is self-inhibition due to fear. So -- to borrow from Wards Wiki, we need to [MakeFearFuel](http://c2.com/cgi/wiki?MakeFearFuel), and just _go_ for it. If you want a guarentee'd non-asshole-run project to contribute too, I'm always looking for ~~lackeys~~ contributors to [my stuff](http://github.com/jfredett). :D
Careful if you gem this, twitter is already using 't' as a binary, so you might have to change the binary name.
hmmm, I may change the binary name to "ttimetracker' and strongly encourage a shorter alias.
Whoa, awesome! Looks like I'll be making my first gem :D
Thanks. I did study Eloquent Ruby. It's really helpful.
Thanks. 
Pretty clever and unobtrusive. Giving it a test drive today.
Well I'm of the opinion that both my front end and back end skills need work. Thank you. Great advice. That's normally how I am, but I'm a bit more timid in the presence of other programmers with cs degrees and whatnot. Ya for sure! What is a good one to get started on?
Thanks. I feel like that is some great advice. I'll start looking for some opportunities and crack open those books/links. 
That's the second thing, yes. And the more interesting thing (IMO). The first thing which acts like a "multiple variable hash" is just a hash with arrays as values.
1. Actually you can using Pathname (though it's a more verbose): require 'pathname' base_path = Pathname.new('~/') user_path = Pathname.new('example') File.open(base_path.join(user_path).expand_path.to_s) do |handle| handle.write('Hello, world') end 2. \- 3. \- 4. I personally use [YARD][yard] but RDoc is also commonly used. 5. Time to find a different editor ;) [yard]: http://yardoc.org
100% no doubt you should do that. twitter should too for that matter
Sublime Text 2 has an [alignment](http://wbond.net/sublime_packages/alignment) plugin. You'll need the [sublime package manager](http://wbond.net/sublime_packages/package_control) first 
Calendar could use some love, it's a gem I rescued while working on a client project which makes heavy use of multi-calendar dates. Graphable could use some tests, I've no idea how to set up a testing framework for it. The idea of graphable is to extract from a database modeled with an active-modelly framework (eg, one that supports #attributes and a few other things) a semantic graph, and store it in Neo4j. It uses Neography (it's extracted from the same project as Calendar). Then theres Sakura, which I never started on beyond some hacky starts, it's supposed to be a re-write of my original search-engine-for-large-bodies-of-C. The original was, frankly, terrible, and suffered limitations due to the fact that it used SQLite and crappy regexen to "parse" the C. I'd really like to get a proper parser (perhaps not full C, but a forgiving parser (in the sense that it will accept even the occasional syntax error, since I really just want to know where functions/variables/etc live) and Redis always seemed like a good way to go w/ it. Botfort is less of a game at this point and more of a series of experiments. Recently found I accidentally implemented something not dissimilar from Method bind/unbind with "Actions" -- the theory is that it's a game along the lines of 0x10c meets dwarf fortress but with a high level language. The pie-in-the-sky vision is that it's a game designed to run in the cloud. recurs.es is a Neo4j based blogging/website app framework thing. It's another one of those, "Largely something for me to hack on when I'm bored". My current baby is Grafton, which is about a million commits out of date on github (I haven't pushed in a while). Aim is to be a lightweight, pure-C graph database. I recently ran into a wall while learning as much as I could about Automake, then another when I found that Thrift -- the RPC tool I was intending to use -- doesn't seem to like to generate pure C servers, just clients, and also depends on glib for it's pure C implementation (which is a bit unfortunate). At the moment I'm debating whether to just roll my own RPC, use Protocol buffers to ease some of the pain, or see if I can get Thrift to play nice. The nice thing about thrift is that it generates serializers and readers, and the client and server code, and it can do it in a dozen languages. Which makes creating client libraries absurdly simple. But it may not be meant to be. If anything, I'd recommend diving into Graphable or Sakura. Both are interesting (the former gets to play with Activemodel mocking, which sounds like fun to me; the latter could be done w/ Parslet or Whittle (though I think Whittle is lacking active development) and Redis (or even ElasticSearch, though you'd have to really hack up a good analyzer)), which means you could play with combinator-parsers. For Graphable, at least, a very important thing is to identify and minimize the required API, so that it transparently works with as many ORMs as possible out-of-the-box. Ideally Graphable is a drop-in DSL for ActiveModel-y models. In theory you could even monkey-patch in all the Graphable bits when you're going to generate the graph, so they don't have any chance of conflicting the rest of the time, but that's -- as we often say at work, "for v2". I'll happily look at and review any pulls you send my way, I like to think I'm not terrible at programming, so hopefully I'll be helpful. I'm just a mathematician though, you've been warned. :) 
Steve Losh's Todo List uses t as well, although now that I think of it, it's customizable with a bash alias. Carry on.
So you're basically just tricking heroku until giving you more web-serving dynos than you're paying for, right? Which works as long as they all stay within the max memory limit for one dyno? 
:)
:)
Whew okay. No pressure, eh? :) I'll probably dig into one of them this weekend and fork it. I took a quick look, but will be pretty busy on some stuff I'm intent on finishing this week. Thanks for everything!
In general, using a long name is ideal, because I'll write my own aliases and functions that tune my interface to it. Being a good shell citizen means having a easy-to-remember, reasonably verbose name. Leave the huffman-coding to the user!
Damn, shebang is sexy. Trollop has gone the way of the dodo for me, I think. Nice work.
Absolutely. I'm just kidding around. I started programming in Ruby because it was amazingly fun and interesting. I can barely sit through my 9-5 (actually a really good job) anymore. I just want to get home to start writing code. I guess I need to get over the nerves of having other people look at my code. I'm used to the internets. Rubyists seem to be really nice so far though and help me fix mistakes rather than mock them. :D
I think this is what you are looking for, I cannot remember how I stumbled on it last week but found it in my history http://williamedwardscoder.tumblr.com/post/21865366869/how-to-make-a-text-adventure 
pragstudio.com excellent courses online and the Pickaxe book. 
Note - This was my *first* gem ever, and I am fairly new to ruby. 
Your indentation is really really weird: https://github.com/alxjrvs/Stattr/blob/master/lib/stattr.rb#L61-73 Everything should be indented by 2 spaces, not just 'some' things ;) Also, try to avoid `@@vars` if you can, you can typically get by with just an `@var` on the class.
Use underscores to name methods and be descriptive, e.g. rollmanyd should be roll_many_dice and statroll should be stat_roll. Also, take advance of ruby blocks and syntax, e.g. instead of @str = modstat(rollmanyd(@@sides, @@dicenum)) @dex = modstat(rollmanyd(@@sides, @@dicenum)) @cha = modstat(rollmanyd(@@sides, @@dicenum)) @con = modstat(rollmanyd(@@sides, @@dicenum)) @wis = modstat(rollmanyd(@@sides, @@dicenum)) @int = modstat(rollmanyd(@@sides, @@dicenum)) try something like def make_stat modstat( rollmanyd @sides, @dicenum ) end def initialize @sides = 6 @dicenum = 3 %w[str dex cha con wis int].each { |s| instance_variable_set("@#{s}", make_stat) } end
Some of these items have already been dicussed so feel free to ignore them if you've already done something about them: 1. Keep your indentation consistent and stick to two spaces per indentation level. No excuses, no tabs. 2. Don't use class variables. Don't use class variables. Don't use class variables. Don't use class variables. You rarely need class variables. Don't use class variables. Don't use class variables. Don't use class variables. Don't use class variables. Don't use class variables. Don't use class variables. Don't use class variables. Don't use class variables. Don't use class variables. Don't use class variables. 3. Namespace your code. Wrap it in a module called `Stattr` or something similar. 4. Document your code using RDoc, YARD or Tomdoc. **Don't** re-invent the wheel of documenting it using some crazy format nobody is used to. 5. You might want to make an executable out of it opposed to requiring people to write one of their own. 6. Creative Commons doesn't make much sense in the context of code. CC licenses are generally meant to be used for written work (e.g. books), art, that sort of stuff. For code you'll want to go with licenses such as the MIT license, GPL (meh) or another similar license. 7. Changelog files, licenses, readmes and others are usually named in CAPITALS so that they stand out. You should also stick to one file extension for markdown files instead of using `mkd` and `md`. 8. Put code on a new line after 80 characters. This makes it possible for people to view your code while having multiple vertical windows open (e.g. in Vim) as well as being able to view it properly in a terminal (terminals usually cut text off after 80 characters but tend to fail a bit at it). 9. Constants (Normstats in this case) should be written in SCREAMING\_SNAKE\_CASE. 10. Write method names using snake\_case and try to use names that make some sense. `rolld` doesn't make a whole lot of sense on its own, you're better off using something like `roll_dice`. Here's an example of how your code would look like taking the above items into account (keep in mind that this is untested): &lt;https://gist.github.com/2633468&gt;
I've always found trollop to be a bit of a dirty hack.
Uhm, what? This isn't a trick to get more than what you're paying for. The restriction on number of ports you can listen on isn't there to force you to pay for more dynos. As far as I can tell, it's to allow Heroku's routing system to get requests load-balanced and routed correctly without turning it into a configuration nightmare. As I understand it, it costs Heroku the same amount to run your dyno at 100% utilization or at 20% utilization because EC2 bills by instance-hour. As the title of this post indicates, this is a performance optimization, not an underhanded trick.
As sporkmonger already said this is neither a trick nor dirty in any way. We (I am the author) just utilize the resources already given to us by Heroku much better.
First things first: Don't use Creative Commons for code. The legalese isn't written to handle it. Instead, use the MIT, GPL, LGPL, BSD, or another software-specific license.
You're welcome :)
Can't touch this.
Nice one, glad I could help!
No, definitely not. [Supposedly](http://www.quora.com/Scalability/How-does-Heroku-work) Heroku is using the "High-Memory Extra Large" EC2 instances. But a dyno backed by an EC2 instance is [isolated from other users](https://devcenter.heroku.com/articles/dyno-isolation), both for security and for resource guarantees. The resources allocated to your dyno are supposed to be guaranteed to be available to you. Heroku is multi-tenant, but it's not a shared hosting platform. Based on the estimates from that Quora answer of 60 dynos per instance, you should be guaranteed with absolute certainty to have 256MB (physical) available to you, and it would be exceedingly unusual to have less than 512MB available (which is the current soft limit per dyno). Going over 512MB will cause your dyno to hit swap, preventing it from doing any significant performance damage to neighbors. Theoretically speaking, it might be possible for a single EC2 instance to be completely overwhelmed by people running unicorn at maximum load, which might cause Heroku to migrate some dynos off the instance, and reducing that instance from its maximum of ~60 dynos, but if Heroku is doing the dyno balancing act correctly (keeping a good mix of high-load and low-load dynos on each instance), this should basically never happen. And even if it does, there's always swap. The other thing to keep in mind when you're talking about this kind of thing is that a lot of people running apps tend to be in the low-load category. 60 dynos at low-load will massively under-utilize a big EC2 instance. And a very substantial portion of the dyno manifold is made up of workers rather than app servers anyway. But most importantly, the Cedar/herokuapp.com stack was explicitly designed to allow concurrent handling of requests on a single dyno. In other words, this is something that's essentially being directly encouraged by Heroku.
Monkey patching is fine in your own code, but when you release a gem you shouldn't dictate that other people's system libraries are going to work a certain way. Make sense? I should have posted that before
Thanks. I come from the blogging world, where CC is the norm. I knew this wasn't the case here, but I was quick about it. I'll most likely go with the MIT. 
Good point, I simply couldn't be arsed to change it :)
That was a pretty good overview. Your examples of brogrammers made my night. I should say so. I started writing code on a Mac Classic II when I was 10-11 and was really into it until high school. Then it just died off for some reason and I went to uni, graduated in something I didn't enjoy nearly as much, and now am finding my love for it again. I don't know how I just "forgot" about it. Maybe it just wasn't the cool thing to do or I had other interests that overwhelmed the passion for creating something. I've always been mathematically inclined though and love creating something from scratch. Nothing is more satisfying to me than that... and solving a problem. If I could do it over again, I would, but c'est la vie. That's a great philosophy. Sometimes I get frustrated because it will take me a few tries to get something working, but it is nice to know that everyone else is the same. I think I just see and read about these rockstars all the time so it gets intimidating. No one ever talks about how it took them an entire night to figure out how whether to add an attribute to a model object or make a new model object and assign it to the first with belongs_to and what effect that would have on the rest of the appliation going forward. Everyone just seems to pump out magic hahaha. I saw IRC bot. That actually may be about my speed. I'm not familiar with Cinch, or IRC bots' purposes, but I bet I can figure it out with my trusty text book "Google." I've deployed to heroku many-a-times so that's familiar as well. You'll see a fork in the next few days for dear "percy."
hahahaha ya. I guess the hold up is partly that I'm not desparate for a gig. I have a good job right now, but it's not making me happy and I prefer to write code. So a good job, but not good for me if that makes sense. Thanks for your advice. I say just deploy them...even if it is just to show that they run eh? Heroku lets you run apps for free (although it is a limited tier service and when not in use it spins down so the first use after 15 min of downtime takes a second to load). But hey for $10 (buy a domain) and launch a simple app to show employers eh? 
What if all my code is already contained in a Class and must be called like so: ClassName.method1(params) wouldn't (using your example) Classname.bob.method1(params) Just confuse someone else since method1 always exists once per class?
I'm not an iOS developer, but if iOS 6 came out, I don't think apps that targeted iOS 5 will just stop working. My iPod Touch runs older apps that haven't been updated in ages just fine.
You can send us a pull request or open up an issue in GitHub to add quotes from there too.
It's gonna be rad. Tickets are going pretty quickly.
This is pretty cool! Upvotes for science. 
if op is poster please provide transcripts.
Upvote for the upvoter of science! =D
Example: # class Namespace would work as well module Namespace module Alice def self.random_number # ... end end module Bob def self.random_number # ... end end end Using this code you can call these methods as following: Namespace::Alice.random_number Namespace::Bob.random_number This would not work: Namespace.random_number This is because the `random_number` methods are defined in sub namespaces, thus they are only available to those specific namespaces.
So, here's some things I was thinking about doing w/ Percy. 1. Logging This is mostly done, I want to get join/part logging implemented, but it mostly works 2. Rubinius I'd _really_ like to run this on rubinius. That might require dropping the ruby-debug gem, that's fine, pry is better (only difference is that you have to use binding.pry rather than debugger). 3. Cinch Cinch kind of sucks, it's hard to test (the whole testing thing now is a big fat mock), I really think it'd be cool to re-write it as a Celluloid Actor, which would mean I could use DCell, and let anyone ask to register their plugin w/ Percy, percy would then send events to all of it's connected actors, and listen for responses. That way anyone (who is authorized) could simply host a DCell actor anywhere (ideally heroku cedar stack), ask percy to inform him of messages, and send him responses to print to they IRC channels he monitors. That would be _way_ cool, and probably the first step to skynet. ---------- Since you mention not knowing what IRC is, I'll give a quick rundown. IRC stands for "Internet Relay Chat." It's a reasonably old part of the internet where people can log in, send messages over IRC protocol to chatrooms, and basically talk to each other. Lots of ruby (and other) developers use IRC for dev support, idle banter, and the occasional drunken rant (those are especially fun in #haskell-blah, the offtopic haskell channel. Sometimes you'll get guys ranting about category theory, it's fascinating stuff, and also funny, because they are drunk). An IRC bot fills the role of a sort of butler. He answers simple messages, manages permissions, reports interesting stuff from the internet (CI reports, exceptions, etc), logging, and any other useful feature you can imagine.
Thanks! 
better use async_sinatra for this.
using Sinatra helpers to rebuild rails yourself! haha, helpers are great but once I am touching view code, it means I probably should have rails. Sinatra seems to be best for APIs for me.
Add it to the NMatrix issues tracker. http://github.com/SciRuby/nmatrix/issues
More like "Writing code to segment and partition the work so you're not handwriting dynamic markup on the presentation layer".
There is a Creative Commons for code, it's called CC0.
CC0 releases things into the public domain. It's likely _not_ what people want in most situations.
Including tons of different JS files based on the page you're on is wasteful and unnecessary. Use something like Sprockets - everything in one file, downloaded once, easy to cache, easy to expire, minified, fast download, no ugly choosing which js file to include based on page name. It is kind of hilarious that you're re-implementing javascript_include_tag :defaults from Rails. You know that you're allowed to re-use other people's work, right?
Can't wait for more. I'm really excited about Ruby 2.0. Going to compile it up to follow along with some of the experiments. Really like the idea of small hashes being stored as Arrays. Anyways, keep up the good work Pat.
Right, For instance, there is a "Clock" plugin, which manages tracking time. The "Logger" plugin logs each message it hears to a file. There might also be a "Quoteboard" plugin which responds to `!remember "string"` and !quote, the former stores a quote in a database, the latter recalls it. The really cool stuff runs a webserver which receives events via HTTP and serializes them to an IRC channel. For instance, a plugin which listens for post-commit hooks from github, or post-test-run hooks from a CI server, etc, and inform a channel of passing/failing tests, or new pull requests, etc.
Rails posts belong in /r/rails.
I am not sure but you can try the Ruby bindings for GSL: http://ruby-gsl.sourceforge.net .. Upvote to SciRuby,great to see Ruby moving out of Rails's shadow.
Always happens. You start simple then life gets in the way and you end up building rails. See padrino for example.
The wheel won't reinvent itself
Downvoted for disabling zoom on iPad.
I would test with your backing relational store first (MySQL/PostgreSQL/etc) before resorting to the additional complexity of a intermediate store (Reddis/Mongo/Cassandra/etc). We frequently hit our PG store with a few thousand inserts a second on an individual event logging table without any issues. Not having an intermediate store keeps our code base/debugging/maintenance simplified as a bonus. Our current site supports upwards of 30K users simultaneously to give you an idea of scale.
Awesome, thanks. I remember seeing "reactor" pattern mentioned before. Searching for that also yielded this paper, which I haven't read yet, but looks promising. Thanks! http://www.cse.wustl.edu/~schmidt/PDF/reactor-siemens.pdf
I'm actually leaning toward this solution right now. As Redis is in-memory, i won't have to worry about latency introduced by disk i/o and, frankly, Redis seems to be sufficiently trivial to implement and scale that it looks very attractive. thanks to you and **damnford** for the suggestion.
&gt; since heroku leans pretty heavily towards PostgreSQL that's a bit of an understatement. The only non-postgres SQL DBs available on heroku are third party plugins. So, more of a "leans entirely upon"
Resque is a very powerful tool in this domain. One of our clients at work has need of a achievement-like real-ish time system, which essentially means we need to check each user for different criteria constantly and quickly. Our approach is to use Resque to enqueue jobs to check users every time they are updated, by propagating the update event from things that connect to users back to the user, we can ensure that users are constantly checked for achievements, while not incurring any loss (since Resque uses a background worker). I would recommend that -- if you're _really_ going to be taking a beating, to try to split out the vote tracking from the main DB entirely. So that the async part (be it custom w/ RabbitMQ/0MQ/whatever or w/ Resque/DelayedJob) can write to it's own, high performance DB (like Redis, for instance), and then periodically flush that information back at a more controlled rate to the main app, or at the very least prevent the main DB store from thrashing constantly due to the background worker processing and storing upvotes.
Not from heroku proper, there's a plugin for RDS and another for MySql proper, and I think all NoSQL addons are third party as well.
So I've spent the last 2 days implementing a "facebook" style notification system for our EMR using Redis, and it's just been absolutely wonderful. It's so refreshing to work on something that normal postgres rails database CRUD
In 1.9 #require doesn't load files from the directory you are in, like 1.8. In 1.9 you can either use #require_relative or just do: require './methods.rb'
bless you... require './methods.rb' works!!! thanks.... i've spent 2 hrs last night trying to figure this out
[Redis](http://redis.io/topics/pubsub) [is](http://redis.io/topics/data-types) [more](http://redis.io/topics/data-types-intro) [than](http://redis.io/commands/blpop) [a](http://redis.io/commands/subscribe) [key](http://redis.io/commands/publish) [value](http://redis.io/commands/zrange) [store](http://redis.io/commands/sadd).
Why have I been ranking puppies as cute vs bieber for 5 minutes now? Bieber is annoying, not cute. Why on earth would you make this? :P
If something goes wrong with the application stack you are screwed though, you might lose logs. I would go with pushing data to redis (resque is awesome) and then work off those jobs with a background worker or 10 (which could even be on another machine) that puts the data into more persistant storage like *sql.
Another option is: current_path = File.expand_path("..", __FILE__) $LOAD_PATH.unshift(current_path) unless $LOAD_PATH.include?(current_path)
Considering huge throughput websites like youporn are using redis with something like 300k req/s I think you can scale it pretty nicely :P
I think, the way to go is a EventMachine (via Rainbows or Thin), but Sequel has pure support for evented adapters :( I found one here https://github.com/jzimmek/em-postgresql-sequel , but I didn't use/test it, so that I could not tell about its stability. But if you try it, then you could tell us :)
This is pretty slick in an old school deep unix geeky kinda way. If you want to learn more about processes passing sockets around, look into how Apache shares sockets between processes... or at least how it used to, I'm not sure if it still works that way. Apache went through a variety of approaches in an attempt to improve over the original "accept a socket and fork" model.
While this is somewhat related to Ruby I'm not exactly sure if this subreddit is the right place for postings that aren't directly related to code itself.
Thanks again :D I have seen the light, and it is well formatted.
other sizes here: http://po-ru.com/diary/ruby-propaganda/ 
Are you thinking about the $" variable?
Fascinating, but I was wondering of there was a hook as to when (if) a module is actually used?
This will be my first conference! Looking forward to meeting some EdgeCase people!
There's no link. 
**update:** wait, you wanna tell not if a certain thing has already been loaded, but if it's ever _used_? The answer below is not for that. I don't think there's good any way to do that. I mean, you can grep your code for references to the classes and modules loaded by the 'require'. --------- Well, when you _call_ `require`, it returns true or false depending on if was already required. But you're looking for a way other than that. I'm not sure you need to -- what action might you take, based on this information, other than, well, `require`ing if it's not already required? In which case, well, just `require`, it's built to work right in either case. You can check if a particular class or module is loaded -- which is different than a particular on-disk file, but may meet your needs. class or module references are just constants like any other constant (they just point to a Module or Class). If it's not namespaced, defined? SomeClass `defined?` is a special language construct, it won't raise if there's no `SomeClass`, it'll just return nil. Checking for namespaced things like "Foo::Bar::Baz" can be trickier, I know there's a fairly easy way to do it, but I don't recall which, I or someone else can look it up if you can't find it. 
Actually _used_, or actually loaded? There's definitely no way to tell when it's "actually used". 
What are you trying to accomplish? I think it may not work as reliably as you'd like. You -can- both undefine and redefine a ruby Class at runtime. If you don't undefine it first, you'll just be adding new behavior 'on top', if you redefine any exisiting method names, you'll replace em, but if there were method names in the 'original' that aren't in the 'new' they'll still be there. So you can unload the class first, sure. However, if any already instantiated objects that are instances of that Class exist, they'll still have the 'old' class definition, they won't get the new one. This probably isn't what you want, now you have a weird mixtures of objects existing. Additionally, the unload-and-reload operation can be hard to do in a thread-safe way. In between unloading and reloading, if a thread is running somewhere else, things can get screwy. Which could especially be a concern in jruby where threads are more likely to be going on. (Although it's also possible that the thread-safety issues are different in jruby). Without actually going into the internals of your ruby interpreter and patching it (jruby, mri, rubinius), I _think_ there's no way to do what you want to do in a general purpose reliable way. There are ways to do it in certain cases. For instance, Rails' development code class reloading _does_ do this. But it relies on single-threaded request processing (you generally have to turn it off if you're doing multi-threaded request processing), and it tries to only reload classes that _won't_ have any outstanding instances 'between requests' -- if, contrary to it's assumptions, you kept an outstanding instance of a reloaded class in a global/class var or something, things are going to get screwy. 
What about autoload? http://www.rubyinside.com/ruby-techniques-revealed-autoload-1652.html
I don't always try to spam my new projects, but when I do, I don't.
There's no link, but it sounds like a mixup between ebay and freecycle and craigslist.
I found [the link](http://zombo.com/).
This prints at the end of the RVM install script. What the fuck?
Unsure how you managed to write Ruby without a shift key.
oh sorry... epic fail www.swopspot.net
i still wonder how 27% liked this - without a link...
Thanks for the heads-up! The main objective was to be able to redefine the already existing methods, mainly for bug fixes (only those can be called by the untouched classes anyway). I did some testing, and reloading a class changes the behaviour of the already existing objects, too. I did some limited testing on the thread safety too, so while it looks really promising it would need more testing for sure. This works well: class Sayhello; def hello; puts 'hello'; end; end;Thread.new do; while true do; Sayhello.new.hello; end; end;i=0;Thread.new do; while true do; eval "class Sayhello; def hello; puts 'hello"+i.to_s+"'; end; end";i+=1;end;end (sorry for the format, cut and paste from ripl) Lol, the sucky way to solve the threading issue could be to drop packets on port 80 while the loading is running ;)
1. Whoops, you are right, sorry. 2. Thanks!
I definitely recommend attending if you can. One of the major goals of the conference was to make it accessible to first time Ruby conference attendees, so it should be very accessible. Let me know if you have any specific questions. :D
This is just Java written in Ruby syntax.
Name a ruby-based blogging platform that *doesn't* support Markdown. 
Zero to Godwin in one comment. &amp;#3232;\_&amp;#3232;
Definitely going to try to make it! I lived in Pittsburgh for a few years and now I only live about 45 minutes away so I have no excuse not to come.
Congrats, you found the formula for being a rails ninja rockstar! 
I use [JWt](http://www.webtoolkit.eu/jwt) which holds more session information in memory than other frameworks, so at least for my case with restarting the active users would lose more state than usually. How annoying that would be is a question, though; with a bit of luck this could be just a flash in the browser, as the session is reinitialized. This is something I'll have to look into. Another minor issue is losing the JIT optimisations, and some initial gui slowdown, while the components get pushed to the clients again. I think of this as a convenience feature for small changes. Using it for big and sweeping would require way more work, so redeploy and restart is here to stay for sure. 
Oh great. Another blogging platform that can't compete with wordpress.
Considering there are tons of articles explaining their usage of Redis with lots of technical details you wouldn't even have to explain that YOU visit YouPorn, you could just say you've researched redis and point to various articles? :)
I don't really get the negative attitude. Programmer like to create things. He created a Blogging plattform for personal use or whatever and is so kind to share it with you guys. No need to bash...
None of the ruby or python blogging platforms can compete with wordpress. Not everyone is a fan of paying $15/mo. They tend to pay that yearly to cheap hosting providers.
You could use an ide like RubyMine to detect any unused imports. Probably the easiest way.
You do know that Wordpress is totally free and supported by virtually every web host on the planet, right? They offer their own hosting, though, which is what you're referring to.
this is exactly why i have said none of those could compete with wordpress. 
I agree that it's an important subject. But not many people feel like that. And it's not a really fun subject. Atleast in POSIX threads it isn't fun to deal with.
Ha! Well, if dRuby doesn't feel like fun, then I suggest one is not doing it right. POSIX threads ... well, there's little I can add to your summary.
Np, I was honestly quite confused, which is why I asked. I expected to have missed something.
What you want is static analysis. There are a few ruby SA libraries, I don't know if they can report unused code. Shouldn't be too hard to add if they don't. There is one huge caveat though; it's impossible to detect if methods are called dynamically, ie. with send, eval, etc so YMMV
I consider DRb more an IPC and RPC mechanism rather than a concurrency mechanism. For example, I wouldn't put things like fibers or threads in the same basket as DRb because they're based around a single process and I wouldn't use them for the same job. In terms of IPC and RPC, I prefer separate message buses, queues, or shared data stores like Redis, an RDBMS, or even the file system - entirely dependent on the job at hand. I think programs should be as separated from running daemon processes as much as possible.
Hi, I am the translator of the dRuby book. Thank you for mentioning the book. As some of you already mentioned, the book is written by Seki san, not Matz, though Matz wrote a nice foreword. In terms of concurrency, there is one chapter about using rinda and Unix "fork" to pass message across parent-child precesses which may be relevant to your discussion (the part is freely available via http://media.pragprog.com/titles/sidruby/rinda.pdf ). Also, I recently read a Japanese thesis written by Koichi (the author of YARV ruby 1.9 VM) about their study about MVM (http://www.atdot.net/~ko1/activities/pro86_mvm_paper.pdf) where they extended dRuby to make it easy for programmers to use MVM(Multiple Virtual Machine) features so dRuby may become even more important in future. I may translate the thesis if I get permission and when I get enough time. 
This blog post describes how to use Cloudinary to automatically deliver all static images of your Ruby on Rails web application through a CDN. Allowing you to improve site's performance without any code changes. It also explains how to perform image transformations using your CSS or Sass files, e.g., for displaying Responsive Images for different devices. Disclosure: I'm one of the co-founders of Cloudinary
Quick question: can I host other static files (html, css, js) that aren't images on Clodinary?
The title is a bit misleading. Shouldn't it be "through Cloudinary" rather than "through a CDN" (i.e. instruction for any CDN)?
&gt; As deeply as I regret the error, for which there's really no excuse Allright then, I'm glad we cleared that up
Cloudinary supports uploading and delivering any kind of files: http://cloudinary.com/blog/using_cloudinary_to_manage_all_your_website_s_assets_in_the_cloud We work on enhancing our GEM to automatically upload and delivery CSS and JS files and also minify and merge them.
&gt; Does anyone know of a ruby or drupal community? [Here's](http://www.reddit.com/r/ruby/) one :D ... If you are wanting to post a job, [this](http://jobs.rubyinside.com/a/jbb/find-jobs) is probably the first place I would look.
Got it. Redis is pretty handy, no? I have a bias against RPC in favor of what I think of as more explicit IPC. We've experimented with RPC for decades now, and, to my mind, mostly established that the syntax adequately confuses those new to multi-core or networked programming. "DRb more an IPC ... than a concurrency mechanism": that's a good summary of a criticism of the book. It looks as though we all agree, though, that Ruby, IPC, and concurrency merit attention.
Delivering static images is easy to do with S3 and cloudfront with the asset_sync gem. I guess cloudinary's value add is the ability to automatically resize images. Never really a pain point for me though.
For those interested in using S3 or whatever directly, we made [Asset Sync](https://github.com/rumblelabs/asset_sync).
Also take a look at Celluloid and in particular DCell: http://celluloid.io IMHO this is dRuby v2.
Hate to be that guy, but Rails posts belong in /r/rails.
I couldn't say it better myself. In fact, Mods should remove this because, in all reality it doesn't add to the discussions of this community. For-shame, OP. 
This is all good, but is it only me that finds this odd: While many sources highlight Ruby's powerful OOP features, you hardly ever hear people talking about the rather large nod Ruby gives to Functional Programming? Really, it's equally good at both.
I really would prefer if they removed the "rails posts in /r/rails" bit from the sidebar, shut down /r/rails, and merged it here. It'd make things more lively. I just pointed it out because it's in the sidebar.
Seems like *had*. That site looks like it hasn't been updated since 2006.
And it doesn't even identify the members of the team.
The ruby site took 18 MONTHS?!
Wow there's already a roadmap starting for Ruby 3.0!
No I am just tired of searching github and finding page after page of half finished, unworking, undocumented, abandoned, and frankly shitty gems. I kind of see it as polluting the community. Making it harder for us to find useful gems and getting work done. Also why can't you have fun making an existing project be better? Isn't there any satisfaction in knowing you are working on a world class project? Doesn't the community feel some sort of shame knowing that not one rails based blog engine holds a candle to those written in PHP, Python, C, .NET, Java etc. Does rails and ruby really want to cultivate the reputation as a platform that can't be used to build complex and useful software?
wow o wow. o rly? lol. shh
Check out the [wiki entry for the datefile adapter](https://github.com/rudionrails/yell/wiki/101-the-datefile-adapter) - it rotates by day (per default) and can be even furher configured. I have not found any use case for rotating a file based on size, so it is not implemented and (if there is any reasonable example for it) would belong into a separate adapter. Also, you are welcome to write an adapter for exception_notification ;-)
This user guie is great. It helps me as a quick review.
As a ruby beginner, I can't speak to the quality of this guide, but here's a project skeleton from LRTHW: http://ruby.learncodethehardway.org/book/ex46.html
You can probably learn some general ruby and rails concepts, but if I were you I'd opt for more current learning material. As kerricklong says the current version of ruby is 1.9.2 (http://rubyonrails.org/) and the current version of rails is 3.2 (http://rubyonrails.org/) Some good books are: The Well-grounded Rubyist, Programming Ruby, The RailsWay or Agile Development with Rails. More advanced books: Eloquent Ruby and Metaprogramming Ruby. Finally check out http://rubyonrails.org/documentation. That page has links to API documentation, rails guides, etc. What language are you coming from? I ask because there may be a book that helps to bridge the knowledge of that language over to ruby. Good luck.
With the greatest of respect for Matsumoto-san (もしもし), lots of people are better than him to get concurrency right. He is a great language designer but he is not particularly expert in concurrency. Threads in MRI are sub-par and he will be (has been) the first to admit it. If you want to see concurrency done really well in Ruby, look at Rubinius (jRuby is cheating ;).
[The Ruby Style Guide](https://github.com/styleguide/ruby)
I was really hoping this would be related to a layman's guide for getting the most out of Ruby conventions... as in cons... a-la RubyConf. :(
Yeah, I think it needs a possessive apostrophe somewhere. Maybe *Bastard's* or *Bastards'.* EDIT: Just browsing through the contents... overall, this book looks great and has potential to rock. 
Follow the gem layout. 
Haha :) When in doubt, sling mud.
I look forward to your next witty rejoinder. Good day to you.
Is the gemification of stdlib still on track? The libraries within stdlib could be extracted and developed outside of the stdlib during 2.0, and then finally removed in 3.0.
Ruby used to do the "odd version is unstable, even is stable" but they dropped that for 1.9 which caused a bit of confusion.
I don't know, you'd need to look that up as I haven't kept up to date with this (yet).. but I like the sound of your idea nonetheless!
And I will forever follow your posts in hope to see many helpful and insightful links to lmgtfy.com. 
Maybe [Gem::Version](https://github.com/rubygems/rubygems/blob/master/lib/rubygems/version.rb)?
So it is agreed.
You don't know what you're talking about... Do you?
After reading through the [Installation section](http://ruby.bastardsbook.com/chapters/installation/). I get the feeling that people may be put off before they even start trying to code. Maybe we should get people to try [Hackety Hack](http://hackety.com/) first?
I thought he was talking about all the build in functionality of Ruby. Though much similar things could be found in the STL od Boost Lib. (or any other library like Qt) I think most patterns apply to Ruby as much as to C++, Java or any other language. They are more about the architecture level, once a project becomes larger. Most of them have not much to do with typing. The main difference is how you implement them. Many patterns can be implemented very easily in Ruby, thanks to monkey patching existing classes. Adding things like observers can be done super simple, since you can hook into the classes at any level or even add functionality directly o single objects. 
We're working on getting a list up soon. I'll comment back when it is up and ready.
Pry is awesome for navigating and inspecting the Ruby runtime. I've also used Pry to track down some very subtle bugs as well. If your interested in IRB alternatives, you might also want to checkout [Ripl](https://github.com/cldwalker/ripl#readme). Ripl is dead [simple](http://rbjl.net/44-ripl-why-should-you-use-an-irb-alternative), easy to write [plugins](https://github.com/ronin-ruby/ronin/blob/1.5.0/lib/ronin/ui/console/shell.rb#L62-79) for (everything is a Module you inject into `Ripl::Shell`), and already provides some [simple plugins](http://rubygems.org/search?utf8=%E2%9C%93&amp;query=ripl-). Here's my [.riplrc](https://github.com/postmodern/dotfiles/blob/master/.riplrc)
Ah that's what I was looking for. I might give it a go.
The [pry-exception-explorer](https://github.com/pry/pry-exception_explorer) plugin may help u with that.
Oh, tanks for the tip! 
You are limited to what the platform exposes. But I saw a nice demo of Unity engine running as a Native Client, so I'd say, if you want to drive WebGl from Ruby, then this allows you to do that - Yes.
Leinster vs Ulster, Leinster vs Ulster streaming, Leinster vs Ulster watch online, Watch Leinster v Ulster live, Leinster v Ulster live Preview, Leinster v Ulster live sports, Leinster v Ulster- live Rugby, online Leinster vs Ulster Live, RaboDirect Pro12 rugby -2012, Ulster live rugby, Ulster Leinster rugby live , Leinster vs Ulster Live coverage, Leinster vs Ulster Live Rugby Rabo Direct Pro12, Leinster vs Ulster LiveLeinster vs Ulster Live stream, watch Leinster Live rugby, watch Leinster v Ulsterlive score, Watch RaboDirect Pro12 Live online, Ulster rugby live, Leinster rugby stream, Ulster Leinster rugby kickoff, Leinster vs Ulster....&gt;&gt;&gt; http://vslivetv.net/leinster-v-ulster-heineken-cup-final-2012-head-to-head/
Postgres HStore also landed, and they're open to Array types coming in if someone can get the code together. https://github.com/rails/rails/issues/4937
upgrade it yourself, lol. that is unless you have shared hosting and in that case I dont see how you're running rails apps anyway unless youre using some outdated ass version of ruby
no you definitely "CAN" run them, which is what I assume he has (shared hosting). Id imagine if youre doing ANY kind of web work at all beyond making a website that gets 1 hit per day, you want VPS or dedicated server where ruby can be easily upgraded ruby to 1.9.3 as well as rails, other gems, full ssh access, vital root security settings etc If you have shared hosting you dont get root access to apache config and all the other things that you need. So thats why I assumed he had it when he said his host hadn't upgraded yet, because he has just cpanel access to some "Rails app" icon one-click-bs
hot damn! Signed up, i know what ill be doing the next 2 days 
1. Why are you using rvm? Just get the package from the ruby site and install that. 2. What does the log file say? "please read /Users/KabirMahal/.rvm/log/ruby-1.9.2-p320/configure.log " 3. Uninstall XCode and get the Commandline tools package from the Apple Developer Downloads site.
You do need some sort of compiler, but do not need to download xcode for 99 dollars. If you make a developer account with apple, go to this download [link](https://developer.apple.com/downloads/index.action). search for xcode 4.1 for snow leopard. You should be able to download it from there. Or, you can download clang, another compiler [here](http://llvm.org/releases/download.html). Clang is the frontend for llvm, the default xcode compiler. Some stuff still compiles a little weird with it though. You will also need developer tools like make though. You can use [homebrew](http://mxcl.github.com/homebrew/) to download those other programs once you have a compiler. I would try to get the xcode thing to work though. EDIT: added stuff about make and homebrew
I know... now is not the time for learning how to code, now is the time for learning *opens book*, contextual inquiries. :C
But it's a crippled vi-like version, you need to install vim-core to make it nice.
I personally think this is a bad idea on their part. Maybe if they had a larger selection I'd be enticed to part with my money, but as it stands there's only four - maybe five - lessons that I'm interested in, and I can get through those before tomorrow night. I'm not denigrating the site at all - I think it's great and I'd like to give them money in the future when there's a larger back-catalogue. 
A good point. 
Rails posts belong in /r/rails.
puts "The servers are busy at this time, please try again later"
Running into a problem trying to get this to run on Windows. Haven't messed with jruby at all before, so please forgive me if this is an easy fix. I did gem install nokogiri, but I get the following when I call jruby app.rb LoadError: no such file to load -- nokogiri require at org/jruby/RubyKernel.java:1033 require at c:/jruby-1.6.7.2/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:36 (root) at ./d3status.rb:2 require at org/jruby/RubyKernel.java:1033 (root) at app.rb:1
Another option is to use https://github.com/kennethreitz/osx-gcc-installer. After gcc and the dev tools are installed you can use rvm to do the rest.
`--debug` sets `$DEBUG` to `true`, enabling extra debugging output. Ruby 1.9 also includes a built-in debugger similar to ruby-debug: require 'debug'
By the way, there is a student discount for $20 off the first month, I just got mine by posting a help ticket with that as the subject.
Do you have multiple rubys on your system? You might have used the wrong "gem" command to install nokogiri
Great if you always want a random comic. What if you want a specific comic?
It can be added easily, as xckd has http://xkcd.com/[0-9]* and if comic not present it will return 404. These seems like a nice plan to add? 
I don't even understand why you have randomness in the API. Your API should provide access to the XKCD comics, and let the users of your API use their own random function to select a random one if that's what they want.
Oh..hmm /me liked randomness...adding one such method to get specific image would be useful? But what would be the input parameter, comic number or comic name?
Yeah, each install will have its own set of gems. Since you're on Windows, you might want to look into pik (https://github.com/vertiginous/pik) to switch between different versions.
Hpricot is dead, use nokogiri instead. 
Suggestion: `xkcd.first.alt_text`
nokogiri is bundled with ruby ? &gt; Nokogiri::HTML(open('http://dynamic.xkcd.com/random/comic/')).css("#comic img").text That is not helping, even though ("#comic img") is giving the right link. **Edit got it!** &gt; Nokogiri::HTML(open('http://dynamic.xkcd.com/random/comic/')).css('#comic img')[0].attributes["src"].value **Edit** Did the changes and pushed the gem, thank you for the suggestion! :) 
Thank you :)
I was really suggesting getting the alt_text for a comic. The `first` method is another suggestion I guess. For example, in a Ruby array you can call first to get the first item.
That's it. Looks like the weekend is over: http://twitter.com/#!/codeschool/status/204421270253744129
Ok :) Adding it, I just need to do &gt; Nokogiri::HTML(open('http://dynamic.xkcd.com/random/comic/')).css('#comic img')[0].attributes["title"].value **Edit** Did the changes and pushed the gem, thank you for the suggestion! :)
I am planning on writing a details post on, chmod command in my blog, will add your comment there.. :) thanks for the input. 
This is actually pretty cool! "If you ever needed a dead simple admin interface, configuration document, or basic content management system, a spreadsheet is a pretty great solution that requires very little engineering overhead. Next time you are in a position where non-technical people need to manage data, ask yourself if a spreadsheet might be a good first solution." 
TIL: You can create a gem skeleton with Bundler TIL: You shouldn't use Bunder to create gem skeletons.
what if i told you that making a gem yourself is really easy...
&gt; TIL: You shouldn't use Bunder to create gem skeletons. I don't know about all that. You certainly don't _have_ to use Bundler to create gem skeletons, I don't know if the OP is even trying to say you _shouldn't_. I find it useful. 
You have never had to use bundler. In the past you could use 'hoe', 'gemcutter', 'jeweler' and probably others. This whole article seems to go on the premise that "it is bundler or the highway" unless you use this magical 'ore' gem. This is a enough of a mind-blowing realization to require the morpheus meme apparently.
You don't have to use anything to write a .gemspec. It's ridiculously easy. All you need to create a gem is RubyGems. Please stop making this seem harder than it is. If you want a tool to help with managing .gemspecs, creating project skeletons, whatever, that's fine. But I feel like people just keep mystifying the gem creation process and it makes me sad.
When you create Gems [all of the time](https://github.com/postmodern), doing so manually becomes tedious and prone to human error. When inspecting other Gems, I tend to find mistakes in the gemspec, missing ChangeLogs, no tests or documentation because the developer quickly created the Gem by hand. I use Ore because it sets everything up perfectly. Try Ore for yourself. You can always uninstall Ore, if you find it clunky.
Like I was trying to communicate, I'm cool with project generators. But we have had many posts in this subreddit talking about how "easy" it is to make a gem..."just use this tool!" I'm concerned that it actually makes it more confusing than it needs to be. I realize in retrospect that "Please stop making this seem harder than it is" might have sounded like it was directed at you - it was meant for the community at large.
Sorry to be adding to the "flack". I read this as a "how to make a gem" post, not a project generation post.
Thanks for posting this. Just write my first Ruby gem recently, and I had a hell of a time getting simple stuff to work when writing from scratch. Ore provides some nice examples.
Project generators ensure that you do not forget to add these files, and are auto-populated with the basic information; so you can focus on writing code and not fiddling with `.gitignore`. Developers are starting to find gems with no ChangeLog or LICENSE; probably because the author rushed the release. You can also run Ore against an existing directory. It will prompt you if it's about to overwrite a file: $ mv lastnights_hacking awesome_fu $ mkdir -p awesome_fu/lib/awesome_fu $ mv awesome_fu/*.rb awesome_fu/lib/awesome_fu $ mine awesome_fu Generating /home/hal/awesome_fu exist lib exist lib/awesome_fu create spec create .gitignore create .rspec create spec/awesome_fu_spec.rb create spec/spec_helper.rb create .document create awesome_fu.gemspec create ChangeLog.rdoc create LICENSE.txt create README.rdoc create Rakefile create lib/awesome_fu/version.rb create lib/awesome_fu.rb run git init from "." run git add . from "." run git commit -m "Initial commit." from "." 
me too :D
I really like the design of the site.
&gt; is@targa5:~/rubyapp_2012feb$ sudo gem install gita &gt; Fetching: gita-0.0.1.gem (100%) &gt; Successfully installed gita-0.0.1 &gt; 1 gem installed &gt; Installing ri documentation for gita-0.0.1... &gt; Installing RDoc documentation for gita-0.0.1... &gt; is@targa5:~/rubyapp_2012feb$ gita &gt; You grieve for those who are not worthy of grief, and yet speak the words of wisdom. The wise grieve neither for the living nor for the dead. &gt; is@targa5:~/rubyapp_2012feb$ gita &gt; All works are being done by the energy and power of nature, but due to delusion of ego people assume themselves to be the doer. No room for a type-A personality (Ruby Rockster) there. 
Rockster++ :)
Could have just written a fortune for fortune.
This actually inspired me to work on something similar, except using the Hidden Words by Baha'u'llah
I know this is a nitpick, so please read this in Comic Book Guy voice: &gt; ActiveSupport provides the group_by and sort_by methods on collections Enumerable provides group_by and sort_by. You don't need ActiveSupport for these two methods: &gt;&gt; RUBY_VERSION =&gt; "1.8.7" &gt;&gt; [].method(:group_by) =&gt; #&lt;Method: Array(Enumerable)#group_by&gt; &gt;&gt; [].method(:sort_by) =&gt; #&lt;Method: Array(Enumerable)#sort_by&gt; 
Thanks! Updated the post.
I stated that Bundler excels at dependency management, hands down. I use Bundler in all of the [Ronin](http://github.com/ronin-ruby) repositories. I also briefly went over Jeweler/Hoe, but they are more than just project generators. Do you happen to know of any other pure-project generators? Also, Ore can generate projects with Bundler: $ mine my_project --bundler There's no sales pitch or binary choice. I tried to express that in the last paragraph: &gt; Now that you have been introduced to Ore, I hope you will at the very least give it a try. I also hope you will understand that I am not simply anti-Bundler / pro-Ore. Ore gives you the option of generating Ruby projects with/without Bundler. The two tools are not mutually exclusive. **Update:** I added a Warning to the blog post, since I've gotten so many confused/angry comments and downvotes.
Not sure why my comments were getting downvoted. If you don't like project generators, continue to not use them. If you prefer `bundle gem`, then continue using Bundler. I tried to clearly state that Bundler _rocks_ at dependency management. I use Bundler in every [Ronin](https://github.com/ronin-ruby/) repository. You can even generate Bundled projects with Ore: $ mine my_project --bundler This is not a sales pitch nor a binary-choice between Bundler and Ore. I'm not asking you to convert to Ore. From the last paragraph: &gt; I also hope you will understand that I am not simply anti-Bundler / pro-Ore. Ore gives you the option of generating Ruby projects with/without Bundler. The two tools are not mutually exclusive. **Update:** I added a Warning to the blog post, since I've gotten so many confused/angry comments and downvotes.
damn, that's interesting. I've been onto the same basic idea for quite a while now.
Seriously? I *just* started using ruby instead of python because of hpricot. Is nokigiri similarly easy to use?
You forgot to tag the release. :) Might I suggest using [gem-release](https://github.com/svenfuchs/gem-release) or [rubygems-tasks](https://github.com/postmodern/rubygems-tasks#readme)?
Never, ever, touch my git repo without asking me. If this ever happened to me, I'd immediately reset the commit, then uninstall your tool.
* You can also use the `--no-git` option to prevent the creation of the Git repository or committing of changes. * Majority of developers will run `git add .` and `git commit -a -m "Initial commit"` anyway. You can even find these commands in various howtos. * You can run `git commit --amend` to update the Initial commit. * You can run `rm -rf .git/ &amp;&amp; git init` to reset the Git history. * Technically the generated library isn't _your_ Git repository just yet; atleast not until you make the second commit. However, this does sound like a +1 for a `--no-commit` option? * If you are morally or ethically opposed to using Ore, then do not install it. :)
Whew.
As a ruby dev who frequents this subreddit, I am trying to understand why there is so much vitriol directed at the OP here. Here we have interesting and original content coupled with a well written project that the OP built as a curtsey to the open source community. Can please not make this a place where we punish people with arbitrary downvotes for sharing stuff like this because it doesn't fit into someone's specific workflow? I learned several things from the post and am now aware of another tool that I could potentially use when writing my next gem.
Yes, do the same. But we dont use any VCS at work. I try to get my co-workers to use one.... hard stuff.. hehe
nice :)
Is there any further explanation?
I see your point, and will be considered on future releases. Thanks
Any reason you're generating the passwords on the backend instead of using JS?
None specifically, just kind of started as a side project to dig into Sinatra some.
Yeah, I guess it wouldn't be very useful for learning that if you did it all in JS.
this is the most pointless thing I've ever seen. Why would I want randomly generated but totally insecure passwords.
Be nice. 
I get the point, but lets be honest...if you're having someone snooping a password then you have far greater issues then if a password generator used SSL. Do you blame a grocery store if someone watched you put in your PIN during your debit transaction? I have had quite a few people tell me the site is far from pointless, so i'll take your constructive criticism and leave it at that.
&gt; Email this password? lol
We have resolved your problem as of today :)
Why would you use this on something like your bank account? This is good for sending someone a quick temp password that is more secure then 12345 so they can change it when they login. (Just one example). If you want something super secure, then type random stuff yourself. lol
My condolences. I really can't comprehend any reasons not to use a VCS amongst a team of coders. Your company must make pretty shitty software :P
For the CLI folks out there: require 'chars' Chars.alpha_numeric.random_string(10..14) # =&gt; "BYNYwMSkqEO5"
You forgot to tag the release again. :(
so you're saying we/you already have the first thing we need, we/you just need to get someone to take your implementation, give it the nod, and put it into production? Do you know who the someone(s) are that have the authority to do that?
Unfortunately yes. :( Two years ago, there was some outrage over http://ruby-lang.org/ not being available on GitHub, for people to fork. Various developers created redesigns using Jekyll or Octopress. I decided to do a straight port instead. The [Ruby Visual Identity Team (VIT)](http://rubyidentity.org/), who controls http://ruby-lang.org/, decided to do their own redesign. They were supposed to merge my ported content into their [new website](https://github.com/ruby/ruby-lang.org), but development stopped due to lack of time. The VIT [mailing](http://rubyforge.org/pipermail/vit-discuss/) list has been dead for several years as well. Personally, I'm OK with the current look of http://ruby-lang.org/. I just want a more open and transparent version of it.
So now there's a list of things people should and should t use this for?
[DHH is not a fan](https://twitter.com/#!/dhh/status/205409699351367683) (I'd paste the conversation but Twitter conversation view sucks shit). Interesting conversation there, kind of impressed/surprised jamesgolick managed to keep his cool. 
:)
DHH is right, though. Instead of using XML to associate different classes and inject dependencies (a la J2EE) we are using a Ruby config object. This obfuscates the actual intent of the system. It also means that to create a single controller action you need to write a receiver, responder, service, and config entry. It is very maintainable and complicated just like Struts apps. I bet DHH doesn't like those, either.
cray i'm
tired the gems you suggested, yet to digest them, will tag with normal git now
I'm not sure why you failed to grasp the comment was an example I gave, but I'm not one to correct others' stupidity. 
Yorick - Don't want to revive a dead thread necessarily, but if you want, here's an updated version of the Gem. took your advice to heart! Let me know what you think! https://github.com/alxjrvs/Stattr
So is it basically an open source clone of ~~github:fi~~ [GitHub Enterprise](https://enterprise.github.com/)?
Basically. Obviously not quite *there* yet, but it definitely seems usable for smallish projects. I know one team is eager to replace gitweb+gerrit and really likes Github, but doesn't want to deal with Github policies or pricing. Gitlab seems to be a solid effort to remedy that!
Can someone explain how this is better than optparse? It looks almost identical.
Optparse *comes with ruby as standard*. So the 'no gems' thing is a bit of a red herring. And the syntax seems almost identical! I don't see the advantage, really. Still, if we were all the same...
I'll be honest: I don't know anything about OptParse, I was just regurgitating what the author said on that answer, and on the trollop page. :P
Here is the authors own first example: require 'trollop' opts = Trollop::options do opt :monkey, "Use monkey mode" opt :goat, "Use goat mode", :default =&gt; true opt :num_limbs, "Number of limbs", :default =&gt; 4 opt :num_thumbs, "Number of thumbs", :type =&gt; :int end And here is the same in Optparse: require 'optparse' params = {monkey: false, goat: true, num_limbs: 4, num_thumbs: nil} opts = OptionParser.new do |o| o.on("--monkey", "Use monkey mode") {params[:monkey] = true} o.on("--goat", "Use goat mode") {params[:goat] = true} o.on("--num-limbs", Integer, "Number of limbs") {|x| params[:num_limbs] = x} o.on("--num-thumbs", Integer, "Number of thumbs") {|x| params[:num_thumbs] = x} end I don't see that one is massively better, or, indeed, that there is a great difference. (On reflection, the syntax *is* different.)
Subcommands. Everything else looks like very slight improvements over optparse at best. Use this only if you need subcommands or if you suffer from OCD.
This is really great news. 
Yea putting all your object dependencies in your routes is kind of dumb.
Could someone explain why it's also better than Slop? https://github.com/injekt/slop
Improved! :-)
Prepare your anus for I will again list 10 things that I feel can be improved: 1. You are vendoring Trollop, why? You're building a gem, there's nothing wrong with adding it to the Gemspec. In fact, it's better because it will make your own gem smaller and easier to maintain as you don't have to bother updating these gems (unless you were to require a specific version). 2. `require_relative` only works on Ruby 1.9 like systems. While I couldn't give a damn less about Ruby &lt; 1.8 it might be worth mentioning this in your README. 3. Your bin/google file is completely useless as most of the logic it should handle is instead placed in lib/google.rb. This makes it impossible for people to manually require these files (e.g. for testing) without executing it. 4. I don't see any tests/specifications. Hell, you can even use Cucumber if you're feeling like it (I have personal objections again Cucumber but I'll put those aside as there's no point in discussing it). No tests is a deal breaker for a lot of people. 5. License files are typically stored as plain text files opposed to formatted (e.g. markdown) files. This is not a requirement or anything but I personally prefer to keep them as "plain" as possible so that they remain clear no matter where they're viewed. 6. Gemspec contains calls to `Dir.glob()` that aren't really required due to the simple structure of your project. 7. Document your code. Document your code. Document your code. Document your code. Document your code. ent your code. Document your code. Document your code.ent your code. Document your code. Document your code.ent your code. Document your code. Document your code.ent your code. Document your code. Document your code.ent your code. Document your code. Document your code. 8. There's no point in using the following code: string = '' string &lt;&lt; "something with a #{var}" string &lt;&lt; 'More stuff' You can easily replace this with the following: string = "something with a #{var}" \ "More stuff" 9. Namespace your code. I've said this before but I'll repeat it (and will continue doing so): not namespacing your code is a bad, bad idea. See &lt;http://www.reddit.com/r/ruby/comments/tcgqs/decided_i_was_going_to_create_a_gem_today_and_i/c4li0t7&gt; for more information. 10. You have Trollop logic mixed with generic parsing logic (e.g. request.rb). You should use exceptions instead. **Edit**: Markdown list fail.
Thanks again - I threw some magic in my Vimrc that will help point out the tabstops, and fixed the ones i have now ( and some other magic to delete some generically annoying whitespace). The spaces were of my design, but I agree that the code looks better without them. 
I thought, wait, I thought Google got rid of their API! Ah, it's left around... for now. &gt; Note: The Google Web Search API has been officially deprecated as of November 1, 2010. It will continue to work as per our deprecation policy, but the number of requests you may make per day will be limited. Therefore, we encourage you to move to the new Custom Search API. From the linked ToS "Deprecation" section.... &gt; For a period of three years after an announcement (the "Deprecation Period"), Google will use commercially reasonable efforts to continue to operate the Deprecated Version of the Service and to respond to problems with the Deprecated Version of the Service deemed by Google in its discretion to be critical. During the Deprecation Period, no new features will be added to the Deprecated Version of the Service. So looks like it's got another year or so of existing with possible severe rate limits. 
Actually, it's on my top 5 list of the next things to try ;) I know it's compatible with Resque jobs, and this is a plus since we've got in place the integration with another system where they push some particular jobs into one of our queues. So if all looks good when I get to try it, switching should be simple.
Awesome, that fixed it!
Thank you for this list. This is my first gem, and in fact my first non-trivial ruby project. 1. For some reason I thought fewer gem dependencies would be better. 2. I mentioned that it's only tested on 1.9.3, but yes I should mention specific incompatibility with 1.8. 3. I'll look into that. 4. I'll be honest, I don't know a thing about testing. I'll definitely look into that, because automated testing sounds so much easier than manually going through and using the app over and over in different ways after every change. 5. I'll keep that in mind, I didn't know of that convention. 6. So I should just list each file individually? 7. I'm sorry. I know. I wrote it overnight. I'm sorry. I know. I wrote it overnight. I'm sorry. I know. I wrote it overnight. I'm sorry. I know. I wrote it overnight. 8. I only did it because I wanted to keep lines under eighty characters. I didn't know about the backslash bit. 9. I'll look into it. 10. I'll look into it.
Wow, had to do a double-take to make sure this wasn't [r/business](http://reddit.com/r/business). That title would mean something *completetly* different there... 
OMG hadn't thought of that! :D
Was this publicized at all when it first came out?
This is the most sensible thing I have read in a long time.
[Here's a video of the announcement](http://www.youtube.com/watch?v=d5nDK2CgomA)
https://github.com/vizbu/vizbu/blob/master/app/controllers/home_controller.rb That's the whole application in one big ass controller. Not nice.
Should've stripped your dev keys out of it. Considering the application is essential one big controller, that's the smallest of your concerns.
Something like this is the RailsApps project: http://railsapps.github.com/ It's a collection of example apps and each is accompanied by a detailed tutorial that shows each step to building an application.
Even if it were the case that those sites exist, that doesn't automatically preempt the purpose of new material being written.
just use em for the use cases they were designed for, that's what they're optimized for. if you're entering 'magic strings' in source code and using them as hash keys, use symbols. If you're taking strings from user input or other I/O, that could potentially be any string at all, use strings. 
I don't know about such a screencast. Since you are looking to do a website i assume you want to learn ruby on rails. anyways, i'm a newbie at ruby and RoR i've just been looking at it by curiosity, might try to do a project with it later because i want to see why it's so popular. Here what i've used to learn ruby's syntax : http://tryruby.org/ to learn RoR : http://railsforzombies.org -&gt; might be close to what you are looking for, screencast lesson + in browser code exercise. 
Also, this http://ruby.railstutorial.org/ruby-on-rails-tutorial-book
[It's...beautiful!](http://imgur.com/lNT0g.gif)
Another thing to watch out for is that symbols are not GC-ed so taking strings from user input is not a good idea.
I have been documenting my learning process on http://www.learnwithjeff.com. I used the Pragmatic Studios "Programming Ruby" video series. It was totally worth the money.
this is great stuff! 
I saw the title and thought this would be some impressive feat. But no, six out of seven have no more than 50 lines and follow the pattern of: generate random number &gt; [print that line of text file|get a URL containing the random number]. 
If you read the [original DCI document](http://www.artima.com/articles/dci_vision.html), you'll note they talk about "something like delegation or mix-ins" but note "each of these approaches has at least minor problems and we'll use something else instead." I still don't understand how the "something else" differs from delegation or mixins
I thought he was an archeologist.
Love the new looks. However, is there any chance of adding keyboard navigation between the quotes in a next version (or perhaps I just missed it)? Clicking all the way through the quotes is starting to make my hand feel numb ;)
Is there a video to accompany this?
I guess people are seeing my post as a criticism of Sequel itself? It isn't, I love Sequel and it is possibly the best ORMish library I have ever used. The presentation is something else altogether. I died around the time we got to a timeline of the developer relationship soap opera... keep it short and simple but don't be boring!
not sure why this has 5 down votes, because its a fairly informative post for someone that isn't familiar with the schema_migrations.
Wow, that was so informative. I never would have known that his hobbies are fapping and playing video games without this slideshow. 
Maybe because most of the people who would want to poke around Rails would quickly see the extra table in their schema? It's weird though, that RailsTutorial doesn't mention this info. I'll give the Guides a pass because mentioning it would only make the Migrations section unnecessarily longer considering that this info is mentioned [in the API](http://api.rubyonrails.org/classes/ActiveRecord/Migration.html). 
-------------------&gt; /r/rails 
Why is this being downvoted? We are in /r/ruby, the sidebar says: &gt;Ruby-on-Rails posts are encouraged to be posted in the r/rails subreddit
This is because no one really cares about subreddit rules or [reddiquette](http://www.reddit.com/help/reddiquette) on Reddit anymore. 
&gt; Now back to the original question. I checked Rails Guides, but they only presented me with vague information regarding it. Then why not add it to the guide in docrails? (Of course, I could ask the same question of myself. :) ). In very recent versions of rails, you also have a rake task that will show you the contents of that migrations table, although I can't recall the name of it at present. try a `rake -T migration` to find it. 
not app/views/layouts/index.html?
Just a general tip for these kind of problems: use a code editor/IDE that supports multifile search and replace. You can use the command line too. Search for the typical head tags (head, link, script) and the file will show up (amongst others, surely) but you can discern which one outputs the head.
If this is related to Rails it should be posted in /r/rails instead. Downvoted for that specific reason.
Hey buddy, again with the aggressiveness, what gives?
Yes, but with refinements. There are just as many reasons as to why it's bad to monkey patch every object you can get your hands on. 
you might need to restart/recompile assets.
I'm not interested of how and why your client hired your or asked your guidance. You were given a job you can't handle, in my opinion the right thing to do would be to reject the job offer, but of course that's your decision. Being able to text for a piece of text inside an app is part of your field of working, no matter what OS or you're using. You can probably do it with windows search too. You can call yourself whatever you want, it's none of my business really. But this has nothing to do with ruby or rails. It's not really the ethical part I'm concerned about. Many great web developers don't know ruby, but they wouldn't agree on getting paid to post a question on stackoverflow (You did post a question there, didn't you?) and r/programming and then copy &amp; paste some code having no idea what they're doing. Would you feel comfortable showing this thread to your client? Probably not. Do what you want, but please stop pretending this is OK. And I won't apologize for the aggressiveness. If you're asking for /r/programming to do your job while you are getting paid, then be ready to accept the criticism too.
encouraged != required
I just committed an update to docrails Active Record Migrations section, so it could contains at least some cursory information regarding the schema_migrations topic I wrote about in the blog post.
I just committed an updated to docrails Active Record Migrations section on github. Thanks for the recommendation. It will hopefully enlighten some other beginner Rails programmer.
As i said, the client is not paying me for this, and i did not accept a "job". When we first start i mentioned i will not be able to help with this specific project, she is aware of that, and i would have no problem showing her this thread. She needs help with this small task, and she asked me as a favor, and i said i will look into it. I did what i could, tried to locate the template file, do a search based on a specific term, inserted my code there, but the front end would not change. Being confused i wanted to ask the help of someone who has experience with this, before saying no to my client and not offering her any help, i wanted to see if i could get any tip from here. I'm not sure what you find so offensive about this, clearly i would not come here if the issue was so small that a small "find and copy paste" would solve it. Could the program have a caching system? Do i need to do anything else? I don't know, i have no idea how it works and that's why i said i should ask for help. This is OK, i want to help my client however i can because i care about them, i don't know this information that is not my in working field so i ask for help, why are you feeling so offended? I am not asking anybody do to my job, but if you would come to a community and ask for help in something you are not familiar with, and i am, i will be happy to show you some guidance or any inside tip that will save you a bit of time. Thank you for your criticism too, but i feel bad as i just wanted to get an information to help a client in need, and instead we got here to this comments. 
Indeed. Monkey punching everything is evil - specially on library code. What are your thoughts on application code? It is a shame the example are based on classes from the standar library, but the point of this approach can be extrapolated to user defined classes. It is all about messages. 
Well Python is actually way more used than Ruby, and has more libraries aviable. I prefer Ruby's syntax, but when it comes to real programming... Python is way better.
We're using capybara-webkit successfully, covering the larger parts of a js heavy application. Combined with spork, startup is not a big pain. I found selenium in comparison very sluggish, but it's been a long time that I tried it. Our app is optimized for webkit, so maybe the errors you are seeing also occur on real webkit based browsers?
I've been doing all my work in Ruby but when I needed to write a Django view in Python it wasn't all that bad. Their lambdas suck some major ass but other than that just grab the docs and get it going. Pretty smooth ride from there. Both languages are awesome so just enjoy yourself.
&gt; Well Python is actually way more used than Ruby, and has more libraries aviable. What is your evidence or data or reasons for believing this? It is not obvious to me that is true. 
&gt; The whole Ruby/Python thing has caused me a lot of confusion what are you confused about? what do you mean? What's "the whole ruby/python thing"? &gt; Is it going to cause me problems later if I start working a bit with Python? What do you mean "cause you problems", what sort of problems are you thinking about? They are two completely different languages. You can certainly switch from one to another, or do some projects in one and others in the other. But they are completely different and seperate, you won't be able to re-use code between them, or write code in one language using a framework/library/gem/egg from the other language. 
There's also the older [Ruby4Skype](http://skyperapper.rubyforge.org/) gem.
For reference, Ruby Toolbox is a great resource for looking up gems. https://www.ruby-toolbox.com/search?utf8=✓&amp;q=Skype
Besides being slow, I've had no problems with capybara-webkit. Gotta love screenshots.
We use phatonmjs 1.4 with xwindows frame buffer. The new release of phantomjs, 1.5, which removed the dependency on xvfb, uses 4 times them memory and I haven't figured out why. 
Ruby's just your first programming language. Learning lots of languages is good for you. Each new language will teach you new ways of thinking about problems and expressing solutions. Learn as many as you can, though I'd recommend ***really*** learning each language before moving on (a bit more time with Ruby may not hurt). And no, learning Python won't cause you problems :)
I think there's no good way to express platform-specific gem dependencies. That hack may not be a good one -- it's probably going to interfere with bundler doing aggregated dependency tree resolution. With regard to "marshal may change in future ruby versions", many people use YAML instead of a custom serialization format to account for this -- although ironically YAML ended up having some compatibility issues with the stdlib between 1.8.7 and 1.9.x too, although it wasn't supposed to. 
http://www.ruby-doc.org/core-1.9.3/Marshal.html &gt; Marshaled data has major and minor version numbers stored along with the object information. In normal use, marshaling can only load data written with the same major version number and an equal or lower minor version number. If Ruby’s “verbose” flag is set (normally using -d, -v, -w, or –verbose) the major and minor numbers must match exactly. Marshal versioning is independent of Ruby’s version numbers. You can extract the version by reading the first two bytes of marshaled data. Whether or when they _will_ change the Marshal format, I don't know, but the API leaves the possibility open. 
Be sure to check out Krypt. While it's not finished, it should hopefully be the panacea for cross-platform crypto in Ruby: https://github.com/emboss/krypt
Your models talk about users (plural) but your view talks about user (singular). Change your view to use fields_for :users.
Well that's exactly my point. I prefer Ruby to Python **as language**, but if you need special libraries, frameworks or even support, Python wins there.
A few I'm following along as they go through various Ruby bootcamps and such: * http://programmingpararaphs.tumblr.com/ * http://notlateforruby.tumblr.com/ * http://matt-nguyen.tumblr.com/ * http://domkm.tumblr.com/ A good resource by thoughtbot: * https://github.com/thoughtbot/trail-map
If you've got a generator that can write the README, ChangeLog, tests and documentation, I'd like to use it!
Haha, I was actually thinking of using Wordpress to blog about my journey into the world of programming. Never really thought about this. Thanks! I am strongly considering doing this.
If you don't mind me asking, how much does that cost on Heroku? Or is it small enough to run for free?
What he's running is free.
You're quite the [anus ripper](http://www.reddit.com/r/ruby/comments/u2l3d/show_rruby_i_made_a_gem_to_give_you_the_power_of/c4rsu53)! :P But seriously, you're doing an awesome service to the community. :D
Hmmm, and I guess a blog is ALMOST the same thing.
A twitter clone would be a better idea for a first [Sinatra](http://www.sinatrarb.com/) app.
Just an FYI, Twitter doesn't run on Ruby/Rails any more.
Oh cool, a nice read. Thanks! Edit: I also have a codeschool.com account and they give out a free month to railscasts.com, so I guess that will be useful as well.
Twitter's ditching the hash-bangs: http://www.webmonkey.com/2012/05/twitter-declares-everything-old-new-again/
Way to argue against a straw man.
Some helpful clarifications: &gt; Don't commit archived files, gems, etc (snappy.zip in this case). Instead, upload them to the [Downloads section](https://github.com/pioz/snappy/downloads) of the GitHub project. &gt; Follow the god damn Rubygems structure for projects. I believe you are referring to [The Ruby Packaging Specification](http://chneukirchen.github.com/rps/). :P &gt; Personal opinion: please don't use the GPL, use a more permissive license like the MIT license. Unless of course you really want to enforce the rules of the GNU religion. Informed opinion: GPL is fine for applications. For example, it does hinder shady people from forking your app, rebranding and reselling it. There's also the LGPL which loosens the restrictions on commercial linking; if you want to allow other commercial apps to link-to/load your code. If you want to allow full commercial bundling of your app, you can dual-license as GPL+commercial-license (ex: [Sidkiq](https://github.com/mperham/sidekiq/blob/master/LICENSE)); developers get the code for free and companies have to pay you $$$$. There's a ton of misinformation surrounding the GPL, it's really _not that bad_... &gt; Document your code. Might I suggest [RDoc](http://rdoc.rubyforge.org/) or [YARD](http://yardoc.org/). Your tips are valid, but would be more effective if you submitted an Issue to the [GitHub project](https://github.com/pioz/snappy/issues).
&gt; It's a fatal error, fucko That's up to the application that uses the library to decide.
Yes, however snappy.rb *is* arguably a library.
This is not a good idea since you would install an old ruby version. Also rubygem is already bundle with ruby. Installing RVM is not that hard, you can simply follow the instruction here https://rvm.io/rvm/install/ Please note that one of the mistake that could be made while installing is the "requirement part" When you enter the command 'rvm requirement', you have to copy/paste the command that begin with apt-get install under "Debian" to install all the dependency needed to compile ruby.
Hey I'm a long time ruby/rails/ubuntu user I'm working today but if anyone want some help, join me on [this campfire chat](https://alexcp.campfirenow.com/32aab)
Chances are you didn't set up your bashrc properly. Follow the RVM instructions carefully. I do wish RVM dealth with bashrc on ubuntu a bit better.
Thanks for the reply. As a reply to your last sentence, I would say that I get stuck a lot of times and I find it hard to isolate that bit of code outside it's context and subsequently, trying to post it in some Q/A site for help. EDIT: Oh and your first line really does strike a chord with me. However, I've been wondering, is it important to have the knowledge to solve problems, or solve problems in the right way, as dictated by the language?
I'm just guessing he's running an Ubuntu VM. I also have a hunch that this might be his first experience with Linux.
I disagree with this. While Rails requires a fair knowledge of Ruby, you can learn both Ruby and Rails at the same time. That's how I did it. I dived into Rails without knowing anything about Ruby except for the similarities it has with Python and I turned out okay. It was pretty hard at first, but it gets better over time.
I guess that's true. The OP didn't give us enough context though.
I'm going to be blunt here, just take into account that this is nothing personal: the code is shit. Note that when I say this this doesn't mean you lack any skills or are an idiot, it's just an indication that the specific code example you've shown looks disgusting (I'm afraid I can't describe it in another way). Don't worry, I'm not just going to judge you an run off, as usual there's a bunch of things I'll list that you can use to improve both this specific code as well as your knowledge. ## Specific Code Snippet 1. Break things apart into modules and classes. This makes it easier to test and re-use various parts on their own. 2. Get rid of trailing whitespace, it has no significant importance. 3. Wrap lines at 80 characters per line. This makes it easy for people to view your code no matter that tool they're using (editor, terminal, browser, etc). 4. Don't use tabs for indentation, Ruby uses 2 spaces per indentation level. Also, if you use tabs for alignment I'll find you and beat you up with every piece of information that I can find about why this is a bad idea. 5. Use whitespace to separate statements (if, switch, etc) from each other. 6. Document your code. It appears this code is a to-do list of some sort but I have no idea what it does and how it does this. 7. Personal opinion: I'm not a fan of sentences such as "Awwwwh man....xxxx", it feels immature. Keep things short and to the point. 8. WTF is this?: numenum = (total_tasks, fin_tasks, left_tasks = filelines[-3].scan(/\d+/).each) subnumenum = (total_subtasks, fin_subtasks, left_subtasks = filelines[-2].scan(/\d+/).each) total_tasks, total_subtasks = numenum.next.to_i, subnumenum.next.to_i fin_tasks, fin_subtasks = numenum.next.to_i, subnumenum.next.to_i left_tasks, left_subtasks = numenum.next.to_i, subnumenum.next.to_i This is not how you assign variables, not if there are this many and they don't fit on a single line. Spread it out on a few more lines and write some comments to explain what they are used for. 9. Don't abuse "break" for control flow, use errors/exceptions for that. 10. Follow the generally accepted package structure used for Rubygems, more information can be found here: &lt;http://chneukirchen.github.com/rps/&gt; ## Learning I've found that the best way of learning something new is to dive in head first. For example, I'm currently learning about the Ruby C API by trying to write an extension right away (opposed to following a tutorial). Having said that this doesn't always work for everybody. Here are a few resources from my "Ruby" bookmarks directory that you might find useful: * Ruby Symbols: What Are They?: &lt;http://old.thoughtsincomputation.com/posts/ruby-symbols-what-are-they&gt; * Symbols and garbage collection: &lt;http://stackoverflow.com/questions/659755/ruby-symbols-are-not-garbage-collected-then-isnt-it-better-to-use-a-string&gt; * Predefined global variables: &lt;http://ruby.runpaint.org/globals&gt; * Ruby Best Practices (didn't read it myself): &lt;http://rubybestpractices.com/&gt; * Learn Ruby The Hard Way: &lt;http://ruby.learncodethehardway.org/&gt; I have a few more but those are related to topics that might be a bit too complex for you at this point (C extensions for example). ## Comparing With Others Based on this one snippet it's hard to determine what skill level you are. On top of that skill isn't just defined by how code looks, it's also based on how you've solved problems and what tools you've used for it (e.g. I consider IDEs to be cheating as they often do a lot of work for you). Becoming a good programmer isn't something that happens overnight, or even in a few months. It can, depending on the languages you're using, take years. All of this of course depends on how quickly you learn things and adapt to new things. As mentioned by nirvdrum it's also not just about learning the syntax, problem solving in general (which is something programmers do) plays a very big role. In the end Ruby is just a tool to reach a goal, if you only learn that specific tool you won't be able to apply your knowledge to other tools. ## Becoming Better Places to start: * Github: &lt;https://github.com/&gt;, there are plenty of projects that need people's help (even if it's just advertising or trying things out). * Join the official Ruby IRC channel, \#ruby-lang on Freenode. You can ask questions in here as well as being able to learn from other people's questions. Don't be afraid of: * Writing ugly code or making mistakes, everybody has to start somewhere (and we've all been there). * Asking questions. While you should do some research before raising your hand and asking a question you should by no means hold back thinking you'll be mocked. Assuming it's not some arbitrary question such as "How do I write poop?" people are more than happy to help you. Do: * Practice, a lot. * Contribute to open source (also known as "open sores") projects, even if it's something simple such as checking for spelling errors. * Go to conferences, talk to people, preferrably ones that are smarter/have more knowledge than you. * Take existing projects apart so you can learn how certain problems were solved (and which ones weren't). Don't: * Reply "tl;dr", I'll beat you with a large trout until you've read this properly :) I've probably missed something so if anybody else has some information feel free to address this.
I had a lot of trouble starting up as well and by no means am I an expert now, but it might help to think of things this way: The files are accessed based on routes. Routes are URL strings. So based on the URL string, the associated controller/helper/model/view is accessed. &gt; mydomain.com/products This basically uses the controller named products_controller.rb, the model product.rb, the helper products_helper.rb and whatever view is associated with the HTTP verb and specification based on the route. So for example /products essentially refers to ALL products; i.e., the index. So /products uses the index.html.erb view. /products/1 would use the show.html.erb view because you're showing a specific instance of the product, not all of the products. You can learn about the other views from tutorials on the web. This logic also applies to within the controller. You'll see different methods like "create", "update", "new" etc. These all map to the HTTP verbs. So when loading a form to create a new product, you'd use the "new" method/view. When submitting the form, the "create" method is utilized. Notice how there's no "create" view? That's because typically you redirect the user at the end. You don't need a separate create view. HTH
I read that as &gt;I do wish RVM death Slow and painful, preferably.
After a few misadventures with rvm, I switched to using [rbenv](https://github.com/sstephenson/rbenv) with [ruby-build](https://github.com/sstephenson/ruby-build) installed as a rbenv plugin. Overall, I've found it easier to keep updated on both the ruby versioning tool as well as new ruby releases themselves.
I disagree that they are part of the learning process. That is like buying a car and having it break down on the road, then having to repair it yourself is part of the learning process for driving a car.
I totally agree. I switched because I couldn't stand the slowdown (however minute) from the rvm cd script. It always felt a little bloated and invasive to me. Now that bundler is the de facto standard for managing gem dependencies I see no reason to look back.
In my experience, Rails development on Windows is not happy fun times. I'd stick to Ubuntu and figure it out, especially since deploying to Ubuntu is fairly standard with Rails. 
I fully agree. While RVM is a good tool, i found a lot of my woes with Ruby went away once I switched to rbenv. Just remember to rehash those shims!
You are learning to be a mechanic, not a driver. Edit: I upvoted because people should see some of the good responses against this kind of attitude towards learning. Also, not everyone is learning to be a rockstar developer. Cut him some slack.
This is a big over simplified. &gt;/products essentially refers to ALL products This is indeed true if its coming from a GET request, however the same URI would be responsible for creating a new product if done through a POST request. It's important to familiar ones self with Rails' implementation of REST, as it's essentially what turns the wheels of a Rails app.
Go on #rubyonrails on irc (freenode.net) and ask specific questions about the problems you are having. Someone there should be able to provide you with specific answers in realtime, which should make this much easier for you.
Ah I wish I'd checked back sooner! I wasn't expecting such a kind response. Maybe tomorrow if you're still available alexcp? And I agree coderjoe, pretty blown away by how helpful people are here on Reddit!
Nice rant, but what tickets were filed for the problems encountered?
Rails specific questions belong in /r/rails.
One-click setup of PHP...which PHP are you using? I remember trying to get a WAMP stack going and having to manually edit the apached server config file to get it to run took hours of Stackoverflow and google searches.
If you are on Windows, you should be using the one-click [RailsInstaller](http://railsinstaller.org/). It installs everything you need and gets you up and running in 5 minutes. If you are on OSX, you should use the excellent [Laptop](https://github.com/thoughtbot/laptop) script. Both of these make getting Ruby + Rails running super easy. If you are set on developing in Ubuntu, I would recommend running RVM, then installing the latest ruby, then 'gem install rails'. With a few exceptions, this should be all you need to do 90% of the time. **[Make sure you install all the RVM/Ruby dependencies in Ubuntu before you install RVM!!](http://ryanbigg.com/2010/12/ubuntu-ruby-rvm-rails-and-you/)**
I forewent using any sort of version manager and just did a 'brew install ruby.' Am I going to get myself into trouble this way?
I've always found Java's standard library to be very efficient. What are you referring to?
I have been doing the same thing for about 6 months. I had never really used ubuntu before, so learning a new OS while also trying to learn programming is a big learning curve. The problems you are having *IS* the learning process. Me too. It's frustrating as hell, but that's your choice to go through the crap or to give up. I choose not to give up. Rails is certainly not n easy thing to understand. After 6 months of digesting everything I could get my hands on (I started with railstutoial and didn't understand a thing when I got finished), I still can't create a rails application from scratch on my own. I have put rails on hold for awhile and have gone back to learning Ruby. You will never be a good Rails programmer unless you are first a great Ruby programmer. There's lots of great resources on the web for it. RubyMonk is one I'm doing right now and really think it's done very well for beginners. I'm sure when I'm done I can find whatever method I need through the Ruby API docs. I dual boot windows7 and ubuntu 12.04. I have ruby and ruby on rails installed on both partitions. But I am trying to do all my programming in Ubuntu just to get the habit down. I use an eclipse-based IDE for my rails dev because I like seeing the directory tree to find files, but I am trying hard to learn gVim because so many have sworn by it being a much faster way to develop, and ultimately that's the goal. Find ways to motivate yourself in the face of failure. "Success is the ability to go from one failure to the next without the loss of motivation." -Winston Churchill
Not unless you need to run multiple versions of ruby at the same time. Having a single clean ruby install will save hours of grief in the future. I'd love to ditch RVM and rbenv but my job requires me to use ruby 1.8.7 
what did you like about rbenv vs rvm
Well, since I'm on OS X I actually have 1.8.7 (the default) and 1.9.3 installed side-by-side. 1.8.7 is at its default path at /usr/bin (and I have lots of shell scripts whose #!s point there) and then 1.9.3 is in my cellar. Seems to be working pretty smoothly so far.
I can't speak to its efficiency. I was referring to the overly complex design of the API. Things were not as simple as they should have been, or consistent in any way. Of course, it could have been redesigned since I last saw it -- when it was still pretty much the same as the original Smalltalk core libs that it had been ported from.
Not just here! Every new Ruby developer should check out their local users group! So many people don't take advantage of them, and I've never not been impressed. I just wish my local groups were at times where I could more regularly attend. :(
Oh p.s. I don't need you in chat, I was just commenting that it was nice for you to help out someone in need. I'm a fairly long time ruby/rails/ubuntu user as well. Wanna share [dotfiles](http://github.com/coderjoe/dotfiles)? :P
It's all about finding the best resources so it's good the OP asked. The best installation guide is [Installing Rails on Ubuntu](http://installfest.railsbridge.org/installfest/ubuntu) from Railsbridge Installfest. Also read this: [Read This Before Installing Rails 3.2](http://railsapps.github.com/installing-rails.html) as it explains Rails is part of a complex ecosystem. Often, developers install Rails but neglect other components needed for Rails to run successfully.
I believe Ubuntu provides 1.9.3 packages? Also, why not Fedora? Fedora 17 provides 1.9.3 as the default version of Ruby.
you should be able to run "rvm use 1.9.3 --default" without adding it to .bashrc. Adding it to .bashrc should work as well though.
The one bug you linked to was resolved in 1.9.2. You also mentioned Date was cleaned up in 1.9.3. I hope you're not still using 1.8.7? Fellow Rubyists, if you find something ugly/wrong/broken in stdlib, please submit Bug Reports to http://bugs.ruby-lang.org/projects/ruby-trunk. _Small_ changes can also be submitted via a Pull Request to https://github.com/ruby/ruby. Blog posts are great for sensationalizing issues, but Bug Reports and Patches get things fixed. Unfortunately, the plan to [gemify stdlib](http://bugs.ruby-lang.org/issues/5481) has been targeted for Ruby 3.0. I think the community should pressure ruby-core to begin creating gems for stdlib libraries (like [Rake](https://github.com/jimweirich/rake)) before their removal in 3.0.
I'm new to Rails and I feel the one thing lacking is detailed documentation in a single location. If the Rails community could take a page from Django, total bliss.
Thanks thoughtpunch! Yep, going to do that now, that's great advice. Hope it's not complicated for me to understand, haha. 
This really helps, going to fix my code as well now; using methods and classes... those ugly whiles and ifs... didn't know there was another way around! Ha, I definitely am a massive beginner. Thanks so much!
All, this is my first real interaction with the community and I am absolutely dumbstruck on how helpful you guys are. Thanks so much. 
Please, I hope more people come around to this. Cucumber is a cancer. It's one of the worst ideas I've ever seen. It feels reminiscent of the XML cult heyday when people were trying to make XML do *everything* and we had to live with XML-RPC and XSL for a while. Rubyists have a different urge -- they want to make cute, clever DSLs for everything. Unlike XML and its offspring, that's been generally a very good thing, but cucumber isn't a DSL, and it simply makes testing much more difficult and less maintainable. Writing your tests in English, then parsing that with regular expressions to construct a test is just ridiculous.
rbenv is a simpler tool that does what I need. rvm does a lot more but adds complexity to achieve that. I didn't have lots of problems with it or anything like that, however I think rbenv is the better tool unless you need rvm's complexity.
I highly recommend using [Fedora](http://fedoraproject.org/) over Ubuntu. Fedora 17 provides packages for Ruby 1.9.3, RubyGems 1.8.24 and Rails 3.0.11. $ sudo yum install ruby ruby-devel irb rubygems $ gem install rails $ rails new blog **Edit:** for the most recent version of rails, run `gem install rails` instead of `yum install rails`. 
Yes, I know. I don't care about users. I've only been doing UI development since 1998. I have a lot to learn. And apparently matching random plaintext gherkin statements to brittle regexes is one of those things I need to learn. Or instead, I'll just speak to the product manager a few desks away and then write code and real actual tests.
Don't tell Larry Wall....
We need tools to make testing easier and faster not more complicated, verbose and slower.
The important part is that management or at least business analysts can *read* the tests and agree whether or not they describe reality from their point of view.
lol u just got OWNED by rubygeek, HARD!
&gt; Readability isn't the same thing as being able to write it though. Exactly. Which is why the complaint I addressed is not really about cucumber but about horrible practices at the company in question. Why were management writing tests? They should not be writing tests regardless of language. Anyone giving them a shot at actually writing the test cases should be taken out and shot. Even if you were to manage to invent a *syntax* they'd be able to comply with, they'll end up structuring things all wrong, as his experience showed. To quote from the Cucumber website: &gt; Cucumber lets **software development teams** describe how software should behave in plain text. The text is written in a **business-readable** domain-specific language and serves as documentation, automated tests and development-aid - all rolled into one format. My emphasis. The point is to be able to have a conversation with a stakeholder, write a test, and then be able to have the stakeholder give a *meaningful* confirmation about whether or not the tests matches their understanding. &gt; Rspec and Capybara you can achieve a much cleaner and very very readable set of unit tests. Readable to software developers. Not readable to business analysts and other stakeholders. I challenge you to find non-technical users that can read more than a tiny fraction of tests written using either. They are solving a different problem, and a much lower level one. And Rspec or Capybara and Cucumber are not mutually exclusive. The meat of your Cucumber tests should be in the step definitions, not in the scenarios. Pretty much all of my Cucumber tests rely heavily on Rspec. The scenarios are succint and to the point documentation and composition of the steps, to force the business-readable description to be in sync with your actual tests, nothing more. The steps should contain all the hairy details that'll make your business analyst hide crying under a table. 
I did not expect this level of Cucumber evangelization. I believe the point the OP was trying to illustrate, is that it's far easier to have someone simply read a Word Document describing the behaviours, and write the appropriate tests. After all, humans are far more skilled at parsing/pattern-matching natural language. Even though you've shown you're affinity to Cucumber, can we agree that the extra layer of Regular Expression pattern-matching can become troublesome, especially for developers new to Cucumber. All of those "you're cuking it wrong" blog posts must have originated from real-world pain. &gt; Complaining about Cucumber because it breaks down if you let non-programmers write the tests completely misses the point. I think this highlights a misconception of Cucumber held by some Rails developers. That it is a way of involving non-developers in the planning of applications, that requires no training or adherence to a syntax.
I believe you are mistaken. rubygeek did not "own" me. He simply posted a lengthy and well thought out comment.
http://www.urbandictionary.com/define.php?term=owned
Gems are no panacea. They often get abandoned or a dozen forks appear each with a slightly different flavor. There is no quality control on the gems it's wild wild west out there. I would go with gems if there was somehow a blessed repository where there was strict requirements for quality, documentation, consistency and compatibility. But there is no such thing. You cross your fingers and pull something hoping it works and then spend thirty five hours trying to figure out why the samples in the "documentation" don't work. Then you have to read the entire source code and try to figure out if you are messing up or if there is a bug. To make matters worse most gems don't have a mailing list where you can ask questions either. 
&gt; however this benefit assumes that you're going to have business people reading your tests It does. If you're not going to use them as documentation of the agreed features, in order to get business people to sign off on them, then I wouldn't use Cucumber. &gt; Cucumber is often sold as being for this purpose (regardless of whether that was the author's intent), which is a horrendously bad thing to do We agree that's a bad thing to do.. I must admit I've tried on occasion, with fairly technical (but non-coding) business people, and the only good thing to come out of that is to drive home just how big the disconnect in thinking is... 
Actually, are there any in that list that people could point to and say "This is the right way"? I'm going through the list, but I'm not seeing much that I like. Many of them don't seem to be testing anything significant -- stuff like logging in and seeing a home page or some other page. The best one I've found so far seems to be Jekyll.
probably rspec-core. Integration testing really tests the happy path. It is hard to let go of the ocd test every edge case vibe that you use for unit testing.
Sounds like propaganda. We make our clients write the user stories at work, and that has proven to be pragmatic (not just theoretical). 
This! If your not doing it this way your going to have a bad time.
&gt; Give him back a first pass of tests written in Gherkin and ask if they matches the analysts understanding. So there's no _guarantee_ that the gherkin you give him accurately describes the test -- it depends on the step definitions being accurate, correct, and a correct implementation of domain knowledge expressed in the gherkin. So what's the plus with gherkin, as opposed to writing the test in code, and giving him the cut-and-pasted comments, or otherwise a separate english language summary? Yes, doing that depends on the comment accurately representing the code -- just as cucumber/gherkin depends on the same thing thing, with the same (and more) places for it to be errantly disjoint. 
This has confused me too. Is there any way to turn OFF "multiline mode" for ruby regexen? This is really confusing because the ruby docs say: http://www.ruby-doc.org/core-1.9.3/Regexp.html &gt; /./m - Any character (the m modifier enables multiline mode) Okay, so if the /m modifier _enables_ multiline mode, this implies it's not on by default.... okay, so what the heck does "multiline mode" MEAN to ruby? To other languages, part of 'multline mode' is that ^ and $ become newline-matching instead of start/end-of-string matching. But in ruby this is true even without multiline mode? So what the heck does multiline mode do in ruby? Even if you think the current behavior is correct and appropriate -- there's DEFINITELY a documentation failure here. It is hard (impossible?) to figure out how ruby regexen work in terms of newlines from the docs. 
&gt;I use an eclipse-based IDE for my rails dev because I like seeing the directory tree to find files, but I am trying hard to learn gVim Consider a happy medium between an IDE and vim, like Sublime Text.
The important takeaway is that "dependency injection" in ruby means nothing but proper seperation of concerns combined with setting objects as arguments (whether to initializer or elsewhere). Which _is_ a useful pattern, don't get me wrong. But it ain't some complicated configuration-based thing, and certainly doesn't involve any XML. 
yeah, really ugly and dump, it was the kind of stuff that i forgot to refactor before publishing.. when writing a blog post we just use the other side of the brain :P sometimes it happens. i've changed the ternary conditional to jsut @power == true someones think that @power is just enough, but i use power == true by a personal taste hope you enjoyed the article about dependency injection, this was the main purpose of it thanks for the feedback
I hate cucumber as well, but you're never going to change peoples minds if they enjoy it. Use your energy on something else.
&gt; At one point, Cucumber was the only way anyone knew to do good integration testing, I think that's part of why it caught on. This is exactly what I have seen. It's just a more cumbersome way to run integration tests.
Considering the state of the standard library this seems like a non starter to me. 
+1 I agree, not only is a lot of stdlib code bad (inefficient) it's also non-idiomatic ruby. Perhaps a lot of it was written before many now common ruby idioms even existed.
I truly feel sorry for the souls stuck in enterprise hell. Java, Windows servers, Oracle SQL... Makes me sick just thinking about it. 
Kind of jumped the gun on Rails.app?
For fucks sake I had a bad time!
for fuck sake, if you don't have anything to actually contribute to the conversation besides fixing typos, then don't contribute at all. And yes, I downvoted myself for this comment because it isn't on topic.
obviously.. stupid question on my part.. we should just create more languages that compile down to other conventional/standardized languages
It's simple: * Always start with \A \z * Never use \^ and $ unless you explicitly need this special behaviour (which is just about never).
yeah I recently heard that Sublime has a really great ruby/rails plugin that helps speed up development a lot. I will be trying it out. 
Regex modes were always a stupid idea, so Ruby did a great thing getting rid of one of them and replacing it with different zero-width assertions. Sadly they took the wrong one to be shorter (line instead of string), and now it's impossible to reverse this.
"Deriveration" is not a word. Did you mean: Derivation 
Yeah I was thinking the same thing. I think katz wanted to put more stuff in there?
If it's a much bigger issue then nominate libraries to be removed from the stdlib that can be replaced by gems on http://bugs.ruby-lang.org. iconv has been removed for ruby 2.0 (it was deprecated in 1.9) and it looks like syck will be removed too (definitely not worth fixing). Complaining about it on reddit is not going to improve things.
"r00t owns you!" 
I actually used `^` and `$` this morning. _shrug_
* 0wnz j00
http://rubydoc.info/stdlib There cannot be alternative gems for every one of those libraries, and the majority of gems depend on at least one of them. I agree stdlib should be gemed up, ahead of Ruby 3.0, to lower the bar for contributors. Ditching stdlib and switching to alternative gems (if they exist), is a reactionary response.
Thank you so much! What a fun site! Any opinions of http://www.highercomputingforeveryone.com/ ? 
No. It is not possible. You are either born knowing a programming language or not. There is no way you can possibly learn one, it must be innate to your specific DNA.
If anyones eyes gloss over, the scenarios in question likely contain too much irrelevant detail. If they don't read like a short, succint statement of what is required of the product, then they're broken. If your stakeholders can't handle reading a sort, succint statement of what their product should do, then you have a bigger problem. 
That appears to be focused on C, which is something I can not in good faith recommend to beginners.
Awesome! How long did it take you and with how much knowledge did you start? 
It's a great language for beginners because it supports two major programming paradigms that you might come across in the real world (OO and functional). Once you learn Ruby and some of the important pieces of the API you can easily take that knowledge and learn other languages. Another benefit is that it integrates very well with other languages as it has been implemented in other VMs like Java (through JSR-223 as JRuby) and .Net (through DLR as IronPython) so you can put ruby code inside a .Net or Java application and use the libraries available to these languages. It also integrates well with C and C++ (via Rice) so you can write extensions that call C and C++ libraries. You should check out Pragmatic Programmer's [Learn to Program](http://pragprog.com/book/ltp2/learn-to-program) book which is an absolute beginner's guide to programming using Ruby as the language of instruction. Of course learning Ruby does not make you a programmer. You'll need to have a good grasp of algorithms, data structures, regular expressions, and concurrency which will all become second nature to you once you've put on the hours working on programming projects. You'll also need to have a programmer's mindset which is basically having the ability to break a problem down to its smallest components which you already do on your day to day life but most likely not aware of them. 
What's not to get? I realized when I wrote the question that I was leaving myself open there. Are these resources good for an absolute beginner? Okay, so I used to be able to do HTML by hand in Notepad (haven't done in years) and basic CSS too. But that's the end of it. 
If it's good enough for Google to steal it's good enough for everyone. 
If enough people are interested I can get a VirtualBox VM image up with Ubuntu and Rails to share with people. 
That may have been over the top, but I had never *seen* an actual good use of cucumber in a real project before. All the tutorial examples I'd seen seemed contrived, and the real world examples all became unmaintainable messes. (And I am currently dealing with one of those messes that I inherited in a project I'm working on.) See the comments below where ballscockr pointed me to it's usage in rspec-core. In that case, I will concede that it seems somewhat reasonable, because they're using it in a very limited way with an extremely limited vocabulary. They only have a few step definitions, and all of the complicated 'Given' stuff is all rspec code. But I'm struggling to imagine how to apply this to testing web interfaces, which is where I have always seen it used. Web UIs are a lot messier to test than command line tools, and I'm not sure how you could boil down your step definitions to the level that they would be maintainable. But I am genuinely interested in seeing examples of the "right way" to test web UIs.
http://yehudakatz.com/2012/04/13/tokaido-my-hopes-and-dreams/ It will (hopefully) be useful in more ways than just RailsInstaller provides. Really great that Rails is getting easier to get started with again on OS X.
That's how I started. I took the typical nerd path in high school with heavy science and math and a programming course was my first college course. I remember being frustrated that the computer is so exacting. It only knows what you tell it. It's not like oh teaching your favorite chocolate chip cookie recipe to your friend. It doesn't have a clue about "what you meant" when you make a typing error or place an instruction in the wrong place in the sequence. It's definitely possible but it really helps to be patient, very patient and able to tolerate some frustration. And when you are frustrated, you are not discouraged and throw up your hands. Instead you are motivated to keep trying and to keep getting better. Looking back I don't think my math and science path in high school helped me all that much with learning programming. Ruby is a good language to start with. But as soon as you're able to craft small programs and understand what's going on, I'd detour into C and assembler - it'll help you understand how a computer really works and better appreciate really high level languages like Ruby and Python. And no programmer does themselves any favors by not studying some Lisp the mother of all dynamic programming languages. It's still hard to beat Lisp today - a language first conceived in the late 1950's. By the way check out Zed Shaw's "Learning to Program the Hard Way" series. It's free and online. Just google it.
scss solves problems that css has. The lack of variables for example. coffeescript solves problems that javascript has. Variable scope for example. Both introduce new problems - you are inserting a extra stage into compilation, and it may at times hinder debugging. You just have to weight up the tradeoffs. I don't think the learning curve is really that steep for either. JQuery and coffeescript aren't comparible. They do different things. I use jquery with coffeescript all the time. It doesn't seem like you've properly looked into this.
Nope. People are either born knowing how to code, or go through their lives in complete ignorance :D Sorry, but you walked into that one. The only problem with ruby as a first language is that every other language in the world is ugly and clumsy by comparison, so you'll spend a lot of your life facepalming when you have to use them...
Why not? We all had zero programming knowledge when we started programming.
Locate your nearest plasmid distributor. Probably a good starting point.
Getting started is definitely one of the biggest hurdles! The best thing to do is find someone to help. [The Rails Hotline](http://www.railshotline.com) is a great, free way to connect with someone who might be able to get you going. The Ruby community is full of kind people wanting to help (MINASWAN), so don't be afraid to ask around. All the best! Hope you are able to get it going.
Ruby Koans. 
Of course, every person who knows how to program started out not knowing. If you want to learn C, as I'm seeing you might by some of your comments, then you should pick up a copy of [The C Programming Language by Dennis M. Ritchie and Brian W. Kernighan, second edition, ANSI C](http://cm.bell-labs.com/cm/cs/cbook/). The first chapter of which is an excellent tutorial introduction to programming in C. As others have mentioned, Ruby is definitely novice friendly. [TryRuby](http://tryruby.org/) let's you try it in your web browser. There is an on-line copy of the first edition of the book [Programming Ruby](http://www.ruby-doc.org/docs/ProgrammingRuby/), by Dave Thomas, at [ruby-doc.org](http://www.ruby-doc.org/). **Edit**: oh yeah, there's also a free book on C programming called [The C Book](http://publications.gbdirect.co.uk/c_book/), but I have not yet read it. It should be pointed out that the aforementioned "K&amp;R" book was written by the author of the language.
+1 for your username 
As a beginning programmer, there is a lot to be said for actually making shit as opposed to trying to figure out pointers and linked lists and things :)
Recently, it's been a trend for people with zero background in computer science to suddenly decide to learn this particular skill. (I saw in a blog post expressing a similar sentiment that Michael Bloomberg is learning to code? WTF?) I'm torn on this, because, on the one hand, learning to code is a great skill to have and it can be extremely rewarding. The most extreme example of this I've got is a personal friend of mine who was contemplating suicide because life sucked and he didn't think he had anything to contribute to making it not suck. Games were all he cared about, so I encouraged him to learn how to write code and try his hand at making them. A few years later I found out that conversation was crucial in his decision not to take his own life. But on the other hand, coding is simply not for everyone. You need an inquisitive mind, an endless passion for "This could be made better and more efficient", and an extreme tolerance for "WTF? Why isn't this working?" And because so many of the most important traits of a good programmer are really just aspects of personality, I often wonder if the best advice to beginners is to make sure they've got a reason to learn this skill first. My friend had a damn good reason to learn it, even if some might think it frivolous. But I think there are also a lot of really awful reasons to learn the skill. Someone else I know chose Packaging Science as their first major because the median income post-graduation was comparatively high relative to the level of effort he expected to expend in that career. When he found out how much chemistry was involved, he decided that was too much work and switched majors to Computer Science. As far as I can tell, the same rationale was used in that selection. I wanted to punch him. What a waste of good talent. If you choose to learn programming, your level of success will be determined by who you are and what you care about. Choose for the wrong reasons and the people who chose for the right reasons will want to hurt you when you attempt to "collaborate". Choose for the right reasons and everything you craft has the potential to make the world a better place, one tiny line of code at a time.
Q: "Where do I start?" A: 1.) Install Ruby 2.) search online (or in a book) for "irb" 3.) type "irb" Have fun!
[Watch out...](http://imgur.com/gFD5o)
:P I swear, it was legitimate! I used `/^&lt;!-- @(\w+) +?= +?"(.+)" --&gt;$/` to match metadata lines in markdown files, like these: &lt;!-- @title = "Using the Datacolor SpyderCheckr for Real Estate Photography" --&gt; &lt;!-- @description = "In this post, I detail the benefits of using the Datacolor SpyderCheckr, how to use it, and why I chose it over the X-Rite ColorChecker Passport." --&gt;
TL;DR for long running processes JRuby 1.7.0.preview1 on JDK 1.7.0_04 seems to be twice as fast as Ruby 1.9.3-p194. It would be nice if someone could verify this :) 
Definitely agree, I just figured I would present the other side of the argument.
Non-technical individuals can also read the output of RSpec as well.
I've just released a simple gem to help create and update rails models using multiple roles. Please check it out. Feedback will be appreciated.
The community prefers to reinvent rather than to improve existing libraries.
Can't jruby start up times be improved by nailgun?
If you put as much effort into the stdlib as you do option parsers there wouldn't be posts like http://architecturalatrocities.com/post/23659800703/the-ruby-standard-library-is-a-disgrace
I've been pretty hit and miss about tests. But then I was put on to "Growing Object Oriented Programs Guided By Tests". Despite being Java based the book is excellent and what it shares can be applied very well in the ruby world.
What?
You might want to cross post this in [r/rails](http://reddit.com/r/rails).
I also have had a difficult time getting into tests; most of the tutorials make it seem so easy, but as soon as you run into something slightly off the "hello world" path, I can spend so much time fighting with the testing environment trying to get the tests to test what I think they ought to. I'm still not great at it (at being good at _or_ disciplined about writing tests), but am getting better... * I've had more success cutting out ALL of the extra fancy stuff. No cucumber -- but not even no rspec. Just plain old Test::Unit. When with Rails, trying to just follow what's in the [Testing Guide](http://guides.rubyonrails.org/testing.html) and hope it's bug-free and complete -- it [isn't always](https://github.com/rails/rails/issues/6573), but at least I avoid fighting with a whole extra layer of abstraction and can [ask for help](https://github.com/rails/rails/issues/5193#issuecomment-6078633) or report problems without having to reference extra layers of abstraction. * Sometimes things are less convenient with straight Test::Unit, my tests are probably somewhat less elegant to read than they could be -- but I figure eventually if I go back to rspec, I'll understand _why_ I'm using it, what it's doing for me over bare bones Test::Unit, and appreciate it (as well as being able to learn it layered on top of a good foundation of how-to-write-tests knowledge)-- instead of feeling like I'm spending all my time fighting with the tools trying to figure out how to make them do what I want. * So far, I've been happier with my Test::Unit path. * Yes, I'm even avoiding FactoryGirl, and just using plain old Rails fixtures as documented in the testing guide. If it starts giving me pain, i'll at least understand _why_ and why I want factory girl, instead of just being another thing to learn and fight with. But so far I haven't used much fixtures either -- I avoid anything requiring such things where I can, and occasionally actually just plain manually create AR instances in my test code -- I already know how to write code to create persistent AR instances, it's not fighting with learning some new something. And it mostly works out. * And I've found some success writing my tests based on "Well, what was I (or would I be) testing 'manually' in irb or a web browser before I was (or if I wasn't) writing tests? Okay, just write some code to test _that_, just the things I was doing manually but automated, so I don't have to do it manually every time I change code that might effect it." By sticking to that path, the actual _immediate_ time benefit of writing tests becomes more obvious so it doesn't seem like such an 'eat your vegetables cause you know its good for you' kind of chore. (It also has led me more or less 'naturally' into TDD in _some_ cases) * And definitely starting a project _from scratch_ with testing is way easier than bolting them on to an existing project. Adding tests using the above mentioned approaches to an existing under-tested project is possible too, but has often been way more of an unpleasant struggle for me. Sadly, of course, one's job often entails a lot more existing projects than brand new ones (unless you're a consultant who can abandon your clients with your technical debt, heh). But only by starting with a project from scratch was I able to start experiencing actual _joy_ in writing good tests, of the kind those of us who love programming get from writing other kinds of good code. Which has led me to slightly better motivation (and competence) at writing tests for those 'legacy' projects too. 
same reason it has so many "configuration" gems. It's something many people need, but it's hard to write something that actually meets everyone's needs, although lots of people _think_ they can and keep trying, convinced theirs will finally be the thing that works well for most everyone. I agree it's unpleasant, I'm just answering your question as to 'why', I've thought about this before too. 
Hmm, I knew thor powered `rails generate`, does it really power all the rest of `rails X` too? I had thought of thor as a a tool for writing 'generators' (command line applications mainly focused on generating files), not a tool for writing general purpose command line applications. Have you found it useful otherwise? Going to look at the 'thor' readme, it does seem to claim more universal/general applicability. hmm. 
Testing isn't hard, you have a method that takes an input and returns an output assert_equal output, my_method(input) If you can't express you feature in methods like this then change your code so you can. Start from the basics first. You don't need RSpec, you especially don't need Factory Girl. Factory Girl, Machinist, even heavy use of fixtures is an indication that your code is broken, it is a sign that your code is tightly coupled. Testing isn't just about ensuring your code has less bugs, it's also about enforcing good design. Code that is hard to test is badly designed. 
thor powers the entire rails CLI, and is a general purpose framework for building command line utilities. Rails includes its own generator framework and that has nothing to do with thor.
Factory Girl isn't a sign your code is broken. Unless you think having validations is a sign of broken code. Or you think doing something like: User.create(:username =&gt; "John", :email_address =&gt; "john@example.com", :password =&gt; "password", ... snip all the other parameters that need to pass validation) Is cleaner than: Factory :user 
Do you need it in bullet points or are you just playing dumb?
What are you testing that requires you to instantiate a User object? The only thing that needs to know about User is your user unit test. Using Factory Girl for that are you? But don't believe me... http://twitter.com/avdi/statuses/181806995752501248 https://twitter.com/avdi/status/181813919160086528 Idiot.
I was with you until the insult. Not everybody starts their life as a coding god like you apparently did.
Think about writing tests as enumerating all of the edge-cases of your code. If you're using RSpec, you would use `describe` / `context` blocks to group tests by which edge-case they are testing, with setup code going in a `subject` or `before` block. I try to avoid FactoryGirl, Machinist and Cucumber, and use plain RSpec. Whether you prefer RSpec or Test::Unit, only use additionally testing libraries when there is a clear need for them.
Growing Object-Oriented Software, Guided by Tests is a great book that teaches how to write (good) tests. Yeah, the Java is somewhat of a pain, but the book is nevertheless outstanding.
Can we please stop re-inventing the wheel of option parsing? It's not even a wheel worth re-inventing every time.
&gt; Rails includes its own generator framework and that has nothing to do with thor. Not true, the generators are Thor too! [Rails::Generators::Base is a subclass of Thor::Group](https://github.com/rails/rails/blob/efb75f774a5d7383d876e1f377a9cf5396e6ffdb/railties/lib/rails/generators/base.rb#L18). It's helpful to know that if you're writing your own Rails::Generators, which is how I am aquainted with it. The [Rails Generators Guide](http://guides.rubyonrails.org/generators.html#creating-your-first-generator) is also clear on it -- which is how I first heard of Thor. Mostly Rails::Generators::Base just adds it's own actions, and it's own defaults for certain things, it's pretty much just a Thor::Group. The confusing thing when I was figuring out what was going on was at first, Thor::Group was under-documented, but now at least there's a [wiki page](https://github.com/wycats/thor/wiki/Groups). 
Having written [the book on Ruby command-line apps](http://www.pragprog.com/titles/dccar), I implore everyone to stop writing new option parsers. There are so many, and almost all of them are degenerate in some way. Those that try to simplify OptionParser do so by killing features. Those that try new syntax invent even more complex syntax than OptionParser. OptionParser is super powerful and not that verbose, but if it's too verbose, please check out [Methadone](http://davetron5000.github.com/methadone), which i wrote during the book and has **all** of OptionParser's features and none of the verbosity. And no ridiculous metaprogramming. Secondly, for command-suite apps like `rails` or `git`, I should warn you that Thor has a very limited feature set, poor documentation, and generates a not-very-friendly-or-canonical command-line interface (last I checked, options had to come at the end of the command invocation or they are silently ignored; I hope that has changed). Please consider commander or [GLI](http://davetron5000.github.com/gli) (which I also wrote) I realize I'm plugging my own open source projects over some other one, but I do believe that my tools are objectively better for writing command-line apps. I use them frequently, in heavy production, and maintain the code and documentation on a regular basis.
Update: added memory usage charts - JRuby needs way more memory than Ruby.
Ruby's open source. You see a problem or an area lacking in stdlib? Fix it yourself. Submit a patch instead of unproductively complaining.
By that I didn't mean that the Rails generators aren't based on Thor, I meant that Thor is not itself a rubigen-like code generation tool and that Rails generators are implemented by Rails and not provided by Thor. I guess that was poorly worded.
Thank you so much
Cool thanks
Excellent, thanks for linking this.
Wow, thank you. Do you use this skill as a job now or do you plan to in the future? 
There are more things than just unit tests. How do you plan on doing integration tests without a user model?
I think every programmer, at some point, will write a command line or option parsing tool. It's like a right of passage. I still think yours are the best though, and the only reason I don't use methadone is that OptionParser is suitable and always available without requiring an extra gem. Thanks for GLI too.
Great, thank you!
+1 "Test Driven Development By Example" is the bible of TDD. Highly recommended for everyone interested in writing tests.
We have a [Test-Driven Development Trail Map](https://github.com/thoughtbot/trail-map/blob/master/trails/test-driven-development.md) (free) that currently recommends: * Read "Test-Driven Development By Example." by Kent Beck ($). * Read "Beginning Outside-In Rails Development with Cucumber and RSpec" by Jared Carroll (free). * Refer to "xUnit Test Patterns" often. It's a work in progress. We're [hoping for pull requests](http://robots.thoughtbot.com/post/23991486237/trail-map) from folks like yourself to help improve it. 
I didn't start life as a coding god, it took me over 10 years of TDD in a variety of languages. Today I don't write a single line of code without having a test for it. I use Machinist every day, that's because the app I'm working on has huge problems with coupling because of poor design. It's a f**king nightmare. The impression I got from the OP was that he's learning RSpec and FG because he read somewhere that that was the cool thing to do. He hadn't even figure out simple testing yet. When you are starting out, learn to write good tests without Factory Girl and you will be in a much better place.
No, english will be fine.
That's the price that comes with having dependencies. The price of using a library is that you need to know how to use the library and how to test with it. There are different ways of testing code with dependencies: * functional tests using the whole application * unit tests that test your code but exclude the dependency * mocking the dependency with either code based mocking or somehow emulating the dependency There's no easy way round it, having dependencies makes code harder to test. Luckily the price is usually constant per library, you just need to figure out the way to get tests to work and the same approach works for other tests also that use the same functionality. 
We did a similar thing at my last job. It requires discipline, and an understanding of why you need cucumber higher than just "let's use this new thing", but it can work very well for client projects.
Sorry if you have trouble parsing sentences that contain multiple phrases. Wait, sorry, that one had multiple phrases too. Back to bullet points then. I'll try to keep each one to a couple of verb phrases and as few relative clauses as possible. - He is working on a project. - You want him to work on another project. - You are criticising him for not doing so. - You are also not working on that project. - That is being hypocritical. - You think you can tell other people what they should spend their own time on. - That makes you an asshole.
why do u tell lies
My system RExec does similar things but it is very lightweight and focuses on distributed Ruby code rather than trying to transport objects from one process to another: http://www.oriontransfer.co.nz/gems/rexec
1. It's considered rude to advertise a competing project on another project's thread. 2. Something really gimmicky and weird about your website, i think it's the stars..but really, just a weird almost creepy feeling i got when visiting it. The only thing it's missing is new age music playing in the background. 3. I notice you don't have an obvious github link for your project, nonetheless i checked out the source --- and it doesn't look/feel like idiomatic Ruby, your formatting is messed up and some of your code just looks weird. In summary, i get the feeling your code comes from a strange lonely place, little lost boy programming in the dark.
When things go wrong in ruby it is usually very simple and straightfoward to figure out what. When things go wrong in C, as a beginner you can spend hours just solving a very simple bug or typo.
I think you were downmodded unfairly so I gave you an upmod but you really should put your stuff up on github and document a little. It sounds like you have some interesting gems.
Mm, I suppose the alternative is C++ style this-API-does-everything-if-you-set-the-right-flag interfaces Ryan Tomayko on Twitter did mention they didn't like including a dependency just for command line options, which is a valid argument IMO https://twitter.com/rtomayko/status/209553434288979969
I have a weird issue with my work PC that BSOD's with VirtualBox every time, so I was forced to take the tough route. It is worth it in the end but it took me a few weeks and two 'I give up' moments before I could even start on a tutorial. This was before I even decided if I liked Ruby, let alone Rails. The moral of the story is, use a VM.
Only Lion that too :\
+1 for Mou. Also if you're feeling lazy and editing a few lines, you can use the web editor on GitHub and use the "preview" mode.
Rails specific posts belong in /r/rails.
It's not that hard. Just write the closing tag immediately after the opening tag, or setup auto-completion for your text editor.
&gt; Learning something new is never a bad thing. You somehow managed to turn discovering new things in Emacs into a point against it anyway. ;)
I hope your name is at least ruby?
Wow, you're a really unpleasant person.
Sorry, I just don't like it when people attempt to deflect criticism by feigning illiteracy or an inability to understand it. Or as you would say: WHUT???
Still not sure what he means when referring to Python users as "frosty." Does he mean that they are mad about everyone making fun of their language?
Pry has fast become a habit when I program ruby. First write the skeleton, add the "binding.pry" to the code, write som the code in the repl and then paste that code in to emacs. Next step is to learn how to use the pry-stack_explorer and pry-nav plugins. Finally Ruby is catching up with the LISP repls.
Nice thinly-veiled advertisement.
Okay, I'll try to improve it if I have time. However, as I've said, all major use cases are covered in those examples. API Dox: http://rubydoc.info/gems/rexec/1.4.1/frames
I guess they don't persist.
You know how Rubyists have the whole MINSWAN thing (Matz Is Nice, So We Are Nice)? Pythonistas have something similar: GIDSWAD (Guido Is Douchey, So We Are Douchey). Ha ha, only serious, but, Pythonistas tend to be kinda mean. But if you had to defend the indefensible (significant whitespace, passing self as an explicit param) all the time, you'd be pretty frosty too.
Actually he talks about Rails' use of method_missing to define methods at runtime based on data models as metaprogramming, which it is.
[This](http://ruby.bastardsbook.com/) might help. It goes over basic web-scraping and introduces Mechanize in the later chapters.
In case you haven't received it yet, good news: Inside the front flap is a piece of paper with a coupon code for a free ebook version of it because you bought the dead tree version. Manning knows what's up. I just wish they made more books that were interesting to me. :P
I swear by The Rails 3 Way. Presumably there is or was a Rails 2 Way?
It was just called "The Rails Way".
It is a very sad thing that you will be on rails2 forever. it's got a lot of rough spots fixed in rails3, and most of the info you will find googling and such will be for rails3, and most third party gems are only maintained for rails3 now. But on the plus side, here's the book you want, it's rails for people who are already programmers, get the 3d edition for rails2: http://pragprog.com/book/rails3/agile-web-development-with-rails Oh, and yeah, if you are new to ruby, I'd definitely start with ruby. The pickaxe book is the standard. Does rails2 even support ruby 1.9, or is it stuck on ruby 1.8.7? I don't recall. If it does ruby 1.9, get the ruby 1.9 updated version: http://pragprog.com/book/ruby3/programming-ruby-1-9
open-uri is in the stdlib and json has been since 1.9 so they are not really gems.
I like pry. Can't get enough pry.
* pry * yard * bacon There are a few others as well but these are the ones I use the most.
I like this in principle, but have a few critiques: * The (demo) questions are too easy. Fizzbuzz has been done to death; it's easy enough to Google a solution in any language. I'd expect all candidates to have identical solutions to the calculator problem. As an interviewer, I'd rather see problems that require some thought. * Timers aren't very helpful and probably add undue pressure to the situation. If it took someone 5 minutes to write the calculator and someone else 10 minutes, that doesn't tell me anything. * Describing the exact problem before starting the timer defeats the purpose of having the timer. * I'm curious to see how assessments work. It seems like there's not much you can meaningfully compare. Candidates using git will have an advantage in the number of commits they use, since they (hopefully) won't push things that fail. Candidates using the web interface will have an advantage in time. * It's way too easy to cheat. If this gets used, expect people to be able to Google for exact copy/paste solutions. * I think it'd be much more valuable for a site to allow me to develop my own questions tailored to the things I care about. Let me upload the tests and code skeletons, and don't charge me $200 a pop.
and soon they'll be pulled out of stdlib and put back into gems. (2ish)
I think that coding tests are a bad way of evaluating people. I'd rather see someone's own code example.
Again, the demo tests are unrealistic; It's hard to think of a bug that lots of people will make on such a simple problem. On larger problems, there tend to be a few really common bugs come up often, that you can check for with this optional feature. I need better explanation here too.
I don't think you have to figure out some way to quantify them. The coding samples are just to make sure the person can code and the code look relatively clean. After that I think interview questions are how you narrow in on how good of a coder they are. The real problem with these tests is I don't think they evaluate how people code in the real world. Every coder I knows looks up shit constantly and I feel like these kind of tests kind of make the assumption that anyone who is good at coding is going to have everything memorized. That said your questions are kind of easy so I don't think anyone would need to look anything up but I'm not sure it will tell you anything either.
Easy, validate on the server side and respond with JSON describing why the content is invalid. that could be reported back to the user.
Looks a lot like [The Req](http://thereq.com/), but paid and with fewer features. :-\
The same way you learn anything. Practice. Stop using the libraries until you understand how to test using the basics. You don't learn driving by starting in an F1 car. Work with people who are good at testing, see what they do, learn from them.
As a sinatra user, I cannot live without [sinatra-contrib](https://github.com/sinatra/sinatra-contrib) Edit I also wanted to add * [slim](https://github.com/stonean/slim) * [watir](https://github.com/watir/watir) * [cucumber](https://github.com/cucumber/cucumber) * [mail](https://github.com/mikel/mail) 
* rails (it's a gem! :) ) * nokogiri * MultiJson * httpclient * vcr * sass-rails * capistrano * execjs (and therubyracer) * thor * parslet 
pry metasm packetfu ronin + its libraries interactive_editor
Thank you :)
Yep, "Agile Development" for Rails, and the Pickaxe for ruby are really the old-school standards, I'm surprised nobody else recommended them. And being old school, they both have older versions for rails2 and ruby 1.8 respectively. The publisher's write-up on Agile Dev With Rails is actually surprisingly bad, I don't know if I'd buy it based on that description! But trust me, it's what you want. It's how I learned rails (back in rails1 days!), and the pickaxe is how I learned ruby. **Do** attend to learning ruby as a language before diving into Rails, you'll be much happier. Rails is simply a framework written in ruby. Also, especially for someone whos' already an experienced web programmer (just not with ruby/rails), the free online official [Rails Guides 2.x archived edition](http://guides.rubyonrails.org/v2.3.11/) are _excellent_. Some newbie is going to find them a bit bare bones, and they are _not_ tutorials -- they're more like narrative overviews of the different components of Rails. But for you, I bet you'll find them super helpful. (Sadly, the rails guides too weren't _quite_ as good in Rails2 as they've become for Rails3, but still worth checking out) If by "two weeks", you mean two weeks of full time immersion, I think an experienced web developer and OO programmer (just not in ruby or rails) can in fact get to the point of basic familiarity and basic competency in two weeks, sure. Spend a few days on ruby with the pickaxe, then move to Agile Dev With Rails, still going back to working through more of the pickaxe for 45 minutes or so each day. 
Yep, I think Yehuda is planning a more thorough experience for developers, including pre-compiled rubygems. Yehuda was aware of the RailsInstaller for OS X project, and similarly the primary creator of RailsInstaller for OS X, Michal Papis, is also working on the Tokaido project. Every innovation in this area is very important.
Am I missing something? Ruby 1.9 is slightly better (43.8 vs. 47.93) than Python 3 in the median. Same with PHP. And it only beats Perl in the median and 75% marks, not across the board. JRuby's certainly faster from median on up, though.
While I am compelled to agree, there are several flavors of the Alioth shootout and Ruby doesn't trump all of those languages on all of them. For example: http://shootout.alioth.debian.org/u64q/which-programming-languages-are-fastest.php
A few more to check out: * awesome_print * activesupport (really, just for String#squish) 
[isitup.org](http://isitup.org/check.php?domain=ruby-lang.org)
I love JRuby, but I'm highly skeptical of it's speed claims. Don't get me wrong, it certainly runs ruby code faster than any other ruby implementation. But, a lot of the processing done in my ruby apps are really done in C libraries. Every time I benchmark one of them on MRI and JRuby, the MRI version is faster except for the garbage collector hits. 
awesome, thank you! I'm going to grab a copy of pickaxe tonight and get started. Out of interest, any advice on the mac issue? I've never used one for more than 5 minutes. I especially don't know what editor to use (Textmate?). Thanks again!
Any time someone talks about one language being faster than another, I have to ask - which version? On which platform? Doing what? And more importantly - does it matter? I didn't care that Ruby was slow before, and I don't care now that I know it's a little bit faster. I'm not using it for anything where the computer's time is more important than my time, because that's not what Ruby's designed for.
its* ;)
Point being? I mean the whole article.
bones, rake, slop, pry, bacon, yard
And that as well ;-) Code walking many of the Ruby implementations is a real exercise. It's hard to tell sometimes if some were written by an inexperienced Ruby developer *or* a genius one who knows all the ways to squeeze out a little extra power by avoiding costly idioms at all costs ;-)
I forget the exact benchmarks (whether they were testing Ruby or Ruby+Rails), but "it" used to be slower than unoptimized PHP.
I listed the gems in the order I use them. Ore is the first one I use when creating a gem, then bundler, then rake, rspec, yard, etc. I couldn't survive without my gems, so I wrote them. Why didn't you downvote [banister's comment](http://www.reddit.com/user/banister)? He wrote Pry and listed it. I sense a double-standard.
[rbenv](https://github.com/sstephenson/rbenv) seems like a nice idea, very minimal bash script for manipulating your `$PATH`. Except I couldn't get rbenv to work on Fedora 17. The `rbenv rehash` didn't update the shims after installing gems. It also didn't set `$GEM_HOME` to `~/.gems/$ruby$version`, to prevent rubygems from installing gems into `/usr/local/$ruby`. I googled for workarounds, submitted Issues, but didn't get any answers. I hope Sam Stephenson will dedicate more time to testing and maintaining rbenv.
Thank you!
Thanks!
Thanks!
I know the difference, but I don't usually reread my comments on reddit before clicking "save"
[Found it!](http://upload.wikimedia.org/wikipedia/commons/thumb/8/80/Halite09.jpg/300px-Halite09.jpg) Now I just have to figure out how to take it without dying.
yep, https://github.com/postmodern/dotfiles/blob/master/.bash_profile#L13-17
I'm saying you should try to find and fix the performance problems. Many C extensions provide Java counterparts which provide similar performance. The JSON gem, for example, is actually authored in an FSM language called Ragel, and it's capable of generating both C and Java backends, which is exactly how the JSON gem is implemented. You'll note there's a -java version of the same gem which is generated from the same Ragel source code: http://rubygems.org/gems/json Many gems which use C extensions also provide Java extensions. Nokogiri is another notable example. When I benchmarked Nokogiri's C versus Java backends, the Java backend was actually faster: https://gist.github.com/1596366
"retardo" ... I see what you did. Great fun!
I was using the java version. I am not new at this. 
&gt; Even then, it wasn't significantly slower. Perhaps, but there was a strong perception that it was. I ran into that when first checking out the Ruby language. Whether the perception was true or not, addressing a perception that does exist is not knocking over a strawman. More like mythbusting, although that makes it sound a little grander than I intend. :)
Other people went with OctoPress, which is an extra set of rake tasks on top of Jekyll. I went with Jekyll because it's dead simple. There's no reason ruby-lang.org has to be a dynamic site; even blogs can be statically generated. Static content is secure (no server-side code to attack) and it scales (no caching needed).
I've worked with both. I immensely dislike the complication they bring to a simple project
I currently work in a Rails shop. 1. Rails 2. guard-(livereload, bundler, rails, jshint) 3. rabl 4. active_admin 5. Kaminari There's probably more but I can't think of them off the bat.
RVM is dying, switch to rbenv!
Do you expect people in this subreddit to answer that Ruby is useless and not worth learning? If you want constructive answers, there is no need for flame bait title.
I don't expect that at all. From talking to two people in the industry, one supported it and one did not. I was just trying to find the advantages of learning Ruby. 
Most people stumble upon Ruby in connection with Rails or Sinatra (or Padrino these days), all of which are excellent reasons to learn Ruby. However, for me Ruby has supplanted Perl as the "glue" language of choice for random scripting. That being said, Ruby is a script language, and as such as not suited for tasks where performance is serious concern. Maybe that's what the interviewer was talking about? Depending on what excatly they do with multimedia online, they may need a language closer to the metal. Or he might just have talked out of his ass, who knows?
If you're using Devise, you can configure this in config/initializers/devise.rb with the stretches param (e.g. set it to 1 in test mode, 20 in dev/production or whatever). This is kind of an unnecessary hack because the stretches are configurable as a parameter, it's in the friggin code right there. def generate_salt(cost = MIN_COST) If you aren't using devise, just add the cost: BCrypt::Password.create("my secret password", :cost =&gt; (Rails.env.test? ? 1 : 20)) Edit: consider this subliminal messaging to go back to using the hash rocket :)
so your argument is that JRuby is slower by default, but if you spend more time working on it, you can maybe make it as fast or faster?
Don't trust anyone who says learning a language is useless. Different languages expose different features and help you think in different ways about programming. I started with Javascript and it was only until I started learning Ruby that I grasped OOP in Javascript (because it's so obfuscated). Javascript allows for a more functional programming with async events and concurrency. Unfortunately I don't have any experience beyond that, but people often comment on the value of learning Lisp—not because of its practicality but because it changes the way you think about code. To be honest with you, a company specializing in 'multimedia online' sounds like something out of the 90's. I'm sure other companies would appreciate your eagerness in learning beyond what they teach at school.
Speaking as someone that, in the last 12 months, has spent roughly 4 months on each of PHP (Zend), Python (Django) and Ruby (Sinatra/Rails), I can say that Python and Ruby are unquestionably better than PHP. To me the single biggest factor is the culture, as in the philosophy and zeitgeist that permeates the code, code*rs* and ecosystem. There is just so much more humanity, sanity and humour in Python an Ruby. Apart from being treated like shit by my Python contractor I still must say that I've enjoyed my time in Ruby's company more than any other. Programmes are written by humans, humans like to be happy. Therefore happiness is useful. Ruby is useful because it makes me happy.
simple test to see if ruby is worth learning: put a couple of years of experience with ruby on your resume and submit to dice. see how many recruiters harass you.
everyone's got their own preferences and judgements. I don't expect everyone to neccearily love ruby. (although I do). But I wouldn't go work for someone who thought ruby was crap and PHP was great. Partially because anyone that thinks PHP is great is on bad drugs, and partially because either way, I wouldn't go work for them because their idea of 'great' is so different than mine, and I don't want a job that consists only of writing PHP. The major advantage of ruby over PHP is that the language makes sense, it's not a bunch of random API strung together with spit and bailing wire. The other major advantage of it is gems. Together, these mean it's possible to write re-useable components and share them with other people in a clean way. 
Since IronRuby runs on the CLR it gives you the ability to call the .NET APIs from your ruby code and since it runs on the CLR you can use other languages that run on the CLR in the same memory space. You can deploy your ruby apps as a .NET application on Windows/Mono servers. Want to write SilverLight apps? You can do that now using Ruby as your language. Rails will work with IronRuby. The only problem with IronRuby is that it's only passing 85% of RubySpec but they're actively getting that number to be higher. 
I could say a lot about PHP, but this says it all and more: http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/ In contrast, Ruby has some warts, but it is largely a well designed language. Ruby is faster than PHP.
Just be careful of something. A ton of people hates ruby. And for no particular reason, most of them didn't even try to use it. And there is a chance this is one of these guys. (The often cited reason for this hate is that ruby is slow. [But that's not even true](http://www.unlimitednovelty.com/2012/06/ruby-is-faster-than-python-php-and-perl.html)) Just try it by yourself and make your own opinion.
The amount of responses these threads get all depends on where in the world it's morning at the time and who has just filled their first cuppa coffee for the day.
Ah ha, I did not realize that Test::Unit would do that, yes I am running with that, I'm sorry for not mentioning it before. This seems to have almost worked. When I ran it I ended up getting a different error out of test unit: C:/Ruby193/lib/ruby/1.9.1/test/unit.rb:49:in `process_args': invalid option: --1 (OptionParser::InvalidOption) Since I was originally planning to just simply do this in the code: $myVar = ARGV[0] it looks like I might have to play around with the Test::Unit library to see what I can do to get back in to process.
It looks like you need to put a space between "--" and your argument.
He wanted you to defend Ruby to him - to tell him *why* you like it. If you can explain *why* you prefer one programming language over another, it shows that you're well-versed in both.
Option 4 may actually be perfect! I'm using some batch scripts up front to kick things off on the server and clean up previous run information. I had read a little about that early on and it didn't even occur to me to try that here. 
I had actually tried it both ways, I only pasted the one failure.
But you must define "performance". Java may beat Ruby in many performance metrics, but usually not in the developer productivity measure. Runtime performance shouldn't be pursued as a goal in and of itself. It must be justified by the requester. As with anything, there are costs and benefits that must be weighed against each other.
nah, an assembler mvc framework!
Well I donno. Ruby allowed me to take a crazy idea and turn it into a powerful product faster than any other language i know. Then I sold the company for millions and millions of dollars, so yeah, I'd say it's useful. 
Hmm, you are right. What you can do is pull the args off before Test::Unit runs: require 'test/unit' puts "First arg: #{ARGV.pop}" class MyTests &lt; Test::Unit::TestCase end Note that you actually need to modify ARGV (e.g. using #pop) for this to work. Edit: Sorry, this is one of contriver's suggestions, too.
All of them. The answer is 'all of them' harass you.
Side note: I thought IronRuby was dead--turns out it's not (as I'm sure you already knew). https://github.com/IronLanguages/main/tree/master/Languages/Ruby
Maybe not the best route to learn CS concepts when just starting, but definitely a fantastic tool later on, once you have all the basics done and just need to get things out fast. Ruby/RoR have phenomenal plugin ecosystems and everything you might run into has already been done before by someone, meaning you can google for all the boring stuff and focus on building your app.
[This comment](http://www.reddit.com/r/ruby/comments/uppb6/cve20122661_sqlinjection_on_rails/c4xkva0) has a basic example of what's happening. Basically, never trust `params` blindly.
correct!
Looks like your site is down.
fewer "magic" side-effects. But the biggest reason is that ruby excels at producing DSL (domain-specific languages). These are small mini-languages that you write for specific problem domains your scripts try to solve. So for example, Capistrano becomes a DSL for defining how to deploy code to remote servers, etc. etc. Perl certainly has it's own strengths, but it's harder to implement DSLs in Perl.
Hmm, it looks like this is "machine learning as a for-pay cloud service, with a ruby API client." Which is still kinda cool, but not quite what the reddit title advertises. 
Marketing? Who does marketing for Ruby? It's not like Matz is out there running ads. People like Ruby because it's likeable. Most of what I like best about Ruby comes from the combination of the data structures and closures. I like iterators a lot. And there's a lot of good ruby software out there. Rails is really cool, obviously, even though it's a lot to digest. The main thing I don't like about ruby is a cultural thing, and one of the things that lots of other people like best about the language. I'm not crazy about the way that ruby's syntactic sugar can sometimes blur what's happening under the hood. I see this a lot in rails helper methods. For example, this is from a rails book: validates :title, :description, :image_url, presence: true :title and presence: are both symbols, but the colon goes in different places for each of them. That's kind of awkward, and it makes things a little blurry sometimes. This thing seems awkward as well: validates :price, numericality: {greater_than_or_equal_to: 0.01} I mean, if you start thinking about the signature of validates, it can be kind of confusing. The use of a super wordy symbol (greater_than_or_equal_to) instead of code with the actual operator seems odd, there's that same issue with colons showing up on different ends of the symbols, etc. This kind of code is strange, because it's really easy to read, and what it's doing is very clear. But it can be kind of confusing to someone who is trying to figure out what's actually being passed and how it's all being processed. Once you crack it open you're fine. But it always strikes me as being wrong. But ruby is way better than PHP. I don't think I've ever even heard of anyone who knows both who prefers PHP. Also, I think that ruby is a little higher up the food chain than PHP. You'll get better jobs, do more interesting work, etc. In the end, who cares what other people think? What do you think? You're the guy who's going to have to swim through this stuff all day at work.
Toss that pitch right slow into the middle of the strike zone, why don't you? Of course /r/ruby thinks ruby is worth learning. Your reviewer shouldn't have been ranting at a job interview - maybe over a beer afterward, but he sounds like someone who can't appreciate the good points of things he doesn't prefer. Hell, I don't like working with Java, but it's damn stable and can do a lot of pretty amazing things. I'm not going to dog it at an interview with a junior hire.
I've heard a lot of bad things about php, but I've never used it so I can't comment. I once was going for an interview and listed C and C++ as some of my skills, the interviewer asked me why I used such "ancient languages" and not something like C#. Since then I have learned a lot of languages, including C#, and even though at the time they made me question myself, I now realise that person didn't have a fucking clue what they were talking about. So just because someone is in a position of authority, show respect, but don't assume they know what they are talking about. They are human just like you. I've only dabbled in ruby, but from the bit I've done, I wouldn't write it off like that. Also, you'd probably be better off posting somewhere like r coding for unbiased comments. Disclaimer: I'm very drunk right now. 
It's free to play with, though. I don't know the people behind Prior Knowledge, but from reading their blog I'm guessing they'd make allowances for people who needed more than offered by their 'free' level but can't afford to pay. That said, this isn't machine learning in a gem, as I was hoping it would be given that there aren't any good ML gems. _That_ said, they've likely made a customer out of me today.
It's not that bad. It's supposed to be simple and not allow arbitrary code.
You should consider building this on top of [Mechanize](http://mechanize.rubyforge.org/). You might also want to checkout the existing Crawler/Web Spider gems, such as [Spidr](https://github.com/postmodern/spidr#readme).
Ruby is not slow, that's a meme left over from the days of Ruby 1.8.6. Ruby 1.9.x is on par with Python, and of course [JRuby](http://jruby.org/) and [Rubinius](http://rubini.us/) offer greater performance.
I would love to use Pow, but every time I try to use it again about 5 or 10 days later it's hanging up infinitely long and I have to basically uninstall it to stop it from running my CPU into the ground.
wirble and pry work together? or you mean one or the other?
The sandbox aspect is not very "sandboxy". I was able to do some things I shouldn't have been allowed to. Security would definitely need some improvement!
So, um, you have 212 million dollars? That's cool.
Don't forget investors, partners, employee stock options and taxes. So far less than the full 212. But still more than enough for one person. The point being: you can see how the question of 'is ruby useful?' seems really silly to me.
RubyKoans is really great for learning/practicing ruby. It's linked in the sidebar: second bullet under 'Learning Ruby?' Also want to second the recommendation of the 2.x Rails Guides. They're excellent. But neither of those is really sufficient -- you'll want the pickaxe and AWD as others have mentioned.
Yeah, I understand, but there's also this thought that you might just be some dude on the internet with heroku in his name who claims to be a multi millionaire. Not saying you're an imposter, but there's a reason so much emphasis is put on verification in AMA's. I suppose the only way to verify is to give me ten thousand dollars.
I'm a bit of a n00b but really trying to fast track the learning process. At the risk of sounding like a complete idiot. Can you please explain your comment like I'm 5? From what I understood (from your comment and skimming quickly over the code) this gem uses CURL to make requests rather than any of the HTTP Libraries available in Ruby. 1) Can you please explain what you mean by "it has the overhead of subprocess creation"? In this case does this mean that our ruby application is calling CURL and so creating a new process that chews up more processing power than is necessary? Alternatively would using a ruby library reduce the required resources significantly? If yes, this is due to the fact that it does not need to execute a third-party application such as cURL? 2) As opposed to the TCP three-way handshake that you mentioned what are the alternatives? A UDP connection that requires no Acknowledgment? 3) Can you please elaborate a bit on the creation of the file? Where is it being stored if it is off disk? Thanks in advance, and sorry if the questions are a bit stupid.
This is actually the first time I'm somewhat pissed off by Ruby code (excluding Rails related code) so the list is a bit longer than usual. 1. You're running shell commands from Ruby code. What. the. fuck. There are dozens of HTTP libraries out there for Ruby (Net::HTTP, HTTParty, Curb or even the somewhat bloated Faraday). If you want to have it handle scraping right away just use Mechanize. However, thou shall not execute shell commands for Curl requests. It's slow, adds extra overhead and is not the Ruby way of doing things. 2. Document your code using RDoc or YARD (or Tomdoc if you're feeling like a rebel). 3. Use whitespace properly. There's nothing wrong with a blank line above a `begin` statement. 4. Don't nest multiple `begin..rescue` blocks inside each other. You don't want your code to end up like this: def get(url) begin begin begin rescue WTFAreYouDoing =&gt; e end rescue AnotherError =&gt; e end rescue SomeError =&gt; e end end 5. You're using STDERR for verbose output. I'm not sure if I can explain how stupid this is (unless verbose output means an error) but data like this goes to STDOUT. STDERR is used for **errors**, it's even in the name. 6. The first rule of URL encoding club is that you do not use `#gsub()` for "encoding" URLs. You should use `URI.encode()` instead. 7. If you're going to write data to `~/.whatever` I want to know about this. Put this somewhere in your documentation or README. 8. DO NOT MONKEYPATCH THE STANDARD LIBRARY OR EXTERNAL GEMS. It's especially bad if you *re-write* existing methods instead of adding your own wrapper class. 9. Your code is executing `rm -rf` as well as changing ownership of various directories. I'm not going to use this lump of code because it's absolutely retarded that a Gem thinks it can handle permissions and ownerships by itself. Here's a hint: everything created by a process has its owner/group set to whatever was running the process. Assuming this script won't be run as root (please stop writing code if you do) there's no reason to change the ownership and/or group. 10. Again you seem to be using `#gsub()` for dealing with filepaths. Use the damn Pathname class already. 11. Why you're trying to tidy up HTML is beyond my understanding. I don't think I've ever run into an issue with Mechanize not being able to parse an HTML page (even if it was invalid). 12. For the love of god people, stop inventing your own file extensions if the code in these files is nothing more than Ruby code. There is absolutely no benefit to this. In fact, it only adds more trouble for developers as they now have to configure their editors to treat this new file as a Ruby file. On top of that it also means that I can't directly `require()` the file if I ever want to inspect and execute it. 13. You're relying on ActiveSupport. I'm pretty sure a lot of people will disagree with me for saying this but it's a stupid dependency. I don't think I've ever thought "Hey, let's use ActiveSupport for this!". Why? Because it adds a number of backports for stupid old Ruby versions, patches various core classes (e.g. `Class`) and so on. Maybe you don't care, I don't know, but this is another reason for me to say well clear of your code (or anybody else's code using `Active*`). 14. Why are you depending on `awesome_print` as a runtime dependency? It's a Gem meant to be used for development/debugging purposes and the like. 15. I can't help but feel that specifying the Ruby platform in your Gemspec is useless. It will be set to whatever platform you used for building the Gem, this however does not mean it won't work on other platforms. 16. You're setting the Rubyforge project to "sinew", however this project does not exist (Rubyforge is dead anyway). Please don't tell me you're setting this just because you're running some ancient version of Ruby and/or Rubygems that bitches at you when you don't set this manually. If you do, shame on you. 17. Ruby version requirements should be specified in your Gemspec. `bin/sinew` bails out if you're not running 1.9 or newer but this is nowhere to be found in the Gemspec. This can be set using `required_ruby_version`. 18. You're using ActiveSupport *and* Stringex? Please, do add some more monkey patches while you're at it. This way other developers that may want to contribute can enjoy the world of monkey patch hell. 19. You're using regular expressions for replacing/tidying up HTML? Have you not learned anything from the internet? Please go read this: &lt;http://stackoverflow.com/a/1732454&gt;. 20. Your indentation in `text_util.rb` (`COMMON_ENTITIES_INV` in particular) is absolutely retarded. One level of indentation for the parameters is enough.
I think people routinely pass in the params[:password] into the where hash and if rails is unable to properly escape that and prevent SQL injections then shame on rails. 
Not the OP, but I'll give it a shot! &gt; Can you please explain what you mean by "it has the overhead of subprocess creation"? In this case does this mean that our ruby application is calling CURL and so creating a new process that chews up more processing power than is necessary? Alternatively would using a ruby library reduce the required resources significantly? If yes, this is due to the fact that it does not need to execute a third-party application such as cURL? You've pretty much got it. It generally tends to be significantly more expensive to start up a new process than to use a library. &gt; As opposed to the TCP three-way handshake that you mentioned what are the alternatives? A UDP connection that requires no Acknowledgment? What he means there is that every time you call the curl program, it doesn't know or have state from the previous time it ran. So it has to start up a new connection, then request the resource, then tear the connection down. For TCP (and you have to use TCP for webpages/http) setting up the connection involves the three-way handshake, which means this will have to be done every time it makes a request. This is opposed to using a ruby library, which could maintain state between calls and simply re-use an existing connection. &gt; Can you please elaborate a bit on the creation of the file? Where is it being stored if it is off disk? Again, a consequence of using an external program. The curl process is a separate process, and so it doesn't share memory with the ruby process, and so to communicate it has to write to the filesystem, and the ruby process has to read from the file system. If it was using a ruby library instead, then it would be running in the same process, and would simply write to memory the rest of the ruby code already has access to.
Ok, I dug in. I still don't see where Ruby is 'consistently' beaten by Python 3. As I flip through the tests, they seem to jump around quite a bit by platform/test. The "big 4" scripting languages on average seem more similar than different. However, if you REALLY drill into the tests one interesting statistic stands out. One language tends to use a lot less CODE to perform many of these tasks. I can always throw a little money at fast metal and get a performance boost. It's significantly harder to get my hands on developers to get more code written, and throwing more money at *that* problem has significantly less return on investment. I've been writing code professionally for 13+ years now. I've spent significant time in each of the following languages (in no particular order): C/C++, Java, Classic ASP, C#, VB.net, PHP (lots of time here), Perl, Python and Ruby (current job). I have never been able to churn out features faster in any of the other languages (the .NET stack is probably a close second) as I can with Ruby. Of course ... Ruby isn't the right answer for every problem. There are definitely times when it'd be better to use a different language. We actually frequently go to Java for some of our background processes, but Ruby and Rails is the glue that holds the app together. 
But that's my point exactly. Maybe I am incorrect to say it's one of the slowest interpreted, but it is indeed slow. People use it because it's fantastic to develop with.
- Bundler - Sinatra + Datamapper/Sequel + Haml for webdevelopment - Cinch for IRC bots
Interpreted languages are many times slower than compiled languages (except JavaScript apparently). That is not news. However, it is unfair to call Ruby the slowest of the slow. It hangs with the best of them and in some cases is the pack leader ... especially in commonly used applications like the b-tree test from the above-mentioned link. 
got it. I picked up a copy of pickaxe last night. I already own the first edition of AWD - should I get the more recent version too? Thanks!
I wouldn't have answered much differently. There's nothing broken with the implementation, but there are plenty of HTTP libraries for ruby that can make sinew much faster. 
Wow, this is great feedback. Kudos!
This is Reddit, not Twitter. Hash tags are useless in titles or anywhere else.
What's the real world case behind using nokogiri over some other crappy XML library? Doodle might not add any crucial functionality but it makes your code a lot more declarative and solves many common and annoying problems regarding instance variables (validation, conversion, defaults) 
I don't really get it. Does this work with some kind of storage system (yaml is mentioned) or is this a different way of writing the code for classes?
You should also post this in /r/rails.
0. Before creating a new project, research the existing solutions. Consider building your project on top of another project (mechanize-recipes?). Don't simply reinvent the wheel. 21. Update your version of bundler. The gemspec appears to have been generated by Bundler 0.9.0: running `git ls-files` multiple times and splitting by `\n` (won't work on Windows). I'm surprised how many upvotes this project got. Do people blindly upvote "yet another" style projects without reading the code?
You might want to checkout [Virtus](https://github.com/solnic/virtus#readme), it's attribute/coercion system is really solid.
&gt; different way of writing the code for classes? This is more on the spot. It's not really different, but more of augmenting the old way when it is too wordy. For example see [defaults](http://doodle.rubyforge.org/defaults.html), [conversions](http://doodle.rubyforge.org/conversions.html) and [validations](http://doodle.rubyforge.org/validations.html) for the most common use cases for me.
Virtus looks great and a lot more focused in scope. But the validation syntax seems more verbose. Perhaps I should do a more thorough comparison later on.
I think you look different than the dude in the video, although it's hard to tell since you're making that face. That'd be awesome if you were really Orion though. My dream is to one day make such successful software. 
thank you! 
&gt; I have to ask - which version? On which platform? Doing what? Yes you do -- and the benchmarks game website tells you! [ruby 1.9.3p194 (2012-04-20 revision 35410) [i686-linux]](http://shootout.alioth.debian.org/u32/ruby.php#about) [platform](http://shootout.alioth.debian.org/help.php#machine) [Program Source Code](http://shootout.alioth.debian.org/u32/measurements.php?lang=yarv) &gt; I didn't care that Ruby was slow before In that case, you actually don't have to ask those questions :-)
Putting stuff in a blog post doesn't make it into The Truth. Read the comments to find out which parts of that reported "experience" are not true. Read the comments to find out that PyPy programs from other developers were accepted that same weekend.
"After all, facts are facts, and although we may quote one to another with a chuckle the words of the Wise Statesman, 'Lies--damned lies--and statistics,' still there are **some easy figures the simplest must understand, and the astutest cannot wriggle out of**." Leonard Henry Courtney, 1895
## gemspec * You don't need to use `add_development_dependency` or `requirements` if you've already called `add_runtime_dependency`. Also `add_dependency` is an alias to `add_runtime_dependency`. `requirements` is reserved for listing external dependencies (`libmysql &gt;= 1.2.3`). * Consider using a tighter version requirement for nokogiri, such as `~&gt; 1.5`. This will match `1.5.0`, `1.5.1`, ..., `1.6.0`, `1.6.1`, ..., `1.99.99`. * `files` is supposed to list _every_ file in the gem. This includes the README, LICENSE, Gemfile, etc. Try this instead: gem.files = `git ls-files`.split($/) gem.executables = gem.files.grep(%r{^bin/}).map{ |f| File.basename(f) } gem.test_files = gem.files.grep(%r{^(test|spec|features)/}) ## gitignore * You don't have to list everything in your `.gitignore`. Consider setting up a global `~/.gitignore` with `git config --global core.excludesfile ~/.gitignore`. ## Release * You forgot to tag your releases! Consider using Bundler's gem rake tasks (`Rakefile`: `require "bundler/gem_tasks"`), [rubygems-tasks](https://github.com/postmodern/rubygems-tasks#readme) or [gem-release](https://github.com/svenfuchs/gem-release#readme). * There's no `ChangeLog` or `History` file. * Do not commit `Gemfile.lock` for libraries. Only needed for deploying apps to other servers. * Your gemspec lists `BSD` as the license, but there's no `LICENSE` file or BSD copyright notice anywhere! ## Style * `"http:#{link.attributes['href'].to_s}"` is redundant. Anything within the `"#{...}"` is converted to a String. `"#{File.basename(img_url)}"` is also redundant. * `file.puts f.read`, you probably want `f.write`. `puts` adds a trailing new-line character. * When printing error messages, use `$stdout.puts` or maybe `warn`. * Don't add extra `\n` characters to `puts` Strings. Simply call `puts` with no arguments to output an empty-line. * In your `bin` script, when an error occurs exit with `-1`. * Consider moving the `puts` statements and error handling into your `bin` script. Typically your library code should not be interacting with the user.
For extra bonus points, if you're downloading large files, you can stream them using `Net::HTTP`. Net::HTTP.get_response(video_url) do |response| size, total = 0, response.header['Content-Length'].to_i File.open(video_path,"wb") do |file| response.read_body do |chunk| file.write(chunk) size += chunk.size printf "\r[%d / %d] %d%% ...", size, total, ((size * 100) / total) end end puts "\nDownload complete!" end
Is Reddit really the ideal platform for question and answers? Wouldn't a site such as [StackOverflow](http://stackoverflow.com/) be a much better platform for asking and answering questions? They have a pretty big community and usually questions get answered within less than one hour. So it seems that it would be the more _logical_ place to ask programming-related questions.
It barely has any subscribers, the posts a months between. They're better off with what's already in the sidebar.
Discussion are **highly** discouraged on [StackOverflow][1]. We can discuss stuff about Ruby on Reddit though. Which we already have the _perfect_ reddit for, /r/ruby. So the ideal setup would be [StackOverflow][1] for questions and /r/ruby for discussion. [1]: http://stackoverflow.com/
Between /r/ruby and /r/learnprogramming, there's no real room for /r/learnruby.
There's no advanced discussion here. It's all a bunch noobs following noobs.
&gt; Your indentation in [text_util.rb](https://github.com/gurgeous/sinew/blob/master/lib/sinew/text_util.rb) (COMMON_ENTITIES_INV in particular) is absolutely retarded. One level of indentation for the parameters is enough. As far as I know, this is accepted way of indenting parameters, arguments, hash keys, and so on. A lot of Ruby style guides [recommend it](https://github.com/bbatsov/ruby-style-guide#source-code-layout). ...not that I agree, but I do see it very often in the wild.
Your `Gemfile` should only have the line `gemspec`. This makes it inherit the gems you've defined in your gemspec file. Also, I would suggest .gitignoring your `Gemfile.lock` file. This way, you can test with multiple versions of Nokogiri (well, it's your only dependency).
It's a stupid indentation guide because it doesn't work when you limit your lines to 80 characters per line and happen to indent data with long elements. There's also no added benefit to the extra levels of indentation.
On that note, I've also personally hated this related indentation practice: something = if whatever? 'yes' else 'no' end *shudder*
Thanks for the feedback. I'll focus on the substantive comments: 1\. (you said: curl via shell is bad) Obviously, Net::HTTP is to be avoided. I've used Curb extensively - it is to be avoided as well due to instability. Actually, I've used several other candidates too, and found plain old curl to be the most reliable. I've never seen a crawling scenario where shelling out to curl was a performance bottleneck. Your mileage may vary, of course. 5\. (you said: don't print verbose output to stderr) Often times you'll see that scripts separate verbose output to stderr vs. stdout to allow for redirection while still printing out status. Examples are too numerous to list. 6\. (you said: don't encode URLs by hand) Usually, users of sinew are responsible for encoding URLs themselves. The encoding you're nitpicking helps to catch crawled URLs that are (erroneously) partially encoded. Yes, this happens when crawling. 8\. (you said: don't monkeypatch gems or stdlib) That's a bit pedantic. It's quite common for apps (like Sinew) to monkeypatch gems or stdlib to work around bugs. The existing nokogiri inner_html behavior is undesirable in any case. 9/10. (you said: rm and chmod are scary) Ha! "Util" has a lot of methods that aren't used by Sinew. That's like complaining because the stdlib has File.unlink! If it'll make you more comfortable I can strip out the Util methods that aren't used. This module is shared across several (internal) projects. 11\. (you said: why tidy?) Tidy makes HTML easier to parse. Sometimes it's desirable to run tidy and then use regular expressions on the resulting HTML. This is a common use case. 13\. (you said: avoid ActiveSupport) I like String.squish, Object.blank?, etc. You'll see that I use them extensively. These are great features and I don't feel the need to rewrite them. 14\. (you said: why awesome_print?) awesome_print is a requirement - it's used to format output when running sinew -v. It's a great gem and I recommend it highly. 15/16/17, (you said: various problems with gemspec) You've got me there. I haven't written many gems and your feedback is appreciated. I'm trying to fill in the blanks from popular gemspecs, which clearly suffer from the same problems! I must've asked ten people how to require 1.9 in my gemspec... 18\. (you said: Stringex sucks) Can you recommend an alternative that has the same feature set? I don't love it but it has the functionality I require. 19\. (you said: don't parse HTML with regex) Look, I tried to ignore the trolling but this is just flat out wrong. Here are a few REAL WORLD scenarios that require parsing with regex: * trying to pull a phone number from 20 pages that have nothing in common * getting a list of photos. From javascript! * parsing cooking recipes from a site that was created before the rise of PHP 20\. (you said: your indentation sucks) You say 'retarded' - take it up with the author of the emacs ruby mode. His name is Yukihiro Matsumoto. (edit: formatting)
1. Mechanize ain't bad, but to my knowledge it doesn't support caching, or the raw/html/clean philosophy that makes Sinew so powerful. It make submitting forms super-simple though. It's a great project, just a different use case. 2. Thanks! Windows support isn't on the roadmap, though. I don't have a Windows machine to test with in any case.
Re: Spidr. Sinew has a different use case. It's certainly much closer to Mechanize than Spider.
Actually, Mechanize aggressively caches everything by default. You can also access the raw response (`page.body`) and the parsed HTML (`page.root`). It's always a good idea to use `$\` instead of `\n`, in the rare event a Windows developer has to build/test your project.
Well, if I'm going to install rspec -- and I should -- then the place for the contract is with the other tests I'm going to write. Because just pinning down the signature of each method like that is not enough to test my code.
Make the code window resizable. Maybe support for multiple files? like 2 or 3. Might be easier for classes Some gems that people can use perhaps (like the library selection in jsfiddle)
6: I didn't say anything about encoding URLs by hand, I said you shouldn't use `#gsub()` for it since there's already a wonderful tool for it: `URI.encode()`. It may use `#gsub()` internally but chances are that it takes care of all edge cases you might encounter. It also saves you from having to re-invent the wheel of URL encoding again. 9 and 10: I'm well aware that `FileUtils`, `File` and other classes/mdoules have similar methods. However, these are again classes that come with Ruby itself and are well tested and known to work. I don't want to end up running code that can potentially run the following: path = "/some/file /path" # Note that space `rm -rf #{path}` 18: At no point did I say Stringex sucks, don't put words in my mouth I haven't used. I stated that I don't really see the benefit of adding more gems that patch core classes. 11/19: there is no excuse for parsing actual HTML using regular expressions. Extracting text is not parsing HTML, it's exactly that: extracting. For example, I'd consider this to be perfectly fine: html = "&lt;body&gt;&lt;p&gt;Phone: 012345678&lt;/p&gt;&lt;/body&gt;" number = html.match(/Phone:\s*(\d+)/)[1] This however is not and will earn you a spot in the developer wall of shame: html = "&lt;body&gt;&lt;p style=\"color: red;\"&gt;Hello&lt;/p&gt;&lt;/body&gt;" color = html.match(/&lt;p\s+style=['|"]color: (\w+);['|"]/)[1] Why? Because there's so much that can go wrong when running this. There are also extremely capable HTML/XML parsers out there (hint: you're already using one). 20: This is a common excuse I see people bringing up: "Oh but my editor does this, there's nothing I can do about it!" BRRRRZT, wrong. If your editor is being a jerk about something there's 3 things you can do: 1. Fix the editor 2. Use a different editor 3. Fix the issue yourself Arguebly the last one is probably the easiest, all it requires is that you un-indent a line. Don't hide behind the incompetence of your tools, you're still using them to write code and you're still responsible for how it looks and works. Having said that I'm not going to discuss it any further. Not because I don't want to but because it's just as pointless as discussing whether Vim or Emacs is better (or any other similar discussion).
I'd upvote more than once if I could. Also, I think I just wrecked the app: def bomb Process.fork { bomb } end loop { bomb } Probably could've gone with this as well: loop { Process.fork }
It looks like I can't extend classes for some reason. This works on irb, doesn't work on rubyfiddle: class String def palindrome? self.reverse == self end end "madamimadam".palindrome? 
But what is the difference between unit-tests and contracts then? (Asks someone who has never heard of a code contract until today).
I sure as heck did delete stuff. File.unlink works, Dir.glob('*') and see your unicorn file gone.
Your down_thread method in /lib is a little opaque and heavily indented - I'd consider putting refactoring it into two or three methods. That said, it's just a little awesome CLI app that does a simple job. OP has delivered. 
How much does this slow your code down? We really should have this in ruby. PHP has it.
&gt; However, if you REALLY drill into the tests one interesting statistic stands out. One language tends to use a lot less CODE to perform many of these tasks. That's at best a half truth. If you really drill into the tests, you'll see that where the Python program uses more code the Python program is using multi processing but the Ruby program isn't.
Thank you. I was just thinking about refactoring this as well. Eventually, I want to this app to monitor a thread till dead, even allowing for alerts on the desktop (but now I am getting ahead of myself like always.)
Oh that would be SICK! That turns this gem from "neato" to "gotta-have" for me. EDIT: guess its time to watch the repo then!
Sorry, I meant **disk caching**. I'm not interested in a memory cache. Is that supported?
Then you should not be running them with arguments on the command line.
Just write separate tests for each scenario.
Then I would be repeating large amounts of work, or copying and pasting unnecessarily. A simple if/switch statement works fine for telling the script which test cases to run and doesn't require nearly as much work on my part.. which is kinda the point of the automation. Since the applications may change often, it also means going back to one place for an update to a script as opposed to 3 or more places depending on the change.
Drill baby drill. :) What it really comes down to is choose the right tool for the job. The tests by and large show that scripting languages are slow across the board (surprise, surprise). It also shows that on balance, there aren't really any clear winners from a performance standpoint. Each language had tasks where it outpaced the others in terms of performance. All this comes down to is that you need to understand your problem domain, and choose the language that's going to meet your performance needs as balanced against development time and execution perfomance. The takeaway is that you should probably develop in the language that allows you to prototype most efficiently. When it comes time for performance optimization, look at your pain points and re-implement where necessary. If you can use the same language, just do it more efficiently ... all the better. However, some complex tasks may be better off re-implemented in a language that handles that type of task better.
Come on guys, that ain't cool. We're all pulling on one string here. Deleting and destroying stuff is really not necessary. If we point out security flaws in public, let's at least be funny about it(Bender from future anyone?). I admit having messed around myself, but at least I added files instead of deleting them. To the OP, I apologize for being a dick, it's not fair given the hard work you put into this, and you even open-sourced it. Instead of being "funny", we should all be sending pull requests instead. That being said, you really should be looking into sandboxing the app.
One obvious example of a hetereogenous non-sortable array is when you splat your method arguments for variable arrity invocation. `def foo (*args)`. But you never want to sort those, they are expected to be what they are. Good call on `sort_by`. It is of course much more straightforward to check if an array is going to be `sort_by`-able for some particular `sort_by` logic. 
Under what circumstances was Cap too slow for you, and how slow? For me, the only bothersome slow part of Cap is waiting for my Rails assets precompile -- but that's not cap's fault, and anything else would be the same, just got to wait for the assets precompile. I am not sure how many people have the problem you have of Cap being too slow. 
The builtin contracts don't slow your code down much at all...they are mostly just simple is_a? and equality comparisons. You can also write your own contracts, and those could slow your code down if you are doing some complicated check. But if that's the case, the check probably shouldn't be in the contract anyway.
They are pretty similar. A lot of unit tests are just contracts in disguise. For example, if you write a test saying that a function `square` should take a number and return a number, you are writing a contract. contracts.ruby just provides a (IMO) cleaner way of writing it: Contract Num, Num # here's the contract def square(x) x ** 2 end And contracts get checked and catch bugs at runtime vs at test time. There's a longer explanation on the [Wikipedia article on 'design by contract'](http://en.wikipedia.org/wiki/Design_by_contract).
No worries. Also noticed you have the version in two different places. Defined in /VERSION, as well as in the gemspec.
Better :)
That's an interesting approach, however don't you still need to maintain an open connection while the script runs to see the deploy output? I suppose this at least guarantees that losing connectivity does not leave your system in a mid-deploy state (though output may be lost If I understand correctly).
I do find deploying with Capistrano extremely slow, but that has far more to do with the associated asset precompilation, bundler, and rake tasks. Not much to do about those, as far as I know.
Mina helps with the SSH connection latency problem that I've talked about in other comments. As for Bundler (et al), the default `bundle:install` task shares gem files across releases, so subsequent releases will have faster gem installations. (though I think Cap does this, I think Vlad doesn't) For asset precompilation, the default `rails:assets_precompile` task checks for the previous version and sees if it has the same assets, and if it has them compiled. If it does, it simply copies the compiled assets into the new release. (This behavior can be turned off, of course.)
Right. Contracts and specs are similar, but not the same. For one thing, contracts check the code at run time, not test time...so it would make sense to put them in the code instead of the specs.
But you just agreed with me that the contracts should be in the spec and not the code...
Oops, sorry if I was unclear. I meant I agree with this: &gt; just pinning down the signature of each method like that is not enough to test my code. It's certainly not enough. You still need tests.
This is really great. I haven't found vlad to be annoyingly slow, but I enjoy seeing additional solutions to this problem. I'll probably take a look at this for the next app I need to deploy. Does it support multiple hosts and different roles, like vlad's rack-remote_task does?
Mechanize doesn't implement disk caching, only short-term caching through Mechanize::History (response bodies are stored on disk above a certain size, but they are removed when the mechanize instance is garbage collected). To implement disk caching correctly Mechanize would need to follow RFC 2616 section 13, which sinew doesn't seem to do. While the 25 pages of section 13 don't all apply to the client, implementing it incorrectly (or not at all) will give you broken behavior. No disk cache &gt; broken disk cache.
Voting up /r/learnprogramming. There is a LOT of activity in there and knowledgeable people willing to help out.
no "else drink()" ??
Did you try [deployml](https://github.com/postmodern/deployml#readme) or any of the other Capistrano/Vlad alternatives, before creating yet another Ruby deployer? DeploYML reads deployment information from one or more YAML files, builds a command String, executes one giant command via `ssh`. DeploYML supports deploying to multiple servers _and_ environments.
Your website is attractive. The gem looks interesting too. I look forward to trying it out.
Pretty amazing, made me re-evaluate my stance on Fizz Buzz being a silly interview question.
With respect to the approach of bundling everything up into one bash script, is there a way yet for an early error on one machine stop and rollback deployment on all machines? Sort of a two phase commit?
I apologize if I gave the impression that I made this. I just found it and thought it was cool/useful for sharing executable Ruby snippets.
There's no provision for multiple servers yet, but this exact feature is one of the considerations for future versions.
Sinew is used differently. It's an iterative development environment. So, you might start to flesh out a recipe with a get and a bit of parsing, then start it running. While it fetches pages you can continue to edit your recipe and then run it again. Because of the disk cache, you can sculpt your recipe until you're happy with the results. Our developers typically run a recipe dozens of times during development. Run, check the CSV, edit, iterate. The disk cache is populate on the first run. The vast majority of time is spent waiting for nokogiri or regex, not curl. Actually, I think that's the case even when hitting the network, though I haven't bothered to benchmark it. The redditors here are focused on curl vs. other libraries, but that's really never been a problem during our use of Sinew. Of course, if you're crawling 250 million pages a day your fetching speed is much more important than your development speed. :) Perhaps this is explained poorly in the readme. If you're willing, I'd encourage you to try Sinew and let me know how it feels to write a recipe. That's really the sweet spot. It's not about crawling speed - it's about developer productivity.
This looks cool and I'll give it a try. One question: if we are using symlinks, why not just build in the releases folder? Why bother building in tmp and moving it afterwards? This seems like an unnecessary step, but maybe I'm missing something?
Thanks, I've now done so.
&gt; Now Java is, what, roughly 10 times faster than Ruby? Out by a good order of magnitude - Java is competitive with C++ with a good VM like HotSpot, and it's helped along by being quite easy to analyse statically - a luxury Ruby doesn't have. A better example of how a good VM can improve matters is JavaScript and all the modern high performance VMs that have popped up in the last few years - Safari's [SquirrelFish](http://en.wikipedia.org/wiki/WebKit#JavaScriptCore), Chrome's [V8](http://en.wikipedia.org/wiki/V8_(JavaScript_engine\)), Mozilla's [JägerMonkey](http://en.wikipedia.org/wiki/SpiderMonkey_(JavaScript_engine\)), Opera's [Carakan](http://en.wikipedia.org/wiki/Presto_(layout_engine\)#ECMAScript_engines) and IE's [Chakra](http://en.wikipedia.org/wiki/Chakra_(JavaScript_engine\)).
Rails related posts go in /r/rails.
This doesn't answer why Net::HTTP is to be avoided.
Hiya, the sandbox is deliberately insecure, in that it's a disposable VM for running tests only. The rest of the system runs on different nodes, and the sandbox is recreated from a disk image every few hours. Thanks for having a look!
Please, everybody - this is not "the Ruby way".
Decorator implementation taken from [Yehuda Katz's blog post](http://yehudakatz.com/2009/07/11/python-decorators-in-ruby/). If you have a better way to implement decorators I'm all ears!
Yehuda was simply showing that you can emulate python's syntax -- i really don't think he was implying you should actually do this in ruby, there are much more ruby-ish ways to achieve this. For example, instead of using the awful `method_added` hook to provide automatic decoration, why not simply decorate it explicitly after the fact? def my_method end decorate :my_method Imagine, if a user had a number of libraries all using the `method_added` hook and `method_missing` and so on, the authors would have to take a lot of care to ensure they all interoperated and didnt break eachother's functionality. In general i think it's far more robust to avoid these hooks, in particular `method_added`. It's a prime example of too much magic for minor syntactical gain, in my opinion.
I agree that less magic is better. `decorate :my_method` isn't quite as nice as I'd like though :P Let me see if I can think of something better.
In the vlad faq: === Q: Is there any way to speed up ssh connections? === A: Yes, add to your Host entry in ~/.ssh/config: ControlMaster auto ControlPath ~/.ssh/master-%r@%h:%p 
I would have to counteract that statement saying Pivotal Tracker is more complex. They are taking out of context the purpose of the pointing system. Points are designed to reflect the difficulty and effort of a task. That feedback the gives the project owners an ideas of how many hard and easy tasks can get done in an iteration. We suck at guessing how long something will take to do if we have never done it before. Now if you need a todo list with timing and feel you can accurately estimate a task's time, have at it. :)
It's totally overengineered. %w(rock paper scissors).sample KISS!
I am not really sure what I am to make of that article. Is it saying that Ruby is like VB6 and that that is a good thing, or is it saying that Ruby is like VB6 and that is a bad thing? While I liked VB back in the day, I still believe that Ruby is way more than "another VB6".
The syntax looks fairly similar. Well, or you could, by ignoring the majority of Ruby features, write Ruby that looks syntactically like VB6. I guess that's an interesting point?
It's the exact purpose of the Fizz Buzz test: to screen out incompetent candidates
Many languages can be made to look similar when you reduce the example code to such a degree as to erase most distinguishing characteristics.
I agree, you could write the same quick n' dirty solutions in Ruby that are also possible with VB. Which is not a bad thing by itself. But I hope that Ruby is not chosen as a language for the same reasons that VB was once chosen... Where VB leaves you empty-handed, Ruby gives you so much more, and you can reach levels of abstraction with metaprogramming, functional programming etc. that are unthinkable with VB. I'd somehow feel uneasy if I'd be told that Ruby attracts the same kind of culture that VB did. It doesn't, does it? But I'll admit that I've had somebody tease me with the exact same argument a few weeks ago ("Dude, that looks like Visual Basic...")... 
kiss back and thank you
[KISS](http://en.wikipedia.org/wiki/KISS_principle)
just play some ruby warrior :D https://github.com/ryanb/ruby-warrior
will do
read through Eloquent Ruby
forget this, try ruby warrior, it's better than D &amp; D! lol
Try rewriting one of your Rails project to a Sinatra/Cuba/Renee project. :)
Do you mean [why's (poignant) guide to Ruby](http://mislav.uniqpath.com/poignant-guide/)?
No. That's good, and well worth a visit, but it gets very complex quite quickly. The last half is a masterclass in super-expert-level Ruby, but not exactly approachable. No, I mean [The Ruby Programming Language, published by O'Reilly](http://shop.oreilly.com/product/9780596516178.do)
I recommend this as well. I started with Chris Pine's Programming book and moved on to Well-Grounded. It gives you a very thorough walk through the language and exhaustively details how it works. After I'm done with it, I plan to move on to Eloquent Ruby. 
&gt; The irony is, [today's] Ruby "rockstar ninjas" are doing exactly the same work that used to be done with VB and Access. I'm always surprised when I run into programmers that are prejudiced against Ruby, a general purpose programming language. The author missed the fact that Rubyists have largely avoided writing native UIs. Perhaps that will change now, with things like [VisualRuby](http://visualruby.net/) and [RubyMotion](http://www.rubymotion.com/).
upvote tech in vermont!
From the author's description, it's designed to be a second Ruby book. And that is how I plan to use it myself. But I am new to programming with Ruby as my first language. (http://www.informit.com/articles/article.aspx?p=1759889)
Great question! The only one I can find in Boston was http://www.voicesthatmatter.com/ruby2008/index.aspx but it was just a single event (for some reason that was the only one) that happened to be hosted there. It wasn't like a "Boston Ruby Conf" or anything like that. So technically not the first in New England, but we're hoping that this event is successful enough that we can do it again next year and it will always be hosted in Burlington.
mainstay trowelled Apocrypha leave Huguenots ghosts tipped timpanists obsoletes Man seaplane miserable initial's anions misspellings fogbound walloping's twits starriest consolidation's monotone blockhouse reoccupy enzymes statuary generally superintendents tribesmen gewgaw centrists hobs colds enameling Barclay verbs Sinhalese sawyer steels grafted Sexton's pretending hectors taster's longest starchy downscale Eastman edema's involved quill's hales diarists unassigned Isiah's sung weightier redrawn Winthrop doles eject satire's Robbie Utrecht's overlay's polished exceptionally Morrow commode culverts uselessly traveller Tokyo's wadding Airedales Pryor Colombo's pinhead's Sankara accompanist Navahos harbor's prowl pardon operating prurience dreadlocks excitable reevaluated rheumier Landon scandalmonger's Canopus interminable knocking genteel odometers veneer's losers sugary cleanness's payment's
It's…verbose
Make sure to run the tests before installing. When using gems straight from git repositories, your safety is not guaranteed.
You should also post this in /r/rails. I was with you up until the point you used `eval()` to parse JSON. Other than that, I agree with the blog post. Also, please use SSL for sites that require authentication, to avoid attackers from MITMing a network and injecting malicious JavaScript into your JavaScript laden AJAX responses.
Naming a method `class_include_or_extend_or_instance_extend_prepends_includes_or_extends` is grounds for a class six beating.
Is this a joke?
Seriously?
You inspired me to try to do this myself as I couldn't figure out how to look at your ./rps.rb file... (new to gist and ruby) This is what I came up with, i'm not sure I'd call it more "streamlined" as I got a little carried away with "features" and it moves in a slightly different direction. [gist](https://gist.github.com/2926531)
Zed Shaw's site is great: http://ruby.learncodethehardway.org/ After that I would move on to the Koans: http://rubykoans.com/ 
Unfortunately I couldn't afford the ticket :( edit: I found a ticket. Tomorrow I will wear a rubinius t-shirt. Tell me the bacon thing and I will recognize you.
Bummer :/ The timing of these things is always a challenge. We knew we didn't want to schedule it too close to RailsConf or RubyConf which left us with something between June - August. We are also have a limited number of nice venues here and didn't want to host it at a hotel and make it feel like just another conference.
laksdjflkajsdlkfj why the fuck wasn't this advertised more eariler? also, just a request for next year... can we have more ruby talks and fewer web talks? i mean they're all relevant, but c'mon... this is a ruby conference, not a web or javascript conference.
gem install chris_hansen
It's serious if you take the time to look at how it works and what it's useful for. It's not serious if you notice that the post was made by banister....
I tested on irb and you are right. I though they were different because of this paragraph: &gt; and and or, despite an apparent similarity to &amp;&amp; and ||, have very different roles. and and or are control-flow modifiers like if and unless. When used in this capacity their low precedence is a virtue rather than an annoyance. But I simply interpretated it wrongly. Sorry.
I look at it this way, if a programming language is complete then there really isn't anything you can do in it that can't be done in another language. The whole reason Matz designed Ruby is not because it allowed you to do things other languages couldn't, but that it allows you to express yourself in a way you might find more enjoyable, much like one painter may prefer water colors over acrylics.
You shouldn't feel ashamed. Just grab Metaprogramming in Ruby - http://www.amazon.com/Metaprogramming-Ruby-Program-Like-Pros/dp/1934356476/ref=sr_1_1?ie=UTF8&amp;qid=1339751925&amp;sr=8-1
This is an old one but lots of people still reference to it: http://jroller.com/rolsen/entry/building_a_dsl_in_ruby Here's a presentation by Obie Fernandez https://docs.google.com/viewer?a=v&amp;q=cache:FJoN1XuBIooJ:obiefernandez.com/presentations/obie_fernandez-agile_dsl_development_in_ruby.pdf+&amp;hl=en&amp;gl=za&amp;pid=bl&amp;srcid=ADGEESjZwcQinAspPWyuPocrWH-F8iyeAxKYPLXrv11B_bnn8-TvCYTuR0dVq5kuEKMYbT6tmoM5HlnkbbQMGgNDDFQSmAIovRb2-f2Ipn40nw2TaCKWY9mCPw5ee-owZOvuB4UokkXE&amp;sig=AHIEtbTlJKLMJX_-M5oYJ95JWhfm37XrBw&amp;pli=1 Another: http://weblog.jamisbuck.org/2006/4/20/writing-domain-specific-languages More recent: http://yonkeltron.com/blog/2010/05/13/creating-a-ruby-dsl/ Let's keep on at it: http://blog.nofail.de/2010/02/writing-your-own-dsl-with-ruby/ Another example without the explanation: http://gdakram.com/past/2010/11/20/simple_academia_dsl_in_ruby_tutorial/
Don't think about it as "metaprogramming" vs "normal programming", they're one and the same. "Metaprogramming" is a vague term usually meant to describe manipulating some of the more intrinsic features of Ruby. Whether you should learn metaprogramming - quite frankly, no. You *should* however learn about the more advanced features of Ruby - eigenclasses, various scopes, class- and object manipulation, etc. - but not for the purpose of metaprogramming. Knowing a little metaprogramming is more harmful than knowing none at all. Let's take so-called DSLs as an example. In Ruby, "DSL" usually just means "class methods with cutesy names". Most DSLs are implemented in a top-down manner, which results in a leaky abstraction that can barely manage to do one thing properly, not to mention be altered or used in different ways than the author originally imagined. DSLs aren't a goal in themselves, they're optional "sugar" on top of a well thought-out "regular" interface. Everything you can do with metaprogramming you can do - usually much better - with "regular" programming. Metaprogramming is often a lazy programmer's cheat to avoid having to design a proper interface. If you want to learn about Ruby's more introspective features, you could simply browse through the [API docs](http://ruby-doc.org/core-1.9.3/); that's the way I learned it, by simply being curious about how Ruby works.
[Here](https://gist.github.com/2641441) is a struct challenge I wrote that will get you off the ground. You'll have to have some basic understanding of the Ruby Object model, and how defining methods works. Don't feel bad if its hard, you can send me an email or tweet or something, it took a friend of mine ~10 hours to solve, because he had to learn a lot to be able to solve it (by contrast, I can do it in ~15 min, b/c I already know the material). I also put together [Ruby Kickstart](http://ruby-kickstart.com/) a site to teach core Ruby stuff, it has ~6 hours of video, some quizzes, cheatsheets for what I think is important, downloadable challenges with test suites suites so you can solve the problems and get instant feedback. Metaprogramming Ruby isn't a bad book, I experienced some clarity as I read it. It's just about 3x longer than it needs to be, and you can really learn all of that stuff by just understanding the object model and closures, and just playing around with it. Dave Thomas also has some metaprogramming screencasts which I enjoyed and covered basically the same material. If I had to choose between them, I'd choose the screencasts, but the book is cheaper. Of course, playing around on your own is free :) P.S. Knowing Ruby well != metaprogramming, be sure to use discretion and pick the right tool for the job (I pretty much only metaprogram in gems, I almost never do it on client work because there is almost never a need, and it may confuse my colleagues). P.P.S. Never feel ashamed of anything.
I agree with mytrile's recommendation but just a heads up that the writing style in the book isn't for everyone. I found it all a bit silly but the information in it is gold. I suggest it as the good to source for learning metaprogramming in Ruby. 
Well, there's the fact that so many APIs return non-iterable arrays of results or don't use generics.
Check out http://rubymonk.com/ Most of the stuff you'll already know, but you can solve interesting problems there. If that's not enough of a challenge then checkout http://rubyquiz.com/
I had a crack at that challenge... it was fun, thanks for posting it! I have been using Ruby at work for a while now, but the nature of my work means I rarely get to mess with this stuff (like you said, there is no need and it's confusing). I didn't even know Struct was a thing until today. My implementation is significantly different from yours, and twice as long (haha)... instead of using a hash as the underlying representation, I decided to use actual instance variables. I also use a superclass to define the behavior of the structs, rather than class_evaling it every time Struct.new gets called. Here it is, if you're curious: https://gist.github.com/2938133 Your implementation is pretty great, by the way. This is IMO one of the best educational examples of metaprogramming I've come across. edit: and I blame all the stupidity in there (looking back, there is plenty) on the fact that I did this right after waking up, before coffee. :)
TIL: The old syntax is kinda broken.
Totally understandable. If you got that raged over a PHP conference though I might be scared.
This thread needs to be on the sidebar!
Yes. Also No.
About time they realized how stupid it was.
The alternative is to use the included? and extended? methods I guess.
Nice! Headless &amp; JRuby are both big steps forward -- thanks for sharing this.
I switched from RSpec to Minitest and the syntax is better (IMHO) because it's cleaner -- less "magic". 
i keep downvoting this retarded article hoping it will disappear, but it never does :(
tie?
Only managed to get 8 items this time. By far the most annoying is your weird directory structure and naming "convention" for file names. 1. What's up with the file name casing and non standard directory structure? It doesn't really make any sense to *not* follow the Rubygems structure and instead invent your own structure (for whatever reason you might have). 2. Ignore files such as `.DS_Store`, there's no reason to keep track of these in Git. 3. Documentation? What's that? All I see are some vague quotes that have no benefit to end developers at all. Sure, there's a README with some examples but it doesn't describe how the internals work. And no, code is not self explaining. 4. Wrap your lines at 80 characters per line. 5. Your code requires Ruby 1.9 or newer (due to the use of require\_relative) but there's no mention of this requirement, nor does the Gemspec specify a minimum required version. 6. Your use of whitespace is a bit of an overkill. There's no real benefit of adding blank lines around module declarations, calls to `extend()`, etc. Whitespace is a great tool but it should be used with care. 7. Interesting enough some tests (e.g. `Array_spec.rb`) hardly use any whitespace so here's it's quite the opposite of what I mentioned in item 6. 8. Your tests are way too large. Again `Array_spec.rb` is a fine example as there's *a lot* being written in a single specification block.
Has anybody ever benchmarked Node vs Evented Ruby 1.9.3? I'd be curious to see how fast Ruby is in comparison...
It simulates a game that is played over and over again until someone wins.
## Directory Structure This is something followed by nearly *every* Gem out there regardless of its size. While there's no official standard set (this isn't Python after all) I'd say the least you can do is to follow the Rubygems guide as discussed here: &lt;http://guides.rubygems.org/make-your-own-gem/&gt;. This guide wasn't written to annoy people by enforcing particular guidelines. It was written so that it's easy for everybody to contribute code without having to spend time figuring out what particular file structure said project is using. ## Line Wrapping Ah, I see you're not familiar with the concept of wrapping lines and why it's important. It basically comes down to the following two reasons: * different people use different editor setups (multiple vertical windows for example) * different people have different screen sizes and view your code in different tools (e.g. Terminals, Github, etc) Since both these items are related I'll just discuss both of them at a time. Assume you have two developers writing some code: Alice and Bob. Alice uses Vim and prefers to work with 2 split views and a NERDTree (file browser) window open. Alice wraps her code at 80 characters per line and is thus able to display the 3 windows next to each other. (1) Bob on the other hand uses Netbeans and is used to only having two windows open: his file browser and one big window for his code. He prefers to use separate tabs for each file that he's working on. Bob is also using a larger screen resolution and is thus able to view more code on a single line. Now imagine that Bob contributes some code to a project Alice has been working on. Alice now has a problem as the code submitted by Bob is different than the standards she's following, and not just because it's not her standard. First of all Alice is no longer capable of using her preferred window setup due to her smaller screen size (2). The second problem is that the code style is different from the existing one. One of the important parts of writing code is not just *just* write code but to also ensure that it's easy to understand 2 years from now. The only way of doing this is to not only write proper code and document it but also ensure that its style is the same. There's nothing worse than a code base that's using a different style in every file you open. The third problem is that Alice (and others) can no longer rely on being able to view the code submitted by Bob in whatever tool they want. Try viewing code with long lines in Github without scrolling horizontally and *not* forgetting the context. That's right, you can't. There's a good reason why almost every form of text scrolls vertically instead of horizontally: it's far easier to understand. It doesn't really matter what specific tool you view the code in now. Whether it's Github, Gitg, a terminal or a text editor: you'll have to scroll horizontally and you'll get lost. The last problem, and this is the sum of the previously mentioned ones, is that the pull request submitted by Bob will cost Alice time and effort. Not only does she have to adjust her workflow to Bob's workflow (3) but she also has to spend time correcting the code to follow her standards. Once this is done she'll also has to verify that the code still does what it was meant to do. After all, it's quite easy to break something when cleaning code up (especially if it's not documented properly). To cut a long story short: wrapping lines at 80 characters per line (the genreally accepted character width) saves people work and makes it easier to deal with your code. Don't assume everybody uses the same setup and tools as you do. Footnotes: 1. I actually such a setup which just fits on my laptop screen (1600x900). 2. Before you say anything about having to use larger screen sizes, this holds true for bigger resolutions as well. At work I run on 1920x1080 (note sure what the exact width is). While this screen size gives me more horizontal space I still have to close a vertical window to be able to properly view lines longer than around 100 characters. 3. If you think it's ok for project maintainers to adjust their workflow to yours because you're too lazy to do the opposite, please stop writing code.
Glad to see you're capable of being patronizing. Were you capable of trying the software? or just of whining?
It's good to see you're taking the feedback so well, and such polite responses. I'm truly impressed. Having said that, the next time you post something on Reddit (or anywhere else for that matter) you may want to mention you don't care for feedback and just want to brush your ego/neckbeard. It saves people like me time trying to come up with a list that may help people like you expand their programming knowledge as well as preventing them from making mistakes a lot of other people have already made. This will also be my last comment in this thread, I have better things to do than to argue with a wall.
So not capable of trying it, I guess.
Except that the evented ruby libraries are not so nice at all. If you don't want to block your reactor core you have to select evented database adapter, orm, http library, redis adapter etc. The bad thing is, not all of these libraries are ready for production use. I would go for Erlang or Haskell if I'd want asynchronious processing. Or then I'd use Ruby with threads.
You sure have a lot of poorly written solutions for problems no one has. Why do you keep spamming us with this stuff?
I understand the way Mina works, just don't entirely understand why you'd want to! Have you found Cap is failing at keeping the connection open as you say it tries to, or that it's strategy even when working succesfully is still too slow for your situation? But yeah, 10 seconds to invoke a command over ssh is, I think, not the situation most developers are in with their relationship to their deploy servers. I see how that could get annoying quick. I am interested in checking out your implementation of a conditional rails asset precompile though, and porting it to Cap! Thanks for the pointer there. 
You mean you? Awesome. Good work.
Agree completely. I just started working at a startup and we needed to sit down and talk about testing tools, in a heartbeat I said Minitest because I knew only programmers would view them. With Minitest I don't have to get someone to install anything other than ruby to run tests, just feels right. 
## Files 1. Do not commit `.DS_Store` to the git repository. This should be ignored in the [global ~/.gitignore](https://help.github.com/articles/ignoring-files). 2. Either use RDoc or Markdown. One only needs multiple README files if the project provides multiple translations. 3. According to the [Ruby Package Specification](http://chneukirchen.github.com/rps/), when a project is named `foo-bar`, it should have a `lib/foo/bar.rb` file, or an additional `lib/foo/bar/` directory. ## Gemspec 1. Set the homepage to the project's Github repository. 2. Specify version requirements for your dependencies, such as `~&gt; 1.2`. 3. No need to set `spec.date`, rubygems does this for you. 4. Use a `git ls-files` command to only include files that are tracked by git: spec.files = `git ls-files`.split($\) spec.executables = gem.files.grep(%r{^bin/}).map{ |f| File.basename(f) } spec.test_files = gem.files.grep(%r{^(test|spec|features)/}) 5. If you are using Ruby 1.9 specific features (`require_relative`), specify: spec.required_ruby_version = "&gt;= 1.9.1" 6. **You forgot to git tag the release.** I highly recommend using [gem-release](https://github.com/svenfuchs/gem-release) or [rubygems-tasks](https://github.com/postmodern/rubygems-tasks#readme) to ensure that you _never_ miss a step when releasing a new version.
fixed
&gt; Try reading the code before revealing your ignorance and shitting all over everyone like you are so dedicated to doing on IRC. I did. That's how I informed my opinion. As to how I informed my opinion of your *character*, that was pretty easy too. After seeing both your code and your attitude displayed here and elsewhere, I think it's pretty clear that you are the worst possible kind of developer: unskilled but unaware of it, completely ego invested, pathologically incapable of accepting the criticism you so desperately need to improve, and more ready to engage in school-yard name-calling than rational dialog. You come across like a petulant and vindictive child and I sincerely hope that no one has the misfortune to work with you or your code.
Can you point to what these supposed obvious points of unskilled code are?
Didn't know about the global .gitignore possibility - thanks for that. Also didn't know about the hyphen/sub-directory rule. Not sure it's appropriate to re-release as cascading_configuration tho? Hadn't thought about tagging it. Will make sure I do that in the future. Thanks for the specifics.
What I do not understand is how anyone can get so upset over style to code. So his style does not fit you - so what? I don't like your style either. In my opinion all your styles to code suck. :) I agree that there is however a maximum of [insert item at hand here]: - There is a maximum of consistency in style. - There is a maximum of terseness in style. - There is a maximum of expressiveness for any given feature in style. I used to use Capitalize filenames for one project (the GoboLinux one). I liked this because GoboLinux likes Capitalization as well. However, after a few years I looked back and realized that this exception does not really make a lot of sense, it brings no real advantage but a few disadvantages (someone else pointed out that he dislikes to even look into capitalized filenames at all, which seems somewhat superficial, but that is how people are!) so I eventually downcased the file names too. It is a similar reason for tabs vs. spaces. When I realized that I am prone to mix tabs with spaces, I switched to all-spaces all the time. And I prefer 2 spaces vs 4 because I can fit more real information per line that way. But I am more liberal in other ways. For instance: "Wrap your lines at 80 characters per line." I do that for code part, but for documentation I dont care about this limit at all. This is the reason why I can not use yard or rdoc right now, because they demand that comments must come before the method defintion, which would kill this current style I have. :( And I dont want to use a tool that forces me to switch the way I work and code. I'll need another way for documentation...
Hey, sorry I didn't notice this message until just now. :( The site's up! Just bad luck that my provider had a scheduled maintenance that required me to make a DNS change right when this hit Ruby Weekly.
most of the include hooks are included for symmetry - tho they are occasionally useful if you want activity to occur at moments during includes, as dependency modules don't have #included or #append_features called when the module that included them is included elsewhere. I wasn't aware of ActiveSupport::Concern, though it is interesting. It looks to be addressing a slightly different concern than I had in mind - contextual behaviors rather than include/extend or ancestor event-driven behaviors. The most useful aspect that is different from just using #included/#extended is that you can use block bindings to consolidate hook contexts. An example of this is in parallel-ancestry's inheritance module (ParallelAncestry::Inheritance). That said, the API definitely needs an overhaul. 
As always I've tried to find around 10 items or so that I feel that can be improved. In this case I only found 7: 1. Update your README so that it's no longer the default README generated by whatever tool you use to create Ruby projects. 2. Your Gemspec specifies that the homepage is &lt;http://paradox.gd&gt;, this however is not the case (I take it this is your website?). You might want to link to the Github repository instead. 3. There don't seem to be any tests. For an API wrapper (or anything else really) this is quite important. 4. You seem to declare everything under `Snoo::Snoo`. This is quite bad because it defeats the entire purpose of namespacing data as well as being more of a procedural approach opposed to using object oriented code. For example, for comments you might want to use `Snoo::Comment`, for users `Snoo::User` and so on. 5. Wrap your line at 80 characters per line, this makes it readable for everybody no matter what application they use to view the code. 6. You're using Ruby 1.9 specific elements (e.g. the `{key: 'value'}` hash syntax) yet the Gemspec has no minimum required Ruby version, nor is this mentioned in the README. 7. Keep up the good work with documenting your code using YARD :)
Pretty neat, might be nice if user input was preceded by a prompt of some kind i.e. what would you like to do? &gt; And option 2 should bounce you back to option 1 if you haven't created any lists yet, it gives a No such file or directory error if you haven't got a list to edit yet.
Your methods are huge. Every time you see a comment like # if task is incomplete you can usually pull the behavior out in its own method. E.g. if hash.keys[0] =~ /\[_\]/ becomes if incomplete? hash.keys[0] ... def incomplete?(task) task =~ /\[_\]/ end /edit: typo...
good point - thanks for that. We'll change this to "Ruby" asap!
Scumbag challenge, asks for people to work on open source, rewards them with closed source toy.
From the rules pages: &gt;Additionally our Expert Panel, lead by the OS Project **Chef** I got really excited for a minute, then realized it's a typo. I'd love to be a project chef!
When a ruby blog conflates rails and ruby, you have to wonder WTF is the point. I mean, kudos to you for correcting the error, but even so.
Finished this last night and I have the same sentiment as you. You/op should also check out Design Patterns in Ruby by Russ Olsen.
Yes, 1.9.3 still uses it, you will have to use either JRuby or Rubinius to use threads. 1.9.x does use real posix threads however, unlike 1.8 which used its own greed threads implementation. This means that some cexts which had issues with 1.8 threads work better, but ruby code is still bound by a GIL. AFAIK there are no plans to remove the GIL from 1.9. FWIW forking a process isn't that bad, and it works fine for concurrency.
I'm a little confused by the challenge, I think it's only for ActiveAdmin. Or maybe the 'chosen project' changes throughout the time of the challenge?
considering getting a chef's hat as one of the prizes ;P We'll fix the typo asap :)
I'm having trouble understanding what this is, exactly. 
There is no way to avoid the GIL on MRI 1.9.x (or 1.8.x). Note that this is a problem _only_ if you actually need to take advantage of simultaneous computation on multiple cpu/cores. It is **not** true that "you have to use jruby or rubinious to use threads". You can use threads all you want -- they'll just be subject to the GIL, meaning multiple threads can't be simultaneously executing on multiple CPUs/cores. Okay, so then why would you want to use threads anyway? Well, believe it or not, threads were invented and often used even back in the days when almost all computers only had one CPU. Multi-threading, even with the GIL, can still be useful when the threads will be blocking on I/O, such as waiting for an external database, or an external HTTP API call, or even disk I/O. In those cases, the GIL isn't a problem, multi-threading can still be useful to have the waiting thread switched out giving up the CPU so another thread can use it. MRI Ruby 1.9's real OS native threads (instead of simulated 'green threads' in ruby 1.8) make multi-threading for dealing with I/O blocking work a lot better. If there are C extensions involved, this kind of multi-threading to deal with I/O blocking _does_ require the ruby C extensions to have been written properly to give up the GIL when they are waiting on I/O. This used to be a problem, but these days all popular C extension gems are written properly to do this. So depending on what you want to do, the GIL may not actually be a problem. But if it is, jruby is the popular choice. MacRuby and Rubinious, I believe, also do not have a GIL. 
Add [rack-test](https://github.com/brynary/rack-test) to that list.
What do you use to test Rack middleware?
Source or it didn't happen. :) Whatever this magical Rack testing harness is, I would like to use it.
I might be way off base here, but I think this makes it worse. Long methods (although I would argue that at 20 lines that method isn't all that long) are not inherently bad, and making another 1 line method to replace 1 method calls is not better in my opinion. The idea that long methods are bad comes from the much better advice that 1 method should do 1 thing at 1 layer of abstraction. With that in mind I think what Enumerable_all is getting at is that the List object shouldn't be where the code to determine if a task is complete resides. I would say the proper fix would be to have a separate Task object with an incomplete? method, then in the List code something like: tasks.each do |task| if task.incomplete? #do some stuff end end That's obviously a much bigger re-factoring, pretty much a whole re-design trying to follow OO principles closely.
The logic for determining whether a task is incomplete is all over the place. So this refactoring DRYs it up as well. You have to generalize it somehow, though, because there are subtile differences between the regexes. Speaking of regexes: I have absolutely no clue why they need to be there in the first place. And of course I agree with you: This code badly needs some OO design. But it seems as if it's OP's first programming language, so he might not be familiar with it yet. /edit: The intension of my first comment was actually to make him aware of the "comment some code =&gt; do I really need to comment this code or does it actually belong into its own method" thought process.
Death by Snoo::Snoo
Why would I want to develop a rails app in the browser?!
I'm not very familiar with the gem so I can't give you any 'real' input, just my opinion on your approach. I think I would have liked it more if the history of letter_opener and the effort of the pull request authors you used stuff from was more reflected. Now it's one initial import of letter_opener files and no actual commits from the contributors. If I would do the same I'd probably fork it, merge pull requests and then start refactoring and adding :)
The current state of the Ruby GIL is *locked*.
Haha, well I'm using those regexes to reverse parse from an external .txt file and organize every "line" in the file as either a main task or a sub task. I'm guessing the whole process could be simplified if I used .yaml files for IO. "comment some code =&gt; do I really need to comment this code or does it belong into its own method" When do I know the difference? Or should I always code with a mentality of "code should be so readable that it shouldn't require comments for explanation". Great advice! Thank you :-) I'm really interested in OO design, could you please recommend me a book and/or web articles on it? Thanks a lot. 
Thanks for both the ideas! Will add them. 
Yeah, I've been just starting out in programming and wasn't wholly aware of that approach :-) Thanks for mentioning marshal functions! TIL. And thanks for the link as well! Very interesting.
&gt; Action Aims to Be the Heroku of Development Environments I remember when Heroku *was* a web-based editor...
Excellent point about DRYing up the code, and I didn't mean to imply that your advice was entirely wrong. I think what you said about the comment being a red flag can also fixed with OO design. In the end the problem is that matching '[_]' is an implementation detail of the task, and unrelated to the function at hand. Enumerable_all is right about the simple fix for that. As far as a book or web site, I don't know one off hand. You might ask in [r/programming](http://www.reddit.com/r/programming/), but I mostly learned from classes and experience rather than books.
Not sure why you didn't fork in the first place. Oh wait yes I am...
Look, I contribute a crap ton to open source software. I know how it works. I've also been burned by doing work and then having it rejected (see: the rails 3 rewrite of ruby gems) only to have someone else a week later do the same thing and get cheered. This time all I wanted was a working gem so that I could get work done. &gt; If you wanted to do things to the gem that you weren't sure would be accepted in a pull request.. Why did you do them at all? ...Because I wanted a gem that did those things? What kind of question is that? O.o
sublime is the first graphical editor that hasn't made me vomit in disgust within the first five minutes. vim emulation is a little incomplete and occasionally wonky, but I'm sure it'll get better. The impressive thing about it is performance. It's so damn zippy and will tell you if a plugin is ruining your day. For the first time ever, I'm actually thinking I might stick with a graphical editor. helps that it's cross platform too. 
Erf, alright. Could you point to the part? I should clarify then if it does.
&gt;When do I know the difference? I don't know. It comes down to common sense and experience for me. &gt;Or should I always code with a mentality of "code should be so readable that it shouldn't require comments for explanation" Imo: yes. Exceptions are for example abstract algorithms where you might gain more readability if everything's in one place. &gt;I'm really interested in OO design, could you please recommend me a book and/or web articles on it? Understanding what classes and objects are usually takes only a few hours. But it took me more than a year to "fully" (I still come across new design ideas, I wasn't aware of, all the time) embrace OO. A book which really helped in the process was [Head First Design Patterns](http://www.amazon.com/First-Design-Patterns-Elisabeth-Freeman/dp/0596007124). [Refactoring: Improving the Design of Existing Code](http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672) was also a very good read. But in the end (as paulmooring already mentioned) it comes down to experience. Also: Read code, read code and READ CODE (preferably from people who know what they're doing). :)
I, too, would really like an answer to this question.
Ryan Bates name is not in the [LICENSE](https://github.com/krainboltgreene/email_spy/blob/master/LICENSE#L1) or listed in the [gemspec](https://github.com/krainboltgreene/email_spy/blob/master/email_spy.gemspec#L5)
Thanks
I am by no means a "ruby super hero". I am in fact learning to program, so it's fair to say I'm "clearly just this side of noob". But I wanted a working tool with these features and I was tired of waiting. Not much else to it.
Except Ruby isn't copy on write friendly so forking isn't that good either. That's being fixed though.
Any computer that serves web pages is a web server. A web server is just a computer. You can develop it on your computer and then run it on a public facing server later. Why are you using rails? Maybe for your use case PHP is better. It sounds like you just want to FTP files somewhere and have them served up. PHP is really good at that. If you want to write more of an application type web thing then grit your teeth and learn about using a terminal to get stuff done. You don't need to know many commands to just start and stop your rails server and bring up the console. Ruby is better at general application type stuff than PHP (well, that's subjective but you are in /r/ruby :) but you're going to be learning more general purpose stuff as a result. Ruby was designed as a general purpose language, PHP was designed to be a web language used to add dynamic functionality to web pages. The are just rather different beasts.
If you want to create a web application, as described from your original post, using Rails, please do read the provided link. In short, Rails possesses three main stages: development, testing, and production. **Development** In this stage, you'll be creating your application. Use a text editor or an IDE. The command line (CLI) is heavily used to jumpstart tedious creation of pages, tests, gem installations, etc. [Read the tutorial](http://ruby.railstutorial.org/ruby-on-rails-tutorial-book) as it is a great resource. Within your development stage, you are given an opportunity to run your application locally on your machine (consider this as a visual and functional example of your app). **Testing** You'll learn, if haven't already, of Test Driven Development (TDD), the new hotness within Rails. From your command line, you can run and monitor tests. **Production** You have many choices for deploying your finalized application. Many people choose [Heroku](http://www.heroku.com/), which is a cloud-based platform. [Check out the first thing from Google, if you need more insight](http://stackoverflow.com/questions/4727399/what-is-the-best-software-to-host-a-ruby-on-rails-application-on-production). 
Yes, I think you're making a good jump and a good choice to use Ruby. Try not to be discouraged but realize that you'll have to learn some things you don't really care about in order to get up to speed. Once you're there you can focus more on making the game itself. We call that yak shaving. You're undertaking not only Rails and Ruby but a bit more general skill around using a unix machine. It will apply to many other things and hopefully will be worthwhile. My advice is to take time to learn a bit about the unixy terminal stuff but jump back to Ruby and Rails before you're tired of it or overwhelmed. Bounce back and forth as your attention and interest allows. It won't be as hard as it seems at first. The hardest part is the very beginning where *everything* is new.
+1 for Fedora 17. It provides Ruby 1.9.3 and RubyGems 1.8.24 packages.
Oh, no sweat then! The terminal stuff is mostly to start and stop the server and run DB migrations when you change the schema. Also, the console. You will love interacting with your app in the console.
As someone who moved from PHP to Ruby back in the day: You have to abandon the 'files are pages and pages are the components of a website' attitude if you want to use *Rails*. Rails builds applications, not web pages. The workflow you used to use under PHP - perhaps something like 'edit page, upload to server, refresh page' will not be very effective with Rails - you'll want to run it locally to view your changes, then deploy properly using Git and your choice of deployment tools. If you want to just use *Ruby*, look at something like Sinatra or pure Rack - it's entirely possible to take a file, parse it with ERB, and display it to users. ERB is the equivalent of PHP in Ruby - an embedded version of ruby used to fill in text. [Here's a real application in pure Rack that I've helped write, the embedded Developer Mode in New Relic](https://github.com/newrelic/rpm/blob/master/lib/new_relic/rack/developer_mode.rb) and [what the 'pages' actually look like](https://github.com/newrelic/rpm/blob/master/ui/views/newrelic/index.rhtml) just for example. This may look more familiar, but it's also more difficult, since you end up building it yourself. That's not what most Ruby code is though. Most code in Ruby is in the gems you'll use - more analogous to PHP's PEAR or Perl's CPAN than the PHP standard library. You probably won't do any substantial amount of work in raw Ruby once you've learned the basics of it. Think of the Ruby web ecosystem as encompassing more than PHP does - PHP you end up having a server, generally apache, which in Ruby is mostly built in as Webrick. There's an expectation that you will, in general, not reinvent the wheel and use the libraries available since they'll make your life easier. So there's more to learn but it's worth it, trust me.
`script/server` is older versions of rails, remember. It's `rails server` or just `rails s` now.
yeah, the kind of people who so easily conflate 'ruby' with 'ruby on rails' are not the kind of people i want anything to do with. Yergggh. Let's all rejoice when the world is rid of rails retards
I'd solve the find problem like this: ary.map { |x| r = x[/(.+)berry/,1] and break [r] }[0]
Improved ary.find {|el| break (el.match(/(.+)bery/) or next) }
Great site, way fun.
It's kinda like Github:FI but without the pricetag. We've been using it at work for about 6 months and love it.
"Everything you do effects everyone else" Grammar nazi alert, the word you're looking for is "affect", not "effect".
Improved ary.find {|el| el[/(.+)bery/] ? break : next }
If I'm already on gitolite, is upgrading to Gitlab as easy as just cloning the repo and starting the server under the gitolite user?
Thank you. Unfortunately, ruby-llvm doesn't support LLVM 3.1 yet.
This has made my night. Bravo!
This is pretty cool.
That was good fun. Well played Eastmedia, well played. :)
coderjoe, thanks for making http://onebigchatroom.com/rpg a reality. I miss rpgs way too much. Have a lovely bike ride!
This looks pretty dope. After struggling with Redmine+gitolite, I'm looking forward to trying this out!
I have just started watching after a quick trip to see Brave. Are ya'll learning much? Seems like a pretty nice line up and awesome topics. 
My company ([CrystalCommerce](http://www.crystalcommerce.com)) developed and has been using a multi-tenant gem called [dbhijacker](https://github.com/crystalcommerce/hijacker). We just recently added support for multiple database servers. It connects to a database name based on hostname urls specified for the controller. It also supports partial connections (called "sisters"), useful for our e-commerce case of stores with multiple brands.
Thanks for the heads-up! I just added an update to my article. I had no idea such a thing exists :) 
why not submit patches to rails/activesupport 18n instead?
Because Rails I18n have totally different ideology and architecture. R18n realize Rails I18n backend API to have Rails compatibility.
Main idea of Rails I18n is common API for different backends, to use this API in Rails code. So filters, class translation, flexible locales are not part of common Rails I18n, because it must be simple, just API. This features must be part of another bigger backend, to integrate with Rails code. r18n-rails provide this way and allow to use simpler API in app.
How does this related to Ruby? This might be better suited for /r/programming or /r/clojure.
You're right. I'm sorry. Totally my mistake.
Wow, this is a novel feature. Also you support WebDAV! I might be more careful when monkeypatching core classes. Possibly move the extensions into modules that are included/extended into the classes.
While a great gem it still has a lot of the problems I find with regular i18n. 1. The "root" is the locale. See the reasons why I don't like it here: https://gist.github.com/2866752#gistcomment-342072 (Examples above) 2. YAML files aren't re-read on change obviously, which means a restart whenver you make changes. This is not conductive to a short cycle. 3. On large projects (see: spree) there is often a fair amount of "dynamic" text. Since it's YAML the dynamic nature is extremely limited and impossible to unit test.
Thank you, Thomas. This one is very useful in my everyday work.
Finally - awesome!
Scott Tiger? Do you work for Oracle?
I'm not sure it's true that Rails3 does that for you. I think maybe in Rails 3.2, the _generator_ for migrations will in some cases generate a migration with an index add in it (perhaps 'automatically' in some cases, in others based on arguments you supply on the command line). Is that what you're thinking of, are you talking about the migration generator specifically?
Use this: https://github.com/lomba/schema_plus
Looks interesting, especially the screencast. Thank you.
sure thing. I'm going to do some more. The screencast got a little long I think. I'm going to try and focus on shorter (about 10 minute) ones for the next few.
I've only had a chance to watch a little of it so far but it is very good. Thanks for putting this together! Edit: I have finished watching it, and thank you again. I am still learning Ruby and Rails so I am thinking about creating a site with this idea and changing it to a Rails project for Heroku. Thank you again!
if you add a new post with a new category, are all old posts re-rendered to include a new sidebar with that new category listed?
Yes just regenerate the site
1 and 3 problem can be fixed with custom loader (just two methods). It is custom, because: 1. For common case, I think “one file for one locale” is better. 3. Dynamic text is very specific. But special build-in loader for tests are very good idea. Do you have any suggestions about API?
There is special ACCEPT_LANGUAGES http header with several user languages list. JS has navigator.language, but it is not use in R18n, because it has only 1 language (some people know several).
This API can be realized with custom loaded, which values with proc filter. I think this syntax is too long, but I often see situation, when we need to get calcualtion like #{user.name}. I think, maybe realize some build-in filter to support #{} inside YAML? Like: hello: world: "Hello, and good #{time_of_day_as_word} #{arg[0].name}!" I think, that we don’t need real Ruby in translation for common case, but maybe I wrong.
Why you write `handles :en_us, :en_uk`? You can now just put `en.yml` and it will be used for `en_us` and `en_uk` locales too. And in `en_us.yml` you need just to redefine different values, without duplicating all common translations.
Rails I18n doesn’t use `locales list`, only one locale (you need to load fallback extension, with are more difficult). But R18n load locale list. For example, if I run `R18n.set('fr_CA')` it will load `fr_CA`, `fr` and `en` translations. If I run `R18n.set('kk')` it will load `kk`, `ru` and `en` translations (because all people in Kazakhstan know Russian better than English).
Sure, in this imaginary gem you can say `handles :en` and mean all those sub-systems as well. I like to have granularity. Again, though: locales as root files is an anti-pattern.
I feel "lucky" for doing the (request, response) wrapper to begin with, when I adopted Rack back in the day. None of my code is strictly dependant on Rack thanks to that, just like it wasn't dependant on WEBrick either, which I used before Rack was around and got accustomed to passing around the request and response objects.
Downvoted for flamebait title.
Thanks for the advice guys (and possibly girls)!
Many thanks. I'm working on a little project now that makes heavy use of scraping across a variety of data sources and have come across a few of the edge cases. So far I've been able to get around most by disabling ssl_verify_mode and force encoding to UTF-8.
This is a great polling site! I use Rubymine because it does the following: 1. Occasional debugging - Guido (creator of python) listed it as a reason as well for using PythonCharm 2. One click to get API docs (don't have to go on the internet to lookup a method, including Rails and gems) 3. Nice formatting and auto formatting (yes this one the good text editors do) 4. Code completion is nice, but not a big deal The first two are the big ones for me. The only cons for Rubymine is slow startup.
I like RubyMine. SSDs really help with the slow startup, as it indexes all the files and such :)
The sensible handling of code completion and formatting are why I use RubyMine. I do an equal amount of PHP development at the moment and strangely never got on with the PHP equivalent, PhpStorm. The slow startup has only tended to be a problem for me on my oldest machine, a Lenovo T61, and then it's primarily the loading of new projects - not the actual startup. On anything more recent it's obviously still not as fast as Vim or Geany, but I never get too annoyed. But then I do tend to leave it constantly running, and rarely switch between projects.
Eh, I've been known to take pot-shots at Python now and then, but always in a "ha, ha, only serious" fashion. In my experience, Rubyists occasionally troll Pythonistas *because* they overreact. Pythonistas, on the other hand... I dunno. People who believe in the 'Zen of Python' are like a cult or something. Seriously, stick to Ruby. It's more fun, there are *way* more jobs, and the community is hella awesome and supportive. 
Vim (MacVim actually). This build: https://github.com/gordolio/macvim with janus and powerline. Never liked nerdTree much and this build solved my particular problem.
I only hope they implement remote execution soon, because for all of us Windows developers that run Ruby and Rails in virtual machines, a lot of Rubymine features go down the drain.
gvim
Cool: currently more Linux votes (257) than Windows (231).
http://flippedkart.herokuapp.com/ is what /me did :) scraps from http://www.flipkart.com/view-books/1/bestsellers
Redcar. (actually Textmate, but sometimes I go back to Redcar to check out how far theyre coming along)
I use Vim for everything, but also for this.
Vim
It basically gives you a good set of plugins and defaults to work with, so you don't have to spend a lot of time messing with your vim setup
is there a list of them somewhere? i didn't find any last time i was looking
&gt; Alternatively, use Markdown. RedCarpet provides a simple, robust solution, and is often easier for users than trying to write in HTML. Be careful, most markdown implementations actually allow HTML in the input, with different (or non-existing) forms of sanitization. I don't know about RedCarpet specifically. 
Yeah look on github, there's a plugins folder I think Edit: janus/submodules.yaml
[SublimeText](/r/Sublimetext) for the win
Why on earth would anybody use WEBrick as an HTTP proxy? You're much better off using [em-proxy][em-proxy]. [em-proxy]: https://github.com/igrigorik/em-proxy
vim with NERDtree, snippets, and rails.vim
Geany
I've really, really, REALLY wanted to stay with VIm. I've put some effort into tweaking it out for Rails development, and it works quite well in a terminal remotely. But 10 seconds into trying Sublime makes me think that I'm going to buy it. I'm going to use it for the next few days and see how I get on.
It's on there now.
You're doing a great job! I'm watching the repo, and you're taking the suggestions well.
Because performances were not a concern. I wanted something to code in less than 20minutes and WEBrick was the first option available. casper was born in an afternoon to prove a redirection error to a developers team so... I was in rush =) Thanks for the suggestion, I wasn't aware about em-proxy gem
Interesting. I'll make a note of that in the article. Thanks!
It looks like minitest has the same [Delegation Issue](http://myronmars.to/n/dev-blog/2012/06/rspecs-new-expectation-syntax#delegation_issues) in minitest/spec. BasicObject does not include [Object](https://github.com/seattlerb/minitest/blob/master/lib/minitest/spec.rb#L539-541) Would you expect a similar patch to minitest/spec coming soon? Or would the preference of minitest users be to fallback to the assert api?
I've just started using ruby, but I use macvim with [spf13](https://github.com/spf13/spf13-vim) plugin
Yup. Works on Linux, Windows, and OS X and you can write python scripting engine.
Eh, they said they thought they made the right choice at the time they made it. If they were starting from scratch in June 2012, they might have made a different decision. is what seems to be the implication and general thrust of the post. 
I really like a lot of the features for sublime text, but the vim shortcuts are kind of buggy for me. Sometimes it doesn't escape to command mode..
Ugh, this poll assumes I'm voting from my dev computer.
Komodo edit
I personally disagree with the entire shim executable approach of rbenv. rbenv describes itself as "unobtrusive", but I can't think of anything more obtrusive (and invasive) than actually _overriding executables_. Ouch. See my blog post; switching between different Ruby versions is a matter of modifying two and a half environment variables. I have no idea why RVM and rbenv have become the behemoths they are, but what else am I to do than to try and fix the situation. :P You won't enjoy rbfu (or rbenv, for that matter) if you're a heavy user of gemsets (which may be the missing feature you mentioned?) I personally believe gemsets are pointless. Up for some further discussion? :)
I'm not sure I understand how this works in production. The asset pipeline compiles all my scripts and styles into one file each. Do you include your asset groups in production and enable compilation?
It didn't take days. It nagged me on a file save. I had seen enough; I bought it.
I've been using VI since college 20 years ago. While I can get around OK compared to mose, I've only started to really get into using VIm after I found NERDtree and the mini buffer explorer, which work pretty well with a mouse, but are painful in comparison within a terminal. Even if I could figure out better ways of getting around the 'tree and the explorer with keystrokes, I'm doing WEB DEVELOPMENT with it, which means I have to reach for the mouse every time I want to try the results of my work and interact with the page and the JS debugger. So I can't live without the mouse. Once this is established, then hobbling myself with `:! mv app/views/users/index.html.erb app/views/users/index_old.html.erb` is kind of ridiculous compared to a single right-click on the file explorer pane of ST2. So how is it improving my workflow? 99% of what I want to do with a text editor is available out of the box, without having to spend hours setting up plugins and learning obscure keystrokes in VIm. For instance, I now have little triangles for code rollups. I could never bring myself to learn the 'strokes for folding in VIm. Sorry, longer than I thought. I guess I'm working through the rationale for myself.
I don't understand what you're saying. rbenv doesn't "override executables", it proxies them. The shims are nothing more than scripts which initialize the environment and then call the command given prefixed with "rbenv exec &lt;commandname&gt; &lt;arguments...&gt;". You can run rbenv without utilizing the shims by just executing everything in the form 'rbenv exec ruby' and the like. The shims become useful in environments where you want rbenv to handle your environment but you may not be able to guarantee your environment. The only difference I can see between rbenv and rbfu is that rbenv requires the path to include its shim and bin directory, but leaves the path alone. rbfu on the other hand modifies the path with every new ruby selection. I haven't tried it any further than that, but it looks like I'll run into the same problems with deployment that I did with rbenv when I switched from RVM. RVM's evil magic allowed me to take shortcuts and ignore the fact that rubies were changed when writing cron jobs, and when deploying with vlad. rbenv didn't perform the same magic, so I needed to make sure to explicitly define my environment for my shell under all of the different execution circumstances. (Interactive, non-interactive, non-interactive SSH execution, environment-less cron job, etc...). Once bundler was released I abandoned gemsets all together... so that's no longer a selling point for me. With all of this in mind, other than the lack of shims rbfu seems to be incredibly similar to rbenv. In that case, it looks a light weight solution isn't what I need for my use case. Are there any benefits I missed? Why would I want a lighter weight solution?
I couldn't afford a mac either, fortunate to have one from work. But Ubuntu kicks butt for development. I can't imagine developing Ruby on a PC.
My biggest problem wasn't with version aliasing. I didn't use that with rvm and I wouldn't make use of it on a production instance anyway. I need to make sure I'm running a well defined exact version on my production instances. My biggest problem with rbenv wasn't necessarily an rbenv problem, it was a problem caused by switching to vlad while also switching away from a deployment method that required the use of sudo. The problem stemmed from the common instructions to install rbenv by adding path and configuration to your .bash_profile file in your home directory. Unfortunately .bash_profile is only run for interactive login shells. vlad deploys by using an SSH command shell which is an interactive non-login shell. I solved this problem by moving my configuration to .bashrc outside of any checks for interactivity. That at least got me to the point where my paths resolved and the rbenv executable resolved. &gt; This is just a hard problem to solve, it may be there is no good way to provide something that is both simple and meets everyone's actual use cases. Yeah, rvm fit my need mostly until the return value of the "cd" command wasn't what I expected (I've heard that this problem is long since fixed). That was enough of a reason for me to give switching a try. Configuring rbenv remotely was a pain in the ass, but now that my chef ruby server bootstrap is configured to use it, it's pretty much fire and forget... so I'm using rbenv for the foreseeable future. &gt; I wish ruby was more stable and we didn't all need to install a bazillion different versions at once, and always a different version than what the OS package management provided. I don't think it's a matter of stability, I think it's a matter of momentum. Of the different languages out there, Ruby (and to some extent Python) move at an incredibly rapid pace. However, unlike other communities, the Ruby community is in the habit of jumping on bleeding edge releases extremely quickly. Combine this with gem versions releasing even quicker, mixed with combinations of gem versions and rubies, and you get a management nightmare for a distribution's package manager.
&gt; production/deployment machine If you ever have RVM (or rbenv) installed *there*, very likely you're doing it wrong.
Huh, I don't think you're paying attention to me. &gt; install the Ruby into /usr/local You realize I need more than one ruby, right? Oh, I see &gt; then set the PATH accordingly for the users. Why is this less confusing or stable than using rbenv? Although honestly I'm not completely dismissing it, it's worth considering. And is essentially the rbfu approach, right? rbfu is just a way of easily switching the PATH (and the one and a half (half? I dunno) other ENV vars that need to be changed). I suspect I'd run into all sorts of other weird edge case problems that rvm, rbenv and even rbfu are all meant to lessen. Is this something you've actually _done_, and have been doing for a while, with multiple ruby versions, and cronjobs, and capistrano, etc.? If so, then it is indeed useful information to hear from you that it works out fairly painlessly. &gt; Better to upgrade to 1.9.3 or JRuby. That'd be nice if there were a released stable puppet that worked on 1.9.3. &gt; Personally, I would just use the Ruby packages provided by your Linux distribution, and not worrying about updating them. That'd be nice if my linux distribution supplied a non-ancient ruby that would work with _anything_. &gt; Fedora 16+ provides packages for Ruby 1.9.3 and JRuby 1.6.2. That's nice for you if you're using Fedora 16+. Perhaps I can convince our ops staff that they should either switch the distro of our entire server/VM fleet in order to accomodate my ruby needs (surely they can do that in an afternoon), or make a special case with custom management routines and special work to verify/troubleshoot that it works out right in our VM environment... for my 2-3 servers that need ruby.... because the rbenv solution works okay, but some guy on the internet said we were doing it wrong. ---- Again, I acknowledge there are lots of ways of doing, each with their own pain points. The one that works best for you will depend on exactly what's going on for you. For not just me but _lots_ of people, rvm or rbenv seem like the least painful one. If you have a situation where it's easier to do without, more power to you, I agree that would be great. 
My experience is RVM breaks, a lot. The final straw for me is when it refused to update because my bash install in Linux was newer than the one that ships with MacOS X. But, hey, all software has bugs and that's going to happen. My larger issue is you never have a consistent install. It'll fetch the latest version of whatever, which is fine on a single machine, but really sucks when trying to make sure your entire team or a cluster of servers is running the same setup.
RVM is actually a "Ruby Version Manager" since you can install versions of Ruby with it. I find that feature so convenient (including -updating- versions of Ruby) that I am not willing to change easily. If rbfu made it easy to install Rubies - even if it's just installing ruby-build and running the command for you - I'd be willing to give it a spin for a while. Gemsets are becoming deprecated very fast since bundler, er ... 1.1, I believe. [Edit - OK, I read the readme. Pretty much everything I said is 86-able. So now the last question.. Why not contribute to RVM or rbenv? Just because you wanted another one? Well - if it really just does what you want, go with it. Honestly, I think rbenv's approach to saying "RVM's implementation sucks" just triggers a kind of mental masturbation where everyone says "PAH I CAN TOTALLY SOLVE THIS PROBLEM BETTER" ... And then we have the problem solved twelve different damn times when it was solved once just fine.]
Well, the point is RVM leads to an inconsistent environment. If you download v1.14.3 today and v1.14.3 a month from now, you could end up installing very different software because RVM will always use the latest released packages. I spent a lot of time jumping through hoops, messing with its DB config to lock down versions, blow things out of global gemsets, etc. in an automated deployment situation (I work on [rubber](http://github.com/wr0ngway/rubber)). But, like I said, it's even problematic in ensuring a consistent environment locally or within a team.
I've actually been talking to Sam on Twitter about the shim executables' purpose. The thing is, they're not necessarily a _bad idea_; it's just another approach to solve the problem of transparently modifying the environment at _some_ point during command invocation. Personally, I believe they're overkill (and too much of an invasive procedure), but it works for a lot of people, and I'm cool with that.
I don't necessarily think it "needs fixing"; it just goes against my personal philosophy of how software should work (focused on single tasks vs. the kitchen-sink approach). I don't have an agenda of making people switch from RVM or rbenv to rbfu. If RVM or rbenv work great for you, that's cool. I'm merely offering an alternative approach that happens to work better for _some_ people.
My problem with rbenv's reasoning is that it mostly focuses on the way RVM hooks itself into the `cd` command. YMMV, but in my opinion this really is, by far, not the biggest problem with RVM. Both RVM and rbenv are (or have become, in time) relatively opaque wrappers around a very simple mechanism (modifying environment variables.) RVM keeps adding features that may seem convenient for some users, but are causing problems for others. The recent addition of automatic 'bundle exec' invocation is a prime example. I personally prefer explicit invocation to opaque magic that is hard to fix or work around once it fails and you don't know what's happening behind the scenes. This is the reason why I like typing 'bundle exec' when I mean it, it is the reason why I prefer rbfu's approach to RVM's (or rbenv's), and it is also the reason why I believe rbfu needed to be a separate tool. You can't create pull requests for cultural differences. I realize that not everybody feels this way. If RVM or rbenv work fine for you, that's perfectly cool. There is no point in trying to "convert" people to rbfu; these things are just tools, and I am merely trying to offer an additional option. Which is also the reason why I'm not adding an "rbfu install" command. rbfu will do just one thing, and that is why it exists. :)
You're so right. I strictly seperate system ruby (for e.g. puppet) and "app" rubies. Special "app" ruby versions and a few gems are stuffed in a debian package. Using rbenv to install more than one version to a server. And I'm not sourcing rbenv into my environment if I do not need it.
(A note for other readers: postmodern and I have discussed this in detail, resulting in [a new issue](https://github.com/hmans/rbfu/issues/19) that I'm hoping to tackle before the 1.0.0 release.)
I don't understand what you mean by 1.14.3 today and 1.14.3 a month from now and ... Different software? Same version of RVM means same version of RVM. The environment around it is the environment. Unless you mean .. The Ruby ecosystem? If that's your problem, then there's no reason to keep on using RVM to install things. Use RVM for the environment it gives you, install Rubies and gems and rubygems once, then package it up and use your deployment thingamabob to make sure your system is the same. Either way, the problem you're having has nothing to do with RVM and everything to do with the environment. I used RVM within a team and on a production machine (we needed different Rubies and passengers) without any problems - mind you, we were fairly Agile about the whole thing, which helped.
The RVM version is the same, but what it downloads and installs is not. If I tell RVM to install 1.9.3-p194, depending on when I install that command I could get a different version of bundler, rake, rubygems, or some other stuff. It's not locked down like it is with ruby-build.
Rein, you bring up some great points, some of which are addressed in the comments section of the post. Regarding your second point, I recall removing the score column, but this throws an error. If you try your suggestion and it works, please let me know. FYI I was replicating virtual attributes which are found in Rails/AR but not documented for Sinatra/DataMapper. I plan to write about this soon. **EDIT** Removing the score column DOES work. Thanks Rein! This will be in the next iteration. Thanks for the comment! 
You *should* be able to simply define an `attr_accessor` for "virtual" attributes, which is also how it would be done in "pure" Ruby. DataMapper is somewhat more friendly to pure Ruby idioms in this way. Source: I'm a former DataMapper core developer. ;)
Monkeypatching the kernel is risky, but it's what 'open-uri' does too. I ran into problems when I override the 'puts' method inside a class and added 'puts' with debug messages. You have to call STDOUT.puts instead. But the final result looks better when you're able to completely hide an API.
I've been on a kick where I answer the classic "How would I make an app that does X?" questions in /r/webdev by creating their app with Sinatra + DataMapper and posting it into a comment.
Gruff generates images from data, and returns them to the client, so the browser just needs to display the image. On the other end of the spectrum, you can return raw data to the web browser (as JSON in most cases), and render a chart with Javascript via [jqPlot](http://www.jqplot.com/) or [g.Raphael](http://g.raphaeljs.com/)
You mean copy the precompiled ruby across? If so, that could work. Although I have a mix of 32-bit and 64-bit machines. If you just mean the RVM install directory, that doesn't gain me anything. But really, just using ruby-build and managing the environment myself is markedly easier. And I've managed to cut out a whole class of problems related to RVM + bundler + cron.
I've used Google Chart Tools with good success in the past. 
It sounds like you're dealing with a heterogeneous set of hardware and software. I do not envy your position, and I am beginning to think that RVM may not be for you -- and in fact I'm beginning to think that we're talking about the wrong problem. I don't know your situation beyond what you've explained though, so I can't be sure.
I gave up on posting in /r/rails because it seems like all the posts there are ignored.
Emacs is my answer for most "what program do you use for x?" questions. 
I'm on EC2. They have some instances that are 32-bit only, some that are 64-bit only. Or rather, that's at least how it used to be. Now all 32-bit instances can be run as 64-bit, but obviously if you had instances running previously, they're still 32-bit. We've tried to standardize on the latest LTS for Ubuntu, but not all older instances have ben replaced yet. So, it's mostly homogenous, at least in spirit, but there are differences. RVM would be fine if you got a repeatable outcome. You don't. Like I said, we tried to get around that by manipulating the RVM DB config. It wasn't pleasant, but mostly worked. The problem came when we wanted to update to the latest patch release Ruby, which necessitated an RVM upgrade (which has no release notes, BTW) and find out how much has changed or is just flat-out broken (it's broken bundler on me several times, there was some stuff around colored output that broken sessions in non-login shells). I get the philosophy of always grabbing the latest and greatest, but more often than not, that just utterly breaks everything (see: rake 0.8.7 -&gt; 0.9.x). ruby-build gives me most of what I need and more importantly has well-defined, expected, repeateble results.
As an ex-sysadmin, I sympathize with your plight. It sounds like you have issues with Linux - not RVM. Non-login shells should never have any kind of text output, for instance. Why not? Precisely because output can break sessions in non-login shells. That's not RVM's fault. The rake 0.8.7 -&gt; 0.9.x was another example of backwards compatibility being broken. Why it wasn't a major version upgrade is a question that RVM cannot answer, and it was a mistake on the part of the devs. Again: the issue is not with RVM but with the Ruby ecosystem that experienced some growing pains in the past two years
It's pretty common for cron to email a sysadmin if anything is printed to STDERR. That's precisely what RVM did when it was unable to set the color for output. Obviously it shouldn't have been doing that at all in a non-login shell, but it did and resulted in a failed cron task for anything using ruby. That's wholly an RVM issue. As is the bash version check that was hard-coded for MacOS's ridiculously old version. It's a death by 1,000 cuts type situation. [Edit] I agree with the Ruby ecosystem part, too. Which to me is all the more reason to not just blindly fetch the latest package...
Oh, I see.. A lot of little things I apparently managed to avoid by chance. For instance, I use Gentoo - so on OSX, I installed the Gentoo tree and use Gentoo's bash, etc. etc. Why was RVM setting the color for output in a non-login shell? I have some suspicions that there was a line in the wrong config file but can't tell. And as far as the Ruby ecosystem, it's ... Well, the thing is, RVM is making the sane choice. Fetching the latest package should not be a problem. It really shouldn't. I mean, think about it. When is that a problem? Unless it's OpenSSL and there's a known security hole in the latest package...
I think a step back is needed here. If you're machines are all different achieving the same environment may not be possible, and controlling multiple ssh sessions won't be the easiest to do, especially if concurrency is your goal. Instead create a default environment on the machine for your chosen user that is compatible and just run things using backticks and check your output eg \`ssh 192.168.10.1 ls /tmp\` Try to keep things unixy, ssh has already been built to do all this for you, strings, pipes and files!
I think I need to clarify the use case: export VARIABLE1="something" export VARIABLE2="something" /run/a/command #Check the return value/output and then either /run/a/different/command #or /run/yet/another/command You can of course use something like: ssh somewhere 'export VARIABLE1="something";export VARIABLE2="something"; if /run/a/command; then /run/a/different/command; else /run/yet/another/command; fi' But you can probably see that this quickly gets all tangled up and buggy. So my goal is to put together a nice DSL that would allow me to write pretty code and get good results. The best solution I have at the moment pretty much packs all those commands together like the second example. But I would love a solution that would also allow me to interact with the individual commands. EDIT: Formatting
This sounds to me like capistrano. I'd start with that. There's also an alternative called vlad the deployer. They're geared towards deploying rails apps but you can just write your own recipes that run the commands you need to.
How about something which compiles it down to a bash script, scp's it up and then runs it?
I looked into capistrano, it only does very basic SSH stuff. There is no interactivity.
This looks like a nice script builder. I might try this if all else fails.
Is #real even needed? If not then this could be simplified to: def score points.pred / (time_elapsed+2)**1.8 end def self.all_sorted_desc all.sort_by(:&amp;score).reverse end
Without #real, over time, you will receive errors regarding complex numbers and the score attribute. Someone on github felt the same way until I pointed this out. Have you tried your (:&amp;score) suggestion? I tried this before and it throws an error. Our attempts to use (&amp;:score) stem from developing with Rails/AR. Sinatra/DM is different. Please let me know if it (&amp;:score) works for you. 