Starting a "Let's Read!" series over Ruby books new and old. To start I'm going with one of my personal favorites, Eloquent Ruby. Now the original was released in 2011 around Ruby 1.9.2 and some things have changed, so this includes a lot of notes on how development has changed and evolved since then. Noted that I'll only submit this first chapter directly to reddit. The remaining ones will only be mentioned on Twitter as I get through them.
"Utilising the rarely-seen %= operator" Ah, always fun to see those ones thrown around. It works with all operators, though I've yet to find any particularly fun uses of it outside of the normal ones like `||=`. Nice article, always fun to see classic problems explained in a bit of detail. You might enjoy "To Mock a Mockingbird" if you haven't read it yet.
Anything Mame touches is holy, true Ruby code. Bask in his glory. In all seriousness though, some of them do incredible black magic trickery in Ruby. That said, I would also not let any of it within a mile of production code, and that's part of the point of it.
Oi, tone it down. No need to be rude to people. A simple answer of "There's a normal version available in the lib directory" is sufficient. The rest is just being antagonistic.
&gt; No need to be rude to people. I somehow don't see you policing the other guy that passive-agressively insults me. Hypocrite.
Maybe the plugin isn't already doing this? You might be able to tell be examining which symbols the plugin links with
Did you try http? If not, you may be able to click a link on the page and proceed anyway
Nope. Auto redirects to https. If I choose to proceed anyways, almost every script is blocked by default. Not really a practical learning environment.
their cert is just expired, just proceed anyway unless ur actually logging in.
Thank you! This also looks very promising
Ugh that was copy/paste error, I'm sorry. Fixed it. Definitely not trolling, just posted worn out &amp; made a mistake removing potentially identifying info
EDIT: Mismatched brace was a mistake in this context (there are some, but only at top &amp; bottom of file so pretty easy to avoid)
I'll look into that algo. Yes it has multiline quotations but they're generally a YAGNI.
FWIW, all of the data can change at a moment's notice; "employees" might become "people" or "humans" or anything else; same with anything else. 
Any chance you’ve checked out the swagger code gen tool? That might help with writing for different versions. 
OK, that makes it much easier. I've whipped up a simple parser that might help you along: [https://gist.github.com/jacoboreilly/25f240217e745f3e7642bd1696770b5f](https://gist.github.com/jacoboreilly/25f240217e745f3e7642bd1696770b5f) I feel like there are probably other cases not represented in your sample that you're facing and I know I've not handled all possibilities with grace but hopefully this is helpful.
I wrote an example parser, that can handle the text you pasted in. Hopefully it will give you a rough idea of how to do it. Have a look at the tests too. https://github.com/tomdalling/wierd_parser
Thanks for doing this. I haven't read this in years, I'll re-read along.
Instead of taking a string and going through each character and substituting non-alphabetic characters and THEN converting it to an array of characters to iterate over, we can just apply the logic while iterating if the goal is efficiency. Plus, we can use `each_char` over `split('').each` because it's way more faster (almost 4x) in addition to being a bit more readable! result = Hash.new(0) statement.each_char do |char| result[char] += 1 if char.match?(/[a-z]/i) end I did some benchmarking with `benchmark/ips`. Your solution was 50% faster than OP but the aforementioned solution was almost 2.75 times faster than OP (and 76% faster than yours).
How frequent are you gonna do this? Also, is the book available in its entirety for free somewhere?
I'm very likely going to be posting new chapters as I get through them and have time. As far as getting it for free, no. I would not endorse piracy either on it.
Good point, thanks!
&gt; Ideally the names of classes, variables, and &gt; methods can be used to give clarity to the intent &gt; of the code so such comments are unnecessary. No. I also don't understand this "hey we don't have to use comments - the code is self-documenting!!!". No it is not. You were just too lazy to document what you did. Comments do not cause harm. They don't kill kittens. If you don't want to read comments, filter them out before you read .rb files. You can easily use ruby to do so, too - just detect all # which covers most comments (excluding the other comment style which is very rare). I feel that the real reason why comments are sparse is because people are very, very lazy. So they come up with excuses to not document their own code. In all the years reading ruby code by other people, using comments and documenting the code is ALWAYS better than undocumented meta-shit nobody really understands (and has bugs on top of it). I very happily discard any code that does not come with proper comments; the more the better. Otherwise it would be a huge waste of my time to sift through awful code - and even though ruby is the prettiest language, people can do real atrocities with it syntax-wise. Lots of the code out there is AWFUL. Some of it is brilliant, though.
I respectfully disagree with you. Bad code needs comments. Good code does not. I would be inclined to reject PRs with bad code, or unnecessary comments (i.e. for self-explanatory code). The only time when comments are acceptable IMO are TODOs, describing unexpected third party behaviour, documentation of core methods in a shared library, and so on. These are all exceptional circumstances, and not the norm. The BIG problems with writing lots of comments are: 1. Comments go out of date. Especially during refactoring, where code gets moved around. 2. If you comment all of the "unimportant" things, then the truly valuable comments for "important" things get lost in the noise. 3. Comments are not a substitution for tests; they might lie. 
they had only issues for the last two years. I remember doing their courses back in 2015 when it worked smooth, the content is great, but they changed their hosting provider and that caused having their site down for a year or so. Also at the beginning of the year i noticed it was back up, but kept having other issues, like CSS not being loaded, and it was responding really slow. Too bad they haven't figured it out yet, it's really the best place to learn ruby imo
How pleasant.
It seems like your Controller might be doing too much. Possible alternative - In your module/concern overwrite `#save` def save if super do_something end end
Oh look, another pleasant person, just jumping on the occasion to insult someone. It took you over a day but I see you couldn't just stop yourself. However I'm already out of this sub, since it's dead anyway, so don't bother replying.
Seek out help man. That's all I have to say.
So, you want every model to respond to `#do_something` but only those that include the module to actually do something? You could define an empty method `#do_something` in `app/models/application_record.rb` which will be overwritten by any models that include the module. # app/models/application_record.rb class ApplicationRecord &lt; ActiveRecord::Base self.abstract_class = true def do_something; end end 
i think by using something like #respond\_to your code makes it clearer that only somde models have and use that method, while if you're always calling it and define in each model class, in some with implementation and in other as a no-op handler you always think that something should happen there when debugging, thinking that something is wrong, just do discover in the end that it was one of those models that had the no-op handler, and that the code is working fine. Anyway since the difference of implementation is at model level(e.g. some need to do something and other not) the best way to tackle this is in the models themselves, with a lifecycle hook like `after_create :do_something` , and eliminate the need to call that method from the controller. 
I'd considered writing a Yardoc plugin to fail CI if the comments lie about param names or arity among some other things. Normally for me I use Yardoc for methods, classes, and particularly hairy sections of code. Sometimes I'll tie those TODO or warning types into issue ticket references as well. What's odd about the earlier reply is I noted all this and said I'd encourage commenting like that. 
It is not doing that, I verified by experiment that background threads do freeze while outside of ruby code. :/
If it was _really_ `record.do_something if record.can_do_something?` (notice you are asking the same record you are telling), the obvious step to consider would be embedding the "can" in the method. On the record: def do_something return false unless can_do_something? # other stuff end or even a new method def do_something_when_possible do_something if can_do_something? end I suspect this isn't answering your true question, but just because sometimes obvious things escape us it's worth pointing out. 
i'm cautious of putting something in model callbacks unless you are really pretty sure that you want to do it _every single time_ you save an instance of that model. A lot of things really are controller/action specific. 
i agree, which is why i try to call one single private model method per lifecycle hook, in order to control what is happening, and usually i call other services from there. I just had the experience of needing to duplicate all my app's functionality(which was session based) for a json api, and i realized how wrong i was to let so many things happen at controller level, since the new api controllers had to do the exact same things. So that was the point when i moved the logic into services called from models, and then i just focused on param valdiation and response handling in the new APIs. Also think about what happens when you refactor/rename model methods, your controller unit tests will fail because the mocked model doesn't respond to the applied stubs. This is ok only for integration tests to happen. Also the fact that in the controller create method on the succcess save you're doing something it smells like the controller cares about the state of the model so it can trigger other behaviour, which is the exact thing an after\_create would seamlessly achieve. However you still have a good point, so kudos for not bloating your models ! &amp;#x200B;
also [this](https://codeclimate.com/blog/7-ways-to-decompose-fat-activerecord-models/) is a good read on where to put the code if controller and model is not ok anymore
It doesn't sound like you agree at all! But whatever works works, I don't think there's one right answer. What about moving the logic into services called from the _controller_, would that allow re-use between different controllers sufficiently also? 
This sounds like a good opportunity to take advantage of the [decorator pattern](http://www.rubyguides.com/2018/04/decorator-pattern-in-ruby/). Something like class FooController def create foo = Foo.new(foo_params).extend(DoSomethingModule) if foo.save log_activity(foo) foo.do_something end # finish rendering etc. end end would give you the explicitness you're looking for in the controller (or wherever else you might use it). It would also help you avoid using callbacks in the model, which IMO should be avoided since they can create nightmares for testing and often break the "principle of least surprise". 
Perhaps the details lie in the simplification necessary to make an example to post about, but... why aren't you just calling `do_something` for the things that need it? What's generic here? Your `FooController` calls `do_something` on a `Foo` because it knows it's dealing with a `Foo` and it knows what methods it can call. Nothing you've described here indicates that `FooController` might be loading a `Bar` or a `Baz` that may or may not have `do_something` defined. Is the request of "I want to make this code as generic as possible" that you want a module to include in each controller? If that's the case, I suggest you don't. For one: This scenario (existing differences). There are differences and unless you have a good way to handle them, it just gets awkward. For two: Future changes. If any of these actions changes in a way that diverges from the others, you'll either have to add more conditionals and make the module and maybe every single module more complicated, or back out of the module for that one controller and then you have to justify to yourself why your module is worth the hassle. The benefit of not using the module is that you can see all of what every controller does, right there, without another file being involved. You can change the actions as necessary. It's not even a very custom action right now, so you don't have to worry about it being too complicated for someone to read. The drawback is that there's more code. It's important to note that simply repeating code isn't enough to consider it "duplicate" because these are all different bits of knowledge -- they all handle different cases that can change for different reasons, even if they appear similar. Duplication and DRY only matters when it's the same bit of knowledge -- for example, how to generate a user's full name from first/last name -- only one place should have the code that knows how to do that. Now that said, if you're determined to continue down this path, what I would do is extract the similarities and allow the differences to be specified with blocks. For example: def basic_create_stuff(&amp;block) foo = Foo.new(foo_params) if foo.save log_activity(foo) block.call(foo) if block end # finish rendering etc. end And then in your controller you have class FooController basic_create_stuff do |saved_foo| foo.do_something end end or if it doesn't have `do_something` class FooController basic_create_stuff end (certainly not working code, but that should get the idea across)
I actually i do agree, as you said there isn't only one right answer. And i said that i was forced to change my code like that, i didn't like it, and i'm only partially learning from that lesson. As for your proposal, yes, it would allow re-use, it's just that you need to make sure to call it when adding a new api for the same purpose, and maintain test that assert that a given service instance is being called a certain method with a set of arguments, e.g. when that service changes it's name or method signatures. And unit tests normally do not catch these changes(i use verifying doulbes for stubbing collaborators in tests so tests would catch this). And that's what i do not like,even though the code's intention is clearer this way. In my team we have the whole app's functionality available through a json api as well, so it was terse to do logic from the controllers. e.g i had to check that both controllers did something, also in the future a dev would change something in the session controller, but forgot about the api one. And then tests needed to be updated when refactoring the code(renaming the service method and other), and that was a pain. 
What sort of need do you have for version managers in your Jenkins pipelines?
I have worked with few teams that has a lot of their codebase split using different versions of Ruby and Python and sucks sometimes to keep on track with the requirements for each project. I also remember that in the past I needed some tool helping me test NodeJS code in different Node versions, and this lib is able to help me with that.
Mmm docker? 
I've seen a couple of \`.flatten.uniq\`'s replaced with \`.reduce(\[\], &amp;:|)\`, though I'm not sure which is better.
``` # frozen_string_literal: true require "benchmark/ips" flatten_uniq = "data.flatten.uniq; " * 512 reduce = "data.reduce([], &amp;:|); " * 512 Benchmark.ips do |b| data = Array.new(16) { Array.new(512) { |_| rand(512) } } data = "data = #{data.inspect}; " b.report("flatten_uniq", data + flatten_uniq) b.report("reduce", data + reduce) b.compare! end ``` gets me ``` $ bundle exec ruby ./flatten_uniq_vs_reduce.rb Warming up -------------------------------------- flatten_uniq 1.000 i/100ms reduce 1.000 i/100ms Calculating ------------------------------------- flatten_uniq 2.470 (± 0.0%) i/s - 13.000 in 5.266676s reduce 3.649 (± 0.0%) i/s - 19.000 in 5.208609s Comparison: reduce: 3.6 i/s flatten_uniq: 2.5 i/s - 1.48x slower ```
Benchmark ips also supports blocks: # frozen_string_literal: true require "benchmark/ips" Benchmark.ips do |b| data = Array.new(16) { Array.new(512) { |_| rand(512) } } puts equal?: data.flatten.uniq == data.reduce([], &amp;:|) b.report("flatten_uniq") { data.flatten.uniq } b.report("reduce") { data.reduce([], &amp;:|) } b.compare! end # Result: ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-darwin17] (2.9 GHz Intel Core i9 32 GB 2400 MHz DDR4) ➜ sandbox ruby flat_uniq_vs_reduce.rb {:equal?=&gt;true} Warming up -------------------------------------- flatten_uniq 192.000 i/100ms reduce 275.000 i/100ms Calculating ------------------------------------- flatten_uniq 2.035k (± 5.8%) i/s - 10.176k in 5.018137s reduce 2.864k (± 7.1%) i/s - 14.300k in 5.019649s Comparison: reduce: 2863.9 i/s flatten_uniq: 2034.8 i/s - 1.41x slower
Yeap... definitely a way to go. I used that too! Just want make something that can give more control about the version management .
yes! i need to remember flat_map
&gt;but I am running into an issue where the seller can continuously keep uploading files. What do mean by that? Your users can upload more than one file per request? &gt;I would like for when the file is uploaded, they can't upload another file and can only edit/update. Being able to just upload one file per model should be set in the the model themself. I'm not sure if I understood your problem and solution, but it seems to me that the later is a little hacky. There should be a better solution. 
Here;s my app: [https://github.com/brandnamewater/digitalcommerce](https://github.com/brandnamewater/digitalcommerce) I have it set up correctly, to my knowledge. order has\_one :sales\_upload - sales\_upload has\_one :order. To my knowledge, this is correct but possibly there should be more to add to it. &amp;#x200B; &gt;What do mean by that? Your users can upload more than one file per request? The issue is you upload a file... then you can reload the new page, and upload another file. and keep going and going. so 1 order can have an infinite amount of files uploaded to it. I only want one file to be uploaded per order. and once uploaded, can only be edited/updated from there. &amp;#x200B; Yes, it will need to be hacky from not displaying the upload button once uploaded. I'm trying to figure that out. Basically trying to figure out how to define an if statement that searches for the orders id within the orders data, and then matches that up with the order\_id in the sales\_upload data, and verifying if a sales\_upload id is present within the sales\_upload data &gt;&gt; if so, only show update/edit. &amp;#x200B; If you take a look at the app in github, you'll see I have it set up so that the order id is present in both the order data and sales\_upload data so I can match them up correctly. &amp;#x200B; How would I go about searching through multiple databases at once? Also, and setting it up 
Whats your gripe with either with just putting "rvm use $version" in the job? 
Do note Ch 2 is out now: [https://medium.com/@baweaver/lets-read-eloquent-ruby-ch-2-6e17a84bd8c2](https://medium.com/@baweaver/lets-read-eloquent-ruby-ch-2-6e17a84bd8c2) &amp;#x200B; I'll likely post back here every 2-3 chapters done so as to not spam too much, and then an index page once it's finished up.
I can't help you with the implementation, the only think I can say is: there is a way of setting up your model to accept only one file per model - so if someone reload the upload page and try to upload a new file, the model would check wether it has already one file, then blocking the users request to upload another file. You also should check if what is happening is the user upload a second file that substitute the first one - like editing the file, but reloading the page. (That should be normal - unless you don't allow edit the file) I suggest you to search on docs for carriwaver, Stack Overflow etc. This is a common problem and must have solutions that don't sound hacky or even need to make so set up to do it. Good lucky!
Use this: https://github.com/vifreefly/kimuraframework
Literally forgot about the most useful web scraping tool in ruby, (selenium)\[[https://github.com/SeleniumHQ/selenium/wiki/Ruby-Bindings](https://github.com/SeleniumHQ/selenium/wiki/Ruby-Bindings)\]
Selenium would be a better choice to use as it uses a real browser and you can execute JavaScript when needed. And if you need headless chrome can do that too. 
Consider the source of the symmetry between controller actions. What makes controller actions often appear similar to one another is not what the _model_ is trying to do, it's what the _controller_ is trying to do, i.e. respond to a web request. Keep web request concerns out of your models. My recommendation is to ignore the apparent symmetry, but if you insist on introducing any sort of abstraction, it'll belong in the controller layer, not the model layer. (And, eventually, these "layers" will stop mattering, but it might be more beneficial to progress one step at a time)
This is hard to answer because people are different. I think two weeks is a too short period though; sounds more as if someone lacks time. I'd say that for an intermediary level (aka someone who knows another "scripting" language very well), with a reasonable daily time allotment, I'd give a range of 2-3 months for ruby; and 2-3 more months of rails. That should be reasonable but again, it depends a lot on the individual. Two weeks seems way too short though, even for geniuses who can memorize everything.
He did. Two weeks is not a lot of time for literally anything.
*Beep boop* I am a bot that sniffs out spammers, and this smells like spam. At least 61.0% out of the 100 submissions from /u/cynthiaGG appear to be for courses, coupons, and things like affiliate marketing links. Don't let spam take over Reddit! Throw it out! *Bee bop*
Mechanize is not mentioned - but should be.
The watir gem is the only way to go these days with that topic. I often avoid the term "web scraping" as it makes people uncomfortable for a reason. The watir gem js the ruby implementation of the wonderful technology called sellenium. Don't try anything else as you will just waste your time.
and nokogiri... 
I have the models set up for orders has\_one sales\_upload &amp;#x200B; If i keep uploading files, it just keeps creating files. I may not have my table set up correctly to do this. 
... is mentioned. But yes, the two together.
Is it needed for orders and confirming orders? Or do you think it may be overkill. &amp;#x200B; I'm reading and everything related to token based authentication is using it for Users signups and with their passwords, confirming by email, etc. &amp;#x200B; I have done a project where I have used it for users. &amp;#x200B; Or are you saying for the actual purchase? I figured I would get the functionality of the website down before implementing Stripe. &amp;#x200B; What are your thoughts?
I've used Nokogiri a lot, never used Pry. What does Pry do in this case?
Okay, I think we need to clarify what exactly is being exchanged between buyer and seller. From what I understand: 1. Buyer visits site and selects a seller 1. Buyer creates order and seller is notified 1. Seller uploads product (a digital file) 1. Buyer downloads product &gt; I have the upload working almost how I want but I am running into an issue where the seller can continuously keep uploading files. What I propose is adding two new fields to your Orders model "seller_upload_token:string" and "buyer_download_token:string". These will be assigned on successful creation of the Order. Tokens can be created by calling `SecureRandom.hex` You can then provide a link to the seller to upload the file, which might look like `https://mysite.com/orders/&lt;:order_id&gt;/sales_uploads/new?token=ebb9e32d918b543e4c6589ab5debd358` Your `SalesUploadsController#new` action will compare the token `params[:token]` with the `@order.seller_upload_token` and redirect unless they match. def new @sales_upload = SalesUpload.new @order = Order.find(params[:order_id]) unless params[:token] &amp;&amp; params[:token] == @order.seller_upload_token redirect_to &lt;somewhere with an error message&gt; end end After the file has been uploaded successfully, in your `#create` action, expire the token by setting `@order.seller_upload_token = nil` Now repeat the process for the buyer to ensure that only that buyer has access to the purchased file.
Just to clarify. The buyer buys a listing, which is created by a seller. So would i be creating the generate migration under the Listing? .. not the Seller.?
https://jsfiddle.net/mnb65fwk/ These are my bookmarks for rspec. I used them to learn.
Why are they on jsfiddle? 
nice list!
### For large amount of parallel requests 1. typhoeus (with hydra feature) 2. nokogiri Generally, only use this approach if you have permission from the website owner since you will be increasing traffic significantly. Could be interpreted as DDoS. Also, if you need to interact with the webpage or wait for it to load js, this approach is not recommended. ### For medium amount of requests 1. Use Google Chrome's "Copy as cURL" feature on the "Network" tab. 2. Use https://jhawthorn.github.io/curl-to-ruby to convert the cURL request into Ruby. 3. net/http 4. uri 5. nokogiri If you need to interact with the webpage or wait for it to load js, this approach is also not recommended. ### Sure fire approach, but slower 1. capybara 2. selenium-webdriver 3. nokogiri 4. chromedriver (headless, unless debugging) This approach is my personal favorite. Capybara really shines when you need to wait or interact with the website in order to crawl it. Works on any type of website, even Cloudflare protected sites. It's slow, but perfect for when you don't want to hit a website more than once every second or two, which I feel is good etiquette.
Nice
# #require 'open3' describe "Securitah!" do it "Brakeman passes" do stdout, stderr, status = Open3.capture3 'bundle exec brakeman -z -w1' expect(status.success?).to eq(true), stdout end it "Bundler Audit passes" do stdout, stderr, status = Open3.capture3 'bundler-audit check --update --quiet' expect(status.success?).to eq(true), stdout end end
HTTP url: https://rspec.info/blog/2018/09/jon-rowe-and-sam-phippen-are-rspecs-new-leads/
Brakeman Pro has this feature built in. Definitely makes the specs feel a bit more complete.
whoops! Sorry!
A nice trick is to ensure your CI has a daily or weekly build which occurs no matter no commit have landed, to ensure bundle audit in particular will be run again. On CircleCI which I'm using for all my projects, you can trigger a scheduled job [this way](https://circleci.com/docs/2.0/triggers/#scheduled-builds).
Zero-value article. There are millions of similar "top N rails gems" articles on the internet. 
Meh. This sub-Reddit seems to have gone from 'discussion and news' to 'clickbaiting and blog advertising'. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [csv11/docs/.../**csv-formats.md** (master → 296ff62)](https://github.com/csv11/docs/blob/296ff62a901d816255e05120cf2952a162f5b745/csv-formats.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e6m1a7d.)
That’s fun. Is it just the true meeting time or did you attempt to take into account the interruptive nature of meetings? In my experience, people often start dawdling before a meeting because they think it’s a waste of time to get into anything and it takes some time afterwards to start your groove. 
A nice use case I've come across a few times is when "manually" running a sequence of validation checks. The code could look something like this: is_valid = validation1 is_valid &amp;= validation2 is_valid &amp;= validation3 is_valid &amp;= validation4 Note that unlike `&amp;&amp;=`, the `&amp;=` operator will evaluate the RHS regardless of the truthiness of the LHS. 
Thanks! Yeah, fixing bugs is always interesting. So far, I've only done print-debugging though. Do you use a debugger for Ruby?
I use byebug.
Writing notes with pen and paper will help. "Students who used longhand remembered more and had a deeper understanding of the material" - https://www.scientificamerican.com/article/a-learning-secret-don-t-take-notes-with-a-laptop/ But I'd recommend that when you solve a problem, stash it in git, and solve it again. Repetition is the mother of learning. You'll be faster and understand more the second time and it will increase your exposure to the code.
Thanks, recording problems and solutions in a git repo sounds like great idea! :)
Thanks for the tips! :) Regarding the slack channel: I'm not sure how to join it. Can you invite me? My email is simon.jakobi@gmail.com
ha. good. but I assumed you'd be working on a project that uses git, and I think that as you work you should solve it, stash it, and solve it again. Don't be afraid to throw things away. Don't keep the stashed code after you've solved it.
Oh, now I get it! :) That's a great idea for exercising! 
Cheers! :)
\`binding.pry\` will be your friend &amp;#x200B; [https://github.com/pry/pry](https://github.com/pry/pry)
I’m just using the actual meeting time in the calendar. Though you bring up a good behavioral point. Most people loose time before and after meetings, as you said . Especially if it involves walking to a conference room somewhere. 
Learn Ruby well. Don't just depend on Rails to do everything for you. Writing Rails without knowing Ruby is like trying to write a book in Spanish without knowing Spanish. Learn OOP. You should have a good understanding of objects, how composition vs inheritance works, maybe a couple design patterns, etc. Learn MVC at a high level, i.e. the purpose of the model, the view and the controller. Keep in mind MVC is a lot more than just web apps. It's fundamentally just a pattern for a certain type of architecture. Then learn Rails. I actually found the default tutorial the most helpful. Make sure to actually do it though. Type out all the code and make sure it runs.
* Do not panic when you see stacktraces. * Read the source code of used libraries (gems). * If you only start now, get RubyMine and set it up to work with debuggers step-by-step. You'll understand what's going on in your methods and how it's all connected. 
Oh man, I forgot about walking. A long, long time ago I remember reading a study that said that people who printed things as a primary part of their job spent ~30% of their time walking to/from the printer. What a way to spend a life. 
In that case you should just use `&amp;&amp;` or `all?` for collections: ``` is_valid = validation1 &amp;&amp; v2 &amp;&amp; v3 .... is_valid = validations.all? ```
I'd just use `&amp;&amp;` or `all?` here: is_valid = v1 &amp;&amp; v2 &amp;&amp; v3 is_valid = validations.all?
Hi, also someone who learned rails on the job, though it was a greenfield project, not an established codebase. Does your team do code reviews? If not, ask a senior dev to review your code. Make notes of the things they tell you, and ask follow up questions when you don't understand something. The rails guides are pretty good, though I've found the api documentation lacking at times. Another really useful tool is a step debugger. Personally, if I'm ever unsure about some code I'm writing, I'll fire up pry and test it out, make sure that things are returning what I think they should return. 
Learn ruby first. Then learn some Rails. Then look at your local codebase. 
rubykoans.com
Brakeman can take a bit of work to get passing the first time you run it especially on an old code base, but the effort is worth it in my opinion.
Well, figuring stuff out for the job will get you up to speed in a hurry. I was in the exact same position as you. The mistake I made was thinking that the companies existing codebase represented anything resembling good practices, or the most simple way of doing things. I tried so hard to learn it and I thought the author was a genius, until I eventually got enough experience to realize it just sucked and was over-complicated and badly-named at every turn.
The best thing I can say is dont be intimidated. There are a lot of gems and a lot of ways to do things. Turn panic into curiosity. Go through the Gemfile and find out what the gems are and what they do. Also, the API for Rails is easy to learn but there are a lot of nuances. Don't panic when something does not work right away, ask questions. I guarantee your not the first person to run into that problem. Building side projects and looking at open source code will help you establish good object oriented design as well. Good luck and congratulations. 
100%. Build your own project first. There’s no greater way to learn what you like and don’t like about code, and how to organize code in the large. 
It says efficient, but are there numbers to back that claim? 
10/14 chapters are free?
Wow, thank you!! I'll start pouring over this; thank you!
Am example would be calling `.valid?` in a rails application. The desire for this behaviour is that you typically want to see ALL of the error messages upfront, rather than one at a time. For example, if you're filling in a long form and leave multiple required fields blank, or misformatted, or with some other invalid input, then you'd presumably like it to show *all* of the error messages when clicking "submit"; not just the first one. 
Read this book https://www.goodreads.com/book/show/45.Agile_Web_Development_with_Rails and you'll be good enough for most tasks in a few days. (There might be a more up to date version)
If you've never written any rails code before, I highly recommend not getting attached to your initial code. When I was in your position I was given a side project to work on and I spent the first week working hard on it, but then threw the whole thing out and started over in the second week. Reason being Rails is full of conventions and stuff that will help you be very productive, but if you don't know what they are, why they are there and how to work with them, you'll probably do what 50% of all people that try rails do: Code something in the opposite way to the convention, and then cry bitterly about how opinionated rails is when it doesn't work and forces you to now go and configure everything rails could have figured out automatically had you followed convention. Some coming examples of this: Partials are named with an underscore to denote their partiality Models are always singular, but their respective crud controllers are usually expected to be plural Avoid using keywords relating to rails functionality for model names. (Named a model Post once. Rails page helpers don't deal with that well at all.) There's many of these little case, but they all become natural with experience, so just be prepared to throw away what you write before you've come into contact with the most common ones. :) While we're here though, I also recommend reading up about using Trello and git or other similar software if you're very new to software development, as well as REST, CRUD and MVC. Those last 3 are some of the architectures rails is conceptually built around, and well help you to understand what is going on when you make a request to the application. Finally: Binding.pry This thing is amazing. You'll see why. Good luck with the new job!
&gt; Does your team do code reviews? Luckily they do! And thanks for referencing the Rails guides. They look useful! :)
Is this site similar to exercism.io (which I'm already using)?
&gt; There might be a more up to date version Would that be [this one](https://www.amazon.com/dp/1680502514)? 
Wow, thanks for all the tips! :)
Yeah, so, I'm not quite seeing the advantage here? Ruby already has built-in lazy enumerators, so why do you need a gem for this? The example given is: File.open("my_100_mb_file.txt") do |file| file.map(&amp;:chomp).map(&amp;:downcase).map(&amp;:reverse).take(10) end Which it's claimed takes a long time to execute, and that's true… but this code: File.open("my_100_mb_file.txt") do |file| file.lazy.map(&amp;:chomp).map(&amp;:downcase).map(&amp;:reverse).take(10).to_a end is nearly instantaneous. Some of the data structures seem interesting and potentially useful, but I'm not sure why you need a gem to accomplish something that Ruby already provides.
Am I understanding correctly it is a set of collections that do exactly the same that core Ruby collections can, but have incompatible API? It also adds new `List` concept, which is like `Array` but not like Array because it is like in functional languages... So, I will probably need Hamster when ... Hm.
Yes, just bookmark those gems for a year from now, when you are fighting Active Record to do something complicated! For now, just focus on the fundamentals. 
Ok. Sounds very similar to exercism.io.
Thanks. I've already applied! :)
Hi! Check out The Well-Grounded Rubyist! I've found it really helpful for learning Ruby. I'm also organizing this webinar about the Well-Grounded Rubyist, 3rd edition today- check that out! You can ask Joe Leo, the author, any questions you have about Ruby- he'll definitely be able to give you good advice since he's like the Ruby expert. [You can RSVP here for the webinar on Ruby!](https://www.eventbrite.com/e/qa-with-the-co-author-of-the-well-grounded-rubyist-3rd-edition-tickets-50453369386)
But in this case, the point is that you can mutate by accident, like with `Array#concat`. I actually think the larger lesson is “do things that will make it harder to make mistakes in the future.” For example, freezing constants. Another: if you’re on Ruby 2.3+, enable frozen string literals. 
Sounds cool. I don't think I have any questions right now but I might just listen a bit! :)
Hey I tested ruby packer out as well but and a big but is that it has issues with dependencies outside of the standard library and native C libraries like sqlite. Which I noticed the author didn't rely on. 
12:30PM EDT happens when this comment is 59 minutes old. You can find the live countdown here: https://countle.com/OcTW1c9Uj --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Unfortunately, what you as a new programmer like and dislike while building your own project is probably going to be pretty much nonesense from a maintainability and collaboration point of view. I get the sentiment, but as someone who learned rails on the job years ago without my own project, it helped me avoid a lot of pitfalls I see with junior projects.
This is the biggest piece of advice you'll get debugging ruby. By a long shot.
So constants are mutable then? Doesn't that make them... not constant? ruby -e ' &gt; MY_CONST="foo" &gt; puts MY_CONST &gt; MY_CONST.concat("bar") &gt; puts MY_CONST &gt; MY_CONST="baz"' foo foobar -e:6: warning: already initialized constant MY_CONST -e:2: warning: previous definition of MY_CONST was here I don't understand, why do some methods mutate a constant while others don't? I thought by the very nature of constants they couldn't be mutated? What am I not getting?
The freezing can be somewhat deceiving for (nested) data structures though. So don't let your guard down just because you have a freezing convention. For example, if you freeze an array of strings, the strings are still mutable. https://bugs.ruby-lang.org/issues/2509 Ignoring the problems with implementation, it would feel chillingly cool to invoke `deep_freeze!` on arbitrary objects. A real sense of power.
In this case the constant holds the reference to the array. The reference never really changes, only the contents of the array change. If we try to change the reference the constant holds we will get a warning. 
Do you have the chance to pair with another dev on a few of their tasks? That should accelerate your learning.
Ruby constants are indeed not constant. You can reassign them, the interpreter just emits a warning. The trick with them constants is the interpreter will only complain if you reassign a constant: FOO = 'sure' FOO = 'why not' =&gt; warning: already initialized constant FOO =&gt; warning: previous definition of FOO was here =&gt; 'why not' This will make it complain. FOO = 'sure' FOO.concat('yep') =&gt; 'sureyep' This is not reassigning the constant but modifying the object referenced by the constant and as such will not issue a warning. Here's an example that is easier to visualize: FOO = [1, 2, 3] FOO[2] = 4 =&gt; 4 FOO =&gt; [1, 2, 4] You're not reassigning the constant, you're reassigning a value inside the object referenced the constant. That said, I don't generally find freezing constants to be helpful, and in this instance the problem could have been fixed by using `+` instead of `concat`.
Ah! Ok, I read that but it didn't quite click. Thanks!
I see, that makes sense. Thanks for the explanation!
This is how I feel as well - `freeze` only gives you the illusion of safety and doesn't protect you with anything more complex.
No, that aborts the whole process: $ ruby -ve 't = Thread.new do Thread.current.abort_on_exception = true; raise "NO" end; t.join; puts "exiting"' ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-darwin17] #&lt;Thread:0x00007fcafe96fac0@-e:1 run&gt; terminated with exception (report_on_exception is true): Traceback (most recent call last): -e:1:in `block in &lt;main&gt;': NO (RuntimeError) Traceback (most recent call last): -e:1:in `block in &lt;main&gt;': NO (RuntimeError) To do this properly you need to join the thread: $ ruby -ve 't = Thread.new do raise "NO" end; begin; t.join; rescue; puts "error #$!"; else; puts "exiting"; end' ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-darwin17] #&lt;Thread:0x00007f8f0a883c18@-e:1 run&gt; terminated with exception (report_on_exception is true): Traceback (most recent call last): -e:1:in `block in &lt;main&gt;': NO (RuntimeError) error NO 
Yep, needs more testing from my side. InvoicePrinter uses only Prawn and that's pure Ruby.
Just a quick bit of feedback... a quick sentence at the top explaining what the gem does might be helpful. (Many-to-many via postgres arrays right?)
Yes, and no. It is not implemented using postgresql arrays, although it could be.
Exactly. I bought mine at https://pragprog.com/book/rails51/agile-web-development-with-rails-5-1 
it has benchmarks for hash, list and set in the *bench* folder
I never like Rails' default behavior here. Will look into using this. Thanks!
Things become more problematic with nested structures. I had considered it a good idea to use [ice_nice](https://github.com/dkubb/ice_nine) by default. But, never did... 
How big are the executables? (I would try but OS X binary release requires 10.12). 
This is an interesting point about language design. It's like recursion - the reason for this being possible isn't a positive ('supports') it's the lack of a negative ('doesn't support'). For example for recursion it's not a positive ('functions can call themselves') but the lack of a negative ('functions can call any function except themselves'). For this case it's not 'statements can be have unlimited modifiers' but rather 'a modified statement is a statement followed by modifier; a modified statement counts as a statement'.
The basis premise of this is 'efficient' storage of relationships _when there is no additional information to be stored in the relationship_. I'm saying that doesn't happen very often and when it does, there are more efficient or straight forward ways to model it.
From what I understood from the Read.me, the OP found a real problem and offered a solution. I don't know how he solved, if his solution is optimized, but he did. I wouldn't take his credits. What I think it's maybe overkill is to install a gem. This could go on Rails core!
That is what the relationship has_and_belongs_to_many does under the hood! But it hides the Third table from you for semantics reasons. You may don't want to have a third table call "join_article_and_tags" on your project if there weren't information for the Third table besides the relationship it does to the First and Second table.
If you add or remove a tag then it becomes a different set. You either find it or create it. You leave the one you had as is. 
I mean removing a tag from the tags table.
Ah. Yes, that is not simple. 
run \`rails db:migrate:status\` to find out which migrations it thinks have been run, and which haven't. &amp;#x200B; Then, you can look at the migrations and figure out if they really need to be run, or if you need it to skip some. &amp;#x200B; There are two ways to have it skip: 1. Open the migration file and comment out the body of the \`up\` or \`change\` method, then \`rails db:migrate\` 2. Add the migration's timestamp to the \`schema\_migrations\` table in the database
Hey, so I cut out the entire sales\_upload aspect and just added a video attribute to the Orders Table. &amp;#x200B; Also, are you willing to get on a message chat and talk through this with me.? &amp;#x200B; Also, how experienced are you because I am looking to pay an expert to polish up my code and do the things I have no way in doing. Actually too so lmk
Ruby is fuckin tight
&gt; rails db:migrate:status `rake` instead of `rails` (cool command, didn't know it exists)
Only works in Rails 5+
that's why it didn't work on my end... i'm still sailing in 4.2.x seas
Just fyi, you do not need a gem to name a join table I believe. Or if you do, I have named my join table in my app without realizing that a gem was required haha.
Take that, Python!
I am sorry that i suck at communicating so much. The gem doesn't rename the join table. It does way more. 
Great article, quality content. Thanks for sharing.
And yet I still got fired
Please don’t encourage it until [this](https://commitfest.postgresql.org/17/1252/) is merged. Rails devs are too eager to break referential integrity. As for the gem itself, please add tables generated to the description, preferably as a diagram. Seeing a visual representation of a model helps a lot. There are people who will arrive looking not for a solution to a problem, but for an abstraction of a solution. Also, use `foreign_key: true` on your `references` declarations. It [defaults to false](https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_reference).
Now I am a ruby guy and python's inferior syntax (in regards to flexibility or mandating () for functions/methods) is a given - but, quite frankly ... If anyone thinks that this code example above is giving ruby an "edge", is an idiot. Nobody writes idiomatic ruby like that either - it's an awful example. It's a cool example too, but ... nobody should use it. There is a simple rule - keep things simple and easy to understand. Don't let code become too complex unless there is no other way. The above code, being as awful as it is, increments a counter variable seven times. That intent isn't clear from the branched if-clauses. If this were a class in school, the candidate would have failed.
Calm down Karen
But you know that some people just got an awesome idea for their online assessment that they use to filter out applicants.
I mean I know you're joking but some people, my boss included, have to make it a war and I have no idea why. Both have neat syntax, focus on clarity and productivity. Some people prefer either. Some use both and their better libraries depending on the situation. So what? Sorry for the little rant.
Pretty sure "take that Python" was a joke. :)
Those were good days. Thankfully we can still pull off nice tricks and optimisations with SQL. 
I won't be using PostgreSQL arrays any time soon. This is strictly a SQL and data modelling optimization. The tests run in sqlite for example. 
Yes, it very much was.
Agreed. They both have their strengths (and weaknesses). I've used / I'm using both professionally, and while I do prefer Ruby, Python's a fine language, too.
How would you test things like `after_commit` hooks, database replication, triggers, etc.? &amp;#x200B; Deletion / truncation is slow, yes, but is sometimes necessary for certain specs in complex applications.
You can turn off transactional nature of tests for those cases. No reason to make 99.9% of your tests slow because of those.
Right... which is exactly what this blog post is saying
Just curious what your reason is for migrating to sinatra/ruby? More familiar with the language? like the language more? better performance?
More comfortable with Ruby vs Python. 
Sequel + TinyTDS. Worked well for me going on seven years. 
https://docs.microsoft.com/en-us/sql/connect/ruby/ruby-driver-for-sql-server?view=sql-server-2017
Of you just have some simple queries, you can even use stand alone tinytds (maybe only wrapping it in connection pool) 
I didn't know about letter opener, but this is a terribly written article.
In my opinion, it would be even better if constants were actually constant in the first place! (And maybe, being ruby, it lets you explicitly "force-change" a constant if you *really* need to.) This whole business of needing to use `freeze` in the first place is an odd quirk of ruby. 
We're using it on production too. It really works well. You can even execute stored procedures with input and output parameters. There are some oddities because it's an uncommon combination (most ruby projects probably use postgres), but for the most part it's quite performant.
Great! The fact that Github cached up with Rails means that they will be pushing PRs to Rails more often. 
Fantastic article. This is the second time I've seen the advice of setting up your app to run on multiple versions of rails simultaneously. At first I was skeptical, but the more I think about it the more it seems like good advice. Especially if Github is doing it, that makes it much more attractive. I also learned about activerecord enums from this article, which I'll definitely be using in the future. 
Here the resulting implementation: module Api class FooClientFactory def self.create_client(version = :v2) case version when :v2 Two::FooClient.new() when :v1 One::FooClient.new() else raise ArgumentError, "'#{version.inspect}' is not a valid version symbol. Valid: [:v1|:v2]." end end end # /FooClientFactory # Api::Restful module Restful def get # get JSON end def post # POST JSON end end # Api::Utility module Utility include Api::Restful def bar puts "BASE_URL: #{self.class::BASE_URL}" url = "#{self.class::BASE_URL}/bar" response = post url ... response.body end def baz puts "BASE_URL: #{self.class::BASE_URL}" url = "#{self.class::BASE_URL}/baz" response = get url ... response.body end end module One # Api::Utility::One::FooClient class FooClient include Api::Utility BASE_URL = 'https://domain.tld/api/v1' def initialize() puts "Creating #{self.class.name}" end end # /FooClient end # One module Two # Api::Utility::Two::FooClient class FooClient include Api::Utility BASE_URL = 'https://domain.tld/api/v2' def initialize() puts "Creating #{self.class.name}" end end # /FooClient end # /Two end # /module v1 = Api::FooClientFactory.create_client(:v1) v1.bar v2 = Api::FooClientFactory.create_client(:v2) v2.bar &amp;#x200B;
Wow! I didn’t know Microsoft released a Ruby driver for SQL Server 2017. Those few years they had IronRuby the never supported anything. 
By "cached", you mean "catched". And by "catched", you mean "caught". 
Yeah, sorry. English is my fourth language. 
What are your 3 others languages? Just curious 
Catalan, French, Spanish. Fifth is Japanese, but I am not fluent yet. 
Awesome!
It would be more awesome if I was not making those beginner grammar mistakes. 🤣
I only meant to help you improve, not a criticism as such. I think it's great to be multi-lingual 🙂
I use [Bullet](https://github.com/flyerhzm/bullet) for detecting n+1 queries, which is likely the case for your index routes if associations aren’t preloaded. I enable it in my dev env, as well as my test env (throws in test env).
&gt; why _why so beloved in ruby community' or maybe your direct opinion ? His work brought me to ruby, and besides that, its just refreshing to see a computer language treated with something other than cold logic.
I'd never thought about making upgrade tests a part of a ci process like they did. But as soon as I read it the benefits felt so obvious that I facepalmed. How had I never thought of it before? And the future testing against edge rails will ensure they're never too far away from upgrading again. Smart.
My mother tongue is Catalan, and I am also native in Spanish. For the rest, I learned them when I needed them. I lived in several countries and that helped me. :)
Catalan is too different from Spanish? Even I don't speaking Spanish, we can understand a lot because of the similarities, also fake speaking (putting some sounds in the end of the sentence so it can sound as Spanish). Did/Do you live in Japan? Learning Japanese is a totally different road. What Brazilian music do you know/like? 
Where ever you are defining the application is where you define the name. For example, with nginx, in the server configuration, you'd do something like: **passenger_app_group_name my_special_app_name;** However, what you're referring to is the name of the Passenger instance which is running. I believe those are randomly assigned. If you ever restart nginx (in your case), Passenger will spin up a new Passenger instance (watchdog, spawner, etc.) with a new unique identifier. It'll then send requests over to that one and spin down the old. That random number is how it separates active processes from decommissioning processes. Also, I'm guessing you must have an errant process running. Normally, you wouldn't have multiple running outside of the spin up/spin down cycle, which normally only lasts a few seconds. I'm guessing you need to manually kill one of them. Determine which one is older by listing the processes and then manually kill the old one.
_why was very important and valuable to the Ruby community. His approach was light and silly and fun, and engaging, and surprisingly educational. As a side note: I worked on tryruby.org (with several others at Envy Labs and Code School). At the time we built Try Ruby, _why had already left the community. He was already missed and many of us cared a lot about him and had a strong desire to preserve both his privacy and teaching approach. We tried to be very true to him. I'm happy to hear that it was useful and attractive to you and I hope that we helped you learn (and maybe even enjoy!) Ruby programming.
Good to know. I figured I could just drop the AR connection in a block and reestablish it outside to get the behavior I'm looking for
Thanks for the clarification.
Catalans is a Latin language, so it is not that different to Italian, French or Spanish. Yes I live in Japan. And Japanese is hard... 
&gt; His work brought me to ruby Thank you :) &gt; besides that, its just refreshing to see a computer language treated with something other than cold logic. Yes. I see this pattern. awesome thing always built by various combination of knowledge discipline.
A comment to (3). I can't speak for anyone else, but _why was a very creative and productive mind. He wanted to separate reallife from most of his work related "online" so when that was no longer possible he retired the online-presence. His choice and decision. It's always bad to lose a productive individual. I remember Zed Shaw whining about _why removing his code in repositories - the very same Zed who kept on pissing on ruby folks ("rails is a ghetto", even though it was specifically aimed at rails, he equated the ruby community with the rails community which is wrong) while having abandoned ruby already years ago (and writing non-idiomatic code tutorials e.g. learn python the hard way and other such nonsense).
 "#{common_name || first_name} #{last_name}"
Guard clauses (example 3) is by far the most readable to me. The last few companies i worked in heavily preferred this style. It makes branches of execution a lot more obvious, and prevent you from doing some of the most bug-inducing things, like conditional re-assignment. On a side-note, stick with the string interpolations either way. ``` def short_name return "#{common_name} #{last_name}" if common_name.present? "#{first_name} #{last_name}" end ```
Ah then the guard clause submission would be the better option
As an aside: if this is a Rails app I'm a fan of the nilify_blanks gem
I would even refactor the second option, and leave it like: ``` def short_name first_or_common_name + ' ' + last_name end def first_or_common_name common_name.present? ? common_name : first_name end ``` or def short_name "#{first_or_common_name} #{last_name}" end
Our database dude cries when I tell him that. Apparently they prefer storing a blank string to nulls?
Oh snap, there’s even a method that already does that. I think I’ll go with this one. 
Neat. TIL. 
There are valid reasons for doing such a thing. One case would be compound unique-indexes, where most relational db's consider two nulls different. eg. you want a person to be uniq by `name` `phone` and `email`, but if you set email to null, two people can exist with the same phone and name, and nothing to distinguish them. That being said, you can do better designs to get out of this situation, but it's one reason you MIGHT want blanks :)
 "#{first_name} #{middle_name} #{last_name}".squish (rails method) Also removes the double blanks. For completeness of this nice topic.
Well that’s pretty handy. Thanks!
About to get on a plane so I’ll keep this short: I think that’s what they’re taking about, yes.
I think the third example is the best form too, and second that you should use string interpolation. But I wanted to mention that I think you forgot the 'end' for your if-else clause in the first example. :)
What is this # witchcraft?
Thanks, added that in
It's interpolation.
Background: https://hacktoberfest.digitalocean.com/
I prefer one method with early ejection (i.e. the third option you originally posted). It's easier for the next person to understand who comes along to maintain the code. Advi whatshisname had a great lecture on structuring functions. Basically, you want to validate your data as soon as possible (i.e. eject early if you have a condition to do so) and then get to the heart of the function once you have "good" data to work with.
IMO storing null seems much more meaningful to indicate that there is no data available. Letting empty string also mean no data ends up with the situation you have now, where things have multiple potential meanings and you have to account for them. Non-null columns make a lot of sense for something like a signup date or a (hashed encrypted etc) password, but making an unentered optional field be a real value (empty string) just adds complexity and takes away from the representative power of your model.
This is a nice article that is almost generic to all web development, not only Ruby. Could easily be adapted and posted to other audiences. Solid tips as well
&gt; # Ruby without Rails version `blank?` is not core Ruby. It is a monkey patch by Rails.
The thing about \_why is in the end, he said something quite interesting: We're all \_why. There are those of us in the community who still very much try and continue that legacy of whimsy and fun, and will continue to.
&gt; I think that’s what they’re taking about, yes. Thank you :) 
Any time!
&gt; That "happening" was "_why's latest work", as in the sense of "artwork". Thank you :)
&gt; There are those of us in the community who still very much try and continue that legacy of whimsy and fun, and will continue to. I never meet or talk to him. But reading/watching what ruby community said about _why really heart touching. You are all very lucky to have such nice fellow.
&gt; It's always bad to lose a productive individual. :( &gt; I remember Zed Shaw whining about _why removing his code in repositories - the very same Zed who kept on pissing on ruby folks ... I know Zed. Maybe every country has different metric of harsh words measurement. But I believe we can impress our disagreement politely. 
I use this currently for methods were I want to guarantee type safety: http://egonschiele.github.io/contracts.ruby/ It also allows to overload methods with different parameter types, the correct method will be called for the arguments.
very interesting!
Assuming that common_name is a string
I prefer the first if/else check. However had, you can shorten it too, e. g.: def foobar return foo if condition_is_true bar end The common_name.presence || first_name is not a real improvement because your brain still has to find out what happens. One of my rules is to never let my brain do any work, so simple a code ought to be.
What? What does Rails have to do with interpolation in a string?
So I'm just wondering... If they want to have everything typed, as they state on one of those slides, why won't they just switch to Java, for instance?
Or Crystal 
&gt; when starting a new project That's a very huge "when". Obviously, it is hard to imagine (at least _today_) somebody thinking "Oh, I want to start a project, that probably requires statically typed language. Ruby+sorbet is an obviously nice choice!" But more or less easy to imagine existing codebases _gradually_ incorporating Sorbet as one of the tools for quality control and developer's productiveness (instead of, say, "let's rewrite everything in Java").
This was me circa 12 months ago. The single most helpful thing when learning Rails is to get a feel for the 'Rails Way' of doing things, so that you work with the Rails magic and not against it. There's a great deal of criticism of the Rails Way, much of it well-informed and reasonable, but none of it will mean anything until you understand what the Rails way is and why it is like that. I'd start off by watching the presentation that popularised Rails in the first place: [https://www.youtube.com/watch?v=Gzj723LkRJY&amp;feature=youtu.be](https://www.youtube.com/watch?v=Gzj723LkRJY&amp;feature=youtu.be) Some of the commands have changed a bit in the 10 intervening years, but don't sweat the details too much - just try and get a feel for the big picture. Then work through building the modern version using the 'Getting started' guide at [https://guides.rubyonrails.org/](https://guides.rubyonrails.org/). The Rails guides are excellent in general, and it's probably a good idea to use them first as you're trying to get to grips with the details of Models (including the ActiveRecord pattern, validations, callbacks), controllers and views. After the first few Rails guides, the Hartl tutorial is great. 
Go into IRB and type `"".blank?`, it will throw an error
A couple comments: * Minor spelling nitpick: You used "except" in several places where you probably meant "expect". I've read your previous articles, too, and I agree completely. I've been a Ruby programmer for a long time, when the FastetCsv gem was the one you installed to get better CSV handling (which had since been merged to Ruby stdlib, and the one you're rightfully complaining about.) I agree so much in fact, I went to go and replace one of the API endpoints in our app that imports CSV to use your gems. However, it was totally unsuitable for production use. It prints several lines of debug output to STDOUT for every"cell" in the CSV, with no way to disable it. This results in dozens of lines per row, or thousands for a very small CSV file. Heroku writes all console output to the logs, so if we were to deploy this, our logs would be full of nothing but CSV debug data. I'll keep checking out your work, I think this it's important to get this right and have a robust solution. I'd love to use your tools once they're usable in production. Cheers!
I replaced it with #empty?, which should work on ruby alone. Unless anyone has a preferred method to check an empty string?
Thanks for your kind words and thanks for trying the new csvreader library. The (new) csv libraries are still in development. The latest csvreader library / gem version (pushed today on Oct 1st) no longer has any debug output to STDOUT on by default. However, the code still needs some polish for version 1.0. Cheers. Prost.
This is something that can be checked for in RuboCop by [Style/NestedModifier](https://github.com/rubocop-hq/rubocop/blob/master/manual/cops_style.md#stylenestedmodifier) and [Style/IfUnlessModifierOfIfUnless](https://github.com/rubocop-hq/rubocop/blob/master/manual/cops_style.md#styleifunlessmodifierofifunless).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [rubocop-hq/rubocop/.../**cops_style.md#stylenestedmodifier** (master → f661cde)](https://github.com/rubocop-hq/rubocop/blob/f661cde4b394522b987fc0d42eb64d72d3e584e7/manual/cops_style.md#stylenestedmodifier) * [rubocop-hq/rubocop/.../**cops_style.md#styleifunlessmodifierofifunless** (master → f661cde)](https://github.com/rubocop-hq/rubocop/blob/f661cde4b394522b987fc0d42eb64d72d3e584e7/manual/cops_style.md#styleifunlessmodifierofifunless) ---- 
In my experience, it's also valuable to distinguish between "principal" and "agent." The agent is the user currently logged in, and the principal is the person or party that the user currently logged in is acting on behalf of. Whenever actions are taken by the user, both the principal and agent ought to be recorded. Separating principals from agents in this manner meets the criteria of enabling your support staff to take action on behalf of users, but because it's generic it can also go much further than that. Imagine an HR system for allowing managers to review and approve employee's vacation requests. Now imagine that a manager wants to go on vacation for a few weeks, and wants to "deputize" a peer as the one who reviews those requests during the vacation. This isn't some elaborate future proofing abstraction that ends up being overkill, it's just designing a user role model that better reflects real world use cases. If you combine the separation of principals and agents with _also_ separating roles from users, your authorization model is now rich enough to handle a _ton_ of real world use cases, without needing to be hacked in with conditional glue. Now, I don't hold any of this as an absolute, because there are contexts where such a rich (read: more complex) system is just plain overkill. But I recommend everyone understand how they might implement it, so that the decision is based on equal confidence in both approaches (versus automatically picking the one that's already familiar).
"Ruby is slow. Here's a random benchmark I just found in google. Lower is better. Above is below."
The slides were pretty clear and explicit about their goals, and that wasn't one of em. :)
Just want to say, as someone who was aware the standard parser (and most alternative parsers) was broken for a while, thanks for tackling this.
Interesting topic, no useful content. For instance, okay, how does one set up "master-master replication" with postgres in Rails? I literally don't know, I have a lot of experience in some areas, but I've never needed to do database replication. This article doesn't tell me, and doesn't even leave me confident it's possible, or even that "master-master replication in postgres" is even the right term. 
What is your use case? 
I’m not sure why the tweet suggests an external lib instead of SecureRandom, because [according to the SecureRandom docs](https://ruby-doc.org/stdlib-2.3.0/libdoc/securerandom/rdoc/SecureRandom.html) it uses `/dev/urandom` which provides enough security for 99% of uses cases. Just use `SecureRandom.random_number`. Relevant bit from the docs: &gt; It supports the following secure random number generators: &gt; * openssl &gt; * /dev/urandom &gt; * Win32
Salting passwords for storage.
IMO you shouldn't be running your own crypto 
Is there ever a reason to use for in Ruby over another option?
I just looked at two of my biggest repos and not a single use of the "for" keyword. I'm not even sure how I'd use it at this point.
for is almost never used in ruby. n.times is also pretty rare, buy does show up sometimes.
\`loop\`, \`break\`, \`while\` are used to instead \`for\` in ruby, I thought the reason to use those keywords is it can read like English sentences, like: &amp;#x200B; \`\`\` while i &gt; 10 end &amp;#x200B; \# while i greater than 10, do something... &amp;#x200B; loop do break if i &gt; 4 i+=1 end &amp;#x200B; \# break if i greater than 4 \`\`\` &amp;#x200B;
Don't ask Zed.
It’s very rare that I’d use a while loop in Ruby. Most commonly Enumerable’s methods like `each` are used.
My most common usage of `for` has been during code review for someone new to Ruby, as a convenient intro to `#each`, Enumerable, and Modules. It's a quick and easy way for experienced programmers to see some cool Ruby features, and newer programmers get to stop writing `for` loops. So I guess I use `for` to introduce why you wouldn't use `for`.
``` i = 0 until i &gt; 4 i += 1 end ```
I use n.times in my Rails seed files.
Pretty sure you can do `10.times do |n|` and n is the incremental value.
I'm a complete novice but I believe it's for repeating sections of code. i.e. 3.times(puts"Hi") Would print "Hi" 3 times. Hope this helps 
Why not?
How weird.
&gt; Use of for loops is generally discouraged in ruby. Citation needed for this statement.
Working with matrices for example.
Because he does not know idiomatic ruby. Best example is learn ruby the hard way - clearly written by someone who stopped writing ruby many years ago.
Do you have an example or link? I tried Googling it just now (admittedly, I didn't go past the first page), but I couldn't find anything really using the `for` keyword.
You can, but if the increment is in a conditional for example, `while` can still be useful i = 0 while i &lt; 10 a = rand i += 1 if a &gt; 0.5 end
So my understanding is that this will show doc for all gems (even the "default" ones line openssl etc), is that correct?
&gt; Citation needed Rubocop, the most common style guide/linter: ["Do not use for, unless you know exactly why. Most of the time iterators should be used instead."](https://github.com/rubocop-hq/ruby-style-guide#no-for-loops) Airbnb, the second most common style guide, quotes Rubocop directly but changes it to ["*Never* use"](https://github.com/airbnb/ruby). Google "ruby for loops" and every result mentions that they're rare and/or undesirable, [including the official Ruby core documentation](http://ruby-doc.org/core-2.5.0/doc/syntax/control_expressions_rdoc.html). The top results: ["The for loop isn't used much by Rubyists"](http://ruby.bastardsbook.com/chapters/loops/), ["most Ruby programmers don't use the for loop very often, instead preferring to use an 'each'"](https://teamtreehouse.com/library/ruby-loops/ruby-iteration/for-loops), ["the for loop is rarely used in modern Ruby programs"](https://www.w3resource.com/ruby/ruby-loops-statements.php). Buy any Ruby book and it will likely explain for loops only in the context of "never use these" -- for example [Learn Ruby the Hard Way](https://learnrubythehardway.org/book/ex32.html), where for loops are contrasted with "the preferred way Ruby loops are written" (iterators). If you search for Ruby for loops on Stack Overflow the first line of the first result calls them ["generally discouraged."](https://stackoverflow.com/questions/31263558/best-practices-in-ruby-for-loop) For loops are slower than `each` (since 2.1 at least) and they leak variables.
Ruby is my favourite language, but I think that not having to type everything is a big advantage if you know what you are doing and like that style. I was just wondering why would anyone want to lose that, I think you are misunderstanding me.
Aha, I was missing that bit, I don't miss Zed Shaw to be honest.
You *might* want to ensure it's not something obvious before claiming citations are needed...
It will show all installed gems, per the `GEM_PATH` issue I mentioned. openssl is not a gem, this is stdlib. stdlib docs (http://www.ruby-doc.org/stdlib/) are not shown. 
You could do it in some classes and not others, for one. 
Broken link 
Salting is not "running your own crypto"
It is a thing - check out the bucardo project as an example of how this can work. It's not without problems. Xoxo Ops guy.
Algorithmic Complexity - Try to parse through it. Understand what inputs it takes in and what outputs it produces. Try to understand the goal of the algorithm. Look up any operations you don't understand. Ask for help. Try to write a simplified version of the algorithm. Most of the complexity could be from edge case handling and things like that. Check any tests if there are any. Structural Complexity - The key here is isolation. In a rails app, just try to follow a request through from controller to page to partials to javascript and css. In a ruby script/app just try to follow the process. See what does what. Everything has a flow of sorts. Follow that flow. Figure out where the "jumping around" occurs and you'll start to get a sense of the structure and how it was built.
This seems like extremely valuable functionality. I wonder if the underlying implementation can be abstracted away from RSpec so that it could be used in other test frameworks (or even contexts that don't involve an automated test framework altogether).
If you need the last value after the loop then `for` has the advantage to not require a separate declaration because `for` does not introduce a new scope. I cannot remember a case where I needed that though.
If your code is good, it won't matter which you pick, I promise people will be able to read it all the same.
Are you familiar with how to use a debugger like byebug? I usually pick some particular path through the code (like, "what happens when you do X"), and then follow it all the way through with a debugger. Taking notes on what the code is doing, as well as another set of notes on additional questions that I have. Then the additional questions I take one at a time (not necessarily all of them), and try to answer them each with the debugging technique too. If there are docs, I have the docs there too, and look at them to see how they correspond to what I'm observing. It's a very "scientific" process of observation. Some of the "questions" can be "hypotheses" I'm testing too. It can be useful to make a 'test case' using rspec, that I can run over and over again so I know the same thing is happening each time, in case I get lost in the debugger and want to start over (which always happens), or run the same thing putting the debugger interupt in different places (also always happens). 
You're not wrong, but you didn't read the question so your answer is a non-sequitur.
Break it down, and understand the parts. Divide and conquer.
I'd be curious to see some examples that aren't more idiomatically expressed using [Matrix.each](http://ruby-doc.org/stdlib-2.0.0/libdoc/matrix/rdoc/Matrix.html#method-i-each), which accepts a parameter allowing you to restrict which elements are processed (only elements on the diagonal, or above it, etc). &amp;#x200B;
Nice writeup OP. Look forward to playing with this. &gt; parse method takes file name Looks like you meant parse_file here. 
multi-master replication is not supported by PG out of the box, but there are some third party solutions. However, valid use cases for this are _extremely_ rare. The vast majority of situations that require more write throughput than can be provided by a single box have architectural solutions that are preferable to scaling writes via multi-master.
So, first try to determine if the code is "too complex" or "poorly architected." That's a subtle distinction, and it requires some self confidence (which is not evenly distributed in our field) and a bit of judgement. If code is complex, but well architected, you should be able to understand it building block by building block. First, start high level and try to understand conceptually what the program does, how data flows into it, what it does with that data, how it interacts with the user, and how it produces outputs. Then, once you have a rough conceptual model of how the app works zoom in on a class by class basis and try and understand what the parts do. Over time you'll see how things fit together and that, combined with your high level model, should allow you to start to understand. From there playing with some classes in an interactive debugger can really help. However, if the code isn't so much complex as it is poorly architected, well, you're going to have to wing it. If there are well architected parts try and understand those first. Then when you have that chunk in your head try and understand what interfaces with it. However, in the worse case, if it is a complete mess all you can really do is do your best to understand it as required on a case by case basis, and then try to make sure that when you have to work with the code you always try to leave it a little better than you found it. Good luck!
Curious what those architectural solutions entail, but mostly this is what the OP _should have been about_ if it was going to be useful instead of seeming like nearly bot-generated clickbait! But yeah, I've never had the need for postgres replication, because _postgres is a beast_, and I work in the "enterprise" at the present. 
I've myself found not that much difference between how to attack code that "poorly architected" vs "very complex". No matter what, if it's not immediately obvious to me how it works, I basically use the same tools. (Others may not!). And I don't know how one would even form an opinion of whether it's poorly architected or not without doing the investigation to find out! (Sometimes something I after a bit of investigation think is poorly architected, after more investigation... well, I still think it's poorly architected, but I understand better the actual domain complexity that made it non-trivial to figure out a good architecture). 
It totally can and is abstracted away. I have written [benchmark-trend](https://github.com/piotrmurach/benchmark-trend) to provide an ability to measure the computational complexity of any ruby code. The matchers in the `rspec-benchmark` gem are a nice syntactic sugar built on top of `benchmark-trend`.
The link is definitely working, you may experience it being broken when GitHub goes down which happens from time to time. Unfortunately, I have no control over this.
"Here's TodoMVC running on my 2012 Macbook. It is the default app server Webrick. I don't know what N+1s are, but this sure looks bad!"
Thanks! That's really cool...
Hmm, on mobile safari the url of https://github.com/piotrmurach/rspec-benchmark%2314-complexity 404s. If I strip put everything after %2314 it works. Maybe an Apollo app issue?
`SecureRandom` uses `arc4random` on platforms which support it. [Even those where it's not very good](https://bugs.ruby-lang.org/issues/15039). We could probably do with a `SystemRandom` which is *explicitly* only OS-provided `/dev/urandom`-equivalent entropy. `SecureRandom` is *not* intended to be that.
v2.5 preferentially uses /dev/urandom then fails over to OpenSSL. https://github.com/ruby/ruby/blob/trunk/lib/securerandom.rb#L59-L114
Take notes. There’s only so much you can keep in your head. Org mode with hyperlinks is a great combo Try to break the code into abstractions. You can either do this top down or bottom up. This means either start at an entry point and trace the code downwards, or start with a function with no children and go upwards. Use tools. IDEs if you can. I use ripgrep and fd but grep and find are great too. Print statements can work, but they do come with mental overhead.
`Random.urandom` only uses `/dev/urandom` [as a fallback path](https://github.com/ruby/ruby/blob/0628973435abeccf676f3c2563579b3dbab06976/random.c#L617-L641) if `fill_random_bytes_syscall()` fails. And one of those calls [`arc4random_buf()`](https://github.com/ruby/ruby/blob/0628973435abeccf676f3c2563579b3dbab06976/random.c#L472-L479) if the platform supports it.
Git history. Knowing the context in which something was written helps understand the choices that were made. Alternatively, seeing that a simple thing grew complex over time tells you that what you’re looking at wasn’t designed to be a cohesive whole. 
Sure. The code is quite confusing, and the docs quite vague, which is kind of a crap combination for something meant to be security-related :(
Nice work! To be honest I didn’t know the “correct” way either lol Will start using tomorrow
`Time.new.to_f` and the like are pretty common. It's one of these things that *usually* works, it's just the odd time when the system clock changes for some reason and now your measured elapsed time is -3599.6 seconds. Monotonic clocks bypass all that - they're always guaranteed to increment. Ruby making it a bit fiddly to use has been a long-standing irritation for me, and I quite like the way Rust exposes it, so... here it is in Ruby, more or less :)
Blog posts like this damage the community, please stop.
I'm using official reddit app client and the link works fine. It must be an issue with Apollo app then. The actual url is https://github.com/piotrmurach/rspec-benchmark#14-complexity, using anchor tag, so it seem the app escapes # =&gt; %23 which seems to be reason.
why it's updated via `gem update` if it's not a gem?
I really like the API. Thank you for the good work and congratulations on releasing it. 
You can’t pass the headers as part of the initializer for the request. You can find the API for managing headers here: https://ruby-doc.org/stdlib-2.4.1/libdoc/net/http/rdoc/Net/HTTPHeader.html For an example API client that sets a custom User-Agent, take a look at the Snitcher gem (https://github.com/deadmanssnitch/snitcher/blob/master/lib/snitcher/api/client.rb)
Delete
omg, thank you, i'm going to try this after i get some sleep and give an update
I would just mension that `#squish` is not Ruby - it's Rails.
Sandi Metz does a fantastic job talking about to unroll complex code through refactoring steps: https://m.youtube.com/watch?v=8bZh5LMaSmE
use rbnacl’s scrypt or argon2 for salting and hashing. the strength of those over salting+hashing on your own cannot be overstated: https://github.com/crypto-rb/rbnacl/wiki/Password-Hashing
use rbnacl’s scrypt or argon2 for salting and hashing. the strength of those over salting+hashing on your own cannot be overstated: https://github.com/crypto-rb/rbnacl/wiki/Password-Hashing
It appears to have been written by a novice, without peer review or a hint of testing, even manual testing in a console. The whole concept of the `Wrappable` module, overriding new and `including` modules into the eigenclass is far-fetched and pointless, the same can be achieved with `Module.prepend`, although it should probably be achieved with the observer pattern in most cases. ``` module Logging def make_noise puts "Started making noise" super puts "Finished making noise" end end class Bird prepend Logging def make_noise puts "Chirp, chirp!" end end Bird.new.make_noise # Started making noise # Chirp, chirp! # Finished making noise ``` Class-level instance variables are NEVER a good idea, they cause all kinds of issues, such as state leaking between tests, thread-safety issues, and, as a result; differing behaviour between different invocations (see below), granted, the article does address the point by changing the `Wrappable` module to use a standard instance variable, but doesn't explain anything about why and then goes on to state `And we’ll admit that inheritable class instance variables might even be quite useful in real life`. ``` module Wrappable @@wrappers = [] def wrap(mod) @@wrappers &lt;&lt; mod end def new(*arguments, &amp;block) instance = allocate @@wrappers.each { |mod| instance.singleton_class.include(mod) } instance.send(:initialize, *arguments, &amp;block) instance end end module Logging def make_noise puts "Started making noise" super puts "Finished making noise" end end module Timing def make_noise start_time = Time.now.to_f super puts "Made noise in #{Time.now.to_f - start_time} seconds" end end class Bird extend Wrappable wrap Logging def make_noise puts "Chirp, chirp!" end end Bird.new.make_noise # Started making noise # Chirp, chirp! # Finished making noise class Cat extend Wrappable wrap Logging wrap Timing def make_noise puts "Meow, meow!" end end Bird.new.make_noise # Started making noise # Chirp, chirp! # Finished making noise # Made noise in 0.0002124309539794922 seconds ``` What's damaging about this post, is that another novice might read it, assume the writer is knowledgeable in the subject and think that the concepts used in the post are good practice.
I have done something like this years ago. The repo is still on Github: https://github.com/netmute/little_rpg Please bear in mind that the code is 7 years old and quite terrible.
You may want to look into some techniques and libraries that roguelikes use. Even if you’re not making a roguelike per se, they still are mostly text-based RPG-esque adventures. 
Hahaha. Sometimes I look at my old stuff and wonder wtf was I thinking
Take a look at https://github.com/rickhull/traveller_rpg
Do you suggest learning ruby first ?
[curl-to-ruby](https://jhawthorn.github.io/curl-to-ruby) is a big help when working with the Net::HTTP module. require 'net/http' require 'uri' uri = URI.parse("http://www.google.com/") request = Net::HTTP::Get.new(uri) request["User-Agent"] = "Mozilla/5.0" response = Net::HTTP.start(uri.hostname, uri.port) do |http| http.request(request) end
Really nice API, zero dependencies would make it perfect.
3000 lines of code, but not a single test.
Thanks for reminding this. I've updated my article accordingly.
Build a game in Ruby that's already been done, for example start really simple, Tic tac toe, then minesweeper, then chess. That way you can breakdown building a game out from designing a game, and you'll be super prepared for your text rpg version
Rust's `std::time::{Instant, Duration}` in Ruby? Love it!
Most of these are common sense though I am surprised they didn't include Kickstarter's `Rack::Attack` for rate limiting brute force attempts at the application/cluster level and something like Cloudflare's Rate Limiting to limit rate limits across geolocation zones. Another I would add is to never roll your own password hashing/storage but to use BCrypt in `Devise` and `ActiveModel::SecurePassword` and make sure it does constant time comparisons of the stored password hash. [Also their recommendation to add a password complexity field I feel is flawed](https://diogomonica.com/2014/10/11/password-security-why-the-horse-battery-staple-is-not-correct/), especially when it has no mention or recommendation to use a password manager to generate and securely store the secure, generated and random password.
Just to be clear: &gt; Class-level instance variables are NEVER a good idea, they cause all kinds of issues This refers to `@@variables`, right? &gt; granted, the article does address the point by changing the `Wrappable` module to use a standard instance variable This refers to `@variables` in class scope, right? If so, I agree with you.
Unless your app doesn’t allow users to sign up, number 3 is pretty much impossible to mitigate. At least in the signup form you need **some** sort of validation, which, of course, should provide checks for duplicate email addresses.
&gt; This refers to &gt; @@variables &gt; , right? I thought this terminology was ambiguous when I read the article. It could also be understood as &gt; @variable &gt; in class scope due to the word &gt; instance &gt; . Fair point, the `@variable` in the class scope is just as bad. I missed the fact that the `Wrappable` module was being extended in the second example too, but I only skimmed the article after reading the title.
Ruby [ships with an openssl library](https://ruby-doc.org/stdlib-2.5.1/libdoc/openssl/rdoc/index.html). I know nothing about anything else. 
The classic first exercise is to build a blog. Another useful exercise would be to build a simple product catalog and shopping cart. Then, anything that requires login and separation of user data, etc... These kinds of projects should expose you to some "real world" programming problems.
Why is it just as bad? Classes are objects, it works just like any other `@instance_variable`.
They make tests difficult with state leakage and cause thread-safety issues.
This is good advice for Rails, but for Ruby, I’d say making things like a Pig Latin translator, hangman game, sudoku solver, and csv-backed to-do list “app” that run in the terminal would be better. Creating an object-oriented quiz game is what really made things click for me.
0.3.0 pushed with the dependency on dry-equalizer removed. Hope I didn't miss anything :)
Funny - Basecamp's rich text editor is my least favorite feature of Basecamp. Editing formatted content breaks 90% of the time I use it. I really hope it's improved on its way into Rails.
Meh, I get that Rails is trying to stay relevant on the front end, but trying to inject webpacker and now Action Text into front end development just feels like a bad idea. Leave front end alone and let Rails handle the back end. 
Unfortunately language developers as a whole don't really respect APIs internally. Ripper itself is pretty unstable and kind of hacky. 
Interesting, why do you think it's desperately needed? I'm mainly of the opinion that a Rails API and a completely separate front end is a lot cleaner and easier than connecting the two via webpacker. Not to mention webpacker kind of rubbed me the wrong way when they decided to name their binstubs `webpack` and `webpack-dev-server`, thus breaking webpack itself. Kinda not smart. 
It will be interesting to see if it gets more community improvement as it becomes part of Rails.
Yes, very good point. I'll take a demerit for assuming Rails. It's definitely much better to have an understanding of Ruby before diving into Rails. Makes it much easier to understand where one ends and the other begins.
Yeah, that's reasonable. But why are you doing that? What benefit does it provide over separate instances? Just curious.
this is interesting. i think if youre still a somewhat complex rails app doing any sort of content, then youve already done some combination of react/slate.js or whatever your front-end preference is, with whatever modern rich-text editing you like. i definitely buy that rich text editing features are now standard and expected behavior on the web, and pushing this on a framework level could be a nice way to solve the myriad options problem. however, that means all of that front-end mess now goes into rails. and i just peeked at Trix, and it's all coffescript... 
&gt; Anybody who would gain an access to the session cookie can easily extend the timestamp by modifying the cookie. Isn't this stored in a rails cookie which is cryptographically signed as well as encrypted? Is there some reason I'm unaware of that one should worry about client-side tampering despite this? If so, it would be good to mention it. Otherwise just leaves me wondering if the author knows what's what. 
Oh of course, sorry. I was thinking of a new app. If you have a legacy rails codebase webpacker is a pretty obvious benefit :)
I understand a lot of people's hesitation with this change and I definitely think that it is valid. However, keep in mind that many WYSIWYG editors are prone to XSS and this can be very troublesome for your app. I do feel bad for new developers coming in to learn Ruby on Rails in 2018/19. Back in 1.X &amp; 2.X, there weren't too many moving parts. You could jump in and start programming right away. 3.X introduced a lot of different approaches which many you relearn a lot of things, but this was adaptable. They did UJS, changed the query interface, etc. 4.X introduced ActiveJobs, secrets, Spring, Turbolinks, etc. 5.X introduced ActionCable, Rails API, Yarn, Credentials, ActiveStorage, etc. In each of these steps, we have had the luxury to slowly adopt and learn the new enhancements. However, as someone just starting out, it would be completely overwhelming. 
Is rails a CMS now?
Rails is a web framework and text editor is one of the most needed parts of any web application, it makes sense from this perspective.
I left rails at 2.3 and jumped back in around 5.0 and my goodness what a leap.
Legacy, shmegacy. Even for new development, there are a lot of people (like me) who think that rendering HTML on the server still has a lot of advantages over apps where the server does nothing but exchange JSON with whatever the cool new Javascript framework of the week is. Of course, there are a lot of downsides too. Not saying one is automatically better than the other, just saying there are a lot of non-"legacy" reasons for a web app to serve up good old fashioned HTML....
Thanks a lot for your feedback! I'm the original author of the article and I'm really sorry that you didn't like it. You're right that the example is a bit far-fetched. I tried to point that out in the summary of the first article. It all started as an experiment to see how to get `prepend` like behavior across the entire inheritance chain. When looking at just one level of inheritance `prepend` does exactly the same thing as the `Wrappable` implementation. Things change once you add an additional level of inheritance, though. With `prepend`, methods defined in the subclass will overwrite the methods from the prepended module. I tried to come up with a way to ensure that Wrapping always happens as the last thing. ``` module Logging def make_noise puts "Started making noise" super puts "Finished making noise" end end class Bird prepend Logging def make_noise puts "Chirp, chirp!" end end class Pigeon &lt; Bird def make_noise puts "Coo!" end end Pigeon.new.make_noise #=&gt; Coo! ``` I share your concern about state leaking. I tried to show the problem by first implementing it using `@@variables`, then pointing out the leaking state, and then changing it to a more robust implementation using `@variables`. Of course, they also share some of the problems once you start modifying their contents after the initial boot-up of your application. As it's unlikely that additional wrappers get added to classes much later in the execution of the application, I considered it a reasonable trade-off for this particular example. I like the idea of using the observer pattern to achieve something similar and would love to hear more. How would you go about making sure subclasses don't accidentally overwrite necessary methods?
I think the scenario the author had in mind is a power user using developer tools to change the expiration time (only the cookie content is encrypted, not metadata).
`rails new --without-sprockets --without-action-cable --without-action-text --without-turbolinks --without-opinions microservice-poc`
I'm the original author of the article. The only thing I can say to this is: D'oh! Yeah, using `object.extend(M)` is a much cleaner way to do this. Sorry I didn't see your comment earlier. 
&gt; what this has to do with Rails in a nutshell. Unfortunately this cancer way of development also has an influence on Ruby and its stdlib.
My bad, I didn't read the first article, or properly read this one, sorry, shouldn't have posted without taking the time to do proper research. Personally, I'd expect the subclass to call `super` if it wanted to inherit the behaviour of the superclass for that method (which this inheritance example doesn't allow for), one way to get the behaviour you want would be the decorator pattern: ``` class AnimalDecorator &lt; SimpleDelegator def make_noise puts "Started making noise" __getobj__.make_noise puts "Finished making noise" end end class Bird def make_noise puts "Chirp, chirp!" end end class Pigeon &lt; Bird def make_noise puts "Coo!" end end bird = Bird.new pigeon = Pigeon.new AnimalDecorator.new(bird).make_noise # Started making noise # Chirp, chirp! # Finished making noise AnimalDecorator.new(pigeon).make_noise # Started making noise # Coo! # Finished making noise ``` Of course you could make the decoration easier using a gem like `draper` or just adding a convenience method, and could use a combination of the above and pub/sub/method_missing to make a more generic implementation.
Not ruby but check out Gatsby.js, works pretty well with GitHub Pages too. 
If you're into security for authentication, you should consider using Rodauth http://rodauth.jeremyevans.net/why.html , which goes up an extra-level and allows you to secure your database authentication data and ships with a lot of security-oriented plugins, like a built-in TOTP plugin. 
The very best thing about Ruby is the extensive standard library. More languages (hello JavaScript) would seriously benefit from a richer stdlib. We shouldn't have to re-solve the same algorithms over and over again when there can be a standard and predictable implementation.
Hope DHH someday will stop sharing his private Basecamp-specific libs with us.
Extensive standard library in Ruby was even before Rails. With Rails it starts to be a dumpster.
Hmm, Active Record, Active Support, and ActionView were private Basecamp-specific things initially.
Seriously. Why would this go into core, but not user authentication? This could easily be a gem. This is a really bad decision.
Yes, but it's hard to compare these things. ActiveRecord is great ORM, which works with almost all RDBMS. ActiveSupport is a nice additional to Ruby's stdlib. These things save tons of time. What's good about Active Text? Does it bring something valuable? Can it be used with Carrierwave? What if i don't like Trix? Bloating rails core with things like Turbolinks, Active Text etc doesn't sound good to me.
I seriously ran this a few months ago: `rails new myapp --database=postgresql --skip-action-cable --skip-action-mailer --skip-active-storage --skip-bootsnap --skip-bundle --skip-coffee --skip-javascript --skip-listen --skip-spring --skip-sprockets --skip-system-test --skip-test --skip-turbolinks`
I do new apps like that too, that's a larger discussion, but I think lots of people in fact still do, and I think it is a reasonable thing to do. :)
Yeah whoops that was pretty ignorant of me. I guess my clarified question would be: if you’re designing an SPA from scratch, would you use webpacker and why? I completely get using webpacker for augmenting rails views, but I kind of don’t see the point if you’re already building an SPA
Depends on your settings, but in recent rails the default settings are [encrypted as well](https://medium.com/@michaeljcoyne/authenticated-encryption-for-rails-5-2-cookies-and-sessions-3f87b1d21fec). Of course, even signing would be enough to prevent tampering... I think? But yeah, not the actual browser-visible metadata, like the actual cookie-specification expiry. Good point. The right way to take care of that (I think?) would be to put the expiry inside the actual cookie data too (which in Rails case is a serialized hash, just another key in it), and having the back-end check that value after decrypting/verifying. I'm not sure if the `Rails.application.config.session_store :cookie_store, expire_after: 12.hours` function does that or not; I wouldn't be shocked either way, worth looking into. 
Agreed, the point of webpacker is not people who were using Rails api-only for an SPA, and if you're doing an SPA with Rails at all, that's the way to do it! It's just that I think probably still the _majority_ of Rails use is _not_ that, and webpacker is really important for those. (Although still not quite as foolproof as it would be nice if it were, some of that might just be the inherent complexity of what's become the standard front-end js toolchain). Was what I was saying too! So yeah, we agree! 
It's true, and I think that actually applies generally to the process of _web development_ using any tool. When people ask me how to learn how to do it, I'm like, I have no idea, except start 15+ years ago when it was a lot simpler and then learn the new stuff over 15 years. 
Good call! If it's an open source thing on git, and I'm looking for more information about some _particular_ part of it (say ActiveStorage in Rails), I search PR's for likely search terms, and look at the diffs and comments. Often at this stage I still don't really know what's going on, so don't completely understand what I'm seeing, but it's helping me build up the context. 
I think that it is something that I'll use as well. Having played a lot with Stimulus and Turbolinks, I really enjoy the power that they bring to the frontend. This is just one additional thing that will make life easier. Though, because not every application has an immediate need for this, I think that rolling it into the rails core may have been a mistake. Now the rails core (not just basecamp) will have to commit to aligning with/maintaining an entire different extension; Trix. I get it that it is a part of basecamp and developed by Sam and Javan, but it doesn't make it an automatic nobrainer to dump into the core. I would have been much more accepting if they took a similar approach to ActiveText like they did with ActiveJob. You could seamlessly drop in Sidekiq or DelayedJob or whatever into ActiveJob and it just worked. Here, they have married Trix to ActiveText and I think that they should have taken a more universal approach. Maybe in time it will support others like TinyMCE, Summernote, SimpleMDE, etc.
I think a lot of people here don't mind it exists, but don't understand why something like Active Text needs to be part of the core of Rails and not just be a gem that can be included if needed. I'd rather opt-in than opt-out (which is something that probably will need to be done by "--without-active-text" or so).
Sure, I'm just shrugging at the grandparent poster who seems to be sick of DHH sharing useful code when we probably wouldn't be on this sub-Reddit if he hadn't. I'm probably further down the "Rails does too much" road than anyone. I hated when it added REST and forced me into using that back in 1.1 or whenever it was.. use Sinatra most of the time now!
Corrected link: https://weblog.rubyonrails.org/2018/10/3/introducing-action-text-for-rails-6/
That's fair. If it was a gem and roughly as simple to include as he showed in the video that would be perfect. I agree that's a large new domain to be responsible for as a core team.
This development in a nutshell. Just look at frontend. It used to be a lot simpler. Create a page with styling, maybe an animation or two with javascript. Nowadays there's this huge chain of dependencies. From CSS pre-processors to compiling your javascript to different versions syntax for compatibility reasons. Not saying it's bad or not useful. Just that there's a lot more complexity nowadays.
You sure you choose the right framework for ur site? &amp;#x200B;
For a lot of people \`require 'activesupport/all'\` is considered stdlib.
I'm fine with him sharing the Basecamp code. But not why this would be Rails core. &gt; I hated when it added REST I'm from the generation that started learning web development when REST was practically standard. May I ask what you have/had against REST? Just curious.
At the time there was a purism around REST (which doesn't really exist now) where the "best practice" was to shoe-horn every single concept in an app into a REST-like structure with the associated URL structure. I prefer to have fewer controllers organized around the user perception and experience of the app instead, rather than lots of controllers designed to make it easier to build an API.
I think a call to action would be appropriate in this case. There's only 5 issues in that repo so far and all are closed. If we want to have our voice heard we should probably do something about it and not just complain here. I don't feel comfortable taking point on this issue since I can't defend this groups opinions as well as others with more experience. Perhaps the other commenters here might feel motivated enough to take that step?
Don't get me wrong, sharing useful code is great, but making something a part of rails only because it works for you and your company is not good at all. We already have things like Tubrolinks, ActionCable, Credentials, Webpacker etc. Does rails need so much bells and whistles?
I would argue that the out-of-box experience for your first Rails app has not changed much since 3.0. None of the things added since then are among the first things you'll use when you're building a basic app. A "Getting Started" guide for Rails now would look pretty much like it always has. But now when you \*do\* need to store files or establish bidirectional communication, for example, ActiveStorage and ActionCable are a lot easier to get going than the options you had before. It had been a while since I started a brand new Rails app, and it still feels the same to me.
I've started stay static &lt;http://staystatic.github.io/&gt; - one design, many samples a while ago incl. live working (static) website compiler samples for jekyll, nanoc, webgen, middleman, hugo (go), gatsby (js), jigsaw (php), and many more (all hosted on GitHub Pages too with source).
I feel like auth would be the next thing for core, yeah. Even something like `gon` would make more sense than this WYSIWYG framework. But devise is just fine for me and probably you.
codewars.com. Ruby section. you can select exercises from tiny code snippets, to more involved tasks that would probably take a day or few days to crack
I want to voice that I'm on the Rails5 + Turbolinks (w/Turbolinks-iOS &amp; Trubolinks-Android for mobile) + Stimulus.js + Trix.js train right now with multiple apps. It's fucking great. The less effort I need to set this up in the future, or maintain, is a huge win for me. I realize that combo isn't for every app, but when it is for your app, the magic just works with minimal work. The equivalent work required without this ecosystem would have easily taken 10x the time for me. Rails is an ecosystem for quick starts and batteries included productivity without the gatekeeping. I bet it's because of that ethos that how many of us got into ruby programming. If that isn't your thing (ever or anymore), no problem, but don't hate on DHH for keeping rails on the track he laid (pun intended?).
Active Record, Active Model, Action Pack, and Action View is core Rails. I just didn't need any of the other stuff!
With everyone's help, I created a \[modular template\]([https://github.com/craibuc/sinatra-modular-template](https://github.com/craibuc/sinatra-modular-template)).
We use Dry Schemas at work, not for everything, they’re super quick. I’ve enjoyed using it. 
Honestly, this is not limited to rails alone. I remember the 1990s (!) era. And the www has gotten a lot more complex since then. It's nice that the features extend and improve but the complexity increase in general? Hmmm.
&gt; I would argue that the out-of-box experience for &gt; your first Rails app has not changed much since 3.0. Not true. I recall having used rails briefly very early on, a long time ago. At some later time there was more code, more components, things such as javascript engines (!) ... and it was no longer as simple as it used to be. A lot HAS changed, there is no denying this.
Indeed.
People are less likely to install gems. I have no idea if this is a good or bad change, but to assume that everything aside from "core" should not get into a framework just out of principle alone, is just as bad a view as the "pack in everything".
I don't think you are necessarily in the minority. I more see it here, with older people not liking change, and younger or new people either not minding, or liking the change. :)
Whoa nice work man. I do like that Gatsby can bring in data from dynamic sources, but what’s your take on things?
A max length on passwords? That is a terrible idea and portrays to the end-user that you're not hashing the password. A password that is 500 chars will result in a hash of the same length as a 3 char password, so there's absolutely no reason to put such a low upper limit on password length.
Yep. Always return a `200` status and a message saying you sent an email to reset the password, regardless of whether or not the user exists.
When is CoffeeScript support being dropped..?
Starting with Rails 4.0, the contents of session cookies are signed and encrypted by default. But you do not need to modify the value of the cookie to re-use it. If an attacker obtains a valid session cookie, in the absence of additional server-side controls, that session cookie will be good forever. The expiration on the cookie can be easily modified/removed, because it's in cookie metadata, not the encrypted values. [This changed in Rails 5.2](https://guides.rubyonrails.org/upgrading_ruby_on_rails.html#expiry-in-signed-or-encrypted-cookie-is-now-embedded-in-the-cookies-values). Now the expiration is (also) part of the encrypted cookie contents, which can prevent an attacker from re-using the cookie indefinitely. However, it's really not a best practice to use cookie storage for sessions. You lose a lot of capability for security controls, such as instant revocation, tracking active sessions, monitoring for stolen sessions, and so on. (Sometimes people get confused because server-side sessions often *also* use a cookie, but the cookie is just a pointer into a server-side session, it doesn't contain the session contents.)
Too much features
And the same goes for initially signing up
Good to know. So the particular advice the OP gave is unneeded in Rails 5.2, at least for the reasons they say, yes? Rails of course _used to_ use server-side sessions with the [activerecord-session-store](https://github.com/rails/activerecord-session_store). Which used to be part of Rails, but now it's a separate gem, not sure if it's officially supported by core Rails team or not. (it is still in the rails github org). At the time Rails _started_ using client-side sessions... which I think was actually 2.0... everyone said _that_ was best practice. (if it was done properly, anyway; with "properly" having evolved over the years, originally just signed, then signed and encrypted, with encryption details possibly evolving, with details like this one on expiry, JSON serialization vs Marshal, etc). At the time they switched, I thought it seemed kinda weird (why would you want to make your cookie package bigger?), but everyone insisted, no, this is the best practice. It looks like at the time, the [explanation](https://github.com/rails/rails/blob/3-0-stable/actionpack/CHANGELOG#L1614) was "Cookie-based sessions are dramatically faster than the alternatives." So... I dunno. Rails has put an awful lot of dev-time into evolving the cookie-based session store over the years. Why the heck are they still using it if server-side session is considered a best practice? Just sunk cost fallacy?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [rails/rails/.../**CHANGELOG#L1614** (3-0-stable → 857c6ee)](https://github.com/rails/rails/blob/857c6ee62c0582273d76e7b21b1eb295359eb837/actionpack/CHANGELOG#L1614) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e76fx7b.)
I agree. Why does this need to be in Rails core? It should be a separate gem. I love Rails for writing backends but they’re really holding on for dear life to stay relevant on the front end.
I got the impression that lots of the statements are this lame for purpose. Almost like he’s trying to start a flame war hoping to get viral, because bad press is still press...
I didn't deny that a lot has changed or that there's a lot of new stuff in there, but the rest of my claim matters: "Getting Started", "out-of-box", "first Rails app". It is provably true that a basic, working Rails app is almost exactly the same as it was in 3.x (and it wasn't that different before, except REST wasn't the convention then). If you don't believe me, look at a basic [Rails 3 tutorial](https://www.sitepoint.com/getting-started-with-rails-3-part-1/). The only significant difference I see is that a migration is now generated with a single, reversible method, although the up/down methods shown in the tutorial would still work.
Urgh, *really*, Devise? return if password.blank? || password =~ /^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&amp;*-]).{8,70}$/ A lovely combination of both eyebleedingly awful and terribly performing. Just think of all the backtracking this thing might need to do in order to check all those assertions. And no, it doesn't stop early if the input is over 70 characters. This is simpler, faster, more predictable, and won't melt your CPU on large inputs: return if password.blank? return if (8..70).include?(password.length) &amp;&amp; [/[A-Z]/, /[a-z]/, /[0-9]/, /[#?!@$%^&amp;*-]/].all? { |re| re.matches?(password) } Though personally I'd be pretty annoyed at any password "complexity check" that rejected, say, a Diceware passphrase. If it's 40 characters long do you really care if it's got a number in it?
This is a short version of an article I'm writing up on later for jollies about destructuring. 
That’s a good point! I forgot about bcrypt’s silent truncation.
I’ve done the base64 sha trick in the past too. I thought I was the only one!
Rails is the gemified version of basecamp. Not that I'm complaining. At least the tools are built for real-world use cases as opposed to being developed in isolation for the sake of "features".
Hanami is a nice in between, FWIW
Niiice. Wicked yet nice
I might be a bit of a dick here but this seems more like an ad than a legit tutorial. All you are doing is hooking your App up to an API. There is barely any Ruby involved in anything you have to do yourself.
Beaver! You are still shapechanging into a lemur.
I was thinking exactly the same when I was looking into ways to do this a while. There is a guide for Action Cable (web sockets in rails) on the official rails website which allows you to do this.
Yes, for the segment Rails is pursuing (startups) you need these marketing exploits because the competition with Node and Go is fierce. If Rails was big on enterprise it wouldn't need to innovate so quickly, but it isn't. I don't really mind , what's the big deal with opting out if you don't need it?
Shouldn't default values be something returns by `parameters`? Possibly as a third element in the array for each parameter?
Come on. Rails has really good, comprehensive documentation.
Unrelated, but `method()` is very powerful. I've often used it in map-reduce style jobs where I have to apply a bunch of transformations to a collection, define a method to do the mapping (or several), then have a few `collection.map(&amp;method(:some_map_func))`. Super useful.
File loading is here: [https://github.com/tmm1/emoji-extractor/blob/5d7add70893ed35be1bad198be78119d97067a16/emoji\_extractor.rb#L49](https://github.com/tmm1/emoji-extractor/blob/5d7add70893ed35be1bad198be78119d97067a16/emoji_extractor.rb#L49) When you call a ruby script from a shell, you can access the arguments you pass to that script using `ARGV`. You could change line 50 to something like @ttf = File.new(ARGV.shift,"rb") and it would open the file you specified as an argument from the shell.
Somebody got some JavaScript on my Ruby! Seriously though, this is pretty cool. One of the things I really love (and sometimes get myself into trouble with) about Ruby is the meta-programming. I come from a Perl background and having access to the symbol table is something I seriously miss in other languages. I'm trying to decide if I should share this with co-workers... I'm afraid we may see this pattern showing up just "because"...
Did you encounter any problem with Turbolink iOS and Android? I have heard stories about both being not ready, i.e there are lots of edge cases not being ironed out.
What a radical concept. Having absolutely no experience with a thing sure doesn't seem to slow down many folks around here from expressing their expert opinions. ;-) 
Very interesting. On a facile note, what code editor is that?
It's the kind of thing I dread implementing but don't need all that often. I imagine it'll be a bit like turbolinks, just turn it off
Quite illogical comment. I do not use rails (but I use ruby daily); however had, we could see a trend that there is a slight decrease in usage of rails. So .. the trend is NOT to stagnate. The trend is to innovate and expand, be it with rails or with ruby. So ... your comment can very happily and logically be dismissed as erroneous. PS: You don't have to use every feature that exists, ya know? I am using only a subset of ruby and don't care about the rest. And it's great - I can remain lazy that way on top of that. \o/
Elixir is ok. The syntax is worse compared to ruby though. And ... to switch a language because of "too many features"? I mean that in itself does not compute as logic to me ... well aside from elixir.
Thankfully I do not use rails but the code that I see in rails applications is usually abysmal, almost always completely unlike "mainstream" ruby too. Perhaps the end result is good but the code is ... weird. Even alien. Having said that - I do not think that you can correlate shitty code written by incompetent fools to represent GOOD code written by clever people. Rails is opinionated all the way down, which includes the code that is written. This will not be that different from using other large code bases. It's still better than any PHP crap that exists out in the wild (I refer to the CODE, not the functionality; the functionality can be great, such as mediawiki, phpbb and so forth).
The Chris Pine was very nice. It's a bit outdated but still a good intro. Don't know about the Ruby Cookbook ... Anyway, the most important thing is to start writing ruby code, no matter how "bad" it is. I also recommend you to structure it like a gem very early on - perhaps not for the first small projects, but the sooner, the better. And publish it too, even if you think nobody will use it - you will learn a lot that way. To your question as for projects ... I think that depends on your own interests. Just pick anything that interests you or some problem that you face. This is usually the best motivation. You can learn as you go, e. g. all the tasks that may be important can come here: - creating files, deleting them, populating them with content - open a remote website, read its content via open-uri, apply regexes to extract important data And so on and so forth. If you still can not pick a project (and it really does not matter that much), pick something that you may have a problem or an interest right now - this can be a hobby too, sports, movies, audio and video conversion and so on. I can assure you that once you get into the habit of writing code, a todo-list fills almost "automatically". I even wrote a small project for "magic the gathering" mostly because I wanted to sell some old cards (while I still play, my heydays here are over) and wanted to see where I could make the most profit margin, to some extent etc... 
I fully agree. By the way - have you published that code of yours on rubygems.org too? :-)
I have not it's pretty basic! It creates a couple empty hashes, sets an error count to 0, defines an analyze method that parses an input file for IPs, URLs, separates IPs by octets, and errors, then defines a count method that just adds 1 for our scanned values, a print method, and ends with the main method which exits if there's no input or analyzes log files.
Line 50 has "rescue" Changing it to what you suggested just gives an error saying the "else" is useless without "rescue". I'm also running this on Windows so the "/system/library/Fonts" directory isn't valid and it doesn't load the font file
Likely evaluate it at the call-time in the context it's defined in.
It's not, it's https://carbon.now.sh
I'm pretty new to anything beyond just weekend coding with HTML or VBA. What is a CLI or a crawler?
I heard about codewars. Never knew they have small exercises. Thank you for the advice!
I work in finance so i was going to try my hand at making a few Mortgage calculator and tools for clients. Like a break even point for Re-financing or highest ROI on thier strategies. I never thought to add creating and deleting files, but that would work perfectly for that project. Thank you for the advice!
This is anecdotal but every time I'm looking for the innards of how a thing works I find 8 definitions because there are so many layers of abstraction inversion. When I find the right one sure, it's good but it's just frustrating. I'll grant they're not bad docs, just a lot I feel is left to be desired for me
Well I can't attest to the quality of the structural design of Rails' internals :-)
To be clear I'm not advocating to switch to another language because of too many features in a framework's ecosystem. But to me it seems that the feature bloat of rails is palpable. Why couldn't this have been a separate library, and depended on standardized interfaces? It's easy to add things to a library or language. It's extremely difficult to remove them. Regarding the syntax, I personally disagree but I've also been writing in it for a couple years so it feels normal to me. But on whether a syntax is worse than another, I think that's dependent on the person and what it's optimizing for. Go for example feels atrocious to me despite it being a "cousin" to elixir. But it wasn't built with the same things in mind that elixir or Ruby were. I'll say I like Ruby. I really like Elixir. But I really dislike ActiveRecord which the Rails ecosystem feels like a slave to.
Direct link: https://www.sandimetz.com/blog/2017/9/13/breaking-up-the-behemoth
I'm not sure if I [found the ticket](https://bugs.ruby-lang.org/issues/8629) you had in mind. I'd very much like this functionality but I worry that a Proc#default_values method would face the same objections.
This article is a bit rambly, and doesn't really get to why Rails is used. Let's break down some of the points: &gt;Nowadays ROR is most trending and most popular development tools in the market Not really. It's popular, sure, but I would not qualify it as the most popular. PHP likely still has that title. That said, popularity is a mostly irrelevant metric, I would care far more about stability and maturity. &gt;Mostly use of ROR to make Chat application It's actually really bad for that, even with ActionCable. That's mostly due to how Ruby handles asynchronous code, GIL, and general parallelism. &gt;If you are asking most IT professionals what you should use for develop your app chances are the answer will be ROR You're much more likely to get an answer of "It depends" than anything. 1. **Less Coding is benefits of it** &gt;Ruby on rails is about writing less code that does more.Representational State Transfer (REST) is biggest advantage and compare to other language, it is too good. REST is a generic standard that's not specific to Rails. &gt;Some ROR principal like CRUD (Create, Read, Update, Delete), KISAP (keep it simple as possible), and COC (convention over configuration) These are not exclusive to Rails either. There's an advantage to using them, sure, but you want to highlight that rather than just using the buzzwords. 2. **It can reduce your time of coding** &gt;One other reason is ruby on rails is really simple to use and very less time consuming takes for a developer to create a solution using the language A consistent theme in this article is you're failing to elaborate exactly why or how it achieves this. 3. **It's used in biggest websites** &gt;You know biggest advantage of ruby on rails is code of ror interpreted without need any compilation It's an advantage but also potentially a crippling weakness. Interpreted languages are around an order of magnitude slower in terms of execution speed. What that affords you though is flexibility and speed of coding. 4. **Rails is based on Agile Development Principles** &gt;Same method you can use in ruby on rails because it’s based on agile development Agile is a generic term, not a Rails one, and also inaccurate. Rails does not actively encourage agile, but you could use agile methodologies to develop in it. 5. **Really Easy to test** Also not unique, and other languages all have automated testing systems. 6. **Very large number of free help desk.** Other languages have this as well, but simply calling them help desks can be taken as offensive as it demeans those in the community who dedicate a lot of time to helping new people. 7. **Main thing it is free** So are a lot of other languages and frameworks. .NET is about one of the only major exceptions. &amp;#x200B; \------ &amp;#x200B; The short version of this comment is focus on what makes Rails unique and give qualified examples of it. Without that it just seems like hand-waving and jargon. &amp;#x200B;
HTTP basic is simpler to set up, but doesn't give you the flexibility of form-based authentication, which can include things like password recovery links, two-factor authentication, CAPTCHA protection, etc. In general, we use HTTP basic as inter-service authentication between microservices, and even then as a second-layer defence, in addition to OAuth/JWT tokens and network-level security.
You can also do that latter pipe sequence via Open3 pipelines, in which case I think escaping again becomes unnecessary. https://ruby-doc.org/stdlib-2.4.1/libdoc/open3/rdoc/Open3.html#method-c-pipeline_rw (Personally I would write the code you provided and probably not use open3 for this but just offering it as a counter example)
Sounds like a different direction but that's what I enjoy about programming, there are so many paths to explore. I'm trying to convince my team to embrace infrastructure as code. Start by just messing with things that interest you, I got started messing with Arduinos and Raspberry Pis brewing beer. That got me thinking about automating networking gear with Python which then lead to exploring automating solutions like Chef which makes considerable use of Ruby.
Thanks for the extra pointers.
thank you!!
Rate limiting on either nginx or application level (or even both) is another step in making Rails applications even more secure. Based on your feedback I should consider writing next article, thanks! &amp;#x200B;
I have been wondering the same. I never needed it so far. I always refer to ARGV.
That still does not really answer why shellwords are necessary.
Yup. I think we still have not answered the question why shellwords would be necessary. So far I have only come up with the thing that it really is not necessary.
Thanks Freeky. It would be nice to benchmark different approaches to measuring password complexity and share results :) 
The only place where I found a use for it was passing a command to `rsync -e`
Very cool, I like you to consider Crystal programming language as well
User input that will be evaluated in a shell is a vector for an injection attack. [gryfft@mothership: ~]$ cat unsafe.rb #! /usr/bin/env ruby args = ARGV[0] puts `echo #{args}` [gryfft@mothership: ~]$ ./unsafe.rb 'hello world' hello world [gryfft@mothership: ~]$ # This is vulnerable to an injection attack: [gryfft@mothership: ~]$ ./unsafe.rb 'hello world; uname' hello world Linux [gryfft@mothership: ~]$ cat shellwords.rb #! /usr/bin/env ruby require 'shellwords' args = Shellwords.escape(ARGV[0]) puts `echo #{args}` [gryfft@mothership: ~]$ ./shellwords.rb 'hello world' hello world [gryfft@mothership: ~]$ ./shellwords.rb 'hello world; uname' hello world; uname [gryfft@mothership: ~]$ ./unsafe.rb 'uname: `uname`' uname: Linux [gryfft@mothership: ~]$ ./shellwords.rb 'uname: `uname`' uname: `uname` 
It’s not a 110% setup and forget it system, and there is a learning curve, but it works well for my use case. So the negative impression you may have gotten does not resonate with me.
&gt;This changed in Rails 5.2 Thanks man, I haven't known about that. I need to update the article to include this information!
With degenerate input of the form `....&lt;etc&gt;...aA0?`: devise 8 bytes: 487553.6 i/s freeky 8 bytes: 398678.2 i/s - 1.22x slower freeky 28 bytes: 376737.1 i/s devise 28 bytes: 271164.3 i/s - 1.39x slower freeky 70 bytes: 336164.5 i/s devise 70 bytes: 138211.7 i/s - 2.43x slower freeky 256 bytes: 1447398.2 i/s devise 256 bytes: 35703.2 i/s - 40.54x slower freeky 1024 bytes: 1454770.1 i/s devise 1024 bytes: 9736.7 i/s - 149.41x slower freeky 131072 bytes: 1460001.8 i/s devise 131072 bytes: 78.2 i/s - 18670.59x slower freeky 1048576 bytes: 1455187.1 i/s devise 1048576 bytes: 9.8 i/s - 148855.80x slower You can see the regexp's clearly not exiting early at any point, and even without mine exiting early it quickly pulls ahead.
Any new samples more than welcome incl. in Crystal, of course. Happy to help along if there any questions. See the Stay Static - Quick Starter Kit on getting started with adding a new sample (if interested) -&gt; https://github.com/staystatic/staystatic-starter 
i’m curious: why did you write a utility for ruby and python.. in perl?
Hi! Outthentic/Sparrow was written as a platform for script development and deployment. Initially only scripts written on Perl and Bash was supported, just because the tool itself was written on Perl and those kind of support was easy to implement. Latter though the tool evolved as a multilanguage framework and I added the same level of support to scripts written on Ruby and Python. That gives a developer a decent level of freedom which programming language to choose when develop a script. However whatever language one choose they always get the **same API** simplifying script development and deployment tasks.
You sit there and read it for longer periods of time. 
Yeah, command within a command is definitely a good use case. As for `ENV`, `Kernel#spawn` and friends accept an optional first argument where you can specify additional environment variables for the shell command, e.g: system {"MAGICK_TIME_LIMIT" =&gt; "10"}, "magick", "input.jpg", ...
Yeah, if you want the shell to handle pipes, in that case you cannot use the ARGV approach. I didn't need to do that yet, but when I do I think I would try my luck with Ruby pipes using Open3 pipelines. However, Open3 is not always a great choice, it [sometimes causes deadlocks](https://github.com/minimagick/minimagick/pull/437) or [uses too much memory](https://blog.sundaycoding.com/blog/2014/02/05/fighting-paperclip-errno-enomem-error/), so if you'd use something like [posix-spawn](https://github.com/rtomayko/posix-spawn) instead, you'd have to implement the pipeline yourself.
Oh it’s more like if you need to inject commands with arguments into ENV, e.g. CC
Oh it’s more like if you need to inject commands with arguments into ENV, e.g. CC
Hear elucidation... think elucidator, man I wish SAO was real (✿◠‿◠) 
This reminds me of crappy low effort articles from those ezine or squidoo pages from 2006. 
oh thanks — i missed that it supports perl as well. i thought i only read it supports bash, ruby, and python. my first gig was as a perl dev. brings back memories. 
You are welcome (;
#seo
As it seems they've deleted their last account and reposted it, here was the original reply I'd written: This article is a bit rambly, and doesn't really get to why Rails is used. Let's break down some of the points: &gt;Nowadays ROR is most trending and most popular development tools in the market Not really. It's popular, sure, but I would not qualify it as the most popular. PHP likely still has that title. That said, popularity is a mostly irrelevant metric, I would care far more about stability and maturity. &gt;Mostly use of ROR to make Chat application It's actually really bad for that, even with ActionCable. That's mostly due to how Ruby handles asynchronous code, GIL, and general parallelism. &gt;If you are asking most IT professionals what you should use for develop your app chances are the answer will be ROR You're much more likely to get an answer of "It depends" than anything. 1. **Less Coding is benefits of it** &gt;Ruby on rails is about writing less code that does more.Representational State Transfer (REST) is biggest advantage and compare to other language, it is too good. REST is a generic standard that's not specific to Rails. &gt;Some ROR principal like CRUD (Create, Read, Update, Delete), KISAP (keep it simple as possible), and COC (convention over configuration) These are not exclusive to Rails either. There's an advantage to using them, sure, but you want to highlight that rather than just using the buzzwords. 2. **It can reduce your time of coding** &gt;One other reason is ruby on rails is really simple to use and very less time consuming takes for a developer to create a solution using the language A consistent theme in this article is you're failing to elaborate exactly why or how it achieves this. 3. **It's used in biggest websites** &gt;You know biggest advantage of ruby on rails is code of ror interpreted without need any compilation It's an advantage but also potentially a crippling weakness. Interpreted languages are around an order of magnitude slower in terms of execution speed. What that affords you though is flexibility and speed of coding. 4. **Rails is based on Agile Development Principles** &gt;Same method you can use in ruby on rails because it’s based on agile development Agile is a generic term, not a Rails one, and also inaccurate. Rails does not actively encourage agile, but you could use agile methodologies to develop in it. 5. **Really Easy to test** Also not unique, and other languages all have automated testing systems. 6. **Very large number of free help desk.** Other languages have this as well, but simply calling them help desks can be taken as offensive as it demeans those in the community who dedicate a lot of time to helping new people. 7. **Main thing it is free** So are a lot of other languages and frameworks. .NET is about one of the only major exceptions. &amp;#x200B; \------ &amp;#x200B; The short version of this comment is focus on what makes Rails unique and give qualified examples of it. Without that it just seems like hand-waving and jargon. &amp;#x200B;
While it isn't a good article, please refrain from outright insulting to it. Instead, try and come up with productive critiques of it to help the author learn.
The **Edit** part makes total sense, thanks for sharing it :-)
Could you maybe help me understand why anyone would care about some files sitting in a hidden away folder that never get touched if not needed? This sounds like a philosophy issue
&gt; In the absence of lightweight, named data structures to pass to our functions Ruby has named parameters. It calls them [keyword arguments](https://robots.thoughtbot.com/ruby-2-keyword-arguments). They are not hashes, but they are congruent to hashes via destructuring and the splat operator. &gt; Now, I said lightweight types because I want to exclude classes like we get in Ruby, Python, Java, etc. They are not lightweight, either to create or to chug along. An empty Ruby class is already bogged down by about 60 methods and attributes This kind of statement is what leads people to write non-OO code (by which I mean, terrible Ruby). Extracting value types is _good_ Ruby style. Refusing to do so for some specious premature optimisation seems like cutting off your nose. &gt; Initialize empty, build later Although it's not actually a completely terrible creational pattern for some circumstances, it's inconsistent to speak glowingly of functional languages and then demonstrate chained methods that explicitly mutate the receiver, or to have eliminated value types for not being "lightweight" and then burn through memory on multiple intermediate representations of the recipient. 
OP here. &gt; Ruby has named parameters. It calls them keyword arguments. They are not hashes, but they are congruent to hashes via destructuring and the splat operator You'd agree with me that named arguments are not a replacement for a real type. It's the most viable solution in order to not break existing code before it was introduced (in Ruby 2). Hashes are good choice, as I mentioned. But it pales in ease of use when compared to the lightweight types you get in Elixir and Go, the two example languages I used. It's possible to talk about an `Email` struct in Go or Elixir, a unique and well-documented type. It's not possible to talk about an `email` hashmap since it could either be extended to include unwanted keys or more keys added. &gt; This kind of statement is what leads people to write non-OO code (by which I mean, terrible Ruby). Extracting value types is good Ruby style. Refusing to do so for some specious premature optimisation seems like cutting off your nose The comparison here, again, was to types in a language like Go. Everything I said in the response above applies. Around this part I was referring to functions that take types. Obviously, if an empty class in Ruby comes in with a lot of fat around its waist it's a terrible idea to encourage creating lots of it without regard to resource usage. You're right that we should extract value types but I'm sure you'll agree with me that there's a significant cost to creating new instances of classes in Ruby, and this is a challenge unique to Ruby (and other programming languages like it). I create new types freely in Go and Elixir for values I want to pass around, usually for the purpose of documentation. I'm able to do that because they're very inexpensive. &gt; Although it's not actually a completely terrible creational pattern for some circumstances, it's inconsistent to speak glowingly of functional languages and then demonstrate chained methods that explicitly mutate the receiver, or to reject value types for not being "lightweight" and then burn through memory on multiple intermediate representations of the recipient. The pattern describe here, _initialize empty, build later_ works in functional programming languages as well. See for example how [ecto](https://github.com/elixir-ecto/ecto) validates changesets or how [bamboo](https://github.com/thoughtbot/bamboo) builds emails.
&gt; Obviously, if an empty class in Ruby comes in with a lot of fat around its waist it's a terrible idea to encourage creating lots of it without regard to resource usage. You're right that we should extract value types but I'm sure you'll agree with me that there's a significant cost to creating new instances of classes in Ruby No, I flatly disagree. You're promoting bad design for invalid reasons.
Good luck writing any Ruby at all without instantiating classes. 
&gt; But this class comes bogged down with about 60 methods and variables that are unnecessary as far as a value type goes. &gt; If the Rubyist did the same thing it won't be long until they're scouring YouTube for memory profiling, memory optimization tips. This overhead only applies to the class definition, not instances of the class. Instances of the class have a tiny cost: http://web.archive.org/web/20120126022146/http://eigenclass.org/R2/writings/object-size-ruby-ocaml
I think it'a a nice thing to have. 
As I understand it, those methods you are referencing aren't actually part of the instance of your class. When you call a method in Ruby, you do a lookup in the class/module chain registered as that object's ancestors. So, I think, whether your class had 1 or 1,000 methods, I imagine that instantiation of either would be the same (or similar?) amount of overhead, depending more on the instance variables you assign within.
Correct. It's the classes that are expensive not their instances. I argue that if all you want is a value type then the default weight of a Ruby class could be unbearable. Remember, a _value_ type/object at its simplest is a key-value pair with a name and some cool things that come with being a _type_. I use classes differently in Ruby. They're either _Service_ objects (like the Email class in the example code) or _Entity_ objects (like ActiveRecord models).
Delete XCode from your applications folder, then re-install?
obj.try(:x)
Or the new obj&amp;.x 
That doesn't do what the original poster is asking for, or the same thing as `try`. ``` irb&gt; class DoesNotRespondX; end =&gt; nil irb&gt; obj = DoesNotRespondX.new; obj.respond_to?(:x) &amp;&amp; obj.x =&gt; false &gt; require 'active_support/all' =&gt; true &gt; obj = DoesNotRespondX.new; obj.try(:x) =&gt; nil irb&gt; obj = DoesNotRespondX.new; obj&amp;.x Traceback (most recent call last): 2: from /Users/chrisseaton/.rbenv/versions/2.5.1/bin/irb:11:in `&lt;main&gt;' 1: from (irb):9 NoMethodError (undefined method `x' for #&lt;DoesNotRespondX:0x00007ff74f8a15f8&gt;) ```
Please keep in mind that this is not ruby but activesupport. 
obj&amp;.x check out the "safe navigation" operator.
The smartest way is to be explicit. 
This is absolutely not the same thing
This is (almost) equivalent to `Object#try!`, which is **not the same thing** as `obj.respond_to?(x) &amp;&amp; obj.x`. The safe navigation operator, e.g. `obj&amp;.x`, is (almost) equivalent to: `obj &amp;&amp; object.x`. This allows navigation through **`nil`** objects, not arbitrary objects.
I might have misled you there. If I did accept my apologies. But I was referring to the class definition all the time, since that's the way to create types in Ruby. I'm not referring to the instances you create afterwards.
I started my API excited about Active Storage. There were several things I ended up not liking about it: - Assumes you are not using API mode - Provides no way to perform direct uploads without using rendered templates. You can’t request an upload token without a ton of hacks. - It is tightly coupled into the asset pipeline - requires using a dsl in views, controllers, and models In turn I went with Shrine. It is way more flexible and performant than Active Storage. It doesn’t require additional tables, it doesn’t care about your views, and you don’t have to do anything special in controllers to use it. I wrote a similar article but focused on Shrine. https://itnext.io/happy-users-uploading-files-with-rails-5-shrine-and-vue-js-bbcc470a327f?source=linkShare-f8354741d7e6-1539001033 TLDR; Tried ActiveStorage and rolled it back out in favor of Shrine.
Thanks for sharing! I think it really fits my needs but I'm going to read your article to find out more about Shrine.
Same story, Shrine is still the best. 
Where does your memory profiling comment stem from, given that a class definition with no methods simply inserts `Object` into it's ancestor chain, which already existed anyway before you made your custom type? Creating new class definitions also does not copy methods somewhere. I just don't really follow your angle, particularly here on the Ruby sub. If you are this concerned about a one-time startup cost of your application to set up the basic environment in which all objects operate, it's clear that Ruby is not for your use case. I'm not advocating for apps that assume that RAM is an unlimited resource, but your stance as I understand it comes off as either incorrect, or over-concerned. 
Love the Python thumbnail.
It was the old image I was using but apparently led to some confusion ¯\\\_(ツ)\_/¯ 
Until you can specify a folder and organize the uploads, ActiveStorage is completely useless to me. I don't want a giant group of uploads sitting unorganized in an s3 bucket. [GitHub Issue](https://github.com/rails/rails/issues/32790)
That is the smartest and most explicit way. Alternative would be: obj.x rescue nil
Why would I pay money for that? I can easily create an equally sad experience like that with ActionCable.
If you’re talking about an internal tool (not aiming to be available on public internet) with a handful of pages, definitely Sinatra will be lower overhead. You can still use ActiveRecord and whatever else you need, but replacing controller+router with Sinatra is a pretty quick learning curve and shouldn’t slow you down much.
Honestly it doesn't bother me much 🤔 Does it cause you inconvenience to have all of those folders?
&gt; Why would I pay money for that? I can easily create an equally sad experience like that with ActionCable. We are currently in Beta. In true MVP-fashion, we decided to release a truly minimal but stable initial version, and are incrementally adding more features to it, while already interacting with users of the system. So please, elaborate on what you find a 'sad experience', because we would love to hear your constructive criticism! As for Rails' ActionCable: Planga's Chat Server has been built using Elixir and the Phoenix webframework. This means that it not only scales a lot better (in that it takes less computational resources and time to perform the same functionality) than a Rails application (with or without using ActionCable), besides being easier to maintain because the Actor Model is a natural fit for (web)socket-based systems. The Planga Dashboard that is used to manage your developer account, on the other hand, _was_ written with Ruby on Rails, because it is easier to test out new features using Ruby than it is in Elixir. &gt; I also don't believe in PaaS applications that are free forever after you have bought it, https://planga.io/pricing The core application will always be fully Free, Open Source Sofware. If you do not want to host your own version yourself, or want to use some of the more advanced features that only make sense in a service-based architecture, you will be able to purchase a subscription. Rewarding early adopters, however, is something _we do_ strongly believe in. Please elaborate what would be odd about our pricing scheme! Thanks for your feedback! :-)
Your site is kind of a mess... From the docs page: The most important thing to remember, is that we've tried to combine the following three features: * Simplicity * Scalability * Security Those are some good buzz words... but how? What makes your app secure? I was going to give more constructive feed back about your service, but after reading this, I just can't take you seriously and there's no way I believe your app is "secure"... &gt; For many commong languages and programming environments Really? You misspelled "common" &gt; Furthermore, the following integrations are being worked on, and will be released soon: &gt; that the visitor's browser &gt; How this encryption works exactly is not important to use Planga: Properly encrypting your configuration and building an HTML/JS snippet from it is what the language integration libraries do for you. &gt; Planga chat screen: The details to be sent in the &gt; (which contains some enbedded JS) &gt; window to your liking: Feel free to show/hide You should really hire a copy writer. You apparently don't know how to use the colon, apostrophes, or spell check. &gt; Super-simple integration How is configuration "above" simple? &gt; Setting up basic chatting will only take a couple of minutes, at most! With how hard you're selling its "simplicity" this makes me think it's not so simple... &gt; Lovely Documentation &gt; We take clear documentation very seriously. Objectively this is not the case... &gt; We're there for you: The Seriously with the colons... &gt; How planga looks is completely customizable by writing your own CSS, so Planga's chat interface will look completely part of your application. So I can do web design? &gt; Furthermore, who and how talks with one-another This sentence makes no sense. Also, this really doesn't have anything to do with Ruby, the linked article is just an Ad.
There is a "Fork me on Github" banner on the home page
&gt; It's not a matter of operator precedence since I isolated with parens the code in the second test. You haven't fully isolated it - the problem is the relative precedence between `=` and `or`. ``` isPast = date &lt; Date.today or (date == Date.today and hour &lt;= Time.now.hour) puts "isPast", isPast # =&gt; false isPast = (date &lt; Date.today or (date == Date.today and hour &lt;= Time.now.hour)) puts "isPast", isPast # =&gt; true ``` You probably want to use `||` instead of `or`, and `&amp;&amp;` instead of `and`, for code like this. 
Thanks!
with ruby 2.5.x, you can use the keanu reeves operator ``` obj&amp;.x ```
Thank you for the excellent write up. Also loved the pundit one. 
&gt; Good luck running Ruby at all without lots of money. Go + Gin is only 3x as fast as Ruby + Sinatra + Sequel at "parse a request, grab some stuff from a DB and serialize it to JSON" and it's even closer if you use JRuby. You can opt out of all that heavy Rails magic any time you like. https://www.techempower.com/benchmarks/#section=data-r16&amp;hw=ph&amp;test=fortune&amp;l=hr9kov&amp;f=zik0zj-zik0zj-zik0zj-zijzen-zik0zj-zijunz-zik0zj-4zsov
I'm not sure what you mean by having "all of those folders". I'd prefer that to having too many buckets when I want to separate applications and environments. Even within a single application there is value in separating different attachments for different models, which I'd rather use folders within a bucket for as opposed to separate buckets. Our AWS account wears a lot of hats, and it would be extremely inconvenient and unsightly if most of our buckets were a workaround for our rails library not providing attachment organization.
I would maybe elaborate and say for all code. `and` and `or` causes nothing but bugs.
They do have their uses, but in general I would agree to avoid them. Some typical uses I've done in the past: do_something or return false check_args or abort "Args not right" while next_line = lines.next and next_line.present? They work well for flow control, but overall can be confusing. To say don't use them period though feels like the wrong way to go about it. Sure, most of those could be postfix-conditionals, but it can read more clearly in some cases. Remember the point of Ruby is to be a pleasure to read and write.
I'd test with a barebones rails app and try to measure the memory footprint for a few queries. I would try to stay with Sequel in Rails if possible -- to minimize memory footprint and rewrites. Chances are your time is more expensive than a beefier device? If I was hitting complexity with Sequel, I'd connect with Jeremy evans on the sequel google group -- he's very responsive and has seen it all. ORMs are convenient but not worth it for complex queries sometimes -- drop to sql and get results as a hash? &amp;#x200B;
&gt; So please, elaborate on what you find a 'sad experience', because we would love to hear your constructive criticism! I believe I could make a better looking chat-room and I am not a designer, I am a backend developer that are not well-versed in CSS or JavaScript. &gt; Rewarding early adopters, however, is something we do strongly believe in. Please elaborate what would be odd about our pricing scheme! Because if I pay today and get a million customers, you would have to support my business for a one-time fee of $99, which is clearly not sustainable. 1. I don't want to base my whole business around a product where I don't pay enough to cover your operating cost. 2. I don't want to use a product where other customers might bankrupt you by their usage because you can't figure out a proper business model with a sustainable pricetag. 
That's true, and also `obj.is_a?(Foo) and obj.x` is even stinkier than `obj.x if obj.respond_to?(:x)`. There are certain circumstances where you want to make a method extremely "friendly" (a.k.a magical) for the convenience of the developer, where it is fine to use respond_to like this. A good example is wanting to accept either an object or an identifier for the object in the same method. @project = Project.find(3) Foo.for_project(@project) # =&gt; &lt;Foo project_id: 3&gt; Foo.for_project(3) # =&gt; &lt;Foo project_id: 3&gt; There are opinions on all sides of this of course. 
You can use it in an API only app. The docs are just not so great in that case.
 class BasicObject def try(mthd) return false unless respond_to?(methd) mthd end end 
Agree to disagree. Those cases do not add nearly enough value for me to have both ways. But I'm also a double-quote only kinda rubyist. Definitely prefer consitency.
No, that's an alternative to `obj &amp;&amp; obj.x`
I may do an exploration article over when they could be used effectively later, and cases where they'd be especially handy.
Go nuts. Never seen a really good argument for them, seen many great ones against them. Would always do guard clauses for control flow ``` abort "Args not right" unless args_are_valid return false unless did_something ``` The while statement with inline assignment is something I would never accept in a code base I had to maintain. So many more elegant ways to deal with streams. `while lines.peek`
0.4.0 pushed with more maths, more tests, more docs, and convenience methods for sleeping.
The last commit is a couple of years ago, but if you want a dashboard to display this data, check out dashing. It’s Sinatra based, and has a bunch of conventions for doing exactly what you want to do https://github.com/Shopify/dashing
I know this is a ruby subreddit, but have you considered GO? It has a much smaller footprint, cross compiles really well so you can create a small executable. And much easier to demonize a small executable in case of power failures or unexpected restarts.
It starts to feel difficult when you are building a more complex architecture, e.g. services that run in the background , queries that display in real time and processing that takes place on demand. I know this is "just a dashboard" but a lot of work is being done in different stages and are too much for a single person to handle. In Rails they just feel very good organised.
No I didn't and I am not against another language or tool. It's just that my free time is very limited and I can't afford it, at least for now.
Yes, Rails provides a structure that helps you organize various classes so that you don't have to do it yourself. What I was wondering is where did you find complexity in Sequel specifically (compared to ActiveRecord).
I have been working for more than 5 years with ActiveRecord and I feel fluent with it. Also the conventions of Sequel seem less helpful and more on the "raw" side of things.
Rails is getting absurd with their opinionated stances on these things and really a lack of regard for the community on implementation of features. Feels like a DHH wishlist. Glad we moved away to more open Ruby libraries and frameworks.
I created a project recently and opted for ActiveStorage. I've been impressed with it so far, easy to set up and it's worked just fine since (with Digital Ocean Spaces). I'm glad not to rely on extra requirements and a more complex setup. If I could work out how to make it play nicely with DO's new CDN, even better.
Raw SQL in sequel can save time **and** memory in queries, when using the dataset API. ActiveRecord doesn't allow that OTOH.
The Rack SPEC actually required this. You should call `#close` on the response body if it supports that method.
The question is If 60MB of memory vs 1GB is worth it. 
[This](https://imgur.com/a/Mz8kCAh) is what I mean with "folders" at least in my local environment. I've never used AWS, only Google Cloud Storage, and I just noticed that I can upload all of the files to one single bucket without any config. Maybe AWS works differently.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/IJhYNIh.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20e7fy8ck) 
I was planning to use DO but ended up with Heroku. The only "problem" is that Heroku has this dyno concept in which they "move" the Dynos to different machines (for what I understand) so I have to use an external file storage service. I'm currently using Google Cloud Storage and I have to say that I'm really impressed!
I'm sure there are *some* scenarios that need this, but it's not a design choice that I'd aspire towards!
Which framework are you using now rather than Rails?
Any benchmarks or comparisons?
Would be nice to know also if it integrates with action-cable
I have no complaints whatsoever about DO. It's not as all-encompassing as AWS but with the correct tooling (Ansible and Capistrano) it's a breeze. Their Spaces and CDN were added more recently and are all nicely integrated. Once the dust settles I'll properly investigate taking advantage of the new CDN features.
Hanami, rom-rb, shrine
I guess that's what you get when being eager to get an initial version out to the public. 😅 Thank you for pointing out our (mostly my) grammar mistakes! Yes, I admit, I am a fan of using appositive colons. Do you think I'm overdoing it? I am mostly aghast that in the years I've spent at the university, nobody has pointed out my improper usage of a capital letter after such a colon. I'll definitely ask someone to proof-read my ramblings in the future. &gt; Those are some good buzz words... but how? What makes your app secure? We use the JOSE-JWE (using the AES-128-GCM-KW cyphersuite) to forward the encrypted configuration information from your web-application, using the user's browser, to the Planga Chat server. This is secure because (in contrast to sending configuration information in plain text) the a 'malicious' user can only forward this encrypted blob (allowing them to chat) or not forward it (and in that case only prevent themselves from using the chatbox without breaking any of the CIA triad for any of the other users of the system). The reason there is no direct communication between your web-application and the Chat server is to reduce bandwidth, round-trip time and code complexity in your web-application, which is one of the main reasons for scalability and simplicity being mentioned. (Besides this: of course everything is served using HTTPS/WSS, but that's rather ubiquitous in 2018). Another way we try to create a secure system, is by working with multiple API-key-pairs under a given application that can be independently created, investigated, suspended and revoked. (Expect this feature to be finished somewhere the next couple of weeks). &gt; How is configuration "above" simple? I do not really understand your question here. We really try to follow 'convention over configuration': Only the information necessary to authenticate to Planga and explain who the current user is and what channel(s) they are allowed to connect to is what you are required to configure. The rest is optional and can be configured on an opt-in basis. &gt; With how hard you're selling its "simplicity" this makes me think it's not so simple... To be honest, most of the time it should only take you a couple of seconds. However, because we realize that there currently are still a couple of rough edges, we decided to not to make things look nicer than they currently are. For one, we're in the process of creating a `planga-rails` gem that will make it even simpler for Rails-users, because it will follow Rails' conventions (moving the API key handling to a configuration file, no need to manually call`html_safe` etc.) &gt; Objectively this is not the case... Ouch! You're right. The documentation is still in the process of being written. If you check the [GitHub Organization page](https://github.com/ResiliaDev/) you can see how much work we spend each day on improvements. Look again in ~ a month time, and I'll be eager to hear your opinions on the documentation then! &gt; So I can do web design?... This isn't a feature of your application. Yes, you can. Of course, we will have a couple of nice default looks to pick from as a starting point, that you can then adapt further to your liking. I disagree with you in that this definitely _is_ a feature: how often have you used a plugin or widget in your application that it was impossible to make it even look vaguely similar to the rest of the page? All elements that are created by the browser client have a clearly-defined class structure, exactly to enable you to reach in with your custom CSS rules and customize it to your hearts content! :-) 
It definitely should! Will change!
I tried playing with this on a real-world app, and it wouldn't start: ➜ Someapp git:(develop) ✗ falcon --verbose serve D, [2018-10-09T10:43:05.345151 #93656] DEBUG -- Async::IO::Socket: Binding to #&lt;Addrinfo: [::1]:9292 TCP (localhost)&gt; D, [2018-10-09T10:43:05.345416 #93656] DEBUG -- Async::IO::Socket: Binding to #&lt;Addrinfo: 127.0.0.1:9292 TCP (localhost)&gt; D, [2018-10-09T10:43:05.345547 #93656] DEBUG -- &lt;Async::Reactor:0x3fecd17131a0 stopped=false&gt;: Exiting run-loop because finished. Traceback (most recent call last): 9: from /Users/user/Repos/Someapp/.gems/bin/falcon:23:in `&lt;main&gt;' 8: from /Users/user/Repos/Someapp/.gems/bin/falcon:23:in `load' 7: from /Users/user/Repos/Someapp/.gems/gems/falcon-0.18.13/bin/falcon:26:in `&lt;top (required)&gt;' 6: from /Users/user/Repos/Someapp/.gems/gems/falcon-0.18.13/lib/falcon/command.rb:68:in `invoke' 5: from /Users/user/Repos/Someapp/.gems/gems/falcon-0.18.13/lib/falcon/command/serve.rb:124:in `invoke' 4: from /Users/user/Repos/Someapp/.gems/gems/falcon-0.18.13/lib/falcon/command/serve.rb:97:in `run' 3: from /Users/user/Repos/Someapp/.gems/gems/async-1.6.0/lib/async/reactor.rb:56:in `run' 2: from /Users/user/Repos/Someapp/.gems/gems/async-1.6.0/lib/async/reactor.rb:201:in `close' 1: from /Users/user/Repos/Someapp/.gems/gems/async-1.6.0/lib/async/reactor.rb:201:in `close' /Users/user/Repos/Someapp/.gems/gems/async-1.6.0/lib/async/reactor.rb:201:in `lock': wrong number of arguments (given 4, expected 0) (ArgumentError) But that application is really old (originaly Rails 2 or 3 maybe?), and currently sits Rails 5.1.4 and Ruby 2.5.0 so it may just be that my application is crusty and jank. Unicorn starts the app fine though. Anyways, I created a fresh Rails app and was able to start with Falcon there. When loading the first page, it triggers the prompt that lets users pick a client certificate to present in both Firefox and Chrome. Clicking cancel to just not present a certificate seems to be sufficient. Not really sure why this is happening - maybe bad browser behavior related to self-signed server certificate over HTTP2? It then loads the "Yay! You're on Rails" page, but fails to load the image for some reason. Reloading the page makes it appear, and it doesn't fail to load the image again until I quit the browser (which makes it re-prompt for a client certificate, which may mean the two issues are related). Falcon is cool. I'm definitely going to play with this a bit to see if I can work out the kinks and make it work in a real app.
Thanks! You have some strong points. After an internal discussion today we've decided to slightly alter our beta pricing, giving you two year of limitless use for $99. &gt; I believe I could make a better looking chat-room and I am not a designer, I am a backend developer that are not well-versed in CSS or JavaScript. Please, go ahead and do! :D The JS outputs HTML elements that have very clear classes so you can easily put your own CSS in place. The current styling is mostly meant as an initial example and simple way to get started now, during the beta. We are planning to release a couple of default looks that you can choose from and adapt further, of course. ------ To thank you for your time in giving us your honest feedback, we'd like to offer you ten of the two-year subscriptions that you can freely distribute in whatever way you see fit. Sign up, tell us your username in a private message and we will give you access!
I figured out my exception on startup. Falcon has an undeclared minimum version dependency on something that was already in my Gemfile.lock. Running "bundle update falcon" updated all dependencies and fixed the issue. It'll be one of these gems that needs a minimum version declared in the gemspec: Installing rake 12.3.1 (was 12.3.0) Installing rack 2.0.5 (was 2.0.3) Installing nio4r 2.3.1 (was 2.1.0) with native extensions Installing async 1.10.3 (was 1.6.0)
This is great! I’m currently doing DigitalOcean droplet and will move into Ruby on Rails on-click next month. Thanks for this! 
Sounds good! Looking forward to it!
Please include docker as an alternate. This would keep the skills relevant. 
I think you should write advanced things too. I know it's too much , and might get you more work, but there are very less resources to turn to when it comes to knowing things about integrationof docker and ssh and email handling and stuff . Would be good to have a beginner to expert book.
I got it to work with one of my existing apps and tried a few benchmarks. This an API endpoint that makes 7 database queries to Postgres and generates ~7.5k of JSON. The database is small enough to fit in memory. This is probably the use case that benefits the least from from HTTP2's performance improvements. *Huge disclaimer:* None of the usual benchmark tools, including Wrk used here, support HTTP/2 yet, so this is all HTTP/1.1. # Falcon: 2 workers # wrk: 2 threads, 10 connections per thread ➜ ~ wrk --latency -d 5 https://127.0.0.1:9292/api/v1/servers Running 5s test @ https://127.0.0.1:9292/api/v1/servers 2 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 50.89ms 10.68ms 74.90ms 65.65% Req/Sec 97.80 11.62 121.00 64.00% Latency Distribution 50% 44.47ms 75% 60.55ms 90% 63.60ms 99% 64.69ms 981 requests in 5.03s, 7.42MB read Requests/sec: 194.85 Transfer/sec: 1.47MB # Unicorn: 2 workers # Wrk: 2 threads, 10 connections per thread ➜ ~ wrk --latency -d 5 http://127.0.0.1:5000/api/v1/servers Running 5s test @ http://127.0.0.1:5000/api/v1/servers 2 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 53.73ms 3.12ms 67.14ms 94.18% Req/Sec 90.89 4.72 101.00 78.00% Latency Distribution 50% 53.63ms 75% 54.51ms 90% 56.01ms 99% 59.20ms 910 requests in 5.02s, 6.88MB read Requests/sec: 181.30 Transfer/sec: 1.37MB # Puma: 2 workers, 1 thread per worker # Wrk: 2 threads, 10 connections per thread ➜ ~ wrk --latency -d 5 http://127.0.0.1:3000/api/v1/servers Running 5s test @ http://127.0.0.1:3000/api/v1/servers 2 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 9.70ms 674.66us 13.55ms 92.74% Req/Sec 206.50 7.31 222.00 76.00% Latency Distribution 50% 9.56ms 75% 9.69ms 90% 9.85ms 99% 12.53ms 1033 requests in 5.08s, 7.76MB read Requests/sec: 203.37 Transfer/sec: 1.53MB # Puma: 1 worker, 2 threads per worker # Wrk: 2 threads, 10 connections per thread ➜ ~ wrk --latency -d 5 http://127.0.0.1:3000/api/v1/servers Running 5s test @ http://127.0.0.1:3000/api/v1/servers 2 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 13.71ms 1.71ms 29.25ms 88.25% Req/Sec 73.02 6.73 80.00 59.00% Latency Distribution 50% 13.28ms 75% 13.77ms 90% 15.74ms 99% 23.94ms 732 requests in 5.03s, 5.50MB read Requests/sec: 145.65 Transfer/sec: 1.09MB # Falcon: 2 workers # Wrk: 4 threads, 10 connections per thread ➜ ~ wrk -t 4 --latency -d 5 https://127.0.0.1:9292/api/v1/servers Running 5s test @ https://127.0.0.1:9292/api/v1/servers 4 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 40.74ms 2.44ms 51.48ms 85.77% Req/Sec 48.81 7.60 60.00 43.50% Latency Distribution 50% 40.47ms 75% 41.12ms 90% 43.58ms 99% 44.49ms 984 requests in 5.05s, 7.44MB read Requests/sec: 194.80 Transfer/sec: 1.47MB # Unicorn: 2 workers # Wrk: 4 threads, 10 connections per thread ➜ ~ wrk -t 4 --latency -d 5 http://127.0.0.1:5000/api/v1/servers Running 5s test @ http://127.0.0.1:5000/api/v1/servers 4 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 42.39ms 2.73ms 51.45ms 85.17% Req/Sec 46.56 9.74 60.00 65.00% Latency Distribution 50% 41.92ms 75% 43.49ms 90% 45.54ms 99% 49.07ms 944 requests in 5.07s, 7.14MB read Requests/sec: 186.28 Transfer/sec: 1.41MB # Puma: 2 workers, 1 thread per worker # Wrk: 4 threads, 10 connections per thread ➜ ~ wrk -t 4 --latency -d 5 http://127.0.0.1:3000/api/v1/servers Running 5s test @ http://127.0.0.1:3000/api/v1/servers 4 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 9.70ms 659.16us 13.25ms 93.04% Req/Sec 103.34 5.31 111.00 65.00% Latency Distribution 50% 9.55ms 75% 9.69ms 90% 9.89ms 99% 12.56ms 1035 requests in 5.06s, 7.77MB read Requests/sec: 204.37 Transfer/sec: 1.53MB # Puma: 1 worker, 2 threads per worker # Wrk: 4 threads, 10 connections per thread ➜ ~ wrk -t 4 --latency -d 5 http://127.0.0.1:3000/api/v1/servers Running 5s test @ http://127.0.0.1:3000/api/v1/servers 4 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 13.68ms 1.11ms 18.29ms 79.54% Req/Sec 73.10 5.19 80.00 63.00% Latency Distribution 50% 13.38ms 75% 13.92ms 90% 15.48ms 99% 17.19ms 733 requests in 5.03s, 5.50MB read Requests/sec: 145.60 Transfer/sec: 1.09MB I'm honestly not sure if I trust these numbers because Puma just seems so much better. I might retry this with Apache Bench later. 
Have you considered adding Capistrano? Make life really easy after initial setup. 
Thanks I will take a look at how this can be fixed correctly.
What OS were you testing on?
Did the cert issue solve the image loading issue? Otherwise please file a bug report and I will take a look.
Nio4r falls back to `select` on Darwin so that might be why the latency is so high. I will see if I can do some impartial benchmarks on Linux later this week. Thanks for your effort so far it’s interesting to see the comparison.
I gotta say, I've been deploying to Linode/Digital Ocean since I started on Rails, years and years ago, and I'd written some scripts to automate some stuff, but it was still a headache to manage these deployments. I recently tried out [Hatchbox](https://www.hatchbox.io/) and while I only have toy projects deployed using their service currently, I freaking love it. Super easy setup, and great UI. It does EXACTLY what I need as far as deploying apps goes, and it's integrated with Github webhooks as well. Could not recommend them enough.
Holy shit that is awesome!
Already been done. See "Efficient Rails DevOps" by Michael Trojanek at [https://efficientrailsdevops.com](https://efficientrailsdevops.com)
This looks really cool; it's definitely better than how I'm handling csv files. I have a question though. How does it handle really large files? I work with a lot of large csv files and a lot of the parsers I've used read the entire file into memory. This really isn't feasible for files that are several gigs. Does this parser have the ability to read files in chunks? Either way, this looks great, good job!
You do realize that Rails came out of Basecamp. Also, Basecamp's real world needs are a big part of what continues to drive the framework forward. If they weren't constantly sharing common implementations extracted from Basecamp then you'd have no Rails or any of the libraries that comprise it. How dare they share their work with us... for free. 🤷‍♂️
I love this one. Good enough for me to get started last time.
I did a comparison of concurrency/scalability here: https://www.codeotaku.com/journal/2018-06/improving-ruby-concurrency/index#performance In general, I think `falcon` has performance comparable to other web servers available for Ruby. However, where it really shines is when you are concerned about concurrent requests with slow IO (e.g. HTTP/database IO in the web application). Provided you use `async`, you can get massive throughput and scalability advantages as shown above. In essence, it allows you to utilise your hardware more effectively.
You are right. My apologies.
&gt; Remember the point of Ruby is to be a pleasure to read and write. Insightful comments. I couldn't agree more with this quote. Regarding `and` and `or` keywords, I've generally had the sentiment that since it's a double-edged sword, it wouldn't be as easy-to-read and -write since you have to spend a bit more time carefully grokking its usage. Thoughts? 
hatchbox.io is really good and cheap. Unlimited servers, projects
If you do have the time, give Go a shot, it'll be worth the time you spend on it. All the best.
Thanks for your kind words. All parsers are "streaming" parsers using an io object for input (and than use getch with a one char lookahead max). Sorry I haven't done any benchmarks or tests on huge files but in theory it's all the same as the old library, that is, for huge / big files use Csv.foreach or Csv.parse with a block or an enumerable (they all really use each "under the hood" ) to read one record at a time (stream-like). The all-in-memory methods e.g. Csv.read or Csv.parse (without a block) are for convenience. Cheers. Prost. 
Thank you. Sure I was thinking about this a lot.
Yes I did consider it. The idea was the only gun you need is Bash. Don't want to teach Ruby in the book :(. Thank you.
Thanks for the reply. I agree that deployment can be pain. My book is focused on understanding things on fundamental level and foster Linux confidence. If people start deploying Rails themselves after reading it great! If they use something like Hatchbox great as well!
Thank you :)
Thanks for the suggestion!
Thank you very much for your insight! I never claimed it wasn't done before although your links are new to me, thanks for sharing them. One thing I *always* missed in DevOps tutorials is lack of SELinux (or AppArmor). Many authors just skip it/disable it in the beginning and many newcomers might feel that's okay to do. Also as a Fedora developer I feel like everybody just goes with Ubuntu where I would like to encourage people go with Fedora/CentOS. About Docker. Even though I briefly maintained [Ruby Docker STI images for OpenShift 3](https://blog.openshift.com/using-openshift-s2i-docker-images-to-build-ruby-application-containers/) I don't claim myself to be a Docker expert (yet :)). I plan to blog more about Docker soon though (especially the development part). For my personal* projects on VPS I skip Docker in production now, deployment without it is *really* fast, simpler and I like it :). * I used Docker at work, I just don't use it for my projects on VPS. This opinion might change in few years though!
Merge sort can work efficiently only loading some records from disk.
For those who use it, why puma over passenger? 
 response = '{ "b_path": [ { "id": 1, "name": "a" }, { "id": 2, "name": "b" } ] }' parsed = JSON.parse(response) parsed['b_path'].each { |h| h.delete('id') } parsed # =&gt; {"b_path"=&gt;[{"name"=&gt;"a"}, {"name"=&gt;"b"}]}
Very right answer. Thank you!
thanks :)
I feel seriously uneasy about it (as with several other Performance-department cops). As I am constantly coming into discussions from "quality of code (as a text)" point of view, I can't help noticing that some "performance optimization" cops are at the same time "style pessimization" ones, and refactoring of `.compact.flatten.map` into a set of bang-expressions feels like "de-Rubyfying code" to me. **Why is it important (to me)?** I believe (as I've expressed in [this](https://github.com/rubocop-hq/ruby-style-guide/pull/730) contrived discussion) that there is a "responsibility" which Ruby style guide and Rubocop takes for shaping community's preferences and directions. From this point of view, having a "knowledge" that sometimes replacing a chain by a sequence of bangs could be an important performance optimization is a nice thing; while the tool that _forces_ this style (because _sometimes_ it is important to performance) is a pretty questionable one. (And yes, I know it is currently disabled by default, but this doesn't change the whole chain of reasoning.) For me, an **important things** to think here are: * probably this kind of suggestions should NOT be produced by static code analyzer, rather by a smart profiler (here is slowdown/unnecessary memory allocation _found_, and probable cause is ...); * probably more "Rubyesque" way of solving such kind of problems is `Enumerator::Lazy` -- which, sadly, doesn't provide neither `flatten` nor `compact` -- which probably is a nice thing to discuss in ruby-core. Sorry for a long rant!
I am wondering about two things: 1. If the standard library is broken, why not fix it? Or at least make your library a drop-in replacement (with compatible API)? 2. Why not namespace all the things, like most of the mature gems do? Your gem is taking several names (including very short and common `Csv`) which have a high probability of clashing with some gem user's code.
foo = bar || foo || baz
Sounds like you need to look into using HDFS or something similar.
Genius!
Kaminari is providing you with this type of functionality already. Maybe people skipped it because they seldom wanted it. It's: [https://github.com/kaminari/kaminari#paginating-without-issuing-select-count-query](https://github.com/kaminari/kaminari#paginating-without-issuing-select-count-query) And yeah, with all awesome kaminari views magic!
&gt; (I'm not against types, but I don't know of any type systems that aren't a complete pain, so I still like dynamic typing.) &gt; &gt; OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP. There are possibly other systems in which this is possible, but I'm not aware of them. --- [Alan Kay](http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en)
Array#lazy actually makes the code about 2x times slower so don’t use it to make things faster. I agree these things shouldn’t be applied wholesale. But in some cases when a really valuable optimization comes along it sometimes gets upstreamed to the MRI VM. For example I was part of a String.freeze fad. It made code faster but also worse because it littered the codebase with freeze method calls. A direct result of this frustration was to introduce the “Magic string freeze comment” that enabled the behavior at the file level and made the code nicer. In theory if this change (or another) showed significant improvement then it might encourage perf work in the VM. So it’s not a one or the other kind of case. Perf work is somewhat circular in that features in the VM drive work in user space and sometime the other way around. The reason this type of code perf inspection lives with rubocop is that it requires source code parsing and analysis which is what a linter does. Splitting it out to a different library could be fine in the future but in the short term I don’t think it accomplishes any goals and would make it harder to maintain two different libraries. I’ll end by mentioning that all perf work is about balencing out tradeoffs. Whether to implement a specific improvement usually depends in large part on how big the improvement is and how much “worse” it makes the code. Sometimes really bad code is worth it if the perf bump Ian high enough. Tools like rubocop can help you identify possible changes but not tell you which are “worth it”. 
&gt; If the standard library is broken, why not fix it? Ad 1) You can read the "long story" titled in the let's count the ways article series online &lt;https://github.com/csv11/docs&gt;. There's also an older reddit thread &lt;https://www.reddit.com/r/ruby/comments/993lkm/csvreader_read_tabular_data_in_the_commaseparated/&gt; with the same question and same answer. Short answer: It's unfixable. It's a hairball. A csv library needs a custom built-parser and string.split won't work for the edge cases and and handling the edge cases (escape rules, leading or trailing spaces, etc.) that's the point of a library :-)). Ad 2) It's namespaced using Csv - it differs from CSV :-). What name do you suggest? How about adding a unique guid? Csv6c5ff0ed608e75724df94a52b05dd6a8 looks great :-). 
Exactly this, merge sort is the typical solution to memory constrained sorting.
This is subtly different from the code posted. Not functionally, but pointing it out for reference. In your version, if bar is nil and foo is present, foo will be re set to foo. In the original code, if bar is nil and foo is present, it won't do an assignment. So your version reassigns foo to foo when the original does not. Like I said, not a massive change, but it's worth knowing that foo ||= baz Is the same as foo || foo = baz NOT foo = foo || baz
Those docs don't make it clear that it's going to issue a different kind of query that doesn't use "OFFSET" (or other db-specific equivalent), but use `&gt; $last_known_id` instead. It just says "creates a paginatable collection without counting the number of all records." If it actually does the first thing, the docs need to be improved to make that clear, and why that matters. As it is, it's not clear why you'd ever want to use the functionality doc'd. 
Yeah, I understand (and mostly agree) with everything you are saying :) The only point I wanted to make that probably matters is the role Rubocop plays currently frequently makes its recommendations a "laws" (for ex., it integrates into CI nicely, and I saw many times, and in my current company enforce myself the policy of "green rubocop before merge"). At one point I already had (in my previous company) a small fight with colleague over some of the Rubocop's `Performance` cops, I don't remember exactly which one, but with the same property "please make it uglier, it would be faster". So, I am biased towards this kind of cops. But I didn't want to underestimate your work in any way. (As a side note, I wonder why `#lazy`'s still so much slower.)
Actually, all you need is foo = bar || baz
&gt; Short answer: It's unfixable. It's an orphaned hairball code drop. Cool word choice, nice to know someone in this community is brave enough to say nasty things about others' work! (Well, not really.) Sad that you ignored the second part of the question: "Or at least make your library a drop-in replacement (with compatible API)?" If I not mistaken, "complete replace of CSV library" had already happened once (with `faster_csv` gem?), so chances to fix the situation are not non-existent, probably? &gt; Ad 2) It's namespaced using Csv - it differs from CSV :-). What name do you suggest? How about adding a unique guid? Csv6c5ff0ed608e75724df94a52b05dd6a8 looks great :-). I appreciate your magnificent sarcasm. Can't help noticing, though, that usually gems authors follow some process like this: * choose ONE top-level name (preferably synonym with gem's name; preferably not too generic: I imagine there in 2018 there are a lot of custom codebases that could use `Csv` name for their own CSV-related stuff) * put everything else in this namespace Just sayin'
You can implement it in Ruby, but I probably wouldn't, I'd shell out to `sort` which already implement parallel merge sort for large input and should be much faster (basically disk speed limited): http://man7.org/linux/man-pages/man1/sort.1.html
To your more general question of how to handle large datasets in Ruby: It depends. #### Do you really need to keep the whole thing in memory? For instance, if you're doing something like `Array#inject`, can you instead store the "memo" in memory and then reach item from a file, line by line? Similarly, can you put the data in a database and then perform the operation on it there? #### If you really must load the whole thing in memory... There are a lot of strategies to deal with this, but here are a few: - Be conscious of references. If an object still has a reference to it, the garbage collector can't free that memory. This can be a tricky sometimes. Profiling tools help. - Use types that occupy a minimum amount of memory: Strings, integers, floats, and vanilla structs tend to have a small footprint. - When safe to do so, modify items in place to avoid allocating more objects. Don't use `#map` on huge objects. - Only keep the data you need. Parsing a JSON string with a bunch of fields you don't need? Put the stuff you do need into a Struct and discard the rest. - It can sometimes be helpful to call `GC.start` after doing something you know generated a ton of garbage. All of the above should really only be done when you know it's necessary. Going overboard with memory optimization can ruin Ruby's expressiveness. ### Embedded devices When memory is seriously tight, like in many microcontrollers, it's usually easier to manage it yourself. So these devices tend not to use GC. Though, there are exceptions: Java Card, a stripped down Java that runs on things like SIM cards, does usually have a very limited GC available. It's been years since I've played with an Arduino, but I seem to recall C and C++ being the only languages available -- both require manual management. It's also worth noting that some devices don't allow dynamic memory allocation at all.
It's evil according some code style guides, but the nested ternary is a one liner. foo = bar ? bar : (baz ? baz : foo)
 foo = bar.present? bar : (foo || baz) Note that those many conditionals are a signal something is quite wrong with the code. Try extracting the logic into a few private methods. Ideally you want to use inheritance to take care of complex conditionals.
This is a Ruby question, not a Rails question, so why introduce the `.present?` check, which is *not* equivalent to `if bar`? If you're *are* going to assume the presence of ActiveSupport, you might as well use `presence` instead, and drop the ternary: foo = bar.presence || foo || baz
Definitely an evil use of the ternary operator. I would argue that `x ? x : y` is a smell, and should generally be rewritten `x || y`.
You probably want to map your structure into a new one. If you want to exclude a specific key like `id`, you can use `Hash#except`. If you want to instead only include specific keys, you can use `Hash#slice`. Given your hash... hash = { a_path: { b_path: [ { "id": 1, "name": "a" }, { "id": 2, "name": "b" } ] } } You can either exclude the `id` key: hash[:a_path][:bpath].map! { |h| h.except(:id) } *or*, include the `name` key: hash[:a_path][:bpath].map! { |h| h.slice(:name) } 
Good point, I am too used to idiomatic Rails code. Your solution should work too. I think an alternative there is using `.nil?` but given OP is checking for false and nil, it's not the _ same_ functionality, but it's always better to be explicit in those cases. Your solution also points to directly to the issue I mentioned in my first reply, to code is basically a conditional of 3 things. While it's not a big deal, it might point at a design flaw in OP's code.
Lol 
While this is not exactly the same as your code, I think something like this makes sense: ``` def foo_param params[:foo] || default_value end session[:foo] = foo_param ```
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [csv11/docs/.../**csv-array-hash-struct.md** (master → 8197725)](https://github.com/csv11/docs/blob/819772510873339f73539883bc5d471a285d9ca2/csv-array-hash-struct.md) * [csv11/csvreader/.../**csvreader.rb#L133** (master → 3826198)](https://github.com/csv11/csvreader/blob/3826198826b82033c57114880ba985ba1877528d/lib/csvreader.rb#L133) ---- 
If your app server is multi-threaded, don't you have to start worrying about thread safety ? Or is that safe to assume "just works" by default?
Those two pieces of code do not do the same thing though.
`foo = bar ? bar : (foo ? foo : baz)`
As someone who uses stdlib CSV all the time for a variety of things (and yet has to consult to docs all the time) I'll def give this a go. I see some code could do with a tidy. e.g. `@names = headers ? headers : nil` is a weird ternary use and you could just test for truthiness of `@names` in `#each`, as the only purpose of it is to guard against `headers` being `false` (even then `headers || nil` would do). https://www.rubydoc.info/gems/csvreader/1.0.0 is 503ing (not your fault I know)
Yes and no. I believe it still needs to be compiled to a jar file. https://stackoverflow.com/questions/151595/jruby-on-rails-vs-ruby-on-rails-whats-difference 
JRuby loads compiled .class or .jar files, not .java files. First you'll need compile the fixture with javac, then you can either wrap it into a jar or include the class file directly: https://github.com/jruby/jruby/wiki/CallingJavaFromJRuby#accessing-and-importing-java-classes
How's `foo = foo || baz` different than `foo || foo = baz`? Especially when you compare to how other shortcut operators expand: `a += b` is the same as `a = a + b`, etc.
I agree with you. The main reason for posting this question was more just curiosity than a desire to actually refactor the code. As a beginner to software development, my life is made 10x harder by trying to decipher someone else's logic that was very cleverly squeezed into as few lines as possible. As long as the code is DRY I don't see any real advantage of making it compact. On the other hand, it's quite nice to see thing written succinctly.
I am from a third world country and my English is not that great. If your target audience is people like me then I would recommend using easier words than syntactic sugar, esoterica, veer, reconcile and blurb. I had to look up these words. 
Don't they?
Syntactic sugar is something of a technical term that I would expect any programmer to eventually run into. So, I wouldn't, personally, avoid using it. Particularly with a language like Ruby, learning what syntactic sugar is, how to implement it, and what's built into the language is an important part of learning the more advanced parts. Otherwise, I agree with you. It can be difficult to remember, as a native English speaking programmer, that the rest of the world doesn't speak our language normally and is forced into learning it. So, using the harder to learn or lesser known parts of the language make things unnecessarily difficult for everyone else.
Code golf is really fun and a great mental exercise, but do it at work and your coworkers will (rightly) want to kill you and dump your body in an unmarked ditch. 
what do you think they do differently?
This is one of our interview questions, since we deal with terabytes if data and must aggregate it appropriately. And an implementation with merge sort is a correct answer. Sometimes though you don’t need to sort the file itself and just create an index and reference the offset of where the actual record resides. Much easier than schlepping tons of bits around.
A layer of indirection solves every problem :)
Sure but `x.empty? ? y : x` is not `x ? x : y` it is `x : y ? z`
It matters when the left-hand side is not a local variable, but is instead a writer method, e.g. `obj.foo ||= bar`. In `obj.foo = obj.foo || bar`, `obj.foo=` is always called (which may be expensive despite likely being redundant), whereas in `obj.foo || (obj.foo = bar)`, `obj.foo=` is only called if `obj.foo` is falsy.
I guess I don't keep up with your writings. Where's your blog/articles?
As written they do the same thing (at least as far as I can tell). I wouldn't expect to see the ternary in the wild written like that, though.
this is very bad for readability. read more &gt; [https://github.com/rubocop-hq/ruby-style-guide](https://github.com/rubocop-hq/ruby-style-guide)
Holy shit I actually wrote the loggers! So nice to see people actually using it! 
`if bar;; foo = bar;;else;; foo ||= baz;;end` Juuuuust kidddding ;)
Thanks! :-) If you are interested I opened a PR in the repo to add a 3rd one: [https://github.com/jnunemaker/httparty/pull/612](https://github.com/jnunemaker/httparty/pull/612)
Good point. Using `||` is a classic. Thanks for highlighting the tidy up. The code is not perfect (and sometimes on purpose a little verbose). I'm still trying to focus more on the functionality itself e.g. will add a numeric option that auto-converts all non-quoted values into floats and a new pre-defined table format/dialect (e.g. Csv.table.read) that uses /[ ]+/ (that is, one or more spaces) as separator and so on. That would be today's task for version 1.0.1. Cheers. Prost.
This had me confused for a bit, too. But if `x` is a method, then `x ? x : y` might call the `x` method twice while `x || y` will only ever call it once.
.java are source code files, they cannot be executed directly. This .jar must be compiled to .class file containing bytecode that the JVM can understand and execute. So yes either include it as a .jar file or execute it with the systems command, something like "java -jar your_jar_here.jar" 
It's esoteric because it requires foundational knowledge of meta-programming, lambdas, procs, blocks, using methods as objects, etc. I think preliminarily touching on the more complex topics in an article filled with them will help readers that don't have a deep understanding of Ruby.
"In an effort to be more inclusive of beginners and build up their skillsets" , so the obvious thought is maybe you should focus more on simple , skillset building topics , no? I mean the widget you're describing sounds nice but if your target audience is mostly beginners they will quickly go tired of your blog if most of your effort is esoterica.
For performance the best way forward is adding a (fast/faster) parser with a (native) c-extension. Any volunteers, any ideas, anyone :-). Cheers. Prost.
oh, that was so easy. thanks a lot. I just needed to type irb into the terminal. Will check out Pry.
thanks for the feedback. In effect, Ruby set `UTF8` as default encoding from the 2.0.0 version.
I like immutability as well, but can you just tell me why you think it's important for strings in particular?
Frankly, I would not do it. All the suggested answers are difficult to decipher. I would probably even write it like this: if bar foo = bar elsif ! foo foo = baz end That makes it more explicit.
I believe internally Ruby implements Quick Sort. I found [this thread](https://stackoverflow.com/a/29218730/2096740) where Quicksort was argued to be faster and have lower memory overhead than Merge Sort if the data is an Array. But for Linked Lists, which Ruby does not implement natively, Merge Sort was said to be superior. Any thoughts?
# frozen_string_literal: true That a magic comment that you can put in your files to make your strings immutable. In 3.0, they will be by default.
1. I really didnt understand this part - &gt;For instance, if you're doing something like Array#inject, can you instead store the "memo" in memory and then read each item from a file, line by line? (See also: Enumerator) What is "memo" here? &amp;#x200B; 2. This was nice to know, &gt;Parsing a JSON string with a bunch of fields you don't need? Put the stuff you do need into a Struct and discard the rest. &amp;#x200B;
Using a Database for working with large records is much better but one of the issues is in production environments, the number of rows in a Tier is generally cost limited. But I have not really done or know of a benchmark vs reading from file for memory, speed and disk r/w.
Once I started using pry I never wanted to go back.
There is even a pry gem that replaces the rails console with a pry console. It's wonderful.
I remember trying to set this up earlier and gave up after much effort. Just found this 'pry-rails' gem that took care of everything. Thanks.
Is there still a way to get mutable strings when this happens? I get that it's faster and has some other advantages but sometimes I really like the fact that they are mutable.
 a = "hello" b = {a =&gt; 1} # a frozen copy of a is used as the key (because hash keys can't be mutable) By using the string `a` as a key in the hash you double memory allocation, even if you don't ever change the original string `a`. Here's how to prove that: ```ruby a = "hello" b = {a =&gt; a} a[0] = "H" puts b # {"hello" =&gt; "Hello"} ```
[here](https://gist.github.com/volgorean/a13fbefacb5034ebd49c19ebd4c1bc58). Not sure why the less than or equal signs are inconsistent in your image.
y isn't referenced anywhere in the function so you can remove it from the input params.
Thanks a lot for the help!
Kiba ETL v2 officialises a new programmatic API, which helps, for instance, to provide rich feedback out of your ETL jobs. I’m detailing how you can do that in this post. Questions are welcome as usual!
If I file what I think is a bug against your library, but I’m somehow mistaken, are you going to treat me in the same insufferable manner? Tell me I’m “wrong, wrong, wrong”, etc.? Just asking so I can know if I should probably or definitely never use your libraries based on the depth of your hostility toward other members of our community.
Try Refinery - https://github.com/refinery/refinerycms
Hey, have you checked out locomotive? https://locomotive-v3.readme.io/docs It's a full engine CMS, based on rails and very powerful for dev yet simple for admins. It's open sourced and we are working on a new version with a lot of new functionalities. We provide hosting and support if needed :) 
Locomotive is neat. I love Comfy. https://github.com/comfy/comfortable-mexican-sofa
It's not a CMS but if you're willing to work with templates and markup, [Jekyll](https://jekyllrb.com/) is my personal favorite.
It's not really comparable to Wordpress or Drupal(ugh). But it's a decent tool that can be leveraged to build out a pretty nice CMS backed app.
But you had to access the method via a special `method` call, just like you have to wrap a block in a Proc to turn it into a first-class citizen. In JavaScript, you can just do var myMethod = function() {...}; var anotherReference = myMethod; myMethod(); Also, it is advised against using `Object#method` because [it's slower](https://stackoverflow.com/questions/6976629/is-the-methodmethod-name-idiom-bad-for-performance-in-ruby). That's one of the reasons I didn't mention it in the article. But I see your point - yes, you can achieve the effect of using methods like first-class citizens using `Object#method`.
It would be fairly idiomatic to do this as a case statement, using ranges: y = case x when -Float::INFINITY...-40.0 3*x+1 when -20.0...25.0 x+32 when 30.0...50.0 1+x else 5*x-1 end A slight gotcha would be that `2..5` would match 2 through 5, but I'm using `2...5` where the upper value is not included. It's the difference between &lt;= 5 and &lt; 5.
In these kinds of situations I put a `binding.pry` in there and poke around until I resolve things. If youre not using [pry](http://pryrepl.org/) and [pry-byebug](https://github.com/deivid-rodriguez/pry-byebug) youre missing out.
That's not really dependency injection, it's also trivial to test the original method...
Honestly, separate it out into two different applications. Easier to manage dependencies, builds, and you may not have to deal with templates in the Sinatra app.
You think so? I don't know, I am doing a research. I want to be able to simplify my setup to run - If it is possible - a minimal configuration on a RPI. If the more experienced ones believe so, I will follow. 
I disagree. I find single line if statements to be worlds ahead of a ternary operator in terms of readability. I'd use a single line if statement like this in cases where the total line length is less than 80 characters. Otherwise a multi line if is appropriate. 
Nothing about the IO model being completely different? One blocks by default, the other is non-blocking by default.
I may just write separate articles about the pre-reqs and link to them all as required reading.
I have a habit of being flowery in my writing that I need to watch out for, exactly for this reason. Syntactic sugar I doubt you get away from though, it's fairly universal across languages. I'll keep this in mind though and review my articles appropriately. Feel free to comment on them if a particular word is confusing, or if you would be interested in translating to your own language. I've had some articles translated to Japanese before.
On point for most all of it. The frozen string was mentioned elsewhere, so I'll skiff over that one. Blocks can be made with `{}` as well, but not like `a = { block stuff }`. You _could_ do `a = begin ... end` but that's ugly at best. Paren-free is both a blessing and a curse for Ruby. There are patches which will make it simpler to write coming in 2.6 (maybe) like this: `JSON.:parse == JSON.method(:parse)`. It won't be exceptionally useful until proc performance is improved. The entire proc vs block vs lambda vs method is pesky and unnecessary I feel. It complicates matters, especially around learning. I also object to the name "block". Function would be clearer and carry across languages more cleanly. There were arguments in the past for merging Symbols and Strings, but Matz had mentioned it'd break too many things if they did. I still want a native implementation of method-call hashes ( `hash.a, hash.b` ) If there was only one thing I could steal from JS though, it'd be destructuring.
`String#+@` will give you a mutable literal regardless of what mode Ruby is in. Similarly `String#-@` will always give you a frozen one: +"always mutable" -"always frozen" 
I wonder why the performance of String allocation trends down a bit from 2.3 to 2.5 - I can reproduce it locally too. Nice to see 2.6preview2 offers a considerable bump - over 50% faster.
Not entirely the same as drupal or so. But I moved to flat html site generators. The one I use is written in ruby. Its called jekyll. 
What code have you written so far? What issues are you having? What have you tried and what's still confusing you? At the moment you've only provided assignment details, which isn't much to go on.
Have you looked into any tools like Rails, Sinatra, Sequel, or other libraries yet?
We have rails available for this project I should have specified, we are indeed using Ruby on Rails 
I like Comfy as well.
I am honestly at a loss at where to start exactly or rather how to implement what I want to do in code. But anyways, this is what I have so far: print "Please input who won Game 1 or type 'done' to finish: " # Where it says Game 1, I want that to be a variable that goes up by 1 in the next prompt for the user to enter the # winner of the next game. For example Game 1 for the first prompt, Game 2 for the second, Game 3 for the third, # all the way until the user types, "done" # I am having trouble on how to store wins. I want the wins to go up by 1 for each team that is entered and I want to # store each team with the corresponding amount of wins that they have so I can sort it later. print "Please input who won Game 2 or type 'done' to finish: " # I was thinking that maybe this could be built with a loop? where each iteration adds 1 to what game number it is? # also it stores each input with +1 wins each time it is entered. # Now once everything is entered, I want to sort the array of teams with wins and display them two times. # First in alphabetical order while also listing their ranking (total number of wins for that team divided by # the total number of wins for all teams) and their total number of wins for that team. # Second, I want the program to display the teams in order of their ranking, while also listing their team name # and total number of wins for that team. 
That works, if you know the keys already. If it's user input then it's a bad idea to convert to symbol just to use as hash keys because symbols are not garbage collected. Converting user input to symbol flares up an attack surface.
What are you using to learn Ruby?
That's a good point. Because I was working with an existing codebase it didn't immediately jump out at me, but I can definitely see this as a pitfall for a JavaScript/Node developer.
I deliberately omitted the \`{}\` block syntax because I thought that in an introductory article it would only add confusion with JavaScript's lexical blocks.
&gt; Computer Science Programming Basics in Ruby What chapter are you currently on? Are you reading straight through?
We are on Chapter 7 currently. And yes, we are reading straight through. I think this assignment is lightly implying that we use previous knowledge from chapter 6 which used arrays.
Whatever suits you
Gets me everytime - I'm predominantly a ruby dev who switches into node sometimes and immediately trips over Promises.
Maybe you should write a post for Ruby devs switching to JavaScript :)
&gt; symbols are not garbage collected. Symbol GC was [added in 2.2](https://bugs.ruby-lang.org/issues/9634).
Go to the rails tutorial, read about scaffolding. The scaffolding in rails should give you a great start from which you can uss your background knowledge 
Another vote here for Camaleon. Caught me a bit of guard at the beginning because how similar it looks to WP.
&gt; I still want a native implementation of method-call hashes ( hash.a, hash.b ) Have you ever looked at [Struct](https://ruby-doc.org/core-2.5.0/Struct.html) or [OpenStruct](https://ruby-doc.org/stdlib-2.5.0/libdoc/ostruct/rdoc/OpenStruct.html)?
It still falls under the umbrella of dependency injection. The dependency on File is removed, making it easier to test. Keep in mind it's an example. Would it have been a better or worse post if the original method was complex?
Strangely enough I did something very similar, but for very different reasons, here: https://github.com/ioquatix/mapping
While this is a nice enhancement, it assumes every column has the same type. The defacto opinion these days is to support a separate type inference/coercion library that can map each cell however the user wants.
This is neat! I'm interested to see what you come up with a few months down the line as well. When I first picked up JavaScript after Ruby, I remember being tripped up because of something I was used to in Ruby. I wonder if the reverse is true. Hash key lookups will always return a value in Ruby, even if the hash doesn't have they key you looked up. You can specify almost anything, but the default (and certainly most common) return value is `nil`. It's so common that it becomes easy to forget that the returned value for a missing key could easily be truthy, and you end up conflating the truthiness of `foo[:bar]` with the existence of the key. It might be especially weird coming from JavaScript in a situation where you're counting the occurrences of items in a list, and have set the default value of your `occurrences` hash to `0`. if occurrences[:foo] == 0 puts 'Never occurred' else puts 'Yes, it occurred!' end Compared to... if occurrences[:foo] puts 'Never occurred!' else puts 'Yes, it occurred!' end &gt;We won’t get into the details as the usage of methods in Ruby is pretty straightforward and does not create confusing situations in my experience so far. Especially looking forward to hearing your opinion on this over time. I think I agree 100%... about 90% of the time. Private class methods (or rather methods that seem impossible to actually make private), and the related discussion about `self` seems to be the most common confusion. Method lookup when including multiple modules and inheriting from a class can occasionally get tricky But I don't know that it's made any "worse" by being used to JavaScript, and isn't too common. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [charliesome/charlie.bz/.../**things-that-clear-rubys-method-cache.md** (master → 092930b)](https://github.com/charliesome/charlie.bz/blob/092930b342edeff6dd6479163ec1a0f4c45294cc/posts/things-that-clear-rubys-method-cache.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e7makf2.)
Thanks everyone. I will try all. 
You can even unbind methods: https://ruby-doc.org/core/UnboundMethod.html Yes, the syntax is not like in JavaScript. Methods *are* first-class citizens in ruby. There is no "special" method - it is just a method. And why do you randomly bring in speed as reason against using something? &gt; Also, it is advised against using Object#method &gt; because it's slower. Slower against who or what? Javascript? Why does speed suddenly have a place here?
&gt; JSON.:parse == JSON.method(:parse) I don't see this in 2.6. Can you point us to the approved code to it?
If you read that section more closely, it says "maybe". It was one of the shorthands that had been discussed in the bug tracker.
Likewise. It also seems to have a good community / decent contributors behind it. Quite easy to slot into an existing Rails app. I liked Comfy Mexican Sofa for its simplicity, but Camaleon is much more of a drop-in WP clone if that's what the OP is after. Thanks for clueing me on the name. Had it wrong in my post (corrected).
&gt; Also, it is advised against using Object#method because it's slower. I don't think that is a compelling reason. It's now slower by spec. It's a RubyVM implementation detail (I assume you're referring to CRuby). I assume the degree of "slow" varies depending whether it's JRuby or something else. And it is slow because it hasn't been optimized enough, because it's used sparsely, because people perceive it as "slow". but it shouldn't be, really. 
These examples seem to focus on running selenium in its own separate docker container, is that really what you want to do? Because that sounds like a recipe for misery. Selenium and docker are both kinda inscrutable already, as I'm sure you've found out. Personally I just build a new image based on the main one that I use for deployment that includes chromium and chromedriver and run my tests on that, it works fine. If you want to see some code PM me as I don't want to dox myself.
Seconded. The nice thing about Rails is that the generators (scaffold, models, etc) are going to give you boilerplate code from the outset - at least enough for you to be able to review and start to get a better understanding. It sounds like you need to get some background on Rails in general. Michael Hartl's Rails Tutorial gets the nod from many people - I wonder if it would be of benefit: [https://www.railstutorial.org/](https://www.railstutorial.org/)
You say "databases" plural. Do you mean your app needs to talk to more than one database at a time? That may require some advanced Rails-fu (though thankfully not too advanced) that might have to wait until you have some of the basics down.
Ruby on Rails, look up some begginer tutorials. Use devise for user management.
“PLEASE DO MY HOMEWORK FOR ME” 
I added `rake benchmark:compare` which compares `falcon` and `puma`. Maybe you can play around with it and add unicorn too? I'm running it on travis, but honestly that's not a great environment for benchmarking :p
While I haven't used any myself, [the list at Awesome Ruby](https://github.com/markets/awesome-ruby#cli-builder) might be a good place to start. I'm also interested to hear what others recommend, as I'm going to be releasing a CLI tool somewhat soon too.
[https://github.com/jfelchner/ruby-progressbar/wiki/Basic-Usage](https://github.com/jfelchner/ruby-progressbar/wiki/Basic-Usage)
I was hoping to expose these settings via a protected route (e.g. `/settings`) so I can inspect them during run-time. `pry` doesn't work for this.
Is this anyhow related to the dry-rb project? If not, then the name is a bit confusing.
It’s a built-in feature. You can see it if you’re a project admin. You create one in Project Settings -&gt; Issue Collectors. 
Bad bot
Thank you, xc68030, for voting on Link-Help-Bot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://botrank.pastimes.eu/). *** ^(Even if I don't reply to your comment, I'm still listening for votes. Check the webpage to see if your vote registered!)
Don't really understand the point of it. Ruby has ducktyping/polymorphism out of the box. Protocols look like a fancy case statement
&gt; Blocks can be made with {} as well, but not like a = { block stuff }. You could do a = begin ... end but that's ugly at best. `begin ... end` doesn't define a block, nor is it a lexical scope so it's not the same thing, e.g. a = begin b = 5 b * 2 end defined? b =&gt; "local-variable" 
That is outdated, OpenStruct defines accessor methods only when they are used now. 
&gt; Also, it is advised against using Object#method because it's slower. That's one of the reasons I didn't mention it in the article. Creating functions in JS at runtime is also slower than defining them statically on an object, at least in V8. 
The example I’m seeing from you is that we should not consider people’s feelings when criticizing their work. But when I criticize your work (in particular, your extremely harsh criticism of the built-in CSV library) the same way you deflect and become defensive. Please take time to sit down with your own feelings about this and re-draft this and your past articles, and offer an apology to the author of the CSV library.
I absolutely hate the 'you dont need parens' thing. That has fucked me over so much when i am tired, and it makes everything much less readable.
&gt;Methods *are* first-class citizens in ruby. I've been trying to find a statement about that in literature but haven't found the term explicitly applied to methods. The book [Ruby Under Microscope](https://books.google.com/books?id=P7AdAgAAQBAJ&amp;pg=PA203&amp;dq=ruby+first-class+citizens&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwj98MHcif_dAhVH0FMKHUAsCdkQ6AEILTAB#v=onepage&amp;q=ruby%20first-class%20citizens&amp;f=false) uses the term "first-class citizen" when talking about blocks, procs and Lambdas. My reasoning here was that since, just like with blocks, you can't directly assign a method reference to a variable (without wrapping it in a special method calls), methods are not first-class citizens. Are you able to share a link to an authoritative source that proves that wrong? &amp;#x200B; &gt;And why do you randomly bring in speed as reason against using something? &lt;...&gt; While performance is not always a good enough reason to not use something, it does affect the adoption of a particular language/library feature. Many ES5/ES6 Array methods weren't widely adopted because early implementations didn't have good performance. &gt;Slower against who or what? Javascript? `[5, 7, 8, 1].each(&amp;method(:puts))` is slower than `[5, 7, 8, 1].each{|number| puts number}` even though the former looks more DRY and idiomatic and I would love to use it (of course performance wouldn't matter in this trivial example). I'm still new to Ruby, but the [StackOvertflow thread](https://stackoverflow.com/questions/6976629/is-the-methodmethod-name-idiom-bad-for-performance-in-ruby) I linked above has some objective data. But anyway, the original discussion was on whether methods are first-class citizens in Ruby or not.
nope: % pry [1] pry(main)&gt; a = "string" =&gt; "string" [2] pry(main)&gt; a = [ "an", "array" ] =&gt; ["an", "array"] ruby is fully dynamic with zero type checking unless you roll your own throwing exceptions with `is_a?` or `kind_of?`
This isn't really a language difference, rather it's a runtime difference. i.e. You can't really speak of 'javascript's IO model' nor 'ruby's IO model' as neither language have one, it's the runtime that provides it. There are evented runtimes for Ruby that are similar to node, and mostly the use the same libraries under the covers to implement this. 
&gt; This isn't really a language difference, rather it's a runtime difference. i.e. You can't really speak of 'javascript's IO model' nor 'ruby's IO model' as neither language have one, it's the runtime that provides it. There are evented runtimes for Ruby that are similar to node, and mostly the use the same libraries under the covers to implement this. It's also key to building DSL's, and I think that's part of the reason for it.
I think part of the reason for this is that it makes it much easier to write a DSL in ruby.
We are all human, yes. You may reread the Life of Galileo Galilei among many others how science works. The critique is about the code not about the authors. All the best. Cheers. Prost.
I would look into the curses gem. It used to be part of the standard library but they pulled it out into a gem awhile ago. https://github.com/ruby/curses https://en.wikipedia.org/wiki/Curses_(programming_library) 
**Curses (programming library)** curses is a terminal control library for Unix-like systems, enabling the construction of text user interface (TUI) applications. The name is a pun on the term “cursor optimization”. It is a library of functions that manage an application's display on character-cell terminals (e.g., VT100). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
This is really neat. I recently jumped into the Ruby ecosystem and has really appreciated the strong testing culture here. Before it would never occur to me to test something like my personal static blog, but it makes sense to me now AND I know where to start.
Hey, patleb, just a quick heads-up: **refering** is actually spelled **referring**. You can remember it by **two rs**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Welcome to Ruby! This is a bit of an original approach, but something which can also help if you start working on larger static sites with plugins. Glad you like the approach!
https://i1.wp.com/imgur.com/6EbBW.jpg
You probably want to add a helper that looks like this and include it via rspec : def session last_request.env['rack.session'] end Then you should be able to do this: expect(session[:user_id]).to be_nil
TruffleRuby uses ropes for strings, you may like these links: https://www.youtube.com/watch?v=UQnxukip368 https://chrisseaton.com/truffleruby/ropes-manlang.pdf
There are some type coercion libraries used specifically by parsers to map ASTs, such as [Parslet::Transform](http://kschiess.github.io/parslet/transform.html). There are also libraries that provide ActiveRecord style property coercion, such as [virtus](https://github.com/solnic/virtus#examples). Then you have the JSON mappers, but those are designed to accept structured input of Plain Old Ruby Objects; not Arrays of Strings. To date, the most advanced general purpose mapper in Ruby is [ROM](https://rom-rb.org/); it also has a steep learning curve. Normally, I would recommend extracting the higher-level inference/coercion layer into some kind of CSV schema library. There appears to be [several attempts](https://rubygems.org/search?utf8=%E2%9C%93&amp;query=csv+schema) at this already on rubygems.org. Worth reviewing them and taking some notes on their design.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [sinatra/sinatra/.../**base.rb#L1222** (master → b7c1064)](https://github.com/sinatra/sinatra/blob/b7c10649cad56f3263df089027621fb1753620cb/lib/sinatra/base.rb#L1222) ---- 
What the hell... 
Not a bad idea. You should consider adding that to [sinatra-contrib](https://github.com/sinatra/sinatra/tree/master/sinatra-contrib). 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [sinatra/sinatra/.../**sinatra-contrib** (master → b7c1064)](https://github.com/sinatra/sinatra/tree/b7c10649cad56f3263df089027621fb1753620cb/sinatra-contrib) ---- 
Wouldn't surprise me. I wouldn't call myself skilled, so this could be something that grows on me later in life. Where it has nailed me to the wall is when I'm very tired and it'll be something like: `method_name hash: :without_brackets` &amp;#x200B; and I totally miss it.
Yeah, I am doing Ruby for 15 years, and it still somehow fascinates me that you can imitate almost any feature from other languages pretty closely with our flexible syntax. Nice exercise, just never use it in production :) 
Are the server and API open source? I'd love to deploy it in our company environment. 
Related: https://www.serverless-ruby.org
Thanks for all the great pointer and comments. About the CSV schema library - I've alreay have built (and extracted) a working library :-), called [csvrecord](https://github.com/csv11/csvrecord), that works like ActiveRecord or Ruby Object Mapper etc. Thanks again. Cheers. Prost. PS: Trivia: CsvRecord builds on the [record](https://github.com/rubycoco/record) library. Keep it modular - yes, extracted for (re)use from csvrecord :-). 
This worked as expected: example "session variables are reset" do expect(last_request.env['rack.session'][:user_id]).to be_nil end Thanks for the help.
Thanks, it helped.
For now I’ll just use one database thanks for pointing that out
Well the idea is that in this scenario we're examining some legacy code somebody else wrote. Maybe I should make that part more clear.
Good man!
For something as simple as that, Sinatra would do just fine. Rails is fine too if you are used to it.
I think that dry-configurable do what you want.
Using Rails is probably a bad idea. It come with a bag of conventions and components that are great when building a progressive webapplication, not so much for serving a single http call. Honestly, you don't need much outside of Openssh and cfn_nag as long as you have access to a ssh-client on the client side. If you, for any reason, do want to wrap it with HTTP instead of SSH you could use any language you prefer. I'd pick a ruby microframework that I haven't used before. [Sinatra](http://sinatrarb.com/) served me well for doing small stuff like this before.
Thanks for the reply! Unfortunately the ssh approach won’t work for reasons other than technology. Rails felt heavy for all I was trying to do, yours is the second mention of Sinatra, I’ll try that out. Thanks!!
Perfect, thank you!
Looks to me that it doesn't persist configurations to disloyalties
Yea OP, answer these questions. It sounds like an [X Y Problem](http://xyproblem.info) because generally speaking, if you're wanting to store something on disk (e.g.: to persist data through runs) your talking about persisting state not "configs"... Can you take a step back and explain more the problem you're trying to solve?
Okkie, I will write an apology and add the page to the repo ([see /docs](https://github.com/csv11/docs)) in the next days. That's my thank you for the great work and many hours put into the CSV library. We are standing on the shoulders of giants. PS: By the way the quotes are from "random" guys from the ruby-talk mailing list. 
This sounds fairly similar to SQLite but obviously that has full SQL compatibility in mind
Got it working in about 30 mins with basically zero experience, worked a treat. Thanks!
Got it working with Sinatra in about 30 mins with basically zero experience, worked a treat. Thanks!
Awesome! :D
`PStore` in the stdlib is pretty awesome. https://redpanthers.co/pstore-ruby-standard-library/
You might want to reconsider your filename. \~/.config is a directory in modern Linux that has all sorts of files in it.
I remember standard lib csv was pretty slow in the old days, and fastercsv was the solution. fastercsv gave me a lot problems with memory bloat. Since standard csv was improved I've never had a problem with it. What is broken?
Yeah I hate when people bash so hard other people's code. It might be hard to work with people like that. 
I thought the CSV library already adopted Fastercsv as its implementation? (I may be mis-remembering a rails-specific thing though) I too would like to know if there’s a good write-up with valid CSV examples that the library won’t parse. 
Well, I mean, on one of these posts, someone posted this comment: &gt; I agree so much in fact, I went to go and replace one of the API endpoints in our app that imports CSV to use your gems. However, it was totally unsuitable for production use. It prints several lines of debug output to STDOUT for every"cell" in the CSV, with no way to disable it. This results in dozens of lines per row, or thousands for a very small CSV file. Heroku writes all console output to the logs, so if we were to deploy this, our logs would be full of nothing but CSV debug data. https://www.reddit.com/r/ruby/comments/9kgu83/why_the_csv_standard_library_is_broken_and_how_to/e6z10wk/
Bigger than the log issue is that it renders using the library useless for piped output if it uses STDOUT. Probably half of my CSV processing is using pipes.
Yeah I think fastercsv became the stdlib csv. I use it probably (actually definitely) more than any other stdlib gem, and although I have a couple of issues with it API-wise, I can't recall any distinct errors with it. I was supportive of this new gem the other day, but I'd echo other comments that the author should just get on with it and then evangelize further down the road. I'd even chip in with help (I browsed the code and there was quite a bit that needed refining).
Let your work speak for itself. &gt;Anyways, the point is the CSV library is broken, broken, broken and I do NOT blame the author or authors I blame all of you. Yes, YOU, all you free-loaders waiting for a miracle. This comment is filled with malice and vitriol, and I would encourage you to consider the spirit of Ruby in your writings.
&gt; Thank you for pointing out our (mostly my) grammar mistakes! Seriously. Hire a copywriter. Your mistakes are largely grammar but you're also not a sales person. You write like a technical person and if you ever want people to buy your product, well, you need to write like not a technical person... It's the CEO/C** that writes the check. Very rarely is the C** a techno nerd. &gt; We use the JOSE-JWE... Ya, literally the shit you should be putting on your website... But maybe not in so many words... would be a good job for a... copy writer? (ok, finding a copy writer who is also well versed in technology is NOT easy... I get it...) &gt;&gt; How is configuration "above" simple? &gt; I do not really understand your question here. I'm really just playing on bad copy here... "super" (depending on context) means "above"... so "super simple" literally means "above simple"... This is more stressing your need for a copy writer. &gt; To be honest, most of the time it should only take you a couple of seconds. I'm being super (or above or more than) critical, but _should_ is a funny word, and again, with as hard as you're selling the "simplicity" it makes me suspicious. &gt; However, because we realize that there currently are still a couple of rough edges, we decided to not to make things look nicer than they currently are. I can respect that. Transparency is important. &gt; Ouch! You're right. The documentation is still in the process of being written haha. Again, my point is not to hurt, but to be objective. You use fairly subjective words... &gt; I disagree with you in that this definitely is a feature: Ok, good. Sell it to me as a feature, don't just sell it as "the same shit you can do with every other framework" (because hint: they use literally the same vocabulary you do) Ultimately, my point is: hire a fucking copywriter!!! You seem to have a really good product, but that's "lost in translation" if you will, because you're a technical person trying to write sales documents. You're clearly good at writing software. You're also clearly bad at [writing about and] selling software. You should hire someone who's good at selling software. I think you have an awesome product, but you need someone to sell it.
Anyone's got any feedback on this podcast? About to start them in my next commute but curious what other people think
I don't think he realizes how abrasive he is in its writing.
And the example looks just like every other exception that's reported during a test run.
To see what OP's problem with the standard CSV library is, just look at the endless posts they've made: https://www.reddit.com/user/geraldbauer/posts/
Two things (in addition to those already mentioned: the author's shameless self promotion and trash talking) bother me about this new csv gem: 1. It's at least as confusingly designed than stdlib csv, if not more. To handle headers, you need to use a different class (CsvHash) than no headers (Csv). To handle tabs (or not skip lines that start with '#', or not skip blank lines, etc), you need to use Csv.strict.parse instead of Csv.parse. Why changing (some of) the defaults counts as "strict" is beyond me. The more I look at how to use this, the more odd/confusing design choices I find. 2. It's full of opinionated defaults. The author is building very opinionated defaults into the gem (since it meets his needs), and I think some of the defaults are patently bad ideas. For instance, a '#' indicates a commented-out line in the input CSVs. See also the default to trim leading and trailing spaces. And others, I'm sure. IMO, such things are nice features if they can be enabled easily, but the default should be to take the data straight as it is, don't change the data by default. Changing the data by default is dangerous, especially when those changes are not explicitly stated at the beginning of the documentation. I can't wait for the first company that uses this gem that ends up silently losing records because someone used a '#' that happened to be in the first field of the CSV. 
This link is 404. BTW, the easiest way is to type u/someoneauaernamehere for a user link.l
`gets` returns nil if there’s no more data on the socket to fetch. In that case, the clause of the `while` loop is false and the loop terminates.
i still dont understand how the variable \`line\` is declare with the while loop
is it like a shorthand of `line = s.gets` `while line != nil` `puts line.chop` `end`
It's like that yes, except line = s.gets is run every time the loop condition is checked. The assignment returns a value and therefore can be used as the loop condition.
Just for the sake of explanation, Consider having for loop(as in Java). for(i=0;i&lt;y;i++){ sout(i); } Here i is initialize and then incremented in each loop. In while loop the condition of termination is executed in every loop. So variable line is reassigned on every loop. When the value of line in nil the loop terminates.
whoops! forgot about that!
so its like while s.gets == nil? &amp;#x200B;
Just to make sure you understand completely: your code would not work, since you are defining "line" only once. line will never be nil in your while condition, the loop does not update it.
okay i think i get it now, `line = s.gets` evaluates to true or false so that statement is just being used as a boolean conditional, so i could use it to do something like this: `loop do` `foo = gets.to_i` `while (bar = true if foo &gt; 5)` `puts bar` `end` `end` and it would execute the code in the while loop, checking the value of foo with each iteration &amp;#x200B;
do you mean the code in my post or the above comment?
More like line = s.gets until line.nil? puts line.chomp line = s.gets end
He's talking about the code in the comment he replied to.
I think a lot of the confusion is coming from seeing a variable declared/defined inline with the rest of the code. Although this is usually not best practice, it is definitely possible. When you assign a value to a variable, that expression itself returns the value. That is why something like this will work: ``` i = (b = 12) / 4 puts i puts b ``` &gt; 3 &gt; 12 Let's run through your code sample above. We'll assume there are 2 lines being pulled from the socket, "foo" and "bar". To make it easy, let's just focus on the while loop part: ``` while line = s.gets puts line.chop end ``` The first time through the loop, the while loop says, "hey, is my condition truthy?", so it checks if `line = s.gets` is truthy. This expression sets the value of `line` to the return value of `s.gets`, then returns it. The while loop sees `"foo"`, and decides that's truthy, so it prints "foo". The next iteration through the loop, the while loop says again, "hey, is my condition truthy?". It again checks if the expression `line = s.gets` is truthy. This will, again, get the return value of `s.gets` and assign it to the variable `line`. This time through it will be "bar". The while loop will look at that and say, "yup, that's truthy". It will print "bar". The next iteration through, the while loop again says, "hey, is my condition truthy?". So, it checks if the expression `line = s.gets` is truthy. This time, however, we have reached the end of the stream; `s.gets` is `nil`, so it assigns `nil` to the variable `line`. The while loop says, "nope, not truthy!" and it ends the loop. Hope that helps! 
You've got the idea. `line = s.gets` does not evaluate to true or false, though. Conditionals in Ruby don't need to be true or false, they need to be truthy or falsey. Nil and false are examples of falsey values. Truthy values include true, and other values like 1234, 'abcde', etc. This is why you can use it in the while condition.
In this example a client is reading input from a server so basically the while loop condition in plain English is 'while the value of line is anything but false or nil' and its also assigning a (possibly) new/different value to line each time
thanks, i think i really understand it now, i probably wont use it for readability purposes but ill know what it does if i come across it again
I think the most understandable rewrite would be this: ```ruby line = s.gets while line != nil puts line.chop line = s.gets end ``` This gets the data from the socket once, then runs the while loop and after each iteration it gets the data again. This is how you would write this in something like C. Now we can take advantage here, that in ruby the result of an assignment into the variable is the assigned value itself. This would also allow something like this: ```ruby a = b = c = d = 1 puts a #=&gt; 1 puts b #=&gt; 1 puts c #=&gt; 1 puts d #=&gt; 1 ``` So, we can take advantage here and put getting data from the socket, assigning it to the variable and checking if it is `nil` into one simple line by writing it as `while line = s.gets`
yeah it seems obvious now, i think this has given me better understanding of assignment and the 'inner workings', if you like, of ruby. thanks :)
Why why why do do do you you you write write write like like like this this this.
If I remember correctly, the _only_ falsey values in Ruby are `false` and `nil`. Everything else is truthy. I don't know how many times I've tripped over 0 and the empty string not being falsey...
Its similar to a variable assignment within an if statement if foo = object.some_method end You only enter the statement if some_method does not return nil or false and the returning value gets assigned to foo. Ugly but it works. 
&gt; This is how you would write this in something like C. Even in C I would try to avoid the redundant assignment. And actually you can apply the same pattern with the assignment in the condition there as well. &gt; Now we can take advantage here, that in ruby the result of an assignment into the variable is the assigned value itself. Ruby is not special with regard to that. It's the same in Java, C...
Have a look at some of the gems for admin interfaces, they might make your life easier for this project if what they provide fits what you need. They tend to get messy if you have to tweak and customize a lot of things, but save a bunch of work otherwise. - [ActiveAdmin](http://activeadmin.info/) - [RailsAdmin](https://github.com/sferik/rails_admin) - [Administrate](https://github.com/thoughtbot/administrate) - [Trestle](https://www.trestle.io/) You can see a few more at https://www.ruby-toolbox.com/categories/rails_admin_interfaces 
 class FunnyJoke end
Sorry to be a dick but no, you don't "know Ruby pretty well".based on this. And I say this because to sooner you realize how little you know, the faster your get to proficiency.
This is some NodeJS leftpad level stuff right here. What in the...
As you said, the `while` line creates the `line` variable. It is important to understand that `line = s.gets` does two things: it sets `line` to the value returned by `s.gets` AND returns that value. That value is used as the `while` expression. `s.gets` returns `nil` when there is nothing left to get. Since `nil` is considered falsey, it will break the `while` loop. &amp;#x200B;
heh, that code was written by a C socket programmer I’ll wager.
‘line = s.gets’ is an expression in ruby, one that assign the result of ‘s.gets’ to ‘line’ and as every expression must return something it returns ‘line’. Just as ‘5+3’ only returns ‘8’. Given that i think it is pretty clear how this works. Hope it helps. More info [here](http://zetcode.com/lang/rubytutorial/expressions/) . 
I think you need to remove the “do” on the first line... You also need to make sure that the two variables joke and funny are defined.
The point they were making is not to use pry in your actual endpoint but rather to use it in development to poke around at the sinatra classes. You can also dig around the sinatra rubydocs or source code.
How can you say its different when you admit its functionally the same? Assigning foo to foo has no effect ... Whether or not assignment happens at all is irrelevant
What does that picture have to do with `&amp;.`
This is some classic FunnyJoke
An assignment expression evaluates to the newly assigned value. When #gets returns nil so does the assignment and the loop is over.
NameError (undefined local variable or method `joke' for main:Object)
In honor of your post I wrote the worst Ruby code I've ever written. Don't ever emulate this style under any circumstances. `puts(("Hahaha funny joke!" if joke.funny? || "Lame joke, man.")`
While keeps going as long as the argument is truthy. Mostly that means non-nil. Assignment returns the value. Thus `(foo = bar)` returns bar, and is truthy if bar is not nil or false. `While foo = bar` just drops the `()`
Do you ever plan on having the "config" be persistent across multiple instances? Do you plan for the config to be updated? If so, you need to store it in the database. If not, then you can built it for yourself in about 30 lines of code or less. Something roughly like this, though this is untested. [https://gist.github.com/wflanagan/e134f10f9db33aa3883262a604f219f8](https://gist.github.com/wflanagan/e134f10f9db33aa3883262a604f219f8) I typically store my custom config in the database, as I want it to work and be accessed across running instances of my code. &amp;#x200B;
Yep, especially if you don't know under what circumstances it was written. A lot of shit code is not really the fault of the messenger (programmer) but management in general.
&gt; Here we can see that in Ruby 2.0, a UTF8 string that we explicitly encode in UTF8 returns the string without replacing the unknown codepoints. So the invalid: :replace operation is omitted. &gt; In Ruby 2.1, the invalid: :replace operation is processed and the default characters � Replaces each invalid codepoint in the sequence. I hadn't realized they fixed/improved this! I am pretty sure I filed a bug report on it in 1.9, i think maybe my bug report got closed as "won't fix" at that time, but regardless I'm glad it got improved!
I think it is still an open question whether this will be default in 3.0. Last I heard Matz was considering and waiting to see how it turned out and how much software it would end up breaking when 3.0 rolled around. (Yes, originally he said it was the plan, but later backed off a bit). Personally, I hope it's not, just because it will break code that hasn't been written for it, and backwards compat is pretty crucial these days, with ruby's somewhat shrunken community we really can't afford fixing significant backward compats all the time. 
This flexibility exists because encodings, such as \`SHIFT-JIS\`, are not considered to be losslessly encode into UTF-8.
I typically feel weird passing in more than one Proc and do one of these instead once it comes to it... # With a result object... result = delete_files(files) result.on(:error) do # ... end result.on(:symlink) do # ... end # With message passing... class Handler def on_error # ... end def on_symlink # ... end end delete_files(files, Handler.new) 
I think you're describing passing in an error handler and then later additional callback handlers. A design like that can work but it requires you know the internals of a method, which can get complicated fast. In your example, you'd have to introduce a NOOP error handler for every callback if I didn't want anything. His approach about logging/raising on errors, is a common pattern. Methods/Classes are not always responsible for making sure the caller did the right thing, but the caller can ask for errors back if they want or choose to ignore them - you see that in CLI's all the time with \`--silence\` or \`2&gt;/dev/null\`. &amp;#x200B;
Shameless plug but I rail about the same problem here: https://boakye.yiadom.org/bikeshed/funparams/
&gt; Now that the giants have left the building any volunteers on adopting the standard CSV library and making it great again? Why not start with a custom purpose-built parser that handles more edges cases for escaping and quoting rules or more flexible rules / conventions for leading and trailing whitespaces and so on. Anyone? You might be giant. Maybe list the edge-cases you have discovered you buffoon? 
I guess that needs an apology :-). Here are some edge-cases to get you started: - 1, "2",3 # leading space in quote - 1,"2" ,3 # trailing space in quote - 1,2`3",4 # "unquoted non-leading" quote in value - 1,"\"2\"",3 # "unix-style" escaped quote in quote - 1,\"2\",3 # "unix-stile quote in value - and so on and so forth
I'm puzzled... are there any other ways to print a backtrace? :)
the neat thing about ruby is that everything has a return value: # enclose it: (5 if true) # =&gt; 5 (5 if false) # =&gt; nil # result can be assigned var = (5 if false) # =&gt; var = nil # therefore even assignment has a return value (line = 'line') # =&gt; 'line' # even control structures has a return value result = if (line = read_line) line else 'line was empty' end think (or rather read) about this. for me this is the very reason why ruby code is so expressive. ruby community is diverse and not everybody emphasises this style, but it's there. *take a note though, that assignment inside `while` or `if` condition is regarded as dirty code and is discouraged*. but for an example like this it's ok.
I don't think static analysis is realistic in Ruby - you can tell almost nothing at all about Ruby code statically.
I have mixed feelings over this. On the one hand it's a very nice contribution to Ruby from a huge company. On the other hand - if you truly believe your codebase is going to scale easier and be more maintainable with types, why not start rewriting it in a typed language? Stripe is probably gonna be here in 15 years from now, so that's a long term investment. &amp;#x200B;
The TTY toolkit does have a progress bar, if that's what you need/are asking for. https://github.com/piotrmurach/tty-progressbar
RuboCop mostly does textual analysis of your source code - it just looks at the sequence of characters and doesn't really do any static analysis. It's useful but it's not static analysis as I'd use the term.
I’m open to using it but I’ve never been able to figure out how to add ten lines of debug output below it. 
We use Rubocop and ESlint (standard JS preset). In both cases they are run as part of the CI build and fail the build if they don't pass. &gt; in 88% of the projects, they are required only for checking code style conventions. Glancing at the data it sounds like you would consider Rubocop / ESlint code style only? I don't agree with this, there are a number of checks in both that look for common mistakes that aren't related to code style. 
_And I felt a great disturbance, as if millions of ducks quacked in terror and were suddenly silenced_
Perhaps i'm underestimating how hard a rewrite would be....I have know idea what size their codebase is.
Someone let me know when this trend of adding types to Ruby goes away... 
Why all the cynicism itt? Gradual typing is becoming more popular in various languages (Typescript, Python) and having options for tooling never seems like a bad thing.
Move the include statement to after the method definitions. 
&gt; In your example, you'd have to introduce a NOOP error handler for every callback if I didn't want anything. Well _that_ part is easily fixed. error_policy ? error_policy.call(file, error) : raise error Or have a default expressed an argument default, that's something other than just re-raising. Although, actually, many people these days seem to think that forcing the caller to consider error handling is a _plus_ to the design. See much discussion in a functional context. 
This may help you log debug output in tty-progressbar =&gt; https://github.com/piotrmurach/tty-progressbar#5-logging
The tty is an assortment of components which can be used independently and when combined can potentially help solve your problem. I would probably start by taking a look at [tty-progressbar](https://github.com/piotrmurach/tty-progressbar) and [tty-box](https://github.com/piotrmurach/tty-box) and possibly [strings](https://github.com/piotrmurach/strings) to help you deal with text in terminal. This would probably get your pretty close to what you need. The scrolling log bit is probably the one thing you will need to be more creative with. However, I'm open to contributions once you get something going.
Why? There’s a reason for the trend of adding gradual static typing to otherwise dynamic languages. 
&gt;I don't agree with this, there are a number of checks in both that look for common mistakes that aren't related to code style. I saw that only code style rules are enforced, but I know that static analysis tools can spot other common mistakes like bugs/vulnerabilities. Do you enforce static analysis tools for checking rules different from code style conventions? &amp;#x200B;
What do you wish to do once you found some method is indeed defined in the base class?
From experience, any estimate you make is probably underestimating.
Why not use tests/specs?
One thing I forgot to mention is that the method I'm testing is private and the A module has a bunch of public methods. I was afraid that the "include" after "private" would turn private the public methods of the module.
Register it in a Singleton class for future use.
The arguments for strong(er) typing haven't changed much over the years. With JavaScript it makes sense. You have no true alternative. The Browser is the platform of the 21st century and its language is dynamically, weakly typed *and* has a lot of quirks! On the backend this is not the case. There are plenty of other (strongly) typed languages to choose from. If one is concerned about this, why are you choosing a language that doesn't support it? Bolting a bespoke type scheme on to your codebase after the fact should unnerve you and seems like a very roundabout way to fix a problem. 
I work with the Hack and Flow typecheckers every day, I can tell you with certainty that it improves developer productivity for literally tens of thousands of engineers here. Frontend/backend makes no difference. 
Yep, we use Rubocop and enforce its standards by running it as part of the CI suite (Travis) that needs to pass before merging to master. I've also got it running a a pre-commit hook, and as a linter within my editor as well, although other developers on the team have different setups there. We do have a pretty large .rubocop\_todo.yml file though, as historically we weren't using it. For the most part we've got all cops enabled with the default options. We've also got a few other static analysis tools running as part of code climate. This is still a fairly new venture, and is mainly being used to identify areas for cleanup. I wanted to try and get the comments added to pull requests, but haven't been successful, despite toggling the various options. I did managed to get it running on pull requests like our CI suite, but turned that off again pretty sharpish. We do also have a few team coding styles, but these aren't tightly enforced. These aren't part of the git repo... perhaps they should be. I should add, while we're open source, and on Github, pretty much all out contributors are internal. I've also got ESLint covering my javascript, but we haven't really come to any team consensus on that yet. &amp;#x200B;
&gt; ... a gradual typesystem was the only option. And why did this project need types? 
Because literally thousands of engineers work on this codebase. Trying to do that with a dynamically typed language is untenable. 
&gt; I work with the Hack and Flow typecheckers every day, I can tell you with certainty that it improves developer productivity for literally tens of thousands of engineers here. Okay, but isn't it possible that you're only recovering productivity that was lost in the process of quickly becoming a company with tens of thousands of engineers?
It’s a wolf in sheep’s clothing. Conflation of class with type is a straight rejection of Ruby’s existing type model, which is about message acceptance signature. I wouldn’t accept a type checker that so fundamentally and insidiously undermines Ruby. Basically they are already programming in another language. 
Have a flip through the table of contents ... there's lots you can do with ruby: http://shop.oreilly.com/product/9780596523695.do Personally, I've used ruby for all sorts of scripting tasks. In fact, I don't use perl for my scripting hardly ever any more. Everything I could do with perl, I do with ruby. Unless it's a perl one liner that I'm copy pasting.. I have actually done a lot of financial analysis with Ruby. There are plenty of financial and statistical libraries for ruby, but occasionally there are shortcomings. I have found that one can leverage tech like the 'rinruby' gem to use the R language and graphing within ruby. Sometimes I have needed to use some python as well. 
It's used in ops (Chef, Puppet, Capistrano), security (Metasploit), Dev tooling (Vagrant, Homebrew), mobile apps (RubyMotion), SASS was originally implemented in Ruby (though moving to Dart now), embedded scripting (Sketchup), I also use it a lot in place of Bash for general scripting.
I'd say your least-bad option, to retain the semantics you want, would be to move the assertion to `initialize`. The disadvantage is that that's pretty strongly on the "runtime" end of whatever divide there is in your application. The advantage is that it allows a lot more probably-reasonable usage variations, from re-opening the class to later add the needed method, to including the module in an abstract superclass while defining the method only in the actually-used subclasses. ----- The most Ruby-ful approach, though, is to not check it at all and just rely on the method to be there when it's called: for examples of that pattern, see the prototypical examples of includable modules: `Enumerable` (`each`) and `Comparable` (`&lt;=&gt;`).
Ignorant question: In the most general possible terms, what kinds of things does one need scripting for? I already planned to learn at least one scripting language, but was surprised when a friend told me I would find scripting useful even as a home user.
I can give you a couple of examples from my own personal use. I've used it to monitor stock of an item I wanted from an online shop so I didn't have to do it manually I use it to automatically fetch new TV episodes I use it to easily ssh into elastic beanstalk instances on AWS I've used it to automate commands over SSH for a number of servers Basically any definable task can become a script
Have you tried doing the include Module right before you close the class? Like instead of at the top, put it in the bottom? 
But what if it is required? When you are integrated with other systems, type safety often becomes a problem and enforcing type checking can help build a more robust solution. Having type checking in the ruby toolkit is a necessary step forward. It’s not inherently wrong simply because it is different. Needs evolve over time, as do languages in order to stay relevant. 
Interesting differentiation &amp; a good point - thanks. So I presume MRI is 'blocking' whereas non-blocking runtimes exist? 
Scripting is an excellent tool for automating repetitive tasks. Anything that can be done with several clicks and typing in a couple of inputs can usually automated with a quick script, whether it's moving and renaming files, adjusting UI colors based on the time of day or the desktop wallpaper image, etc. For example, if you take a lot of screenshots, like I do, you may want to automatically rename them with a date/timestamp plus the name of the application in the screenshot. Maybe every time you save a file in a specific directory, you want it to be automatically backed up to a home server, or sent to another device (without using Dropbox or other cloud services). 
The so-called type checking they're doing is class checking, not type checking. Type in Ruby is defined by which messages an object accepts, not what class it is. If someone has a _requirement_ that types are based on class, then they are looking for a language other than Ruby. &gt; Having type checking ... is a necessary step forward That sounds like some kind of cult slogan. Type safety is a means to an end, viz. more robust code, not an end in itself. It's neither necessary, nor is it automatically a step forward, to rip the fundamentals out of a language. 
The thing I like about Ruby is that it's a bit of a chameleon. Because of its dynamic features, you can pretty much adapt it to any use fairly easily and create a Domain Specific Language or DSL. The most famous one is, of course, Rails, but the idea is universal. You can do it in [testing](http://rspec.info/), in [automation](https://learn.chef.io/), etc. 
A cult slogan is when you take a design feature of a language and hang on to it until it stops making sense. Like it or not, people are already writing type check logic in their APIs because you need to ensure that what you get from the other side works after it comes over the wire. The other system is not necessarily going to be in ruby. Look at any well used APIs built on ruby/rails, if it ain't a library that's doing it, it's someone's implementation of type checking, whether or not it adheres to your cult slogan. Also, all language features are a means to an end. Quacking like a duck is neither necessary nor automatically the right thing as a fundamental of a language.
I don’t think adding any kind of invocation qualifier to Ruby is going to abolish the need to be careful about wire protocol formats. Type checking doesn’t give you magic parsing abilities. 
It's generally good at most tasks that don't require insane performance, particularly when orchestrating already optimized tasks, and acting as a middleman data layer. One of it's chief strengths is it's ability to represent abstract case logic in a very readable manner - i.e. ruby can read a lot like English. This makes it excellent for web development as often it serves a business process purpose, such as ordering a case of paper towels, or dealing with client billing. This ability doesn't arise purely from method semantics, it also has something to do with the fact that everything is an object open to modification, as well as a lot to do with the internal consistency of the language and Rails. One classic thing you will see in a Rails app is the following: \`3.minutes.ago\` So that gives you a timestamp in local time that was exactly 3 minutes ago. Normally in some languages this would be a huge pain in the ass, especially given how trivial the task is to conceive. But Ruby/Rails makes this easier by defining a few simple functions: "#minutes" on any number, and "#ago" on any number. #minutes multiplies the number by 60, giving you the total in seconds, and "#ago" gives you that many seconds ago as a timestamp. Because we can redefine types in Ruby, Rails can create these convenience methods to better serve web applications. This is Ruby's prime strength; it is extremely mutable, and can be easily modified to serve a particular domain. It's a general purpose language in the real sense of the word. It's actually pretty bad at being good at any one thing in particular, but it's very good as a "glue" that communicates or leverages other applications and technologies. When not using it for web applications, I use it for asset pipeline stuff with my own video game projects, and I also use it as a drop-in bash script replacement when I know the environment has at least an MRI runtime. Writing system scripts in Ruby is a lot easier than in Bash, and while I do know Bash and have used it a lot, it's much easier in my opinion to maintain a Ruby script. &amp;#x200B;
Well you are taking one part of the solution and saying that it doesn’t work for the part that doesn’t require it and invalidating the entire need for type checking. The whole thing works hand in hand to build a systemically more robust ecosystem for writing services. Invocation qualifiers are but a small part of it, and what you see in the Stripe video doesn’t go into the implementation details much but that’s what it has to deal with internally, which is what is needed to build said services. 
This effort will make it easier to write ruby programs that are more correct and with fewer errors. But, it won’t make Ruby faster. That’s why we have projects like: https://crystal-lang.org/
Again, I think this is confusing the means with the end. I’m sure your system inside Stripe makes sense to you inside the company, as an end-to-end and coherent architecture/set of practices for a particular product. But as other commenters have suggested, you may as well be writing in another language. 
Which is kinda what’s been happening don’t you think? 🤔
Programming language design is not a popularity contest.
This will be unpopular, but in industry, nothing really. Ruby is Rails. Ops is now k8s and Docker. Scripting is python. Homebrew is probably the most ubiquitous program, but it's not significant enough alone to separate Ruby from Rails (and the perception of Ruby being married to Rails).
Here's some Ruby code for solving the Archimedes Cattle Problem in 0.15 seconds. The smallest solutions have over 100000 digits. &amp;#x200B; [https://github.com/octonion/puzzles/tree/master/chakravala](https://github.com/octonion/puzzles/tree/master/chakravala)
I do not want to sound rude but this is a very bad answer and also skews the meaning of somewhat related concepts. k8s and docker absolutely DO NOT mean Ops. While ruby is a toolbox to be used to build tools what you have described are already made cranes, tools. Your question is solely based on popularity than really an answer to the OPs question. Python is used for scripting because of general popularity and availability of people that are capable of doing it. 
Wow very impressive! I feel stupid after reading all these comments :( 
SCRIPTING omg its so fun.
Asciidoctor is written in ruby. And asciidoctor is great! If you don’t know it, It’s like markdown but better. 
I'll add infrastructure testing ([ServerSpec](https://serverspec.org), [InSpec](https://www.inspec.io)), data processing ([Kiba ETL](https://www.kiba-etl.org) which I wrote &amp; use daily), etc.
&gt; The so-called type checking they're doing is class checking, not type checking You're confusing nominal versus structural typechecking. Both are a form of typechecking. I'd say that adding support for structural typing would address 99% of the concerns here. Dynamic languages almost all embrace some kind of implicit duck/structural typing ("here's a thing that has methods X, Y, Z"), which can be modeled after an anonymous interface that the checker infers. As an example, Flow heavily relies on structural typing to get around writing tons of class/interface boilerplate in Javascript. 
I’m posting this in reaction to [Outside of web development, what is Ruby best suited for?](https://www.reddit.com/r/ruby/comments/9oj6uw/outside_of_web_development_what_is_ruby_best/). The second half of this talk presents a number of use cases for Ruby in the area of data processing &amp; ETL, namely: - Micro-batches (e.g. realtime sync) - Multistep batch processing (e.g. enterprise data aggregation) - Automation of internal company tasks (e.g accounting, data extraction from PDF) - Big rewrites &amp; data migrations 
I think we should reserve out judgement until it is open sources and being actually used.
Anyone know what time will this be released in Open Source? This year ? Or looking at 2019?
Looks pretty cool, but I'd say it seems more like python than ruby. What benefit would Imba have over something like [Opal](https://github.com/opal/opal)? (Which is syntactically a lot closer to Ruby)
I would say Opal aims for Ruby compatibility. Imba is something you use to augment your Ruby app in the view layer.
What's your point? If it is just "having `#initialize` in documentation is not pretty, because it is called `.new`!", I'd leave it the current way. Looking at docs, Rubyists are used to look for `#initialize` in order to understand class' constructor call sequence. All other gems typically render `#initialize` docs this way. But if you really want it, you can, for example, use `@!method` directive like this: # @!method self.new(name) # @param name [String] 
I build all my mobile games with it. A Dark Room for iOS and Android were both built with Ruby. 3.5M downloads world wide and counting :-)
Nomenclature aside, I totally agree. An inferring Ruby type checker based on the _messages that are actually sent_ is the holy grail here. To some folks I suspect "structural type" might still mean "named interfaces", but to me it's still all about "does it respond to `is_ugly?`", not "does it implement the interface `Anitidae`.
i am using jruby for the last few years. It is ruby that runs on the java jvm and has full access to all java classes. It has allowed our older java gui (swing) application to have ruby code instead of java. Also using ruby prawn for writing pdf's.
I don't mean any offense by this, but I am going to challenge you here. How can you extrapolate that _all_ codebases can't scale to thousands of programmers, just because yours couldn't? The Linux kernel, for instance, is an example of a massive project written in a weakly typed language that has likely scaled much further than Stripe. Generally, I put strong type checking around the edges of things. So, I'm not against type checking, particularly when it's opt-in and can be localized to where it's most useful. But I'm concerned that a big company like Stripe getting behind static typing will cause a hype cycle around static type systems. Everyone would do well to remember that static typing is decades old, and ruby doesn't have it for a reason. It's not the only way to build complex systems that many people can work in without stepping on one another's toes, but it might be the only way _left_ for a large organization that's mired in a massive monolith.
What's neat about scripting languages is that the more you know about them, the more opportunities you'll find to use them.
I my city Ruby is used more for automated testing than it is for anything else. Even big .Net based enterprises use Ruby for automated testing.
No. Maybe at the 2 jobs you’ve been at, but still no.
Why? Static type systems are ancient in software-years. Their tradeoffs were well known back when Matz invented ruby!
Thank you for echoing what I'm sure are the thoughts of many of us reading this thread.
&gt; The whole thing works hand in hand to build a systemically more robust ecosystem for writing services Do you mean "services" as in "service objects" or "microservices?" What do you mean by "services?" Do you mean "services" as in "service objects" or "service architecture?"
In industry you can spend 6 months writing your own cranes, while 99% of businesses will be using the currently hireable open source solution. There's nothing wrong with Ruby being primarily used for Rails, it's a great framework.
When I google for job postings for Ruby, why are they all Rails jobs?
You could try using mimemagic ([https://github.com/minad/mimemagic](https://github.com/minad/mimemagic)) or ruby-filemagic ([https://github.com/blackwinter/ruby-filemagic](https://github.com/blackwinter/ruby-filemagic)) &amp;#x200B; I haven't used these, not sure if one is better
What library should I import ?
IIRC it’s in the standard lib, so you don’t need to require anything... https://ruby-doc.org/core-2.5.1/Dir.html
Great! Keep up the awesome work!! :) ♪♫♪♫♪
https://www.ruby-lang.org/en/community/ruby-core/ Probably there.
Not sure where you live, but here's a[ ruby job search](https://www.indeed.com/jobs?as_and=ruby&amp;as_phr=&amp;as_any=&amp;as_not=tuesday+steakhouse+steak&amp;as_ttl=&amp;as_cmp=&amp;jt=all&amp;st=&amp;as_src=&amp;salary=&amp;radius=25&amp;l=Columbus%2C+OH&amp;fromage=any&amp;limit=10&amp;sort=&amp;psf=advsrch) for my town
You probably want to write a DSL and after that monkey patch all the things. Doable, but why?
I don't think it's possible to alias a keyword in Ruby. 
This is not something you can override. It's a keyword like `def`, `if`, `class`, etc. You gotta change the ruby interpreter. This seems like an important change thought and I'm all for it.
Thanks for all the feedback. I will answer all of them. For this one, I realize now that I should have called it a saved state or context not a config. In my little tool it will consist of a handful of data, which can easily be represented as JSON, YAML or a text file. So for example, it might contain "number\_of\_devices = 3"
See above. But I agree with the sentiment expressed: this is not really a config, it's more of a state or context. I am writing a small CLI to operate my home automation (yes I know there are lots of gems. I am using them.). And I want it to remember from invocation to invocation certain simple facts so it will remember. I guess its analogous to a .git directory in a git repo. But not nearly as much information!
Checked it out. Thanks for the tip but it doesn't quite do it.
See above, it should clear it up.
Thanks for reminding me of that. Totally correct. I will not use .config :) 
Thanks. A couple of points. Even "just 30 lines" that someone else wrote and tested is 30 lines I don't have to write. And I think that by the time I've got a solid tool it easily could be more. But you do remind me of concurrency which I hadn't considered. If I am running this tool in two processes my scheme with a text file containing json is gonna break down fast. At that point I will have to switch to something else. Whats the simplest lightest store accessible from ruby that would handle that? Is there anything simpler than sqlite3?
Hello, I've published a new library / gem, that is, [csvjson that lets you read tabular data in the (new) CSV &lt;3 JSON format](https://github.com/csv11/csvjson), that is, comma-separated values (CSV) line-by-line records with javascript object notation (JSON) encoding rules. What's CSV &lt;3 JSON? CSV &lt;3 JSON is a Comma-Separated Values (CSV) variant / format / dialect where the line-by-line records follow the JavaScript Object Notation (JSON) encoding rules. It's a modern (simple) tabular data format that includes arrays, numbers, booleans, nulls, nested structures, comments and more. Example: # "Vanilla" CSV &lt;3 JSON 1,"John","12 Totem Rd. Aspen",true 2,"Bob",null,false 3,"Sue","Bigsby, 345 Carnival, WA 23009",false or # CSV &lt;3 JSON with array values 1,"directions",["north","south","east","west"] 2,"colors",["red","green","blue"] 3,"drinks",["soda","water","tea","coffe"] 4,"spells",[] And how to read / parse in ruby? Example: txt &lt;&lt;=TXT # "Vanilla" CSV &lt;3 JSON 1,"John","12 Totem Rd. Aspen",true 2,"Bob",null,false 3,"Sue","Bigsby, 345 Carnival, WA 23009",false TXT records = CsvJson.parse( txt ) ## or CSV_JSON.parse or CSVJSON.parse pp records # =&gt; [[1,"John","12 Totem Rd. Aspen",true], # [2,"Bob",nil,false], # [3,"Sue","Bigsby, 345 Carnival, WA 23009",false]] or records = CsvJson.read( "values.json.csv" ) ## or CSV_JSON.read or CSVJSON.read pp records # =&gt; [[1,"John","12 Totem Rd. Aspen",true], # [2,"Bob",nil,false], # [3,"Sue","Bigsby, 345 Carnival, WA 23009",false]] o CsvJson.foreach( "values.json.csv" ) do |rec| ## or CSV_JSON.foreach or CSVJSON.foreach pp rec end # =&gt; [1,"John","12 Totem Rd. Aspen",true] # =&gt; [2,"Bob",nil,false] # =&gt; [3,"Sue","Bigsby, 345 Carnival, WA 23009",false] and so on. Happy data wrangling with ruby (and csv and json). Cheers. Prost. 
I have no idea. If you don't mind that your exceptions will be gobbled up for the sweetness of the word, you could do something like this: Client code: dang(OpenURI::HTTPError) do open("https://www.reddit.com/this-url-does-not-exist") end Implementation code: module Kernel def dang(*exceptions) begin yield rescue *exceptions puts "Dang, I'm sad." end end end If you want to actually handle the error, you will need to pass two blocks and then it loses it's shine IMHO. Maybe you create a chaining DSL, like fingers_crossed{ open("http://www.hamsterdance.org/hamsterdance/") }.dang(OpenURI::HTTPError) { puts "This website doesn't exist anymore. Dang... }
You can add the following code to [this line here](https://github.com/ruby/ruby/blob/5b72097225797dfb91d4e3cbd4983bedf0eadb26/eval.c#L1913) and recompile: rb_define_global_function("dang", rb_f_raise, -1); Keywords aren't very friendly to metaprogramming.
&gt; This seems like an important change though and I'm all for it. I was gonna selfishly open a PR, but its probably only right that OP take the credit.
Perhaps thats your local market, but globally, Ruby is used primarily for Rails. Why are folks so defensive about this?
I was going to save that for April Fool's, but it seems like there's a much more pressing demand for this then I thought. I'll post an update tonight with the PR.
&gt; How can you extrapolate that all codebases can't scale to thousands of programmers, just because yours couldn't I never claimed that _all_ codebases are going to benefit from a static typesystem. I don't think that's a knowable fact, and isn't something I'm trying to prove. But as a side note, every medium to large sized project I've worked on has greatly benefited from some form of static typing. &gt; The Linux kernel, for instance, is an example of a massive project written in a weakly typed language _Weakly_, not dynamically typed. C is very much a statically typed language. Weak typing and dynamic typing are orthogonal concepts. The variant of C that the Linux kernel is written in is also not particularly weak once because of all the implicit casting warnings. &gt; Everyone would do well to remember that static typing is decades old, and ruby doesn't have it for a reason Hopefully we all recognize that engineering decisions made in the mid 90s aren't gospel. Ruby was created to be a language for doing batch text processing, a successor to Perl. It was not designed for writing large scale (usually web) applications. It's far outgrown its original purpose in the last two and a half decades. Neither Javascript or PHP have a static typesystem. But Flow and Hack have made maintaining codebases in these languages far easier than they otherwise would be. Even for small projects, I've found this to be the case. 
Are you trying to *determine the type* of a file on disk that has no file extension, or are you trying to *find* a file on disk that has an extension, given only its path and filename? These are totally different issues with totally different solutions, so you need to clarify which you're talking about to get good answers.
Are you honestly claiming that there have been no interesting advancements in gradual static typing? I urge you to go read the Flow whitepaper. These ideas were not being explored when Ruby or Javascript were young, nor were there popular implementations. Software at the scale of Google's, Facebook's, and Stripe's codebase did not exist back then. Why do you think that the above companies have gone out of their way to bolt on a static typesystem on dynamically typed languages? Do you think they're just spinning their wheels, not putting thought into these decisions? 
This sounds like good practice for using regex. You want to find the letters that come after the last period in the name.
&gt; To some folks I suspect "structural type" might still mean "named interfaces" "Structural typing" is a word with a specific meaning - that a type is satisfied not by the "name" of the thing, but by the structure of the underlying value. If somebody thinks that means "named interface", they just don't know what they're talking about. 
`rescue` is a keyword, not a method, therefore you cannot just alias it or modify via metaprogramming. What you can do (be aware, it makes completely no sense, just showing an example here) is to write a method that will wrap all your code, replace "dang" with "rescue" in that code and run it. For example: def dang_wrapper(&amp;blk) rewritten_source = blk.source.sub("dang_wrapper do", "").sub(/end\z/, "").gsub("dang", "rescue") eval(rewritten_source) end dang_wrapper do class MyClass def some_method raise "I raised error" dang RuntimeError =&gt; e puts e.message puts "but nothing happened" end end MyClass.new.some_method end If you run the code above, the output will be "I raised error\nbut nothing happened", which means the error was rescued. Again, it's just a fun snippet to see what you can achieve with Ruby. Please don't ever use it for real applications though.
Lol, this is insane. Good, I love it. Here is a "clean" way that would not require compilation to work on people's computers: You could write something that rewrites the Ruby code as it gets required. This is the approach [deep-cover](https://github.com/deep-cover/deep-cover) takes to instrument code. It's relatively tricky, but if you only need to support MRI Ruby 2.3+, it's easy. You need to override `InstructionSequence.load_iseq`, similarly to [here in deep-cover](https://github.com/deep-cover/deep-cover/blob/master/core_gem/lib/deep_cover/core_ext/instruction_sequence_load_iseq.rb). You will probably want to filter which files you transform, because `dang` could be used in your gems and you don't want them breaking. Now for the actual transformation. You can either do a `gsub(/\bdang\b/, 'rescue')`. But this would break if you also used dang inside of strings. Another option for the transformation would be to use the [parser gem](https://github.com/whitequark/parser). You would probably need to monkey-patch it because I don't think it supports customizing the syntax. But basically, but with it, you could parse the ruby code and truly consider `dang` to be a keyword used in the same context as rescue, then you only rewrite those. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [deep-cover/deep-cover/.../**instruction_sequence_load_iseq.rb** (master → 64db167)](https://github.com/deep-cover/deep-cover/blob/64db16774eee8871ad010a16b24a066a51a6d7e9/core_gem/lib/deep_cover/core_ext/instruction_sequence_load_iseq.rb) ---- 
If its linux use "file" 
I see, if it's just a key value store then something like PStore in standard library might be helpful: https://imagazine.pl/2018/03/02/ceny-telewizorow-wiosna-2018/
I would only use an IDL if I had the problems that an IDL solves.
That's `raise` isn't it?
&gt; Are you honestly claiming that there have been no interesting advancements in gradual static typing? Why do you qualify "static typing" with "gradual?" I _am_ comfortable claiming that static typing hasn't changed much in recent years, but only because it's already matured over the last 50 years. Haskell came out of the 80's, for instance. &gt; Software at the scale of Google's, Facebook's, and Stripe's codebase did not exist back then. Google? I'll buy that. Facebook? Maybe. Stripe? I don't see how you can make that claim. &gt; Why do you think that the above companies have gone out of their way to bolt on a static typesystem on dynamically typed languages? Do you think they're just spinning their wheels, not putting thought into these decisions? I think _they_ have problems that static typing solves. Not everyone does, or ever will. There's some survivor bias evident in your line of reasoning, too.
&gt; I never claimed that all codebases are going to benefit from a static typesystem. I don't think that's a knowable fact, and isn't something I'm trying to prove. But as a side note, every medium to large sized project I've worked on has greatly benefited from some form of static typing. You said this: "scaling a dynamically typed codebase to thousands of engineers was not working". This statement dispositions the problem as the lack of static typing. I'm not going to be a jerk and downplay anecdotes like yours, because thye are valuable data points, but they can't ever tell the whole story. There are ways of decomposing projects, or _partitioning_ projects, that prevent the loss of productivity that static types can reclaim. Such decomposition offers many other benefits, too, though. Static types don't make an unreadable mess suddenly become readable, for instance. &gt; Weakly, not dynamically typed. C is very much a statically typed language. &gt; Weak typing and dynamic typing are orthogonal concepts. The variant of C that the Linux kernel is written in is also not particularly weak once because of all the implicit casting warnings. In a past life, I spent a few years working in the Linux kernel itself. It's so far distant from the same universe as an FP static type system that it might as well be dynamically typed. It's tremendously easy for a mistake to get past the compiler. Contrast it to Haskell, and it's every bit as night and day as ruby is to Haskell. &gt; Hopefully we all recognize that engineering decisions made in the mid 90s aren't gospel. Ruby was created to be a language for doing batch text processing, a successor to Perl. It was not designed for writing large scale (usually web) applications. It's far outgrown its original purpose in the last two and a half decades. Yes, one would hope. The point I was making is that static type systems aren't new, and a healthy debate about them is better than everyone hopping on a bandwagon. I hope I'm not coming across as being argumentative and combative. I don't want this to get lost in the shuffle: I think it is _good_ that what Stripe has built exists and will be available for the public good. I just don't want it to be perceived as a cure-all, which can happen whenever a big company like Stripe gets behind something like this.
&gt; I have worked at, or know a number of engineers at all the companies I mentioned. I’m confident that I’ve estimated the codebase sizes correctly. These companies also deal with data and operational capacity orders of magnitude greater than what people were dealing with in the 90s. Great, but what really matters here is that large codebases with thousands of active contributors are not new. &gt; Just because large codebases were maintained in the 90s does not mean it was a very pretty sight. We’ve come to a consensus that it’s nice to catch bugs statically, before code ever runs. And many _others_ among us have come to a consensus that it's nice to catch bugs when we test our code, before we ever write additional code that depends on it. &gt; I said gradual static typing because we’re talking about a gradual static type checker for ruby :) I'm referring to how you characterized _my_ claim. You started off your comment with, "Are you honestly claiming that..." and you proceeded to qualify my claim in a manner that altered the original meaning.
 Dir.entries(path).select { |f| f.include? "825" }[0] That will give you the filename as a string, including any file extension.
I've implemented a parallel exception system in the [return_bang gem](https://rubygems.org/gems/return_bang) which uses block syntax because you need to recompile ruby after editing [defs/keywords](https://github.com/ruby/ruby/blob/4444025d16ae1a586eee6a0ac9bdd09e33833f3c/defs/keywords#L39) (I think) to change a keyword name, and you end up with an incompatible ruby. Here is the [implementation of return_bang](https://github.com/drbrain/return_bang/blob/master/lib/return_bang.rb#L3) Allowing both `rescue` and `dang` is a larger exercise which includes also modifying [parse.y](https://github.com/ruby/ruby/blob/trunk/parse.y) to add `keyword_dang` and allow it to be used in addition to `keyword_rescue`. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [drbrain/return_bang/.../**return_bang.rb#L3** (master → 77471b1)](https://github.com/drbrain/return_bang/blob/77471b15c7aa7202ec3acc04bcc9393d19d6a834/lib/return_bang.rb#L3) * [ruby/ruby/.../**parse.y** (trunk → c312111)](https://github.com/ruby/ruby/blob/c312111c7c61306ea11ab02d5548c779b4ea9cf9/parse.y) ---- 
I know what I'm doing, bot
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [minad/mimemagic/.../**README.md** (master → dd1f09f)](https://github.com/minad/mimemagic/blob/dd1f09fe1da6aba3975f6b30693a416fc8b79934/README.md) ---- 
Just use another language. It defeats the purpose of using Ruby. It's like trying to add types to Smalltalk.
If you get to the point that you're considering using this, you need to back up, stop using JavaScript, and just use Ruby in the first place.
But does it offer gradual typing..?
&gt;There are plenty of financial and statistical libraries for ruby Any recommendations?
That's awesome, congratulations. Since this is not written in Ruby, do you mind explaining how it executes Ruby jobs? Do you just specify a command line to execute?
you use ruby motion , right?
:partyparrot:
Fair point, but the answer to that is _not_ "I know, I'll write the whole frontend in something that looks kind-of-but-not-entirely-like Ruby."
Check out the [https://github.com/contribsys/faktory_worker_ruby](faktory_worker_ruby gem) for the client/worker libraries. The Faktory server is implemented in Go while the various languages need to implement their own client and worker.
I think that last one wins for most ruby-ish and least evil. 
I've used these gems: indicators, xirr, array_stats, finance, smarter_csv and parallel (for data intake), histogram/array 
Yep. And mRuby with libSDL. 
Ruby is pretty rad for [interactive command line applications](https://github.com/angela-d/resgen).
Exactly, since most of the "smarts" are in the Faktory server, the language-specific worker becomes much simpler/dumber than something like Sidekiq. You can see all the different language workers here: https://github.com/contribsys/faktory/wiki/Related-Projects
Sidekiq is, without a doubt, one of the absolute best things about working with Ruby, so I find any news about Faktory very exciting. Congratulations on the release!
 path = '4251ad3e7715dea81aaf2b25a67f026c' # it's a jpeg valid_extensions = `file -b --extension #{path}`.chomp.split('/') =&gt; ["jpeg", "jpg", "jpe", "jfif"] This assumes you're on a linux system with the `file` utility, and be aware it's not 100% accurate. 
I think that's a common thought. But, a gem someone else wrote will also be a LOT more than 30 lines. It will add bloat. You won't know everything it does. Sometimes, 30 lines of your own code, replacing thousands of lines that someone else maintains, is a good tradeoff. &amp;#x200B; I'd use the YAML/store that was described above, if i'm running multiple processes. 
This makes me happier than you know. Thank you!
Extensions are merely conventions, since it is otherwise impossible to accurately guess the intended 'type' of every file without guidance. Your best bet would be to read the first few bits of the file for its [magic number](https://en.wikipedia.org/wiki/List_of_file_signatures).
If you're just looking to serve a directory you could use the built in webserver `ruby -run -e httpd . -p 9090` Otherwise you'll want to loop over all the html files in the directory and programatically generate routes in sinatra which sounds pretty over kill but this is how you'd do it: require 'sinatra' set :bind, '0.0.0.0' Dir.glob('*.html').each do |file| get "/#{file}" do File.read(file) end end &amp;#x200B;
Hello, I've published the [tabreader library / gem version 1.0](https://github.com/csv11/tabreader) that lets you read in tabular datafiles in text in the tabular (TAB) format. Use `Tab.parse` or `Tab.read` or `Tab.foreach` or `Tab.open` or `Tab.new`. Or with headers (column names in the first row) use `TabHash.parse` or `TabHash.read` and so on. Yes, tabreader uses `"1\t2\t3".split( "\t" )` for parsing :-). Happy data wrangling with ruby (and csv and json). Cheers. Prost.
How to except some files or folders with `ruby -run -e httpd` way? Only want to show html files.
Having a quick look into this and it doesn't seem like you can without doing a bit of coding on your own [http://www.benjaminoakes.com/2013/09/13/ruby-simple-http-server-minimalist-rake/](http://www.benjaminoakes.com/2013/09/13/ruby-simple-http-server-minimalist-rake/) explains better than I can I think your best bet is to stick with the sinatra route or copy the html files into a different directory and running the command from there
Appears to be directly plagiarising https://gist.github.com/jamesyang124/03a9e374601758e3fcdc. If so, not cool.
yes, you are right. I have moved the files to another folder and ran the start server there. Perfect. Thank you.
This "article" is basically a cut-down section of Avdi's book, which starts with exactly the same code and then develops exactly the same iterative improvements, only with much longer and better discussion along the way. It's straight-up plagiarism to publish this as your own work.
Thank you. We use sidekiq on a bunch of ruby projects and I wanted to use factory on our new go projects but no one wanted to maintain a new DB engine. This will make it much easier to get a POC out and maybe get some support. 
Will Faktory one day replaces Sidekiq? 
Is there any reason that a SQL database could not have been used or would be a disadvantage to storing the state of jobs/work?
I think performance is the main reason here. A key-value store like Redis or RocksDB fits nicely with this use case. I am curious about how u/mperham plans to tackle the highly available feature that is mentioned in the wiki: &amp;#x200B; &gt;It is possible replication will be a commercial feature of Faktory Pro. My thinking: if you need high availability and reliability, you should have a budget for good tools and support. &amp;#x200B; Due to the async nature of Redis replication, there have been many reports of data loss. This makes me a little hesitant using Faktory for mission critical jobs.
From another thread over at Lobste.rs &gt; I’m confused. Why is the object version number not in the actual byte string that is sent to the cache? Then the cache store would not need to know about it at all. With the old scheme let's say that you have 3 objects and 3 slots in your cache. All of the user objects are in the cache and everything is fine. The objects are differentiated by letters A, B, and C while their versions are indicated by a number, these are all version one: ``` [A(1), B(1), C(1)] ``` ## Without Cache Versioning (recyclable cache keys) When A changes, it doesn't evict the cache for A, instead, it evicts the last cache entry which is C. So now the cache looks like this: ``` [A(2), A(1), B(1)] ``` The next time that C is requested it won't be found and so it will get added (back) to the cache: ``` [C(1), A(2), A(1)] ``` Now the next time B is requested it won't be found and will have to be added back to the cache: ``` [B(1), C(1), A(2)] ``` That one tiny change (A) resulted in clearing and re-setting the values for both B(1) and C(1) even though they never changed. ## WITH Cache Versioning (recyclable cache keys) This is what happens with the new scheme, before the change: ``` [A(1), B(1), C(1)] ``` Cache keys are consistent so the same bucket is re-used when A is updated: ``` [A(2), B(1), C(1)] ``` With this new scheme changing one value does not have a cascade effect on other cached values that has not changed. In this way we're able to keep valid items in our cache longer and do less work.
I’m not sure if performance makes sense to me as a reason here, so I’m definitely curious to hear from the author on the reasons.
Konglomerate sounds interesting, I've been following faktory and trying to think of some good way I could set up faktory to push to serverless functions to have autoscaling workers and relatively low compute costs (services like lambda are priced cheaper than separate compute instances). The issue there is that you push to serverless functions and faktory workers pull jobs. I suppose you could run really cheap workers that just push to lambda and wait for a response. But then you don't have autoscaling and still need to pay for a bunch of workers. The other option I can think of is pushing and not waiting for a response but handling lots of retry logic and such in the serverless function itself. But that gets rid of a lot of niceties of using faktory in that I need to handle my own retry logic, push jobs back on a queue if they fail myself etc.
From the Sidekiq FAQs: [https://github.com/mperham/sidekiq/wiki/FAQ#wouldnt-it-be-awesome-if-sidekiq-supported-mongodb-postgresql-mysql-sqs--for-persistence](https://github.com/mperham/sidekiq/wiki/FAQ#wouldnt-it-be-awesome-if-sidekiq-supported-mongodb-postgresql-mysql-sqs--for-persistence)
No, they will be peers.
Does it have to be free? Sikuli is probably your best bet if that's the case. Otherwise I might recommend EggPlant to your company (full disclosure I'm a manager of that company)
Could you point me to a report of people losing data due to async replication data loss? 1000s of customers use Sidekiq and Redis every day for years and I have yet to hear a single data loss issue that claims async replication as the root issue. All that said, no tool is perfect for 100% of all use cases and only you can judge your requirements.
Right, but as this was a brand new product and not Sidekiq The choice of database was open and obviously being considered based on this post.
Data loss is something that's mentioned in the official Redis docs: [https://redis.io/topics/replication#allow-writes-only-with-n-attached-replicas](https://redis.io/topics/replication#allow-writes-only-with-n-attached-replicas) &amp;#x200B; Redis is pretty solid for most use cases, but for mission critical jobs (for my company at least) the possibility of data loss is not acceptable. I guess I'm just curious if there are any other distributed data stores out there that provide the features Faktory needs. &amp;#x200B; For the record, I love Faktory and Sidekiq, and am really looking forward to watching these tools evolve.
I mean, Faktory implements a lot of the existing Sidekiq features, so I'd expect the usage pattern to be very similar. But you're right, I guess I'm just speculating here
That's an abstract design tradeoff, not an actual incident. mysql's replication is async also and millions (?) of people use it daily for their business. Faktory uses Redis in localhost / named socket mode, which is as reliable as you can get on a single node. I would be far more worried about a Faktory bug than Redis; this is, after all, pre-1.0 software.