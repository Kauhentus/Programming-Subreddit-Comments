We've taken a VERY good and LOOONG look at Elixir so thanks for the newbie intro but we are already well beyond the intro stage. We took it out for a spin, followed it for 6 months and built an app with it (thats why we KNOW the comparison to Ruby is superficial at best) Nothing about "train" implies anything about hype but yeah theres is a bit of shiny syndrome thing going on with its fans. Natural to an extent "which is designed for communications systems" thats just the point - Erlang has seen very little other mainstream use but in telecom. Its been around for 20+ years and not gone much beyond that niche (neither should it). Phoenix brings that to the web and beyond you cannot name a single mainline software use today other than that. Just like Ruby and rails. Plenty of languages run on many things but have no main usage on those things. "I don't see Go eating Elixir's lunch, and definitely not Crystal either. " Go already does precisely as I said in mindshare. Crystal if it reaches 1.0 will undoubtedly because Crystal is much more a general programming language than Elixir will ever be. Go in fact is stretching out beyond web. "IMO there are a number of Elixir libraries that have surpassed their Ruby equivalents" You are right - thats your opinion. This is one of the minor reasons I personally didn't like elixir. Elixir fans in that regard are in hype mode - theres no way a rational person would counter the fact that the Ruby community's resources is much wider and deeper in resources. The more honest thing to say is that its natural for a younger language. Which is fair and not denial of reality. "well shit, PHP still offers enough concurrency and speed for 99.999% of user applications. You can even build your own web server from scratch in C if you want" Not sure what that has to do with anything unless you have no clue about Go and think its as difficult to build something with Go as it is with C from scratch. Your lack of knowledge there is probably why you completely missed the point - PHP does NOT offer the performance and concurrency potential of Go. GO like elixir has strong concurrency built in. One of the main things that Elixir fans tout for superiority of Elixir is its out the box concurrency but the difference between Go and Elixir isn't going to break your app or limit your usership until you reach the scale where you would have to have investors and MILLONS of dollars in capital anyway (just for company non tech infrastructure)and then be able to punch up servers. Thats the .001% I spoke of . At the end of the day it doesn't make a whole lot of sense for Ruby programmers to jump off into a language thats as tied to one particular use as Ruby was, and is. to rails when its only going to make a vast difference to your apps adoption if you have millions of users with still no investors. YOU might as well migrate(or just pick up a second language since Rubys resources are so solid ) to a language where you are not so tightly coupled to one use and give yourselves as programmers a wider reach. 
↑ this What stuns me is how easily people say that Elixir is just Ruby on Erlang VM. Yes, the syntax looks similar, but that's about it. Everything else is different. If I said Java is a "Greater" C family purely because of syntactic similarities, I would probably expect the Spanish inquisition to come after me. Come on, people! There is more to programming languages than just syntax.
`i = 20 loop do`
What if you wanted to print something like i = 20 loop do i -= 1 print "Only #{i} more" break if i &lt;= 0 end Now do you see why sometimes you'd need a away to do this? 
&gt; To put this simply, the maths and scale of economy doesn't work very well for Ruby And Rails on many applications. But heres the problem with that angle (and I do agree the monetization is the factor) - regardless of stack you are going to need deep investors pockets anyway with an ad only based monetization scheme. You are right about large web scale company use but A LOT of small startups still find Ruby optimal as the first step to getting market share. Since we deal with a lot of entrepeneurial startups I can tell you getting the initial 1.0 app out there is far more important to success than being able to do twitter level massive scale. Ruby just needs to get itself 3-5 times performance level that seems to be coming and I could see it growing well again.
Ok, I can grant you that Go is certainly capturing a lot of attention, but at least in the Elixir / Erlang world you aren't going to find a lot of fans. "You are right - thats your opinion." -&gt; come at me with some examples then. Here's one: Phoenix Channels vs Rails ActionCable. I mean, if you wanna talk about day vs night ... Give us an example then of a library in Ruby that you're missing a good quality one for in Elixir / Erlang. Elixir might be young, but Erlang certainly is not. Which language is "young" then? It's dishonest to ignore the giant head start that Elixir has because it's building directly on top of Erlang. I can't comment on your specific case obviously, since you've avoided mentioning any details. I did not say that PHP offered the same potential as GO. I said that PHP is sufficient for 99.999% of web applications, performance wise. My point is that if this is your only requirement then you can basically choose whatever software you want. Go does have concurrency, but you're also dealing with shared memory, which means you're going to be dealing with mutexes. This has a limiting effect on the concurrency potential (and also guarantees subtle bugs that are difficult to debug). Elixir has a big advantage here IMO, since all data is immutable. This is not hype, this is a concrete example. I don't know about you, but I write information software for the internet, which by definition is communications software. Moving over to Elixir would solve a lot of problems for the project I'm working on right now. It's not happening right now because we are in the process of moving from ERBs to React, but it's on the radar for sure. Anyways, if you like Go, I am not going to argue with you. And actually I can't respond to any of your arguments because you haven't mentioned a single example of a library in Ruby that you're missing a quality equivalent for in Elixir. (I mean, I could come up with a few examples myself; I am not going to be doing scientific computation in Elixir anytime soon; but I'd like to hear your specific example).
So, `print i` prints the value as a number (integer) and `print "#{i}" is string interpolation, where the `#{i}` is replaced by the value of `i`. So you can do things like this `print "The number is #{i}".
It will come in handy later on. The text between the `"` double quotes is a String. We can dynamically insert text into that String with the `#{}` construct. There is no hard-coded text in the String in your example, so in this case `print "#{i}"` and `print i` will indeed give the same result. Try adding some other text into the String and observe the result: print "number#{i} "
Understood, thanks for your help! 
Thanks for putting it to me in a simple way, much appreciated 
"come at me with some examples then." Why? Why argue something so obvious as Rails having more resources than elixir? You just have to look at Rails repository compared to elixir's. Want one? okay. Devise...and don't even try to come back with coherence or Guardian or anything else. None of them are as battle tested as Devise (and certainly not as tightly integrated). You keep assuming that anyone that doesn't fall over elixir is some noob to elixir. Thats where the fanboyism comes in - every one has to love Elixir. In the most basic needs of authentication there still a back and forth over how to go about authentication in the Elixir community. For awhile looks like it was going to be coherence now not so much. With rails command line install devise - ready to roll and modify. Actioncable is a poor example. Everyone in the Ruby/rails community knew we were late to the gate there. "Which language is "young" then? It's dishonest to ignore the giant head start that Elixir has because it's building directly on top of Erlang." For someone not arguing you sure ARE - and where exactly did I deny that ELixir is written on top of Erlang. Lets face facts - Theres just a whole lot fanboy denialism with new shiny thing syndrome in the Elixir community. ELiixr has come a way but to even try and argue as you certainly ARE that it has the same amount of library resources as Ruby and Rails just shows how over the top people go with their "this is the new hotness" delerium "My point is that if this is your only requirement then you can basically choose whatever software you want." Nonsense. Plenty of languages cannot scale well out of the box. Before php 7 you probably would need to look at HVVM. Its just dishonest to pretend GO doesn't offer some pretty good concurrency better than PHP out the box and so PHP is comparable. I haven't claimed that Elixir doesn't offer advantages - but those advantages are not must have or even should have for all the great sites out there that are serving millions of users without Elixir much lss to the 99.999% that never get to that state. Elixir fanatics like to act like Elixir solves this great problem the whole world was having and no one else is or was working on while being unable to function and serve millions of users without it . Like I said 99.999% of site out there do not need the extra concurrency oomph Elixir provides over say go. Many other languages are catching up or have projects built to make them more performant. Despite Elixr fans' thinking its the zen no one is close or can catch up many aleady are catching up and they are more wider use stacks. 
If you are so secure in your decision to not use Elixir, why are you resurrecting old posts from two weeks ago and engaging in epic rants on how fanboyish everyone in the Elixir community is? Keep using Ruby, you're not bothering me. I still use it!
The Devise issue you mentioned was already fixed in master, back in October: https://github.com/plataformatec/devise/commit/1009096172f2cbc86bcd54d053c89a09be67fb9f I think it would be better to just suggest running off the master codebase (temporarily; not in production!) instead of manually re-applying the same fix.
IMHO reapplying is better. It's the only incompatibility and by fixing that you don't have to upgrade both at the same time just to make sure that your codebase runs on 2.5
aw man! I was so excited for it to come out..
&gt; Beginning with Ruby 2.5, bundler is now a part of Ruby’s core library. You’ll be able to bundle install to your heart’s content as soon as you install Ruby. If I recall correctly, the change was reverted. There was a short discussion [in a different topic here](https://www.reddit.com/r/ruby/comments/7m0vb4/ruby_250_released/drqkvc0/). I saw your comments in the thread though. Something doesn't feel right here
One nice thing is now ERB has `result_with_hash`: $ ruby -v ruby 2.5.0p0 (2017-12-25 revision 61468) [x86_64-darwin16] $ ruby -rerb -e 'p ERB.new("Hi &lt;%= name %&gt;").result_with_hash(name: "Tom")' "Hi Tom" 
Which particular performance issues are you referring to? I know that Ruby is not as fast as C, Java, C++, for various reasons and for certain applications like numerics, but otherwise it is already quite fast.
Yeah, that's really very impressive! Every Ruby release is full of nice surprises :)
You are correct, it is now possible to something like [5, "str", {}].any?(String) for which you needed to write [5, "str", {}].any? {|item| String === item} I.e. the `#===` operator is applied to the single argument and each enumerated item.
Great article. Added "Ruby 2.5 is out - Let’s benchmark" to the Ruby 2.5 News Bytes collection at the [Ruby Advent Calendar 2017](https://planetruby.github.io/advent2017/). Great to see that Ruby is getting faster (and HexaPDF too). Keep it up. Cheers.
Yes. And it really is Rails not Ruby that didn't scale good enough or cheap enough. I do agree the 1.0 app is the most important step in start up, but a lot of start up are also *not* choosing Ruby Rails simply because of its scaling problem, because Rails used to be about its ease of use, now a lot of other framework offer close enough alternative. And it doesn't help when the world has now moved to AWS which makes things 10x more expensive, compared that to Basecamp, which is still on full metal performance server. And the more important issues, is the whole Economy of Ruby. People seems to focus on tech and usefulness, and not its Ecosystem. You need more company using Ruby, successful and money making companies, which will paid and hire more Ruby developers. The Ecosystem needs to be sustainable. Ruby doesn't have the luxury of Go having Google paying dozens of developers actively developing the languages while dogfooding it, nor Apple's Swift or Kotlin from Jetbrain. PHP from Facebook, Java from all major enterprise and Python with Data Science has all reached a level where it is self sustainable. The Ruby communities thinks it is perfectly fine for companies to move off Ruby once they scale big enough, which is why there are not enough investment made into Ruby itself. 
if? resurrecting? lol...Two weeks is hardly an old thread (real programmers get busy and do their reading when they have time) ...I had no idea I would encounter a fanboy who is terribly upset just because I stated we like about 99% of the programming world are not using Elxir. 
Sure bud, I'm the fanboy here. 🤣
Thanks for this - your avatar sure is cute! What'd you use to make that? A Crystal version of this would also be awesome.
IMO reapplying is a valid *alternative suggestion*, but should not be considered the "recommended" approach. Especially if you're already using `v4.3.0` (i.e. the latest version) of the gem. If devise `v4.4.0` (or whatever) had been released, would you still recommend applying this patch, rather than updating? Probably not; you'd only do that if updating was not a plausible option right now. And besides, if you're currently *stuck* on an older Devise version for some reason, then updating your ruby version to `v2.5.0` is probably not a great idea right now anyway! So basically, *my* advise would be: Just run off the master branch, then update again to use the new Devise version when it's released. Only apply this patch manually if the above proves too problematic.
Side note: *If* you do find that updating to the latest Devise version is problematic, why not consider submitting some back-port(s) of the syntax update to older version(s) of the Devise gem? That way, people can just use Devise `3.5.11` (or whatever) rather than having to apply the patch themselves.
&gt; Dir::Tmpname#make_tmpname or Dir#tmpdir are no longer available Doh! Why'd they do that?
Weird/annoying they didn't do a release before 2.5 came out. Also don't understand why 2.5 changed that syntax legality, or if it was intentional. 
Great summary with examples and links what's news in Ruby 2.5. Added "What's New in Ruby 2.5?" to the Ruby 2.5 News Bytes collection at the [Ruby Advent Calendar 2017](https://planetruby.github.io/advent2017/). Cheers.
I think in this case you're just confused because in the block the 'name' variable should probably be called user. How does this look? names = users.map { |user| user[:name] } Basically it sometimes help to just modify code a bit to make it clearer for yourself, just make sure to not commit the changes (unless they're needed!). 
Yay!
how about comparing with other languages?
The names of the benchmarks (the bold words) are links to the gist with the benchmarks where HexaPDF is compared with other PDF libraries and tools written in C, Python, PHP. However, the goal of this benchmark was to compare Ruby versions, not Ruby against language X.
Will confirm, both of my active gems I just set travis to test 2.5.0 and everything "just worked".
2.4.0 accidentally allowed the syntax, and 2.4.2 reverted it: https://bugs.ruby-lang.org/issues/13939 What's also odd to me is that a number of people used a syntax that was only briefly valid.
Why? Static analysis has existed for decades. Ruby doesn't lack type checking because it was invented before type systems...
Use `$stdin.gets.chomp`?
The second one looks a lot more manageable. I say this as a huge ruby fan who has never been interested in lisp.
``` collection.group_by(&amp;:itself).transform_values(&amp;:count) ``` Just remember, one programmer's beautiful is another programmer's bundle of confusion! It's very clever, though, I can't help but to admit. Cheers :-)
I don't have a problem when I use the gets.chomp(currently commented out). Its when I use ARGV that I get the problem.
`gets` will read from ARGV if it's populated instead of standard input. You can also do this as `STDIN.gets`. Also, I think you can just discard arguments via `ARGV.clear` and `gets` will work as you expect again.
Ok thanks, I will look into that.
ARGV.clear worked thanks
Thank you.
Here's what I see with TravisCI running test suite: - 2.2.7 - 22.00 seconds - 2.3.5 - 22.39 seconds - 2.4.2 - 21.45 seconds - 2.5.0 - 17.26 seconds Something is noticeably faster.
at my previous company we used [clockwork](https://github.com/Rykian/clockwork) IIRC you basically set up a specific dyno in your procfile that only runs the clock scheduler, and you just use clockwork to kick off whatever sidekiq job at the interval you want.
Recursion, recursion &amp; recursion. Spoiler: https://gist.github.com/inopinatus/c2db24261b5146bf03a9e92d385da447
Aha, thanks for the clarification. So devise is actually broken in 2.4.2, not just 2.5? What's odd to me is that devise somehow got this in _only_ testing on 2.4.0 (and/or 2.4.1). Devise's [travis](https://github.com/plataformatec/devise/blob/master/.travis.yml) says it's tested on latest 2.1, 2.2, and 2.3 too. Are you sure this was really only valid in 2.4.0 and 2.4.1? I suppose I could try to do some historical commit and travis build spelunking to see if that specific devise code actually passed in &lt;2.4 versions too. The whole thing is definitely odd! That bugs issue suggests it was before only invalid when the argument is a _literal_, which would definitely not be obvious. If that is what happened, I'm sure people didn't realize they were using a syntax that was only briefly valid; the syntax of ruby, and in particular around block args and precedence and optional parens, can sometimes to me be sufficiently non-obvious to me that i just try something and see if it works (passes tests, whatever), and if it does, I figure I'm good, it would never occur to me to think it was only accidentally working, as a bug, in the particular version of ruby I happen to be using. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [plataformatec/devise/.../**.travis.yml** (master → 135d898)](https://github.com/plataformatec/devise/blob/135d898e0e955bfeb539611cf0f575d244275b22/.travis.yml) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Start with this: http://railscasts.com/episodes/366-sidekiq create a file in your app's root dir called `Procfile` with the following: web: bundle exec puma -t 5:5 -p ${PORT:-3000} -e ${RACK_ENV:-development} worker: bundle exec sidekiq -C ./config/sidekiq.yml create config/sidekiq.yml with the following: development: :concurrency: 5 production: :concurrency: 20 :queues: - default :schedule: MyWorker: every: '1m' bundle, commit, push to heroku then scale the worker dyno, `heroku ps:scale worker=1` more resources: https://github.com/mperham/sidekiq/wiki/Deployment#heroku https://gorails.com/episodes/deploying-sidekiq-to-production-with-heroku https://devcenter.heroku.com/articles/background-jobs-queueing 
Yes :) I guess the most speed-up comes from the removal of the trace instructions.
don't think this addresses the specific topic. 
&gt; Can anyone point me towards some reliable resources that explain setting up scheduled jobs to run in a Heroku app? &gt; I'm trying to set up a job that needs to run every minute but struggling to find the resources to set it up. &gt; Tried exploring Sidekiq and Sidekiq-scheduler/ Sidekiq-cron but the documentation around these seems limited/lacking..
This is already updated in the post. Travis provided 2.5.0 support.
What was the point of top level constant lookup? Seems to me like if you write Foo::Bar you _don't_ mean ::Bar. Why wouldn't it NameError in the first place?
ActionCable is also experiencing a bug with 2.5 atm. https://github.com/rails/rails/issues/31517
Using Ruby for data intensive work really does show its true color's for how slow it can be. For simple tasks, you're right, it is fast enough. It wasn't even to long ago ruby didn't even have threading. And native concurrent processing is still away's off. ATM you're stuck with using Sidekiq and other similar heavy packages.
In general this is just another click bait article that says nothing new. There are some pieces in the article that are downright offensive though. Comparing writing your app in another language/framework to being trans is fucked up.
Wow. Can't even properly count how many ways it is fucked up. 
I think you want to ARGV[0].chomp
Yes, Java belongs to the "Greater" C family, of course :-). That's a fact. For example, the all-knowing Wikipedia article on Java reads: &gt; The [Java] language derives much of its syntax from C and C++, but it &gt; has fewer low-level facilities than either of them. 
&gt; See the difference? Now try and do that for Ruby and Elixir. It's often not even possible as their semantics are so different. That snippet there for example, that cannot be written in Elixir.
&gt; That snippet there for example, that cannot be written in Elixir. Are you saying you cannot print out a list of numbers in Elixir :-) !?
I agree with you that certain kinds of applications/libraries are much slower when implemented in Ruby than, say, C or C++. However, Ruby is fast enough not just for simple tasks. Take, for example, my [PDF manipulation library](https://hexapdf.gettalong.org) (there are surely other Ruby libraries/applications out there with similar performance characteristics but since this is one of my projects I know the benchmarks), which would fall into the category of heavy object use/parsing/serialization but no CPU intensive work - it is [quite fast](https://gist.github.com/gettalong/8955ff5403fe7abb7bee) despite being written in Ruby.
`yield_self` can’t take any arguments so there's no need to pass `*args` along. It does return a sized enumerator if no block is given. Here’s a pure Ruby implementation: https://github.com/graalvm/truffleruby/blob/e4c2726f8588337bdd84dd42e4b107c50789ad19/src/main/ruby/core/kernel.rb#L472-L478
Great summary with examples and links what's news in Ruby 2.5. FYI: Added "New features in Ruby 2.5.0" to the Ruby 2.5 News Bytes collection at the [Ruby Advent Calendar 2017](https://planetruby.github.io/advent2017/). For the record so far: - Standard Gems 2.5.0 - Default Gems, Bundled Gems / by Jan Lelis, Idiosyncratic Ruby - 10 New Features in Ruby 2.5 / by Junichi Ito, Ruby programmer @ SonicGarden.jp - 10 More New Features in Ruby 2.5 / by Tom Lord, Software Developer from London - Performance Improvements in Ruby 2.5 / by Jesus Castello, Ruby Guides - yield_self in Ruby 2.5 / by Michał Łomnicki - Improved stacktrace display in Ruby 2.5 / by Michał Łomnicki - Ruby 2.5 Series / by Amit Choudhary, Mohit Natoo et al @ BigBinary - What's new in Ruby 2.5 / by Nimmy Vipin, Red Panthers - Ruby 2.5 is out - Let's benchmark / by Thomas Leitner, HexaPDF - Changes in Ruby 2.5 / by Kir Shatrov, Production Engineer @ Shopify - What's New in Ruby 2.5? / by Nithin Bekal, Programmer from Ottawa @ Shopify - New Features in Ruby 2.5 / by Rodrigo Ponce de León, Ruby developer @ WyeWorks
Still incorrect. The Heroku Scheduler (does the capitalization help). https://devcenter.heroku.com/articles/scheduler It runs one-off dynos to run some particular Ruby code. What you're suggesting is to run some always-on bit of Ruby code that spawns workers and feeds them jobs from a queue. Very different beast.
Still incorrect because he wants to run ruby code every minute and Heroku Scheduler's shortest duration is 10 minutes. Heroku Scheduler also invokes Rake, and it's fair to assume that because he's asking this question that he's fine with loading his entire environment anyway.
This is the correct answer—no answer under those constraints.
Hey thanks for the recommendation - I tried clockwork previously but was having some trouble getting it to work last time. Just tried it again and was able to finally get it all set up and running proper on Heroku! For anyone trying to do something similar, [this post](https://lorefnon.me/2016/03/31/database-driven-scheduling-with-clockwork-and-activejob.html) is what helped me finally get all the necessary pieces in place. I think the only thing this post doesn't include that I additionally did is add this to my Procfile: bundle exec clockwork clock.rb Thanks!
ARGV.clear solved the problem
#yield_self isn't similar at all to #try. That's really weird to posit. I think the author got confused with #try and #tap.
If Ruby was actually documented, we wouldn't need to scrap together these various guesses about what's been changed.
That's the reason it is open sourced, free and used so much
You're missing the point. The changes are well documented, see -&gt; https://github.com/ruby/ruby/blob/v2_5_0/NEWS The What's New in Ruby 2.5 blog posts are for celebrating and sharing the good news with friends and such. The more the better. Start spreading the news! Ruby 2.5 runs faster and faster... and so on.
cool stuff. so nice to see a project that is well documented. thx.
I don't know, strangely enough it isn't part of the announcement either, https://www.ruby-lang.org/en/news/2017/12/25/ruby-2-5-0-released/ 
&gt; well documented They don't even mention that `Dir::Tmpname.make_tmpname` is removed.
I'd say everyone tries to do the best. Remember ruby is not back by billions of dollar. It's not Apple Computer or Google Alphabeth Inc. May I ask - What have you done lately for Ruby? 
Nothing, which is why I am not a maintainer.
Can't you just traverse the tree placing each node value into an array?
That's the idea, but I'm trying to figure out how to do so, as far as what information needs to be passed along..
[Depth-First Search](https://en.wikipedia.org/wiki/Depth-first_search#Pseudocode) would be your best bet out of the [tree traversal algorithms](https://en.wikipedia.org/wiki/Tree_traversal#Data_structures_for_tree_traversal). Using the stack version would be the most straightforward approach, since you just need to clone the stack and add it to your list of paths once you hit a leaf node.
Then I guess it depends on the nature of your "tree type structure". What is the structure? Is it a binary tree? What values do the nodes hold?
Is this a [minimum spanning tree](https://www.hackerearth.com/practice/algorithms/graphs/minimum-spanning-tree/tutorial/) problem? That's a classic problem for algorithms and data structures. [Sedgewick's treatment](https://algs4.cs.princeton.edu/43mst/) is on the web. Kind of amazing that such a valuable resource is right there with diagrams and everything. The criticism for Sedgewick used to be that it doesn't handle degenerate cases very well. That's probably been fixed with modern editions, but do a lot of testing with goofy inputs — graphs with one node, that kind of thing. The [writeup on Wikipedia](https://en.wikipedia.org/wiki/Minimum_spanning_tree) is really math-heavy, but looks very complete. (IANAGT (graph theorist))
Right on and well written. Committing and proposing small changes makes code review a heck of a lot easier and it also makes bisecting to find any unexpected issues easier. When a single commit alters 10 lines on 10 files... then you still have to dig through those 100 lines to find where things went wrong.
Do you want to traverse the tree or get all possible 'paths' assuming you can only 'travel' in one direction? For the former I recommend you read this: https://en.m.wikipedia.org/wiki/Tree_traversal The latter is more complicated
**Tree traversal** In computer science, tree traversal (also known as tree search) is a form of graph traversal and refers to the process of visiting (checking and/or updating) each node in a tree data structure, exactly once. Such traversals are classified by the order in which the nodes are visited. The following algorithms are described for a binary tree, but they may be generalized to other trees as well. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
It’s one way paths, so I just want all possible paths from top to bottom. 
Wouldn't it be sufficient to get all leaves in the tree? A leaf is a node with no children. If you needed the path you could just recursive access the patent node until that is null. 
Good idea. I’ll do this... thanks!
Thank you for the kind reply :) Completely agree that it makes finding issues easier.
Not a good answer anymore, if it ever was. Compare Ruby to [its contemporaries](https://www.python.org/dev/peps/).
Even judging it as open sourced and free, it falls down compared to open and inclusive organizations: https://www.python.org/dev/peps/
hint: the terms you're looking for are "depth first" versus "breadth first". once you realize what those two mean in relation to the problem, it should be pretty obvious how to make each one work. the hard part will be figuring out which one is better for your needs.
oops, I didn't notice that in the other thread! 
Thanks for pointing it out! 
google for stuff on tree traversal, it's a classic intro computer science kind of thing. Here's an article on it in ruby. https://rlafranchi.github.io/2017/03/08/tree-traversal-for-rubyists/
You know you are correct so why not submit a patch to them to include a note in the news that make_tmpname is now performed as a part of create? 
Not sure what's your point. Can you explain? FYI: You can propose your improvements on the redmine tracker - it's public and open to everyone - https://bugs.ruby-lang.org/issues 
Nice! I believe that [fast](https://github.com/jonatas/fast) (find-in-ast) gem could be pretty helpful in tasks like this. Also, inside-and-around Rubocop there are a lot work about AST analysis and editing, worth examination, for example their [NodePattern](http://www.rubydoc.info/gems/rubocop/RuboCop/NodePattern) idea, and, in general, the "cop" itself.
I’m not hating it, but I’m curious why this is so highly upvoted in /r/ruby but has no comments and is a JavaScript library... :-/
It’s written by basecamp, the company created by DHH, who also created rails. It’s not entirely unrelated to ruby, so it is nice to get some exposure here.
I’m very familiar with the history or rails and ruby. I guess I’m mostly asking “Is this here because of Sam and DHH?”. Like I said before, I’m not hating it, it seems nice. The upboats and lack of comments is what I’m mostly curious about. 
Oh! Well, it’s a Saturday, before a holiday, and it’s it’s brand new from what I can tell. All reasons people might not have a lot to comment on about it yet, or are too busy to (what does that say about me???) That’s my guess. It’s getting upvotes because of who made it and how it’s purported to work with rails, though I have not seen how that works because the hand book in the project is not complete. 
❤️ you are a wonderful internet denizen. I hope the rest of your day is awesome. 
I upvoted because I felt is deserved attention - people need to check this out because DHH is saying, "this is how I suggest we approach JS in our community". There is a related podcast where he talks about the coming release of this library ... https://devchat.tv/ruby-rogues/rr-342-rails-development-david-heinemeier-hansson for some more context.
Upvoted as it fills into the existing JS ecosystem pretty well. For those projects where a full SPA adds unnecessary overhead for the project scope or deployment costs. 
Loved Livable Code by Sarah Mei in Brighton this year https://brightonruby.com/2017/livable-code-sarah-mei/
Thank you
It would help if you described what you've tried so far and what exact issue you're having. Toml-rb's parse function outputs your data into a hash while retaining the structure, so it should be fairly straightforward.
Looks like it turned out to be a nio4r issue.
"Looks like" - my point exactly. Elixir looks like Ruby from a syntax viewpoint but semantically it's the polar opposite of Ruby.
Some Vienna.rb / Linz.rb talks: - [Blockchain! Blockchain! Blockchain! - Build Your Own Blockchains in Ruby from Zero (Scratch)](https://github.com/geraldb/talks/blob/master/blockchain_ruby.md) - [Quik - The Missing Project Scaffolder for Ruby - Quick Start Your Ruby Gems, Your Sinatra Apps, Your Jekyll Sites 'n' More](https://github.com/geraldb/talks/blob/master/quik.md) - [New Horizons - Build Your Own (Static) Planet News Site with Pluto (and Ruby)](https://github.com/geraldb/talks/blob/master/planet.md) Happy new year. Prosit 2018!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [geraldb/talks/.../**quik.md** (master → e6296c4)](https://github.com/geraldb/talks/blob/e6296c484cca20f0fd8c9f11bdde8bb1b186c2a2/quik.md) * [geraldb/talks/.../**planet.md** (master → e6296c4)](https://github.com/geraldb/talks/blob/e6296c484cca20f0fd8c9f11bdde8bb1b186c2a2/planet.md) * [geraldb/talks/.../**blockchain_ruby.md** (master → e6296c4)](https://github.com/geraldb/talks/blob/e6296c484cca20f0fd8c9f11bdde8bb1b186c2a2/blockchain_ruby.md) ----
TL;DR: “I implemented Machine Learning in my Rails application. By writing a completely different application in Python.” Unfortunately, that’s really our only option as Rubyists, for now anyway, while Python still has a much better ecosystem for scientific computation and “mathy” stuff. It’ll get better though. There’s already a number of efforts to bring Ruby up to speed.
what makes is 3x faster?
ive been waiting for this
See the [Ruby 3x3 Page at Awesome Rubies](https://github.com/planetruby/awesome-rubies#3x3-news). The latest goody, for example, is the MJIT (method just-in-time machine code compiler infrastructure). 
Thanks for taking the time to help me understand. 
Thanks for taking the time to help me understand, that was a great podcast. 
Thank you, will look into these. I presume they’re in English?
Yes, the (linked) talk notes / slides are in English. Sorry no video recordings. Cheers. Prosit 2018!
The NES benchmark is cool... but damn that must be some unoptimized code. I remember playing emulated SNES games on my 486 at a playable FPS (no sound though, and color downsampling), and NES games ran fine. 
C is a bit better language for writing high performance virtual machine (which emulator basically is) then ruby...
we've been hearing this shit for years.
Something like this: Node = Struct.new(:value, :children) do def initialize(value: nil, children: []) super(value, children) end def paths return [[value]] if children.empty? children.flat_map { |child| child.paths.map { |p| p.unshift(value) } } end end tree = Node.new(value: 'p') c1 = Node.new(value: 'c1').tap { |n| tree.children &lt;&lt; n } c2 = Node.new(value: 'c2').tap { |n| tree.children &lt;&lt; n } c3 = Node.new(value: 'c3').tap { |n| tree.children &lt;&lt; n } Node.new(value: 'gc11').tap { |n| c1.children &lt;&lt; n } Node.new(value: 'gc12').tap { |n| c1.children &lt;&lt; n } Node.new(value: 'gc21').tap { |n| c2.children &lt;&lt; n } pp tree.paths 
10x faster abandonware and total rewrites too
Python is still ahead, but my company has a ton of Ruby code for ML stuff, primarily NLP. We use a few external libraries like Stanford NLP (which is Java), but we use rjb which integrates it nicely.
Although I really applaud any effort to make ruby faster I really think time would be better spent working with the Crystal team to make crystal more compatible with ruby. Crystal is already much faster than ruby.
What about Crystal? Do you have some insight / opinion?
then don’t use ruby/python when speed is critical, and don’t use node/go where readability and maintainability are paramount. chefs don’t just have one knife in the kitchen and orchestras don’t force every musician to use the same instrument. 
Does it still install `spring` too?
Yes, they do different things.
I love Bootsnap. It makes booting rails apps up so much faster, it's literally life-changing.
Yes, and everything is slower than f\*cking *assembler* ! We're not using Ruby because it is fast but because of the features it offers. Speed is a nice-to-have in comparison to that
You've not really given much to go on. What are you hoping to achieve with a mentor? 
The only thing that I sorta-kinda disagree with here is this: &gt; Commonly developers will notice problems and refactor as they go - and that’s awesome! But those fixes should be done in a separate pull-request. I have never worked anywhere where this means anything OTHER than "never refactor." "Fix it later" == "Fix it never"
&gt;It’s faster because it’s less compatible. If you made it more compatible it’d get slower. Slower sure but still faster than ruby. 
Why do you think that? Because it uses ahead-of-time compilation? Ahead-of-time compilation works *against* performance for the more dynamic functionality of Ruby. For something like `set_trace_func` that's easy to optimise in a virtual machine - you can elide it until it is needed. In an ahead-of-time compiled system, such as Crystal, the code to handle that functionality always has to be there, as all code is generated one during compilation. With ahead-of-time compilation, every little feature you add adds a runtime cost. With a virtual machine, the features don't need to cost anything until you use this. I don't think it would take many features to tip over to the point where ahead-of-time is slower. This is a good reason to use just-in-time compilers, even when you have an ahead-of-time compiler available. For example I work with a just-in-time compiler for C code which can sometimes outperform the ahead-of-time compilers, because it can do things like remove branches that are never taken, turn values that never change into constants, and so on. I wrote about why dynamic compilation of Ruby is so important in my PhD http://chrisseaton.com/phd/.
I don't agree - I don't think it would take many extra features before Crystal became a lot slower than an optimising implementation of Ruby with a JIT. For example, `set_trace_func`. With a JIT you can just ignore this feature until someone uses it. At that point you recompile all the code to enable it. With an ahead-of-time system like Crystal, you only have the compiled code you start with, so you need to compile in support for things like `set_trace_func` from the start, making the code slow. There are many many features like that in Ruby.
Nice work!
For those wondering [How does this work](https://github.com/Shopify/bootsnap/blob/master/README.md#how-does-this-work)
Thanks so much for the kind words :) We're really glad that we could make is open source and a part of Rails by default!
I see where you're coming from. Getting teams to refactor (or rather have them be given _time_ to refactor) is not super common. We (try to) refactor on the go at my company. Usually happens when we trip across something especially gross/troublesome/non-standard in the code base. For a long time we'd just fix it up as we came across it, but if that feature was canceled/paused/whatever, and all those refactors were lost. Now if something bothers me enough that I want to change it, I'll just open a new PR for it specifically so it's not attached to anything else.
$ echo "DISABLE_SPRING=true" &gt;&gt; .bashrc &amp;&amp; say winning
&gt; so you need to compile in support for things like set_trace_func from the start, making the code slow. Technically if you don't care about code size, you can just compile both with&amp;without and switch between them in runtime... But it definitely wouldn't be pretty implementation-wise.
It’s an exponential problem though. Compile every combination of on and off for every feature for every method? It’s technically possible but intractable in reality - which is why they’re not doing it and instead simplifying Ruby.
Oh I see, thank you. I saw production mentioned in the article from last May. gem seemed to work fine for me, but it's just in a review app now. When you Ctrl-F production in README it doesn't come up. Just a durrr moment for me, I suppose it's assumed Shopify is using it in prod if you released on github under your org :-/
Ah you're right! I fixed the confusion [in this commit](https://github.com/Shopify/bootsnap/commit/7b8ea05cff45bcf052c30fbb9b07fd5583701fea). Thanks for the feedback.
Thanks. I've just started writing, and I know not everybody would like it. Can you please be specific on what is wrong? This will help me get better as a writer.
Sorry you feel this way. Can you tell me which points you didn't like? This way I can get better at writing.
To be honest, I really don't know where to start. But, taking the "bird view", I'd suggest if you are "just started writing", to try writing on a more "utilitarian" topics, so to speak. E.g. "I know this and that, and that's how this works and why that is important". What is written in your article is "Veeeee! I ADORE Rails! Veeeeeeeeee! You SHOULD tooo! Veeeeeee! Everybody who DO NOT, are just dumb suckers!" That's exactly the kind of bullshit-first, no-strong-facts, lot-of-fun-and-pictures kind of texts that can only make the things worse for Ruby community, allowing other communities make a point of "Rubyists are just bullshitty fanboys". Sorry for the strong language, but I am trying to show you how this looks from other people perspective.
How static typing will save in situations like `user = User.fetch_from_database; puts user.department.name` (considering user may belong, or not belong to some department)? 
I think #3 and #5 are the most important. #3 - The Null Object pattern: Polymorphism is the answer to repeated conditionals. If you don't know what I mean by that, I can give examples, it's a well known refactor technique. Sandi Metz just came onsite to my company and did her 3 day course, and she recommends using polymorphism and null objects rather than using the &amp;. safe navigation operator. When it comes to OO, I trust Sandi a lot. She said many times throughout the course that if there's an if check before sending a message to an object (which I consider implicitly true when using the safe navigation operator), that's because the object is too stupid to just respond to the message! All of the messy conditional logic should be in exactly one place, and that's in a factory that creates the appropriate object - after that point, all of the objects should conform to the same interface no conditionals will be necessary. #5 - The Law of Demeter: This one I did not understand until recently, but it's really changed my life. The way I understand it is this: if you envision your objects and methods as a graph, adhering to the Law of Demeter means only working with objects that are one edge away, i.e. direct collaborators. The reason this is so important is that interconnections between objects and methods is basically the definition of complexity in software. It's what makes my brain feel like a pinball machine when trying to read code. To combat that, we have two options: either get smarter (which is biologically difficult) or make the code simpler. One way to make it simpler is by reducing dependencies, and the Law of Demeter is here to bound the number of dependencies that we create. One way to see the pain of clear Demeter violations is if your tests are a pain to set up, i.e. tons of mocking of nested data. Usually that's because you have a long method chain somewhere (user.account.thing1.thing2.description). These method chains are what needs to break down - because you need to know the return type of each call. So each call in theory could actually be coupling you to another type. 
I think all Crystal types are implicitly nilable aren't they? How do you think its type system prevents nil errors? This article gives specific examples such as `department.supervisor.full_name`, which can fail if `department.supervisor` is `nil`. How do you think Crystal would prevent against that kind of error on compilation?
Don’t use the safe navigation operator. You are basically saying “I know this might be nil but, meh, let someone else deal with it”. Same goes for `try` in Rails. 
If the Crystal compiler knows, with a union type, that the result possibilities are an object or nil then it will fail to compile the #full_name line because nil does not respond to it. 
It's not possible to write a mutable for loop in Elixir. A list of numbers could be printed like so: ``` Enum.each(list, &amp;IO.puts/1) ```
Thanks for the clarification. Happy new year. Prosit 2018!
I hate to be the contrarian all the time, but there's one approach to nil headaches that's the _most_ important: understanding how nil values can emerge unexpected. The _vast_ majority come from one of three buckets: 1. Dumb bugs that should be caught early via testing 2. User input (which by its nature can be all kinds of wrong) 3. Data access The answer to #1 is testing, which the article mentions. The answer to #2 is validation. The answer to #3 is to be _disciplined_ about what gets stored in a database, as well as recognizing all possible permutations of data that can be returned when querying from a database. The article mentions a few things that I think, if followed, might lead to less than desirable outcomes. The null object pattern, in particular, should never be used to reduce "NoMethodError on NilClass" exceptions, because those exceptions should still not be happening. If I'm writing a web app, and I've got a notion of `current_user` that is `nil` whenever the user isn't signed in, the Null Object pattern is a great way to improve the code quality and reduce cyclomatic complexity. But without employing that particular technique, a disciplined programmer should still be testing their web interface in both logged in and anonymous modes (except pages that require a login, obviously). Going deeper, rescuing NoMethodError is a pretty egregious antipattern. In the blog post, the example code rescues NoMethodError inside a begin block that calls `orders.last.placed_at`. There are simply too many reasons for NoMethodError to get raised that have nothing to do with `orders.last` returning nil. It'd be better to simply call `orders.last.nil?` conditionally (even that is undesirable). A better approach is to encapsulate the data access in a query object. The root cause of nil headaches is poor programming habits and techniques. Addressing them by bandaids in the form of patterns, lonely operators, rescues, etc. is just piling on additional poor programming habits as countermeasures. Instead, stop `nil` at it's _source_. 
Some languages would force you to unwrap the result there, because they know it could be nil. 
[removed]
just monkeypatch Nil with method_missing that responds everything is fine. But seriously I liked the Null Observer Pattern when I learned it from Sandi. https://www.youtube.com/watch?v=OMPfEXIlTVE
I also don't use the safe navigation operator because it's not the most greppable thing. I've wasted some time looking for a bug that was because of the `&amp;`. I love the Null Object pattern.
Thank you for this. Any other takeaways from the workshop for you personally? What other practices/outcomes are you looking forward to implementing? What are some other “aha” moments?
?a for one single character (same as “a“)
Definitely the safe navigation operator: http://mitrev.net/ruby/2015/11/13/the-operator-in-ruby/
One possible cause for constant warnings is bootsnap making some assumptions about certain directory contents never changing, which end up getting violated. I'd be curious to know if this is reproducible after removing `tmp/cache/bootsnap-*`.
Ruby's conditional assignment `||=`
Personally, I find that correctly using Ruby [keyword arguments and splats](https://www.justinweiss.com/articles/fun-with-keyword-arguments/) can really make your code elegant/expressive/flexible. It is also one of the first things that you should pick up when learning the language.
%w[value value value] for an array of strings %i[value value value] for an array of symbols
I love the [safe navigation operator](http://mitrev.net/ruby/2015/11/13/the-operator-in-ruby/). `Thing&amp;.method`
%w{mon tue wed} to make building arrays of strings faster.
My favorite ruby syntax is definitely the Block. It's what makes ruby ruby. 
Destructuring in assignment and parameter lists. 
Technically `&amp;` as _syntax_ is an operator that passes a `proc` object as a block argument, and coerces it's argument to a `proc` with `to_proc` if needed. From that, and the `Symbol#to_proc` method, comes the behavior you mention. 
My aha moment was that I didn't really understand what the intention of Object Oriented meant, I think because I've mostly seen bad OO code. And I define "bad" as procedural code that just slaps objects in there because that's what you're supposed to do. Sandi is an OO purist - she believes in the paradigm, but she looks at it from a different angle (partially because she was a Smalltalk programmer for a long time, which was created by the person who coined the term Object Oriented). The OO that she believes in is all about messages and objects - like how cells communicate in biology. Through that lens, you have to first design your objects and how they communicate with each other. This leads to the concept of collaborators, or objects that talk to each other (via messages) to get a job done. That's the backbone of the system, which has little to do with code or implementation. The practices I'm personally looking forward to implement are a much greater focus on creating small, well-tested objects. I actually have the perfect project at work that involves fixing and extending a legacy system, and I want it to be able to be understood when I'm done with it. She also preaches a very interesting refactoring style where you run the tests for the current component after you change one line of code. So you can be sure you don't ever introduce a breaking change (again that's only for a pure refactor where no behavior changes at all). Lastly, she talks a lot about well defined code smells and the way to refactor them, which are covered in great detail in Refactoring by Martin Fowler. I really want to learn how to identify specific smells so that it doesn't seem like a guessing game where I have to invent the solution each time. That way I can actually focus on solving the unsolved problems of the business.
"Have you restarted spring" is now like my go-to question whenever anyone encounters any kind of weird behavior in rails dev.
&gt; Node is fucking +10 times faster in a VM than Ruby is on bare metal ...they're both running inside VMs. You might need to go do a bit more research here before making judgments.
Able to confirm the same error occurs both before and after removing the two bootsnap caches. My steps to reproduce on Ubuntu 16.04.3 LTS: $ ruby -v ruby 2.5.0p0 (2017-12-25 revision 61468) [x86_64-linux] $ rbenv -v rbenv 1.1.1-28-gb943955 $ gem uninstall -aIx $ gem install bundler --no-rdoc --no-ri $ gem install rails -v 5.2.0.beta2 --no-rdoc --no-ri $ rails -v Rails 5.2.0.beta2 $ rails new rails52beta2 -GT $ cd rails52beta2/ $ rails -v (many warnings starting with the following...) /home/dev/.rbenv/versions/2.5.0/lib/ruby/2.5.0/set.rb:625: warning: already initialized constant Set::InspectKey /home/dev/dotfiles/rbenv/.rbenv/versions/2.5.0/lib/ruby/2.5.0/set.rb:625: warning: previous definition of InspectKey was here /home/dev/.rbenv/versions/2.5.0/lib/ruby/2.5.0/pathname.rb:20: warning: already initialized constant Pathname::TO_PATH /home/dev/dotfiles/rbenv/.rbenv/versions/2.5.0/lib/ruby/2.5.0/pathname.rb:20: warning: previous definition of TO_PATH was here ... Rails 5.2.0.beta2 $ rm -rf tmp/cache/bootsnap-* $ rails -v (same result as above) (comment out `require 'bootsnap/setup'` line in config/boot.rb) $ rails -v Rails 5.2.0.beta2 (no warnings) I'm not sure if that helps but figured it could be something funky I'm doing with my rails setup or something specific to my dev environment
So, you know how`&amp;:methname` calls `methname` on the enumerable item-by-item? `&amp;method(:methname)` does the opposite. It takes the item being enumerated, and passes it *to* the method. Its equivalent to writing: %w[1 2 3].map { |x| Integer(x) } `Integer` is just a method in the Kernel class.
I've been using Ruby for 12 years and somehow didn't know about `%i`. I have code golf scripts to update.
The spaceship operator: ``` &lt;=&gt; ```
It's amazing how many people don't know about this feature. I think it's more useful than the regular Symbol#to_proc because it's easier to write methods with a single argument than to modify an existing class. Sometimes you don't have access to the class and can't add methods to it.
The block generated for symbols has some interesting nuances. The behaviour is written in C, but is effectively like do |*args| args.shift.public_send(:symbol, *args) end which enables using it with parameterised methods: class Person # ... def compare_name(b) [self.lastname, self.firstname] &lt;=&gt; [b.lastname, b.firstname] end end people.sort(&amp;:compare_name) 
How about using &amp; with a hash. factorial_cache = Hash.new { |h, n| h[n.to_i] = (1..n).inject(:*) || 1 } 100.times.map(&amp;method(:rand)).map(&amp;factorial_cache) 
A nice example is require 'prime' my_filter = Prime.method(:prime?) #... later ... 1.upto(100).select(&amp;my_filter) 
There's a wonderful Jim Weirich presentation from 2009 in which he called it the Very Good Suggestion of Demeter, in a talk on connascence that you might appreciate. https://www.youtube.com/watch?v=NLT7Qcn_PmI 
Oh man I didn't even think about that. Yea that's awesome. Still a little more sugary in Elixir though. 
Regarding splat, I love this move when writing csvs headers = my_hash.keys # or headers = %i[my interesting headers] csv &lt;&lt; headers # ... csv &lt;&lt; row.values_at(*headers) This specific functionality was the first way I got comfortable with leveraging splat action in any meaningful way. 
Rescue `NoMethodError`‽ Please, do not do this! This leads to broken code that is hard to debug. This suggestion should be removed. Given the author's example: class User def last_ordered_at orders.last.placed_at rescue NoMethodError =&gt; e raise UserMissingOrderError, "no order found for user with id #{id}" end end &gt; The effect at runtime is that instead of a cryptic: &gt; ‘NoMethodError: undefined method ‘placed_at’ for nil:NilClass’ &gt; We’ll get: &gt; ‘UserMissingOrderError: no order found for user with id 1234’ &gt; Which, in this particular context, might save us a lot of debugging. No no no no! This can mask a real error and introduce **a ton** of unnecessary debugging. An assumption is made that *only* `nil.placed_at` will trigger the error, but in reality, one can introduce changes to `#orders` or even `#placed_at` that can result in a `NoMethodError`. And, since we're rescuing it, no one will ever know (more or less) the code is buggy. 
As a little aside, I like this trick too, but I usually prefer using square brackets so it feels more array like %w[ one two three ] To whoever finds this as news: you can use any of the matching pair characters to delimit this trick. (, [, {, &lt;, etc. So feel free to pick'em!
Can you elaborate on what this is on about? I understand the general usage of `&amp;method` but I don't follow your reasoning, or what is implied by the `yield_self` comment. I'm not saying I question the validity of your comment; I just don't yet understand `yield_self` usage, as it seems it just returns what my code would have done if it weren't in a block... Which is what a block does anyway. Maybe it has to do with the ability to pass blocks around, but I haven't yet grokked this one. Either way, what are you describing with the issue about modifying a class when using sym.to_proc? And what is this excitement for yield_self?
Weird. So, after reading a bit, am I understanding this correctly? Given my example at https://www.reddit.com/r/ruby/comments/7npcne/comment/ds40eld csv &lt;&lt; row.values_at(*headers) is equivalent to csv &lt;&lt; headers.map(&amp;row) # ? I had no idea that hash could proc. And then after I just read about it, I had a hard time understanding why I might use that syntax instead of just calling the key. But then I realized it's very similar to what we might use `&amp;:method` syntax in other situations. (Avoid the `{|a| stuff[a]}` type stuff...)
Thank you. 
You mean the _proc_ generated for symbols, with the `Symbol#to_proc` method of course! A`Proc` is a type of object (that is, a class). A 'block' is a syntactic feature for passing a proc object as an argument to a method. 
&gt;you can use any of the matching pair characters to delimit this trick Not just them. `%w]one two three]` works. And `%w?one two three?`. Even some of the ASCII control characters such as NUL and DEL do too.
Blocks aren't objects and don't require allocations to invoke. They live on the stack. You can capture a block (or rather the block to invoke and its surrounding environment) as a Proc, which lives on the heap and are garbage collected. Avoiding that allocation will improve performance, however.
Not in this case. If you read the MRI source code, you'll see that when a symbol is passed as a block via the &amp; operator, it's passed on the stack as a `block_handler_type_symbol` not a `block_handler_type_proc`. 
*splat https://endofline.wordpress.com/2011/01/21/the-strange-ruby-splat/
In this case I'd use your splat-version because I think expresses intention more clearly. The use of `&amp;hash` is great for self-populating caches and for passing a lookup table as a block. 
I've never seen the Null Object pattern implemented in any code base I work in. I'd like to start using it but I'm wondering where would you put that file in your project? In Rails everything tends to get dumped in lib so I try to avoid that. What about nesting it? class User class NullOrder def placed_at 'No order history' end end def most_recent_order orders.last || NullOrder.new end def last_ordered_at most_recent_order.placed_at end end 
Sick
The ones already posted are best, but honorable mentions for me: * `super` without arguments to implicitly pass up the arguments of the call site method (vs `super()`) * `if`/`unless` one-liners 
perhaps you haven't seen: https://bugs.ruby-lang.org/issues 
Re. the database. I've long felt that NOT NULL should be everyone's default. They can still sneak in on outer joins though. 
I wouldn't put inside the User class but if it's small would consider placing it in the same source file as the Order class, either as a separate NullOrder class or as nested Order::Null. 
I'll tell you what. (More as a theoretical and generic answer, not targeting just current Ruby update.) In my Ruby mentoring, I typically suggest PickAxe, and at some point even used to say first edition is OK (which covered an ancient Ruby 1.6, IIRC, but it is freely available from Ruby website), then started to insist on "the most recent" edition -- which is 4, covering Ruby 1.9/2.0. Of course, they are ancient too, now, but "maybe not that different, concepts haven't changed a lot"? Bollocks. Ruby evolves, and if it is not Python 2→Python 3 changes, the evolution is still steady. Not only "new features you can learn later" emerge, but our entire understanding of what is good Ruby code evolves, too. Core methods like `tap`, `yield_self`, methods-returning-Symbols, frozen Strings, Enumerable updates, are changing the basics of code structuring. Gems infrastructure becomes crucial for any interesting work. Community preferred style(s) got updated. Focus on functional features becomes valuable. So, what books targeting outdated Ruby versions are missing is not this or that feature, but mostly the spirit of a modern Ruby. TBH, currently, I firmly believe that what is (mis)represented [here](http://ruby-doc.org/core-2.5.0/) through a silent list of uncommunicative filenames, should be facelifted to be used as The Ruby Book, it has enough information and reasonably well-structured, and always updated alongside Ruby releases. ¯\\\_(ツ)_/¯
It gets better actually. There's a whole bunch of these % operators that match with brackets for various reasons. One that i've found handy in the past was %s() for a string where you might want to use double quotes without any bother. %s("*#{some_variable}* is what I'm about to do." Charles said.) Ruby Weekly had a great article with all of these around the start of last year if I remember correctly.
After starting coding in C, Ruby's case statements are a dream. (None the least because they work on more than just integers) loop do input = gets.chomp case input when 'exit' exit when 'help; puts 'some help string' when 'mem', 'memory', 'ls' puts 'whatever was saved' when /^some_magic_(regex) = (this)$/ mem[$1] = $2 else puts 'unrecognized command' end You have a basic ruby shell right there.
&gt; note there are pitfalls with this technique; most notably, it fails if nil or false is a valid result I [answered a question on StackOverflow](https://stackoverflow.com/a/47948666/1954610) caused by this exact problem, just the other day!
A (hash) map is a function from `Key` to `Value`, so it's natural to replace a method/proc with it. For example in Clojure calling a function and accessing a value of a map has the same syntax: https://clojuredocs.org/clojure.core/get#example-542692d3c026201cdc326fbf
You can also use %i(one two three) for an array of symbols
I choose `Maybe` when there's no good null object (most of the time). For example it doesn't make sense to have a `NoArticle` object returned from `Article.find(1)`: There's no reasonable value for `title`, `user`, etc. unless you make them `nil` which is, of course, just deferring the issue of nullability. &gt; Or are there other benefits? Using `Maybe` instead of custom null objects allows you to write more general code because the interface for `Maybe User` and `Maybe Article` is exactly the same.
For me some of the best have already been mentioned, %i/%w for defining arrays of words, if/unless, Symbol#to_proc with the &amp; operator. I'll add to that: The simple ones that everybody forgets are actually really nice syntactic sugar: attr_reader/attr_writer %r for defining regular expressions, so that you don't have to escape /.*\/.*/ # vs %r{.*/.*} I also like that you can create ranges with many different types, i.e. DateTime.now..Date.new(2018, 2, 14) 1..9 'a'..'z' Also the exclusive rage (excludes the last value): (1...10).to_a # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9] kwargs, and specifically the fact that you can exclude the hash brackets from argument lists: def test(one:, two:) [one, two] end test(two: 2, one: 1) # =&gt; [1, 2] Parentheses around block arguments when yielding an array: [[1, 2], [3, 4]].map { |(a, b)| a + b } # =&gt; [3, 7] Which is expecially nice with each_with_object and hashes: { one: 1, two: 2 }.each_with_object({}) do |(k, v), hash| hash[v] = k end # =&gt; {1=&gt;:one, 2=&gt;:two} Struct inheritance/struct constant assignment: # class User &lt; Struct.new(:first_name, :last_name); end User = Struct.new(:first_name, :last_name) do def full_name [first_name, last_name].join(' ') end end User.new('John', 'Smith').full_name # =&gt; "John Smith" Proc#curry: adder = -&gt;(a, b) { a + b } # and the stabby-lambda is awesome too add_one = adder.curry.call(1) add_one.call(2) # =&gt; 3 The inheriting from module trick that you can see in use in https://github.com/dkubb/equalizer and other variants such as defining a capitalized method name (i.e. https://github.com/dry-rb/dry-equalizer/blob/master/lib/dry/equalizer.rb#L5-L7) or defining a self.[] method (i.e. https://github.com/rom-rb/rom-repository/blob/master/lib/rom/repository/class_interface.rb#L19-L24) I'm sure I've forgotten a few.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [rom-rb/rom-repository/.../**class_interface.rb#L19-L24** (master → d5bce87)](https://github.com/rom-rb/rom-repository/blob/d5bce87cde9801da937dad1d9f9e1a8b49c1b33a/lib/rom/repository/class_interface.rb#L19-L24) * [dry-rb/dry-equalizer/.../**equalizer.rb#L5-L7** (master → f46d7ed)](https://github.com/dry-rb/dry-equalizer/blob/f46d7ed0f693296ab4ab578081d586b8ee48aa97/lib/dry/equalizer.rb#L5-L7) ---- 
&gt; [1,2,3,4,5,6,7] - [6,7] =&gt; [1, 2, 3, 4, 5] is pretty cool
Trailing conditionals is probably one of my favorites.. &gt; thing.do_this if other_thing.thing_needs_done
Awesome. I think I found a comprehensive list: https://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Literals#The_.25_Notation
&gt; Parentheses around block arguments when yielding an array: &gt; &gt; [[1, 2], [3, 4]].map { |(a, b)| a + b } # =&gt; [3, 7] The parentheses in this example are superfluous
I appreciate the answer.
I had to look up where this was documented! https://ruby-doc.org/core-2.4.2/doc/syntax/calling_methods_rdoc.html#label-Proc+to+Block+Conversion
We've had great success in building small, independently deployable services using [Roda](http://roda.jeremyevans.net/), which I enthusiastically evangelise at every opportunity. Once [dry-web-roda](https://github.com/dry-rb/dry-web-roda/releases) stabilises a bit more, it'll be a great system to wrap Roda with, using [ROM](http://rom-rb.org/) and the excellent [dry-rb](http://dry-rb.org/) Gems in a coherent, useful whole.
.tap to avoid temporary variables 
Hmm, we had some Rails core devs and a contributor try it on out side and we don't seem to be getting that error. It's possible a bootsnap cache from a previous run is conflicting since IPAddr was moved from stdlib to default gem in 2.5. Can you try removing the cache?
I definitely agree but don't forget your end statements ^.^
Haha well spotted. I'll fix that quick. :)
It happens mostly automatic, it is required for deeper nested structures: [[1, [2, 3]], [3, [4, 5]]].map { |a, (b, c)| a + b + c } # =&gt; [6, 12] On the other hand: if your code looks like this you might want to reconsider the used data structures.
So, very quick crash-course in an elixir feature called pipelines. Pipelines allow you to take an object and preform a myriad of operations. The operations chain one after the other, each one taking the output of the previous as its input. With them, you can, in an easily understandable manner, preform a myriad of manipulations to a bit of data, without the need for variables. They look like this ["foo", "bar", "baz"] |&gt; Enum.map(String.upcase) |&gt; ApiClient.post("api/url") |&gt; DoSomethingWithApiResponse.wew() This isn't ruby, its functional, hence it appears a little redundant, but the principle is the same. You could write the equivalent in ruby using: ["foo", "bar", "baz"] .yield_self { |x| x.map(&amp;:upcase) } .yield_self { |x| ApiClient.post(x, "api/url") } .yield_self { |x| DoSomethingWithApiResponse.wew() } While thats a little more verbose, the idea is the same, and you could probably refactor it to be a bit cleaner. Previously, you could use chaining, but that could get super ugly fast. 
[removed]
But I mean if there's n methods in your program, and m features that can be enabled or not, that's n2^m methods you need to compile. For just say n=100 methods, and say m=8 features, that's already a quarter of a million different methods you need to compile. It doesn't scale. And you can't just compile them all on or all off, because you'll end up using all on half the time and it'll be colossally slow.
Yeah, I fully agree. I was just testing whether I was understanding the idea. Your hash cache took a moment for me to sort out, but felt very clever once I did. I haven't had any use cases quite like that (beyond defaulting to 0 for example). Very interesting. Some day in the future, I'll have one of those "Oh yeah! That thing! Where was that?!" moments.
nah. 
Thanks. Many of the examples look similar to this -- but is there a practical difference between replacing `yield_self` with `map`? I've been making "pipelines" of that nature using `map` in a lot of ETL type jobs. I mentioned this in another comment: the `|&gt;` is really cool. I love how the subject argument is implied. Clever and clean. I hope something like this appears in Ruby. I wouldn't mind a full-on copycat!
for `m features` sure, I was talking more about one version with instrumenting and one without :) but yeah, I agree with you, it's probably not feasable. 
There is literally no other definition for what Ruby is other than the MRI. 
That's a great question. I've seen it used/implemented in a few different ways. * A (very light) factory. You have something like a `SafeUser` class that implements whichever find_by methods are needed. * In the model itself. I'm on the fence about this one since the user might be expecting nil to be returned. 
A code base I'm working on (legacy) has an incredibly long service class called eg. TheCustomersConfigurationService with a class method key. I've been replacing this in new (encapsulation) classes with: Key = -&gt; (v) { TheCustomersConfigurationService.key(v) } and calling with: Key.("lookupvalue") I'm currently pushing to get the class renamed to ```Key```, and ```key``` renamed to ```call```. Its just 3 pieces of the language (upper case first letter constants, arrow procs, dot proc calls) which just all feel so nice together. 
I've had this argument before, and I know you're not alone, but I disagree. I think that is an optimization implementation detail -- without looking at the source code, just actually looking at ruby as it behaves, there is no way to distinguish between your explanation and mine, and IMO no use to thinking of a 'block' as thing other than a syntactic construct, and a lot of explanatory power in thinking of it as simply a syntax for passing a proc as an argument. MRI could easily change it's internal implementation such that there isn't different VM code and different memory optimization, and it would not change the results of any ruby program (likely it's performance; it's an internal performance optimization). There is no way to store a 'block' in a variable, and no way to call methods on it. As soon as you _do_ anything with it, it's a proc. You can say it's some kind of schroedinger's cat thing where it was not a proc until you looked at it, but I don't see the utility. 
Ah there it is. It becomes obvious when we break out of the array, using the full array itself as the argument, instead of it's components. Thanks for taking this time. Reading the interpretation of the plain Ruby version helped me see what I was missing. 
for arrays and hashes, yes we have a built in enumeration method `map` which does the trick in most cases. However say you want to send a string through a series of made-up methods: ``` # note the parens are unnecessary here evaluate(interpolate(sanitize(string))) ``` you are basically working backwards, with the last function in the chain being written first. Using `yield_self` you can reverse this, although granted it's not what I'd consider prettier: ``` string .yield_self(&amp;method(:sanitize)) .yield_self(&amp;method(:interpolate)) .yield_self(&amp;method(:evaluate)) ``` If I actually saw something like this I would think it's a little overengineered, so I consider it more of a academic trick than a game-changing one in practice. Another interesting detail - the definition of `yield_self` is literally just `yield self`. 
What does this do?
It makes large numbers easier to read when defining them :) It's stil an int of 1000000 
Is it really? That's pretty damned exciting!
Some documentation here https://github.com/graalvm/truffleruby/blob/master/doc/user/svm.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [graalvm/truffleruby/.../**svm.md** (master → 4efdf37)](https://github.com/graalvm/truffleruby/blob/4efdf37e50bb89798b219bbf93107eda457d0128/doc/user/svm.md) ---- 
The relatively universal rule of optimizing Ruby code is to reduce a number of method calls. So if you say it's "per-method" then we'll still have this method-calling overhead?
Ruby != Crystal
It might be helpful if you posted an excerpt from a section that you find confusing.
Because the parenthetical statement is evaluating first: 2.4.1 :006 &gt; (hash[:names] ||= []) += ["name1","name2"] SyntaxError: (irb):6: syntax error, unexpected tOP_ASGN, expecting end-of-input (hash[:names] ||= []) += ["name1","name2"] is equivalent to this: 2.4.1 :007 &gt; [] += ["name1", "name2"] SyntaxError: (irb):7: syntax error, unexpected tOP_ASGN, expecting end-of-input [] += ["name1", "name2"] 
You're looking for join, documentation [here](https://ruby-doc.org/core-1.9.3/Array.html#method-i-join) Basically, you say string = array.join, and join takes a string that you want it to put between every item. so array.join(', ') would return 'hi, hi, hi'. But array.join would just return 'hihihi'. Hope this helped.
 array = ["hi","hi","hi"] array.join #=&gt; "hihihi" 
came out a while ago, and still no advisory in https://rubysec.com/ alas. I am losing faith in rubysec.com. It is a good idea. Apparently not enough people working on it. 
What's the purpose of: (hash[:names] ||= []) Is this to give :names, if it doesn't yet exist as a key, a default value of [] before you append to it? If so, perhaps you want to give your hash a default value: 2.3.1 :017 &gt;hash = Hash.new{|h,k| h[k] = [] } =&gt; {} 2.3.1 :018 &gt; hash[:names] += ["name1", "name2"] =&gt; ["name1", "name2"] 2.3.1 :019 &gt; hash =&gt; {:names=&gt;["name1", "name2"]} 
I expected your example to work too. Do you happen to know why is that?
It's trying to make an assignment to a value rather than a variable. x += 1 is basically the same as this: x = x + 1 So what you have is this: [] += ["name1", "name2"] which means this: [] = [] + ["name1", "name2"] What result would expect from that? You can't assign anything to `[]`, it's not a variable.
Ohhh right, I get it now! Thank you!
This is great news /u/chrisgseaton! Can you throw some benchmark figures at us for Crystal vs Truffle with SVM? Would love to stick with pure Ruby where possible, but Crystal has really been compelling a lot of movement lately.
Glad to help!
Thanks.
Thank you.
Nice, thanks, learn't something new!
Why does nobody add/approve the vulnerability? Can't rubysec outsource the vulnerability submission to github? Like make an issue with Tag #report, community approves, bot pulls data from issue (from a template for example), merges it with live. That way we can also leverage notifications from github and other goodies. Smh
Hey to do this, but collect is actually not really used. `map` is an identical method that is more idiomatic, `collect` is a leftover from smalltalk that the community has mostly stopped using.
Yes, `rvm` and such usage is key right now to get more hands on usage and testing. You just can't get people to jump through the hoops generally at this point to get TruffleRuby up and running en masse. Would love to see an update to your post [here](http://nirvdrum.com/2017/02/15/truffleruby-on-the-substrate-vm.html). The benchmarks are pretty important, especially given the enormous Crystal interest and uptake that's happened over the past 6 months. 
They're both the same method, two names for the exact same method. Somehow when I started writing ruby, I choose the "collect" name cause nobody told me everyone else was using "map", and "collect" made more sense to me for what it does. And the habit has stuck, sorry! For some reason Matz liked giving lots of methods more than one synonym name. 
So this is like using `var s = myObject?.Count;` on C# where `s` doesn't get a value if `myObject` is null?
Is there any benchmark in particular you'd like to see?
Aside from just seeing your original results rerun, I think an update here would be interesting: https://github.com/kostya/benchmarks
Wouldn't it make sense to pass a hash out of the function? def my_func hash = {} hash[:a] = "thing" hash[:b] = "other thing" hash end (there are even ways to improve this, using `tap` or other approaches, this is just a crude example)
You also could do: array.inject('') { |result, elem| result + elem.hi } See https://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-inject This adds the result of the hi-method of each element of the array to result, which is initialized with '' (empty string).
Thanks. I plan on revisiting my original blog post with updated progress made over the past year. I'll look at these benchmarks as well. Personally, I haven't spent a lot of time with Crystal. But I'll take a look and reach out to someone if I need help. I don't want to miss any optimization flags or what have you.
No - that is C#'s null-condition member-access operator. Ruby equivalent of that is the safe-navigation operator &amp;. as in `s = my_object&amp;.count`. They're very similar in utility but not identical. For example I believe the C# operator short-circuits the expression, whilst Ruby's does not, because in Ruby nil is an object; `my_object&amp;.count&amp;.to_s` will return an empty string if my_object is nil. There's no direct translation of conditional assignment because this is idiomatic Ruby borrowed directly from Perl. In C#, contextually, an `s ||= myObject.Count` *might* be if (s == null) s = myObject.Count; but conditional assignment is also an expression, so it provides a return value, and acts for both `false` and `nil`.
Well first of all you can't call `foo[:a]` because `return a,b…` returns an array of objects, not a hash. For some small functions this is probably acceptable, but for larger ones it adds comprehensional complexity, in that any programmer attempting to use the function needs to understand the order of its returns. As /u/isaacpriestley said, I'd use a hash and just return it.
Given that SVM produces statically linked binaries, do you know why TruffleRuby doesn't distribute binaries for common systems (like go projects do)? I know C extensions are still a pain point, but I'd still like to play with it and every time I've tried to use TruffleRuby in the last couple of years it's been kind of a confusing nightmare.
I like that its written in typescript, Rails should go ahead and ditch coffee for it 😎
You can call foo[:a] because it is being assigned in the single line I provided, however you're right in that you would need to understand the order of arrays being returned. I understand the points being made and I've thought of several ways to refactor including this one, however, I wanted other people to refactor and see what they came up with.
Would it help to represent the data you’re returning as an object? It could just be a Struct for now. Since it seems pretty complex, it could be helpful to think about modeling it this way. It also gives you a natural place to put behavior that is common to that data, rather than spreading that around. 
i get what you are asking. maybe instantiating in the array literal doesnt work? instead of: &gt; [Test.new, Test.new, Test.new] try array = [] 4.times.do |i| array &lt;&lt; Test.new end and then.. array.each do |a| a.hi end 
It's virtually impossible to give you good feedback because it's not clear what the **intention** of the code is. Without any clues as to the intention of the code, from a refactoring standpoint, it might as well be minified. Clean code is about isolation of concerns and organizational/intentional clarity. My first instinct is that these methods both overlap in their responsibilities and are trying to do too many things.
 Don't you lose the svg structure if you use an img tag? 
Do not use CSS background attributes for images that are not actually backgrounds. For a presentational icon it is more appropriate to use the SVG data URI in a CSS content attribute of a :before or :after pseudo-element.
Yes. But you need an additional HTTP request to load it or validate the etag. The elegance here, as far as I understand it, is that the image comes with the CSS which is requested anyway (so no additional HTTP request), is sent only once (instead of for every usage location) and - since browsers cache CSS more aggressively according to my experience - the overall number of requests for this application likely goes down even further.
I understand now, the begin-end block from the previous example confused me a little bit. Thank you for the explanation.
If you are collecting but the end result is a single string, you might as well just reduce. string = array.reduce('') { |acc, obj| acc + obj.hi }
&gt; Wouldn't an svg at some URL as the target of an &lt;img src also be globally cached by browsers and the CDN? It will. See here: https://twitter.com/yaroslav/status/949020933020319746 With every major developer-friendly supporting HTTP/2, there is no longer a point in doing massive inlines for everything just so save requests. Most browsers you target for support H/2, most CDNs do, Heroku, as previously pointed, does not, but it does not matter. You don't have to optimize for the number of requests anymore. In fact, just getting raw images over HTTP/2 may be faster than de-base64ing them from a massive CSS—you have to benchmark. Also, as pointed out in another thread, you absolutely don't have to use non-backgrounds as backgrounds. HTTP/2, img src and some gzip is what you should be going for when targeting progressive users—which is what you do when you target developers.
It's because the Principle of Least Surprise is a design goal of Ruby. Sometimes your brain can remember one synonym and not another, so the language should help you get you think when you remember one or the other. Some people hate that philosophy, but I love of course.
Thanks for the explanation, added to my notes :)
Excellent, this seems like the most ruby-esque way. Thank you.
Same as the data uri in css, yes. 
I don’t totally understand your comment. Why should I not use a background image? Semantics or is there a technical reason? Doing the ::before method what does the css look like? 
The only optimization flag you need for crystal is `--release`. 
Hello, I've started a new Awesome News page @ Planet Ruby that collects ruby news incl. 3x3, 2.6, etc., conferences &amp; camps, libraries, stats &amp; benchmarks incl optcarrot and more. How do you get your ruby news? How do you find libraries / gems? Anything missing. Updates welcome. Cheers. Prosit 2018!
so sad
?
&lt;use&gt;? Lets you have them in your DOM for CSS color/animations, but also not duplicate content. You can polyfill for IE.
We distribute TruffleRuby as a native binary for both Linux and Mac as part of the GraalVM distribution. And we have instructions on how to build a native binary using the open source distribution using: https://github.com/graalvm/truffleruby/blob/master/doc/contributor/workflow.md We're constantly looking for ways to improve initial setup for end users. We're aware that it's still less than ideal. The recent open sourcing of the Substrate VM does open up some new opportunities there, for sure.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [graalvm/truffleruby/.../**workflow.md** (master → b7dd459)](https://github.com/graalvm/truffleruby/blob/b7dd459bc54796dcfdfba13708a204e9daf07bf3/doc/contributor/workflow.md) ---- 
Low effort shit post. This punchline is overused and not really funny. 
I don't understand the question. It's written as though it's a request for a community contribution, but it's clearly an organisation website. Is this a job ad? &gt; but I'm sure since you are reading it Probably worth noting that because the site doesn't seem to be in English, a lot of users are *not* reading it.
OK! I actually wrote a library (script? package? I have no idea) that does **EXACTLY AND ONLY** THIS. My goodness...something I did might actually be useful to someone :D It's called [Jocket](https://bitbucket.org/DaveahamLincoln/cjocket) (the 'c' in the repo name just indicates it's a consumer version of something I'm currently developing). It's hard to explain what it does exactly, but I've provided a really thorough readme that starts off like this: &gt;Jocket is a flexible and easily extensible core for deploying and marshaling servlets written in Ruby. No Rails required. Currently, the system requires an [Ultrahook](http://www.ultrahook.com) API key (free) because I'm developing from behind a NAT and it's just easier for me that way. You should be able to extract that bit fairly easily if it doesn't suit your needs by tinkering with modules/endpoint.rb and jocket-launcher.rb. If nothing else, I hope that this provides you with a good starting point. I twisted my brain in circles for a while trying to figure this issue out, and in the end I came up with Jocket.
How much you payin'?
That document is titled "The TruffleRuby Contributor Workflow." Does it describe how to link a ruby program _with_ the TruffleRuby executable created by SVM? I'm still new enough to this that I don't feel fully comfortable with my understanding of the document.
Ahh, I think there's some confusion here. What we do with the Substrate VM (SVM) is ahead of time compile the TruffleRuby interpreter, not an application. This is akin to what you'd do with MRI. Instead of treating Java as a language you compile to a .class file and load with the JVM, the SVM's native image generator compiles it to a native binary. There's likely no reason we couldn't compile Ruby applications into a static binary. TruffleRuby itself is implemented mostly (53%) in Ruby. But it's not something we've really explored and thus not something that's made easy. I would caution that building the native image is a bit slow -- that static analysis phase doesn't come cheap. It's not too bad, maybe on the order of a couple minutes. But most people wouldn't want to pay that cost every time they modify their Ruby app.
This is a great presentation about the same topic [https://www.youtube.com/watch?v=X2sgQ38UDVY&amp;t=1773s](Ruby Object Model)
Most of the time this is a code smell. But don't be dogmatic about it. If in your mental model my_func returns an array of things - returns something that can be indexed, iterated etc., then the best code is the code that returns an array of things no matter what rubocop says. However if you don't want an Array of things just a bunch of unrelated things, then my_func should probably be split up each part only dealing with related things. If a,b,c,..f are components of a single thing, then that single thing should be an object. Different ways to deal with this, and in the first case returning an array is completely fine.
Yes. They all have varying utility in the long run. However, some are basically evergreen. Evergreen: * Refactoring * Design Patterns in Ruby * Practical Object Oriented Programming in Ruby * Ruby under a Microscope Likely Evergreen: * Metaprogramming Ruby 2 (Possibly new ways added, but the ways shown in this book will remain relevant) * The Well-Grounded Rubyist (Third Edition is being written right now, but older editions should still be relevant) Not Sure: * All the JS stuff. JS changes really fast, but JavaScript the Good Parts should still be relevant for learning vanilla JS. * HTML &amp; CSS - Newer CSS grid and flex variants are probably not in this book. The other stuff should be good though. * Programming Ruby 1.9 &amp; 2.0 - This is the pickaxe book. It still is relevant, but there are definitely newer ways of doing certain things that might not be covered by this book. * Jumpstart Sinatra - Sinatra just went to 2.0 I believe. I'm not sure how much has changed. I only use Sinatra sporadically for small APIs so I don't know. * If it says Angular and is an older book, it's out of date. * Rails 4 books are out of date when it comes to frontend. Rails 5 embraces JS frameworks. However, the backend stuff should still be useful.
The POODR book by Sandi Metz (3rd from the bottom) is a keeper for sure.
Eh, most of them should be fine. The exact syntax may change but the concepts won't.
I recommend Well Grounded Rubyist to everyone learning Ruby. It’ll really take you through how the language works, which is arguably even more important than just knowing the syntax and some OOP concepts. 
Eloquent Ruby is one of my favorite reads of all time.
I would _love_ to be able to package binaries. And I remember spending 12+ hours to compile OpenOffice, so a few minutes doesn't bother me :-) This is something I'd love to contribute time towards researching and implementing, if it's something y'all would feel comfortable supporting long term.
The refactoring book is the single most important book you could read as a programmer.
I’m currently reading Eloquent Ruby, loving it so far. Good to know I’m on the right path. POODR should be the next one.
What about Eloquent Ruby? 
It should still be relevant. Framework books become out of date faster than language books as the framework evolves. There’s new stuff in Ruby since Eloquent Ruby, but mostly convenience methods. 
Does anyone have an educated guess at what this means for Rails? What kind of performance boost in rails is the team expecting? and what would be a disappointment if not reached? 
There's a version of the Refactoring book that uses Ruby instead of Java that you might find more useful.
Screencasts: https://www.rubytapas.com/ , http://railscasts.com/
What does Evergreen mean? I’m pretty new to Ruby so I’ve never heard the term. Are any of these books better then others for a noob?
Sorry, not a computer term at all. Also, I shouldn't have capitalized it. It just means something that has long lasting relevance. It is derived from evergreen trees that stay green all year long.
Ahh, I gotcha. Thanks!
I'm assuming the Node.js, MongoDB and AngularJS book is covering Angular 1. In that case, it's out of date already. Angular 2 is a totally new framework compared to Angular 1, and both Angular and MongoDB have fallen quite out of favour. 
If you buy the ebooks from PragProg, many of them receive updates.
 MyCollection = Struct.new(:a, :b, :c, :d) def my_func MyCollection.new.tap do |result| result.a = "thing" result.b = "other thing" end end 
I really like eloquent ruby, especially for the mid level developer who knows the Ruby basics already
May I ask why you're doing this? Is this for monetary gain or do you hope to pass on knowledge to someone less experienced for the sake of it? 
&gt; two years professional experience Mmmm...do you have a Github? How do we know you have enough experience to have learned all of the best practices of the framework? It's a generous offering, but as someone who has been a mentor before (and is mentoring), I'd be curious to see how effective your methods are given your own limited experience.
Good question - I'm glad you asked. It was a gorgeous Sydney summer's day and I'd planned to have breakfast with my girlfriend in the park. We'd picked up some coffee and sandwiches on the way and brought along a picnic mat. It was just about everything I liked, almost perfect, but something was bugging me. There were a couple of teenage boys trying to play basketball not far from us. I say 'trying to' because someone had dunked the ring hard enough to bend it down basically vertical, parallel to the backboard. Because of this, the kids were just throwing the ball at the little square on the backboard and vigorously arguing about whether or not the ball "would have gone in". I can't tell you how frustrating I found this, it wouldn't even be hard to fix, it just needed someone to come along with a ladder and push it back up. Honestly, I wanted to go home and get the ladder, but if I'm honest, my reasons were selfish. I just wanted to be the hero, but living a 15 minute walk away, it would have been a 30 minute round trip. Our coffees would have gotten cold, my girlfriend would have been ticked off, and there was every chance the boys wouldn't even be there when I got back. It was inconvenient. What I really wanted to do in that moment was take a photo of the problem, geotag it, mark is as requiring a ladder and stick it onto some kind of online database. Had I of known there was an issue I could fix just by bringing a step ladder before I left the house, I would have. But such a database doesn't exist. But it should. There's huge potential to make the world a better place. That was around three years ago. Shortly after that I decided to quit my job and focus on learning software development. After completing a bunch of text-books and online courses, I stumbled across this post on this very subreddit: https://www.reddit.com/r/ruby/comments/387kaw/anyone_need_a_mentor/ Well I jumped at the opportunity, and amadman114 eventually became my boss and friend at my first full time Ruby job. Life happens and both of us moved on to newer and bigger projects. Well, it's been three years since I decided I wanted to build WellWish, and I'm now empowered to do it. I'd also like to pay-it-forward so to speak by helping to mentor new developers on their own paths. WellWish is not-for-profit, with the goal of becoming a registered charity in the future. I pay all expenses out of my own pocket. All of our code is open source, and our project tracker are public.
Glad to see someone giving back. And good luck with your idea, I recommend you to try validate it before you jump into coding it. I've seen many ideas like this come and go :).
You can sign people up with a landing page before you have anything up and running. Need to figure out who is actually going to take the time to list things and then who is going to take the time to take action. &gt; Had I of known there was an issue I could fix just by bringing a step ladder before I left the house, I would have. The key assumption here is, why would you have checked the website in the first place? I highly doubt you would have thought of it. 
Absolutely I wouldn't have. When users create an account, they are able to select skills, tools and a location. With their permission, they would receive notifications when tasks fitting their profile are created.
Hey I am a Ruby beginner. I know a bit about sinatra, but not much about Rails. I have been learning programming as a hobby for around an year now and am trying to be employable as a professional developer within April of new year. I would love to help you out with your project anyway I can. 
Glad to hear this! Google a startup called Aardvark. You should try a concierge/low tech trial approach to validating this.
Google a startup called Aardvark. I'd recommend a concierge/low tech trial approach to this. My bet is something like thjs doesn't exist because the pain is too low and infrequent, combined with the difficulty of building a critical mass being extremely hard. You would need to start this on an extremely local level and have some major connections to an organization that can just give you all the users you need. ie. Tenants association or local government
I think you’re probably right about limiting the scope even further. I have no doubt of the value proposition, but you’re not wrong about the massive critical mass needed. Nonetheless, I think it can be achieved. There are incentives on both sides of the coin, for ‘highlighters’, they’re able to list things they truely care about, while ‘volunteers’ will get a wall similar to LinkedIn, but instead of work history its public contributions. This would be of particular value to companies looking to improve their PR. That said i’d expect that anon’s wall has the most contributions. 
I may in fact be you. Thanks for getting in touch. I’ve been so overwhelmed I haven’t had a chance to get back to everyone yet. I think I’ll create a slack channel seperate from WellWish where I’ll try to help anyone I can. 
I'm not in a position to take you up on this yet, but love what you're doing. Will save and follow up with you in the future to see if you're able to take anyone on at that time. Cheers and good luck with WellWish
&gt; What I really wanted to do in that moment was take a photo of the problem, geotag it, mark is as requiring a ladder and stick it onto some kind of online database. Had I of known there was an issue I could fix just by bringing a step ladder before I left the house, I would have. I am sorry, but this sounds a bit too much like another technical solution for a social problem. Plus, I am not sure this is really a solution: someone puts up the tag and feels good because he/she "did something about this". Did they? There still needs to be someone coming along with the ladder and doing the fixing. And whether everybody looks into that database before leaving for some place is an open question as well. &gt; But such a database doesn't exist. But it should. Why should it? You could have come back another day with the ladder and fix it. That would have been far less hassle than programming and deploying an online system, wouldn't it?
The idea is when a new user registers, they give details about their skills and tools. Then, with their permission, when a task that matches their profile is listed, they are notified. You’re absolutely right, it is a technical solution to a social problem, but I’m not sure what’s wrong with that. 
I love the idea of what you're doing and would love to get mentored by you. I'm trying to learn ruby as well. Although, I dont believe I have 8 hours a week in one day to spare. I could definitely use a local friend to get together with occasionally though.
Huh. I really don't understand what's going on here, does anyone, who can explain it? If `Rails.application.routes.url_helpers` is meant to be a module that gets `include`d -- why can you call methods directly on it at all? Like, literally, technically what makes this possible? And why would it be slower? And do the comments by sgrif in issues on Rails suggest that `helpers = Rails.application.routes.url_helpers; helpers.some_method` somehow has different performance characteristics than `Rails.application.routes.url_helpers.some_method`? How is that even possible? Ah, cause the module/object gets regenerated every time you call `Rails.application.routes.url_helpers` maybe? But didn't used to in older versions of Rails? This stuff has been a pain point in Rails for a while, alas. 
It's an open source project, so feel free to pitch in :-) We're active in our [gitter channel](https://gitter.im/graalvm/truffleruby). I'd just caution that there's some annoying issues without a clear solution. E.g., we use POSIX calls for opening and reading files. If your app needs to open a file and all of that is embedded into the binary, there's no natural way to open it since it's not sitting on disk. It's not entirely different from what the JRuby team has had to do to support apps loading from a JAR, so we can probably pull some lessons learned from them.
Generating urls from non-request-contexts seems to be one of the most underserved popular use cases in Rails. Seems like everyone is doing it the "wrong" way, but it's unclear what the "right" way is, or if it exists for sure. Some of the comments on those issues seem to suggest problems with the simple `include Rails.application.routes.url_helpers` method too. I guess this isn't a Basecamp use case, somehow?
just what I've been looking for! Thanks!
With self. It’s not an instance method. 
57% faster download is pretty good for maybe 5 minutes of work.
Thanks, do you mind elaborating a bit more? I'm still fairly new to programming. Is it because in rspec they call Board.default_grid instead of creating a new class object? (like calling board = Board.new first)
Sure--it's because the scope for those two methods is different. One is an instance method, which means @default_grid is available within that instance, and only that specific instance of your class. The other is a class method, in which @default_grid is available only in the context of that class. Here's a gist with some code that might help clarify: https://gist.github.com/progressions/1099757f732dac5191e6d8792aa55960
Thanks, that helped
This didn't use to be the case. `Rails.application.routes.url_helpers` was previously a singleton. But this caused weird issues like `url_for` not actually having the same semantics when called via the singleton vs when included.
I don't mean to hijack your thread but I would also like to mentor someone. I have about 3 years professional experience and 6 months of teaching at a bootcamp. I really miss the teaching aspect and would love to give back. I would not be able to spend 8 hours a week but I could check in a few times a week and then do some pair programming on the weekend. If anyone is interested feel free to reach out. I would specifically like someone who has a decent understanding of the basics and a possible project they would like to build. 
Hey rbiddis1, I've had a huge amount of interest - which is fantastic, but more than I can reasonably spend any decent amount of time with. I've created a Slack channel for anyone who is interested to join: https://join.slack.com/t/sheldonsrubymentoring/shared_invite/enQtMjk0ODc0NjYwNzUzLWZhMjhiYmRlN2Y4YmZjYzBlMjMxYjA0ZjA3M2M4ZDc0MjQ1MGFiZjI4NzkxNGQ0ZTgwYzllMDM0ZGQwYjQwNTU Join there, introduce yourself and I'll try to answer any questions as quickly as I can. Good luck!
Hey sioa, I've had a huge amount of interest - which is fantastic, but more than I can reasonably spend any decent amount of time with. I've created a Slack channel for anyone who is interested to join: https://join.slack.com/t/sheldonsrubymentoring/shared_invite/enQtMjk0ODc0NjYwNzUzLWZhMjhiYmRlN2Y4YmZjYzBlMjMxYjA0ZjA3M2M4ZDc0MjQ1MGFiZjI4NzkxNGQ0ZTgwYzllMDM0ZGQwYjQwNTU Join there, introduce yourself and I'll try to answer any questions as quickly as I can. Good luck!
See the [centralbank](https://github.com/openblockchains/centralbank) or [bitshilling](https://github.com/bitshilling) as real world example on how to build your own cryptocurrency with ledger-lite. PS: You might also read / browse the (free online) [Programming Cryptocurrencies and Blockchains (in Ruby)](http://yukimotopress.github.io/blockchains) at the Yuki &amp; Moto Press Bookshelf.
I've always wondered why this wasn't possible at the first place...
Except it's not 57% faster download. You only reduced the footprint for your HTML, at the expense of your CSS and IMO the ease of understanding your code. You moved bytes from one place to the next.
Making these methods available via refinements is another way to add these methods to String without monkey patching.
 some_enum_one.map { |item| transform(item) } .map { |item| second_transform(item) }
 some_enum_one.map { |item| transform(item) } .map { |item| second_transform(item) }
[removed]
If you already have some programming experience (e.g., you do not have two tasks at once: grasp Ruby and grasp programming in total), I'd recommend "classic" Programming Ruby book: https://pragprog.com/book/ruby4/programming-ruby-1-9-2-0 Unfortunately, its last edition covers only somewhat outdated Ruby 2.0, but to "taste" the language it is still the best. After this just read through some interesting libraries (through, say, https://github.com/uhub/awesome-ruby and https://github.com/arbox/data-science-with-ruby), and official language docs: http://ruby-doc.org/core-2.5.0/ (it has docs for all versions, currently most used are 2.3-2.4, the most recent is 2.5.0), it is pretty extensive (though the "file list" style of TOC is not that friendly). I believe that will be the clearest path in described situation
First one. If I append a new statement, `git diff` shows changes in 2 lines when using the second approach.
From [Ruby Style Guide](https://github.com/bbatsov/ruby-style-guide/blob/master/README.md) * Adopt a consistent multi-line method chaining style. There are two popular styles in the Ruby community, both of which are considered good&amp;mdash;leading `.` (Option A) and trailing `.` (Option B). &lt;sup&gt;[[link](#consistent-multi-line-chains)]&lt;/sup&gt; * **(Option A)** When continuing a chained method invocation on another line keep the `.` on the second line. ruby # bad - need to consult first line to understand second line one.two.three. four # good - it's immediately clear what's going on the second line one.two.three .four I'm surprised there isn't a specific guideline for this.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [bbatsov/ruby-style-guide/.../**README.md** (master → 8848182)](https://github.com/bbatsov/ruby-style-guide/blob/8848182272337f76e589a01b75043851eb460cda/README.md) ---- 
&gt; And the advantage of (2) being that you can easily copy-paste the code in a terminal. You might like the [fc](https://math2001.github.io/post/bashs-fc-command/) command.
I've always seen Action Mailer previews explained as more of a test feature, where you can see what the email looks like without sending one. That's what I use it for. In that context it makes no sense to have params, cause if you want two different emails for two different authorizations, you'll just create two different previews. I've never needed to use params. I guess it makes sense that the feature was created like this, and only afterwards did the need for params arise.
To me, it's clearly better to leave a trailing dot, so you know the line is continued. But rubocop on some open source projects is making me do the reverse, so clearly I have a minority opinion. I don't get it. 
I would checkout the gem: https://github.com/mperham/connection_pool which should be customizable enough to handle DBI. Unfortunately there's no true 'native' connection pooling in Ruby (without writing it yourself), but this gem has worked for me in the past. At the very least perhaps you can look at the internals and grab some ideas on implementation?
Brought to you by the Whitespace Gore Department :-)
Similar for me, based on programming habits from other languages, leaving trailing dot creates a *continuation* for code reading.
This is a great idea an offer. I am very interested in participating, and will follow-up for additional information. 
&gt; When I read a line of code, I will have already looked at the beginning of the next couple lines ... &gt; ... if the line that I start to examine is a continuation line, I will not know that unless a leading dot was used. Maybe I don't get what you're trying to say, but it sort of sounds like you're saying that, when reading a line, you already know what's on the next line, but _not_ what's on the previous line... like you're reading the code bottom-to-top instead of top-to-bottom.
Same for me. I hate that rubocop enforces leading dots. (The other default ruby style rule that I can't stand is putting a space between a method call and a block argument, e.g. preferring `foo.each { |x| bar(x) }` over `foo.each{ |x| bar(x) }`.)
You read from left to right, and your eyes can already see the beginning of adjacent lines. So you already know which lines are continuation line before you finish reading that lines. For example, if I skim the code and see the beginning of these lines: openTransaction.start(..) blah blah .foo(....) blah blah blah executeBar(...) I immediately know that the second line is the continuation line, and the third one isn’t, without having to read to the end of the line. 
I use leading dot together with either parentheses or backslash new line. Got the best of both worlds.
For one of our apps customers have a dedicated marketing person. When we send mails, we render some contact information into the mail and we need to make sure, the mail layout is not *completely* broken (I know, I prefer text/plain as well). Having a seperate ActionMailer preview class for each marketing employee is a bit cumbersome, and it would be *much* easier to parameterize either the customer or the employee id. Our current approach actually avoids the preview classes completely. Instead, we use [MailHog](https://github.com/mailhog/MailHog) and deliver the mails locally. Granted, this does not tell us what Outlook will do to the mail, but neither does ActionMailer::Preview :-)
No... I read the start of each line in a given block before reading the entirety of any given line. Consider the following code (from https://raw.githubusercontent.com/stympy/faker/master/lib/faker.rb): def regexify(re) re = re.source if re.respond_to?(:source) # Handle either a Regexp or a String that looks like a Regexp re. gsub(/^\/?\^?/, '').gsub(/\$?\/?$/, ''). # Ditch the anchors gsub(/\{(\d+)\}/, '{\1,\1}').gsub(/\?/, '{0,1}'). # All {2} become {2,2} and ? become {0,1} gsub(/(\[[^\]]+\])\{(\d+),(\d+)\}/) {|match| $1 * sample(Array(Range.new($2.to_i, $3.to_i))) }. # [12]{1,2} becomes [12] or [12][12] gsub(/(\([^\)]+\))\{(\d+),(\d+)\}/) {|match| $1 * sample(Array(Range.new($2.to_i, $3.to_i))) }. # (12|34){1,2} becomes (12|34) or (12|34)(12|34) gsub(/(\\?.)\{(\d+),(\d+)\}/) {|match| $1 * sample(Array(Range.new($2.to_i, $3.to_i))) }. # A{1,2} becomes A or AA or \d{3} becomes \d\d\d gsub(/\((.*?)\)/) {|match| sample(match.gsub(/[\(\)]/, '').split('|')) }. # (this|that) becomes 'this' or 'that' gsub(/\[([^\]]+)\]/) {|match| match.gsub(/(\w\-\w)/) {|range| sample(Array(Range.new(*range.split('-')))) } }. # All A-Z inside of [] become C (or X, or whatever) gsub(/\[([^\]]+)\]/) {|match| sample($1.split('')) }. # All [ABC] become B (or A or C) gsub('\d') {|match| sample(Numbers) }. gsub('\w') {|match| sample(Letters) } end When I first read this, I read things in the following order (ref to the LOC above added for clarity's sake): 1. `1 def reg` 2. `2 re = ` 3. `3 re.` 4. `4 gsub(` 5. `5 gsub(` 6. `6 gsub(` 7. `7 gsub(` 8. `8 gsub(` 9. `9 gsub(` 10. `10 gsub(` 11. `11 gsub(` 12. `12 gsub(` 13. `13 gsub(` 14. `14 gsub(` 15. `15 end` 16. `2 re = re.source if re.respond_to?(:source)` 17. `4 gsub(...).gsub(...).` 18. `5 gsub(...).gsub(...).` 19. `6 gsub(...) {|match| $1 *` 20. `6 # All {2} become {2,2} and ? become {0,1}` 21. `6 |match| $1 * sample(Array(Range.new($2.to_i, $3.to_i))) }.` 22. `7 |match| $1 * sample(Array(Range.new($2.to_i, $3.to_i))) }.` 23. `7 # (12|34){1,2} becomes (12|34) or (12|34)(12|34)` 24. `6 /(\[[^\]]+\])\{(\d+),(\d+)\}/` 25. `7 /(\([^\)]+\))\{(\d+),(\d+)\}/` I could continue, but my point was that in my initial scan of this code - from 5 through 14 above - I have to assume that the preceding line had a trailing dot. Actually confirming that takes me about three times as long as it would take me to confirm that the following line has a leading dot, since the end of the previous line is not located at a consistent location and there's much more noise impacting locating the end of the previous line of code.
:+1: too often we avoid writing new objects to write even worse code :)
I reduced my page by 57% (the size of 50 SVG icons) at the cost of increasing my CSS by a tiny fraction (the size of only one SVG icon). That icon is on EVERY page so it has to be downloaded somehow. It's better to only be downloaded once via CSS than 50x times for every page load. CSS gets cached by browser and CDN while the HTML does not. Even if I repeated the SVG icon in my CSS the same number of times instead of only once, it would still be a net performance benefit. If you see the "update" section at the bottom you can use a `&lt;use&gt;` tag with external resource. That's probably what I would use if I had to re-do it again to maximize "ease of understanding". 
I do that too; yet mysteriously, we prefer trailing commas for lists, writing DEVICE_MATCH_RULES = [ {device: :ios_hi, os: /ios/i, width: 1024..2732, height: 768..2048}, {device: :ios_lo, os: /ios/i, width: 0...1024, height: 0...768}, {device: :android_hi, os: /android/i, width: 1280..2560, height: 800..1800}, {device: :android_lo, os: /android/i, width: 0...1280, height: 0...800}, ] and not the apparently unnatural (and syntactically invalid) DEVICE_MATCH_RULES = [ {device: :ios_hi, os: /ios/i, width: 1024..2732, height: 768..2048} , {device: :ios_lo, os: /ios/i, width: 0...1024, height: 0...768} , {device: :android_hi, os: /android/i, width: 1280..2560, height: 800..1800} , {device: :android_lo, os: /android/i, width: 0...1280, height: 0...800} ] There are languages where the latter style is preferred e.g. Elm. 
Has anyone seen a clarification of what the "big issue" was causing bundler to be backed out of 2.5 release at the last minute? https://bugs.ruby-lang.org/projects/ruby-trunk/repository/revisions/61416
Code has two goals 1) To compile into something useful. 2) To be understandable by someone else and/or future you. Which one makes it most obvious to you what's going on? 
No. Weirdly, that commit with log line about "big issue" you link to is by @hsbt, whom the newsletter above says was added as a bundler committer/maintainer. While the newsletter also says "the Ruby language core team has yet to announce why they decided to remove Bundler a few hours before Ruby 2.5 was released." One would have thought the author of the newsletter writing on behalf of RubyTogether could have... just asked @hsbt, who is a maintainer on Bundler, a RubyTogether project. Before writing a newsletter about bundler. Otherwise, the implication seems to be that we are waiting for hsbt to "announce" something to... themselves? As the relevant member of the "ruby language core team" seems to in fact be a "bundler maintainer". Odd indeed. 
will take a look on the gem. thanks alot for the suggestion
I seem to recall a regression that I think broke the Rails test suite, something about embedded Gemfiles. A good example of the "x.x.1" bug -- a bug that requires a really quick patch release to fix a major regression. Happens all the time; all us OSS developers fear it.
you can type begin , paste, and then end and #1 will work
Is writev just emulated using a loop on Linux? Or is it an actual syscall?
Great articles series on Ruby 2.5. FYI: If anyone is looking for more article I collect [Ruby 2.5 - What's News?](https://planetruby.github.io/advent2017/ruby25) bytes at the Ruby Advent Calendar page. 
&gt; In Ruby applications we tend to do an awful lot of string concatenation before shoving, say, a piece of fully rendered HTML over a socket. This string mangling burns CPU and memory. Has anyone compared the speed of `writev` vs multiple `write` calls?That's what currently happens when you assign an `Enumerable` object as the response body in Rack applications, the underlying web server (Puma, Unicorn etc) will iterate over the `Enumerable` and `write` strings to the socket.
That HTTP chunking patch is already showing a really significant performance improvement. Note that a loop over write(2) has different semantics to a writev(2), particularly with network sockets. The vector write gives kernels a much better opportunity to coalesce buffers into packets. And syscalls are expensive - and about to become more expensive.
&gt; Oh, nice! I'm going to try to make the same patch for HTTP.rb :) Ok, unlike Net::HTTP, HTTP.rb writes each encoded part of chunked request bodies in a single `#write` call. In other words, instead of socket.write("#{chunk.bytesize.to_s(16)}\r\n") socket.write(chunk) socket.write("\r\n") HTTP.rb writes it like this: CRLF = "\r\n" socket.write(chunk.bytesize.to_s(16) &lt;&lt; CRLF &lt;&lt; chunk &lt;&lt; CRLF) In my opinion this is already optimized, since it's reusing the string allocated by `chunk.bytesize.to_s(16)`, it's not creating any additional strings.
It's not allocating a new string object, but each of those `&lt;&lt;` calls can cause the memory backing the string to be reallocated and copied. It's possible the first one avoids it because the output of the `to_s(16)` is small and the `CRLF` is small. But `chunk` is probably going to force a reallocation and if it doesn't have spare capacity, the next append will also reallocate. See http://patshaughnessy.net/2012/1/4/never-create-ruby-strings-longer-than-23-characters for why this is the case.
Do I understand right that the "new" better way to do this would then simply be: socket.write(chunk.bytesize.to_s(16), CRLF, chunk, CRLF) This new API (IO#write taking multiple arguments) is probably only in MRI and not JRuby at this point, I'd imagine?
The Passenger application server uses a native extension to use `writev` instead of `write`. That they've done that indicates that there's some real world performance improvement to be had, though I don't know of any benchmarks, maybe /u/FooBarWidget has more info.
Looks to be an actual syscall: https://linux.die.net/man/2/writev Though it appears the glibc wrapper function will emulate it with a single buffer and a loop if the number of buffers is too large for the kernel to handle.
Right, my JRuby comments were less about performance than API compatibility. JRuby may not need the perf improvement, but I want to be able to write a multi-arg `write` that will get the perf improvement in MRI, but still _work_ in JRuby, so my code can run in both. Could be as simple as JRuby supporting multi-arg `write` that actually simply concatenates them, rather than be new behavior/implementation. 
I personally tend to avoid indentation in most cases except for blocks/conditionals, and multiline method indentations: do_thing( long_var_1, long_var_1 ) Why? Because although doing stylistic indentation might look nice, it can sometimes make the code harder to edit. And it also can make the code look disorganized, if there are many different statements indented at different (arbitrary) levels So, if I were to follow my approach, your second snippet would look like so: some_enum_two. map { |item| transform(item) }. map { |item| second_transform(item) } Instead, I would prefer this: some_enum_two .map { |item| transform(item) } .map { |item| second_transform(item) } it's visually clearer to me what's going on this way, since the leading dots provide a little bit of pseudo-indentation.
Your first program overrides String? That's actually pretty impressive.
Congrats :) Ruby is wonderful. Some nit-picking, though: * 2 spaces * for-loops are quite taboo in rubyland * you're dangerous for extending string :) * ... this should probably be its own object The Ruby Style Guide, while not the police, is a great resource for learning "preferred" practices when writing Ruby, https://github.com/bbatsov/ruby-style-guide
Or just linked to the redmine issue. Changes like that usually have an associated issue.
But never do it. It would be better if you created a new class and did something like this Scraper.new('https://projecteuler.net/problem=1').search_source("...")
Check out mechanize and nokogiri to up your ruby game. Also, everything u/hehestreamskarma said
or a refinement, in a module. 
Thanks! :)
This was what I was going to say too. I am new at ruby and doing project euler off and on when I get bored. There is a great chapter on web scraping with nokogiri in the book "bastards of ruby" which is free online. I think nokogiri can do what you are doing. Good idea about using it for project euler though. I should have thought of that use case.
I've done programming before (Coming from Python, and Java before that), so everything is very similar. As /u/hehestreamskarma has pointed out, I still have much to learn. Thank you anyway! 
EDIT - I read the style guide, and I now know why. I will be implementing all your suggestions soon. Thanks! Thanks for the suggestions! I didn't know ruby-people didn't like for loops - why would that be? Is there an alternative? Thanks again! EDIT
This is better. Thanks for the suggestion! 
The .each |block| style is more readable (at least for Ruby devs, because that’s the convention). 
Congrats on getting started.... it get's better from here... One suggestion that I would like to make not only for you, but for everyone would be to use wget to download the file you will be working on. This helps in several ways. One, you are not depending on the network for your source material (and being nicer to the server). Two, when you or others fork your source, possibly years from now when the site is gone or changed they can still understand what was going on.
Posting this article here is a little obnoxious. So, in response, here are the top 5 reasons for Ruby-ists _NOT_ to use Crystal and just keep using Ruby: 1. Very, very low learning curve. You already know Ruby. 2. Dynamic typing is a feature, not a bug. Compile time checking is useful, but so is dynamic typing. It depends on the type of problem you're solving. 3. Mature ecosystem with a commitment to performance enhancements and the ability to target JVM and other environments trivially through use of appropriate runtime. 4. The Web framework you want is already here. Love the completeness of Rails? Guess what, you've got Rails. Want something lighter, you've got Sinatra, Nancy, or build your own. Rack means you can choose your own adventure. 5. Ruby is not written in Ruby, but you don't care. If you wish to extend the core language, you can do so, but you can probably just extend it in Ruby, because it's ruby and everything is up for grabs.
Interesting read. Thanks. :) 
&gt; Updated by matz (Yukihiro Matsumoto) 12 months ago &gt; OK, accepted &gt;This is because -l is older than chomp. &gt; &gt; Matz. https://bugs.ruby-lang.org/issues/12926
Most of Ruby is written in Ruby. 
So after playing with it a bit, I just wanted to show a little more of the Ruby way on this: BTW, I did scrape the file and put it into index.html in the same dir as the code to make working with it faster.. | require 'open-uri' | | class Scraper | | # Let's keep the filter items with the class... | # no need to polute the global namespace | FILTER = { | '&lt;p&gt;' =&gt; '', | '&lt;/p&gt;' =&gt; '', | "\u00D7" =&gt; '*', | '&lt;/dfn&gt;' =&gt; '', | '&lt;/sup&gt;' =&gt; '', | '&lt;sup&gt;' =&gt; '', | '&lt;div style="text-align:center;"&gt;' =&gt; '', | '&lt;/div&gt;' =&gt; '', | '&lt;br /&gt;' =&gt; '', | '&lt;p style="font-family:\'courier new\';text-align:center;"&gt;' =&gt; '', | '&lt;var&gt;' =&gt; '', | '&lt;/var&gt;' =&gt; '', | '&amp;lt;' =&gt; '&lt;', | '&lt;span style="color:#ff0000;"&gt;&lt;b&gt;' =&gt; '', | '&lt;/b&gt;&lt;/span&gt;' =&gt; '' | } | | # This looks like a one off so let's not | # over generalize for custom filters yet | def initialize(url) | @url = url | end | | def search_source(start, final) | open(@url).read | .match(/#{start}(.*)#{final}/m)[1] # Since we are using them anyway, filter just the things we want | .lines.each { |line| filter line } # Let's farm out the complicated filtering to it's own method | end | | def filter string | FILTER.each { |key,value| string.gsub!(/#{key}/,value) } | end | | end | | puts Scraper.new("index.html").search_source('&lt;div class="problem_content" role="problem"&gt;', '&lt;/div&gt;&lt;br /&gt;') | 
6. Doesn't insist you indent with 2 spaces.
Interesting, though it missed what I perceive to be one of its biggest advantages - the ability to produce native executables.
In contrast, I used this sometimes and basically does the same [1] pry(main)&gt; hsh = {} =&gt; {} [2] pry(main)&gt; (hsh[:foo] ||= []) &lt;&lt; :foo &lt;&lt; :bar =&gt; [:foo, :bar] [3] pry(main)&gt; hsh =&gt; {:foo=&gt;[:foo, :bar]} or if you have an actual array: (hsh[:bar] ||= []).concat myarray Not particularly nice code but sometimes it has it's uses in quick and dirty solutions :)
What was that thing you did with .match(/#{start}(.*)#{final}/m)[1] ?
Warning: argument about semantics ahead. &gt; Most of Ruby is written in Ruby. That depends on what you define as 'Ruby'. Does 'Ruby' include its stdlib? In my mind what 'Ruby' is, is the runtime and nothing else. I don't look at my ruby code and say that **is** Ruby. I say that is code **written in** Ruby. The MRI runtime, AKA YARV, is written in C.
&gt; Posting this article here is a little obnoxious. Why? The post is just presenting a language that might interest some rubyist. The title is not "5 reasons ruby-ists should ditch ruby". Ruby is a cool language, Crystal is a cool language. You dont have to be so bitter
I haven't used Crystal at all but it seems interesting! I just installed it and ran their basic HTTP server tutorial and enjoyed it very much. Perhaps I will look for an excuse to use it in a more purposeful manner.
Ah... So I am doing a [capturing regular expression](https://www.regular-expressions.info/refcapture.html)
Be prepared to get sucked in ;)
Most of the Ruby (CRuby) programming language is implemented in Ruby. You are correct that MRI is written in C. To demonstrate what I mean, just look at the repository on GitHub, you'll see that most of the codebase is in fact Ruby, not C.
I applaud your effort but it just doesn't have the elegance of other cleanly defined testing DSLs. This, for example, hurts my brain: add "Test Eval::truthy", -&gt; { (Nanotest.run silent: true do add Nanotest::Eval::truthy "true" add Nanotest::Eval::truthy -&gt; { true } end) == 0 and (Nanotest.run silent: true do add Nanotest::Eval::truthy "false" add Nanotest::Eval::truthy -&gt; { false } end) == 2 } To me, many people accept the downsides of Ruby in favor of clean syntax and readability (of course there are many other reasons, too). That code snippet just seems like you're using as many language features as possible without any real reason to.
For a little context, I've been using ruby for over 5 years... I *wrote* some of the language!! Most of the [standard library](https://github.com/ruby/ruby/tree/trunk/lib) is written in ruby, it's true. However, most of the [core library](https://github.com/ruby/ruby/tree/trunk/ext) (which is what *I* would consider to be "**the language**") is written in C. When you install MRI, it takes a while to *compile*. Because the *core language* is mostly written in C.
Thank you for your answer. I will check those links! 
Thanks!
That is still maturing. Of course, if you use vim or emacs, you can configure those. Some work has been done to build in [debugging and other plugins to VS Code](https://github.com/crystal-lang-tools/vscode-crystal-lang). I still just use Atom. 
Look at the deployment process for Rails (or even Sinatra) compared to, say, a Go web app. Being able to prebuild *everything* and drop a fat binary in is an incredible deployment setup. The advantages for client-side tooling are even greater. 
The file that you link to is really inconsistent, I'd recommend using `rubocop`. No space after the `&lt;`: `Nanotest.run(silent: true){ add -&gt; { true } } &lt;1` Multi-line blocks with braces: 7.times { add -&gt; { false } } Multi-line blocks with `do...end` syntax: Nanotest.run(silent: true, abort_on_fail: true) do add -&gt; { false } add -&gt; { var_test = true } after -&gt;(x) { var_after = true } end This block of code calls the exact same method (`Nanotest.new`) with and without parentheses: t = Nanotest.new silent: true do s = Nanotest.new(silent: true) {add -&gt;(*args) {args == arguments}} add s end Here you use `-&gt;` for a lambda: add -&gt; { false } And here you use the `lambda` keyword (as well as a magic number. I don't know what the `[1]` means here: Nanotest::Eval::succeeds(lambda do 1 + 1 == 2 end)[1].call
I don't see the need for the use of lambdas either. Forgetting the rest of the API, which definitely doesn't optimize for readability and cleanliness, why can't this `add` method be called as: add 'Test Eval::Truthy' do # Do some testing end Blocks are probably the most idiomatic Ruby feature. Lambdas and Procs have their use cases, but I think they should be the 2nd choice. APIs are a very important decision as well, so the weight of making the wrong choice here is pretty hefty.
Any book that covers 1.9 or 2.0 idiomatically and properly will be fine since the last large shifts in Ruby syntax came across those versions. Since then it's been more about performance and minor tweaks to syntax that don't break things (mostly).
hahaha yes I know, the reason for that inconsistency is that I am not really sure which way I prefer, so I just tried out many ways to do things in hopes that I'd some day go back and change it all to one consistent style. I still haven't really found a way of writing things that I like.
Crystal does not have static compilation and has many dependencies like LLVM. 
What do you think we should indent by?
Ahh, huh, for some reason I thought there was. That said, even a binary + shared libs is probably easier to deal with. 
I'm looking to scale a page size. Is this possible in HexaPdf?
Docker containers are helpful and heroku build-packs of course. There are some (build-packs) for crystal and amber, though they might not all show up on heroku's site, you can still use them if you have the right git url.
Interesting! I guess it's because you're assigning that specific array to the hash key, and then mutating it after it's been assigned, right?
Did you read the thread? You didn't bring any new information to this discussion. This thread started because someone said NOT compiling to a single executable was a missed opportunity.
thanks :)
Are many people using ruby 2.5 in production?
1. In short, no. While Ruby may be able to do those things as well as any other dynamic language, it is not common in robotics, game dev, or ML. Machine Learning is dominated by python, Game Dev will vary based on the engine that is being used, but I'm not aware of any major game engines that utilize Ruby. I don't actually know much about robotics, but have not seen it associated with Ruby and I would think that python would also be popular here in addition to compiled languages like C/C++ or C#. 2. Ruby on Rails is specifically a web framework that implements many conventions and special features. There is a difference between learning Ruby and learning Rails. In my experience, learning Rails has not helped me do anything but work in Rails. 3. I'm sure that there are projects out there in Ruby for all three of the areas you've mentioned. They may not be commonly used, and so the odds of finding a job with them is not likely, but that doesn't mean that it's something that you can't do. 
Guess I can't skip using Nokogiri. 
Aside from the obvious learning aspect, is there a particular reason you didn't settle on [RSpec](http://rspec.info/)? Your syntax seems extremely similar.
Apart from the spheres you've listed, and as far as I know, `mruby` is being used widely in Japan for embedded systems.
Thank you for the suggestion for mruby. I hadn't come across this platform yet. 
Ruby has libraries for these types of things but I wouldn't call it widely used for any of them. I see ruby used in two places, those being web dev (rails) and technical operations (infrastructure, particularly with tools like chef) our companies ops team all wrote in Ruby for most task we do (we all work in devopsish positions) I've written some small games using Gosu which has a ruby port and it makes writing games fairly easy. 
It can be such a PITA distributing Ruby code to non-Ruby users. 
I ran this alongside Activity Monitor and ruby's memory usage keeps climbing… working as expected over here.
What happens when Ruby runs out of memory? Does it throw an error, or something else, perhaps? And is that the stack or the heap?
The question really isn't _can_ you do it in Ruby. You can. The question is can Ruby overtake the languages that have several years head start in these fields and, in some cases, the backing of very large companies? I'm not so sure about that. 
httpd isn't a great name for a utility. This conflicts with the ubiquitous Apache webserver. Along the same lines, `http` might not be the best name for a ruby module. Food for thought. But i love the idea! Have a convenient http status code reference on a CLI util is a great and very useful idea. GJ. 
I upvoted your comment, I totally agree. I think I saw the Apache thing somewhere and didn't want people to get confused with it, but I also wanted the tool to be short and quickly accessible. I thought of https for "http statuses" too but that's a no go obviously... haha
Nice! Ruby is a great language for creating CLI's. 
So when you do this: begin raise SomeErrorHere # ... rescue =&gt; e puts "Bad Thing Happened: #{e}" end ... the kind of error that is caught is a StandardError (or any of StandardError's descendents). It's a shorthand for "rescue StandardError =&gt; e", and is very common. On a practical level: * SyntaxError doesn't extend StandardError, and so will simply pass through that "rescue ... end" block. * To make things worse, SyntaxError is thrown when doing things like loading a script (it's a child of ScriptError). If you *do* catch it (and you can), you'll also be catching errors like _"loading a ruby script that has a syntax error in it"_ which, depending when and how the capturing is happening, could be Bad™. Aesthetics: Anyone actually using this library is going to have two choices when it comes to handling errors: catching StandardError children and presenting it in a generic way, or catching specific error types and presenting them differently. If you're going to make them look up the kinds of errors you're going to return anyway, you may as well make them specific to the application, to stop any potential _"is this Ruby complaining about a type error or that library...?"_ kinds of questions. *tl;dr* i'd make new exception classes that extend StandardError, for practical and aesthetic reasons
I'm not the hexapdf author (was a guest post by Thomas Leitner). I'd say best to read / browse the hexapdf docs - https://hexapdf.gettalong.org Happy new year. Prosit 2018! Cheers.
Cheers!
Like I said, try to use a service that doesn't respond with HTML :) A json response might look something like: { up: "yes" } 
&gt; Moreover, mapping an English phrase or clause to a portion of executable test code is a bit like using descriptive method names to organize and clarify your logic in Ruby, and that's a universally encouraged best practice. But honestly, that's why I'd argue that people avoid it: why go for the (arguably fragile) overhead of mapping parts of specific English phrases to code instead, when you could write vaguely-Englishy descriptive tests with code instead? (I know you can [embed code inside .feature files](https://github.com/rspec/rspec-core/blob/master/features/formatters/custom_formatter.feature), but I'm not sure what using them actually gets you at that point.) The usual selling point that I heard back when Cucumber was hot was that non-programming business people could read **and write** these cases. I've personally seen one place that had some tests and were read (occasionally), but I've **never** seen anyone matching that description writing them. As it is, I haven't seen any Cucumber on a project since 2014. I've heard of it come up in Q&amp;A circles, but not in Ruby (or non-Ruby) groups for a while. I'm in Sydney in Australia, if that's relevant.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [rspec/rspec-core/.../**custom_formatter.feature** (master → b48d851)](https://github.com/rspec/rspec-core/blob/b48d851ce1b56f42e5362682f1cf5767ef0d9245/features/formatters/custom_formatter.feature) ---- 
I can't seem to find any APIs that provide this service. I did however find a [python script](https://github.com/fenhl/isup) that does something similar to my gem (instead of "is up" it checks for "its just you")
Thanks! Yeah I tried writing the something similar in shell script, it was really different. optparse is pretty cool I think
&gt; As it is, I haven't seen any Cucumber on a project since 2014. I've heard of it come up in Q&amp;A circles, but not in Ruby (or non-Ruby) groups for a long while. Well, there it is. &gt; ...when you could write vaguely-Englishy descriptive tests with code instead? Simply put, the vaguely-Englishy code that tests consist of are at a much lower level of abstraction than the plain English descriptions that begin each `describe`/`context`/`it` block, and interleaving the one with the other seriously impedes getting a broad picture of the spec as a whole. Alas, this is more or less the answer I was expecting. Guess I missed my chance to try it and find all those reasons to hate it myself.
I do think that Cucumber is a very useful tool. In [tus-ruby-server](https://github.com/janko-m/tus-ruby-server), which is just an HTTP API, I first wrote the acceptance tests in Minitest ([server_test.rb](https://github.com/janko-m/tus-ruby-server/blob/f8869faae28f8b13891d2863c1b6dc8592799ac6/test/server_test.rb)), because I wanted it to just be code. It was horrible, it always took me too long to figure out what the test is testing, reading the code wasn't easy. I could have probably extracted "features" into multiple files, and added a bit more DSL, but I was thinking: why not just use a tool that's meant for this? So I [ported](https://github.com/janko-m/tus-ruby-server/commit/66c9d2ed9eeefb0942fd7e54eb766fe9a9d2006c) all my acceptance tests to Cucumber. That was a big win. It immediately solved the readability problem, because no code is more readable than English, and it's just so natural to write HTTP interaction with Cucumber. I like that I can write exactly how I want it to read, and handle the implementation separately. When acceptance-testing web applications, I think that Cucumber can be really useful tool to motivate you to make assertions based only on HTTP API interactions, because it forces you to think in a way that a client would interact. It's tempting to assert whether `POST /articles` created an article by checking `Article.count`, but that couples you to the implementation; it's much better to instead just visit the `GET /articles` page and see if the created article is listed.
I typed "is up api" into google. [This](https://github.com/sindresorhus/is-up) is the first result. Under the hood, it's using: `https://isitup.org/google.com.json`: { "domain": "google.com", "port": 80, "status_code": 1, "response_ip": "216.58.198.78", "response_code": 302, "response_time": 0.013 } A library using this API is far more reliable and well-defined! Which is probably why that npm package has over 260 github stars, compared to that python script's 5 stars.
What about just plain http-stat? Individual users can then alias the name to something shorter or have their shell autocomplete it :)
I don't really think so.
I think cucumber / gherkin style tests (we mostly use Turnip as the runner so it's more rspec-like) make the most sense if you actually have non- or less-technical people who need to read/write them. In our case product owners and QA will write/read them during story creation and verification. We also use it mostly for BDD-style tests and still rely on rspec for lower level tests.
Ruby was prevalent in DevOps for a bit, but I think Go has superseded it for tooling.
Yea so? You think you are going to get away from that by some magic language feature? 
&gt;My comment explicitly states that it is possible to package ruby. But the whole experience is awful, though, for quite a few reasons. The first, and biggest one, is that your gem packaged as a .deb had better be compatible with whatever version of ruby is in the default repository of every distribution that uses apt. You name a specific version as a dependency. &gt;Oh, and if someone added an apt source that includes more up to date rubies, you've got to account for that, too. It's a mess. And how would you avoid that with your magical language. For example if somebody installed multiple versions of a library you depended on? 
When comparing ruby and crystal. Neither one compiles to a single binary.
Something like: ``` %(north south south).exclude?(input) ``` or the opposite: ``` %(north south south).include?(input) ```
For the second time, we know that.
so it would be this (below) if i wanted my code to exclude those words inputted? elsif %("north", "south", "west"). exclude?(input) 
`elsif %(north south west). exclude?(input)` works equal 
&gt; Was wondering if you can use more than one set of || in a row. No, because || is disjunction of boolean values, not a disjunction values which you can then test against another value. Some languages do have this though - I think Perl 6 calls it 'junction' (which is funny because it's a disjunction really). Other people's suggestions in this thread look idiomatic to me.
ah okay, thanks for the clarification!
To do that using `||`, you would have to do: if (input != "north") || (input != "south") || (input != "west")
If you use emacs checkout [know-your-http-well.el](https://github.com/for-GET/know-your-http-well).
I'd love to have a reason to implement this. Unfortunately I am stuck in CRUD land
Thank you for the response, the post contains a lot of valuable information. I will definitely bookmark it and use it as a reference in future projects. Right now I am using AWS StepFunctions for my purchasing and content distribution state machine it is nice however I like your solution because I get to keep using Ruby :)
&gt; all living in the same, clashing namespace /u/olbrich just mentioned turnip, which supports namespaced step definitions by defining steps in modules. It also uses strings to define steps, rather than regular expressions. But — correct me if I'm wrong — it doesn't seem you're particularly convinced by the value proposition either way. I do appreciate the insight.
Have you ever looked at eventstore.org? I would use it over RabbitMQ for both inter-service messaging and event sourcing every day of the week and six days till Sunday. (And I don't use eventstore.org really, either, but I'm not here to self-promote)
&gt; You name a specific version as a dependency. Right, think through what that means if ubuntu, debian, etc. all don't have the same version of ruby. Debian and Ubuntu have different release tracks for long term stability vs. up to date. &gt; And how would you avoid that with your magical language. For example if somebody installed multiple versions of a library you depended on? I'm not talking about a "magical language," and that kind of flippant sarcasm is harmful to discussion and rude. I'm asserting that packages of native executables are much, much easier to work with. I'm not saying that they are utterly free from the challenges of dependency management, rather that those challenges are significantly mitigated when native executables can be statically linked and aren't tethered to a runtime. In many cases, such as a database, they don't require any dependencies. Are you being contrarian because it's fun or something? I'm trying to understand your overall point here. It seems like you're simply arguing for the sake of arguing. I hope I'm wrong. Cheers
&gt; On the other hand, if your feature test suite grew by an order of magnitude, I could see it becoming very difficult to navigate and maintain. Well, so will any kind of test suite, right? ;) &gt; Do you use Cucumber on larger projects / test suites? We don't use Cucumber at work, but I would see a lot of benefit in it, especially in motivating us to test side effects through the HTTP API (it's a JSON API app). I haven't yet had experience testing JSON APIs though, only full-stack apps and non-JSON APIs, but I'm guessing it could also be made very readable and flexible.
`exclude?` is an extension provided by ActiveSupport, not the standard lib. You can do the same thing with `include?` and then negate the result though: `!%w[north south west].include?(input)`
I’ve heard of it but that’s about the extent, definitely need to investigate it some more. Since this post is mainly about making existing applications more “event-sourcing”-ish I thought it would make sense to use some less exotic pieces of infrastructure like Rabbit and Mongo (also that’s what we’re using at Kontena and I wanted to explain a more real life scenario).
Give people time to try out and test their Christmas present!
I'm curious as to what makes you say this. I'm certainly not disagreeing, but haven't been up to date on devops since Docker really swept it all up. I suppose docker is written in go...
No I have not seen this yet but it looks pretty sweet so far. Will definitely be digging in some more, thanks!
Thanks for the kind words! Of course the AWS solution definitely has some nice features such as minimal infrastructure overhead. So it really depends not just on your use case but what level of buy vs build you are willing to go. I agree coding the state machine DSL in Ruby feels very nice. :)
As this person states. Python is used for data sciences as well, and it also has a very friendly syntax.Definitely explore Python if that is your interest.
~3-5 years ago I saw a ton of Ruby for ops tasks, and Chef was extremely popular. I think Chef saw a decline in popularity as people moved to cloud/immutable infrastructure, and other configuration management methods (Puppet/Ansible/Bash) because more popular as a "run once at instance boot and never again". There's also been less of a need for config management with the move to containers/etc. I haven't seen Ruby scripts/Rake tasks recently for ops tasks, while also seeing a lot of projects both big and small written in Go. It seems more common that someone in operations would create a Bash script or Go CLI tool than to write something in Ruby. This is likely due to portability issues (system Ruby is not guaranteed, and Go can be compiled for any OS and the built binaries have zero dependencies.). Disclaimer: I work for HashiCorp. We publish quite a few infrastructure tools written in Go, but I primarily work with Ruby/Rails.
I see your point, but I would never raise an error that doesn't descend from StandardError myself. i think you're gonna run into all sorts of unexpected consequences. Ruby SyntaxError will, I think, always be raised _when the file is loaded_. There's no way to load the file (with a `require`) for instance, and _not_ get a SyntaxError, but then get a SyntaxError at some later run point originating from that file. So this is indeed as close to a fail-quick "static" kind of error as you can get, especially if using a loader that loads all your files on boot (like Rails typically does in production env). Are you _certain_ the same is true of your type definition error, that it can only be raised at file-load time, and never later? I think it's unlikely you can be certain of this (what if your type definition is inside a conditional of some kind?). So I would not use a non-StandardError-descended class here. In theory, I think it's a good idea to use ruby's built-in exception classes. I do when I can. But ruby's built in exception classes aren't quite consistent and well-thought out enough to do it universally, so I don't when it seems sketchy. I don't think I'd ever use a built-in exception class that does not descend from StandardError. 
Thanks! That makes sense. I immediately thought about the portability of Go as well. I totally agree with the immutable infrastructure thing being a shift away from the original DevOps tooling of which I would group Chef along with Puppet and Ansible. You guys make cool stuff over there at Hashi!
I use Ruby for web automation on the regular. The language itself helps non-technical people to understand the tests that have been developed more easily.
That is exactly the sort of interesting-I-never-of-heard-of-it-before infrastructure component that: a) Is fun to play with for side projects, but b) I would never dream of recommending for a commercial project because I can't tell if they'll still be around in 36 months Startup datastore vendors have it really hard at the bottom of the adoption curve, and people like me aren't helping. 
I use vim with the crystal-vim plugin. From what I've seen the Sublime plugin works really good. I've hard of people using Atom and VS code as well.
I'd say `elsif !%w[north south west].include?(input)` is the most idiomatic Ruby. JFF; two more ways that are not idiomatic that your colleagues may grumble about: elsif %w(north south west) &amp; [input] == [] elsif %W&lt;north south west&gt;.index(input).nil? 
I fell in love with crystal 2 years ago and have put way too much time into open source crystal projects since then. Even after 10 years in ruby and a few in Java I feel that my XP with crystal has made me a better programmer.
Ruby is amazing and saved me from Java in 2005. I don't think anyone is saying abandon Ruby for Crystal. But in a world where everyone seems to be dumping Ruby for Go or Elixir, having the option to use a language that is very similar to ruby but way faster than Elixir and a bit faster than Go is a breath of fresh air to me. For the last few years going to ruby conferences and listening to everyone talk about Go, Rust and Elixir was starting to depress me. My team still uses ruby but whenever we need a specific end point or page to be extremely fast, we use Crystal, which the whole ruby team can use without much of a learning curve.
I love ruby and crystal. I'm so grateful that on occasion when I need something faster I can use Crystal instead of Go or Elixir. Thanks to the Crystal and Amber Teams.
Here are a couple examples of how one could potentially scale a pdf. https://github.com/gettalong/hexapdf/issues/23
But I'm not wrong. If I were, I would say, "thanks, /u/myringotomy for improving my understanding." The presence of dependency management in both scenarios does not imply that the _degree_ of dependency management is the same. Let me give a concrete example: if I want to target all the Linux distributions and Mac OSX, I've got to restrict my usage of ruby to 2.0.0 only. If I write a program that uses 2.4 features, I _couldn't_ package it for e.g. Ubuntu, because the ruby installed by that operating system's package manager is older than 2.4. NixOS is the only OS I know of that even _allows_ side-by-side installations of different versions of packages, and that _still_ wouldn't be as great a user experience as a native executable. The reason for this is that if ruby could be compiled down into a native executable, then it wouldn't even matter what version of ruby I was using to write the code to begin with. The ruby runtime itself would get dropped as a dependency, which is such a major improvement that you appear to be completely ignoring. You seem to be saying that because my executable still might get dynamically linked against, say, `libpq`, that it's still prone to dependency issues, and therefore is not materially different. I think that's wrong, in the same way that a single error in a story in the New York Times doesn't make it anywhere near as untruthful as, say, Fox News. So there's a _clear_ difference between the two approaches. Shipping ruby script files in a package is technically possible, but it's tough sledding from the get go. That's been my whole point from the get go, and I don't see where you've demonstrated that it's wrong.
Oh lawd. So native executables offer no advantage over scripts that depend on the ruby runtime because we can stick our ruby runtime inside an operating system and distribute _that_ instead? You realize that many computer programs, say, `ls` or `vim`, need to be resident in the same system as end users, right? Do you also realize that software that's easy to package is _also_ easy to put in a container, but the converse isn't necessarily true (at all)? Are you assuming the only kind of programs worth writing are "apps?" How I pine for the good old days before the web developers took over the larger software landscape...
Alllrighty team, Macs for everyone!?
&gt;So native executables offer no advantage over scripts that depend on the ruby runtime because we can stick our ruby runtime inside an operating system and distribute that instead? Yes a container. You may have heard of them. &gt;You realize that many computer programs, say, ls or vim, need to be resident in the same system as end users, right? Containers are in the same system. &gt;How I pine for the good old days before the web developers took over the larger software landscape... How I don't pine for anything that happened five years ago. 
Command line tools in Ruby are my current obsession;-) I have developed a suite of libraries under **tty-** namespace(nearly 20 gems and growing). The tty site [http://piotrmurach.github.io/tty/](http://piotrmurach.github.io/tty/) provides links to all the current gems. I'm currently focused on finishing a **teletype** executable implementation to help in creating/scaffolding terminal applications. If you're interested, you can read &amp; contribute @ [https://github.com/piotrmurach/tty](https://github.com/piotrmurach/tty). I hope you will create more CLI tools in Ruby!
Totally agree!
I'm currently working on **teletype** executable for creating CLI apps which uses Thor [https://github.com/piotrmurach/tty](https://github.com/piotrmurach/tty).
&gt; Yes a container. You may have heard of them. Do you even understand the tradeoffs of using containers? Do you understand that not all software can still be useful if it's stuffed inside of one? For example, a text editor that can only edit files living in a docker container, and can only be interacted with through a networking layer, would be pretty useless, now wouldn't it? &gt; Containers are in the same system. They're in the same system as that of the end users? Really? _Really_? No, they are most certainly _not_. Unless you run your whole OS inside a container, and then run your ruby program inside _that_ container as well, and then we end up right where we started, don't we? Docker containers aren't even remotely the same _kind_ of thing as operating system packages. Packages can do things container's can't, and vice-a-versa. They can be used in conjunction with another. They're orthogonal technologies. At this point, you are just throwing shit out that's completely wrong just to keep this discussion going so you can avoid coming to terms with the fact that your position is utterly untenable. I shudder to think what kind of software decisions get made when someone has misunderstood the basics to this kind of extreme.
Sounds like a legit question to me, I have no idea why this was down voted. Betamax was better than VHS, but the world went the way it went. Python has the lions share of 'scientific' stuff for a few reasons... Ruby could get into that space if someone / some company really went after it, but I / we don't really expect it to happen. 
Thank you for introducing me to this platform!
Thank you! I'm definitely going to check it out.
I'd use rails but only the api application like this: http://guides.rubyonrails.org/api_app.html
Lotus is now named Hanami.
Sinatra, maybe, if your project is tiny, and doesn't plan on growing or doing too complex things. Hanami (formerly Lotus) is a tradeoff towards maintainability, with a lot more up-front work. Most likely you just want a rails api, as rails can scaffold all the boilerplate code quite nicely, and if super easy to get started with, compare to hanami or grape.
I’ve avoided REST frameworks and gone with Sinatra for the most API needs. However, i’ve very recently switched to Roda and couldn’t be happier. Similarly, for database needs i’ve left ActiveRecord for Sequel. I find the Roda/Sequel combination for API/DB much simpler and performant. And plenty of plugins for both. 
I have no programming background or anything. I spent an hour researching how to run this thing I found on github damn. why is it so difficult? can't there just be an execute button ? lol
Depending on what kind of code it can be as simple as booting up `irb`/`pry` or running `ruby &lt;script&gt;` or there might even be an executable script attached. What are you trying to run?
Link me that shit fam. If it's a very simple thing it's `ruby file_name.rb`, if not it could be hella complex. &gt; can't there just be an execute button ? Ruby is interpreted, which means Ruby code needs Ruby to be installed on your system in order to run. Since things can be installed in different ways, there's no simple "execute" button. Compare to programs written in C, which (often...) don't require special shit on your machine and can just _run_.
https://github.com/jmopr/job-hunter a job application program lol. I don't even know what is ruby or any programming thing. is it possible to just download a converter and make this an exe?
what kind of machine are you on, do you have ruby installed, and what are you trying to run? Sorry it’s so difficult at first. But keep asking, be patient, and you’ll get answers. 
I'm on a mac I've tried to install ruby, but even installing this program is difficult. everything just makes no sense 
ruby is already installed on your mac, though perhaps an older version. if you save the ruby code in a file with a name that ends in `.rb` then you can run it in terminal using simple commands. do you know what i mean by terminal?
yes but what if one project has like 7 different .rb files? https://github.com/jmopr/job-hunter I just want to get my resumes and covers sent out to the masses lol
this app has a db — is a rake db:migrate in order? i don’t do rails so i’m leaving this to others. 
Yoinks, good catch
this is a ruby on rails web application. someone below has started giving instructions. i’d go with their instructions first and report problems there. 
I heard that [Sequel](http://sequel.jeremyevans.net) is very similar to Python's SQLAlchemy, so if you've been using that you might enjoy Sequel as well. But in any case I would recommend investing time in Sequel. As for the web framework, I find [Roda](http://roda.jeremyevans.net) to be the most advanced one out there. It has very flexible [routing](http://roda.jeremyevans.net/rdoc/files/README_rdoc.html#label-Usage), and is packed with [features](http://roda.jeremyevans.net/documentation.html#plugins) which are all opt-in in sense that you only load the code for features that you use. A lot of things have been built on top of Roda and/or Sequel: * if you ever choose to go [ROM](http://rom-rb.org), it's SQL layer is implemented in Sequel * [Hanami::Model](https://github.com/hanami/model), the persistence layer for Hanami (formerly Lotus), is implemented in ROM * [Rodauth](http://rodauth.jeremyevans.net) is an advanced authentication and account management framework built on Roda &amp; Sequel * [dry-web-roda](https://github.com/dry-rb/dry-web-roda) provides structure for Roda apps, which scales much better than the Rails structure * [Autoforme](https://github.com/jeremyevans/autoforme) is an administrative console for Roda/Sinatra/Rails and Sequel
I've got a lot of production code running fairly complex systems, all running the Rack / Sequel / Sinatra stack. I absolutely love it. Simple to setup, and highly configurable. Roda is also great (it's from the same author as Sequel), but I found it's routing trees to be somewhat confusing and sometimes unintuitive. Better minds might get better milage though :) Sinatra is unopinionated, though, which means you'll have to set up various features and integrations that you'll get for free through Rails API. I've written [Ditty](http://github.com/eagerelk/ditty) as my opinionated version of Sinatra, if you're interested.
&gt;For example, a text editor that can only edit files living in a docker container, You can mount any directory you want into the container. &gt; can only be interacted with through a networking layer, would be pretty useless, now wouldn't it? no you can docker run without a networking layer. 
Why exactly? I've read pro/cons before but since you feel so strongly about it...
Sinatra or Hanami + GraphQL might be interesting. 
It's worth checking out Roda + Sequel for that type of stuff. Sweet, short and to the point.
1. Machine Leaning (ML): There are many languages to work with ML out there, some obscure ones as well but the big player are Erlang and Python although Scala and Rust are also used. Ruby could be used for the task but it isn't popular because it is slow and lacks all the scientific libraries which these other languages have. 2. Game Development: This is a very large topic and there are many languages out there you could use depending on the complexity. You can use Ruby with the Gosu gem or Python but neither one is really popular. Python does have a small community of game enthusiasts but don't expect any AAA games. Most of the games build in Python are hobby projects. C++ with Unreal Engine and C# with Unity are two of the big players but there are so many more options that professionals use although I would recommend C# with Unity since it is very beginner friendly and you can build AAA games (I didn't dive too deep into game dev myself). 3. Robotics is based on AI,ML, Data Science and working directly with the hardware. What I saw this far is that engineers will use python to crunch data, build their ML models or the robots AI and finally implement all the low level aspects of accessing the hardware using C++ or even Python sometimes. Once again I didn't see Ruby being used for these tasks because of the libraries, etc. Where does Ruby excel ? Web Development and CLI scripts. Personally I love Ruby and prefer it over Python but Python is more widely used. I guess things would be different if there were all the scientific libraries in Ruby that Python has and if Ruby were faster. Maybe Ruby 3 might be a game changer. 
Are you telling me that you'd be pleased with the user experience of using a text editor run inside a docker container? You're being ridiculous.
Nothing is "wrong" with Kafka.
EventStore can store messages permanently, _and_ it can serve as a transport. RabbitMQ can't perform both functions.
I think you all confuse 'dead' with 'not trendy'
Those subtitles though...
That's the point of the article.
Hi, crystal dev here, you can do static compilation on Linux, using `crystal build --link-flags "-static"`. Just ensure to have all `-dev` packages installed and `.a` files available.
For API work, Sinatra is the safest, most straightforward bet.
I think the folks behind TruffleRuby deserve some recognition for delivering a realistic hope of a much more powerful runtime environment for ruby. To be honest, when I talk to most people who now scoff at ruby, it's because they worked in big, messy rails apps for a few years and got sick of running into the same problems over and over. It's funny, though, I don't ever have the problems they often cite. I don't end up with huge, out of control codebases, or issues with rubygems/bundler. Conversely, the deserters almost always pick up node.js or elixir, and when I ask about what they've done since quitting ruby, I notice that they often ended up building big, monolithic web apps built on an ORM. Web development is the segment of software development that seems to be driven hardest by "fashion."
Hi, crystal dev here, you can do static compilation on Linux, using crystal build --link-flags "-static". Just ensure to have all -dev packages installed and .a files available.
Agreed - I think the problems they site are cultural, not related to the language or the Ruby Community - the culture of the company/companies they worked for. TruffleRuby and also JRuby and Mirah are great examples of ways to avoid things people sometimes view as shortcomings of the runtime. 
You can do static compilation using crystal. example project here: https://github.com/maiha/xq.cr#static-binary-is-ready-for-x86_64-linux 
Wait, sometimes Udemy courses AREN'T 90% off?
$200!? Or Google for free. Tough. 
To be honest, I'd prefer Ruby to be "not dead" the Python way (find new applications for new things) than Perl way (still good for what it was good 10 years ago). In my feelings, Ruby is not dead but it definitely being sqeezed out of the list of industry's game changers. Which eventually will lead to death. I don't think "we are still relevant" self-assurance is what we need, in fact. New things outside of "better Rails plugins" / "better non-Rails web frameworks" is what we need. 
If performance is a big issue for your app, I would consult [these metrics](https://github.com/luislavena/bench-micro/blob/master/README.md) 
First take a look at what [buildin exception](https://ruby-doc.org/core/Exception.html) classes there are. Even though it could be considered to be a syntax error (your `String\Integer` example) `ScriptError` and their descendants are not intended for runtime user input exceptions (depending on what your `x` is). This is because rescuing `Exception` is considered bad practice so if you just want to rescue broadly you rescue `StandardError` and you should try very hard not to raise anything that isn't a StandardError caused by runtime stuff. I use NotImplementedError a lot though now thinking about it. When I do command line tools or libraries in general I like to be more specific with my exception names but I inherit from the appropriate buildin class so that you _can_ go specific but you can also just broadly handle, say argument errors, easily. As an example here are a few cases of one of my CLI tools where I use absolutely no generic class but forced myself to create more meaningful named exception classes. Note that they normally would be in their respective module but to show in one line what it ends up with they have their namespaces expanded): Colorize::UnknownColorError = Class.new(::ArgumentError) EventedResultset::SetAlreadyClosedError = Class.new(::RuntimeError) Worker::IO::PvWrapper::NoCommandError = Class.new(::ArgumentError) Container::SSH::CommandExecutionError = Class.new(::RuntimeError) SlotPool::SlotAllocationError = Class.new(::RuntimeError) SlotPool::PoolAlreadyClosedError = Class.new(SlotPool::SlotAllocationError) # Why argument error? Because it comes from a config file loaded at runtime. # If it would be a boot loaded/parsed file I would use ScriptError and descendants. Application::Container::AdapterNotFoundError = Class.new(::ArgumentError) The goal was to see directly from the exception name where things go south without looking at the stacktrace. ofc you still have to but when I see `RuntimeError` it's basically useless information but `SSH::CommandExecutionError` tells me way more. You can argue that's what the message is for but as soon as you want to handle specific cases you find yourself substring testing the message string (especially if it's a library or something that others use, if you work in your app you can still change things if you need specific cases).
Having used both, my vote is for Hanami. Much more consistent ecosystem that encourages good design and enjoyable coding of maintainable code. Far less implicit "magic" than Rails for you to have to work around/against in development and testing. Hanami also has a growing, welcoming community [on Gitter](https://gitter.im/hanami/chat) and elsewhere. There are maybe four language/framework-or-library combinations that I've used in my nearly 40-year career thus far that have given me as much productive enjoyment as my work with Hanami to date. Enthusiastically recommended.
We've been using Grape for our 10 year old Rails App API. It's been fantastic.
This is not how it works. `Foo.const_missing` will only be called if attempt to lookup a constant **under** that namespace. Basically `Foo::Bar`, given that Foo already is "looked up"/defined, will call `Foo.const_missing` or fallback to the `Object.const_missing` method. Also note that constant lookup is defined by the lexical scope of the code, basically meaning where it's written not where it's executed. In cases of blocks for example constants will be looked up from the lexical scope of where the block is defined aka. written in the code. Even if you instance_eval or just call the block inside of a module or something it doesn't matter. An example with inheritance, given a class `::Foo::Bar` that includes a module `::Helper` which has a method that attempts to use a constant from ::Foo::Bar module Helper def doit Baz.new # this will try in order # * Helper::Baz via Helper.const_missing # * Baz via Object.const_missing # * fail with `doit': uninitialized constant Helper::Baz (NameError) end end module Foo class Bar class Baz end include Helper # this will try in order # * Foo::Bar::Helper via Foo::Bar.const_missing # * Foo::Helper via Foo.const_missing # * Helper via Object.const_missing end end Foo::Bar.new.doit Also might be worth a read: http://valve.github.io/blog/2013/10/26/constant-resolution-in-ruby/ I hope this is understandable :D
For new things may I highlight my little Blockchain! Blockchain! Blockchain! libraries and books: See the blockchain-lite, ledger-lite, merkletree, copycats, etc. libraries in ruby @ [openblockchains](https://github.com/openblockchains) and the yuki &amp; moto press book (free online) titled [programming cryptocurrencies and blockchains](http://yukimotopress.github.io/blockchains) in ruby - of course :-). 
It's because the constant lookup in the block is not resolving in the scope of Foo, but in the global object space. module Foo def self.const_missing(c) puts "#{__method__}(#{c.inspect})" const_set(c, Module.new) end def self.run &amp;block instance_eval &amp;block end end Foo.run do puts "&gt;&gt; undefined: Foo::Test" pp Foo::Test end puts Foo.run do puts "&gt;&gt; undefined: Test" pp Test end Output undefined: Foo::Test const_missing(:Test) Foo::Test undefined: Test const_missing.rb:23:in `block in &lt;main&gt;': uninitialized constant Test (NameError)
I don't know if they are yet (it came out less than two weeks ago), but I imagine they will be within several months. These days new MRI versions are generally pretty painless to upgrade to, and get adopted pretty quick. (and old ones are no longer supported pretty quick. Ruby 2.2 is already security-fix-only, and is planned to be completely unsupported by April. https://www.ruby-lang.org/en/news/2017/04/01/support-of-ruby-2-1-has-ended/) Someone at some point had been using some source of data to provide estimates of ruby version usage in the wild, but now I can't find it. 
As someone with Ruby and C# experience who is in the midst of the job interview process, Ruby is definitely not dead. There are a ton of companies in Boston that are committed to a Ruby/Rails tech stack and looking for developers with experience in Rails. 
I can't think of any reason this would be intended. It's pretty core to the purpose of migrations that they be idempotent, whether you run one at a time or all at once. It doesn't need docs if it's just a bug that should be fixed! Someone should probably file it as an issue on the rails github. I dunno if that will result in any action though. :(
To amplify what /u/kmaicher said, Grape is spectacular for doing pure API work. Add grape/entities and it just gets better. You don't even need to embed it in Rails; you can set it up as its own Rack middleware and build stuff without any of the overhead that Rails brings.
It’s not dead, it just doesn’t need to constantly shout it’s alive anymore. 
Thx for the link, will read. So if I understand correctly, the syntax I want is just not possible and I have to use `module` keyword to help me out? So either module Foo Bar.foo Bar.bar end or Foo.run do module Foo Bar.foo Bar.bar end end While not pretty, it seems to work: $ cat x.rb class TBar def foo pp 'foo' end def bar pp 'bar' end end module Foo @map = { :Bar =&gt; TBar.new } def self.const_missing(c) @map[c] end def self.method_missing(m, *args, &amp;block) @map[m] end def self.run &amp;block instance_eval &amp;block end end Foo.Bar.foo Foo.Bar.bar module Foo Bar.foo Bar.bar end Foo.run do module Foo Bar.foo Bar.bar end end $ ruby x.rb "foo" "bar" "foo" "bar" "foo" "bar" 
And it's not being touted as the "one size fits all" solution for every problem, which is probably a good thing.
https://github.com/rails/rails/issues/31692
Since this is the case, I think Ruby is nowhere near to being dead, and won't be for a long time Which I'm happy about, since I'm in school but really loving learning it as a side project more than the C++ we're learning in class
Did my usual monthly scan of the hacker news who's hiring for January. More rails jobs than I have seen in a while. Ruby had about 110 hits, javascript about 150 or so. Obviously not super accurate metrics, but interesting. I've been told it's because many have been fleeing the ruby/rails community leaving more opportunity. https://news.ycombinator.com/item?id=16052538 
Been there; done that... Windows with a Linux VM might be a solid solution if you need a wide range of software other than just pure dev. I've had some really super success with Hackintosh systems if you choose or build them properly. My problem is that I always need so many other apps due to multitasking that I can't just use a *nix system. I've been using Linux, FreeBSD, and others for over 20 years, but being able to run all of my other apps aside from dev has been the real keeper for me to stay on macOS. Heck, I'd like to see Apple replace the kernel with Linux, but c'est la vie. :s 
I think the main thing that you will find frustrations with is the hardware. Many PC companies have fairly junk quality hardware. I remember a lot of the early lenovo laptops had very questionable touchpads. The MSI laptops had some fairly crappy oversized ones that never worked well too. So your best bet is to find some hardware that feels good for you. You also want to take into consideration the hardware specs; CPU, Memory, Disk (SSD SATA or NVMe), GPU, etc. I wouldn't worry about the OS so much as you'll be able to use Windows 10 to do dev work (via Docker) or linux (Ubuntu, Fedora, etc). I think that you will find that the spit &amp; polish is missing on a lot of systems though. My personal favorite brands are ASUS -&gt; HP/Dell/Lenovo/MSI -&gt; Everything Else -&gt; Acer. Careful for U processors (similar to what's found in 13" MBPs. They are low voltage and usually don't have much bang for the buck. Also, don't expect the nice battery life from the PC. Almost all of this is subjective, but should be some things to think about when in the market for a new lappy.
I think it depends largely on the market. Here in PDX, .NET used to be the big hot thing 5+ years ago. Now Node is huge and Ruby is starting to make a come back, particularly for smaller and startup companies. Imo Ruby gets its popularity and infamy with Rails. When it was introduce, Rails was massive; ahead of its time. Now it is aging and generally slower than competing frameworks, especially in NodeJS land. I have a strong feeling that once Ruby 3.x is released, Ruby will have a huge resurgence in popularity. 
I'm trying to map multiple coclasses under one ruby module using win32ole; that I have working now but it's not really DRY since I have to repeat the module name (`Foo` in this example) with each COM call so I'm trying to figure out a way to allow leaving the module name out in the script using my module
I just want to caution you - and I think there was a post about this on /r/cscareerquestions recently - don't tie yourself down to one language. The more languages you know, you'll be more in demand on the job market and you'll get better at one language from working in others. The analogy I like to use is you're like a carpenter and different languages are like different types of wood. Birch or oak or pine are good for different things and you should know how to use them all.
How is performance without scipy/numpy?
I've not done a head to head comparison against a python implementation but I've not really focused on performance. It definitely won't perform as well as scikit-learn right now. For now I'm just hoping to build out more core functionality and will think more about performance when the time comes. Any input or contributions to performance are welcomed though.
Is there really a benefit to run LXC within KVM? Wouldn't it just be easier to run Docker on the Windows Host?
I hear you. I'm not the most experienced in Ruby, but I also feel like it is loosing ground. You don't find that many projects written in ruby, and somehow because of this reason, few do want to use it for new stuff. Despite that, I do use it daily to automate stuff I'm doing at work, but hey, it is only me.
Mobile is walled gardens. Almost all languages are second class here. Use what your overlords dictate. WebAssembly is here. It'll take a while but Ruby will play in this space. Ruby isn't going to be competing for comprehensive Math and GUI bindings anytime soon. For devops, tooling and services, I disagree with your assessment. Its wide use in this space is due to it comparing favorably with the alternatives.
Sadly If my automation project ever outgrows a certain number of files and lines of code I immediately start to think about re-working it in a different language. And even if it does not on a numerous cases I found myself rather installing powershell core on the nix boxes than ruby on Windows boxes.
I've had good results teaching beginners with https://rubymonk.com/ For Rails, https://www.railstutorial.org/book/ is the standard tutorial. I'm not really a fan of it when teaching experienced web developers as it's too basic. But then again if you're an experienced web developer, you should be able to get by using just the official guides at http://guides.rubyonrails.org/
Try Programming Ruby by Dave Thomas. It’s a tad outdated but still covers most of the language and it’s regarded as a classic now.
Perhaps not a very good metric but #ruby on freenode is almost always inactive. Ruby will likely always be my favorite language but I think many industries are choosing Python now where they might have chosen Ruby before. I think ruby really excels in small web micro services and I don't think any language comes close to the overall "developer happiness" of Ruby
Are you telling me that somebody wrote a text editor that has no external dependencies? 
No, as a matter of fact, I haven't said that. And, by the way, I don't know a single text editor that I need to either install in a docker container, or else need to make sure my version of ruby, java, or any other runtime is compatible with.. Let's turn this around. What conclusion would you have me draw? That the age of native executables and packaging is over, and that we can now distribute all software in docker containers? What assertion did I make that was incorrect? Is it my assertion that native executables are much more appropriate for distribution than script files, given the dependency that source code files have on a particular runtime that runs those scripts?
I would like to format it to something like this &gt; puts "#{k}: #{v}" displayes like &gt; lt_cdr: Data &gt; chief_engineer: LaForge &gt; doctor: Crusher
Have you heard of [Crystal](https://crystal-lang.org)? Sounds like it might be right up your street.
you can do GUI with jruby https://github.com/jruby/jrubyfx, I guess will be similar with truffle android: https://github.com/ruboto/ruboto rubymotion also. But, they are second citizen :)
Oh my gosh wow... All I had to do was call a .each on the a_ro_m saved hash. Your .each comment jogged my memory and more I feel dumb lol. I was trying to do it a really dumb way... I should also probably mention that I'm new to programming in general. Thank you for your help. 
I've recently changed hdd to ssd in my 5 years old Lenovo laptop with 8gb ram and so happy. Ubuntu + rubymine work perfect :)
Rails is the back bone of most startups. Ruby isn't going to die
&gt; If you release a package with ruby code in it, the ruby code must be compatible with the interpreter on the system. No it doesn't. There are multiple ways to ship your own version of ruby around. Get educated.
I use chruby every day. My users might not even know what ruby is. Are you going to tell them to get educated?
Lenovo Ubuntu done.
ruby-build, chruby.
`:ruby` 
Neat.
I used to be very happy with FreeBSD on T-series Thinkpads, but that was back when they were still IBM branded. 
Hokay: A Lenovo laptop with an i7, because it was the fastest thing I could buy with my budget. That includes adding an SSD and maxing out the RAM. Runs OpenSuse. The lights under the keys I find a bit silly, but overall this was one of my better purchases.
Which models are currently implemented?
Custom Linux desktop with Arch Linux, 10x happier than I was with Mac but it's not for everyone
I've been using Lenovo laptops with Ubuntu Linux for 9 years now. Before that I had a MacBook Pro but since nearly all the applications on macOS aren't quite that customizable and I found myself basically using applications written mainly for Linux I gave it up. I would recommend buying a Lenovo laptop (HP is find but not quite as good in my opinion, Dell XPS laptops would be an alternative) but stay away from the consumer models like the IdeaPad, go for the ThinkPad X/T/W series, depending on your needs. They are much sturdier and can take a beating, I regularly drag around my X230 via the display. A few years back the main problem with Lenovo laptops was the crappy display but that has changed. Nowadays you get high-resolution displays with a good build quality. The backlit keyboard is quite a nice feature if you are working in a dark environment. The chiclet style keyboards used currently are okay but not as good as the keyboards in models like the T410s. I personally don't use a touchpad on laptops (only once with the MacBook Pro) since the ThinkPad laptops come with the TrackPoint located between the keys G, H and B. Using that you are normally much faster because your hands never need to leave the home row. Precision use is no and scrolling is also supported by means of using the middle "mouse/touchpad" key located directly beneath the space bar. Also: Choose your laptop for your needs on the go! E.g. size, weight, battery runtime, etc. If you are at work or at home just buy yourself a docking station and use your 27" 2560x1440 monitor together with your favourite keyboard/mouse combination. Your eyes, hands, neck, shoulders and back will thank you.
I just use plain windows 10, because videogames and stuff. Works surprisingly well.
I'm just gonna say, the new XPS13 looks so sick, I am planning on getting one and putting Arch on it.
There is Russian saying, roughly translated as "it would not become sweeter in your mouth just from shouting 'sweet'". New startups mostly tend to use "new shiny things, ready for this year challenges". So they may lean to frontend-first and node.js, concurrency-first and Erlang/Elixir/Go, data-processing-first and Scala/Python, robotics-first and Go/Rust. What's Rails in a year when "some Rails rip-off" is present for virtually any language (if you go fast-prototyping-first)? 
If you already have experience with OOP languages, then [learnxiny](https://learnxinyminutes.com/docs/ruby/) is a great place to get an idea of general ruby syntax.
I never saw people writing "RUBY". But I always got sick when people write "LUA". It's "Lua", for **** sake!!!!
To print the version in ruby - you use :-) - it's a constant: puts RUBY_VERSION
The key thing missing from my comment is "successful" startups. I'm willing to bet the teams prototyping and transitioning software based on rails are doing so with much more long term success than the flavor of the month stacks. Just think, some one is trying to convince leadership they should rewrite their express/mongo app in elixir or phoenix etc. These stacks might have advantages to some degree but the disadvantage practically all of them face is they become harder to maintain as time and requirements grow. Rails has solved most problems and Ruby is easy to keep sane. When Ruby can no longer perform a specific task, good teams find the best technology that can fill that specific need and work it in along side their existing solutions. 
The only laptops I will purchase are thinkpads. Dell has shit service, and the only intriguing machine is the XPS 13 - until you touch the squishy keyboard that literally flexes while you type. I have never owned anything made by HP that didn't self destruct, or have some form of engineering oopsie that caused it to fail. ThinkPad / Debian / Windows dual-boot for school if necessary. I'm currently running the X220 I bought in 2011 with Debian. I will likely upgrade this year to an X1 Carbon or an x280. Or a t480. So many to choose from. Why Thinkpad? Generally good Linux compatibility. Drain holes in the keyboard. Tough as hell. Best keyboards in the business. Seriously, comparing Dell's to a Thinkpad is like comparing a Lexus to a Yugo. My machine has had two beers spilled on it (separate occasions) and has been literally run over. No issues whatsoever - since 2011. I know your question was about ruby, but IMHO, you can do ruby on anything. You will be less frustrated if you do it on a ThinkPad.
Thanks dNitza! I changed the name to http-stat
Awesome! I've never heard of that tool before. I took a look at the page, seems interesting
&gt; https://github.com/piotrmurach/tty Over 1,500 stars (O_O)
Wow, that's a lot of gems! I could have even used `pastel` instead of `colorize` in this gem
Well, the Ruby symbol for `200` would be `:ok`.
In my humble perspective we should to pursue the same direction Python went: being a high level tier above some blazing fast engine made in C. Tensorflow and Anaconda/pandas/numpy would be much more awesome in Ruby than in Python. Pure Ruby will always be slow and people will always complain about it.
I bought a second ssd for my gaming pc over the Christmas break and installed Ubuntu, been using it for dev for the last couple of weeks, I’m enjoying it for sure. Trying to get used to not using macOS as I also don’t want to upgrade my laptop, experimenting on what I already have though before buying a new laptop. Had to creep back to my 2014mbp this week though to work on an iOS app in swift, and our designers sometimes send me sketch files so I need a Mac hanging around for that.
I would be all for it considering there are all these: RUBY_COPYRIGHT # =&gt; "ruby - Copyright (C) 1993-2017 Yukihiro Matsumoto" RUBY_ENGINE # =&gt; "ruby" RUBY_PATCHLEVEL # =&gt; 0 RUBY_RELEASE_DATE # =&gt; "2017-12-25" (not even a Date object?) RUBY_VERSION # =&gt; "2.5.0" RUBY_DESCRIPTION # =&gt; "ruby 2.5.0p0 (2017-12-25 revision 61468) [x86_64-darwin13]" RUBY_ENGINE_VERSION # =&gt; "2.5.0" RUBY_PLATFORM # =&gt; "x86_64-darwin13" RUBY_REVISION # =&gt; 61468
Didn't really like it or see the benefit of it. Also for more complex queries Cypher can be a bit complex. I personally didn't see anything it could do that would be difficult to do in PG. Also the benefit of PG is hundreds of others have tried to do it before, and there are more docs/tuts/etc., whereas with Neo4j there's a lot less of that. YMMV and I certainly am not an expert or against it. I just didn't see the point of it on a project I worked on compared to PG.
I use chruby every day. What if the users I'm distributing my software to aren't ruby programmers? Or even programmers at all?
Neo4j and pg are very different dates stores. Neo4j is for graph data, meaning you not only care about the data but you also care about the connections and want them to have meaning. It's really useful for things like crm's where the connections to things have meaning. This is a very small niche of apps though. Most apps are better suited with pg.
Switched about a year ago to Debian + Thinkpad, and will never go back. I even was able to get the Thinkpad keyboard for my desktops.
Just taking a moment to comment that I love the set of gems you've made. I have a library that... honestly, probably doesn't do anything significant that is left out from your libraries, but, I almost always rewrite a quick console library as one of my pet projects. So, I try to keep abreast of what else exists. Your gems are definitely a source of inspiration and something I use in a lot of my projects.
Thanks for such a thoughtful response. I like the idea of detailed error classes. I definitely think I’ll go the route of having my own classes, inheriting from the appropriate class.
I suppose what I’m wondering is if the purpose of the library is to check the types of certain variables, and if it can’t do that because the type definition provided by the user is a nonsensical, isn’t raising a `SyntaxError`-like exception (whether of that class or descended from it) the most appropriate thing to do? I get that the typical thing Rubyists do is to write error handling that handles `StandardError`-like exceptions, but I guess I’m struggling to imagine the exception handling they’d write that would deal with this scenario in a way that would make sense.
I understand what you're saying, but the fact that ruby's SyntaxError does not descend from StandardError, I think makes it a bad idea. You pretty much never catch an actual SyntaxError (unless you're writing some kind of compiler or static code analyzer maybe?). There's not really any way to recover from it. A SyntaxError is always raised when the file with the syntax error is _loaded_, and means the entire file can't be interpreted as ruby. I don't think any of these things are true of your hypothetical exception. It does not mean the entire file can't be interpreted as ruby, it might be raised at a point later than initial read of of a file, and you might want to catch it. 
this. 
Thanks! I'm glad to hear there are others interested in having a machine learning package in Ruby. I work in a primarily Ruby organization and whenever we want to introduce a model into our apps we have to integrate with Python. I'm excited to make Ruby a viable language in the data science community.
I have used orientdb and neo4j in production, not as a primary source of truth (this was mysql). Some notes: * we found neo4j to be much more stable than orientdb * the ruby libraries for neo4j are generally much higher quality and have better support (I say this as an author of a ruby client for orientdb) * with orientdb's mvcc implementation, depending on your workload and whether you are using &gt;1 node for HA, you will frequently have to retry writes due to distributed transaction conflicts. We were never able to find write retry settings that "just worked". I have heard from someone with lots of "neo4j on ruby" experience as well that this can be a problem with neo4j * I believe that with ruby you will have a fair bit of query overhead due to communicating with the server over JSON. Not sure if there is binary protocol support for ruby neo4j client * Main takeaway: unless you have a really good reason to do it (we had query patterns that were extremely slow and expensive on mysql but very fast on orientdb), I would stick with pg. 
I think that the quite old “ruby programming language”, by Mats itself, is really deep and good for its pespective. Not free, and without any reference to Rails
Dykstra’s shortest path is a neo4j primitive. Try writing an equivalent method in sql. 
Thanks Justin, yeah I should have been more specific that I am using Cloudfront infront of my S3 files. I'll have to look into the invalidation logic.. thanks!
The only thing a community can definitely not do is fail to offer continued, open support. 
Out of curiosity, can you point to large companies deploying large scale python applications?
people often tend to lose sight of the server/client divide when talking about React. You can use React with a Ruby backend just like you can do with any other backend. 
Aren’t you missing the @bootstrap-sprockets in your application scss file? When doing the tutorial I also included the sprockets in the application.js
What does this do that Pundit doesn’t?
I used Neo4j with Ruby for many years. I am still technically listed as a co-maintainer of [Neo4j.rb](https://www.github.com/neo4jrb) but have not contributed much since sometime before the 8.0 release in August 2016. Since then, I've been working with Postgres full-time and only used Neo4j briefly for a POC project that was not pursued by my employer. My experience with Neo4j was mostly positive. Some pros: + The team working on Neo4j.rb are fantastic. Responsive, smart, helpful, dedicated. Brian uses it in professionally (I think some of the others do, too) and works hard to make sure that everyone has a good experience with it. I've never encountered another open source project that is as responsive. + The Neo4j.rb gem itself is excellent. If you like ActiveRecord, you should find it easy to pickup. It's easy to pickup and very flexible. + Cypher is a dream to write and read, IMO. It's deceptively powerful. I still prefer it to SQL. + Neo4j, the organization, are great. I worked closely with many of the folks behind the curtain and they're smart, dedicated people who really want to make an excellent product. + Data modeling and querying is so natural to begin with and then the Neo4j.rb library makes it even easier. I miss it all the time. Now, my cons, all stated with complete respect to everyone who works in these areas or disagrees: - Hot backup requires a paid license. To backup using the open source license, you must shutdown your database. - System requirements are steeper than PG. You'll probably need a beefier system to get adequate performance than you would with PG. - Limited options for hosting. You're either going to manage your own EC2 instance or you're going to pay a premium for Neo4j-as-a-Service. Postgres hosting, being a more competitive market, is simpler, cheaper, and more reliable. You'll find no shortage of tutorials on how to deal with Postgres, while Neo4j is a bit more sparse. - Performance isn't great until you have the kind of graphy problems that it excels at and a lot (A LOT!!!) of data. While you certainly can use it as a general DB, I don't think that it's worth it. - Deadlock during writes on busy servers are brutal. Maybe it's better now, but it was pretty hard to troubleshoot and embarrassing for me a few years ago. - Anti-RDBMS snobbery within the community was really tiresome. I was guilty of this for a long time, I drank the kool-aid right down. Same of Neo4j take every opportunity to trash JOIN and the rigidity of database schemas. I came to think it was an immature and inaccurate way to make the product look better. The last meetup I went to was mostly this and I never engaged with the community again. To everyone who had to endure me acting like this, I apologize. To answer your very specific questions: - Did you hit any drawbacks? Yes, I think that's covered above. - Did it help you solve your problem easier than using PG, for example? That's a bit more complicated. Data modeling was faster since I never had to worry about migrations. I think it was easier to do rapid prototypes and experiment with changes to my data model, especially at the very beginning of a project. Any pattern matching, recommendation engine-y things that I wanted to do were infinitely easier to reason about and implement in Neo4j than PG. (Someone who's an expert with SQL might contest some of this.) None of that, however, is on the roadmap for my current job and the prototyping and data model experimentation benefits had diminishing returns once our schema stabilized and I started to value performance predictability over flexibility. On the occasions that I still need schema flexibility, I just use JSONB columns in Postgres. So, in conclusion, I think it's an excellent product that comes with some baggage. If you're being told that your RDBMS is old technology that isn't intended to handle relational data, your schema is holding you back, and a graph is THE ANSWER for your modern data storage needs, I'd think long and hard. If you think you have an appropriate use case for it and are prepared to deal with that baggage, I think it's totally worthwhile.
Why do they need to be? You write your app. You install ruby into a subdirectory, you write a bash script to call your app with your own ruby using chruby. Your users just call the bash script. 
Mate, thanks so much for the extensive and helpful answer. Definitely 10/10.
thanks!
If if the users _did_ happen to have chruby, and their shell profile set environment variables that altered the behavior of the script, it wouldn't work. So the script would have to set all those environment variables before shelling out to `chruby`. And I'd have to essentially design a whole build system just for the package, to get `ruby-install` to place a compiled ruby inside the directory where I prepared the package. If I am using a Mac, and am building a .deb, I'll need to cross compile _ruby_, but that's fine, because there's a million resources out there that can help out with any issues that may arise. And whenever a security update for ruby is released, I've got to rebuild the package and get users to upgrade _my package_ because it has an entire runtime inside it. Really, the problems are just getting started. Without _tooling_ to do what you describe, it's not really a viable path. Technically possible, but you can also pick your nose with a jack hammer. So yeah, you're not going to convince me that building native executables isn't a worthwhile feature. I've never disputed that a language can survive without it (hell, ruby has for 20 years). And that's what makes this discussion so insane to me. You're trying to convince me that I'm wrong for desiring to have a feature that doesn't exist. With a liberal peppering of smarter-than-thou one-upsmanship, of course.
It's in production in several interesting places. Linux side is solid but they're rounding out the Windows stdlib. A lot of gems port (or have been ported) straight from Ruby. When they don't, somewhere in their code is a Nil exception waiting to happen. Tools and ecosystem - wasn't this post about new challenges?
Whilst certainly not dead, Ruby adoption is declining relative to its main competitors - Node.js and Python. Indeed.co.uk for London and modulecounts.com show a consistent 3:1 for Python:Ruby. The same is true for Node:Rails in the UK. My fear is that TruffleRuby and 3x3 will be too late to reverse the trend.
"The more languages you know ..." the less likely you'll know any one of them in depth. It takes years to really become expert in a language and I wonder whether learning, say, Python after Ruby is just a lot of wasted time given how similar they are. By all means learn JS for the front end, Python or Ruby for scripting and prototyping plus Golang for typesafe executables and speed. These are distinct realms. 
In lots of metrics Python:Ruby is now 3:1 or higher - indeed.co.uk, modulecounts.com, Stack Overflow.
Not sure what Data you’re storing but if it’s a json payload then maybe memcache might be a good fit. 
&gt;If if the users did happen to have chruby, It wouldn't matter. Your scripts sets the proper env variables before calling ruby and your code. &gt;So the script would have to set all those environment variables before shelling out to chruby. It wouldn't shell out to chruby. Chruby is just a script. &gt;And I'd have to essentially design a whole build system just for the package, to get ruby-install to place a compiled ruby inside the directory where I prepared the package. No you install it inside your app. &gt;If I am using a Mac, and am building a .deb, Why would you do such a silly thing. &gt;And whenever a security update for ruby is released, I've got to rebuild the package and get users to upgrade my package because it has an entire runtime inside it. Yup. Just like you'd need to recompile and repackage your app if there was a security issue. &gt;Really, the problems are just getting started. Without tooling to do what you describe, it's not really a viable path. Technically possible, but you can also pick your nose with a jack hammer. The tooling exists. &gt;So yeah, you're not going to convince me that building native executables isn't a worthwhile feature. I've never disputed that a language can survive without it (hell, ruby has for 20 years). I didn't think I could. You seem quite the zealot with your position. This if for the benefit of others not for you. 
&gt; These stacks might have advantages to some degree but the disadvantage practically all of them face is they become harder to maintain as time and requirements grow. Rails has solved most problems and Ruby is easy to keep sane. Every Rails app I've seen becomes harder to maintain over time. Most of Rails solutions outside of the web framework part have serious drawbacks. The ruby part makes it all worthwhile, though, IMO.
I too decided to learn Ruby because of Metasploit. As of Metasploit switching to another language, I don't think that will happen unless Ruby's development is stopped.
It sounds like you're making a personal choice to do something else. That's cool. You could make other choices, but if you're convinced alternately and you don't want to, then great. Find something you love doing and do that. I write a number of things in Ruby, because I enjoy writing code in Ruby. Really is that simple. If you're not getting that joy, than hopefully you'll find it elsewhere.
Aw yeah, that's so true, so true. At some point, we can even quit this IT sh*t and just support and hug each other and be nice, because, all in all, it is all about community, not about engineering, right? So, let's break all the discussions about future and evolution and tech with "SILENCE EVERYBODY COMMUNITY IS NICE".
Nah it's not a personal choice it's just the way things are. Also the job market in europe and in some other parts of asia for ruby are shrinking every day. I still use ruby for hobby projects but justifying to continue to do so becomes harder.
We just said the same thing. All systems get harder to maintain as they grow but Ruby's advantage is its much more pleasant to work with and reduces the mental lift required.
To the guy(s) who down-voted this: care to explain why? To the folks who up-voted this, *thanks!* Questions and discussion/suggestions either here or on the issue tracker. Thanks again!
Thanks a lot! That's great to hear! There is still many tty gems to be added so watch this space.
In my university days, machine learning, and specifically text processing was all done in Python due to its many libraries. Ruby pales in comparison, quite often the best solution being interfacing through JRuby with mature Java packages. I really feel there is so much stuff that could be developed in Ruby outside of the 'web development' realm and hence I'm really glad to see this gem! All the best!
Because, and perhaps this is my opinion, without a community, any language, hell any tech or tech philosophy, will die out. Ruby still has a strong core team working on it with contributions from the community - which features both old “tried and true” folks and new people coming in to contribute. Without that community, there wouldn’t be anyone to build houses for, regardless of the weather.
Sorry for the bad formatting, that is not how the code was actually formatted when I wrote it. It just came out that way when I posted it.
Ah, I see what you meant now. I thought you were saying the _other_ frameworks, but not rails, cause maintenance headaches down the road. Thanks for setting me straight!
Did you try to use four-spacing on the text? If you use 4, then 8, etc. for indentation the text is treated like code. Click edit and then the "formatting help" link to get details.
Your algorithm has a lot of low hanging fruit: 1. you don't need to check every number as even numbers can't be prime. 2. you only need to check up to the square root of the number. The easiest way to think about this is by example: Consider 49 (7*7). what happens to the answer when you compute 49/2=24, 49/3=16, 49/4=12… the quotient gets smaller, but it's still larger than the numerator. What happens what you consider numbers larger than 7? 49/8=6, 49/9=5… the quotient is getting smaller, but it's smaller than the numerator so you would have seen the pair of factors already when you were working your way up from 0. 3. if you're looking for the largest factor why not start at the biggest number you're going to consider and work down: stop when you find one? If I were going to write this I'd lean on Ruby's built in Prime method: require 'prime' SOME_NUMBER = 600_851_475_143 puts Prime.prime_division(SOME_NUMBER).last.first Presumably this is an exercise where you're supposed to find some of the improvements listed above, then read about [the Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) and implement it instead of just using Ruby's standard library.
Thank you. I've got a lot of work to do on my problem solving for sure. Working makes much more sense. I don't know why I didn't think of it. I've never heard of the Prime class so I'll definitely look into it though. 
Chris has a great response. A couple of notes: * unmanaged extensions are indeed great, though I think they're falling more out of favor now that it's possible to write your own stored procedures for Cypher. Unmanaged extensions required you to implement and hit a separate HTTP endpoint on the server, but stored procedures allow you to integrate custom logic with your queries. * Speaking of stored procedures, definitely check out APOC. It's a plugin for Neo4j that introduces lots of helper stored procedures (kind of like `ActiveSupport`) https://github.com/neo4j-contrib/neo4j-apoc-procedures * I think that performance has gotten better in the last few versions (though it still has some progress left)
Thank you, I'm a little rusty on ternary operators honestly, but this gets the solution lightning quick like I was hoping to do with mine. It's more clever than I'm used to writing code but I'll try to internalize the logic. 
It's always a personal choice. I get the reasons you're making the choice, and the perceptions you have. You feel it's too difficult to continue to make ends meet by continuing to do Ruby and because of the pressures you have in your life, you're making the correct choice for yourself. I suppose I'm blessed that both the perception professionally, and the job market in the U.S. and especially the Chicago area, are quite different in regards to Ruby. The value of small effective teams that can do more with Ruby and Rails exceeds the value offered by other languages in many cases. Professionally, people aren't quite hopping on the Ruby is dead train and they see the speed gains from 2.5 and further that are in the pipeline. So, the internet hype doesn't affect real business all that much.
Not sure this counts but I use a MBP hardware but i run elementaryOS linux on it. highly recommended, elementaryOS is a *beautiful* linux distribution, almost as pretty as OSX.
This is amazing and we are not worthy.
BTW the original post that I found this code is at : https://www.reddit.com/r/ruby/comments/7618ud/i_just_finished_my_first_ruby_program/
For a notebook/laptop, I'd recommend Lenovo. However, I use a custom desktop with Manjaro (Arch derivative) that works amazingly well. You can select your desktop environment (I went with i3-gaps). The Arch wiki and user repository are absolutely amazing.
Especially with the Ubuntu subsystem. Eliminates pretty much all headaches associated with Windows. 
&gt;If I was using EC2 instances, I would just write the URL to a local file. OK, if I understand right you're suggesting just putting a _filename_, not the data structure itself, in a local file. Implying you think reading from a local file is faster than reading from a db? Are you sure this is true? Just put the filename in the db (or even better, a redis instance key, esp if you already have redis), and do the same thing?
**If I were**
Are you using the right gemset? Have you run `bundle install`?
Is this downloadable in a mobile form?
Yes and yes :(
Check the openssl version you are using and try to get another version instead of compiling one.
Let's thank Gregory Brown for putting it all together and offering all articles under an open access (free license). Find the full archive -&gt; https://practicingruby.com 
you might want to look at net-ssh-telnet
&gt; I was hoping they For now it's just my humble self :-). The Yuki &amp; Moto Press bookshelf uses Octobook - see [/octobook](https://github.com/octobook) @ GitHub. The idea is to add more book themes over the next months - a book theme is really just a "regular" jekyll theme (e.g. with liquid templates). See [/book-2018-theme](https://github.com/octobook/book-2018-theme) for what gets used for now. Anyways, there's only so much I can do :-). Cheers. 
Cool, I hadn't heard of derailed_benchmarks before.
Thank you Paweł, lots of useful information in here!
Thanks, great to hear that
This was supposed to be here, but reddit on the phone put it as a separate comment: Because, and perhaps this is my opinion, without a community, any language, hell any tech or tech philosophy, will die out. Ruby still has a strong core team working on it with contributions from the community - which features both old “tried and true” folks and new people coming in to contribute. Without that community, there wouldn’t be anyone to build houses for, regardless of the weather.
Does it fail when you use the ssh command: `ssh user@host 'show version &amp;&amp; show version`? If not, do you seen anything interesting when you run with `:verbose =&gt; true`? Net::SSH.start(host, user, :keys =&gt; keys, :verbose =&gt; true) &gt; I now log in to every switch, give only one command, exit, log in again If `ssh` works, is it not possible to shell out to it: # stderr goes to process' stderr here output=`ssh user@host -o BatchMode=yes -i keys 'show version &amp;&amp; show version` process_output(output) if $?.success? 
To be honest...I've lost track to. What say we let bygones be bygones and maybe, should we ever meet, share a beer and shake hands?
Hi I'm a fairly new Rubyist and I followed through the guide, but when I reached the part when I packaged the gem and then installed, I couldn't get it to run. The equivalent to the line `steve@computer:~/src/how_i_start$ how_i_start` doesn't run when I install. Any thoughts to what I am missing? 
The thing that I didn't understand for a while about Neo4j: While it's not a perfect description, you can think of traversing nodes and relationships in Neo4j as traversing pointers. If your query can start with a node (or a subset of nodes) and be given a pattern to traverse outward, then it doesn't need to scan tables or indexes. It can just hop across the relationships to the other nodes and so on and so forth. This makes it really useful for querying on and aggregating from deep / complex relationships. And since you're exploring the local neighborhood of the graph, the query doesn't slow down as your database grows. You may say that you don't have those sort of deep / complex relationships, but what I've found is that sometimes (certainly not always) by using a graph database I find myself freer to model / query in cases where I might have compromised in a relational database. I realize that's perhaps not a very specific thing, but it's been something that I've been trying to put into words for a little while now. Of course, I use also Neo4j mostly because the data modeling is much more pleasant than a relational database. That's a fuzzier sort of thing to qualify, though. Yes, you can represent trees and other "graphy" structures or special use-cases (social networks/fraud detection/recommendation engines/access control/etc...) in a graph database and it can be really helpful for querying those things, but if you use Neo4j for a while you start to see that you just have a lot more flexibility / agility.
Another thing that I didn't understand for a while using Neo4j: Anything that people cite as being use cases for a graph DB (like the examples I gave above) you can totally do in a relational DB. But certain use-cases become more real-time with a graph DB. The example that I give for this is fraud detection. Of course you can have something that looks in your relational database for fraud rings and flags a new account as suspicions in an offline/background process, but the reason graph DBs are touted in this space is because you can often just do a single query when somebody requests an account and you can come back and deny that application immediately because you're just querying the local neighborhood of that person's connections to other people who might be sharing the same personal information which would indicate a fraud ring.
I uh, wrote this in 2014; I'm not sure why it's appearing here, exactly. Maybe something changed between then and now?
Can you expand on why please.
Ah ha! I had libssl1.0.0 installed but did not configure the path. Thank you so much! Had me stumped for a while. I'm now going need to fix a problem I'm having with Prax but that's an issue for another day I think. Rails S works for now. Thank you!
Agree on the "check that your model actually fit". We had one use case where switching from a RDMS to Neo4j did lead to an impressive performance win, but the model was very specific (representing a massive code base with thousands of programs calling each others) - Data was nodes &amp; edges with properties - Schema was flexible - Most queries were about path (find all nodes with relationship to a specific node, through one, two or twelve edges) This being said, I agree that most cases are better served with a RDBMS, and with the "popularity matter" aspect (more doc, more hosting options, more people with the skills, etc)
`&amp;&amp;` isn't a thing on cisco ios
Um can you update it..? It will be really useful to beginner Rubyists I bet. 
It's appearing in the Yuki &amp; Moto Press Bookshelf because it's a great free starter guide. Thanks for your great write-up on helping new rubies build a gem together. About the license if I may ask maybe you can agree on dropping the non-derivs clause so that the article can get updated e.g. for now it is Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [yukimotopress/auto/.../**hoe.md** (master → 4bd43e9)](https://github.com/yukimotopress/auto/blob/4bd43e96fa4572e6e14cb6ef76e14b84d1d77bc2/hoe.md) ---- 
Very cool! I noticed you used cmd/ctrl + click for multiple selections when replacing methods like `sprintf`. You could do this faster/more easily by highlighting an instance of `sprintf` and using cmd/ctrl + d to create multiple selections without clicking on each instance separately. 
Normally I would say yes, but I wrote this specifically for a site with that license. You should email them and ask if it's okay with them, if it is, it's okay with me.
As far as I know, everything should be working.
Yeah, absolutely agreed, though there's also a continuum between "business idea proof of concept" and "NASA mission" which require different risk tolerances.
Hey! Looks good, I try to run your app But I cant find any gems like 'active_support'( activesupport maybe), and 'yaml' on https://rubygems.org . -&gt; 'bundle install' doesnt work(
hmm... will do!
Thanks!, and yea .. that's why i said that "if that didn't work.. install them manualy" but i'll make it to a gem
Julia Evans ([b0rk](http://twitter.com/b0rk) on twitter) is doing a great job writing a profiler &amp; sharing what she learns. Can't wait to try the profiler out.
Funny, followed you on GitHub after you starred my binance gem, and here you are :P
Incorrect. That config tells Sidekiq to always check critical first because it is first in the list.
Right, didnt know sidekiq works like that without weights provided. 
:D
I did get it to work with some messing around, thanks for writing the guide!
&gt; Ecto is not an ORM That's not really true. &gt; schemas are used to map any data source into an Elixir struct That is literally the definition of an Object Relational Mapper
&gt; Ecto is not an ORM That's not really true. &gt; schemas are used to map any data source into an Elixir struct That is literally the definition of an Object Relational Mapper
To add to this: ActiveRecord is a design pattern, it just happens to be a gem bundled with Rails. While I'm not as familiar with the low-level ideologies of the pattern as, say, DHH, I don't see how these things really fit into the pattern. 
Regarding "validations use database constraints", there are some AR tools that help a bit with that, like [consistency_fail](https://github.com/trptcolin/consistency_fail#consistency-fail) and [active_record_doctor](https://github.com/gregnavis/active_record_doctor#active-record-doctor) and [nullalign](https://github.com/tcopeland/nullalign#nullalign) by yours truly.
I get that its named similarly to rake, but that name is really unaware of colloquial homonyms/terminology. Shovel, broom, trowel, scoop, shears, mower, pick-axe - these are all better names.
I've been experimenting with this for bulk updates. So far its working out pretty well. https://gist.github.com/hopsoft/32fb00998e68064def7b6c63f4fd484d
or just use sequel and never say you're sorry. 
Interesting, I've never seen that `with_options` construct ever! And I thought I had seen most parts of AR. Is it newish? Happen to know where it's documented?
It's actually not part of AR. It's an `ActiveSupport` thing (and one of the ugliest hacks in Rails if you ask me). http://api.rubyonrails.org/classes/Object.html#method-i-with_options
I'm not sure that I'm properly understanding your point, but if it's that the `activerecord` gem isn't really an implementation of the Active Record pattern, you're correct.
Ironically, internally we're much closer to an implementation of the data mapper pattern
The `with_options` is actually part of Active Support; it was [added in 2005](https://github.com/rails/rails/commit/85fe1ecaefe415ac1de36883f5f6162f49bd5287), so it was least since Rails 2. The AR part here is the context-sensitive [`on:` option](http://guides.rubyonrails.org/active_record_validations.html#on).
Yeah... it was kinda hard for me to think / talk / refactor and remember all the cool editor tricks... I am ashamed to say, I have not fully moved over from Sublime ;) but then again... I am on a lot of different editors... VI(m) mostly it seems... On the editor note... I moved over to mac as my main platform almost entirely to use the Textmate editor way back when... I was mainly using Linux and Windows when I had to... (have used mac since the earliest days tho) I loved watching Katrina Owens doing her refactors and just thought some folks would like to look over a shoulder for a while... and the code was not too intense or too small... just seemed like a good fit.
Bad design, IMO. You should *always* be able to use keyword arguments. In the rare case that specifically positional arguments are required, provide a method for it, like Person.pos_init(...).
https://github.com/rails/rails/pull/26206 -&gt; https://bugs.ruby-lang.org/issues/13683
I like it and have subscribed. 
&gt;&gt; schemas are used to map any data source into an Elixir struct &gt;That is literally the definition of an Object Relational Mapper It's the definition of a "mapper", but I'm not so sure about the "object" and "relational" parts.
weak
Rails-free zone is a nice twist, but it's be nice to see stuff that I didn't see X days earlier on Reddit, Lobster, etc... 
Ah nice thanks for the pointer /u/_matthewd.
Relation literally refers to the fact that you're working with an RBDMS. If you want to be pedantic about "object", this is the actual definition of an object in CS: &gt; In computer science, an object can be a variable, a data structure, a function, or a method, and as such, is a location in memory having a value and referenced by an identifier.
I see, sorry for nitpicking, just thought I should mention it! For those reading this, the video provides some very useful insight and is a very good how-to on refactoring Ruby. 
I didn't know that. I'm having trouble finding it in the spec, but I don't doubt that it's in there somewhere. If a byte is an object, then Haskell is OOP and we were already doing OOP in C before OOP even existed. It doesn't make any sense.
Object had a definition before class based OOP
finally. 
At this point it's legacy backwards compat. To ruby `SomeStruct.new(foo: 'bar')` would be indistinguishable from intending to pass _one_ hash arg `{foo: 'bar'}` in the first positional argument. But I agree Struct should have been designed differently from the start. People have been wanting keyword/hash initializer forever, which is why we finally got one as an option I guess.
The argument is that structs are just data, not objects, so they have no behavior. It's a repository data mapper, I guess?
&gt; Changesets They are super nice for a lot of reasons, but [AR does have validation contexts](http://guides.rubyonrails.org/active_record_validations.html#on) &gt; Validations use database constraints I do wish Rails would do more with this, but adding an extra check in the ecto changeset has fel about on-par with rescuing database exceptions and adding the error to the model in AR (admittedly the former being more elegant) &gt; Preloading After having used Ecto's preloading enough I actually think [AR is a lot more flexible here](http://blog.scoutapp.com/articles/2017/01/24/activerecord-includes-vs-joins-vs-preload-vs-eager_load-when-and-where) in terms of giving the user options to do what they need. &gt; Batch inserts Has been added for Postgres in the latest Rails beta, although they have existed for MySQL for a while. Better late than never I guess? &gt; Repo.one Nothing really like this in AR beyond `first!` which only raises for 0 results not more than 1. &gt; Ecto query language [Arel](https://github.com/rails/arel). Although the Rails team tries to dissuade you from using it, it's great even on it's own outside of Rails. Not meant as a rebuttal, just some added context. I love Elixir and Ecto. Great article!
Is it meant to do some things differently/better than [ruby-prof](https://github.com/ruby-prof/ruby-prof)? Or more of a learning experience for the author?
I actually never copied a link from RubyWeekly but frequently what comes on Tuesday here is repeated in Thursday in RW ;) As for Reddit, unfortunately it's my main source of information. I try to diversify, but it's hard.
I cant install manually, because "gem install active_support" and "gem install yaml" doesnt work neither. Because ERROR: Could not find a valid gem 'yaml' (&gt;= 0) in any repository
Did you look into http://rom-rb.org/? Ecto 2 is heavily inspired by it.
So, by your definition, `pg` gem is an ORM? :)
If I understand well, a core reason is to have a profiler that doesn't "live inside your process", but is instead an external tool. You can get more information here: * https://jvns.ca/blog/2017/12/02/taking-a-sabbatical-to-work-on-ruby-profiling-tools/ * https://jvns.ca/blog/2017/12/17/how-do-ruby---python-profilers-work-/
I was initially unhappy, too. But then I've thought better of it. As `Struct` is a generic "value object", initialization with regular argument CAN make sense (even if we forget about backward compatibility). Small value objects of 1-2-3 fields (like geometrical `Point`, or some `Name = Struct.new(:first, :last)`) is handier to instantiate with regular arguments. And, as the "ugly" part of the new API (explicit `keyword_arguments: true`) goes only to struct definition, and looks pretty informative (e.g. Rubyist who just missed this change in 2.5, can guess what it means and how it works), I now see it as a quite acceptable.
I love it! That's the kind of digests that are useful: a lot of personal comments and not a "those three things that were everywhere (Reddit, RubyFlow, all newsletters...) last week"! A small note: in Issue#2: &gt; ...Yuki Torii presented **his** custom build of Ruby, supporting pattern-matching. Yuki is _she_ is in fact: http://rubykaigi.org/2017/presentations/yotii23.html
nice, thanks. 
Aw... now it works! just run `bundle install`
TRU... ;)
You can also use (new in 5.1) `direct`/`resolve` to teach the router how to handle your form object directly: http://api.rubyonrails.org/classes/ActionDispatch/Routing/Mapper/CustomUrls.html / http://guides.rubyonrails.org/5_1_release_notes.html#direct-resolved-routes They're good for different use cases: `to_model` is perfect when your form object is a fairly straightforward presentation of a single model, and should be routed the same -- but `direct` gives you more power to route it differently.
nice. I haven't gotten to Rails 5.1 yet in any of my projects, but I'm excited by the new powerful routing-related APIs. Meanwhile, I'm really frustrated that in Rails 5 I have no good way to simply use ordinary ruby to override route helper methods to do what I want. What's behind `Rails.application.routes.url_helpers` is a tangled churny mess, and touching it at all is terrifying. 
A lot of rails internals is a nicely wrapped mess... I call it "shit in a candy wrapper".
That's basically the point of the new API. It's not just "here's a DSL because we don't want to let you write real ruby"... it's there to paper over things like the fact you need to define both a `foo_path` and a `foo_url` if you want it to feel like a "real" route helper. If it wasn't frustrating in older versions, we wouldn't've needed to add new API 😅, so yes, I can empathize.
Oh, I was totally prepared to define both a `foo_path` and a `foo_url`, that's not a big deal... it was just really unclear if there was even a way to reliably do this such that it would effect `Rails.application.routes.url_helpers`. It's easy enough to define some rails helper methods, even ones that override already existing route helpers (and can even call super!)... but that just effects things using the route helpers via the rails 'helpers' in views (or occasionally controllers). Not all the things that are directly using or `include`ing `Rails.application.routes.url_helpers`, because they need routes, but aren't part of a request-response action. Of which there are many. And using/include'ing `Rails.application.routes.url_helpers` seems to be the way to do that. And the thing behind `Rails.application.routes.url_helpers` is... weird. If there's just a module somewhere I could just `extend` or `prepend` on to, I didn't find it. Anyway, yeah, the new APIs were totally needed, and I'm looking forward to em. 
I have never heard Ecto 2 was inspired by ROM. Any source?
&gt; They are super nice for a lot of reasons, but AR does have validation contexts Validation contexts are not quite the same though. Once you have conditional validations and contexts, the DSL gets messy. With Ecto I solve it by composing functions. &gt; After having used Ecto's preloading enough I actually think AR is a lot more flexible here in terms of giving the user options to do what they need. Ecto supports "preload", "includes" and "joins". Just "eager load" is missing.
Quoting "ORM" on wikipedia: &gt; Object-relational mapping (ORM, O/RM, and O/R mapping tool) in computer science is a programming technique for converting data between incompatible type systems using object-oriented programming languages. Quoting "Object-oriented programming" on Wikipedia: &gt; Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods. If you have any source that refers to Objects in ORMs as the general term "Object", I would love to see it because all literature I am familiar with implies it is under the context of OOP.
&gt; Quoting "ORM" on wikipedia: On an article with a giant disclaimer saying "this article has serious problems", with a citation linking to the Hibernate website. ;)
&gt; Otherwise, everything that reads anything from a relational database is an ORM, and that's a not very helpful distinction, is it? For me the distinction is whether there's any intelligent mapping going on. An ORM actually does something based on the data structure you want out or based on the schema you're reading from (generally at the row level) whereas a driver only works for you at the column level
That's a great point but it doesn't necessarily invalidate all content on the page. I would still appreciate examples in the literature of ORMs where Object is used in a broad sense. Otherwise we will be basing our arguments on personal opinions that do not necessarily match the broader usage of the term.
http://diesel.rs/
https://github.com/alevy/postgresql-orm
&gt; Otherwise we will be basing our arguments on personal opinions At the end of the day that's all that most arguments about language are. My issue with statements like "This is not an ORM" is that it's usually because they're putting ORM into a very narrow and negative box, when the argument could just as easily be framed "This is a really awesome ORM that will make you think differently about what ORMs are capable of". I think that for most people, ORM means "A high level tool that I use to interact with the database", trying to avoid that label does a disservice
The only way to use httpd with Sinatra would if Sinatra supported fast-cgi which I don't think it does. Generally speaking, httpd is used more of a static file server than a reverse proxy. However, if you're set on using OpenBSD tools, relayd would be what you're looking for. 
You haven't explain anything about what Errbit does, just how to install it. What problems does it solve? Any examples? Why should i add this to my toolbelt? Also why are you suggesting that we should use our users as testers? That's just a recipe for a failed product.
&gt; super secure ... sending them packets of Ruby code to execute Seems like an unlikely combination of requirements. 
Closed network.
In your example, we have to go all the way down to the base case before we can start returning results up to the callers. Consider `range(1,2)`. On the first call, we say, "the output of this function is the output of `range(1,1)` with `1` appended it". Since we need to know the output of `range(1,1)` in order to resolve that statement, we evaluate it. Well, it turns out the output of `range(1,1)` is an empty array, so now we can return back up the call stack and substitute that in. Now we can say, "the output of `range(1,2)` is an empty array with `1` appended it", so it's `[1]`. What you might be missing out on is the `&lt;&lt;` operator. This operator appends an element to an array (it can do other things in other contexts, but let's keep it simple), so it's no particular mystery to someone who knows the syntax that the output of the function is an array.
&gt; ... hosted in AWS That implies it's going over the internet. I don't like being negative but you're combining practices (remote code execution) and technologies (IoT devices) over public networks, none of which are commonly considered super secure, individually. Wish I had more. You're in for a challenge, for sure. Good luck!
Yup. Start from `range(1,1)`. What do you get? `[]`. Okay, now how about `range(1,2)`? Well, you get `range(1,1) &lt;&lt; (2 - 1)`. And we know `range(1,1)` is `[]`, so that's `[] &lt;&lt; 1`. Etc. 
Instead of squeezing usage of small non-leaking gems, you may replace Puma with less greedy servers like Thin or Passenger. I've been battling the same issue and cut memory usage from ~512 to ~380 instantly. Equivalent config with 2 workers by 16 threads. 
For the big advantages are. I am big supporter of using cucumber for test from the outside in. Describing user interactions and expectations with the UI in a set of easily readable step makes my development life much easier. Translating business goals into tests is a huge win for our projects. Advantages (IMO): Reusable steps: A huge advantage over rspec, turnip, steak style functional tests. Signal to noise ratio: The goal of the test is far easier to express and later read than using code only tools. I introduced cucumber at my workplace while testing some complex interaction with a search filtering UI. A less technical colleague on my team who was was handling a lot of the business analysis was able to express the business logic of the search filtering very easily. I then created all the steps to automate them. This was a huge win and ultimate got the project over the line. It is however important to focus only on the tests that provide test valuable business cases and ensure good regression protection. Also using the page model pattern to avoid duplicating css selectors through your test code is very helpful. On another note, Cucumber 3 has done away with regexes in step definitions and replaced them with interpolated strings. I have only just begun to explore this new step format so I can't say much yet. Although it does appear be more manageable. Hope this helps.
So...why would I use this? What would I use this for
Thank you.
Ruby isn't dead and may even come charging back in 2018. The biggest hit against Ruby was performance and TruffleRuby will either put those concerns to bed or accentuate that performance wise its inherently flawed. What I do know is there is no reason for me to go anywhere right now. Not jumping away from one of the most productvie elegant langauges I have encountered in the very year that both TB and Crystal stand to make a big splash. Crystal might technically be another language but its so much like Ruby its almost like a different branch of Ruby (one which promises to do so much more than web apps). Others can go play with langauges that have nowehre near the ecosystem. I'll be building apps and getting to market. 
Yeah, for me "ORM" just means "high-level database library". Even if there is a proper definition of an ORM, I don't think I'd find it useful, because I don't see the point of categorizing libraries by whether they're ORMs. Making categories based on *design patterns*, on the other hand, makes much more sense to me.
You did a great job, thank you!
Thanks! It seems to be more of a case of authors exchanging ideas and helping improve each others projects. Which is really nice. :)
This is not really a framework problem. Sounds like more of a transport layer and trust problem. PKI is probably your best bet. You could go as far as using client certificate validation as well if you require that level of trust. Not sure if these IoT devices will come from known sources but you could also do some sort of ingress/egress rules at the network level using AWS security groups. 
Furthermore, security is done in layers. More thank likely your solution would require most work to be done below layer 7. So the web framework you choose should have no bearing on your security goals [except for web security problems like CSRF, XSS, replay attacks]
Did you read the introduction?
c'est fantastique! For more conference may I highlight the [Ruby Conferences and Camps in 2018 Calendar](https://planetruby.github.io/calendar/2018) @ Planet Ruby incl. Paris.rb XXL.
Since I've never heard about your "weekly" project until this post, you can drop the winking, ta ;-) It is curious that quite frequently people start up their own projects and see fit to drop in weird sly references to being better or different to what already exists in some way. It's churlish. Just get on with building things and let the work speak for itself.
It's pretty much always a bad idea from a security standpoint to create a setup where your clients must receive remote code and execute it. This, at minimum, can open you up to remote code execution or command injection vulnerabilities, which are severe. You should examine what you're trying to accomplish and come up with a new method. Is there a reason the clients can't store the code and execute it when called with proper authentication? source: I'm a security engineer with a ruby background.
I did. And it toils me what it does, but I still don't know what problem it's solving. Or, to be more specific, what causes that problem in the first place. Why do I need a security page? What is a security page?
The idea is that there is a simple web page with contact information at a well known URL containing information how to contact your security team in case someone has found a security issue with your website. Usually, you'd include here who to contact and how to reach them securely. Having such contact information readily available and at a common location helps security researchers (or generally people who have found a security issue with your web site) to reach the correct channels at your organisation to report these issues, thus increasing the likehood that you will learn about them in time or at all. At https://securitytxt.org/, you can learn more about the basic idea. As for the gem shown in the blog post, I think it's mostly superfluous for most apps. Just add a simple view at the right URL in your app with your security-team's contact information and you are fine. Be sure to keep it up-to-date though. 
Thank you! I appreciate the well-thought out response. Do you think having a separate security page makes sense for smaller organizations, or is it just for large companies really?
I think it makes sense for anybody. With a smaller site / organisation, there is a greater chance that you can also make the same information discoverable with a web page (that can then be actually found by someone trying to contact you). Also, with a smaller organisation, there is a bigger chance that a contact attempt will end with at the right people in any case, even without such a page. At the end, the point of all this is: make it easy for people who have found a security issue at your site to contact you and ensure that they end up with people at your org who will be able to correctly handle reported issues. If the reporting-process is easy, it is more likely you will learn about issues and people don't just give up frustrated by clueless first-level support. In addition to that, having a public dedicated security page with documented and thought-out procedures and dedicated contact channels shows me as a customer that you care about security and have organisational provisions to deal with security issues (which will occur, it's not a question of "if" but only of "when").
Just started a new job as a technical tester. Ruby is my weapon of choice, so that's what I am using. Also love Cucumber, so using that as well. Combining it with the parallel_test gem and a selenium grid is bloody awesome. Using Watir, Appium, REST, SOAP, and soon WinAppDriver, to drive test of almost every product we have. Organizing your tests in Cucumber using tags also makes great sense. I could go on 😊 I don't expect anyone from the business side to want to look at my feature files, but they would be welcome to do so. So I wouldn't hold it against you.
Interesting... in your code example this also works, but I see what you're getting at! x = [] x.push( y = 1 )
Because everything in Ruby is an expression, you can make the first example work by putting the two terms in parentheses, separated by a semicolon, thus: x = [] x.push( (y = 1; y) ) It's not the most readable, though. Mostly just useful as an insight into the way Ruby parses things!
Added to https://rubyland.news aggregator. 
That's a weird place to put a code block... I wonder if it's doing the equivalent of x.push(-&gt;{y=1;1}.call)
Finished chapter 3. Interested in any feedback. * Was this helpful or not? * I'm not happy with the look but if you have specifics it's appreciated. 
Subscribed! 
Im super-excited for this
&gt; x.push(if true &gt; y = 1 &gt; y &gt; end) Maybe a better example is needed cause it seems to me that this is where the ternary operator can be used: x = [] x.push( y = true ? 1 : nil ) 
I’m excited for this, but it’s been done before. There was the Ruby Hangout - https://m.youtube.com/channel/UCZKYKp38YY-hl5HlK1PRk1w
of course there are other facilities available, i'm just saying it's interesting that this is possible. 
Here's another interesting thing: rails [4.2.6] (rails426)$ def foo 1{ def bar 2{ 123 2{ end 1{ end =&gt; :foo rails [4.2.6] (rails426)$ foo.bar =&gt; 123 
Also subscribed. 
And then executing them.....
What was the result when you tried chartkick?
RemindMe! 20 days
I will be messaging you on [**2018-02-08 07:17:01 UTC**](http://www.wolframalpha.com/input/?i=2018-02-08 07:17:01 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/ruby/comments/7rd2ri/remote_ruby_a_monthly_online_ruby_meetup/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/ruby/comments/7rd2ri/remote_ruby_a_monthly_online_ruby_meetup/]%0A%0ARemindMe! 20 days) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Does this: ![](https://raw.githubusercontent.com/zverok/any_good/master/doc/example.png)
Sublime Text 3! If using WSL, make sure you install https://github.com/faustinoaq/crystal-windows-installer. Crystal's Sublime package is very nice, auto formats on save, etc.
Is it any good though?
¯\\\_(ツ)_/¯
But... why? So many cloud hosting options, why chose MS? Article would be much improved by addressing the advantages Azure has over other options. Off the top of my head, I can't think of any, but I admit I'm not well acquainted with Azure.
same here! see ya there.
Thanks for sharing! While it's a bit exotic, it's definitely something useful to share. As a sidenote, you can I think use the [sequel](https://github.com/jeremyevans/sequel) gem with SQLLite &amp; Ruby for more flexibility.
The items read: - #10 Learn Ruby Conventions - #9 Everything is an Object - #8 (Almost) Everything is a Message - #7 Ruby is Way More Dynamic Than You Expect - #6 Objects are Strongly Typed, Not Statically Typed - #5 Don't Worry About Interfaces - #4 Mix it up with Mix-ins - #3 Embrace Closures - #2 `ri` is Your Friend, `irb` is Your Other Friend - #1 Write Less Code - #0 Ruby Makes Programming Fun Again 
touché
Subscribed! What platform will the hangout take place?
Would be neat if it suggested alternatives/similar gems. Not sure how you would do this, since Ruby Toolbox (dead project) would be the closest thing to an API for that sort of data.
In Lisp, you do this all the time. Pretty convenient stuff; never used it in Ruby so I'm glad to see it's possible.
some folks might already be invested in Azure or they might work at a MS shop where most things are on MS platforms. I don’t feel every Azure related article should rehash comparisons with AWS or others.
[Awesome Ruby](https://github.com/markets/awesome-ruby) has a nice list. 
Although I have heard of, I have not used Sequel before. I will have a look. Thank you very much for your reply.
http://www.earthclassmail.com are scamming people.
It is a creative solution to a problem we don't really have any more
That's exactly the thing this gem is NOT for. That is not a challenge: you can't say that HTTP client with the latest release 2 weeks ago and 100k of downloads is in some way "better" than one which has 3 weeks and 80k. But, on any "final score", people WILL try to use it this way. Moreover, everything depends on you, and your needs and circumstances. Sometimes "fresh, but not widely used" is acceptable, sometimes "widely used and battle-tested, I don't care if it fresh" is a more reasonable approach. The only thin the gem does: it _assists_ in a quick first human decision about is it _any_ good (is there a point of at least giving it a chance).
Yes. So it is a magic trick relying on the unusual behavior of Ruby's top-level `main` context. Methods defined in `main` become instance methods of `Object`. Calling `foo` causes the definition of `bar` in `main`, after which *all* descendants of `Object` will respond to `bar`: foo #=&gt; :bar "anything".bar #=&gt; 123 Object.bar #=&gt; 123 Object.new.bar #=&gt; 123 BasicObject.new.bar #=&gt; NoMethodError 
https://ossert.evilmartians.io/
Really hope to attend this one! A good resource for future Ruby conferences is [http://rubyconferences.org/](http://rubyconferences.org/).
``` class Foo def ==(value) true end end a = Foo.new puts (a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3) # true ```
Yep, I am well aware of it... but, honestly, never used. The reasons are: 1. It is on web, and I constantly forget where is it (I am that lazy I become really angry when there are no link from GitHub repo to RubyGems page, and vice versa); 2. "Summary values" have not enough details for me, while "detalizations" have too much of them. What I tried to achieve (as explained [here](https://www.reddit.com/r/ruby/comments/7rgqbz/any_good_gem_quickcheck_if_some_gem_is_any_good/dsynrar/)) is not _judging_, but _assistance for a quick judgement_.
Easy. $arr = [1, 2, 3] def a $arr.shift end a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 # =&gt; true 
There are many ways to accomplish this. Here's one I think is easy to understand: class StupidInterviewQuestion def initialize @a = 0 end def ==(b) @a += 1 @a == b end end a = StupidInterviewQuestion.new puts (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) # =&gt; true
It looks like you either didn't install Gosu at all or you somehow installed a version that doesn't come with prebuilt binaries. What command did you use to install Gosu?
yeah thats what I meant
Try uninstalling the gem and reinstalling and then pasting the output from `gem install gosu` here.
Actually, never mind that other post. I found your issue: https://github.com/gosu/gosu/issues/427. Gosu is not compatible with Ruby 2.5.x. You will have to downgrade to 2.4.x or wait for the next release of Gosu.
I have tried that, and I just looked on the gosu github issues page and apparently you have to downgrade to Ruby 2.4.x to run gosu because it isn't supported on 2.5.0. How would I go about downgrading? Uninstalling and reinstalling?
Thanks for your help!
upvoted for the class name, made me chuckle :)
Or just define ` ==` to always return true.
Prompted by the [recent popular Stack Overflow question](https://stackoverflow.com/questions/48270127/can-a-1-a-2-a-3-ever-evaluate-to-true) about whether this is possible in JavaScript, I assume.
Well that's just cheating
I think you'll like it. I still use AR from Rails, cause for me it's too much friction to try to use something else in Rails where so much is built assuming AR. But from non-Rails, I choose Sequel every time. 
Yeah it's possible. Redefine the default == operator to return true for everything. Any language that lets you redefine basic syntactical stuff can produce *really* weird behavior. That's why some people don't like dynamic programming languages. In truth, whether that stuff is good or bad depends a *lot* on your team. If you've got a team of numbskulls dynamic languages can be a nightmare.
You can also just always return true - that does not need you to mess with idempotency.
Ruby doesn’t allow you to redefine any syntax - all its metaprogramming works with the same syntax.
There are levels at which an answer would work. With your logic, answering “everything is possible” is a valid answer. Tho possible, this requires to break a fundamental of math and computing. The sloutions we should be looking for shoukd focus on people and usefulness, and not wether how bad we are willing to go to get a job. But yeah, its possible. 
Willingness to crap all over math and programmign just to get the job dobe? I’m not going to judge an unknown person just for this, but I dont like ehat this question forces candidates to do. 
There is certainly fastcgi rack adapter exists. So it will be easy to run sinatra with fastcgi.
...since basically everything is metaprogrammable, it's the same thing. You can literally redefine the assignment operator (=) to *not* do an obvious assignment. You can create a monstrosity if you're not disciplined about what you're doing.
Yeah... If you're gonna do a dirty hack, you might as well make it a monkeypatched language-breaking dirty hack :-)
As you can see by the top comment, your analysis is false anyway. If a is a local variable, sure, but if a is a method, there are endless ways one could accomplish this without tweaking the == operation.
You say monstrosity, I say beautiful work of human creativity for a pet project.
I'm curious if there are any advantages to SuckerPunch over Rails' now-built-in `:async` job processing. They both do roughly the same thing.
It's kind of funny how in example 3 half of languages use Scala though Scala is not among languages used. 
`bootstrap-sprockets` should come before `bootstrap` in your `application.scss`. Also you shouldn't have `bootstrap` in your `application.js`, just `bootstrap-sprockets`. Don't think that will fix your issue though (it might) because in your screenshots bootstrap is definitely being loaded. 
The 10 One Liners to Impress Your Friends started as a Scala blog post (no longer online - there's a gist with all the Scala "originals" -&gt; https://gist.github.com/mkaz/d11f8f08719d6d27bab5 Will change the text in #3 to toot and "promote" mastodon. Cheers.
Haven't knew that (and I knew it I already forgotten). Could you put that somewhere in the post to remind it for people like me? ;)
Thanks!
&gt; range(1, 1000).reduce(0, Integer::sum); Ah Java, you've come so far. 
&gt; results = Nokogiri::XML(open("http://search.twitter.com/search.atom?&amp;amp;q=scala")) Better to not depend on 3rd party dependencies if you don't have to, I think: require "open-uri" require "rexml/document" results = REXML::Document.new(open("http://search.twitter.com/search.atom?&amp;amp;q=scala")) 
Half of the JavaScript ones could be solved with .map() ....
An old resource that folks may have forgotten or may not have been aware of. Be sure to checkout the homepage and other languages' sections. 
Yep! Just like the first one that is currently `??` could just be: `Array.from({ length: 10 }).map((_, i) =&gt; (i + 1) * 2);`
 you're totally missing the point. If you can break things like this you show a knowledge of the language. You then explain why this is a terrible idea. Broaden your horizons. We're paid to think, reason, and be creative. Think about why someone would ask this question and how it could happen. I am sure someone is inexperienced or reckless enough to do this. 
Coders like you make me wish hell were real. Have an up vote you evil bastard.
Knowing about failure modes is important.
I stand corrected on the overwriting argument. Still don’t like the question. 
You’re right. Its a sum of things: I don’t like these interview questions much, and got triggered by the defense of rewriting == just to make this happen. Stepping back and re thinking about what got me to write code to make an iffy sentence like that work is way more important to me than just making whatever to make it work. 
I really miss Jim and his wisdom. :/ If you haven't watched many of his talks, there are several available on ConFreaks. They're worth the time.
This guy is gansta.
 [501] inopinatus@ursula:~$ irb irb(main):001:0&gt; def ==(*); true; end =&gt; :== irb(main):002:0&gt; a = Object.new =&gt; #&lt;Object:0x00007fe7f2159af0&gt; irb(main):003:0&gt; (a==1 &amp;&amp; a==2 &amp;&amp; a==3) =&gt; true irb(main):004:0&gt; true == false =&gt; true 
Just (1..1000).sum with Ruby 2.5 [1] pry(main)&gt; (1..1000).to_a.sum =&gt; 500500 [2] pry(main)&gt; (1..1000).sum =&gt; 500500
Sorry to say, but can't find anything *"impressive"* about these examples. Notorious, trivial and some not even one-liners despite being declared so. Btw. Ruby's primes sieve #10 is quite unidiomatic with for/while loops. I'd expect something like 1st example in [Rosetta](https://rosettacode.org/wiki/Sieve_of_Eratosthenes#Ruby).
Thank *you* for saying so! I hope this helps other folks get started with Hanami!
I did not, so thanks for the links!
I appreciate the approach and the time taken but I don’t think this would be the best Ruby to write. As for returning a lambda, the syntax is just confusing if you’re coming back to it. Again, I understand this was a comparison and I appreciate you writing it. Good job. 
*thug life music plays* *cartoon glasses fly over to OP's eyes*
[Damn](https://lh4.googleusercontent.com/proxy/eVOmMp1Eu0YlKF6kEp1t4qvUdSqo72shqD3OVOva9PbI6LmvCB5wOxTH5jH2FR-0QqlZBtfMM190laNVV3PlUA-YdyZYoLJ1eRXGibE=w320-h180-nc)
Yes, that is true of SuckerPunch too, as the OP says too. 
Curious if you've had experience maintaining large projects in other languages that you've loved more. I have no opinion on whether this is likely or not, I've been mostly using ruby for some years now, I love it too. Back before ruby, I generally didn't love maintaining large projects written by other people in other languages either though, heh. 
In my opinion, it’s because it doesn’t try to get in your way of writing code.
i love it too! i was just talking about this with a co worker! i never get to use it at work (we do mostly java and python) and i wish i did because something about it just makes me happy
to me it only happens with ruby &amp; smalltalk coincidence?
The syntax and ability to easily write declarative, functional, or object-oriented code lets you write in the way you want where you want. There is so little ceremony and the high level of the language eliminates so much boilerplate. Java and C# seem painfully verbose and structured in comparison. Of course the downside is that large Ruby projects must maintain consistent conventions and implement thorough testing, otherwise they become incredibly painful to understand and unexpectedly fragile. 90% of the code I have written professionally over the past decade is Ruby, and I feel spoiled every day.
The article was originally posted (in 2011) to show off Scala to Java developers and - of course - in Java pre-v8 - it is unimaginable to do anything in one line ;-) In ruby or python or perl that's a daily routine / practice. You're right - nothing "impressive" if you can see beyond Java will rule the (enterprise) world etc. 
Thanks. Add to the page.
Thanks. Added to the page.
&gt; (1..1000).sum with Ruby 2.5 Thanks. Added to the page too.
Thanks. Added to the page too. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [yukimotopress/examples/.../**01-strings.md** (master → e1a363d)](https://github.com/yukimotopress/examples/blob/e1a363d9c0dd3e1b73c27938e0e897048c950673/01-strings.md) * [yukimotopress/examples/.../**02-numbers.md** (master → e1a363d)](https://github.com/yukimotopress/examples/blob/e1a363d9c0dd3e1b73c27938e0e897048c950673/02-numbers.md) ---- 
Ruby was written specifically to be pleasant to write in. I don't think that's true of any other popular programming language. 
Not a coincidence, Snalltalk was one of Matz's inspirations when he was designing Ruby.
The flipside of Ruby being fun to write is that it's fun for everyone in slightly different ways, resulting in a mash of coding styles. I have the joy of being one of a team maintaining a decade-old Rails monolith with about 50% test coverage and a succession of about thirty junior devs as previous maintainers. Most of the time, it works. When it doesn't, finding the problem can be a nightmare. Fixing it can be a month's work, and it tells you nothing about whether it still works until you have QA try everything they can think of and report that they didn't cause any exceptions, which is still only a 'maybe'. Ruby is a beautiful language, but I really wish it would punish beginners harder. It's so easy and fun to write crap code that 'works' that some people stay that level forever.
&gt; When it doesn't, finding the problem can be a nightmare. Fixing it can be a month's work, and it tells you nothing about whether it still works until you have QA try everything they can think of and report that they didn't cause any exceptions, which is still only a 'maybe'. Doesn't that argument apply to *any* large, "badly written/poorly tested" project?? It's certainly true that this can happen in ruby projects (I have first hand experience of that!). But I've also seen this happen in C++, Java, PHP, Python, JavaScript, ... &gt; Ruby is a beautiful language, but I really wish it would punish beginners harder. Beginners probably need to work alongside a skilled mid/senior-level developer, to get good habits. This applies to any language, in my opinion.
Check out [crystal](https://crystal-lang.org) it’s just as fun but more powerful!
i’m not familiar with rails anymore, but iirc, sucker punch syntax and usage might be very similar to sidekiq. so if you’re considering moving to an out of process queue one day, it might prove an easier switch if you start with sucker punch? same with if you are ever considering moving away from rails one day.
Ruby with the speed of C? Oh my
Yep! It’s pretty fantastic. Still young so obviously doesn’t have as huge of a community but people are working on it and it’s honestly a super enjoyable experience to work in. I did some benchmarks of doing a massive Postgres migration in a rails app with complicated joins and such and in ruby it was around 7hours where crystal was 1.5 - we’re talking millions of tables and such but it blew my mind at the speed. I’ve been writing micro services for heavy lifting with it and incorporating into my ruby apps to really get the feel and find its purpose and I am super impressed.
I've tried to code in Python and Go. I just can't warm up to either of these languages - their syntax, their structure, their idiosyncrasies. Last week I wrote a gem for company use from scratch after not having done much Ruby in nearly two years, and it was just enjoyable. I like Ruby's elegance and the way you can do thing with readable one-liners where other languages need five or six lines to do the same thing. 
If you want a functional language that is ruby'ish look at https://elixir-lang.org/
Don't get the Postgres comparison. Are you pulling data down and then mangling it in code? Because executing joins and stuff happens on the database, language that calls it doesn't matter.
I have a much easier time maintaining Java than Ruby or Python because the static typing and consistently forced object oriented nature makes it more straightforward to figure out types and where methods are defined. Obviously it’s possible to have terrible Java codebases that are a nightmare, but the average Java project I’ve worked on is miles better than the average Python or Ruby project that I’ve worked on. 
Maybe the bigger thing was related to DB caching? It can be really hard to benchmark code if it interacts with the DB. Anyway, not that I'm doubting improvements in speed by using Crystal, but this is definitely not the type of benchmark I would give too much weight to.
&gt; Of course the downside is that large Ruby projects must maintain consistent conventions and implement thorough testing, otherwise they become incredibly painful to understand and unexpectedly fragile. I do not know why Ruby is singled out here. I believe that it applies to all languages. ;)
I know how you feel. I "found" Ruby a few months ago and I've loved it ever since. 
&gt; error: sqlite3.h: No such file or directory You're trying to install the sqlite3 gem but you haven't installed the library the gem depends on. You can install it with `apt-get install sqlite3 libsqlite3-dev`
Adoption is growing quite quickly but agree we need more folks participating! It’s super exciting to be close to such a new language, so just keep spreading the word!
No, it was running off of a sql file locally for testing to ensure and test, it was impressive. Granted a DB maybe isn’t the best benchmark, but in my case it made sense and made a huge impact in speed. Especially the migration I was running but it was a good comparison between ruby and crystal in my case as I could easily benchmark it. The way I see it, it was a good IRL sample of “okay let’s see how this goes” and the results were impressive 
I think if you're using ActiveJob and sticking to ActiveJob API, it should probably be just the same to switch from :async (ie [ActiveJob::QueueAdapters::AsyncAdapter](http://api.rubyonrails.org/classes/ActiveJob/QueueAdapters/AsyncAdapter.html) ) to sidekiq as SuckerPunch to sidekiq. And you'd want to do that to be able to switch from suckerpunch to sidekiq easily too. 
I'd love to be able to support as many platforms as possible, but that's probably not surprising. I mainly use Windows (I know I know) so that's what I'd be targeting for now.
You can use RubyMotion on Mac (though RM is not really Ruby). You can also try things like Electron with Ruby (yeah I know it's an overkill). 
It's funny how we love Ruby but are waiting for perks that come from using Crystal :D. Crystal is not Ruby but we hope it will be.
Crystal is not ruby of course, but writing low level code in the syntax is great.
In my feelings, the sad answer is "most of the time, you don't". I don't see any active GUI projects currently. Ruby used to have `tk` as a part of standard library, which is kinda cool (it is exactly "GUI framework for scripting languages"), but AFAIK it is at least not installed with default `rvm` ruby distributions anymore (and probably not that well supported?) There was the cool [Shoes](http://shoesrb.com/) idea once, but I am not sure its current state: Shoes4 is rewritten to depend on Java/JRuby, and is in "hey it is preview stage" for years (though, it still seems to be actively developed). For something experimental I'd probably try [flammarion](https://github.com/zach-capalbo/flammarion) (UI is in electron/chrome, but it is not a web framework, just check it out!), and for something dull-yet-production-ready my best guess would be [fxruby](https://github.com/larskanis/fxruby)
Here's a sneak peek of /r/crystal_programming using the [top posts](https://np.reddit.com/r/crystal_programming/top/?sort=top&amp;t=year) of the year! \#1: [Crystal 0.24.1 is released](https://github.com/crystal-lang/crystal/releases/tag/v0.24.1) | [3 comments](https://np.reddit.com/r/crystal_programming/comments/7lvu8s/crystal_0241_is_released/) \#2: [Crystal 0.23 released!](https://github.com/crystal-lang/crystal/releases/tag/0.23.0) | [0 comments](https://np.reddit.com/r/crystal_programming/comments/6katow/crystal_023_released/) \#3: [Crystal has a new Website!](https://crystal-lang.org/) | [3 comments](https://np.reddit.com/r/crystal_programming/comments/617qeo/crystal_has_a_new_website/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
Thanks for the detailed response. I actually looked at Shoes just before making this post. It looks neat, but I was worried it looked almost *too* simple. Dull-yet-production-ready might be the best place to start actually. I will definitely look further into fxruby.
I write primarily in Ruby and Go. Once you get past Go's slight oddities (error handling took me a while to appreciate, and the weird `$GOPATH` stuff) it's actually a very nice language. It comes down to picking the right tool for the job. On my current project, I *need* something easily shippable/deployable; Go is definitely the right tool for this. Drop an executable file on a server, everything *just works*. Plus the static typing makes refactors slightly less-risky and my tests don't need to be *as comprehensive* as if I was writing in Ruby. When I'm contracting, I often have data to do imports, cleansing, munging and tasks that require text processing. Ruby is my goto language for this kind of thing because I can get something working very elegantly and quickly, and the standard library is excellent.
Most of the time when you see functions being passed to methods in Ruby, it's in the form of blocks rather than `Method` objects or procs: ``` def outer_function yield(10, 8, 3) * 15 end outer_function { |a, b, c| a + b + c } ``` That's not to say that the article is wrong. If the code runs, it's definitely not wrong. :-) But this is closer to what you'll see in the wild. We can still pass the block as a variable using the `&amp;` prefix: ``` def inner_method(a, b, c) a * a + 2 * b + c end outer_function { |a, b, c| inner_method(a, b, c) } # Explicit, passes args manually to the inner method outer_function(&amp;method(:inner_method)) # Same as the above line, but forwarding args happens implicitly # Same example, but with a proc instead of a method inner_proc = proc { |a, b, c| a * b + c } outer_function { |a, b, c| inner_proc.(a, b, c) } outer_function(&amp;inner_proc) ```
Could you give a concrete example of both application and test code? I'm having a hard time visualising your problem from the description you provided.
This is just an example to ilustrate the idea (I haven't even actually launched it, so I am sorry for all the mistakes). class Order::TotalCalculator def self.call(*args) new(*args).call end def initialize(order) self.order = Types.Instance(Order)[order] end def call if order.total &gt; 100 order.total else order.total + local_fee end end private attr_accessor :order def abroad_fee 20 end end require "rails_helper" RSpec.describe Order::TotalCalculator do let(:service) { described_class.new(order) } let(:order) { instance_double(Order) } before do allow(Order).to receive_messages(total: total) end describe "#call" do context "with small order" do let(:total) { 90 } it "adds shipment fee" do expect(service.call).to eq 110 end end context "with big order" do let(:total) { 105 } it "does not add shipment fee" do expect(service.call).to eq 105 end end end end 
I don't remember having to do this, but if I had to, my first impulse would be wrapping blocks into Procs and passing them as regular params. If all the blocks where "of similar importance" then I would wrap all of them. If one block "stands out as the main action" then I would leave that one as a block and pass the other(s) wrapped in Procs. That said, ideally a method should do only one thing. Having to pass more than 1 block to it seems to indicate your method is doing more than 1 thing at the same time. Consider splitting things up into smaller methods. 
Same here, it's my starting point and I'm grateful I started with it.
The language family lol
Loved the library when I first saw it (a couple of days ago, though) Got a question though What's up with the naming? As far as I understand, `Abilities` are basically the same as `Permissions`. However, the latter word is used a bit more frequently. What's the story behind the odd name? Or did I misunderstand the purpose of the Abilities?
Thanks for feedback &lt;3 About naming: hard question for me because I just thought that user has an ability for something, instead of permission. Not more :D If it confusing for someone I think we can rename it to `Permissions`
Two stabby procs? ```ruby vertical_split 5, top: -&gt; { header }, bottom: -&gt; { body } ```
This seems interesting, but the docs are leaving me a bit confused about how it works. In the example "Also, you can register more than one ability in one place and use string or symbol keys:", I don't understand how these ablities are triggered -- do PostAbilities and AdminAbilities somehow _both_ apply at once? Can you add to this example to show how you'd call the auth check, and what would be checked?
cancancan uses "ability" too, I think it's fine and I'd leave it. 
Yeah, I think that's what it is. There isn't really a way to pass two blocks, blocks are a special syntactic construct which only allows one. You could do one block and one proc arg; I'd probably just do two proc args to keep it consistent. Whether the proc arg is passed with a "stabby lambda" or not is up to the caller, but seems a good way to show it in examples. 
Totally agree. No need to change. Especially since a popular Ruby library uses the same glossary. 
I've been playing with [Ruby2d](http://www.ruby2d.com/) and it is active and promising. Worth a try.
How can it be a gem if there’s no gemspec?
If you can't find a way to make stubs + dry's type checking work, I would solve it in any of the following ways: * The type is too restrictive, maybe there's a way in `dry-types` to only check for "should respond to `total`"? * All you're really implementing is a pure function from `Order` to some number. So, this function could live in `Order` (next to `total`)? * Why not pass in the total instead of an `Order`? (e.g. `Order::TotalCalculator.call(2010)` - this would get rid of the entire `initialize` ceremony as well.)
I like this version, because of the expliziness, it uses the normal block, not lambda or proc syntax. But nevertheless the dsl version seems for me to be the best to read. Eventhough if would be not that short to implement.
Those are very good points, but this is just a simple, raw example. Imagine in a real application there would a bit more logic towards the final calculation, a few more methods would have to be called. This would easily justify the need to both pass the actual object and extract the logic to separate entity. Just checking if the passed instance has a valid type is obviously possible in pure ruby. Not only it's a bit more complex and less readable, but in the end, causes the exact same issues while stubbing.
Good question. See http://yukimotopress.github.io/gem-tasks
There's always more to learn, thanks
FWIW this is idiomatic Rails: respond_to do |format| format.html { redirect_to @thing, notice: "Updated" } format.json { head :no_content } format.js { head :no_content } end so your equivalent might be vertical_split(5) do |split| split.top { header } split.bottom { body } end 
Ruby is as appropriate as anything, but you are almost certainly under-estimating the difficulty of creating such software, especially as someone with no prior programming experience. I think it's going to be much much more challenging and time-consuming as you think. It's like asking "I've never really picked up a hammer before, but what kind of wood is best to build a garage?" I've never used C#, but I'm sure that would work too. Couldn't say which would be easier. 
I think you'll have an easier time with it using Rails as opposed to C#. There are several CRM gems out there that might work for you with Fat Free CRM being the most popular. It's actively being maintained.
This. It's hard to argue what is feasible given your lack of experience and seemingly tight deadline. Rails is well-documented and many people have built CRMs on top of it, so if you have time and effort, go for it. Don't discount solutions like Salesforce either. If you're not trying to build your own product, consider the cost of development and maintaining your own app, and not just the price of an existing solution. Building your own app isn't always the solution to the problem. 
I wouldn't go for C#, but you may want to look at Django. It's in Python, which was designed specifically to be easy to learn, and I have the vague impression Django apps end up scaling better than Ruby apps. 
it’s a small app for a local business. scaling won’t be an issue until you have thousands of users. ruby and python are both at the bottom o the performance pole, though ruby edges out python more and more. rails might indeed be a bigger hog but it’s friendlier for newbies who will want things to work magically. i’m personally more for explicit cod over magic though. 
Don't forget to link/credit PLEAC!
One could add a method missing method for the block to delegate the messages to the collector. This way you could also write the block in the style from above. What do you think?
bingo bango. self-entitlement is what is killing ruby (and Python, and Scala, and ...)
It's not really the PLEAC! The heroes are the authors that deserve the credit. 
Rails was originally abstracted out of the tools used to build the Basecamp project by 37Signals. Basecamp is precisely the sort of collaborative CRM software that you're talking about building, so I think Ruby/Rails is probably as good a choice as any if you want to go it alone. However, I would encourage you to look into something like Basecamp, instead of trying to build from scratch. Even what seems like a smallish application can get pretty overwhelming pretty quickly. I built a registration system for a small summer camp that I run, and it's at a point where I could really use some extra hands (my test coverage is abysmal, I have features I'd like but don't have time to build, I have bugs that I need to squish and don't have time to deal with). I wind up spending more time each year on fixing weird little problems, rather than growing things out. I'm not saying that what you want to do isn't possible, but even with something as easy-to-learn and straightforward as Ruby and Rails, it's a challenge. And there are pre-made solutions that might be better suited to your needs. 
A note of warning, do not build types on the fly. Types are stateless and their construction takes time, assign them to constants and reuse.
On a gem's page, at a very bottom right corner, "reverse dependencies". Example: https://rubygems.org/gems/sequel/reverse_dependencies
Argh! That's so obvious. Thanks, I looked all for this, even stumbled on a blog post where a guy wrote a script to solve this problem and then said "this doesn't work any more".
TBH, I found this myself, like, half a year ago, after 10+ years of Ruby experience (maybe it is a new feature of rubygems.org?). Used VersionEye (now deceased) before for that task.
Thank you very much for your reply and comments. I have added a small section about "yield" and how more common it is when one has only one function-as-argument to pass. If we want to use more than one then "yield" wouldn't work. Am I wrong? Thank you very much again.
You're not wrong, Walter, you're just an asshole.
I've been working on a personal project and realized I had broken out a piece of utility functionality that might be useful to others. I haven't put together a real gem before, and thought this would be a worthwhile project. `rack-params` provides a DSL for type coercion and validation of hash values. For example: def some_action(values) result = validate(values) do param :id, Integer, required: true param :title, String, required: true param :created_at, DateTime param :tags, Array, sep: " " do every Symbol end param :content, Hash do param :headline, String, required: true param :body, String end end fail unless result.valid? fail unless result["tags"]["content"]["headline"] == "Something" end It also provides a mixin for the case of using a framework within Rack that provides `#request`, which overrides `#params` and allows `#validate` to not take a separate values parameter. get "/" do validate do param :id, Integer end params.valid? params.errors["id"] end Any sort of code review, thoughts, etc. would be rad, especially around testing and the readme - I'm working on beefing up the RDoc now. Thanks!
 Awesome, have you considered performance?
I Love it too! There is something in Ruby that every one loves.
Yup, hope it will get enough traction.
Reminds me of the schema/validation from http://dry-rb.org/gems/dry-validation/
Oh, man, I hadn't seen `dry-rb` before. These look pretty sweet, I'll check them out, thanks! Cheers!
Gluck! Side note: One time, I built most of ActiveRecord::Enum and showed a friend, then he sent me the link to it hahah.
Someone asked why (and then deleted their comment :/), but I wanted to throw this out: We've all been in a place where there's something established that might do a thing better, but I'm pretty committed to the project this came from being 100% mine from top to bottom, since it has exactly 1 real user, and I'm feeling like more of a plumber than an engineer lately. Thanks for taking the time, and if anyone gets a chance to dig into the code and find something you want to yell at me about, please do! You only get better when you ask...
Nice job! The Rails free approach is greatly appreciated. Ruby is so much more than the single web framework that made it so popular. 
Site doesn't load for me. Not sure if it's on there or not but I recommend https://www.schneems.com ;) 
I'm curious if Jruby can use graal and have same speed. Any way, I guess this is one of the great hopes for speed for ruby. 
It's called the "standard library" and it is shipped with Ruby by default. Here's a list of all the things [1] which are part of the standard library: https://ruby-doc.org/stdlib-2.5.0/ [1] modules? files? libraries? not sure what the correct term is.
That was a super confusing thing about rdoc when I first started: trying to grok what's a file, what's a module and why I would want to navigate via one or the other.
Finished Chapter 4 of Effective Testing. Starting out with a Test File and using it as a base of operations was new. I think I like it. It reduces the cognitive load of where I am going and what I am doing. I appreciate any feedback.
I know what you mean. In many languages a file is tightly coupled to some other language construct: module in Haskell, class in Java, ... Not so in Ruby: requiring a file can potentially introduce any (and multiple) constants (module, class, value, ...) into your code. You can only hope library authors don't abuse this freedom too much.
is anywhere documented which ones are required by default?
I would recommend reading the documentation for Enumerable, Array, and Hash all the way through. Another good thing to do is read the source code of some widely used gems - try to understand the techniques that don’t immediately make sense to you. You’re not reading for comprehension, just to look for pieces of code you don’t understand. Each of these can be a small research project. This will get you used to reading other people’s code, start to build your sense of what code should/could look like, and demystify what important, successful programmers are doing. Along the same lines do something like setting up a project using some of the technologies your next employer will be using on your home computer. Get good at googling obscure errors!
A reminder, just to be safe: "TruffleRuby is progressing fast but is currently probably not ready for you to try running your full Ruby application on. Support for critical C extensions such as OpenSSL and Nokogiri is missing. TruffleRuby is ready for experimentation and curious end-users to try on their gems and smaller applications."
In order: http://ruby-doc.org/core-2.5.0/doc/keywords_rdoc.html http://ruby-doc.org/core-2.5.0/doc/syntax/precedence_rdoc.html http://ruby-doc.org/core-2.5.0/doc/syntax/methods_rdoc.html http://ruby-doc.org/core-2.5.0/doc/syntax/modules_and_classes_rdoc.html http://ruby-doc.org/core-2.5.0/doc/syntax/exceptions_rdoc.html http://guides.rubyonrails.org/ https://relishapp.com/rspec/ http://ruby-doc.org/core-2.5.0/Array.html http://ruby-doc.org/core-2.5.0/Hash.html http://ruby-doc.org/core-2.5.0/Enumerable.html http://ruby-doc.org/core-2.5.0/File.html http://ruby-doc.org/stdlib-2.5.0/libdoc/json/rdoc/JSON.html http://ruby-doc.org/stdlib-2.5.0/libdoc/net/http/rdoc/Net/HTTP.html Ultimately you should know this stuff very well. 
Easy, first get the == operand then change the receiver require 'continuation' def a callcc do |c| Object.new.tap do |o| o.define_singleton_method(:==) do |other| c.call(other) end end end end puts a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 # true TMTOWTDI, override == method by Refinements a = :hi using Module.new { refine(a.class) { def ==(*); true; end } } puts a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 # true And another one f = Fiber.new do Fiber.yield 1 Fiber.yield 2 Fiber.yield 3 end define_method(:a) do f.resume end puts a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 # true and one more e = Enumerator.new { |y| y &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 } define_method(:a) do e.next end puts a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 # true
"corelib" is required by default. "stdlib" is not, thus the distinction between the two despite the fact that they both ship with Ruby.
Quite interesting. &gt; The difference between fir and a repl like pry (or most others) is that fir parses the syntax and re-renders the screen every time it receives a key input...since every keystroke triggers a loop and a full re-render, we can continuously update the screen with new indents, suggestions, and in the future, colorization. The article is written as if Pry cannot do auto-indent/dedent, but it's had this feature for years. Further, with the correct plugin (`pry-cooline`) it also auto-colors input with every key stroke. See here, code is both correctly indented on input and the text is colored *as you type it*: http://recordit.co/cwJKuFWfAk
There is an online book that I have been having a good time using recently called Bastards Book of Ruby. Ruby.bastardsbook.com I needed something light after finishing The Well Grounded Rubyist.
Yes, this is a good point. I usually build types in types.rb and then refer to the constant. In this case, I didn't want to pollute already complex example with yet another file. Anyway, do you have an idea how to cleanly stub the types?
I’m glad I thought to come back; you’re right that this is the better solution. 
Haven't heard of Raiks 😐
It is indeed poorly documented, alas. 
I think that's what you get when you `bin/rake` `bin/rails` over the coals, but I've been Rails-free for a year and a half 😜
rubygems is one of a few magical gems that is physically a separate gem/codebase but is auto-required also, like core.
to provide some context Cosmos DB is product from Microsoft Azure (with some similarities to AWS Dynamo DB ) ...Cosmos supports several types of API to communicate http://www.eq8.eu/tils/40-connect-ruby-on-rails-app-to-azure-cosmos-db-with-mongoid-gem ...but the nice thing for Rails developers is that you can just use Mongo API =&gt; use Mongo Mapper or Mongoid . But getting the connection on was bit tricky, that's why this TIL note
is there a reason you recommend minitest over rspec? I've mainly used rspec over the past 4 yearsa, but had to pick up minitest for my current job. I prefer rspec, but i suppose like many things it's possibly bbecause i learned it first
The best tutorial is Facebook APIs official docs. They explain everything on tokens and auth pretty clearly. Start from here: https://developers.facebook.com/docs/graph-api, then apply the knowledge to koala :)