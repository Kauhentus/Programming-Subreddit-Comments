Huh, was totally prepared to talk about how wrong-headed this is etc. but it (Thankfully) not what I expected. Quite a funky idea.
A great point. Don't fix what ain't broken.
Using `to_set.subset?` implementation is `n(log n)` complexity, comparing two arrays directly with `include?` is `n^2` complexity. For large arrays, the difference is huge. You can also do `(input.chars - array).none?` (array subtract) or `input_chars = input.chars; array &amp; input_chars == input_chars` (array intersect), it's the same complexity as `to_set` and thus grow at the same rate, albeit with somewhat different constant factors. Which you chose (`to_set.subset?` vs array intersect/subtract) should depend on whether you expect to compare a given input once (thus spending more time on building the initial set and thus not worth to build a set) or many times (where comparison cost outweighs the set build cost, `to_set` wins).
Missing information: What is @socket?
 (input.split('').uniq &amp; array_of_letters_allowed).length == input.length
Neat tool for solo projects! The code that it enables is a little too "magical" for professional/enterprisey work, IMHO. I also feel like automatically naming and assigning the "result" variable is an answer in search of a question. If I'm working with multiple requests, now I have to add code to *reassign* the responses to distinctly meaningful names. Ie: &gt; http://API.sourceone.com/people &gt; &gt; source_one_result = result &gt; &gt; http://API.sourcetwo.com/people &gt; &gt; source_two_result = result 
Text of [a comment](https://github.com/undercase/proof/issues/2#issuecomment-205273800) I left on the issue /u/Freeky opened: ---- &gt; A MAC "accepts as input a secret key and an arbitrary-length message to be authenticated, and outputs a MAC (sometimes known as a tag). The MAC value protects both a message's data in&amp;shy;tegrity as well as its authenticity, by allowing verifiers (who also possess the secret key) to detect any changes to the message content.". It's "sometimes called a keyed (cryptographic) hash function (however, cryptographic hash function is only one of the possible ways to generate MACs)". This is basic enough to be in the Wikipedia article on [*Message authentication code*](https://en.wikipedia.org/wiki/Message_authentication_code); anyone who's had any professional involvement with crypto and/&amp;shy;or secure comms, including the people who taught me on-the-job 30 years ago, take this to be nearly as basic as "two plus two equals four". &gt; &gt; It *does not* encrypt the message itself and it's not possible to produce original plaintext given only an HMAC token; the token ac&amp;shy;companies the payload it was generated from (and then signed). Anyone else *who has the secret key which was used to generate the HMAC* may gener&amp;shy;ate an HMAC using the claimed algorithm from the claimed content and claimed secret key; if the new HMAC mat&amp;shy;ches that in the token, then the "claimed" qualifier drops off the message and sender/signer. &gt; &gt; Naturally, therefore, one needs to send the payload (in the form in which it was signed, usually cleartext) along with *but separately from* the HMAC signature; this is typically accomplished by encod&amp;shy;ing the latter in, say, an email header, where the email body con&amp;shy;tains the plaintext being signed. It's good practice to sign and authenticate attachments separately; the system that we develop&amp;shy;ed back in the day would en&amp;shy;crypt and sign the attachments, and add the manifest to a MIME-Multipart message (this was *long* be&amp;shy;fore [RFC 2015](https://tools.ietf.org/html/rfc2015), let alone [RFC 3156](https://tools.ietf.org/html/rfc3156)). &gt; &gt; You have what looks to be some good code here; shame that you're either misrepresenting it or, more charitably, misunderstanding its basic purpose. And it's already generated [a response](https://github.com/undercase/proof/issues/2#issuecomment-205276542): &gt; You're right. I have used "encryption" too broadly in the documentation. This is not a security flaw in the library, as all that is needed for authentication is signing, but I will fix the language issue. I never claimed it was a security flaw, merely that it's orthogonal to what most people think of as "secure message transfer", which involves encrypting the plaintext. I'm glad to see that he's going to work on the wording, though. 
If you are truly closing out program A while program B is blocked on a `write` call, I would expect a "connection reset by peer" error, which happens when a TCP stack abruptly closes a connection and sends an RST (for "reset") packet. However, it's actually tough to be sure that program B was truly waiting for `write` when program A shut down without detailed logging. That logging has to take into account that writing out to `$stdout`also introduces some uncertainty -- you want to buffer the log messages in an array and dump out the whole telemetry package at the end. Finally, it's possible that ruby's internal buffering may be muddying the waters; try setting `socket.sync = true` (or checking to see if it is currently `false`).
Actually that's my mistake: The Errno::ETIMEDOUT actually happens during the process of trying to receive data although it only happens after at least one write has been done *after* forcefully closing the game's process. In other words, that hopeless read doesn't appear to time out unless a write is also attempted.
ahhh thank you so much!!
I feel what the author was doing is just caching. I see memoization as caching results against the set of input parameters. So if you lookup the results of a prior computation using its parameters, that comes closer to memoization for me.
I'm actually pretty sure this is meant to be a joke. At least I hope so.
I've [written about the topic before](http://gavinmiller.io/2013/advanced-memoization-in-ruby/) and my basic conclusion was: once you start memoizing parameterized methods you're effectively caching, so use a cache. I'd argue that's where the flipping point between memoiziation and cache is.
Yep. Easier to just execute parameterized queries and let the SQL engine handle it.
Yep! Get rid of the line that says just "@order" in the final_order method and you should pass that part of the tests. You probably also need to add the gifts. something like (@order - OUT_OF_STOCK_ITEMS) + GIFT_ITEMS would work.
Not only `@order` hasn't been modified, but unless implemented, two Item.new(:thing) won't `eql?`
Depends if the attributes are accessible or not. If they are then object.subject + object.normal will do it. Look up attr_accessor or attr_reader
If the class has accesor methods for those variables it would be as easy as: va = VisualAcuity.new x = va.subject if not you could use `instance_variable_get()` on the object like so: x = va.instance_variable_get('@subject') 
`object.inspect.scan(/subject=([^,]*)/).first.first.to_i` FTFY
Big O is meaningless in this problem, the array isn't going to be larger than a few hundred elements at absolute most, 52 elements would be the entire english alphabet. That is no where near large enough for growth to dominate constant factors for data of this sort. As is often the case the fastest solution is likely to be the one that causes the fewest CPU cache misses / packs into the fewest cache lines. 
Thanks all. I have this code : class VisualAcuity attr_reader :subject def initialize(subject, normal) @subject = subject @normal = normal end def self.can_drive? (@subject / @normal) &gt;= 0.5 end end class DrivingLicenseAuthority def initialize(name, age, visual_acuity) @name = name @visual_acuity = visual_acuity @age = age end def valid_for_license? VisualAcuity.can_drive? @age &gt;= 18 end def verdict if valid_for_license? "#{@name} can be granted driving license" else "#{@name} cannot be granted driving license" end end end Where I see this error message : undefined method `/' for nil:NilClass which is becoming because @subject is nill in the self.can_drive? function. I did that by putting a p @subject there. I know that @visual_acuity is containing this : #&lt;VisualAcuity:0x000000033998f8 @subject=20, @normal=20&gt; so I try to find a way to get the @subject to the can_drive? function THe whole challenge can be found here : https://rubymonk.com/learning/books/4-ruby-primer-ascent/chapters/50-debugging/lessons/119-the-debugging-primaries last exercise from that page 
No way to know the API of the object from it's `inspect` output, you need it's documentation or source code. Sure, there are ways to pry the value of the instance variable out, but those are extreme measures that won't serve you well to build reliable or maintainable software. You need the docs or source code, not just the `inspect` output. 
Why is can_drive? a class method?
yes. as you can see in the code can_drive? is a class method of the VisualAcuity. I need to use this function in the DrivingLicenseAuthority class
Hi! I saw couple of possible mistakes in code you posted. First, you don't need *self* in the code below, considering you operate with instance variables. def self.can_drive? (@subject / @normal) &gt;= 0.5 end So try the following: def can_drive? (@subject / @normal) &gt;= 0.5 end Second, this probably won't work as expected: def valid_for_license? VisualAcuity.can_drive? @age &gt;= 18 end In the end this method just checks that *@age* is greater or equals 18. Try to change it like so: def valid_for_license? @visual_acuity.can_drive? &amp;&amp; @age &gt;= 18 end Hope this helps.
Yes. That's true. You pass it as third parameter on *DrivingLicenseAuthority* initialization. In example: DrivingLicenseAuthority.new('John', 21, VisualAcuity.new(20, 20))
oke, then there is where my thinking took the wrong turn. I assumed after looking with p it's onyly contains the variables. Thanks, lessons learned
There is also a way to do this with just rubygems. You can add your local project to your gem path: export GEM_PATH=/u/tall-guy/library:$GEM_PATH That can go in e.g. a bashrc. This has the advantage of not having to change one of your project files. Of course, if you do use Bundler, you'll find that it severely overrides your rubygems environment (and I have no idea if setting `GEM_PATH` will even work in that case).
I do use bundler on the project layer, but I will check this out. Maybe GEM_PATH still works, thanks!
You're exactly right. Writing your own auth gets you into situations like this that you don't even realize. In this particular case, they hadn't rolled their own auth, just added an extra "feature". Seems trivial until examined!
thanks, that is exactly what I wanted. I did dig through the code and find it myself a few days ago. The message reads like it is BOND that failed, not the test, IMO. Thanks for the email address, if I have further questions, I"ll use it, but as of right now, I am using Bond and liking it.
No, you can not. Because the gemspec file is meant for actually building the gem package to deliver to users, and someone downstream using your gem can't find another gem at a certain path on your local workstation. 
Interesting. Didn't know there were GTK bindings for Ruby.
Yes, I see what you mean. That's because we are doing it wrong. Using gems as a way to publish ruby code between layers - instead of a closed API.
You can use gems for solely internal code sharing, no problem, gems don't have to be public. But yeah, if you are using gems in such a way that, in production, you want them to be installed in a certain location, instead of just in the gem repo -- you're going to be fighting with things. Some options though. If the "gem" is only used in one project, one thing I really have done before -- structure it as a gem, but include it in the repository of the 'owning' project. The owning projects Gemfile lists the so-called "gem" with a `:path` parameter. You know it will always be there, because the source code for it is in the owning project's repo at that location, there's pretty much no way to deploy the owning project _but_ with the so-called 'gem' at the location pointed to by the Gemfile `path`. I've done this when I had something I wanted to maybe eventually extract as a gem, but for now, just a component of the project. Also, in my case, it started out as a Rails plugin in an old version of Rails that had non-gem plugins, but Rails now only supports gem plugins -- I wasn't ready to make it a real gem, but structuring it like a gem and including it in the owning project's repo as per above was the easiest thing to keep it working. That sounds like it might be your case, you have something structured as a separate Gem, but there's really no good reason for it to be, it was kind of a mistake, it's just a component of the owning project, but it would be a lot of work to combine it at this point. Okay, put it in the repo of the owning project at a particular location, point to it in the owning file's `Gemfile` with a `path`, no problem. If the gem really is going to be shared between more than one internal project each having it's own separate repo... I suppose you _could_ still include it in every dependent project's Gemfile with a `path` parameter, and make sure your deployment routines ensure it is present at that path on every deploy... But I think you're fighting with things too much here, I'd just get it to install as a normal gem in the local gem repo, rather than re-inventing infrastructure for sharing ruby code between projects. Gems is how you do that, installed in the normal way. (They don't need to e published to the public rubygems, you have a variety of options to avoid that). Incidentally, I've seen lots of questions from you in the reddit that basically amount to "We've structured ruby code in a completely bizarre way that isn't like anyone else does ruby and is very inconvenient to work with, but we can't really change anything to be how ruby is normally done, how can I deal with this?" You've got to deal the hand you're dealt, but be aware that's what you're doing. I am kind of amazed at how you wound up with so many lines of code created by people who knew Java but not ruby and insisted on structuring all the ruby at all levels exactly as if it were the kind of Java they were used to, no matter how inconvenient or crazy it makes the code. I'm sure a lot of people/teams start that way, but it's kind of amazing you guys managed to create many thousands (tens, hundreds of thousands?) of lines of code that way, and actually get a working product at all. 
Sure so my experience has been that the web browser has most of the GUI tools we need to make what we want (buttons, text areas, you name it) While I don't have any experience with Rails, I'm 99.99% sure that it could do a localhost only app. I'll give you an example of something I'm working on right now. I'm writing a library that interfaces with Opticon brand scanners and lets you issue commands and change settings on the device via USB. While I am more than comfortable using IRB to make things happen, my co-workers needed a GUI way. I kept my library cross-platform (thanks to rubyserial and ruby-ffi) and I thought it would be a shame to rip that away from the GUI. I use Sinatra here but, I have every reason to believe this would work on Rails as well. I make the server only run local host on port 8080. I connected all the stuff via slim (lookup slim template) and turn it on. You then point your browser to localhost and you've got access to your app. I can definitely see some design choices to be made, one of the most important choices was, "Do I make this app work in a single user or multi user mode?" In a single user mode only one user can use the application at a time, (via localhost), in multi user mode you let the app reach out to the network and users connect to it via their own browsers on their computers. Depending on the kind of app you are planning on making, planning this design choice out a head of time is a good idea. The easiest way to decide which is right for you is to ask, "Can all the GUI actions I do be threaded?" If the answer is yes, multi user mode will work. A great example of this kind of localhost only application would be fast-track and metasploit's web guis (which inspired my design choice for the GUI). Both use a webserver + frontend to work the application behind the scenes.
Re: account enumeration. This will exist in some form within every system via registration, otherwise you'd be getting duplicate accounts. The remedy is not authentication, and instead proper rate limiting and/or intrusion protection.
&gt; The remedy is not authentication, and instead proper rate limiting and/or intrusion protection. Yes, however this *is* still largely encompassed by "authentication" gems such as Devise (and its many extensions ). Rate limiting on the number of password attempts, before the account is "locked", is an obvious security measure -- and I *think* is handled by default in Devise. (Or if not, it's a very simple extension to add.) However, there are other more subtle forms of rate limiting to consider: * Limiting the number of (automated, brute force) logins for *different accounts* (see my above examples of "guessing existing user names") is pretty much *impossible*. (What are you going to do? Disable all logins until the attacker goes away?) So ideally you need to hide any information leakage from incorrect password events. * Similarly, you cannot really restrict the number of "forgotten password" events. And by default, Devise has information leakage here too. * And again, the same problem occurs for the "didn't receive unlock instructions" Devise default error messages. * Limiting the number of (automated) account creations can be done via a Captcha. (My favourite is Google's [reCaptcha](https://github.com/ambethia/recaptcha)). There is unavoidable potential for information leakage here, and also DOS attacks; but at least the use of a Captcha heavily mitigates it. Again, nothing like this comes out-of-the-box with Devise. None of these security concerns are "major", and can probably be ignored by developers of small sites. But that's the whole point: Devise was built with the "simple users" foremost in mind, not the "high security" users. By point here is not, by any means, the Devise is insecure. I'm only highlighting how much consideration needs to go into high security, beyond simply "using a standard tool". 
This would be good except it ONLY support MacOSX, iOS, and Android. The OP wants to have at least big three support (windows, linux, mac).
GTK isn't great for Ruby and I try to stay away from it if possible. Besides it being quite buggy and poor docs (for ruby), it's hard to install cross-platforms (especially Windows and Mac OSX). Although it is the most "vetted" ruby gui out the maybe besides qt which I haven't gotten working well either.
Thats very interesting. I don't think I would be able to do everything I want through the browser tho ... If I want to interact with a UDP port for instance. Or if I want to make a 3D game. I don't really have a project in head really but I am trying to find a general solution. Should I switch to Python ?... I dont want to tho ... 
This situation is nowhere near as bad as it sounds. All passwords are still hashes with Bcrypt. All of them have a minimal complexity enforced, thanks to the library introduced. The only weakness here is that brute force mechanisms can identify weak passwords easier, which is only a linear improvement in attacking an already strong password set. As far as the example attack goes, running bcrypt using hashcat will be significantly faster than the sample Ruby code.
Yeah I tried jruby, its cool but I already know Java. I could do a pure java app but i want to do ruby. I want Cruby. 
That sounds like an interesting option. How would you build something which is user friendly for this kind of project ? I mean easy install and easy run ? either a few command and the app start or even a binary to click on and the app start. 
[here's the thread from when i asked this question last year](http://comments.gmane.org/gmane.comp.lang.ruby.general/377521) - no one seemed optimistic about packaging and distributing a cruby gui app. (i ended up just rewriting it in ocaml, which compiles down to a self-contained executable)
absolutely! Sinatra is very easy to setup, its like a simpler rails. You can do the same thing with Rails though. As long as the server has permissions to do so, it can really do anything you want. To make the app easier you can do a couple things, I'm working through a similar thing with my company right now. So my plan is to use DNS to map locally a server computer, then everyone just types in "company_name.local" in their web browsers and then it just routes everyone to the server running the software. This way every device is essentially guaranteed to work with your app, as long as it does internet. The app can run (as a server or clientside) on all platforms natively, but know that the devil is in the details, there are differences you will have to account for in the standard ruby library across the platforms. I have had to deal with many such differences between Linux and Windows with my serial port work. You will potentially have to write OS dependent code, which I feel is a bit of a code smell, and a huge potential for error. As for ease of use, it depends on your tactic. Lets say single user, you could easily create a BAT, SH, whatever your flavor of shell script is, and just have the user double click on that. They could also go the console route for any platform. For multi user, consider using a URL shortcut to "whatever.local" and just keep the server running all the time. 
Pretty sure he is too, but that doesn't change my response. 
I'd say check out Shoesrb, which is basically a DSL around some Java stuff using jruby, or try Gosu if you want to use MRI. Gosu is more for making 2D games, but you can still write a desktop app. The final solution is still super new, but it's https://github.com/zach-capalbo/flammarion. This basically makes a web app in chrome similar to electron, but written in Ruby.
The code is certainly not optimized, but I think you're understating how bad this is. The back of the napkin numbers that Jon and I calculated were an almost 500x speedup using a 10,000 password dictionary. That equates to 10min to iterate a million row database. That's significantly more than a linear improvement. That said, hashcat is a great example of a tool to run against this scenario and something that most Ruby devs don't know about!
1. This isn't really about how Rails works. It's about perceptions of how apps using Rails should work. 2. I feel like I'm allowed to complain about how Rails works at this point. 3. Not so thinly veiled.
I'm supposed to be under cover! 🙊🙊🙊
CRuby is regular, plain, MRI Ruby. You are maybe thinking of mRuby?
I know it's Ruby and all, but why does "shortness" of code used as a metric for how good something is? I'd much rather just have a method with a case statement than dynamically dispatching symbols to s model, for the cost of a few lines of code.
Because they started with ruby-GTK, then ruby-GNOME for the first gtk version. They decided then to rename the project ruby-GNOME2 for the gnome 2 version. Since then they keep the name which can be misleading, you can use the latest gnome libs with ruby-GNOME2. You can see here the history : http://ruby-gnome2.osdn.jp/hiki.cgi?History
Have a look at a gem builder I made, [pad_gem](https://github.com/nicoschuele/pad_gem). Inside, there's a test directory with a Gemfile and a `test_runner.rb`file. When I want to test a gem, I just execute `ruby test_runner.rb` and so I don't need to build the gem.
Thanks, that seems to be almost exactly what I was after.
I can teach you some idiotic ruby.. i am pretty good at that
I downloaded it from a Google code repo. I left it as is. I'm still looking for a more comprehensive list or API I can pull from.
rubocop enforces those rules, so just scan your code and make the changes. atom and sublime text both have linters that use rubocop as well. it will save you a lot of time than reading the whole style guide. 
I support this wholeheartedly. In addition to the archiving problem, this also solves another issue that comes up: before someone posts a rather specific or simple code question here, they're going to go to StackOverflow first and hopefully find an existing answer.
Yes, this is absolutely true as well. No doubt a good portion of the questions posted here are duplicates of StackOverflow posts.
I really wish there was a community edition! Even Python has one! 
I dont have much respect for Ruby Hero awards at all. It really seems more like popularity contest, or who self-promotes the hardest. People who have done WAY more for the Ruby community but are otherwise quiet on social media never get look in (for example creators of `byebug` or `pry` or `minitest`) but other people, who just loud and self-promote always win. I'm not saying many of ruby heroes don't deserve it, but there are people out there more deserving who have done lot more (but just not so social-media savvy.) Sometimes Ruby community feels like cult of personality, with the loudest often contributing the least and hero awards another example of that 
I agree. Most of the problem does seem to come from /r/Rails. /r/Ruby isn't nearly as bad. My goal is to make sure it stays that way -- even more so than it is now. :)
Questions that are 'off topic' on SO should still be allowed. Like asking for opinions "what is the best", or "how would you structure this code", or "what are some options for doing X with pro's and con's", or other things SO tends to close as not appropriate for SO for being discussion or opinion. reddit is just about the only place we have to discuss them. The line might be hard to determine/enforce. Not sure how to deal with it, I'm not sure there will be any way to succesfully prevent people who have no idea what they're doing from asking terrible questions, except maybe if we stop trying to answer them. 
New heroes are picked by old heroes (including myself). Believe me, we are very aware of the "popularity contest" aspect and try to pick not just the loudest but those who've improved our community for the better. That said, votes are considered. It doesn't matter how loud someone is if no one is voting for them.
&gt; Which in many cases i'm sure results in "i'll pick my buddy on social media" -- people who are already part of the pathologically sociable in-group patting each other on the back. Many see a conspiracy wherever they look but I can assure you that it's never that simple. Part of the Hero mission is to highlight people who've most improved the Ruby community - our proxy for that is the popular vote. If someone votes for X, presumably it is because X has improved their life somehow. That said, it's only one data point. There are long-time developers who have been nominated this year despite having zero social media presence and few popular votes. Agreed about Ryan and there are **tons** of people deserving of a Hero award. They give 6 per year, that means there's going to be lots of people who don't win.
Ryan is just illustrative of the point. He's been around in the ruby community for more than a decade, everyone is using at least one of his gems -- if a guy like that, has been passed over **48 times** (8 years * 6 choices) - what chance do other people have (like the author of `byebug` for example) who are even more under the radar? I have very little respect for the award. You, of course are deserving of it -- but i can name a large % of the past recipients (i dont want to name names) who shouldn't even have made the short-list. Only reason i can imagine they got in is their volume on twitter, their unrelenting presence at conferences, and their ability to network.
&gt; new job soon, majority of work in Ruby, no experience in This has to be some kind of a joke, or ? Anyway, recommended style guides and linter tools won't help you much at learning idiomatic patterns of a language. Learn by realworld tasks solutions, compare used algorithms with a language you are experienced in, learn core and standard Ruby libraries, start write a lot of your own code … There is related and fairly good free online book [Learn Ruby the Hard Way](http://learnrubythehardway.org/book/) or collection of notorius programming problems solutions on [Rosetta code](http://www.rosettacode.org/wiki/Category:Ruby).
Brevity is the soul of wit.
Oh hey I even wrote a library to do this properly: https://github.com/dry-rb/dry-validation Unfortunately it doesn't monkey patch Object so it's doomed from the start and nobody will use it.
That's disappointing.
I respectfully disagree, I think it makes more sense to look through the style guide first and establish a baseline for what is recommended (it's pretty consistent in terms of general trends), then when the corrections show up later, they'll be reinforcing what you've learned instead of being the first time you're learning it. It may also give a new ruby programmer some ideas.
The last time this came up, didn't we establish that Rails was highly unlikely to see any benefits because it already does use frozen string literals almost everywhere that it possibly can?
I am still hoping that they'll hold off on making this a feature in future ruby based on evidence of it as an experimental opt-in feature. 
I'd like to know if frozen string literals improve memory consumption.
I thought that was the point, not runtime speed (though there should theoretically be some runtime speed performance from reduced garbage collection).
It's a command-line argument: ocra foo.rb --icon bar.ico Your icon will need to be in ICO format.
Thanks!
Thanks for your well stated opinion. I was basing my recommendation from my own experience. On my first reading, I found that the style guide mostly seemed to be concerned with superficial rules regarding indentation, semicolons and so on. These rules seemed superficial because the style guide rarely ever tells you *why* a rule is required. Here are some typical examples I just randomly picked: &gt; - Do not use then for multi-line if/unless &gt; - Favor until over while for negative conditions &gt; - Don't omit the parameter parentheses when defining a stabby lambda with parameters That is all the explanation and justification that is given for these three rules. While there is good reasoning behind all the rules, without being told the reasons you are likely to just dogmatically gloss over the lengthy guide without knowing which are more important to you. So while I observe its rules, the guide does not serve me as a learning document. I find rubocop to be more effective because it identifies the violations that are *most prevalent in my code*, and this drive me to investigate those rules further. Moreover, rubocop does more than just follow the style guide; it brings in deeper metrics such as ABC and cyclomatic complexity that, imho, are far more important to developers. I only really learned about those metrics from using rubocop.
Interesting. I find I was able to retain most of it, and that reading through the style guide, on a personal level, satisfied many little "which should I do?" questions that were floating around in my head - things that were the same on the surface, just stylistically different. But for someone newer to ruby, it's true that those would not be there. I have met some people that only use rubocop as a linter, as opposed to as a standalone analysis tool, and have never read the style guide. Therefore, when they get errors, they just become frustrated and don't really gain understanding, since the single-line linter messages are truncated. Thinking of somebody using rubocop in the standalone way, I can definitely see why it could be a quicker and more directed means to the same end.
Because clearly the only reason we'd want immutable state by default is FOR SPEED? How about, say, correctness as seen in immutable state functional languages, or hybrid functional/imperative languages which are immutable-by-default like Rust. Immutable string literals also open the door to *future* performance improvements, particularly ones that reduce GC pressure. That said, it's unclear if these benchmarks run long enough or allocate enough memory to even measure the performance effects it has on garbage collection. Silly "roflscale" post.
Please leave your e-mail address at the end of the survey so we can contact you if you win.
&gt; Make your indentation consistent. Specifically, two space indents are considered standard in Ruby. Anything else just *feels* wrong.
&gt; This has to be some kind of a joke, or ? Nope. They were far more interested in general programming skills rather than specific language skills, to the point where the technical questions part of the interview process was done in a language of my choice.
here you go: https://developers.facebook.com/docs/marketing-api/reference/product-feed/uploads/
btw, i don't think koala supports the facebook marketing api.
If you *aren't* using it from a constant, but instead just have a string literal somewhere in your code, that allocation cost can add up. The performance difference is real, but comes from places like Rails not from users' applications.
Even before that point, less memory overall should mean less time needed by each run of the GC.
If you read the article, it does into a lot of detail explaining how there are **no known affected gems** (but it is *possible* that some gems pushed before 8th Feb 2015 *could* be have been affected). In other words, there's almost certainly no damage.
Rails has a number of great plugins for Swagger which is pretty nice http://swagger.io/ The grape API gem and Swagger work very well together
I use Swagger Docs. I use a gem called swagger-blocks for the DSL. I am also using JSONAPI and it is a bit of a pain to get the structure right. I use Swagger UI to display the generated Swagger json file. It has been mostly nice to use so far.
I wrote this script, it can help you to identify which gems are not verified: https://gist.github.com/dcu/3c06e4ab0e98158c5742c4fd2b31523d 
For what it's worth, `Kernel#loop` is [considerably slower](https://glot.io/snippets/edjz5d40wd) than a bare `while`, which is arguably quite relevant to OP's particular use case.
I have never seen the `|&gt;` operator before. What is it?
It looks like it sort of means something like "send" or "tell".
Very interesting! even when not doing the while inline the speed difference holds true! I guess loop does (or used to? haven't checked recently): - an implicit rescue for a StopIteration being raised (so you can do .next inside it without having to rescue it manually) - it takes a block and thus opens a new variable scope Those two probably add quite a bit of overhead. In the end, I think opening the socket and reading from network would take up 99.9% of the time, so optimizing 0.1% probably doesn't matter :)
Try this: request = RestClient::Request.new( :method =&gt; :post, :url =&gt; "https://graph.facebook.com/v2.5/99999999/uploads", :payload =&gt; { :multipart =&gt; true, :access_token =&gt; "#{ENV['FB_MARKETING_ACCESS_TOKEN']}", :file =&gt; IO.read("exported_file/superfile.csv") } ) response = request.execute In your `curl` command, `access_token` is part of the multipart form data, but you didn't format it that way in the RestClient request. There's also a comma missing in your example.
That's Elixir's [pipe operator](http://elixir-lang.org/getting-started/enumerables-and-streams.html#the-pipe-operator).
I like zendesk's stronger_parameters for parameter validations richer than what's available in strong_parameters, unfortunately I don't think it provides automatic documentation generation: https://github.com/zendesk/stronger_parameters
Why don't you want to use Array#flatten?
There is Svelte, which is a gem for easily consuming swagger APIs. https://rubygems.org/gems/svelte/versions/0.1.2 Disclaimer: I work with the team that works on this.
It improves the efficacy of brute force attacks by several orders of magnitude. I'd say that was pretty bad. Hashcat has ruby bindings btw.
Yes, that was my point. Why is `each` OK and `flatten` or `flat_map` not? 
The target audience are Rails developers who are trying to learn something new. 
Not sure if sending a zip is legal (dunno under what license this font is distributed) but running this script is pretty simple. Ruby should be installed by default on OS X (you can check that by running `ruby -v` from Terminal app). Download the script, delete old "images" folder using Finder or Terminal, navigate to the folder in Terminal and launch it by typing the following command: `ruby emoji_extractor.rb`. After it finishes running your images will be located under "images" folder.
Hi! It doesn't have up to date images in folder by default. Have you run this command? ruby emoji_extractor.rb This will extract images from your *Apple Color Emoji.tff* Then you can check *images* folder. Hope this helps.
8-hour event, not even enough time to get Zookeeper running happily let alone Kafka
ah I'd forgotten about daemon - I used it to write a mail client (believe it or not) years ago.
Persistent HTTP connections will not avail you if the connection drops or is reset. Servers recycle connections periodically anyways (see `max-age`). The network is unreliable, plan around it.
no, when I delete the reverse I see as answer String where Object is the right answer. 
You should launch it without "-v" flag. -v is used to check version. You said it does nothing - just check the "images" folder, your icons should be there. The script has no output on progress, so if there are no errors - you're good to go.
 correct but Object is a superclass of String. And I have to find the first class where to_s is made. Not the class that ruby uses 
Then filter `all_classes` to contain only classes and not modules. I am not sure what your actual goal is, what if the method comes from a module via some include or extend?
its a exercise from ruby monk. so I think the last cases are not involved.
Quite simply because in any moderately large app you will have more than one scenario for creating / updating records. You could add payments manually or by an import or automatically when somebody pays by credit card. An employee might only be able to change certain properties of an order, depending on their role in the company, etc. There's data validation in the DB (and for really tricky stuff that is too hard to do in the DB, maybe in the model), but that's just an ultimate sanity check about *consistency*. Once I've crossed the boundary into my application I don't want to have to check whether the data I got is valid and/or permissible. Also, the "models validate themselves" breaks down as soon as you have use cases that interact with different models etc.
I wrote this thing. It works like dotenv or envdir, but it stores your environment variables in gpg-encrypted files instead of in plaintext. Thoughts, suggestions and bug reports are welcome!
Did you look at the library? Part of the point of it's existence is that maintains the connection, detecting failures and reconnecting as needed. 
&gt; I think something similar could be done with a SQL database at any rate. It's an 8hr event that will be running on his laptop, `File.write` is more than sufficient. 
As am I, which is why I'm curious as to OP's motivation. The whole notion of interface vs. implementation is incoherent in Ruby, which is why we typically only concern ourselves with the module whose method definition is actually used for a given object.
Then you may post a link to the task, to make it more clear. Mixing-in methods from a module is a quite common technique.
That's just `.grep(Class)` in "modern" Ruby.
The exercise can be found here : https://rubymonk.com/learning/books/4-ruby-primer-ascent/problems/85-whodunnit
So Ruby is not a fast language ? Java would perform better ? Is Python faster than Java ? 
no, ruby is a much nicer language to work in, and jruby is a truly great piece of engineering. it offers full compatibility with MRI, *and* seamless access to java libraries. 
Disclaimer: I'm just a random guy e.g. not affiliated with gitlab. Yes, you can use any builder even just good plain old HTML and than copy it from your git repo via a shell cp. All runners configured with a yaml file (travis ci-style) and running in a docker container. Example: pages: stage: deploy script: - mkdir .public - cp -r * .public - mv .public public artifacts: paths: - public PS: Jekyll (in Ruby) is - of course - the world's most popular #1 static builder ;-) See ["Which Static Site Generator Should You Choose?"](http://www.remotesynthesis.com/general/2016/04/06/which-static-site-generator-should-i-use). And now you can use Middleman (in Ruby) too (it's kind of a "static Rails" e.g. uses ERB, Sprockets, Rails-style Helpers, etc).
Every single time I read about GitLab, I think to myself "man, it sure is quite awesome. If only you didn't need a fucking cluster to host it because it's fucking Rails."
In terms of speed Java -&gt; Python -&gt; Ruby. However understand that the reason we write code in Ruby is not for speed, it is for API design, syntax power and flexibility. 
Sure if you want to go that way.
Why Nokogiri instead of Oga?
Even better!
Pretty sure you want to lowercase `require 'Nokogiri'` and `require 'HTTParty'`. Also it's a bit confusing how you write the scrapping code first, then wrap it in a method. It might be easier to understand if you wrote the scraping code first as a simple script, then refactor it into a formal Class that works on any URL?
There's no need to write a class for case this simple. 
What's the benefit of this over using ActiveSupport::Notifications? 
very different purpose. `ActiveSupport::Notifications` are for instrumentation of ruby code, see how `ActiveModelSerializers` uses [ActiveSupport::Notifications here](https://github.com/rails-api/active_model_serializers/blob/db87f8d85e7a46ef195a555cb7e2509f1affc622/docs/general/instrumentation.md) My gem is a thin layer on top of websockets, which allow a constant line of communication between client and server over http(s). WebSockets are classically used for any type of chat program, where all clients need to be synced with each other with the messages.
You mention that you get a call to hash_tree for every beer on your index page, but why? Why are you calling all comments on the beers index page? What is it you are trying to render? I'm assuming it's a list of beers, but what part of comments do you want to render on the beer index page?
The index page is just for testing right now. I started with a simple app just to get comments and closure_tree setup. The end use is I have a news feed with statuses, and want to show the comments for each status. Very similar to how Facebook and Fitocracy show comments for each news feed item. So if you go to /profiles/blimey85 you'll see a list of my statuses, check-ins, etc. Each item on that page can have comments. By default it shows 10 news feed items with a button at the bottom to load the next 10 via ajax. In my sample app however it's beers and so I just used the index page to show multiple beers, and associated comments. In my actual app I have: def feed Status.where('statuses.name IN (SELECT followed_name FROM relationships WHERE follower_name = :name) OR statuses.name = :name', name: name).joins(profile: :avatar_files).includes(profile: :avatar_files) end Profile has an associated avatar image. The feed method pulls statuses for myself and anyone I'm following, as well as associated profile and image information. That works rather well and allows me to grab everything I need to show the status feed in a single query. Now I'm trying to work out how to also get associated comments within that one query. And I managed to do it with SQL pulling everything into rows, meaning for each comment, I have a row showing all data, but that's obviously a very dirty approach and has a return set much larger than what it needs to be, whereas my current feed method is very clean and returns properly associations. Am I explaining this clearly?
Thanks
Okay
Would you be willing to post your schema and some dummy data?
The author of Oga has compiled a list here: https://github.com/YorickPeterse/oga/wiki/Problems-with-Nokogiri I personally stopped using nokogiri because every new OSX release changed the version of libxml on my system it seems. Depending on that library meant that nokogiri stopped working for me on an annual basis. It was also painful for others around me to install for similar reasons. Oga has worked like a charm and if you use xpath, you'll almost have to make no changes to your code. Note, however, that Oga also has a small native C component for performance reasons.
This is my first gist but hopefully this links to the current schema: https://gist.github.com/blimey85/669d6fc6f2ec1e0bd7be257e2c617681 And this has three inserts for data. https://gist.github.com/blimey85/b4745bd39059e7f61d004b942bface6a There are beers, comments, and comment_hierarchies as that's the table closure_tree uses to quickly match up the comments.
[removed]
Hello again jrochkind :-) The problem is that the multiple layers are indeed shared across multiple of solutions AND separated into different Git repositories. I guess I can deploy the gem into the different repositories, but the deployment system used here in Gradle (and we are not even using JRuby) - and I feel like fighting over things. I think I found a solution for the problem. Bundler is smart enough to overwrite .gemspec specified gems if your asking it to. So I can 'overwrite' the .gemspec gems with my local gems using the `path` and have no need to change anything on the gemspec file. The reason I'm struggling with things like that so much is that the original programmer who wrote the system is a Java programmer that wanted UI testing and heard good things about Capybara. Because the development of the testing framework was during normal work cycle, I don't think he fully understand the core difference between Ruby and Java. So now we handle a lot of Ruby code written like Java code. But the good news that with your help and other people help from this reddit we making good progress on refactoring the code to be more Ruby oriented. Thanks!
Cool, idea, I will check it! Thanks!
Thanks. I will have alook on that :)
You don't need a cluster. If you install the omnibus edition that's available in most Linux package managers everything it needs comes embedded within it. It's actually an incredibly easy setup process 
It is suppose to count down to 0. 0 is less than or equal to 10. So is -1 and -2 and so on. I assume it needs to stops when number is zero.
I don't see how the easy installation has anything to do with needing a cluster. GitLab is an incredibly resource heavy app that requires a very powerful server.
Try changing it to 'while 0 &lt; number'
That doesn't pass the test either. 
Bloody hell mate. "Less than or equal to 10" is `&lt;= 10`. You need to change it to "greater than or equal to 0" and you can't work out what to change from that description? I don't mean to be a dick, but is this a homework assignment we're doing for you or something?
 While number &gt; 0 or perhaps Until number == 0 Dont forget to en the function with Return "Happy new year" Sorry about formatting on mobile
Hey, the more difficult you think it is the more rewarding it becomes when you wrap your head around it. Make sure you don't stop just because the test passes. Stop when you completely understand what is going in. Loop upwards, downwards, Randomly and then look into the break statement and try to figure out how to get out of the loop with that. Good luck. 
Ah, gotcha. I don't know much about websockets / actioncable yet but working on learning. Thanks for responding. 
Sorry for down voting but you're doing yourself a disservice. If someone just hands you the answer you're not going to learn anything. The value of this exercise is in *you* learning how to think in algorithmic ways, getting to code that just works is pointless.
i understand that. answers dont mean anything in the big picture. but when im just starting out, and for this particular problem, the answer will help me understand the entire process. its the same way someone can learn to build something by taking apart the finished product.
Yeah but if the result of this flexibility is having a slow, one platform (web) language , it's not really worth it .... I love using Ruby language and I am sad that it cannot be used for desktop application in an efficient way. I though since it's seems "easy" to use C library that a wonderful easy to use library for GUI would be here. I guess it's time to take the matter in our own hand and start a project ! haha
Ok, so you've already got an [answer](https://www.reddit.com/r/ruby/comments/4dwdaz/how_to_exclude_the_modules_of_a_class_here/d1v6w0w) how to filter-out module objects. By the way, the exercise is a bit vague as it doesn't take mutual relationship of classes and modules into an account. To your example with `:to_s` method, its original definition is in `Kernel` module, `Object` class only includes it. If true owner of the original definition is required, you may also use `Method#super_method` helper, instead of walking through ancestors list: supm = -&gt;(m) {m.super_method.nil? ? [m.owner] : supm[m.super_method] &lt;&lt; m.owner} supm['a'.method(:to_s)] # [Kernel, String] 
Why without flatten and sum? You could just use recursion to parse through each element and each sub-element. Or use foreach and check the type (since it looks like there is only integers and arrays). 
The uuid gem makes uuid objects, SecureRandom returns a string. The activeuuid gem expects uuid objects.
Is there an advantage to this other than type checking?
I'll write this in plain English to complement your code. Define a method called "countdown". Set variable titled "number" to the value '10'. While "number" is less than or equal to '10', run the following. print to console "(value of number) SECONDS(S)!" and remove one from the value of number. end method. Now your first problem is, number will always be less than or equal to 10 - it starts with a value of 10, so 10 == 10, so it runs the code in the while loop, "(number value) SECONDS(S)!" and remove 1 from the value of number, then it repeats IF number is still less than 10. During the second run, because 9 is less than 10, it puts "9 SECONDS(S)!" and removes 1 from 9. Now, already what is wrong? (It was wrong from the get go) - SECONDS(S). Why are there two 'S's? If you want to be lazy, and according to the directions, you can be, just remove the S from the end of "SECONDS". Now, what you may have noticed is, that since we are subtracting 1 from the value of number, and since number started at 10, number will always be less than or equal to 10. You've created your first infinite loop. Congrats, don't create them again. In plain English, it's like me telling you that you are an 8/10 as far as attractiveness, then saying, you are 8/10, but subtract one from 8 until you are 9/10. Do you see how it is impossible? Basically, the below is how it reads (mixing code with plain English) -- While (Condition is true) do this end So, you need to make sure that condition will eventually be false. So while number &lt;=10 would always be true.... ...a statement like while number &gt; -1 would return false once number was equal to -1. So now we know how we can make it count from 10 to 0. Now how can we make sure the right output is sent depending on value of the variable number? Let's use if &gt; else if &gt; else while (condition is true) if number value is greater than one, puts "#{number} SECONDS!" else if number value is equal to one, puts "#{number} SECOND!" else puts "HAPPY NEW YEAR!" Good luck! 
This is why Ruby isn't the best beginner language. "Idiomatic" Ruby is extremely terse and there's a lot of stuff happening behind the scenes
a.to_s.scan(/\d+/).map(&amp;:to_i).inject(&amp;:+)
Absolutely agree if the database is PostgreSQL, but the same would not apply if a different database was being used. Please correct me if I'm wrong.
It will prompt you to upgrade, not update. Yes, it does require a reinstall on both Windows and Linux. Haven't done my MacBook yet but seems likely. Source: Did this twice today already.
Just a nitpick.... Uuids are 128 bit numbers. So like an IP address, it's wrong to store it or work with it as a string. It should only be converted when you're going to show it to a human or if you're outputting to a log. Practically, it's only really an issue at scale like you mentioned.
Thank you! It's making sense now
 eval(a.join(?+))
It's not wrong at all. Just because it's a number doesn't mean you have to store it as a number. Unless you need to compare them numerically or perform mathematical operations on numbers, which for UUIDs you generally don't, it's not just okay to store them as a string, but actually a good idea. That way you don't need to worry about the integer size on different platforms, signedness, decimal values, or anything like that. Also, storing it as a string indicates it's not a value that should ever have numeric operations applied to it. Like phone numbers, SSNs, ZIP codes, etc., just because it looks like a number doesn't mean you should treat it as one. IP addresses are a different story, because there it's plausible that you would need to figure out a range of addresses, apply a netmask, or perform some other numeric operation where it is useful to relate numbers to each other. But the only value of a UUID is that it's random and (almost certainly) universally unique. There is no reason to ever compare or perform math on a UUID, so there's no reason to treat it as a number.
Just use Postgres. ;)
I can . Then I see a message that the function hello does not exist. it looks if RubyMine does not look in the same directory ad the spec file I have no clue what settings I have to check. I just begin with ruby and Rubymine. 
Im working on Ubuntu linux 
but the file is there. I made it and still this annoying error. 
been trying to use loops to extract the numbers but it starts to get convoluted ): 
I would disagree that Rubmine is flaky. It works just fine after setting it up correctly. I do agree to start in the terminal to make sure everything is working with ruby prior to going to Rubymine. 
Are you using any virtual environment for ruby? Like rbenv? As /u/kickinespresso said, RubyMine probably doesn't know which ruby to use. 
I have only installed 1 version and that is the version that rubymine is using 
I think I found the issue here for you /u/roelofwobben . Simply Don't use RubyMine for this project for running the rake and rspec. The rake and spec just aren't meant to be used in RubyMine the way this project is using them. Its fine the use RubyMine for editing the files, but you'll have to reconfigure rake and rspec for each lesson directory when you want to run that particular lesson. I think it is much more trouble than it is worth, especially since your goal is to learn ruby and not learn how to configure RubyMine for lessons. Just like /u/montas and I have been saying, the first task is the environment and it sounds like that is working in the terminal now. You should run with that while doing the lessons IMHO. If you're going to use RubyMine, use it to edit the files, then drop to the terminal to run the rake tasks. I never looked at [learn_ruby](https://github.com/alexch/learn_ruby) before, but what is happening is that the project is has one `rakefile` and `gemfile` at the root of the project just like any other ruby project. To do each lesson you go into the lesson path and run rake to execute the rspec tests. RubyMine, by default will run the rake and rspec tasks at the root path of the project. Even though RubyMine is a great IDE (and I use it daily), you still need to learn the terminal and be comfortable with ruby on its own. I would recommend that you complete this project in the terminal and use SublimeText or VIM or whatever you find easiest. The objective is to learn Ruby and not spend time with an editor. I ran the first test outside of rubymine: https://youtu.be/lHSBtwu2B94 
Thanks, I will try to install SublimeText on my Ubuntu box. Is this a good setup then ? and can I do the test then better ? 
&gt; Only one kind of uuid is random. Most kinds are deterministic. That's irrelevant. Once it's created, I don't need to *do* anything with it, mathematically speaking. You can't add UUIDs. You never need to find the square root of a UUID. Internally, every data type can be represented by a number. That doesn't mean it's a good idea to do so. &gt; You don't really really worry about things like word size unless you're doing something low-ish level. Really? Try stuffing a UUID into an SQLite integer type and see what happens. For all intents and purposes, a UUID is a string, so it should be treated like a string. And what happens down the line if you decide to convert from a UUID to some other identifier? If you were only planning on using a 128-bit number, you're going to have data type compatibility issues if the identifier size changes. If you store it as a string, it's relatively easy to determine not just what the value is, but what kind of identifier it is as well. Furthermore, not every 128-bit number is a valid UUID. In actual fact, a UUID has six reserved bits (four for the version number plus two extra), so storing the data as a 128-bit integer (and validating it as such) could lead to unexpected problems down the line. &gt; I think your comment illustrates how common it is for developers to be confused about types, and it's why I point it out whenever I see it. You're the one who seems confused. A UUID isn't just any old 128-bit number. The bottom line is if this: If you don't need to do math on it, it's a string.
Haha, thanks! And what do you think could make it awesome awesome? For example, I'm planning to include a section with tutorials alongside every lib.
I like the idea. Phase one, you could add the wiki link and maybe a screenshot (if present).
All error service clients will have a Ruby API to send errors. Honeybadger, Bugsnag, Sentry, and Rollbar are four popular choices. Pick and use one.
I don't want to burst your bubble after so much effort, but [the ruby toolbox](https://www.ruby-toolbox.com/) is already a 'go-to "Ruby Toolbox".'
"convert hourly rate to float". Storing money as floats is a bad idea. You'll end up with rounding errors.
No, it needs to be specifically written for Crystal.
As i have asked AWS guys in one webinar they are in progress to launch ruby support for lamba
Have u ever tried using rubymine on multiple projects each that use a different version of Ruby? 
No harm in competition.
How about jRuby? https://github.com/c9katayama/aws-lambda-jruby
I believe the behavior of `require` would benefit from an explanation of how $LOAD_PATH works as well. When you `require 'something'` it looks through all of the paths in the array $LOAD_PATH until it finds a file with that name. You can add additional paths to the $LOAD_PATH as well which is often important when developing gems or libraries.
These are fairly [well](http://ruby-doc.org/core/Module.html#method-i-append_features) [described](http://ruby-doc.org/core/Object.html#method-i-extend) in the official documentation. Find the linked article rather confusing and superficial in this aspect. `Module#include` mixes-in module's *instance* methods (besides module's variables and constants) and works (is defined) on module objects (class is also a module). `Object#extend` does not produce "class methods" but instance methods become *singleton* methods at the target object. When receiver is a class (which is also an object), singleton method is identical with class method. This is but a single case of the general rule.
Even if it detects that failures occurred, it can't detect if the HTTP messages were actually posted. Which means messages will often arrive more than once on the other end. There is a fair amount of complexity to faithfully reconstituting a bytestream over unstable TCP connections.
Could be useful to host the examples on github pages or something
here is the exercise : https://rubymonk.com/learning/books/5-metaprogramming-ruby-ascent/chapters/31-lifecycle-hooks/lessons/70-introduction-lifecycle-callbacks if I understand the text well. these calls are callbacks and called by the runtime. So I do not have to call them. See this text : Ruby offers programmers what are called "object lifecycle callbacks" to track such changes and respond to them. Worried that someone might override a method? Register a callback and you'll be notified when something happens. That's why it's called the "Hollywood Principle": you don't poll the runtime for changes; instead, the runtime calls you when something changes.
Not OP but isn't Ruby Toolbox unmaintained? I don't think its possible to submit new projects, so most of the newer ones aren't on it. 
Hi @markets86. It's written in a few places - footer/about, that it is based on the official list at GitHub. Also, people are urged to contribute to that list by opening pull requests. Sure, I'd be happy to get in touch. Cheers!
`UserMethodMissing` wraps the hash (1 hash lookup in your benchmark) but `UserRegular` unpacks the hash (4 hash lookups). If your benchmark accessed all four attributes then `UserRegular` would run faster than `UserMethodMissing`.
Something to note is that while they seem similar, the following code is different: SomeClass.extend SomeModule class &lt;&lt; SomeClass; include SomeModule; end One key difference is that the module's 'included' method is not called, which often contains further setup for the usage of the module.
Off-topic but out of curiosity: what does EventMachine offer that the concurrent-ruby project doesn't? Is it ease-of-use? I'm always debating with myself which direction to go with these things.
&gt; The bad news is that it’s an older version of Ruby that doesn’t contain the latest updates and security patches added to the language. Basically, it’s not good enough for real coding. It is good enough for coding, **for beginners**. The majority of *ixs have an older version of a lot of things and work just fine. Particularly in the enterprise environments where compatibility is a must. &gt; To know what directory you’re currently in, type in pwd. It stands for (p)resent (w)orking (d)irectory and will show your location in the terminal. It's **print** working directory, but close enough. &gt; Apple uses the default, pre-installed version of Ruby for important system items This! Much better than "Basically, it’s not good enough for real coding." --- Other than that, the article is great for beginners.
Installing rbenv is the second thing I do. Homebrew being the first. 
I'm not a big rbenv fan :-)
I have an application I developed using ruby on lambda in production using this guide https://cloudenlightened.wordpress.com/2015/11/29/executing-ruby-code-in-aws-lambda/ and though a little annoying to compile initially, it works well... even using bundler now, though if a gem involved native code it's possible you'd have to install that into the custom built ruby manually. Initially I tried to use JRuby, and getting it working was easy, but getting JRuby to package gems was a pain for me, maybe easy for someone who's worked more extensively with Java/JRuby/Warbler etc.
I used to use RVM, until I looked at the source code.
I used with this with a linkedin crawler that found companies and tagged them based on their descriptions. Didnt manage to make my program worth using, but the SDK is pretty easy to use when you plug in one of the pre-made classifiers. 
But `Module.extended` is called... http://ruby-doc.org/core-2.2.0/Module.html#method-i-extended We can think about this like: `extend` is for adding class methods, `include` is for adding instance methods (but of course using `extended` and `included` callbacks you can go around this).
Absolutely. I applaud any and all efforts to make the ecosystem stronger. Well done OP.
So, the same issue that you would run into if you defined a class repeatedly within a loop rather than once outside. Though I can't say I've ever seen a `Struct.new(...).new(...)` in the wild, either.
Does this really need to be set by an environment variable? I mean, is it too much to ask just to add that one-liner to your `production.rb` if you want to log to `STDOUT`.
Yes, environment variables can be changed without shipping new code. 
I guess sometimes we can set some to send log to STDOUT, while some not Although we can do it ourselves already :P
Would be kind of neat if they also included a log level that could be adjusted with ENV variables. This way you could have the log level by default set to error, but then lower it to info or debug if having to troubleshoot something in production.
Yes, but not significantly enough to have any effect on GC. At least, not in my apps.
[removed]
This is the way. Start from scratch and build your own vimrc file bit by bit. It's important that you only add stuff that you understand what is doing (if you don't, take your time to learn it first). Another good advice is to use the built in help system, it's really useful.
There have been more than 3,500 visits for the last 24 hours. Thanks for the interest. More improvements are coming. Moreover, I plan to share the tech-stack behind http://www.libhunt.com. It is Ruby (and Rails) primarily.
I've had to do similar things in the past for bulk data validations, and used both AM::Validations and Virtus. Perhaps the `check_validations!` method could indicate that it will throw errors, something like `assert_valid!`? The current method name seems like a query, but is actually more an assertion. In your examples, you catch the exception for invalid items and log them out to a file. More recently I have had been using the pattern of partitioning my inputs or operations by state, e.g. valid/invalid, or success/failure. This is treating as a normal case that some operations will succeed and some will fail, and are not exceptions.
I made some progress but ran in to another problem while trying to install bundle: "An error occurred while installing stackprof (0.2.7), and Bundler cannot continue. Make sure that `gem install stackprof -v '0.2.7'` succeeds before bundling." Any idea? Running the gem install stackprof command is also giving me an error.
What is the error?
To add to what others have said about starting from scratch and building up your .vimrc file I recommend adding a bash alias for editing your .vimrc file alias vimrc="vi ~/.vimrc" You could also add a vim mapping to open up the .vimrc file (From http://learnvimscriptthehardway.stevelosh.com/chapters/07.html) :nnoremap &lt;leader&gt;ev :vsplit $MYVIMRC&lt;cr&gt; :nnoremap &lt;leader&gt;sv :source $MYVIMRC&lt;cr&gt; And this is quite useful for sourcing the .vimrc file after saving. augroup vimscript autocmd! autocmd FileType vim setlocal foldmethod=marker autocmd BufWritePost $MYVIMRC source $MYVIMRC augroup END None of these are really necessary, however, when I find something useful to add to my .vimrc file I have one less excuse not to. 
Some gems are dependant of a certain version of another. If gem foo 1.0.1 requires gem bar &gt; 2.0.2 but you have bar 1.0.4 an error will be thrown. Dependancies are listed on the rubygem site, but will be included in the error message. Update the dependant gem (bar) and you are good to go Edit: reading back, i am not sure if this is your problem though 
If you provide the full error message, we could see which dependency is missing. It is probably a library. What OS are you running as well?
Here is the full paste from what I get when I run gem install stackprof: EDIT: Running windows 10 $ gem install stackprof -v '0.2.7' ERROR: Error installing stackprof: ERROR: Failed to build gem native extension. C:/RailsInstaller/Ruby2.2.0/bin/ruby.exe -r ./siteconf20160413-2916-1f2hvuj. rb extconf.rb checking for rb_postponed_job_register_one()... yes checking for rb_profile_frames()... yes checking for rb_tracepoint_new()... yes checking for RUBY_INTERNAL_EVENT_NEWOBJ... yes creating Makefile make "DESTDIR=" clean make "DESTDIR=" generating stackprof-i386-mingw32.def compiling stackprof.c In file included from stackprof.c:15:0: c:\railsinstaller\devkit\mingw\bin\../lib/gcc/i686-w64-mingw32/4.7.2/../../../.. /i686-w64-mingw32/include/sys/time.h:42:13: error: conflicting types for 'gettim eofday' In file included from c:/RailsInstaller/Ruby2.2.0/include/ruby-2.2.0/ruby/define s.h:163:0, from c:/RailsInstaller/Ruby2.2.0/include/ruby-2.2.0/ruby/ruby.h :29, from stackprof.c:9: c:/RailsInstaller/Ruby2.2.0/include/ruby-2.2.0/ruby/win32.h:318:12: note: previo us declaration of 'gettimeofday' was here stackprof.c:58:47: error: unknown type name 'siginfo_t' stackprof.c: In function 'stackprof_start': stackprof.c:63:22: error: storage size of 'sa' isn't known stackprof.c:64:22: error: storage size of 'timer' isn't known stackprof.c:100:20: error: 'stackprof_signal_handler' undeclared (first use in t his function) stackprof.c:100:20: note: each undeclared identifier is reported only once for e ach function it appears in stackprof.c:101:16: error: 'SA_RESTART' undeclared (first use in this function) stackprof.c:101:29: error: 'SA_SIGINFO' undeclared (first use in this function) stackprof.c:102:2: warning: implicit declaration of function 'sigemptyset' [-Wim plicit-function-declaration] stackprof.c:103:2: warning: implicit declaration of function 'sigaction' [-Wimpl icit-function-declaration] stackprof.c:103:31: error: 'SIGALRM' undeclared (first use in this function) stackprof.c:103:41: error: 'SIGPROF' undeclared (first use in this function) stackprof.c:108:2: warning: implicit declaration of function 'setitimer' [-Wimpl icit-function-declaration] stackprof.c:108:31: error: 'ITIMER_REAL' undeclared (first use in this function) stackprof.c:108:45: error: 'ITIMER_PROF' undeclared (first use in this function) stackprof.c:64:22: warning: unused variable 'timer' [-Wunused-variable] stackprof.c:63:22: warning: unused variable 'sa' [-Wunused-variable] stackprof.c: In function 'stackprof_stop': stackprof.c:129:22: error: storage size of 'sa' isn't known stackprof.c:130:22: error: storage size of 'timer' isn't known stackprof.c:140:42: error: 'ITIMER_REAL' undeclared (first use in this function) stackprof.c:140:56: error: 'ITIMER_PROF' undeclared (first use in this function) stackprof.c:143:16: error: 'SA_RESTART' undeclared (first use in this function) stackprof.c:145:42: error: 'SIGALRM' undeclared (first use in this function) stackprof.c:145:52: error: 'SIGPROF' undeclared (first use in this function) stackprof.c:130:22: warning: unused variable 'timer' [-Wunused-variable] stackprof.c:129:22: warning: unused variable 'sa' [-Wunused-variable] stackprof.c: In function 'stackprof_record_sample': stackprof.c:405:6: warning: ISO C90 forbids mixed declarations and code [-Wdecla ration-after-statement] stackprof.c: At top level: stackprof.c:427:35: error: unknown type name 'siginfo_t' stackprof.c: In function 'stackprof_atfork_prepare': stackprof.c:476:22: error: storage size of 'timer' isn't known stackprof.c:480:46: error: 'ITIMER_REAL' undeclared (first use in this function) stackprof.c:480:60: error: 'ITIMER_PROF' undeclared (first use in this function) stackprof.c:476:22: warning: unused variable 'timer' [-Wunused-variable] stackprof.c: In function 'stackprof_atfork_parent': stackprof.c:488:22: error: storage size of 'timer' isn't known stackprof.c:494:46: error: 'ITIMER_REAL' undeclared (first use in this function) stackprof.c:494:60: error: 'ITIMER_PROF' undeclared (first use in this function) stackprof.c:488:22: warning: unused variable 'timer' [-Wunused-variable] stackprof.c: In function 'Init_stackprof': stackprof.c:545:5: warning: statement with no effect [-Wunused-value] stackprof.c: At top level: stackprof.c:474:1: warning: 'stackprof_atfork_prepare' defined but not used [-Wu nused-function] stackprof.c:486:1: warning: 'stackprof_atfork_parent' defined but not used [-Wun used-function] stackprof.c:500:1: warning: 'stackprof_atfork_child' defined but not used [-Wunu sed-function] make: *** [stackprof.o] Error 1 make failed, exit code 2 Gem files will remain installed in C:/RailsInstaller/Ruby2.2.0/lib/ruby/gems/2.2 .0/gems/stackprof-0.2.7 for inspection. Results logged to C:/RailsInstaller/Ruby2.2.0/lib/ruby/gems/2.2.0/extensions/x86 -mingw32/2.2.0/stackprof-0.2.7/gem_make.out Temporarily enhancing PATH to include DevKit... Building native extensions. This could take a while... 
So where does that put me exactly? My 3 coworkers who uses windows 8,1 and windows 10 has gotten this to work. Is stackprof actually anything I need or am I able to bypass it somehow?
Dumb question: I've often seen class Foo &lt; Struct.new(:one, :two) Would Foo.new incur the same overhead in a loop, like in the post? I suspect not, since the Struct class is only being evaluated once.
&gt; I have a mingw64 Not according to the error log you posted, note all the path references to mingw32. Remove devkit and install the 64b version, there are separate downloads for 32b and 64b builds of devkit on the download page: http://rubyinstaller.org/downloads/
The problem is insignificant if it's not repeated, but there's still a superfluous class. The above is equivalent to OneTwo = Struct.new(:one, :two) class Foo &lt; OneTwo A better way is Foo = Struct.new(:one, :two) do
Unbind arrows first
Arrows or hjkl?
Chunking (as in ActiveRecord `find_in_batches`) is not really performant because it uses a [Schlemiel the Painter's algorithm](https://en.wikipedia.org/wiki/Joel_Spolsky#Schlemiel_the_Painter.27s_algorithm). I think #each should stream the result set without using chunking/batching, but that requires cooperation from the database driver. As far as I know, nobody has bothered building support. I built it in 2010 for Active Record 2.3 but I never open sourced the code.
You disable the arrow keys and use hjkl all the time not to move your hands while doing anything in the editor. You can fork my .vimrc.after as a start: https://github.com/wieczorek1990/dotfiles/blob/master/.vimrc.after It does as little as unbinding the arrow keys, coloring column 120, setting the clipboard to X clipboard, and enabling line wrapping. Apart from that I use janus for syntax highlighting. You can also try this Chrome extension: http://vimium.github.io/
Yeah, I had the same reaction isn't 'unsafe' hash traversal is built into ruby. If you want a clear KeyError instead, I suppose you could do `hash.fetch(:countries).fetch(:canada).fetch(:ontario)`. Which is of course what the OP code is a one-liner implementation of a shortcut for. I guess maybe if you want to do that all the time you'd want a shorter syntax? I have never felt such a need. You also, of course, could write: `%w{countries canada ontario}.reduce(hash) { |a, e| a.fetch(e) }`
Environment variables are useful for configs that vary based on where your app is deployed. This is described in greater detail in the [12 Factor App](http://12factor.net/config) — a must-read for developers. 
 before_update :expire_changed_tags, if: :tag_list_changed? should be before_save :expire_changed_tags, if: :tag_list_changed? 
As an alternative, you can use [dry-validation](https://github.com/dry-rb/dry-validation) to validate plain hashes (and it's more powerful than AM::V) and build pure and type-safe data structs from validated hashes via [dry-types](https://github.com/dry-rb/dry-types). It's gonna be faster, more flexible and you won't have to deal with mutable objects.
still not working. seems to be, that no ruby gems could handle this problem.
I'm in your boat. I haven't had an issue yet. Most times in I would just write and write and write to get the idea out into the code. But then, I'd sit back and think, *this can be refactored, more modular, and better to make it more maintainable for the future*. That's exactly what I'd do. With the power of Ruby and backing of Rails, there shouldn't be a maintainable issue, and if there is, it should be able to be solved by refactoring the code because 99% of the time its a code issue. Every framework has its up and downs, thats a given. The OP mentioned having to make several iterations of a CMS and it wasn't portable. He doesn't go in depth about this nor about his shortcomings with Rails.. I assume by portable he either means a one-size-fits-all or literally a portable format. Both of these issues don't seem Rails specific to me. I'm going through this myself with my own CMS. I'm trying to put the most useful features I can into it but my goal is to never make it a one-size-fits-all like Wordpress. I'd really like to know more about what his issues we're to truely understand the reasoning behind the post. It would help us better understand his mindset or maybe we overlooked something obvious.
From my own experience the main issue I've run into is a reliance on letting Rails do everything. I call it lazy programming. Just because Rails can, doesn't mean Rails should. By that I mean there are situations where using a gem to add a feature is quick and easy but not always the best course of action. Most recently I needed to add voting to a project. First attempt was with acts_as_votable which seems to be the standard in the Rails world. Setup sign caching enable it's 14 queries to cast a vote in my project. One of those is the fault of my project and not the gem so let's say 13 to be fair. You pass which model is being voted on and a user object as the voter. On my view, I know the id of both. So I created a new method, pass in both id's, do one query to see if the person already voted and if not I insert a vote. 2 queries. I also rethought how I'm pulling the data and realized I don't need to cache counts so I was able to eliminate additional queries. Had I stuck with the standard approach my project wouldn't scale as well. But that's not the only example I have and it's just one project. Nested comments are a great example of inefficiency. Most tutorials illustrate a rather simple polymorphic association. And even using something like closure_tree you're still pulling comments on multiple items. When you have a page showing ten items, each of which may have comments, you're up against the N+1 problem. Now it's just a bunch of selects which are admittedly fast, and can be even faster with caching (their properly indexed of course), but going away from the Rails standard and using raw SQL can get it down to a single query to grab everything you need. I'm no expert with Rails but I've noticed a lot of needless queries that I've been able to eliminate by taking a step back and thinking from the perspective of I don't want to hammer my database. But this comes from years of maintaining a site that had 400 concurrent users circa 2002 when servers were woefully underpowered. And with my voting feature, I could use MySQL's replace to get it down to a single query but I'm loathe to do that as Rails is database agnostic and going with database specific features is frowned upon. Why, I'm not sure. Seems like we should be using any tools at our disposal to build better apps, so I may end up going that route as I'm fine with locking myself to MySQL. My project won't need any PostgreSQL features and can benefit from MySQL's speed. 
Completely agree. I love Rails for everything it does and when I hear Rails can't/won't scale, my first thought is you're probably not using it correctly. You can't just drop in a couple dozen gems, wire them up, and expect to support thousands of concurrent users. But you can get a prototype out the door quickly and then write a great Rails project that scales very well IF you focus on efficiency.
Interesting, I'm actually looking to break out a core Rails application into services/SOA and using Roda along with Sequel (both the same author). ROM still seemed to stuck in the object-data mapping paradigm where behaviour lives in data objects. My preference is for dumb data objects with business logic organized in service objects. Think thin controllers *and* thin models, with fat service objects. Although "fat" is probably the wrong word since the service objects are typically single purpose.
Hey there, I am a cofounder at Honeybadger and maintain our Ruby gem. You're right, we do a fair amount of automagic-framework integration. I think there are tradeoffs to both approaches, and I also think if you go the automagic route (as we and many others have in Ruby) you have a greater responsibility to make sure your gem works everywhere. My solution was to detect which frameworks/gems are available and then load integration code on a case-by-case basis, in relative isolation (meaning if something fails, the integration is just disabled and the rest of our gem (and your app!) continues to work as expected). I have also written many of our client libraries for other languages, and in most cases have taken a more opt-in approach to framework integrations (for Node or Go, for instance). I think I personally prefer the latter style, but I also think that many Rubyists expect us to "just work" without having to manually add our Rack middleware to their Rails app, for instance. I wish I could please everyone, but have never succeeded at that so far. :) Anyway, all that to say that you [can absolutely use Honeybadger without Rails](https://github.com/honeybadger-io/honeybadger-ruby#honeybadgernotify-send-an-exception-to-honeybadger), and we have lots of folks who do. It's also possible to disable our plugin system entirely, which is what performs most of the automagic stuff I mentioned. If you know of any specific issues which have prevented you from using our gem outside of Rails, I would love to spend time fixing them. [Issues are always welcome!](https://github.com/honeybadger-io/honeybadger-ruby/issues/new)
All apps should log to STDOUT and let the OS redirect the output wherever you want, logfile, syslog, etc. I'd like to see a proper binary with Unix-style `-v -v -v` CLI verbosity tuning. Default to WARN, use -v to get INFO or -v -v to get DEBUG. It would be nice if Puma could do this for us. ENV variables are such hacks.
&gt; From my own experience the main issue I've run into is a reliance on letting Rails do everything. I call it lazy programming. Just because Rails can, doesn't mean Rails should. By that I mean there are situations where using a gem to add a feature is quick and easy but not always the best course of action. I agree with you, but adding a third party gem is not "letting Rails do everything". 
&gt; in fact, it allows you to do whatever you want. I understand that, which is why I was surprised to see OP saying they found "Rails didn’t offer enough supporting architecture," and ROM was somehow the answer. These things don't usually go together. 
What ROM gives you, is a way of separating persistence from your core app logic without the burden of a heavy object-releational-mapper. That's the vital part of rom-rb + dry-rb "stack", among other things, like component-oriented architecture with abstract dependencies provided by the container or separation between "web front-end" app and core application.
I'm not really understanding the argument. You mention letting Rails do everything but use third party gems as examples. Is it somehow Rails' fault for having an ecosystem? Would the same issue not exist in any framework that is popular? &gt; First attempt was with acts_as_votable which seems to be the standard in the Rails world. Setup sign caching enable it's 14 queries to cast a vote in my project. Chances are you had some issue with how it was being used as it definitely doesn't trigger 13 queries per vote any time I've used it. &gt; And even using something like closure_tree you're still pulling comments on multiple items. When you have a page showing ten items, each of which may have comments, you're up against the N+1 problem. That doesn't require an n+1 query... &gt; I'm no expert with Rails but I've noticed a lot of needless queries that I've been able to eliminate by taking a step back and thinking from the perspective of I don't want to hammer my database. It's probably true that you could reduce the number or improve performance of some queries by hand optimizing them. But there is no systematic issue in Rails with the number of queries generated, all the tool exist to avoid n+1 queries and other issues. &gt; And with my voting feature, I could use MySQL's replace to get it down to a single query but I'm loathe to do that as Rails is database agnostic and going with database specific features is frowned upon. Rails, as a framework tries to stay agnostic, although it's not always the case. There is nothing saying your app should be agnostic and personally I think it's somewhat silly to try to do so. You can always write raw SQL any time you need it, all the facilities to do so are provided. &gt; My project won't need any PostgreSQL features and can benefit from MySQL's speed. Not sure I understand this statement but Postgres isn't 'slower' than MySQL in any meaningful way. 
Regarding Rails itself, I didn't intend to knock it. I was merely suggesting that people generally seem to drop in gems when a tiny bit of custom code could serve them better. When I first started, I was using gems for everything and wondering why my app wasn't very fast. Then I realized I was using a lot of gems that were bulky and designed very adaptable to many situations where I had a very particular situation. At the time I hadn't yet learned how to code those features myself. I wasn't trying to attack Rails at all. I was only offering my opinion that sometimes using a bit of raw SQL rather than relying on ActiveRecord or writing some code instead of just dropping in a gem will yield better results. Regarding my N+1 issue, I setup comments with closure_tree on a page with statuses. The way the closure_tree gem is presented is that it pulls comments for a single item. Thus, when I load ten statuses, I need to call status.comments.hash_tree and I get my comments for that item. This causes an additional ten queries. The gem uses raw SQL for it's query to pull the comments and while it looks to be possible to somehow include that in my query that pulls the statuses, I wasn't able to do so. Regarding acts_as_votable, I didn't really have a problem until I enabled caching. It then fired off a number of queries to get the various counts. And just to submit the vote itself, it has more queries than it needs. It's designed to be easy to use and something that anyone can just drop in and go. I'm not saying it doesn't work, I'm saying you can do it more efficiently. For example, since I know what is being voted on, who is voting, and how many votes the item currently has, I can pass in those three pieces of information and not have to query them. That's three queries gone. Further, because it's getting the actual count, if an item currently has 5 votes, you click to upvote it, and while you were on the page other people voted, what it returns is the correct number but that's not what a user is expecting. They are expecting if they vote up, it will increase by one, or conversely if they downvote, it will decrease by one. Regarding MySQL vs Postgres, in the comparison I've read if you are primarily doing selects, MySQL seems to be faster. I haven't actually compared them side by side. To be perfectly honest, I've been wanting to learn Postgres but I'm intimidated. I wasn't meaning to knock it at all. I know it has a lot of features that MySQL lacks and is superior in many ways. In my limited research it appeared the general consensus was if you didn't need the features, MySQL could be the way to go.
I agree it's common in Rails land to make the mistake of using gems when you don't need to, or when they cause more trouble than they are worth, but I wouldn't say it's the "Rails way" in any way. As far as the AR vs SQL, I know what you mean I think. It's often possible to get perfectly good efficient SQL by using ActiveRelation, but you have to know what you're doing in SQL, and it can sometimes be more confusing than just writing the SQL yourself (which of course also requires you to know what you're doing in SQL), sure. 
&gt; Regarding MySQL vs Postgres, in the comparison I've read if you are primarily doing selects, MySQL seems to be faster. I haven't seen the benchmarks, would be curious to. If there's a minor advantage in speed for MySQL for some kinds of selects, I think that's probably still not a good reason to choose MySQL. But "I know MySQL, and haven't had the time or reason to figure out postgres yet, or even to figure out if it's better" is reasonable. But, yeah, it's better. My impression of "the general consensus" is different than yours, my impression is "the general consensus" is: Just use Postgres. 
I'd say it is not a rails thing but something else. You see the same effect in the javascript/node ecosystem with the left-pad nonsense. I would rather say it is a symptom of the many write once but never come back and maintain web sites that are written for one time purposes. People need to learn that having lots of dependencies are a long term maintenance cost.
It (a) hasn't been updated for rails 5 (yet) and (b) has a few gems that we don't use in _every_ project (omniauth, for instance); but, [Gemfile](https://gitlab.devfu.com/devfu/base/blob/master/Gemfile) is a good example of our basic stack.
&gt; Either way I'm curious if you compared it with Sequel at all? rom-sql adapter uses Sequel's DataSet API under the hood. Sequel itself is better than AR in Rails but at the end of the day it's still an Active Record and an ORM. I've moved away from typical ORM concepts and prefer pure data-oriented approach and "immutable" values.
With the addition of [TimeHelpers](https://github.com/rails/rails/blob/master/activesupport/lib/active_support/testing/time_helpers.rb) in Rails 4.1+ (namely the `travel_to` method), do you still have a need for `timecop` in your stack?
&gt; MRI's tooling is so bad What issue are you having? I've generally found MRI much easier to profile than other VMs, e.g. the JVM profiling tooling has a wonderful habit of lying. 
I wouldn't use `hash_tree` at all, just recursively descend the children. 
I think another big problem with Rails is that it's implied that you have read some amount of documentation to even be able to begin working within the system, so your ability to write good Rails code is dependent on the completeness of your knowledge with the system. This is embodied in 'convention over configuration', it's faster but at the expense of the time you will spend reading how to figure out what the correct convention is.
Makes sense. Thanks for the post.
Latest Rails, Passenger/Apache, React 
Thanks — I'm getting up to speed on Virtus and all the alternatives. I think that my implementation should be the fastest, though: because it only does checking on object instantiation, and later only if asked, e.g. with `#valid?`. It literally adds validations, not continuous type checking. (?) I should really document my [#check_validations! method](https://github.com/dogweather/validated_object/blob/master/lib/validated_object.rb#L62-L67): I reproduce the Rails-style list of validation errors, which is incredibly useful. Instead of quitting on the first error, all the validations are run providing complete info about all errors — not just the first one found: def check_validations! raise ArgumentError, errors.full_messages.join('; ') if invalid? self end Also my code is really only about 15 lines because it's essentially AR:Validations. As crufty as it is, I like re-using my knowledge of how to write Rails validations.
I've recently discovered [thoughtbot's stack on github](https://github.com/thoughtbot/suspenders). I'm going to try out a couple new tricks from there, specifically the [bullet gem](https://github.com/flyerhzm/bullet) for catching N+1 queries.
&gt; What's the state of the art? not really a state of the art issue, unicorn has been a bad idea for years. puma / thin / passenger are the current options. puma is the default in rails 5 and probably the best goto.
&gt; unicorn has been a bad idea for years This is just an (unfounded) opinion, right ?
You've made the original claim without arguments, so it's you who should provide them first. Btw. stack of Unicorn behind proxying nginx is a very common deployment solution, but probably there are so many people mistaken …
Nothing is "unmaintainable" in the literal sense of the word, it's just a painfulness threshold that is different for everyone. You say "warty, hard to reason about, needs a rethink" and another person says "unmaintainable" – it's the same thing. So you cross a threshold and start refactoring. As part of refactoring, you replace certain Rails features with other libraries, or write it yourself. Depending on how far you go, you might not be adhering to The Rails Way™ anymore, and at that point you start questioning whether you need Rails at all. If you're not using 90% of the Rails features, maybe you can switch to Sinatra or Roda without much effort. You're not being _forced_ to switch, maybe switching fits into your architecture better. There are pros and cons to ditching Rails, as always, but I think there are definitely situations where it makes sense. I could go on about this topic forever, but if anyone is interested I suggest they check out all the gems made by [Piotr Solnica](https://github.com/solnic) and [Nick Sutterer](https://github.com/apotonick).
&gt; That's from 2009... and still valid in 2016, after 7 years … Ie. in a contradiction to what you've claimed - *"unicorn has been a bad idea for years"*. At least Github devs don't find it bad, proven in practice.
&gt; I reproduce the Rails-style list of validation errors, which is incredibly useful. Instead of quitting on the first error This is actually an anti-pattern that is now being cargo-culted. Validations depend on each other very often, blindly applying all validations to get all error messages leads to more complexity. This is the reason why dry-validation is based on predicate logic and has type-safety as a first-class feature. You can safely define all kinds of rules and they will never-ever crash because of type errors AND we can still provide all error messages by generating "validation hints" from rule definitions. That's how dry-validation is multiple times faster than AM::V.
Use cocoon if you want to dynamically add form fields to the form. Otherwise accepts_nested_attributes gets you there. If things get too complex, build your own custom form object. 
Do you have some open source project that I could take a look? Are you familiar with the Hanani (old Lotus) framework? 
Choosing your tech stack based on what Github has twisted and modified to their likely isn't a stellar idea. Last I knew they were still trying to get to a place where they could upgrade to rails 4 and didn't get to Rails 3 till almost 2015 (after 4.1 was out).
&gt; I handle timeout in ha-proxy. But that doesn't stop the request thread in Puma. &gt; Instead you tune the # of forked processes, and the GIL is always an issue. You are stretching it. By that I mean you don't have thread waiting on each other because they are doing CPU bound tasks, i.e. rendering JSON or HTML. &gt; The primary reason to use a threaded server is to allow parallel processing during IO on MRI And you get exactly the same thing with multiple processes, plus parallel processing for non IO tasks. &gt; For that reason you have to always run it behind a reverse proxy I wouldn't recommend exposing any app without a reverse proxy. You talk like having a threaded or evented server was giving you unlimited capacity, that is wrong. You always have an hard limit on the number of concurrent requests you can process, and you always want to protect yourself form slow clients as up as possible in your stack. I'm not saying Puma is worthless, but Unicorn isn't either and it can be a very good choice based on your use case.
If the warning is just in the log file, I'm pretty sure nobody's ever going to see it. Rails log files are a mess by default, and very hard to get under control. 
Perhaps they're demonstrating the difference between `capitalize` and `capitalize!`, the latter modifies the caller in-place.
&gt; TimeHelpers I didn't know that exists! Thanks! Should be able to clear out some specs now.
Thanks for the input. I'll definitely look into that refactoring that you suggested. 
Unfortunately my experience is mostly from work. We mostly use [Padrino](http://padrinorb.com/). Our models only contain logic to create, query and manipulate persistent data. Majority of our supporting logic is in `lib/`, in the form of reusable mixins, single purpose modules (ex: caching), non-persistent data structures, and API clients to internal micro-services. The API clients are small classes that use either [RestClient](https://github.com/rest-client/rest-client#readme) or [Net::HTTP](http://ruby-doc.org/stdlib-2.3.0/libdoc/net/http/rdoc/Net/HTTP.html) and handle parsing JSON and handling network exceptions.
&gt; Examples include: doing Jasmine tests that actually test some HTML population/content/rendering, but don't talk to any API; doing controller tests that perform much of the permutation testing over my API, but without needing to go through the interface; doing request tests that verify that information returned from the server is indeed a PNG or PDF. You are hitting on something really important, here. I think the end result is such a severe blurring of the lines between the original meaning of "unit" and "integration" testing that it becomes more of a continuum. One one end, you have high isolation, low coverage per LoC, and absolute determinism. On the other end, you have low isolation, high coverage per LoC, and non-determinism is a factor that must be controlled. In my experience, the determinism and easy debuggability of isolated tests nudges teams towards favoring primarily isolated tests, with some coarse grained testing ensuring that all of the components "fit" together. Fully integrated tests are often solving problems better suited for a monitoring system. What you are describing, using something like Jasmine to test the GUI with the actual application out of the picture, is a fantastic way to test the "web interface" part of the application stack.
Oh, this one's easy. def sorting(*arr) out = [] [*arr].flatten.map{ |x| Thread.new{ sleep x; out &lt;&lt; x } }.each(&amp;:join) out end Go ahead and turn that in for your homework assignment. I dare ya. :)
After thinking through merge sort, I think this is what OP's assignment is Socratically trying to achieve. In particular the `#merge` method of that sample. That having been said, recursion in Ruby sucks. In my IRB, I can mergesort arrays a couple of thousand integers long, but you DO hit a stack overflow eventually. It is not a lazy language built for recursion, and you probably Just Shouldn't Do It^TM
I recently joined a company with a sizeable grape api (in-rails). It's very effective and makes building new versions/endpoints straightforward, turning what would once have been a mess of varied approaches into a unified system. It is a bit tricky to write good tests for though - the helpers are complicated to mock/stub, and the endpoint tests are essentially all integration tests, meaning that they all require database support and are therefore slow. If anyone has a solution to that last problem, I'd love to hear it please!
Even though it's most definitely a homework problem, and you won't learn anything by copying this, I still felt like solving it. def sorting(a1,a2) arr = a1+a2 out = [] while arr.count &gt; 0 i = arr.min out &lt;&lt; i arr.delete(i) end out end 
We have a Rails app with a number of Grape controller classes mixed in at work and I mostly like it a lot. The parameter declarations and namespacing are great and I love Grape::Entity, though there is nothing keeping someone from just using that anywhere else. I think I prefer Grape::Entity over jbuilder and certainly rabl at this point.
If you don't mind using full fledged form objects you could try [reform](https://github.com/apotonick/reform)
the problem is that i cant duplicate the arguments so i can't use arr = a1+a2 ...
thank you so much for this explanation!! recursion is still a little confusing for me but this is definitely helping me understand a little more. xx
Can be confusing if you start with a super complicated guide without nailing the fundamentals. You have: - ruby itself (the interpreter) - ruby gems that you can think of as packages (the packages) - bundler which manages sets of gems (a way of managing package dependencies) - tools like rbenv and rvm that manage ruby environments (a way of managing multiple versions of ruby / package locations) http://guides.rubygems.org/rubygems-basics/http://www.justinweiss.com/articles/how-do-gems-work/ http://stackoverflow.com/questions/5233924/what-is-a-ruby-gem Most things are some sort of location an path manipulation that let ruby know where to load the code from.
This is a bad practice write implementation specific code, unless there is a very good reason for it. Even MRI may have GIL removed in some of its future versions and original program would suddenly behave differently.
Fun theory, impractical in reality.
exercism.io
https://rubymonk.com This helped bring me from entry to intermediate level.
It's not a coincidence, it's design. If you're curious about these topics and how implementations vary I would recommend reading the source for `concurrent-ruby`. e.g. here is the implementation for concurrent array: https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent/array.rb. You'll note that the implementation for MRI just passes through the stdlib implementation. 
coderbyte.com codewars.com 
codewars.com
[rubymonk.com](https://rubymonk.com/) - I've made biggest progress in ruby because of this site [exercism.io](http://exercism.io/) is great - challenges + advices from other users. But you don't write code in web browser (which is good), so I'm not sure if it should be considered as 'online' I don't know codingbat, but maybe hackerrank.com may be good, they have [ruby tutorial](https://www.hackerrank.com/domains/ruby/ruby-tutorials) and more
To be fair the comments in the code do not exactly inspire confidence: &gt; # Because MRI never runs code in parallel, the existing &gt; # non-thread-safe structures should usually work fine. "should usually" work fine? Um, great? Concurrent code is hard enough, I need guarantees it will work as it should, not "should usually work fine." But perhaps later someone was more confident than the original comment writer, at least based on the present MRI implementation. Either way, the benefit of concurrent-ruby is if someone _does_ discover it's not guaranteed 'fine' after all, they'll fix it in concurrent-ruby and you can just update your version. 
looks interesting, thanks. 
*coincidence*, because the ruby code being discussed is not thread-safe and wasn't specified as MRI-only. I'm aware there is produced a lot of poor and/or unportable code everyday, but never would admit this is ok. I'm happy projects I'm working on do care about quality and correctness and important topics like proper threads synchronization aren't thrown out of the window. Thanks for the link, as a demonstration how it shouldn't be done. Hope it eventually get added thread safety also for MRI as it would mature.
&gt; Thanks for the link, as a demonstration how it shouldn't be done. So open a PR that adds locking to `Array` on MRI, I eagerly await the discussion. 
I'd recommend [Practical Object-Oriented Design in Ruby by Sandi Metz](https://www.amazon.com/gp/product/0321721330/ref=oh_aui_detailpage_o04_s00?ie=UTF8&amp;psc=1). 
I feel like the controller layer is so thin at this point that it's pointless, and you're just adding more complexity with another layer and another dependency.
&gt; Tired of writing the same old CRUD actions over and over? So instead of writing them in one class we write them in 6 classes? (1 controller, + index, show, create, update, delete operations) &gt; or of filling your controllers with difficult to test logic? I don't do that anyway. &gt; no one likes integration tests when it comes to web requests I love them, much more valuable than unit tests, they tell me what the thing is actually supposed to do... 
I usually generate resource or scaffold with rails. Is this better?
1) There are many ways to manage your ruby versions. rbenv and rvm are the most popular. They let you have multiple ruby installations and muck with loading in different ways (rbenv uses shims; I believe rvm uses PATH). Each provides the idea of "gemsets". These let you isolate your gems between projects within a single ruby installation. In general there isn't much use for these anymore and you should prefer Bundler. Bundler is the idiomatic way to manage a project's dependencies. You specify your dependencies in a Gemfile, then when you do `bundle install` a Gemfile.lock will lock the versions of each of your gems (as well as their dependencies). Bundler works by maintaining a separate directory structure where gems are installed. It modifies the GEM_LOAD_PATH env variable (I forget the exact name of it) and injects itself to run at load time with whatever command you `bundle exec`. The end result is that Bundler gets to choose which dependencies get loaded instead of the default Rubygems mechanisms. TLDR; Bundler manages gem dependencies 2) As linked previously, Rubygems has an excellent tutorial that I recommend running through. In general Rubygems are very flexible. The file structure is based on what you define in the `*.gemspec` file. There are some common conventions however
Yeah, but when you have two interfaces to your business logic Policies, Actions etc really can help. Typical use case: you have a rake task to import external data in bulk, or sidekiq worker in addition to dealing with web traffic via REST. Being able to simply define whats allowable or not in one spot becomes a boon. Ditto testing: you get to write many more fast scenario tests with fine control, as opposed to controller level tests where network, DB, etc can contaminate your test results.
I'd recommend Eloquent Ruby. POODR is great but it's more a book about OO which happens to be in Ruby.
It would be in addition to. So, maybe: rails g scaffold resource_name And just include SkinnyControllers::Diet at the top. If you are going to have some logic, you'd: rails g operation resource_name If there is authorization logic, you'd raills g policy resource_name Both policies and operations are optional :-) But the controller actions can have render json: model Without the two extra files. It's the diet that provides that ability :-) Hope this helps!
http://codereview.stackexchange.com/ is your friend ;)
https://codenewbie.slack.com/ has various channels including ruby, rails etc. 701 active users. There's also https://rubyonrails-link.slack.com/ with 443 active users. I've not been on either for a while, but they seemed pretty good places to share knowledge and learn.
Thank you. I'll check them out. Edit: I didn't realize this at first but I've applied to the second one you listed twice and never received an invite. It just asked basic info so I'm guess they aren't receiving application emails. Or maybe they just didn't like my name. Lol
[removed]
Buy a book?
&gt; For my particular app, I sometimes have a hundred or so lines of code for an action, so taking it out of the controller has bee hugely beneficial from a testing perspective. That's when you refactor, maybe use a service object
I did refactor, and ended up with a pattern that resulted in the gem. :-\ I do use service objects, but there is some business logic where it doesn't make sense to have a service object, especially if you have enough of that kind of logic where it can become its own layer (operations). :-\
I think this would be perfect for you: https://blackbytes.info/ruby-course/ It's specifically designed to help you develop a deep understanding of the language. It contains over 50 code examples &amp; it also has some exercises. In addition, it comes with a set of mindmaps that explain all the important Ruby methods. 
I'm looking for something that will help me 'master' the Ruby language. Of course that can't be done with just a book but I'm looking for something that will just overall give me a better understanding of the language.
This sounds like something I'm looking for. How does Eloquent Ruby compare to Well Grounded Rubyist?
I haven't yet read 2nd edition and have sold my 1st one. Quickly browsing through 2nd ed I'd say it worth reading.
I'm afraid I can't offer an opinion on which is better - I've never read The Well Grounded Rubyist. I can say that Eloquent Ruby is not just about learning Ruby, but also about learning the "Ruby way" of doing things; basically, how to write Ruby code that looks and feels like Ruby code. It's good if you want an understanding not just of how to do something in Ruby, but why it's done that way too.
Honest question, not trolling: can someone explain if there are clear benefits to using RM over Sublime Text or Atom (for example)? I've been using both of the latter for ever, and the last time I tried RM out of curiosity it felt overly complicated and bloated... Haven't tried again since (~7 months)...
I'm usually "no book" but there's a book called Rebuilding Rails. Read it. It's fantastic and you'll learn a ton.
It also helps to have a good understanding of Ruby before you learn Rails or at least as you learn it, so that you don't feel completely lost. One of the best books I have seen on Ruby is Manning's [The Well-Grounded Rubyist](https://www.manning.com/books/the-well-grounded-rubyist-second-edition). Though of course there are lots of great free resources too, like the Codecademy series on Ruby. Another Rails resource I could mention is [a MOOC on Coursera](https://www.coursera.org/specializations/ruby-on-rails) presented by Johns Hopkins University. If you like being kept at a pace and learning by watching videos then you'll enjoy it. I completed the first part of it and really enjoyed it. It's considered a free resource, because Coursera allows you to audit courses (not get an official certificate) for free and they offer financial aid to cover the cost of the certified option for anyone who applies.
&gt; i want to create a new array without using sort Yes, your answer is the "sensible" solution. This is roughly what we'd all write under normal circumstances. But it's not what the OP asked.
In https://www.railstutorial.org/ Michael Hartl recommends starting off with Cloud9 IDE, that way you don't need to worry about OS specific issues and the environment is already setup and ready for you to start coding. 
If you want to build iOS apps, you must get a Mac.
I'd argue that atom is very much an IDE. Well, I usually do. Barring Visual Studio, I've yet to come across a more integrated environment for development, be it frontend or programming. 
mmm, ok no budget for that. let's just stick to android then
Can we stop telling people not to use an IDE without context? Atom is, for all intents and purposes with the right plugins installed, just as much an IDE as something like Rubymine, so what's the point in telling someone not to use something, just to recommend they use it by calling it a different name? All an IDE is, is a text editor with tools attached to it. My Atom looks a lot more like an IDE with it's folder view, syntax highlighting and additional tools than it does a text editor like Notepad or Nano.
well I do have a server that runs on vmware esxi,can i install osx on that just fine? ive never used osx or a mac ever.
Anything but Windows. They'll tell you ruby/rails run on Windows which more or less it does but the pain of running a rails production server on Windows is horrendous. 
&gt; That's fine by me. My point was to prefer a lightweight text editor with optional plugins over a product that is an IDE first, editor second. Perfect, and I appreciate that. I still prefer Rubymine to Atom for Rails development, if for no other reason than the fact that it probably saves me 10 minutes on every hour of doing things like automating git tracking (There are lots of others, actually, but seriously that alone *would* be enough for me) but I don't recommend it, especially to students, if for no other reason than the fact that it's not free. I definitely don't recommend students learn something like Eclipse or one of the other big no-cost IDEs with a Ruby plugin because it's much like getting an entire tool chest for automotive simply to have a few screwdrivers and a socket set. There's just so many parts that won't be used. That being said, Atom is a good middle ground with plugins and the right settings (A tree-style folder view, syntax highlighting, lots of other quality-of-life bits) and is intensely lightweight. vi/vim is, in my opinion, essential if you're going to be spending a lot of time on a linux machine if for no other reason than the fact that it's ubiquitous. I agree that the argument goes round and round, but largely I tend to think that's because of knee-jerk reactions. I don't intend to argue, just sharing a viewpoint that isn't terribly different (but is one held by a happy IDE-user).
to those down-voting: let me know how i could've improved the post or if it was off-topic for the forum.t hanks.
I disagree about not using an IDE. I have Emacs, TextMate, and GEdit all set up for Ruby development, but I still 'live in' RubyMine most of the time I am coding Ruby. The instant syntax warnings, autocomplete, and all the bundled tools save me a ton of time.
Why not just start with java then? Windows or Linux are both fine for Android development. 
Not Windows. Spin up a Linux VM with vagrant if you're on Windows, or just use Linux. Macs are great if you're just looking to buy a computer but I wouldn't buy a new computer just for this purpose. I say use vagrant because then you can just ssh into it, and it's automatically headless, has a shared folder, and has things you need installed. 
+1 Eloquent Ruby is my favorite Ruby book by far (and I've read many of them). The best thing about Eloquent Ruby is it teaches you how to write good, idiomatic Ruby while also teaching you the concepts
Why the RubyMine hate? It's a good product and good for beginners who want a simplified intro to working with ruby? 
but.... it is free for students.. I seriously think RubyMine is one of the best things to debug ruby with. Though once you get experienced enough it's not really necessary anymore. Though it is nice. 
you don't need to get a mac, you can build a hackintosh, but it's probably not worth it.
If you want to develop iOS apps you'll pretty much need to buy a Mac. If you want to write Android apps, learn Java and use the Android Studio IDE.
Linux/OSX and vim. Everything else is bloat. 
What a mess...
Whatever you do, don't use the Window version of Ruby. It works most of the time but it's nothing but trouble. I run Windows as my main OS so I have Virtual Box running Linux for Ruby work, it's the only real practical solution for now. Microsoft is releasing its Linux runtime for Windows soon though, Ruby and all the Linux tools should run very well on that so if you're on Windows you won't need virtualbox for long. And as you said a mac is out of your budget, this is your only real option. That or install Linux and dual boot, but if it's just used for Ruby development that's a bit overkill. However, if your aim is to make apps I don't know why you chose Ruby. There are some tools to make apps like RubyMotion but I don't know why you'd use them. I don't know anyone who does use it, it's bound to be undermaintained. If you want to make apps, why not learn Java and/or Objective C? And there are other cross-platform ways to make apps that are a bit less niche, such PhoneGap (and other similar projects, they let you run HTML5 as an "app") or Xamarin.
Is there a better asset pipeline out there?
Would you agree that for a beginner it's better to start with a simple text editor instead of an IDE which has many features that could be overwhelming when starting out?
You can use Windows if you want. It installs pretty easily and you'll be able to do most things it's only when you start using Gems with C extensions you'll hit problems. However there's now another alternative on Windows: Ubuntu tools for Windows have been created and it runs a native bash shell so you don't need to run a Linux VM. Here's a video about it which includes a demo of using Ruby on Windows ... https://channel9.msdn.com/Events/Build/2016/C906
I'm a big fan of JSONAPI.org as standard. Mostly because it takes a away a lot of unnessary thinking and designing. By not having to design yet another paging system or HATEOAS linking scheme. Allowing focus on the actual application. However, I met some resistance with our IOS devs, some difficulties with the Android folks, because the jsonapi.org is opinionated and has poor implementation in libraries like RESTkit. (Which actually lead me to conclude that RESTKit is not REST at all) I have not yet seen the need to add another layer on top of Rails. With Controllers, Service Objects, Models and jbuilder (or Serializers) views it is not hard to implement JSONAPI.org schemes at all. How would having their own controller abstractions and own serializers/presenters help me organize my code better? Would this extra layer of complexity not add even more indirection and therefore confusion and therefore hard to debug code? Looking at the code: I like that the JSONAPI Resources are rather simple and clean objects that I should inherit from: a great design choice. Especially since in Rails it too often happens that some gem gets magically injected in all your models and all your controllers (looking at you, devise). 
No RubyMine hate here. I just recommend going through the learning process without the many "makes life easier" tools that RubyMine provides. That way you develop a deeper understanding of the language. It's the same reason I recommend not using generators when learning the Rails MVC structure.
How would you describe that useful tidbit -- what is the useful tidbit contained here? What is it you are intending to demonstrate/share? I am not certain. What is `wrapped_ap`, where does this come from, you just wrote it yourself? What do you mean by 'wrapping ap in wrapped_ap does work', what does that look like/mean, 'work' how -- and why? You seem to be missing a code example for this 'wrapping', but maybe not, the fact that your code examples seem to have the linebreaks removed makes them kind of illegible -- at a bare minimum, get line breaks in your code examples. Why do you think any of this has anything to do with 'streaming', what do you mean by 'streaming'? Use a title that succesfully summarizes your content to your audience (it's not about streaming anything). Your big reveal is that `map` and `each` are not synonyms, something I'd hope is not a surprise to many -- is that the useful tidbit, that map and each are not synonyms? If so, even though most rubyists know this, there might be an audience for such a blog post, but such content would focus on the difference between map and each, not get lost in `awesome_print` and `&amp;method`, and explain the difference clearly and correctly with good examples. This code: `["some", "list", "of", "stuff"].map(&amp;method(:ap))` is very odd. I'd just write `['some', 'list'].each { |s| ap s }`, and am not sure what benefit your alternate more confusing way of doing it with `#method` is supposed to bring. I am not sure why you use `map` instead of `each`, unless you want to get the results in an array? Which won't work anyway, because `ap`, like `puts`, prints to stdout but returns nil. You discover yourself it won't work in the end -- but miss the main point that the reason it doesn't work to give you an array of output is because `ap` returns nil rather than a formatted object. If you're using `map`, you need to pay attention to the return value of each block, that's the point of `map`. (Is there another method in `awesome_print` that actually returns formatted strings so it could be used in this way? Or a way to get awesome_print to do that? That would be the logical next thing to look for.) What's the point of any of this code, what are you trying to accomplish? It seems like a more confusing version of the more straightforward way to do it with unclear motivation. You don't even end with a final 'solution', once you discover map and each are not synonyms, although it's also not clear what problem you are trying to solve in the first place. If it's meant to be sharing your journey learning the basics of ruby -- it would be more useful if you understood the concepts better before trying to share them. I am not sure what you are trying to share, or why it would be useful to anyone. It just reads as somewhat random disconnected thoughts on unrelated ruby misconceptions, without fully explaining the underlying concepts that were originally misconceived. I don't intend to be mean, but you asked why people are not finding this post helpful or useful, that's my review. I'd: spend more time editing, think through what it is you want to demonstrate and how, not just a stream of consciousness; look into the fundamentals of what's going on and have a good understanding of the concepts before trying to teach them to others; make sure you can format your code examples with at least line breaks, if not syntax highlighting; make sure you have a code example for things you are discussing that may not be clear what you're talking about (eg "wrap in `wrapped_ap`"); if the point is to arrive at a good/the best way to do something, you have to clearly explain what that 'something' is (what you're trying to accomplish), and actually end with an example of a good/best way to do it (and be somewhat confident it _is_ a good way to do it before suggesting it to others. Being able to explain why you are doing it and why it's a good way to do it are probably a prerequisite to being confident it is a good way to do it). 
why would i use this rather than google?
so you mean it's structured data
Careful being lulled into a false sense of confidence. Cyclomatic complexity (i.e. `if` statements) in both your controller action and your views can introduce variability and non determinism to the output of this method.
This is useful. Somewhat related question: Is there a way to completely block any database activity at all in views? I try to practice this but it would be nice if I could enforce it. For example: # in `things_controller.rb` def index @things = Thing.select(:column) end # in `things/index.html.erb` &lt;% @things.each do |thing| %&gt; throws error: &lt;%= thing.other_column %&gt; &lt;% end %&gt;
I like this idea. Gems like [bullet](https://github.com/flyerhzm/bullet) help with stuff like this, but it would be cool to just throw an error in dev.
what linux
&gt; I have it in the same folder as the script And which folder are you *running* the script from? With that code example, your file needs to be specified as a relative path *from the location that the script is being run from*. (Or, an absolute path.) &gt; but still gives me errors What errors? Where are you running the script from? Where is the script located? Where is the file located? I can't help much more without seeing the error.
I use ubuntu and its text editor. I suggest researching which distro of linux will work for your machine . It took me a few install to find the one that worked for this laptop. Ubuntu mint and puppy are good starer distros.
&gt; `nil` What command are you running, exactly? It looks like you're not specifying the filename, in the command. The first line of `ex.rb` says: filename = ARGV.first `ARGV` is a programming convention for "argument vector", i.e. a list of arguments passed in by the command line. You need to specify which file is going to be opened, by running: ruby ex.rb textfile *Not* just by running `ruby ex.rb`. This is the key difference between using `ARGV` and `gets`.
oh ok. I didn't get that from reading the lesson off the website. Anyway, I did that and it worked.
Do you have a source on that?
Here's my source (not the person you were talking to) https://www.urbandictionary.com/define.php?term=you+do+realize+... 
Drama aside, this was an interesting read. Thanks for posting :+1:
o_O that's an interesting stylization of of Emacs you've got there For those who are curious, [RubyMotion](http://www.rubymotion.com) allows one to build applications for iOS and Android in Ruby (and it can be done free of charge nowadays).
Ubuntu is fine 
So it looks like honeybadger needs to be changed. Maybe the ruby docs should also make it clear what a danger Thread::kill poses. ATM there is very little written at all in regards to Thread::kill 
can you give an example? 
I have to agree. There is something to that "instant gratification" that comes through browser based experimentation and learning. Arguably this is one of the factors of the prevalence of JavaScript right now. Opal gives that kind of an experience. Having game libs like [`opal-phaser`](http://opalphaser.com) are a real plus.
Great info, good to know. I have a lot of controller tests on active projects.. I think I'll use the gem and slowly move it to the new methods in the future. It'll be a lot of work. 
Read up on some social psychology ;-)
&gt; Parse resulting HTML in the view? That seems all kinds of terrible. That sounds actually less terrible than coupling yourself to some instance variables. A controller (in web terms) is responsible for making sense of an HTTP request and returning an appropriate response. Why wouldn't you want to test at that level as well?
Haha, thanks for pointing that out. Obviously, I've been brainwashed by Apple a little bit!
I haven't read the post yet (I read the comments first) but I believe the idea is the controllers shouldn't be doing much and if they are that is a code smell. I agree that there are some cases where unit testing controllers is useful, but at work we've been trying to avoid those cases by making our controllers less complex and using service layers instead(and unit testing those).
Could you elaborate? I've never seen a production Ruby web app that didn't do both, unicorn, thin, puma, passenger all fork workers and all end up with multiple threads per worker regardless of how the application code is called. 
 string = "" tasks.each do |task| string += "#{task}, " end puts "#{string}" can be replaced with puts tasks.join(", ") which would also get rid of the trailing comma.
Wow, that's really useful. Cheers!
Absolutely amazing reply. I've managed to re format my code to include all of these additions, including the loop do There is one bit where I'm not quite sure what you mean, and that is: Keep working at it! A next step might be to think about ways to refactor your code so you're not writing the same thing over and over again. For example, subtraction is just negative addition, so maybe there's a way you could have calc_subtract negate one of its parameters and call calc_add. Could you expand on this further?
They mean that x - y is equivalent to x + -y, so you could just make the y operand negative and then plug x and your newly negated y into your addition function and get the same result without having to have an explicit subtraction function.
You have methods named calc_add, calc_subtract, and calc_multiply. I call this inferred name-spacing. I would take these three methods, create a Calc module and then have Calc::add, Calc::subtract, and Calc::multiply. This gives you explicitly name spaced methods. It also puts code for doing math in this module, separated very cleanly from your user interface code. Also, look at the rubocop gem. It'll let you scan your code at will for industry standard best practices.
I just took a quick pass at it but tried to clean it up a bit class Calculator OPERATIONS = %w( add subtract multiply ) attr_reader :num_a, :num_b def initialize task_from_input end def add "#{num_a} + #{num_b} = #{num_a + num_b}" end def subtract "#{num_a} - #{num_b} = #{num_a - num_b}" end def multiply "#{num_a} * #{num_b} = #{num_a * num_b}" end def operation_prompt print "\nWhat would you like to do? (type 'exit' to quit the program)\n" puts OPERATIONS.join(', ') end def numbers_from_input numbers = [] print "\nType two numbers\n\n" 2.times do print 'Enter a number:' numbers.push(gets.to_i) end numbers end def task_from_input operation_prompt user_input_operation = gets.chomp if !OPERATIONS.include?(user_input_operation) exit else @num_a, @num_b = numbers_from_input puts send(user_input_operation) end end end Calculator.new 
No, if cost is no object, use RubyMine while learning. Everything that can be automated, usefully should be automated. RubyMine does a lot for you.
Instead of having your `calc_(add|subtract|multiply)` functions deal with arrays, I'd instead "splat" the `ask_numbers` calls in your `case` statement, like so: case answer.downcase # ... when "add" puts calc_add(*ask_numbers) # ... and so on ... end # ... And then rewrite those functions to take two numbers, like so: def calc_add(first, second) "#{first} + #{second} = #{first + second}" end Basically, that little asterisk before `ask_numbers` tells Ruby to take the returned array and "splat" it into two arguments for `calc_add`. So, if `ask_numbers` returns `[4, 2]`, then `calc_add(*ask_numbers)` would translate to `calc_add(4, 2)`, which then would evaluate to `"4 + 2 = 6"`.
Got a gist from Zzak https://gist.github.com/zzak/770e49cf52b166e41eb3ecba497f58d8
Forking from single-threaded mode than spawning threads in the children is fine. Forking in a multi-threaded process is filled with peril and basically impossible to do safely in a language like Ruby. Quoting the FreeBSD fork(2) manpage: · The child process has only one thread, corresponding to the calling thread in the parent process. If the process has more than one thread, locks and other resources held by the other threads are not released and therefore only async-signal-safe functions (see sigaction(2)) are guaranteed to work in the child process until a call to execve(2) or a similar function. This is why fork() is so broken with JRuby - it's *always* heavily multithreaded, and the moment you fork all the GC threads, JIT compiler threads, signal dispatch threads, IO threads, all of them just *disappear*. If you're lucky it might hobble along long enough to get to a nearby exec() call, but you're at too high a level of abstraction to be able to guarantee that. MRI's in the same boat, really, but you tend to get away with it more often because it's simpler.
ha, yep. Thanks.
"HOW it looks." or "WHAT it looks like." not "how it looks like."
In addition to all of what's listed below - and it's great stuff! - let's also look at the logic of your actual may operations. These a coyote of ways you could go. What if someone wants to add 3 numbers? Or 5? Or any *n* numbers? What happens if you want to use the value from the first operation as an operand for another operation without reentering it? (Like how entering 5 - 2 + 1 will yield 4 on a calculator) What if you want to enter a statement and have it follow the order of operations? Just some other avenues that should help stretch your coding chops. 
Yeah, that's weird. I'll remove the link, I guess.
Good, more choice is better, but I always scratch my head a little when I come across a rails app not on Postgres. I'm sure there are reasons, probably very good ones, but it just seems peculiar to me
Thanks. How would this code look?
The api is _really_ simple, here's the reference to get you started: http://ruby-doc.org/stdlib-2.0.0/libdoc/csv/rdoc/CSV.html
It might be too soon, but I would try learning how to think about solving the problem in an object oriented manner, since that is the forte of ruby (along with many of the good parts of functional programming mixed in). The first part of that comes down to breaking up the problem into small pieces. Lets think about a calculator in the real world. The screen takes input one operation at a time. It tracks the last result, until you clear the screen. We can break up the operations into separate classes which calculate the result . I.e. class Calculation attr_reader :input def initialize(*args) @input = args @result = calculate end def result @result end end class Add &lt; Calculation OPERAND = :+ def calculate @input.reduce(&amp;OPERAND) end end # Add.new(1,2,3,4).result # =&gt; 10 (the *args you see above, just turns any number of arguments you pass into the method, into an array. So we can accept any number of numbers as input) Then, we have the actual calculator itself. It executes the commands one by one, calculating the next statement against the result of the previous one. Furthermore it has things like history and what not built in (if we are talking about a fancy TI). Lets implement those. class Calculator def initialize clear! end def add(*args) @calculations &lt;&lt; Add.new(@result, *args) @result = @calculations.last.result self end def clear! @calculations = [] @result = 0 end def result @result end def print! @calculations.each do |calculation| str = calculation.input.map(&amp;:to_s).join(" #{calculation.class::OPERAND} ") puts str end end end # screen = Calculator.new.add(1,2,3,4).add(1,2,3,4) # screen.result =&gt; 20 # screen.print! # 0 + 1 + 2 + 3 + 4 # 10 + 1 + 2 + 3 + 4 =&gt; 20 Put full example in a gist here: https://gist.github.com/jasonayre/2caef2c80814a00239b5efc7033d574d If you gem install pry Then pull it down and run ruby calculator.rb, you can run it in interact with it and get a feel for how objects and instance variables and what not work.
 load = double allow(Table::Load).to receive(:new).and_return(load) expect(load).to receive(:perform) Well, don't mix instantiating your dependencies with using them. Of course you're better off just using static methods if you don't pass in your dependencies.
The main one I know of is Postgres' poor support for master-master DB replication, in comparison to MySQL and friends. Yes, [DB replication exists](https://wiki.postgresql.org/wiki/Replication,_Clustering,_and_Connection_Pooling) in Postgresql. Historically, it was only supported by a myriad of 3rd party tools; core support is now getting better, but still [not as good as MySQL](http://dev.mysql.com/doc/refman/5.7/en/replication.html) etc. ----- Disclaimer: I do still use Postgresql for all my main production apps.
Link: [link](http://ruby-doc.org/core-2.3.0/Object.html#method-i-dup)
Design is not in question. Resource consumption is. But if it's possible to StackOverflow your user input method. Well that's bad design IMO. 
While I've only needed to use `each_cons` a handful of times, it's always been a lifesaver when I *do* need it. Trying to reproduce it with other enumerable methods always feels un-rubyish.
Are you looking for a cloud development solution? Cloud9 and Koding are both good options for having a RoR environment ready to go, if that's what you're after. If you have a mac, you've already got ruby and can install rails easily with something like the bundler gem. Codepen.io works for front-end development, but it's tough to work like that on the back-end like Ruby on Rails.
X-Post referenced from /r/pakyow by /u/tewls [pakyow 0.11 feature walkthrough](https://www.reddit.com/r/pakyow/comments/4g00xk/pakyow_011_feature_walkthrough/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^my ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Nitrous.io
[Runnable](https://runnable.io/product.html) although they seem to have changed their business model since the last time I've checked it.
AR philosophy is to integrate the M in the MVC, and make you look at it as a beautiful ruby object with an awfully huge method dispatch surface, while taking you away from what it is for: database-to-object mapping. It should abstract your code while still keeping you close to the metal and allowing you to use those unsexy (dare I say, unomakäse?) DB features like triggers, stored procedures, checks, views, security strategies (ACL users), etc. Sequel achieves this goal by not dumbing me down as a user and telling me exactly which features of my chosen or legacy DB I can use (DBs are quite feature-rich beasts, btw), while still allowing me to apply the active record pattern. You may take the "dumbing down" as a slight, but this is exactly what it feels. Think node.js: A whole generation of new programmers has been dragged into a language which was designed in two weeks, which lacks abstraction for parallelism, because they were told that it works in the browser, and since you'll have to learn it anyway... they even came up with a word for it: "isomorphic". So majestic. I've been using sequel for a couple of years, came to it because I needed low level support for extracting data from oracle databases and setting up AR was sysyphean and using the raw client was too unmaintainable. I started toying with the idea of maybe replacing AR with Sequel in most of our legacy projects, but didn't see the business value nor the killer feature. AR was accomplishing everything I needed, so why bother? Then the requests came: I needed to build some statistics page which required some more complicated queries than the AR query API could provide. it involved SELECT DISTINCT ON (we are using postgresql). I managed to do it in AREL, but not without "dirtying" myself with some raw strings in the middle of it. But hey, task was done, ticket closed. But then, we had complaints about another bottleneck: some external API consumption was being stored in the database really slow. Basically batches of data which had to be stored in rows, referenced by some combination of keys. The UPSERT case. Our AR implementation was basically trying to get the records from the db, if none was found then insert, otherwise update. One by one. These batch inserts were taking 15 to 22 seconds, sometimes more due to row locks. We had just installed postgresql 9.5, and I read that there was support for INSERT ON CONFLICT UPDATE syntax, which would work like a charm with multiple values. So I looked for AR support, and none. I looked for Arel support, none. I went over to sequel, and there it was. I benchmarked it, and my huge inserts dropped down to less than a second. The problem with it? I didn't want to maintain 2 separate db pools, so now I'm using Sequel as a DSL only to build the SQL, which I after pass to the AR raw connection. I'm using sequel as a glorified Arel! So now I've had it. Migrating my models to sequel became a top priority. This is a philosophy matter. AR is a part of a cake, and its goals are not the goals of the layer it tries to cover, but the tight integration with that cake. The whole release model of Rails, and therefore AR, kind of demotivates you from demanding or contributing these features, as you'll have to wait a year to see them. And every time one of these features gets accepted, it's a victory, but you feel exhausted. I still remember as prepared statements support came for AR 3. Huge. Foreign keys for 4.2 . Insane! Rails 5 will come with DSL for left outer join. About time! For how long has sequel had support for them? Sequel releases a minor version every 1/2 months. People ask for support for some feature, and they'll either submit a patch or Jeremy does. I saw the request for the support for ON CONFLICT UPDATE last month, and I didn't even care, until I needed it. My question is: when will this feature be added to active record? before or after I migrate my projects to sequel?
Using this form: Table::Load.new(file).perform has the advantage of allowing you to interrogate aspects of Table::Load.new(file) short of actually running perform on it. For example, suppose we want to boil down the contents of file to an intermediate state (e.g. an iterator over its normalized contents). We might want to simulate what .perform would do without actually loading the table. Using memoization, these intermediate states can actually be used when we finally execute .perform, without repeating the computation. For example: load = Table::Load.new(file) puts load.records.length load.perform is preferable to Table::Load.records(file).length Table::Load.perform(file) 
&gt; Might be a bug. lol
 require 'csv' array_of_arrays = CSV.read("./test.csv") array_of_arrays[0][1] = "column2" CSV.open("new.csv", "wb") do |csv| array_of_arrays.each do |line| csv &lt;&lt; line end end 
ELI5: what is ngram and its real world application. 
Suggestion: don't call syntax "beautiful"
Yeah cloud 9 is great you can write ruby scripts and hit the run button. It's super fast to check out code you've written 
http://www.text-analytics101.com/2014/11/what-are-n-grams.html
inspecting it with chrome devtools: [bug](http://i.imgur.com/i84678Z.png)
I'd say do this the same you'd do it mentally. Start out at the beginning of the list. Since we haven't found any numbers yet, the first number encountered is the closest to zero (so far). Remember it. Next, move on to the second item in the list. Compare it to the number you already have in hand. If the new number is closer to zero, forget the last number you were holding, and keep this one. If the number you already had is closer to zero, keep the old number and move on to the next number in the list. To perform this comparison, you first want to compare the magnitudes of the numbers, not their literal value. Ruby has a [Fixnum#abs](http://ruby-doc.org/core-2.3.0/Fixnum.html#method-i-abs) method that you'll find useful. If you compare the magnitudes of two numbers and find they're the same (-5.abs == 5.abs), then compare them directly and keep the greater of the two (-5 &lt; 5). If the two compare the same at this second step (5 == 5) then they're literally the same number and you can keep whichever one suits your fancy.
I ran cd `mktemp -d -t ex18`; and it gives me: mktemp: too few X's in template ‘ex18. I tried google for answers but it isn't helping me understand why this error is happening. I'm using ubuntu.
If you're just out for a brainteaser, here's an approach (not computationally efficient, though): squaring the numbers in question will make both of them positive and doesn't effect there rank in respect to each other.
Or just use .abs()...
The error `No such file or directory` comes when the file you are trying to run doesn't exist. Do an `ls` in your terminal in your working directory. Is there a file called `ex_18.rb`? If not, you probably saved it in the wrong directory. I highly recommend you getting used to working from the terminal, before going into programming, as this will save you a lot of headaches in the future.
"If you're just out for a brainteaser, here's an approach (not computationally efficient, though)" ...
Okay, thanks for the advise. As for doing a ls, it shows up with ex_18.rb and ex_18~ in the terminal. So it does exist, but when I run ruby with it, it does not exist.
 Great work on it!
If I were tackling this... I'd use a combination of abs, sort, and min.
For this type of problem, you don't need/want to call sort. Sort takes O(n log n), and you can solve the problem with a single loop in O(n).
How do you get a non-destructive updating object that holds both its state and its functionality? Deep copy it with each state change? Seems like a huge waste of resources to copy an entire object holding state and functionality just because the state changes.
Most instances themselves hold no methods, so it's just the data (and the pointer to the class) that needs to be duplicated. Hence, it's essentially the same "waste" as would occur in duplicating immutable data structures in a functional paradigm. What you're describing only makes sense if objects are fairly small.
But it's *incredibly* rare that you need to actually do a deep copy of an immutable object. Given that no field of an immutable object can change, all fields that don't change during an update/state change can be copied by reference. For the fields that do change, you only need to do the work required to update them. For an immutable Hash or Array (which is what I'm assuming you're concerned about copying), updates should be ~log n time, worst case (many immutable containers are backed by trees, which allows for a lot of structural sharing between pre-update and post-update objects). If you need to do a lot of updates at once, many immutable containers will give you a bulk update API, or will let you convert them to mutable containers + back, meaning that your originally linear time update becomes nlogn, worst-case. It's certainly not free, but tacking on a logn here and there I don't think is a "huge" waste of resources. Whether it's actually worth the added complexity (naturally) varies from case to case.
I appreciate the fancy use of `tap`, but the specific example being touted has both race conditions and is inefficient. Updating the records of a query and returning the IDs of those updated records should be done in one query both for race conditions and for efficiency (that's why SQL has the returning clause!) 
Why would you deep-copy everything? Given immutability guarantees, aggressive lazy evaluation, boxing, and shared-reference semantics are possible that mostly eradicate this issue. You bundle things at the expressivity level; that doesn't mean you have to maintain the connection naively in the compiler output.
dank meme my friend
&gt; You make it sound as if object-oriented and functional programming were mutually exclusive, when really they are not. I don't think OP makes it sound like that at all, quite the reverse: &gt; This is because; Ruby’s support for functional concepts is better than working with objects in Elixir. In Ruby I can leverage most of the lessons I learned from my time in with functional programming. That is, author found that it's easier to use both OO and functional paradigms in ruby together non-mutually-exclusively, than it is in erlang. 
Why not use both? 
Yes, but I find I can only remain an expert in so many languages at once, there is some context switch cost in my brain to switching back and forth all the itme, and only so much room in my brain to really be an expert in so many. Even working in ruby, I've already got to deal with ruby, SQL, CSS, and Javascript. Although CSS and SQL are simple enough (and different enough) and baked into my brain enough (I've been using both for many many years) that it doesn't cause me too much context-switch confusion, switching back and forth between JS and ruby do keep tripping me up, especially as I get into more complex front-end ES6-y stuff. Don't get me wrong, if I had something that Elixir's advantages would really be important for, I'd use it (the author's suggestion that massive paralellism is it makes sense), and I'm sure I'd find it a valuable mind expanding learning experience to play with it. But on the day to day, I don't think I can be expert at half a dozen languages simultaneously, there's a limit. I don't know if proficiency is the same as expertise, but for me, I find myself in a better flow when working in a language/platform I'm really an expert at, know all the ins and outs of, know what parts to reach for when, keep up on the ecosystem and evolution of the platform, etc, and I think there's a limit to how many platforms I myself can do this in simultaneously. 
Yeah, comparing Elixir to "being able to do immutability in Ruby" kinda does both a disservice. Same with OP's assertion that you don't think in objects in Elixir/FP (which has Records, Maps). 
In that case expertise and proficiency may need definition, but, also to be said. The flip side is totally okay. I just do often end up wondering if I'm the only one that treats it like this. I'm well aware I'm not, but, it does seem like the opposite is stated more often and I feel compelled to bring up that you don't -have- to treat it that way unless it's just how you feel better working with these things. :) I typically think of expertise as knowing in intimate detail how a language executes certain patterns. Like knowing that in ruby, it has cross platform handling for STDIN.raw! that makes it behave appropriately because you've read that particular bit of the Ruby C source code. Proficiency is being able to pick up the language, know enough of it's syntax not to be slowed down by it, and able to use the various documented APIs to produce effective code. 
Oh, I rarely look at MRI C source code, and don't even recall coming across `STDIN.raw!` before, but if I had use for it knowing exactly it's API/contract would be enough for me, I wouldn't need to know it's implementation. And I still consider myself pretty expert at ruby after using it fairly intensively for 7 years or so. I think the flip flip side is that some people don't even realize there's such a thing as _expertise_ in programming, or that becoming an expert at a tool can lead to amazing effectiveness at using it. 
&gt; Would you want to dig either of those sets of holes equipped with only a spoon? The op's perspective is that their arsenal is comprised (at least partly) of programming languages. My perspective is that my arsenal is my experiences, my habits, and my approach to software design that I've learned over the years. The only important tool is between our ears. I am neither for nor against for learning Elixir. Hell, if ruby is one's only programming language, it's possible one can learn a lot by picking it up. But after a while, there is nothing new under the sun to be found in these tools.
It's not quite true. MRI will context switch on I/O so it can see plenty of concurrency, even with the GIL. Where JRuby or Rubinius shine is in computation - they can use all cores at the same time. Topaz is vaporware. It's not usable AFAIK.
Tap is one of my favorite tools, but I'm continually surprised how many people don't know or understand what it does. So much so I often reconsider whether to use it for fear the next dev won't understand the code. 
Proficiency and expertise are worlds apart when dealing with many problems, in my experience. It look me along time to see the 'amazing effectiveness' that can happen when really knowing a tool. But for me it was worth pursuing. 
[¿Por qué no los dos?](https://github.com/YellowApple/rubix) Disclaimer: I wrote this. More disclaimer: if you use this in production, then may God have mercy on your soul.
Not to mention that Elixir has some features pretty squarely in the realm of "hard-core OOP" (interfaces, multiple dispatch, built-in actor model, etc.) that are either nonexistent or severely lacking in Ruby. Of course, Ruby has a more complete sense of class inheritance (and classes in general) that make some programming problems easier to reason with and are closer to what most folks think of when they see the words "object-oriented". Basically, both Ruby and Elixir have their strengths and weaknesses, and having invested quite a bit of my time into becoming at least somewhat proficient with both, I've come to appreciate what both of them can learn from one another. Julia is another Ruby-ish language worth noting if you're looking for a good implementation of "object-oriented with functional concepts". I took a break from learning it when I started to switch over to Elixir, but I think it'll be worth revisiting in the near future.
&gt;&gt; Do you want to dig 10 holes 6 feet deep or one hole 60 feet deep? &gt; Depends. Am I an undertaker or a miner? ;) Yo man, cool joke!
What I don't like is the custom language `"-f/--frobulate &lt;text&gt;"`. This might be frustrating to use if the error messages aren't great. I'd prefer to express as much as possible using Ruby syntax which would also enable more fancy stuff like `map`ping over the results or parsing arguments differently depending on other arguments. o = switch.short('x').long('x-axis').map { |_| XAxis.new } | switch.short('y').map { |_| YAxis.new } o.run(['-x']) # =&gt; &lt;#XAxis:...&gt; But I'm probably spoiled by [optparse](hackage.haskell.org/package/optparse-applicative).
This is a really good point and I did consider a variety of approaches. In particular, [slop](https://github.com/leejarvis/slop) migrated away from the use of implicit short/long option and now prefers strings. The specification you provide to samovar is essentially parsed internally into the corresponding flags. So you could work with the data structure if you wanted to. It was designed to closely resemble the style of git. The benefit is that it reduces the amount of syntax required to define options, and since it is the same domain language I think it reduces the cognitive overhead too. Additionally I found the differentiation between short and long options superficial at best. Samovar makes no differentiation. I prefer this clean implementation that this affords. Thanks for your feedback.
For my workflow, when I'm pointing at a local gem, I am doing it for development only, and I only want to commit Gemfile/Gemfile.lock pointing at actual released versions (at least to the master branch). Either using `:path` or `bundle config local.`, I wind up with things in both my Gemfile and Gemfile.lock that I don't want to actually push. With the `path` option, it's the `path` option itself as well as the `Gemfile.lock` recording it. With the `bundle config local` option, it's the `:github` in the Gemfile and the exact SHA (instead of a released version) in Gemfile.lock. So with both options, I need to remember to fix the Gemfile and regenerate the Gemfile.lock before committing (or use `add -p` carefully to avoid including them in the commit). Which is annoying. But there are occasional times a `:github` option in the Gemfile really _is_ what I want to commit, when I really do need to deploy using a non-released version of the gem. I try to avoid doing this, but occasionally it's neccesary. So when I see a `:github` in the Gemfile, I have an additional thing to think about -- wait, was that just a temporary development thing, or something I actually do want to commit? When I see `:path` in the Gemfile diff, I know for sure it's something I don't want to commit, as it's never okay to commit that. Additionally, when in the middle of development, with `bundle config local.`, I need to look further (at the bundle config) to figure out if it's really looking at a local possibly modified version and where on disk that lives; with the `:path` option that info is right there in the `Gemfile`. So I stick to `:path`, even though it's a pain in the neck remembering to commit only the Gemfile/Gemfile.lock I actually want -- I end up having to do the same thing with `bundle config local.`, but in even more confusing and inconvenient ways. If you are actually fine with routinely committing/pushing Gemfile/Gemfile.lock based on an unreleased git version, then `bundle config local.` is probably more convenient -- and it is nice it saves you from accidentally pushing a dependency on uncommitted changes in a dependency. I don't think my workflow is all that unique, don't other people do that too, work against a local gem only for development, and never want to commit/push anything but a dependency on a truly releaesd gem? There is no convenient workflow for this, alas. But I find `:path` less terrible, although still inconvenient. And if I make a mistake, I'd rather have it fail hard on CI or deploy to staging (you have CI right? `:path` will fail immediately and hard on CI or deploy), rather than the `bundle config local.` that will happily actually deploy to production depending on an unreleased git commit that you didn't mean to deploy against, and making your `bundle updates` work weird and unexpected from there on until you notice the mistake. 
Poster apparently has deleted himself. Oh well... Yeah, copy and paste - but with proper formatting. It seems there is some confusion about the naming of the file...
I'm not totally sure I love those patterns. I feel like code can usually be written in a clear way, and the `include Thing.new(:blah, :blah)` is not terribly clear
Ok, that makes sense. I don't know if that's unusual though I don't often encounter folks holding themselves to that as a rule. I'd say it's not unusual for teams to point to a specific sha of a gem, especially if it's a private gem or, in the case of a public gem, important commits haven't been released. In my opinion, it's more important that the code works (tested, backed by CI, verified) whether or not it exists in an official release. Perhaps released code offers that reassurance but that's not always the case either. 
I'll release against a specific unreleased sha if I _need_ to, if I really need that unreleased version. And in those cases of course I'll point to the git/github in the Gemfile, that's how you do that -- but in most of those cases, I don't need a local checkout with `bundle config local.`, right? It's kind of an orthogonal concern. And the times I need to develop against a local gem go way beyond that, most cases I'm developing against a local checkout are not cases where I'm going to need to release against an uncommitted sha. The most common one for me might be testing my own local app with a PR I'm going to submit to a dependency. The other danger of including a git/github reference in your Gemfile, is if you later run `bundle update` on that gem (update with no arguments, or with that gem included in the arguments), it'll update to the latest sha available on the branch you mentioned. Maybe the particular sha you first locked to was one you trusted, but is a future later sha on that same branch? It depends on the branch and how the committers on that remote repo treat it; if you have to start asking questions about what backwards compatibility or reliability commitments they're making on that branch... isn't that what actual releases are for, ideally with semver? If you're depending on a particular sha becuase you need an unreleased version, you can if you want actually put the specific sha into your Gemfile (as the `branch` param, perhaps confusingly), to avoid any `bundle update` modifications. But that kind of conflicts with using `bundle config local.`. The times are rare that I both need to depend on an unreleased version _and_ need to be hacking on the local source. When they happen it's more or less a coincidence, the reasons for the two things are generally different. 
I agree that for me as well, the best use case for developing against a local gem is for working with code dependencies that's part of an application PR and typically for gems that my team owns - most often private. Often these dependencies are private gems and I haven't been on teams that have felt strongly about semver releases outside of the public domain. Having run up against enough backwards compatibility and reliability issues with public releases like the ones you mentioned, I don't believe semver saves us from issues with running `bundle update`. For public gems that my team doesn't own, I have to agree pointing to the `git/github` source comes with a potential downside that the team should acknowledge and that it's preferred to use official releases instead. I find it's less common to be developing against a local checkout for the majority of third party gems in my apps.
I've found that learning new languages definitely improves my abilities with my old ones, even languages I haven't touched for a decade or three (yes, I've been doing this that long). I've learned many esoteric languages over my career, but never a truly *useless* one — even if I never wrote a line of code in it again once I finished that first project. Conversely, I have found my code quality drops *significantly and measurably* when I "hold fast to [one] and forsake all others" for an extended period of time (which may be as short as six months; certainly a year). Even beginning to learn Elixir, Go, and a few other languages has significantly improved my Ruby code, just as learning Prolog, Lisp, and Eiffel improved my C++ back in the day; every language is designed to encourage one particular way of looking at the world, but *good* languages don't make that an our-way-or-the-highway "choice". I've had the good fortune to be paid to write code in over forty languages thus far in my career; I've held the firm opinion since at least the early '90s that a good developer should be conversant in at least a dozen. I have little difficulty getting folks who live in multicultural, multilingual environments to see my point; most of those who say "Language *P* is all I will need to know for a while" tend to be monolingual in human languages as well.
The fact that you need to explicitly specify separators. The latest version (4) doesn't support sub-commands. No support for token parsing.
Good post. Personally I find that pattern too magical; code should be easy for coworkers to read.
Slop v3.6 for lyfe!
Yeah. Maybe if you use one of these gems tens of times in your code it'd be worth it. But if just once or twice then I'd prefer to just have the few extra lines of code in rather than use any of these gems. They are really just syntax sugar gems more than anything.
Sorry for being a downer but I'm pretty unimpressed with all of these offerings. Mostly the overhead you add for little gain. Let's break your examples apart: `Concord` (at least what you praised of it) is built into Ruby and has been for some time, it's `Struct`. &gt;&gt; class ComposedObject &lt; Struct.new(:foo, :bar); end =&gt; nil &gt;&gt; a = ComposedObject.new(1, 2) =&gt; #&lt;struct ComposedObject foo=1, bar=2&gt; &gt;&gt; a.foo =&gt; 1 &gt;&gt; a.bar =&gt; 2 So, instead of loading yet another gem to do this why not just keep with native Ruby. Unless `Concord` comes packed with some more significantly useful features -- I'd say there's no reason to spend time learning this gem. And I'd even argue that most Ruby engineers would not really catch the `Struct` call when loading (and those I've worked with aren't familiar with structs, usually). So, your next one -- I know of nothing magically built in. Just curious what is so amazing about this include call that requires a block allocation, dynamic method definition -- all to avoid writing this yourself? def self.call(*args) new(*args).print end So it's three lines vs. one but it lacks dynamic method lookup, dynamic method definition and it's extraordinarily clear what an object with the method defined on it does when it's `.call` method is called. No new engineer has to look up what `Procto` does, nobody needs to care about how `include Procto.new(...)` works -- it's clear. Finally we see `Equalizer`, of the three you assessed this one seems to be the one with the most value, although I have issue with some of your statements around it. Most significantly: &gt; We call cmp? and pass `__method__` to it which is a special identifier that Ruby sets up for when you enter a method and that gives you the actual method name back. ... &gt; ... Whoever reads this just knows that you are referring to [`cmp?(:==, other)`] ... I find it odd, that last part. If everyone would _just know_, what reason did you have to describe it? Sure, anyone would _just know_ that `__method__` inside of `==` would refer to `:==` _after they looked it up_ (they could just know, but it's obvious this isn't widely known knowledge because you felt the need to explain it). Aside from that issue that I had, it's frustrating to know that calling `#==` actually calls another method (`#cmp?`) which then dynamically dispatches not one, but **two** dynamic calls _on two different objects_! Sure, it _might_ be easier than (and all the other ones): def ==(other) self.longitude == other.longitude &amp;&amp; self.latitude == other.latitude end If you're horribly concerned about adding a new field and then having to alter the behavior of an object (which I actually find it quite valuable to be forced to realize the gravity of a change you make to an object). You could just as easily simulate some of these features by doing a quick-and-dirty: class GeoLocation ATTRS = [:latitude, :longitude] attr_accessor *ATTRS def ==(other) equal = other.is_a?(GeoLocation) ATTRS.each do |attr| equal &amp;&amp;= send(attr) == other.send(attr) end equal end end Now you can add an attribute to `GeoLocation` and not even remotely care what effect your change might have on anything. I don't like this (and this implementation in particular because of those dynamic method lookups). In my experience people don't think about what "magical" things do, they just abuse them. I get that you seem to like and enjoy these gems and you didn't do a bad job assessing how they work (and I did learn how `include SomeClass.new` worked, but won't be using it). I just don't think you really cut to the real core about why these are _more_ beneficial than being explicit about your intent. When your work is implicit that makes it open to interpretation. But when it's explicit -- well it's quite clear exactly what you intended. And a change in what `Equalizer` thinks means equality (with this gem, this is probably unlikely) doesn't mean that the way your program works will change as well. I will end on this note, using these "tiny" dependencies are what led to the `left-pad` fiasco with Javascript. Honestly if the work is small enough don't use a gem. If you can figure out how the gem works and it's small enough copy it into your work (you can still transfer licenses/declare the work came from elsewhere, I'm not advocating theft). That way if the `Equalizer` gem (or any others you listed, really) suddenly vanish your work doesn't break. I get that this standpoint could really apply to gems of any size, but with larger gems (like, say `devise`) you can only hope that it will be there as long as you need otherwise you'll be reworking a lot of your application. I fully expect that a lot of people will probably dislike my viewpoints, and I would prefer discussion over just a down vote (feel free to down vote, but add a comment as to why). **edit** grammar, spelling and clarity
I mentioned in my (long) comment some of your sentiment. Of all of them I thought `Equalizer` provided real value although ultimately don't like it's implicit nature on how these (I would argue key) features and prefer an explicit approach. Some would say "but when I change the object I have to change _all_ those methods" to which I retort "Good." Only then do you know the true weight of how much your single data point addition can have on the way your object behaves.
Praise this person. 
I really want to up vote you but I'd feel like like I'm just self promoting at that point! :P
There is a large hurdle to leaving ruby. First of all you are ditching all the expertise you have built up over the years. That's a massive productivity loss as you are going to be spending 80% of your time looking up how to do things rather than just doing them. You are also giving up the massive library of you have already built up over the years. I bet all of you have lots of code you rely on every day to get a jump start on new projects. Then you are giving up all the code in the community. No more "bundle install" and then voila a shopping cart, or a survey, or a complete authentication and authorization framework with migrations!. Finally you are giving up the interpreted world and going to a edit-compile-run cycle. So what are you getting in return for all? Is it worth it? 
&gt; I fully expect that a lot of people will probably dislike my viewpoints I'm not sure why they would. Sure, the article claims that these "best Ruby codebases" bring "clarity" or whatever to a project, but I'd argue the exact opposite for the reasons you've pointed out: they're complex, they're extra dependencies, and they're not doing much that can't already be easily done without them. All three of them (*especially* the first two) border on being antipatterns, to be honest. I know Ruby is a powerful and flexible language, but in one's quest to determine whether or not one could, one should always stop and think about whether or not one *should*.
Great article, thanks! Kudos on the choices of libraries, too. The focused "micro-library" approach is something I hope we can do more of in Ruby. As for the mixin pattern you uncovered, I hadn't realised this was possible via inheriting from `Module`. So far in similar code I've always returned a dynamically-built module instance from the methods I pass to `include`.
In `GeoLocation#==`, I'd suggest leave comparison to parental implementation for different kind of argument, for later refactoring. Also instead of iteration with `each` and storing in a temp variable, just use `Enumerable#all?` as it's made just for that :)
Yeah, but the article is specifically about "when you don’t care about the instance". In this example you do, so it wouldn't be appropriate.
I agree with those observations for sure!
Nice effort :-)
Don't despair. This is a common problem with RVM; it looks like the `ruby` executable is not in your `PATH`. In order for the shell (zsh) to find any executable on your machine it will search all entries in the `PATH` environmental variable. Since you've installed Ruby with RVM it means the RVM `bin` directory (the directory where the Ruby executable resides) needs to be in your PATH in order for the shell to find the Ruby exe. I haven't used RVM in a while, but if I remember correctly running `rvm get stable --auto-dotfiles` should fix your `.zshrc` so that the PATH variable is set up properly when you log in. You will need to close your terminal window and open a new one to reload `.zshrc` with the fixed PATH. If that doesn't help then you can try to edit `.zshrc` manually and add this as the last line: [[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; . "$HOME/.rvm/scripts/rvm" That snippet will load RVM and set up the proper PATH for you. 
This really is a beauty of a gem. I used it on a recent project. Worth a look.
Ah, in development or test, yes, I see what you mean now.
Looks great, will look into it. Also a bit worried about the dependencies; for example, seems the domain name gem is not actually used? Chuckled at the use of google groups
Serious question. Why should I use this over one of the curl wrappers?
If anything proper timeouts.
Looks awesome! One question: can I pass in the socket used as the connection for underlying requests? I've written libraries to wrap sockets with decorators that put blocking I/O calls on a reactor loop (think EventMachine, but without the need to litter EventMachine async calls everywhere).
I always prefer to see native gems as optional. I've been disgruntled ever since I had to install a C compiler on my dead simple production server just to install the `stripe` gem because it pulls in unf_ext.
Could you elaborate on your question?
Keep chugging we all run into these sorts of things, good that you reached out instead of quiting. Determination Is everything.
Shouldn't your array be a 2d array in order for "row-based/column-based" to make sense? If you have a 2d array, look up [`transpose`](http://ruby-doc.org/core-2.2.0/Array.html#method-i-transpose).
&gt; the exceptions raised for I/O errors so they're all subclassed from HTTP::ConnectionError Awesome, love it
Yeah and then transpose that.
no offence but your indian accents are so strong i can't understand a single word you're saying!!!!!!!!!!
Thanks for sharing! I've been wrestling with an app that uses Grape on and off for a few months now. It's an absolute beast to discover (what code is this URL calling???), and debug (where is my stack trace?). To be honest, it is hard to understand why one would choose a complex declarative REST API (Grape) built upon another complex REST API (Rails) when you could just use the latter in the first place...especially when essential Rails debugging methods (rake routes and stack traces) no longer function. Perhaps this blog series will lend some light and lessen the burning hatred I have developed for this framework. 
I'm just waiting for [HTTPalooza](http://httpalooza.com/) to support it.
I do love this pattern. It fits in so well with many of the use cases for Rails apps: controller actions, background jobs, rake tasks, etc. I particularly like how blocks/procs/lambdas, Methods (note the capital M), and these command classes can all quack like a function via the #call interface. 
What about HTTPClient then?
I can, the challenge is to convert characters to the corresponding asci-art characters, I know the height and the width of the asci-characters and I have the asci-characters, The begincode is : @l = gets.to_i # the length/width of a character @h = gets.to_i # the height of a character @t = gets.chomp # the text to convert @h.times do row = gets.chomp end puts "answer" in the loop the asci-characters are read row by row. The asci characters look like this : http://lpaste.net/161591 so 5 rows are read in. 
domain_name is a dependency of [http-cookie](https://github.com/sparklemotion/http-cookie)
&gt; built upon another complex REST API (Rails) Huh? Since when does Grape depend on Rails? Your point about discoverability also applies to Rails: You either need to read the logs in order to find out which controller method got called or look at routes.rb to figure out the mapping. &gt; where is my stack trace? `rescue_from :all` and log it yourself?
Like uncommon clean coding style and comprehensive inline docs. Although stdlib version was enough so far, I may have a look at this when solving more demanding tasks.
Sorry :) We also have a blog series http://blog.bigbinary.com/categories/Rails%205 whew you can check all the new things coming up in Rails 5.
One of the biggest benefits I've yet to write about, because it was a little too much to include in this article. In short, having a class is helpful because it gives us a place to mix in an auto-injection module that provides defaults for the object's collaborators from an inversion of control container. class CreateArticle include MyApp::Import( "validation.validate_article", "persistence.create_article" ) def call # can work here with `validate_article` and `create_article` end end This makes the composition even easier to do and still allows manual injection for situations like unit testing. I'll be writing about this in my next couple of articles!
Then comes the funny part, as you can't make a first class object out of `.()`, because it is *not* a (operator) method but a hack in Ruby syntax and it can't be passed around. token = proc {'foo'} token.() # "foo" token.respond_to? '()' # false token.method '()' # NameError: undefined method `()' for class `Proc' token.send '()' # NoMethodError: undefined method `()' for #&lt;Proc:0x00000002d89148 Find it in a contradiction to functional paradigma. Not mentioning it may be confused with standard method sending, explicit precedence definition etc. Can't understand why shorter version of `Method/Proc#[]` was not enough. token.(args) token.[args] token[args] `[]` is a standard operator method and does not introduce any additional inconsistencies.
Try this, where x is your array: x.min_by{|y|[y.abs,-y]}
Over 50% of our objects implement `#call`, so for us it's just part of the information we deliver when onboarding new team members. I think it helps readability because it keeps the focus on the name of the class, which is being used as if it were a function.
Someone showed this to me a few years ago and I ran with it... I tend to just use a factory method and null objects for that: class CreateArticle attr_writer :validate, :create def self.build new ValidateArticle.build, CreateArticle.build end def validate @validate ||= NullObject.new end def create @create ||= NullObject.new end end That way I can still exercise the class in isolation, but keep the logic for constructing an "actual" instance on the class itself, rather than delegate to something like an IoC container. There is more boilerplate this way, but there also isn't any fanciness.
Load all the 'rows' into an array, so you have an array of arrays, then call `transpose` on it. This will leave you with an array of arrays where each of the inner arrays is 1 column. You can then get each ascii art character by splitting the outer array up into n-column pieces. 
One thought I had, that might make it easier to support passing in sockets, is to pass in the "thing that makes sockets" instead of the socket itself. That way the two internal code paths can be symmetric. Not sure if it's feasible or not (I could be a raving lunatic).
Awesome! I prefer a written blog to a video myself! Lucky I had checked back on this thread, you should mention that on the video posts so people who prefer written text will see it! Thanks!
FYI, it's "lease on life"
Ok it looks like you have the Rails executable in your PATH now. But something else is off :-/ Can you post your `.zshrc`, `.zlogin` and `.zprofile` files (you might not have all of them, but post those you have). Are you sure you don't have an RVM setup in two places in your `.z-files`? I.e. check for references to RVM in those files. There should not be more than the one line you added. You can post the files to something like https://gist.github.com for example and just leave a link here. Also do `echo $PATH` on the command line and post the result here too. Another one to check the output of is `rvm info`. Actually, perhaps you messed up your installation while trying to get it to work. In that case `cd $HOME; rm -rf .rvm` to remove everything, and then start over by reinstalling RVM from scratch. 
This is exactly how the old API used to work.
It's even worse because it includes commits from previous releases as well and no indication of which commits are present in which release.
Ah, I'm surprised to see this present a design hurdle, but I don't have context. Is there any possibility of getting this feature back?
Thanks :) 
The release maintainer strategy they have is pretty strained. I wouldn't mind a git log if there were more frequent releases. I wonder what would help the Ruby core team to make this better? I wonder if I could write a script that would ping every contributor with a question "was this a new feature or a bug fix?" and manually write a more human readable doc. 
I thought about writing a parser for this change log and allowing community members to annotate them with useful descriptions which could be fed into the release blog. This sort of issue is very much why I created http://keepachangelog.com/ in the first place.
the rubymine bugs are listed in basically all the commits, so I'm not sure it would be much different. 
I completely agree with the points made here. This comment deserves to be a blog post on its own. Well done!
That's the thing, this is learning and advancing. Being able to set up your environment and resolve issues with it is essential to writing software. I promise, this will seem like cheesy pie when you start working with external services. Anyway, getting the correct version of ruby running (assuming it is installed) requires nothing more than setting a collection of environment variables. RVM can complicate things. I would recommend chruby + ruby install. Also remember to start a new shell session when you make changes to your path (or run `source ~/.zshrc`). 
I'll try that as a last resource, yeah, thanks man
 Of course, when you think of it the solving all these errors is also learning, however, doesn't make it less discouraging at the beginning when the future is foggy, as with any sort of venture. As you can see above with superfoodist, the ruby version is fine and RVM seems to be working, but it is rails who now wishes to cause trouble (most likely because of something I did wrong, while trying to fix the previous issue). On another note, I don't mind spending as much of my free time as possible on this, so does anyone else have another resource (preferably free) where they have learned from/know it is good to sort of accelerate my learning progress (I know it depends on how much time I put into it, but that's my plan, put as much times as I can into it)
Aye man, chill, hahaha, what I meant is that although I am following a tutorial online and trying to do things step by step, I prefer to learn the way in which I can be as independent of unnecessary services in the future, and also get good with the command line, etc, etc. Besides, as painful as this may be, like motionCuty said, it's part of the progress of learning
Yes. This right here: http://www.rubeque.com/ That's a bunch of small Ruby challenges. Once you get the correct answer you can view other users answers. You'll learn a lot because you'll see numerous ways of solving things. 
 That's exactly what I wanted to see! Cheers brother. When I finish with the tutorial/book from Hartl, I'll move into it... By the way, as you seem more savvy and wise than me, do you think books are actually a good resource for this? Is there anything I wouldn't be able to find online, for free? And what is your opinion on paid material? Worth it? I plan on making money from this on the future anyway, so I'd take as an investment, having said that, I am very wary of my investments.
Don't worry. There's plenty of bullshit for you to deal with that has nothing to do with local environment issues.
Well, I mean... Aren't local environments the general rule when developing?
Grow a sense of humour.
Just to let everyone know, I was able to solve the issue! Absolutely reinstalled everything and now I am able to generate a rails controller for my app (initial issue), so we're past that, thanks to everyone!
I've created this because I needed to test my NginX docker image without lunching the entire Rails app. So this repo is pretty generic and reusable. So maybe someone will find useful. 
Hey, don't worry about it man, I posted at the top of the post, I was finally able to solve my issue! Thanks for your help, you made an important change
Or just don't do them. They don't work very well. Many automated build/deploy scripts end up eating them so nobody sees them. They annoy people. 
If you are IO bound, you can try eventmachine or goliath. They do not support threads. Instead they use the reactor model, and cooperative multitasking.
I'd prefer not to have to rely on C extensions, but that is certainly something that would work. 
The main problem is the timeout backend: it's using IO.select and io/wait (there's actually an odd semantic difference between the two), but on e.g. Celluloid::IO it should be using Celluloid's timeout subsystem. I've been meaning to extract the code into a separate gem that provides a high-level socket wrapper with support for different timeout backends. Until we do that though, it's stuck with Ruby stdlib nonblocking I/O.
I went 2 years ago and it was awesome. Great crowd and a lot of fun. 5/7 top marks. 
I appreciate the reply. I'll keep an eye out for this, thanks!
I'm wrapping up a full-time developer bootcamp that was 12 weeks long. I learned more in those 12 weeks than I had the two prior years of learning on my own.
Granted, I have really good internet. Me being able to access my workspace and work on it from any device in the world is a huge benefit to not storing anything locally.
Awesome HTTP2 example!
The cheatsheet is an interesting idea, but most of what's in there relates to features not used often by most ruby programmers. It doesn't contain what I'd be looking for anyway. The software search is also an interesting idea, but when I try [this search](https://duckduckgo.com/?q=rubygems+blacklight&amp;ia=software&amp;iax=1&amp;iai=2) for a less popular gem, the software results are several dozen identical hits for the same thing (the rubygems.org page for the most recent version), and not other gems that contain or begin with the same word, as they were for cucumber. 
&gt; I know this is a noob question. I've worked in software development since 2002. I can't help you; other than to say, this is not a noob question. My only real help, and this is only very tangentially helpful, is to tell you to install linux in a VM and develop there. I've not used Windows 10, but Ruby on Windows has historically been problematic.
https://github.com/rails/rails/compare/v5.0.0.beta3...v5.0.0.beta4
When is the official release?
why not?
Oh dear. Thanks for spotting that. The repeated results seem to be coming from the upstream API: https://rubygems.org/api/v1/search.json?query=blacklight Anyway, I've filed an issue for it: https://github.com/duckduckgo/zeroclickinfo-spice/issues/2716 (Disclaimer: DuckDuckGo staff)
I have windows as my main OS, and I use Linux VMs to work. My code directory are shared through samba (check the permission for file created/edited by smb user) and I edit from windows using Sublime/Atom.
We call these Use Cases but yeah, great way to decouple the business logic from the model.
you can always do &gt; def name &gt; end &gt; private: name That's how we do it in most of our projects when classes get too big
In later versions of Ruby (&gt;= 2.1) you can also do: private def name end 
A slightly less cheeky answer: Having a single keyword swapping the visibility of the method means it's easier to define the layers of usability of the class, from the public API to the implementation details. It guides you towards what should be tested and what can be kept hidden, and it does help with overall readability. If the object is so large you can't find the private keyword easily, your object is too large.
This might also have been a non-native English speaker.
To promote thinking in interfaces. Idk about you but I much prefer pushing methods down into private and focusing mainly on the public interface, makes reading much easier.
Nice. I would generally define a service object as a pattern *which abstracts away complex processes/logic which cross multiple objects/models/domains* So we might have a `User.archive` &amp; a `Post.archive(posts)`. Ignoring use of concerns, associations etc for a moment. Both methods are logic which belongs to the specific model. I may want to archive posts without archiving users and vis versa. Wrapping the process of archiving a user, which in turns archives the post I see as as great place for a service object aka `AccountClose`. This then opens the door to add other Account related process such a stoping payment subscriptions etc etc. However I do not think there is a hard and fast rule so YMMV, but really complex logic should not be in controllers, and avoiding models which call or execute logic based on other models should be also avoided.
See the various CHANGELOG.md files on GitHub while viewing the v5.0.0beta4 tag, e.g. https://github.com/rails/rails/blob/v5.0.0.beta4/activerecord/CHANGELOG.md
[removed]
I think it's connected to Scissors Rule, from C++. Its basically like put all public methods at the top and private at the bottom. When you print the source code you can use scissors and cut the private part and give the "public part" to other programmers in the team. The explanation seams to be very out dated but for me it seams legit. You just don't mix interface with methods which shouldn't be called from outside. Probably its a matter of language you come from, personally I come from C++ and writing private in front of every method, like in java, is a big pain for me. For more info about scissors rule in Ruby, check out this article http://www.eq8.eu/blogs/16-scissors-rule-in-coding 
As far as I know, the keywords change the status of the interpreter and therefore the context the subsequent statements will be interpreted in. That's quite a different thing than a separate definition command. In a ruby class definition, you can do all kinds of stuff. You can, for example, put a few `puts "Hello World!"` inside and they will get executed while the class is defined. More or less, a class definition `class Foo` just sets up a special context that's valid until the `end`. The statements in between will be interpreted in that context. For some statements that context is really important (def, for example), and for some it doesn't matter (the aforementioned puts, for example). With the visibility modifiers, you can change that context while the interpreter is working through the statements. It shows the dynamic nature of Ruby. A method definition is just a "command" that gets executed in the context of a class.
There are two big questions about this gem, namely **why** and **how**. **Why** When you decide to create some gem of your code, you typically should ask yourself: * if this code is independent and useful on its own? (otherwise, it may be better to do a pull request to some existing library) * if I see potential for growth for this gem? (that mean, you are releasing not "just a code sample", but some new -- even if rather small -- topic for good Ruby code) It seems answers for both of those questions is vague in your case: its just a small "utility" calculation; it feels like it could be just a pull-request to `color` gem itself. Though, can't be "gradient calculations" made as a separate useful gem? Of course, it can: if you'll study "which gradient algorithms exist", "when and how people use gradients", and plan some gradient algos repository, growing and extending... (Of course, if you made your gem only to teach yourself how to make gems, all above is not actual. Though, in this case it would be better not to pollute rubygems.org) **How -- design** Now, let's talk about your gem API. What I really want when I want "gradient from `start` to `stop`, spanning `N` steps"? Most of time, it's just fire-and-forget thing: `colors = generate_gradient(start, stop, N)`, and have this "colors" as a normal Ruby Array, which I can further map/select/reverse and so on. So, why do I need separate "gradient object", like in your implementation? There can be several cases (neither of which you cover), for example: * border control (anything at `color_gradient.gradient(100)` always return non-nil value (for example -- always last, or cycled through all 7); * intermediate values: for example, `color.gradient.gradient(0.3)` returns either intermediate value, or nearest of 7 points. In your implementation, there is no excuse to not "just return an Array". **How -- implementation** Do you aware of [Color::RGB#mix_with](http://www.rubydoc.info/github/halostatue/color/Color/RGB#mix_with-instance_method) method? In fact, your entire gem could be rewritten as: (0..resolution).map{|i| start.mix_with(stop, 100 - i * 100.0 / resolution)}
Not keywords but `Module`'s singleton methods and suppose it is that way because methods "visibility" can be altered during a runtime and it is more straightforward and flexible implement it with normal methods then by a reserved syntax, resolved at a parsetime. Btw. methods visibility in Ruby has a *bit* different meaning then in C++ or Java. It is comparing apples with oranges here …
There's no fixed date.
In workplaces where we are required by corporate IT to use windows, this is how the teams I've worked with have done Ruby work. Linux development is so much nicer than Windows (imo) unless you are doing .net or some other MS toolchain.
I think the answer is probably lost to history, or only known by Matz, or perhaps in a Japanese-language thread somewhere. I wonder if either of Smalltalk or Perl (two of the main influences for ruby, although Perl less so for the OO stuff) did it similarly to how ruby does it. In some ways ruby's approach is more flexible. The code where the methods are defined does not need to decide if the methods are private or not, it could go either way, some other line of code can make that choice. 
Thanks for the reply. I thing I'll wait around till there is an official release, although I see books for Rails 5 starting to come out already.
This is very thoroughly the genuinely correct answer here. I PREFER the `private` declaration over a `defp` precisely *because* it encourages good coding practices. [](/GNU Terry Pratchett)
As I recall, all Smalltalk methods are public; but in general the smalltalk way of interacting with code was through browsers that would group things by type. So this somewhat smalltalkish. I don't believe that perl has access control.
"Just don't do it wrong" is only feel-good wankery.
Just wanna say DDG is awesome. Been using it as my main search engine for something like five years now. Keep up the good work!
You can actually use this to add your own decorators, such as memoize. Still, the pattern used by tools like Rake or Contracts is generally better for decorators
I completely agree with you :-) . Still, in classes with 150-250 lines (which is what Rubocop uses as max iirc) I find it not always very clear.
This is an absolutely amazing new insight! Awesome! 
Although this might be considered 'treating the symptoms', I think it is a smart way to reduce confusion -- especially when tasked with maintaining horrribly outdated legacy Rails code --. Thanks! 
The big qualm I have with this though, is in C++ you define visibility in your header file separate from the implementation. You just have: class mycoolthing { public: mycoolthing(); setThis(std::string value); private: internal_method() } In ruby all your method bodies are in the way. Honestly, I like the way python does it, just prefix it with an underscore and you're done.
Actually I bet it already exists! Anything written as a class-method that you do `some_custom_method :name_of_method` will now magically work with `some_custom_method def name_of_method`, now that `def name_of_method` returns a symbol. 
Lots of reasons, as you note. Nice thing about AWS is I can access it from anywhere. And the way storage, backups, etc. work is actually very intuitive.
Thank you for a constructive answer :)
No, it isn't. At worst it's unhelpful. At best it is good advice. Sometimes it is even helpful. Unfortunately it takes too long to explain it. I may get berated worse if I said "go read these four books".
&gt; Honestly, I like the way python does it Python doesn't actually have access restrictions, prefixing a method with `__` causes python to mangle the name by prepending the class, `__test` becomes `_MyClass__test` 
I'm well aware of that, but method accessibility in any language is purely a recommendation that cane be worked around (even C++ just requires you change the header file, C#/Java are a bit more of a pain because you need to deal with reflection unless you modify bytecode).
the way i see it, one key difference is that the desugaring of `+=` very transparently has an `=` in it.
I disagree, no one would bat an eye if `x++` was syntactic sugar for `x+=1`.
Looks good. Having a helper method for basic auth would be the bee's knees.
&gt; I'm not sure if this ever was an actual problem I can remember at least one merge conflict which got resolved such that a private method ended up being public. That's not a big deal, but could easily be avoided with `private def`.
also: http://ruby-doc.org/core-2.2.0/Fixnum.html#method-i-succ
If you get input from the CLI using `gets`, it will contain a trailing newline (basically the enter character). Replace `gets` with `gets.chomp`, which removes this trailing character, and you should be fine.
Ohhhhhhhhhhh. That makes sense, thanks man :)
Heard it the same way only with Null Pointer Exceptions instead of the cache bit, and from my personal experience, yes.
Awesome! I had found [this http-2 gem](https://github.com/igrigorik/http-2), after I saw your gem actually used it as a dependency, didn't it? But igrigorik's http-2 seemed to have an awfully confusing API (maybe a bit too low level for the masses?), yours seems a bit more workable to someone not already expert in http-2. 
&gt; x = x++ 
Funny you mention that, but I have nearly completed a custom Cop for Rubocop to enforce privacy access type enforced and consistent usage of that type across a project. It should be released in May along with a blog post describing why the new 2.1 method is preferred (more explicit, easier diff-ing, more readable and maintainable, etc...)
excellent, thanks for that!
Electric Light Orchestra?
Any instructions or a blog post showing how to use this?
I had a chance to do a project in Trailblazer recently. What it does do is provides an exceptionally good way to organise code and have standards, and even a level of abstraction though sometimes seems a little over the top but is understandable. What I liked was the service objects, big fan of these thanks to trying to convert logic from a large scale business app into an API. What I disagree with is that I think validations do belong in the model, but the idea of contracts was good. I like the concept of cells, but it seemed a little redundant at times. Policies were ok, as I have used pundit before. I did not have a lot of interaction with the renderers. The problem with MVC it that people heavily abuse the M &amp; C. Is Trailblazer worth a look(?), most definitely and the concepts are implemented well. A framework, whether MVC rails or Trailblazer sitting on top of it etc, is only as good as the person(s) abusing it. 
To be fair, if there's *any* language that supports excessive trickiness, it's probably Ruby.
At least Matz would.
I lean more on the side that a++ then would hide the fact that there is an assignment and the object a points to actually changes (for Fixnum anyway). I assume that Matz had considered this too much sugar.
Note that datamapper is very much a dead project. You may want to look into [sequel](http://sequel.jeremyevans.net/) or [rom](http://rom-rb.org/).
Thank you for your feedback, all valid points which have helped me understand the larger gem ecosystem. &gt; Though, in this case it would be better not to pollute rubygems.org I'm not sure I agree with this - how am I meant to get experience building gems if I'm not able to test/play with everything that that encompasses? The gem may well be useless, but it's not hurting anyone by sitting there.
Ilya's great gem handles all the low level byte protocol. It does not deal with the transport, which is what I've added in my gem. Hope this clears up :)
&gt; It just takes (long, yet pretty descriptive) name color_gradient forever. Nobody can ever release the gem with same name. You see, I view this as a failing on the part of the gem ecosystem. I come from a PHP background which uses the Composer package manager. One of the great things about Composer is that all their packages are namespaced, meaning issues like this never crop up. Want to name a package `color_gradient`? Go head, you won't be blocking anyone else from using that name because the namespace makes it uniquely yours. Anyway, I feel that's getting off topic a touch. Thank you again for your feedback, it was very insightful.
A better metric is "don't have large public interfaces". Large classes suck, but objects with tons of public methods are much worse. My life with Ruby has been much simpler since I've been writing more classes with domain driven names and simple interfaces
+1 so many Rubyists just forget about this. The core guidelines that work for all the other languages still apply to Ruby
Ruby's current parser won't actually accept a method called `++` (I tried it), ruby's parser is already rather complicated, perhaps accepting `++` as a method name would make it even more so. The difference between the prefix and postfix `++a` and `a++` would require more than just defining a `++` method, it would require actual low-level language semantics support. In particular, the semantics of C's postfix `i++` don't really make any sense in ruby at all. Ruby _does_ support a small set of prefix "unary" operators, so theoretically `++i` could be supported, if `++` could be a method name... But this is a lot of extra stuff in the language to support an operator that isn't really needed, would be very un-ruby like if it actually did an assignment to the variable on it's own (and requiring yet more low-level language support) and is often kind of confusing in C. As someone else noted, you _do_ have `i.succ` (alias `i.next`) that you can use to return a Fixnum + 1. Good enough, semantics that make sense in ruby, without confusingly looking like C's `++` which actually have different semantics involving assignment, that would be odd and inconsistent to have in ruby, let alone the postfix/prefix difference in C which would make even less sense in ruby. 
I worked on an application where the original developer went rouge with his own file structure, using many service like objects, cells for the views. It wasn't Trailblazer, but some of the same concepts. It was absolutely horrible to step into from the outside. The ideas themselves weren't so bad, but it was really a framework on top of rails which had an additional learning curve. Implementing new, small, features became very verbose. The quick and easy but effectiveness that I loved about rails was gone. It was hardly even a rails app. I'm not saying these types of frameworks are bad or that you shouldn't use them. If you do use something like Trailblazer, however, there will be a price to pay, especially as you bring other developers in to the project. Iteration will be slower. For me, I'll stick to the Rails Way as it's the best way for me and my teams.
From my observation, there's no "++" in Ruby (or Python) for the sake of keeping it pure OO, and to maintain the eloquence of Ruby, since some people think ++ looks a bit dirty. Plus, 90% of the time you can probably substitute a counter with a for loop.
Roughly how mature/complex are your typical projects? Can you give examples of the kinds of problems you are solving?
Are you really hanging your criticism on a particular line of code as opposed to the concepts? (Thats the most concrete/clear criticism you have offered, the rest comes across as vitriol)
Immutability of values and OO has nothing to do with it. You are conflating the concepts of: values, values stored in mutable locations, and value identity. In C "++ x" is exactly the same as "(x += 1)" or "(x = x + 1)", which is also perfectly legal in Ruby. 
Have you never heard of Perl?
This is an incoherent argument. The identity of a number cannot be changed because its visible state is unchangeable. This where the term "value object" comes from. However the value stored in a location can be changed. Does the variable assignment change the value of number or the value in the location?
The application I mentioned was relatively small, with easy to grok concepts and functions. The approach taken was overkill for what the application did. Your statements can be accurate, but you're making the assumption that large, multi-year stale-code stability is something everyone needs. Those same arguments can be made against Ruby/Rails in general in terms of language semantics, static typing, etc. if we wanted to get into it (I don't, just making a point). I can only speak to why I use Ruby/Rails over other easier to maintain frameworks and languages. For how I use Rails, "The Rails Way" is the best way. How you use Rails might be something different; to which I'm not speaking. It sounds like you have a need for the additional structure that Trailblazer provides, which is great. I do believe, IMHO, that the majority of Rails projects/devs out there don't need something like Trailblazer.
The application which I mention above was relatively not complex and in the beginning phases of the product (SaaS), which is probably why the approach taken was so extremely painful and overkill. I don't believe that specific application would have ever reached the point where something like Trailblazer would be justifiable. There are applications out there that might, but this was not one of them.
It's actually not. You have to consider how Ruby is implemented. Everything is an object, therefore 1 is an object. ++ only makes sense when all you're holding is a pointer.
I went up my own asshole, and wrote this: https://github.com/NullVoxPopuli/skinny_controllers -- it's helping me on my major rails-api application. I liked some ideas of trailblazer, but didn't like everything, so I just did my own, and added a bit more implicit invocation of things (channeling ember). edit: oops, I meant to reply to /u/bitwad66
This is on mperham. After he wrote his dependency-killing article, any dependency, no matter how small, is now the pet peeve of hipster developers all over the globe.
I understood the issue is not just the extra dependency, it's that the dependency is an advertisement for a commercial service owned by one of the contributors to capistrano (a "shameless plug" if you will).
There are a set of people that will take any rule of thumb to its logical extreme. Don't blame me for fundamentalists. Dependencies are always a trade-off, my article was meant only to raise awareness of that fact. FWIW I think this move is totally cool. OSS developers need more options to monetize their (in this case, 7 years of!) hard work.
Sure, those were the two issues. But, from the very first paragraph: &gt; First of all, adding new dependencies is considered a kinda bad thing to do So the advertising is far from the only thing on the posters mind.
Yep, but maybe they should have released a separate gem - "capistrano-pro" (or similar) instead of attaching an "ad-gem"/dependency to the main gem?
Rails has always been meant to be the glue between your app, HTTP, and the database. A good Rails app is a good Ruby application. What most people seem to be referring to as "The Rails Way" are really just a bunch of mistakes that intermediate devs make by overusing or misusing certain tools. 
 class NilClass def present? return true end def nil? return false end def method_missing puts "LOL" end end
Snake case is more common in Ruby but it really doesn't matter (unless you are using something like Rails).
&gt; Using a library to mimic a real FTP server doesn't differ too much from mocking the method call. It does differ a great deal, actually. You can test edge cases (e.g. don't start the FTP server/access a file with no permission...) without relying on documentation to be correct, you can catch changes in behavior if you update the external dependency and in general keep your tests from being green if the implementation is completely broken which will happen sooner than later with so many mocks. &gt; The test that verifies that the upload works is not the job of the code I own and thus it doesn't make sense to test that. The code you own is called `MyFiles.upload`. Sounds like it has exactly one job which is uploading files. &gt; but if you go out and make a network call to the real server each time you run your test you're going to end up with a very brittle test You would only do this for the FTP "gateway" (aka `MyFiles`) and if the server runs on localhost it's not going to be brittle - I don't see Rails tests failing randomly either. Even if the test would fail occasionally, the error messages provide good insight into what might fail in production.
Hey /u/jeremywoertink wrong number of argument errors are related to cap 3.5 not the harrow integration, if you have 5 mins could you open a bug report for us... 
Snake case
Tabs
Use CamelCase for classes and modules, snake_case for variables and methods, SCREAMING_SNAKE_CASE for constants. Source: https://github.com/thoughtbot/guides/tree/master/style/ruby
Thanks all.
The first version of [Programming Ruby](http://docs.ruby-doc.com/docs/ProgrammingRuby/) used camel case for variables and other identifiers as well, but most Rubyists I know follow the style guide as described by [berkes](https://www.reddit.com/user/berkes) comment and would look a little cross-eyed at anything else.
Consistency &gt; choice
Do as the standard library.
Sure. I'll submit an issue on GitHub.
Meh, it's a trade off. If you're making a change to project A that depends on project B as a gem and you use this approach you now have to ensure to always keep project B update to date before working on project A. You may have to also ensure that you've checked out the proper version tag of B that matches the contents of `Gemfile.lock` in project A. If you don't do the above then you're in a worse spot than having left `path:` left in, mismatching the version can cause very weird bugs. Leaving `path:` in the gemfile is trivially caught on your CI server or in code review anyway so I don't see it as much of a real problem. Especially since needing to make changes to both projects together, which is where you'd need `path:`, should be quite rare in comparison to working on each project individually. If it's not rare you should consider re-thinking the boundary between the gems. 
I think it's because you're creating a new instance of Mechanize and trying to do the cookie handling yourself. Don't do that -- at least not initially. You're saving the cookie jar which contains the session in `login.cookie_jar` and expecting it to be there on `movie`, a totally separate instance. Use the same instance and let Mechanize maintain the session for you until you get the scraper working, and parallelize when you have a need to.
I'll try that out. Thanks for your help!
I tried this with one variation `page = browser.submit(login_form)` instead of `page = login.submit(login_form)`. I can successfully move to the next page with that, however, when I go to `page_movie = browser.get(https://www.example.com/movies)` input search data and `page_movie = browser.submit(movie_search)` it still sends me back to the login page. Am I missing something? edit: For claification, the rest of the code is page_movie = browser.get('https://www.example.com/movies') movie_search = page_movie.form() movie_search['q'] = title page_movie = browser.submit(movie_search)` 
I like 80-char lines. I can fit two Emacs windows (with gutters and everything) with 80-char lines side by side without wrapping. *Edit:* word.
I'm using SummerNote currently but going to test out Trim by the folks at Basecamp as it looks pretty great. Lightweight and a focus on great code. Any chance of a similar screensaver using Trix?
So... Why exactly is "you cannot change the value of a number" an incoherent argument? Your argument above, saying you can't change "the visible state" but you can change the value that a pointer refers to, confuses me. Further, I *thought* I was agreeing with you, but now it's clear that I'm not. I apologize for this. Can you help me understand your argument a little better, please? I have not contributed to MRI internals, and my understanding must be mistaken.
I can definitely put it on the list. Might go nicely next since this one was just released. How are you handling image uploads with Summernote? This was the easiest way I could find, but wasn't sure if there were other implementations.
In the real world, a number's value is its identity. `5` is always `5`. `5` always has the same properties and behavior. Every `5` is indistinguishable from every other `5`. Its state can never be changed. The argument "Ruby doesn't have `++ x` because you can't change the value of a number" is incoherent because `x = 5; x += 1` does not change `5`. The expression`x += 1` changes the value stored at the location bound to `x` to `6`. In many other languages `++ x` is the same as `x += 1` or `x = x + 1`. The variable `x` is changeable (it has state), the value`5` is not. Similarly: `h = { k: 1 }; h[:k] += 1` is the same as `h = { k: 1 }; h[:k] = h[:k] + 1`. The value at `h[:k]` is not being changed, the value stored at the location reached by`h[:k]` is being replaced by `h[:k] + 1`. This is achieved with two method calls: `Hash#[](k)` and `Hash#[]=(k, v)`. In MRI, Fixnum values, like `5` are not pointers to a changeable location. In contrast, MRI Float values, unless Ruby is built with `-DUSE_FLONUM`, are implemented as pointers to a location containing native float value, but by convention this visible behavior/state is unchangeable. https://github.com/ruby/ruby/blob/trunk/include/ruby/ruby.h#L437 At one point in MRI's history, a Float's visible behavior/state, was infact changeable, creating pathological cases, where Floats were not guaranteed to behave as value objects. 
Not to say that language semantics should be a cognitive burden .... Programmers who do not understand the semantics of a language are a common source of problems -- or blame the hammer that hurts the thumb.
I haven't setup image uploading yet. I use Cloudinary and it looks like Trix should work well with that. I've yet to try it though. I've only played with their demo. 
I'm almost entirely positive we're saying the same thing. If you don't mind me asking, what did you understand that my argument was?
I took your argument to mean "if `1` is an object, then `++` makes no sense" -- you appear to be agreeing with the facile statement: "because you cannot change the value of a number". The fact that `1` is an object in Ruby, or represented in any other way, or that the value of a number cannot be changed, has nothing to do with incrementing the value stored in a location. The `x` in `x ++` is not a pointer, neither is the `h[:k]` in `h[k] += 1` a pointer. The argument "because you cannot change the value of a number" is incoherent and facile -- `x ++` is three operations: `STORE(x, ADD(LOAD(x), 1))`, on one stateful variable binding `x` and two non-stateful numbers, `5` and `1`. Numbers are not being changed, only the state of a variable.
please edit your post and remove you API credentials
No, no, I'm sorry. I must have put the wrong words in the wrong order. I was trying to express precisely what you are trying to express. Matz is also making a tongue-in-cheek reference to, what was it, Fortran? where a bug actually let you change the value of a number.
This reminds me of an old Soviet joke. Two friends meet: - Man, I heard beatles yesterday. They suck! THey are tone deaf, and horrible accents. - Really? Where did you hear them? We are behind an Iron Curtain! - Our friend Peter, sang me a Yellow Submarine.. You are judging a framework based on incomplete usage by another developer. TRB only recently went more or less mainstream production, and in my experience it helped improve both maintainability and performance. Rails way is fine for smaller projects, but on something larger, TRB is definitely helpful. 
i just did it to my largest project code and nothing happens. I really wonder what your code does.. can you test it on yours and show me here the result ??
&gt; You could theoretically use headless camelCase, but you'll rarely see a codebase that uses it It's actually not *that* odd. camelCase is the convention in a lot of C-like languages, particularly Java (which influences the JRuby world).
http://imgur.com/YkAn4Xa That's what I got
`tempwinner = gets.chomp.to_i.to_f` =&gt; "player1".to_i.to_f =&gt; 0 You want to get the ELO associated with the player that the user inputs and do math on that, not on the playername.
This is what Hound says, too. And I agree. But even if you don't agree, and you'll most certainly find a colleague who does not agree on this point, having an independent third party making these choices for you, is a great productivity boost.
imgur LOLZ
Yeah your `tempratio` variable is trying to do "player1" / "player2", when it looks like you want 1000/1000 (Elo[player1] / Elo[player2]. You can add some code to parse the user input to ensure it matches the way you have player data stored, but if you are prompting the user for the name of a player, then you need to convert that input to the associated number before you try to calculate anything.
who cares, reddit blows ass
Just use Mina.
An important part of /u/berkes's post, in the broader sense, is that they use hound/rubocop. If you're new to ruby and want some tooling that helps you through conventions and common idioms - use one of those two. I prefer rubocop locally and integrated with my editor of choice (vim), though, because it'll warn me as I'm writing code that I'm doing something uncommon or strange.
I'm trying to get the callback to work and then figure out the OAUTH, both of which I have had a lot of trouble doing
[removed]
As someone who is happening to be studying blocks today, this was very informative. It's helpful to know that I can convert blocks to procs and call them like a function call. I don't know what usefulness this actually has, but I think it does make the code easier to read. Thanks for the post.
One use would be filtering or sorting based on user input. For example: if params[:sort_type] == "latest" posts = posts.sort_by(&amp;:date) elsif params[:sort_type] == "best" posts = posts.sort_by(&amp;:votes) end can turn into sort_type = Hash.new( Proc.new { |e| e.id } ) sort_type["latest"] = Proc.new { |e| e.date } sort_type["best"] = Proc.new { |e| e.votes } #somewhere else posts = posts.sort_by(&amp;sort_type[params[:sort_type]]) 
This does look cleaner. I never imagined I would see conditional statements as bulky, but in studying Ruby I see there are various ways of shortening or eliminating them.
 print "type the player# for the winner: " tempwinner = gets.chomp.to_i.to_f print "now type the player# for the loser: " temploser = gets.chomp.to_i.to_f tempratio = tempwinner.to_i.to_f / temploser.to_i.to_f So `tempwinner` = 0.00 if you enter player1 and `temploser` = 0.00 if you enter player2. (see explanation below) If you divide a float by 0 (or 0.0xxx) you get NaN. Try it in irb, `0.00/0 = NaN` and `0/0 = ZeroDivisionError` Plus it it makes no sense, you are taking input and then assigning it to a variable `tempwinner = gets.chomp.to_i.to_f` and then casting it again `tempratio = tempwinner.to_i.to_f / temploser.to_i.to_f`. A little more information for you &gt; to_i(base=10) → integer click to toggle source Returns the result of interpreting leading characters in str as an integer base base (between 2 and 36). Extraneous characters past the end of a valid number are ignored. If there is not a valid number at the start of str, 0 is returned. This method never raises an exception when base is valid. `player1` will result in `0` as there are not valid numbers at the start of the string. `1player` will result in `1` as there are leading numerical characters. You may want to use something like `temploser = gets.chomp.scan(/\d+/).join.to_i`
change_hair_color is not just a Ruby style, any language can do and does that, it still is exposing the object insights - outside of it, in the example I wanted to show that exposing methods to change code allows misuse, that anyone can change hair color or even worse the name
There is no war. The web programmers that understand HTTP can design APIs that couple very loosely to clients and leverage all the good work that went into HTTP around idempotence, distributed messaging patterns, and encapsulation. Those who don't have that knowledge are probably building piles and piles of coupling. They are still getting paid just as well, but that's only because their performance -- like that of most web programmers -- isn't evaluated based on the quality of their work. There is no "academic" vs. "pragmatic" debate here. All of the seemingly elaborate affordances of HTTP are, in fact, pragmatic! Deciding that you don't care about them is the opposite of pragmatic -- it's arrogant. Deciding that you don't want to learn about them is even less pragmatic.
Then you chose an unfortunate example, because a barber is supposed to change hair color, that is his job. In fact a barber is so specific, I would not be surprised if he would be totally responsible for hair. So that a person has a `#hair=` that is set by the barber. In my opinion if you have data that should be modifiable by one class (for example the barber), but not by another class (the optician), you should instead use for example a restricted proxy. An object that only allows exposes methods relevant to the concern. But we would be moving really fast into the access control domain.
For the barber, I'd prefer to set it up such that a person has a hair object and passes that hair object to the barber, who can then modify it. This is assuming we want modifications and that the hair "belongs" to the user instead of just being a property. Another idea might be to make the hair a value object so the barber can give us a new value object as our new hair. And since this is all awkward, it might happen inside a barber shop object.
Ruby beginner here. That was interesting and informative (now I know what *yield* does), but I don't see what class of problems it solves. Why would I use a blocks as a parameter, other than to show off what Ruby can do? Right now, it seems like an unnecessary feature of the language to me. Can someone enlighten me? Give an example where yielding to a parameter block would save time or make my code more readable/maintainable.
In functional programming a barber object would have to clone you with new hair altogether. Then dispose of an old you...
I'm very sorry if I came out as arrogant in this article, it wasn't my intention. Can you tell me when I said I didn't care about all affordances of HTTP? It's quite the opposite actually since the moment I've learned more about HTTP and how most situations can be handled simply by following the RFC. My problem is that I didn't have the chance to learn about them earlier and I know there are many, many developers that don't know anything about it. My use of the word pragmatic was obviously not adequate because you are totally right. It came mostly from people saying that they are doing pragmatic-REST that I decided to put that as a debate between 'academic' and 'pragmatic'. When I talk about war, I'm talking about the comments hate you can find on most HN topic involving hypermedia formats or REST. You might disagree with me but I've seen so much poison in those threads between people who are trying to push towards HTTP/true REST and the people you describe as not having the knowledge that it just makes it painful to read.
`yield` is great when you want to split up code organization and execution. Imagine a structure like this: class Post attr_accessor :id,:title,:content,:votes,:date end #in a view Post.all.sort_by(&amp;:date).select { |post| post.votes &gt; 5 }.map(&amp;:title).each do |title| #do something with title #and repeated in another view Post.all.select { |post| post.votes &gt; 5}.sort_by(&amp;:date).map(&amp;:title).each do |title| #do something with title Now, if the logic behind choosing these posts changes (let's say I want 10 votes instead of 5), I'll have to change this specific block of code multiple times. Alternatively, I can put the logic into a function and have it look like this: class Post attr_accessor :id,:title,:content,:votes,:date def fancy_posts self.all.sort_by(&amp;:date).select { |post| post.votes &gt; 5 }.map(&amp;:title).each do |title| yield title end end end #in a view Post.fancy_posts do |title| #do something with title #and repeated in another view Post.fancy_posts do |title| #do something with title
oh, could you share an example?
Unknown? It's right there. It'll presumably break your app, hopefully in interesting ways, nothing more. 
 # It would be nice to read something like: # # barber = Barber.new # person = Person.new("Michael", Hair.new("brown")) # barber.dye(person.hair, "blue") # person.hair_color #=&gt; "brown blue" # # This opens the way for things like: # # 3.times { person.wash_hair } # person.hair_color #=&gt; "brown faded blue" Hair = Struct.new(:color) do def dye(color) @dye_color = color end def to_s "#{self.color} #@dye_color" end end class Barber def dye(hair, color) hair.dye(color) end end class Person attr_reader :name, :hair def initialize(name, hair) @name, @hair = name, hair end def hair_color @hair.to_s end end There's a slight bug in this implementation where a person's hair color, before dying, would return `"brown "` instead of `"brown"` But I hope this illustrates how you might extend the behavior a thousand ways with small objects?
I am having trouble understanding what you are trying to test exactly. 
This was a nice refresher/thought experiment to read through. People got really pissed about the barber but it's a nice generic example. 
I think this is a good approach. Ruby's duck typing allows for easy use of this kind of composition and manipulation of composed objects, so you can expose only the parts of the class that you need to. In this case the `Barber` isn't directly mutating the `Person` class, but only the `Person`'s composed `hair` object. So if you need to pass a `Dog`'s `hair` for example the barber could still be able to dye it as long as it meets the `Barber`'s interface. At some point you need an interface if you want objects to interact, and separating out those concerns into a separate object (i.e. a `Hair` object) is better than changing every class to meet the `Barber`'s interface. Composition is kind of an objectified version of mixins that is more flexible. Instead of including a `Barberable` mixin with the `Barber` interface methods you can just add a `Hair` object to any class that needs hair.
Will do that. Thanks for the feedback,
I'll increase the time but this is an important way of connecting to the blog visitors. There is a close button (easily seen) and it only pops up one time per session.
Ahh good point. With Rails I was guessing that sidekiq would take on a Rails logger. Even the there's the case where sidekiq is run with another framework. You coming to KC this week? Let's chat.
Then I think you need to read more about TRB before commenting. That is exactly what TRB is advocating. Use proper tools when needed, but use them - don't squeeze 50 different concerns and 1000 lines of code into one fat model ( I'm exaggerating to make a point) . Everything in TRB is decoupled. You can just use Reform ( form objects) for instance if you that's all you need. And event that you don't need to use everywhere if it doesn't work for you. 
Sidekiq logs to STDOUT by default and will use Rails's logger if Rails is detected so the logging part should need no work. I was more speaking of the RAILS_MAX_THREADS thing. The database pool size is a common support issue. That env var is web-centric but I could add support for it; not sure if it's right to assume puma thread count == sidekiq thread count. I'll be there tomorrow night. Think on it and we'll chat then.
I have moved the share widget to the right. Please let me know if it stopped bothering you. Also, I'd like to know what device are you using to read the blog. Thanks.
Hey! So something that people aren't talking about here is best practice, so I thought I'd chime in :) You're treating Ruby, a beautiful object-oriented language, as a procedural language. All fine and dandy, but you're not taking full advantage of objects! Because _everything_ is an object in Ruby, you can be awesome and use it! Here's something to get you started. I'm typing on my phone (as I did the code) so mind the brevity. http://pastebin.com/w27Px7aq While your error is trivial, you'll find that writing object-oriented code is a great investment, both long-term and short-term. You'll see what I mean once you start to expand the logic of your game :) Treat yourself to the docs for #attr_accessor and take good note of it! It's a beautiful thing.
If we look at what they did on the Rails end... it wasn't actually at all hard to do this before. Really all they did was add 4-5 lines of _generated_ code, that anyone could have easily written themselves already. The innovation is that every newly generated Rails app will have these, so you can just tell _anyone_, even newbies "Oh, you need to set RAILS_MAX_THREADS", and it'll work without them having to write any code or figure out how it interacts with existing code -- and that the same ENV is used for puma thread count and AR connection pool size, which if you don't know what you're doing is certainly a good place to start. If you already have an ENV variable at all, even a different one -- you're already there as far as being able to tell sidekiq users "Oh you just need to set this ENV". If not, it might be a good idea. ENV variables are a really good way to set this kind of thing. I think you're probably right that the default number of puma threads is not neccesarily a good assumption for the default sidekiq thread count. However, the ActiveRecord ConnectionPool size probably makes sense as a _default_ sidekiq pool size, unless otherwise configured. And RAILS_MAX_THREADS in a newly generated Rails5 app, by default, sets both puma threads and connection pool size. So maybe it's not so much that puma thread count is a good assumption for sidekiq thread count -- as that size of the AR connection pool is a good default for both puma and sidekiq. :) So it might make sense for that very same `RAILS_MAX_THREADS` to be the default, along with another sidekiq-specific ENV to set just sidekick that will keep the default from happening. I emphasize _default_. There will be many cases where this doesn't hold, and you want more or less sidekiq threads than AR connection pool size, of course. But as a default, it's reasonable, and will keep some people from shooting themselves in the foot. (What I'd _really_ like is for AR to adopt a different concurrency architecture more like Sequel's (or old DataMapper for that matter), that would make it a lot more feasible to routinely have more threads than connection pool size... but i'm not holding my breath). 
[I've got a gem that rewrites exception messages to help give the user more information]( https://github.com/bgreg/humanist-errors). These explanations would be great to add to it! 
Oh, and yes, of the two choices... over on the right is better than over everything on the left. Now I can read the post, and I am enjoying it. You really capture that aspect of ruby... how it is adaptable to different ways of thinking about programming. And you elucidate the limits of ruby very clearly.
Do I need to keep using Redis Labs in order for my Action Cable app to work?
You need to iterate through the array and it starts with 0 rather than 1. You have two elements so 0 and 1. There is no 2, hence the error. But again you need to iterate through. 
it was ok, nothing special. but i'm super smart so i found it too easy/slow. It might be great for you though, i don't know your IQ.
It's also a good way to piss visitors off and make them skip your article, as I often do when I get a popup like this. At the *least* make it close-able by clicking out of the popup window.
Never really used sinatra, but this looks okay to me. According to this you should be able to access route handler @ivars in your templates: https://github.com/sinatra/sinatra#accessing-variables-in-templates Your screenshots don't include line numbers. Can you confirm that what you've posted actually shows line 40 from views/tweets.erb?
Note that none of these have much Rails content. But if you want to understand Ruby well, you should probably just learn it on its own. Rails is nothing but a Ruby library after all.
Thanks! Yeah, I'm definitely discovering that this is the way to go.
"I want to become adept at building reliable and scalable web apps in as little time as possible." My advice? Pick one (reliable/salable) and double the time you think it should take you for become an adept at both to become "ok" at one. There is no cheating learning -- only yourself.
Eloquent Ruby by Russ Olsen. helped me to write code the ruby way
http://betterspecs.org will be helpful to you
It's a solid top 10 language and has been for a long time http://www.tiobe.com/tiobe_index . Maybe it will die one day but there aren't any signs of it happening now .
No.
It's dying just as much as PHP, Java and C. ie. it's not, it's just not the flavour of the month at the moment, there isn't a language out there that is as nice to use though. There are supposedly "bigger" and "less dead" languages (flavour of the month), that have issues at the moment: Python's version 2 vs 3 is a mess, NPM's "use a package for everything" pattern is starting to show its limitations. Ruby is in that sweet spot where it's a solid language that's well thought out, nice to use, has a strong ecosystem (but not an overcrowded one), a bunch of large projects (including Rails and Homebrew) driving progress and best practices. Best of all, the hype-train has moved on so the average Ruby community member is interested in Ruby for what it is rather than this shiny new hyped thing.
[removed]
Nah. 
I guess you can start with this The Ruby Programming Language by David Flanagan &amp; Yukihiro Matsumoto 
This is a great real-life story! I love reading about how systems are operationalized. I'm glad you mention the SRE team and monitoring at the end. It seems to me that the primary issue wasn't "we need to change our queue system" but "we don't have any monitoring for our queue/jobs". Did you agree on a Service Level Objective for queue failures or a maximum time in queue? Is there an alert (not just a passive dashboard that can continue to be ignored) and a clear playbook? Those are the hard problems :-) I became a much better engineer when I started working with an awesome SRE team. Thanks for sharing!
I think ruby will have JIT someday, but not soon. JIT makes the code very difficult to work with from a maintainer perspective and right now there are only a few companies that have hired someone to work on the Ruby core team full time. Right now Heroku has Matz, Nobu, and Koichi. Recently another company pledged to hire another dev. But it's a still a very small core team that has lots to accomplish, moving over to JIT would take a long time and make it harder to work with the code afterwards. I think they'll focus on other improvements first. Redhat sponsors jruby development, IBM has offered technology to Ruby however it's unclear if that will be merged and accepted. They did a total re-write of the garbage collector to make it a tiny bit faster. It's nice that they did that but if they commit that and then leave, the Ruby core is stuck maintaining code they don't understand and didn't write. I've not heard of Oracle doing anything to help Ruby. If you want to contribute to a language in a major way you probably want to hit the biggest problems first. People like the design of Ruby already, the major complaint of Ruby compared to other languages like say Scala or Java is that it's slow. So companies are hoping that they can make Ruby faster which has real world benifit for them and also has a large impact on the community.
Not dying..it has just rounded over the top of the "hype curve" and becoming stabilized. http://image.slidesharecdn.com/startup-engineering-culture-mk-ts-151026004342-lva1-app6892/95/startup-engineering-culture-what-matters-what-does-not-24-638.jpg?cb=1445824171
I'm not familiar with a "Redis Labs". I don't understand the question. 
Well, it started with the idea to replace Resque with Sidekiq, but ended up being - as you mention - operationalisation :) We do have Sensu monitoring latency and reporting warning and critical level thresholds to a slack channel. However, I wouldn't say we have a clear playbook for what needs to happen if we get high latency. That indeed is one of the hard problems - implement noiseless monitoring that shows real problems so people pay attention to them. I do think latency (maximum time in queue) is a good metric to base SLA on. I don't think queue size matters as much. Totally agree to your remark about SRE team - I feel exactly the same way. Thanks for reading!
I've built a couple of tools to help with this: - [a git pre-commit hook](https://gist.github.com/christhekeele/5594243) to keep you from accidentally pushing with `path:` - and more recently [a rubygem extension](https://github.com/christhekeele/gem-local) that makes interacting with `bundle config local....` much more intuitive
1) Design Patterns is by Russ Olsen ( Not Obie ) 2) I would also recommend Eloquent Ruby - again by Russ. 3) and for a ruby heavy book, i would suggest 'The Ruby Way' too.
Are you interested in legislation that will enforce STRICTER background checks for chauffers than the City of Austin currently mandates, INCREASING safety for riders in Austin? Reply with "1" if your answer is YES.
42
Ok, I see this is bothering many people. I have removed it and included an e-mail subscription in the page itself. Is that better?
Thanks for reading and providing feedback :)
I'm not familiar with the API, but: if response.status == 200 JSON.parse(response.body.to_json) else raise Exceptions::ResponseError.new(response), 'Clash of clans API has returned the error.' end might not be what you want. There are other status codes which indicate success. AFAIK faraday's `Response` has a `#success?` method you can use.
I failed to mention that I have tests for each underlying classes that test for the behavior/outcomes of each input, etc. Would I need to test that again for my Game spec? Or would it be a valuable test if I tested that each method was called in the correct order using `expect(something).to receive(:something).ordered`? Sorry if this seems like a dumb question, I'm just quite not understanding how to write the test for the Game spec.
No, no worries. In that case, since you have unit tests for each of the underlying methods, I really would just have one test that calls the start method and tests that the behavior is correct for the various inputs start may receive. So not really trading each method again, but testing that, assuming that the building blocks are correct, if I put them together, does it all work like it should. Does that make sense? 
Why would a model be calling a method to send email? 
Yes that makes sense. I'll try that out and see what I can come up with. Thank you for your response!
Ok awesome! I wasn't sure if what I wrote was clear, but I'm glad it made sense. Best of luck! 
I would suggest Python if you want another scripting language, then js. If you want a compiled language then go or Rust. Of course if you are looking for a job then C# or Java are always your best options.
If you've not seen code similar in nature, you've not worked on a big rails app.
Maybe apparently not, because I've always seen the controller handling that functionally. *Shrugs*
This is great. I would have expected #details to include the human readable error message too though, so you can get everything about the error in one place. The error symbol, plus any additional contextual info, plus the message too. I'd want to give all of that to the client, so the client can decide in some cases just to punt and display the suggested message. 
I don't understand the point of the `auto_create` flow. Using exceptions for flow control is often considered bad practice (I hate the term 'code smell', but okay if you wish, call it a code smell), for a few reasons, including but not only performance. Invalid input is probably not a particularly exceptional condition, it shouldn't be handled with a raise and rescue. I also find the new code confusing as to what's going on -- in what cases do you send `auto_create` param, what does that mean exactly? Changing from the more typical way of doing this (shown in the first example) also has little to do with avoiding AR callbacks. There's no AR callbacks in the typical way either. I prefer the typical way. I do think avoiding the AR `after_create` callback is a good idea, and so is the `send_welcome_email` method, and perhaps some version of the `register` method -- but I'd figure out a way to structure the API to use AR `save` rather than `save!`, without exceptions for flow control. I realize the point of the exception-flow-control here is so the method can return the model, rather than true/false, and use the exception for extra flow control -- I just don't like it. 
Try https://www.codeschool.com/ to learn ruby/rails. Also try the Dummies books, they are a good starting point. 
You could encapsulate additional business logic. If you just used #create you would need some sort of ActiveRecord callback which is the pattern he is trying to avoid.
I'm not sure I agree with the solution provided but yes, ActiveRecord callbacks are the devil.
Thank you. Was leaning towards js if go lost my interest since js can work with Lambda and even the Alexa skills 
A couple of excellent free resources: https://launchschool.com/books/ruby https://rubymonk.com/ 
Ugh. I find xpath a core technology for working with xml, just learn xpath. You'll be a lot better served with xpath knowledge (shared by those working with XML on any platform) then with knowledge of some specific or in-house abstraction layer, that can have it's own bugs, and hides what's really going on in the XML from you. (Especially in tests/specs, I don't want what's really going on to be hidden from me!). If "it can be difficult to find a small typo in a big XPath query", then break your xpath query into pieces, using standard code design and refactoring techniques. For specs, I do sometimes create domain-specific helper methods -- in terms of xpath and nokogiri nodes -- if I'm going to be doing the same thing over and over, and/or if the xpaths needed in specs start to get complex. These helper methods seldom need to be more than a couple lines long, when written for the specific use-case you have in front of you, if you know xpath. You can of course even write specs for those helper methods themselves intended to be used in specs -- although I rarely if ever have taken that step, I suppose I would if one was giving me trouble. I don't think those minor downsides to using xpath mentioned justify diving into a whole additional DSL/abstraction layer. Just learn xpath, it's a robust mature useful and widely-used technology. 
from a basic computing standpoint, I think http://learnrubythehardway.org/book/ is pretty good.
Hm, if it does that's cool, but I got the impression from the blog post that #errors was still equivalent to Rails4 #errors, that lacks this info, and the additional info was only in `errors.details` (which lacks the messages found in errors). Which would make sense to keep `.errors` backwards compatible with consuming code expecting the old #errors. But I'll fire up a Rails5 beta app and try it out and see when i have a chance... if not, perhaps #details can/will be enhanced to have messages too before 5beta turns final. 
If you don't like ActiveRecord callbacks you can write methods like Model.create_with_benefits(...) Model.save_with_benefits(...) etc. and use them everywhere. These would simply create/save and then do whatever other work you want them to. This way you know if the model's save / create / update / delete involves some other code you need to follow linearly, or whether it ends there itself, and removes the ambiguity that the author cites as a problem. 
To start with I'd suggest http://tryruby.org/. It's a 15 minute tutorial that can be done in the browser.
HN thread: https://news.ycombinator.com/item?id=11624890
Our slack alerts are equivalent to being oncall alerts. We always have an SRE monitoring those. Currently, the system has a bit of noise because we have latency spikes during deploys (we have a complicated setup with many pools / workers and loading lots of ruby code from different files in parallel takes too much time) and when CRM is going out (even though CRM is the lowest priority queue, those jobs are batch jobs and they take longer than others, thus it sometimes increases latency to levels that we want reported). Now when I wrote this down, CRM problem seems very easy to solve :D By noiseless monitoring I mean - if I report errors that fix themselves even without much attention paid to it, its noise for SRE and developers. They don't need to do anything about it and they will start ignoring these messages. As well as messages that they NEED to do something about. I got a bit confused when you wrote "not-noiseless page" - but you probably understood me in the first place. Now you got me thinking about a playbook. The only obvious thing I can think of is an easy way to increase capacity. What's your playbook :)? Very nice idea about capacity reviews. That's what SRE could be doing on Guild day ;)
http://tryruby.org/ the best but after that you can look https://www.codecademy.com/learn/ruby
Next post is due for the weekend!
On Windows, I use Ruby 2.1.5. The only time I ever use Ruby natively on Windows is when I need to compile a Windows Service or Executable Application with Ocra (https://github.com/larsch/ocra). Other than that, I develop any Ruby application on Linux and/or MacOS.
It's certainly still possible that there are bugs that expose such a vulnerability in paperclip though. 
huh. That's kind of neat framework . Never seen that before. Thanks for the intro to it. 
There are several frameworks popping up in the lambda/serverless space. (One is called serverless, which irritates me as it ends up over-loading the term that once was just an architectural concept) Apex is the first one I've seen that 'shims' in a non-native language into lambda. I should probably pimp /r/serverless while I'm on the topic. This is the architectural concept, not the specific framework, although you will see a lot about the framework there.
You are right, I'll implement that. Thanks for the tip! Although since the Clash of Clans API only returns 200 for OK responses for now(only get requests). I can update this code in case in further versions they decide to add another statuses.
Yeah, they're not great... but my rule of thumb has become, they're OK as long as they only touch or effect the model's own data, for maintaining integrity/cache invalidation etc. The ones I try and cut out with a vengeance are any with any cross cutting concern. In a production app that may have 20 controllers touching a single model, and a new concern for something to keep that model OK, I don't like adjusting all 20 controllers and then hoping anyone who writes the 21st also remembers to do the same....
After 3 or 4 years of this game release, is kind of a miracle, really!
&gt; WDYT I think you are totally right, I've been thinking on how to implement this, I'm going to follow some of this design in the API: [https://github.com/digitalocean/droplet_kit/blob/master/lib/droplet_kit/client.rb](https://github.com/digitalocean/droplet_kit/blob/master/lib/droplet_kit/client.rb) Also, since this is my first gem, I'll just wanted it to work, but I'll make sure to add the tests accordingly, although I must have done it in the start of the development process. Thanks for your tips.
rubymonk is by far the best interactive resource in ruby, I think.
https://rubymonk.com/ https://rubymonk.com/ https://rubymonk.com/ https://rubymonk.com/ https://rubymonk.com/
I'm thankful I opted to use Cloudinary over handling image processing myself. In all honesty it was more laziness than anything but now it looks like it was a wise decision. Also, I didn't think I would be able to match their features locally. Specifically the face detection where you can crop while centering on the subject automatically. It seems freakishly accurate. 
Or C: extract to a service class which is just as capable of breaking encapsulation but awfully good for a pedantic rant about fat models and simple controllers. Makes for some good blogging and tweets!
There is a difference between building a performant app and relying on the ability of Heroku to throw more hardware at your shit show. All too often you see poorly written code go into production simply because memory or more cpu power is relatively cheap. Coming from a background where servers were expensive and we had to wring out every last drop of performance we could, it worries me how the general attitude is just use Heroku and crank up the resources. That gets expensive quickly. 
This isn't really a vulnerability for most websites. Every website I have written does type checking. If you aren't doing that, you've got a lot more problems than this. Uploading a PDF will cause one image to be created for every page - for example. This is a "know your tools" issue. In order for it to be a legit vulnerability, you have to be using it correctly and still be vulnerable. That said, it should be fixed but it's hardly a crisis.
It's just OpenCV - you can copy the code right from their gem's README to do that. Do you work for this company?
Yeah, i've been spending my free time looking into this, I really want to do some work in this sort of stuff, but the frameworks are all immature. Serverless (the framework) has the ability to simulate lambda locally for development purposes. Couple that with redis for simulating SQS locally and the local version of dynamodb and you can play with a lot of stuff.
I'd suggest you not to be too excited about meta-programming, at first. It's much better to first understand what you need in simple code (like define class `Clan`, define its constructor, define when and how client will construct them) -- and only after that make the code "generic" and working with any types API defines.
I know that it's not the point. I'm just curious as to why they did so in the example. 
If at all, use [getrandom()](http://man7.org/linux/man-pages/man2/getrandom.2.html) instead if available
I wasn't referring to simply writing efficient and performant code but rather the devop chops necessary to achieve horizontal scalability 
I had never heard of OpenCV. Had no idea there was a gem that could do it. Very cool. And no, don't work for them. Sorry it came across like that. 
Good idea!
Could you point me to alternatives? It's always better to know your options - is there any article you can recommend on the topic?
Hi, one should not instantiate the `Barber` object inside the `Person` object, nor should one instantiate `Hair` inside `Person` (though admittedly, hair does grow from a person's body). It might be better in that case to do something like `def dye_hair(color, dyer) ; dyer.new(hair).dye_hair(color) ; end` As you mentioned, here there's a matter of the right interface. The `Barber` object *needs* to have a `dye` method so he can change the hair color, but I would argue the `Hair` *needs* to implement an interface which we might call `Dyable`. So maybe, with even more objects: module Dyable def dyable(color) @color = color # assumption that the object will have a `@color` ivar end end class Hair include Dyable def initialize(color) @color = color end end Does this make sense?
I bought the book yesterday. Can i drop this into the examples without too much modification? Happy to poke around but good to know if it will require a lot of digging.
Use a hash. Traverse A and use each element as the key in a hash, incrementing the value of key each time each time you see it. Then group by value and select where there was one instance of a key. I would write code for you, but I'm on my phone. This solution should be O(n) complexity, which is about as good as you can get i think.
 def solution(a) # write your code in Ruby 2.2 while a.count &gt; 0 curr = a.pop curr_count = a.count a = a - [curr] break unless a.count &lt; curr_count end curr end
Think of what you're doing. You're going through the array once per unique number (count has to go through the entire array to find equals to numb). Think about whether you can do it in one pass. I don't want to provide code, because I think it's beneficial for you to actually write this, but think of it this way. If you go through the array once, on each number, what can you check that can tell you without a doubt that the current number is _not_ the one you're looking for? What data can you keep to help you? If you figure that out, then you can traverse the array, and if the array is correct, you will have excluded (using the check you devised above) all numbers except one. That one is the answer. In general, if you find yourself going through the entire array for each element of the array, that means O(n) complexity, which grows very rapidly, and is rarely the best solution. You should aim for going through an array once to determine properties about it, and rarely will that be impossible. You will have to make book keeping while you traverse it, and the nature of the book keeping is what solves your problem. I hope I helped more than I confused you. Feel free to ask for more if you're stuck. 
Using that code just to see how it performs, it was rated 55% FYI
How was your correctness vs performance points? I have hunch that one of the tests is wrong.. small1, medium2 and big1 specifically.
Yeah, I get those three wrong all the time as well, even after I became completely sure of my solution. My code replies that there is no single value in the input in all of them. EDIT: There seems to be a 35% of correct answers, so I don't know, perhaps we're just missing something. :)
I love this part of the readme where you explain how different gems contrast and fit into the security space: https://github.com/square/rails-auth#comparison-to-other-railsrack-auth-librariesframeworks Nice idea for anyone publishing their own take on a solution.
Ok good, at least I am not going crazy haha
Any plans on extracting the Rack specific parts?
100% :)
this fails: solution([1,1,1,1,2,2,2,3,3]) there's a 2 that's "unpaired" i originally didnt understand this about the question. so something like: def solution(a) dic = Hash.new(0) a.each do |numb| if ((dic[numb] == nil) || (dic[numb] == 0)) dic[numb] = 1 else dic[numb] = 0 end end dic.key(1) end
The reason is to keep the program simple to read and understand and less prone to errors (as well as more debatably - write). Its not more important than speed in all circumstances but it is in most things youll do in ruby. High level languages are successful precisely because of things like removing loop incrementors from your list of worries
Objects on Rails by Avdi Grimm, didn't read it yet but heard good things about it. 
Yep, I modified my code to that, and was able to get 100%. cheers!
I was surprised to find that not only is it not dying, it is pretty steady compared to other languages as per [Google Trends](https://www.google.com/trends/explore#q=ruby%2C%20java%2C%20php%2C%20c%2B%2B%2C%20javascript&amp;cmpt=q&amp;tz=Etc%2FGMT%2B4). I really expected to see JavaScript to be taking off since it is the flavor of the month, but it was holding steady as well. Have fun swapping out different languages!
Awesome! as a point of refactoring, I'd probably write it like this: def solution(a) dic = Hash.new(:paired) a.each do |n| dic[n] == :unpaired ? dic[n] = :paired : dic[n] = :unpaired end dic.key :unpaired end Instead of counting and then detecting an odd, you just have to keep track of whether you've seen an even or odd number of a particular key. This achieves 0(n) time complexity still, and is very memory efficient since you're using symbols. Probably not the best solution, but it's something to think about and consider improving if you care to dive that deep into it. Another option is adding keys to the hash if they are not represented and deleting them if they do exist. This would achieve the same effect, use even less memory, though I'm unsure of the time complexity in deleting keys from a hash, so you'd have to experiment with that to see which way is truly faster. def solution(a) dic = Hash.new a.each do |n| dic[n] ? dic.delete n : dic[n] = 1 end dic.keys end
Yep! Symbols will end up taking less memory that counting and trying to find odds (in the worse case scenario) because each symbol with the same content is the same object in memory, you're just making new references to it. Observe: irb(main):001:0&gt; sym1 = :something =&gt; :something irb(main):002:0&gt; sym2 = :something =&gt; :something irb(main):003:0&gt; sym1 == sym2 =&gt; true irb(main):004:0&gt; sym1.object_id == sym2.object_id =&gt; true The way you have it written, you're still at O(n) time complexity, but your memory complexity is also O(n) (I believe) and the time complexity is really 2n in the worse case scenario (everything's unpaired). Both of those things can be better. Please realize that I'm kind of nit-picking here and your answer is a fine one. I just love talking about this sort of stuff.
No, but you can pull them in without the Rails-specific parts by requiring `rails/auth/rack`
Is this like a factory, but automatic?
https://github.com/JuanitoFatas/active_sample/blob/master/lib/active_sample.rb#L13 Shouldn't this return an empty array or an empty relation?
[].sample returns nil so I follow its behaviour.
The sort is probably way more expensive than the group. But the important thing is to be thinking about it. :)
Nice, that's pretty much the alternate solution I was thinking of. Be aware that using `select` instead of `find` forces you to iterate over the entire array, whereas `find` stops at the first match.
damn, that's a nice idea!
My version is almost twice as fast as yours by my tests (MRI a=[4,3,2,3,4,7,2,8,7,8,3]) I suppose this is the point where I write something smug like 'But the important thing is to be thinking about it. :)' [edit] anyway, lets concede the winning one is this https://www.reddit.com/r/ruby/comments/4hw46q/help_on_performance_on_this_ruby_quiz/d2tmceg
Why not implement this in terms of `order by random()`? This implementation seems overly complicated
oh ok cool, thanks
Thanks for the advice, I have used rubocop before, but my doubts were more about the API implementaion, instead of code-related.
Wouldn't a pointer to a symbol take up the same amount of memory as an Int ?
 return unless parts.empty?
PostgreSQL 9.5 supports this construct: SELECT .. FROM table TABLESAMPLE [SYSTEM | BERNOULLI] (percentage) [REPEATABLE (seed)] Where SYSTEM selects from random table blocks (and so may be slightly biased) and BEROULLI selects precisely from random records. The [tsm_system_rows](http://www.postgresql.org/docs/9.5/static/tsm-system-rows.html) extension lets you replace `(percentage)` with `SYSTEM_ROWS(row_count)` SQL Server supports `TABLESAMPLE SYSTEM`, with the argument `([n ROWS | n PERCENT])`
Topaz has a GIL.
🎉🙌 🎉🙌 🎉🙌 🎉🙌 🎉🙌 🎉
Sometimes I want to take some random records out to test.
Perfect. Haven't used a XOR operator since college lol.
Thanks. Is the OP using one of the techniques mentioned in that blog post. Which one?
so something like module ApplicationHelper def title(*parts) if parts.empty? return else content_for :title do (parts &lt;&lt; "Ticketee").join(" - ") end but then I see this : Use a guard clause instead of wrapping the code inside a conditional expression.
Well then I'm even less interested.
Depends on your dataset. When you get into larger numbers, `sort` bogs down: require 'benchmark' max_num = 2_000_000_000_000_000_000_000_000_000 test_arr = (1..1_000_000).flat_map{ [ rand(max_num)] * 2 } test_arr &lt;&lt; rand(max_num) test_arr.shuffle! def sort_slice(a) a.sort.each_slice(2){|b,c| if b!=c then return b end } end def group(a) a.group_by{ |x| x }.find{ |k,v| v.count.odd? }.first end Benchmark.bm do |b| b.report("sort_slice "){ puts sort_slice(test_arr) } b.report("group "){ puts group(test_arr) } end Gets me this: user system total real sort_slice 1826416629268837682147968286 4.840000 0.060000 4.900000 ( 4.899506) group 1826416629268837682147968286 3.860000 0.100000 3.960000 ( 3.969492) But hey, we're coding in Ruby, so performance is irrelevant, right? ;) Though the xor method is indeed blazingly fast. The downside is it only works for integers, so it's useless for floats, strings, etc.
&gt; Hm, if it does that's cool, but I got the impression from the blog post that #errors was still equivalent to Rails4 #errors Based on a [source code dive](https://github.com/rails/rails/blob/master/activemodel/lib/active_model/errors.rb#L268) I think you're right. At the least serialization of an ActiveModel::Errors object is still turning it into a hash of `key: ["message"]`. It shouldn't be *that* hard to patch something together that includes both, but it's kind of annoying. From a look at the source code, details and messages are basically entirely separate from each other in the object and just kept in sync at each change point. It seems like the details should be enough information to generate messages, but that last step hasn't really been done.
kinda annoying. i guess it's easy enough to write a wrapper that merges the usual messages into errors, but this seems like something that should be standard. `details` should include everything including the messages! 
LMFTFY: Use heroku and you mostly get scalability at very high cost. Show me a medium sized app running on heroku and I can show you a app that can cut its ops cost by more than 60% with very little effort. 
can't you have 12 hours a week ? 
You can also just tell rubocop to ignore that rule for a line: &gt; One or more cops can be disabled on a single line with an end-of-line comment. &gt; &gt; unless parts.empty? # rubocop:disable Style/NegatedIf &gt; https://github.com/bbatsov/rubocop#disabling-cops-within-source-code
Yeah. It's even hard to patch this in since the `normalize_detail` method doesn't take in the attribute name, so you can't use it to generate the message and add that too. That said, it looks like there's [already a pull request](https://github.com/rails/rails/pull/20641) hopefully it gets merged for 5.0
When I do that I see this output : app/helpers/application_helper.rb:4:5: C: Use a guard clause instead of wrapping the code inside a conditional expression. unless parts.empty? # rubocop:disable Style/NegatedIf ^^^^^^ app/helpers/application_helper.rb:4:25: W: Unnecessary disabling of Style/NegatedIf. unless parts.empty? # rubocop:disable Style/NegatedIf ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Paired with some docs, I'd definitely agree.
oke, so I change my code to return unless !parts.empty? and I see the same problem as my orginal problem. It looks like to me Rybocop wants to rewrite this code or in a postive way or without any conditionals. As soon I as try to make a difference between the empty and the non-empty case. Rubocop is not happy.
This is definitely an idea people should get more involved with. The position the Ruby team took is embarrassing.
!parts.empty? is the same as parts.present? second one is cleaner.
FYI: For more static sites news bytes (Jekyll, Middleman, and friends) see the Static Times twitter news channel [@statictimes](https://twitter.com/statictimes). For more Jekyll goodies, see the [Awesome Jekyll](https://github.com/planetjekyll/awesome-jekyll) series @ Planet Jekyll. Cheers.
&gt; return unless !parts.empty? Thanks, finally got it working and learned another thing
&gt; For instance, don't test that a #validate message was received, test that invalid input produces the expected result -- an error message, an invalid flag being set, whatever. And that valid input goes smoothly. I can see a case for both. Many tests around the input and output of the validity objected (tested in as much isolation as possible), then a test to make sure that it's being wired up correctly and actually called.
Glad to help. :) One.more thing, I always prefer to use blank? as it is equal to nil? and empty?
finally! now I'm still waiting for aws lambda to support Ruby. 
I like this blog series, I think it's well written, neither too much nor too little narrative, and serves as a good example for relatively less experienced coders at "how do I read source", suggesting you really _can_ just look at the source of your dependencies to see what they do, debug, etc. :) Plus the code reviewed in this example anyway is indeed generally fairly well-written and interesting. 
Is it using something like Puma or Passenger behind the scenes to serve e.g. Sinatra apps or did Google write their own Ruby app/web server? 
What's a harph? Is it just a harp? [](/GNU Terry Pratchett)
`candidate.applied_recently = false` I really don't see the point of using `while` here and doing those `candidate.is_an_experienced_programmer = true/false` assignments.
I've got many versions that use only one if statement, but this is the most recently written version. As for the assignment at the end, should it just be *return true/false*?
indeed reasonable assumption, my only concern is how to protect person from unauthorized change of hair color, I do not want to expose hair to anybody. The `person` picks a `barber` and ask him to dye hair, so it makes sense if `person` calls `barber.dye_hair`. I know it looks awkward but I do not see other way to prevent leaking permissions.
Hi Thank you for suggestion. The reason why this gem exist is is that few months ago I was writing simple CLI for deployments in my company. Because that CLI was used by DevOps guy who not necessary need to install bundler, rvm,... I was trying to limit the dependencies. As TTY has several dependencies (https://github.com/piotrmurach/tty-prompt/blob/master/tty-prompt.gemspec) I wrote this gem. I was never planing to release it as rubygem but then this solution got implementned in several other DevOps tools. So long story short I highly recommend to use TTY as it's has more use-cases. But if you are looking for something primitive "inputs" gem is an alternative. In future I'll make "colonize" optional dependency. 
I don't know if that's reasonable. If a can of paint falls on someone, their hair will change color. That's not the person's choice.
thank you for defence. ...and yes I agree the project is too far from being good, it's just a simple Helper tool that just works :) 
Only short attention spanned devs think Ruby is dying
**First issue** /u/Valvyn and /u/toolbelt are telling you not to use assignment (`=`) when you really want comparison (`==`) in the condition where you check `candidate.applied_recently`. **Second issue** Later, in the condition where you check `candidate.languages_worked_with`, you're using the `include` method where you should be using the `include?` method. The question mark is important. **Third issue** As others have said, the `while` loop is not what you want here. If you want to see why, try fixing your code as I've described above, and then run it with a `candidate` that satisfies the conditions: candidate.age == 18 candidate.applied_recently == false candidate.languages_worked_with == ["ruby", "javascript"] It's an infinite loop, because if the candidate satisfies all three conditions, execution will enter the `while` loop, but none of those conditions ever change. **Fourth issue** The logical conditions checking `years_of_experience` and `github_points` are needlessly complicated/redundant. The structure of those conditions is basically this: (a &amp;&amp; b) || (a || b) But the `||` operator is an "inclusive or," meaning that if `a &amp;&amp; b` returns true, `a || b` will also return true. Therefore, you don't need the `&amp;&amp;` portion of that check at all. **Fifth issue** You don't give much info about the class identity of `candidate`, but since it already apparently has instance methods, why not take advantage of that? You could make a new instance method that tells you whether a candidate is an experienced programmer. [Here's one way to rewrite your code](http://pastebin.com/NHWt0fzU), taking into account all the issues I've noted above.
When node came out, I got a little nervous. But then... JavaScript.
Probably the Elixir hype train. 
What exactly are you complaining about? You don't like MVC and RoR - so what? Why didn't you created your own MY-SUPERIOR-MVC or whatever else you prefer?
Its not dying, Rails finally arrived in Enterprise, like: If a big company will plans to start a new Website RoR will be at least an option.
Oh, good. I was worried that I wouldn't have a job on Monday.
I also don't like Rails, but luckily there are many other Ruby web frameworks which give me the flexibility I want.
Thanks a lot for the answer. Could you also explain me why JS is terrible ? That's what my professors will tech me soon.
&gt; Ruby is... a dynamic, open source programming language with a focus on simplicity and productivity. It has an elegant syntax that is natural to read and easy to write. ruby-lang dot org I would add that it is really easy to setup and get started, multiple platforms are supported, libraries (gems) are easy to install, has a nice package manager (bundler).
In the fullest sense of the word 'why', JS is terrible because browser people in the '90s made a language they thought would be good for normies. If normies, being dumb, do something like: "20" + 2 the result will just be `"202"`, so that normies don't get their feelings hurt. In any non-idiotic language, adding a string and an integer causes an error. The other thing is, just as there are "two" Pythons, there are like 200 javascripts. In Ruby or C or whatever, the version you're on is the version you're on. That's it. If I write a program in Ruby 2.0, but I try to run it on a computer that only has Ruby 1.8, it just won't know how to run it (assuming I use 1.9+ syntax, yada yada). But I could just download 2.0, and then everything would be golden. But there is no JS. There are EMCAScript *standards*, published by EMCA, about what a "conforming" language should do. But these are just documents. Just words. There is no official Javascript. Every browser implements it differently. Every person who accesses your webpage is potentially using a different javascript interpreter. It's just a big fucking mess. 
Thanks a lot for your great answers, you've been very helpful. I'm starting Ruby right now with the "Try Ruby" website while im downloading it :)
Yeah, we shouldn't blame MVC for Rails' sins.
Obviously you don't practice resume-driven development.
Because I work 50 hours a week and don't have time to single-handedly convince sneering chumps like you that their life would be simpler by switching to CQRS domain modelling.
A few interesting topics there, looks good! Will the videos be published on the CloudCannon YouTube channel at https://www.youtube.com/channel/UC8CXR0-3I70i1tfPg1PAE1g?
Somebody went to RailsConf http://i.imgur.com/qUyln4l.jpg 
Honestly, the only other language that even piques my interest at this point is [Crystal](http://crystal-lang.org), and that's only because it is trying to copy Ruby syntax as close to exact as possible.
What the heck happened to C in 2008?
Crystal is great and flat out pitches itself as Ruby like. But damn it is blazing fast. Ruby has too much support to ever die. That is just silly. 
Not sure why VB, but I can understand Perl. A lot of sys-admin type tasks, DBA, data/reporting, BI, devops and of course legacy applications still utilise Perl. Not everyone is working in a startup in San Fransisco and get to use all the cool stuff :) 
I think Go will be a very popular language one day, it seems to be suffering from a form of performance anxiety at the moment. 
I think interest is waning as when you look at various aspects they aren't being developed like they once were. Take documentation. Yard is quite popular but when was it last updated? It's been years. Nearly all Yard plugins are circa 2011-2012. Sure that's just one example but I've come across a lot of stuff that was developed around that time and then left to wither. Seems like maybe we peaked in 2012. 
heyyo! http://i.imgur.com/wCbbtsJ.jpg
That's the clearest and most complete explanation of Ruby functions I have read. Well done. 
Given that google quite literally is replacing almost everything webside with Go, and is almost done with all their serverside stuff, as well as huge parts of their data infrastructure.. I don't get what "performance anxiety" is here. Remember when GvR left google? That was about the time Python was being removed in favor of Go, and the planning was almost complete THEN. It's well into being the backend language of choice for google. 
&gt; Given that google quite literally is replacing almost everything webside with Go So you are saying it is a very popular internal tool, well that is good but it is also the problem. The problem as I mentioned in another post is that it has not found a big enough footing in the general user community. &gt; Remember when GvR left google? That was about the time Python was being removed in favor of Go, and the planning was almost complete THEN. That statement is like saying *"C# is one of the greatest development languages ever because Microsoft uses it."* I am not bitching at Go I think it has great potential, but given the company who has control over it and the size of that company, and that they are a leader in so many areas of technology, it still has not made a big enough impact YET. This thread was started with a post from Toibe, they made it very clear that the list is not about the best programming language but the popularity of them. I live in country in Asia, in fact I lived in many Asian countries for many years, I would be surprised if I saw 1 job ad for Go every few months. I do not even know of 1 user group, 1 business, 1 training centre, 1 developer who uses/used/going to use Go. I can rattle of lists of Ruby, Python, Java, C# shops, I can even point you to companies using C. 
Ruby apps running on Windows in production? Madness.
I'm confused - what's the benefit of this?
Good one!
I'm actually big fun of ruby and rails, but I think first scripting language should definitely be js, because web is everywhere and knowing js give you free bonus in that area, more over node is a thing now, and it is rapidly developing. ES2015 gave js real power, you already can use it in nodejs 6, though in browsers you have to transpile it by babel or another tool. Ruby is more powerful and consistent language and I doubt that there are such well done framework as rails in node world, but it isn't overweight js bonuses. And I know that python actually beats ruby by popularity and some other things, you can [see it for example here](http://blog.udacity.com/2015/05/pick-your-first-programming-language.html ) 
I'm glad you liked it. Thanks for reading.
I'm glad you liked it. Thanks for your feedback.
i took this course after years of stagnation as a coder. When I took the course, I found that learning Ruby, Rails, rspec, agile, and everything else was too much for my little brain. I like to learn a little but know it deeply. so the course was good in giving me a whirlwind tour of rails but I wasn't functional in it afterwards. I had to retreat back to learning Ruby, then move to learning Sinatra, minitest, and everything else in basic form. I never actually went back to rails after that. I appreciate the course for opening my eyes but I took a different track. YMMV. 
Dig it, but for some reason I need to scroll down to see the word list. Either the block of letters is too big or maybe the word list should be on the side. Other than that it's good.
Totally agree with slade981 on the scrolling thing, but this is impressive. Keep going. Also, put something on the landing page - right now it's a bit...sparse.
In what sense? Could you share some examples? Not trolling, really need to know.
Because why would you do that? Windows hosting normally costs more because Windows isn't free, and it's a pain in the ass.
I can't tell if this is serious, or not. As a joke, I find it kind of amusing. I really hope it's not serious. If you are psychologically impacted by the words being printed out on the computer screen by your test framework, I wonder if you're prepared to read the logs or exceptions when your code actually fails in production.
Rust is a systems programming language, like C or C++. No VM, compiled ahead of time to native code. Its special bit is that it prevents a lot of problems at compile time, rather than at runtime. For a Rubyist, a main use case (and one Helix is targeting) is that you can extend Ruby with Rust the same way you extend Ruby with C, and you'd do so for similar reasons.
Here's what I'm seeing. If it helps. Again, not a huge deal, and I can zoom out or whatever, just figured I'd point it out. https://imgur.com/sARaPqJ It could be the cookie popup. Now that I see what you mean. Edit: Yeah that's what it was.
Very cool. So now tell us the technical details. 
ruby easy for dsl, every script is a mini language. just use ruby.
&gt; The game engine is full javascript from scratch. This is the bit I found most interesting, so did a bit of reverse-engineering research. From what I can tell (please correct me if I'm wrong): * All puzzles are pre-generated, with solutions (stored as JSON), in the database. * When playing a puzzle, the only client-side information known is the total number of words, and the number of words found so far. * When you enter a word, this makes a `POST` request to the server. If the coordinates are a correct answer, then they are repeated in the server response. * Keep-alive messages are also sent. If they stop (because the browser lost focus), then the timer pauses. Nice. That's a pretty simple, robust system. Not that it really matters in this case, but I bet the system has a basic anti-cheat check built in too: If the `timer` drops to a lower number than the last keep-alive, it must have been a cheat. (I couldn't be bothered to actually test this though :P)
So are you saying he should learn js? Which is not a scripting language in its core? I can't guess from what you write, but I am no native speaker. Could you rephase a bit to make your point clear? :)
are you sure you know what a pun is?
Maybe it's a typo or a misunderstood idiom. Doing something "[**like** a dream](http://dictionary.cambridge.org/dictionary/learner-english/like-a-dream)" is an idiom meaning "very well". I really can't think of anything else it could possibly be - there's no meaning of "dream" that seems to fit in this context (programming, e-mail/SMTP, Ruby, etc).
To be honest I have never heard of some of these people. I know of: * Charles Nutter for his work on JRuby * Advi Grimm for his general ruby work and books * Koichi for his work as a ruby core commiter * Coraline Ada Ehmke for the CoC brouhaha * Schneems for various ruby work. All this does is link to a Github profile. It would be useful if there was maybe a page that detailed why exactly these people are "Ruby Heroes", it might showcase the work they have been doing. Especially since I remember a blog post by someone who use to be a "judge" (Past hero?) or something like that which basically says "Ruby Heroes" is a very cliquey and basically decided not to take part. EDIT: Found a slide deck https://speakerdeck.com/olivierlacan/ruby-heroes-2016 which gives the reasoning for each
You should put the words above the wordsearch itself, I think that's what they're saying. I had the same issue.
ok ! Thanks for the feedback ! 
all that "Coraline" does is yap endlessly about equality for trannies and other hot topics for SJWs. She's (or 'he') is a bully, an exceptionally unconvincing and unattractive "female" and, afaict, has done nothing for Ruby except cause dramas. Example: Her attack on opal.rb maintainer https://github.com/opal/opal/issues/941 She/he is a fucking dick.
Here's hoping this won't take too long. Roughly speaking, the best way to understand Ruby is that MRI (Matz's Ruby Implementation) is a program (written in C) whose sole purpose is to interpret and execute programs (or 'scripts') written in the Ruby language. Ruby *the language*, is simply a well-defined syntax. All that means is that you can write a program which will read a file and say "yes, this is a valid Ruby program" or "no, this is not a valid Ruby program". This has nothing to do with the *semantics* of the language, though. You and I could both implement programs which parse Ruby- they would, by definition, agree 100% about the form of "valid" input, but that doesn't necessarily mean that they agree on "what should I do in response?" Ruby, *the implementation* solves this problem. Although there's not exactly a well-defined means to define what syntax elements "mean", we consider MRI to be the de facto standard. In other words, if I use any program calling itself a "Ruby interpreter" to execute a Ruby program, it should have theoretically identical behavior to MRI. The two major alternatives to MRI are JRuby and Rubinius- the former is implemented in Java and gets executed on the JVM, and the latter is implemented on a much more bare-bones interpreter. Now, just because the interpreter of my program faithfully performs all the things I told it to do, it doesn't mean that all interpreters are equivalent. One might be faster, or less buggy- consider the analogy of two Japanese translators trying to translate the same English sentence; furthermore, suppose that one has a lifetime of experience, and the other has only been interpreting for a couple years. The former would be able to translate the sentence more quickly, and also capture the intent of the source sentence. The latter would translate slowly, and only be able to translate the basic ideas. Ugh. It's hard to explain in more detail... partially because I'm a bit tipsy, and partially because I'm bad at explaining this stuff. This is why one takes a Programming Languages class as part of a Computer Science education. Feel free to ask more questions- hopefully I've given an overview, and more specific answers would help you out. 😁
Well, for example, an on-premises installation for a small business that already runs on Windows and has a Windows "server" in the closet at the office. Because not all software is SaaS, at least not yet.
Shooooot, that looks amazing. I had actually heard about this book a couple years ago but it completely slipped my mind. Thanks!
Hah, thanks! Yeah, some of those abstractions I was aware of but helpful none-the-less. I understand some of the higher level differences between the interpreters. Correct me if I'm wrong here... jruby compiles down to run on an entirely different runtime, right? The JVM? And Rubinius does... some kind of dark arts to get around the GIL? Heck, maybe I'm an idiot but I'm not sure I even understand what a VM really is or at least how it's implemented. If I'm reading you correctly, the ruby vm/runtime will **always** be the same regardless of the interpreter used? Thanks again!
bundle exec [command here]?
You're welcome! You may want to also start a really basic puzzle on load so people can just jump in and play. It could be the same one for each new user, no need to clog up the back-end. :)
As chipperclocker comment, you have only mispeled orca instead of ocra
Bah, you're not an idiot! Part of the problem is that some of this stuff is remarkably resistant to explanation. I never really *got* Rubinius until I started digging into its implementation- and even now, I have a hard time explaining it (which proves that I don't 100% understand it myself, haha.) Have you ever used a SNES emulator? The concept behind a Super Nintendo "emulator" is that it's a program which tries its absolute best to "emulate the behavior" of the physical SNES hardware. In a certain sense, any program which "emulates" the behavior of SNES hardware well enough can be said to be "virtually identical" to an actual SNES. It is a "virtual machine". I'm using lots of "scare quotes" because I am, myself, not doing a very good job of "getting" to the "point". In this sense, a "virtual machine" is a program which "pretends" to be a general-purpose computer. Physical computers (processors) are circuitry on which programs (written in a programming language) can run; virtual computers are programs on which programs (written in a programming language) can run. Getting back to the point a bit, the JVM (Java Virtual Machine) is a very sophisticated program that tries very hard to pretend that it's a general-purpose computer, which can execute other programs. However, the programs it executes are "written" in a language very similar to assembly language: "JVM bytecode". Various communities have written compilers which convert high-level languages to JVM bytecode: * The GNU Compiler Collection (gcc) compiles C code into machine code, which is executed by the computer's actual hardware. * The Apple Objective-C compiler compiles Objective-C code into LLVM bytecode; then the LLVM compiler compiles LLVM bytecode into machine code, which is executed by the computer's actual hardware. * The official Oracle Java compiler compiles Java code into JVM bytecode, which is executed by the "Java Virtual Machine", a program running on the computer's actual hardware. * The OpenJDK compiler compiles Java code into JVM bytecode, which is executed on the "Java Virtual Machine", a program running on the computer's actual hardware. * The official Clojure compiler compiles Clojure code into JVM bytecode, which is executed on the Java Virtual Machine, a program running on the computer's actual hardware. * Microsoft's official C# compiler compiles C# code into Common Language Interface bytecode, which is executed on the .NET Virtual Machine, a program running on the computer's actual hardware. * The official Erlang compiler compiles Erlang code into Erlang VM bytecode, which is executed on the Erlang Virtual Machine, a program running on the computer's actual hardware. * The JRuby compiler compiles Ruby code into JVM bytecode, which is executed on the Java Virtual Machine, a program running on the computer's actual hardware. * Matz's Ruby Interpreter *reads* Ruby code, which is executed on the MRI Virtual Machine, a program running on the computer's actual hardware. * Rubinius *reads* Ruby code, which is executed on the Rubinius Virtual Machine, a program running on the computer's actual hardware. Does that make a bit more sense? Kinda repetitive, but it might help you get the idea. :)
You're going to kick yourself, but... It's not ORCA. It's OCRA. O-C-R-A. That's why the command's unrecognised.
&gt;In a certain sense, any program which "emulates" the behavior of SNES hardware well enough can be said to be "virtually identical" to an actual SNES. It is a "virtual machine". *makesomuchsense.gif* That's definitely enough of a concrete explanation to help me form some additional ideas! That list definitely helps. It's repetitive but a pretty good rhetorical device. Massively helpful. Thank you so much for your time! I think I have some reading to do :)
Okay so I get all the ones you list - but how is Coraline a ruby hero? she tried to stir up shit about a code of conduct we'd be better off without her(or him?)
…and this post is where his heretofore interesting and useful series finally jumps the shark. Not content to merely jump, it performs air tap-dancing and other pointless aerobatics with the aid, primarily, of `dry-component`. My understanding of the dry-rb classes (of which I'm currently using `dry-types`, `dry-validation`, and `dry-equaliser`) has been the reification of the principle that "explicit is better than implicit". You can set up some very nice duck-typed duct tape ("duck tape"?) with these Gems that leaves your code explicit yet free of sizeable chunks of boiler&amp;shy;plate. And then `dry-component` comes and explicitly says "we're going to make everything magical again; at least, we're going to move the man moving the levers back behind the curtain". **wat**
&gt; The solution are not stored actually Hmm, not sure I understand this exactly - wouldn't it be more convenient to store the answers? For example, you could then add functionality such as "show hint" (which could eliminate part of the board where the word is not placed)? &gt; It also avoid cheat because you cannot submit a time less than the time in the database However, a really determined person could still "legitimately" cheat by writing a script to just solve the puzzles and send a `POST` request with the answer in a fraction of a second... But if someone really wants to go to those lengths, they probably deserve the high score ;)
I just made a poster for my office. I wasn't trying to create an amazing piece of artwork and cannot see how a poster made up out of logos can be "childish"
done ! :D 
I made the change, when you are not logged in, the random puzzle are easier ( max difficulty 5 ).
man, the RVM logo throws everything off.
If you already now what websockets are you can skip to the example app and implementation https://blog.heroku.com/archives/2016/5/9/real_time_rails_implementing_websockets_in_rails_5_with_action_cable#building-a-real-time-chat-app-with-action-cable which includes a Heroku button to 1 click deploy an app.
If that (i.e. creating an application with so serious design flaws) is possible, does the framework do a good job then?
 * clean syntax which allows for very readable code * built in sane and complete support for regular expression (as opposed to Perl's regex craziness) * blocks (i.e. anonymous functions) * programming fun
You could use the same argument with c++, or any universally accepted technology
(I'm a past Ruby Hero) One of the original purposes of the Ruby Hero award was specifically to make people know about great work being done that was under-appreciated. So you not knowing about some of these people is absolutely normal :) &gt; Especially since I remember a blog post by someone who use to be a "judge" (Past hero?) or something like that which basically says "Ruby Heroes" is a very cliquey and basically decided not to take part. If I had to guess, you're talking about Greg Brown, and https://medium.com/@practicingruby/some-facts-about-the-ruby-hero-awards-1ebe6011973a To be honest, I haven't kept up much in the last few years, so I didn't pay a ton of attention to this particular situation; I have no idea who's right or wrong.
It's a troll comment by a troll account (less than 21 hours old). They made it to bash Coraline in another thread https://www.reddit.com/user/deven7. I think they commented here to try to not trigger some kind of auto detection for throwaway troll accounts. Looks like you got caught in the crossfire. Thanks for sharing. On the link posted, i'm a bit color blind. The black ruby is hard to see. Switching to a lighter color would help with contrast.
People are tired of hateful bullshit from assholes like you. Her contributions are what the community needs.
People are tired of hateful bullshit from assholes like you. Her contributions are what the community needs.
300K downloads is nothing. I know guys that have millions of gem downloads and don't even get nominated for a ruby hero award. By the way, those gems they either wrote or actually contributed towards, unlike you, who just merge pull requests -- my god, do **you** actually have any gems you're a 'contributor' on where you dont **just** merge pull requests? I've wanted to say this for a while but you write blog posts about how many gems you're involved with, how busy you are in open source, but you don't actually do shit, you just have your name on the readme and just sit there merging pull requests. Do you even write code? have you ever written code? Or are you just good at self-promotion? I think you're a fraud. lol i think i've even seen projects where your *only* commit (aside from merge commits) was adding yourself to the Readme as a collaborator....
Yep they are. But they're also tired of tip-toey, "safe space" extremist PC bullshit from assholes like you. Hopefully the coders of the future find a happy place between our two extremes.
At first I just wanted to say "lol", but..... So, the first thing that I object to is the notion that only writing code directly is "real work". Actual, real open source has much, much more to do than just code. Different people are good at different things; I actually enjoy doing a lot of this kind of managerial stuff, and think I'm fairly good at it. Doing this kind of work can be a multiplier for those who _do_ want to just buckle down and write code; they no longer have to manage all of this other stuff, because you're getting it out of their way. Secondly, reviewing PRs _is_ work, and coding work. It's not like you just click the merge button; you have to understand what's going on before you do so. Every new line in a repository is a line you're gonna end up having to maintain, so if you just merge crap, well, your gems are going to end up being crap. Third, you are really focused on _volume_ here, but it's not always about volume. For example, the most popular gem of mine I wrote myself is `request_store`, and it currently has 5MM downloads all on its own. It's like 40 lines of code. I wrote it at like 4am one night when I was jetlagged in a hotel room, and I wrote it to fix a bug in Draper, but then realized that the bug was something that other gems had too, and so extracted it out to help other people. It doesn't have a lot of activity because it's small and focused, yet it's used by a _lot_ of people. Knowing the _right_ kinds of work to do is just as important as churning out tons of code. A lot of people in open source end up in positions like mine. What happens is, you start a project, people find it useful and join on, but since you're the original author, it's your vision, so you end up making these high-level decisions, but there are more people than just you doing the work, so eventually, your code % ends up being less in the end, because you're competing against a team of people. An example of this is Linus with Linux: he writes very little code these days, but that's because he spends all day reviewing pull requests. By your measure, if I don't do anything in open source, neither does Linus. Finally, it's very true that I haven't been doing a lot of work in the Ruby gem space lately. This is because I haven't actually had a job in ruby for almost three years at this point; any Ruby work I do is purely because I love Ruby. &gt; I think you're a fraud. Cool story. I gotta run though, because, well, I have work to do.
What would be the use of this, in practice?
Well...that was embarrassing. 
Is Google running a marketing campaign? Up until now, I hadn't heard anything of Ruby/Rails' apparent demise, yet this week I've seen 3 posts about it.
[removed]
I do agree many "rails way" are not very suitable for large applications like helpers. Luckily we still got many Ruby lovers producing useful gems. :) e.g. cells
Maybe updating some custom attributes that does NOT require cache expiration? def cached_random_child_id Rails.cache.fetch(cache_key(:children_updated_at)) do children.ids.sample end end Feel free to fix my crap example
Hi there. I just wanted to chime in on this. I'm a Rails committer with over 1000 commits at this point, and I'm pretty sure I pass your bullshit test for what qualifies as contributing to open source. I just wanted to let you know that you clearly don't understand what maintaining open source is about. Steve's work is absurdly important, and well appreciated by everyone involved with every project he works on. TL;DR: Go fuck yourself with a wooden spoon.
Thanks for sharing your thoughts, Jeff :) This is an understandable point of view and I'll work hard to develop some material that can perhaps change your mind. In the meantime, some initial thoughts: I'm not sure I'd classify dry-component as magical: it behaves according to a clear set of rules, and entirely deterministically. For example, unlike Rails' autoloading, it doesn't go anywhere near const_missing. It just crawls some user-specified directories and sets up matching container registrations. Each source file will still declare its own `require` statements up top, and any auto-injected dependencies will have require exactly whatever they need to work, and so on. I purposefully only covered one feature of dry-component, just to keep with the theme of the article. I hope to cover some more of its helpful features later on. For example, when you're testing, you can boot up a dry-component _completely empty_, and as you request individual objects within the container, their specific requirements - and no more - are loaded for you. This means that you only ever get exactly what you need for the fastest running test. The focus of my article was about making this technique work at scale, and for that to happen, sometimes we do need to have _systems_ to "move the levers" for us. But what we should expect is for those systems to be understandable and fully user-controllable, which I think dry-component offers. Would love to hear if you have any thoughts on how it could become more palatable for you!
To allow the head to remain buried in the sand about the impracticality of Russian Doll caching.
&gt; A small module that's reused a lot is a small cost for big utility. Like `left-pad`? Nice one.
chruby &gt; rbenv
Thanks! I debated between 30 and 60. As the saying goes 76% of numbers and statistics are made up on the spot (yesterday it was 63). I want to make sprockets easier to work on. But it will take time. I appreciate the PRs to any OSS projects. 
Good question. Clearly it's buggy. Paperclip has been a bit unmaintained for a bit, hopefully that's changing. One thing paperclip did some time ago that was the _right_ thing to do was make content-type validation mandatory. If you really don't want it, you can opt-out of it, but you have to actually opt out with explicit code. Otherwise if you don't have content-type validation configured, you get an exception. That was the right thing to do. (Apparent bugs in the validation notwithstanding). If shrine makes content-type validation only an optional plugin, then I guarantee most users aren't doing it, just like most paperclip users probably weren't before it was mandatory/opt out. 
Even 60 is probably optimistic for me. Maybe i just run into the especially tricky bugs (but isn't that mostly what's left in relatively popular codebases). And especially if I'm not previously familiar with the codebase. Or if the codebase is... difficult (as you and anyone who's taken a try knows is true of Sprockets, for example). Or if it's not even clear how to get the tests to run green on a clean checkout (an important bullet point missing from your slides -- make sure there are instructions for getting tests to go green, even if that's just `rake`. Among other things it allows someone to file a bug report if `rake` on a clean checkout _doesn't_ go green, knowing that it's clearly a bug since it conflicts with the doc, instead of them just wondering if they hadn't figured out how to 'correctly' run the tests according to some undocumented process). Anyhow, the exact numbers are just numbers, and will obviously be different for different projects, developers, and bugs. But why it matters is I think you're under-estimating how challenging and time consuming it is to make contributions like this. Still, I agree, there's nothing to it but to try to do it, and I appreciate your focus in the latter part on setting up projects that are easy to contribute to -- and I think you identify the right things to do there. But that's time consuming for the maintainers too, who already undoubtedly feel time-pressed and on the edge of burnout. But there's nothing to do except try on both ends, and I do appreciate your optimism and positivity that I have trouble maintaining sometimes these days. :) Oh and I'd supplement your suggestion to provide a repro app, with the suggestion to contribute a failing test case. Depending on the project and bug, a failing test case can be easier or harder to come up with than an independent repro app. But it can be even more valuable. If it's even easier to contribute a failing test case than a repro app, do that! For that matter, as a non-maintainer contributor on a project, if/when I can start with someone elses failing test case, it makes it even easier for me to try and contribute a bugfix. A maintainer could even leave a failing test case for a bug they haven't had time to fix, for someone else to contribute the fix. (Unfortunately, github workflow doesn't make it that easy to contribute or make available a failing test case in a useful and not confusing way). 
Obvious troll is obvious. Yawn. You're a fake and that insult doesn't even make sense. Nice try, thanks for playing, better luck next time. 
Everybody should know that this is the wrong way to do it. A professional Ruby programmer would always prefer `ap` (awesome_print) to get better structured output.
I am also a puts/pp debugger but I've recently discovered the magics of byebug
StackOverflow job adds are a pretty great way to reach out to devs. [This](http://stackoverflow.com/jobs/93566/work-on-our-awesome-product-as-a-mobile-engineer-intercom?med=clc&amp;ref=large-sidebar-blue-nearyou) is a pretty good job add. It covers: - why the job is interesting - what you want devs to solve for you - the skillset you are after - information about the company - and (very importantly!) the Joel Test score tells me what kind of software culture you have in place
&gt; I am too lazy to find the PR for this change Here is the github commit for adding `touch` to the `#save` method: https://github.com/rails/rails/commit/e780e2fda326fa5ea616e1441a6ed81b2890085c And here is the associated issue/discussion: https://github.com/rails/rails/issues/18202 As you can see, it was actually implemented way back in 2014, but was targeted at the Rails 5 release.
So this would be like Heroku on Google infrastructure?
Coming from you that's high praise for chruby. I'll have to take a look at it. 
Well in his defense he's clearly not at your level. I think he'll get there someday but give the man time.
 I think I may be the only Rails guy left that still uses MySQL. Well MariaDB but nearly same thing. I use what I'm comfortable with and haven't had a need to make the switch. 
One use I can think of is a user updating their password. I'm obviously not displaying passwords when I show profiles so the cache should remain intact, but currently when any field is updated, the record is marked changed and the cache destroyed. This seems like a way to solve that. 
Not entirely. You should definitely do your research on the differences before choosing one over the other. Edit: anyone care to comment on why I'm getting downvoted? Has something changed in App Engine?
I am planning to make an improved version
I think a simple site detailing best practices would be useful. Things like why callbacks are frowned upon, alternatives, etc. With the array of tools we have at our disposal it would be nice to have a quick reference for pro's and cons of both tools and techniques. Editors: RubyMine et all, Atom (possibly) most popular. Authentication: Devise most popular. And so on. Even for experienced devs sometimes you don't have the time to research and compare five gems and just want to know a summary of differences and what's popular. Not that popularity equals quality but all things being equal, what's popular is usually popular for a reason. 
Who isn't? Even in java, where I can remote debug a machine and do all kind of cool stuff while it is running, I still use System.out.println for the small quick and dirty tests.
Only if you catch it. :D 
solutions finded seem not the best ; see comment on 945 target...
The Thoughtbot folks are unreliable clowns who produce highly questionable software.
I usually find that "service objects" are a bandaid over poor OOP design in the first place. If you simply opt for creating small, well-contained objects, break out logical groupings of per-object behavior into concerns (aka mixins), and make good use of namespaces (not Services::BlahBlah but Mailboxes::Message or Transactions::CreditCard or something like that), you can organize your code in such a way that you almost never need to stick random functions (let's be clear, that's what these are) into "service objects". Years ago I left PHP behind and embraced Ruby precisely because Ruby is a fully OO language. I don't want to go back to wading through a random collection of functions!
Give it a shot, hit me up on twitter with questions. It is much simpler than all the others, but that simplicity gives you flexibility. It might not be right for everyone. Often when someone complains to me about a problem with another version manager a switch to chruby was able to fix the issue.
Basecamp i.e. the company that made Rails still uses mysql/MariaDB. They would prefer for it to be on postgres but the transition costs aren't worth the benifit. I think there's quite a few people in that boat. When Rails first came out mysql was the dominant force. It was the default database before being replaced by sqlite3.
&gt; “The best measure of a man isn't his code quality or product produced. It's the debugger he uses.”
Thanks so much for the examples, and I think that's super helpful. I didn't know much about Joel Test - forwarded onto a tech lead now fo us to start using wherever we can. What is the thing you care about MOST when looking for a new job? If we made the job spec really long and detailed, or succinct and to the point (as per the 5 points above)... we're running two tests of identical roles, with one short job ad and one long job ad at the moment, both just advertised on Twitter, to gauge responses... so I'll have some kind of data point soon. Do you think that is the only thing we should change/test?
Thanks heaps - I know Stack jobs well... Its good to hear you use it/trust it. It's pretty expensive for companies, but if it's worth it and respected we'll absolutely take a crack.
This is overengineered, java-scented junk.
&gt; break out logical groupings of per-object behavior into concerns (aka mixins) Remember that little old nugget of good OOD 'favor composition over inheritance'? Far too often I see concerns/mixins used as the rug under which to sweep the garbage code (and very seldom stemming from actual 'design). &gt; I don't want to go back to wading through a random collection of functions! There's nothing to prevent services being instantiated as a part of (or injected into) a class, and a class being composed in part of those services. Far less than random, and usually easy to test and work with. 
Ruby is built into the raspberry pi which has a full operating system and is a bonafide computer (with usb input and wifi connectivity), the arduino is just a microcontroller where you upload 1 program and that controls everything. I am not sure you can code the arduino in ruby. The Pi will be much more flexible approach and experience building a ruby app on the Pi will transfer to other domains better than the Arduino. A benefit of the pi is that it can drive a hdmi monitor and take keyboard input. I am currently using rails(a ruby web framework) on the pi to serve as local rails app with an easily customizable Gui (html/javascript in browser). If your interested I can share my setup. Also provide a little detail on what you want the computer to dictate and how will it connect to the cnc machine? 
Thanks for the quick and helpful reply! The machine essentially should work like this: User inputs x and y coordinants, and then sprays selected area with an airbrush. A simple example would be...X1 = 0, X2 = 10, Y1=0, Y2=10, and then the machine would spray a square. 
[That blog post](https://cuttingedge.it/blogs/steven/pivot/entry.php?id=91) shows a few things which can be implemented using the chain of responsibility. The author goes a step further and also separates commands from command handlers, but the same concept applies if you keep them coupled. You just need to be aware of the different arities of your call methods.
You can use Ruby with arduino by using the serial port and the SerialPort gem http://playground.arduino.cc/Interfacing/Ruby, also check out http://artoo.io/
[I did my best to follow what was said](http://imgur.com/BSgaGB6), but.... I don't know, maybe I am just not smart.... sorry &gt;~&lt; 
&gt; If you're comfortable with me sharing our posts, I can DM - I don't want this to come across as another ad because it's genuinely not. I know the majority of the users here would be out of our (currently) limited geographic boundaries anyway, and I am much more interested in your opinion as a professional than a job seeker. I'll send some stuff to anyone who is keen to help me out though! EDIT: Quote because I accidentally posted as a new comment rather than replying, I've deleted the new comment now (new Reddit phone app is confusing late at night) 
Based on the down votes, it seems as though my use of a debugger is the unpopular opinion. Regardless, I still believe that proper use of a real debugger is a skill that every software engineer should know. Object can't always be well represented by a string output. My setup with pry is: * [pry](https://github.com/pry/pry) * [pry-rails](https://github.com/rweng/pry-rails) * [pry-nav](https://github.com/nixme/pry-nav), [pry-debugger](https://github.com/nixme/pry-debugger), or [pry-byebug](https://github.com/deivid-rodriguez/pry-byebug) depending on the version of Ruby that I am using. Although, I tend to find that pry-nav works quite well across all current versions. * [pry-doc](https://github.com/pry/pry-doc) * [pry-stack_explorer](https://github.com/pry/pry-stack_explorer) * [pry-rescue](https://github.com/ConradIrwin/pry-rescue) By itself, pry is a great irb replacement. It also allows you to set breakpoints in your code. You can then gather basically any information that you can think of about an object. Using cd, you can step into an object. Then use ls to view all methods and variables that are defined on that object. You can also view, edit, and reload code that you are working on while staying in a break point. show-source will show you the source code of a method or an object. This is where pry-doc helps out because it will help give you more access to Ruby's source written in C. If you set a break point and run your code, pry-nav, pry-debugger, and pry-byebug give you the normal debugger commands to navigate through live code using step, next, and continue. You can sometimes know where to place a break point, but you may not necessarily know how you got there. As Aaron Patterson said, Ruby has a method called caller that will show you the call stack. To take this a step further, pry-stack_explorer has the method show-stack. It will give you a more detailed version of caller. It will also allow you to navigate up and down the live call stack. Going up the call stack allows you to see exactly what the state of an object was before it got to you. pry-rescue works great if you encounter an exception, but don't necessarily know where it came from or why it happened. If an exception is encountered while using pry-rescue, it will automatically open up a pry debug session where the error was encountered. Combined with the previous tools, you can execute and play around with actual code and object that caused the issue. If you have any other questions about pry, I will gladly answer them to the best of my ability.
I'll take a look, thanks for the input!
I think you're almost where you need to be. The "cannot find the path specified" error suggests that bundler (the gem which provides the "bundle" command) might not be installed. To get that, you need to "gem install bundler". Do you have a Gemfile alongside your ruby script? If yes, make sure you're in the directory that contains your .rb file before you run the ocra command.
This is a bad pattern. You're instantiating an object that needs no state just to call it.
Thanks for taking the time to read my article :) We've been finding that this is actually pretty light-weight in practice, and has helped us ship a number of apps that feel more solid than anything we've done before with a typical Rails approach. We've also had beginners to this approach get up and running pretty quickly, too. If you have any particular concerns about these patterns and the way they encourage better design, I'd be happy to talk things through. Let me know!
Piotr considers that the Active Record pattern in general doesn't scale well, that's why he created [ROM](https://github.com/rom-rb/rom). I personally (still) like the Active Record pattern, but I don't use ActiveRecord not because it's bad, but because it's just a handicapped version of [Sequel](https://github.com/jeremyevans/sequel).
While I'm not necessarily saying that this is Sprockets or Rails, I just want to point out that an open-source project lacking progress is not always because "there simply isn't enough contributors". Sometimes software starts lacking development because it's simply "not it" (like in relationships), and the maintainers feel it and don't feel motivated to contribute that much anymore. There is a reason why some Rails contributors run away from ActiveRecord (e.g. Steve Klabnik, who told me that at one conference, looking very relieved), while developers like Piotr Solnica and Jeremy Evans continue actively developing ROM and Sequel even after so many years (ROM development started with DataMapper). I just think we're all completely discarding the possibility that the Rails ecosystem may not "be it" (and that people may feel it subconsciously), because Rails has been with us since forever. And then we're making fun of how JavaScript frameworks are changing more frequently than our underwear, but at least they're open to change and searching for the best tool.
Thank you for being thorough and detailed.
You can always procify the module/class method at call site when you inject it into the thing which will eventually "call" it.
Very cool.
Thanks for sharing! This is an awesome list and will help me a lot as I am just getting into Ruby. 
EventMachine is not designed for what you have in mind. Search for Drb or Distributed Ruby. It provides a high level abstraction for distributed computing. If i remember, there is also a book on it from pragmatic, i think.
He's just a troll Tim, check his comment history
Take a look at File.dirname, File.basename and File.join. 
Which is a bad pattern, mine, the one from the article, or both? Doesn't it do almost exactly the same thing as the `Services::Base` module from the article?
I am going to give you two types of suggestions: **Programming practice** - https://projecteuler.net/ - http://www.codewars.com/ **Practice projects** - Build a blogging site - Include: Polymorphic associations, form validation, unobtrusive js, and specs for code coverage (TDD in mind) - Build a book catalog - Include: single table inheritance for fiction and non-fiction. Include simple authentication using sessions. 
yeah I'd just give a one-column excel file (array?) and the output would be populated by information made available from search results
Huh, I had no idea this existed, and could have made use of it several times in the past! 
Right, that's what I'm looking for. Thank you for so much detail. Last year's website is no longer available. It looks like the website is all database driven, and we would be giving a list of the precise words to use (we'll supply in any different versions of the search terms, e.g. with and without spaces for drug compounds, in the excel file) For the accepted sample, a lot of this 3 - 20 hour allocation is not hands-on work right? It should be mostly automated? Thanks!
An additional tip: build something that you, yourself, need and use. That makes it fun to maintain and nice to build. 
This may sound stupid, but how do I use/test my gem using IRB? I'm going to try making a weather gem that takes a zip, reaches out (somehow), grabs the current weather info, and based on key words, returns the current weather. I built the zip code grabber, and I want to test it. soo.. how do i ? 
yeah you have to enable the toolbar via the keyboard shortcut CTRL+SHIFT+ ALT+M edit: i broke english
Sprockets is more than Rails. I've used it with Sinatra, for instance. The asset pipeline provides a very much needed feature and can't simply go away, because I don't see a substitute in the horizon. Should it integrate with babel/commonjs/webpack? probably. Should it be faster? hell yeah. But I really don't know how other envs (go/rust/django, the ones that come to my mind) solved the asset bundling issue. http2 support is coming for all of us, and I assume sprockets will play a role in "signalizing" assets for server push. 
&gt; For the accepted sample, a lot of this 3 - 20 hour allocation is not hands-on work right? It should be mostly automated? Depends on the case. Sometimes it is just "run script and wait", sometimes it is like "check in a 30 minutes, fix incompatibility with THAT seciton tickets, check in a 20 minutes, fix behavior for presentation with two abstracts, check in 10 minutes, fix filename for some German letter in presentation address, ...." and so on. I suppose, honest developer would say it (how many time he really worked, and how many was just watching Game of Thrones wating), but with fixed pre-specified payment personally I prefer most pessimistic estimation ("everythin would break up and create problems").
I never meant to imply it wasn't a needed feature, or could go away. Just that it was kind of a mess. Even by Rails standards. If you look at the sprockets codebase, and how it integrates with Rails (or Sinatra, whatever), you will probably increase your estimation of the challenge of getting sprockets to "play a role in 'signalizing' assets for server push". I'm not sure how sprockets could do that. 
What's wrong with SecureRandom, that it needs to be replaced?
This doesn't replace SecureRandom, it simply enhances it to acquire random bytes from getrandom(2) or its equivalent instead of OpenSSL. As to the why: it's been an ongoing discussion in the community for the past few weeks. Here are some links if you care to read more about it: Ruby bug: https://bugs.ruby-lang.org/issues/9569 HN thread about Ruby bug: https://news.ycombinator.com/item?id=11624890 /r/ruby thread about Ruby bug: https://www.reddit.com/r/ruby/comments/4htjow/ruby_bug_securerandom_should_try_devurandom_first/?ref=search_posts /r/ruby thread about RbNaCl: https://www.reddit.com/r/ruby/comments/4i3bp3/if_youd_like_to_use_devurandom_or_a_windows/?ref=search_posts 
Ha, have you ever done this kind of thing before? In my experience, the text is _never_ "formatted in a regular [enough] matter [to make it] a reasonably easy job". 
He's not talking about your excel file, he's talking about trying to get the abstracts out of the web site. 
I'm new to contracting, and not great at estimating, although experienced at doing this sort of thing when I worked for an 'enterprise'. I can tell you from my experience your friend who said he could do it in "a few hours" was grossly under-estimating how long it will take. I mean, all software estimates by people who don't have experience doing software estimates (even if they have experience doing software) grossly under-estimate. Because there's always little things you didn't expect. Especially in an 'integration' project, which this kind of is -- integration with the conference website. (Clearly, the conference should be providing a searchable schedule themselves!) Anyway. If it took you 200 billable hours last year, then assuming a software contractor doesn't bill too much more than you, if it only takes them 100, it's a bargain! Except somehow you don't have 200 hours this year, you only have... 36 on the clock! I dunno. It probably wouldn't take 100 hours. It make take 10-30. I just made that number up. $100 an hour for a developer who knows what they're doing is pretty cheap. $3000 is in the ballpark of what you're talking about, although more. Depending on what you bill (and your client was willing to pay!) for doing it manually, it very well may be more cost effective to just do it manually. If you billed (and your client was willing to pay for!) 200 hours at $20, that's $4000 -- doing with the software is 'riskier', it's harder to predict in advance how long it will take (and if whoever you hire is going to be any good), and a reliable you know you can do it in $4000 is better than you might be able to do it in $2000. On the other hand, if you billed 200 hours at $100, then you billed $20K, and even if you pay $10K for a software contractor you've cut costs 50%! Oh, but you don't have 200 hours, you somehow only have 36, without taking breaks to sleep or eat! I dunno! 
Good stuff. Thanks for the pointer to DrB!
Oh my gosh THANK YOU!
Yeah a 36 hour turn around time is going to get a rushed hack job for sure. That's a day and a half and no legit contractor is going to do that. I typically bill around $150/hr depending on the client. I'd ball park a decent product to be somewhere around 25-30 hours between talking to the client, architecting the software, coding it out, testing, and getting it back to the client. It might take even more if the site has some counter-scraping stuff in place or something else that makes life difficult. I'd budget around $4k for the job and be prepared to fork over more if the site in question has anything that makes life for the consultant miserable. Consulting isn't a game where you get $500 prizes here and there. It's billed in hours and you pay the consultant accordingly. It's okay to have a budget but be prepared to go back to the well to compensate your consultant fairly.
After opening connection you need to subscribe to a specific channel first. id = { channel: 'TestChannel' }.to_json cmd = { command: 'subscribe', identifier: id }.to_json socket.send(cmd)
A related pattern I use a lot: def some_iterable_thing return enum_for(:some_iterable_thing) unless block_given? # contrived example @items.each { |i| yield i } end `enum_for` will create an `Enumerable` out of any method that calls `yield` for you. 
I created Pry (and many of its plugins) -- and i learned a trick or two from tenderlove's post. I don't think less of him for not using a debugger, it actually impresses me more that he's accomplished so much without the aid of one. He's legit 
after much much hacking, i ended up figuring it out, and it was this precisely :) however the problem now lies with Actioncable.server.connections returning always []. I can't broadcast anything. I'm using rails 5 so maybe there's some weirdness happening. Either way after like 4 hours of cluelessness, I'm just going to use Pusher and stay away from this.
Yo can just use `enum_for(__method__)`
Use [Padrino](http://padrinorb.com/) instead. No Asset Pipeline, no Spring, no binstubs, ActiveRecord and CoffeeScript are optional, simple test structure, multiple sub-apps, and Rack based. However, there is no magic framework that replace understanding dynamic typing, meta-programming, OOP design, and ultimately their limitations.
Yes, exactly what you said that happens for you. I think if a codebase is large but the project still solves the problem great, it can usually be refactored to improve the situation and raise the motivation. But once you start feeling that you mind some of the core design decisions, that's IMO where the motivation can drop.
Very nice use case for Enumerators, you did a good job at justifying the switch to Enumerators. I love Enumerators as well.