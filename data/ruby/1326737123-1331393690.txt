Any plans on doing both? Github repos can go away easier than gems can, honestly.
Good point. There's nothing stopping a gem from working in Vesper, but I don't have a standard way of using them as plugins. I'll look into it.
Sigh. Rails finally removes its plugin arch after years of unnecesasry complexity and walled-garden syndrome and here you go creating another one. &amp;#3232;\_&amp;#3232;
Yeah totally agree. Cracking by brute force shouldn't be considered as cracking.
I really enjoy rolling my own from the ground up in sinatra (particularly Padrino) but one thing you must keep in mind, is that many gems are written with a rails-centric world view and there are going to be some cases where things which should "just work", don't. This means you have to either find a work-around (eg. bring in or emulate some Rails components) or dive into the source of the gem and make your own Sinatra-compatible version. This takes a lot of time, but it can be pretty fun. So, yeah. Horses for courses.
Its gem database [has been out of date since November 2011](http://help.ruby-toolbox.com/discussions/problems/14-cannot-suggest-testr-gem) so newer projects cannot be added to The Toolbox. So take its suggestions with due consideration, for they're a bit stale, like *Yesterday's Jam*. :(
Far easier to use rvm.
And for those of us who won't give up on mouse, there's [guard](https://github.com/guard). Install the core, install extensions for your test frameworks, enjoy. But either way, even if your project is huge, [it can be made faster still](https://github.com/sporkrb/spork).
Apples and oranges.
My feelings exactly. I'm having a lot of fun with Sinatra and I feel like it's making me a better ruby developer, because there's not so much of a reliance on Rails 'magic' - not that this doesn't have its place. Ruby is such a succinct language that writing more code doesn't automatically mean messy, fragmented, or out of control. I like being able to see more of what's "under the hood" so to speak.
I think it was on twitter recently, but I agree with and like this quote: "Every time I try to wrote a Sinatra app I end up re-writing half of Rails". I agree. Rails has everything in it, Sinatra is too slimmed down. I'd rather sacrifice a bit of overhead for convenience.
If you want to get one version of Ruby and keep it at that version, rvm is easier. If you want to keep multiple versions of Ruby, rvm is easier. If you want a newer build of Ruy that hasn't been packaged for apt yet, rvm is easier. OP's question falls under the first and third categories. 
It was @steveklabnik in [this tweet](https://twitter.com/#!/steveklabnik/status/141338070631981056): &gt; Every time I use Sinatra, I end up building half of Rails. And I think he was being (partly) tongue-in-cheek and (partly) thinking of his experience with [Rstat.us](http://rstat.us), which started life as a Sinatra app and moved to Rails.
I agree with both parts! I thought it was either Steve or Evan Phoenix.
One problem with an approach like that is, if you ever wanted to extract out some of the code used to generate the hash (to make it drier, or to have complex logic in its own method), there's no clear place to put it. But if you have a presenter object, then you can add whatever methods you need to that class. So it'll be easier to keep your code clean and readable.
Did you happen to run across this? https://github.com/binarylogic/authlogic/issues/52 Old issue from 2009. You could try turning off the session maintenance to get it to stop logging in during the tests.
Thanks for sharing this, I'm delving into Ruby now and this was my next stop. 
I haven't used Rails in a while. I should check it out again. I've been using DataMapper with Sinatra. 
If im honest I don't like RSpec :(. I'm still using the default combined with FactoryGirl to avoid fixtures.
I don't think it includes default email verification and such. You would have to build that yourself but that's a large reason why I prefer Sorcery.
I'd like something in between the two. Rails is bloated with crap I would never use even if I needed the functionality, whereas Sinatra is a bit too bare-bones.
No longer true that they're not friends. The Debian Ruby maintainers are [working on migrating to a workable packaging methodology](http://www.lucas-nussbaum.net/blog/?p=708) so that they can ship a full working Ruby 1.9 and have a way to switch between 1.8 and 1.9.
And for the "a little too big for sinatra but too small for rails" there's [Padrino](http://padrinorb.com). Sinatra is awesome for tiny apps.
Fair enough. I haven't had time to check them out, but I'd have no experience switching if it has the functionality I need. I've done it before: bash-&gt;zsh, GNU screen-&gt;tmux, ion3-&gt;XMonad, etc. 
Here's a mental model which works for me to understand the difference, without having to know about internal hidden singleton classes. Might not be entirely correct, but works for me: * `extend` will add the module methods onto the actual object the message is sent to * In a typical class definition, `self` is the Class itself, this is why `extend` ends up making the methods in the Module class methods, not instance methods * in an instance scenario, `something.extend Foo`, you're sending the `extend` to a particular instance, `something`, and that's why you add those methods onto only that particular instance. * `include`, however, is in fact the weird one special one * it can only be sent to a Class, not to anything else * and instead of adding the Module methods onto the Class itself, it will tell the Class to add them onto to any instances of the Class created. Now, I may have just said the same thing as the OP, but with more hand-waving black-box, and perhaps slightly less accuracy. But for me, and the way I approach programming and think about OO, this mental model lets me understand when to use #extend and when to use #include, without actually having to know anything about the hidden "singleton" meta-classes, which I honestly consider an implementation detail that I don't want to have to understand. 
Well, if you just use Rails but *don't use* those parts of Rails you would never use, even if you needed the functionality, don't you already have that? Rails 3.x is pretty good at not insisting you use anything, even if it's default. You can almost always turn it off or just not use it, and use some other third party gem for that problem space instead. 
I dont' know what you mean, you can quite happily "extend Ruby with C" without wrapping a 3rd party library, for example: https://github.com/banister/binding_of_caller
i often fork from a custom boilerplate i've prepared for my usual needs when starting a new project, then the setup time is neglectable. here's what i usually use: https://github.com/carlhoerberg/sinatra-boilerplate
I thinks Sinatra is awesome for big apps as well, we have used it for &gt;8000 LOC projects.. 
This is not insanity wolf. Please stop.
how does MRO (method resolution order) fit into your mental model? For example: class A def a() puts "from A" end end a = A.new module M def a() puts "from M"; super; end end def a.a(); puts "from a"; super; end a.extend M a.a output is: from a from M from A In order to understand how MRO works in that example (and how the `super` keyword can make sense in that context) you need to understand that in some sense the method `a.a` is being defined on a subclass of `A` and that the module `M` is in some sense being inserted in a `class` between those two. At least to make sense of it, that's what I have to do. what about you?
Ha! I'll be careful. I haven't used it extensively either but I like the basics of how it is set up. I do have concerns about extended functionality and handling more complex requirements than simple index listing of select columns and so forth. 
Why can't you extract it as a separate map presenter ?
you can use class and define `#to_proc` in order to use it same way. There are definitely some benefits of having builder, but I think this concept combining with some DSL sause can turn into smth very nice.
I'll check it out, thank you. 
apt is easier to upgrade your ruby and it is easier to maintain the server using a tool like puppet or chef.
Ruby core devs are notoriously bad at maintaining backwards compatibility and avoiding breaking random things with new point releases (and even patchlevels). It's often best to have strict control with which exact Ruby version you use for each application. RVM (or similar) makes it easy to switch between Ruby versions, and to keep multiple installations side by side. That way, you can test your app with the new Ruby and avoid spurious server updates that break your app.
Nice...and thanks for sharing!
but, in that code example, a module is being extended onto the `a` instance, yet it is called AFTER the method defined on `a` (using `def a.a`). So how can the module (that is extended) have its methods defined on `a` if it it's being called after the `def a.a` method?
Sounds to me like you just made a case against using ruby in the first place. 
Sure, it's a pretty big item on the "cons" list, but there are some pretty big items on the "pros" list as well. :-)
I haven't started playing this yet, so I do not know if it is any good yet, but way to go! This idea is great and should of been implemented long ago. These blockbuster games need to stop worrying about stopping bots and start encouraging them. How about seeing some robot wars that are totally virtual.
Yes, but I'm not a fan of huge frameworks. When I see a list of 20+ dependencies, I start to get very wary.
Why? Real question. If the thing has a lot of dependencies, but 90% of the code won't be used unless you write code to use it (or can be made to be not used by config turning off defaults).... what's to worry about regarding code that will be included as dependencies, but not actually used? But I guess what there is to worry about is you can't be _sure_ what code will be used or not. If there were no dependencies and the framework is only x lines, you only have that x lines to look at, ever, in debugging etc. Which is nice. Is that what you're thinking? Nonetheless.... it is difficult to do what you ask for. Everybody's got a different 'in between' sweet spot. Effectively you have to go either * the Sinatra approach (don't include hardly anything as a dependency, but *try* to make it easy to add features with just-works plugins; this is harder than it seems, and you can end up spending a lot of time debugging plugin interactions), * or the Rails 3.x approach (include a hell of a lot as supported and tested and maintained features, meaning a lot of code whether split in dependencies (better) or monolithic; but *try* to make it easy to turn off or swap out what you don't want; this too is hard to do well, and you can end up with, well, all the downsides we know about Rails). I'm not sure whether trying to make a framework with a 'medium' amount of features would actually satisfy anyone, or just be the worst of both worlds, inevitably having a bunch of stuff that you don't need, and also lacking a bunch of stuff you do, for any particular use case, cause everybody's different. But **Padrino** built on top of Sinatra seems perhaps an attempt to do what you ask for, have you checked that out? (I have not really myself)
Thanks for trying out :). I cannot reproduce this (on the macbook of a workmate). Anyone else is having this problem? Which Ruby version do you use?
Datamapper rocks.
It isn't immediately clear how this is different than how guard (with guard-rspec, for example) works. Can you enlighten me?
ha, thanks. I've thought about it, but haven't found anything that I love enough to indelibly imprint it onto my husk. :p
Done w/ [Gem::Specification#post_install_message](http://guides.rubygems.org/specification-reference/#post_install_message)
http://wmii.suckless.org/
But why? Why not chose the best and what suits you best instead of just whatever scripting language the given desktop environment has chosen to customize with.
What better way to learn a language then to fully immerse yourself in it?
There's a right place for everything. Just because you want to learn Ruby there's no need to run a desktop made in Ruby on an OS made in Ruby. You can just as well run the best OS with the best desktop environment and then code in Ruby.
Hmmm... couldn't the security of this password manager be easily circumvented with a "clipboard history" program?
Already said, but [subtle](http://subtle.subforge.org) is what you're looking for. Its configuration file is written entirely in Ruby, and it has a concept of "sublets', which can be thought of applets that run in the panel of the window manager, they're programmable(in Ruby) and can receive events to perform actions. sublets share the same thread as WM itself, so it is important to not block in your sublets or you will freeze the WM itself. This is a huge downside. I used it for 1-2 years before buying a Mac. 
I know - I understood that much. I was just making my point with a little exaggeration
You certainly can.
why ask why when that has nothing to do with the actual question at hand.
I remember reading about this when I was reviewing tiling managers. wmii has bindings for a number of languages, including ruby.
ah, good call. 
[the 3.2 release notes](http://guides.rubyonrails.org/3_2_release_notes.html)
Thanks for the pointer, maybe I've been too simplistic using Marshal. I'll keep that in mind and will update to another format sometime (while staying backward compatible).
I like Ruby the Hard Way: http://ruby.learncodethehardway.org/book/ It has some good exercises. Just skip stuff you've already done in the book. I use the 1.9 pickaxe as a reference when I need it. This slideshow covers 1.8 vs 1.9 differences. I'd go through it later on when you understand the differences. http://slideshow.rubyforge.org/ruby19.html#1 If you want to build a web app the easy way, I'd recommend using the Sinatra framework. It is easier than rails, and doesn't require nearly as much base knowledge. http://www.sinatrarb.com/ Learn rails later on when you are ready for it and if you are interested in it.
Ruby 1.9 isn't that far from 1.8, I use 1.9 and have the 1.8 book, they don't differ that much, but I would recommend you to use 1.9, since that's the future. Start with the Pickaxe (Programming Ruby ...) and then read http://rubybestpractices.com/ (It's a free book and helped me a lot to get to know the advanced concepts, e.g. how to effectively use blocks). I don't know what you exatly want to build, but have a look at Sinatra, it's a very lightweight framework for web apps and it's very beginner-friendly. Have fun with ruby!
I recommend "The Well Grounded Rubyist," from Manning Press. http://www.manning.com/black2/ It really fleshed out my understanding of the language and the runtime.
Check out my [Best way to learn Ruby &amp; Rails](http://astonj.com/tech/best-way-to-learn-ruby-rails/) post.
Read the rdoc in depth for the following 4 things: * String * Array * Hash * Enumerable That will take you a long, long way! All can be found in the core section at [http://ruby-doc.org/](http://ruby-doc.org/)
http://tryruby.org
+1 for The Hard Way as well. More of a general concept book than a ruby book is Clean Code: A Handbook of Agile Software Craftsmanship. This should be mandatory reading for all software people. Though the examples are in Java the concepts are applicable to any and all programming languages. It gets right to the guts of why one should write tests. Without them you fear refactoring since you don't know what side effects might occur. It's also one of those books that has more impact the longer you've been writing software because you're able to look at the various case studies and say "yup I've seen that".
damn, it works. http://img6.imagebanana.com/img/dk2cv4z0/Selection_005.png
To be honest, I've never really tried scraping before (or really looked into either Nokogiri or Mechanize) - and Nokogiri looked really cool. What makes Mechanize easier for scraping? I'll be sure to check it out, though.
It's pretty awesome how this works. Only problem I see, is when the first link is a citation, it doesn't like those. Try searching for: 'Free association'. Easily fixed I'm sure.
Nokogiri is a parser, while Mechanize is more closer to a full blown web browser. Mechanize makes things like traversing a website, clicking links, going back in history, etc dead simple. Mechanize also allows you to parse the webpages using Nokogiri. Mechanize is a dream for web scraping. This entire script could be written in maybe 5 lines of code.
I believe Mechanize caches all the pages by default, this impacts performance when crawling large sites.
A couple of people had mentioned before but the best of both worlds is actually Padrino, you get much of the Rails goodness like generators without sacrificing the flexibility that Sinatra gives you. I have used the 3 frameworks on different projects and I can tell that Padrino is the one that feels more comfortable and fits most of my projects; in the end they are tools and each developer has to choose the one that fits the project and his coding style. [CoderonCode.com](http://coderoncode.com/2012/01/20/Between-Rails-and-Sinatra.html)
This for example: UrlsPresenter = lambda do |base_url| { 'self' =&gt; "#{base_url}/me", 'gauges' =&gt; "#{base_url}/gauges", 'clients' =&gt; "#{base_url}/clients", } end UserPresenter = lambda do |user| { 'id' =&gt; user.id, 'email' =&gt; user.email, 'name' =&gt; user.name, 'first_name' =&gt; user.first_name, 'last_name' =&gt; user.last_name, 'urls' =&gt; UrlsPresenter[Gauges.api] } end
Www.ruby-kickstart.com. The videos and exercises were all I needed to get ruby. If you're a programmer, this is a very efficient approach. 
I'm interested in how similar your code is to [my code here](https://github.com/steveklabnik/maze_solver). At least, the procedural version.
I'm assuming you are talking about this version: https://github.com/steveklabnik/maze_solver/blob/procedural/maze.rb Where is the similarity? * He uses `open-uri` while you use `net/http`. * You extract the path using `//link` xpath to extract the link. His version use CSS selector over paragraph and then checking all the children for `A` tag. * Your maze solver saves visited links while his doesn't, his version doesn't handle loop in article links at all. For 70 LOCs program that request HTTP resource and then extract content for hrefs, I don't know how it can be more different than this. Or is it similar just because he defines some function first and then call it later in a while loop?
Definitely recommend RubyMonk if you have **NO** experience with basic code structures, primitives, types, etc. 
How did you do twitter::search.new Whenever I try to use that it throws an exception? 
&gt; Or is it similar just because he defines some function first and then call it later in a while loop? Yep. I meant structurally. I didn't really dig into his implementation, just read the methods, skimmed the code. &gt; I don't know how it can be more different than this. Probably not that much. However, as the OP says they've "never tried scraping before," I figured another example of code that's similar, but different might be helpful.
If you're going to be venturing into [Rails] (http://www.rubyonrails.org) at all, I highly recommend the tutorial at [ruby.railstutorial.org](http://ruby.railstutorial.org). I used it when I started learning Ruby (and, subsequently, Rails) in the middle of last year, and its foundation was super helpful in getting several web apps off the ground. It's very thorough, and it even walks through the very basics of installing ruby, rails, git, setting up github and heroku (if you want it), etc. Definitely a worthwhile look if you want to get into Rails. Good luck! I've enjoyed every minute of my Ruby journey so far, even the tear-your-hair-out ones. :)
If you really wanted to try all the articles, here are a couple of thoughts: - cache every article that eventually leads to Philosophy, then if a given page links to an article in the cache, it too eventually leads to Philosophy - Wikipedia used to (probably still does) make available an archive of all the articles for download. Then, you wouldn't have to deal with network latency, and whatnot. Sounds like a fun project!
http://hackety.com (blatant self-promotion)
awesome
I haven't heard back yet, but according to [this tweet](https://twitter.com/#!/LivingSocialU/status/160028587007807488), we'll know within the next two weeks or so.
Certainly try both before you buy. Sublime has an unlimited trial period. Personally I've never tried a "heavier" IDE for rails development (like rubymine). I get around just fine with a powerful text editor like Sublime along with terminal.
This is awesome man. thanks for all the hard work you've been doing on your patches. I'm installing this with RVM right now. I just recently start getting our app to work on Rails 3. It's an old old app, and its very large, like 200 models large. I really wanna try and get you some bench marks (since I think you will see alot of improvements with our large app). Any suggestions on how I should go about doing that? EDIT: ruby 1.9.3-p0$ time rails runner 'puts $LOADED_FEATURES.size' 1407 real 0m16.343s user 0m14.081s sys 0m1.264s ruby 1.9.3-p0-patched$ time rails runner 'puts $LOADED_FEATURES.size' 1408 real 0m13.385s user 0m12.041s sys 0m1.089s EDIT 2: More and Better Benchmarks Using this script, https://gist.github.com/1661178, I tested rails startup 10 times each for these 3 rubies user system total real 1.9.2-p290 0.000000 0.010000 316.000000 (321.433950) 1.9.3-p0 0.010000 0.010000 170.210000 (174.386164) 1.9.3-p0-patched 0.000000 0.010000 148.020000 (152.318101) so it looks like it shed 2.2 seconds off. 
is there a handy list that tells us which WMs are compatible with EWMH ?
If you have powerful computer (like latest Intel near 3GHz), than 2s is adequate startup improvement for `$LOADED_FEATURES.size == 1408`. I have AthlonX2 on 2.1GHz and 2s improvement is shown with `$LOADED_FEATURES.size == 1044`. Startup improvement depends only on $LOADED_FEATURES.size and $LOAD_PATH.size, it doesn't depend on startup logic complexity. And, since you test development mode, it doesn't load controllers and models. Could you test `RAILS_ENV=production time rails runner 'puts $".size'`? Could you also test application performance with `ab` or `siege`?
running that on a MacBook Air, 2.13 Intel Core 2 Duo. (SSD make a big difference?) I can test more on my iMac (non SSD, but higher processor) when I get back home. I don't mind to test these startups more with siege or ab (couldn't find a good link for that), but I wouldn't mind a good blog post to help me out with that. any suggestions?
&gt; I don't mind to test these startups more with siege or ab (couldn't find a good link for that) I meen, test application performance with `ab` or `siege`, not startup performance. [ab](http://httpd.apache.org/docs/2.2/programs/ab.html) [siege](http://www.joedog.org/index/siege-home) I use `siege` with something like this `siege -b -c 5 -t 15S http://localhost:3000/some/page`
Well, there is optimization of hash creation in the patch, so that it would be useful in production as well as in development.
I only read part-way through the patch. Most of what I saw was memory pool management, which I'd expect (without digging further) to affect long-running efficiency with lots of allocations and frees. I wouldn't expect that sort of thing to impact a "start-up and print something" code path by much.
Not sure why a "click" method really matter much in a screen scraper. 
Ah, thanks for pointing out the separate patches. Neat.
Thanks Sunshineq! 
so what's the chances of these things making it into the actual official MRI release, so we don't need to apply custom patches?
I love hackety, sorry I missed it. Another _why creation! He was my internet superhero for a long time, but you are very awesome as well Mr. Klabnik!
No worries! Thanks.
~~Why did you create a Markdown rendering library that's specifically tied to Redcarpet? I think using [Tilt](https://github.com/rtomayko/tilt#readme) would give users more flexibility.~~ Someone already submitted an [issue](https://github.com/steveklabnik/metadown/issues/1). Also why stop at Markdown? In the past I've needed to annotate Assembly source-files with a YAML header.
&gt; Also why stop at Markdown? Fill your immediate needs first, move on to bigger things later.
Hurray for this. spork + guard have been causing problems since day 1. Guards okay (love the modularity), but spork takes forever to load. I use rspec + cucumber, and factory_girl for mocks; anything I need to be aware of?
Also, please open a ticket on https://github.com/rubygems/rubygems/issues.
Dunno, as they're on GitHub as pull requests, which isn't really how you propose changes to Ruby. If they want them to get in, they'd do good to submit them on Redmine.
No. Too much logic in the controller. If you don't like this crap in the model, then introduce a new layer the model can use. Take information from the controller (current user or other access specific information) and pass it off. 
I thought it was now always backward and forward compatible?
tconsole preloads your Rails environment so that it doesn't have to reload between each test execution. It also gives you a nice clean set of commands for running specific test files and individual tests within those files to help out with tightening up the TDD loop.
I think it's safer to just go with the latest stable release. I started learning a few days back and I've already had problems with tutorials using the old rake command vs the new one to create a new project, some gem version incompatibilities, and even the setup tutorials were for different versions of rails/ruby/linux. If I'm going through all that, I might as well have the most up-to-date apps when I'm done.
As I understand it, 1.9 doesn't break much (if anything) from 1.8, but does add good things. Use it. [rvm](http://beginrescueend.com/) is your friend. It installs versions and switches between them easily.
Don't forget the fun of gemsets as well!
I've started with 1.9.2 Since I'm getting back into programming by learning Ruby I'm in a similar position to you. From what I can understand, the differences between the versions only seem to matter if you are trying to make the transition from one to the other.
Nothing gigantic has changed from 1.8.7 to 1.9.3, you can upgrade without a lot breaking If it does break, StackOverflow usually has solutions
RVM is not my friend - I don't know if it's my OSX install, my ENV, or what but it's thoroughly broken. It's also scary inside. But I recognize that many people use it, even in production, so I must be an outlier. That said, it serves an important purpose since Ruby Gems is so global in nature.
&gt; will require at least 1.9.3. [FTFY](http://weblog.rubyonrails.org/2012/1/20/rails-3-2-0-faster-dev-mode-routing-explain-queries-tagged-logger-store): &gt; The master git branch for Rails is now targeting Rails 4.0, which will require Ruby 1.9.3 and above.
1.9.x has been the standard verison of Ruby for just shy of **THREE YEARS**. There's no reason to use 1.8.x unless you've got a bunch of legacy code.
Not really necessary for someone like op who has no legacy projects to support. Bundler does this and is better at it.
hey rvm fans, don't downvote something because you disagree with it; instead, drop a note explaining why you disagree. As it happens onyxrev is correct; it's a fragile solution and is very scary inside. rbenv is a better-engineered solution that doesn't attempt to override common system commands.
Concur completely on rbenv; it's easier to work with and doesn't require rewriting any meta-environment tools to deal with it.
How does Tork handle databases in testing? I have avoided parallel testing in the past because it was annoying to isolate databases for each test runner. Does Tork do this automatically for me or do I need to write some hook to spawn/destroy databases?
Gemsets and bundler are orthogonal. Gemsets provide a clean-room environment, bundler manages application dependencies.
incorrect. Bundler also provides clean-room environments.
Mind pointing me to some docs on this?
Control-f 'clean' shows nothing. Reading that page shows nothing about clean room environments. Can you explain it to me like I'm five?
Oh hey, glad to see he fixed that bug. I hadn't checked it out in the last half of 2011. But characterizing that as 'FUD' is nonsense. I was simply not caught up to latest developments. That said, if you can't tell what's wrong with recommending someone sudo a bash script off a curl of a random internet repository, then...yeah.
Nothing on that page talks about clean rooms. At all. I've used bundler every day since the 0.7 releases. You're the one claiming it has some kind of feature, but you refuse to describe it to me.
I had big hopes for rbenv, but it turns out it's just as messy internally. Now, bash is not a great computer language, but it's still not an excuse to write spaghetti code. At least the code base is smaller than RVM's.
Parent is correct in the sense that `bundler exec` will rewrite the gem path so that the only visible gems are those specified in the `Gemfile`. That gives you a "clean room environment" with respect to gems. In fact, it's pretty much impossible to use system-installed gems with `bundler exec`, something that makes certain things a lot more awkward than they'd otherwise need to be. (For example, if you have a Rack app you want to run with Unicorn in production, you actually have to put Unicorn as part of your dependencies, even though the app itself does not need to concern itself with which web server it's being run with. We end up having our deployment system munge `Gemfile` to add Unicorn and other gems after `git clone` to fix the issue.)
'clean rooms' is not the only terminology for a gem environment that's encapsulated to the project. If you've used bundler since 0.7 and don't understand the role of Gemfile.lock, 'bundle pack', and the --deployment flag, then I suggest you read the document I mentioned. Here it is again: http://gembundler.com/rationale.html
Read the [man page for `bundle exec`](http://gembundler.com/man/bundle-exec.1.html). The relevant part is that it will: &gt; * disallow loading additional gems not in the bundle &gt; * modify the gem method to be a no-op if a gem matching the requirements is in the bundle, and to raise a Gem::LoadError if it's not &gt; * Define Gem.refresh to be a no-op, since the source index is always frozen when using bundler, and to prevent gems from the system leaking into the environment &gt; * Override Gem.bin_path to use the gems in the bundle, making system executables work &gt; * Add all gems in the bundle into Gem.loaded_specs As for Unicorn: Well, it's only one of several gems related to the hosting environment. We keep that and other gems out for several reasons: One is to simplify our projects as much as possible. The other is so that we can use specific versions of those gems with having to change our code. The third reason is that this allows us to change the hosting environment (eg., change from Unicorn to, I dunno, Passenger) without changing the app. All of this is important because we have a *lot* of apps. Most people write a big monolithic Rails app with database, front end, API and lots of auxilary stuff baked in (eg., user signup and login, email/SMS notification, SMS sending, logging, etc.). We stopped doing that. Instead, we break everything up into tiny, self-contained parts that talk to each other through APIs, with the main, user-facing web app being a thin, database-less front end. So the sheer number of micro-apps we maintain means that avoiding repetition and boilerplate code becomes really important.
i have had a hell of a time getting debugging to work in ruby 1.9.x. still don't have it working.
Yes, of cause, a password is not secure anymore, as soon as you retrieve it. It's a compromise between security and user-friendliness. And I think it's a much better and more usable approach than, for example, displaying them.
They tell you to run stuff sight unseen as root. If that's not a dangerous practise, I don't know what is.
I do believe the installation recommends to **not** run as root, but yes it's a risk just running an installer off a curl script, this is somewhat mitigated that it's not an unknown source, but a popular tool used by the community
I've not had a single problem on either 1.9.2 or 1.9.3. What issues have arisen, just for curiosity's sake?
i usually get compile errors during some of the gem installs. i haven't spent a whole lot of time trying to figure it out since i am still ok with using 1.8.7, but i did try [this](http://stackoverflow.com/questions/8087610/ruby-debug-with-ruby-1-9-3) with no luck. im using 1.9.3p0 (on Winxp) and whatever the latest devkit was when i downloaded ruby.
Why? He's right. At some point in the chain, you have to trust. If you knew Wayne, you'd know he's a trustworthy guy. If that's not enough, it's backed by Engine Yard.
How is it broken? The irc channel is usually pretty responsive to questions.
I've seen tons of people blogging about installing it in production. I don't see how traffic volume would matter, though.
i can think of 3 big differences between 1.8 and 1.9: * 1.8 is much slower * 1.9 has the new hash syntax {foo:"bar"} in addition to the old {:foo =&gt; "bar"} * character encoding is all new in 1.9 if you're just starting to learn, it probably doesn't matter too much. if you ever feel the urge to install 1.9, use rvm or rbenv.
RVM is incompetently written and managed to screw my system by happily doing things to various `~/.files` without any clue whatsoever what the fuck they really do. Avoid it like a plague, it's pile of brokenness.
"Trust but verify" It would be irresponsible to expose a system like that. If the source system were compromised, you would be toast. It is better to fetch the source, verify the checksums, load it on a test system. Better to download the package, checksum the files, install on a test system. Once you have an installable copy you can deploy it on your target systems. Too much work? Then make a conscious decision to accept the risk of compromise and the consequences of losing your data and systems to an attacker. If the probable loss is in a range you find acceptable, then go for it -- you have made a rational decision. 
And nothing stop security conscious people to do that when they install RVM. Those people worth their security job should do it anyway. It is nonsense to point out RVM's installation instruction as if it's any different from how people install software today. 
Fair enough. But it is worse nonsense to call any criticism FUD.
Thanks. I'll have to give it a try then. Sounds promising.
"It would be irresponsible to expose a system like that." later "If the probable loss is in a range you find acceptable, then go for it -- you have made a rational decision."
1.9 do break a few things. Encodings come to mind as something that might need attention. 
Any alternatives you could recommend?
I've been really happy with rbenv: https://github.com/sstephenson/rbenv
rvm is super awesome. It cured my baldness, saved my marriage, and solved peace in the middle east. See what I did there? There are valid reasons for criticizing ANY piece of software, but let's keep it to actual criticisms and not wild, inflammatory statements. Here, I'll even give you one: since rvm is written in bash shell script, it's largely inaccessible to Rubyists, since they tend to use Ruby instead of bash in the first place.
Actually, Wayne reverted that change. As of today, the default [once again is **on**](https://github.com/wayneeseguin/rvm/blob/master/scripts/cd#L3-5): # Source a .rvmrc file in a directory after changing to it, if it exists. To # disable this feature, set rvm_project_rvmrc=0 in /etc/rvmrc or $HOME/.rvmrc if (( ${rvm_project_rvmrc:-1} &gt; 0 )) 
Just compile from source. Alot easier
That only handles one of rvm's use cases, though. If that's all you need, it might be simpler, I'll give you that.
I don't see why this has to be a religious war. If you don't like rvm, that's fine, but like it or not a LOT of ruby developers use it.
There's an updated gem that will load properly. From a clean gemset/environment: $ curl -LO http://rubyforge.org/frs/download.php/33063/archive-tar-minitar-0.5.2.gem $ curl -LO http://rubyforge.org/frs/download.php/74596/ruby_core_source-0.1.5.gem $ curl -LO http://rubyforge.org/frs/download.php/75414/linecache19-0.5.13.gem $ curl -LO http://rubyforge.org/frs/download.php/75415/ruby-debug-base19-0.11.26.gem $ gem install archive-tar-minitar-0.5.2.gem $ gem install ruby_core_source-0.1.5.gem $ gem install linecache19-0.5.13.gem $ gem install ruby-debug-base19-0.11.26.gem -- --with-ruby-include=$HOME/.rbenv/src/ruby-1.9.3-p0 $ irb irb(main):001:0&gt; require 'ruby_debug' =&gt; true 
You absolutely *can* check SHA1s or download the script and inspect it first. However, `rvm` and `npm` and a lot of other recent cool tools have gotten into the habit of recommending you just run curl and pipe it into bash. It's not unreasonable for a sys-admin to object to *that* advice.
it's not umask that's the problem with the 'sudo bash &lt; curl external_site' command.
Word.
Actually it's 31. ;-)
Thanks, those are good reasons :) I like DSL, but the others outweight the lack of DSL :)
I initially got my start in a QA group. After 6 months or so, I moved over to web dev. 
I just threw this up on github. If you look in the specs, you can see that it deciphers the text based on the clues in your document. I'll whip up a readme and gemify it later when I get some free time. https://github.com/PatrickTulskie/quick_cipher
Do you want to do web dev or other stuff?
Y U NO POST TO /r/tinycode ????
What do you mean by fork a project? Take an existing program and customize it? What if I have this little ruby program that organizes my books? I have a s-ton of books so I built it as a learning project. Should I put that kind of thing on github too? 
I would really like to web dev but I am interested in Ruby itself too. 
Didn't know it was there. Feel free!
Not mentioned in the pros/cons: RVM's command line help text is (a) bloated with useless verbiage that makes it scroll off any reasonably sized terminal and (b) wrong, listing commands that simply don't work. That's what made me chuck it and switch to rbenv. My experience is that documentation quality is a good indication of code quality.
this is a great idea. You should totally write it up somewhere, and/or write your own wrapper gem providing conveniences if appropriate. 
&gt; RVM's command line help text is (a) bloated with useless verbiage that makes it scroll off any reasonably sized terminal Addressed in a release yesterday: http://www.engineyard.com/blog/2012/rvm-stable-and-more/ &gt; Significant changes to the output formatting of RVM should be noted—especially the installation and get / notes actions. RVM now displays less information and more readable output when it is installed and updated. and &gt; wrong I'm sure they'd love a bug report.
Good on you. The easy road seems to be to just stifle on whatever road you end up, but changing paths seems to demand a stomach for uncertainty and a bunch of hustle. 
Checkmate LISPers :P
If you're interested, I have a real-life web app in Rails you could potentially help out with for the experience, and to be able to put on your Resume/CV/portfolio. It's a fairly simple social site similar to twitter, with a reddit link-sharing flavour to it also. I'm an experienced developer, but quite new to Rails, so it may be a mutually beneficial arrangement as we could discuss and share as we learn and develop. PM me if you're interested.
couldn't you just make these methods/commands on a normal irb/pry console?
Is the issue that one or more of these gems isn't officially released though rubygems.org yet? Edit: also that worked (after also `gem install ruby-debug19`)
Just adding this in case anyone finds it. A friend of mine got a call and is meeting them early next week. They said they were behind on callbacks and were probably going to be doing calls until at least Friday.
Okay, in the command prompt, once you are in the directory with the gem file you want to install type gem install [GEMNAME.gem] yes? Because that's what I recall doing last time but of course naturally, now that I've asked, I can't find the page that showed me how to do it and I'm having trouble reproducing it. Regardless, "ruby_code case not handled: Regexp when trying to install fxri using rubygems" pretty much was the entire output. From what I recall, it said it was unpacking or compiling or whatever (I'm sure you can tell that I'm new to this), it went from 0% to 100%, and then gave me that output. Hopefully that's enough, if not, I can try again. Either way, thank you for assisting.
I co-founded a collective that does ruby work mainly and we take in apprentices; which is basically a step up from an internship because you're being trained for the needs of the company for a long term position. One of the biggest problems I've run in to lately is that new Ruby on Rails only partially know the Rails side of that equation and don't even have rudimentary knowledge of Ruby. My advice would be to not focus on sample sites. Instead learn the ins and outs or arrays, hashes, modules, and classes. You will be much more valuable as the person that can step in and solve a problem than the person that knows how to use Rails for the most basic projects. After that I would focus on semantic html structuring, when to use classes vs ids, et al. And for the love of all that is holy, learn sass! Ground yourself in that and you'll have the hard things learned that will make you valuable in the long run, while learning the other stuff. **Edit:** Enumerable#select, reject, map, and collect are some of the most useful overlooked tools of the trade.
Yeah thankfully I have a friend that is a RoR developer and he suggested I learn Ruby first, which I did. I am by no means great at it yet but it really helped me understand what Rails was doing. I want to build more apps too but I don't exactly know what to build. All I have now is a program that organizes my books lol. Would you suggest anything read/sites for the html structuring and for that matter sass? I also have to ask... any chance your apprenticeships are in Colorado? *crosses fingers
&gt; Yeah thankfully I have a friend that is a RoR developer and he suggested I learn Ruby first, which I did. Awesome! &gt; I want to build more apps too but I don't exactly know what to build. All I have now is a program that organizes my books lol. So, you have a program that helps you organize books? Is it web enabled? Does it support multiple users? Is there a concept of a social library that is the total of all shared books from all users? Can you build a reading list from said library? Is there an api that I can hit say from my Android or IOS devices? How about making the front end HTML5? Offline mode? Those are all ways you can improve a book program that I can think of off the top of my head. And all of those cover unique skill sets that will make you not just hirable; but attractive, sought after. &gt; Would you suggest anything read/sites for the html structuring and for that matter sass? As far as html structuring goes, [A List Apart](http://www.alistapart.com/) has been my go to site since the early 2000's. In fact here's [a recent article on Sass](http://www.alistapart.com/articles/getting-started-with-sass/). &gt; I also have to ask... any chance your apprenticeships are in Colorado? *crosses fingers We are a global collective with mostly remote work. I don't see how Colorado would be harder than Michigan or the UK :) Most of us live in Phoenix, AZ so the time difference doesn't matter usually. We aren't hiring right now, but that changes quickly. The best way to get in is to work on an open source project with us and get invited to pair on a paying project. Right now some of us are building a communal site to help facilitate more apprenticeships. Want to help? Here's the project: https://github.com/rebelhold/communal You can email me [ michael@rebelhold.com ] for pairing time and so on.
Thank you, shot an email to you. 
Ruby is optimized for programmer speed, not execution speed just as on the other end of the spectrum you have assembly which is optimized for execution speed and not programmer speed. It would probably take an ISO programmer-standard "weekend" to rebuild Reddit in Ruby, where the standard is to shift up a unit of time (hours -&gt; days, days -&gt;weeks). In real-world terms you're looking at about 200-400 hours to re-implement most of it, start to finish. I've built large social sites before and the problem was never Ruby execution speed but keeping the database from melting down as data piled up. You'll be doing more DB tuning to fix queries that take over 2000ms than fretting about how you could shave 20ms off of your page rendering times by switching to inline assembly. Your DB will always be a bottleneck. Rarely do you see a lot of work being done in Ruby to transform the DB contents into actual pages. You could build a site that handles 200K users on commodity hardware and stock Rails, a choice of MySQL or Postgres, and various other favourite goodies. If you're careful to apply tactical caching using memcached you can get some extremely fast rendering times. Building a Reddit-like system isn't nearly as hard as building a Reddit-scale system. At that point you'll be spending months building a highly distributed, fault-tolerant DB fabric to try and support the multi-terabyte dataset you've accumulated. Ruby is ideal to scope out the system and build a prototype as well as the first few generations of the software. One you scale up you'll need to evaluate other databases, other stacks, and hybrid approaches to see what works best for you. Maybe you switch out some parts with Python, JavaScript V8 or some unholy C++ server that's tuned for a very specific purpose. Remember that scaling is about discovering performance problems and fixing them, not choosing some hypothetical magical "web scale" stack from the start. I'm tempted to do this as a personal challenge and see what comes of it.
For a year I ran a penny auction site based on Ruby on Rails. I wouldn't actually use this for production anymore but the [code](https://github.com/rofflebuster/FirstBargain.com) might be a useful starting point for something.
I guess. Removing rubygems.org from your gemrc sources configuration and then trying to install ruby-debug19 in a clean environment pulls in the correct versions from rubyforge.org. I don't know why rubygems.org is behind. Edit: good to hear it worked.
&gt; Ruby is optimized for programmer speed, not execution speed just as on the other end of the spectrum you have assembly which is optimized for execution speed and not programmer speed. Obligatory: JRuby / Rubinius.
I don't think the language matters that much in this case. Ruby seems a reasonable choice, as it has a lot of libraries for developing web applications, but there's no reason in principle you couldn't write it in any other language. It might take longer and more effort to write in Java, for instance, but you'd get to the same result in the end. The biggest issue is probably the database. Reddit uses Postgres currently, but if I had to redesign it from scratch I probably wouldn't use a SQL database. A site like Reddit would probably have a fairly simple data model, and it isn't a huge deal if your site is only eventually consistent, so I'd look for a NoSQL database built for scalability that has the properties I need. I think I'd be tempted to go for Amazon's DynamoDB (then I don't have to worry about hosting!). Personally I'd probably be writing it in Clojure, hosted on Heroku, with DynamoDB as the database, but that's just because I prefer Clojure as a language ;) - Ruby would also be a fine choice.
I work for a "millions of page views per month" website built on RoR. Our experience with Mongo was that while it was indeed quite fast, it was just not stable enough for us and lacked sufficient capability for monitoring and administration. However, I do agree that Mongoid is the best gem for connecting to Mongo. Mongo is promising, but in our opinion not ready for prime-time. We decided to ditch Mongo for now, and are still relying on PGSql and smart use Memcached (we use a highly customized version of Cache-fu). Currently we're evaluating Cassandra vs. Hadoop for an upcoming project that is just crying for a NoSQL solution. We've also got some support around the office for CouchDB, but it's a runner-up right now. I also agree that it's probably best to stay out of the cloud for now. We use commodity servers hosted at a local colo and feel no need to break from that. The points of failure are fewer and solutions are under our control, not some remote entity whose needs don't necessarily reflect your own. As for webserver, we use Apache/Passenger behind an HAProxy load balancer and copious use of a CDN and lighttpd for static content.
Rubinius is an impressive effort, but they've still got a long, long way to go to match up to C++ or even JavaScript V8 in terms of execution speed. A lot of the problem is that Ruby, because of its programmer friendly features, is quite hostile to compiler developers.
No, then you'd just start 3 holy wars by promising a new Reddit that didn't have the portability issues or verbosity of the older Reddit implementations. Years later, everyone will still be using the old Reddit, and making humorous references to that new, awesomer Reddit that never materialized.
I've recently done a round of interviewing junior-ish developers, and for me it's looking for a mixture that is two parts attitude, one part skill. I'm not impressed by degrees (mine stinks), or even decades of experience (I've got 15 years and I know how much I suck! :-) ), but it's about the ability to pick up a problem and run with it. Seriously, work on some FLOSS, and make sure your github URL dazzles. It will make you *very* hirable, and at a higher rate of pay than some other applicant who doesn't dazzle quite so much but whose CV has 5 years commercial experience...
I'm working with HBase on Hadoop from a Java/Python based project and I've be really happy with it. Its a great product that performs really well. We are sucking in about ~600gb a month and it performs really well. Haven't used HBase from Ruby and I'd be hesitant to use REST with anything too big. Our requests are for 5k to 250k object sets. Way too big for REST. 
Been a long time redditor, but using a throwaway to post this link. I am one of the organizers of the RubyConf India this time around. This will be the third time around RubyConf India is taking place. Having attended the last two, it's absolutely a great place to learn ruby things as well as socialize with the thriving and friendly Ruby community in India. If you are not an Indian and need any assistance with any Visas or travel, PM me and I'll be happy to help :-) It'll be great to mingle with and befriend Rubyists from various countries and cultures in the scenic city of [Pune](http://en.wikipedia.org/wiki/Pune)!
ASCII regexps work on UTF-8 strings in Ruby 1.9. The fact that \w doesn't include accented characters is a [POSIX spec issue](http://en.wikipedia.org/wiki/Regular_expression#POSIX_character_classes), not a Ruby issue per se.
Cool, but at this point I'd need a reason to switch back.
Yes, that was the intended joke...
Ya, I didn't pay attention to the winking face and italics and so didn't get the joke at first.
I'm not a fan of the way described to handle errors. Feels… wrong. 
Torquebox + (riak || hbase || cassandra) That's it really. 
Yeah... When you have to put a list of caveats right after it's probably not a brilliant idea.
This is retarded. Guess what, if i put the method def all on one line, they're pretty much the same size: `let(:full_name) { [@user.first_name, @user.last_name].join(" ") }` vs `def full_name() [@user.first_name, @user.last_name].join(" ") end` 
"inheritance […] being evil" LOL
Here's a reddit clone using Sinatra (monk): https://github.com/monkrb/reddit-clone
The best supported of the 'traditional GUI' bindings are probably those for TK. They're apparently widely used in Japan - but regardless of reason, they're generally kept up-to-date. I hesitate to recommend TK for use as I don't think very highly of it, but your mileage may vary. Unfortunately the Qt bindings are not well maintained anymore. Swing works really well from JRuby and I have heard of several successful projects using that. There's a project called Limelight which is a GUI framework for JRuby that is quite well maintained. I'd recommend taking a look at it and seeing if it meets your needs. Link: https://github.com/slagyr/limelight And as previously mentioned, Shoes has been resurrected thanks to Steve Klabnik and is also worth a look.
I've always gone with that too. I still unsure what `test_engine` provides over that approach.
I have page on doing this (though brief) http://stahnma.fedorapeople.org/aix/ Another resource http://projects.puppetlabs.com/projects/puppet/wiki/PuppetAIX lower on the page
Not trying to start a war here, but as a general point, you'd have a quieter life writing your gui app in Python right? [There's a lot more tools to help](http://wiki.python.org/moin/GuiProgramming) and [better maintained](http://www.wxpython.org/) gui libs, and [better crossplatform distribution support](http://docs.python.org/faq/windows.html). (?) Also python is ready to go on both OSX and Linux, so you're increasing your possible 'easy-install' user base. My gut tells me that it's also easier to package up a python app for windows use (without the user having to install python). (That's based on unending suffering [trying to package up a very simple ruby command line app as an .exe](http://www.erikveen.dds.nl/rubyscript2exe/) a couple of years ago). Am I wrong about this? I'd like to be, as I'm a 95% ruby person. But I've considered making things with guis before and it's always looked like no one who'd have the skills or dependencies to be able to get my app to run would need my app, or a gui, anyway...
For MRI it's definitely Tk. It has a strange love/hate curve. You'll hate it at first, then quickly love it, then hate it again. So far, no loving set in again, but I'm not in love with any of the GUI toolkits out there, so that's that. But after all, it gets the job done and is admittedly an exceptionally fine piece of software.
For cross-platform, JRuby is a good bet. If you don't mind targeting Mac-only, you can do some pretty amazing things with just a little bit of MacRuby.
Not sure of your needs, but you might consider looking at JRuby if you already have Java in your environment. As I understand it works pretty well on AIX.
goddamn i hate your nickname BBHoss sounds like some serious redneck BS
You have such a fowl mouth! :) I am from Alabama, you are correct!
I hadn't even considered TK. That's an interesting choice.
I really tried to like python and just could not get myself to like it. So far the best option seems to be jruby with swing. I don't intend to write an app that I will ship to somebody but if I decide to it looks like I could ship a jar. BTW one interesting thing about ruby is that you can ship ruby as a directory. I did that once. I just put the ruby binary and all the libs inside of one directory and set a couple of vars and it worked just fine. 
I'll check out limelight thanks.
Shoes didn't seem all that comprehensive to me. It doesn't offer many widgets.
MacRuby with Cocoa.
What is it missing that you'd like to see?
Nope, you don't want to use `wx`. I've built one app and after recent Ubuntu and OSX upgrades it just stopped working. Library is unmaintained (or close to being in that state) and the docs are lacking in few areas.
That's not the part where there's savings. extend Cls takes :user vs def initialize(user) @user = user end It also does some nil-checking and such. With one variable, it's not that much, but with a bunch of them...
I have always longed to visit the fabled City of Poon. Why a throwaway? 
@jrochkind hits many of the high points over using the rails plugin generator. Basically you don't have to manage the dummy app and can switch between Rails versions in rapid succession. Plus I don't like all those extra files cluttering up my repo. I prefer the dummy app to be something that is not part of the repo and can be re-generated at any point. Maybe just personal preference. I also question if a stripped down rails app is really valid for tests. There might be some corner case difference between a pristine "real" rails app and a stripped down rails app. Seems safer to test against the real thing. But in the end it is basically doing the same thing (testing against a dummy app). Just changing a few of the details to fit my development style better.
Cool thanks, what about upgrading from 1.8.7 to 1.9.3 though. I've had problems before trying to upgrade.
Daryl? 
As of Rails 4, 1.9.3 will be the only supported Ruby, so...
Never really hit that one, but having said that I've only migrated one app over that barrier so far...
the performance between jython and jruby is similar and jruby has more development behind...actually jython is some steps behind jruby
It was kinda a joke, because Reddit switched from Lisp to Python, and Clojure's a lisp on the JVM. Not a very good joke, I'll grant :)
That's retarded way to "sanitize" command line options. Ruby has system("command", "--option", "--option", "etc.") for a reason. This will die even on spaces in directory names, without anyone trying to break its security.
Being a whitelist, it looked like it at first glance, but I guess you're right, not control characters. It is a little bit ambiguous at what level you're running the code in the sample though. Is it an internal library, or intended to be packaged for use with third party code, and how much is expected to be user input. It gets a little tricky to provide a balance between allowing full access for more advanced uses like you seem to require, and sanitizing everything assuming it's all user input
patch is included in rvm: rvm get head rvm install 1.9.3 -n falcon --patch falcon -j 3 https://gist.github.com/1688857#gistcomment-79311 https://github.com/wayneeseguin/rvm/commit/828283dfda64d36cea41ac5f603ff348036426b1
I'm curious why the second argument of Timeout.timeout isn't used: http://www.ruby-doc.org/stdlib-1.9.3/libdoc/timeout/rdoc/Timeout.html#method-c-timeout
that was the first thing i thought when looked at README "pretty big dufference huh".. lol no, just another DSL you need to teach people and just another thing you will refactor out of your project in couple of months
I've heard it's because for-clauses are better for multi-dimensional arrays. 
The very idea of least surprise is that it should be the same to you as to Matz. Matz isn't the only one who makes language decisions nowadays anyway.
It completely avoids off-by-one errors when used to iterate through a set [EDIT: I misunderstood something. See replies.]
It's syntactical sugar, that's all. If you want to use it, then you can. If you don't want to use it, then you don't have to. It's nothing to get exercised about, though.
I don't use `for`, because of the following reasons: * for loops doesn't introduce a new scope, as nilved explained * for loops just delegate to each anyway * using `each` makes my code look more consistent: it's blocks everywhere, it doesn't matter if it loops or not. * you cannot use for loops functionally, like passing lambdas: `users.each(&amp;:save)` * you're tempted to miss the other enumerable methods when using `for`, like `select`, `reject`, `find`, `map`, `all?`, `any?`, and dozens more that you really should learn, use and love.
Thanks for your explanation, it makes sense that `for` doesn't introduce a new scope. Here's a small tip: .select(&amp;:valid?).first can also be written as: .detect(&amp;:valid?) 
Ah, wait. I WAS talking about Enumerable#each. I assume there is a "for i in..." syntax because 1) other languages have this 2) follows Ruby's philosophy of more than one way to do things
Sorry, my bad, I was looking at the question in the title (`Why is there for-statement in Ruby?`), but you were answering the question in the submission text (`Is there any reason to prefer Enumerable#each`)...
What has been the response? For me (and im sure for others as well) this is awesome stuff .. And it has a direct impact on my rails/ruby dev.
(I might not know what I'm talking about, but I'm sure someone will jump on me if I have this wrong.) I think of it as a historical thing. When Ruby was first invented, the flavor of the language hadn't really revealed itself. The for statement is something that looks back to the way the last generation of languages did things. When Ruby was invented, it was natural to put for loops in, because that's what everyone was used to. Now we've all internalized closures so completely that we look at a for statement and say, "Why the heck would you do it that way? Why not use an iterator?" But that's a change that has taken place over several years. Ruby has played a big role in making that change. Even so, we have to remember that when Ruby was first invented, that mental shift to closures among average users of scripting languages hadn't actually happened yet. 
It's even more fun when you realize that local variables changes the parsing: b /1#/ # this is the same as b(/1#/) a = 1 a /1#/ # this is the same as a / 1 (and the rest is a comment) Or, that a simple refactoring doesn't work that well: # this works if foo = bar p foo end # this does not p foo if foo = bar # however, this does! foo = nil p foo if foo = bar
I was going to say that I have a few cases in which I would use for, but I end up writing something like (1..3).times { yield }
As mentioned a few times in this thread: foo = :bar [1,2,3].each do |foo| puts foo end foo #=&gt; :bar for foo in [1,2,3] puts foo end foo #=&gt; 3 That's definitely NOT syntactic sugar - that's two different tools used for two different situations.
or as .find(&amp;:valid?)
This isn't that kind of for-loop.
Just curious, why are you using Curb instead of Net::HTTP(::Persistent), httparty, httpclient, rest-client, resourceful, etc etc Curb's performance (even with Curl::Multi) is no better than Net::HTTP::Persistent and many other clients which don't depend on a 3rd party library.
The former is wrong, and the latter raises a NoMethodError without parentheses around the range. So that's the reason why I prefer the `for` loop. Your for loop should be for i in 0..5 puts i end and `#each` with a range needs to be: (0..5).each do |i| puts i end
Thanks for the tip! I've never heard of that. I'm definitely looking into changing it. Curl has been inconsistent at times for me.
I appreciate the suggestion, but getting java setup in each environment isn't going to be very realistic, at least not for my intended purposes. Thanks though!
wish i could upvote more than once. this is awesome thank you for your help, i figured out a way similar to the way the gem works. again thank you dude :D
Sweet, thank you for the idea. I just found a group here in Denver. 
Honestly, if you worked hard enough, you could bring in plenty of habits learned from other languages - Ruby is great for that. However if I saw a for loop instead of an iterator, the first question I'd ask is about the quality of the code.
You're quite welcome. It was a fun challenge. If you want to improve upon it, send me a pull request!
Mechanize is what you want.
Looks like it only is for 1.8.7....which is somewhat history? I've only been learning on 1.9. The differences, and how much extra work that would require to navigate, or if it would even be necessary, I'm not sure of. Edit: Mechanize does seem to be what I need in skill range atm
Proceed straight to Mechanize. Pass reinventing it yourself. Collect 200 internet dollars.
Would the sessions be online? I currently live right across the country, and would be unable to attend due to prior commitments. 
As learning experience? Great. But don't ask me to judge the design, because I would.
Oooh, that's really nice. Impressive work! My only complaint so far would be that I don't like the fact that those little box things aren't aligned. It would be great if posts boxes were in two columns or a dynamic number of columns or something like that.
Been using ruby for nearly a year for server administration. After seeing this, I think I need to step up my game.
Github or it didn't happen.
I would make it for the command line, and no, lynx does not count.
It's still very much beta and I imagine there are still holes in the sandboxing. If you find any problems or bugs, feel free to post them here. I'm still working on adding more problems too. Thank you!
I think a good tip would be to check the code with asserts that are not published as well. For example, this is how you could ['solve' fizzbuzz](http://www.rubeque.com/problems/fizzbuzz?solution_code=case+x%0D%0Awhen+3+then+%22Fizz%22%0D%0Awhen+50+then+%22Buzz%22%0D%0Awhen+15+then+%22FizzBuzz%22%0D%0Awhen+5175+then+%22FizzBuzz%22%0D%0Aend) 
This is good stuff. You should look into Reddit Enhancement Suite and see what you can do. Also, mobile phone support?
Good point. We have hidden assertions in the pipeline too so I think I will prioritize it higher.
Great job! And thanks ubermuch for open-sourcing this. I'm gonna be looking through the code - I'm trying to get better at rails but I've kind of hit a temporary dead-end. As a quick question, how do you match the route - http://www.rubeque.com/problems/maximum In this case, is the 'id' simply 'maximum'? EDIT: I think I stumbled upon an error assert_equal phone_number?("555-555-555"), true for the same reason why "555555555" isn't true, shouldn't this ALSO be false?
Why are you preventing the use of `while`, exactly?
Hello ! My best guess, since WEBrick can serve your static files, would be that www-data doesn't have the rights on the assets. Can you su as www-data and attempt to read window.js ? Good luck !
Not that I know of, no. Can you access other static assets from the app ? If so, check permissions differences between those files and the ones from the plugin. If not, it's probably a problem Apache's config. I'm sorry I can't pinpoint it better, but I used to use Passenger on top of nginx, not Appache :-/
So... I think I needed the following rewrite rules... Puzzled as to why, but it seems to have resolved my 404 errors. RewriteCond /var/www/chiliproject/public%{REQUEST_URI} -f RewriteRule ^ /var/www/chiliproject/public%{REQUEST_URI} [L] RewriteCond /var/www/chiliproject/public%{REQUEST_URI} -d RewriteRule ^ /var/www/chiliproject/public%{REQUEST_URI} [L] Why did you choose nginx over apache? I've heard that nginx is grat but don't have any experience with it. (I've also heard that it handles Perl/plack (plack is an implementation of PSGI) naively. As I'm a perl guy this interests me)
Any experience with different coexisting versions of ruby under Passenger ?
Thanks ! In that case Passenger's main advantage (for me) is lost (simplicity of the setup) and I'd rather go with Unicorn which seems to be more flexible. Do you know how both compare in terms of performance ? I deployed a Spree based app today on Unicorn and it looked much snappier but I haven't seen any serious comparison yet.
We're using mongoid (http://mongoid.org/) which allows us to use string columns for ids. So like normally it would be /problems/8 or something but since the problem id is maximum, the path is /problems/maximum. You can achieve the same basic thing with a gem though: http://railscasts.com/episodes/314-pretty-urls-with-friendlyid. Also, you're right about the phone number thing. It should be false. thanks for reporting that!
You're right. Thanks!
Hehe. That works. :)
I can't figure out why we aren't using while. I'll have to look into that. dup is not allowed because it can eat up memory very quickly. I might try to take a look into another way of preventing DOS by consuming memory so we can allow things like dup.
Committed‼
Hm, makes sense from the perspective of overeager caution, I suppose, but it's really not the kind of thing that should be blocked on a site like yours; `while` is a very common paradigm and there's nothing inherently wrong with it. I imagine it's blocked to prevent an infinite loop doing any damage, however temporary, but that problem is covered just fine by Ruby's Timeout module.
Why is RoR such a resource hog? &gt; On a side note, i like nginx' style of configuration syntax better than Apache's too. This XML-like stuff... Heh, this has been one of my biggest complaints with Apache for years. I guess it could be worse and be a full blown XML spec.
It would be nice if I could click Title, Tags, Difficulty, or Solutions and have the list be sorted by which one I clicked.
By all means, [keep it that way](http://datamapper.org/).
The prime factors one is wrong too
Looking at the other solutions, I'm not sure I'm doing it right. **My solution** max = 0 arr.each do |a| if a &gt; max max = a end end max **Everyone else's solution** arr.max 
51 is not a *prime* factor. Just a factor. 51 can be broken down further to 17 * 3.
Is it possible using this to turn the TV on when it's off. I've tried using the app to turn it on, when it's off it's not possible. It's likely it's because it was connected over WiFi, ethernet might have allowed wake on lan but I haven't been able to test that.
I haven't really got time to help out, but a little bit of input: For the first point you mention, there's a couple of ways to go here, an alternative to continuously looping would be to setup a unix system such as cron to trigger a script (e.g. rake task) to poll the moderation queue. If you do want to go the looping route, I'd suggest looking into EventMachine, it's a really good library for writing a looping event driven system. (I'm not familar enough with the reddit API to know which approach is more appropriate). Also, I'd definitely recommend having a ruby wrapper for the reddit API kept as a separate gem/library to the rest of the modbot, that way there actually will be a generic ruby wrapper, and you're more likely to get contributions for that portion of code.
I have no idea if you've seen [therubygame](http://www.therubygame.com/) yet, but it's in the same area although it's more about the shortest/fastest ruby code. I bet you can get some good inspiration from that project!
There are 3 gems I found....which were mostly worked on in 2010, updated sporadically and have a limited sophistication compared to the python version I read through. The one I tried errored for almost every request. Its a matter of time and money, so I'll just bolt on something basic for what I need as I need it. Admittedly, I may be reinventing the wheel and could just use the python versions of the api and bot, but I wanted to do this and stretch my ruby skill set a bit more.
My immediate thought was, “ActiveRecord magic is a leaky abstraction."
I've used cinch for over a year and found it pretty capable. Easy to get up and running, but may not easily allow to grow to do some more complex bot stuff.
 ("do" || "do not").include? "try" =&gt; false 
op.languages_understood.include? "ruby" =&gt; false
That's the point of my original comment. ('do' || 'do not') is functionally identical to 'do'. 'do'.include? 'try' misses a significant part of the yoda quote.
Good stuff. I'm thinking about getting a VPS as well since I'm using shared hosting for like 20 websites, and I'd like to start deploying rails apps on a vps of mine as well. With a VPS i can install any version of ruby/rails right?
Sent. Size M. Thanks!!!!!
Any version you please I use rbenv because it's lightweight, but I have it installed over a system ruby so rbenv's only purpose is taking jRuby and Rubinius for a spin I'm yet to find a good deploy system which works on a VPS and for local deploys though, at the moment it's a bundle exec unicorn --daemonize command in my .zsh_history :)
I wish I had access to a computer powerful enough to virtualize :/ &gt; All ruby code is executed in the VM That made me think of xzibit :)
heh I have NO idea how to do any of those configs. The only deploying I've done so far is "ralis s" for local development and "git push heroku master" for deploying to heroku :p I'm looking forwarad to discover all the problems I'm going to run into when deploying to my own vps :D
That's actually pretty good/usable. My only comments would be to give the boxes some form of symmetry so they don't appear as though they are randomly strewn across the screen, and perhaps clicking on an image(or a button in the corner) could enlarge images without the need to open a new page.
I don't use WEBrick as I think it has pretty poor performance in comparison to Thin Instead, I use Unicorn behind nginx, which works out well for most use cases. I use memcached where possible, and PSQL as a backend As with deploying anything, make sure your logging layer (tail -f) is bulletproof, knowing when shit blows up is crucial when you're managing your own infrastructure I use thin in development, and just keep it daemonized in the background Good luck, post if you have any problems :)
Heh, I should try to branch out a little, I haven't tried Rainbows recently, so I might take that for a twirl
No, but I'll check them out now!
Why can't we have more case studies in programming? These seem so useful, even in less obfuscated cases. It's like having a more experienced programmer standing right next to you spending half an hour explaining things. Thanks for taking the time to write this up!
I will look into it! Thanks a lot 
What kind of problems have you had with capistrano?
Ruby &lt;3 Linux though, and Linux and Windows can happily co-exist on a PC or laptop. I have nothing against people who use Macbooks, but they are not the only option. There's even one person on the Rails core team who doesn't use one!
I'm sorry to hear that, capistrano is one of my favorite tools ever! I've used it to deploy everything from my old Wordpress blog, to my home automation system, to apps on my jailbroken iPhone. And of course, I use it every day with RoR apps. I agree that documentation (used to be?) lacking. But, I just found out that they've replaced their website with a GitHub wiki. [This page](https://github.com/capistrano/capistrano/wiki/2.x-From-The-Beginning) looks quite helpful? Anyway, please do let me know if you try it again and need any help.
&gt; Why is RoR such a resource hog? Well ruby's an interpreted language, but the situation's been improving for a while. Is perl much better in that respect ? &gt; Heh, this has been one of my biggest complaints with Apache for years. I didn't have much experience with Apache when I started being responsible for my stack, so I went with the lighter and more enjoyable of both ;) Plus, it seems most of the RoR community favors it too, so...
:_(
You significantly overestimate what's necessary to get a simple, headless vm set up. 300megs of memory and you're off to the races. Iunno dude, figure it out? A new harddrive is $100. A new computer is like $400.
Nice. I like undercover nerd shirts.
&gt; that I can't SSH to GitHub This is easy to fix. The networking inside a VM is complicated but doable. Anyhow… that sucks dude. But… if you're learning how to program that's your best ticket out of being broke.
College blocks port 22, so I would need to proxy it somehow, and I might as well use the VPS anyway Heh, shame, nobody wants to hire a 17-year-old Rails programmer, otherwise I wouldn't be broke :) 
It'd be cool if you could see the highest average score on the "Scores" page.
I've built dozens of ruby based bots, from scrapers to far more nefarious tools. Ruby is a great language for it. I wrote a blog post a while back about getting started with watir, which is a very fun botting platform: http://www.layeredthoughts.com/automation/how-to-write-your-first-ruby-web-bot-in-watir-scraping-weather-com
Hi all, just finished Mendicant University's core skills course, and my personal project for the course was outlaw, which tries to help you and others avoid anti-patterns that you can define formally by example. I don't expect it will work for all the examples you can dream up yet, but maybe with your help we can get it there together. just `gem install outlaw` and then `outlaw` in a project directory to try it out, or peruse the repo on github.
 require "rest-client" # build json req = &lt;&lt;-end { "name": "Your Name", "email": "your@email", "about": "About You", "urls": ["http://example.com", "http://anotherexample.com"] } end # post the request url = "https://www.parse.com/jobs/apply" res = RestClient.post url, req, content_type: "application/json" puts res.headers[:status] # "200 OK" means success
I went with mechanize for now as a not too much/ not too little solution. It gives me some of the basics without being too complex (which is what I want here, a more from the ground up experience).
Yeah. I'd just do it with jQuery in the Chrome console
At least you've got it right in your HEAD. I should really stop LINKing you to such things, but I just can't help putting out a request for comments.
I see what happened there. Often when botting you'll mix and match libraries. Installing nokogiri with mechanize is a smart move as you generally use them together. With watir specifically though there is no dependency on mechanize
[No Really](http://Sophrinix.com)
Reminds me of ruby koans. You can cheat if you want to... but then you're just wasting your own time.
`curl` FTW!
My curl powers are not as strong as I wish they were
Video demo: http://www.youtube.com/watch?v=VoHmJfXqwbM
god, thank you
2010 will last forever
Another one: http://railslove.com/jobs.json with more style ;)
Have you ran messie against [Wivet](http://code.google.com/p/wivet/) or the [Web Spider Obstacle Course](https://github.com/postmodern/wsoc#readme)? Also interested in how this compares to [Spidr](https://github.com/postmodern/spidr#readme), and where it could be improved.
Messie is a very young project, Mechanize has been around for a while, so it definitely is a lot more mature. But I don't intend to copy Mechanize, it can do a lot of things that I don't want to support with messie, e.g. handling of cookies and submitting forms. Messie is just intended to download pages, not to completely automate things.
Might want to check out the RailsCast source code. It's for video, but even if you can't use it directly it may be able to give you a good jumping off point for the CMS side of things. https://github.com/ryanb/railscasts
YAY! This is almost exactly what I was looking for for a project I am working on. Thanks!
BTW, http://cfru.ca/ gives a 500 error... EDIT: Fixed. Not 500'ing anymore.
I created a very small and simple sinatra app for this, probably not what you're looking for but still relevant. [https://github.com/orta/ortacasts](https://github.com/orta/ortacasts)
There is podcast plugin for refinerycms https://github.com/djones/refinerycms-podcast
This is one of those ages old philosophical debates in programming: should you assign before you branch, or assign while branching? Every time nowadays I've been tempted to assign while branching, I don't. I didn't even realize this caused a warning. After years of doing that when I was a C programmer, I'll say not doing this makes your code both easier to read and refactor.
It's generally considered bad practice in languages that are liberal in what is true. For ruby, a lot of stuff is true that could be meant as false. Example: true &amp;&amp; 0 =&gt; true true &amp;&amp; [] =&gt; true true &amp;&amp; {} =&gt; true When the function call is "inlined" in the conditional, you're distracted from it. When you're distracted, you make mistakes. It's just a line more and it also gives you more options: a = method_returning_nil_on_failure if a.nil? then deal_with_failure else do_something_with a end This make clear that method_returning_nil_on_failure is called and its result is needed later. It doesn't "hide" the assignment and you can use a.empty? or a.zero? without changing the general layout. EDIT: corrected the script. See comment from jawdirk.
It's not false_on_failure, it's an_object_I_wan't_to_use_normally_but_nil_on_failure.
Returning nil on failure is probably a Bad Idea. Also, nil is false.
I've done this only a few times and it has bitten me in my ass at least once, it's handy, but I don't recommend it.
 true &amp;&amp; 0 =&gt; true ... ? y u no !!0 double bang is a common thing in ruby to get a pure boolean... 
Because it's an example. What I wrote, everyone with at least some programming background will understand right away. Double bang saves a few keystrokes but will confuse at least a few readers.
 a = method_returning_nil_on_failure if a.nil? then do_something_with a Interesting that you made a careless error using the "recommended" idiom (do something with nil?). Needless to say, I've made this error many times too. Haven't used "then" recently, however... When was the last time you programmed in ruby? Anyway, I find that unless a.nil? is the expected value instead of the exceptional value, then this is better: if a do_something_with a # or better a.do_something else deal_with_failure end I prefer it to yours, because it naturally puts the interesting code first in the if. Everything is true except for false and nil in ruby for exactly this reason; because it produces compact code that reads like English. 
I'm not sure if it was Sussman or Knuth that said: "Programs are meant to be read by humans and only incidentally for computers to execute". Anything that improves code readability for a human being is a plus. If the price to pay is a few keystrokes, it's a small one. I prefer separating assignments and conditionals in separate lines.
You shouldn't, unless it's common in your project. Otherwise, someone (possibly future you) is going to see it and "fix" it with a ==, which will break things, and you'll get the blame. That's what happened to me, anyway.
Clever is cool in the moment, but never in the long-run. Made it easier to read, first. ...so *no.* not approved.
Returning nil on a soft failure is not a bad practice. Returning nil in the case of a serious failure is. A soft failure is asking for a database record that may or may not be there. A hard failure is asking to save a record and it can't commit to the database.
Turning it into a gem would make it easier to distribute, but wouldn't particularly make it easier to work on. Nonetheless, people will expect you to observe the conventions around gems (naming conventions, directory structure) so I recommend following most of what is discussed [here](http://guides.rubygems.org/patterns/).
Not trying to be a jerk, but you break a lot of Ruby language conventions. I would add improving that to the top of your list.
Use Enumerator for cleaner results: `enum = some_method_that_yields; enum.next.should == whatever; …; enum.next.should_raise StopIteration` or however you do raising exceptions.
I'm really glad you pointed this out. Could you (or anyone else) point out what I'm doing wrong so I can do it right?
I don't have a lot of time today but here's a couple of things from a quick scan: * "return" is implicit on the last line of a method * method names should be underscore case * you generally want to use symbol Hash keys (although the YAML library doesn't do that)
## Ruby conventions (generally accepted, not defined in PEP like documents): * Filenames don't include capitals and are snake_cased. This means that instead of ExampleFile.rb you'd end up with example_file.rb. * Use 2 spaces for indentation, it's what 99% of all Rubyists use and people will hate and mock you for not using it (there's no reason to use more as well, Ruby looks fine with 2 spaces). * Don't mix indentation. Book.rb contains different indentation sets than Game.rb. If your editor is messing up use a different one or configure it properly. * Document code using either the RDoc style or YARD style. I'm a big fan of YARD but it comes down to personal opinion, just don't re-invent the wheel of documenting code. ## File structure The general structure of Ruby projects is the following: ._ bin/ | |_ some_executable_if_you_have_any | |_ lib/ | |_ project_name.rb | |_ project_name/ | |_ spec/ (or "test", doesn't really matter) | |_ spec_helper.rb (or "test_helper.rb") | |_ README.md (or a similar extension) |_ Rakefile (when needed) In your case you'd end up with the following: ._ lib/ | |_ kolb.rb/ | |_ kolb/ | |_ action.rb | |_ book.rb | |_ game.rb | |_ kolb.yaml.rb | |_ README.md ## YAML Next up is the use of YAML. I'll probably start a small flamewar because of this but I'd advise against using YAML, especially if you're going to deal with large files (though I'm not sure if this applies to your game). The YAML parser isn't super efficient and parsing large files will quickly cause Ruby to use quite a bit of memory. Last but not least I don't really get why you're using YAML as a file format when the source of it is generated by Ruby, you might as well keep it in Ruby code (e.g. hashes or arrays) as this will 1. use less memory and 2. doesn't require you to convert it to YAML only to convert it back to Ruby code again during runtime. Other than that it doesn't look too bad, hope you're enjoying Ruby :) 
nice
The syck parser is slightly faster, but broken.
Ruby doesn't do audio natively, so any solution is going to involve something like that. Or use JRuby, I'm sure Java has audio APIs.
Bastages. Well, kolb might be good enough.
No, I haven't Are Cherokee, Thin and WEBrick all showing 500? What's the RAILS_ENV you're trying to run the server under? Have you precompiled your assets? Have you migrated your database? 
Yes.
It isn't [libyaml](http://pyyaml.org/wiki/LibYAML) though. That's what I was trying to point out.
Finally, a post nobody can disagree with.
I'm excited to try Sidekiq, but my application uses resque-loner to prevent jobs from being enqueued twice if the payload (class + arguments) has already been queued up. That being said, I was planning on submitting a patch (or writing a plugin) to do what resque-loner does but for Sidekiq, but opened an issue first. Within the night, mperham's accomplice ryanlecompte had already pushed to a branch to add unique payloads to Sidekiq. I'm pretty impressed.
I've gotten everything up and running (ie, PA compiled and the ruby wrapper pointed to the library). I'm having trouble figuring out the right combination of settings you spoke of. Also, it looks like the wrapper doesn't implement Stream#read, which I'm guessing I would have to use to do any recording. Wouldn't I basically do the following: 1) open an input stream, 2) create a buffer, 3) read from the stream into the buffer, 4) manipulate the buffer, and 5) write data to a file? I have no experience with implementing an API wrapper, so if I wanted to go about forking the PA wrapper and implementing Stream#read myself, could anyone give me a point in the right direction?
Agreed.
For one, it's a time thing. In 10 seconds, I can glean the same information from text that would take a minute of video to convey. Two, it's a programming thing. Having examples to copy/paste and work with would be nice. Having code to read is, for me, the best way to learn. I don't think I've ever watched a video to learn programming (unless it was to visualize a sorting method, for example).
There's some code which Works For Me(tm) here: https://gist.github.com/1761661. No idea if it'll be any help.
I thought you could already do this with Rails3 (I _know_ you can do this with [DataMapper](http://datamapper.github.com/) / [dm-rails](http://github.com/datamapper/dm-rails#reade)) just by specifying the per-environment Database configuration as an Array of Hashes?
In contrast to some of the other comments, I actually appreciate that you put it in video form. I read constantly so sometimes a change of pace can be nice. Great video.
In the interim you might enjoy this post that I made along similar lines back in 2006: http://www.rubyinside.com/21-ruby-tricks-902.html .. although I don't like these as much as the ones I moved on to do now :)
I agree entirely that the right metric is readability, but readability can be sadly subjective. I think assignment in if conditions often DOES improve readability. if user = getUser doSomethingWith user else noUser! end vs user = getUser if user doSomethingWith user else noUser! end 
 a = %w{a b} #=&gt; ["a", "b"] b = %w{c d} #=&gt; ["c", "d"] %w{} is a Rubyism to create an array of strings. Each space-separated word is turned into a string, and the results are aggregated into one array. a + b #=&gt; ["a", "b", "c", "d"] [*a + b] #=&gt; ["a", "b", "c", "d"] These last two up yield the same results. The asterisk is Ruby's "splat" operator and essentially explodes/flattens arrays and hashes. Trying to do just *a + b would result in an error, because splat itself does not return an array. That's why that last splat is placed in an array to catch the arguments that are exploded out of a + b. Without that explicit array, you'd end up having just "a", "b", "c", "d' with no container; the array is added to make that usage of splat legal and not throw a syntax error.
Thanks!
thanks for the effort peter. was a nice video to watch. 
There's so much wrong with this application that I'm not even sure where to begin. The layout is a pain in the ass, the font is completely out of place, the text reads like it was written by a 5 year old in his "gangsta" phase and the link to Github is a link to your profile and not the project. The board also isn't truly anonymous. Initially I thought it was something like 4chan where there was no need to register, only to find out you have to provide a username and password. I have no idea why this is even needed since the information doesn't seem to be displayed anywhere. If it's to combat spam then there arae plenty of other and less annoying ways to do so (e.g. Defensio or Akismet).
Nice idea .. the Pry-ecosystem keeps growing at an insane rate.
How about using Mocha like this [1]? Do you think that's a bit more readable? [1] https://gist.github.com/1770156
&gt; Ruby-on-Rails posts are encouraged to be posted in the r/rails subreddit
With passenger standalone I'm pretty sure it would be very very similar to how you do it with unicorn, perhaps easier. But whatever works for you is the right choice! 
Great to see that you're enjoying Ruby, after all that is the most important bit :)
Here's a comparison of the languages, from a great Python programmer: http://groups.google.com/group/comp.lang.python/msg/28422d707512283?pli=1 Also, here's the learn ruby from other languages page: http://www.ruby-lang.org/en/documentation/ruby-from-other-languages/
Thanks!
PLEAC is absolute awesome for comparing how to do stuff between languages. [http://pleac.sourceforge.net/](http://pleac.sourceforge.net/) I've always heard that the main difference between python and ruby is in the mindset. In Python there is (i've heard) one correct way of doing something. In Ruby there's a ton of different ways to solve most problems. I imagine this difference can be a big change.
Well mostly what I will be doing is updating existing scripts, so I will probably end up doing things to match how they are currently being done. Thanks for the reference! I didn't know about PLEAC. Doesn't seem like the best for learning but a great thing to use as a reference if I am confused at how something works differently to compare. I still need to pick up a book on ruby but I have not decided which one yet. 
I strongly recommend acquiring a hat collection and novel facial hair like [this gentleman](http://tenderlovemaking.com/about_me/) I would recommend the Ruby Koans from the sidebar, if you're comfortable with test driven instruction. They will calibrate your skill level so you can move on to other ways to learn appropriately.
I have to say, I don't get your hat collection reference.
His facial hair doesn't seem that novel. I am sporting a full unix beard, so I would have to pointed to examples of how his is novel :P
He often sports a chester-the-molester moustache which is fairly excellent.
Is there a certain area you'll be focusing on? Rails? Core ruby stuff? Sysadmin scripts written in Ruby? Do you care if your code looks like it was written by a Ruby programmer, or do you just need it to work? If you just need it to work, you can probably just wing it. Virtually everything in Python works the same way in Ruby, with minor differences. You *can* iterate over a list in Ruby using a for loop, it's just not the way it tends to be done by veteran Ruby programmers. If you want your code to look like it was written by Ruby a Ruby programmer, your best bet is to look at Ruby code. Often you can find resources like [these wikipedia entries](http://en.wikipedia.org/wiki/Category:Programming_language_comparisons) comparing how common things look in various languages, to make the sorts of things you use look more typical of Ruby code. 
Learning the language is only half of it, figuring out the tooling is likely as big of an issue. Look up: * bundler * rvm * pry * rack * ... I'm sure there's more, but I'm drawing a blank.
[http://ruby-kickstart.com](http://ruby-kickstart.com) is an awesome resource for programmers. Make sure you go through the exercises on [github](https://github.com/JoshCheek/ruby-kickstart). This is what got me started and over the threshold of "getting it." Also, Matz's book, The Ruby Programming Language is great. Make sure you get the Ruby 1.9 edition. Good luck, it's a beautiful language that makes me smile every day.
I don't really need those things I don't think. I will be usinig ruby as a scripting language rather than developing ruby appliations.
[Why's Poignant Guide to Ruby](http://mislav.uniqpath.com/poignant-guide/) 21 comments and **no mention of _why**? What sort of world are we living in‽ Coming from Python myself, I never truly understood Ruby until I perused the Poignant Guide; Now I'm a die-hard Rubyist.
I don't plan on becoming a rubyist, or a die-hard anything. I don't really consider myself a pythonist. I think everyone should know a function language, a compiled iterative language, and a scripting language. The one I happened to learn was python, but now I have to switch to ruby. Well, I will still be doing most of my coding in C++ but my scripting will now be in ruby. Thanks for the guide though, I will check it out.
Need is of course contextual and subjective, but everyone can benefit from pry. [Pry](https://github.com/pry/pry) (and its friend pry-debug) are super useful for development and debugging of all kinds.
note that a few thigns in that comparison are flat-out wrong -- namely he doesn't understand the way ruby methods (and method objects) work.
I second this recommendation. I just finished reading through it and it's fantastic. 
bundler is useful for making it easy for users of your script (including yourself) to run your code on other machines
Eloquent Ruby Should give you the diff without being too much work.
Because the guy already identified as a programmer, and _why writes for.. artists, or newbies, or some shit. I liked his work, but I'm treating the OP like I would a colleague, not a non-programming uncle.
If you don't mind my asking, what is that you enjoy more? What do you miss, if anything? I'm a rubyist and was recently contemplating a Python job. Wondering how our reasons will compare.
djdonnell listed good resources for Ruby web programming. I'll give you a quick summary because I feel some might be relevant to you. The final decision is still yours **Bundler** Manage independent sets of ruby gems (standalone plugins). Useful for allowing different folders to use different gem versions. Script A may require an XML parser. Script B could use the same XML parser gem, but require functionality in a newer version that would break script A. **RVM** Automate using different ruby versions between folders. Nice way to ensure that ruby version upgrades don't break your old scripts. **rack** Standardized web server interface. Used across Rails, Sinatra and Padrino. I can see both RVM and Bundler being useful to you. Just my two cents
As someone a few months into learning Ruby, from a Python background, let me put this to the OP in Python terms: Bundler and RVM are your virtualenv and gem (RubyGems) is your pip/easy_install. One thing I'm not totally clear on, however, is when it is appropriate to use rvm-based gemsets as opposed to bundler bundles. So far I've been using bundler bundles for rails projects, but I've seen several rails-focused resources (in particular, Michael Hartl's railstutorial.org) suggest the use of rvm gemsets, which, coming from a Python virtualenv background, makes no sense to me why you wouldn't just use one Bundler bundle for each project, rather than some combination of bundler bundles and gemsets.
RVM is useful for maintaining different Ruby versions across different projects and for testing any given project against different Ruby versions. Ruby 1.9 introduced some new language changes and is still gaining traction at 1.9.2. Matz's Ruby Interpreter (MRI) 1.8.7 is comparatively mature, and there's a memory-optimized branch, Ruby Enterprise Edition (REE). RVM should be learned on an as-needed basis IMO, and the need will vary depending on what you're building. I think there's no point in learning a tool you'll use rarely, since you'll forget its functionality when you later need it (or its core commands/api can change). My company uses Heroku, which has introduced a new stack that uses 1.9.2. They've announced official support for it and deprecated their 1.8.7 stack. TLDR: it's a good tool to manage Ruby version transitions.
Ah, the old "If you can't read my style you suck as a programmer" argument. Awesome for teamwork. I'm not saying they're impossible to tell appart, I'm saying they're easily confused. So *in my opinion*, it reduces readability.
Pry is the iPython of Ruby
im in the same situation, but the other way around; i know ruby and am now learning python. what works for me is to just jump into a project and research the bits and pieces as i go. i already know what i want to do, so its just a matter of looking up python's syntax on the google as needed. the [stackoverflow](www.stackoverflow.com) community is very helpful.
Included toolset is better. Ruby's gem is far superior to python's pip. Also rake is excellent. I appreciate the true object-oriented nature of the language, and that there are no built-in functions. An example of an irritation with Python is sorted() vs sort(). sorted() is a built-in which can act on any iterable and returns a sorted list, but sort() is a list method that sorts the list in place. Contrast this with ruby, where I've just got .sort() and .sort!(), both array methods, very simple to use and remember which does what. I like the explicitness of methods ending in ? or !. Another issue with Python is the standard library -- things like urllib2 and subprocess. It's difficult to do anything without continually referencing the docs because it is all so overengineered. Luckily there is a movement around this and we have things like Requests now, which I have used a few times recently and it is excellent. But it will still be some time before the rest of it has clean, simple interfaces like ruby comes with out of the box. They say Python has only one correct way to do things; the trouble is figuring out what that one way is. From Python, I miss things like pep8 and pylint, because I appreciate the consistency they provide and I haven't really seen any analogs in the ruby world. I dislike that 'return' when returning a value is optional in ruby, but I do it anyway for explicitness (not sure yet how common this is). I also enjoyed Python's whitespace blocking, it just looks cleaner, but very trivial. On the other hand, ruby's optional () make it look much cleaner than python at times.
The Builder class is a good thing to read up on. 
I don't understand why you consider this better. In each case, calling include can be replaced with a method invocation. So when you invoke a method on N, it in turn just invokes the appropriate method on M. module M def self.m_ify(klass) do_something_to klass end end module N def self.n_ify(klass) M.m_ify klass end end class Foo N.n_ify self end Each of these are just ways of dispatching methods, with inclusion it is implicit, inaccurate, and poorly named. I don't see any functionality that it offers that can't be had by simply creating and explicitly invoking your own methods.
If it hasn't come to mind - you should probably still learn how to deploy a Rails application on a Linux server as you would with a PHP application (having them run side by side is usually not a problem except in shared server environments, I've seen). It'll be good experience - though I guess you could put this off until you've made an application. Congrats on finally getting a working local environment up.
Thanks… I might for experience sake deploy to a Linux VM, it would be good experience. I think this would be a bit easier than trying to do it on my Mac. Only time will tell.
Either you misunderstood him or you fail to understand ruby methods yourself. Would you care to elaborate? He states it's *his opinion* that a method without () should return the reference and not invoke it (as python does) instead of having to access it with a special operator &amp; I'm very much on the ruby side of this comparison, so I don't neccessarily agree, but nothing he says here is incorrect. 
it most likely is, to be honest. I don't know of any Macs used as production servers.
I don't get it, you ended up installing RVM anyways so what was too hard about rails s ? Or how would that mess up your php env
look for incron. Sadly ruby doesn't integrate (as far as I know) with incron but an incron daemon can run scripts.
https://github.com/nex3/rb-inotify - I stand corrected
This looks pretty great. Any word on affordability? I'd love to check out a conf but the $750 for RailsConf makes it impossible to do.
For me running 'rails s' kept creating errors due to the MySQL2 Gem not playing nicely with my local MySQL 5.5 installation. There are a few hacks for getting this to work however they were unsuccessful for me at the time. POW made getting up &amp; running enbelievably easy!
Pittsburgh is an affordable city, and this will be an affordable conference. At least, unless plans changed last time I talked to the organizing group. :) Most Ruby conferences are in the $100-$300 range, Railsconf is special.
Did you ever try SQLite? I know that it's not anywhere near production, but for most applications there shouldn't be any code differences when you decide to deploy.
Every learning resource I've found/used all use SQLite, but I didn't want to have to setup &amp; install another database and I'm way more familiar with MySQL.
It'll be cheaper than beer for a weekend's worth of partying ;-) Well, depending on where you live and what kind of beer you like.
I agree they're easily confused, but given what a disaster it is if you get it wrong, you really need to be paying attention to this. I don't know how many times I've heard from programmers that are just getting started "So like *every* character has to be right?" Yes. All of them. How many years of effort have been spent tracking down single character bugs? Thousands, at least. If you're liable to get it wrong, you can always put an immutable thing on the left side to trigger a failure instead of a reassignment like: `if (:foo = foo)` vs. `if (foo = :foo)` Personally I've taken to using a `case` statement even for single things because it makes it clear you're not assigning anything. 
A few high profile Rubyists have contacted SCRC about speaking, and SCRC has contacted a few potential speakers. I can't name names yet, unfortunately. In the event's first year, we want to focus on selecting speakers that are perfect for the target audience: people who have not previously attended a Ruby conference. That said, the format is yet undecided. There will be speakers, that we do know. Whether it will be all speakers or speakers + group discussions, etc., is still up for decision. **If you have suggestions for good topics for first time Ruby conference go-ers, feel free to post 'em in this thread somewhere or tweet at [@steelcityruby](https://twitter.com//steelcityruby).** The schedule will be out when the speakers are confirmed, but definitely by the time registration opens in May.
Personally, I'd find a decent command-line tool and shell out to it.
Take inspiration from the ImageMagick - RMagick pair and wrap something around ffmpeg, maybe ? [just googled: ffmpeg-ruby exists]
I think you are right, which is unfortunate because ruby is such a dynamic language and can do far more than server-side web scripts.
* guard - https://github.com/guard/guard &lt;- I like this one * watchr - https://github.com/mynyml/watchr * kicker - https://github.com/alloy/kicker
You're missing the point. Since you can't reassign `:foo` then you won't have anything erroneously being assigned. It's a fail-safe. You do that and you get an exception, not a mysterious bug you later have to track down. 
My primary reason was that the gem and library scene seemed to have more focus put into maintenance and usability compared to pip. I checked out Pep8 and PyLint, they look like style tools. Ruby doesn't have those as far as I know. I've seen some style guides on Github (in the form of Gists), but there certainly doesn't seem to be a de-facto one. This leads into returns, actually. One style Gist recommended separating the return value of some code with an empty line. In cases where it seems ambiguous, it recommends a return statement. I've seen the same recommendations on Coffeescript style--in particular, to use or not use returns at my discretion. Whitespace blocking is definitely a plus, IMO, as I've experienced it with Coffeescript (which also has optional parens...except for the case when you want to call a function with no params). Optional parents are one case I feel that the "explicit is better than implicit" guideline doesn't apply to.
Woops, I missed that in your original question. I've had to use gemsets in one specific case, but it was a godsend in that case. I was upgrading an old Rails app from 2.3 to 3.0. 2.3 was actually pre-bundler, but I was able to get it to 2.3.11, which would work with Bundler. In the mean time, RVM gemsets were useful, since I had no equivalent of Bundler before that. Even after I got Bundler installed, I had issues switching back and forth, but I can't remember exactly what the issue was. I would recommend using separate gemsets only when you run into issues switching between git branches with very different `Gemfile.lock` files (and even then, only when you run into issues). I think the other situation that comes in handy is when I `gem install` something in order to get the system executable it provides. For instance, the haml gem provides the haml2html tool. If I did the gem install in a 1.9.2 project without a gemset, then switched to a 1.8.7 project, the executable might not work. I've run into an issue like this before, but never did thorough testing or research to figure out why it happens. Gemsets fix the issue for me. I could use `bundle exec &lt;command&gt;` as well, but the Gemset approach has been easier for me.
Personally, I would just sink the time into setting up a solid staging environment. Also, if you're put off by Capistrano, there are many lighter-weight alternatives ([vlad](http://rubyhitsquad.com/Vlad_the_Deployer.html) and [deployml](https://github.com/postmodern/deployml#readme) come to my mind). Question for the greater Ruby community: Why must POW be written in node.js and not Ruby?
This makes me think of Betamax :&gt;
Wow, reinventing the wheel. Look into catch/throw.
Then don't code for them, but don't block them either. Like I said, why completely break your site just because some of your page is broken in that browser? This is just a half-step up from those old "you must have IE6 to view this site properly" JavaScript popups. 
This is the most misguided and stupid thing I've ever seen. It's not that difficult to make sites cross browser compatible. 
I asked the mods and they warned that it might get downvoted. I'm not sheepish, just be honest that I don't care if it gets downvoted because it doesn't hurt me in anyway.
Typical spammer logic.
Nice work! Nice name!
That's awesome, how 'bout you give me a quote to make our site work perfect on IE6 and then I will compare that to the revenue we loose by not supporting IE6 (and IE7 for that matter) and I am guessing you will LOSE You see if you feign support, you will have to actually support it and it's a hell of a lot harder than it sounds to make things work with older browsers even when using lots of helpers like jQuery. 
Well, good luck finding someone in the Bay Area. The demand is high and the availability low. I have been offered a number of jobs there (San Francisco, Palo Alto, etc.), but I grew up there and I'm happy to NOT live there anymore. In geographic areas like that, companies should start to consider telecommute workers more seriously. For programming jobs it can work very well, as long as the company is willing to do a little setup work. One of the oft-heard complaints is that communication is not as good with telecommuters. And that's nonsense. When it's done right, it can be as good or better. I've been doing contract work for a while (which is all essentially telecommute). But at my last full-time position, which was also essentially telecommute, the communication was far better than in a prior job I had, for example, in which I sat in a cubicle and could practically reach out and touch my co-workers. 
My skeptic tank is almost full. If you really didn't care, you wouldn't have said anything about downvotes, etc. and just posted the job opening.
Thanks for your support. :)
I appreciate your feedback. You're right, for some sites, it's not difficult to make them cross-browser compatible. In my app's case, it's more cost and time effective to support 97% of our users. For the other 3%, our app can't appear broken. rack-bouncer helps give those 3% the best experience possible given our time and cost constraints.
Well said. Also keep in mind that some browsers are really flakey with their jQuery support.
Thanks for your support. :)
&gt; Go ahead and downvote As you wish. Douchebag recruiters like you are part of the problem.
You should post this in the bayarea jobs subreddit. 
Glad you're spreading this message. I'm in LA, love ruby and friends, but am unable to find any exciting ruby opportunities in LA or outside of LA with option to telecommute. 
Useful functionality (somehow I didn't even know about the built in retry keyword, I've rolled it myself before with a block, Doh!) But disagree completely on monkey patching kernel, the first version of the gem did it right. Better to be explicit with the module include or namespaces module method-- so its completely clear to future readers where the code is coming from, and so you don't need to worry about method name collisions with something else. Too much magic is to much magic, to save a few keystrokes.
He had trouble setting up a *dev* env? I don't get it, what was wrong with 'rails server'? I agree that setting up an actual production env is more confusing for newbies than it should be (too many options), and those mysql problems sound like exactly the sort of Just Does Not Work problem I hate (although I don't think problems with mysql2 are common, wonder what was going on)... But problems setting up a dev env, or with dev env conflicting with something else on the machine? I don't get it, I don't understand what such problems could be.
So it sounds like this not being good with the newer mysql 5.5 was the real problem? Does POW come with mysql 5.5 then? Cause otherwise, if insisting on mysql 5.5 was really the only problem (not saying there's anything wrong with wanting mysql 5.5, that's legit) and you solved it by, well using an earlier version of mysql instead... I'm not sure that concludes what you think it does
What you should be doing is injecting a Warning banner at the top of the page (like stackoverflow's `noscript` warning to enable JavaScript). That way _unsupported_ browsers can still attempt to use your site. Also, I can see this being abused by developers who think everyone should use the latest version of Chrome; much like the days when websites would bounce FireFox and insist you use Internet Explorer.
There are a number of pieces of syntactic sugar that are present in Ruby that I wish Python had. In particular the /regex/i syntax and the &amp;:to_proc syntax. The corresponding syntaxes in Python are much more verbose, and only slightly more explicit. I also love the symbol type. Python has a lot of metaprogramming functionality that has to be special-cased in because of a lack of useful things like the Object#send and Object#methods and symbols: attrgetter, setattr, getattr, hasattr, etc. Also, JRuby is much faster and more current than Jython, which is a big advantage, since there are so many useful Java libraries out there. RVM, bundler and rubygems really blow virtualenv and pip out of the water. Not having to endlessly mess around with packages is almost worth the price of admission by itself. I also came from Python to Ruby against my wishes. I really want to love Ruby as much as I love Python, but it's hard sometimes. The biggest syntactic thing I miss from Python is significant whitespace, and a standard 4-space indentation. 2 spaces is too few to make block structure apparent, IMHO (I have pretty poor vision, which may contribute), and I find "end" to be a useless and ugly keyword. I really miss variables being public by default; adding variable names to attr_acessor has always struck me as pointless busy work. Python elegantly handles keyword arguments, which Ruby struggles with. While the syntax for the caller of the function is fine, adding keyword variables to a function is a pain. I like Python's simpler and more explicit scoping rules better. I don't think that there is a huge benefit to having to spell out @variables, @@variables, Variables, etc, compared with the extra complexity. Especially when there's no clean way (that I'm aware of) to do inheritance of class variables well in Ruby. I really miss bounds checking for arrays. Almost 100% of the time, when I try to set ary[n]=something and n&gt;ary.length, I have a bug in my code. I wish Ruby would let me know. Python and Ruby have a different set of packages available, and I mostly like Python's better. There are world-class Python packages for data mining (like numpy, scipy and scikits.learn) that just don't have anything comparable in Ruby. That said, I don't think there is anything nearly as good as Rails and ActiveRecord in Python, though I'm much more familiar with Rails than with Django. All in all, they're both excellent and innovative languages in their own ways, and they're both getting better all the time.
It depends which platform your targeting. There are a few Ruby Audio libraries for Linux. * [ruby-alsa](http://rubygems.org/gems/ruby-alsa) * [gstreamer](http://rubygems.org/gems/gstreamer)
Thanks for your suggestion. I'll certainly keep it in mind if our current model doesn't pan our like we hope.
If you want to do anything useful with ffmpeg without shelling out you have to reimplement the executable because they don't provide any high-level API. I've worked on such a wrapper, it sucks unless you really know what you're doing (and I don't know enough).
Alright. The first you need to know is the power of functions that can be passed around: twice = proc do |x| x * 2 end twice.call(2) # =&gt; 4 twice.call(3) # =&gt; 6 That doesn't seem so useful, but when you can pass around functions, you can abstract things: def map(arr, blk) res = [] arr.each do |x| res &lt;&lt; blk.call(x) end res end (I do realize that there's a block/yield inside the method, so this is kinda a recursive explanation, but just treat that one as a block box which just loops over the array) Now we can use our map-function to solve general problems: # Convert a list of integers to strings: map([1, 2, 3], proc { |x| x.to_s }) # =&gt; ["1", "2", "3"] # Double them map([1, 2, 3], twice) # =&gt; [2, 4, 6] This is a very powerful pattern (passing around functions). Now, what matz (who created Ruby) realized that *very often we want to pass in **one** function as a parameter*. There's a wide variety of methods which takes another (and just one) function. So he made a special syntax for it: def map(arr, &amp;blk) res = [] arr.each do |x| res &lt;&lt; blk.call(x) end res end And now we can call it like this: map([1, 2, 3]) { |x| x.to_s } map([1, 2, 3], &amp;twice) *Blocks* in Ruby is just functions that you pass along to methods with a special syntax. Semantically, there's *no difference* between `map([1, 2, 3]) { |x| x.to_s }` and `map([1, 2, 3], proc { |x| x.to_s })` (other than the syntax and how the method is implemented). Then matz realized another thing: Very often we're not really interested in storing the function as an object (and pass it along); we just want to call it: def map(arr) res = [] arr.each do |x| res &lt;&lt; yield x end end So `yield x` is just the same as `blk.call(x)`. It runs the block (which is just a function that's passed with some special syntax) and returns its value. And some notes on terminology: Ruby doesn't have the concept of "function", but I've used it here loosely for "some piece of code that you can run with some arguments". In that case, a *method* is a function defined on a class (which gets invoked on an object). "bob".length runs the `length`-method in the String class on the `"bob"` object. A *proc* is "function as an object" bound to wherever it was created (it share its local variable etc). While a method creates its own local scope, a proc shares it with its context. A *block* is a syntactical thingie (`do … end` or `{ … }`) which lets you pass a function to a method. It's kinda like the same as an `if`; you can't store it in a variable - it's just syntax. Running `yield` calls the block passed to the current method. `def foo(&amp;blk)` captures the block into a proc. `foo(&amp;blk)` passes a proc called `blk` as a block to the `foo` method. --- Not sure if this helps or just complicates everything. Maybe the best thing is to just try things out…
A Proc isn't bound to an object. You can easily create one, pass it around, call it, change its context (see #binding) without even having to know where it originates from.
that is great, let me reread this a few times. I really appreciate the in-depth answer, judo
i see. what might be a real world scenario for this?
Those `save` calls return either `true` or `false` according to the success or failure of the operation. Compare with `save!` which pops an exception instead.
Thanks, glad they were helpful :)
Because blocks and procs can see their enclosing environment (can access local vars and methods on your current object). Also, it makes for a much nicer interface when dealing with ad-hoc needs. For instance, what would the interface look like if you wanted to convert `["1", "2", "3"]` to `[1, 2, 3]`? Write the code that would do this with methods (even if it assumes array interfaces that don't exist). Then write it with blocks. Which is easier to understand?
I wrote an article explaining an aspect of yield that might help. [Anonymous Blocks as Function Arguments in Ruby](http://rakeroutes.com/blog/anonymous-blocks-as-function-arguments-in-ruby/)
I have a web scraping script that takes a url and three procs as parameters. The the url is the address of the first page I want to scrape, the first proc does the scraping and returns the data I want to save, the second proc returns the url of the next page to be scraped, and the third proc returns false when I have reached the last page to scrape. This sounds a bit complicated but what it means is for each website that I want to scrape I just have to write three simple functions and I can store each set of functions in a hash. I have a base scraping framework and the website specific code has been extracted into procs.
Beautiful work man. Can't wait to deconstruct it.
Why certainly! DataMapper should not conflict with ActiveSupport / ActiveRecord. You would still have to define separate DM and AR models.
These cost money, but it's been hands down the best explanation I've seen of how ruby operates when dealing with these types of patterns. http://pragprog.com/screencasts/v-dtrubyom/the-ruby-object-model-and-metaprogramming It not only explains how they operate, but it explains WHY they operate that way. When you begin to understand where your self currently is and how to invoke metaclasses, etc it really gives you a good idea of what to expect when implementing these things.
very nice project. I use this skeleton for my sinatra apps - https://github.com/oren/sinatra-template it has the following: * Modular Sinatra app version 1.3.2 using ruby 1.9.3-p0 * capybara + minitest for integration tests (no need for rspec) * minitest for unit-level tests * rack-test for routes tests * yard for documentation 
what is ":pass_param"?
I'll vouch for it. Not only is it awesome to use in development (e.g. locally), I have it set up on our staging server as well to catch all mail from pre-production. Our testing team loves it. DEAD simple.
exactly this
Of course, *after* I've paid for MockSMTP I find this. Not that it wasn't worth the money, but I *did* look for exactly MailCatcher before buying it. That being said, from the little testing I've done MailCatcher looks very good indeed.
Thanks for adding this. I've been playing with Sinatra and Datamapper as a backend for an iPhone app. Although this is for HTML5, It is nice to see what others do to get started. 
I wish more DSL providing libraries did exactly this.
Awesome, I really appreciate the clarity on shell code.
 print `clear` works nicely without throwing the error. Thanks. For the record i wasn't looking for so much the how this should be done as the why this behaved this way. More of a curiosity I encountered in irb.
Hmm interesting. What was confusing me was the fact that `\e[H\e[J` *did* clear the screen (minus ": not found"). Using " print `clear` " works nicer as pointed out below.
 Everything works when i go directly to the port address, but when i set up a reverse proxy through cherokee i get a 500 error :(
&gt; What's the RAILS_ENV you're trying to run the server under? &gt; Have you precompiled your assets? &gt; Have you migrated your database in production env?
 Search this subreddit button ^ | | ---------------&gt; Sidebar with links Welcome to the subreddit!
Ugh, I flubbed the release, so 2.2.1 is out now!
Execute `notacmd` in ruby, and your shell will say: notacmd is not a command, or whatever. When you put that binary stuff in backticks, the shell responds by outputting blah is not a command. But when it outputs that same binary stuff in the error message, the terminal sees it and interprets it as a command to clear. That's why you just see the final quote and command not found. 
It should run on 1.9.2 as well. let me know.
[Learn Ruby The Hard Way](http://ruby.learncodethehardway.org/)
Also check your city for good meetups. Ruby seems to have a lot more functionally meetups than most other languages I've worked in.
I'm not your guy, buddy.
I am learning ruby as well, and I am using *Why's Guide To Ruby* and a book called [*The Ruby Programming Language*](http://books.google.com/books?id=jcUbTcr5XWwC&amp;dq=editions:S6BSldfzFfwC) (if you are going to buy this book, don't get the ebook from google books; it is DRM'd and you can't copypasta code). I really didn't truly understand ruby until I tried it out. The books mostly teach you about the grammar, but not a lot about the standard library. I started solving [Project Euler](http://projecteuler.net/) problems, and this is where it all came together for me.
The Bastards Book of Ruby. http://ruby.bastardsbook.com/ Awesome and with fun projects.
Upvote for lots of links. Just a tip, think about using []() to tidy up your post. See formatting help below the text area.
thanks, I don't post much so I'll take a look
I found this to be a useful tool to practice ruby. Once you get the broad strokes I would go through this learning game. https://github.com/ryanb/ruby-warrior
I'm also continuing development of \_why's [Hackety Hack](http://hackety.com), which teaches people how to program via Ruby. (He's the author of the Guide and the original TryRuby)
I'm not your guy, pal!
I'm not your buddy, guy!
if only pry_nav didn't say "can't work with multi-threaded apps." and a bunch of those extensions are marked "experimental, many known bugs." pry is neat, and when mature will be better than ruby-debug. But I still really really miss ruby-debug working with out of the box 1.9.3. If pry can do it... ?
I'm not your guy, friend!
I just released a new version. Adding timeout and refactoring a lot of it. I also made including it in Kernel optional. If you want the non kernel included version, just: gem 'retriable', require =&gt; 'retriable/no_kernel'
Thanks for the suggestion. Is this available in PDF form? So I can remember where I am up to? EDIT: ah found it.
Thank you for the advice :)
We literally have [another thread on the front page right now about this](http://www.reddit.com/r/ruby/comments/po8lw/hey_guy_i_am_just_starting_to_learn_programming/), so you might want to check it out.
did you build the site that's hosting the online version of the book or is that an app/service that's available somewhere?
Awesome, thanks. For several of my projects, I need multi-threaded support though, and pry_nav as a replacement for ruby_debug is what interests me. I wonder what the problems are with ruby_debug working on 1.9.3, that some things on the web suggest are problems hard to fix without changes to 1.9.3, but that pry_nav manages to avoid. hmm. 
Pyflakes has a much better precision than pylint at catching bugs. It has a limited set of bugs it can catch, but it's decent at finding them and not much else Pep8 is a style tool; pylint has a lot of style tips. You can disable them, but it's a pain. I use a Textmate bundle to run pyflakes whenever I save a .py file, and it's a minor productivity boost.
Adient, came back to this thread just for you. Went through the LASER docs today, which is a static ruby analysis tool with some extras. I haven't had a chance to use it yet, but thought you might be interested: https://github.com/michaeledgar/laser Quote: 2. Style Fixing - There are many style no-nos in Ruby. LASER can find them and fix them like similar linting tools for other languages. 3. Common Semantic Analyses - dead-code discovery, yield-ability, raise-ability, unused variables/arguments, and so on. 
How is this going to be different from The rails tutorial? 
I learned to program ruby by using ["koans" from Edgecase](https://github.com/edgecase/ruby_koans), the company who made them are right down the street from me, and I feel like I learned faster by getting my hands in code from the moment I started. Just clone from their Github and it'll tell you how to set it up.
I been using RubyMine since version 2.0 and loving it. I wish more Ruby and Rails developers would give it a chance. If you do, try out the refactorings, they are great!
This isn't to do with scope resolution; your second code snippet defines an instance method 'mike' on objects of class Baz, rather than a class method 'mike' on Baz. So you could either do: FooBar::InnerFooBar::Baz.new.mike or change your code to read: module FooBar module InnerFooBar class Baz def self.mike puts "4" end end end end and use your original method invocation.
I agree with this sentiment. Except :%s/Aquamacs/MacVim/g Seems like a great occasion to fan the flames of the Editor Wars! :-P
Like mortice said, in your second example, mike is an *instance* method. If you want to be able to access constants from a class or module, you'll need to use the double-colon operator (the Pickaxe calls it the scope operator, C++ called it the scope-resolution operator, take your pick). FooBar::InnerFooBar::Baz::Mike # 4 FooBar::InnerFooBar::Baz.mike # call to a class method FooBar::InnerFooBar::Baz::mike # equivalent to previous Note that, for a class method, the second and third examples are equivalent. For accessing constants, only the third method will work. If you want your second example to work properly, you'd have to do something like this: FooBar::InnerFooBar::Baz.new.mike # 4 As a bonus, remember that the scope operator is a unary operator. You're used to seeing the scope operator between constants but you can also use it at the front of a constant all by itself. You see this usually used to be sure that the scope you're trying to access is the top level scope instead of an (inadvertent) call to a nested scope (because Ruby will search up the class hierarchy for the constant you are using, unless instructed otherwise). As an example, say your library uses the constant ActiveRecord to encapsulate all your ActiveRecord changes. To make sure calls to Rails' ActiveRecord resolve properly, you could do this: ::ActiveRecord::Base This ensures that you are accessing the ActiveRecord in the outermost namespace.
I don't think anyone will argue that it makes you 20x more productive. I don't think anyone will even argue that it makes you 50% more productive. My main problem is that I use a MBA which maxes out at 4GB. Using more than 600MB is a big deal if I only have 4GB. 
Does it support any form of remote server yet? I develop in a VM, but RubyMine only really works if you have your entire dev stack running locally. Their PHP IDE, PHPStorm has wonderful support for this setup including mounted network shares (which is what you would use if you had your dev environment in a VM) so it's kind of weird how it doesn't seem to be a part of RubyMine.
In regards to the book teaching Ruby on Rails it won't be different since those are the same goal. It will however be a different application, author, process, and cover other topics not covered in the Rails Tutorial and that should be enough to justify its existence. Also, this book is free in many different formats. I've written a little on the frontpage about why I'm doing it if you're interested. Thanks.
Are you _trying_ to start a flame war? But puts et al should not be colored differently. They're just method calls, why should some method calls be colored differently? But gedit will work just fine. If you think it's inadequate, try something else.
&gt; easily open code from gem dependencies I know it's not quite the same, but `gem install gem-open`. This lets you do `gem open sinatra` to open that gem in your text editor.
Not an actual RM user, but speaking in general terms, an IDE will do a lot of "tasky" stuff for you. Finding function definitions in other files, syntax, auto-completion, changing variable names or massive code rearchitecutures, that sort of thing. It means you have to learn a different set of skills, so you need to know all the magic to make the IDE do these things for you, vs knowing the magic in the plugins or extensions for your editor to do (some of) these things for you. Personally I'm a vim only guy, but I've used IDEs in the past and once you get past the learning curve, they are great, *if* they work the way that works well for you. Nothing worse than a great working IDE that does things the opposite of what you expect :)
Does it *still* do that?
Learn to Program by Chris Pine There's an online version and a book version. Incredible book.
Awesome, thanks for this! I'm a Vim/Janus/Terminal guy myself, and have a hard time justifying putting time and effort into learning an IDE when my current workflow is fast enough for me, and I have no pain points when using Vim.
&gt; Maybe it is just me but this feels cleaner. I treat instance variables in my specs as a smell and you should too. But what's the problem indicated by the code smell? They may not be completely identical (let being lazy-evaluated) but they are functionally identical.
Sublime 2 (best editor on the planet) :)
It's all in good fun these days, but the editor wars even have their own [wikipedia entry](http://en.wikipedia.org/wiki/Editor_war)
I want to be in this IRC chan. 
Or (should) already use Bundler. The functionality is one `bundle open sinatra` line away.
Hey man, haven't you heard of The CLOUD?! Hardware limits are a thing of the past now, get with it!
Certainly interesting, but it's essentially just GET requests and OpenStruct (which, I have on good authority, leaks memory terribly, thus my decision to use plain structs). Wrapping the reddit API involves a good deal more functionality, in that returned objects are susceptible to further manipulation. While the object setup is certainly the code I'm least happy with, I do think it's a very effective approach. I'd much rather declare the object's kind once there as an instance variable, rather than having to use `self.class.to_s.split('::')[1]` inside of all of the Actions module's methods, which just strikes me as inefficient. Admittedly, that code isn't very DRY, but I really like that no matter how complex the wrapper gets, it'll pretty much just be a matter of choosing the right combination of path and fields to look for when constructing a new object, and then adding the new functionality to Actions. The objects are different enough from each other that they pretty much have to be declared separately, and the rest of the code has to know what sort of object it's dealing with; what makes more sense than an instance variable? Just for future reference, Net::HTTP uses URI internally, so no need to explicitly require it.
I've got a license, but I think it would definitely be a time/productivity sink. Maybe I'll give it a shot when my workload eases up. Their vim keyboard support would be great if I wouldn't have to hit ESC 1-7 times to leave insert mode....
Absolutely, it's a much simpler API. &gt; Just for future reference, Net::HTTP uses URI internally, so no need to explicitly require it. Word. I try to require everything that I use explicitly. I doubt that Net::HTTP will ever _remove_ the URI dep, so leaving it off would be okay in this instance, but I find it a good rule of thumb.
That is weird. I use PyCharm, same code base, and I doesn't spike like that. I am at around 60MB.
I'd gladly give it to you if my company didn't pay for it!
I haven't had any problems with it.
TextMate
Pry itself works fine, however some of the newer plugins wont work on jruby -- like pry-stack_explorer and pry-exception_explorer. I would love to support jruby properly (and rubinius) but we just dont have the resources to do this at the moment as our core team is very small (about 3 people). Basically to get some of the more advanced plugins working on jruby we will need a jruby (and rubinius) version of the [binding of caller(N) project](https://github.com/banister/binding_of_caller) project. I'd also like to backport binding of caller to ruby 1.8 too, but again this is a big job and i think for the moment my time is best spent elsewhere. 
I use redcar. Written in Ruby itself. Overall it works pretty well. I just started using it recently. There are some bugs and quirks but being written in Ruby means you can easily fix it and customize it.
It still quacks. :) This usage does look elegant. Thanks for helping us learn something new.
&gt; Their vim keyboard support would be great if I wouldn't have to hit ESC 1-7 times to leave insert mode.... That is my biggest problem with RubyMine, believe it or not. I got around it by making a RubyMine specific hotkey in [Quickeys](http://startly.com/products/quickeys/mac/4/) (a hotkey program for mac os) that types five escapes when you press control+[. You could do the same with [autohotkey](http://www.autohotkey.com/) for windows or [xautomation](http://hoopajoo.net/projects/xautomation.html) for linux
`productivity / memory usage` isn't a very useful metric. If you have the spare RAM, there is minimal difference between a program that uses 600MB (eg RubyMine) and a program that uses 10MB (eg vim). So even if the RubyMine only increased productivity by 5%, it would be worth using over vim if you had the memory.
This. How much would it cost in dollars to buy the extra ram versus how much time RubyMine might save you would be far more interesting. 
I'm not a convert, but I'm an IDE advocate for lots of reasons. SCM integration - I use Subversion for everything and the integration is great. RM also supports Git and Perforce. I can see line by line as I'm editing code, exactly which lines I've changed. I can even right click on the indicator to see what the code was before my edits. Autocomplete - haven't seen a text editor yet that can do it. I tab complete just about everything. Click-through - hold control and click on a method call and go to the definition of that function. Refactoring - It's incredibly easy to rename methods and variables and perform other basic refactoring tasks. Find usages - Do you want to get rid of a method because you refactored it or because you want to deprecate it? This will scour your code and tell you where you're using it. Testing - I can run Spork and rspec in my IDE and get detailed reports of all my tests that passed and failed. If a test failed or threw an exception I can click on the console output and it will take me to the exact line of the test that failed. I didn't have to switch to another window to run my tests, it's all in the IDE. I can also right click on a test and run or debug just that test. Debugging - I keep my app running in debug mode all the time. Any time I see something fishy in my browser, I add a breakpoint in the code and can evaluate statements and add watches. I can then step through my code line by line as you'd expect from a normal debugger. In general, it's pretty standard debugging but that's why it's great. I don't know of any other rails debugging utility that does it as well. Contexts - We use JIRA for issue tracking and I have RM connected to JIRA so that I can create contexts for issues that I'm working on. It's nothing too fancy, it creates change lists for SCM and a session of open files but it's really nice when I'm in the middle of working on something complicated and I have 8 different files open and a new issue arises that I need to fix or troubleshoot. I can switch contexts quickly and easily and I don't have to worry about losing the state of the current task I'm working on. I will be honest though, emacs is my *nix editor of choice, so I don't know squat about vim, but from my experience, an IDE is a whole other monster that in my opinion allows me to get more work done faster.
The best free IDE for ruby, IMO is Netbeans. Most often though, I just use gedit because it's fast and easy. I'm mostly a scripter for server tasks though, than a full-blown programmer. Gedit should also highlight 'if', 'def', 'end', constants, global variable, instance variables, comments, and maybe a few other things but really there just isn't a whole lot that needs to be a different color. You can google for something like "ruby on gedit" to get ideas for tweaking gedit, although I tried adding like a console and file browser pane, but I realized if I want to get that fancy I'd rather use Netbeans, and keep gedit simple for when I want something simple.
Start with [Learn to Program](http://pine.fm/LearnToProgram/), then [Learn Ruby The Hard Way](http://ruby.learncodethehardway.org/book/) and/or [Ruby on Rails Tutorial](http://ruby.railstutorial.org/ruby-on-rails-tutorial-book). The great thing about Ruby on Rails Tutorial is, even if you don't care about Rails or web programming, it teaches some fundamentals like using Github and git and writing tests. You'll probably also pick up some more ruby programming from it. I also like all three of the above sites because they have exercises for you to do on your own, which I feel really solidifies the learning.
Out of curiosity, what do you think about remote development with a VM? Some of my managers at work have brought it up as a possible, future development platform. The face of it seems outrageous to me, given my experience with remote-desktop (over wan &amp; sketchy lan), and virtualized desktop environments. Any serious wins from your perspective that make development on a VM worth it to you as a developer?
One way around the kind instance variable would be to break the modules apart into groups that are more related. If it's a generalized method that works with everything, that's one module. If it only works with a single class, rip out and put in the class. If it works with a handful of classes, maybe it's a single method module. This smells a little still, but I think it's better than checking @kind. It's OK to include more than one module. Think about it this way, too. In checking @kind, the instances end up checking themselves to see what kind they are. But an instance already knows what it is! It's kind (excuse the unintended pun) of like asking a person "Are you a male? But are you really sure you are a male? Can you check for me?" A reasonable person will answer "I don't need to check" Another way you could handle shared actions is to access them through an action instance inside the objects. The Action module could mixin a class method for white/blacklisting the methods, which in turn proxy to the action object. That way the object itself can declare what methods it wants access to, and you don't need to do kind checking in your module. One of the problems with code like the kind check is that it violates the Open Closed Principle; specifically, when you add a new object type, you have to run through all the places you do kind checks and add to the list. That change should be handled in the newly declared class itself. Hope this helps.
I've been using RM for about 6 months now. I typically do development in an IDE, but I'm also a heavy vim user, such that it pains me to work without vi keybindings. (Fortunately, RM has such a plugin, however buggy it is at times.) I'll concede that a lot of what RM gives you, you can do with other tools and a bit of learning. The advantage of RM is that it's all under one roof and you don't have to learn the syntax of several different tools and how to execute those tools seamlessly from within your editor. It also gives huge gains when you're editing layered documents. It picks up on html syntax within javascript strings (...within html within erb, if you dared to write such a file). It's the only IDE I've ever found that you can request the function definition and actually be brought right to it. It manages a lot of little things for you, so you quickly spot unused variables, undeclared variables, small structural or logical gotchas you might 1-in-50 otherwise miss. It manages whitespace so you don't end up with tabs/spaces confusion, trailing whitespace, or other annoyances. These aren't things I typically have problems maintaining, but it's nice to have someone watching my back for the little stuff so I can focus on what I'm working on. Basically, I use it because it simplifies a lot of learning you'd have to do in other development environments and makes the code feel much more connected than when editing in vim. Navigation just feels smoother and the code tends to be a bit cleaner. I still use vim for scripts or files that tend not to be hugely interconnected, but for big projects, I'm okay with using a big IDE.
Last thing, I swear ;) Another thing to consider is how the actions raise RedditError in places where a method is not useable for a given object instance. Consider this, what would you expect to happen if you called 1.downcase ? OK anyway, enjoy your ruby, and may github stay up for you today.
Here's a link to the downloads for [1.8.7-p358](http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/393484).
http://lte.soup.io/post/232049272/http-www-ruby-lang-org-en-news
And still no ruby-debug19 that works. Sigh. =/
That's too bad, that was the one issue I was having.
I would advise against it if you're running VMs. I used to have only 4GB on my 13-inch Macbook Pro and it was painful whenever I wanted to run a couple of VMs (using Vagrant/VirtualBox). Maybe wait for the next (Ivy-Bridge based) MB Air? It will probably support adding more RAM (I hope!). If it's not an option, a 13-inch MacBook Pro?
Hmm, anyone know if this 1.9.3 release includes any of the performance-related patches that have been floating around the net lately? Grepping through changelog for 'performance', it doesn't _look_ like it does, although I did find this one that may or may not be relevant to my multi-threaded app: Fri Apr 29 10:07:13 2011 KOSAKI Motohiro &lt;kosaki.motohiro@gmail.com&gt; * thread.c (rb_mutex_lock, lock_func): Avoid busy loop and performance regression. bm_vm3_thread_mutex.rb performance change from 109.064sec to 16.331sec. [Feature #4607]
yeah, sounds kind of scammish. this (or the 'Ruby Association' in general) isn't something that most of ruby community (in the US at least?) have heard of. If you have your own reason to believe it will impress some (potential or current) employer and get you hired or more money, that may be. But don't assume so automatically, I have no idea. 
For the stuff I do in ruby, it would be more than adequate. I mean, I was using a netbook for ruby not too long ago. But then again, I don't use a heavy IDE or anything, just vim.
If the guys at 37signals can do it, so can you.
I dont have problems running a windows xp vm on my 2gb MacBook Air. Only one generation old. I use it for primary dev and upgrading to the new one soon. 
Ruby 1.9 has a built-in debugger: require 'debug'
i have found an answer and its ERB
I have that MBA a primary dev machine, but I don't develop iOS, so I don't run xcode, which I hear is a beast. Generally I have 3-4 rails servers running, consoles, textmate, browsers etc... Maybe a single VM at a time - none of that has really slowed me down. I recommend it unless xcode kicks you in the balls.
I program ruby and iOS on a machine with 2GB. I usually have entirely too many terminal windows open and I rarely close a browser window. xcode hasn't given me any problems yet. The only problem I have run into is actually with firefox where I occasionally need to reload it. Disclaimer, I code almost exclusively in VIM (I only open xcode when absolutely necessary) and never run VMs.
I dont really use VMs. Im not a fan of waiting around for Apple to update hardware. I will be making this purchase in the next week or two.
Thanks for the insight.
I have the model right before the latest and it does great. The SSD makes it nice and zippy. I also have no trouble running Xcode and compiling projects. I'd say it's definitely worth it. I work from an iMac while I'm at work, but I do all of my work I take home and pair programming and code review/refactor sessions with that.
Nice. May I ask how much ram you have? I'm assuming 4GB.
Then by all means buy one. Apart from the RAM upgrade issue (a minor "problem") it's the best laptop computer currently on the market. :) I plan to buy one myself when my perfectly good mid-2010 13-inch MacBook Pro dies. :) 
I bought the i7 11" air a few days ago. So far its worked fine. I haven't noticed any significant difference between it and my work laptop (a 17" Macbook Pro with 8GB of RAM). The Air actually seems somehow snappier, which I guess is the SSD.
Yep. Here are the specs: - 13" - Core 2 Duo @ 1.6GHz - 4GB (2 x 2GB) RAM @ 1067MHz - NVIDIA GeForce 320M Graphics chipset - 128GB SSD (With all of my code, Xcode, and RVM, I still have 67GB leftt) I would highly recommend this laptop. The newest model is even better than this, so you should really be in good shape. Start-up times are great because of the SSD. I only have a 128GB SSD and that has been perfectly sufficient space-wise. Me and another developer at work got this same laptop at the same time. I do mostly Ruby and PHP development and some iOS and Android work. He does mostly iOS and Android and a little bit of PHP and Ruby. He works primarily from his Air, reporting that it's often faster than his Mac Mini thanks to the SSD. He does tons of iOS compilation just from that. We also keep all of our regular applications in memory and they do just fine (Vim, Terminal, Chrome, MAMP, Office Communicator, Outlook - all at the same time). If iOS builds ever get too heavy for it, you could always do a distributed build if you're in an office with other Macs. The super light weight makes it awesome for meetings and taking home. The only thing I would caution you on is the keyboard. It's obviously going to be just a little bit smaller, but it's not really a big difference and it's quite easy to get used to.
I use it often, but only using the assigned variable within the statement. It should be treated exclusively as a local. It is also useful in ternary operators.
Yes, I am and have been for two months. 13" i7 4GB 256GB. I do Ruby, a little iOS and Android, and a few other esoteric things. Love it. Best laptop I've ever had by a country mile.
It's definitely the "ugliest" part of the code, and I did it primarily for the sake of simplicity. I realize that putting everything in a single module and then filtering is a bad idea, though, and will be changing it. `if !` is a byproduct of my previous languages; it's just a matter of getting into the habit, but thank you very much for my third reminder. As for @kind, I would very much prefer to just keep all of the API paths abstracted out into a single hash and then use the correct URI depending on the context, but to do that‒at least at the moment‒I have to have some way of telling the method which one to grab. The `comments` method, for instance, can be used for several different *kinds* of objects, and a different path key must be used to grab the correct URI. The only options that seem to be available are explicitly setting an instance's @kind, or figuring out the kind at the top of every relevant method. As I mentioned, I'd much prefer setting it once for each class as opposed to: kind = self.class.to_s.split('::')[1] being used in every single method. Perhaps I'm missing something?
It's horrible. I'm so glad I'm not the only person having this problem. I fixed it with some weird combination of things. I made a comment in my source about what I did, so if you're running into issues, you should try this in your Gemfile: # You may need to type this into your shell for ruby-debug: # bundle config build.ruby-debug-base19 --with-ruby-include=$rvm_path/src/ruby-1.9.3-p0 # Source: http://stackoverflow.com/questions/8087610/ruby-debug-with-ruby-1-9-3 gem 'linecache19', '&gt;= 0.5.13' gem 'ruby-debug-base19', '&gt;= 0.11.26' gem 'ruby-debug19'
+1 for perfect nickname ;D
Disclaimer: I really have no idea what I'm doing as far as testing/versioning my gem goes. I'm hoping for some community enlightenment. 
Unfortunately I have experienced two crashes today which resulted in loss of work, something that has never happened before with RubyMine and which has seriously shaken my confidence in it. I can't recommend it at this point. The debugger is also simply awful. I realize that some people write perfect code that is tested inside and out but my work deals with lots of web interaction that can't be fully anticipated. Basically, it causes crashes and odd bugs in the code that don't exist outside the debugger.
Matz appears to be on the Board http://www.ruby-assn.org/en/about.htm 
very nice! I always enjoy the OEIS when I'm dealing with any kind of sequence :)
The only way to answer this question is to ask one: Why do you want "the latest Macbook Air"? If it's because you're constantly on the move and are willing to give up power for portability, you'll get different answers than if it's because you have some extra money and think the latest MacBook Airs are cool. Not that there's anything wrong with that.
Because I'm in need of a new macbook. The Macbook Air's looked nice so I figured I get others' opinions before I make the purchase. 
The funny-falcon GC tuning patch was integrated.
we use this at work for our UI documentation. works as expected.
That's completely wrong. Not only is it doing http requests but it's mapping them to objects. What if Reddit changes the API? Without having a human **MANUALLY** validating it, you don't know if it works or not. Testing your code helps you find more bugs, prevents bugs, and can even act as a guide on how to use the code. Adding tests to your project is trivial. Especially for one small like this. I recommend you add tests if you want anyone to take it seriously.
It's highly unlikely that they'd do so in any destructive manner and the fact that I run a bot constantly pretty much performs the same function as testing, in that I would know of any major changes almost instantly. Rest assured, I completely understand the utility of testing and use it in any large-scale project, but snooby‒at least in its current form‒seems perfectly covered by the fact that I'm *constantly* supervising it.
Thanks, exactly the advice I was looking for. I'll be making some changes to it later today, and I'll be sure to check out semantic versioning. Can you recommend a good way to test the gem? Right now I keep uninstalling and re-installing with changes, then playing around with it. Obviously this is the wrong way to go about doing it. 
That clears something up for me, and might be a point of clarity for others, but if that works for you, ok.
That's what an external monitor and keyboard are for.
[:\)](http://www.emotasia.com/wp-content/uploads/cute-octopus-emoticons-pb-4.gif) 
I know several people that use the 4GB version and it works fine for them. The SSD makes it quite snappy compared to a baseline MacBook Pro.
Absolutely correct. Every uncaught exception represents a case where the programmer did not sufficiently account for a given state (in all likelihood based on unanticipated user input). As innocuous as the error may seem at the time to the programmer, this is all that's needed to open the doors to building a turing-complete weird machine entirely out of unanticipated behaviours. [Here](http://esec-lab.sogeti.com/post/Analysis-of-the-jailbreakme-v3-font-exploit) is just one example of how it's done.
I was looking at it as a way to offer the gem user to change some error types from an exception to a warning or to silence them completely. For Instance, If a config file is not at the expected place, some people might be satisifed with a warning, some people might want an exception, depending on if they are using that file or not. it means I don't have to write code like this everytime I raise an exception that the user of the Gem might or might not want to cope with. def some_thing #... rescue MyModuleError =&gt; e raise e unless e.ok_to_ignore? warn e.message unless e.ok_to_ignore? == :silent end I'm not at all attached to the idea, just something that occurred to me.
&gt; I was looking at it as a way to offer the gem user to change some error types from an exception to a warning or to silence them completely. That sounds like the wrong solution to the problem. There may be "bad apple" libraries, that throw exceptions when they shouldn't. The solution to that should be fixing the library in question. If the library isn't, in fact, buggy, the code should handle the exceptional case — never ignore it. &gt; For Instance, If a config file is not at the expected place, some people might be satisifed with a warning, some people might want an exception, depending on if they are using that file or not. I don't think that's a very good example. A well-designed software solution most often has sensible defaults without a configuration file, if the file is missing, but if the software *does* require a configuration file, and cannot function without one, you most certainly want an exception. Half-baked requirements are not helpful. :) &gt; it means I don't have to write code like this everytime I raise an exception that the user of the Gem might or might not want to cope with. def some_thing #... rescue MyModuleError =&gt; e raise e unless e.ok_to_ignore? warn e.message unless e.ok_to_ignore? == :silent end Code like that is a *huge* "code smell". Dirty hacks happen, but if you find yourself doing stuff like that often, you most likely have way more fundamental problems in your code, which should be dealt with instead. :-) EDIT: grammar and politeness.
Coded JS, c++, java and python on an air for 3-4 years and I loved it. Only switched to a mbp because of VMs.
If the program can't run without that config file, it's absolutely ok to throw an exception with an error message explaining it, causing the program to end. Warning's are for cases like "hey, I can run this, but unless you do XY it won't have result Z", and don't forget ruby actually has a [warn](http://apidock.com/ruby/Kernel/warn) method built in to print to stderr without exiting
that's a very comprehensive answer yozzy, nice work
I'm genuinely surprised by all the vim love. I only know vi well enough to get out of it. I should give it another look. +1 for TextMate though, if you're of an OSX persuasion. 
Pretty much the only time you want to swallow and ignore an exception is when dealing with a poorly-designed API. There are a handful of other *exceptional* cases where you might consider swallowing exceptions, but making an API for it seems like madness.
Gedit is totally fine, but at some point learn vim or emacs. I use vim, but learning vim or emacs is totally worth the intial learning curve.
Offhand I can't think of any exceptions in Ruby that I'd like to ignore. I've worked with some C++ code that will throw an exception at the drop of a hat, but in Ruby they seem to be a bit more critical. This seems like a solution to a problem that rarely, if ever exist and could be solved ad hoc.
What did you bait it with?
4GB is more than plenty. What are you running besides rubymine that's taking up GBs of RAM while you're coding?
I had the same problem, make sure the network drive is mounted before opening rubyMine.
I converted a year ago to PHPStorm and Rubymine, they are both great IDE's PHPStorm 3.0 saved me a lot of pain with the remote deployment feature, so long FTP I know can promote changes from my IDE. RubyMine is adding new features as well that I'm waiting to try. 
One review I was reading mentioned that the i7 upgrade did add about ~20% performance increase for the 11 inch model. Source: http://www.anandtech.com/show/4554/apples-11inch-macbook-air-core-i7-18ghz-review-update/2
Yeah. Probably the same review I read. Said the upgrade was significant (15-25%) for the 11" model, but minimal (as I recall 5-10%) for the 13". Most of the gain seemed to be in advanced graphics processing such as 3D games. Overall, recommended upgrade for the 11", but not for the 13" unless you had special needs. 
I currently use this exact machine for a lot of development, particularly on the move. This includes cross platform development and work with the following: * Bootcamped Windows 7 for doing things with .NET on desktop and WP7 (C#, F#), C++, Haskell and Erlang. * OSX for Haskell, Erlang, C# on Mono, C++, iOS dev with ObjectiveC. * Arch inux (VM) for C++, C# on Mono, Erlang and Haskell. I bought this machine just a couple of months ago. I love it. It's the best hardware I've had and for cross-platform stuff it's awesome. Being able to 3-finger swipe across operating systems (thank you VMWare Fusion) is amazingly good. I also do most of my writing (articles, blog posts) on this. The memory limit could be annoying down the track depending on how much I have on the go at once, but so far I haven't really noticed it that much. If it solves this problem for me when I use the tools I use, I doubt very much that this would have any issues doing Ruby dev.
I have the latest gen 13" MBA, 4GB RAM, 256GB SSD. Prior to this machine I had a 17" MBP (w/ 8GB RAM, 500GB 5400 RPM Drive). I can confidently say that the MBA is the best computer I have ever owned. I occasionally run a Windows 7 VM via Parallels (for the times I have to write C#). It performs way better than I had expected. You will eventually swap to disk RAM-wise with a VM up, but you're swapping out to an SSD, so the performance of Visual Studio, compiling, etc. on the VM is quite snappy. The slowest is when I have to browse the VM's file system (rare) and (gasp), use IE for testing (though perhaps that's painful just from connotations alone). I typically write web apps (and some Erlang) using WebStorm on the mac, Sublime Text 2, Emacs and occasionally fire up XCode for phone gap development - all of this while I have over 60 tabs open in Chrome on avg, Seesmic, Spotify, Mail, iCal, Skype (vid and audio chat) and more running at the same time. The machine is super responsive, and I typically only hear the fan kick in while I'm on a video chat via Skype. 90% of the time I'm using the 13" screen in conjunction with 2 24" Asus monitors (I bought a USB adapter), so the biggest warning I'd give is to make sure that you're ok with the screen size if you won't be using external monitors. The resolution is great on the 13" screen, but it's dense and could get tiring on your eyes. Would I love more than 4GB of RAM? Sure! And I will move on to a newer MBA once that's possible. But virtual memory with an SSD is a different story compared to your typical 5400 RPM notebook drive. FWIW, at least 3 other people I work with (ranging from designer, PHP, Ruby, iOS, JS/HTML) also use an MBA and they swear by them....Good luck! Hope you love whatever you end up with.
Great post. Thanks. How's the heat on it? Are you using the i7 model?
A great way to memorialize a great man!
ok progress... I have the rake distribution working for this project. I'll do a git push to my fork when I can at least display a bitmap. rake install_template still fails. Also on the test code, setupcocos2d function needs an argument, but doesn't know what window is when said argument is passed.
I think you're a bit optimistic regarding Apple's attitude to open source.
perhaps
I'm a huge fan of mechanize. It lets me write some very cool crawlers -- especially useful when you dig in to grabbing the nokogiri page object. One of those great Ruby libraries!
why are you asking about python on a ruby subreddit?
Read the source for neat projects on Github. One that I've found particularly inspiring is YAIL (an IRC library) that makes good use of metaprogramming: https://github.com/Nerdmaster/ruby-irc-yail
I second this. For me, it helped a lot that I got it a year or so in doing Ruby development. It seems to be targeted at people that have already seen a bit of Ruby code though and are able to recognize the things he talks about.
I can recommend http://rubykoans.com/
I read the Poignant Guide and it had the opposite effect on me. Luckily I hated Python and learned it (Ruby) anyway.
I second the "reading source on Github" part, but I suggest seeking out very active projects from well-established and highly regarded members of the Ruby community, such as [Thoughtbot](https://github.com/thoughtbot). Those projects might be the ones most likely to reflect the consensus of the community. This sounds like the hard way compared to a book, but you won't have to see much code before the most important preferences become very apparent.
Here's what I was working on last semester: https://bitbucket.org/seydar/chitin It's a shell built around Ruby. **It is not bash.** It is different. It is designed to run raw Ruby code. It is built so that you can do ls | L {|i| i.split } and get each line from ls as a separate line. It's got bugs. Most notably, it can't remember variables you assign. **If you can help me fix this, please do so**. I'd loooooove to make this my main shell again. It has its benefits, but ultimately, it failed to repalce bash for me for more than a few months.
It's a shell built around Ruby. **It is not bash.** It is different. It is designed to run raw Ruby code. It is built so that you can do ls | L {|i| i.split } and get each line from ls as a separate line. It's got a few bugs, noted in the TODO. Most notably, it can't remember variables you assign. **If you can help me fix this, please do so**. I'd loooooove to make this my main shell again. It has its benefits, but ultimately, it failed to repalce bash for me for more than a few months.
this is the output I am able to read after the program quits.... Not sure if this gives away how it draws "\e[?1051l\e[?1052l\e[?1060l\e[?1061h\e[?1049h\e[1;36r\e(B\e[m\e[4l\e[?7h\e[?1h\e=\e[39;49m\e[?25l\e[39;49m\e[37m\e[40m\e[H\e[2J\e(B\e[0;1m\e[33m\e[40mHello, welcome to Dungeon Crawl Stone Soup 0.9.1!\r\e[2d\e(B\e[0m\e[33m\e[40m(c) Copyright 1997-2002 Linley Henzell, 2002-2011 Crawl DevTeam\r\e[3dRead the instructions for legal details.\e[37m\e[40m (Read options from /usr/share/crawl/settings/init.txt.)\r\e[5dEnter your name:\e[30m\e[40m \e[37m\e[40mTheishi\r\e[7dChoices:\e[30m\e[40m \e(B\e[0;1m\e[37m\e[40mDungeon Crawl\e(B\e[0m\e[30m\e[40m\e[29X\e[8;18H\e(B\e[0;1m\e[37m\e[40mTutorial for Dungeon Crawl\e(B\e[0m\e[30m\e[40m\e[16X\e[9;18H\e(B\e[0;1m\e[37m\e[40mHints mode for Dungeon Crawl\e(B\e[0m\e[30m\e[40m\e[14X\e[10;18H\e(B\e[0;1m\e[37m\e[40mDungeon Sprint\e(B\e[0m\e[30m\e[40m\e[28X\e[11;18H\e(B\e[0;1m\e[37m\e[40mZot Defence\e(B\e[0m\e[30m\e[40m\e[31X\e[12;18H\e(B\e[0;1m\e[37m\e[40mInstructions\e(B\e[0m\e[30m\e[40m\e[30X\e[13;18H\e(B\e[0;1m\e[37m\e[40mThe Arena\e(B\e[0m\e[30m\e[40m\e[33X\r\e[16d\e[37m\e[40mSaved games:\e[30m\e[40m \e[30m\e[47mTheishi, a level 1 Demonspawn Transmuter\e[30m\e[40m\e[75X\r\e[19d\e[37m\e[40mUse the up/down keys to select the type of game or load a character.\e[30m\e[40m\e[63X\r\e[20d\e[37m\e[40mYou can type your name; if you leave it blank you will be asked later.\r\e[21dPress Enter to start, Tab to repeat the last game's choice.\e[30m\e[40m\e[72X\e[22;131H\e[1K\e[23d \e[1K\e[5;25H\e(B\e[m\e[39;49m\e[37m\e[40m\e[18G\e[37m\e[40mS\e(B\e[m\e[39;49m\e[37m\e[40m\e[K\e[7d\b\e[30m\e[47mDungeon Crawl\e[16;18H\e(B\e[0;1m\e[37m\e[40mTheishi, a level 1 Demonspawn Transmuter\r\e[23dDungeon Crawl: The main game: full of monsters, items, gods and danger!\e[5;19H\e(B\e[m\e[39;49m\e[37m\e[40m\e[37m\e[40my\e(B\e[m\e[39;49m\e[37m\e[40m\e[7d\b\b\e(B\e[0;1m\e[37m\e[40mDungeon Crawl\e[8;18H\e(B\e[0m\e[30m\e[47mTutorial for Dungeon Crawl\r\e[23d\e(B\e[0;1m\e[37m\e[40mTutorial that covers the basics of Dungeon Crawl survival.\e(B\e[0m\e[30m\e[40m \e[5;20H\e(B\e[m\e[39;49m\e[37m\e[40m\e[39;49m\r\e[36d\e[K\e[36;1H\e[?12l\e[?25h\e[?1049l\r\e[?1l\e&gt;\e[?1051l\e[?1052l\e[?1060l\e[?1061l" 
very cool. So the read was the problem :-) thanks
I started down this path a couple times in my undergrad, but it looks like you got farther than I ever did. Nice work!
I'd recommend these books in this order, and if you have to read just one book, I'd say the first one is all you need. Most thorough coverage of Ruby I've ever seen anywhere, very well written too. - The Well Grounded Rubyist - Eloquent Ruby - Meta programming Ruby - The RSpec Book
It's taken a few false paths before I got something useful. It was a lot of fun figuring out how to get pipes to play nicely. I still don't have error pipes playing well together (grumble grumble grumble). I'd really like to see this develop into something better, but it's gonna take some time an ingenuity.
WOW! How did you find that ? Can I learn the process to do that so I can use it on other stuff ?
seconded... write code.
What element did you inspect ? I'm using chrome inspect tool. What should I be looking in source code to find what I need
&gt; Maybe it is just me but this feels cleaner. I treat instance variables in my specs as a smell and you should too. You admit that this is just an opinion when you say it "feels" cleaner, but then you assert that the rest of us should treat instance variables as a code smell with no objective justification whatsoever. That makes no sense. Have you benchmarked it? Is there a measurable reason of any kind to use let? ```ruby its(:find_good_cars) { should eq [car_1, car_2] } ``` This may be "cleaner" (to you)... but it sure as hell isn't clearer. Read it out loud and compare to: ```ruby it 'only finds good cars' do @good_cars.should eq [@car_1, @car_2] ```
I bought mine about a year ago when my old MBP died. It's got 4GB RAM, 256GB SSD and the 2.13 GHz Core 2 Duo. At the time I thought I'd get a big MBP later on and would then use the MBA for demos and to travel. I'm doing Rails dev full time, using MacVim ( with [Janus](https://github.com/carlhuda/janus) ). I have MySQL and MongoDB running all the time, and I use pow in development, but I've used Passenger over either Apache or nginx in the past. Never had any trouble. Maybe if you use VMs or a full IDE it would be a different story (I had trouble with RubyMine's constant re-indexing on a big desktop a couple of years ago). For me it's fast enough that I haven't felt any need for the MBP.
Yeah, Vim got big with ruby devs a while ago, while TextMate was stagnating (I think they've released an alpha of V2 recently). One of the big turning points (for me at least) was [this article by Y.Katz](http://yehudakatz.com/2010/07/29/everyone-who-tried-to-convince-me-to-use-vim-was-wrong/).
&gt; What should I be looking in source code to find what I need Stop for a second and think to yourself "I want to write a Google Maps application that plots the coordinates of FooBars located in my city." The first thing you need is data of where these FooBars are. So, you write a simple little script that renders a map on the page using the Google Maps API, because you need a place to visualize that data. Then what do you do? You fetch the data and parse it. Since you want to possibly include this map on multiple pages, you write your javascript into an includable asset, instead of inline with your HTML. In order to do this, you include it in your page. Now, what have I told you? 1. The Javascript file is most likely going to be included in the HTML somewhere. 2. The Javascript file is going to build a map using the Google API. 3. The Javascript file is going to fetch the data from someplace. So you go look at what Javascript files are being included in the document. There are a few on this one, so lets go through them one at a time. 1. jQuery. 55% of all web pages use jQuery, but only less than a minority edit jQuery directly, so you can safely assume that you won't find anything interesting or unique in that. Plus it's loaded from Google'S AJAX CDN, so that site doesn't even have control over it's contents. 2. jQuery UI. Same thing. Hugely popular UI framework that thousands of sites use, also coming from Google's CDN. 3. Google Maps API Library. This renders the map, but it comes directly from Google, and is the same exact file served out to everyone that builds a Google Maps application, so you might find some interesting things in it, but nothing specific to the data you are looking for. 3. jQuery Cookie. A jQuery Plugin. 3rd party code that helps them write cookies to your computer through Javascript, so they don't have to do a page refresh to set persistant meta-data in your browser. 4. jQuery Translate. Another jQuery plugin. They didn't write this, and there's no need for them to modify it themselves, plus it only really helps to translate text from one spoken language to another, which doesn't seem to be relevant to geographical coordinate data. 5. Css Browser Selector. Looks like it helps normalize CSS styles across browsers. Is this relevant to Geo-Location data? 6. station-map.js. From the first line of the file &gt; This file creates the Capital Bikeshare Station Map Huh, that looks interesting. Wonder what that does. The first line of code seems to generate a new map centered over Washington DC, then it sets some options, and then it looks like it finds an HTML element, and then writes the HTML generated from the map onto the HTML page. Then, holy shit, by line 20 it starts to describe the data it needs, and at line 50 it says: &gt; $.get('/data/stations/bikeStations.xml', There. you just learned how to pirate data. 
I wish I could give you more than one upvote! I'm new to web programming so thank you for taking the time to do a detailed write up. 
Yeah, you could very easily embed all of rush into chitin and use them both.
do you have the code for that? i'd like to check it out
These are fun.
No, sorry. Looks like the RubyForge svn is also empty :-/ 
Yeah, I love that book. I also like how he used images for code examples so they display properly on a kindle. It is perhaps the least annoying programming ebook I've ever read :)
It would be nice if there was an explanation of what gitlab is for the uninitiated.
Evented I/O is definitely the way to go forward though. Phusion Passenger is also going (at least internally) evented starting from version 3.2. Future versions will even expose evented I/O to web applications themselves. Say hello to unlimited I/O concurrency and websocket support.
Four pull requests sent.
You can try hacker news too.
http://www.rubyflow.com/
Open an IRC channel in freenode so people can join to ask questions in real time.
it should be URLStore, URLNip, etc URL is an acronym. 
Rugby and Ruby are two very different things.
at 3 gigs, you're still fine to run ruby mine.
Personally, I prefer Ruby League over Ruby Union. 
Yeah, pushing/pulling files from DNS sounds like awesome hacker news material. Making a nice github page for your project would be a good idea too.
Hey, pretty awesome. I've been thinking about moving some stuff I've written into gems as it could be useful for some people. Thanks!
Yay! I'm so glad to hear that. I needed to figure gems out last week for some work. I ran into enough confusing things that I figured yet another article on how to write gems wouldn't be a horrible idea.
Yep, it was really well written and informative. I have one question though... &gt; When you install a gem via :path or :git it will not be listed in gem list and will throw a LoadError if you try to require it directly in irb. I have twitter-bootstrap-rails with :git in my Gemfile yet when I do "gem which twitter-bootstrap-rails" it will give me a local path. Surely it downloads the gem from the :git path and saves it locally?
This might be slightly off-topic but what's the point of ValidAttributes? There are already tests in the Rails codebase that make sure validations work. The validations themselves are the documentation of what you intend. Why repeat yourself by writing redundant tests?
In general, the gemspec is relied upon to determine WHAT files are actually in the gem. Not every file in the source tree is meant to be distributed with the gem, some are just for development of the gem itself, etc. So the default bundler-created gemspec, the gemspec decides what files are in the gem based on what files are in git. So if you've got a file in your source tree, but not in git.... the gemspec doesn't think it's actually part of the distro'd gem, it won't be included with the distro'd gem if you upload to rubygems, and even when using a gem from source (local file :path or :git with bundler).... it may be that in some cases it finds these files anyway, but I wouldn't count on it. If it's part of the gem, it needs to be listed in the gemspec, and the bundler-created gemspec decides to include anything in git (but nothing else). You can definitely change the code in the gemspec to have nothing to do with git (say if you don't even use git). The other options seem to either be: * listing each file explicitly one by one (what a pain!) * Using the ruby Dir class to say "include ALL of the files in the source tree". Or all of the files matching a certain pattern. Or all of the files except X, Y, and Z. Each has plusses and minuses. With the Dir approach, I've found it _very_ easy to accidentally include files in the gem that should not be (such as a ginormous log file, oops, giant gem package size; or a file that includes local passwords I just had sitting around as a note to myself, oops, better change all those passwords since I just pushed em to rubygems!). Incidentally, while bundler's gem-creation helper uses the 'git' technique, rails 3.1+ has a "rails plugin new" that will also create a gem structure for you... and uses the Dir glob approach instead. 
I don't know about you, but I run more than an IDE, rails app, and browser, and the OS takes up some memory too. Trust me, my complaint is from experience. If I run rubymine and jruby rails apps, 4 gigs is not enough memory. If I avoid the JVM, all is fine. 
http://ruby-doc.org/stdlib-1.9.3/libdoc/uri/rdoc/URI.html
Pro-tip: Githubbers love READMEs.
Both of those articles are written like crap and you don't need to insult my participation in the community without having any idea of who I am.
Chunky bacon!!
It wasn't clear on how to handle gem dependencies. What to do when your gem needs other gems.
I stand corrected on that last bit, but only because a more official source has incorrectly spelled it URL :) Seriously, all caps for an acronym you will never need to unravel, and is in reality a word of it's own, is bad practice.
Did you have to include that cancerous .DS_Store file, though? Yech!
:) Java also does it this way: http://docs.oracle.com/javase/1.4.2/docs/api/java/net/URL.html
if the end user is using a gem that had it's gemspec specified properly, then all will work fine. if not, then not. 
They're a 501(c)(3). I'm not sure who their donors are.
Some minor suggestions. Don't lock your `.rvmrc` to a specific version of Ruby: rvm --create use @periodic_table Also, you don't necessarily need Bundler to generate a fresh gem, there's other project generators [available](https://www.ruby-toolbox.com/categories/gem_creation). You can even go super minimal and not use Bundler at all (this sometimes makes sense for gems that have zero dependencies) and instead use the [PackageTask](https://github.com/rubygems/rubygems/blob/master/lib/rubygems/package_task.rb) included in RubyGems. # Rakefile require 'rubygems/package_task' Gem::PackageTask.new(Gem::Specification.load('mygem.gemspec')) do |pkg| pkg.need_zip = false pkg.need_tar = true end $ rake gem [Part 2](http://rakeroutes.com/blog/lets-write-a-gem-part-two/) is missing an important step in Gem creation, Documentation. Wether it be [RDoc](http://rdoc.rubyforge.org/) or [YARD](http://yardoc.org/) with RDoc/Markdown/Textile markup, please document your gems! Once your gem has been pushed to [rubygems.org](http://rubygems.org/) people can view the documentation on [rubydoc.info](http://rubydoc.info/gems/).
Alright, thanks! :)
Yes, to all of the above. In mature gems you'll be adding/removing files *way* less often than you'll be changing them. Think of it the way that git makes you add things to the index explicitly instead of simply committing everything-must-go ala subversion.
I have used it and it works. I use waitr if i need to interact with javascript or poorly coded pages. 
Only evil can come of this
It's probably the proper way in general but when using an ORM that has certain expectations, as MongoMapper does, it's probably easier and less error prone to follow their conventions as much as possible, which in this case would be to go with less capitals.
That's covered in [Part 2](http://rakeroutes.com/blog/lets-write-a-gem-part-two/). If that doesn't answer your questions please let me know.
I'm using it here: https://github.com/blueblank/reddit_modbot I did some questioning and researching, and chose mechanize for ease and simplicity in getting the basic parts of what I needed done and out of the way. I'm not advanced enough to dig into net/http yet, and I'm not sure why I would need to rebuild the wheel. I'd recommend mechanize, but your situation might differ.
Fantastic, I'm so glad to hear that it helped you. As for :git in a Gemfile, try this. - make a new directory /gemfile_test - make a new gemset `rvm use --create 1.9.3@gemfile_test` (or whatever ruby) - `gem install bundler` - make a Gemfile in that directory source "http://rubygems.org" gem 'twitter-bootstrap-rails', :git =&gt; 'git://github.com/seyhunak/twitter-bootstrap-rails.git' - `bundle install` (lots o' stuff happens) - `gem list` (no twitter-bootstrap-rails) - `gem which twitter-bootstrap-rails` (ERROR: Can't find ruby library file or shared library twitter-bootstrap-rails) - (irb) `require 'twitter-bootstrap-rails' (doesn't work) - `bundle console` (Twitter::Bootstrap::Rails) Unfortunately, I have no idea why your Rails app is working differently than this experiment. Do you get the same results when you follow these steps? Bundler: Is it weird? Yes. :-)
Wow, thanks! There are already some really great writing a Gem articles out there. I just hoped to fill in the gaps I ran into. :-)
Cool troll post brah.
Fantastic, glad to help. It gave me the perfect opportunity to confirm my understanding of how all these pieces fit together. That is weird though, so if you start with a `gem install` version and then switch to a :git version, the gem installed into the system gems is left untouched? When you go into irb and require the gem you'd be getting a different version of the gem than the one being used by your app? BTW, I made the exact same switch in some of my apps. Love twitter bootstrap and twitter-bootstrap-rails. Bootstrap 2 is awesome. :-)
There are also some really great "micro gem" frameworks such as [micro cutter](https://github.com/tjh/micro-cutter). One of the goals for my post was covering how to develop closed-source gems, a subject that I found particularly tough to find information for. Using bundler seemed to strike a good balance between easier gem development and framework weight.
Thanks! I've been meaning to update the presentation and gem with more details, but I haven't gotten around to it yet. Suggestions (and pull requests :p) very welcome on this.
You can also use capybara with selenium which is handy if the website you are scraping uses a bunch of JavaScript. 
My take, based on your solution (using 1.9.2p290): https://gist.github.com/1901811 A bit more Ruby-esque, I think.
Maybe [ncurses](https://github.com/eclubb/ncurses-ruby) is what you're looking for?
A bit hard to read though wouldn't you say? It seems like you should space the code out a bit.
I do not want to write to the screen (at least not yet), rather I have captured the output of a program and I want to decipher it so my program can figure out what would of been written to the screen had I not intercepted it
That's just my style. Not sure there's that much to space out besides perhaps where I'm getting the max of upleft/upright or the proper input/output files, though.
Most vt100 escape sequences start with ESC[ and end with an upper or lower case letter. There may or may not be a variety of numbers or symbols between the [ and the ending letter. There are a few exceptions to this but starting with a rule like that should help get you started. Just replace the ESC[ through the terminating character with nothing. At that point you can see if you have to deal with any of the odd sequences that don't match the pattern above. 
This is a terrible algorithm to use. You are running find_sum on each of the bottom-most triangles once for every path that leads to them. You only need to run it on each of them once. 
terrible is a little harsh don't you think? I was going more for readability and fewer lines rather then overal speed. It really depends on what is required I guess
&gt; why exactly do people like gemspec generators? What work is it saving you? That's my opinion - none at all, really. Gemspecs are just plain ol' ruby anyhow, no point in using a generator when you can just write code into the gemspec.
Ha! I love that you even do to the same `cd ..` `cd -` trick to reload the .rvmrc. Is the code for teachmetomakearubygem.heroku.com somewhere? I didn't readily see it on your github. It's totally awesome and I'd love to help work on it. 
It's been a while since I have done any calculations on computation time, but like I said I wasn't really going for speed. That being said, I think you math is a bit off as recursive (as far as I know) is just as fast as iterative. If you have a more efficient recursive solution I would be happy to read it. The program runs without error and the code is very readable, thus your adjective of terrible is incredibly incorrect.
I don't think anyone in their right mind would use it for production but I absolutely love actually using scrubyt because the API is exactly what you need and nothing more. It just sucks that it's not supported anymore, but still useful to know because it uses mechanize in the backend, so it's a useful repository of code of essentially mechanize. Do you have recommendations on resources for using mechanize(?), hopefully making web scripting with it easy. I haven't tried it because for doing little things here and there where it's not mission critical, scrubyt is getting the job done. EDIT: I just found mojolicious for perl, it's web scraping support looks really good to me, I think I'll be moving over. [http://blog.kraih.com/mojolicious-hack-of-the-day-web-scraping-with](http://blog.kraih.com/mojolicious-hack-of-the-day-web-scraping-with)
If you want an example of a scraper: https://github.com/xrl/amzn-scraper . It's got a little mechanism for defining page schemas so you can just treat the page as a clean data-structure: https://github.com/xrl/amzn-scraper/blob/master/amazon/extractors/review.rb
A similar problem is problem [18](http://projecteuler.net/problem=18) (small triangle) and [67](http://projecteuler.net/problem=67) (large triangle, 100 lines) on Project Euler. My take on this is, with the triangle in triangle.txt: f = File.open('triangle.txt').readlines triangle = [[]] 0.upto(f.length-1) {|x| triangle[x] = f[x].split(' ').map! {|y| y.to_i} } (triangle.length-1).downto(0) {|x| sub = triangle[x] 0.upto(sub.length-2) {|y| triangle[x-1][y] = [sub[y], sub[y+1]].max + triangle[x-1][y] } } puts triangle[0][0] 
Or just define custom inflections in rails.
I said your algorithm is terrible; I didn't say your code was terrible. Your code is very nice and readable. Recursion *can* be as fast as iterative, but it isn't guaranteed to be as fast. It can be terribly, terribly worse, such as in your example. Here is a solution with much better algorithmic characteristics: def find_sum(array) # start from the bottom of the triangle array.reverse.each_with_index do |line, i| # return the result if we are at the top of the triangle return line[0] if line.size == 1 # add the maximum path starting from the bottom to the line above line.each_with_index do |value, j| array[i + 1][j] += [value, line[j+1].max end end end I didn't test this because I am lazy, etc.
You take your valid points and get the F outta here!
 That's called "tree accumulation" right? OK, thanks for the feedback.
Wow, this code is way more "Rubyesque." It's worth a thousand words. I will study it closely. Thanks for posting it.
ooh hadn't thought about the iOS case. How about this: module TagHelper def tag_title(tag) name = tag.name.downcase iProduct = %w(iphone ipad ipod ios) if iProduct.include?(name) apple_product_titlize(name) else name.capitalize end end # refactored version def apple_product_titlize(name) return name[0] + name[1..-1].upcase if name.size == 3 name[0] + name[1].capitalize + name[2..-1] end end 
I used RVM on my MacBook, it was quite a pain in the ass... Is it as bad on a Linux box?
One thing I suggest you really not miss out learning are the tiling window managers like [AwesomeWM](http://awesome.naquadah.org/). For a VIM guy like me that package is a dream. Also, don't miss [freetype2-infinality](https://wiki.archlinux.org/index.php/Font_Configuration#Infinality). It brings the 'details and customizability' you crave to the 2nd order of magnitude in font rendering. As a Mac guy now those are the two things I miss about Arch (GNU/Linux in general really, Arch just makes it all simple and easy).
It's been a few months since I tinkered with RVM so I don't really remember what didn't work. All I remember is that nothing worked as expected.
I do remember having a bit of a hard time with RVM on my macbook, but I'm in love with it nonetheless. 
I'm on a Mac, and using Textmate. I keep toying with the idea of going back to emacs. But it never seems to last more than a week or so of twiddling. I'd really like it, as I have to do the occasional Windows/Linux work, and I feel lost using a different editor.
Now do `MagSafe`! &lt;/socratic&gt; 
Thanks so much for this. I am in the middle of my first ruby web scrape. This helps me immensely. 
I am amazed you are not running Ubuntu like everyone else. Every google term that has to do with linux is followed by ubuntu.
very cool, I am going to look into that on Monday :-)
Very good post
I'm afraid I don't really see a lot of substance to this article. The complaints, as far as I can tell, are that he doesn't like the way models are subclassed from ActiveRecord::Base, the lack of a sane default source for Bundler, potentially bad documentation, and the lack of evolvement in Rails 3. The complaint about AR is strange, since it's been that way forever. The rant about bundler is lame, it's such a minor thing. He complains about the Merb merge and lack of Rails 3 evolution, but never says what specifically is bad about it or what's missing (unless he's complaining about plugin development, which I happen to think is a good thing). And how any of this ties into Node.js I have no idea. But gosh, golly, gee, if Ward Cunningham says it's the future, it must be. I guess it's easier to turn your brain off and let other people make your decisions for you. Then again, Giles Bowkett turned his brain off years ago from what I can tell.
You likely didn't get the path correct, when you install RVM you also have to tell it a path, it is a line of code in your .bash_profile that would look like this (placed at the end of the file): [[ -s "/Users/yourusername/.rvm/scripts/rvm" ]] &amp;&amp; source "/Users/yourusername/.rvm/scripts/rvm" 
I've been using awesomewm for a couple of years now and swear by it, but the learning curve is crazy hard. The "configuration" is actually a Lua script that you use to implement a whole new window manager. The reward is that you get exactly what you want/need, because you wrote it. Anyway, my philosophy on learning curves for complicated software is that even weeks or months of lost productivity due to ramp up will pay off in the coming years that I'll be a more productive developer. So grab some coffee, load up the docs, and stick with it :)
This happens automatically now as part of the install script.
nope, but I am adding it to my reading list. Thanks
The [janus](https://github.com/carlhuda/janus) vim distribution/plugin-package has many of the features used in TextMate. When I moved from TextMate to Vim I used this and it was a great starting point. As I became more comfortable with Vim I ended up ditching janus for my own custom set of plugins.
mysql2: https://github.com/brianmario/mysql2
have you installed libmysqlclient-dev? That's the cause of most problems installing this gem. sudo apt-get install libmysqlclient-dev
That's what I thought too but this tutorial had me think otherwise http://zetcode.com/db/mysqlrubytutorial/ EDIT: actually says the same thing for require 'mysql2' 'require': no such file to load -- mysql2 (LoadError)
what's your require line? Should be: require 'mysql2'
actually says the same thing for require 'mysql2' 'require': no such file to load -- mysql2 (LoadError) 
and do you have require 'rubygems' above it?
ok, to be honest I haven't been keeping up with 1.9.*, I only know that in 1.8 you either need to explicitly require rubygems or run ruby with -rubygems .. and this seemed like a classical example of someone forgetting it .. have they changed it? EDIT: ok, [the docs](http://docs.rubygems.org/read/chapter/3) says "The default Ruby 1.9 package now includes RubyGems by default on most platforms (**presently Debian based systems split this out into a separate package**). This means that on Ruby 1.9 and above, you will not need to require 'rubygems' in order to load gem libraries." .. so you're right, but if devcoderinhere is using ubuntu, he may still need it
In the 1.9 series rubygems is bundled and you shouldn't need to ever explicitly require it. But, from what I just read, Debian de-bundles it in the version they ship from their repos, so if you're using that binary, you do need to, still. The gory details: http://docs.rubygems.org/read/chapter/3
In my experience helping out mechanize users, scraping is largely a black art. Nokogiri provides XPath and CSS accessor like a browser, but bad web pages may make these less effective as libxml does not provide the DOM correction the browsers perform. If libxml, nokogiri or another library provided such corrections it would be much easier to create an easy scraping API, but that's beyond the time commitment of the present mechanize maintainers. Fortunately most popular pages have valid markup so using the CSS or XPath accessors works fine most of the time.
maybe you could try specifying port so it uses TCP instead of a socket? Or maybe use a different user, details should be in XAMPP docs .. but this would never work with a default debian install of mysql since it wouldn't allow you to login as root like this.
Tried that, specified a databse name, a user and password for that, and the socket empty value, still the same error.
OK this is what the problems was. Since it is a MySQL running from XAMPP folder the socket is different. The path is /opt/lampp/var/mysql/mysql.sock. It works now, Thank You ALL! Now to get the querying down good. 
[Sequel](http://sequel.rubyforge.org/). I find it to have the most Ruby-like API, and it can do more than just MySQL. 
Well way to go! I pc game so I only use linux for servers and my distro of choice is centOS. The packages may be older but they are rock solid. However if I were to choose a desktop linux distro, it would be openSUSE. I never liked ubuntu from back in the day because it was gnome based and I am a kde guy. I tried kubuntu but is really bad.
to convert True to 1, False to 0 ?
 1.9.3p0 :006 &gt; foo = true &amp;&amp; 0 || 1 =&gt; 0 1.9.3p0 :007 &gt; foo = false &amp;&amp; 0 || 1 =&gt; 1 Have fun
Want to have it the other way around, but nice idea, I'll give it a go with some modifications (1 for True)
Ah right, I reversed that.
Browse the [monthly gallery of desktop screenshots](https://bbs.archlinux.org/viewtopic.php?id=134789) for inspiration before settling on a window manager. I've been using [WMII through Ruby](https://github.com/sunaku/wmiirc#readme) for the past 6 years, particularly [under Arch Linux](https://bbs.archlinux.org/viewtopic.php?pid=1035204#p1035204) for the past 2. Cheers!
*on* what, not *to do* what.
still not entirely sure what you mean. If you mean the version then 1.9.2
Where should the function live? In the mysql gem (probably this)?
This looks really intriguing. I'm a big (huge) fan of Octopress, but I'll be checking this out. I dig the blurb about some of the styling magic going on. Congratulations on the launch :-)
Have you ever tried Arch? Doesn't seem like it.
Nick put a lot of effort into getting those guides up. He had them peer reviewed by a number of us before they went up. We thought they were good. Certainly, much much better than the old rubygems doco that we inherited. But apparently it is "crap" to you. I asked how it was unclear and if so, what you've done about improving it. Have you filed an issue? Have you submitted a pull request? Doesn't look like it: https://github.com/rubygems/guides/issues Either one of those would be much more helpful than "written like crap".
I think that'd make far a great part 3. I recommend rdoc: https://github.com/rdoc/rdoc It is as simple as putting comments above classes/modules/methods/attr*s/constants. Even ships with a rake task to generate the doco. One nice new(ish) feature is the doco coverage report. I've wrapped that up in hoe as the 'dcov' task. I've also got extra tasks to generate and rsync up the doco to a specified location. 
One extra note... I put it all in `Manifest.txt` which is a plain text file with one file per line in sorted order... It is much less of a hassle than dealing with ruby array syntax (even w/ %w[]). By doing it that way, it makes the diff idea a lot more manageable. 
Use Capybara. The same code can run different drivers. It has a mechanize driver. So if you need to debug, or want to run JS, you can run a full browser, or headless browser through selenium by changing a single line. It also has great selectors built-in. https://github.com/jnicklas/capybara The examples on the home page are focused around RSpec, but don't be fooled. It can be run entirely separately. ----------- require 'capybara' require 'capybara/dsl' Capybara.default_driver = :webkit module MyModule include Capybara::DSL def login! within("//form[@id='session']") do fill_in 'Login', :with =&gt; 'user@example.com' fill_in 'Password', :with =&gt; 'password' end click_link 'Sign in' end end
It's unfair to say someone can't complain about documentation unless they've submitted copy or even just ideas to improve it. manys comment is representative of an opinion you all, for whatever reason, haven't tapped into yet. You should be thanking GP for putting this dissatisfaction on your radar and brainstorming ways to address it, not knee-cutting for not having contributed in the way you expected. Stuff like: - Make it much more clear that the documentation is meant to be a community effort (more so than a link to github in light grey text at the bottom of the page). E.g. a clear call to action "Are these docs missing anything? Let us know!" - Rethink your documentation process. Maybe peer reviewed by "us" isn't great at getting a sense of how the broader community will receive the instructions. Effort and internal review doesn't necessarily add up to what people expect or need. The echo chamber effect can be very powerful. - Research problems that people are having while developing gems by actually going to the places that people ask for help (e.g. stack overflow). This one is the most effective because it's real world input. 
Another cool thing to do (if you don't need to combine Users and AdminUsers) is to setup "login as" for AdminUsers. In our setup, admin can be viewing a user in Active Admin and they have a link to "login as X". Clicking that will drop them into a new session logged into the public website as the user with an issue. They get to see exactly what the user sees and can describe to them exactly what they need to do. 
Whether it's quoted or not shouldn't make any difference to MySQL. Just divide by 1000 and you're good.
So, saying what I thought of the writing quality was helpful, just not helpful enough. I wouldn't be surprised if the peer reviewers were already subject-matter experts.
the ads on this page are really obtrusive and cheapen the whole blog
Go with Vim, I switched recently and once you have mastered the simplest things it becomes awesome and really fast!
I've always been promised that the non-programmers can write the Gherkin and I've never actually seen it happen. Programmers end up writing the same tests through the inconvenient fog and abstraction of Gherkin, and no business person even reads them.
If it's too brittle, you may want to look at the Page Object Pattern. 
thanks for the downvotes
This is really interesting idea. I'm quite keen to have a play with it but the code could do with some work.You asked for code advice so here it is. * Most of your code is logging. If you have to have it why not use the built-in Logger or puts? * You have a module called File that shells out to copy, rename, move, rm etc files. What's wrong with using Ruby's File class? * Speaking of shelling out all the time. That's bad and unnecessary. * You `ls` to get a list of files that you created moments earlier. Maybe keep the list in an instance var * uuencode == "A string".pack("u") * Have you seen https://github.com/bluemonk/net-dns Is it useful? * instead of lxsplit -j why not... File.open(out_file_path, 'w') do |out_file| Dir.glob(in_file_pattern) do |in_file| out_file &lt;&lt; File.read(in_file) end end * Ruby has a TempFile class that might prove useful. * You create module instance variables. I don't think they do what you think they do. * You have block, zone block and send block methods in a module called GenerateRecords. Maybe you need a class called Block. * Your interface is kinda weird. send.rb has one line... PushFile.new(domain, key, file) You're telling me initialising a class causes data to be sent. That's scary. I expect initialise to initialise only. Your library is called sendtodns so why not... SendToDns.send(domain, key, file) or... sender = SendToDns.new domain sender.send key, file I could go on... The way I would tackle this is starting with get.rb. Create a class that handles all the dns/dig stuff. It takes a getname, nameserver and domain and has methods for returning parts, md5s, anything to do with parsing dig responses etc. Then I'd create a FileChunk or FileBlock class that deals with chunking files, temp files, encoding, joining chunks back together, etc. I'd wrap partdomainlist in a class, probably called SendToDns, with a get_file method. Once you've done this get.rb should be looking quite nice. The get rid of all the loops and you'll be sweet. Send will write itself. Let me know if you want me to tackle any of this. 
OP, is that you in the video?
&gt; than just sticking to one version of Ruby for the whole system which is allowable on most Linux distros. Or you use Ubuntu, which somehow allows 3 different versions of Ruby to be installed at the same time, all from the official repos. The paths for gems, libs, etc were not all the same, meaning there were three distinct versions of ruby binary and three distinct locations of folders for gems. Doing *anything* was a pain in the ass. I ended up nuking the install from orbit just to clean up that mess. Not to blame Ubuntu, but I don't even want to know how apt-get allowed that clusterfuck. 
rvm / rubyenv If you don't want latest ruby for system add this on /etc/pacman.conf NoUpgrade = ruby 
Cucumber looks like code masturbation.
this worked, thanks! Here's what I wrote '#{field1}', FROM_UNIXTIME('#{field2}'), '#{field3}'
Good idea, is there a list of most common SQL injections or something out there ?
According to Ruby 1.9.3's Core RDoc, calling Fiber.yield always returns control to the caller who resumed the currently running fiber (by calling Fiber#resume). So, basically, it goes up just one level.
Um, that's look *awesome* :) pun intended of course.
I've been putting off the switch to Linux for the same reason, BBHoss - just felt like I didn't have enough time. But playing episodes of the Linux Action Show all day while I was working had some strange effect on me - I was like... WAIT. THIS SHIT IS FAST. I WANT IT. :) Also, I'm kind of getting tired of the mac cult - yeah it's great and all, but I miss the 90's already - and the endless tweaking and customization of my own themes and and setups. I dunno. So to get around the "don't have time" dilemma, I'm installing it in a VM first, on a 30gb partition on my work laptop. I'll work on it during the evenings when I get inspired and when I'm stuck on a problem at work during the day and need a break. I guess mostly I don't want to feel like I'm just a "user" of my machine anymore. I like tinkering, and OSX doesn't give me much freedom to do that. 
Well, part of the reason you may be getting some downvotes is that you decided to post a video which essentially bashes Ruby for being "trendy" (something I'm not sure Matz has any control over) to a sub-reddit specifically for Rubyists. A more appropriate place to post this video probably would have been the C# sub-reddit. If you had criticism about your first experiences with the language or something like that, you'd probably still receive downvotes for being a "n00b". Most of us however would be genuinely interested in hearing about those experiences, both good and bad. That aside however, I'm always happy when ANYONE gets into programming for ANY reason, so stick to what you enjoy and keep at it. Language choice matters infinitely less than actually doing something.
It was a joke...the whole post...I dont get it...I linked the girl's video at the specific part where she talks about Ruby lol
I wish we had more articles like this
You sir are right on the money.
here's a blog post from someone (else?) who liked the idea of capybara as a web scraper: http://www.chadcf.com/blog/using-capybara-javascript-capable-replacement-mechanize
I can't answer your question directly, but I did write a gem for process management and it can intercept all IO fairly easily: http://www.oriontransfer.co.nz/gems/rexec/index You might want to ensure that you are redirecting all standard output pipes including stdout and stderr - also terminals can be manipulated indirectly - so you could try detaching with a daemon (as described in the RExec documentation) rather than launching the task directly.
Are you on windows? If so, are you sending "\r\n" at the end of each line?
There can't be a 'better solution.' If you want to manage versions of something, you need to have the solution run first. You could only find a better solution by tackling the problem in an entirely different way (like rvm gemsets. Which make you not type 'bundle exec', but introduce their own problems).
on debian: apt-get install something-else mysql-
My guess would be character encoding issues on the streams leading to VT control sequences getting corrupted.
Try [rbenv](https://github.com/sstephenson/rbenv) with ruby-build, I find it cleaner.
there's nothing that special about ruby here, especially if you already have an AST. You've just got to recursively go through the tree, and output code for each node. Look up some example tutorials, ruby or not, for compilers/interpreters and code generation, maybe? If you didn't already have the AST, there are several nice ruby tools for parsing, some of which have built-in mechanisms meant to support code generation from the intermediate AST. I've used Parslet which parses based on a PEG... although actually the code-generation part of Parslet I'm _least_ happy with, and don't use it, I just use it for parsing to an AST, and then generate code myself from the AST. There's an alternative that's similar to Parslet but uses a left-recursive parser instead of a PEG, that was posted on reddit a couple months ago... but now I can't find it and cant' remember the name of it. Haven't used it. Wouldn't personally recommend treetop, although it's the old school standby. 
I understand how the changes he suggest would make Twitter API closer to actually being "REST". It's unclear if they'd make any difference at all for actual ease of use by clients and client developers though. We're so far from the point of having REST API's which are, like, auto-discovered and used by generic REST clients that "just work" as long as it's "really REST" (by "following their nose")... and except for that, does it matter at all if the api really conforms to the platonic ideal REST or not?' In fact, actually requiring real HTTP verbs with not even a fallback option generally makes your API _harder_ to work with, not easier, in the real world environment. 
 l = gets.chomp.downcase if ("a".."z").include? l puts l else puts " " end You don't need to check whether the letter is lowercase or uppercase, since `downcase`'ll return a lowercase letter even if the input is lowercase. "a".."z" gets a Range of all the lowercase letters and checks whether `l.downcase` is included. EDIT: You could ensure that you're only getting a single character by adding `and l.length == 1` onto the `if`. EDIT II: Made `"a".."z"` actually strings, thanks nochte
One-liner (identical in function to Intolerable but uses ternary operator in place of if/else): ((('a'..'z').include?(l = gets.chomp.downcase) &amp;&amp; l.length == 1) ? l : ' ') 
Shouldn't that be `gsub`?
Depends on requirements I guess. &gt;Whereas **sub** only replaces the first instance, the **gsub** method replaces every instance of the pattern with the replacement. Edit: trying it in IRB: &gt;&gt; puts gets.chomp.downcase.sub(/[^a-z]/, " ") a a =&gt; nil &gt;&gt; puts gets.chomp.downcase.sub(/[^a-z]/, " ") 1 =&gt; nil &gt;&gt; puts gets.chomp.downcase.sub(/[^a-z]/, " ") A a =&gt; nil 
Whittle is the name of that parser, it's LALR. Looks like it's not very active development, but I hope it comes back.
That's my tentative feeling: http://www.reddit.com/r/programming/comments/p95iv/hidden_gem_general_principles_for_good_uri_design/c3npo7u
Just in case downcase isn't allowed, you can do ascii math: l=gets.chomp if l.ord &lt; ?A || l.ord &gt; ?z || (l.ord &gt; ?Z &amp;&amp; l.ord &lt; ?a) then puts " " else if l.ord &lt; ?Z then l = (l.ord + ?a - ?A).chr end puts l end *edit: If the value of this method is not immediately seen, it doesn't use any loops, and is thus much faster and more efficient than any ('a'..'z') methods.
When you see a giant pile of junk like that, usually that's a sign you're doing it wrong. Ruby has a great array generator you should make use of: `('a'..'z').to_a` will give you the lower-case version. The upper-case is just as easy. Really what you need is to learn Regular Expressions because without them your life will be miserable and devoid of meaning. 
 puts gets.chomp.downcase.match(/^[a-z]$/) ? $~[0] : ' ' If only one character is allowed, then this is better: puts STDIN.getc.chr.downcase.sub(/[^a-z]/, " ")
How many seconds faster is it?
A few pointers! &gt; Internet Media type returned could be JSON, XML, SOAP, etc. It has to be hypermedia. So really, it can't be any of these ;) At least, not as a primary representation... Which leads into point #2. While these points are all valid and good, really, URIs are supposed to be opaque, so 'designing' URIs isn't really a part of REST. &gt; Allows both "POST" and "DELETE" as verbs This is actually totally acceptable. POST is a bit less semantic, but it's not inherently wrong. &gt; Both are fundamental principles we should use to guide our actions, not restrain them. REST is actually defined as constraints on your architecture. So yes, by 'doing REST,' you should be restraining your actions. That's the point: REST says "hey, apply these constraints to what you're doing, and you get these benefits."
The question mark operator returns a String in 1.9.
Oh, right, it only takes in a single character. Managed to miss that bit.
Yeah, thus it should use getc rather than gets
Read [The Well Grounded Rubyist](http://www.manning.com/black2/) and, when you're good with the syntax, tackle [Metaprogramming Ruby](http://pragprog.com/book/ppmetr/metaprogramming-ruby). Oh, and read source code on GitHub or various, smaller libraries. Lots of delicious source code. For rails, [Rails 3 In Action](http://www.manning.com/katz/) is a great book to get you into the framework.
You should absolutely check out Michael Hartl's Rails Tutorial - http://ruby.railstutorial.org/ It's free to read online and completely fantastic.
I'm a rubyist but I still prefer [this breakdown in APL](http://www.youtube.com/watch?v=a9xAKttWgP4). There are quite a few eureka moments contained therein.
That is, unless, the OP hands in the final solution with only his name on it. Be sure to cite your sources (this reddit) or face the consequences (and ethical guilt) of plagiarism, OP!
Good point, my python's pretty rusty. In ruby, all strings are mutable. Symbols are effectively immutable strings, but aside from direct comparison and 'fetch me the entire table of symbols in the interpreter', there are effectively no methods directly on them: everything there is, is implemented by first stringifying the symbol. So to moderately oversimplify, if all you're doing is comparing a sequence of characters to another for equality, use symbols. Anything else, and you may as well just start with a string as it's going to end up as one anyway.
Ruby is an interpreted programming language, meaning it reads the input file line by line doing a [read-eval-print loop](http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop). Being interpreted means that there is no practical difference between you typing at an interactive console and you passing a file of the same commands (as text, of course). Ruby can be compiled to various states, depending on what you're thinking of. Checkout [this stackoverflow post](http://stackoverflow.com/questions/884186/can-ruby-php-or-perl-create-a-pre-compiled-file-for-the-code-like-python) for more information. Note, compilation is not necessary in ruby, really, and we generally don't concern ourselves with it (unless you happen to develop on one of the implementations of ruby like jruby). Ruby on Rails is a [web application framework](http://en.wikipedia.org/wiki/Web_application_framework), specifically a variant of [model-view-controller pattern](http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller). Ruby on Rails is not ruby, and ruby is not Ruby on Rails. Ruby on Rails uses ruby, however. RoR is not a program like php or apache. First, php is a language, nothing more, like ruby. Apache is not a language. Apache is a [daemon](http://en.wikipedia.org/wiki/Daemon_(computing\)) that responds to web requests. With respect to php and Ruby on Rails, apache can be told to route the requests to the php and RoR processes through [CGI](http://en.wikipedia.org/wiki/Common_Gateway_Interface). Yes, RoR is, very roughly, processing databases and displaying it in the browser, although not necessarily as I can write a RoR app that doesn't access the database at all (maybe it holds it in memory or it just calls other web services, etc.).
I'm a relatively new Rubier too. I found the Ruby Koans to be a very quick way to get up to speed with the specific features of Ruby. They only take a couple of hours to complete and you will have a very good idea how to approach many problems afterward. I learned Rails mainly by trial and error, working on a project that was already fairly mature. There is a LOT of stuff it seems to do "behind the curtain", like automatically translating database table columns into model properties. The guides on the official Rails site are pretty good. I should mention that as a mainly Java developer, having the chance to work with Ruby has made me start to mildly despise having to jump back to Java :)
Please don't ask the Internet for help with your homework. It's okay if you sincerely want to learn, it's not okay if you're just trying to find a better solution so you can look good and get a better grade. That being said, I am going to critique your solution instead of offering an alternative, because I think that's more valuable. Your variable names should be way more expressive. Imagine you return to this program months later and try to figure out what `arrlcl` means. After a while you might remember that it's supposed to be an array of lower case letters (I would guess?), so why don't you just name it `lower_case_letters` or something? Also `l` is a terrible variable name, call it `letter` or whatever. It's not like storage space is in short supply. Always make your variable names expressive. This is, I'm totally serious about this, one of the most important things in any kind of programming. There is no error handling at all. What if someone enters more than one letter? Your program will just silently fail. You have failed to identify the idempotent `downcase` operation. Bear with me. If you downcase an already downcased letter, what happens? It gets even more downcased? Of course not, you just get back the same letter. This property of an operation, that applying it multiple times doesn't change the outcome after the first application is called [idempotence](http://en.wikipedia.org/wiki/Idempotence). So it doesn't matter if your character was downcased or not to begin with, applying downcase will give you back a downcased letter. In other words, it's totally unnecessary to check if the letter is uppercase to begin with and you can get rid of `arrucl` completely. If I were the teacher, that would be the lesson I would be trying to teach with this example, and you missed it. Now for the love of god, don't show off with the fact that you now know what idempotence means in front of your class, okay? Finally we are left with checking if the character is a letter or not. The way you are doing this, by spelling out all letters in an array, is kind of crude. There are other, better ways of doing this. You could use regexps, which is what I would probably do, but that's maybe a little advanced (though as others have mentioned here, you should learn them eventually). As astrodust and Intolerable mentioned, you can use a range expression. But what's really important is that you look at your code and see that unnecessary repetition. You see something that the computer *should* be able to do for you, you may not know how, but it *should* be possible. Learn to identify situations like that, that's far more valuable than learning how to solve this particular case. 
I didn't mean to start a debate or anything. I just remember wondering what the hell the colon before an identifier meant, whether it was some kind of class reference, only to find out it's actually just a literal value - it's just a string, but not a String.
sending keystrokes to the program, some times it seems like it is recieving a different keystroke then I sent. I am not really sure what the problem was, but I think I might of inadventatly fixed it.
Slowly introduce JRuby. Since it interfaces with Java, you can make the argument that you're still doing Java work, just with better syntax and features ;)
The nice thing about Parslet and Whittle are that neither one is a parser generator. They are parsers that you configure with ruby code expressing grammar rules -- you could call them frameworks for building parsers in ruby. There's no code generation involved (except any code generation you write yourself for the actual domain language you are parsing and perhaps want to transform into some target language, which is usually not going to be ruby). This makes them a LOT easier to work with, debug, iteratively develop, compose, customize, etc. Being not from the land of parsec/haskell, I don't know what a combinator is or whether parslet or whittle have anything to do with that, though. (treetop is a parser generator, which is part of what makes it, to me, difficult to work with). 
I was actually hoping this was a standard feature I didn't know about. Goto gets a lot of shit but it still has its uses in certain cases as a high-performance stand in for exceptions.
Go to [www.ruby-kickstart.com](http://www.ruby-kickstart.com), see the free overview of all language features, do the exercises on github and you're done. It is designed for programmers and is the most efficient path to getting ruby I've seen.
I've been using Ruby for about a year now and love it, haven't tried Python. I'm not at all trying to start anything here, but can you give any specifics for what Python would be good for and Ruby not so much? Thanks
Rubymine, try it out. Edit: I should add, I run rubymine on a machine with an ssd and 8 gigs of ram. 
or a 'token' or, well, a 'symbol'. It's not exactly a 'string', it's not a sequence of characters or bytes. (I mean, everything's a sequence of bytes one way or another internally, but conceptually it's not). It's just a unique token. Unlike a string, even in ruby 1.9 it doesn't have a character encoding. Because it's not characters. It's just a unique symbol. Essentially used in places you'd use an 'enum', except it's of course not chosen from a closed enumerated set. 
&gt; Does this mean Ruby is an interpreted language, and can't get compiled? Yes, that's right. &gt; And finally, what is Ruby on rails? Is it like a program that is running on a webserver (like php, apache) that processes databases and displays it on the browser, like php? It's a "framework" for building a web app. A web app is an app accepts HTTP requests and returns things (usually HTML) to the browser, usually also involving database access for persistence. A Java analogy might be Apache Struts. I have no idea how similar Struts is to Rails in any aspect (I know nothing about Struts), they're probably pretty different in approach, but they both have the same basic role, as far as being frameworks for building web apps. A web app framework (or really any framework) aims at providing the 'basics' a web app will need, so you don't need to write any boilerplate, you just need to write the parts unique to your app. That's the idea anyway. PHP, being a language targetted almost entirely at web apps, has some things built into it's standard libraries that in other general purpose languages would be optional third party libraries or frameworks instead of built in. But there are web app frameworks for PHP too. Examples would be the Zend Framework, or Cake. (Never used either myself)
Anything involving numeric or scientific libraries - ruby doesn't have the kind of scientific library support python does. The scientific communities have largely committed to python for development.
don't use an IDE, use your brain and a good editor like vim, emacs and the newer one like textmate or sublimetext for doing code completion of gems, read the gem docs, or in my opinion the better way show the tests/specs of the gem, to learn waht the gem does and with this knowledge you are making code completions 
still lol'ing at the nerds who didnt get I was quoting her part as a joke....If you click the link it goes to the Ruby part....
I use (and love) [Netbeans](http://netbeans.org) 6.9.1 with the Ruby pack and the Extra Color Themese plugin. Netbeans dropped Ruby support after version 7 but 6.9.1 is still available by going to downloads &gt; archive &gt; version:6.9.1 and build type:release.
Sadly this is rarely a popular opinion even though code completion encourages intellectual laziness.
Try version 4.0. We're on a very large project here, and it works fine, and is fast. Also, +1 to 20k line files being a WTF. You're doing it wrong ;)
To use netbeans 7.1 with ruby support: http://blog.enebo.com/2012/01/workaround-for-ruby-support-on-netbeans.html
https://github.com/gmate/gmate
[See my response to your sibling](http://www.reddit.com/r/ruby/comments/qcd7g/lies_damn_lies_and_dependencies_yet_another_ruby/c3wk5w1).
Almost. The problem is the way that it handles the generation of the depgraph: it downloads the gems and extract the dependencies from there. Unfortunately, this does not work with Gentoo-packaged gems (because we provide the _correct_ dependencies, which quite often do not correspond to the gems themselves), and even worse, it does not work if you do not want new gems to be downloaded/installed from rubygems, but rather use them from the system package. Don't get me wrong: it could be much worse, and Bundler has improved tremendously over time, but it's still way too prone to abuse.
Or solve most. If you read my blog's history you can see how many issues we have uncovered, with broken gems, missing testsuites, and so on so forth. Relying on RubyGems is a system administration nightmare.
I don't know, it sounds like you have problems and I don't have them. It's really a matter of perspective; I'm a developer, not a sysadmin. What we want out of systems are almost diametrically opposed.
That's true for sure. And that's where the two package managers enter the picture: RubyGems is designed for developers and have no regard to the requirements of a system administrator... our packaging is designed to help system administrators. Bundler, honestly, have helped a lot on this matter, but there are still uses and abuses that make it very difficult to have reliable packaging for gems that are well tested and well integrated on the system. As for who has the problems.. do you go testing all the gems you rely upon? We do, as much as possible, and we found that a number of gems had either tests that only worked on the system of the original developer (so nobody tried them beside him), or that relied on some other package that could never have worked with a newer Ruby version. We found the fcgi fork that was boasting to work with Ruby 1.9 that merely built but would never have loaded as well. To go back to Bundler: would you vouch it works on JRuby? Most people would say so, yet I doubt anybody has tried testing the latest version: the tests rely on a documentation tool that uses a C-only extension (riscount). The end result is that you cannot test Bundler at all with JRuby.. yet people use it. What about sass? If you were to run the sass testsuite under JRuby it would fail miserably — I've reported this to JRuby upstream, and the issue turned out to be sass is depending on behaviour that is true on MRI but is not specified (about caller information), which means that it will not work, as it is, on JRuby correctly. Sure it'll work for most basic usage and I'm sure people are using it right now as well.. but the moment you use one of the features depending on caller information, you're screwed. This is what we deal with daily, and this is why our task is as important as the developers', for every user's and sysadmin's sake.
I understand what you are suffering right now. We cut down our code base by making an effort of removing dead code, then going after code duplication. We also consolidated a bunch of little crappy projects into the bigger application. Our next step is to refactor the big app then split it back up into separate services. 
The IDE is valuable for highlighting things - Deprecated features - Spelling errors - unused variables - creating documentation (first thing in the morning thats all i can think of) Don't get me wrong, I agree with the premise that IDE's make people lazy, but when you get to a new project and have no idea where everything is it makes it a lot easier to get up to speed. 
Huh, am I misremembering that it exists? I've rarely (if ever) actually used it. Certainly is hard to find evidence on the net that it exists, let me keep looking.... okay, I guess I imagined it, sorry! throw/catch is where it's at. 
Ah, so we get to the true crux of the matter, the age-old conflict over what should install code, rubygems or the system's package manager. :)
Yeah, I even watched the silly girl for quite a while waiting for a punchline or something.
Software which must run on Windows or interact with a Microsoft product. Windows support is an afterthought for a lot of gems, if they support the platform at all. It's a lot less common that you'll even have to compile a Python library on Windows. It's not that Ruby's Windows support is always terrible, it's just that Python's is usually better.
If dependencies are poorly specified in a Gemfile and you choose to blame the tool instead of the programmer, I guess you could blame bundler.
That's a poor analogy and the notion that an IDE is required for rapid development is unsupported. Indeed a large codebase can cause some IDEs, such as NetBeans, to choke quite quickly. I said that code completion encourages intellectual laziness, not that IDEs are for dumb programmers.
I just wish there was a way to browse a gem's dependencies on ruby gems.org up front instead of installing it and finding out it requires half a dozen random gems just to do something you could probably do yourself if you had a half day to fix it. I've ended up in dependency hell on several projects where there's no way to resolve the mess that's created. One library can't use a version that's too new, the other can't deal with the old one. You have to twiddle, patch, and rattle things around until you find a combination that works...and is certainly buggy. 
This or if you have to use ruby use... IO.foreach('file.sql') {|line| line.sub(/foo/, 'bar')} This streams the lines efficiently to the gsub.
Before, I had imported the database and then started selectively deleting entries according to certain criteria. However, the initial import took about 15 hours, and the deleting was going on for several more hours before I decided to abort it. I think going through and removing those insert statements from the sql file will end up being a lot quicker.
yeap use cat &lt;file&gt; | ssed ... cat for line read and (s)sed for replacement its the fastest way and you have no problems with file size
I'm not 100% sure of this, but I believe sed doesn't necessarily read in a complete line into RAM. If you don't use commands that involve complete lines, it may work just fine, chugging through your SQL one convenient buffer after another. If you use the --unbuffered flag, it even tries to read the absolute minimum.
I've done something like this before so I might be able to help. It would be really helpful to know what your **end** goal is. What are you looking to accomplish?
Why would the location matter? Just curious.
Lots of companies prefer local candidates/employees to remote ones.
I'm not sure what user you're running as but FileUtils.copy_file(src, dest, :preserve =&gt; true) Will cause the permissions of src and dest to be the same.
ruby style suggests "snake-case" for variable naming, such as "dir_name" 
are you running your script in /cygdrive/d/eclipse_workspace/ ? either this or do this instead: FileUtils.mkdir_p(dest)
Can you paste the output of la -lah on that directory after you've run the script?
Do you need to specify the full path in the call to makedir_p?
Try setting File.umask in your code to make it readable by you on creation.
Sure, why not. The title's overly mysterious at this point.
It's legacy code; do not question it, unless you're ready to [become one with Codethulhu](http://thedailywtf.com/Articles/The_Call_of_Codethulhu.aspx).
[Vim 7.3](http://arstechnica.com/open-source/news/2011/11/two-decades-of-productivity-vims-20th-anniversary.ars) with built-in Omni Completion (use `&lt;c-x&gt;&lt;c-o&gt;`, see `:help ft-ruby-omni`) for Ruby and Exuberant Ctags (use `&lt;c-]&gt;`, see `:help ctags`) for navigating your code [and any gems you use](http://effectif.com/vim/using-ctags-with-bundler-gems).
http://www.reddit.com/r/conspiracy/comments/qfrgx/disappeared_slate_article_about_why_this_link/ done 
I'm working with some very large sql dumps that I want to "thin out" a bit by filtering out values I don't need (otherwise their imports will take forever). To be more specific, I'm working with several Wikipedia sql dumps and trying to extract the necessary information from them to construct a "knowledge graph", that represents how different articles are related, and then try to find clusters on this graph to define "concepts" (i.e. a cluster = a concept). It's been really difficult, since the files are so enormous and take forever to process, so I'm trying to find the most efficient approach possible.
What are you trying to represent? It seems to me that you may be attempting to force the arrays into the function of hash keys. Would you mind sharing your code so that we can get some context to help give you suggestions?
Maybe use a 2-dimensional Hash? hash = Hash.new { |hash,key| hash[key] = {} } hash[1][2] = 3 hash[1][2] = 4 
You solved your problem, and in any case, I don't think in your case this would have applied, but I'll just mention this in case anyone benefits from it. In Ruby, it's not enough for two objects to have the same hash value, but they also have to be `eql?`: class Key1 def hash 0 end def to_s hash.to_s end end h1 = Hash.new h1[Key1.new] = 1 h1[Key1.new] = 2 p h1 # {0=&gt;2, 0=&gt;1} class Key2 def hash 0 end def eql?(other) hash.eql?(other.hash) end def to_s hash.to_s end end h2 = Hash.new h2[Key2.new] = 1 h2[Key2.new] = 2 p h2 # {0=&gt;2} Again, it probably doesn't apply in your case, but it's something similar to your problem you may run into.
[here](http://sanarothe.herokuapp.com/ruby-quick-start) is a little reference guide I wrote a while back on 1.9.3/rvm install for Fedora. Most of the packages should be the same between fedora/RHEL, so you should be able to just follow along. Note that when using RVM for Ruby 1.9+, there is the requirement of a native ruby being installed. It doesn't really matter what version you choose to use natively, because you can just install any other version of ruby after installation.
So I did this, but a peculiarity arose. If I'm in su mode, and enable ruby 1.9.2, when I exit to my user in terminal, the ruby being used is still 1.8.7 and I have to do rvm use 1.9.2 again. Is this normal ?
attr_accessable definitely doesn't belong in models. By default models should not be mass assignable and require a whitelist. The controllers should be able to further restrict the list. I am undecided on whether the controllers should be able to expand the whitelist.
This is a great idea. And to be honest one that should always be used. attr_accessor may not be enough for a model since there are different contexts that the updates could be made in. Though that is what building your own model update methods are for. It is up to developers to sanatize, and NEVER trust user input.
Using mutable values as hash keys?
If there's a libssl-dev package, try installing that. Recompile ruby with rvm if still getting error.
[rvm openssl page](http://beginrescueend.com/packages/openssl) should answer your question.
why not just pull out the JSON out of the page either using a regexp or something more advanced, and then use the json gem to parse the data?
Yeah you need one of the ssl packages... try removing your version of ruby in rvm and reinstalling with openssl (I am looking for the documentation on it but can't seem to find it) - it's an option from the install line, something on the order of $ rvm install 1.9.1 --with-openssl, but that doesn't seem exactly right...
So, [_why's poignant guide](http://mislav.uniqpath.com/poignant-guide/) is out of the question? :P It would be an unforgettable class, you have to admit.
what os
Hint: `ruby.exe` Which version would be a better question...
Ah sorry: -Windows 7 (x64) -Ruby 1.9.2
Nice article, can't wait to try some of this out. 
Oh, man. 
I did browse. Whenever I highlight ruby.exe and click Open, it closes the browse window, but doesnt add it to the list of programs. This only seems to happen with ruby.exe... Is ruby.exe even the standard program used to execute .rb?
Please define intellectual laziness. How do you know someone is intellectually lazy apart from using an IDE? 
The only way I could replicate this is by messing around with installing/uninstalling various ruby versions creating a messed up registry setting for the ruby interpreter. You can try resetting the registry setting by deleting [this registry key/folder](http://i.imgur.com/6tGxE.png) (ctrl-f - ruby.exe to easily find the folder). I got it [working](http://i.imgur.com/l8YFt.png) when I retried changing the default program after doing just that. When all else fails, you could also post your problem over at the [RubyInstaller google group](http://groups.google.com/group/rubyinstaller?hl=en).
Thanks a lot for what seems a lot of work for you! Got it working now. I'll also bookmark the google group you linked, might come in handy. 
Great article. I never really *heard* about node.js until I added its page on one of my circles on Google+. Ruby and Rails will always be my gems (A HAAA), and I'm sad that projects on the game scope don't survive a lot (rubygame, for example).
Awesome. This will be so useful.
I'm pretty sure... I don't remember exactly how I did it, but I can at least confirm that it can be done on 7 for what it's worth. It took me a second to do just by browsing for the Ruby application like I would for anything else. 
I've looked through most of the online docs and I can't see a single example of the output. 
My sense over the last year is that Javascript specialists are bored of being stuck on the front-end, so they're moving into the server. It's not wrong or right, but so many commenters have glaring conflicts of interest for impartiality (as we all do) that these developments strike me more as mere extensions of themselves. Boy, a CoffeeScript guy likes Node? Small wonder. Ruby didn't always have Rails, but it's not a zero-sum game. Why isn't the backbiting between Rails and Node touching Python/Django at all? To me, I assume because it's just [Overton Window](http://en.wikipedia.org/wiki/Overton_window) type marketing. Nowadays a lot of participation in these games implies changes in Twitter followers, blog readers, book buyers, and all the attendant professional affectations (and money-makers) that every platform has.
Check out [Ray](http://mon-ouie.github.com/projects/ray.html)
I was able to connect using this method over here - https://gist.github.com/1037492 Is this the best way to connect and pass data to Nokogiri? require 'net/https' require 'nokogiri' url = "https://example.com" url = URI.parse( url ) http = Net::HTTP.new( url.host, url.port ) http.use_ssl = true if url.port == 443 http.verify_mode = OpenSSL::SSL::VERIFY_NONE if url.port == 443 path = url.path path += "?" + url.query unless url.query.nil? res, data = http.get( path ) case res when Net::HTTPSuccess, Net::HTTPRedirection # parse link doc = Nokogiri::HTML(data) # do what you want ... else return "failed" + res.to_s end 
[This little video](http://brakemanscanner.org/docs/video/intro/) should give a good idea of what it looks like. There's no sound, so no need to grab headphones.
I have been able to get an array of elements which look like this whole element here &gt;{id:"8",name:"Lodge Road, St. John's Wood",lat:"51.52834133",long:"-0.170134484",nbBikes:"9",nbEmptyDocks:"9",installed:"true",locked:"false",temporary:"false"} Is this a JSON ? The reason I ask is because I did a .class method on these elements and ruby says it's an array which I can understand. But when I run puts on the result of JSON.parse it gives me error can't convert from array to string.
Node sucks. There I said it. It absolutely sucks for general purpose back end work. If you really want to code in JS go and use Helma. Node is for posers.
As the update states, the slowdown on 1.9 is negligible.
Grab 10 random Ruby based CMS programs, list em with basic blurb and try to make ad revenue Useless list.
Tap? :) It's really more of an inject, actually...
Seriously though, I've never understood why such a method is even needed. In cases where they are used, could it be avoided?
it can be helpful sometimes when doing some metaprogramming shiznite. see: https://gist.github.com/5cf27742477cd4c75dcd
I suspect the push toward node.js is basically because: (A) some people feel the need to engineer for a non-blocking server backend (whether that need is legitimate or not), and (B) some people prefer to speak a single language on front and back ends. Unfortunately, many developers are also people who have low self esteem, and fall into the trap of one-upmanship in terms of proving how skillful they are. They feel the need to overcomplicate matters to prove their self-worth.
Node devs are just doing to Ruby what Ruby devs did, and continue to do, to PHP. The circle of life.
I've used it for setting a number of instance variables based on a hash. A couple lines of code instead of 13+.
A hastily thrown together list of broken and out of date links. A cheap traffic generation post if I ever saw one.
Interesting article on [explicit returns](http://tomafro.net/2009/08/the-cost-of-explicit-returns-in-ruby)
um, I hope you consider submitting a patch to rspec to fix the exit code issue, instead of just working around it with more stuff in your stack. Or at least filing an issue with them even if you don't have a patch. 
You can do a JSON.parse(string_of_json) to have Ruby convert it to a Hash for you. How are you getting the JSON? I'm assuming you're using a HTTP request 
Is there a special request for getting JSONs only ? because right now I'm connecting to the https page, then passing the source code to Nokogiri, extracting the javascript with JSONs in it, then parsing for just the JSONs with regexes. After that I have an array of strings. The string is a JSON. Is this string what I parse with the JSON.parse ? 
Dick. 
I wrote this article (some time ago) and if it's not in the documentation, the source is probably the source code.
Did anyone read the last comment on that blog post? According to it, the post is simply incorrect: Bundler does not install dependencies from excluded groups.
I think Learn ___ The Hard Way would definitely be what I am looking for. I've seen it before, but never looked at it. Thanks a bunch!
Here's [how I migrated from WordPress to static files using nanoc](http://www.conigliaro.org/2011/09/08/from-wordpress-to-nanoc/).
The OP suggested that "it's expected that objects will override [the #clone] method with one that can do deep copies." It seems to be controversial whether this is 'expected' or not. I think I'm standing by my original statement that it's deeply frustrating that ruby provides #dup and #clone, but there's no clarity at all in the documentation or in the community about what the difference is supposed to be, and no consistency in the open source ecosystem or probably even in stdlib. 
Great article! .. my only complaint is that the link to the source code aka the magazine website at the bottom is dead :( 
what's up with people posting 2-3 year old blog posts to reddit lately? What's up with blog authors and/or blog CMSs not including date of post in the readable text?
There's also the [Grape micro-framework](https://github.com/intridea/grape) if you want to build a light app that serves up REST api's. It can be used on top of an existing Rails or Sinatra app too
Do you have an available example of how you do this with Sinatra?
I recently forked and added onto someone's template: https://github.com/gnarmis/sinatra-rspec-bundler-template. This has the modular style I was talking about. However, this template doesn't have any gems included for implementing REST services, but it should be easy enough. Add a gem to Gemfile (no need to `require "foo"`, then) and just start using it. DataMapper and Warden/Sinatra_Warden are good go-to choices. I might consider making a branch for an example REST service... UPDATE: I integrated Grape and Sinatra together into a Rack-based template here: https://github.com/gnarmis/rocketship
Sinatra is great for small apps, but if you have a Sinatra API that grows and grows, eventually you're going to want to break it down into separate files. [You don't want it to turn into this](https://github.com/antirez/lamernews/blob/master/app.rb). Lightrail gives you quick startup times and fast responses like Sinatra, but you can still harness many of the features of Rails including its directory structure conventions and in-development autoreloading.
That link was hard to parse. Just for reference, [sinatra/contrib](https://github.com/sinatra/sinatra-contrib/) has a lot of the common extensions that make life easier. `sinatra/reload` is one such extension, and then there's the shotgun gem too. I guess structure is a plus, but then again, once you have a good enough template, you get all the wins. This is much easier to follow than the other Rails metal solutions, though. Plus, it might be easier to mix this into an existing Rails project as a plugin (although Sinatra is ok in that regard too). Good to have options, in any case.
thanks, informative
Since link posts don't allow you to write a description I'll be explaining a few things about Zen here in the comments. Zen is a CMS that I've been working on since late 2010 (I started somewhere in August). It's written using [Ramaze][ramaze], [Sequel][sequel] and a few other things. The primary reason for writing it was because I got fed up with the limitations of Expression Engine (a similar system written in PHP), the stupid API it came with and various other problems with it. In my opinion one of the things that make Zen so interesting is that you're able to define how your content is organized in terms of field names, types, formatting and so on. For example, if you take a look at common tools such as Wordpress you're usually limited to a title and a body field (I'm aware Wordpress has a concept of "custom fields", although I think it's a joke). For a more in depth explanation see the following URL: &lt;http://zen-cms.com/documentation/file.zen_compared.html&gt;. I'd greatly appreciate it if people don't just up/down vote this thread (or even worse, report it for whatever reason) but also give their opinions about it, whether those are positive or negative. [ramaze]: http://ramaze.net/ [sequel]: http://sequel.rubyforge.org/ 
So its action controller metal plus a not so good implementation of active model serialzers? No thanks.
Nope, sorry. I only upvoted you. :&gt;
Any reason in particular you decided not to go with an ORM such as [OrmAdapter](https://github.com/ianwhite/orm_adapter/) rather than Sequel so your CMS would be compatible as well with those using MongoDB?
Because using a non relational database engine (Mongo, Redis, etc) makes no sense when the data is relational and can't be easily stored using either key/value pairs or document objects. On top of that the code required to make this work would probably slow things down quite a bit. 
I'm not saying a document database would necessarily be the best choice for a CMS - though not all data has to be relational, for instance comments *could* be embedded in sections - but supporting multiple adapters would give your users more room to make their own choices. I for one run no SQL on most of my production boxes so a piece of software that's locked in there would be big turnoff. I doubt the performance impact would be large either, the adapter merely hands over the calls with some minor changes, also Devise for instance uses it as well to support more orms. Also a random point that I noticed, when creating a section, there are required fields on the second tab, which isn't made exactly clear when trying to submit the form, the browser just complains required fields haven't been chosen.
Yep, I was going to say this, I just finished adding mobile support to a rails app and I used Grape. It's really easy, all in one file with very little code required (of course you can split it up into multiple files if desired) and rack compatable so you add one line to your routes config and all your api calls work. I initially thought I'd just use normal rails calls and render back JSON, but then I realized routing gets painful that way, and it's quite nice to segregate out your mobile API calls (notably since it, for me, involves disabling form tokens and providing an alternate session handler based on tokens, not to mention the mobile app is read only and calls a backend that is only used by administrators). 
It looks like this would only be useful for making, say, a standalone website no? I have a project coming up where I have a rails app that also needs to manage a public facing front end that administrators can easily manage/update. While I like what you've done, it doesn't look like it can be integrated into an existing app, correct?
Use [RVM](http://beginrescueend.com/). It will allow you to run it all from your home folder.
tl;dr: Leave off the $ It has become a standard practice when writing a command-line tutorial to use a $ for all commands you run as a regular user. For example: $ ls -la Anything that should be run as the root user it is common to use #. For example: # apt-get install ruby
Sure. I'll edit the post after 24 hours with the number of responses I got. So far it's 5.
Looks really interesting, most probably useful for a website I will have to build shortly
Lovely. 
Integrating it into an existing application, especially one that's built using a different framework would be rather difficult. I'd say that in most cases it's easier the other way around but this depends heavily on what these applications do and more importantly, how they do it.
Considering I'm already using it in production and have been working on it for over a year I highly doubt that :)
I am sure you mean well but looking at the dozens of abandoned ruby based CMS projects out there I am willing to take the bet you'll abandon the project. 
How much are you willing to bet? ;)
This sounds like an [XY Problem](http://www.perlmonks.org/?node_id=542341). What is your goal?
He said he wants to 'reset' the comments array at some point. To reset something you have to have a copy of the original to that you want to reset to. Thats why I pointed out `clone`. Some example code: nested_array = [[[2,3],2]] temporary_array = nested_array.clone temporary_array.map! {|x| x*2} #temporary_array != nested_array now temporary_array = nested_array.clone #temporary_array == nested_array now
What are you trying to do? Your code makes no sense. The top-level `array` is filled with values that never get used. #shift_comments removes one item from the inner array of the argument, but does nothing with this item, then returns the modified array. Is the top-level `comments` array supposed to be an index into `array`? This seems more sensical: array = [[9, 2], [4, 1], [7, 1], [6, 1]] def map_distance_coordinates(array) array.map {|x,y| [Math.sqrt(x*x + y*y)]} end distances = array.each_cons(2).map do |pair| map_distance_coordinates pair end p distances PS: you misspelled "coordinates"
Sorry for the late reply. It appeared that PostgreSQL was having various issues preventing the database from being reset properly. These issues have been fixed but I'll be keeping a close eye on the entire server in the coming days.
well, not sure how to compare cars to trains :)
Anyone seen problems compiling if you have a ton of blog posts? I've heard everything, including compilation, gets slow after about 60 posts. 
are people who aren't me actually motivated/interested in those gamification 'achievements'? It astounds me. 
Yay! Happy ending! Upvotes for everyone :D
Didn't Mozilla just do this? http://openbadges.org/ edit: along with 50+ other random implementations scattered around the web?
Good points, I was thinking more along the lines of a gem that random web app would add to their rails app to enable achievements. The problem (as you mentioned) is trying to become a central hub that everyone uses. Perhaps something like Identi.ca is doing, anyone can setup their own private avatar server if they'd like, but allow federation of data. In regards to the "ask input on this specific site", the goal was to just use the email address as a unique ID. So as long as the user profile has their email address there wouldn't be any type of oauth stuff (which is annoying). Thanks for the comments, sometimes it's just fun to noodle on ideas. :)
Do you have a version of this code that doesn't require us to know why parts seem to be missing?
How do you handle pagination? 
&gt; Windows Well, there's your problem.
Looks good but...DataMapper only? Quickest path to acceptance to my mind would be to make it more odm-agnostic, doing it yourself or using one of the orm abstraction gems.
I have a mac partition, should I switch over to that one instead? Are there any major differences? 
Yes, it was initially built with ORM-agnostic in mind. Next priority task is to create adapters for Sequel and ActiveRecord. Other adapters will depend on community requests. 
Use it to set up an ad-hoc/barcamp style Ruby conference happening outside/after the next Google I/O conference. :P
I would really love to try this but need ActiveRecord support.