Definitely, I replied to make sure OP takes another look.
&gt; Timezones are Hard &gt; … unless you use Date.current and Time.current. &gt; The end. It's better to *always* use `Time.zone.now` and `Time.zone.now.to_date` (shows intent/need to use the time zone). And like it's said in [one of the linked articles](http://danilenko.org/2012/7/6/rails_timezones/): &gt; There is no rocket science in dealing with time in Rails. But it's a good idea to understand it once and always keep in mind that when you build time or date object you should respect current time zone. In most cases it simply means to use `Time.zone` instead of `Time`, `Date` or `DateTime`.
What's with the log to STDOUT thing. This feels wrong to me although I still have to really grasp logging on Ruby. Having been used for years to Java logging, Ruby logging always felt heavily neglected and not really fleshed out. Sure, redirecting STDOUT is a simple logging option but what if I want to have a logfile with normal messages and one with error or warn messages? For example to Monit those logfiles and alerting people when non-fatal errors have happened?
Isn't it just an array of arrays. rows = [] # coordinates: rows &lt;&lt; ["", "", "", ""] # 0,0 0,1 0,2 0,3 0,4 rows &lt;&lt; ["", "", "", "", ""] # 1,0 1,1 1,2 1,3 1,4 1,5 rows &lt;&lt; ["", "", "", "", ""] # 2,0 2,1 2,2 2,3 2,4 2,5 rows &lt;&lt; ["", "", "", ""] # 3,0 3,1 3,2 3,3 3,4 Then you reference it like rows[1][0] (y = 1, x = 0) When you want to know if there's something in the cell right of your player, you do something like rows[player_y][player_x + 1].empty? The rest of the mathematics of navigating a hex grid is in your link. 
I wouldn’t initially split the application unless I knew it had a runway for more than a couple of years and a large development team. Splitting to services/engines/whatever is going to slow you down initially, which is not generally what you want at the start of an application. Instead of focussing on splitting up the app, focus on something like domain driven design, to prevent your models from being large and housing a lot of application logic. Keep the app logic in standalone objects in the '/lib' directory and then no matter what the future brings the core of your application won’t be coupled to the rails framework and you can split out into whatever different architecture you need.
Yup, that way is nice, and it doesn't result in an anonymous class in the ancestor chain: irb(main):001:0&gt; Team.ancestors =&gt; [Team, Struct, Enumerable, Object, Kernel, BasicObject] I still don't quite understand why I see lots of code doing: class Foo &lt; Struct.new(:x) ; end Maybe because it's easier to add class members later if needed. 
That's what I meant. Edited my comment.
Yeah I get a segfault here: compiling c code : clang -pipe -fPIC -O3 -g0 -x c -I/Users/tomcopeland/github.com/rujit -I/Users/tomcopeland/github.com/rujit -I/Users/tomcopeland/github.com/rujit/.ext/include/x86_64-darwin13/ -I/Users/tomcopeland/github.com/rujit/include/ -I/Users/tomcopeland/github.com/rujit -include-pch /Users/tomcopeland/github.com/rujit/ruby_jit.h.pch -dynamiclib -Wall -o /tmp/ruby_jit.59991.1.dylib /tmp/ruby_jit.59991.1.c generated c-code is /tmp/ruby_jit.59991.1.dylib nativecode generation : 56 msec link trace. parent=0x10fd33058, child=0x7f992515f620 generating enc/trans/big5.c ... converter from Big5 to UTF-8 make[1]: *** [enc/trans/big5.c] Segmentation fault: 11 make: *** [srcs-enc] Error 2 Seems like it's doing something JIT-y at least!
Error/Warn messages belong in STDERR, don't they? 
The reason Java needs so much logging control is that it has to work on non UNIX platforms like Windows. `/dev/stdout` and `/dev/stderr` are all you need.
No, according to the article and the linked article within it, you should just log to STDOUT. The linked article - which shows a little DIY daemon - redirects both stdout and stderr to the same output.
Funny, but more wrong than right. I agree that adding a language should be project driven -- don't quit a language or try to learn a new one language without compelling reasons. But Ruby expertise breaks many people of some flawed procedural/algorithmic thinking, much like Lisp/Clojure or Haskell.
Ruby is alive and well in enterprise running cucumber automation and many large entities are just starting to adopt Ruby for that purpose and jobs are plentiful at least in the mid-west part of the country. Cucumber is much easier to bring to fruition with Ruby than other implementations. I also see it alot being used with chef for setup scripts.
I'd use [runit](http://smarden.org/runit/) instead of daemon tools. But yes.
POODR isn't advanced by any stretch. Definitely a beginners book. I can however echo the *Eloquent Ruby* recommendation. I've nearly finished David Black's *The Well-Grounded Rubyist* which I recommend to people learning Ruby from a different language. 
I've worked on Rails apps with well over 100 different models and it worked just fine. I wouldn't handicap yourself from the start by overcompartmentalizing your code before you know exactly what benefits you'll get from it. I once inherited a webapp that was three separate Rails-based git repos that all had to be deployed in a very specific configuration to work together to accomplish what should have been the job of a single monolithic Rails app. It was a giant PITA to set up, sharing code between the applications was both very necessary and very difficult, and the associated infrastructure for both testing and deployment grew way beyond the size it could have been, if only my forebears had had the good sense not to prematurely optimize for problems they never even got a chance to encounter (scaling) because the confounded architecture made working on the app so laborious.
A database written in ruby would likely perform like shit. This "one language everywhere" trend is funny... Rails (albeit a framework, not a language) used to be uncool for being the hammer that makes everything look like a nail. Now it's different? Now we should have one hammer for every kind of nail? 
Seems like it would be a novelty only.
What was your pet project?
Yeah, the concepts in POODR aren't very complicated, but I think you get a whole lot more out of the book if you're not distracted by learning Ruby at the same time. Nice call on _The Well-Grounded Rubyist_. That's another good one to add to the list.
I'm not necessarily saying it's the way to go, but it could be an option. If you have ever worked with the MEAN stack then you would know it is quite convenient to have everything in JS. That being said, I love Ruby on Rails and will continue to use it for a long time.
You could argue [PStore](http://ruby-doc.org/stdlib-2.1.2/libdoc/pstore/rdoc/PStore.html) (part of the standard library) can be used as a pure Ruby database, although it's not a full on DBMS or daemon in its own right. Of course, you could argue writing direct to files or reading and writing XML documents is a database but people draw the lines in different places ;-)
Well node.js is written in C, correct? I guess I was referring to the interpreter, but you make a valid point.
The very first was a small Rails website to learn the basics. Then I developed Minecraft servers management panel with user management and PayPal integration.
I'd guess that folks just don't realize they could use the block version. It's not obvious that it exists. You should be able to re-open the class or extend it equally either way.
Prior to using SQLite instead, I used PStore numerous times for single system scripts that needed persistence without needing the headache or scalability of a real database. It works pretty well for that use case although I eventually moved to SQLite as the ORMs got better and because PStore is notoriously touchy whenever the marshalling format in Ruby changes in even the slightest way (and doing everything in a transaction is a PITA as well)..
ArangoDB has done some neat experiments with MRuby as an alternative to Javascript for scripting: https://www.arangodb.org/category/ruby/mruby It shares the same downsides as DBM but there is always Ruby stdlib's SDBM (http://www.ruby-doc.org/stdlib-2.1.3/libdoc/sdbm/rdoc/SDBM.html). YDBM is fun since it's a bit more useable (http://www.ruby-doc.org/stdlib-2.1.3/libdoc/yaml/rdoc/YAML/DBM.html).
YAML::Store is a PStore-like solution too, but YAML instead of Marshall for serializing: http://www.ruby-doc.org/stdlib-2.1.3/libdoc/yaml/rdoc/YAML/Store.html You might want to take a look at the nifty Daybreak gem as well: http://propublica.github.io/daybreak/
Hi speaker here :). Ruby still needs to determine the type of entities in order to store them internally in memory. However, as you can see, Ruby developers are rarely exposed to this.
In the case of sqlite, we have ruby interfaces for it, so who cares if it itself is not written in ruby? I don't care at all that all the other bits of software that I use are not written in ruby; I have an interface to them. It's called "interfaces", people. Maybe I should name a design pattern after it or something.
You should have a spec/spec_helper.rb file.. If rspecs generator doesn't put one there for you, try copying one from another Rails project and tweaking to taste...
rspec-rails has a rails generator run this rails generate rspec:install it will create .rspec spec/spec_helper.rb spec/rails_helper.rb and all specs should have require 'spec_helper' at the top 
Isn't Opal a ruby implementation in javascript? It doesnt compile to javascript.. it runs in javascript, like jquery or angular?
nm, I guess it's both.
I really wanted to use cube coordinates, but I guess I'll use axial coordinates. Actually, I just looked at it again, and axial coordinates are making more sense. I guess to generate a field, I just need to make an array of height and width ranging from -size to size, and just ignore the corners (and/or put null values in them). Then I can just act as if it is hexagonal and assign the different combinations of pluses and minuses for the direction functions. 
But you can write custom database functions that run on the database server in javascript. And the condole lets you run arbitrary javascript, and the interpretation between a javascript object and a mongo document is thin. It would be nice to do those things in ruby, although rails console with with mongoid effectively gives you the same thing. (except the custom db functions that run server side)
They interact in exactly the same way, they just determine what gets rendered as the response, corresponding to the "format.js" or "format.json" that you've defined for the action. The only difference that the controller knows is that params[:format] is "html" or "js" or "json" or "pdf" etc, whatever you've sent as the request format.
I have a js with an "ajax:success", how can I pass that xhr.responseText back to rails? i.e. say it returns an json object of searchresults, how can I turn that responseText back to rails so I can do a #each and stuff on it
I'm just learning things so I'm sure I'm wrong, but I thought mysql starts it's index at 1and not zero?
Check this post http://railscook.com/recipes/rails-view-controller-ajax-response-example/ I hope it will help you...
Awesome read by real Ruby rock star, thanx!
You don't. xhr.responseText is in JavaScript. JS runs on client, in browser. There is no Ruby in browser. If you want to #each results you have to do it in controller, before you render json view. If you want to handle the results sent from server in JS, you have to use JS. That would be with jquery something like: $.each(JSON.parse(xhr.responseText)['posts'], function(post){console.info(post)}) 
Sorry I just went over your code. What you want to do is, in JS handle products retrieved from your AJAX call and for each create a new form for "wish" with all the field you need, filled from the product data. Then just create the wish with post. The form should directly go to your create action, not new. 
I worked once with Refinery and it was okay but I have to be honest: I don't like CMS that much. Especially with Rails and the gem ecosystem I was able to make my own CMS which only does what I need with almost no code and that for multiple projects. There are implementations for almost everything. [CKeditor with file upload backend](https://github.com/galetahub/ckeditor), [JS libraries at your fingertips](https://rails-assets.org/), something like [nested set](https://github.com/collectiveidea/awesome_nested_set) and you are almost done. My issue with Refinery was that extending it's functionality was quite a hassle while it could have been so easy with "plain rails". If you just want to use it, use it. If you want to extend/modify it expect quite a bit of additional reading on top of what you might already have with ruby/rails.
&gt; How did you become a wizard without university training? You're not a wizard. You sound like a noob.
sorry late response, yeh i figured it out, been a long day at the time, it was staring me in the face
sorry late response, yeh i figured it out, been a long day at the time, it was staring me in the fac thanks guys
Well, it's acutally quite obvious, all you need is strong will, dedication, motivation and desire. What does university training has to do with becoming a specialist in a particular field?! Especially in coding! Does he really sound like noob? Neh, you sound like frustrated person. 
I'm not talking about university training. Just referring to his self-description as a wizard. A programming wizard is someone very experienced and skilled -- he is clearly just a beginner. That's all. 
May be so. But on the other hand it's a nice example, that without any education and background in IT you can become a programmer - something, that for some people is wizardy. In my opinion it's just a simplification to show the point, I hardly doubt, if this guy sees himself as very experienced and skilled. 
Here is a distributed KV store (or so it says) https://github.com/roma/roma
s/API/REST API
Is there any chance you would explain why nested set is needed? I have been working with rails for almost two years but almost entirely with front end elements/views. I am trying to understand more database aspects. I have read and re-read rails guides but it just doesn't stick because I am not doing any work while reading. So now I have a little app called the wishlist. I have run into problems where one class knows way way to much and I want to break it up into new classes but am unsure how to save everything with one form. This has been a barrier for me and have had a few people recommend nested set, but the documentation is difficult not knowing how the underlying works.
I have been using RefineryCMS for nearly two years for a production site. It's beyond decent. The developers and community have really helped out quite a bit, they are awesome. I was able to get a functional site up with nearly no Ruby or Rails knowledge. As time has gone by, I appreciate the CMS more but also know that it is heavy handed. By that I mean I do not use nearly a fraction of what's there. I have been wanting to create a very simple custom CMS myself but my knowledge has halted that. I do well with modifying views, helpers, etc but need more understanding setting up models and how they work together. RefineryCMS eliminated that need, now I want to push further.
I made this tiny gem because I couldn't find any solution for ad hoc ruby code reloading that works on Windows (e.g. does not use fork). Hope others who work with ruby on Windows find it useful. If that's you, let me know what you think!
Hi! If I'm not totally mistaken, type inference is a property of a language, not the runtime (you mean the runtime when you talk about "in memory", right?). To quote Wikipedia: "Type inference refers to the automatic deduction of the data type of an expression in a programming language." Sure, Ruby needs to know the types of the objects during runtime, but that has nothing to do with type inference. btw. there seems to be some research about type inference in dynamically typed languages. E.g. you could deduce the type of `b` in `b = 2 + 2`. You won't get very far in Ruby, though with all the meta programming going on.
It'd be nice to see a list of benefits of using Grape over Sinatra.
Just offhand from looking at it, it appears to just be a more-specialized DSL; with some shortcuts often used with APIs. For instance: defining resources to lump together things in a route; api version numbers; automatically converting things to JSON, etc. It looks to be similar enough to Sinatra though.
wow this seems great - and very timely for me at this moment. If i use it in an upcoming project i'll be sure to you let the developers know
Looks like this subreddit is for shitty titles.
Great thanks for all your help. My first thought when i hear this is to just append a html form lets see if everything works ok.
Any experience using the rubyracer to turn my ajax response into a ruby object?
This is brilliant. I've been debating using Angular for the project I'm about to start and I've been dreading the learning curve.
What is the advantage of using Rust, rather than say, Rice. I've used rice and ruby's C interface and found them both to be really great tools. Rust seems require learning a new language whose only use case is building gems... I'd like to hear the rationale from someone who has actually used ruby.h but prefers rust despite what seems to be its serious limitations. Honest curiosity, no hostility intended. 
Grape doesn't restrict you to "REST API"s, so "REST API" isn't a good title either. You could even write (web) APIs which aren't HTTP-compliant. So, what's your point?
[Rust](http://www.rust-lang.org/) is a general purpose low-level language, that just happens to be useful for writing Ruby gems since it has some similar properties to C. It has advantages over C for low level programming (including but not limited to writing gems), because it is memory safe and has a stronger type system: the compiler gives a lot more assistance. [Website](http://www.rust-lang.org/) blurb: &gt; Rust is a systems programming language that runs blazingly fast, prevents almost all crashes*, and eliminates data races. 
 I was under the impression that it acts like CoffeeScript
That looks pretty cool, I'll have to play with that a bit.
Then why not "Web API"? API isn't about Web, s the title is misleading.
You don't want to do that. User JS in browser to build your form properly with all the fields. Then when you submit it, you will get proper params with proper attributes for your Wish.new().
"Stuck"!? Nice place to be "stuck"
I'm still not sure why this confuses me: "systems programming aims to produce software which provides services to the computer hardware (e.g. disk defragmenter). It requires a greater degree of hardware awareness."[0] Rust should be used to write something like that and yet a gem's internals somehow doesn't fit into that category and yes, I realize I'm nitpicking. [0] http://en.wikipedia.org/wiki/System_programming
&gt; Many cry "overkill" when design principles are applied to trivial problems. And for good reason: in the context of work, excessive embellishment gets us into trouble. Complexity costs us time and money. &gt; This talk explores how stepping outside of the realm of work and applying outrageous engineering practices to toy problems can deepen our understanding of the trade-offs that we make. Comically simple problems provide the perfect ground for developing actionable heuristics which can be applied to those monstrous complexities that we face in the real world.
Most other disciplines have what are called drills and she mentions it in the talk. If toy problems are not how you'd like to practice programming drills then one other way I've found that helps me stay engaged is re-implementing a medium level project in another language. My go to projects are parser combinators, lisp interpreter, and sometimes a ray tracer. I've noticed that after struggling with porting it from one language to another I have a better understanding of both languages.
yup ended up going that route, works great, now just need to set up the ajax so the section above refreshes with the new wishes
Do not ask to ask, just ask. 
You would expect it to only be 2x faster because you assume flat_map will map and flatten in one pass of the enum, rather than 2 when you call map then flatten, but it looks like the implementation in clever enough to speed it up even more!
Your best bet is [ChunkyPNG](https://github.com/wvanbergen/chunky_png) which is a pure-ruby PNG library. red = ChunkyPNG::Color.rgba(255, 0, 0, 255); green = ChunkyPNG::Color.rgba(0, 255, 0, 255); blue = ChunkyPNG::Color.rgba(0, 0, 255, 255); png = ChunkyPNG::Image.new(20, 20, ChunkyPNG::Color::TRANSPARENT) # You can now set the color of pixels in this 20x20 PNG like so: png[5, 12] = red # ... png.save('filename.png')
Exactly. What would `["a", :b, {c: 1}].sum` return?
We'll have to disagree there. JRuby is awesome if you need one of the unique features it offers but otherwise... [this](http://www.isrubyfastyet.com/).
JRuby is supposed to be quite fast for longer running processes.
I'm not sure if I understand your problem (maybe you gist some code?) but nested set does a simple thing: It adds three integer values to your table and therefore combining to "principles": nesting and sorting. * **parent_id** the ID of my parent (that's why it's called nested) or NULL/nil to be root element) * **lft** the ID of the item left (previous) to me or NULL (then I'm the first entry) * **rgt** the ID of the item right (next) to me or NULL (then I'm the last entry) The advantage of using left&amp;right instead of a sort column is that you don't need to update all records in the current nesting. With left&amp; right it's max. 3 items. This allows you to have a sortable and nestable list of items (which I use for pages =&gt; navigation). With some javascript and ajax you get something like [this (the blue button would enable you to rearrange the items)](http://files.sven.bmonkeys.net/images/Administration__Seiten-20130619-150017_1065847_2014-09-25_18-09-29_2014-09-25_18-09-34.png).
ActiveSupport thought about this as well: Loading development environment (Rails 4.1.2) [1] pry(main)&gt; [].method(:sum) =&gt; #&lt;Method: Array(Enumerable)#sum&gt; [2] pry(main)&gt; [].method(:sum).source_location =&gt; ["/Users/chaos/.gem/ruby/2.0.0/gems/activesupport-4.1.2/lib/active_support/core_ext/enumerable.rb", 20] [3] pry(main)&gt; show-source [].sum From: /Users/chaos/.gem/ruby/2.0.0/gems/activesupport-4.1.2/lib/active_support/core_ext/enumerable.rb @ line 20: Owner: Enumerable Visibility: public Number of lines: 7 def sum(identity = 0, &amp;block) if block_given? map(&amp;block).sum(identity) else inject { |sum, element| sum + element } || identity end end [4] pry(main)&gt; [1,4].sum =&gt; 5 [5] pry(main)&gt; ["foo", "bar"].sum =&gt; "foobar" 
Your description sounds a lot like PPM (http://en.wikipedia.org/wiki/Netpbm_format). With PPM (or it's sibilings) you can write plain ASCII to a file and have an image. It is not efficent space-wise, but conceptually simple and can be converted to jpg/png/... with any image editing program.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Netpbm format**](https://en.wikipedia.org/wiki/Netpbm%20format): [](#sfw) --- &gt; &gt;A __Netpbm format__ is any graphics format used and defined by the [Netpbm](https://en.wikipedia.org/wiki/Netpbm) project. &gt;The __portable pixmap format__ (__PPM__), the __portable graymap format__ (__PGM__) and the __portable bitmap format__ (__PBM__) are [image file formats](https://en.wikipedia.org/wiki/Image_file_formats) designed to be easily exchanged between platforms. They are also sometimes referred to collectively as the __portable anymap format__ (__PNM__). &gt;==== &gt;[**Image**](https://i.imgur.com/lCIuluC.png) [^(i)](https://commons.wikimedia.org/wiki/File:Example_of_ASCII-art_turned_into_a_bitmap_scale20.pbm.png) --- ^Interesting: [^Netpbm](https://en.wikipedia.org/wiki/Netpbm) ^| [^Image ^file ^formats](https://en.wikipedia.org/wiki/Image_file_formats) ^| [^FFmpeg](https://en.wikipedia.org/wiki/FFmpeg) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cks9z0s) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cks9z0s)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
If it helps, the target age range is 8 to 12.
By sharing chapters of the book with readers in advance of printing it, getting their feedback, we'll make the experience for thousands of kids trying to learn Ruby that much better in the final, printed version that will appear in libraries, bookstores, and so on. Hope that helps to explain. 
This looks like a good possibility. Thanks!
Programming is hard! For kids who aren't yet reading/writing at adult levels, there's ScratchJr, a project out of MIT, the same group that does Scratch. It's free app for the iPad that's nice and easy, visual, but even that's aimed at 5-7. You can read more about it here. [ScratchJr.org](http://www.scratchjr.org/)
I like it. If I were given such a book when I was 8 (well, and also a computer), I would go crazy! Is there a mailing list or something for us to know when it's finished?
I had that kind of book when i was 8, BASIC. I went thru it hundred times and got absolutely nothing. Children refuse to understand unintuitive things such a byte, variable, function call and passing arguments, order of execution change. It's even worse with Ruby, since it's way more complcated, it has OOP and string interpolation, hundreds of methods in each object, complicated data structures, dynamic typing. I would prefer someone gave me a Forth book back those days. Though I have doubts they had Forth book for kids back those days.
Can confirm it's similar to Sinatra. Source: I wrote a Grape-flavored DSL for Sinatra at a previous job.
Important: [].sum # =&gt; 0 unlike nil when using `inject(:+)`, though `inject(0, :+)` may be used. [].sum 3 # =&gt; 3 Non-zero default.
What would You expect for `max` to return for this data?
touche
I would expect a plain call to Enumerable#max to return an error since you can't compare a symbol with a string, etc. Sure enough: ``` irb(main):005:0&gt; ['a', :b, {c: 3}].max ``` ``` ArgumentError: comparison of Symbol with String failed ```
Amit has fantastic info on all sorts of grids, including hexagons: http://www-cs-students.stanford.edu/~amitp/game-programming/grids/ 
Ruby itself is fine on windows if you use the ruby installer and add the devkit, but certain gems never work out of the box, and compiling Ruby on something like VS2010 is a very arduous task due to the lack of documentation. It's quite possible to make it work, but if you also want ruby gems to work, on the other hand... 
All those methods rely on the Comparable module. What would `#sum` use?
Is there a serious gem for this? Interesting library, but people already don't take me serious. I don't need them not taking my code serious too.
It is. Without any data to back that up, I'll just say I use a hybrid environment of JRuby (1.7.13; for multithreaded and long-running daemons) and MRI (2.2; for rails and some quick background tasks). JRuby is a memory hog, like everything that runs on the JVM. But its thread support is blindingly good. I regularly run &gt; 1k threads on a particular JRuby-optimized daemon, and it is truly impressive. IO rates are really good as well, although MRI is a bit faster there.
Very cool. Really don't understand a lot of what's happening under the hood here, but it looks really java-y.
Topics at present look rather amature, but i think it makes for a good foundation equally. Will be interested to see how this evolves. I got A LOT of value out of railscasts when i was learning, and I have been hoping someone else would try to fill the void. 
Eh, I don't really think that page is very good for comparing implementations. It tests: * Single-threaded performance * Using Webrick * With Rails 3.1 (Default config.threadsafe off) * On a macbook laptop Which is hardly representative of a production setup. It is like comparing sports cars' performance but limiting them to 1st gear only on a dirt road. [This](http://www.madebymarket.com/blog/dev/ruby-web-benchmark-report.html) is a better representation I think since it also compares frameworks and app-servers, although the hardware is still a Macbook.
yes. the use of `for` in ruby just makes me squirm `(count).times` does the same thing
Addable
Sweet, nice and simple. Just one question, running the math directly like this, would that tax the server if you got a lot of load? (Rails newbie.)
[Hashie](https://github.com/intridea/hashie) can probably give you at least some of the functionality that you're looking for.
I don't understand this script. Would it be possible to walk through what's going on here. Also, what does Complex pertain to?
No, I assumed someone had thought of it and rejected it. I just wanted an motivation, for my own education. :)
Yeah, it not being applicable is reasonable. The reduce versions are not very readable though :)
Ruby on windows is always a bad time. Introduce yourself to Vagrant and your life will be much easier. 
'Complex' refers to [complex numbers](http://en.wikipedia.org/wiki/Complex_number), which to simplify are what happen when you take the square root of -1, which is called i (greek letter iota). The interesting propert of i is that it's powers repeat: i^1 = i, i^2 = -1, i^3 = -i, i^4 = 1, i^5 = i. In general, i^4p+q = i^q where q = 0, 1, 2, or 3. Also, i^-1 = -i, and any complex number can be expressed as (a+bi) Using these properties, we can generate fractals. Take a function, say f(z) = z^2 + 1. Start with z = (2 + 3i), we get (-4 + 12i). Put that back into the equation, and you get (-127 -96i). If you repeatedly evaluate f(z) (something like f(f(f(f(f(f(z)))))) ) the numbers will either explode to infinity, or drop to 0, or loop around without going anywhere or exploding. With this background, I can explain fractals. For any point (x,y) make a complex number z = (x+yi). Iteratively evaluate f(z), and count how many iterations it takes for both x (z.real) and y (z.imag) to exceed some threshold value, say 5. If it takes more than 100, however, the script gives up and returns 100. Each number of iterations is stored in an output buffer. Then, the script runs through the buffer, generating colours. The colours are generated by evaluating `(max_number-actual_number)/max_number * 255`. So if it takes a maximum of a hundred iterations, then each channel (Red, Green, and Blue) are set to `(100-100)/100 * 255 = 0`, and the region is black. If it takes one iteration then each channel is set to `(100-1)/100 * 255 = 252`, and it is nearly white.
Yeah Java was my first language and I enjoyed it. I would appreciate it if you showed my a more idiomatic Ruby solution though :)
All I can say is, if you want speed from a programming language, Ruby shouldn't be on your radar of solutions. That being said, while there are always slower and faster ways of doing things, *in general* we aren't looking for the most computationally efficient solution in Ruby, we're looking for the cleanest solution that makes the developer happy, not the processor. If you want to learn Ruby, I suggest you throw away notions of computational efficiency and soak in the various object oriented ideas and solutions that are floating around. You can always make things faster later, if you need to. If you do this, I assure you that you will come to love Ruby as a new tool in your programmer's tool belt. It's not the solution for everything, but when it is the solution, it's an awesome ally. &gt;I'm used to just casting a char to an int at a fairly instant rate. As far as the nitty gritty of Ruby is concerned, there are no chars in Ruby. A single-length character String is just that, a String object. It's an object in heap and it does a lot of fun, cool things for you, and speed is not one of them. There are no primitives in Ruby. Everything is an object. Even integers. 3 + 2 This may look like the plus operator over two integer primitives, but it's not. It's the plus method on the integer object 3 passing the integer object 2. 3.+(2) That's a more accurate representation of it (and is also valid syntax in Ruby). It's a little weird at first coming from a lower level language, but it will all make sense after a while, and things will start to come as little or no surprise. Good luck and happy coding! Also, if you have any other questions, feel free to ask!
You'll simply be much happier in the long run if you make friends with Vagrant+Virtualbox. You'll waste far too much time trying to get things to play nice on Windows. I'm sorry if this is not the answer you are looking for :(
Thanks, that's a far more detailed answer than I expected!
Holy crap my first reddit gold ever this has literally made my day.
Great answer. I'd like to add one thing, though: &gt; Everything is an object. _Most_ things in Ruby are objects, but many things are not. For example, keywords, statements, and operators are not objects. That said, Ruby provides lots of tools that let you wrap these things so that they look like they're objects. For example, there is a `Method` object (though it is not itself a method), a `Proc` object, and so on.
Hey, I'm there too, and thought it looked fun. I'm trying to figure out a way to get my company to pay the licensing fee for RM... The last time I looked into RubyMotion, I thought it looked like almost as much work as learning Objective-C, but under-os looks like it would close the gap for me.
It kind of looks like a normalization difference. When typing in a console in ruby, it will use the composed form, meaning user the single character 'ö'. In OS X, it seems the file names are stored in the decomposed characters, meaning first a 'o', and then a '¨' that places itself on the previous character. That encoding would just do this transformation which you can do with active_support: "my ö string".mb_chars.normalize(:d) to get the decomposed, and :c to get the composed. Note, i could be wrong, i don't have a Mac and so i cannot test.
Maybe that depend simply of how the file was created, if it was speciying a composed character there is no reason to store it differently
Sweet. You should give it a go and let me know whether you think it made things easier for you.
Never heard of it.
It does look like a normalization issue alone at first, but I noticed the docs for [CPAN's Encode::UTF8Mac](https://metacpan.org/pod/Encode::UTF8Mac) say they don't decompose everything possible, a few ranges are excluded. So it's uh, *normalized but not Unicode Normalized(tm)*?
That's exactly how I feel. I think if nothing else it would be fun to whip up 1st and second interations
Generating a raw `.ppm` file, clever! I was expecting you'd use [chunky_png](https://github.com/wvanbergen/chunky_png#readme)
I wanted a quick solution. I have a program to convert it that I call using `Kernel.``
Actually, in HFS+ the encoding is specified like this for over 16 years. No surprises here. &gt; Mac OS Extended (HFS+) uses canonically decomposed Unicode 3.2 in UTF-16 format, which consists of a sequence of 16-bit codes. (Characters in the ranges U2000-U2FFF, UF900-UFA6A, and U2F800-U2FA1D are not decomposed.) &gt; &gt; All BSD system functions expect their string parameters to be in UTF-8 encoding and nothing else. Code that calls BSD system routines should ensure that the contents of all const *char parameters are in canonical UTF-8 encoding. In a canonical UTF-8 string, all decomposable characters are decomposed; for example, é (0x00E9) is represented as e (0x0065) + ´ (0x0301). To put things into a canonical UTF-8 encoding, use the “file-system representation” interfaces defined in Cocoa (including Core Foundation). Source: [Apple Developer Documentation](https://developer.apple.com/library/mac/documentation/macosx/conceptual/BPInternational/Articles/FileEncodings.html)
Raise an issue with remear. https://github.com/remear/jewelrybox
The trick is that OSX uses "combining diacritics" for extended characters. I don't know why they decided to do this, but it seems like it would make it easier to support searching accented text using non-accented search strings. Here's something to try: str.start_with?("mo") You should get true for that.
Check out Drb
Indeed :) [2] pry(main)&gt; str = File.basename(Dir["Desktop/*"][2]) =&gt; "möp" [3] pry(main)&gt; str.start_with?("mo") =&gt; true
solved: something (stack overflow?) told me to have this command in .bash_profile. I commented it out, and now sass compiles fine. (I also upgraded ruby and sass before doing this) # export PATH="/usr/local/bin:/usr/local/sbin:~/bin:$PATH"
I don't think I've ever needed to do this with a rails app... can you provide a more concrete example where this is necessary?
you're right in that Rails doesn't really do the modular thing so well out of the box. Rails lets you get up and running quickly, and as such a problem a lot of rails apps face with a usual team including new developers, is around the 1 year mark - you're gonna find a lot of bloated models, and messy interdependencies. The dependency injection pattern you describe usually involves mocking and stubbing to test and *is* generally considered best practice, though in my experience - it's an advanced technique that isn't always followed. Lookup guides on the difference between the two and when to use them in ruby, to get a feel for the ruby best practice here. Second question is pretty straightforward. It depends if you're writing an application or a library. For applications: use bundler. Read up on it here http://bundler.io/ - it manages the dependencies of other libraries (gems) your application needs. Rails has support integrated, and it's best practice for other apps too. For releasing/developing libraries - the format is a ruby gem. Gems format their metadata in a gemspec file, which is where dependencies on other gems are declared etc - read more at http://guides.rubygems.org/make-your-own-gem/
Thanks for the informative answer and resources! So, if you don't mind expanding on your answer, what do most Rails apps do when they hit that point and need to start modularizing but don't want to have to manually instantiate 10 different objects of various classes every time they want one class that is directly/indirectly dependent on the other 10?
It's not so much that you don't need to inject your dependencies, it's more that you don't need a dependency injection container to fake the overriding of things. Dependency injection and Inversion of control are still very important concepts.
Thanks for the reply! Example: I want to send a message to a user in some webapp. This should persist the message to the database, related to both users, send an email to the receiving user, and set a status on the user's inbox. To do this I need to get a Mailer class that knows how to send mail. I need a templating class that knows how to build the email template from the 2 user objects and the message. I need some sort of database connection to get the User objects and persist the message object. I ideally would also like an abstraction layer on top of the database connection, like Active record. Lets say I also need some validation class where I have rules defined for what a message constitutes a valid message defined in some sort of configuration file that must be loaded by the validator. So my validator requires a class to load and parse that configuration file. So as I see it here is my dependencies (not s: * MessageSender requires Validator * Validator requires ConfigParser * MessageSender requires Emailer * MessageSender requires Templater * MessageSender requiresUserRepository * UserRepository requires DatabaseConnection So in this example, to do all of this with proper dependency injection I'd have to manually instantiate 6 objects to finally get to the one I want. With what I'm used to in Symfony/php I'd just define these steps for instantiating each class in a configuration file, and get my new objects from a container that builds them for me from that config file. I imagine there is a way to circumvent this extra effort in ruby as well.
Oh, container's aren't for fake overriding dependencies. Tests in php actually should never involve the container. Its just for defining how objects are used to instantiate other objects so it doesn't need to be done manually. So getting a new object that requires 3 other objects to instantiate becomes $container-&gt;get('MyClass'); and the container instantiates an object of MyClass and instantiates the objects it depends upon and injects them for you, then returns it to you.
So, how is def emblem @emblem end Different than attr_reader :emblem # ? It seems basically identical to me. You should still be able to be expressive and build any other interfaces you want, but that last code snippet stuck me as odd. 
As with anything, if you don't refactor as you go - you'll hit the point where you suddenly notice your productivity drop because everythings interlinked and you can't reliably change anything without something else breaking in 5 places. If you can, try and keep your technical debt to a minimum with refactorings as you go. It might not be worth it to write a fully modularized, generic format for everything you implement. But paying attention to keeping responsibilities of classes low, and refactoring bits that get unwieldy frequently goes a long way. I'd also say that 10 is a heck of a lot. If you develop with Single Responsibility Principle in mind, even if you don't follow it religiously - ideally you'd be looking at each class touching 2-3 other classes max. Anything approaching more is probably trying to do too much in one class, which is usually a sign of abstraction at the wrong level. I can highly recommend http://www.poodr.com/ - Practical Object Oriented Design in Ruby as a great guide as to how to achieve good modular, OO design in ruby. Rails doesn't really nudge you in this direction, it just gives you an empty controllers/models folder.
It looked really nice, but when I became better with the command line, just using RVM was simpler
Ignore rails: 50%+ of what it pushes is right for the short term, wrong for the long term. IE: http://david.heinemeierhansson.com/2012/dependency-injection-is-not-a-virtue.html vs http://solnic.eu/2013/12/17/the-world-needs-another-post-about-dependency-injection-in-ruby.html To speak more directly to your question, most of the time in both PHP and Ruby I've avoided needing a container for DI - a few factories to help build complex/annoying objects like reading configuration from disk perhaps; but that's about it. A major exception to this is factories in tests - https://github.com/thoughtbot/factory_girl is fairly commonly used. Another major area that you usually see the value of DI in is working with external services - sticking in fake services for example. https://github.com/vcr/vcr is a good tool with some limitations. How it does its magic to change how HTTP libraries work is both Dark and Scary(tm), but so long as you control the global state entirely (as with a unit test) it ends up being more helpful than not. Finally, writing testable code is mostly about finding testing "seams" - places you can unpick, stick in something you control, and observe the effect. In Java/PHP/etc the new operator, class definitions, etc are all pretty much set in stone. In ruby there's the ability to revisit some of those areas after the fact - it's very hard for one knucklehead writing an upstream library to take choice away from you.
these are what are known as complex object factories. this has nothing to do with a DI container or a DI framework.
I'm sorry but you are mistaken. A factory is a class in which you use code to construct an object from scratch as the steps might be too complex to express is a simple configuration language (yaml, xml, ect...). The bare bones definition of a DI container is simply a place where you define how dependencies are injected into an object so that all of its required dependencies are met, however you want to do it. Setter injection, constructor injection. It has the added benefit of making swapping out implementations of a certain dependency much smoother. Most DI containers allow you define factories for more complex objects, but the majority of all your definitions will be simple configuration (I prefer yaml in symfony). 
Very helpful answer, thanks! Yeah DHH has always rubbed me the wrong way, and for a while that kept me away from ruby as I had the preconception that ruby more or less was just rails. After working with some of the tools written in it I decided to take a more in depth look at it. Thanks for the links, I'll be reading them shorty.
Oh, my point of 10 is that it wouldn't directly have 10 different classes injected, but maybe 3 classes, which might have their own dependencies that need be injected so that our new class indirectly requires 10 objects to be constructed before it can be also. I'm definitely with you that no class should require 10 objects to be injected, that's just a sign of poor(lazy) design. I'll definitely look at that link as well. Thanks again!
The whole section about attr_readers is irrelevant, just make them private... You should never know even about your own object's implementation details, including whether or not you are using instance variables. The only thing which knows about instance variables is a constructor/initialize method. class Player #... private attr_reader :emblem end 
That is an interesting point you bring up there. It will make you internal code of course make a lot more readable. I think I'll update the article in regards to this concept. So you would equally favor the method driven assignment over direct instance variable assignment? def specify_emblem(*whatever) self.emblem = Emblem.new(*whatever) # ... I only use the actual instance variables in the lowest level of abstraction inside the objects. There is an older post which (though not covering this particular topic) gives you an impression of what I mean: http://jakob.io/wshfl Still is you feedback somewhat not contradictory to the statement that directly exposed instance variables can violate UAP. It does more focus on a cleaner approach for the internal implementation of your objects. Did I get you right there? Cheers
&gt; So you would equally favor the method driven assignment over direct instance variable assignment? Yep. If we just give ourselves some fake type annotations, we can easily see the difference in the methods. # EmblemAttributes -&gt; () def specify_emblem(*whatever) self.emblem = Emblem.new(*whatever) end private # Emblem -&gt; () attr_writer We don't *have* to expose the attr_writer, but it still represents the common internal interface for setting an Emblem instance on the player. And then when we have more complex interactions as part of that behavior, they have a natural place to go # EmblemAttributes -&gt; () def specify_emblem(*whatever) self.emblem = Emblem.new(*whatever) end private # Emblem -&gt; () def emblem=(other_emblem) @emblem = other_emblem update_scoreboard email_badge end
If you're talking about injecting for testing - the point is to inject a fake object that has the same interface - but wouldn't depend on the actual other components.
You could take a look at Eratosthene's Sieve^[1] to quickly find prime numbers. It's blazing fast and not too hard to implement in Ruby. [1](http://rosettacode.org/wiki/Sieve_of_Eratosthenes#Ruby)
I've not made any attempts to optimise this, but I split it up a little so the prime check is in its own function, and has a way to test it. http://pastebin.com/qTtLUgXu This actually optimises a little as it's not doing the valid check on every step of the loop any more. However, since we already made the number an int, it should be fairly clear we could actually just replace `invalid_number` with a check for `number &lt; 2`. I'm sure people will pick issues with my style (#ruby certainly did that one time), but it should now be a simpler job to work on a faster `is_prime`. Next thing outside of that I would attack would be the slightly odd double `while true` loop, but that's needed for now because the second prompt is at the *end* of the outer loop.
This was my first try to post an article to reddit, I thought it could be a valuable channel for feedback. And in fact it is. Thanks I added this particular point as last paragraph of "Notes on Ruby" to the article. I also added a modification to the getter to show a possible benefits of explicit methods.
One thing you should start to think about (and others have started hinting at) - separate the concerns. You've got the logic to check if something is a prime or not; and you've got the bit that prompts the user/displays results/etc. Knowing where to draw the lines between the two responsibilities is one of the hardest but most important lessons about programming that rarely gets explicitly taught. You aren't going to speed things up much re the large prime issue - http://www.amsi.org.au/teacher_modules/Primes_and_Prime_Factorisation.html#prime_testing_and_factorising_a_number offers some insights though. 
This is in fact a really good idea to use attr_ for internal implementation. I think it would bloat the current article but it is worth to dedicate a distinct article to this topic. Would you mind me writing about this idea? :) (of course, I can reference your github or reddit profile for thought-provoking impulse, if you want) Cheers!
Common problem I see with people learning Ruby (or any language for that matter) is an over dependance on loops. I recommend making the Enumerable object in Ruby your BFF. As for your code, your algorithm can be greatly simplified using a block method on an enumerable. In this case lets use an array of the "base" primes (prime numbers less than 10). primes = [2,3,5,7] We know that all non-primes will be divisible by one of these numbers. Now we can pass the inputted value into a block, this case, we will use *any?*. This block will perform an action on all values in the array and return true if all are true or false if not. primes.any? { |n| number != n &amp;&amp; number%n == 0 } This process will return true if the inputted number **is not prime**.
The woes of not using Rails! This seems far more complicated than it really should be. I would do this: * Get the config * Validate the input * Generate the email object, (subject, to, from, content, etc) * Persist it with a database *model*. * Send the email. You're trying to do too much with one object. Give each class a single responsibility and build off of that.
There are some shortcuts in trial division that may help your running time. One of which is the idea if any number n has factors one will be less than \sqrt{n}. This means you only have to try dividing by primes &lt; \sqrt{n}. In addition if you keep an index of all primes encountered in your algorithm you won't have to compute 1 to \sqrt{n} for every new number. http://en.wikipedia.org/wiki/Prime_number#Trial_division EDIT: Sources
That's a very "rubyist" way of going about things, but there are some problems with your math. You claim that all non-primes will be divisible by one of your "base" primes, which is a hugely false assumption. For example, take 143. Using your method, this would come back prime while it is actually composite.
like other said, breaking things up into methods helps, as well as getting rid of some of those while true things, would be nice. for example, your outer while loop is easily replaced by method control flow, and your inner while loop should really be a more controlled thing like each over a range. off the top of my head I'd write something more like this. not saying it's nessecarily the best way to write it, but it can serve as an example of one of the many ways to do things in ruby. def welcome_message guess.... end def get_number puts "number plx" gets.chomp end def test_number num = get_number case when num == "exit" return when num &lt;= 1 puts "invalid input" when num == 2 puts "prime!" else puts modulo_check(num) end return test_number end def modulo_check(number) (2..num-1).each do |n| if num % n == 0 return "not prime!" end end "prime!" end welcome_message test_number
Racc is very much relevant, and is used today in production. For example, Rails uses it for parsing routes. &gt; Considering I have a really simple grammar and need to work quickly on this project, are LALR parsers even a good idea to begin with ? Depends, do you think you'll need to extend the grammar any time soon? Hand writing parsers certainly is possible but they can get messy pretty quickly. &gt; How is the Windows support for Rex/Racc ? And for Treetop or Parslet (or similar) ? Racc should work on Windows just fine as far as I'm aware of. &gt; As JRuby might be an option later on, how is the support for those parser generators ? Racc runs on MRI, Rubinius and JRuby so whichever one you pick you should be fine. 
Sure no problem. I'll pm you. 
&gt; Depends, do you think you'll need to extend the grammar any time soon? Hand writing parsers certainly is possible but they can get messy pretty quickly. I may, but as it is a school project the main goal is to finish it *in time*. But still, I doubt the grammar would be drastically changed if I have to extend it. And thanks for the support confirmation !
I second this suggestion. No reason to reinvent the wheel. Although, making your own #prime method is a good exercise. I would recommend that OP read through the libraries, as it is a great way find out everything that is available to you, should you ever need it. God bless the devs who made the prime lib, not the mention the incredibly convenient #prime_division....
Nice refactor!
 require 'prime' Prime.prime?(n)
Author of GoRails here! Happy to answer any questions you guys have! :)
Yeah, I've been starting slow and working my way up. Recording good screencasts was a lot tougher than I thought it would be at first so I have huge respect for all the time Ryan, Avdi, and all the other screencasters put in. Let me know if you've got any topic suggestions for me. A lot of newbies on the site right now so I've been tailoring towards them for now.
If time is your constraint then I'd stick with Racc. Sure, the grammar is a bit dodgy but it's faster than writing your own LL/LALR parser from scratch.
Yeah, this example wasn't great. I was trying to keep the example simple while still give semi-feasible situation. In the real world, if this is all I was doing I'd forgo all the extra indirection and do it very similarly to how you described. In less trivial situations, I've found the additional modularity useful. But I'll see how doing things in a more ruby way works for me and adjust as I go. Thanks for the responses!
What caadbury said. Read on accessors. http://www.rubyist.net/~slagell/ruby/accessors.html Basically, you need a method that accesses that value, you can manually make one by defining the method and making it return @lyrics, or use attr_reader. The link above will explain all of this in detail.
Ok, thanks for the quick response! So I can call @lyrics from inside myClass, but to get it from outside I need to define a method and call that?
Use axial coordinates (r,q), but calculate the third cube coordinate (s = -r-q) as needed. Then in your loop from -size to +size, you already know -size &lt;= r &lt;= +size and -size &lt;= q &lt;= +size, but you need to also check the third part of the cube coordinate, so you calculate s = -r-q and make sure -size &lt;= s &lt;= +size. That'll cut off the corners. 
 number == 0 || number == 1 || number != number.abs could also (ignoring decimal numbers, as we are) be rewritten as number &lt; 2 
*instance variable; there's a pretty significant difference.
My version - separates logic slightly differently def test_number (number) begin case simple_prime_check(number) when true puts "#{number} is a prime number." when false puts "#{number} is not a prime number." end rescue puts "Invalid number or input!" end end def simple_prime_check(number) if not number &gt; 2 raise "Invalid input" elsif number ==2 return true else (2..(number/2)).each{|x| #number/2 as no number greater than half with be a factor if number % x ==0 return false end } return true end end test_number(4) test_number(5) test_number(6) test_number(7) test_number(-2)
Also worth mentioning that ruby's attr_whatevers are optimized and much faster than writing your own methods.
In addition to what others have said, in general it's good to remember that when you have anything in the form `a.b`, it always* means you're attempting to call a method named `b` on the object `a`. ^(*for almost all intents and purposes)
You only need to define initialize if you want to run code as soon as you create a new instance. It doesn't matter where you put your accessors, because they are just shortcuts for writing out the whole method. Because those methods are called later in the code instead of being run sequentially, you can put them wherever you like inside your class definition.
Okay, will do. Thanks a lot for your help :)
uhhhh, I don't think you know what you're talking about. irb(main):001:0&gt; class A irb(main):002:1&gt; def do_something(args) irb(main):003:2&gt; self.emblem = args irb(main):004:2&gt; end irb(main):005:1&gt; private irb(main):006:1&gt; attr_writer :emblem irb(main):007:1&gt; end =&gt; nil irb(main):009:0&gt; a = A.new =&gt; #&lt;A:0x007fc59aaa0868&gt; irb(main):010:0&gt; a.do_something('1') =&gt; "1" irb(main):011:0&gt; a =&gt; #&lt;A:0x007fc59aaa0868 @emblem="1"&gt; And I never said you should use your method setters in your initialize, I explicitly stated quite the opposite. That the only thing that should know about instance variables *is* your initialize method. 
The idea is that internal state should not be exposed unless explicitly needed. Instead of reaching through objects to their internal state to perform actions on their collaborators, you can (should?) define behavior that federates access to behavior on your collaborators. Or to put it simply: "tell, don't ask"
What problem are you solving? Why are those the only two you are evaluating?
The submitter isn't talking about Unix piping, which are just one-way binary data I/O channels. He's talking about using the syntax as a language construct for calling methods.
I like slim over html in rails projects. Also, formtastic is a really nice form builder that most people would use over coding forms by hand. You should also checkout the asset pipeline as it lets you combine many different preprocessors on your html.
+1 for Slim templates. It took me a little while to adjust but now, ERB just feels wrong.
Apart from other things, there's SEO. Google does a half-assed AJAX crawling implementation (the '#!') but that doesnt always work nicely (If you know a good implementation, please let me know!). Anything that needs to be crawled needs to be output first time in plain html, not on button clicks or form submits. This mixing of crawlable content and interactive elements is a kind of thing the user expects.
If you asked me, I would say it depends on your what kind of data you are dealing with. For lots of kinds of data, a full page reload is fine, especially if you make use of turbolinks (which will reload only the body and use pushstate to update the URL.) But for some kinds of data, particularly small models that users want to be able to CRUD quickly, like comments, JavaScript is the way to go. I think it is the viability of this mixed methods approach that makes Backbone so popular in the rails world. 
Haml or bust 
Try looping(ARGV[0].to_i, ARGV[1].to_i) ARGV is an array with Strings as elements, so you need to cast them to integers if you want to do mathy stuffs.
Yeah, `3.5` is just `3.send(5.to_sym)`. :P
Nothing is always the solution.
Hah, well moving states and being away a week in Japan will do that. I'm back and settled now, so back to writing/coding.
A well working single page app is ideal, but there are many times when a normal reload is quick enough that the additional development time to make it single page is not worth it. Also, making a well working single page app with good separation of concerns, code clarity etc etc is something that often fails, and you end up with an application that is single page, but hell to maintain. Keeping to the default rails views with a sprinkling of ajax lets you develop a lot in really short time, and as long as you keep your views clean, a reload doesn't bother anyone. The other option is to go with a full on javascript framework setup, and not use any rails views at all, only using rails as a json api to the javascript.
`ARGV` can be used as an Array. Its elements are Strings. Btw, looping in Ruby is rarely done with while. You're example could make good use of `x.upto(y) do ... end`.
The `|` operator is just function composition from left-to-right (rather than the standard right-to-left of the usual `.` or `*` composition operator) As a result, we can trivially implement it as just a monkey-patch on `Proc` class Proc def |(other) -&gt;(*xs) { other.call(self.call(*xs)) } end end Then using his proc definitions: Mooify = -&gt;(string) { "Cow said: " + string } Reverse = -&gt;(string) { string.reverse } We can simply go: (Reverse | Mooify).("hello") #=&gt; "Cow said: olleh" Now, if we define a `pipe` function that does this: def pipe(*xs) -&gt; { xs } end And provide one final monkey-patch to `Proc` to add this: class Proc def &gt;=(other) other.call(*self.call) end end Then we can go: pipe("hello") &gt;= Reverse | Mooify #=&gt; "Cow said: olleh" Where the `&gt;=` operator is to be read as injecting a value into a chain of functions. Note this process also works with methods, by utilizing `Symbol#to_proc` pipe("hello") &gt;= :upcase.to_proc | :reverse.to_proc | Mooify #=&gt; =&gt; "Cow said: OLLEH" This process is also a lot more powerful if you add partial application into the mix pipe(3) &gt;= mult(5) | add(1) | negate #=&gt; -16 I wrote a library about a year ago that implements all this stuff ;) [funkify](https://github.com/banister/funkify) 
cute lang-specific list-comprehension/iterator-syntax-sugar confuses newcomers. in my old age i try to make my Ruby read as similar to C as possible, ignoring all the silly tricks it allows
I hate turbolinks. Hardest bugs to squash ever. I'd rather learn a new fancy framework than use turbolinks.
Ruby is not a good fit for numeric and bitwise computations. That's it. This is the reason OpenSSL and other computation heavy tools are not being rewritten in pure Ruby, though it would have been much easier to read and maintain. If your code is for something else, Ruby is fast enough.
If you want to have any code run as soon as you create an object of that class, then you would add that functionality to the initialize method. If you want to make a @classVariable respond to accessor methods, you just have to include attr_accessor or attr_reader to automatically define the appropriate methods. What I mean to say is that defining the initialize method is completely independent of the accessor methods. You could definitely pre-set values in the initialize method, or you could go and poke another object or even create another object.
Here are three ways to produce your results: 0.upto(3).map { |i| i + i } 4.times.map { |i| i + i } Array.new(4) { |i| i + i } 
This is what [`Range`](http://www.ruby-doc.org/core-2.1.3/Range.html) and its [`#step`](http://www.ruby-doc.org/core-2.1.3/Range.html#method-i-step) method are for. (0..6).step(2).each {|num| puts num}
You could use a [range](http://www.ruby-doc.org/core-2.1.3/Range.html) for this, and use the `select` method (see the [Enumerable module](http://www.ruby-doc.org/core-2.1.3/Enumerable.html) for this) to pick the desired numbers. numbers = (0..6).select do |n| n % 2 == 0 end puts numbers.inspect See https://eval.in/199703 for the result. EDIT: other commenters were way ahead of me. :)
numbers = Array( 0..6).keep_if{|num| num.even?} * Array(0..6) returns [1,2,3,4,5,6] * #keep_if only keeps numbers that evaluate to true in the block you pass in. It cycles through each number in the array and if it matches the code in the block (num.even?) then it keeps it. If you really wanted to you could chain them all together to get your desired output, but I don't like the way this looks. numbers = Array(0..6).keep_if{|num| num.even?}.each{|num| puts num}
Especially if maximizing performance is not important, I'd check out [parslet](http://kschiess.github.io/parslet/), I suspect it will be the easiest and fastest (to develop) way to get to what you want. Parslet will work just fine on Windows and on jruby -- it's nothing but pure ruby and will work fine on any ruby. (Performance may vary, I have no idea). For a simple grammar, it's probably parseable (and without too many contortions) in both PEG and LALR. But racc should work too, if you are familiar with LALR and prefer it, why not. (There was _something_ in ruby I saw once that took the approach of Parslet or Treetop (pure-ruby, no code-generation, just ruby code) with an LALR instead of a PEG, but I keep losing it). 
♡
Thank you! This is exactly what I was looking for. I knew about the range operator, but I couldn't figure out how to increment it. Thanks again!
Thanks for your input, everyone! I really appreciate it.
Looks like you're getting errors with SSL. Based on the paths, I'm guessing you're on a Mac? Do you have [Homebrew](http://brew.sh/) installed, or something like it? I'd suggest trying to reinstall openssl, then uninstall and reinstall the rubies you're trying to install via RVM.
Is that just a matter of convention as opposed to best practice? I mean essentially they do the same thing, and while x.upto(y) do..end is more readable, isn't while meant for just that purpose across the board of languages? Not to hijack OP's topic, just wondering.
Seems like an awesome way to start a calculator app. Mind if I ask what you want to use the script for? 
No reason in particular. Just trying to take different intro concepts I'm learning and find different ways to put them to use.
FYI, Numeric also has a [#step](http://www.ruby-doc.org/core-2.1.3/Numeric.html#method-i-step) method. 0.step(6, 2) {|num| puts num }
dead link?
Thank you for clearing this up. That really helps me grasp the concept a little better!
Yeah, unless I'm mistaken, it only stay true for numbers below 100, higher and you have to take into account higher prime numbers such as 11, 13,... 
Thanks! Looks much cleaner.
Thanks for taking your time to whip it up! I need to learn to use functions instead of looping everytime.
You need autolibs http://rvm.io/rvm/autolibs Or install the required libraries or type rvm requirements from console to see what external packages you need to have installed on your system. 
this is nice too! It lacks the repeating gets, but otherwise very clean. in retrospect I ought to have separated the printing bits from the calculating bits like you did.
Ruby's cute iterator-syntax-sugar is one of the most powerful concepts it has. Far from a silly trick if you ask me!
Instead of `n % 2 == 0` you could write `n.even?`.
You have a typo in your first bullet point (left out the zero). Also: numbers = (0..6).select(&amp;:even?)
Array.wrap()?
I like this API, but it's not in the standard library. 
I think there's a lot of little touches like this that could do with being back ported from Rails to Ruby. I really got introduced to Ruby through Rails. Now that I'm trying to use Sinatra and other non-Rails platforms a bit more, I'm finding that most of Rails actual usefulness comes from these types of functions.
Pretty much every script I write these days has been a Dir.glob.each. I don't even bother with shell scripts anymore, just Dir and ``.
EDIT: The official Neo4j blog just published a post I wrote that walks through some of the features. [http://neo4j.com/blog/neo4j-rb-3-0-released/](http://neo4j.com/blog/neo4j-rb-3-0-released/) If you're not familiar with Neo4j, it's a NoSQL graph database. [This page](http://muhammadhamed.blogspot.com/2012/05/why-graph-database-why-neo4j.html) seems to do a good job explaining why graphs are awesome. The Neo4j.rb gem itself acts as an ActiveRecord replacement for Rails. I spent the past few months contributing to it in particular and I like to think it's pretty awesome, but I guess I have a bit of a bias. I'd say the most significant part of it is the speed with which you can develop. There's no schema to deal with and because of the nature of its relationships, you can define new associations within models whenever you find the need for one. It's a very logical, natural way of organizing data.
As a newbie trying to learn ruby/rails, I can't wait to explore your site. I'm bookmarking it to check it out this week.
Array#wrap is actually part of activesupport, which you can just use like a regular gem. A lot of the functionality of rails is split into the active* gems and can be used outside of it as well.
That's an ingenious phrase right there, I can't think of a bigger hurdle than someone like me wanting to build their first website with optimization as the foremost priority, I'd never get anything done, get overwhelmed with the inherently complex topics I'd be introduced to prematurely, and probably never actually get to writing a single line of code without spending tons of time researching and debating implementations that in all reality I'd never be able to understand fully with no experience and that I probably wouldn't even have the skills to implement. Thanks for answering me though!
Nice. thanks :-)
&gt; If you're not familiar with Neo4j, it's a NoSQL graph database. Why did you put the term "NoSQL" in front of "graph database"? Let's just stop using that meaningless term, please. Thanks for your contributions! Now I just need to come across a domain where a graph database actually makes sense \*waiting impatiently\*.
Ha! Yes, you're right. "NoSQL graph database" is redundant but "NoSQL" for some people evokes the idea of new, modern database technology in a way that "graph database" in itself may not. Can't assume that everyone out there will know that graph databases exist but most devs will recognize "NoSQL" at this point. But I might have just been sneaking away from work to post and writing in a hurry, so there's that. ;-) As for a domain where it makes sense, I'd argue it makes sense anywhere that you have relational data and don't need features unique to PostgreSQL. A lot of Neo4j media out there talks about how wonderful it is for matching but if you just want an all-purpose, schema-free database that handles relationships well, it's a great choice.
Both first and second example contains a branch, just because it is just one line doesn't mean it isn't a branch. First example is a bit verbose, but the implementation is quite readable, and easy to understand. Splat is a bit magic, but its a nice suggestion, but I don't know if I like it better.
If you want to know about Rails, Michael Hartl's Rails Tutorial book covers all of this and more. [https://www.railstutorial.org/book](https://www.railstutorial.org/book). That's definitely the first place I'd start for an overview of how to build and deploy an app. It would be easier to help if you gave us an idea of what you did understand. What is your background, what is your understanding of things so far?
&gt; Now I just need to come across a domain where a graph database actually makes sense *waiting impatiently*. Be careful what you ask for.
now i just need to come across a situation where "Turtle files on the filesystem" aren't enough of a graph-database. anything i can think of maybe wanting is going to call for much more than basic graph-pattern-matching - NLP, machine-learning, bloom-filters, levenshtein, Bayes, full-on Gremlin/Blueprints rabbithole..
Question from a noob: what does "obj.each &amp;:function!" do?
Also, awesome that you've been playing around neo4j and Rails! Shoot me a message if you have any trouble or questions or you can always post an issue on Github and I or someone will respond real fast.
crap! 100% my fault... Missed the v3 section on github some how. thank you!
The [documentation](http://www.orientechnologies.com/docs/last/) is the best place to look, as it's the one thing it's sorely lacked since... ever. [Here's their Java API](http://www.orientechnologies.com/javadoc/latest/). It is a Java-native DB so it works best with Java (boo) but there are clever ways around that without having to rely on Rexster or anything like that. 10.1 covers their SQL, you can also find that on their github docs but that's kind of fractured and awkward to navigate. The docs don't really do justice to how powerful their SQL is. [Here's](http://pettergraff.blogspot.it/2014/01/getting-started-with-orientdb.html) an old but still relevant intro to it using the Grateful Graph. You can embed Gremlin directly through ReST using their query language. [Nice documentation on their ReST API](http://www.orientechnologies.com/docs/last/orientdb.wiki/OrientDB-REST.html) I honestly feel like Neo4j's lack of schemas is more a bane than a boon. Mixed schema gives you the best of both worlds. Just learning my way around Neo4j I corrupted my db a few times and had to hard-reset it. I have no idea why people pay $15k for that software. There's more to say than I've had the opportunity to learn and I've been working with it non-stop for the past two weeks. Neo4j took an afternoon to find my way around, inside-out. What Orient lacks with speed (to learn) it makes up for with power. When I was initially thrown this project I really pushed for Neo4j, but I got shot down because of licensing concerns. I got the OK for Orient. I was seriously bummed at first but once I started finding my way through the weeds I couldn't believe how much it could do. Then 2.0m1 was released like 2 days later and I saw it as a blessing in disguise. Neo4j is cool, I'm not denying that, but Orient is worth a long hard look.
It's a shortcut for `objects.each {|object| object.function! }`. See: http://stackoverflow.com/questions/1217088/what-does-mapname-mean-in-ruby
[the link](https://motioninmotion.tv/screencasts/45) works for me. The URL says /45 but the episode is #43. The content of the video seems to be inline with the title of the link though.
+1 for Hollywood Principle :)
Personally, I think this is a matter of understanding what Array() really does. The author already linked the Array() documentation and already referenced the explicit to_a conversion that hash has built in. So I think we're good on that front. But I understand wanting to guard your functions from a lot of different inputs, but going farther down this path really seems like your getting very paranoid. When first moving to ruby, I had a lot of issues doing type checking (I came from a C++ &amp; Java background). I would check everything and I wrote a lot of code that seemed unnecessary in hindsight. Using the Array(args) trick to normalize your input gets a lot of bang for your buck. Those function APIs will be very flexible when taking in a single object, an array of objects, and the accidental nil. Just be aware that some other data types will have these built in conversions that you may have to understand.
The title of the article sounds reasonable to me, but the example given sends chills down my spine. I've seen such powerful abstractions brought to bear on trivial logic like this in real life, so I think the article should mention the example abstractions are toy, and should only be implemented in a mature code base that has aged like a fine wine, or maybe blue cheese. Whatever, it should be old and rich. Don't write code you don't need. Don't create abstractions until you have a concrete requirement to reuse or clarify code. Don't assume and anticipate potential possible future requirements unless you're actually working in the 1970's world of waterfall software design and have a 4 year road map laid out with your Gant chart. It's a waste of time now and even more time later if/when the project actually succeeds and needs new people to understand what the UniversalFactoryGigawattFactoryFactoryInterface does. TLDR; YAGNI 
Looks good but after poking around their [documentation](https://github.com/orientechnologies/orientdb/wiki/Programming-Language-Bindings) for a bit there do not appear to be any maintained ruby drivers apart from the jruby-only version, which is a bit of an adoption roadblock I think.
Interesting. I liked it up to the last point. &gt; The usage of the classical assignment method also breaks the flow of reading from a domain perspective and robs the opportunity to tweak arguments of the call. I don't know if I agree here. I suppose it doesn't make a ton of difference in the particularly contrived and terse example the author's given, but what if we have something like: class Player ... def join_guild(guild) ... self.emblem = guild.emblem end end From a readability perspective, we certainly don't want to extract each of the guild emblem's attributes and pass them to Player's emblem-specifier. Plus from an encapsulation perspective, when the `Player` class accepts `Emblem` attributes and then builds an `Emblem` from that, we're ultimately just exposing internal design features of `Emblem` to `Player`. This seems bad. The `Player` object frankly doesn't actually give a damn about the attributes of the `Player` instance's `Emblem`, does it? In fact, all it should care about at all is the `Emblem` object itself. So yeah, if you're having to write a brand-new `Emblem` object whenever you set the `Player`'s `Emblem`, then your code might suffer in readability in that particular domain, but a) `Player` will remain decouples from `Emblem` and b) we're probably not gonna be spending a ton of time hand-writing `Emblem` instances in the same domain where we're assigning them to `Player`.
Well, interesting point you bring up. Thanks! The quoted passage is more related to the external interface. You probably don't want instance variables settable through setters by other objects. the `self.emblem=` call is an internal call, looks like a private method to me. If the emblem is a first class object in your domain that is used throughout different entities it is not a bad idea to expose it with a getter so that it can be used by other objects to there needs. I would just make sure that it is frozen after creation so that nothing particularly evil can happen after exposing your emblem to someone else. And you are very right in regards to the emblem's specific attributes. Knowledge of how to construct it in a lot of different places would introduce a static coupling to the class and an inherent logical coupling by enforcing knowledge about its construction. Does this clarify your thoughts? Cheers 
I've taught younger kids than this some programming. It's not impossible, but they have to want to do it. Either that, or be bribed with sweets, that works wonders. 
Patch it in or alias it? 
There's a right tool for every job. Just because you lack familiarity with bash does not discount its value. 
Hehe, me and @banisterfiend have been screwing around with pipes for a while now. Welcome to the madness. https://github.com/baweaver/streamable
As a rubyist, I see every reason to use it.
Can you explain why. I've heard this a lot lately 
For me, at least, the issue is not about dogma. Swift looks really nice, as do the new tools for development. But, I know that I'm much happier working in a language like Ruby from the command line or in a text editor. On the other hand, I'd also like to be able to find work, so...
I'm new, so please excuse the dumb question, but: If you're programming in Ruby why wouldn't your client expect to see the final product in Ruby?
I'm relatively new as well, but the advice I was given was that I'll find very few clients directly (unless I go the freelance network route) since most prefer to hire development firms, not indie developers. As such (and perhaps this is wrong?) the bulk of available jobs for someone like me would be outsourced work from these development firms, which more often than not would insist upon native tools. Even going with gigs on oDesk, Elance, etc, it appears that many (most?) clients want the source code at the conclusion of a project (a reasonable request for future maintenance) and likely won't take kindly to receiving Ruby source code in place of native Objective-C or Java. It makes some sense that even in those cases where I find a direct client, they'd prefer I use the standard iOS and/or Android toolchains as finding someone in the future to update or maintain a mobile app made in Ruby would be far more difficult.
Probably because he/she has a hammer and everything looks like a nail to him/her. 
No, my understanding, and someone please correct me if I'm wrong, is that Rubymotion code compiles directly to LLVM bytecode, just as Objective-C code does when it's compiled. If you write an app in Rubymotion, the source code will always be in Ruby. It isn't converted to Objective-C first.
I think it probably depends on the client and the type of app they want developed. Some things to consider when using a non-native language is app startup time, performance, and development activity (ie: you don't want to be stuck rewriting your app when iOS 9 comes out). If you are developing a game or anything where the user will expect the app to load and run quickly (like a camera app or something), you better start studying some Object C (and Java if you want an Android version). That said, from what I've read of Rubymotion, it seems pretty good...kind of expensive though. I do mostly Android dev and I checked out some Ruboto demos, but was disappointed (Rubymotion seems to have gone in a different direction and will likely perform a lot better). It's a cool project, but the startup time is just too slow for me. I've been messing around with Titanium lately and while not Ruby, I do like it for cross platform development.
I realize the example in this article is fabricated, but I find this a little scary: params[:summary_type].constantize.new Allowing user input to decide which class gets instantiated is a potential security hole. The only thing being called on the resulting object is 'summary_for', but that could easily change to include something more dangerous. I would prefer to be explicit about what gets instantiated based on user input eg: if params[:summary_type] == "Something" SomethingSummary.new else if params[:summary_type] == "SomethingElse" SomethingElseSummary.new else Summary.new end 
Really? http://owensd.io/2014/09/24/swift-experiences.html
I mostly just want to say thanks! The deployment guide was particularly valuable to me. Your documentation is almost definitely the most clear, modern, and well-presented I have found in the Rails community. Any chance you're planning to do an episode on Rails + [Docker](https://www.docker.com/) soon? I have been having troubles finding a good tutorial/doc on it -- in particular how to manage something like my Rails project (a git repo w/ private credentials and such) with a Docker image.
This comment is quite misleading... RubyMotion compiles down to ObjC byte code , so the performance drawbacks are extremely minimal. I'm sure one could run benchmarks and find minor performance issues here and there... but we use RubyMotion for all client work at my company and have been nothing but happy with it. We have used it for applications that require a high level of performance and it just works. I think the biggest thing that this thread is missing the point on in saying that Swift makes RM obsolete is the Ruby ecosystem. You can use (mostly) all gems that are available to you and all the DSLs that extract away the iOS APIs are just a joy to work with. Its also the ability to ditch Xcode with I cannot stand to work with. 
Thanks a lot!
If Emblem were immutable Value Object there would be no need to #dup or #clone it for protection before exposing to others.
Thanks. You worded my question better than I did. So, from those who have experience in this, are there enough of those clients who "might not care either way" to make purchasing, learning and using Rubymotion viable for freelance/contract work? Or are far too many of the type that "have specific requirements"?
Good enough for Basecamp. Good enough for me.
This is not a very good example of when you actually need prepend. 
It's not supposed to be an example of when to use it, just an example of what it does.
You're right. It isn't but I couldn't think of a good example. As said below, it does provide a (hopefully) simple enough to follow, contrived example of how to implement it.
Sorry, but in what kind of bizarro world can you assume that $200 is a trivial amount to everyone? Any why would you assume that everybody doing this kind of work would blow $5k+ on their gear? Everybody needs a $1000 convertible desk and a Herman Miller chair? How about: * 13" MacBook Pro - $1100 * Simple desk and chair from Staples - $300 * Apple dev membership - $99 * Xcode and Swift or Objective-C - free The price is only a triviality if you have a lot of money. Plenty of people don't for plenty of reasons, whether they're running a business or not.
Any help or feedback would be appreciated ;)
That's why I added this: &gt;Rubymotion seems to have gone in a different direction and will likely perform a lot better 
Definitely! I haven't actually played too much with Docker yet, but I absolutely want to. Docker has been taking off so much in the last few months that it would be a shame not to cover it. Also thanks for the compliment. I hoped it would be useful and I'm happy to see I accomplished that. :)
Yeah, I make about the equivalent of $2,000 a month and have a family to support. I don't have $200 to spare. As is evident by my salary, my company is also stingy with money so asking them to buy it (and for each developer) will require a ton of justification which, right now, I can't justify. 
If I had found this this morning I would have had a much nicer day... Thanks for the link.
Let's three way this. I'm game
You should look into this: https://github.com/remiprev/her I built a wrapper for an API using this gem and it was really easy!
Mind-boggling. $2000/month is the equivalent of roughly a $30k/year salary. You work professionally as a developer at that salary level? You seriously need to quit your job, developers are in high demand. Entry level salaries for fresh graduates in my (not very large, 250k pop) city are 2x that.
To a business? Nowhere did I say "everyone", I explicitly said "for a business". A business is generally spending $100k+ per year per developer, more if we start talking about high-cost-of-living cities. At that price point, $200 is a drop in the bucket.
I live on a tiny island in Japan. It's sadly a pretty average salary here for this type of work here and moving isn't an option (pay in Tokyo is way higher, but here on this island, we have the lowest wages in all of Japan). Japan is weird when it comes to wages...you can't just hop between companies and expect to get paid more for your skills and stuff. Instead, pay here seems to be based on how long you've been with the company. It's possible to hop between companies and get a higher salary, but it requires lots and lots of networking and getting in good with senior management at a company before ever even applying for a job. I work with guys who make a lot more than me because they've been with the company for 10 years yet I can run circles around them when it comes to a lot of our work. I've asked for a raise, but it's not going to happen. I'm looking at doing some remote stuff on the side though for some extra money. I do like my company and the work I do...it's just a different culture that takes some getting used to. And yeah, it sucks lol.
You have a very narrow definition of "a business", especially for the mobile development world.
Okay so after much hard work, I've finally posted. Now I have to start the 5th post...
As a Rails developer in the payroll business, I enjoyed this read.
&gt; Consolidation of state-specific code &gt; In our Rails app, we have several models where we have to implement specific code for each state. [...] A DSL implementation allows us to consolidate and organize all of the state-specific code into a dedicated directory and primary file. &gt;Scaffolding for states &gt; Rather than starting from scratch for every new state, using a DSL provides scaffolding to automate common tasks across states, while still providing flexibility for full customization. Took me a while before I realized by "state" they don't mean "mutable fields of an object" but "the geopolitical hierarchy between city and nation".
Here's my take. I hope this helps. http://pastebin.com/GqNHaE42 Keep coding!
[I'd do it like this](https://gist.github.com/awestroke/7275d4753b288c4cd3c1)
If I were only making and selling my own apps, that'd seal it for me, as well. But I want to do client work, and am uncertain if there are enough clients out there who'd be cool with me using Ruby as source code.
Thanks for this I'm going to spend my day tomorrow playing with answers and see which one I like best.
Thanks for taking the time to have a look :)
Echoing what /u/jrochkind said, I think these kind of "DSLs" have some significant drawbacks. Off the top of my head, the main wins you get with a traditional DSL are the ability to define custom syntax/vocabulary specific to the problem domain, and to "lock down" the interpreter such that no harm can be done to the system on accident. These ruby "DSLs" fail on all accounts, in my estimation: 1. While you get to define your own vocabulary via the methods that you implement, this ends up being just a mirage. For example, most people learning rspec struggle with remembering if it's `should_not eq 4` or `should not_eq 4`. 2. Without grammar, your DSL becomes littered with ruby operators and symbols. E.g. `its(:color) { is_expected_to eq 'blue' }`. 3. One of the biggest benefits of building a DSL is to be able to hand off that DSL to, say, a business analyst. You probably shouldn't hand over the ruby interpreter to a non programmer. You certainly couldn't if that business analyst did not work for the same company as you. This isn't to say what the author did was *bad*. I just look at it as more of a non object oriented API. This is often useful in ruby, and in this case it certainly seemed so.
Then it's your clients and not reddit you should be asking.
I've just taken a quick skim of the script,I have not debugged it. But be aware of the concept of "current working directory" -- the directory 'you are in', the directory that is returned when you type 'pwd' on the unix command line. if Dir.exists?('saves') Dir.chdir('saves') These are both relative paths. So first you are checking to see if the dir `saves` exists in the current working directory. If it does, you are chdir'ing into it (the equivalent of `cd` on the unix commandline) -- which _changes_ the current working directory. If you were to run the above two lines of code twice -- it would first create a directory `save` and then `cd` into it; and then create _another_ directory `save` inside that first one, and cd into _that_ one. You follow? Apologies if this is obvious. I have not traced or debugged your code, but I suspect the issue is that you are using all relative paths (which means relative to the current working directory), but changing the current working directory from time to time, so the same code running more than once is running in a different current working directory. I'd leave the current working directory alone -- set it to your apps main direcotry and then never change it, never call `chdir`, instead use paths relative to that app main directory. 
I'd be more willing to advocate for the use of rubocop if it didn't break projects with its suggestions. A colleague ran rubocop with autofix on a rather large codebase, and about 6 or 7 subtle bugs were introduced. Things like "self.foo = bar", and rubocop not liking "self.", ever, so it changes it to "foo = bar" and suddenly you're just creating a local variable called foo instead of invoking your "foo=" function. It converted several regexes from "%r{}" format to "/.../" format because there was "only one slash" in the body of the regex, and ruby guide says only to use %r if there's two or more. Thanks? Except it forgot to include the trailing regex flags, so %r{...}i just became /.../ and now my regex is broke. Not to mention the fact that half of the "offenses" from the default style guide sound good in practice, except when making exceptions to them increase readability. (Rant: The style guide says never to use "self.", but in certain longer methods, not seeing a "self." in front of a variable may make the reader think it's locally-scoped, and will start hunting for its first definition, only to realize that it's actually calling a method. This is especially the case with ActiveRecord models and column names, where the ruby source may not even have a single reference to the column name because it's detected at run time.) The rule teams should follow should be: "Is it readable? If not, fix it. Do people have different opinions on what's readable? *Then* use a style guide." This is a lot different from "Use the style guide constantly and indiscriminately whether the code is readable or not."
As an experienced Rubyist, I think style guides are one of those things that make you feel like you are doing something vital and important when you are not really doing anything at all. The Ruby community seems to have a fascination with these things as these style guide articles get posted a lot, I think it's because you can implement these things without having to think about what you are doing, it makes you look like a diligent programmer.
Man! Upvote and huge respect for reading, considering what I said, and not trying to escalate the tech argument! Please don't get me wrong, OrientDB seems awesome and in the right situation, I can see why it would be a better fit. Its handling of RDBMS concepts seems very enterprise-friendly and if you want SQL and configuration, you'd be right at home. Seems like a much easier sell in an Oracle environment where I'm guessing the DBAs would have some input and gravitate to technology that feels less foreign, too. But it's very different from Neo4j. For a startup or app developer who wants a setup-and-go NoSQL (there's that word /r/Enumerable_any wants banned!) solution, Neo4j is probably a better fit. It definitely is for me -- I don't need any of those enterprise features, I just want a powerful graph with a solid community and good developer tools. You gave me a lot to think about, though. I'm pretty invested in Neo4j and have a bias-inducing relationship with Neo Tech but I love technology, so I'm going to keep an eye on OrientDB. Thank you for good, healthy debate!
I wish I could upvote this more than once. In practice, style guides are often tools that elevate mediocrity by shifting the goalpost from quality design to ritual. In other words, from something few can do well, to something anyone can do adequately.
Consistent syntax is a good idea for a team of developers working together.
I just create the room to discuss here : https://gitter.im/Calyhre/dribbble
Agreed. Absolutes are *never* a good idea. ;-) I see this a lot on reddit. If someone asks a question about an outdated or unfavored library, a lot of the responses will be "Upgrade," or "Just use X instead." But as you say, a lot of people are using those libraries *because* they've thought it through and decided they're right for their use case (or at least not wrong enough to warrant a rewrite).
The biggest draw isn't necessarily that the style guide is some aesthetic or moral truth, the benefits from using a style guide come about regardless of what guide it is. 
I know for right now Im not applying discounts. Im just wondering why this right now is not working. Here's the c++ version with discount. #include &lt;iostream&gt; #include &lt;iomanip&gt; using namespace std; int main() { //VARIABLES double totalprice, softwarequantity, total_price_after_rebate; const int priceConstant = 99; const float rebate1 = 0.80; const float rebate2 = 0.70; const float rebate3 = 0.60; const float rebate4 = 0.50; char again; //AUTHOR cout &lt;&lt;"ISMAEL FILALI - 9/25/2014"; cout&lt;&lt; endl; cout &lt;&lt; "How many copies of the software are you going to purchase?\n"; cin &gt;&gt; softwarequantity; if( softwarequantity == 0 ) { cout &lt;&lt; "Do you want to buy anything?(y/n)\n" ; cin &gt;&gt; again; if (again == 'Y' || again == 'y') { main(); } else { cout &lt;&lt; "Good bye" &lt;&lt; endl; system("pause"); return 0; } } else if( softwarequantity &lt; 10 ) { totalprice = softwarequantity * priceConstant; cout &lt;&lt;"$"&lt;&lt; totalprice &lt;&lt; endl; } else if( softwarequantity &lt; 20) { totalprice = softwarequantity * priceConstant; total_price_after_rebate = totalprice*rebate1; cout &lt;&lt;"$"&lt;&lt; total_price_after_rebate &lt;&lt; endl; } else if( softwarequantity &lt; 50) { totalprice = softwarequantity * priceConstant; total_price_after_rebate = totalprice * rebate2; cout &lt;&lt;"$"&lt;&lt; total_price_after_rebate &lt;&lt; endl; } else if ( softwarequantity &lt; 100) { totalprice = softwarequantity * priceConstant; total_price_after_rebate = totalprice * rebate3; cout &lt;&lt;"$"&lt;&lt; total_price_after_rebate &lt;&lt; endl; } else if ( softwarequantity &gt;= 100) { totalprice = softwarequantity * priceConstant; total_price_after_rebate = totalprice * rebate4; cout &lt;&lt;"$"&lt;&lt;total_price_after_rebate &lt;&lt; endl; } else { cout &lt;&lt; "bye" &lt;&lt; endl; } system ("pause"); return 0; 
This isn't python :)
Also, it can be rather confusing to have the discount prices at the top with no explanation for what they represent. Documentation of code is always important or at least place the variable declaration where it will be used. price = 99 puts "How many copies will you buy today?\n" amountofcopies = gets.chomp # No Discount for 1 - 9 copies # Discount for 10 - 19 copies (80% of total price) # Discount for 20 - 49 copies (70% of total price) # Discount for 50 - 99 copies (60% of total price) # Discount for 100 - Infinite copies (50% of total price) number_of_copies = amountofcopies.to_i case number_of_copies when 0 puts "You have to at least buy one" number_of_copies = gets.chomp when 1..9 totalprice = price * number_of_copies puts totalprice when 10..19 discount = 0.80 totalprice = (price * number_of_copies) * discount puts totalprice when 20..49 discount = 0.70 totalprice = (price * number_of_copies) * discount puts totalprice when 50..99 discount = 0.60 totalprice = (price * number_of_copies) * discount puts totalprice when 100..(1.0/0.0) discount = 0.50 totalprice = (price * number_of_copies) * discount puts totalprice else puts "good bye" end 
I used to use rubocop, but combined with syntastic in vim it seems to significantly slow down the time to open files. Without having it integrated as part of my primary text editor I find that I just don't run it that often.
By the way, this may help to explain what the 1.0/0.0 is 1.9.3-p547 :001 &gt; 1.0/0.0 =&gt; Infinity 1.9.3-p547 :002 &gt; 1/0 ZeroDivisionError: divided by 0 
[guard-rubocop](https://github.com/yujinakayama/guard-rubocop) is the best thing ever because it focuses only on the file you're working within (and not the 500 other warnings in your project). This is how I have my Guardfiles set up with groups so that rubocop [only runs if the tests pass](https://github.com/bensheldon/panlexicon-rails/blob/master/Guardfile#L5), which is awesome for doing red-green-refactor cycles.
Heavy use of DSL's over OO design patterns is what drove me away from Ruby. We are developers, and learning someones strange proprietary DSL is not how we should be spending our time.
Try reading [why's (Poignant) Guide to Ruby](http://mislav.uniqpath.com/poignant-guide/). It has some syntax that's slightly out of date, but I think it does a good job of trying to make Ruby something new and exciting in an emotional way (which few other technical books capture). Also, check out the sidebar for the subreddit's booklist.
"Organizing" is definitely a faux-productivity time waster, but my counterpoint is that consistent styling helps detect smells and makes code easier to read for anyone else who has to look at it. [This talk by Katrina Owne](https://www.youtube.com/watch?v=qLpvc5r6Bb0) shows a bit about how consistent styling can help with both. (The talk is not specifically about that, but she shows examples and it's also a good talk.)
C# has a similar tool called Resharper. From my experience, there is an odd cult built up around Resharper and the folks that use it simply cannot code without it. Resharper also doesn't always follow MSDN coding standards and tends to call normal coding practices bad and suggests other ones that are contrary to the existing style guides. From what I gather about Ruby, there is no official style guide and that's always struck me a bit odd. I hope that RuboCop isn't like Resharper in that it's a Rubyist or group of Rubyists trying to push their own a idea of what "best practices" are.
kobaltzz, I guess I'm too late. I'll post my solution too.
# Here is what I came up with. :) I'm a newbie too, so please forgive me if I am not following any ruby best conventions. ### How do you read input from the Ruby command prompt?: http://stackoverflow.com/questions/6556280/read-input-from-console-in-ruby baseprice = 99.00 # base price for one license discount0 = 1.00 # no discount (&lt;10 licenses) discount1 = 0.80 # 20% discount (10-19 licenses) discount2 = 0.70 # 30% discount (20-49 license) discount3 = 0.60 # 40% discount (50-99 licenses) discount4 = 0.50 # 50% discount (100+ licenses) mycounter = 1 while mycounter == 1 do ### Consider displaying the price discounts before the user names a selection. puts "\nWelcome to our licensing cost estimator. The base price is $99 per license." puts "\n\t Discount pricing structure: " puts "\t| 20% off 10 - 19 licenses | 30% off 20 - 49 licenses |" puts "\t| 40% off 50 - 99 licenses | 50% off 100+ licenses |" puts "\nHow many software licenses are you considering purchasing? " myinputvalue = gets licenseqty = myinputvalue.chomp.to_i ### By using ".to_i" to convert the String class to an Integer, if the user enters a quantity with a decimal place, the value will be truncated, thus the quantity is rounded down to the nearest integer. ### Additional logic is necessary if you wish to prohibit your user from entering a fractional quantity. ### How can I use a case statement in Ruby? (cleaner if, then, else clause if options are limited): http://www.codecademy.com/glossary/ruby/switch-statement ### You may want to delete or comment out the calculation line. This line helps you visually confirm that the correct calculation is being used/selected. case licenseqty when 1..9 totalprice = (licenseqty * baseprice * discount0) puts "\ntotalprice = (licenseqty * baseprice * discount0)\n#{totalprice}=(#{licenseqty} * #{baseprice} * #{discount0})\n" when 10..19 totalprice = (licenseqty * baseprice * discount1) puts "\ntotalprice = (licenseqty * baseprice * discount1)\n#{totalprice}=(#{licenseqty} * #{baseprice} * #{discount1})\n" when 20..49 totalprice = (licenseqty * baseprice * discount2) puts "\ntotalprice = (licenseqty * baseprice * discount2)\n#{totalprice}=(#{licenseqty} * #{baseprice} * #{discount2})\n" when 50..99 totalprice = (licenseqty * baseprice * discount3) puts "\ntotalprice = (licenseqty * baseprice * discount3)\n#{totalprice}=(#{licenseqty} * #{baseprice} * #{discount3})\n" when 100..999999999 totalprice = (licenseqty * baseprice * discount4) puts "\ntotalprice = (licenseqty * baseprice * discount4)\n#{totalprice}=(#{licenseqty} * #{baseprice} * #{discount4})\n" else puts "#{myinputvalue.chomp} is an invalid quantity. Please contact customer service or try again.\n" puts "Do you wish to try again? Enter 1 to try again. Enter 2 to quit." tryagainresponse = gets.chomp if tryagainresponse == 'Y' || tryagainresponse == 'y' || tryagainresponse == '1' then tryagainresponse = 1 end if mycounter != tryagainresponse then break end redo # restarts after while mycounter == 1 do end ### How do you round a number to two decimal places? http://stackoverflow.com/questions/10459901/how-do-you-round-a-float-to-two-decimal-places-in-jruby # Consider telling the user the % saved and the total $ saved due to their discount. # Consider telling the user if they purchase x more licenses, they will get y% discount. puts "\nThe cost of #{licenseqty.to_i} licenses, including any applicapble discounts is: $ " + sprintf("%.2f", totalprice.to_f) puts "\nDo you want another estimate? Enter 1 for yes. Enter 2 to quit." tryagainresponse = gets.chomp if tryagainresponse == 'Y' || tryagainresponse == 'y' || tryagainresponse == '1' then tryagainresponse = 1 end if mycounter != tryagainresponse then break end redo # restarts after while mycounter == 1 do mycounter = 2 end # end while mycounter == 1 do 
I included an option at the end for the user to try again or quit. I also searched for helpful links for various tasks that you need to accomplish. If you give my code a try, you can make some modifications and make it simpler or fancier. Due to the discount pricing, there are certain quantities that are more expensive than if the buyer were to purchase a greater number of licenses. If this were the case, you could tell the user this information. Or, you could tell them, if you purchase x more licenses, your price will be _____. You could give them the price per license based on the quantity they selected. My thinking is that if the code does what it is supposed to do, that's great. If you improve the formatting, user interface/friendliness or give the user more options, that's an even better bonus. It demonstrates that you are thinking about the problem and trying to use new aspects of the programming language. It is ALWAYS good to be as clear as you can with the user and make the assumption that if you took someone off the street and asked them to try out your program, they would understand what the purpose of your code/program is. So, by adding a few intro headers and showing them the discount structure, it's more intuitive to the user that the program will calculate the cost of their software purchase if they are buying multiple copies. It's my perspective not to discount that your interface is a command line prompt. It can still be user-friendly and intuitive. (For instance, I said to enter "1" for yes or to try again, but if the user typed in "Y" or "y", I also repeated the program instead of terminating it). I tried to anticipate how the user might interact with the program. Is this for a course you are taking? Sorry someone already answered your question before I even scrolled down. I'm new to Ruby and I wanted to give it a try. Thanks!
CaptainKabob, I just clicked on the link. Do you know if there is a pdf available? So far it seems non-traditional with cartoons and some narrative, but it looks interesting. Thanks for posting the link.
The thing is I added a block to the Dir#chdir. Which makes it work the same as how file#open works where it automatically closes the file at the end of the block. everywhere I put dir#pwd in my code it shows the correct working directory when I get to the main menu loop and when the load_dictionary method is called. I checked already to make sure that it is in the right working directory. aside from that yes I know that considering this is just a little program so leaving everything in the main directory is doable but I need this to help me build upon future ventures where I will not be able to leave every file in the same directory, well unless I want file chaos. Edit: nevermind after typing this I re looked over my code. I forgot the do end in the dir#chrdir for the true conditional branch. 
If the self.foo cop bothers you, it's easy to disable in a .rubocop.yml file. Before you start running --auto-correct, I recommend customizing the rules for your needs.
It helps remove bikeshedding. It avoids having the same conversation each time a new Rubyist joins the team with his/her own preferred style. Those sorts of discussions have never moved a goalpost and yet I see them happen all the time in both commercial and open source software. That aside, each time a dev touches an existing area of code to fix one thing and decides to also replace the style, that diff becomes more complicated than it should be. This increases the likelihood important things slip through the crack, even if the discussion weren't derailed by the style changes.
A lot of the cops are based on a group curated style guide but rubocop is pretty configurable and pluggable, allowing you to mold it to your own best style practices. 
Why are you using autocorrect in the first place? 
I was gonna say, okay, I'm wrong then, I was just guessing, I guess it'll take some debugging! But maybe my guess landed after all! 
Yep! You can get the PDF (and soundtrack) here: https://github.com/mislav/poignant-guide/downloads
The point, I believe, is that it shouldn't do it at all (at least by default) if it's going to screw up the semantics of your code.
To be clear it wasn't me but a colleague. But I would say that if you have to spend a ton of time getting a style guide tool to conform to your expectations, it ceases to be all that useful. I'd much rather just have good code review where people look at, and discuss, the subjective readability of each other's code, and point to style guides where appropriate. "Use rubocop before you make a PR" is counterproductive.
*A foolish consistency is the hobgoblin of little minds* -- someone probably important.
well I tried to use the relative paths with File.open but for some reason it kept erroring out. 
Minor point, but... &gt; The bare gets provided by Kernel is an alias to $stdin.gets This is not true. First, it's not an alias (picky, I know). Second, it calls `ARGF.gets` not `$stdin.gets`. This often bites people when they use just `gets` and suddenly it is attempting to read from some file instead of `$stdin` because they passed in some commandline arguments.
Absolutes aren't a *coding* anti-pattern, they're a *social* anti-pattern. The mistake here is coupling the social aspect of one's professional life with the product of it. A mistake I feel programmers make too often.
I'll grant that style bikeshedding is worse than style guides, but both are symptoms of a deeper problem. Programmers who bicker about almost anything that rubocop complains about have the problem, in my view. It's not hard to make your code fit in with others. I personally prefer to omit parens on my method definitions, but most of my teammates don't, so I leave the no-parens for my side projects. What's the big deal? I think the biggest problem is the pesky programmers who make a big deal about it, tbh.
*This* seems delightful. Any excellent way to have your cake and eat it too.
Is anybody using this?
Note that with beta2 this is already a little out of date, in the way that one creates new jobs. i.e. it is now `Job.set(options).perform_later(obj)` rather than `Job.new(object).enqueue(options)` See http://weblog.rubyonrails.org/2014/9/29/Rails-4-2-0-beta2-has-been-released/
&gt; I'd much rather just have good code review where people look at, and discuss, the subjective readability of each other's code, and point to style guides where appropriate. "Use rubocop before you make a PR" is counterproductive. Sorry to be oppositional, but automating your linting allows your PR code reviews to focus on what's really important: patterns, architecture, introduction of technical debt, and readability issues that are outside the specifics of a styleguide. My ideal (and actual) team workflow is that people use guard-rubocop locally so that they're actively linting files alongside their tests, and using PullReview (Hound works well too) to automatically integrate with CI and Github to call out things that the developer missed. Then you can trust that the small stuff has been taken care and free your reviewers to focus on the big issues.
holy shit what year is it am i back in 2009? i haven't heard maglev in YEAAARS
&gt; Do you have issues where your team argues over style guide issues? Honest question. Not really. I turn off the line-length (I keep line-length at 150 chars to try to catch people shoving long blocks of html into strings) and Sandi-Metz-length checks, parameter alignment checks, and preference for single-line if statements . Otherwise I find Rubocop to be quite reasonable and the things it does complain about are legit issues (`&amp;&amp;` != `and` is not an opinion, but an actual problem). Mostly I just love that it catches stuff like trailing whitespace that are super annoying. You can also dial back the linter to nothing and then be additive in adding rules (rather than being subtractive of rules that people don't like) We have a very CI-centric culture though, and having an automated style guide pushes discussions towards "Either put it in the linter or drop it", rather than just trailing off without a consensus action. Having a linter is actually one of our engineering requirements for all projects (not just Ruby ones). 
I'd say there's a fair difference between "start using it on an existing project" and "use it from the start". I'm not advocating the product (because I haven't tried it) but I know from experience using splint on C that it was a very good tool on a new code base, and I won't accept a PR that causes a splint error. But, trying it on an existing codebase is hell, and frankly, no one ever should do it.
I might buy into that mindset when team sizes are pretty small and the lifecycle of a project is relatively new. I've been on teams and projects that were pretty small and these style concerns came up and were sometimes more of a hindrance. Sometimes an hour or two is blown talking about something that really does not matter. But going into larger teams, and larger code bases... I really think some buy-in to some standards has some value. You really start to see personal fingerprints in a codebase that is over 8 years old (maybe kinda old for a rails project?) and when it's had over 30 developers touching it in its history. These personal markings can be distracting at times. Now when I personally follow a standard, I honestly don't feel like I'm doing busy work just to do stuff for the hell of it. I'm buying into the notion that the standards are an attempt to make the codebase a bit more uniform. It's not for me, it's for the people to work on my code after I move on. After all, this is code that I am writing for someone else and it's not my own.
Are you hoping to eventually scale up to Rails? If so, definitely start with [Michael Hart's Rails Tutorial](https://www.railstutorial.org/book). This is probably the most popular intro to Rails - teaches you to build a twitter-like web app.
Thats a valid concern as most clients may want to hire on a developer and there are certainly more Objc devs than RM devs. Its really about selling your client on the time saving/cost saving that they will get with using RubyMotion. I can power through a RubyMotion app faster than I could an Objc app simply from all the new tooling that is available with RM. It's also worth mentioning that RM byte code can be used natively by Objc code as an included framework/library within an Xcode project.
Awesome, I'll take a look into it. Thanks!
Is there a particular reason to run on WEBrick rather than Thin or Unicorn or Passenger?
Legacy app that uses WEBrick servlets directly, pre-dating rack. Also, especially on Windows, convenience.
WEBrick is like a swiss army knife for building network servers that is right there in the standard library. For quickly standing up an http server (or any kind of server for that matter), WEBrick is the proverbial "batteries included". You can get very low-level with it too, since the whole stack is in Ruby and available to you. For example: class Echo &lt; WEBrick::GenericServer def run(sock) while line = sock.gets sock &lt;&lt; line end end end It's a shame it's so poorly documented and generally dismissed as a toy.
Here is another example - a streaming server (borrowed from tenderlove at https://github.com/tenderlove/fridge/blob/master/server.rb): require 'webrick' Thread.abort_on_exception = true root = File.expand_path File.dirname(__FILE__), 'public_html' server = WEBrick::HTTPServer.new :Port =&gt; 8000, :DocumentRoot =&gt; root server.mount_proc '/stream.json' do |req, res| rd, wr = IO.pipe Thread.new { loop do begin wr.puts "data: [#{rand(100)}, #{rand(100)}]\n\n" rescue wr.close break end sleep 2 end } res['Content-Type'] = 'text/event-stream' res.body = rd res.chunked = true end trap 'INT' do exit! end server.start
Nice find! Very interesting, thanks for posting
It seems you really want some advice from someone that has experienced a lot of sides of the field, so here's my thoughts, but let me prefix this with I did Objective-C before RubyMotion, I run the MotionInMotion RubyMotion screencast so I'm a little biased, but I've also got a Swift book on its way so I'm really not that biased. I've done consulting/contracting and freelance with both Objective-C and RubyMotion, and I'm working on apps with Swift at the moment (as well as with RubyMotion). Look at this decision purely from a fiscal and business sense. RubyMotion is a niche, but a niche with quickly growing popularity in the (funded) start up world. These people have the money to pay you and are often great to work with. There is plenty of work out there for a RubyMotion developer as long as they do what any freelancer has to do, network. Being in a niche will help you out here, because there is less noise to yell over. If you don't want to go niche though, focus on Objective-C and Swift, it will enable you to do work for larger IT companies as a consultant occasionally. It's good money, but honestly from experience it's not nearly as great as working with start ups using RubyMotion. My suggestion for you would be to learn RubyMotion if you already know Ruby, it will lessen the difficulty of learning Cocoa (OS X) and Cocoa Touch (iOS), and will also let you start playing with Android when you want to as well soon once it's out of beta, if you're not strong with Java. Still practice Objective-C and Swift though, especially in the early days you will be wanting to take any and all work that comes your way so that you can build your portfolio. The languages and the small style differences in how you use them are easy, it's the frameworks and the mindset that is much more difficult, you won't be an expert in that quickly, so start with RubyMotion and then learn some Objective-C and Swift and try recreating things from your RubyMotion projects in those. There is two reasons I say learn Objective-C, first is so you can understand all the code out there, second is that there will be projects that aren't new and are just needing updates. These will likely still be written in Objective-C. As a RubyMotion developer you can still use all the same tools that Swift and Objective-C developers use, including Xcode's Interface Builder and any of the open source Objective-C code out there like CocoaPods. This doesn't work in reverse though, a Swift or Objective-C developer coming to a RubyMotion project will have to get used to all the gems we use. There is much more value in an experienced RubyMotion dev for a RubyMotion project than there is an Objective-C or Swift dev, but there is almost the same value with any of the three working on an Objective-C or Swift app. With all that in mind, in my opinion learning RubyMotion seems like a fiscally sensible decision.
I run SoftwareCriollo.com. We do apps for people. 95+% of our clients don't care about the technology. Clients care about the final product, the cost, the user experience and the design of the app. Most clients don't know the difference between Objective-C, Swift, RubyMotion, Xamarin, Titanium, AppCelerator, etc. If you solicit work for Objective-C, Xamarin, Titanium or Swift and you deliver RubyMotion you'll be looking for problems. If you sell your services as RubyMotion developer you'll be cornering yourself into a niche and limiting your opportunities. Most clients nowadays want an App that runs on Android or IOS. If you deliver a quality app they will be really happy. If you deliver an app that crashes on Objective-C they will be unhappy. If you deliver an app that crashes on RubyMotion they will be unhappy. Focus on quality and the final product instead of the tools you used. Always be transparent and tell them about the technology you'll be using before hand. There is a much much much bigger market looking for the final product than looking for certain technology. Is RubyMotion suitable for Client work? For us is a strong yes, but depends on the client and how you sell your services. If the client wants Android / IOS and you want to have some technology overlap Swift/ObjC/Java are out. 
&gt; So true! 
Testing/committing updates to Gems *individually* is imperative. Seems like any time saved using bundler-updater would immediately be lost in the ensuing git commit -p madness.
Thanks for the update information!
Yeah, I can't imagine any scenario in which I would want to answer 'yes' to more than one gem. - `bundle outdated` - Update one gem - Test - Commit - Repeat 
It's like a Rubymotion #Inspect reunion in this thread! :)
It is undoubtedly slower than the alternatives in absolute terms. But performance is also relative to what problem you are solving - for a small internal app its performance is just fine. In the sense that from the user's perspective you would not be able to perceive the difference if it was running faster. It is definitely not web scale though :) Edit: Also, I am referring to WEBrick servlets, not rack. I think the rack adapter for WEBrick may have some issues of its own that need to be looked into. 
Thanks for that informative reply, @jamon51. The advice I originally received made sense to me in that clients typically want the source code of contracted apps. But, if you give it to them in Rubymotion, you are pretty much forcing them to find another Rubymotion developer (or come back to you) for future maintenance or updates. A much more challenging prospect than finding an Obj-C/Swift developer. And yet, you say that no clients have ever questioned your decision to use Rubymotion. Is that because most clients are simply unaware that they might be limiting themselves for future work on the app, or because they really just don't care so long as you deliver a working, polished app?
Thanks for the thorough response. Just wanted to say that I have really enjoyed your sample screencasts (one of the things that got me turned on to Rubymotion), and I'll definitely be signing up for the rest if/when I jump on the Rubymotion bandwagon. 
Aside: thanks for sucker_punch, it's very useful.
[**@schneems**](https://twitter.com/schneems): &gt;[2014-10-02 00:12:08 UTC](https://twitter.com/schneems/status/517467031034028033) &gt;I got 4598 objects allocated in every Rack request, but an unnecessary duplicate ain't one: [*github.com*](https://github.com/rack/rack/pull/737) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2i4b7w%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Another smell he failed to mention... He is creating objects all over the place to get away from doing an "if".... ie. It's a good way of making code look clean... but it is very inefficient code. That said, I'm always in favour of "Make it Correct", "Make it Clean", and if need be "Measure then Make it Fast". When I'm trying to clean up code / refactor code I tend to profile / memory profile code to look for "Huh!? WTF?" results.... because inevitably they are places where I can be cleaner / less stupid.
Fantastic presentation! I spent quite a bit of time to really understand monads, but can still barely implement them on my own off the top of my head. This is a perfectly concise, informative, _and_ practical guide to monads in general.
The latter. Our clients are typically startups who want a long term partner (us) and the cost savings of going with RubyMotion are more attractive than the portability of Objective-C. We don't reflexively recommend RM in all cases; it's important to consider the clients' business objectives and constraints and work within those. But so far RubyMotion has been more than adequate. For example, I worked with a startup to build an MVP iOS app a while back. We built the RubyMotion app for them, got it ready to submit to the App Store, and then their funding unexpectedly got yanked (for unrelated reasons) and the project was abandoned. If we'd done it in Objective-C, the initial cost would have been higher, and the portability wouldn't have mattered. For MVPs, you're generally looking for something that will get the minimum job (but still done well) but not necessarily satisfying every possible future need. 
He's making `Struct`s not `Class`s, which should be more performant. Besides, all of this really is just syntactic sugar in order to make it cleaner - theoretically, the performance loss is just an implementation detail. Ruby's all about trading off performance for expressiveness and dynamism.
Remember that cute "shell shock" vulnerability? env x='() { :;}; echo vulnerable' ruby -e 'system("bash -c \"echo Hi\"")' vulnerable Hi Note I had to specify bash -c because the system I'm testing on (ubuntu) runs dash as /bin/sh But the principle applies if you ever call out to a bash script... even several levels down.... env x='() { :;}; echo vulnerable' ruby -e 'system("dash -c \"bash -c \\\"echo Hi\\\"\"")' vulnerable Hi 
Wooooooooooooow. By the way, "open source" isn't a verb.
his whole rationale for using monads here is that he doesn't like `try` -- but his reason is just "monkey patching is bad". Was that really it? seems like kind of a weak reason for then going onto build some enormous edifice of decorator/wrapper classes using `method_missing` ...
And his `Many` monad is similar to `.map(&amp;:method_call)`. And the `&amp;&amp;=` operator is also monadic in nature. The reason monads are useful is the same reason these features in ruby/rails are useful. He's demonstrated that monads are the generalized case for all of these operations. A `Monad` class in ruby would encapsulate all the common implementation elements of `try`, `map(&amp;:method)`, `&amp;&amp;=`, etc. If you wanted this feature and it wasn't implemented, well this is how you could implement it. Sure, you have little use for his examples because ruby/rails conveniently already has a few specific cases implemented. This is for when you want a different monadic feature or when you're using a language that lacks these features. P.S. You called monads an "enormous edifice". That's how some people view monkey-patching _every single object_ with a `try` method.
I know what a monad is. I just didn't find his reasoning, nor his implementation particularly convincing for the cases given. Although it's not generalizable to all monads, implementing at least the Maybe monad and the State monad with haskell-like do-syntax is possible in Ruby using fibers. I would much prefer a fiber-based (do-syntax) approach to a janky `method_missing`-based implementation (ugh)
One possibility: irb(main):028:0&gt; " word1 word2 word3 ".match(/(\w+)\s+(\w+)\s+(\w+)/)[2] =&gt; "word2" Your initial `scan` solution seems nicer though.
FWIW, Paolo Perrotta's "Ruby Metaprogramming 2" has a nice explanation of it in an appendix: http://www.amazon.com/Metaprogramming-Ruby-Program-Like-Facets/dp/1941222129
Regular expressions are incredibly terse and take a lot of work to use effectively. http://www.regexr.com/ is one site that you can use to practice and learn more.
%x() learned something new, thanks
Well, that was a freebie
You may need to log in to view them. Feel free to nitpick my other exercisms as well, any input is welcome. Thanks!
Consider this: 2.1.1 :019 &gt; " word1 word2 word3 ".rstrip.match(/\w+\z/) =&gt; #&lt;MatchData "word3"&gt; It's not necessarily more "correct" but it looks nicer.
Good job :)
All the goodness of java in the late 90s 
I can understand service objects, but repositories I have a hard time grasping. It feels like you are particularly fighting too much of the framework for them to make sense.
BTW, since no one mentioned String#split, I'll offer this: string.split(' ').last Why does this work? [From the documentation](http://www.ruby-doc.org/core-2.1.3/String.html#method-i-split): &gt;If pattern is a single space, str is split on whitespace, with leading whitespace and runs of contiguous whitespace characters ignored. It sounds like this may be exactly what you want, for your use case. And I haven't benchmarked it, but this should be cheaper (performance-wise) than building a Regexp.
Here's a quick benchmarking run: irb(main):001:0&gt; require 'benchmark' =&gt; true irb(main):002:0&gt; s = " word1 word2 word3 " =&gt; " word1 word2 word3 " irb(main):003:0&gt; Benchmark.realtime do irb(main):004:1* 10000.times { last_word = s.match(/(\w+)\s*$/)[1] } irb(main):005:1&gt; end =&gt; 0.060223 irb(main):006:0&gt; Benchmark.realtime do irb(main):007:1* 10000.times { last_word = s.split(' ').last } irb(main):008:1&gt; end =&gt; 0.013851 Edit: Simplified the Regexp, and reran the benchmark.
`MovieEntity` is in fact still a DAO, despite the fact that you've stick ActiveRecord underneath it. Look at what it does. Also, I really can't get behind the private `attr_reader` called `#success`. You only make it private because of the `#success?` public method. Normally I don't nitpick this kind of triviality, but I feel that is a good example of the amount of excessive indirection in this example. Swapping out ActiveRecord for Entity+Repository is not a good idea. There are other approaches to persistence, such as event sourcing, that offer tangible improvement. But taking a transactional persistence state machine and extracting it from the superclass into a separate collaborator is not going to improve anything. Repositories are wonderful in specific circumstances. As a general purpose pattern for your entities that need persistence, repositories will be woefully inadequate.
I don't understand why everybody is trying so hard to isolate from their database. Don't you guys use SQL? Shouldn't that SQL be tested? In my universe, the database *is part of* my system.
sh(...) 
BTW, if it worked like that, you'd also get the wrong answer, because the parentheses would need to include the **\d?**. As it is, your code worked because the **\w+** matches the digit as well.
He said he needed "word3", but if you just mean that's how you interpreted it, fair enough.
We use Segment.io at Iron.io currently and absolutely love it!. It can be data overload we built a nice little integration and this use case around funneling segment into elasticsearch. Feedback would be helpful.
So, the rule is that if you are about to use 4 of the same characters, you switch to the subtractive notation. [source](http://en.wikipedia.org/wiki/Roman_numerals#Reading_Roman_numerals). If you look at the decimal representations, you will notice a pattern of (prev_number * 2) inter-spaced with (prev_number * 5). If you combined those two steps together, you would have a base 10 system and would match the decimal system that you are used to. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 1. [**Reading Roman numerals**](https://en.wikipedia.org/wiki/Roman_numerals#Reading_Roman_numerals) of article [**Roman numerals**](https://en.wikipedia.org/wiki/Roman%20numerals): [](#sfw) --- &gt; &gt;Roman Numerals, as used today, are based on seven symbols: &gt;Numbers are formed by combining symbols and adding the values. So II is two ones, i.e. 2, and XIII is a ten and three ones, i.e. 13. There is no zero in this system, so 207, for example, is CCVII, using the symbols for two hundreds, a five and two ones. 1066 is MLXVI, one thousand, fifty and ten, a five and a one. &gt;Symbols are placed from left to right in order of value, starting with the largest. However, in a few specific cases, to avoid four characters being repeated in succession (such as IIII or XXXX) these can be reduced using [subtractive notation](https://en.wikipedia.org/wiki/Subtractive_notation) as follows: &gt; &gt;* the numeral I can be placed before V and X to make 4 units (IV) and 9 units (IX) respectively &gt;* X can be placed before L and C to make 40 (XL) and 90 (XC) respectively &gt;* C can be placed before D and M to make 400 (CD) and 900 (CM) according to the same pattern &gt;An example using the above rules would be 1904: this is composed of 1 (one thousand), 9 (nine hundreds), 0 (zero tens), and 4 (four units). To write the Roman numeral, each of the non-zero digits should be treated separately. Thus 1,000 = M, 900 = CM, and 4 = IV. Therefore, 1904 is MCMIV. &gt;Below are some examples of the modern use of Roman Numerals. &gt; &gt;* 1954 as MCMLIV (Trailer for the movie *[The Last Time I Saw Paris](https://en.wikipedia.org/wiki/The_Last_Time_I_Saw_Paris)*) &gt;* 1990 as MCMXC (The title of musical project [Enigma](https://en.wikipedia.org/wiki/Enigma_(musical_project\))'s debut album *[MCMXC a.D.](https://en.wikipedia.org/wiki/MCMXC_a.D.)*, named after the year of its release.) &gt;* 2014 as MMXIV - the year of the games of the XXII (22nd) [Olympic Winter Games](https://en.wikipedia.org/wiki/Winter_Olympic_Games) (in [Sochi](https://en.wikipedia.org/wiki/2014_Winter_Olympics)) &gt;The "standard" forms described above reflect typical modern usage rather than a universally accepted convention. Usage in ancient Rome varied greatly and remained inconsistent in medieval and modern times. &gt;Roman inscriptions, especially in official contexts, seem to show a preference for additive forms such as IIII and VIIII instead of (or even as well as) subtractive forms such as IV and IX. Both methods appear in documents from the Roman era, even within the same document. "Double subtractives" also occur, such as XIIX or even IIXX instead of XVIII. Sometimes V and L are not used, with instances such as IIIIII and XXXXXX rather than VI or LX. &gt;Such variation and inconsistency continued through the medieval period and into modern times, even becoming conventional. [Clock faces](https://en.wikipedia.org/wiki/Clock_face) that use Roman numerals normally show IIII for four o’clock but IX for nine o’clock, a practice that goes back to very early clocks such as the [Wells Cathedral clock](https://en.wikipedia.org/wiki/Wells_Cathedral_clock). This is far from being an unvarying convention; the clock in Elizabeth Tower on the [Palace of Westminster](https://en.wikipedia.org/wiki/Palace_of_Westminster) in [London](https://en.wikipedia.org/wiki/London) (aka "[Big Ben](https://en.wikipedia.org/wiki/Big_Ben)"), for example, uses IV. &gt;At the beginning of the 20th century, confusion over the correct representation of 900 (conventionally CM) was reflected in several inscribed dates: for instance 1910 is shown on [Admiralty Arch](https://en.wikipedia.org/wiki/Admiralty_Arch), London, as MDCCCCX rather than MCMX. On the north entrance to the [Saint Louis Art Museum](https://en.wikipedia.org/wiki/Saint_Louis_Art_Museum) 1903 was inscribed as MDCDIII rather than MCMIII. &gt; --- ^Interesting: [^Roman ^numeral ^analysis](https://en.wikipedia.org/wiki/Roman_numeral_analysis) ^| [^100 ^\(number)](https://en.wikipedia.org/wiki/100_\(number\)) ^| [^21 ^\(drinking ^game)](https://en.wikipedia.org/wiki/21_\(drinking_game\)) ^| [^Regnal ^number](https://en.wikipedia.org/wiki/Regnal_number) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckzo5jd) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckzo5jd)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Abstracting the library used for persistence is beneficial as well: * Single entry point for caching * Methods on a dao/repository serve as documentation about *which* requirements the app has. * Changing databases gets easier (you almost never need to swap out databases though, but sometimes you might want to replace some parts where you don't need strong consistency with faster stores, like redis) tl;dr: Clear boundaries are clear.
What if you want to change from Active Record to something else like raw sql, Redis or another Abstraction for whatever reason in the long run?
Will do. Are you Gabe?
https://github.com/rurounijones/bsf-scraper might be useful. I did it a while ago by refactoring someones spaghetti ruby as practice and a teaching exercise. Not a very complicated app. A command-line web-scraper that saves data to postgresql http://www.poodr.com/ would be a good read as well.
I work with Sinatra and do a very similar thing to this to include bootstrap. Seems to work but it's not a great method as need to manually update with any bootstrap changes. 
I keep my frontend sources as separate as possible. I use bower to manage my dependencies so I get the benefits of package management. I then have a gulp task that will minify my bower stuff. If I had a public facing site I'd probably have a cdnification task instead. The setup has also this setup can use tools like gulp-livereload to have the same updating features I expect from a development server in my frontend sources. The gulp/grunt plugins for doing js modules, or building more experimental languages are often leagues ahead of their ruby counterparts.
A couple of things: 1) You wont get updates and bug fixes automatically. 2) If the gemspec is written correctly, nothing gets added to the load path. For instance, see the [bootstrap-sass gem](https://github.com/twbs/bootstrap-sass/blob/master/bootstrap-sass.gemspec). Note that the gemspec does not add any folders to the load path. 
Sounds good to me, sign me up. I'm @LimeBlast on Twitter. 
Pm me skype
I have been developing in Ruby since 2005 Happy to be a drop in veteran. 
if got more spots, sign me up boys.
thanks! PM me your skype or gmail
Hey can i join too :D
I'm into it. pMing…
No pressure, but if there's room for another, count me in! PM me your skype and i'll add
I'll PM you now
https://github.com/discourse/discourse
I've switched over to [chocolatey](https://chocolatey.org/) its way more flexible.
If a program "doesn't work", you should tell us how. Or even try to work it out on your own from the error message. If I run your program, on entering a number I get: test.rb:9:in `&lt;': comparison of String with 10 failed (ArgumentError) from test.rb:9:in `&lt;main&gt;' So it's pretty easy to deduce that one side of the comparison is a string, and it isn't the number in your code. All you need then, is to convert the input into an integer: amountofcopies = gets.chomp.to_i 
You all mention bower. Does nobody know https://rails-assets.org/?
&gt; amountofcopies = gets.chomp `amountofcopies = gets.chomp.to_i` Saves you having to create a new variable with a homogenous name.
Also, I realise that this is OP's error and not yours, but simply asking for input again if the user enters zero will not go over the case statement again. The program will just stop. 
Uck. What if I want to change from Ruby to Egyptian hieroglyphs?
Chocolatey is incredible. I can't believe Microsoft themselves never came up with a package manager and instead expected you to roll out SCCM and all of its other bullshit for your infrastructure needs. I designed a Windows hosting system about 5 years ago and the deployments were automated and it was **miserable.**
How is it regarding updating the repo's? 
Fairly good not quite as good as say homebrew but most repos are less than a month out of date.
Hey, I just had a read through this and thought I'd have a go at it myself to help you along a bit. A few things I noticed in yours to be careful of: - method names: what is `discount1`? It's not meaningful, and if you can't think of a good name then it might mean you need to rethink how you're representing this data. - reassigning variables straight away that you could do in one line, ie: `myinputvalue = gets; licenseqty = myinputvalue.chomp.to_i` could be `myinputvalue = gets.chomp.to_i` - a lot of complication around the looping and validation - weird counters. There's almost never any need for them. I've tried to cover most of those issues here, have a look and let me know if you have any questions. Or even if anyone else has any refactoring pointers for me; I'm not an expert by any means. https://gist.github.com/revdan/02299a99a5c67ce746ec 
Thanks for that. What editor do you use?
I don't know about the quality of the codebase, but Chef should be interesting to browse around, since it's a pretty widely used project: https://github.com/opscode/chef
Thanks for introducing me to that. I've had a quick play and it seems awesome. Wish it had an option to change the default install drive, but still something I'm sure to make use of! 
They need to dedicate an entire release to performance improvements like this.
New hash syntax in trunk: https://bugs.ruby-lang.org/issues/4276
&gt; But what I want to see is a really great, true object oriented Ruby application. Don't get me wrong, discourse is a good piece of software, but it's far away from what I'd call good object oriented practices. There are SOLID violations in almost every single file.
https://github.com/rurounijones/bsf-scraper/blob/master/lib/bsf/scraper/fund_data_populator/holdings_page_parser.rb#L80 What's with the random 0? :P +1 for poodr. Go read it, /u/briansprojects, it's awesome.
oops, completely missed that was in there. oh well. [EDIT] That was my deliberate mistake to check someone actually looked at the code.... really.
I use vim now but used rubymine in the past and that is awesome as well.
Good to see this coming along. Bury the hashrocket, its way too obnoxious
Hope i'm not too late I just sent you a PM as well with all my info. I have been using teamtreehouse about half way through the course, but still a beginner. I also have a Linode box that we can use if needed. Edit: I think Google hangouts can support up to 10 users maybe more, just a thought Thanks! 
A nice little blog post :)
 { "foo": 1 }["foo"] # =&gt; nil This is pretty confusing, IMO.
This wouldn't allow you to avoid it as it's still only setting symbol keys. The only difference here is that now you can use symbols with spaces in them with the new syntax. This doesn't set a string key { "not a string": "it's a symbol" }
I still like my hashrockets :/
&gt; Does anyone have a trick for saving the hash to file? I think the best way is to use JSON or YAML. &gt; there is something wrong with the 'view' part. what's wrong is, `each` calls the block with a `key`, `value` pair, not with 3 different variables. http://ruby-doc.org/core-2.1.3/Hash.html#method-i-each Also your value is an array. One solution would be doing it like this: ``` crimes.each_pair { |year, data | puts "#{year}: #{data[0]} drunk driving cases and #{data[1]} speedings." } ``` Another solution would be to change the structure of your crimes hash to make it more readable.
I like using decorators to add view-level logic to models, when it doesn't quite make sense to put the logic in the model itself. [draper](https://github.com/drapergem/draper) is a pretty good gem that helps with that. This article does bring up a pet peeve of mine. Describing a design pattern using really trite examples that never occur in the real world. e.g. "Imagine you have a car which has a 'drive' method..." I have never written any software that creates classes that so closely resemble real-word physical objects. I know the intention is to create a simple example, but it makes it harder for me to apply an idea to any sort of real-world scenario.
Regarding the second paragraph. That is so true. The other thing that I joke about with other rubyists is when a blog ends with, "I've been doing this for a few days, and it seems to be working so far." Really? A few days and you're now convinced of this new approach?
We do a lot of Chef stuff and have become fans of Mixlib::ShellOut. Easy to read. Easy to use. 
Not anymore than :foo and "foo"
True. However I suspect that happens more often than you'd expect. Think of a.b as an object of some class. Then accessing field a.b.c is bypassing the encapsulation (remember one of the main points of OOD?) So now you have couple your design to the internal representation of a.b Worse, it is the responsibility of the "b" class to maintain it's invariant, the relationship and constraints between it's field members. You have now loaded that responsibility on to the class that followed the chain as well.. 
Aw shucks
I don't think so, this way `&lt;key&gt;: value` is always equivalent to `:&lt;key&gt; =&gt; value`, no matter if `&lt;key&gt;` is `"key"` or just plain `key`
I've been looking for years for good timeline implementations (considering how it looks, how it works, and how it's implemented), and sadly there aren't any that I'm happy with. Simile is the least worst, though. Other than Simile, a custom one (D3 or otherwise) is my recommendation, as well.
You can make this even easier using `def`s return value in 2.1 http://blog.sgtfloyd.com/post/84242904702
It's actually called a thunk.
Thanks Maybe it's something common that I had not known about. Can you share some links?
Hey everyone, I'm writing an email right now - expect that within the next couple hours.
I'm about to PM you about this.
[Observable](http://ruby-doc.org/stdlib-2.1.3/libdoc/observer/rdoc/Observable.html)
If it's not too late, is there any more room?
about to PM you
Yeah. Most approaches work well for a few days. I'm really interested in whether it's still working 6 months later, after you've had a few requirements change, and some other code has been built on top of it. Is it still working at that point?
Jekyll is what you are looking for.
You're looking for a static site generator like [middleman](http://middlemanapp.com). 
In addition to those suggested there is [nanoc](http://nanoc.ws/)
www.staticgen.com there is lot of them here :)
Not to be rude, but if you had google'd the keywords "static ruby blog" from your post you would have found the very popular solution Jekyll.
Jekyll is what you are looking for like others said. Try hosting it on S3 with Cloudfront instead of a web server. It is much faster and no "server is down" head aches to be had. Use this gem to make it easy for you: [S3 Website](https://github.com/laurilehmijoki/s3_website)
There are certainly ways of creating variable names out of strings or symbols. But why not use a hash here since you basically want to refer to an object value by key name? pile = { "1"=&gt;[3,2,1], "2"=&gt;[], "3"=&gt;[] } =&gt; {"1"=&gt;[3, 2, 1], "2"=&gt;[], "3"=&gt;[]} # could get the following from gets.chomp pile_from = '1' pile_to = '3' pile[pile_to] &lt;&lt; pile[pile_from].pop =&gt; [1] pile =&gt; {"1"=&gt;[3, 2], "2"=&gt;[], "3"=&gt;[1]} Forgive me if I have forgotten nuances about Towers of Hanoi. --- edit: another solution using an array of arrays (but i still prefer the hash method above) pile = [] pile[0] = [3,2,1] pile[1] = [] pile[2] = [] # could get the following from gets.chomp pile_from = '0' pile_to = '2' pile[pile_to.to_i] &lt;&lt; pile[pile_from.to_i].pop =&gt; [1] pile =&gt; [3, 2], [], [1]] Here we have to start indexing our piles from 0 or we get a null element in front of the array
Why not use multidimensional arrays to store the stacks? Take this as an example: # Create an array of three arrays piles = Array.new(3) { Array.new } p "Which stack to move from? 1, 2, or 3?" # Prompt user for a number, and convert the input string to an integer i = gets.chomp.to_i pile_from = piles[i - 1]
`piles[3]` is `nil`. we'd have to subtract 1 from the number given, since the array is indexed from 0.
Whoops, my bad. Fixed it now.
It's not necessary, because BasicObject doesn't have respond_to? instance method.
This one I've not heard of, but it does not look like you and actually write updates in any form or post box of some kind, it seems like you still have to actually code+date each update in html yourself by hand. (Or markdown.) Which is what I am already doing without any Ruby scripts.
I can't find anything about how you post on their site. Can you tell me?
According to the page http://jekyllrb.com/docs/posts/ you 'make' posts by writing the html or markdown by hand, which is what I am already doing without Ruby scripts. Like I asked in the OP, I was looking for something that I write posts inside of, and after clicking a 'submit' or 'post' button of some kind it would take care of writing and dating the html file. 
According to the page http://jekyllrb.com/docs/posts/ you 'make' posts by writing the html or markdown by hand, which is what I am already doing without Ruby scripts. Like I asked in the OP, I was looking for something that I write posts inside of, and after clicking a 'submit' or 'post' button of some kind it would take care of writing and dating the html file. 
According to the page http://jekyllrb.com/docs/posts/ you 'make' posts by writing the html or markdown by hand, which is what I am already doing without Ruby scripts. Like I asked in the OP, I was looking for something that I write posts inside of, and after clicking a 'submit' or 'post' button of some kind it would take care of writing and dating the html file. 
According to the page http://jekyllrb.com/docs/posts/ you 'make' posts by writing the html or markdown by hand, which is what I am already doing without Ruby scripts. Like I asked in the OP, I was looking for something that I write posts inside of, and after clicking a 'submit' or 'post' button of some kind it would take care of writing and dating the html file. 
Why bother generating static content if you need a backend anyway?
`draper` is a complicated solution to a simple problem. It does some really complicated things in order to play nice with `form_builder` and the like. Better just using a PORO and pass in the model, when building a form - return that same model.
Not quite. You just do: nanoc post And it busts out $EDITOR for you to write your post (in markdown). Then "compile" the markdown and launch a local webserver to check your post: nanoc view Keep editing until it looks good, then push to production! nanoc deploy
Another great one is Dan Mayer's coverband: https://github.com/danmayer/coverband This is Rack middleware that uses set_trace_func to report on which lines of code are being executed. One of the best things about it is that it uses the simplecov output format, so you get a clear display of what's been executed: https://camo.githubusercontent.com/8189357691eb50b1f2b821dc9a7f730ce800a94d/68747470733a2f2f7261772e6769746875622e636f6d2f64616e6d617965722f636f76657262616e642f6d61737465722f646f63732f636f76657262616e645f64657461696c732e706e67
&gt;Isn't that what Jekyll does? No. Not according to their site.
What I'm wanting is for that to just be a local thing. The static part is what I would be uploading to a server.
&gt; Boy! does this class ever look clean. Actually it doesn't, the `super()` call to initialize a mixin is a massive bug. If you have two includes that work the way you describe (own `initialize` method, and a `super()` call in the constructor of the including class), you'll only ever manage to use one of them, as the constructor of the second will never be called. Example: module A def initialize puts "Hello from A" end end module B def initialize puts "Hello from B" end end class Foo include A include B def initialize puts "Hello from Foo" super() end end Result: Foo.new #&gt; Hello from Foo #&gt; Hello from A And that's only the beginning. You'll also completely destroy constructor inheritance: class Baz def initialize @baz = 'baz' end def baz @baz end end class Bar &lt; Baz include A def initialize super() end end Result: Bar.new.baz #&gt; "Hello from A" #&gt; nil Instead of using the instance variable directly, use a wrapper (in the module): def observers @observers ||= [] end Now you can remove the `initialize` in each module, as well as the super call. However, as wwzd pointed out, you effectively replicated the `Observerable` module in the stdlib.
Use the rake tasks to create a post, and an editor like [Mou](http://25.io/mou/) to create the posts. You are on your desktop, use its possibilities.
I could not find anything on their site about that. I tried it and it said that is not a known command. grey@x60:~/aliferecorded$ nanoc post nanoc: unknown command 'post' grey@x60:~/aliferecorded$ 
I suggest just signing up for a service like Tumblr if you don't want to write your posts in a markup language like markdown or textile. Tumblr has a wysiwyg interface, is very easy to use and there are tons of themes available.
Is there a feature missing that you want, or are you just insistent on having a gui versus a text editor?
I'm the author of the article, and even I agree with you about the examples. ;) One problem I face when explaining concepts like this is that having real world examples often distracts us from the core of the concept. If I include code from my actual projects, it's often some slight variation of the pattern that would require some extra explanation on why I made that choice in that particular case. That diverts us from the core of the concept being explained. I'd love some feedback or pointers on how to find the right balance here. &gt; I like using decorators to add view-level logic to models I actually wrote a [follow up article](http://nithinbekal.com/posts/rails-presenters/) about exactly this. I've used draper in the past, but I've moved towards PORO decorators since then.
Hey, thnx for this! Actually I've seen it before (and have it starred on Github already :), but haven't tried it so far. For sure I will and it goes along the lines of the gems I've listed in the article. Thnx again!
Thanks for the feedback. Looking back on it today, I guess I was actually supposed to handle the user input by running it through a case statement which is inelegant, but I do know how to do. 
The closer you look at enumerable, the more useful it gets.
you'll need to install nanoc gem http://nanoc.ws/install/
Wow, super useful list! Most of these gems (in particular deadweight) are actually going to be useful for a project I'm working on currently. 
I have. I know what a gem is. 
Have you seen [this](https://github.com/rails/activeform) I hope it can unify, and provide best practices for the front end. It is now in the rails repo!
In the first example, you're looping through N puddings one time. Using partition, you're looping through N puddings one time, then looping through each partition one time. For a small number of items there is no significant performance hit, but as your business and project grow and you start processing a much larger volume of pudding, there's a chance the partitioning approach may not scale as well as performing your operations all in one shot (both processing time and the amount of memory needed). The other side of this, though, is that you could theoretically partition out the puddings then queue up separate background jobs to process valid and invalid rows simultaneously, which could potentially be more performant given the right infrastructure and resources.
This is a very good idea. Thank You.
Good idea. Thank you.
On 'implementation 2', it might be more appropriate to use a Set instead of a Hash, since all you're trying to do is determine whether some character is a member of the set of characters you've already seen. I'm not sure how best to respond to the 'no additional data structures' constraint, especially in a language like ruby where there would never be any reason not to use methods like `uniq`, which presumably do use 'additional data structures' internally. If I were doing it in something like C, I might quicksort in-place and then check for equality across all adjacent pairs. Or, depending on interpretation of the problem, I might just allocate a char array (technically the same 'data structure' as a string) with the size of the character set, and use it as a table to store and lookup characters in constant time. Do any of you clever people have clever solutions to the 'no additional data structures' constraint, in ruby or any other language?
[Design Patterns In Ruby - Russ Olsen](http://www.amazon.com/Design-Patterns-Ruby-Russ-Olsen/dp/0321490452) - Attempts to take some of the patterns in the famous gang of four book and show a "C-like" way to implement in Ruby and the "Ruby way" to accomplish the same patterns. [Practical Object-Oriented Design In Ruby - Sandi Metz](http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330/) Those two are just good general Ruby/programming books. Here is a good beginner web dev book for Node.JS: [Learning Web App Development - Semmy Purewal](http://www.amazon.com/Learning-Web-Development-Semmy-Purewal/dp/1449370195)
&gt; I wasn't exactly sure how to solve without using an array or hash. The first thing that springs to mind would be to do it with regex. def dups? s s =~ /(.)[^\1]*\1/ end You'll get nil without duplicates or the index of the first repeated character. As for avoiding the 'no other data structures' rule: does passing a block violate the rule? can I make new strings? 
thanks for the improvement (set vs hash). Yea, the book was written using java, but I've been studying ruby and web development, so I wanted to practice with ruby. From your 3rd paragraph, sounds like you would solve using something like implementation #2 or #3? In terms of time complexity, would implementation #2 be considered the most efficient O(n).
&gt; From your 3rd paragraph, sounds like you would solve using something like implementation #2 or #3? In ruby, this was how I would do it (off the top of my head, in practice, not having not considered the problem in any great depth): def has_dup?(s) s.chars.uniq.length == s.length end Your #3 does seem to be the best way of doing it just based on the basic algorithm and data structures; it should be O(n) since the hash lookups can be expected to run in amortized constant time. That algorithm should be applicable in pretty much any language, while using ruby things like `uniq` 'hides' the implementation details.
&gt; Now, I'm curious which one is the most efficient solution You could always benchmark them...
Thank you for the response. I'm still confused, though. Doesn't the bang (sort_by!) alter that variable called string? Wait... if the variable string's still a String object, then it's not an array. Is that the problem? That you can't join a String? But since the join is applied directly to the recently split string, it's working on an array. So... If I had done something like: &gt; tempArray = string.split(' ').blahblahblah &gt; tempArray.join!(' ') That might have worked? I *think* I got it now. Thanks!
sort_by! is not called on string. It's being called on that temporary array that's stored in memory. Yes, if you had stored that array to a variable you could have called join on that. I think you got it, ese.
Yes, I think I do, even though I can't articulate it. Thanks again.
And guess how cool ruby is?! You can actually ask ruby what methods are available for you. 'a'.public_methods [].public_methods And, while we're at it, you can search through the methods to see that String doesn't respond to #join. 'a'.public_methods.select{|m| m=~ /join/} #=&gt; [] [].public_methods.select{|m| m=~ /join/} #=&gt; [:join] ruby is so damn cool.
GP may not be familiar with that so here's an example. Assuming the 3 methods in the OP are dups1-3 respectively, and the regex example is dups4: Add this to your code: require 'benchmark' TEST_COUNT = 1_000_000 … Benchmark.bmbm(5) do |b| b.report(:dups1) { TEST_COUNT.times { dups1('thequick brown_fox') } } b.report(:dups2) { TEST_COUNT.times { dups2('thequick brown_fox') } } b.report(:dups3) { TEST_COUNT.times { dups3('thequick brown_fox') } } b.report(:dups4) { TEST_COUNT.times { dups4('thequick brown_fox') } } end Which on ruby 2.1.3 (MRI) produces: $ ruby foo.rb Rehearsal ----------------------------------------- dups1 20.340000 0.090000 20.430000 ( 20.543420) dups2 10.030000 0.010000 10.040000 ( 10.046996) dups3 8.660000 0.010000 8.670000 ( 8.671653) dups4 5.560000 0.010000 5.570000 ( 5.581120) ------------------------------- total: 44.710000sec user system total real dups1 19.120000 0.040000 19.160000 ( 19.169931) dups2 10.200000 0.030000 10.230000 ( 10.249548) dups3 8.970000 0.030000 9.000000 ( 9.033016) dups4 5.460000 0.010000 5.470000 ( 5.474588) Probably not terribly surprising. EDIT: (made things a little less compact so it's easier to follow)
Their solution is wrong too, it wouldn't work unless you assigned the first modifications to "string" like so: def sort_string(string) string = string.split(' ').sort_by! {|word| word.length} string.join(' ') end 
Np. Vagrant is probably the best addition to my development tool chain in years. The initial investment is paid back a thousand fold. 
No, they are calling `#join` on the result of `#map`, which is an array. So it will join each element in that array.
I personally like the first implementation the best; so simple and concise. One small improvement to your third implementation: Enumerable#all? # Implementation 3 # Split and sort characters, then check if every next character # is different from the previous one. def sort_check_unique(s) s = s.chars.sort.join (0...s.size).all? { |i| s[i] != s[i+1] } end
This doesn't work unless the characters in your string are sorted (or if you happen to get very lucky), since squeeze only eliminates duplicates where they occur in continuous groups e.g.: irb(main):008:0&gt; "foo bar".squeeze =&gt; "fo bar" irb(main):009:0&gt; "bar baz".squeeze =&gt; "bar baz" Note that the two 'a' characters survive in the second example there. Also, whitespace is represented by characters; presumably they should be handled like any other characters since the problem doesn't specify otherwise.
Just to add to how cool Ruby is, you reimplemented `Enumerable#grep` near the end there.
Decorators can be an unnecessary abstraction when you use them simply as a replacement for inheritance. Here, I was trying to explain a scenario where inheritance is a poor choice because the properties added by inheritance are composable, and therefore you will need a large number of subclasses to represent the all the variations. For instance, you could have LargeBurger, CheeseBurger and BurgerWithFries subclasses. But you might want to mix and match these to get LargeCheeseBurger, CheeseBurgerWithFries, LargeBurgerWithFries and so on. For n properties, you will need 2^n subclasses to represent all variations. In this case, that's 8 subclasses. Every new property now doubles the number of subclasses needed. Contrast this with the decorator example, where you only need 3 new classes for representing all variations. The BurgerDecorator class only exists to DRY up the initialize method logic from the previously described decorator classes. I hope that clarifies things a little better.
Searching through the methods is a lot more easily done with respond_to?, but I take your point. &gt; 'a'.respond_to?(:join) =&gt; false
Great book. The main thing to remember if you're doing this in Ruby is that the question starts with "implement an algorithm" not "write a function". If you can't tell the complexity, that's because you haven't written the algorithm! It's probably not going to look like idiomatic Ruby. Believe me, I know, I wrote a bunch of solutions from that book in JavaScript. :) The question asks "has ALL uniques". Some of your solutions should exit early!
Yeah, that's the status quo of rails development +-5 years ago.
I doubt that :) What is your proof?
Ok, let me try to explain by mentioning all the classes involved. We start with a Burger class. The three properties we have are "large", "cheese" and "fries". For once, let's ignore "large" and just focus on "cheese" and fries. This leads us to 4 classes (the latter 3 being subclasses of Burger): Burger, CheeseBurger, BurgerWithFries, CheeseBurgerWithFries. Next we start considering the "large" property. We now have 4 more subclasses to represent the large version of the 4 burger types: LargeBurger, LargeCheeseBurger, LargeBurgerWithFries, LargeCheeseBurgerWithFries. In total we have 8 classes representing all the permutations of three properties. So, how can we solve this? We create 3 decorator classes: BurgerWithCheese, LargeBurger and BurgerWithFries, that we can use to dynamically generate all the 8 variations. For instance, instead of "LargeCheeseBurger.new", we could do: LargeBurger.new(CheeseBurger.new(Burger.new)) As an example the LargeBurger class looks like this: class LargeBurger def initialize(burger) @burger = burger end def cost @burger.cost + 15 end end Because we can mix these decorators any way we want, we need to make sure that they all have the same interface as Burger. So any method that is defined on Burger should be available to the decorated objects as well. To do this, each of the decorator classes needs to inherit from SimpleDelegator (which is part of Ruby standard library) and call super in the constructor method. class LargeBurger &lt; SimpleDelegator def initialize(burger) @burger = burger super end # def cost... end Now the only difference here from the previous example is that it inherits from SimpleDelegator and there's a call to super at the end of the initialize method. All three decorator classes (LargeBurger, CheeseBurger and BurgerWithFries) have this in common, so we can DRY up this code by moving it into a BurgerDecorator class that only contains the initialize method and inherits from SimpleDelegator. Now we only have to implement the cost method that is different in each of the three classes. The classes look like this: class LargeBurger &lt; BurgerDecorator def cost @burger.cost + 15 end end class CheeseBurger &lt; BurgerDecorator def cost @burger.cost + 20 end end class BurgerWithFries &lt; BurgerDecorator def cost @burger.cost + 10 end end Hope this makes more sense?
Yea, that's fine. Translating numbers to something human readable can be quite tedious. However, you want to extract the strings and use i18n to get them from a language file. Translation to another language probably isn't on your mind, but you might want to reuse the terms.
The only way I'd change it is (provided the method doesn't grow) is something like def stock(book) return "In Stock" if book.stock &gt; 5 return "Few copies remain" if book.stock &gt; 0 "Out of Stock" end As well as using I18n like /u/Femaref said.
Neat!! Ruby way of enumerating.
yup, thanks for the clarification. that put things into perspective. I guess I could always try to solve using idiomatic Ruby, and then try to implement algorithm using ruby.
Great point about them needing to be continuous. I overlooked that.
Didn't know the 'return' trick, thanks! :)
My mistake, I thought OP's second example (multi-liner) was the site's official solution. My comments above stand for OP's multiline solution though.
Ruby internally uses a hash to find the unique values when called on #array.uniq which parses the entire array at least once thus time complexity for Implementation 1 and Implementation 2 is O(n) * Although Implementation 1 takes longer in Benchmark results due to the additional overhead of split Implementation 3 is #array.sort which ruby internally uses Quick Sort, time complexity of which would be O(nlogn). Implementation 3 takes longer than Implementation 2 in worst case scenario when there are no duplicates, since it doesn't return untill it checks the entire sorted array. 
Upvote for thinking for Regex for this. :) Benchmark seems to give different results when there are no duplicate characters. Implementation 2 is faster than Implementation 3. TEST_COUNT = 1_000_000 Benchmark.bmbm(5) do |b| b.report(:has_dup?) { TEST_COUNT.times { has_dup?('world') } } b.report(:uniq_chars?) { TEST_COUNT.times { uniq_chars?('world') } } b.report(:sort_check_unique) { TEST_COUNT.times { sort_check_unique('world') } } end Rehearsal ----------------------------------------------------- has_dup? 8.740000 0.010000 8.750000 ( 9.578441) uniq_chars? 2.960000 0.010000 2.970000 ( 3.110357) sort_check_unique 4.960000 0.000000 4.960000 ( 5.349469) ------------------------------------------- total: 16.680000sec user system total real has_dup? 8.660000 0.000000 8.660000 ( 9.138248) uniq_chars? 2.960000 0.000000 2.960000 ( 3.278826) sort_check_unique 4.940000 0.000000 4.940000 ( 5.425829) 
Conditionals get a bad rap in OOP. They would become painful if the bodies inside your conditionals jumped to other methods or classes. Since you are just spitting out strings, you're fine.
Might look at something like [Jekyll](http://jekyllrb.com/), which is written in Ruby and can be deployed directly to Github pages or any server. 
Ruby always returns the last thing unless you use return.
Are you implying that when people ask for help that they don't actually have the foundation of knowledge they're claiming when they say "I read X but don't understand something"? Or are you implying that when someone says "You should read X", that the person recommending that book hasn't actually read it? In the first case, I think it's being needlessly aggressive to someone who is asking for help. In the second case, I think it's a lot easier to reply with "tell me what you liked about the book?" if you're skeptical. Otherwise, I think we should standardize on "Pics or it didn't happen" as the necessary first comment to every post :-)
How do you hold pdfs again?
Same here...
I need to keep this in mind so in a few years I can retire to a nice sunny place with low living costs in the US. Now I am in the big city, but in the future would love to switch to remote work.
Hey, thanks for the help! I'll check out JSON or YAML later on. Your solution worked perfectly. However, I'd like to ask you why you want to use #each_pair. I tried with #each, which worked just as good. In addition, do you have a solution to clear the screen and pause the program?
If this catches on, it's probably going to end up insulting a lot of folks and drive many folks away.
Yeah, this is a totally legitimate use of an if-elseif conditional. Although, now that I say that, I'm wondering if this shouldn't be implemented as a #stock_status method on the book class itself. Keeping the conditional, of course.
Yep. I would say fuck your book, show me what you know. Edit: ok let me rephrase that. Put down you book (read 'ego'), and let's talk about whatever the subject is instead of trying to figure out if the other person has really read whatever book was mentioned. If you have read it, sure, tell me what you like in it, don't be an ass about it.
I think that depends. It could be that the low stock threshold that bookstore uses to time their next order is different than what you'd present to a user -- something to entice them to act quickly.
Because you don't have to sponsor that person and that a huge cost for the company and blah blah blah, that's why, for the sponsorship and normally that company haves to pay for an apartment for that person
still looking for anyone self learning Ruby to work remotely :)? I think inversely the problem in Chicago is it is hard to find a place that is willing to take on someone with the passion and talent, but not necessarily the years of experience.
PushBots launched a long time ago and has since been vital to our push infrastructure and engagement, this gem has been used internally for months and has been extracted and gemified for your enjoyment and use.
It's very easy, in programming forums, for individual ego's to be hurt and then it becomes a bit of insults and bitch fighting in a passive-aggressive way - and that tends to make folks, especially beginners, stay away. Programming is about problem solving, and forums like these provide a good platform to do it collaboratively in what is a relatively independent profession. It's easy to bruise egos and trolls abound. Having said that, there is much wisdom in many books on programming, even in ruby programming, and it's good to encourage others to read, enjoy and make their coding better. 
there are tons of ruby developers lurking around /r/forhire
I'm in Los Angeles, CA
Yes, we're still hiring: https://www.covermymeds.com/main/careers/ Though I would add for a candidate who does not have a lot of experience with Ruby, they'd need to have good experience doing web development in another language and a desire to learn ruby (though our infrastructure includes PHP, Python and even some .Net moving forward most things are ruby). Most of our junior developers are co-ops we've employed and hire after graduation so we don't actively seek out many junior folks. 
Sure. And then you add some more model methods (like `Book#low_stock_for_user_enticement?`, LOL). My main point was that you can separate the model-appropriate business logic from the decision about the actual strings you'll use in your views.
Why limit your remote work to just US residents?
If you want to find an employee, why don't you make the information public here? I've seen ads for programmers and the ad itself makes me not want to work for the company. Maybe that's your problem?
It depends where you are and how modern your accountants are. Where you are matters because some places (in and outside the US) have surprisingly few competent developers fluent and literate in technical and customer English. I'm an American working as Chief Engineer of a Singapore small company that's about to move our development office to the Philippines because the number of open jobs here routinely exceeds the number of available *competent* people by at least one order of magnitude. I've been living outside the US for most of the last two decades and often working for American companies &amp;mdash; just never on a W-2. Once you get *those* blinkers off, the remote world becomes a much less inaccessible place.
the one you created yourself ;)
Hey Femaref, thanks for the feedback! I didn't know that the super() keyword in Ruby would only instantiate the last module. This will likely save me debugging time in the future :) I can see where the added benefit of being able to initialize the observer array anywhere (not just the initialize method) would come in handy. I'll add an note on the post about it.
Personally I'm using Jekyll. It has really good support for Ruby syntax highlighting. You can use github pages as free hosting. And it is really easy to update blog.
`gem` always takes a ridiculous amount of time to install on my machine. It might not be the advice you're looking for, but try running the command and let it be for five minutes or so. (just to see if it really is the problem)
What do you get for "ruby -v" ? 
I'm using Jekyll but I think you want to use something like [ghost](https://ghost.org/)
I would say "yes". They're not as plentiful as Java/.NET programmers. 
Is there a reason for this other than it looks neater? This is actually how I often do this sort of thing, but I've wondered if there was a performance difference in heavy usage (better or worse) compared to if-else.
I'm not OP but it could possibly be time zones. Our team works remotely, and its hard enough with the Pacific &lt;-&gt; Eastern timezone shift. I (pacific), try and start my day earlier than I normally would, so I can interact with my co-workers better.
checkout /r/jobbit for job postings
Yup, and since it produces static pages it can withstand pretty much any flood of traffic. You'll saturate the network before running into any CPU issues.
Why wasn't this post deleted then?
I wasn't intending to return phrases (from the model), just boolean values. The phrases are probably more properly considered a view concern.
Because the mods haven't noticed it yet? Because the mods are happy to let the community vote it up or down and thereby decide whether it accepts job adverts or not? Because the mods will let a few small infractions slide, and will only start deleting posts if it becomes a significant problem on the subreddit? Everything not immediately instabanned is not necessarily therefore mandatory, or even desirable.
Awesome. This is probably just what I'm looking for.
OK, then there is no harm for the poster to post their job opportunity.
It may save microseconds, so probably not a performance reason. It's somewhat of a convention to try and stay on the same indentation level as much as possible. But it's a convention not a rule, of course. 
I'm not sure. When my LinkedIn prominently displayed that I was a Ruby freelancer, I got bothered by recruiters all the time for the NYC area. Never been on the other side, though, looking for someone qualified for a position. I'm not looking for full-time but am always open for freelance and short-ish contracts. chris@subvertallmedia.com. [github.com/subvertallchris](https://github.com/subvertallchris).
Las Vegas has ruby devs and no companies using it. We need more companies coming in and hiring.
There is actually built-in support in i18n for handling different strings based on different counts -- but it's targetted use case is for when the forms of words vary based on count (not all languages have just 'singular' and 'plural' some have more forms). I'm not sure if you could use it for your 0, &lt;=5, &gt;5 cases, and I don't know if you'd want to if you could, but it's possibly an option. https://github.com/svenfuchs/i18n/wiki/Pluralizations Hmm, wait, that just describes singular vs. plural. I could swear rails i18n did CLDR-compat pluralization, which handles more than just that, but maybe i was wrong. Anyway, yeah, probably more trouble than it's worth even if possible. 
It's also mostly a question rather than a straight job posting.
It gives me this: http://pastebin.com/raw.php?i=RjujL0dq
It gives me this: http://pastebin.com/raw.php?i=RjujL0dq
Are you not finding anybody at all or are you not finding qualified candidates? Where have you looked?
I'm not sure how you came to that conclusion based on what I said, unless it's just your personal opinion? (Also, I didn't downvote you, BTW)
I agree with this statement. 
I agree that production gems *absolutely* should be updated and tested in isolation. In practice, I've found this flow to be a huge productivity saver for updating non-production dependencies including: * test libraries/utilities * toolbox/binary gems * development utilities 
Crazy and great! :D
Great! We're looking for a senior Ruby developer with 10 or more years of experience, with a strong background in web development, databases, etc. Salary? Oh. We can pay $30,000! That's competitive, right?
Been working from CET with PST for 4 years already. Hardly can imagine myself switching back to regular 9to5. First of all, I wake up at around 12AM and have a whole day free, it means: sunlight, easy groceries, no traffic, no queues in any places. When you flowing with regular daily graphic, you expect waves of people right after the work day is over. Working that way you can cheat the system! I start working about 8 PM, having a break to get my daughter to sleep. After that, I am alone in my office room, having nobody to disattract me: no spam calls, no appointment reschedules, nothing. Just a night and some proper coding. Obviously you have to be a night bird for that, but this experience is priceless. If I'd have to change my job, I'd definitely be looking for US remote opportunity.
It seems like there's about 1,000 bootcamps now that are churning out Ruby developers.
AFAIK, it's not a big issue. You just make your remote devs act like a company and basically pay their corporate bills on a monthly basis. How could it get any harder?
From my perspective, changing a working place is a roulette. There are thousands of small start-ups looking for devs, offering high salaries and bonuses. But how much time would it take for them to eat investments out? And what's next? Yet another start-up with crazy night shifts? Not an option for a family man, I'd rather stick with lower salary, than taking such risks. Leave it for younger generation, but hey, that's why it's hard to find 8+ years devs - kids grew up and made their own kids. They don't need Guitar Hero in the office, they need their lawn to be mowed regulary.
Greetings Jon! Would you be open to seeking a full time role in DC? I am sending your way a link to the PD http://param-solutions.com/ruby-on-rails-developers-washington-dc/. PM me if this peeks your interest! -AK
This is definitely wrong. 
This makes no sense
This is the correct answer. 
I don't care about the downvotes. I came to that conclusion because this is a post trolling for jobs disguised as a question. The poster knew that listing the job offer here would be downvoted so they were smart enough to make it a question. The question has 8 upvotes so /r/ruby likes it enough. Posting the job listing would help the poster figure out why they aren't getting applicants. The fact that they haven't replied at all implies to me that they got plenty of people asking about jobs. Pretty clever. 
You can probably get some output with dtruss; that should show you what syscall is blocking, too: $ sudo dtruss bundle exec gem install olde_code_finder dtrace: 7957 dynamic variable drops with non-empty dirty list SYSCALL(args) = return thread_selfid(0x0, 0x1DC0, 0x7FFF6F63C550) = 4822186 0 csops(0x0, 0x0, 0x7FFF551D0084) = 0 0 issetugid(0x0, 0x0, 0x0) = 0 0 shared_region_check_np(0x7FFF551CDFB8, 0x10AA2F000, 0x4) = 0 0 stat64("/usr/lib/dtrace/libdtrace_dyld.dylib\0", 0x7FFF551CF168, 0x7FFF551D00A0) = 0 0 open("/usr/lib/dtrace/libdtrace_dyld.dylib\0", 0x0, 0x0) = 3 0 [.... and much more output ...]
My company has done the same thing. We are based in Canada, not the US, so we have good salaries but can't compete with SV pay. So we've changed our job description from "We're hiring Ruby developers" to "We're hiring developers". We have a critical mass of smart people and good practice so we haven't had any problems training up talented people on the Ruby stack. It's still a bit of a trope in the Ruby community though. You'll be hard pressed to find any Ruby shop that isn't actively hiring Ruby developers. Attending Ruby conferences is almost comical in how desperate for devs so many of the shops are.
Yup. We're on our second round of looking for a senior Rails developer and it's really hard. I had one recruiter tell me that for senior developers, they were getting $120k - $150k in Boston. I have no idea if that's true or not, but pretty amazing if it is. We just can't compete with salaries like that.
There's a substantial Ruby community in Ottawa, Ontario, if "Canadian" is close enough to "US residents." About half of them are already employed by Shopify though.
You could also use the Ternary operator. ` condition ? if_true : if_false` But watch for, "long line itis", so to speak. You don't want some really long single line... Just looks bad. 
Looks fine to me dude. Easy to read. I know exactly what it does without comments, etc, etc...
Well you have achieved a good first step by removing the "must be in the office" requirement. But you are still limiting yourself to the US geographically. There are people outside the US as well. Might be worth re-evaluating what it is that is stopping you from hiring outside the US. (I know one company that had this restriction because, frankly, their accounting department were too lazy to investigate it.)
Then compete on other things, like offer a strict 40 hr max work week. Too many software shops, especially startups, fetishize herculean effort, and burn out their devs.
Its all relative to cost of living, however it can be sticky(from a tax perspective) hiring non-citizens as a small US company.
This is an interesting read on the issue http://www.acc.com/legalresources/quickcounsel/ecwuscmoaeieoc.cfm
Explain
www.materialdesignr.com/development
Yup this. 
Bootcamps aside, senior ruby developers are some of the most passionate and opinionated people I've worked with. The top notch devs need work that will impact and change lives. They've typically experienced other languages and been won over by the simple expressiveness of the language. Finding great Ruby developers is very difficult, not because there are few of them, but because they are in such high demand. The sheer number of bootcamps and novice training groups testify that demand is high. Investment in juniors now is critical for the language's future.
wth, you must be really bored..
This could not be more true. I've been coding in Ruby for about a year now and all I've been hearing is "we're looking for someone with more experience".. Despite the fact that I've built several apps, have good front-end skills, and have past experience launching and running a startup. 
Just [posted there today actually](http://www.reddit.com/r/forhire/comments/2ikgvk/for_hire_enthusiastic_ruby_on_rails_and_frontend/) :)
I attended a 9-month full-time bootcamp, been coding in Ruby for about a year now. You would think investment in juniors is critical now but all I've been hearing is "we're just looking for someone with more years of experience" - now this could be because I'm located in Chicago, who knows. 
I love Bullet, I didn't realize I was performing multiple n+1 queries in one of the apps I built and it felt good to clean that up.
I think the issue is the lack of mid/senior devs, with a glut of junior devs.
So wouldn't it be in a company's best interest to hire junior devs, so that down the line (assuming they have good retention), they don't have a problem finding mid/senior devs?
Boston, NYC, and SF are all high-salary areas for devs. Seniors generally make in the $120k-$150k range in those cities.
Shit, all I want is a parking spot.
Double plus on Russ Olsen's book. It also teaches you useful Ruby idioms, not just application of patterns. The fact that he selected the most applicable patterns is telling - it teaches you a level of pragmatism. 
Plus plus on this. If you use Github's built in support for Jekyll (automated deployment for instance) you will be limited in what plugins you can use, but it's fairly easy to get around this by deploying the site yourself. Hosting Jekyll on Github is pretty sweet. 
That's a refreshingly realistic definition of "senior". Too often (though more in relation to another very well-known initialism of a Web language than to Ruby) I've heard "senior" defined as low as one year. To a guy with nearly five years of Ruby experience out of a 35-year career in over a dozen languages (and with real engineering exposure elsewhere), this is… *disheartening and frustrating* would put it absurdly mildly.
The service doesn't seem to support Ruby
That's sort of like, should I learn calculus before I learn physics? You can... But most of the example applications are going to be physics problems. I found it was most effective to just learn them together.
It does make sense, but it doesn't explain why decorators are better. Maybe it's the burger example, maybe I'm just dense. FWIW, I understand how inheritance works, so there's no need to re-hash the "bad" method again. You explained it at length in your original post and I got it then. &gt;Now the only difference here from the previous example is that it inherits from SimpleDelegator Again, I understand the difference and even what SimpleDelegator is doing. What I still don't understand is why writing this: class LargeBurger &lt; Burger class CheeseBurger &lt; Burger class BurgerWithFries &lt; Burger is worse than class LargeBurger &lt; BurgerDelegator class CheeseBurger &lt; BurgerDelegator class BurgerWithFries &lt; BurgerDelegator when both override the same method and nothing else. Again, maybe it's just the examples (why would your LargeBurger class accept a Burger as its #new argument instead of just inheriting?) that don't make sense and as someone else mentioned, a real-world example might make it crystal clear. I appreciate you trying to explain it to me, but don't feel like you have to keep trying if I'm frustrating you.
No need to use `#join` as `#==` work on arrays. Alternatively, you could skip the `#downcase` and use `#casecmp` on the sorted strings (this would require using `#join`).
Along the same lines, you can get use caller_locations to get an array of Thread::Backtrace::Location objects which have that same information but without the need to split strings: irb(main):001:0&gt; class Foo ; def bar ; caller_locations.each {|x| pp x.path } ; end ; end =&gt; :bar irb(main):002:0&gt; Foo.new.bar "(irb)" "/opt/rubies/ruby-2.1.2/lib/ruby/2.1.0/irb/workspace.rb" "/opt/rubies/ruby-2.1.2/lib/ruby/2.1.0/irb/workspace.rb" 
Seems low when you consider the cost of housing in those areas, though.
take a look at http://www.sublimevideo.net
Thanks for the response! Their solution is to also encode the video twice (once in mp4 and once in webm), I was looking for a way to avoid this and only have to encode the video once but it looks more and more like that dream won't be a reality. 
No, zeef is more like a link directory where people can organise their links. In this case it's the author of asciidoctor himself who created that page (there were a few tweets about it from reputable people on twitter). As far as I know there's nothing algorithmically there and I certainly don't see any adds. They're most well known for several popular Java pages like https://jsf.zeef.com (created by top stackoverflow user BalusC) and https://javaee7.zeef.com (The asciidoctor author Dan Allen used to be a Java guy too, but he converted to using mostly Ruby some year orso back)
I would add the following to the mix: gem 'capistrano-rvm' gem 'capistrano-bundler' gem 'capistrano-thin' gem 'capistrano3-nginx', '~&gt; 2.0' gem 'whenever' Nginx one has its downsides, but works pretty well. Don't be confused by whenever, it has capistrano related tasks too for crontab generation.
This is not a Ruby question hence why you are banging your head. Try looking at some of the flash/javascipt media players. Getting 100% cross platform playback isn't easy although I think that mediaelement.js comes close (NOT A RECOMMENDATION) and I have used jwplayer in the past with decent results. Flowplayer, video.js and some of the OSMF players might also be worth a look. For what its worth I'm working on a OS HLS server and need to code up the client this month and media-element is probably what I will be using based on my initial research.
Communication makes it that much harder if the timezones are too far apart. We don't want to hire someone with whom we only have a 4 hr window to speak.
Hush now... only dreams.
Nice! hackernews_ruby&gt; $ bundle console Resolving dependencies... irb(main):001:0&gt; HackernewsRuby.configure {}; HackernewsRuby::Client.new.get_item(8863).title =&gt; "My YC app: Dropbox - Throw away your USB drive" 
Hmm, to do in linear time, I just thought of: def anagrams?(s1, s2) ord1, ord2 = [s1, s2].map { |s| s.downcase.strip.chars.map(&amp;:ord) } ord1.inject(:*) == ord2.inject(:*) &amp;&amp; ord1.inject(:^) == ord2.inject(:^) end I'm not yet sure that it's completely correct though. **edit** I think if every `ord` was mapped to a prime - then all you'd need to do is compare their products. **edit** whitespace
It's not: &gt; &gt; anagrams?("ef", "dg") &gt; =&gt; true
thanks!
Yeah, I realized just addition wouldn't. The prime thing should work though.
Yeah. Using `#casecmp` requires inspecting the return value to determine equality, so just removing the `#join` cleans things up while still keeping it simple.
You could also use `s.downcase.scan(/\w/).sort` if you were code golfing.
Would you care to write a line explaining that to a complete newbie? :) 
My perception is that seniority levers also move when demand is so high. This is usually driven by recruiters with little or no experience in the area, to ensure their salary/bounty ratio is correct. 35 years will obviously give you a breadth of experience like few others.
Oh, yeah, forgot about that. Just added a `strip`.
Yes, that's true. However, it's still bad form to need a super() call to make a mixin useable.
Yep. I still use Sinatra for smaller sites that really don't need rails. I've been doing more work with it than rails recently.
Yep, it's my first choice for APIs.
I'm a hobbyist but I pretty much left rails for Sinatra because it doesn't tempt me to write a huge web app every time. it let's me focus on composing smaller services. 
If you are looking for an easier to setup CAS server take a look at http://casino.rbcas.com/docs/configuration/ . It also nice way to test using casino-test_authenticator which only tests that the username and password are the same. As a sidenote rubycas-server is only compatible with version 2 of the spec plus a few bits of v.3 . The spec is currently at v.4. There is also not much activity going on with it, All of that said unless you have bunch of disparate apps that need to use the same credentials for everyone CAS is overkill. Background: Wrote/maintain cas_sso plugin for Discourse. Got changes made to CAS auth handling of SLO (single logout) made to Canvas. A patch or two to omniauth-cas.
The `&amp;` symbol indicates a block. For instance def foo(&amp;block) block.call end foo do puts "hello" end # =&gt; "hello" There is a feature in Ruby, where a symbol can be turned into a block (technically a proc). The feature is called symbol to proc http://railscasts.com/episodes/6-shortcut-blocks-with-symbol-to-proc So what that syntax means is instead of writing `groups.map! {|x| x.join }` all you have to do is write `groups.map!(&amp;:join)`
Just FYI if you want to break up your text into multiple lines without creating a new paragraph you can put a double-space at the end of the line.
Ahh, this is super helpful. Thanks a lot for the response! Your 4 collection operations breakdown really cleared a lot of this jumbled info in my brain up.
That makes perfect sense, thanks for the response!
 def anagrams?(s1, s2) (comparable(s1) - comparable(s2)).empty? end def comparable(s) s.delete(' ').downcase.chars end
I just wrote my own with rails. basic but working fine.
Again, to play devils advocate, WHY do you need more than 4 hours per day of communication? A developer develops, they work best when given a task and left to it. Why do you need the ability to contact them at any moment in the working day? If the response is something like "putting out sudden fires or if we need to change something at a moment's notice" then I think you should be looking at your internal workflows and work style. You should also consider people in place like Australia where the difference does not always mean a shortened window Sorry if this offends, that is not the goal.
I use this for internal multi-app web single sign-on at my company. Integrates via LDAP with our Active Directory setup. Works like a charm. Since this is an internally facing only application set, I don't worry too much about how up-to-date it is.
http://www.ruby-doc.org/core-2.1.3/Array.html#method-i-product Get to know Array and Enumerable well, the time investment will pay for itself many times over
 #permutation would also work I think?
basically, sinatra gives you a webserver and nothing else. it's like rails without the structure. if that's fine for your project, use sinatra by all means.
Yep, misread requirements
You could just shift everyone along 1 - i.e. match up `team_1[i]` with `team_2[i+1]`. If it needs to be random then shuffle the teams in tandem first - i.e. `team_1,team_2 = [team_1,team_2].transpose.shuffle.transpose`. A permutation that has no fixed points is known as a *derangement* if you want to have a google.
How big are your teams? I'm not good at algorithms, so perhaps someone can correct me. Create a hash with Team 1 Members being the keys. The each value is team_2.dup.shuffle. Every round: Create a blank "opponents" array. For each key in the hash, check if its last element is in the opponents array. If it's not there, remove the last element from the array, and push into the "opponents" array. If it is there, select a different element from your hash array. You can try the first element, and then a random one between the first and last. Whatever you want. Just make sure to remove it from the hash array. Zip your opponents array and your team_1 array. Those are your matchups. Your hash now contains a list of each Team 1 Member's unfaced opponents. Do that for as many rounds as you want to play, which can be anywhere between 1 and team_1.size.
Can you explain how you'd do this with product?
There is also [Octopress](http://octopress.org/) that is built on top of Jekyll. Octopress has HTML templates, CSS, Javascripts and a basic configuration to get you started.
Solution source code: rounds = team_2_ary.permutation.map{|_| team_1_ary.zip(_)}.shuffle Explanation: * keep the team 1 array stable * generate all the permutations of team 2 * for each permuation of team 2, zip team 1 and team 2 * the result is an array of the possible rounds * shuffle the rounds 
Yep, just built a simple stats collector with Sinatra + Mongo yesterday.
A lot of truth there. Interesting that he sees the breaking point to be when code gets stored in a database. I've also found it helpful (when I don't feel like I understand a model fully) to add an "options" column of type TEXT. I can then store additional attributes that only apply to a few rows in there, and I can later promote them to additional columns or perhaps to tables if they need it. It's a poor man's key/value store, but it does the job until things get nailed down.
Well, you have to group afterwards but something like this: irb(main):016:0&gt; a1 = ["Bob","Tom","Jim"] =&gt; ["Bob", "Tom", "Jim"] irb(main):017:0&gt; a2 = ["Beth","Tanya","Jane"] =&gt; ["Beth", "Tanya", "Jane"] irb(main):018:0&gt; a1.product(a2).group__by.with_index {|_, index| index % a1.length} =&gt; {0=&gt;[["Bob", "Beth"], ["Tom", "Beth"], ["Jim", "Beth"]], 1=&gt;[["Bob", "Tanya"], ["Tom", "Tanya"], ["Jim", "Tanya"]], 2=&gt;[["Bob", "Jane"], ["Tom", "Jane"], ["Jim", "Jane"]]} Get the permutations, then groups by the index, moding by the size of the arrays to gather the first, second, and so forth occurances. Makes assumption that arrays are of equal length. irb(main):019:0&gt; a1.product(a2).group_by{|a,b| a} =&gt; {"Bob"=&gt;[["Bob", "Beth"], ["Bob", "Tanya"], ["Bob", "Jane"]], "Tom"=&gt;[["Tom", "Beth"], ["Tom", "Tanya"], ["Tom", "Jane"]], "Jim"=&gt;[["Jim", "Beth"], ["Jim", "Tanya"], ["Jim", "Jane"]]} You could also group by the players themselves to get their matchups. Lots of other ways to mix and group, depends on what you need.
Thanks! I haven't worked with CAS at all until my current job, and was hoping to find an easy way to set it up for folks that might need it. RubyCAS + Casino look like they could do that without needing a full Tomcat/Java stack setup.
Based on my own experiences, I'll throw in the Matasano Crypto Challenges. These are amazing for the amount of Ruby I learnt in a short period.
I don't think of it as a split really. I work for a company trying to make data science more accessible (not gonna spam) but we do support Ruby. It's the first language I learned and it was nice to feel like I could do more than build Rails apps. We also support Python though. So I understand how Ruby isn't the best language for it. 
Oh, I see that. Hmm, thats a good question. Let me think, product may not be the best for this. Maybe a combination of #permutation and #zip Looks like this works: irb(main):037:0&gt; a1.length.times{|x| puts a1.rotate(x).zip(a2).to_s } [["Bob", "Beth"], ["Tom", "Tanya"], ["Jim", "Jane"]] [["Tom", "Beth"], ["Jim", "Tanya"], ["Bob", "Jane"]] [["Jim", "Beth"], ["Bob", "Tanya"], ["Tom", "Jane"]] Rotate through a1 a1.length times, and zip that to the staying a2. I feel like there should be a cleaner way to drop that length and times, but all the methods I can think of operate on elements instead of the array as a whole. Either ways I'm going to do some actually profittable work for a bit, but that was fun looking through the methods available :)
a few ways you could handle it are outlined already, but it sounds like shuffle is not what you want. You could use Array.cycle on one of the arrays, and only cycle the number of times for each element there is, and that would work. I would usually lean towards more fool-proof solutions, such as making each into a hash, with a value as an empty array. Then, anytime you want to see who in team_2 should go against in team_1, you would determine who isn't already in an array, and allow them through. A pitfall of this solution though, is that it's possible for bob and beth to get stuck together because jane could take tom when it should take bob, which screws beth; so you would need some logic to ensure that when a pairing is selected it's not going to cause conflict elsewhere. So, maybe something like cycle would be a better solution, then. Other solutions identify all the possible permutations and those are viable approaches as well depending on how you you need things to behave in the grand scheme of things. 
Let me format this for you. Code block 1: irb(main):016:0&gt; a1 = ["Bob","Tom","Jim"] =&gt; ["Bob", "Tom", "Jim"] irb(main):017:0&gt; a2 = ["Beth","Tanya","Jane"] =&gt; ["Beth", "Tanya", "Jane"] irb(main):018:0&gt; a1.product(a2).group__by.with_index {|_, index| index % a1.length} =&gt; {0=&gt;[["Bob", "Beth"], ["Tom", "Beth"], ["Jim", "Beth"]], 1=&gt;[["Bob", "Tanya"], ["Tom", "Tanya"], ["Jim", "Tanya"]], 2=&gt;[["Bob", "Jane"], ["Tom", "Jane"], ["Jim", "Jane"]]} Code block 2: irb(main):019:0&gt; a1.product(a2).group_by{|a,b| a} =&gt; {"Bob"=&gt;[["Bob", "Beth"], ["Bob", "Tanya"], ["Bob", "Jane"]], "Tom"=&gt;[["Tom", "Beth"], ["Tom", "Tanya"], ["Tom", "Jane"]], "Jim"=&gt;[["Jim", "Beth"], ["Jim", "Tanya"], ["Jim", "Jane"]]} After you paste in the code, select it and press the little `&lt;&gt;` button above the text editor (or indent each line 4 spaces).
Associate user account with language or allow user to set language using a dropdown / button in the UI and save the selected language in the session. Then use the selected language to pick the correct css file in the view. If using the sessions method then default to language X is nothing set in the session.
Edit: I see that I misunderstood your question. You actually count a ROUND as 3 matchups -- all of the team members play at once. That makes the question a little trickier, but the second solution can be pretty simply extended to meet that case -- just also keep track of the eligible players for the ROUND, too. Original reply below: \-\- It's pretty easy. If the N is low, you can just compute all possible matchups with product, then shuffle it once and iterate through the array: matchups = ["Bob","Tom","Jim"].product(["Beth","Tanya","Jane"]).shuffle #combine arrays and shuffle matchups.each_with_index do |match,ix| person_1,person_2 = match #this is a random matchup, since you shuffled puts "Match #{ix + 1}: #{person_1} vs. #{person_2}!" #call match playing method here, get result of match puts "Winner is whatever that method says!\n\n" end That way you just shuffle once and iterate once. Computationally efficient! =) It produces output like this: Match 1: Jim vs. Tanya! Winner is whatever that method says! Match 2: Bob vs. Jane! Winner is whatever that method says! Match 3: Jim vs. Jane! Winner is whatever that method says! Match 4: Tom vs. Beth! Winner is whatever that method says! Match 5: Bob vs. Tanya! Winner is whatever that method says! Match 6: Tom vs. Jane! Winner is whatever that method says! Match 7: Bob vs. Beth! Winner is whatever that method says! Match 8: Jim vs. Beth! Winner is whatever that method says! Match 9: Tom vs. Tanya! Winner is whatever that method says! [Finished in 0.1s] Your results will almost certainly vary -- it's random after all! If the N is high, I'd recommend instead just sampling from the 2 arrays and then keeping track of matchups that have already occurred, like so: t1 = ["Bob","Tom","Jim"] t2 = ["Beth","Tanya","Jane"] already_played = Hash.new([]) #this creates an empty hash with a default value of an empty array 5.times do person_1 = t1.sample person_2 = t2.sample if already_played[person_1].include?(person_2) puts "#{person_1} has already played #{person_2}, skipping..." next else puts "#{person_1} plays #{person_2}!" already_played[person_1] += [person_2] end end For such a small sample, this will result in many collisions. But if your sample is large and your number of rounds isn't too high, it should be fine. Both options have their downsides. The first, comprehensive option requires you to do all of the work up front. The second option requires no work up front but has increasing difficulty as more of the available matchups have already occurred.
if you're using Postgres the `json` type is awesome for this, Hash in, Hash out, plus you can query on hash fields if needed. You can even write accessors which map to fields in the hash you think you're likely to promote to columns later so that refactoring is fairly painless. 
You can also use it to make a lightweight mock of an API for your tests http://robots.thoughtbot.com/how-to-stub-external-services-in-tests#WgaWga
We use Sinatra as the basis of our in-house tech stack.
Why not outsource? 
As a Senior Ruby Dev and as a person who is part of the hiring process at my company, I would say "yes". In our area (Philadelphia and suburbs), Ruby developers are hard to find and hard to attract. They are almost always already employed or in the very brief period between jobs and almost all that we've seen will get multiple offers, even the ones we disqualified as not up to our standards.
I'm in the complete opposite situation: after spending 10+ years coding in .NET, I switched to Ruby/Rails two years ago but nobody is using Ruby in Switzerland. Been looking for a full-time Ruby position for the past year without success.
a month for full time? (realized it now, wow ...)
Hi! Check this [link](https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats#Browser_compatibility) to see which browser which format supports.
[Repost](http://www.reddit.com/r/ruby/comments/2i3drl/refactoring_ruby_with_monads/) (from just 6 days ago)
doing same thing. night time is best. zero distractions.
By "sums", I assume you mean products. 11+13 = 19+5
&gt; $30,000! No its not. he meant 30k per year. In Latin America salaries are usually talked in terms of months, but the rest of the world is usually per year.
What do they do?
Ah weird - I updated the gem this morning so perhaps I broke a build you installed. Mind updating and trying again? `Hackernews::Client.new.get_item(2323)` should work.
Is not like i couldn't give a structure to my app following some design patterns and conventions
Brilliant!
App Academy is producing a constant stream of high quality rails devs: http://www.appacademy.io/#p-home
Like Matz built "mruby" to compete with LUA. Its small experiments that either work and gets traction, or don't and get buried. I was once told that the F# language started with a guy that wanted to prove how bad the .NET runtime would handle functional programming, but that he was surprised of how well it handled it. Now you see all kind of functional programming elements get added to other languages connected to the runtime. Experiments are healthy.
I'm from Boston, you can afford to own a house in the nearby suburbs no problem if you have that salary...
I know he meant per year, You'll be amazed how screw up is Venezuela in terms of exchange controls and how much a single dollar is worth.
Still doesn't account for whitespace within the anagram (or upper case chars). You'd need to do something like `s.downcase.scan(/\w/).map...` for it to handle whitespace and upper case chars.
You need to use test framework for that. Did you try with minispec / rspec ?
well, thats all there is to rails really. it comes with a bunch of stuff prepackaged. if you want to implement things yourself, or don't want them at all, sinatra is a much better framework for you.
Good point. It's low for a senior dev in SF or NY. It's more typical of a senior dev in Boston or DC, though, which aren't quite as pricey.
Exactly -- their alternative to your job is usually pretty good, and you've got to make a compelling case for them to switch jobs.
The mail gem provide matcher for that https://github.com/mikel/mail/blob/master/lib/mail/matchers/has_sent_mail.rb You can see how the gem is tested and do the same : https://github.com/mikel/mail/blob/master/spec/mail/message_spec.rb
How far is "nearby"? Long commutes are grating.
Medford, Waltham, Arlington. All good places with houses in the 400-500k range.
Move your execution code into a method (lines 42-49). Make a second file that requires the first one and then runs that new method. Now you have two files. One with all your code in a file that doesn't do anything on it's own. And one that only calls the methods to start the program. You can now require the file with the methods in an rspec test file. And test each method in isolation. 
Well, If you are going to use it, it should be used consistently throughout the source code. Both Dave and lazy Tam should be using the same conventions.
That's actually a pretty good place to start, and then I would also recommend taking a look at [Learn to Program by Chris Pine](http://pine.fm/LearnToProgram/) (he is hilarious, in my opinion!) and [Learn Ruby the Hard Way](http://ruby.learncodethehardway.org/book). After doing those two plus the Codecademy website, you should have a pretty solid understanding of the basics.
Thank you! :)
You could mock the `send_html_mail` method with rspec mocks. Even better you could mock the `RestClient.post` method so you can ensure you called the function you need to send email without actually calling it. I should note you're using instance variables without a class wich in effect makes them globals. I would rewrite your methods to just use normal variables and pass them where they need to go. It will force you to make your functions a little cleaner and easier to test. Instance variables come in to play a lot more when you use them on classes and help you make your classes a lot cleaner.
Thank you! This is exactly the kind of advice I was looking for!
There are plenty of senior devs, in the US, like me who own their own consultancy of one. Find one of us to work long term for your company. At this level it is assumed you will be pairing with the junior people at the company. Hire a junior or two and contract the senior dev for a few months. It would not be unheard of to have one of those junior people move up to mid level or become and export on what ever feature the group was working on. I have been developing since 1995. A long time for sure, but not that rare. Most meetups (meetup.com) I attend in my area include at least a few of us there. Try attending a few meetups and get to know the people you end up seeing at several.
Define huge.
Check [rails-api](http://github.com/rails-api/rails-api)
Us poor bastard drupal devs. 
IMO it had a chance at some point of time, but haven't received much attention. It should have been promoted as A collection of Sinatra addons, which it mostly, rather than a new framework built on top of Sinatra. I love how rack apps can be mount and I hate Padrino 'sub-applications', though they may have models in common.
Oh yeah, whoops. I was wondering if it was possible to do this without multiplication, got mixed up. I think I was considering sum _and_ xor, but wasn't sure. Maybe with xor you need to map to powers of two...
huh? :)
I'd recommend: [MailCatcher](http://mailcatcher.me/) to test if the mail is sent. In addition, you can test the length of your deliveries, which will indicate whether they've sent. Test would look something like this: RSpec and Capybara. scenario 'background mailer sends upon user registration' do mail_sent = ActionMailer::Base.deliveries.length register_user #this is a support method where it is creating a new user expect(page).to have_content 'welcome to the aapp' expect(page).to have_content 'test@email.com' expect(page).to have_content 'Logout' expect(ActionMailer::Base.deliveries.length).to eq (mail_sent + 1) end Edit: In addition, I would use RSpec. It's easy to install and is well documented. This allows you to have a spec/ directory where you would create a *vertretungsplan-mailer_spec.rb* file
I found https://rubymonk.com to be very easy to follow. It's learning by trying yourself. Liked it a lot
I use Sinatra whenever I need a light-weight app. Hand-roll everything Rails does for for you while eliminating 80% of everything you don't want from Rails.
More specifically, the breaking point was when I realized that it's no longer ruby. You see a new task, come up with a nice ruby solution, and then go "How nice would THAT be! Oh well, back to higher-level entities."
I'd highly recommend [Middleman](http://middlemanapp.com/basics/blogging/). middleman-blog is an extension for the Middleman static site generator that adds blog-specific functionality. Deploy your site for free to Heroku. Use NewRelic to ping your site. Pinging your site will keep the [dyno](https://devcenter.heroku.com/articles/dynos) spinning. Thus, preventing slow load times.
The resources mentioned in the comments here are great starting points. I'd say that anything you can get your eyes on and wrap your head around is a good resource. I know how difficult and challenging it is at first, and how daunting it can be, but **stick with it**! The reward of writing code is well worth the learning curve. One resource no one has mentioned is simply the Ruby documentation itself. The Ruby documentation along with IRB is, in my humble opinion, probably one of the best ways to learn. You get to play with Ruby without constantly editing files, saving them, and running them. You get immediate feedback, since each line you write is immediately evaluated. So, open up that good old Ruby doc, fire up IRB, and make yourself a String object: On your command prompt, type: irb. Now, make your string: my_string = "This is an awesome string" Then head on over to the "String" documentation (simple Google search for 'ruby string', 1st result): http://www.ruby-doc.org/core-2.1.3/String.html Now, start messing with your string, man! There are tens of methods that you can call on a String. Try something like: my_string.reverse Pretty awesome, huh? Okay, a little boring and self-evident, I suppose. But keep messing around and you'll start to see the immense amount of power that *you*, as the programmer, hold in your grasp. Now imagine if you knew the most important methods on String by heart, and you also knew them for Fixnum (whole number), Float (decimal number), Array (container of other objects), Hash (key-value store), etc. That's when it really gets fun! The trick is to keep playing around like this, read, read, read, but more so, play, and play alllllll day long. You're gonna catch on real quick. Good luck, please let me know if I can help you further. Feel free to PM me, would be glad to speak with you and help via Skype. Hell, I'd even be happy to let you watch me doing some coding work on a screen share, if you think it might help you :)
I love Sinatra! I've been using it for about 3-4 years. Rails is bloated and annoying (though convenient in some cases, and has much more community support). I usually use Sinatra and extract components of ActiveSupport that I really like. Padrino is nice too, as someone else mentioned. Much lighter-weight than Rails, and you still get a bunch of fancy little helpers. Depends on what I'm working on. Sinatra is going to take more code and more time and effort, but if you're looking for maximum power and flexibility, as well as speed, I'd say Sinatra is one of the best choices out there. But, to answer your question more directly, all you have to do is visit https://github.com/sinatra/sinatra and check the watcher count, star count, and fork count, as well as the latest commit (18 days ago). I'd say it's certainly well-received and popular, probably still today, but it seems to be a little less active than it probably once was.
Computed fields? Surely nothing in D7 core actually does this...
I'm a Ruby newbie (first time posting) and this one looked fun so I decided to take a crack at it. Let me know what you think. The only issue I see is if one team has more players than the other, then there are several players on the other team sitting on the bench until later rounds. They'll still play, but will be more rested than the other players. class MatchUp attr_accessor :team1, :team2 attr_reader :results def initialize(team1=[],team2=[]) @team1=team1 @team2=team2 @results={} end def find_matchups(rounds=1) group1=@team1.length &lt; @team2.length ? @team1 : @team2 group2=@team1==group1 ? @team2 : @team1 group1.shuffle! group2.shuffle! rounds.times do |round| @results["round #{round + 1}"]=group1.zip(group2) group2.rotate!(1) end return @results end end
Thank you, this is awesome advice! I'll use that to redo the whole thing!
Happy to help. You might want to pick up a copy of [Practical Object-Oriented Design in Ruby](http://www.poodr.com/) if you write a lot of code. It's a brilliant book that does a much better job of explaining how to do this.
Without actually testing this, I think that the problem with your code is that your not putting the value back into the array. Instead you are copying a value out of an array and modifying it, but not touching the original value in the array. The map function remedies this by creating a new array from the values returned inside it. So the function inside the map block returns either (i + n) or just (i), based on the result of the ternary statement ( the ? : thing)
It's the ternary operator. It essentially is a shorter version of if/else. it's the same as array.map do |i| if i.is_a?(Integer) i + n else i end end "statement" ? "do if true" : "do if false"
Ahhhhhh that totally makes sense why it didn't work, I just made the following changes and which worked: def only_int(array, n) new_array = [] for i in array if i.is_a?(Integer) i += n end new_array &lt;&lt; i end new_array end thanks for the help! I'll look into researching ternary statements.
Ahh, I was really overthinking things. That makes perfect sense, thanks!
The sequence '?' and ':' is called a ternary operator. It tests the whether the first expression is true or false, and evaluates the expression between the '?' and ':' if it is, and otherwise resorts to the expression after the colon. So basically a one line if..else..end statement. Check here for more details: http://stackoverflow.com/questions/4252936/how-do-i-use-the-conditional-operator-in-ruby
Thanks man! :)
look into Array#each #map #map!, Enumerable. I'd go, depending on whether you want a new array or just modify an existing array. #returns a new modified array def only_int(array, n) array.map { |i| i.is_a?(Integer) ? (i + n) : i } end #modifies passed in array def only_int!(array, n) array.map! { |i| i.is_a?(Integer) ? (i + n) : i } end
+1. Using a `for` loop in Ruby is typically anti-idiomatic. Making use of `#each`, `#map` (or `#collect` - several of the `Enumerable` methods have aliases), and the other `Enumerable` methods will make your code much cleaner and more clearly express what the intent of your code is. Compare def only_int(array, n) new_array = [] for i in array if i.is_a?(Integer) i += n end new_array &lt;&lt; i end new_array end or even def only_int(array, n) new_array = [] for i in array new_array &lt;&lt; (i.is_a?(Integer) ? i + n : i end new_array end to def only_int(array, n) array.map { |i| i.is_a?(Integer) ? (i + n) : i } end Knowing that `#map` returns an array of the return of a block invoked on each element of the array, e.g. `[1, 2, 3].map { |i| i + 1} =&gt; [2, 3, 4]` (though it'd be more idiomatic to write `[1, 2, 3].map(&amp;:next)`), I can easily tell that `#only_int` is going to return an array based on the operation on the argument array's contents.
[Ruby Koans](http://rubykoans.com/) is great!
Chris Pine's site is also my favorite book for a beginner. I even purchased the book after going through the site because I felt he deserved the support. I was not a fan of Learn Ruby the Hard Way though. I went straight to the pickaxe after Chris Pine's book, but that was years ago and some of the other suggestions here that have come around since then may be better. edit: or if you are around age 8 - 12, I just got this book for my 8-year-old and it looks pretty good: http://www.nostarch.com/rubywizardry
You can also use [middleman-deploy](https://github.com/karlfreeman/middleman-deploy) to push to [GitHub Pages](https://pages.github.com/), if you don't mind everything sitting in a public GitHub repo. Then you don't need NewRelic to ping.
&gt; Without actually testing this, I think that the problem with your code is that your not putting the value back into the array. Instead you are copying a value out of an array and modifying it, but not touching the original value in the array. Yes, that's right. Everyone else explained the other points, so here's a little snippet that should show what's happening: irb(main):001:0&gt; array = [1,2,3] =&gt; [1, 2, 3] irb(main):002:0&gt; for i in array irb(main):003:1&gt; i += 10 irb(main):004:1&gt; puts i irb(main):005:1&gt; puts array.inspect irb(main):006:1&gt; end 11 [1, 2, 3] 12 [1, 2, 3] 13 [1, 2, 3] =&gt; [1, 2, 3] The array element `i` is getting modified, but `array` is not. The for loop is essentially giving you a copy of each array element, not a reference to each element.
IRB is also great for when you aren't sure exactly how something is going to turn out. If you can't remember what's getting returned after an Enumerable method, then you can fire up IRB and quickly learn.
+1 for any sort of exercises. I really struggle with a typical book that says "this is how to add two numbers, and this is how you..". You want to start with an exercise that says "add these two numbers" then go and learn how to complete that exercise and move on.
Start here: reddit.com/r/learnpython Ruby blows, learn Python
I have been given two CSS files for English and Arabic. What if I swap out the respective CSS files depending on the query string? Like for instance: www.abc.com?lang=en The value I see in this is this is optional and this is sensible to read.
Any ideas whether it will cause any performance hit to swap CSS files, as it if the language query string is changed will the page momentarily get messed. 
That's cool. Currently doing a course on codecademy. Halfway through so I'll probably get to it sooner or later but it's nice to know in advance.
No comment on the generators thing but for authentication there is Warden, which is what Devise is based on. You can even write apps in Sinatra/Warden that operate seamlessly with a Rails/Devise setup.
Great reply, thanks also for the ones that just occasionally stop by. And taking advantage of the thread, I can tell that for me there's a couple of barriers in learning a new language, I think that this applies not only to ruby but in this case it's the one that I'm also learning: * The good and bad thing is the amount of resources, it's pretty cool that nowadays we have so much stuff and it seems some times hard to choose. But it's on these times that we fallback to those who know like you to recomend. * I see alot of guys to give advice on how to start, but in my case and I believe that with others it also happens, is the path to follow. Some guys try to replicate something that already exists, others to follow online challenges, etc etc. * I was going to write something about the motivation part, but more and more I'm convinced that it's the persistence that counts, but it's soooooo easy to not doing that one exercice, not practicing just one day... :( I find that those days easily turns into weeks and then there I go to the start. * Finding the right thing to practice is important, like a certain problem that you have or a certain field but then the bugs appear, things not working because of small things, and the amount of time lost on doing the simplest things is really tiring... Rambling but just my two cents on these kind of experience, any feedback is really apreciated.
Neither; why not just leave it as request? Then when someone else comes back to the code they won't wonder what the variable represents. Also I believe _&lt;var&gt; is typically used when there already exists in an outer scope &lt;var&gt; but the name &lt;var&gt; works really well for some variable in an inner scope.
I used the codecademy to learn. The best part is, if you are a complete begginer at programming, you will learn same much as the experienced proggramers
I can see why `_request` would be helpful in the future if you have to change the code. Instead of wondering what variable you skipped, you know right away that you can just remove the underscore and have access to the request data.
Ofcourse there is not generator, it does not bind you to any especific structure nor convention like Rails does, there is not "Sinatra way" as "Rails way".
Back when I was doing Lua, _ seemed to be the accepted way of doing it. I've kept doing it since and never really gave it any thought, but given the other replies here it does make sense just to leave a descriptive orphan rather than a complete throwaway. 
_request It signals to people who'll be maintaining the code base that a 'request' variable exists in the block but it is not in use.
You forgot about the bit where you need to be on the CSS3 planning committee and have at least 4 years mobile app experience using Swift. P.S. Photoshop skills a plus!
Because unnecessary variable binding/exposure causes unneeded mental overhead when evaluating a method. 
I personally didn't find it super engaging. I thought the material was too easy and the format kinda sucked (lecture -&gt; quiz). 
Definitely this. This is what I personally do. Easy to see that it's unused but keeping the variable name for potential future use
Yeah, one of the first things I did with Ruby threads is to parallelize an algorithm I had been working on, using MRI 1.9... ran it on 8 threads and was disappointed to get negligible speedup. Looked at my CPU profiles, at any time, only one core was active; it was compute heavy enough that one core would go high for a couple of seconds, then the next, etc. I had heard about Python's GIL and figured that Ruby had one as well; quick google and download and I was running in parallel on JRuby minutes later, getting decent speedup. I'd be interested in learning if there's any interest in removing the GIL from MRI or in hearing more discussion on the differences between MRI and JRuby; besides the ability to use JVM classes and run in parallel, my understanding is that the other difference is that the JVM doesn't support tail recursion optimization so you can run into stack overflow for tail recursive methods operating on larger collections. I think there's a lot of use-cases to real parallelization and I would prefer not having to choose between tail recursion and parallelization for some applications.
What problem would `_request` solve that isn't already solved by `_`? Either you care enough to use a name for a value, or you don't. If you don't want to use a variable inside a block, it's nice to signal this non-use by using `_`.
I found codeschool to be better for making you think critically on issues, but treehouse is pretty good about thoroughly explaining what is going on behind the scenes. I recommend people try both.
I'm currently using it with iOS programming. The material is "easy", i.e. targeted more for newbies and it is slower to get through vs something like http://railscasts.com/ I was initially just going through all the misc blog post tutorials, etc. for Swift and then started treehouse. I like that it starts from the beginning and touches on many little details in xcode, rather than having to stumble around misc blog tutorials and wait for Swift books to be released. I'm getting value out of it as it is jumpstarting me in a new ecosystem that is very different from the ruby/rails world. You can probably get through all you need within the free trial period. I'll probably keep it for a couple months and casually go through Android and Python even though I don't need them right now. Haven't tried codeschool. Probably do that next. In the past I've always learned languages from books and blog posts, but I have to admit that I like this dumbed down intro with well polished videos. I can be a bit lazier and coding is all about laziness.
I use `*` i.e `do |source, *|` EDIT: why the downvotes?
Definitely an improvement. :-) Did you end up writing specs?
I haven't quite figured out how to do that yet. I guess I would have to create a second file, call it something_spec.rb and require my class and put the methods under test. Is that still possible though? Currently only 1 method is public. Edit: How would I stub out `Premailer`?
Using `_` is generally accepted, preferred by me personally, and implemented in ruby.
I've been using this one for a side project for the last 2 years: https://github.com/sosedoff/capistrano-unicorn Works as advertised, variety of Ruby versions, never any problems.
Yes, that's right. Make a file (it doesn't need to be `something_spec.rb`, any `.rb` file is fine, you can just run `bundle exec rspec my_file.rb`) require your class, go from there. Try [this](https://gist.github.com/subvertallchris/3cdbb0ba201002890d25), it or something like it should get you started. You'll also want to stub out `Premailer.new` and Nokogiri's opening of the timetable URL unless you want to be sure that those URLs are valid. A better test would also verify that the mail that is sent matches what you expect it to look like. You don't want to concern yourself with *how* it happens, you want to test what it does and what it returns.
This is in response to http://www.reddit.com/r/ruby/comments/2ipfy5/ruby_keyword_arguments_improve_your_code/. I didn't want to just link in the comments because it would be too easy for someone to have read the original but not see the rebuttal. There are so many posts in this subreddit from people looking for getting started advice and while the original blog does a good job of demonstrating a cool Ruby feature, it doesn't offer advice that everyone needs: always consider the cost of an implementation. Even if you disagree with my conclusion, especially the OOP part of it, you need to consider cost. "Cost" is more than just execution speed, it also includes the time spent (or not spent) updating code throughout a project when you make changes. Keyword arguments are more expensive than standard method arguments.
The dependency argument is bunk, the performance argument is compelling. I'll switch back to using positional arguments aside from public interfaces. Keyword arguments have one source of change that positional arguments don't; the author of the object may want to change the names of the keywords. However, the author is free to rearrange the order of those arguments without forcing you to change how you're calling the method. With positional arguments, you break everyone when you swap order. So both approaches have a "dependency" that the other doesn't. And even aside from that, calling this a "dependency" is a stretch. You can't use a method without understanding the method signature. Period.
Yeah, it's a stretch to call it a dependency, but I think that the question, "How will code that calls this method need to change if I change the method itself?" is always worth considering. The original post didn't address this at all. It was just, "look at how much easier it is to read," but there's more to consider than that. I find myself wanting to change the order of arguments infrequently but wanting to change their names all the time; to me, having code bound to method names is far worse. I guess that's a matter of taste. I edited the post to be more careful with the word "dependency," since it feels like a sure way to start arguments about semantics.
Oh I totally agree. Thought you were arguing in the opposite direction, sorry. 
&gt; def cool_method(magic_number, magic_type) puts magic_number puts magic_type # it does something awesome end def cool_caller cool_method(magic_number = 666, magic_type = :black) end What happens if you change `cool_method` to def cool_method(magic_type, magic_number) ? 
You either have to flip the positions of each variable within that method (essentially rendering the names meaningless) or flip the order of the arguments of all dependent code or you'd wind up with some broken specs. The only benefit to declaring variables when calling the method is that you get a little note of what they mean if you glance at `cool_caller` and don't want to dig up `cool_method`. In practice, it'd probably end up looking like this: def cool_caller # some code magic_number = # the result of something that happened in your method magic_type = # something else that happened in the method cool_method(magic_number, magic_type) end In which case, with keyword arguments, you'd end up with `cool_method(magic_number: magic_number, magic_type: magic_type)`.
I know this isn't quite your question since worst appears to have answered it, but a pattern I've seen and is quite nice is to define pad in terms of dup and pad!. IE def pad(n, v) dup.pad! n, v end def pad!(n, v) self.concat(Array.new(n, v)) end
Exactly this. More people using, extending and contributing to Ruby can only be a boon for the language.
Glad to help!
Yes, IRB is ballin' for all sorts of Ruby mastery. I totally ignored IRB for the first two or so years of my Ruby journey. When I started using it, it was like the rocket launched. Exponentially, I learned so much more, day by day, and that continues to this day!
I'd personally say don't pay for anything. Seems ridiculous when there is a tutorial, or documentation, or at the very worst, the code of the thing you're learning. I think so much more about learning a language, especially Ruby, is learning all the libraries on top of it. Learning the language will come as a result of that. Of course that's not to say you should dive into the Rails codebase with little to no idea of what an Array is for or how Ruby works on a basic level, but with just a couple books under your belt, and maybe a few tutorials and a couple small pet projects, there is nothing stopping you. The rest will come naturally, much like learning a spoken language.
The guy you're replying to isn't the same as the guy you replied to. The guy who replied to you also didn't read the post of the guy you were originally replying to.
No 'request' doesn't convey the maximum information. It says "here's a variable called request". Meanwhile '_request' says "here's a variable called 'request' that I'm not using.
I thinks less about order, and more about deciding which args to omit. If you want to skip the first arg but not the second in a non-keyword method, you're out of luck. So, are people using keyword arguments for every method? I can't say I've seen them that much. But then I tend not to read many Ruby projects.
Lol I love this "lame basic program". I'd love to see the code for the method 'code'.
Hey, I just posted a comment on your blog (stop paying for Minecraft hosting!) Get in touch with me if you're interested and I'll figure out what all I did. Otherwise I'm curious if nanoc supports commenting out-of-the-box. Noticed you have that setup, but I don't want to have to take the time to get it all working correctly myself. No time for that. Anyway, Jekyll is awesome but I wanted commenting. Thanks!
Like the tires I built for my car, which I built out of glass and metal, that I forged myself, and with an electrical system I designed myself, using wires that I meticulously constructed myself? Seriously, I hate Sociology (well, I hated the class, anyway), but you should really take a look at an introductory Sociology class, man.
Jekyll is cool, just played with it quite a bit, but it lacks commenting, and I don't have time to extend its functionality. :( Still though if you just want a super-simple and (bonus points) static blog, this is your thang.
I appreciate the response and especially the benchmark on the methods. If you went about this post in a less asshole-ish tone (no offense...), I think it would have been a lot better received. For example, the title alone is oddly combative and holier-than-thou for such a friendly topic. &gt;No, You Should Not Use Keyword Arguments for Every Method Why not &gt; Drawbacks to Keyword Arguments As another poster pointed out, there's dependency issues either way, and there's people who don't need to worry about the speed of their app. Why not present your side and let someone decide for themselves what's best for them? It's also ironic that you're tearing down his argument for recommending it in all situations, then at the end you declare your method "Better code", essentially doing the same thing as if there's never a situation where someone could prefer improved readability and non-order parameter dependence. 
Maaaaybe the title was a bit more aggressive than it needed to be, but my intention was to encourage a discussion and... Surprise! Here's a discussion. The system works! We now have a discussion where before, we only had a link and some upvotes. But if you or Luis, the other of the original post, or anybody thought I was unnecessarily rude or combative while making my point, I very honestly apologize. My goal was to make a point, provide a rebuttal to something that seemed like bad advice, and encourage thought and debate. For what it's worth, I don't think anything is THE BEST in absolute terms, I just have strong feelings about what I prefer and why.
There's this: http://www.reddit.com/r/ruby/comments/2h34uk/a_tldr_summary_of_eliminating_gil_in_ruby_through/
[Relevant Blog Post](http://www.jstorimer.com/blogs/workingwithcode/8085491-nobody-understands-the-gil) IIRC neither implementations support TCO. There's no mentioning of TCO in the MRI implementation (unless they added that in a patch I missed) and it's not in the JVM implementation. 
Name collisions for unused variables? Tell me more.
This
The [Parallel gem](https://github.com/grosser/parallel) has a nice interface for true parallel processing. It's quite close to Python's `multiprocessing` module.
interesting, never seen that in the wild, though
"_request" form is quite uncommon, so many readers of your code would wonder, what did author really mean. "_" already treated by ruby parser differently, you can have this as a hint it's the official way to go for very short blocks. "request" is fine, too for anything more complex or anticipating to be complex in future.
ah, looks like parser treats any _var a little bit differently, than var. you won't get "SyntaxError: ... duplicated argument name" for |_var, _var|, for example. Interesting.
Reply part 2: I toned down the title and edited it just a tiny bit to maybe come off as less of a dick, cause you have a point. I still call my alternative "better code" because as far as I'm concerned, faster + easier to maintain = better. If someone has different standards, they're free to think I'm wrong. EDIT: I changed back to the original title. It may not be diplomatic but I can't think of any justification for saying you "probably" shouldn't use keyword arguments for every method. You shouldn't.
EDIT: This post originally contained something written at 5AM that was not coherent.
AFAIK there was some extensive work done to support tail recursion optimisations in OpenJDK, but for some reason it has never made it into the mainline. It's not just JRuby that would benefit from it, also Clojure, etc.
Uh, you didn't skip the arg. You've clearly passed in nil there.
Minor note: I would consider naming your `size` argument `pad_size` instead, as you apparently did in your tests. `Array#size` is already a method, and while your use of `size` will work, it could be a little confusing to read later. My solution was essentially the same as the one posted by /u/smix. class Array def pad!(pad_size, value=nil) return self unless (extra = pad_size - length) &gt; 0 concat(Array.new(extra, value)) end def pad(pad_size, value=nil) dup.pad!(pad_size, value) end end Edit: I just realized that `pad_size` in your tests is a different quantity. Oh, well. My only point was that it can be helpful to not reuse existing instance method names.
/r/ProgrammerHumor 
That plugin works for capistrano 2 only. [capistrano-plugins](https://github.com/capistrano-plugins) are for capistrano 3.
Woah. No, I did not. Sorry, it was 5 AM and I somehow saw "skip" and went to "skip assigning a value for."
Using _request would allow it to be overridden by a variable of the same name. Ruby will allow `Proc.new do |source, _request, _request|` (and _request would have the value of the last parameter named _request) but would raise an error on `Proc.new do |source, request, request|`. This example would likely not have an issue, but if you aren't going to use a variable, you shouldn't give it a name that may or may not end up reflecting its value.
How do you build tires out of glass and metal? And what does sociology have to do car construction or software development?
Testing just now, it's not an actual syntax error in either Ruby or JS, but it has confused tools for me in the past.
A great application of that gem is another project, also by Michael Grosser, parallel_tests: https://github.com/grosser/parallel_tests If you have a Rails test suite that takes more than 5 minutes or so this gem is worth a try. If your suite takes less time it's probably more overhead / hassle than you need.
[This post](http://robots.thoughtbot.com/ruby-2-keyword-arguments) offers a good argument in favor of keyword arguments over hashes. It doesn't address the performance issues, so that's a call for you to make in your app. I still don't think the cost is worth it.
&gt; just want to say that after you get used to ruby and it's rich core classes java.util.* is part of the core class library in java. &gt; Java seems like a stone age again. Because of imports? You need to do the same thing in ruby and python; you just don't need to for the core like you do in java. Just because you don't have to do the import by hand doesn't mean you don't need to know the API still; ruby and python don't just magically work without knowing it. &gt; And you may never feel this unless you get this experience of having to re-learn one of your "old" languages. Ugh. Java is not old or outdated simply because of imports. There are a billion reasons to rail on java, and while imports are a PITA, they're hardly the best of reasons. &gt; Long story short: do a little ruby and you get a serious WTF moment when you realize that you don't have Array.sort readily available for you whenever, whereever, however. I don't get it. The method in Java is literally in Arrays.sort (or Collections.sort), just because the entire classpath isn't loaded into memory on start up (which would be a bad thing) or dynamically searched (which would be a slow thing) doesn't mean it doesn't exist or isn't convenient. I'm very sorry, but your entire argument sounds very sophomoric. Having to tell the compiler you're going to use a class is a pain, but hardly a reason to have an epiphany or WTF moment.
This has nothing to do with "how good" a language is. 
IMO what's really the problem is that Arrays.sort doesn't provide an object oriented way to manipulate an array nor is an obvious place to look for the functionality.
If you enjoy Ruby because you don't have to understand how languages and compilers work in order to use it then you should probably say so, because the subtext is very obvious.
I don't really understand this rant. It gives no good reasons for why ruby is excellent. It sounds like you're a fairly junior programmer who looked at Java for 5 minutes, saw that it wasn't ruby, and went to reddit to moan about how crap Java is.
&gt; I don't get it. The method in Java is literally in Arrays.sort (or Collections.sort), just because the entire classpath isn't loaded into memory on start up (which would be a bad thing) or dynamically searched (which would be a slow thing) doesn't mean it doesn't exist or isn't convenient. I'm not sure if this is what the OP meant, but something I love about ruby is that the array methods are callable on instances of the array. Something like; array = [4, 2, 7] array.sort whereas in java (last time I checked) sort is a static member of Array. So it's more like int[] array = {4, 2, 7}; Arrays.sort( array ); Is it a small thing? Yep. But small things can add up :) It tends to map really well to how people think - it reads more like english.
I am "ruby-newbie" and here is my solution: def anagram_solver(x,y) x = x.downcase.split(//) x.delete(" ") if x.include?(" ") y = y.downcase.split(//) y.delete(" ") if y.include?(" ") x.sort == y.sort end puts anagram_solver("Rosewood","Doctor Who") puts anagram_solver("Torchwood", "Doctor Who") 
I work on a code base that is hundreds of thousands of lines and I don't think we use a single array, other than for the main method which must take an array as an argument. Arrays in Java are just bad. If you want a sorted iterable, use a TreeSet. 
I think that given the complexity of the idea, your code is more than acceptable. Perhaps better semantics improve the code more than idioms and functional tricks. def apply_defaults givens, defaults, wildcard = '*' givens.merge defaults do |_key, given, default| if given.is_a? Hash apply_defaults given, default else given == wildcard ? default : given end end end Alternatively, you could monkey patch in a recursive_merge that would allow you to write something like given_hash.recursive_merge default_hash do |_key, given_value, default_value| given_value == '*' ? default_value : given_value end Of course, monkey patching isn't always great depending on the context, but I like the idea more and more as I wrap up. You've got two ideas--the funky merge and the notion of wildcards--so you might want two functions.
&gt; Perhaps better semantics improve the code more than idioms and functional tricks. This is a great point and I'll most likely borrow inspiration from your first example. Thanks for the feedback! *edit I've been thinking about your last point (You've got two ideas...) and I'm pretty sure this is the sort of _complection_ [transducers](https://github.com/cognitect-labs/transducers-ruby) aim to address.
I couldn't agree more with you. Arrays aren't great in java, especially from an API view. Also there is a SortedSet in ruby, if you want TreeSet Behavior. 
Perhaps I'm overthinking it, as you obviously need to come up with some sort of simple example for such a blog post (and that can be deceptively hard), but are either functions really better than the OO approach? class Totaler attr_accessor :tax, :discount def initialize tax, discount @tax = tax @discount = discount end def total subtotal subtotal + tax - discount end end Of course, you still have the initialize method that has two ambiguous parameters, but now that you're only passing the tax and discount (or the tax and discount providers) once, you can now even have the luxury of readability and performance. def initialize tax:, discount: @tax = tax @discount = discount end
I'd say the experience the OP describes is more akin to going back to manual memory management when you've used a language with a garbage collector. And your response is like saying "but you're meant to manually manage memory - that's how languages work!". There are tradeoffs with every language feature; the poster is trying to describe something that you don't seem to understand (probably due to the complete lack of clear examples), and you seem to be shutting them down rather than just asking what they mean. But then again, I'm not completely clear on what they mean either.
That's a really good idea!
I think the code is fine, in terms of what you're trying to achieve there aren't really a lot of variations on doing this - pretty much the only changes you might want to think about making are firstly to extract those strings out using the i18n features, and secondly if it was me, I would put this sort of code in some kind of "presenter" class, rather than a "helper".
Another easy sort in Java: List&lt;Integer&gt; array = Arrays.asList(4, 2, 7); array.sort(Integer::compare);
self
Yes, it's a part of the Object class -- doing `def woof` adds it as a private instance methods of Object. http://www.sitepoint.com/rubys-top-self-object/
In the top level context? It's an instance of `main`
Why would wildcards get replaced with defaults?
I'd almost be tempted to set the default proc to be a lookup and then decorate those wildcards away.
why? it's a valid syntax. And it could be more efficient too, I'm too lazy to check.
"You can just hardcore the list of states:"
I'm trying to think of how I would go about defining this presenter class. I'm still thinking in terms of MVC I guess so thinking of an arbitrary class is a bit of an abstract concept for me. Any pointers? (I apologise for buggering up any terminology)
Many people use Nginx or Apache to take all incoming HTTP/HTTPS requests to port 80 and use internal configuration to send it to VirtualHosts, such as yours on port 3000. If you read this it gives advice as to why this can help: http://en.wikipedia.org/wiki/Reverse_proxy As Padrino is based on Sinatra you could take a look at this (http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_Ruby_sinatra.html). I imagine the deploy steps are very similar.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Reverse proxy**](https://en.wikipedia.org/wiki/Reverse%20proxy): [](#sfw) --- &gt;In [computer networks](https://en.wikipedia.org/wiki/Computer_network), a __reverse proxy__ is a type of [proxy server](https://en.wikipedia.org/wiki/Proxy_server) that retrieves resources on behalf of a [client](https://en.wikipedia.org/wiki/Client_(computing\)) from one or more [servers](https://en.wikipedia.org/wiki/Server_(computing\)). These resources are then returned to the client as though they originated from the server itself (or servers themselves). While a [forward proxy](https://en.wikipedia.org/wiki/Proxy_server#Forward_proxies) acts as an intermediary for its (usually nearby) associated clients and returns to them resources accessible on the Internet, a reverse proxy acts as an intermediary for its (usually nearby) associated servers and only returns resources provided by those associated servers. &gt;==== &gt;[**Image**](https://i.imgur.com/mue5Gd1.png) [^(i)](https://commons.wikimedia.org/wiki/File:Reverse_proxy_h2g2bob.svg) - *A reverse proxy taking requests from the Internet and forwarding them to servers in an internal network. Those making requests to the proxy may not be aware of the internal network.* --- ^Interesting: [^Proxy ^server](https://en.wikipedia.org/wiki/Proxy_server) ^| [^DMZ ^\(computing)](https://en.wikipedia.org/wiki/DMZ_\(computing\)) ^| [^Pound ^\(networking)](https://en.wikipedia.org/wiki/Pound_\(networking\)) ^| [^Nginx](https://en.wikipedia.org/wiki/Nginx) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cl79cwp) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cl79cwp)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Alright here's a crash course: The code you've written could go in a number of places - you could whack it in the model, but this is perhaps the worst place to put it because it's presentation logic (so shouldn't be anywhere near the model). You could put it in the helpers too, as you've suggested here, but the problem with the default helpers is that they're un-scoped so if you wanted a "stock" method for another type of product (other than books) then you'd have to re-name your method. The other reason I hate helper methods is that you are pretty much required to do a grep to find out where the hell they were defined! The "presenter" pattern is a more appropriate way of dealing with this sort of thing. In a nutshell, you create a new object that acts as a wrapper for your model. You put all presentation logic in there. Like this: class BookPresenter def initialize(book) @book = book end def stock if book.stock &gt; 5 "In Stock" elsif book.stock &gt; 0 "Few copies remain" else "Out of Stock" end end end Then in your controller; def show @book = book @book_presenter = BookPresenter.new(@book) end And finally, in your view: &lt;%= @book.name %&gt; &lt;%= @book_presenter.stock %&gt; The issues you've solved here are: * You have a "place" for presentation type logic * It is obvious where to look for the @book_presenter I usually put these under app/presenters. There is a gem out there called "draper" that implements this pattern (although it calls them "decorators" rather than "presenters", because they "tack things on" to the existing model rather than creating a new one like I have) https://github.com/drapergem/draper And grand overlord Bates did a railscast on that gem: http://railscasts.com/episodes/286-draper Happy coding!
I thought "in the wild" was a pun for wildcard
Fair point, but in this case i assume he's destructuring an array so he needs to pass a second arg. e.g If he just used one arg: proc { |a| a }.call([1, 2]) #=&gt; [1, 2] But if he uses a second arg (or *) proc { |a, *| a }.call([1, 2]) #=&gt; 1 In fact you don't even need the `*`: proc { |a, | a }.call([1, 2]) #=&gt; 1 
You don't actually need to name it anything, you can just leave the arg out: proc { |source| } 
Yes. https://github.com/neocities/neocities
Extending base objects is intensely debated. For ideas, Google "monkey patch" and "method extensions". IMHO add your method to Hash, rather than putting your method somewhere else, because your method is quite similar to an existing method. IMHO it is good to have your method in the same OOP namespace. Your method does not affect Hash internals nor any other method. Your method can be broadly useful. I do like a method extension to be in its own file for organization and so I can quickly see it's an extension, such as `./lib/extensions/hash/merge_using_wildcard.rb`. If you want to be really friendly, also wrap your code in its own module; then you can include the module only when you need it.
Thank you so much, Metal Mikey! Your explanation was perfect and draper looks interesting. I like it when I learn something that makes the old way look… wrong. I think this might be one of those things, so thanks.
Not bad. I can't help with the compression, but you might consider using Bundler to create a gem skeleton to make your code into a more conventional Ruby library (i.e. a gem). http://bundler.io/v1.7/bundle_gem.html
You say that a compression rate of 74% isn't very good. Have you compared it with other software?
Yeah, for example, the built in compression of a mac turns the 25K file to 10k zipped. That compares to my ruby code which results in a 16K compressed file.
If you want advice on compression algorithms, you might be in the wrong subreddit.. 
If you're looking to explicitly improve your compression ratio, assuming you've implemented the algorithm correctly (which you can verify by hand), the only way to do so is to apply transforms that optimize for that particular compression algorithm. Try combining optimized transformations with your compression algorithm. You can try running a Huffman code first, and then applying LZW. Also a better metric for comparison would be to try compressing more than just one single input. Give it a bunch of different text files all around the same size and see what kinds of compression ratios you're getting. With a single test run, it's impossible to tell if their compression algorithm is better in the average case or just better in this particular one since both use different algorithms.
You can confirm this in the console: 2.1.1 :011 &gt; def foo 2.1.1 :012?&gt; puts "I'm an instance of #{ self }" 2.1.1 :013?&gt; end =&gt; :foo 2.1.1 :014 &gt; Object.send(:foo) I'm an instance of Object =&gt; nil 
`self` for the top level (called `main`) is an instance of the class Object. `def` on the top level defines methods on the class Object. When you define a method on the top level, it gets defined on the Object class as a private method. For simplicity, you can think of your program file as being the "..." in this snippet. class Object private ... end
My first impression after downloading the code and running it myself wasn't the compression ratio but the speed. Additionally, I wanted to try a larger text file in order to see if it would provide better results. When I did, it never finished. Hmmm... So now I'm thinking that your implementation is super-linear time, and I started to look for the cause. It took me a long time (too long) to realize that "dictionary" wasn't actually a dictionary but an array and your call to Array#index made your compress method O(n^(2)) instead of O(n). Here's my rewrite: def compress(to_compress) # populate the dictionary with all 256 ASCII codes dict = Hash.new 256.times { |ascii_code| dict[ascii_code.chr] = ascii_code } s = to_compress[0] to_compress.each_char.reduce [] do |output, c| if dict.include?(s + c) s = s + c else output &lt;&lt; dict[s] # the dictionary's size is the next index dict[s + c] = dict.size s = c end; output end end Now, it compresses War and Peace by 68% in just a little more time than it originally took to compress the smaller file.
Yeah, try Richard Hendriks or r/piedpiper?
I'm not sure why you were downvoted - this is entirely true. Compression algorithms are a pretty hardcore area of math/comp sci, and it's pretty unlikely that anyone in a random *ruby programming* community (as opposed to a specialist "compression algorithms" or "advanced comp sci theory" subreddit) is going to be able to improve on LZW off the top of their own head.
Asides from code optimizations, you might as well try a different approach, i.e. arithmetic coding
&gt; because they are trading one dependency for another: instead of having to know the order of arguments, you have to know the names. Right. To me, this seems exactly equivalent as far as how much the caller needs to know, name for position, neither is obviously better or worse -- the named variant is arguably more self-documenting in context. It also allows for more flexibility in optional arguments. In some languages, like ObjectiveC, almost all the arguments are named, as the convention/idiom of the language. That has not been the idiom in ruby, which is perhaps a reason not to prefer it, but on the other hand there is lack of consensus in idioms in many many areas of ruby, and language changes (like the new keyword syntax) will inevitably change idioms. 
IMO the main takeaway on MRI threads, is that they will work well for I/O heavy work (as the thread waiting on IO can and will be efficiently switched out and another switched in), but not so well for CPU-heavy work (as there is not true parallelism). I think every article on threads in MRI should mention this. If a significant percentage of the wall time is spent waiting on the db, that counts as IO-heavy work. This will be true of many web apps. 
[Enumerable#reduce](http://ruby-doc.org/core-2.1.3/Enumerable.html#method-i-reduce) is a nice little pattern that keeps you from initializing and using accumulator variables outside of their contexts. For example... def array_sum array sum = 0 array.each do |n| sum += n end sum end becomes... def array_sum array array.reduce 0 do |sum, n| sum + n end end I would recommend reading the documentation, though.
[Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform) + Huffman coding does really well on text files. (Compare bzip2 to gzip.) Alternatively, [LZMA](http://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm) will tend to beat LZW on text. Performance of a Ruby version will probably be problematic, though, as the C versions are already slow enough.
I've considered it for a lot of projects, but most things end up needing Rails features. It seems like I would only use it for really tiny projects that don't need an admin, mailers, a bunch of different tables, cache, etc.
I don't think so. 
Is it controversial. It is sometimes done, but I agree with you that it's poor form, unless you can articulate a really good reason for it. I don't think making the implementation of one single method slightly more concise is a good reason. If it was going to be used all over the place, and especially if it was going to be used by clients of _your_ code too (not just internally).... then maybe. I still would resist. 
Fair enough. Personally, wiring up basic sign up/login/profile views on top of warden isn't that much more work than customizing the default Devise stuff. Not to take away from Devise, because it's awesome.
The whole path? Just the id? What is your routing like? Also, it might help adding that you are asking about rails.
Take a look at [Rack::Request](http://rubydoc.org/gems/rack/Rack/Request) which is exposed as `request`.
Maybe a little OT but have you considered packaging everything into a gem? There's a bunch of tools that can help you bootstrap a library if that's what you're doing. I personally use ore/mine [1] : psyomn@aeolus ~ $ mine awsmprojct Generating /home/psyomn/awsmprojct create lib create lib/awsmprojct create spec create .gitignore create .rspec create spec/awsmprojct_spec.rb create spec/spec_helper.rb create .document create awsmprojct.gemspec create ChangeLog.rdoc create LICENSE.txt create README.rdoc create Rakefile create lib/awsmprojct/version.rb create lib/awsmprojct.rb run git init from "." run git add . from "." run git commit -m "Initial commit." from "." So that could setup your overall directory structure + configure your testing environment (notice the spec files) + provide you with a bunch of handy rake tasks. Of course you could do everything by hand. But these tools; much pretty. So when you're done writing your library you can simply include the gem in your next project. Hope this is not too OT! Good luck! [1] http://postmodern.github.io/2012/05/20/you-dont-have-to-use-bundler-to-create-new-rubygems.html
What does response.body return?
The performance of an encoding algorithm isn't as important as its ability to encode and decode at roughly the same time complexity. It should be no harder to encode than it is to decode. I believe there's a term for an encoding that is harder to decode than it is to encode but I can't recall what it is.
Is this in a Rails app? Can you point us to the rubydocs that you say suggested what you are trying to do? We need a bit more context here. In a Rails app, it is about your routing configuration, which you have not shown. The routes file is what determines how the URL path is mapped to your params hash. 
Make sure you have it defined in *routes.rb* like this: get 'jobs/detail/:id' 
try this and post the result: puts response.code puts response.body
This is the best TL;DR on ruby threads.
Thank you for this link! Ore seems like a good idea, I like automation! 
Is the site using http basic auth?
I haven't touched Java for a few years. I tried to program in Java last weekend at a hackathon for some Android development, and it was then that I realized how happy programming in Ruby makes me. OP may not have explained it well, but I can identify with feeling frustrated when temporarily moving back to a language that you don't enjoy using (for whatever reasons).
The params hash doesn't get populated on it's own. You need to set the route in your routes.rb file for that to work. The routes.rb file is where you tell Rails "Hey, you know that url you got? It looks like '[http://www.mywebsite.com/user/1](http://www.google.com)' ? Well, I want you to take the params hash and have the :id key point to the number on the end." And that would be with the following code: get 'user/:id' [Read up on routing for your answer.](http://guides.rubyonrails.org/routing.html)
I don't know why you're getting downvoted, as this is the most correct answer, and it *truly* answers the correct question, which is "where am I when I'm not inside a class or a module?".
&gt; It should be no harder to encode than it is to decode. You mean the other way around surely? You don't want it to be harder to decode the data than it was to encode it. And I don't buy that both should be roughly the same time complexity. Back in the days of Infocom text adventures, the text compression took a hellish long time to complete, but was really quick to decode -- and that was perfect for the problem domain. Similarly, MP3 is much slower to encode (at max quality) than to decode. Which is fine, because you only encode a file once but you decode it maybe millions of times.
Go to github and search away.. look at gems, look at the ruby source itself
{}
How do you tell? It doesn't show the site at all. You get a window that pops up before the site saying 'Authentication Required: server https://imawebsite:433 requires username and password. The server says:web. 
Not sure what exactly is happening, but when I run into weird web issues I use [Advanced Rest Client](https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo?utm_source=chrome-ntp-icon) for Chrome to troubleshoot. It has a lot of nice knobs to play with so you can figure out what the issue is. edit: you also may want to check out the rest-client gem. Its nice to just use the http library to understand how the whole process works, but rest-client is going to end up being a much cleaner solution (your whole block there will be 2 or 3 lines of code)
This is basic auth. Basic auth can be included in the URL like this: https://user:pass@api.mysite.com/
Sidebar is thatta way -&gt; --- But Sinatra is an okay starting point: https://github.com/sinatra/sinatra I'd also suggest [Metaprogramming Ruby](http://www.amazon.com/gp/product/1934356476/ref=as_li_tf_tl?ie=UTF8&amp;tag=redditrrubyco-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1934356476).
wow I am retarded. Forgot to put ""'s around my strings in the bracket nm!
Also check out Gregory Brown's books and columns 
I'm not OP but I am also a beginner and there is no gem that I use daily. How do I find out what are the most popular ones?
[These](https://rubygems.org/search?page=1&amp;query=&amp;utf8=✓) seem to be roughly sorted by popularity.
Thanks!
not an error in code academy... you're doing it wrong. keep trying.
I find that the Redis gem is quite good for learning properly structured libraries, since it's relatively lightweight. Also, as a bonus, you can check out hiredis-rb, which is a good example of how to build C extensions for Ruby. Neat!
My experience when first learning to code (and even now when learning something new) is very similar to when I learned how to golf. Try something. ERROR! I hate programming! Try something. ERROR! I hate programming! Try something. ERROR! I hate programming! Try something. It WORKS! I LOVE PROGRAMMING Keep at it. You'll be able to create awesome software that does *exactly* what you want it to do. 
Learn programming from open source? LOLWUT?
anything that whytheluckystiff left behind is great 
Newbie here. Can confirm. Although, I think I just recently passed that stage because instead of deciding whether or not to keep trying, my mindset is now just *how* can I fix the problem, not *should* I even try.
Make sure to take a look at some of the options: psyomn@aeolus ~ $ mine --help Usage: mine PATH Options: [--rubygems-tasks], [--no-rubygems-tasks] # Default: true [--rspec], [--no-rspec] # Default: true [--bundler], [--no-bundler] [--bundler-tasks], [--no-bundler-tasks] [--hg], [--no-hg] [--rdoc], [--no-rdoc] # Default: true [--bin], [--no-bin] [--git], [--no-git] # Default: true [--gem-package-task], [--no-gem-package-task] [--gemspec], [--no-gemspec] # Default: true [--test-unit], [--no-test-unit] [--mini-test], [--no-mini-test] [--yard], [--no-yard] [--gemspec-yml], [--no-gemspec-yml] [--markdown], [--no-markdown] [--textile], [--no-textile] -T, [--templates=TEMPLATE [...]] -n, [--name=NAME] -V, [--version=VERSION] # Default: 0.1.0 -s, [--summary=SUMMARY] # Default: TODO: Summary -D, [--description=DESCRIPTION] # Default: TODO: Description -a, [--authors=NAME [...]] -e, [--email=EMAIL] -U, [--homepage=HOMEPAGE] -B, [--bug-tracker=BUG_TRACKER] -L, [--license=LICENSE] # Default: MIT So you are not bound to use rspec if you don't want to (notice minitest etc). 
Disclaimer: this is something I'm working on. I think it's not too big to get you confused, and not too small to actually help you learn some ruby. NB: _I THINK_. If you feel like it, take a look here: &gt; [https://github.com/psyomn/wlog](https://github.com/psyomn/wlog)
Try running it without setting the result = 1. The first time through the loop, you'll get an error as it tries to multiply nil*base
If you don't first initialize result, you won't be able to multiply it by base a few lines below. If your question was about the "1" : initializing a var to 1 for a loop/recur multiplication structure using this var is similar to intializing a var to 0 when you have a loop/recur addition structure : that's the starter, neutral value upon which you build the results.
setting result = 0 makes this clear too
Also a good idea is to peek into the standard library of ruby (which is a gem you use often, even though it's not a literal gem) and it gives insights of how the ruby makers think ruby should look like. https://github.com/ruby/ruby/tree/trunk/lib It's not the easiest thing to start with but every semi-ruby-dev should have looked into this folder once. And the good thing is: there is more documentation than code!
You have to define result before using it in the loop - otherwise Ruby doesn't know where to start when calculating `result = result * base`
If you're interested in system scripting, the ssh gem is perfect for learning some system methods and networking methods. If you're interested in a typical Rails app, the TodoMVC-Rails-jQuery app is very helpful, and also easy to compare to other frameworks. 
This one did it for me. https://github.com/JoshCheek/ruby-kickstart
How has motivation changed since you started using it? My understanding is that rewards ultimately de-motivate complex / intellectual tasks. 
A tried and true method to understand something is to change it and see how it affects the computation. In this case try changing result to 0 and see what happens. You can also trace the computation by hand to understand what is going on because in this case it is pretty simple. Here are the values of i, and result as we go through the loop a few times: i -&gt; 1, result = result * base -&gt; 1 * base; i -&gt; 2, result = result * base -&gt; 1 * base * base; i -&gt; 3, result = result * base -&gt; 1 * base * base * base; ... I hope you see the pattern and why result needs to be 1 because at the end of the day result is just going to be 1 * base * base * base ... * base. Incidentally you can set result to base instead of 1 and it would still work but you would need to change the loop termination condition from i &lt;= exponent to i &lt; exponent.
Split returns an Array of Strings. What is the downcase of an Array? You could create a new create a new array of downcased strings... but that would be slow and wasteful... eg. sentence.split.collect{|s| s.downcase}
Because: there is no Array#downcase method. * http://ruby-doc.org/core-2.1.2/String.html#method-i-split * http://ruby-doc.org/core-2.1.2/String.html#method-i-downcase String#split returns an Array of Strings. String#downcase returns a String. To #downcase each String in an Array, read up on #map: * http://www.ruby-doc.org/core-2.1.2/Array.html#method-i-map * http://www.ruby-doc.org/core-2.1.2/Symbol.html#method-i-to_proc 
Others have answered why result needs to be initialized. If you want to know why result is initialized to 1 specifically, take a look at the condition for the while loop: i = 1 while i &lt;= exponent #... end i is being set to 1 and the while loop body only executes if i &lt;= exponent. Since i is 1, the while loop body only executes if exponent is 1 or greater. What happens when exponent is 0? The body of the loop won't execute which means result will be nil if it isn't initialized to 1 earlier. Why 1? Because anything raised to the 0th power is 1. Incidentally this exposes a weakness of this method - it can't handle negative exponents.
the [ruby toolbox](https://www.ruby-toolbox.com/) is helpful to see the most popular/active/mature gems listed by category
Holy fuck. I am too drunk for this. 
I've had a couple of beers, but moved on to the bottle of wine my wife was cooking dinner with. What are you drinking?
I'm a big fan of bourbon in particular, Old Weller 107 is my current favorite. JD gets a pass in my book, charcoal filtered or not. When it comes to building a programming language, it's all turtles. Turtles all the way down. https://www.youtube.com/watch?v=A0XXmVts1y0
Thanks, I hope people will find it useful.
When all you have is a hammer, all your problems begin to look like nails... Ruby is not an appropriate tool for building GUI apps. While you could probably make something work, the correct answer is to get a different tool and learn an appropriate language. 
Berlin has a pretty big and active Ruby community. We have a regular meetup the first thursday of the month, hosted by one of the various Berlin companies. You can find info at the [rug-b.de](http://www.rug-b.de/) website. The talks are always in english and the audience is really diverse and international. 
Why not? He could use the gtk gem 
Have you considered using a NodeJS based framework? If you're already a Web Developer, and know JS, perhaps it's an easier option? Check out [Node Webkit](https://github.com/rogerwang/node-webkit) or [Atom Shell](https://github.com/atom/atom-shell).
Ah - I wasn't aware there were any, thanks! I do know JS, and have a passing familiarity with Node. I still much prefer Ruby, but at least coffeescript makes JS a little less unpleasant. 
None I'd ever use that I'm aware of.
Good to hear :D
Have you looked at [Shoes?](http://shoesrb.com)
&gt; Ruby is not an appropriate tool for building GUI apps That's true, I heard it actually summons demons if you use it outside a browser or without the rails gem.
No worries - it's worth discussing anyhow. It might be the best option aside from my local-websockets-horror. 
Paris.rb (http://www.rubyparis.org/) is really nice, active and welcoming - a weekly meetup or more, always limited by the size of the room (100-120). Small caveat, they are mostly speaking a very weird local language named "french" during the presentations (even if individuals can probably speak english). Else you can come say hello in Belgium - we are not many, but we are nice people, we speak english and we have beers.
Thanks, Where in Belgium?
We do have a moving group, mostly between Brussel and Gent. Belgium is a very small country, so it does not make a big difference anyway (everyone is back home for the night). Look there: http://www.brug.be/ for info &amp; contact - best would be to contact the team when you know when you are coming to see what is organized at that time.
Yes There are. Google it
Dan Pinks talks on motivation http://www.ted.com/talks/dan_pink_on_motivation?language=en Alfie Kohn's book Punished by Rewards, with over 30 pages of references. Both backed by tons of research. The message of rewards is "this is not worth doing unless you get the reward" and the practice kills intrinsic motivation. It is much better to rely on / create space for people enjoying contributing to others, and seeing that their contribution makes a difference and is appreciated. Contribution and appreciation are basic human needs and do not get exhausted. Rewards give temporary positive results followed by long-term negative ones. Ultimately you want to work with people who contribute because they want to. Manipulating that want diminishes it (and the quality of contribution) in the end. 
Qt is also [available](https://github.com/ryanmelt/qtbindings).
[ruby ships with tk bindings in the stdlib](http://ruby-doc.org/stdlib-2.1.3/libdoc/tk/rdoc/index.html)
Awesome, that could be the ticket. I don't know anything about TK, but at first glance it doesn't look super-complicated like some of the other options, it also looks more "professional" than Shoes possibly... I didn't know that, thanks a bunch. 
Most. Specific. Gem. Ever.
[this doesn't seem to be that bad of a tutorial](http://www.tutorialspoint.com/ruby/ruby_tk_guide.htm). glad you found it useful!
If you're on Linux you can use the GTK2/3 bindings (https://github.com/ruby-gnome2/) or the corresponding FFI bindings (https://github.com/mvz/gir_ffi). I started messing around with writing a basic SQL GUI (https://github.com/YorickPeterse/sql-gui) using the latter, though never completed it. Looking at the code might be useful. One note, GTK documentation is pretty bad so you should be prepared to do some digging around in order to figure out how to do certain things.
Is that a bad thing? Serious question. I'm a junior dev trying to learn best practices, just trying to extract behavior that I've found useful in stuff I have built.
Nope, nothing wrong with that at all. At the least it's a good demonstration of packaging a gem. And your code is very conventional. All good, imo. 
Thanks! Good to hear.
that's not a hidden bug, that's knowledge
Why not just expose a nice web UI like Sickbeard? 
Thanks for interesting response. To clear things up, we're not rewarding each other for fulfilling his/her basic work-duties. We're focusing on actions that can impove the atmosphere and work spirit. Let me present some examples from last months: organizing afrer hour activities like paintball, wakeboarding or out-of-town barbecue, organizing office pizza-days, ordering refreshing beverages or finally bringing to the office home made cookies.
No probs. Obviously your milage my vary, but they're both pretty sweet tools.
I have not found a use for Ruby besides Ruby on Rails.
So I can just do %w(abc sdf fed) and it will form an array for me?
Well, there's [Opal](http://opalrb.org/).
Is there a way to see which answers were right?
&gt; Ruby is not an appropriate tool for building GUI apps. There is nothing wrong with Ruby for GUI apps - I've written several using QT as the toolkit. The *real* negatives are that the QT bindings are only available up to version 4 and that the QT bindings don't fit well with the normal style of Ruby. While its still an effective combination I've tended to go for Python if I need anything app based front endish with REST (Sinatra/Rails depending) based services providing the GUI which works nicely.
Awesome feedback. Thanks so much.
GTK? Qt?
I don't think that's what /u/ephrion was asking. The detailed results page does not show you the correct answers to questions you missed; it just shows the incorrect answer given with an unhelpful green box. On the topic, what is it you think a block is if not a Ruby language construct?
Let's see if I understand: - Everyone gets 50 monthly points to give or retain. - At the end of the month, points convert into cash bonus. - Participants can give each other points and identify the reason. - if someone chooses to not do anything, they end up with 50 cash-able points at the end of the month. - Presumably, receiving points, will motivate people to do for each other things that encourage gratitude and point transfers. Is the above correct?
Thank you for clarifying, that is precisely what I meant.