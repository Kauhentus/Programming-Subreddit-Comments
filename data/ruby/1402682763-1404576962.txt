That makes sense. You'll probably have to invest some mental effort in learning about how classes, jars, etc are resolved. Since it is a common pain point. I haven't done any Scala. I've been debating investing in Go or Rust. 
Don't you see that a Maybe#map and Enumerable#map are doing the exact same thing?
I actually hadn't heard of Rust. I hear a lot of folks talking about Go being relatively fun to code in, but more in the context of personal projects since it hasn't really been adopted on the enterprise or even start up level yet from what I can tell.
Having dealt with uncommented code in large projects I have to say...*ugh*. Personally about 80% of my code is comments but then I have a poor memory so sometimes I actually forget what a method does, why it does something a certain way, why some methods may appear very similar but with subtleties that might not be apparent at first glance, why the design might not follow the initial obvious route, where I've taken shortcuts and would like to revisit and what the design options might be etc. It's nice not to have to explain these things, its nice to actually use comments for what they are intended for (communication) at which they can save a hell of a lot of time rather than having to head over to someones desk and explain the rationale. Code without comments just costs teams time. Edit: Speeling, "uncommitted" doh!
I believe Go will probably see some uptake as it makes sense from a systems perspective. Rust I'm less sure on, as it isn't very far along. I'm fighting to get Node.JS adopted in a hardcore Java shop. We've only had mild success because we were able to quickly create node apps to replace legacy Java apps. But I am skeptical it will stick, we have a history of replacing everything with Java - our Ruby apps were poorly re-written in Java ... 
How about using JRuby for an existing app, and building a few extensions in Scala? Just as an experiment. Though Ruby and Scala share some similarities, Scala feels quite different to code with, and you often feel you're doing more than you need to do to get stuff done. I enjoyed my brief time with Scala, but was only evaluating because I wanted to replace Rails with Play framework. The boilerplate involved (particularly in terms of ORMs) turned me off, and I returned to the magical land of Ruby. Another thing that made me sceptical was the near-empty pool of Scala developers. That, and it's full of converted Java developers who still insist on over-engineering everything. Check StackOverflow -- nearly every answer in Scala is wordy and convoluted. I'd love to use Scala more often, especially with client projects, but it's tough to sell. 
Oh right JRuby is the most obvious transitional tool. Do you have experience with JRuby and how to implement Scala extensions in tandem?
I've used JRuby on a few production apps, nothing too complicated, just for real multi-threading on Puma. I haven't built any Scala extensions, but it's very simple to reference Java/Scala libraries from JRuby. See here: https://github.com/jruby/jruby/wiki/Integrating-with-Scala
French was a tough language for me to pick up because I know Spanish relatively well and so the delineations began to run together a bit. Whereas picking up a little bit of Hungarian was challenging, but has stuck in my mind clearly because it shares almost no characteristics with other languages. And yes, actually. I am doing it to build out my resume. Thanks for not beating around the bush. There are some incredible next-level opportunities that require Java, and while many hipster startup shops snicker at Java, it is still an omnipresent language that can be found tucked away in so much powerful tech that's in use across so many platforms. I'm not totally privy to Java 8, but it's something I'll look into. Given the shared characteristics of Java and Scala, it may be useful to learn them together. But at the same time I think Scala is a bit more present as an infrastructural tool at the kinds of progressive companies I am now keeping my eye on.
You will need to know how to interact with ORM's like Sequel, ActiveRecord, or whatever the kids are using these days. You will need to know how to develop in the MVC mindset or something like that, and you will need to know how to separate code into reusable, refactorable, and readable parts. You will need to understand how gems work and how to use them with Bundler or a similar package. You will need to know how Ruby loads these files. You will also need to know the difference between Ruby classes and modules, mixins and inheritance, instance variables, and class variables. Language basics. Lastly, it would be impressive if you had knowledge of unit/integration testing using rspec or a library on top of that, like RR, MiniTest, etc.
When I say "very simple" I'm talking about referencing Scala libraries from Ruby, not learning a new language or Java/Scala integration.
Thanks!!
I agree. There's been a tremendous amount of work done on JRuby.
And even then, if after a few years in the industry your CS degree is the biggest source of your knowledge, then you're doing it wrong.
I love passenger because it's a dream to install. They called it mod_rails originally, and it's every bit as easy as say, mod_python on apache. I love thin and unicorn because they support multiple simultaneous user connections per app (for free). Sadly, no open source ruby app servers have captures the pure simplicity of installing passenger.
Scala feels like an attempt at functional and concurrent programming, but it doesn't go as far as Clojure does. I've been instead tinkering with Clojure personally, and I've become utterly enamored. I feel that most Rubyists would appreciate Clojure more than they would Scala: - Macros are infinitely cleaner and more powerful than Ruby metaprogramming. - It's a very concise language, with a lot of syntax sugar and convenience reader macros/special forms: - Common data structure reader macros( `[]` for Vectors (Arrays), `{}` for HashMaps, etc). - Destructuring via `let` bindings, which are used implicitly in many places. - The threading macros, which make it more readable than most Lisps. - (Honestly, I can keep going.) - Since all the data structures implement the `ISeq` interface underneath, almost all the functions can be used on all the common data structures. Essentially, data structure duck typing. - A language that doesn't have years of baggage, since it is quite new. (Think all the Perl-isms in Ruby. Yuck. Nothing like that.) - A number of familiar concepts, like `:keywords`, which are used exactly the same as Ruby Symbols. - Anonymous functions are definitely cleaner than Ruby procs and blocks, especially with the nice `#()` reader macro. - Built in Software Transactional Memory (STM). - "Goroutine" support via core.async. - Access to all the Java libraries, which are plentiful. - A clean Java object interface, with syntax sugar for all of it. Honestly, I can go on, and on, but the real benefit is how once you get into the Clojure mindset, and avoid mutability as much as possible, you end up with some of the most, subjectively, beautiful code I've seen.
Generalization of the concept is not equal to doing the same thing. If it did the same thing, I'd be able to chain `#map` with `#zip` without wondering what the fuck went wrong with core ruby API.
Spurred by this post, I wrote [What It Takes to Be Entry Level Rails Developers](http://www.kcoleman.me/blog/2014/06/13/entry-level-rails/) on my blog. Most of the content in the article is below: I was at this ATT hackathon and I got paired with these two new rails guys. It took them over 6 hours to build a CRUDL (create, read, update, destroy, list or basically what rails g scaffold does) application and hook into devise. For me to want to hire a entry level guy, I would want them to be able to do: 1. Build a CRUDL application 1. Understand and apply bootstrap 1. Build a to-do application or any simple super basic app that requires a few controllers, models, etc. 1. Use slightly obscure gems, like the twitter, koala, mandrill, kamari, j-builder, etc. to prove to me that they can read the documentation and figure out how to use a gem. 1. Git Bonuses: 1. understanding a testing framework (rspec is my preference) 1. knowing some basic javascript (jquery) 1. know TDD 1. Thin Controllers, Fat Models 1. Attends the local ruby on rails meetup Edit: Added version control Edit fix controller model sizes 
Actually deploying an app onto the internet is a distinct skill and something that many junior devs haven't done. Would love for a new developer to be able to be able to do simple deploy stuff like production [asset pipeline setup](https://devcenter.heroku.com/articles/rails-asset-pipeline), [setup ssl on heroku](https://addons.heroku.com/expeditedssl), and maybe [run rake commands](https://devcenter.heroku.com/articles/rake).
Those are just the first steps. The hardest part will be finding people willing to take the risk on you, especially if you don't have previous development experience in other languages or a college degree in CS. I graduated from GaTech with a degree in Engineering and had 2 years of C# experience when I landed my first rails job. At that time, I had done 1, 2, and 3 from part 1 and 2 , 3, and 4 from the bonus section. Because I started in C#, I had a pretty solid understanding of SQL and [good programming practices](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882). I consider myself pretty successful at programming and rails in general. My secret is that I am always coding and learning. I spend 40-60 hours per week either programming for clients or working on side projects to beef up my resume.
&gt; Fat Controllers, Thin Models lol what? I assume you mean they know **not** to have fat controllers and thin models? Even the whole "thin controllers, fat models" thing is erroneous. It should be "a plethora of thin domain objects with singular purposes, most of which are POROs"
Testing :D
Iterate through arrays, interpolate strings, rspec fundamentals, database migrations, model generations, html / css/ jquery fundamentals, and definitely git.
was going to say the exact same thing. clojure is a very appealing next language after ruby; it's the most fun i've had with a jvm language, jruby included.
I've had the..."fortune" to work with multinational teams where English was not a requirement (not just English as a first or second language; any English). Run most function names through Google translate and more often than not you get the function name returned verbatim. Run *comments* through Google translate and you usually get back something...passable. Not always right of course but I've been able to get front end developers up and running with the backend API simply by documenting it with comments. There is no such thing as self-documenting code. There is documented code or there is code which is only comprehensible to a small subset of the potential users of that code.
Let me just leave this here... http://www.martinfowler.com/bliki/AnemicDomainModel.html
Bam, already done this and created a gem and I've only been developing for 6 months. 
I agree that Thin Controllers, Fat models isn't the best path for building a scalable application, but for entry level rails people, I think understanding that much will at least land them a job.
&gt; college degree in CS I've often wondered, do people with CS degrees not find themselves utterly unchallenged with web development?
[Learn Haskell](https://github.com/bitemyapp/learnhaskell) instead. Scala's only benefit is that it runs on the JVM, and that comes at a price - crazy type system hoops to jump through (CanBuildFrom), lack of real tail-call elimination, etc. For any real functional programming, Haskell does it better, and without the JVM penalties. * https://news.ycombinator.com/item?id=7867780 * http://functionaltalks.org/2014/03/31/runar-oli-bjarnason-functional-programming-is-terrible/ * https://twitter.com/pelotom/status/469659132455157761 * https://www.youtube.com/watch?v=TS1lpKBMkgg
&gt; What questions would you pose to an entry-level Rails developer? I am still pretty new to the game (3-4 years out of school) and only have been apart of hiring two developers in my time, so take everything I say with a grain of salt. For more perspective, I work in Atlanta and have looked out moving California-side. When I interview in Atlanta, 50-80% of the companies do not ask technical questions or only give 1-2 simple ones. They were more interested in what I have done before and what I can do for them. When I left my C# job to get that RoR job, I got a $15k pay pump and that interview had 0 technical questions. I also think your github account speaks more loudly than whether or not you know how to sort an array. After I left that, I looked at going to the bay area and I was grilled about everything under the sun technical. To answer your question, I have no idea. It seems to depend on where you are hiring. If I was looking to hire someone, I probably wouldn't ask them anything super technical (like describe the factory pattern or what is the difference between include and extend in Ruby), but I would look at their source code to see what they actually do. &gt;Also, if I were to score the interview and land a gig, what would I expect to be doing on a daily basis as an entry-level/junior developer? It really depends on the company. My entry level C# job had me take a 1-mo on boarding class on how to program their 15 year old code base. The rails job I did started off as "go write a load tester in ruby" and eventually grew to write the reporting engine. Many of the jobs I interviewed at, and my friends work at, are about porting an existing php/c#/java system to RoR so it can scale better.
I don't have a CS degree and I am totally unchallenged by web development. But my long term goal is to start a company, and building websites is a good skill to have.
No. That's awful. 
Here, have an upvote! Actually going from Rails Guides to prod is a pretty large set of moving parts to understand and pitfalls to jump.
This doesn't directly answer the question asked, but Code School offers me up tons of "aha!" moments even when I've been at it FT for a couple of years. RailsCasts, although growing a bit stale, is still the best resource for "I know I need to use X gem, now how do I go about wiring it up?" Some of the comment threads are excellent for figuring out semi-obscure issues with specific packages, too. 
That's also entirely related to how much you challenge yourself, too. It's incredibly easy to coast on what you know and only look up stuff when you need it. Honestly, if you don't feel challenged *and you have a genuine interest in the work* I would encourage you to work harder to find a challenge. I work with several people with PhDs in things from Data Structures to Algorithms and they freely admit they find web development challenging on a daily basis.
u boss
This might very well be true, but the companies using Java have not similarly advanced.
I'd add Git to all that.
I've always used a Service-Oriented Architecture, with rails as an API client, so I just removed active record and the models directory entirely and defined my own service classes. In a more traditional rails app with models, mutations are great for getting that SOA feel.
Drumroll please... Exactly the way you thought you would. ;) &gt; "Awesome!" if true &amp;&amp; (false || true) =&gt; "Awesome!" &gt; "Awesome!" if false &amp;&amp; (false || true || false || false) =&gt; nil When in doubt, fire up irb. It's also worth knowing that Ruby uses short-circuit evaluation on both &amp;&amp; and || operators, so you're not adding massive overhead by checking a whole bunch of conditions. You can use this to your advantage by putting expensive (or less likely) conditions at the end of the chain.
Hi fellow entry-level developer! (Been at my job for 2 months) 0. How to read other people's code. Most projects are not green-field (i.e. `rails generate my_app`). 1. Not really Ruby, but version control. You'll use a version control system (usually it's Git) literally every day. 2. Testing. You can get away with untested apps for the first few weeks-months but at a certain point your app needs tests just for sanity's sake. Also it helps in designing a system (if it is hard to test usually it is not a good design). 3. I think constant practice is needed. Like just write things constantly. I'm actually bad at this, since I love reading programming books/watching conference talks. 4. Know how to connect other Gems to the code. Ex: Devise for authentication, Stripe for payment, Resque/Sidekiq/DelayedJob for background stuff, Paperclip for image uploads, AWS, different APIs (both connecting to external ones such as Twitter/Facebook and making your own). I needed to learn this the first day, as I had never done this before XD 5. Know how to deal with people, I think is the most important thing, the best way to improve is to pair with other people and see how they work, little things like how their editor is set up, what they test, why they make these decisions and why they don't (oftentimes the "I did not do this because" is more important than the "I did this because").
Seems like go or rust might be better candidates for you.
Yeah, that's interesting. I'll look around GigaOm etc. for more info. I am basing that off of a conversation I had with an Etsy and Kickstarter engineer that both loved using it but agreed they weren't able to sell it to the company despite being in management positions. Small sample size, but specific examples.
Rust snuck up on me. But per other conversations in this thread, Go is certainly a language I've given a lot of consideration towards.
Depends on what you mean by web development. With modern web apps being more akin to distributed systems, I think that there's plenty of challenge once you move past CRUD apps.
This one isn't really technical, but more cultural. You *have* to know how to explain your thought process, and how you may go about solving a problem. Doesn't matter if you get the answer right or not, as long as you have a sound thought process that demonstrates an approach to problems, you're better off than most people.
 return a &amp;&amp; [b, c, d, e].any? Note that this evaluates all expressions, though. So don't do that if they have side effects (e.g. delete a file) or are expensive to execute. If you already have all the values, this is a very clear and flexible way of doing it.
What kind of consultant forwards all their problems to Reddit? And what's a semi-startup?
That makes sense. I've just recently started consulting so it's all a bit new to me. I guess fitting in to coding styles keeps everyone happy.
&gt;It's funded but makes money. I guess it's how I differentiate companies in my mind. Not really forwarding problems just asking for opinions from people who have a lot more experience than me especially since I'm new to consulting.
That seems like a sensible option. I will have to sit down with them and briefly talk about their likes and dislikes regarding programming practices.
Different types have different interfaces that may share method names and may behave differently. If you think that makes for surprising code then you need to make a case against object orientation and polymorphism. Maybe#map does the exact same thing to a Maybe that Enumerable#map does to an Enumerable. A Maybe just happens to be a wrapper around a single value rather a collection, so while implementing the whole Enumerable interface would be trivial it wouldn't make a lot of sense.
&gt;I've often wondered, do people with CS degrees not find themselves utterly unchallenged with web development? I have a CS degree and a lot of grad school. It's not like it's a magic bullet that solves all your problems. I've spent the last twenty years working on servers and backend stuff, networking, architecture, etc... I've spent the last three days trying to figure out how to line things up in CSS ("OMG just use fucking &lt;table&gt; already!!!"). It's not that CSS is that hard, or that I'm stupid. It's just a different skill that I don't have practice in (which is *precisely* why I'm doing it). 
The idea that only Enumerable objects can implement a #map method is bonkers. Your assumption that anyone else will be 'surprised' by this is pure conjecture. We should figure out what a method's the return value is and what other messages we can send based on context and well chosen, role based variable names.
TIL you can get a PhD in "Data Structures"
I like to go with thin models (pretty much just validation logic), thin controllers and put most of the application logic in separate services.
Can you expand on this a bit? Of the various Rails tutorials I've done, these are all typically a part of it, and it seems like fairly easy stuff to look up and reference. Are you just looking for someone to have memorized or know how to look up and then implement the basics? Or do you mean they should fully understand the underlying logic that lets the magic happen?
For the Gems bit, is it sufficient to be able to know how to read docs, find an online tutorial, and piece it together from there? Or does the knowledge go beyond that?
FYI, you'll learn all of this and more if you thoroughly read and follow Agile Web Development with Rails. Great book. 
Can you give an example of how you use them in a DCI pattern? I ask, because DCI (at least as I understand it), requires extending classes with functionality, which doesn't seem like a pattern that you guys used in any of the mutation examples. I'll be honest, I've tried DCI patterns in the past, and haven't found them to be more valuable to me than pure service objects. In either pattern, you can reuse the logic in your controllers and in your API. Have you spoken with Jim Gay at all (http://clean-ruby.com/)? He's an amazingly bright guy, and just an awesome dude all around. His book on DCI is definitely a worthwhile read.
Why would you downvote me for this? I'm excited to have learned this stuff already because I'm trying to become a developer. 
You should 301 to the correct URL or set a canonical meta tag. These two urls could be considered duplicate content by search engines: - https://www.qraex.de/tintenshop/anfrage_stellen/drucker/Hewlett+Packard,+OfficeJet+710 - https://www.qraex.de/tintenshop/anfrage_stellen/drucker/Hewlett%20Packard,%20OfficeJet%20710 
Hmm, Rails definitely handles `+` as an encoded space in a _query param_ just fine -- and indeed, this is what most browsers will generate in the URL if you enter a space in a form set to `action=GET`. But maybe Rails doesn't handle it equivalently in a URL path component, which is your example. And I can't even say with confidence they are supposed to be handled equivalently, the specs can get confusing. I can't imagine there will be much noticeable difference in performance between rack middleware, vs having the part of your app that takes the path component and does a database lookup normalize `+` to a space first. But I am not sure whether all search engines and other things really will consider those URL variants equivalent, `%20` vs `+` in a path component of a URL. I'd agree with the person that said it would be better to have the 'accidental' one redirect to the 'canonical' one -- and to fix your sitemap! You could probably do the redirect in rack middleware too if you wanted to, but I'd just use a before_filter myself. 
Sendgrid are migrating a lot of their Perl/Python code to Go as well. At my local Go meetup there's been guys from Sendgrid, Apple, Facebook, and three guys from Comcast who are trying to get away from Java(bless their souls).
A DSL authoring howto and not a single mentioning of abstract syntax trees?
I feel the same. In fact, I choose nodejs for a recent project that is required to run on windows servers, behind firewall. If it was a internet site, or I could figure out running ruby on windows same way I can easily run node (without installing) I would have picked ruby
First true programming language? I think you'll find that lots of languages have Windows support, but if you want an environment that is conducive to programming you'll want some flavor of Linux or OS X. Unless you're programming specifically for Windows, you're better off working on a Unix based system. Most web development positions require you to know some form of Unix because that's what most of them deploy to. If you are truly adverse to using some form of Unix, then I would suggest just using RubyInstaller.
I wouldn't ever bother writing code on Windows outside of VisualStudio.
If you have to use windows then * Accept the fact that you are a second-class citizen in ruby-land and this is not going to change. There are some people that do amazing work making ruby on windows easier but the vast majority of ruby developers are of the opinion "If you want to cripple yourself by using windows then go ahead, but don't complain to us about it" * Use [jruby](http://jruby.org/), it is just easier.
If you *have* to use windows then [jruby](http://jruby.org) is your best bet, it is easier to setup and can run on things like tomcat and other java servers that have a better history with windows.
d'oh! thank you.
In that instance, yeah, yield would be equivalent (and nicer to read). But in other circumstances, using &amp;block lets you save the block to pass it around, store it somewhere, pass it into a different function, call it later, etc. So there's definitely reasons to use it, just... not there. (That being said, some people like to add the &amp;block parameter to methods that expect a block, to make it clearer to someone reading the code that the method needs a block. But they still might call it via yield, so that's not quite what's going on here)
One quick aside before I answer your last question: As you know, Ruby's method signatures allow you to optionally specify that a block will be used by the method. **However**, if the method doesn't use the block, or no block parameter is specified, it's not an error to pass the block to a method. The block is simply discarded. For example, this is perfectly legal: def foo # doesn't take block arguments 100 # doesn't use a block anywhere end foo { |x, y, z| 200 } # =&gt; 100 # "100" is the result of calling `foo` That method call is equivalent to writing: block = Proc.new { |x, y, z| 200 } foo(&amp;block) # =&gt; 100 Being explicit about a `&amp;block` argument in a method is therefore a documentation convenience -- it's a hint to the reader that the method takes a block and that it will get used somewhere in the method's body. &gt; Why not just use yield, like tweets.each {|x| yield x}? When you write `yield`, you're **assuming** a method has been passed a block, because it *is* an error to yield to a method that hasn't been passed a block: def bar yield end bar # =&gt; LocalJumpError: no block given For that reason, some people prefer to work with the `block` object itself, and call it directly if it exists. These are roughly equivalent: def bar yield if block_given? end def bar(&amp;block) yield if block end def bar(&amp;block) block.call if block end You also need not name it `&amp;block`, which is helpful when understanding a method actually does. For example, consider which one is clearer: def sort(&amp;block) # ... def sort(&amp;comparison_strategy) # ...
One difference is that you're reusing the given proc, rather than creating your own proc that wraps that proc. It may be micro-optimizing, but there's no need to create a new Proc object when one's already available.
From my experience trying to set up virtual box on my Mac for rails development, I noticed that my specs took about twice as long to run as on my naive Mac host os. If you don't care about how fast your rails app performs in development mode, by all means try out vagrant.
I use yield by convention if my method is designed to return value(s) to the block in some kind of immediate fashion...whereas I use explicit &amp;block always when the block passed is saved for later execution, which is far more frequent use-case for me.
This is the best answer. Yield is the thing to do if you need the block inside your method, but often times you need to pass the block as an argument to higher order functions or save it for later.
Vagrant does not require using VirtualBox - that's just its default [provider](https://docs.vagrantup.com/v2/providers/index.html). This post is about using the Docker provider, which uses the lightweight virtualization tools built into the Linux kernel, **not** virtual machines (assuming you're using a Linux host machine). That of course makes it very fast, but the main benefit is the consistency of environments that Docker images bring.
In my experience in about 90pc of cases, Rails being slow when run in Vagrant is due to the method of folder sharing used. Switching to NFS will almost always fix it. I've never seen a noticeable performance difference with that approach. In this case using the Docker provider alone on OSX won't fix that because it's still going via a VirtualBox VM. See &lt;http://www.talkingquickly.co.uk/2014/06/rails-development-environment-with-vagrant-and-docker/&gt; for details on getting Vagrant + Docker + VirtualBox working efficiently with shared folders. 
The biggest thing is that there are just so many concepts outside of the programming logic that is generally considered "development", and any additional knowledge in those areas is a big win. Take my first example of asset pipeline setup - in development it just kinda works, but there are production specific issues with it on Heroku and about a million other variants depending on the size and type of project: are you serving files from Rails or letting the web server handle it? Far futures headers? Did you toss in a js from Google's CDN that accidentally was set to use straight HTTP instead of protocol-less and now there are SSL errors all over the site?
What about it?
Do you know the content? Is it good? Is it worth the $70?
Ive loved pretty much every language Ive dealt with (C,C++,Java,C#,Python,Perl,javascript) with a major exception to ruby, python being my fav because ideas can be expressed so easily, until I decided to bite the bullet and try ruby and I must say its not as bad I had thought, its not my fav but I plan todo alot more with it and then eventually hop on the rails bandwagon and see what that`s all about. Alot of people are talking about the docs and such, what i disliked about python the most was its "batteries included" were not too useful, alot of the stdlibs that were included are very basic and threading support was mostly an afterthought, unless your talking about stackless but I havent even began to dig into the ruby docs, however for me I learned a very long time ago that learning to "decipher" docs is probably a programmers most valuable skill. having said that the python docs are a bit of a maze at times. but atleast for the most part its all there. since switching to ruby ive found that not only is the code so much shorter but that alot of programs use it for scripting, the most widly known metaploit framework, and my recently purchased rpg maker vx ace. and with rails being a "de-facto" standard for web app with ruby It feels more native then django which for me kind of feels like again an afterthought.
So most of the things you said were new to me (I'm still very much a beginner). Aside from looking up the individual items, is there an umbrella topic I should research that all of this would fall under? Is this considered dev ops?
&gt; So can the ampersand turn a proc into a block, and vice versa? No, there is only the proc. A *block* is a purely syntactic construct that results in the VM creating a proc internally, but it's not accessible to the code. A *proc* is an explicit Ruby object (`Proc`). If you declare a method *without* a `&amp;block` argument, there is no variable that can be passed around. This is mostly a remnant of early Ruby behaviour before you could access procs directly. The only way to use the proc is via `yield` and `block_given?`. If you declare a method *with* a `&amp;block` argument, then you get a proc object that you can pass around. In this case, the proc is passed to the `tweets.each` method as if it were a block. As others point out, doing this vs. `yield` has exactly the same effect, and the performance is identical, because in both cases, a proc object must be created. 
in my opinion ruby worth us$70 but you can start lerning ruby in sites like codecademy and if you alredy know another programming language you can buy a book to learn and save some money sorry for any english mistakes 
unless You are using said service object in many contexts and not just in one rails app. One reason I try not to make statements like the above, it is too easy to come across as a "black/white" instead of "grey based on situations"
I never said you can't share the domain across multiple apps, but making that domain primarily service objects instead of legit domain objects is almost entirely not a great idea. Sometimes people need to make lines in the sand so that beginners and intermediate people don't fall into the trap of poor decisions before they know enough to evaluate what is an appropriate gray area. 
Thanks a lot IndianGuru.
There has been improvement in recent years but the best thing you can say is that they make Java less awful for those who have to live with it. They don't even come close to making it an appealing language compared to so many alternatives. To the original question, scala is a really interesting language to study. Unless you are interested in Java to become more maretable as a developer, I would suggest you skip it.
The content is worth it, but mostly is available in the the tutorial. What you will find is the course is alive, it changes each course. The conversation changes each course, and the fact that you learn so much more than just Ruby if you take part in the pair programming makes it worth much more than the price of entry. In addition to Ruby, there are a couple "side tracks" that address version control and html, and a couple other things that are optional. If you participate more fully, and are able to make the hangouts, then you will cover even a more variety of things, to include things that may be learning more about your operating system, pair programming, developing in a team, more complex git use, and many other topics, mostly lead by the student.
if you go here http://rubyinstaller.org/downloads/ they explain everything you need to know, but this isn't the only language that suffers from this problem, python is even worse, id say just install whats suggested and ignore support issues, your there to use to language not worry about its support. if you worry about small things like support, your just distracting yourself from using the language, prob bad advice but the bottom line is your trying to program not troubleshoot windows support.
Just some simple things combined into one. learning *gets* was proabaly the greatest thing for me.
Anyone? Bueller?
&gt; Which just makes it odd how little support it seems to get imo. The CLI is a second class citizen in Windows, so Windows is going to be a second class citizen for most scripting languages.
Guess you're applying to Ada too? I wonder what the acceptance rate is.
The hard part about the ruby -&gt; java transition is just how verbose java is. I've been doing ruby for 6 years or so and i'm on a c# project at the moment. c# is a decent language, but sometimes it hurts me inside just how much extra code i have to write to do the same thing. Scala is a lot better in this regard.
Why not use more portable RPC solutions like RabbitMQ?
Overkill for simple scenarios.
The aim of the eBook is to show Ruby newbies the mechanics of using Sourcegraph while programming in Ruby. You will be able to check on documentation and real-world usage examples, while coding.
That's cool, but what is the benefit of monkey-patching Kernel instead of being its own module that you can either call directly(`Egison.match_all(foo) { ... }`) or be included in a class like this? class Foo include Egison # Foo now has a match, match_all, etc. method end 
Are you receiving any sort of error message? I have found that even though the tags do not match the specification provided, it still works.
Good question, I had intended to also share the error message: This is what I get as a result from this particular service: &lt;s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;s:Header&gt; &lt;Action s:mustUnderstand="1" xmlns="http://schemas.microsoft.com/ws/2005/05/addressing/none"&gt;http://schemas.example.com/Service/TransferService/ProposalSignedResponse&lt;/Action&gt; &lt;/s:Header&gt; &lt;s:Body&gt; &lt;ProposalSignedResponse xmlns="http://schemas.example.com/Service/"&gt; &lt;ProposalSignedResult xmlns:d4p1="http://schemas.example.com/BasicServiceContract/" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"&gt; &lt;d4p1:Status&gt; &lt;d4p1:StatusType&gt;ERROR&lt;/d4p1:StatusType&gt; &lt;d4p1:StatusDetailCode&gt;TSE-NFE&lt;/d4p1:StatusDetailCode&gt; &lt;d4p1:StatusIdentifier&gt;50bab207-1a2e-4016-8918-c1b837335c2d&lt;/d4p1:StatusIdentifier&gt; &lt;d4p1:StatusDetailDescription&gt;No dossier found with reference id '00000000-0000-0000-0000-000000000000'&lt;/d4p1:StatusDetailDescription&gt; &lt;/d4p1:Status&gt; &lt;/ProposalSignedResult&gt; &lt;/ProposalSignedResponse&gt; &lt;/s:Body&gt; &lt;/s:Envelope&gt; The '00000000-0000-0000-0000-000000000000' should really be "13118512-1201-0000-0000-000000000009", but that's what the Error message says. Other services (with more fields to be entered) just give error messages, the request files aren't processed.
Yeah in my experience (Getting Savon working last week.) The namespaces tend not to matter in the overall request. But if they are theres not much we can do with out seeing some sort of response. If you want to try different SOAP requests and see the results the SoapUI application makes it really easy.
I found this in Savons Docs http://savonrb.com/version2/globals.html **env_namespace** Savon defaults to use :env as the namespace identifier for the SOAP envelope. If that doesn't work for you, I would like to know why. So please open an issue and make sure to add your WSDL for debugging. Savon.client(env_namespace: :soapenv) This is how the request's envelope looks like after changing the namespace identifier: &lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt; **namespace_identifier** Should be extracted from the WSDL. If it doesn't have a WSDL, Savon falls back to :wsdl. No idea why anyone would need to use this option. Savon.client(namespace_identifier: :v1) Notice the v1:authenticate message tag in the generated request: &lt;env:Envelope xmlns:env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:v1="http://v1.example.com/"&gt; &lt;env:Body&gt; &lt;v1:authenticate&gt;&lt;/v1:authenticate&gt; &lt;/env:Body&gt; &lt;/env:Envelope&gt;
Can you try the Savon call in SoapUI And see if it works there? I've had some problems with Savon where the call itself was working but something else weird was going on.
Wait, I noticed something. The whole end result thing shown at the end has differences from how the tutorial tells you to code it. After the first step I ran it to see how it looks and mine looked a lore more huge than yours because it never tells you what to say about window size in the tutorial, BUT, at the end when it magically shows up without being talked about. Also the line that shows the learner to do the title disappears from the final code. Also also I notice that with this part: flow do @title = edit_line "New note", margin: [0, 5, 0, 5] @para = edit_box "Describe your note here" end end it shows the learner to write this part in the middle of the tutorial, so it ends up around the middle of the file, but in the end end result this moves down to the bottom of the file.
some gems won't work. but Ruby and even Rails work acceptably well on windows. one can develop rails app entirely on windows. the choices of gems could be somewhat limiting, but if your goal is to learn the language, windows work pretty fine. what are specific issues you are running into?
Are you planning on covering authentication?
Yes! That's why *Practical* Microservices.
It's not really a big deal IMO
I have updated the original text with the results of another of the services that I need to call. To answer your question, the SOAPui results in a Bad Request 400 error.
That namespace_identifier partially solved one possible issue I saw, sadly it doesn't solve the problem outright: &lt;env:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mor="http://schemas.example.com/Service/" xmlns:env="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;s:Header xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;To s:mustUnderstand="1" xmlns="http://schemas.microsoft.com/ws/2005/05/addressing/none"&gt;http://url:port/Service.svc&lt;/To&gt; &lt;Action s:mustUnderstand="1" xmlns="http://schemas.microsoft.com/ws/2005/05/addressing/none"&gt;http://schemas.example.com/Service/IService/CheckPrepayment&lt;/Action&gt; &lt;/s:Header&gt; &lt;env:Body&gt; &lt;mor:CheckPrepayment&gt; &lt;MortgageDossierReferenceId&gt;13118512-1001-0000-0000-000000000009&lt;/MortgageDossierReferenceId&gt; &lt;OrderReferenceId&gt;13118512-1011-0000-0000-000000000001&lt;/OrderReferenceId&gt; &lt;PrepaymentDate&gt;2014-06-16&lt;/PrepaymentDate&gt; &lt;PrepaymentForLoans&gt; &lt;PrepaymentForLoan&gt; &lt;LoanReferenceId&gt;33-01-01&lt;/LoanReferenceId&gt; &lt;PrepaymentAmount&gt;15000&lt;/PrepaymentAmount&gt; &lt;PrepaymentPenalty&gt;0.00&lt;/PrepaymentPenalty&gt; &lt;/PrepaymentForLoan&gt; &lt;/PrepaymentForLoans&gt; &lt;/mor:CheckPrepayment&gt; &lt;/env:Body&gt; &lt;/env:Envelope&gt; I'm not too well versed in XML, but would the tags within the &lt;mor:CheckPrepayment&gt; also need the "mor:"? As it seems to have in all examples I have access to. And if so, how can I make Savon do that for me. :)
I have updated the original text to add the request and response of another service.
Thanks I will try that and report back :) **reporting back** sadly no difference in response. It seems that the service expects the MortgageDossierReferenceId and other tags to have the namespace too. But I have no idea how to get Savon to add them. Request now looks like: &lt;soapenv:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mor="http://schemas.example.com/Service/" xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;s:Header xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;To s:mustUnderstand="1" xmlns="http://schemas.microsoft.com/ws/2005/05/addressing/none"&gt;http://url:port/Service.svc&lt;/To&gt; &lt;Action s:mustUnderstand="1" xmlns="http://schemas.microsoft.com/ws/2005/05/addressing/none"&gt;http://schemas.example.com/Service/IService/CheckPrepayment&lt;/Action&gt; &lt;/s:Header&gt; &lt;soapenv:Body&gt; &lt;mor:CheckPrepayment&gt; &lt;MortgageDossierReferenceId&gt;13118512-1001-0000-0000-000000000009&lt;/MortgageDossierReferenceId&gt; &lt;OrderReferenceId&gt;13118512-1011-0000-0000-000000000001&lt;/OrderReferenceId&gt; &lt;PrepaymentDate&gt;2014-06-16&lt;/PrepaymentDate&gt; &lt;PrepaymentForLoans&gt; &lt;PrepaymentForLoan&gt; &lt;LoanReferenceId&gt;33-01-01&lt;/LoanReferenceId&gt; &lt;PrepaymentAmount&gt;15000&lt;/PrepaymentAmount&gt; &lt;PrepaymentPenalty&gt;0.00&lt;/PrepaymentPenalty&gt; &lt;/PrepaymentForLoan&gt; &lt;/PrepaymentForLoans&gt; &lt;/mor:CheckPrepayment&gt; &lt;/soapenv:Body&gt; &lt;/soapenv:Envelope&gt;
Sorry, I don't really know my self. Every time I see SOAP come up at work I want throttle a vendor.
Same here. I've been wrecking my brain on this problem for about a week now, and I'm stuck. Thanks for thinking with me though, much appreciated.
You may just need to use the namespace directly: { 'mor:CheckPrepayment' =&gt; { 'mor:MortgageDossierReferenceId" =&gt; ... If you use strings as your keys instead of symbols, Savon will use them literally as the fields in the request. Symbols go through some processing (i.e. :foo_bar would get converted to &lt;fooBar&gt; but 'foo_bar' would remain as &lt;foo_bar&gt;)
No problem. I feel like SOAP is an industry term for 'I have a hard on for Java'.
This is what I ended up doing for some of the stranger service calls.
https://github.com/sklise/sinatra-warden-example
Didn't know that was possible. Will try that too, tomorrow, If that works, I'll gild you. :) **edit** YES! that worked. I never knew that possibility was there. Hadn't found it on my travels on the web. Enjoy your gold, /u/clockwerx!
Could you show me an example of a project that's developed like a set of microservices? Maybe there is an app like that on github?
I ask this question whenever someone says they are writing a book; I hope it does not come across as offensive as this is not the goal: You are writing a ruby book about microservices: Who are you? What makes you super-qualified to write a book about microservices? Where have you implemented them? Have you written about them somewhere before (blog etc.)? Done a conf presentation? Basically: Why should we buy this book when it comes out. Go on, sell it :D
Awesome! Looking forward to it
Using Warden would be the way to go. Depending on how complex your app is going to get, you may find it less daunting to just use Rails than to begin implementing a lot of Rails conventions into Sinatra. In my experience Sinatra can outlive it's usefulness very quickly once you get to the point where you need to being authenticating users. That's just IMO. Good luck! 
Thanks for your feedback. I've just updated post.
Looks interesting. Our company website is growing in every direction you can think of and while the customer oriented part is relative simple, we are putting more and more services for our employees online. Most of this not being typical Ruby territory like data analysis where we provide interfaces to very different types of data.
Ive stated before that someone who is completely new to programming will more then likely go for the latest version and that's all well and good but when they start wanting to use other libraries most of the good libraries are still stuck in 2.X, that's the main concern. and for a newbie thats sometimes enough for them to ditch the language altogether in my experience. but from your previous response what i gathered it could be that language is so stable that it doesnt need a 2.0/2.1 maybe those are just for "bleeding edge" which if your just starting with the language you shouldn't deal with anyways, 
with powershell this just isn't true, powershell is extremely powerful but when most people say CLI on windows they're still talking about the old cmd/command which is very primitive for anything other then very generic batch scripts It may be that when it comes to porting *nix programs over to windows they miss out on powershell because it simply isnt known to them or they dont understand it as it is a whole other language.
You're awesome.
You're right. In that case using the docker provider should be as quick as native provided your host OS is Linux. I was thinking of the times I have tried it when using OS X. I also do a significant amount of coding on my Linux machine so I will give this a try.
Thanks. I'll give it another go. The slow experience I had was about 1.5 years ago, so performance may have changed significantly since then.
Yes, I am also interested in Erlang. Can you point me to other specific industry implementations you're excited beyond the common example of WhatsApp? I should also mention that I am a relatively fresh programmer, which means I do have the opportunity to 'learn it right the first time' and I have read that Erlang is one a few a languages that can form good habits - though of course 'good' is very much subjective in this case.
To answer my own q a bit, someone replied to a separate thread I've started about Erlang: &gt; Amazon's SimpleDB is written in Erlang, and IMDB switched from Perl to Erlang
This was such a timely thread. Just started working on a custom-iterator feature for my rubyretriever gem. I went with using the explicit declaration of &amp;block and then executing it with block call. I needed to be able to pass it around thru a number and it worked just as I had hoped. Also very cool that &amp;block is an optional argument by default.
Ha, sure. I will certainly give it a shot. I've noticed that a lot of interviews don't allow the use of IDEs, so I don't want to lean too much on one for that reason. But certainly worth a look.
Not to mention I think it's a great way to adopt healthy practices as a young malleable developer like myself. But that's entirely subjective. I'm less interested in cloudflare or docker at the moment (just don't know enough about them) but certainly do find eBay, Google, and especially Soundcloud interesting.
Of course, I'm covering not only Rails and Sinatra, I'm covering *polyglot* services too, think Scala/Finagle or Clojure/Ring — the whole point is to show that each service can use whatever it needs and that its consumers don't have to care. Now, on pure Rack-based services: I don't see the point of showing how service A can be implemented with Sinatra's routing DSL and how own router can be implemented. It's just not the point. That said, it probably will still touch on some things Rack, like middleware.
I am definitely interested in Haskell, and thank you for passing along the resources. Alternatively, have you used Erlang much? Love the tweet, very insightful actually. Not to kill the joke, but do you mind explaining the comparison in the tweet in greater detail?
I honestly would like to learn functional programming, coming from a bit stronger object-oriented background (though I'm not expert level with Ruby as of yet). This may even be an argument for Haskell in my specific case. My only counter-point for your IDE comment is that many interviews at elite tech companies do not allow you to lean on IDEs, especially if you're hitting the white board straight on. Your point about learning one language well and then translating that logical knowledge forward to the next one is well taken, and has been echoed by a few. There is that object-oriented to functional programming divide but I believe Scala would be a great tool for bridging that divide.
I already anticipate a storm of examples from you for why Clojure is the best and all the companies that have adopted it, but I really haven't seen many (or any?) software engineering job listings list Clojure as a desired skill set in my searches. I have seen more exotic languages like Erlang and Haskell pop up, and equally new languages like Scala or Go, but rarely Clojure. I'm definitely not looking to start a flame war, it stems from a genuine curiosity. And you already laid out some clear reasons for adopting Clojure. Seems the main one is adopting best practices as a developer, no matter how subjective that may be.
I hate doing a* in sinatra and am sure you will find the same annoyances that I was running into. I now only use sinatra for absolutely tiny web apps (2 pages and 0 auth) Good luck and have fun!
He's a polygot software developer who has been freelancing and contributing to OSS, read the bottom. :P
Also note that you can use $ instead of show-source and ? in place of show-doc 
The powershell is also a second class citizen. It's a well designed shell, but it is not the main focus of the developers.
I do not code Clojure professionally, nor even at anything more than a tinkering level. From a purely subjective overview, focused on the ideals presented in the language's design, I find Clojure to be very compelling. It is the first language that I've touched that feels like it's been designed from the ground up. Clearly thought out. Almost minimalistic in its approach, yet very powerful. As for jobs, I don't know the market at all. Clojure may or may not be a waste of time, but it sure is interesting from a design perspective. I was definitely not comparing it to Scala on popularity or employment merit. I just find it fascinating and elegant.
Speaking of relational algebra, does anyone know if there is an active fork of squeel? Ernie has, unfortunately, discontinued it
Because someone wants to learn how to do it. That's enough for me. 
yes! I keep forgetting that! thank you. 
Very Cool. I've been playing around with shoes quite a bit in the past few weeks and would love to see some more. Im struggling on how to design a shoes app that is a bit more complex/ not all in one file. Cheers to the great post though!
I've heard Goldman Sachs does their HFT in Erlang amongst a number of other wall street institutions. It's big in a number of telecom companies and runs on some hardcore embedded systems for routing and switching(not exactly "exciting" per se). As a Ruby/Rails developer I'm excited about Elixir, which runs on the Erlang VM. My plan is to learn Elixir since the underlying paradigms are the same(functional programming, immutability, the OTP, mail boxes) and pick up the Erlang syntax afterwards. Erlang is still an evolving language from what I can tell, and the popularity of Nodejs and Go seem to suggest concurrency is the way to go, so I expect it to be a good investment of my learning time. To give you something to compare to, I plan on focusing on Ruby, Go, Erlang/Elixir, and perhaps something on the CLR or JVM like C# or Java/Scala/Clojure(since both platforms have good game programming libraries), in that order. Haskell and Ocaml look interesting too but I doubt I would do much in either except maybe a one-off project or two to pick up their ideas. That's the plan at least. Anything interesting you've found that you'd recommend checking out?
Yes, I have used Erlang a little bit - actually it was a language I was pretty excited about a couple years ago. Not in-depth, unfortunately, but I did the "Learn You Some Erlang" tutorial and about 1/2 of the "Erlang Programming" book. My main problem w/ Erlang is that I never found a good use case for it for my hobby projects, so it just kind of atrophied for me. IMO if you have a problem you can model with Erlang's message-passing semantics - like chat, every tutorial uses chat - it works amazingly well. The downside to Erlang is that I don't feel like it's a good general-purpose programming language. It's dynamically typed, and not very fast at doing mathy stuff. You can use Dialyzer to try and find type errors, but it can't fully make up for the lack of a strong type system that languages like Haskell have. Everyone says the syntax is weird (and they're right - prolog-y, variables capitalized, etc.), but you get used to it rather quickly. Honestly I feel like the programs people are building with Go now would oftentimes be better done in Erlang. That said, I haven't written anything in Go so maybe I'm missing something. But some things I've gleaned about it that make me nervous are the stop-the-world garbage collection (Erlang has per-process heaps), the seemingly greater reliance on shared memory between goroutines (Erlang follows "shared nothing"; processes have private memory from eachother. Technically processes can share memory using things like ETS tables, but in practice I think that pattern is rare), the insane amount of `if err != nil` defensive error checking all over the place (Erlang encourages just letting processes fail and allowing supervisors to restart them), and the imperative structure of programs. After seeing [tweets like this](https://twitter.com/aphyr/status/478266298367897600) I'm starting to wonder if the "new hotness" sheen on Go is going to wear off a bit and people are going to realize that in a concurrency-oriented language you need to take a more strict approach to shared memory. TL;DR if you have extra time, I do think Erlang is worthwhile to learn. But I think Haskell will be more important for general purposes, and there are Haskell libraries like [CHP](http://hackage.haskell.org/package/chp) that might be able to reproduce some of Erlang's CSP goodness (but I don't have enough experience w/ Haskell yet to say that). edit: About that tweet, I don't totally grok functors enough to offer you a better explanation than this: http://www.haskell.org/haskellwiki/Typeclassopedia#Functor The main takeaway from that tweet is that the type definition of the equivalent of a functor in Scala is a total mess due to having to work around the JVM
&gt; our Chef run is interrupted by the need to use Ambari to provision the Hadoop cluster in the middle of the deployment. No. Learn how to configure your Hadoop cluster and then make Chef do it for you. Everything goes in Chef, and everything gets configured in a single Chef run. Anything else is a recipe for disaster.
Your idea of pulling things out and using the block is fine, but I think you need to ask a larger question: why do you need to do so many things to recover each of these exceptions? (And are you sure exceptions are the right flow for this?) The example you gave is a little generic, but it looks like you do a number of assignments and call `save`. Why doesn't `@object` have a method like `reinitialize` (or whatever you're doing to it)? Then you could just have @object.reinitialize in the shared portion of the blocks.
Fantastic! Swift brought pattern-matching back to the fore, even though it's an idea that's at least ~40 years old. [I was just commenting](https://twitter.com/jxxf/status/473834183253438464) on how I wish more languages should take cues from history for features, and this is a nice addition. Great work -- I can't wait to play with it.
I do have experience configuring Hadoop. I've never heard of this Ambari thing though, so I just googled it and saw that it's for "provisioning and managing Hadoop clusters." That's what Chef does. Don't try to use two different tools to configure your server infrastructure. Or do, but then don't forget that someone with several years of Chef experience warned you.
push the ambari repo config from a yum_repository resource. in the same recipe you can install your packages via the yum_package resource. 
If it looks like sweat is pouring off your brow with every keypress, it's a problem. Largely, I wouldn't worry though. Strive to be the best thinker you can be, you'll spend a lot more time ponder than whacking keys.
I don't think I've ever been asked that question during an interview nor heard of anyone required to prove it. With that said, typing is a critical skill of programmer. I don't think it would be a problem as long as you can produce a reasonable amount of code (with quality) in a fair amount of time to meet objectives. Coworkers might become frustrated if you are a slow typer and make many simple type-o's. Can you touch-type or do you hunt and peck? 
Typos! It's typos, haha.
Thanks! That's helpful. 
I am a programmer myself and have managed and hired a decent number of technical staff as well. Programmers I work with or that work for me who don't know how to touch type is a huge pet peeve of mine. While Its not something you ask or will be asked on an interview it will make you look like a novice. There is nothing wrong with being a novice but in software it is not a situation you should stay in for very long. If you can touch type just fine but just do it slowly, that is not a problem, keep at it and the more you program the faster you will get. But if can't type without looking at the keyboard you should really spend some time practicing that skill. A professional learns how to use their tools. If you want to be viewed as a professional, learn to type. The keyboard is your primary tool. I learned to type in college. Every time I sat down to the computer I practiced for 5 - 10 minutes. Considering how often I sat down at the computer I became proficient in about a month. I recommend finding a copy of Mavis Beacon teaches typing or something similar. You'll be amazed how quickly you learn. 
Yep, it's short for "typographical error".
Is the term "Microservices" What the cool kids are now using to describe Service Oriented Architecture? Or is the a difference? 
What Nitrodist said. Also, check out the gem, whenever. It's a nice simple way to keep your cron configuration in your project code base.
Since you all are so helpful. Any chance you would be willing to look at my question on [stack overflow?](http://stackoverflow.com/questions/24255675/trouble-with-api-queries-using-a-ruby-gem-how-can-i-fix-thisoverflow?) 
It's Ruby, not Java, so it doesn't matter that much. I'm kidding, everyone knows Java programmers get their IDEs to write code for them.
Java programmers get their IDEs to write JavaCodeFactories that make JavaCodeFactoryImpls that write ConcreteJavaCodeFactoryImplFactoryImpls that write code for them.
cool kids like Martin Fowler?
awesome! I was waiting for a book on this topic.
Nice work dude.
The only jobs I've ever seen where people cared about WPM was secretarial work or data entry. As long as you aren't a one-finger hunt-and-peck typist I seriously doubt it would be a problem. Most of your time as a programmer is spent thinking and reading existing code anyway. The actual typing out of new code is a distinctly secondary activity.
Very few people care. I have had coworkers who type faster than me (100 wpm), and coworkers who hunt and peck at 20wpm. Very, very rarely is your programming speed capped by your typing speed, so being able to type quickly isn't going to have a measurable effect on your net productivity. That said, if you can't touch type, you should really learn to. It's extremely easy and avoids the awkward questions about knowing how to type. And lastly, for your amusement: the WPM that people actually care about. http://blog.codinghorror.com/content/images/uploads/2009/02/6a0120a85dcdae970b012877707a45970c-pi.png
The helper method approach is probably fine, but I'd also start attacking ... a bunch of stuff that can raise a variety of errors ... to see if there was a way I could isolate parts of it to reduce the number of different exception classes that have to be handled in that one place. It's also worth taking a look at the `rescue...else` construct to see if you can usefully invert the logic anywhere. Another thing to think about: what's `@object`'s role in all this? Would this whole method be better implemented there instead?
Martin fowler [argues](http://martinfowler.com/articles/microservices.html#MicroservicesAndSoa) SOA means too many different things and usually SOA refers to something different than microservices, due to focus on ESBs, microservices, however, are all about simple lightweight message delivery mechanisms like HTTP and AMQP.
Not much but if I see on pair programming that you cannot operate your computer effectively (your editor of choice etc) then its a problem. Just shows that you don't program often which might be indicator of inexperience.
Yeah. I'm almost 50, been working in IT since I was 19. I use three fingers to type. One for the left side, one for the right, and a thumb for the spacebar. I had a typing class in highschool, and met the 40 WPM to pass, but I think the teacher was being generous, and I was really doing 35-38 WPM. I can't seem to think and touch type. I can still sort of touch type if I am simply transcribing things, but if I am thinking and typing at the same time, I go into three finger mode.
Hm, I've been wanting to play with carrierwave + S3 myself this summer. Have you tried replicating the basic tutorials you linked? Have you gotten those to work yet?
Unless you have a disability, writing code will quickly make a proficient typist out of you. So if you can't type proficiently, it might look like you haven't written a lot of code. No one cares about your typing speed in and of itself, but writing a lot of code is how you become a proficient programmer. (A lot of code and verbose code are not the same thing.) 
I use 2 fingers on my right hand and three on my left (excluding left thumb for spacebar), have my whole life, and I average about 140 WPM, maxing out at 170 WPM in typing contests. I am a touch typist. Touch typing has nothing to do with how many fingers you use or their position; it just means typing for long periods of time without ever looking at the keyboard or having to look at it. 3 total fingers is definitely going to cause you issues though. I'd recommend practicing typing long blocks of text on typing practice websites, like 10fastfingers.com and typeracer.com. Don't worry about how many fingers you use, their position, or your methodology. Just focus on finding something that works for you, and build as much muscle memory as you can.
You're being downvoted but I agree. Typing fast is not at all a required skill, but touch typing (typing without having to look down at the keyboard) is pretty important. If you have to keep looking down at the keyboard to hunt and peck at keys, it is going to be an obstacle between you and the development. It will distract you, slow you down, and make you lose mental ("where's the next key?") and visual (no longer looking at the screen or the code) focus. A 40 WPM touch typist would probably be more efficient than an 80 WPM hunt-and-pecker (if there was such a thing).
meaning... couldn't get them to work at all? if so, here are some other resources I saved back when i did a bit of research on carrierwave. One of your links is in it. Maybe another one might give you better luck? I would suggest first just trying to use carrierwave to save to file before anything more ambitious. - CarrierWave gem - [File uploads live demo: Carrierwave + Sinatra](http://vimeo.com/70001769) - carrierwave + sinatra + DB/file? - [A Gentle Introduction to Carrierwave](https://blog.engineyard.com/2011/a-gentle-introduction-to-carrierwave/) - carrierwave + sinatra + AWS - [Using Amazon Web Services S3, with Sinatra and Carrierwave](http://www.webdevstory.com/posts/2) - (assumes carrierwave already setup with ActiveRecord/DataMapper) - carrierwave + sinatra + AWS on Heroku - [Setting up CarrierWave and MiniMagick with Sinatra](http://coledotcode.tumblr.com/post/56836607326/setting-up-carrierwave-and-minimagick-with-sinatra) 
Google. "Nginx Sinatra ec2" would be my first guess
I thought it sounded funnier at the time to typo the word typo when discussing type-o's. I'll work on my humor. 
Well, after 26 years it hasn't caused issues, so I'm not too worried. If my employer decides that 10 finger touch typing is more important than my coding, logic, and troubleshooting skills, I guess they will replace me, but saving them money with those skills has always seemed to outweigh my typing deficiencies. 
Having just had to work this one out myself, I found [this github repo](https://github.com/p8952/nginx-unicorn-sinatra) to be extremely valuable. I tried several different Rack servers, and found that unicorn was the simplest to get going.
Have you looked into carrierwave direct? https://github.com/dwilkie/carrierwave_direct Edit: Bad paste
That's not helpful at all. I know there's a ton of information out there, however as I do not know how to do this, I am unable to identify the resources worth reading. I am asking for help with this task, as you would know if you though for a second about the question being asked.
Thank you.
Looks neat but appears to lock you into a specific start model (Go process must be child of Ruby process) and a specific interchange format. I'm not sure why you'd use this over Protocol Buffers or Thrift.
Basically a more concise version of http://jakegoulding.com/presentations/rspec-structure/ which is not bad thing at all.
I type at 100 WPM with three or four fingers.
Or use [getoptlong](http://ruby-doc.org/stdlib-2.0.0/libdoc/getoptlong/rdoc/GetoptLong.html) which is in stdlib.
[getoptlong](http://ruby-doc.org/stdlib-2.0.0/libdoc/getoptlong/rdoc/GetoptLong.html). It's in stdlib.
See: http://www.reddit.com/r/ruby/comments/28c3yt/how_important_is_my_wpm_in_the_eyes_of_an_employer/ci9r310 Hunt and pecking vs. touch typing has nothing to do with the number of fingers used.
Current student from 52nd batch and following is what I can add - * Cost is 45$ for first 10 students (which is what I paid) if you sign up early. Anyway for a real good Ruby course between 45-70$ is a fair price. * Much of the ruby material is available for free out there, what sets this course apart (and reason I signed up) is one on one help from a mentor. I'm in week 4 and have already learned more than any of the free resources that's out there. * You get your code reviewed from the exercises by the mentor and other students. * Course isn't limited to ruby learning itself. I've already started doing TDD and got an insight on Vim and have jumped the bandwagon. * It has added sidetracks as Github and web development (that's what I saw so far) that's part of course, so an added advantage. Would be happy to answer if anyone else has any other queries.
http://recipes.sinatrarb.com/p/deployment/nginx_proxied_to_unicorn First hit from google, and looks like it covers the basics.
So Unicorn is the way to go? Cheers.
I'm digging his whole MetaRuby series. Quite easy to understand.
What is it specifically that you're having a problem with? For one though, I would avoid storing the actual video file in the database. Instead you should store a reference to the file itself. An api I recently built had to do something similar with carrierwave. Here's a Gist close to what I ended up implementing: https://gist.github.com/ifightcrime/9291167a0a4367bb55a2 Side note, but are you planning on this being a high traffic app? If so, be careful, especially with videos where it's tougher to front with a CDN. Amazon bandwidth is freakishly expensive.
This implementation has zero dependencies in both Ruby and Go.
Yes, and another way to think of it (because we all approach things in different ways) is whenever you have some branching logic in your code, that is a new context. If you find yourself dropping into a lot of different contexts in your test, that is a good suggestion you should refactor stuff into a new method/object.
This is a pretty superficial critique, but I think it helps when/if your project scales up: I would group your tests based on the method they are testing. Ie describe Btc do describe '#new' do it 'should initialize as a BigDecimal' do ... your test... end it 'should raise ArgumentError if invalid btc amount' do ... etc ... end 
Hey thanks! Let me know if there's anything in particular you'd like to see.
Some minor suggestions: * `gets` will always return a string (it's short for "get string"), so no need to use `to_str`. Also, you generally want to use `to_s` instead of `to_str`; you don't really need to worry about `to_str`'s existence most of the time. * In Ruby, `snake_case` is always preferred over `camelCase` for variable and method names. `new_name` would be more Rubyish than `newName`. This is personal preference, as are all style decisions, but if you want your code to be more idiomatic relative to 98%+ of the Ruby community, it's best to use `snake_case`. * There's not necessarily anything wrong with `new_name = name.gsub(...)`, but a shorter version is to use the mutating version of that method, which is `.gsub!`. So you can replace that entire line with `name.gsub!(/\s+/, "")`. These are minor things though. For the actual functionality you want to implement: my advice is to Google around, look at documentation, and try to work it out yourself. For a simple program like this you definitely don't need any gems. There are some spintax gems, but when starting out it's better to try and implement things like this yourself. Some advice for that: * It'd be best to keep this to a purely command-line program for now. Instead of having the user press a button, you should just show the output right afterwards. * Once you have a fully functional command-line version of this program, you can rewrite it as a GUI application. The best way to do that would be to break your command-line program into different functions (methods, technically, but think of them as functions), then when writing the new GUI program, call those pre-written functions. For a GUI, you will definitely need a gem. I recommend **[Shoes](http://shoesrb.com/)**. * That means as you're writing this command line program, you should try to think of ways you can break it into a few different pieces so that it could be called by a different program. Don't worry if each step takes you a while. Just research and keep trying things. Also, make use of the Ruby REPL (the prompt you get when you type `irb`) so you can experiment with different things.
I wrote this: https://github.com/dchuk/Arachnid because I was using anemone for a project years ago and it was a RAM and CPU monster. Mine is not. I updated it a bit earlier this year for another project but generally don't touch it. If you need a fast crawler, give it a shot. The docs on the readme should be enough to get you started.
just tried with ruby 1.9.3 and ruby 2.1.1 and got this: checking for curl/curl.h in /opt/local/include,/opt/local/include/curl,/usr/local/rvm/rubies/ruby-1.9.3-p545/include/curl,/usr/local/rvm/rubies/ruby-1.9.3-p545/include,/usr/include/curl,/usr/local/include/curl... no need libcurl *** extconf.rb failed *** 
This means that this gem is dependent on a native package that it expects to be already installed on your OS (via brew, apt-get, etc). Normally the README would include the specific per-platform install instructions, but this gem looks a bit under-documented too.
Consider using a [gist](https://gist.github.com) and updating it as necessary. Making changes to them gets committed as patches so you can see the progress of the work as you go. It also makes it easier to see what changed since then people only need to focus on the diff.
https://gist.github.com/defianthydride/8fd2e54720646621726a
Mechanize is great: https://github.com/sparklemotion/mechanize
I've ran into this exact problem, and eventually hacked together something using nokogiri. Basically it just grabbed a page, found all 'a' elements, and followed ones that were on the same origin. Slow and imperfect, but it got the job done
Don't try to be everything at once. Pick node, or RoR, or PHP and focus. Try to find freelance work doing one thing, and focus on doing it very well. Right or wrong, the stereotype is that overseas freelance work will be low quality and banged together by someone who doesn't really know what they're doing - so you have to overcome that and deliver great work if you want to build a reputation that you're worth paying well.
Great @zenani. Thanks a lot for your answer. May I ask you how many hours do you usually spend in the course for week? I - in a very reallistic view - intend to dedicate between 8-10 hours week studying ruby. Do you think it's enough in this case? How does the mentor chat works? 
Nice update! This is really minor, but as far as code style, a common Ruby idiom is to omit empty parentheses for method calls without arguments (like you have on lines 13 and 29). Same for line 10: puts filename.write [GitHub's Styleguides](https://github.com/styleguide) are handy references. Happy Ruby-ing!
Hi varkerkamachi, thanks a lot. May I ask you the same questions as I did to the other replier? &gt; May I ask you how many hours do you usually spend in the course for week? I - in a very reallistic view - intend to dedicate between 8-10 hours week studying ruby. Do you think it's enough in this case? &gt; How does the mentor chat works? And, just curioous: why taken the course twice. Thanks a lot. 
Finding remote freelance was hard here, because the internet &amp; technology penetration was still low, Indonesia people still live under poverty. I am planning move to UK to take post-graduate programme, and to work there.Thanks for the suggestion i will keep in mind.
Yeah that was my bad. i keep moving from one language to another after i take a grasp on it. Now i am really focusing on ruby. anyway people here suggest me to take a freelance did you guys mean like odesk or what?
According to Glass Door, you are getting paid pretty decently. http://www.glassdoor.com/Salaries/indonesia-software-engineer-junior-programmer-salary-SRCH_IL.0,9_IN113_KO10,45.htm
Maybe i am the one that cannot be grateful. But what i want to said is from my point of view and my friends who are programmer too. we really cannot afford to have decent life as a person in here.
Yeah, it's best to find the job market of a job before making a career out of it. Sorry bud. Emigration is always an option. Or suffering until you get enough experience. Or telecommuting.
I'm not sure where the good places to get freelance work are, unfortunately. The standard stuff like elance (terrible), odesk, and craigslist come to mind, but I'm not sure if there's something better.
You're correct. If you're on mac, use homebrew to install curl and you should be good to go. I documented this gem a few years ago, albeit not comprehensively.
Selamat! There are many companies that will hire people working from all over the world on a contract basis, but usually you need to be upper-Junior level or above. Your English is pretty good, so I would really suggest having a github or other version control account. This will help people see your code quality, which is much more important when you are coming out of Jakarta. Even if you got hired on a contract basis at $15-20/hr (very low in the US), that would be 30-40k per year.
Programming languages are great, but being able to sell yourself is even better skill. Polish your English language skills as much as you can - take classes in it if you have to, it's a complicated language. I realize you've taken great pains to word your question well, but many of your replies show it as something with rough edges. Good communication, especially on the internet, is an incredibly underrated skill. It will help you a great deal when dealing with people in the UK, the US, and Canada for contract work.
It blows my mind how long some programmers go without understanding operator precedence.
On what levels are you on the said technologies?
Sure i am already have Github too. Thank you, you give me such a confident.
I can confidently said my skill as a ruby programmer are on mid level. 
Not in indonesia you can easily find PHP job. Ruby programmer or Node.js are so rare here, because currently many employee preferences are PHP or .Net.
You may have 'simplified' it, but you also made it twice as hard to read and debug. As bbatsov's styleguide puts it 'and and or are just not worth it'
Would you work for 10,000 a year full time doing php? do you have a github profile with examples of projects code you have built?
Yes, if i am suit your requirements. :)
Emigration. Your salary is determined by your market environment, move to the UK or Germany and suddenly you earn ten times the the amount.
Oh, you're welcome! I think networking will also be huge for you, but you need to start networking with people in Europe and the US. Get a twitter account, try to participate in live rails talks over the internet, tweet at other developers and ask questions. Contribute to open source projects. These things are all good but optional in the US, but I think in your case they would really help you out. Also, be honest with yourself about where you are at. You don't have to be a crazy good developer with all of the answers. You're a junior dev, and can market yourself as such.
&gt; Don't pick PHP. It's harder to find decent work. [I call bullshit](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html) - at least, unless you're falling prey to a No True Scotsman fallacy and arbitrarily redefining any PHP job as "not decent".
Did you ignore my github question?
i met an indonesian who did this - he got a low-paid job as a web dev (php) after graduating, then he moved to the netherlands, where the money is better ruby (rails) developers are in demand in the uk - one recruiter i know has difficulty finding them unless he's offering £3-400 per day
I have sent you a pm for my github profile did you not get it?
I don't think this simplifies the code in any way. Using 'and' and 'or' rather than '&amp;&amp;' and '||' will bite you since their precedence is different - if you don't realise why, you could end up with a really hard bug to track down. Also- and this part is much more important: This is procedural code. It is a sequence of operations which you have decided should happen in this order for program and computation correctness. You might be wrong. If you split each statement out into a method, place the whole group of methods in a class and wire it correctly, your code *will* be easier to follow, easier to debug and easier to refactor. By working towards a more declarative style via OOP, you will pass the decision of execution to your computer which in turn will execute your program faster and more efficiently. I'm not giving you hassle, just moving the clouds aside so you can see the top of the mountain. Hopefully this will excite you enough to want to climb it. Have fun.
Itu bukan apa apa. Semoga sukses!
Sukses buat anda juga :)
RoR would be good if you wanted to emigrate to the United States. There aren't enough of them here. I've got recruiters annoying me constantly.
&gt; Using 'and' and 'or' rather than '&amp;&amp;' and '||' will bite you since their precedence is different But their precedence is different on purpose, so that they can be used exactly like this...? &gt; It is a sequence of operations which you have decided should happen in this order for program and computation correctness. Isn't that true of the entire program? The whole program is a bunch of statements I've decided should run in a certain order for computational correctness. I guess someday when I live on the mountain I'll understand ; )
rubyforge is down **forever**. They shut down this week.
Thanks for the link for `Shoes`. Never heard of that before!
The change from 1.8 to 1.9 was much bigger than the change from 1.9 to 2.0. Learning 1.9 is alright, it's mostly new feautures that have been introduced, no significant changes. Don't learn from a 1.8 oriented book though, it's nit supported any more and the ecosystem has advanced a lot since.
The idiomatic way to deal with deeply nested ifs is: index = @inv_selection &amp;&amp; @inv_slots.index(@inv_selection) inv = @inv_selection &amp;&amp; @mgr.comp(@player, Inventory) item_id = index &amp;&amp; inv.items[index] item = item_id &amp;&amp; @mgr.comp(item_id, Item) etc However, once your ifs get _this_ nested, there's probably a completely better, other way to do it altogether. Looking at your code, I'd say you're not properly making use of OO methodologies. For example, by adding encapsulated functionality to the Player, Inventory, and Item classes, you could instead use the following syntax: selected_item = @player.inventory.get_usable_item(@inv_selection)
I second that. I've used Mechanize extensively on several projects. It's built on Nokogiri for speed, and the syntax finds a good balance between terse and expressive.
Fred Brooks quoted a study in The Mythical Man-Month that put the average daily output of a programmer at something shockingly low - like a dozen lines of code. Granted, this was in the 60s using languages that were a lot less productive than Ruby, so take that with a grain of salt, but the kernel of truth is still there: typing speed will not be much of a factor in determining whether or not you can be a productive engineer. That said though, you should be working toward improving your speed, especially if it's something you see as a problem, because the keyboard is the interface that lets you practice your craft.
There's no point of using the splat: class Cat attr_reader :name, :surname def name=(value) @name = value.first @surname = value.last end end felix = Cat.new felix.name = 'Felix', 'the Cat' felix.name # =&gt; "Felix" felix.surname # =&gt; "the Cat"
You just have to put that inside a loop all_good = true while all_good print "Enter something:" input = gets.chomp if input.empty? all_good = false else puts "Good job!" end end
`integer?` is a method so you can do `1.integer?` =&gt; true. You can put it inside of a loop or you can define it as a method and call the method inside of the method. def print_program print "Enter something:" input = gets.chomp if input.empty? puts "please type something" else puts "Good job!" end print_program end
if you want only an integer you have a couple options. coerce the input into an interger with to_i like this puts input.to_i so if input is 45 it will work but if they input 'hello' it will return 0 another way is to test if its an integer and raise an error: if input.is_a? Integer puts "#{input} is a integer" else raise "Exception: input is not an whole number" end 
I usually put in 6-8 hours. This is spent on reading study material (2 hours) doing quiz and exercises (4-5 hours). I try to at least hangout with mentor twice per week. A single session can be of any duration. This is again based on each individual's availability. In the past I've been with mentor for 4-5 hours straight too. Apart from this, I spend some time reading and practicing through free materials that's available online. Mentoring is the best value and positive point of this course. You login to course and if mentor is online (which is 80% of time), you connect through Google Hangout and then can learn from them or get your queries resolved. This is like having a senior developer respond to all your issues personally which is more than what you pay for entire course.
I have been working on, and posting on here about, my latest project -- Rubyretriever. http://github.com/joenorton/rubyretriever Right not it has 3 command-line modes, 1) sitemap (URLs only), 2) file harvest (collects all files by filetype), and 3) SEO mode (grabs page title, meta desc, h1, h2). I just merged in a PageIterator feature yesturday, and after some tests I will be pushing out a new version gem this week (v1.3.0) that can do custom blocks on a per page basis (like Anemone does). 
if you change the filetype of your gist file to `.rb` you'll get syntax highlighting for free.
That is a good idea I may create an account there and do that. I am new to reddit (and posting code publicly in general) and that was my first post ever and it was done here to try to help others. I read this forum every day to get new ideas so it seemed sensible that it would be some help posted here.
It's generally said that clever programming solutions are anything but - and this one falls pretty firmly if the category of something that becomes un-maintainable pretty quick. I tend to try to stick with the Ruby Style Guide as much as possible, which suggests avoid and/or at all cost due to the potential for precedence issues they can cause, but others have already pointed this out so I won't harp on it much. To me, more than anything, this code doesn't allow for very good exception handling. Regardless if @inv_selection, item_id, or the item is not usable, the result of this chain ends up that the method would return nil. If that's not what you are expecting, you'll end up spending more time debugging the chain rather than immediately understanding the problem because the method gives good information back. So let's say you want to add some exception handling to this chain is @inv_selection is null - easy enough right? Don't forget those parentheses to ensure precedence! (@inv_selection or fail StandardError, 'Inv Selection not found!') and index = @inv_slots.index(@inv_selection) and ... But wait! You shouldn't raise an exception without also writing an error to your log: (@inv_selection or (logger.error('Inv Selection not found in method') and fail StandardError, 'Inv Selection not found!')) and index = @inv_slots.index(@inv_selection) and ... This was supposed to be better than nested ifs? One parentheses forgotten or in the wrong place will cause havoc in this code. The better approach, in my opinion, is to give yourself "guard clauses" that bail out of a function as soon as it can: unless @inv_selection logger.error('Inv Selection not found in method') fail StandardError, 'Inv Selection not found!' end inv = @mgr.comp(@player, Inventory) index = @inv_slots.index(@inv_selection) item_id = inv.items[index] return unless item_id needs = @mgr.comp(@player, Needs) item = @mgr.comp(item_id, Item) return 0 unless item.usable ... Clean, clear, and no nested ifs required.
Obviously a few people saw the point of this being posted. While, sure, a blog post may have been better it still is sharing knowledge there is now a post that can be found in case someone queries for: "Frame no id capybara" which can be helpful to future people in need of help. 
Does it really have to be Ruby? I'm not a big fan of Python, but [scrapy](http://scrapy.readthedocs.org/en/latest/) is pretty much without compare in this area. If your spiders are simple you don't even really have to know any Python to write them - just follow the examples.
 class Cat attr_reader :name, :surname def name=(*args) @name = args.first.first @surname = args.first.last end end For the love of all that is holy please someone recite an exorcism over this code and shoot it before it breeds! 
&gt; move to the UK Speaking as someone in the UK, don't bother - the cost of living here compared to salaries is just painful *even for mid-senior roles*, so much so that I'm looking for work in the US.
Eh. I prefer codeschool better. http://mbsy.co/6Vm29
Thanks for the suggestions. I have to admit I never would have written a combined series of or's and and's like that if I needed error checking. I would have done exactly like you suggested. unless @inv_selection logger.error('Inv Selection not found in method') fail StandardError, 'Inv Selection not found!' end index = @inv_slots.index(@inv_selection) and inv = @mgr.comp(@player, Inventory) and item_id = inv.items[index] and item = @mgr.comp(item_id, Item) and item.usable and Proc.new do ... end.call That was actually quite easy to change. If it was in the middle, then I would no longer consider this a simple list of instructions that depend on each other, and I wouldn't have used this 'and' method. And if I used guard clauses, then what if there was additional logic after the failure that should still be run within the method? Using the chained and's it only bails out to the end of the chain, and then continues on like normal. With the guard clauses you're just out of the method or you have to start adding else clauses. I suppose you could try and stuff all the additional logic into the guard clause, but what if it is not directly logically related to that code and doesn't really fit there? 
&gt; And if I used guard clauses, then what if there was additional logic after the failure that should still be run within the method? Without a concrete example, it's hard to say exactly, but my initial inclination would be that you are trying to do too much in that method then. You don't necessarily have to thrown an exception, you could have the method simply return early from the guard clause if it doesn't have enough information to complete the operation. The caller then can continue on with the program with or without the result from the method call. If you need the method to continue and an important value is missing, you could also initialize it to ensure successful completion of the method: @inv_selection ||= 0
Pretty cool, though I don't see myself, or most developers, using this in a practical dev environment until at least the September release. 
I would add a funny gotcha: private setter method calling. setters must be called with an explicit receiver while private method must be called with an explicit receiver :D
It looks like you're searching for 'Authentication:' and 'Authentication2:' to decide whether to append your lines. Something like this should fix that, file.insert_line_if_no_match("/AllowUsers ubuntu/", "AllowUsers ubuntu") file.insert_line_if_no_match("/AllowGroups dev/", "AllowGroups dev") Though I usually prefer to just make an erb template for the whole file and then have the template notify a service reload on a change. You can also override a few variables and then call the [chef cookbook](https://github.com/opscode-cookbooks/openssh) and let it do the heavy lifting.
The sooner you start developing within scripted, repeatable virtualized environments, the better.
Making bank from a foreign country and spending it in your less expensive country seems like a pretty solid life move to me. Still get to be with your family and everything.
I go both ways on this. Using Vagrant with VMWare is nice when I have to [test against a particular database configuration](https://github.com/basho-labs/riak-ruby-vagrant) but testing on bare hardware is easier on the batteries and runs cooler.
Also if you run a lot of tests it's much faster.
This is incredible, thanks
@player is just an id, it isn't a class, and Inventory and Item are pure data - no functionality on purpose, because they are components in an entity-component system. There is no doubt that it is a little more verbose than inheritance when you have to unpack things like I'm doing here, but when organizing a large structure of objects I've found it really starts to pay off. I can create entire new complicated entities in the game by just piling together pre-made components. I actually came across the and/or operators, because I was looking to do exactly what they do. With this system, this process of unpacking components is quite common, and it is always a short list of instructions that each depend on the previous (i.e. get the id, get the component, get the needed data). So this method seemed a perfect fit. I like your suggestion as well, but I find it slightly more confusing to quickly glance at.
youd probably want something more like begin print "Enter something: " input = gets.chomp puts "Good Job!" unless input.empty? end while input.empty? This will loop as long as input is empty and only prints good job if it is not empty, you can change the puts ... unless to a conditional if you need something more there
So then make it a class! You clearly have non-trivial operations specific to this @player_id. This is a perfect example of when to use OO. player = Player.new(@mgr, @player_id) Once you define the `Player`-specific logic _within the Player class_, to get the inventory you just: player.inventory # none of that @mgr.comp(@player_id, Inventory) junk
&gt; You were thaught wat?
But node is better and makes you happy 
The = before Genre should be a -, then you need to add a = to the %li genre line - Genre.all.each do |genre| %li= genre The loop line isn't outputting anything, that's why it's changed to a -.
Obvious troll is obvious
I kinda want to benchmark this…
Hey, what I used to do was have conf files in the files or whatever dir of the cookbook, and whenever that conf file was updated, the recipe would then update the conf file on the client. You'll of course have to modify your actual recipe to do this but I recall that being only a one or two liner. Good luck. 
 input = '' print "Enter something: " (input = gets.chomp) while input.empty? puts "You entered #{input}"print "Enter something" This has the disadvantage of needing to 'initialize' the variable called `input` though. Checking for an Integer, if it is the only thing you are asking for, you could use the Kernel#Integer method. It will raise an error if the object it is trying to transform to an Integer is not possible. You could use the String#to_i method, but it will convert anything that doesn't start with a number to 0. Such as "this is number 12" will become the integer 0. "12 is the number I chose" will become the number 12. 
The Ruby REPL is IRB, the functionality you get when you simply type ruby at the command line is the fact that it is reading your STDIN buffer. You will get good line by line feedback using IRB, and you should become comfortable experimenting in IRB.
Sorry, meant to write "irb". Spent all day writing Python and was thinking of its REPL. :)
the process is exactly the same in Mavericks which is why I decided to just go with Yosemite to future proof the video.
You are right, however introducing beginners to VMs and scripting a development environment right away is a bad idea. We wanna make it simple for people who don't know the first thing about programming. There is always a balance we have to strike when teaching beginners. I would make the VM / scripting, making your dev environment repeatable and as close to production as possible a separate episode. its a good idea for an episode though thx! :)
Reddit treats anything that begins with four spaces as code and preserves whitespace. I think RES also includes a code button. Try this instead: corolla.color = "blue" 
Yes definitely there is demand. There are also a lot of remote positions available - so you could work from say a beach in Bali, for a client in the US. Only issue is that's more for senior developers with some solid experience.
Usually comments on the ruby subreddit are constructive in some way. Please go troll elsewhere.
yeah, junior ruby jobs pay nowhere near as well in the UK, quick straw poll looks more like £75 a day at entry level even in london where an apartment costs over £200 a week http://www.indeed.co.uk/jobs?q=junior+ruby&amp;l= 
I'm glad that Yosemite doesn't break a basic rails environment. Thanks, OP!
Thanks, that's exactly what I was looking for. I knew it must be "a thing", I just didn't know what to search for.
if you teacher told you that cats are good for late night food you eat? remember you are a developer, not a javascript/ruby/scala/erlang developer. Learning a new language is easy, new syntax, new libraries, maybe new aproach for similar problems ex: scala actor vs golang routines. and javascript is not a better language :) btw: https://plus.google.com/+JohnCook/posts/RqgWFQHCrWU "For me, JavaScript is a lost cause." -- Douglas Crockford, author of "JavaScript: The Good Parts" google that name. Douglas best!
If you type 41 wpm &gt; (average for adults http://www.ratatype.com/learn/average-typing-speed/), it's okay. The main thing you have to do - create logic of code and use as little code as possible. Use more brain than fingers.
FYI, you should probably try to avoid using class variables in ruby: https://github.com/styleguide/ruby -&gt; See section on class variables http://stackoverflow.com/questions/9396563/why-should-we-avoid-using-class-variables-in-rails http://makandracards.com/makandra/14229-the-many-gotchas-of-ruby-class-variables Why couldn't you achieve the same thing with just an instance variable? 
Solid move, though I'd probably put that in the beginning of the video (and point out instances in which the process may be different as you go along). I think it's great you did this. I tagged it for future use. I'm just saying I don't know when I'm going to be upgrading to Yosemite on my work machine. I was thinking, after I watched this, that I might try it on my personal machine. I'm in the process of making a company specific ruby build engine for iOS apps. Hearing good things about the compatibility of Yosemite to iOS 8 and their new tools. I'll need to upgrade as it rolls out, I would imagine. Thanks for the video!
No Trinidad, no Torquebox...
You never push the first word you enter to the words array. I'm also a bit worried about your grandma.rb and xxx.rb programs...
In other words, initialize the array and then push words = [] words.push "Hello" You can also use the "&lt;&lt;" operator words = [] words &lt;&lt; "Hello" The difference between &lt;&lt; and push is that push can accept multiple arguments. words.push "A", "b", "c" However, &lt;&lt; is faster than push. 
thanks, i ended up reversing the order of two lines... so, after while i've got list = list.push word word = gets.chomp rather than word = gets.chomp list = list.push word 
Ruby is more fun.
Sounds like you're not running bundle in a directory with a Gemfile
Yes, I am not! I was assuming, Bundler would go to its location and open it!! By the way why would anyone want to use "bundle open" command if they were already in the gem folder?
It's not in the Gem folder - it's in the Gemfile folder, ie, where your application is instanlled (vs where the gems themselves are installed).
`gem` is actually an executable of RubyGems, which is completely different than `bundle` (which is Bundler). Bundler will manage which versions of gems to use for a specific application, while RubyGems can install, build, and perform other gem related operations. Bundler does have more functionality than this that isn't relevant to this discussion. If you want to open a gem just look inside of your $GEM_HOME/gems path. You can also use `gem which jekyll` to find the path of a specific gem. Of course, if you are working within a project directory which uses Bundler, `bundle open jekyll` would be the way to go, since that will open the specific version that project is using. `bundle show jekyll` will also get you the directory.
I think you have some confusion around the responsibilities of Rubygems (`gem`) and Bundler (`bundle`). They are 2 different utilities. The first `gem` command is telling you "these are the gems that are installed globally" while the second `bundle` command is trying to show you the gems that are installed via a Gemfile. Bundler is used to create "bundles" of gems for specific applications, while just running `gem` shows you the gems that are installed globally. Those 2 different contexts (gem global vs bundle local) do not necessarily overlap. 
My brother-in-law took this course and learned a lot, so he recommended it to me. At first I was hesitant because my disposable income is almost nonexistent and there are other things like Codecademy and Ruby Monk. Well I've taken the Ruby Learning course twice and I can say that [RubyLearning](http://rubylearning.org/classes/) is an **incredible** **bargain**. Zenani covered most of the details. I would emphasize that it's not only Ruby. You can do the side projects that go over the basics of HTML and CSS and Github. They do assume that you already know a programming language, but even without that you can still make it through the course. If you've never looked at code before then it might not hurt to work through Codecademy. They (Codecademy) estimate it to take 9 hours to work through the free course and in doing so you will barely scratch the surface. The best thing about the course is that you have a mentor available to you. The current mentor (Victor) is **really, really good**. Any time that he's online, which seems to be most of the time, you can log on and ask a question, chat, or do pair programming. The pair programming with your mentor is what really sets this course apart. You'll learn quite a bit in a short time. This course is $45 ($70 max). Where you can you find a mentor for less than $150-200 (and for almost 2 months)? Seriously....I looked. I also bought the [PDF](http://book.rubylearning.org/) from Ruby Learning for $10 (again a bargain) which has all the course material. It's been quite helpful. Of course this is *completely optional* as you have access to all course info via the website when you start. If you're happy with the course they offer several other books/tutorials for cheap, some of which you could probably use at the same time. The free sites like Ruby Monk and Codecademy are great, but I think you really miss out from being able to interact with the other participants (especially the mentor) and learn from them and their code. Another drawback is that the automated sites are looking for an answer that tends to be coded a certain way; if you don't do it their way it's wrong with little explanation as to why. Sticking to this you really miss out on *flexibility*, which stifles creativity, and that's something that's key to Ruby (i.e. having many ways to do the same thing). Here's an [article](http://www.forbes.com/sites/women2/2012/07/07/how-i-learned-to-code/) that a previous student wrote that made me determined to take the course.
try gem open ...
FYI, if you have text to post, try something like pastebin...not a screenshot of the text.
Also, a [gist](https://gist.github.com) works well, too.
You could also use `gem unpack jekyll` which will upack the jekyll gem to a subfolder of the current directory: Fetching: jekyll-2.0.3.gem (100%) Unpacked gem: '/Users/pglombardo/jekyll-2.0.3' 
where's goliath?
Be interesting to see before / after OpenCL benchmarks as well.
You don't create classes in javascript... You dont need to that's why node is better
Nope, that gave the following error: ERROR: While executing gem ... (Gem::CommandLineError) Unknown command open
Yup, was simply getting misunderstood! Thanks!
Rubygems itself has a great set of guides on building your own libraries: http://guides.rubygems.org Honestly I'd start there rather than with a third party guide. There's a lot of duplication of content and the official guides are open source so one can submit improvements directly.
Great GBressler. Thanks a lot for your answer, I'll give it a try =) I registered yesterday and I was one of the 10 first, so it was $45 (I must say I imagined more people would take the course... but that's OK). Yes, the mentorship is really what called my attention to this. I've tried codeacademy and codeschool, but this one seemed much more attractive. 
Less of a Ruby issue and more of a SQL issue, but interpolating values to create SQL statements is generally considered a bad practice (ripe for SQL injection, malicious or inadvertant). You should use parameterized queries or prepared statements to fix that, check out: http://rosettacode.org/wiki/Parametrized_SQL_statement#Ruby
&gt; If your gem needs to use some other gems to work after it’s included to a RoR app, you should put it into this Gemfile. Nope. Not entirely sure what this means, but, no. All dependencies needed to run your gem need to be be in your .gemspec. Whether your gem is used in a Rails app or not. Dependencies used only for development of the gem... don't neccesarily need to be in the .gemspec, and there are rare times when it causes a problem to put them in the .gemspec. But as a rule of thumb, just put them in the .gemspec too, as `development_depencency` (that's what it's for!). But every every every gem dependency needed by your gem at runtime needs needs needs to be in the .gemspec -- NOT just a Gemfile. The Gemfile is not really used at all at run/load time, by projects using your gem. Things in there might be useful for you developing, but might as well not be anywhere at all at gem runtime. 
Thanks! Yeah I basically did what worked, had no idea. I'll read up and make it better. I really appreciate it &lt;3 edit: just a followup, so should I be doing more of what I did with the save method to the update method? just making sure I understand the requirement. 
You are using puts for several of your commands. puts returns nil. Keep that in mind when youre doing conditionals.
&gt;edit: just a followup, so should I be doing more of what I did with the save method to the update method? just making sure I understand the requirement. Yup.
have you read the [README](https://github.com/jimweirich/rake)
My programming teacher told me that you have to be an expert programmer to understand Javascript because the language is advanced. And ruby is a toy. That might be why you say it is fun. But in business you have to choose a proper language like node.
My programming teacher says ruby is a toy. He says the man who made ruby made it for his children. In business you need a proper language like node
Yeah that totally makes sense. I don't think I was entirely aware of that one way or another but I can see why now.
Lol, that's excellent.
This is a project on codeacademy but games instead of movies. 
yeah the actual "menu" for the program is the same, I was more trying to get things to actually store to a database, which was something new for me. The menu I also want to rewrite.
Wow you are making a big deal of nothing. 
Man up and learn C/C++. 10 years from now you'll be glad you understand manual memory management, manual thread management and several other important things that languages like ruby, c#, and even Python hide from you. Get a good grasp of advanced c++ and almost every other language will be trivial to learn.
Break it up into small routines and classes. ie some level of abstraction at least. I know the code is not big, but every level of abstraction helps, especially in an interview setting. Also check out Russ Olsen's books on ruby style (eloquent ruby ) and patterns. There's also another book on writing command line apps in ruby though i haven't read that one myself but might be worth checking out atleast for another person's take on commandline apps in ruby. A coding style guide i find very useful is [Ruby Style Guide](https://github.com/bbatsov/ruby-style-guide)
Well, I solved it, though now I am not sure if I solved it by using instance variables in the Shoes buttons, as in: button "Choose..." do @csvname = ask_open_file end instead of button "Choose..." do csvname = ask_open_file end and then passing the instance variable to the method (no class definition required), or if I solved it by discovering that Dir.glob cannot take folder paths containing backslashes, and ask_open_folder returns (at least on my Windows machine) Windows-style folder paths with backslashes. So I had to do a .gsub('\\','/') on the folder path before passing it to Dir.glob, although in testing this just returned zero results, but maybe the error was getting tripped because of that? I am not sure. In any case, it works now. The error I received from green_shoes is super generic and seems to just trip whenever the app ends unexpectedly for any reason at all. Not a great way to log errors, but there it is.
&gt; or if I solved it by discovering that Dir.glob cannot take folder paths containing backslashes Core documentation: 'Note that this means you cannot use backslash on windows as part of a glob, i.e. Dir["c:\foo\*"] will not work, use Dir["c:/foo\*"] instead.' http://www.ruby-doc.org/core-2.1.2/Dir.html#method-c-glob BTW I've heard that the Windows kernel internally accepts both forward slash and backslash as path separators, and backslash is preferred only because of the conflict with forward slash used on the command line to indicate flags.
Thank you, I worked on it really hard before replying here, made huge advances in the ui and the app evolved into something else. I will commit the new updates soon. Thanks for your input, helped me a lot 
Great idea, I'm certain there are at least a few others that will find it useful.
I agree with everything enry_straker said. I'd also like to see some expansion on why you need the code under "Hack because OS X". At least in my experience, I don't often come across the "$:" variable. What if I'm not running your script on OS X? 
It's all practice. If you're a beginner, it's difficult to think in terms of testing, but when you start to incorporate testing into your development practices, you'll see things that don't sit right. For example, you could ask yourself, what is this method doing. If it's doing more than one thing, then it's a sign (code smell) to pay more attention to that method and split things out or think of other ways of doing things. The same applies for classes. If you are describing the responsibilities of a class and you use 'and' in the class's description, then your class could be doing too many things. Just suck it and see and you'll learn. As you get more experience, you'll start to feel uncomfortable with methods/classes doing too many things. But for now, enjoy playing and exploring. Just as an aside: consider using [fetch](http://www.ruby-doc.org/core-2.1.2/Hash.html#method-i-fetch) when accessing values from hashes. It will give you more control and is more communicative for people reading your code.
I would use require_relative. http://stackoverflow.com/questions/2900370/why-does-ruby-1-9-2-remove-from-load-path-and-whats-the-alternative
Shameless self-promoting :) My newsletter: http://greg.molnar.io/newsletters/rake-guide
It's cool but why develop a game in a library style pattern? It seems like it complicates the code for unneeded abstraction into a library pattern. 
It would be better if it didn't use the same name as one of the most widely used free &amp; open source Mail Transfer Agents on the Internet.
This is a really nice native interface! I hope to learn Go in the future.
No real reason really. By making all operands Floats, I avoided the need for extra lines of `if` statements and checking whether a token is an Integer or a Float — which meant optimized performance for the tokenization process. What are the disadvantages of doing this?
Well, no reason to cast to float if you want to do integer math. It also has the subtle errors inherent to floats (`(1.2 - 1.0) == 0.2 =&gt; false`). You may want to check out [BigDecimal](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/bigdecimal/rdoc/BigDecimal.html)
Very cool, thanks, [fixed](https://github.com/rafalchmiel/postfix/commit/1e7ae0b793cde857ae6eeb320a817d0d3b3c4b1d).
Having done my share of *hiring and firing* for a few years, I can tell you that someone who used a well known name for an entirely different project would be less likely to be invited to interview. It demonstrates to a prospective employer; either a) a lack of research, or b) a blatant disregard for others' work as well as potential "users" due to confusion. Excuse me for getting increasingly off-topic for this sub-reddit.
In no particular order: 1. It's a weird design choice to upload a temporary object to the first existing bucket; this could have ramifications if someone is assuming something about the structure of said bucket. Since buckets are free, it's safer to just create your own. 2. "rescue Exception" is super dangerous. You pretty much never want to rescue all exceptions. See http://robots.thoughtbot.com/save-bang-your-head-active-record-will-drive-you-mad 3. What /u/enry_straker said 4. Make it a gem. Gems are cool; they're more maintainable and more re-usable, and can help large teams DRY code across projects. In terms of an interview, showing that you think this way is a big win. 5. Is it common that, when creating a bucket, it sometimes doesn't exist after? If not then I'd drop the guard clause that comes right after. See the thoughtbot article linked above. 6. repeated code between your two scripts should be DRYed Overall not bad. All of my comments center around one thing: strive for the most well-factored code you can (reusable, DRY, structured through simple methods or a full-on OO structure). Look at other popular gems and mimic what they do. Pivotal Labs and Thoughtbot both put out excellently-factored code.
[Fixed](https://github.com/rafalchmiel/postfiks).
Nicely done. Best of luck.
Up-vote because this game gave me years of enjoyment in my childhood. Great job!
If you're looking for more traditional resources, I have a standard set of books I recommend * Refactoring by Martin fowler * Confident Ruby by Avdi Grimm * Practical Object Oriented Design in Ruby by Sandi Metz * Rails Antipatterns * Objects on Rails by Avdi Grimm * Head First Design Patterns * Refactoring to Patterns by Joshua Kerievsky * Working Effectively with Legacy Code by Michael Feathers * Growing Object Oriented Software Guided by Tests by Steve Freeman and Nat Pryce * Domain Driven Design by Eric Evans * Patterns of Enterprise Application Architecture by Martin Fowler * Smalltalk Best Practice Patterns Start your way at the top and work your way down.
Although, `should` is arguably better than `expect`.
Can anyone expand on what these two styles look like?
certainly easier to understand linguistically. but "better"? what's your heuristic for that?
Go go gadget ruby: irb(main):001:0&gt; -&gt; (n) { (1..n).inject(:+) }.call(10) =&gt; 55 EDIT: Explanation: - Concept #1: [Ranges](http://www.ruby-doc.org/core-2.1.2/Range.html): (x..y) will produce a set of values in that range, so (1..3) produces [1,2,3]. - Concept #2: [Enumerable#inject](http://ruby-doc.org/core-2.1.2/Enumerable.html#method-i-inject): Applies a binary operation taking a block to execute, or a symbol for a method to call. - Concept #3: [Procs/Lambdas](http://www.ruby-doc.org/core-2.1.2/Proc.html): An inline function reference that you can execute .call() on, passing the arguments it expects. For example: -&gt; () { puts "hi" }.call will print "hi" In my code we are creating a lambda that takes an integer, creates a set from 1 to the given integer, and then using inject with the :+ method symbol reference to add each number in the set to the sum of all previous items in the set. EDIT #2: Note that Enumberable#inject and Enumberable#reduce are the same method aliased. You will see both used depending on which other programming languages the ruby programmer has used in the past.
See [my comment](http://www.reddit.com/r/ruby/comments/28rap8/true_beginner_question/cidphch) for power ruby solution.
The simple iterative solution above is actually the best way to go imho. It's very simple and very fast. Some of the more "ruby-ish" ways I can think of are: def sum(n) sum = 0 n.times do |i| sum += i + 1 end sum end Another one, which is "elegant" but really wasteful in your case (because you'd have to create an array of numbers): [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].reduce(0) { |sum, elem| sum + elem }
I did. I wanted to create a game using a bitmap to represent the terrian. But it wasn't the right fit and convoluted the code. I've rewritten it to just use an array to represent the heights. Its much more concise now.
Edit: apt-get install libsndfile1-dev libglew-dev libopenal-dev libfreetype6-dev Take a look at the readme for the gem I'm using: https://github.com/Mon-Ouie/ray I'll boot up a VM today and have a try on Linux.
Your first sentence *is* the heuristic. If it isn't, then what exactly is the point of rspec? Isn't it to feel like we're describing our behavior in plain English as we write tests?
It's almost obligatory that we need to have an "are dependency injection frameworks really necessary in ruby?" discussion. Seriously, though, there are already a few IoC containers in ruby. What drove you to write a new one? I prefer approaches that require less configuration, such as [this one](https://github.com/joshuaflanagan/ruse).
How do you use it? Do you just do 'ruby converter.rb myscript.rb' at the terminal?
There are tons of Ruby and ObjC videos on YouTube. Stop staring and start clicking.
There's also fold, if that terminology tickles ya.
In the present script you write the location of the ruby code in the program itself. line 173 you can modify it to accept command line arguments. 
do you have any links to some good ones? the ones i usually come across aren't that helpful
Or use a range. `(1..10).reduce(:+)` _Edit: Fixed range notation._
Best solution in my opinion.
I've read the Gang of Four design patterns as well as Design Patterns in Ruby. As best as I can recall, I'm not confident the Sinatra API follows any of the patterns introduced between those books on it's own. While I haven't read Sinatra source in a couple of years, from what I recall it actually implements a delegate pattern internally. It receives requests and delegates them to their respective responders. The API is a way of registering those responders.
https://www.youtube.com/watch?v=983zk0eqYLY
Looks nice and simple. Does the constructor need to be written manually? Seems like a holdover from less expressive languages.
&gt; n.times oh no.
Ohhhh, alright, thanks.
Try building something you need yourself. That way you have at least one user and you know your needs better than some imaginary future user's. Next time some app or program or library annoys you, start implementing similar thing that works better for your need. 
There is a nice video tutorial on confreaks on basic Rake by the recently passed away author, Jim Weirich: https://www.youtube.com/watch?v=AFPWDzHWjEY
?
house = House.new(lambda { Window.new }, lambda { Door.new}) what's wrong with this? I have a lot of trouble understanding how this library is helping me.
This is the way I'd do it as well. You should use parentheses instead of square brackets though. Does that even run like that?
I you're talking about the constructor for your classes, yes.
 House.new Window, Door
IIRC, rspec was the first spec style BDD tool. The goal was to build a formal specification while you wrote your test. The DSL was designed to mimic English, and output English sentences when you run the test suite. But you're right, that is probably no longer the goal of rspec. Alas, they're more concerned with dumping hundreds of thousands of human hours into switching from `should` to `expect` because "less monkeypatching."
You could set the dependencies yourself. In fact, for something as trivial as the house example, you might be better off. When the number of classes you have starts to grow, manually setting the dependencies yourself becomes a pain in the ass. Also, in the example in the README, the house, window and door objects are single instance objects. That may not make much sense for a house, but it does for more complex applications. The point of dependency injection is to decouple the bootstrapping of your application from the rest of your application. Doing this, you end up with a pile of code that is your application and a pile of code that bootstraps your application. The pile of code that bootstraps your application is pretty generic and can be partially extracted into a library. Jerry is that extracted library.
I work at a coding bootcamp that teaches a non-traditional way to build rails apps where code is highly modularized and follows a similar pattern to what you describe here. Our hope is that if you teach proper design at the beginning then people will be better developers later on. It is very challenging teaching these concepts to beginners and I was wondering if you had any advice on it. Most people new to programming don't understand what it means for an application to be *tightly coupled* or what *module dependency* is and so they have to experience it to understand it. 
The map here is completely unnecessary. Ruby will unpack arrays when doing multiple assignment. E.g &gt; first, last = "Zach Siri".split(' ') Works just as well. Also, if you said &gt; first, last = "Zach Siri Go".split(' ') Then 'first' would be "Zach" and last would be ["Siri", "Go"]
I think something like (1..10).to_a.sum works. To explain, (1..10) is a range .to_a turns it into the array [1,2,3,4,5,6,7,8,9,10] .sum sums the array. Also could try without the to_a. I'm not sure if it's necessary
&gt; (1..3) produces [1,2,3] I think this is misleading. Range and Array are 2 different ruby objects, albeit similar. That is, [1,2,3] == (1..3).to_a returns true 
You are correct, I was not intending to imply that it returned an actual array. 
Why I didn't read your blog: Cat pictures everywhere instead of useful examples on how to avoid/why to avoid using them. If you're going to advocate something like this you need to do more than just say it, show it off!
Ha, no, it's an array with a Range as it's only object.
For my learning project, I build a gift registry (birthday's and Xmas). My family uses it to prevent duplicate gifts. :)
I didn't think so, but I wanted to clarify for OP
What is this bootcamp called?
I'm not a fan of concerns for models but I have found them useful for certain controller code.
He wanted only the first letters, not the whole names. There were other unnecessary things though. ' ' and n[0]: first, last = 'Zach Siri'.split.map(&amp;:chr)
Is good design something that can be taught? You can tell people, "do it this way, because in 2014, this is what most people agree works best." But all the folks that got us here (including ourselves) had to go through a certain journey to be able to understand tradeoffs. How do you avoid merely teaching students to cargo cult the "best practice de jour?"
I feel like cargo culting is sometimes OK when teaching new programmers. Case in point: TDD. I learned how to code by TDD as, "this is how it's done," much like CPR for medical folks. It's simply how one "does it right" as the current best practice. Sometimes we have to question our practices, though, just like how [CPR gets questioned every so often](http://www.health.harvard.edu/fhg/updates/update0605c.shtml) and sometimes those [recommendations change](http://www.global-medical.ca/content/new-update-cpr-best-practices-american-heart-association). At least we won't likely ever have to argue about whether or not CPR is dead! To me, TDD is for programming was [the J-stroke is for canoeing](https://www.google.com/search?q=j+stroke): not absolutely necessary, but you're going to have trouble it you don't learn it and do it right sooner than later. Oh, and good teachers teach it day two. Day 1 is "here's a canoe! paddle! here's a text editor! use the REPL!" Once the student understands the basics and the best practices, she's free to experiment and perhaps eventually learn the hard way why the best practices are recommended. Ever do a project "just as a prototype" and skip TDD, only to incur significant technical debt later on when the prototype goes into production?
&gt; "Once the student understands the basics and the **best practices**" This is the problem... "best practices" have an incredibly short shelf life. A few years ago, TDD unlocked a huge productivity gain for me, for sure, but it's so much more important that we keep our eyes peeled for the next big thing. Unfortunately, as a community, these days we're more concerned with shrinking our test feedback loop from 800 ms to 300, and replacing `should` with `expect` because, we're told, "monkeypatching is bad." I worry about raising a generation of programmers to believe that "following suit" is the most important part of our job description. Your point is well taken, though, beginners absolutely need to start by cargo culting. I sure as hell did. But I'm not sure anyone took my cargo culting and promoted it as "good design."
I like the presentation, but the lack of prepared statements makes me nervous. Take slide 32 for example, is this an exercise in sql injection?
For ruby, reading [these](http://www.ruby-doc.org/core-2.1.2/) now and then helps a lot. Actually, I do the same with the SVG, HTML, CSS specs as well. Every time I read new things, somehow. More generally, you could try to start thinking in design patterns (there's a good book on that for ruby), metaprogramming (especially if "less code" as a measure is your thing), and trying out other programming paradigms (like, pure functional, pure OO, declarative style programming, specific DSLs) or languages.
&gt;There's no real downside to having a bunch of small classes managing your business logic. There is one downside and that's garbage collection which is the cause of most ruby performance problems.
I might add, the simplicity you are seeking is in code readability and understanding. At a certain point you will be able to refactor your code to the point where its small and understandable. If you were to decrease the size again and make the understanding more complex, you've gone too far. I think sometimes people are a little too worried about making things as small as possible. The problem you run into is eventually you have to perform "magic" on your code to get it even smaller. If you hand off your code to another developer they may get lost trying to understand the purpose of the code when trying to understand what you are _actually_ doing. Your goal should be to make everything as simple as possible. That might mean your code is a little bit big, but as long as others (or future you) can understand what is going on then you are still on target.
Two, Two word answer for me: pair programming and code reviews.
wow this looks freaking awesome... thanks for the share.
Make it work; make it right; make it fast. Don't try to do them all at the same time.
they are talking about [classic vs. modular style](http://www.sinatrarb.com/intro.html#Modular%20vs.%20Classic%20Style).
I've been programming for quite a bit of time at this point, and the only way to get really good is to work on hundreds to thousands of projects and write an extreme number of lines of code. Nothing beats experience. This applies to just about everything in life. Now, the best code is produced when the system you want to make is fully fleshed out mentally. At that point, the code you write will serve pointed purposes as you code out every element of the system. The problem with this is software systems can be extremely complex. Making an entire one on your own is a huge task, but many people have done it successfully, including me. It can be done and it can be written well. It feels good to produce a large system, at least for me. I highly recommend doing it. The important thing is to accept the fact that you will want to change things eventually, even to parts of the system that at the time fulfilled their purpose and need. This is something you accept as part of the practice, especially given that there are an infinite number of ways to implement something, but in reality only a few good ways of implementing something, and even fewer ways of implementing something that does exactly what it needs to and nothing more while still supporting future enhancements and changes. Remember, its not always neccessary to write code that is concise, optimal, or readable. However, it's likely that ensuring you have those 3 elements as attributes of your coding style will produce a better system in the long-term.
Test Driven Development (TDD). It's almost magical in the way that it helps you design your code. The code I write this way is often entirely different than when I use a code-first approach, but is more correct, concise, and readable, which is what you're looking for. As a bonus, it's also completely tested (giving confidence in its correctness) which allows for refactoring at will -- which in itself is an excellent practice for improving your development skills and is what allows you to push towards concise and readable. ([The three rules of Test Driven Development](http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd).) Combine that with the idea of keeping functions small. One-line functions are awesome! I once took two dense lines of ruby code and turned them into about 10 one-line functions, with the result being that the code was instantly readable and understandable to a non-ruby developer, whereas he had only questions about the first solution. I was pushed in that direction by TDD. Keep classes small. Less than one or two screens of code. Keep modules small. Keep everything small so it can be tested and understood in isolation, leading to high cohesion and low coupling. Make your code self-documenting by using accurate and concise names for your classes, functions, and variables. Completely avoid any other use of comments! (Seriously.) Avoid case statements and large if-statements in favour of polymorphic inheritance. Generally avoid repeating yourself in your code, i.e. keep it [DRY](http://deviq.com/most-popular-principles/don-t-repeat-yourself). Get mentored, whether that's through pair programming, code reviews, taking classes, or watching presentations / reading blogs of amazing developers. All of the above is covered very well by the [Clean Code](https://cleancoders.com/category/fundamentals#videos) video series. RailsConf 2014 has some amazing presentations. And practice, maybe at a site like [Codewars](http://www.codewars.com/)?
Thanks, I see. Would it be accurate to say: classic is writing your application in global scope while modular is defining your application in the scope of in Sinatra::Base or Sinatra::Application? Does the classic style conflict with using the application as middleware? If not, what is the actual benefit of classic style?
is this your project? You have a typo &gt; monhts
This looks awesome.
&gt; If you use Lotus, you employ less DSLs and more objects, zero monkey-patching, separation of concerns between MVC layers. Halle-freaking-lujah.
&gt; I should probably change $: to $LOAD_PATH, but essentially that shouldn't do anything on most systems, but on my machine the local directory isn't loaded, which I need for require 'config/aws' I didn't know such a thing existed. That change is in the last commit. 
Sure. Here's some motivation. Do it and become an apprentice wizard. Over time you gain your knowledge and eventually you become [the most bad ass wizard ever...](http://fc09.deviantart.net/fs71/i/2012/204/8/2/raistlin_majere_by_akiranao-d589vxm.jpg) Start with rubykoans and ruby monk. Then learn Metaprogramming in Ruby, as well as Ruby under a Microscope. Never give up, never surrender.
That style guide was very helpful! I'm going to take a peek today and refine the s3 upload script. I know there's some optimization to be done there.
I'm currently reading Eloquent Ruby by Russ Olsen. It seems like this book covers your question very well. When it comes tu ruby obviously. For general overview, I would recommend Clean Code.
Definitely looks really cool. Needs some things like live reloading and environment support before it's mature enough for me. I really like the direction of the project though.
Forgive my ignorance - I'm currently learning both Ruby and Rails. Would Lotus be considered an improvement over a framework such as Rails or Sinatra? If so, why? 
I'm still not sure if this is a problem, but I confess I fell a little uncomfortable about duplicating modules. I have been trying to come up with a better solution but still didn't find any reasonably good option :(
I'm not sure I understand why Bookshelf::View needs to do anything other than pick up some Bookshelf-specific configuration and include Lotus::View as a module. From the project's otherwise healthy suspicion of this sort of magic I'd imagine there's a good reason, but I don't see it.
I'm still new to web frameworks, how does this differ from Sinatra and the like? Cheers, Louis
The differences are perhaps a little subtle for a true beginner to understand. I don't know enough about Sinatra to comment, but Rails is by design an "opinionated" framework. Which is to say that you implement everything The Rails Way or waste a lot of time trying to get it to do something else. Lotus, based on its mission statement, aims to avoid that. It's trying to say, "We're based on a Model-View-Controller pattern, but other than that we won't dictate your application's architecture at all."
I think this is in serious need of an eplanation of how to actually build an app with it. The individual components look nice, but how does it all fit together?
Along with what tobascodaagama said, Sinatra is just a DSL for writing the router and controller layer of your application(though you could separate those two if you wanted to). It isn't even really MVC. From what I can tell, Lotus is aiming to be more purely object oriented than Rails, along with having a smaller API. If your application strays far from the architecture Rails expects you to take, then Lotus could be a good alternative. Obviously Rails works really well for a great number of websites(i.e. user-based CRUD systems), and Lotus's fortunes won't change that fact. Personally I look forward to using Lotus, loosely coupled OOP is hard in Rails, and I want to feel free to swap out components in my application without worrying I'll make the whole thing blow up.
Cool, this seems like it will be a nice alternative framework for Ruby - thanks.
I really like Rails and I think I'll continue with that until I'm a little more comfortable. But i would really like to try out Lotus at some point in the future. I like the documentation and it seems like it might be simpler to get started then I initially thought. From what I read the plan is to keep the core libraries to under 500 lines of code - so that may make it a heck of a lot simpler to get a handle on how the guts of it work. I would love to see a section of the Lotus site devoted to small tutorials - for example, how to build your own JSON API with Lotus.
You are right about the code part. But why does everyone push thoughtbot? You don't need to pay someone to teach you ruby. Look up basic tutorials online and make a shitty app. Then check out books like Eloquent Ruby, Mislav's guide, and Metaprogramming in Ruby. Shitty app -&gt; Read -&gt; Repeat.
I learn a lot by reading other people's opinions and code. I post this around quite a bit, but only because I truly believe in these resources. I have a standard set of books I recommend * Refactoring by Martin fowler * Confident Ruby by Avdi Grimm * Practical Object Oriented Design in Ruby by Sandi Metz * Rails Antipatterns * Objects on Rails by Avdi Grimm * Head First Design Patterns * Refactoring to Patterns by Joshua Kerievsky * Working Effectively with Legacy Code by Michael Feathers * Growing Object Oriented Software Guided by Tests by Steve Freeman and Nat Pryce * Domain Driven Design by Eric Evans * Patterns of Enterprise Application Architecture by Martin Fowler * Smalltalk Best Practice Patterns
Sinatra in many ways is an even more paired down version of this. Its just a router and some helper methods for doing things like auth and template rendering in the dsl. Everything can be swapped out easily. Bigger projects with it kinda turn into roll your own rails usually using DataMapper or Sequel as an ORM. 
...and just saw this in the [`Lotus::View`](https://github.com/lotus/view) repo README: &gt; It's based on a separation between views and templates. &gt; &gt; A view is an object that encapsulates the presentation logic of a page. A template is a file that defines the semantic and visual elements of a page. In order to show a result to an user, a template must be rendered by a view. (fist pumping air energetically) Yes! Oh, *yes!* You've just made one of my Top Three Monorail Pain Points completely *irrelevant!* I'm not about to rewrite two years' worth of Rails apps overnight, but this goes high atop my "New Tools to Investigate" list with a view towards new projects. I firmly expect, however, that there'll be multiple *new* pain points to smooth over in such a new framework. That's *not* a ding against Lotus or Luca or anybody else; *any* new project is going to go through some turbulence on the way to sublime awesomeness.
You can read about initializing Time objects in the Ruby doc - http://www.ruby-doc.org/core-2.1.2/Time.html The Time#new method shows how to create the objects using any date or time. Then you can just subtract one from the other and use the to_s method to get a string out. 
There are probably gems to handle it, but to give you a start on figuring it out for yourself... require 'date' future = DateTime.parse('2020-11-29') # =&gt; #&lt;DateTime: 2020-11-29T00:00:00+00:00 ((2459183j,0s,0n),+0s,2299161j)&gt; days_apart = future - DateTime.now # =&gt; (22557818741011/9600000000) # that's 2349.772565086007 days # divide by 365 to get 6.437733055030156 years for some weird reason, you can't access DateTime until you require 'date', but after that, you can parse a static date using `DateTime::parse` and then subtract another DateTime object (this time using `DateTime::now`), et voila, days apart. You can then do some math on that to get an approximate difference. You could also just use the `#year`, `#month`, and `#day` methods on your DateTime objects and do it that way, though it might take a few more lines of code.
##One way to do it (maybe not the prettiest, but it works): 1. Install the 'rails' gem 2. Make sure you have ActiveSupport installed 3. Install the 'dotiw' gem (Distance Of Time In Words) ##Create a ruby file: ------------------------------------ require 'action_view' require 'active_support/time' require 'dotiw' include ActionView::Helpers::DateHelper distance_of_time_in_words(Time.now, DateTime.parse("2020-11-29"), true) ------------------------------------ =&gt; "6 years, 5 months, 5 days, 18 hours, 2 minutes, and 38 seconds"
Not at my laptop, so can't try it myself, but when you do the subtracting, is it another DateTime object that's returned or is it just the int (guessing epoch time)? If it's another DateTime object, try using the strftime method to get the format you want. Should be able to do days_apart.strftime("format string goes here") Otherwise you can probably do a DateTime.parse() around the int and use strftime from there 
It returns a Rational (so a fraction, same as in the following comment) representing the number of days between the two dates. iirc, Python would return something like a TimeDelta that makes this insanely easy. Too bad Ruby doesn't do the same.
I just used **lotus-router** but it was great
Good work! I love it when people make fun, useful stuff (whether it's with Ruby or not).
It's best not to try to express things in terms of years or months if you need exact spans, because they're not constant values. Its value changes based on its position in time. for example, june has 30 days, july has 31 days. 30 days from june 30th it will be july 30th, has a month elapsed, or is it one day short? Which value for a month is considered valid?
I'm mostly just using it for a counter on a website. you give it a date, it gives you back how many years, months, and days until that date.
Okay so I'm getting an error when I try to run the [one file application example](https://github.com/lotus/lotus/blob/master/README.md#one-file-application). Am I retarded or is something going wrong here? $ ~/Projecten/lotus_test% ruby config.ru config.ru:13:in `&lt;module:OneFile&gt;': uninitialized constant OneFile::Controllers (NameError) from config.ru:4:in `&lt;main&gt;' 
You can also look into implementing that in javascript, but if it's Ruby you really want to use, either of the answers above should do. 
I hadn't tried it and thought rackup would work some magic but no, it forced me to look at lotus since I was curious. The problem with ruby is one can never be certain what magic is being wrought behind the scenes but given there is no Controllers namespace within the OneFile module that's the cause of this error. However the docs say: *For instance, when a Bookshelf::Application is loaded, Lotus::View and Lotus::Controller are duplicated as Bookshelf::View and Bookshelf::Controller* That doesn't seem to be happening. Perhaps the docs are out of date or the rubygems version is behind those on github. I'll await the example applications I think.
Documentation is wrong, it's fixed with this PR https://github.com/lotus/lotus/pull/8 EDIT: Aaand here is a Gist of a working example https://gist.github.com/Calyhre/ae54117b4dc3aecac882
/u/Calyhre below just updated the readme (I think it was that user anyway), apparently it was outdated
aSave is not a part of my use case :) only these two definitions :) because we have to create large project in 14 people :P 
its still bad code. That should of been removed in a code review.
I have added your code but I have always error that doctor is not working, I have added Schedule and DoctorWorkplace to DB:( I have added Schedule.id =7 : doctors_workplace_id=7 day_of_the_week=2 start_working="10:00" end_working="16:00" and DoctorsWorkplace.id=7 doctor_id=1 I try to add appointment for doctor with id=1 on 24th June(Today -Tuesday) at 13:05
The easy Rack compatibility makes this at least somewhat nicer. You have the option of either doing an "internal rewrite" (temporarily) using Lotus::Model and Lotus::View under a Rails controller *or* mounting up a full Lotus app and having it answer the URLs it's taking over. Either way you can go piecemeal instead of stopping everything for one giant rewrite.
&gt;The examples in the slide deck assume you have sanitized input against SQL injection and are not recommended for use in production without testing the security of your sql statements.
Here is my actual def: if DoctorsWorkplace.joins(:schedule).where("schedules.day_of_week= ?", visit_date.wday).where('start_working&lt;= ? and end_working&gt;= ?', visit_time, visit_time).where("doctors_workplace_id = ? ", self.id).empty? self.errors.add(:doctor, message: 'not working!') end
Maybe error because of date is date_time_field and time is time_field? Could you tell me how to change this to use only date_time? 
thanks for the hint - I did not count that in ... 
I have tables in DB and I have added data Schedule.id =7 : doctors_workplace_id=7 day_of_the_week=2 start_working="10:00" end_working="16:00" and DoctorsWorkplace.id=7 doctor_id=1 . I think error is because I use date_time_field to put date and time_field to put time, I could use inly date_time but how to change this def? 
Sorry, dont have a lot of time right now to help you. Have you tried converting dates and date times? http://apidock.com/rails/String/to_datetime http://apidock.com/rails/String/to_time
This seems to be paraphrased from the "Delivering Results" chapter of [Confident Ruby](http://www.confidentruby.com) right down to the choice of introductory quote ("Be conservative..."). 
That's pretty scummy. People will do anything for karma, I guess. =/
My interpretation of the post, of course, is not proof... but it would be totally acceptable to me if the author introduced the post as, "I learned some interesting things from XYZ book. Here's an example [current post follows]. And here's a link to buy the book if you want more like it." Or if the author happened to be OP and could explain it's just a coincidence... 
my thoughts exactly.
It sounds like maybe you're not familiar with what dependency injection is for... http://tutorials.jenkov.com/dependency-injection/when-to-use-dependency-injection.html 
That's actually a really good idea, Dohxuul. I'm going to try that down the line. Thanks!
Maybe I have forgotten about checking if doctor_id in doctor_workplaces = doctor_id from form? I don't know, please help :P
are you using rvm/rbenv/chruby? install bundler : gem install bundler then run bundle install.
Totally unintentional, but you're absolutely right :-/ Confident Ruby is one of my favorite Ruby books, and I recommend it every chance I get. But this specific thing is also something that our team has been talking about a lot lately, and that's one of the ways I get ideas for posts, so I didn't even think about the specific place the thought originally came from. Re-reading that chapter in Confident Ruby, though, yeah, it's uncomfortably close, and I'm definitely going to take macktastick's suggestion below and add that phrasing to the post. 
Aaaaand I just realized that you're also macktastick! So yeah. *Your* suggestion :-)
This seems really good, I'll use it on my next project I think
The "Be conservative..." quote is old as computer science itself. It doesn't mean @justinweiss 'paraphrased' Confident Ruby. It's not unusual for two people to come to same conclusion independently, especially when that conclusion is the correct one.
Very cool, dude. Nice edit! 
The RFC you are looking for is... http://www.ietf.org/rfc/rfc1958.txt
Please do not follow that principle. Be conservative in accepted input, as well as your output. Have a simple API. Expect a specific input consistently. 
Yeah, this is one I've definitely done a few times. It often seems sensible at the time, but the first time you need to refactor the code covered by the test...
Having a simple api != limiting input options. Please explain your position more fully since you are going against the grain here. 
You need to post the errors
There are a lot of old popular gems, and some unfortunately some current ones, that don't have great Windows support. Most of this is because of the way Ruby is distributed on Windows. On *nix systems, Ruby is basically compiled on the local system as it's distributed. As such the tools to build native C extensions, on in the case of RubyInline some C code is compiled at run time, are already there. On Windows this is a much harder to get an "assumed" environment. So I don't know how the `png` gem works, but I would guess it's looking for an "assumed" environment. If you're using the [RubyInstaller distribution](http://rubyinstaller.org/downloads/) (If you're not I suggest you do), then make sure you also install the appropriate DevKit for your installation. The DevKit sets up an environment similar to *nix systems and allows you to compile C extensions. Short of that you can try some pure Ruby gems like [chunky_png](https://rubygems.org/gems/chunky_png).
I'm very excited to get to be a part of it too. I saw you pop in to our chat room while I was AFK. Feel free to hit me up with any questions you might have.
Spot on. Audience, give a shout out if you've *never* had a big-bang rewrite go pear-shaped over something you knew about but presumed would Magically Go Away&amp;trade; *because* you were doing a big-bang rewrite? *(crickets, and an embarrassed shuffling of feet)*
You'll need to post the errors you're getting if you want help. I will note that Ruby support for Windows is basically nonexistent. Chances are you will have to get a linux vm running if you want to do a lot of ruby.
Never, ever run benchmarks on localhost. Race conditions make the data unusable.
good point / I could fix this by using some kind cpu affinity (but still be I/O bound somehow) or just run them on a diff. VM
Nice one! Bullet (https://github.com/flyerhzm/bullet) is another one in my collection.
I've heard that leaving the server as Web Brick is a terrible idea for performance reasons, What's a good alternative for that, and is it as a simple as installing a gem?
Thin, puma or unicorn. All are pretty easy to set up. 
unicorn/passenger - for MRI | thin/rainbows - for MRI with slow responses | puma/torquebox - for JRuby and Rubinius
nice read on the issue: http://blog.salsify.com/engineering/automatic-eager-loading-rails
You could try going to a local Ruby User group and meeting some ruby devs in your area. I was in a similar position to you a year ago and I rented a coworking desk in a Tech Incubator which gave me a chance to meet some early stage companies that were using Rails. A lot of young companies that need help are too busy to write/post job openings, but that doesn't mean they aren't looking for enthusiastic staff/interns.
Just tell them you can make dynamic webpages very quickly. Unless they express an interest in the actual technologies they likely won't need to know much more than that.
Would need to be a well paying internship! haha, am in a senior position at my company now. I'm not sure what Tech Incubator is, is that a regional thing?
Im finishing up a boot camp right now. If you have any questions feel free to message me.
I agree with SkepticalMartian.. Just sorta skip on the surface...they probably don't care as much about details if they aren't too technical. 
`rake db:test:prepare` will do most of what you want. Then you could set up database_cleaner to clean the database after the tests have been run: RSpec.configure do |config| config.after(:suite) do DatabaseCleaner.clean end end
png depends on inline so that's likely the first error you saw. It appears that inline doesn't work with Ruby 1.9.3 on (Windows at least) which is your second error.
Yes, I am a newbie. Thanks for the encouragement! I agree with you, hands-on experience is essential, but there must be a more efficient way to become better at problem solving. 
If your code looks like this: string = "hello, world" puts string.reverse string = "foo" puts string.reverse A method version would look like this: def my_reverse(s) s.reverse end puts my_reverse("hello, world") puts my_reverse("hello, world") I'm not sure if that is what you are looking for, but it is my best guess.
Ive looked for something like what you are talking about; Ive found nothing. Maybe someone else knows something. Pair programming helps.
Thank you, this will be helpful!
Everywhere I was looking, I was being told to run bundle install, but it turns out if you just require 'bundler/setup' it'll create a Gemfile.lock for you. Then I had some github issues, because I really don't know anything about Github, but that was it. 
Maybe it is a regional thing, in Scotland it's just a building with lots of early stage tech companies inside! I'm sure with an ops background you'll do fine. Sorry I wasn't much help! 
Look at other solutions to the problems you have had so that you start to build up a library of alternate approaches. They can be your own or someone elses. e.g. using regexs is a common method: 1234567.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse Personally though regexs are a tool of last resort and my approach would be more functional: l = lambda { | s, e | (a = e%1000) &gt; 0 ? l.call(s, e/1000) : return; s &lt;&lt; a} l.call([], 1234567).join(',') The rails programmer would think in terms of what active support has to offer though: require 'active_support/number_helper' number_helper.number_to_delimited(123456) Whilst the procedural coder might come up with something similar to: num = 1234567.to_s i = num.size arr = "" while i &gt; 0 if i &gt; 3 arr = ",#{num[-3..-1]}" + arr else arr = num + arr end num = num[0..-4] i -= 3 end puts arr All satisfy the same basic problem (not checked for bugs) but are VERY different and have advantages and disadvantages. Learn what those are for each solution (edit: not *these* particular ones, the ones *you* discover/research) and you'll find you build up a mental toolset that you can apply across a range of problems. P.S. Probably the ruby way: 1234567.to_s.reverse.chars.each_slice(3).map(&amp;:join).join(',').reverse
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Problem solving**](https://en.wikipedia.org/wiki/Problem%20solving): [](#sfw) --- &gt; &gt;__Problem solving__ consists of using generic or *ad hoc* methods, in an orderly manner, for finding solutions to problems. Some of the problem-solving techniques developed and used in [artificial intelligence](https://en.wikipedia.org/wiki/Artificial_intelligence), [computer science](https://en.wikipedia.org/wiki/Computer_science), [engineering](https://en.wikipedia.org/wiki/Engineering), [mathematics](https://en.wikipedia.org/wiki/Mathematics), [medicine](https://en.wikipedia.org/wiki/Medicine), etc. are related to mental problem-solving techniques studied in [psychology](https://en.wikipedia.org/wiki/Psychology). &gt; --- ^Interesting: [^Elementary ^arithmetic](https://en.wikipedia.org/wiki/Elementary_arithmetic) ^| [^World ^Chess ^Solving ^Championship](https://en.wikipedia.org/wiki/World_Chess_Solving_Championship) ^| [^Future ^Problem ^Solving ^Program ^International](https://en.wikipedia.org/wiki/Future_Problem_Solving_Program_International) ^| [^Morphological ^analysis ^\(problem-solving)](https://en.wikipedia.org/wiki/Morphological_analysis_\(problem-solving\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cih50wr) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cih50wr)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
If by "efficient" you mean "learn algorithmic patterns/solutions as quickly as possible no matter how difficult the approach may be", then the most efficient would be to take a crash course in competitive programing. * First get your Data Structures and Algorithms down pat. If you're not a CS grad, this means reading and understanding large portions of [TAOCP](http://www-cs-faculty.stanford.edu/~uno/taocp.html) and [CLRS](https://mitpress.mit.edu/books/introduction-algorithms) or similar books. (CS grads just need to review via [TopCoder tutorials](http://www.topcoder.com/tc?d1=tutorials&amp;d2=alg_index&amp;module=Static) or [The Hitchhiker’s Guide to the Programming Contests](http://comscigate.com/Books/contests/icpc.pdf).) * Solve dozens of [TopCoder](http://www.topcoder.com/)'s Algorithm practice problems, starting from the High School division (TCHS) then moving on to the SRMs. The site's UI is kinda wonky so you may have to refer to the [help pages](http://help.topcoder.com/data-science/competing-in-algorithm-challenges/) to learn how to start the arena applet. * Refer to the problem analysis (for [TCHS](http://community.topcoder.com/tc?module=Static&amp;d1=hs&amp;d2=match_editorials&amp;d3=archive) and [SRMs](http://apps.topcoder.com/wiki/display/tc/Algorithm+Problem+Set+Analysis)) in case you're stumped or if you want to see if your approach is optimal. By the time that you can already solve [Round 2 problems of previous Google Code Jams](https://code.google.com/codejam/contests.html), you've already spent months squeezing out every drop of your brain learning all of these algorithms. Think you're ready for software development now? Nope. Software development is a different beast altogether, where optimal algorithmic solutions are often impractical, and you'll need to learn a different set of patterns and idioms altogether. So yeah, problem solving is hard.
Read code. Write code. Do it some more. 
Don't know what you might actually use this for, but found the "range reduction" coding problem, and thought it would be fun to gemify it.
Scrape an api? Can't you just ask it for what you want? 
OMG, github project with hundred of files?! OMG, *gemify it*?! Please, stop throwing this shit into internets. Problem is solved with just an `Enumerable#chunk` oneliner.
Passenger works great with JRuby and Rubinius too.
No you don't. JRuby and Rubinius support are in open source. Where did you get the impression that you need Enterprise for that?
Here's a solution using enumerable: p [-3, -2, -1, 1, 2, 4, 7, 8] .each_cons(2) .chunk { |a, b| a + 1 == b } .map { |c, nums| !c ? nums[0][-1] : (nums[0][0]..nums[-1][-1]) } 
With 25 years of coding experience I think I can safely say those kinds solutions to the problems are like party tricks. Sometimes useful, sometimes really helpful but they're just one of the many, many tools programmers need to know. If you figured out a working solution to the problem, you solved the problem 100%. That was the hardest part. Problem solving is a much more useful skill than knowing 100 party tricks :)
When I dove into Rails a few years back, I leaned Ruby first and I have yet to regret it. The Rails framework is quite large and contains most of what you need, but understanding the core language is extremely important. I suggest the pickaxe book. It's typically called the pickaxe book because of the cover, but I think the actual name is Programming Ruby. Pragmatic Programmers has it and it will come with plenty of free updates.
Yes. /thread
Definitely. In fact, the more time you spend learning Ruby, the more awesome you will feel about yourself when you actually get into Rails. If you get really comfortable with Ruby and OOP, Rails will just make sense to look at. source: me.
I dove into Rails before learning Ruby. I didn't understand it so I hated it and gave it up. I'm back to learning Ruby now and I'm loving it. I don't have an immediate need for Rails so I'm enjoying Sinatra/Padrino and other things first. I'm enjoying making my own gems and CLI apps, playing with Jekyll, and learning ActiveRecord from scratch. I'm getting a lot of small projects done for my own needs. I can't wait to pick up Rails in the future again because now I'm finally beginning to understand what it was trying to solve.
Always
Do you have prior programming experience? If no, then yes. If you do, then it's not necessary. HOWEVER, you will want to read a good ruby book after your first rails one to fill in the blanks
Would you also recommend learning HTML and css before rails? Ive been practicing python for a while so learning ruby has been good fun but some of the html/css stuff in rails confused me. 
of course ;)
Always (Period)
But that paragraph has got nothing to do with JRuby or Rubinius. Multithreading is not necessary for, nor related to, JRuby and Rubinius support. Multithreading is just a concurrency mechanism, nothing more. It does not imply support for specific Ruby implementations. Here's how it works: unless a feature is explicitly documented in [the manual](https://www.phusionpassenger.com/documentation/Users%20guide%20Nginx.html) as an Enterprise feature, it's open source. See section [Supported operating systems and languages](https://www.phusionpassenger.com/documentation/Users%20guide%20Nginx.html#_supported_operating_systems_and_languages).
(prepare for the downvotes) I learned rails and ruby at the same time with rails using [this book](http://www.barnesandnoble.com/w/agile-web-development-with-rails-4-sam-ruby/1115448409?cm_mmc=googlepla-_-book_25to44-_-q000000633-_-9781937785567&amp;ean=9781937785567&amp;isbn=9781937785567&amp;r=1). At the start, they give a chapter on Ruby just so you can understand the basic syntax and then jumped right into Rails.
Is the environment variable `MONGO_URL` or `MONGOHQ_URL`? In that Ruby code, the value of `uri` is `ENV['MONGO_URL']` - the environment variable. This is one of the connect lines: https://github.com/MongoHQ/mongohq-openshift-quickstart/blob/master/quick_start.rb#L100 I assume the Mongo URL environment variable has an address similar to "'mongodb://localhost:27017/'"? If you're not already, you could just SSH into your openshift app, startup a python console and test it directly to make things quicker... Then you could validate that mongo is really running/listening on your OpenShift app via `netstat -tulpn` /few ideas
updated, MONGOHQ_URL is just plain URL variable to mongohq. Since it failed, I added environment variable as MONGO_URL. this wouldn't be connecting to local mongodb: 'mongodb://localhost:27017/' ?? and also how did you come across this string? its not present in the code. def test_connection_string_valid(uri) uri =~ Moped::MongoUri::URI end who is calling above functions and what it is sending as URI? and yeah, above log is from ssh console only
Great suggestions. Thanks. I haven't read it yet, but *How to solve it by computer* by R.G. Dromey seem to be good. The book is dedicate to G. Polya :)
Multithreading does not require a Ruby implementation without GIL. Multithreading works fine even with a GIL. The only thing the GIL does, is preventing your threads from using multiple cores. But otherwise, threads still work fine: even with a GIL, when a thread performs a blocking I/O operation, the Ruby interpreter will still preempt to another thread. We run all our production sites on MRI with multithreading enabled. It works great.
&gt; ...and also how did you come across this string? its not present in the code. That just a standard mongo connection string. &gt; who is calling above functions and what it is sending as URI? Ruby is using `send` to call the methods [here](https://github.com/MongoHQ/mongohq-openshift-quickstart/blob/master/quick_start.rb#L56). It's takes every element in `CONNECTION_PROCESS` builds a method name by prepending "test_" with `"test_#{step}".to_sym` and then calls that method passing in `ENV['MONGO_URL']`. That Mongo URL you updated the post with looks good. OpenShift is extremely locked down in terms of security. It's possible that this is not a python issue and you are really getting permission denied for some reason external to Python. Can you connect to that Mongo URL using other tools? Even testing with netcat may provide some useful info: netcat -v kahana.mongohq.com 10034 That should indicate if you even can make the outgoing connection to that host and port...
There is no point of reimplementing `#sort` in Ruby, since (it would be slow + it would be unreadable = it is nonsense). Ofcourse, unless you have no clue in programming and don't even know the simplest thing -- **use proper tools, proper languages for specific tasks**, and the only thing you can do is shitting into internets, wasting time of those, who aren't the same useless.
This is a question for /r/python or the MongoHQ support team.
Wow, I actually never heard of that one. Id have to read it sometime.
Magic.
Still a terrible idea. Ruby is a great language but its syntax alone can be tricky for beginners to learn (optional brackets around method parameters, begin/end/{/} ambiguity, implicit hashes, etc). Rails is a great framework, but it's deeply, *deeply* magical and written in a way that seems *actively obtuse* at times. It's not - it's just written in a way that allows you solve many common tasks in what amounts to a collection of specialist DSLs designed for the purpose, but that's only possible because it hides significant complexity under the covers, intentionally obscuring *what* it's doing and *how* it's doing it in order to present a simpler interface to the developer. That's great once you know what you're doing, but if you're still trying to learn Ruby (or even just Rails) then it's actively unhelpful.
Learning both together worked for me, coming in from knowing a few other languages first. Having Rails and a project I wanted to get done helped focus my learning.
yeah, thats standard Mongo connection string, however you have to pass Mongo HQ Url if you want to connect to mongo hq. netcat is not installed, so I cannot check it 
I asked mongohq support, learn python, open shift IRC and stackoverflow... no help :(
The only performance limitations from additional methods is the same you'd get from recursion. I wouldn't be that concerned about objects either, as long as you have a reasonable method/object ratio. In general, I'm in favor of the Smalltalk coding school: If the method doesn't fit a single page (in terms of height and width then it's too big. 
As a rule of thumb, yes, methods should be smallish. But when intent and implementation are overly obscured in a pile of methods, or the number of methods/objects causes undue cognitive overhead, it is an antipattern. Call me a rebel, but I'd rather maintain a 20 line method than 10 2-line methods.
the MONGOHQ_URL contain all of this already
I tried to learn both at the same time but found that I ended up just going back to focus on ruby and get a strong foundation there before venturing back into rails again.
Honestly, the fact your asking the question is the best answer. You could say that there are two camps, both with their own point-of-view. But in reality, there is a lot of grey area. Don't look too hard for your place in the grey area. As long as your code is readable by others and doesn't produce a lot of overhead or technical debt, you're fine. The only real objective should be to find where you're comfortable and producing sound code. Beyond that experience will sort it all out in the end.
http://stackoverflow.com/questions/21031278/connectionfailure-when-connecting-to-mongohq-uri-via-flask-pymongo-on-httpd ?
I thought JRuby and Rubinius are plenty fast (e.g. with JIT) even without multi-core capabilities? And isn't one of the points of JRuby also the Java integration?
Sandi Metz discussed some rules to use as a guide on an episode of Ruby Rogues. This gist has some transcription and some discussion about it. https://gist.github.com/henrik/4509394
Tried them both on production apps and without a threaded server you just get mildly better performance after the JVM warms up with the huge downside of slower start-up time. Depends on the app: for example threaded JRuby is about 30-40% faster in an API based Rails app with fast requests without the view layers but slower compared to MRI on a classic simple blog. Again JRuby kicks ass if you run heavy algorithms like comparing sub-graphs for this scenario I reckon even in single threaded the JVM should be faster but why limit yourself and not ramp up the full benefits of the JVM using a fully threaded app server?
Apart from telling them about the purpose of your service, I would try to explain that you are using a known and respected framework to structure your code instead of just cobbling together some ad hoc code. You can tell them if the benefits of this approach: speed of development, clarity of using conventions, etc. If the person is a manager, they will appreciate why you are using Rails. 
Very nice! Also, I second what ts2ftw said... All you need to do is make the communication bi-directional and you would be set!
So I want to just use the method in my main file? Google yielded I can just run it from command line, but that doesn't seem to be working. 
&gt;I have installed and deployed a basic Sinatra app via Apache &amp; Passenger The app is running correctly when accessing the site via IP.
show use your apache vhost settings and passenger settings.
An explanation in the README of the benefits for those of us who have no idea what "Clojure's -&gt;" does would be good.
Thank you very much for the reply and thank you for the recommendation. I have read through POODR, but a second read through would never hurt.
Done. Added an entire how does it work section. People really underestimate how powerful reduce and Kernel are. The thing to keep in mind about reduce is that the return type doesn't have to be the same as the input, and the value of the blocks return is what it folds into. Makes for a good bit of fun hackery though.
OP here. This one is interesting for sure. It seems that with blocks, the anonymous function is reinstantiated for each instance of the loop, meaning that extracting a block into a lambda can have some serious performance gains (I'm seeing 15-20% in some cases.) Of course this warrants a lot more looking into, but for large data pipelines using blocks this could be the difference of several minutes easily. (Ignoring the whole Ruby is slow bit, that's irrelevant to this post.)
Sorry, I'm not sure where to find these. Are you referring to apache2.conf and *name_of_app*.conf ?
what does the output of cat /etc/apache2/sites-available/* show? how about the output of cat /etc/apache2/apache2.conf? What IP do you browse to in order to get to the app? Is it something like 2.2.2.2:4567 or is it just the IP? If you need more in depth help feel free to shoot me a PM.
You know, everyone learns differently. I first went through the Michael Hartl book. I Lerner enough ruby to get through the book and was super excited to see what rails could do. Afterwards I picked up Eloquent Ruby and also went through Pragmatic Studio's Ruby course. There I realized that I love ruby! It's such a beautiful language. That was my experience. Listen to everyone here and chose what is more appealing to you. 
Thanks, that makes things much clearer!
Phusion Passenger author here. I'd like to say: if anybody is still on Passenger 3, you should upgrade to Passenger 4. Passenger 3 is *very* old, over 2 years now. Passenger 4 has received *tons* of improvements, as documented at "Recent Technical Advances in Phusion Passenger": https://vimeo.com/85970704 Honestly, I'm surprised anybody still talks about Passenger 3 nowadays. The improvements in 4 are so huge that 3 shouldn't even be worth looking at. Also, the tests don't seem to say how the servers are configured. Passenger's out-of-the-box configuration is designed to *conserve resources*, not performance, because a lot of our users are on low-memory VPSes. It needs a few minor tweaks to optimize for performance like Unicorn is. With settings like these, it behaves almost exactly like Unicorn: # 'x' is whatever your Unicorn worker count should be passenger_max_pool_size x; passenger_min_instances x; passenger_pre_start_url http://yourapp.com/
You have triggered formatting which makes it hard to read. Put it in a github gist and link it
http://en.m.wikipedia.org/wiki/RubyForge#Shutting_Down
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 1. [**Shutting Down**](https://en.wikipedia.org/wiki/RubyForge#Shutting_Down) of article [**RubyForge**](https://en.wikipedia.org/wiki/RubyForge): [](#sfw) --- &gt; &gt;At 7:03 AM - 10 Nov 2013 Evan Phoenix, in a tweet linked from the https://rubyforge.org/, has announced that RubyForge will be shutting down on May 15 2014, and that users should migrate their data from RubyForge before that date. No explanation was given at that time. &gt; --- ^Interesting: [^Ruby ^\(programming ^language)](https://en.wikipedia.org/wiki/Ruby_\(programming_language\)) ^| [^IronRuby](https://en.wikipedia.org/wiki/IronRuby) ^| [^SourceForge](https://en.wikipedia.org/wiki/SourceForge) ^| [^Camping ^\(microframework)](https://en.wikipedia.org/wiki/Camping_\(microframework\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ciienry) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ciienry)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Imo, a parse should only be responsuble for parsing, not for fetching the thing that needs to be parsed *and* parse it. Why don't you pass in the result of a Snoo request? If you want a nice and sugary class that outputs parsed responses, you can combine Snoo and your parser in a separate Class.
OMG
On the other hand, developing in swift on your own mac costs $0 while ruby motion still costs $199 with no trial. And if you buy ruby motion the assumption is that you're going to want to submit to the app store so there's another $99 on top of it. Swift won't replace ruby motion, but it will look more attractive to a lot of people
There is no prerequisite either way, so do js if you want or do ruby if you want. It's not going to make a big difference. That being said, if you want to make web apps, then start with ruby, then rails. After you have rails basics down, you can go from there
your second `REPLACE_ME_1` probably should be `_2` right?
I made one here copying/pasting from the source of his comment: https://gist.github.com/evanscottgray/81263abfea456a46efe5
There's no need to learn JS before Ruby. A lot of JS things you can find scripts for (assuming you want to use JS to make the front-end look/work better) to help you in the mean time.
If you just want to learn how to build website and don't care about Ruby in particular (as a backend) I'd say just learn JavaScript. You can write your backend in JS with Node. If you do care about learning Ruby, skip JavaScript and learn it some time later. Writing a HTML/CSS only website is difficult enough to just dive into.
appreciate it!
What does it mean to replace? If less than 1% of all apps are ever written in RubyMotion does it need to be replaced? It never placed to be replaced.
tl;dr RubyMotion is a minority. Most of the developers I know never used RubyMotion and already started learning Swift. The statement that Swift only brings new syntax is plainly wrong. It also brings a rather nice type system. Swift brings type safety, a thing that neither ObjectiveC nor Ruby will ever achieve. The toolchain is already there and it will be free for everyone after the public release. I know quite a lot developers that write ObjC for living in my area and none of them is using RubyMotion. They started learning Swift as soon as the beta was released.
"ServerName &lt;ip&gt;" should be "ServerName &lt;domain&gt;"
Whoooops, edited. thank you
Huh. You would think they would have made more of an effort to advertise this to owners of projects on rubyforge. Fortunately, I saw the writing on the wall and moved all my stuff off rubyforge over the last year or two, but I had no idea I actually had a deadline, I'm just lucky I met it. 
Give this man a medal!
thanks for the replies! I think I'm gonna head straight for Ruby. Also, does anyone know any other places to learn Ruby that I can use along Codecademy? 
I don't agree with the current crop of answers here. JS and Ruby work totally different for back end work. If you learn JS (express) for back end don't expect to jump into any blocking (non async) languages such as Ruby. If you really want to do mostly back end work I would start with Ruby. Node is hot right now but the lack of standard library is concerning if you don't know any other languages
I get they assumed a large majority of **active** projects were no longer using RubyForge.. https://twitter.com/evanphx/status/401028473545707520 Apparently it was supposed to be available as an archive.
I agree.. this is probably what's going wrong. Should be your domain.
What makes you think that Ruby is a better language than swift? Swift was designed by a very talented team that incorporated a ton of research from the PL Theory world. IMO, swift is a much better language than ruby. There's 3 problems with it though: * completely proprietary * not cross platform * no decent command line toolchain
Works great. I'm currently learning Ruby, just wondering, how long did it take you to get to this level?
I like this and I'll use this strategy. Thank you!
This is Scala's syntatical sugar for monads. There's some of that in [monadic](https://github.com/pzol/monadic).
I don't care what some of those designer types say. I honestly like Bootstrap.
 (1..n).collect do |i| (1..i).collect do |j| # could also be yield(i, j) if you want to # yield instead of return [i, j] if isPrime(i + j) end end.flatten.compact
 def isPrime(n) #No, this isn't right. Yes, I'm lazy. n % 2 != 0 end def demo(n=50,i=50) n.times do |n| i.times do |i| yield i, n if isPrime(i+n) end end end demo do |x, y| puts "#{x}, #{y}" end No problem for Ruby. If you _really_ want syntax that will blow out the back of your mind, look no further than quicksort done in 4 lines of Haskell: quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater) where lesser = filter (&lt; p) xs greater = filter (&gt;= p) xs 
I always use zurb's foundation (which isn't much different than bootstrap) to build a site, then detail it later. Bootstrap looks good enough and gives you enough of a slick looking site that you'll be inspired to add your own personal touches as you go along. At least that's been my experience.
cool thank you
&gt; in 4 lines of Haskell: It's at least 5 lines (6 if you count the function declaration): You omitted the base case (empty array). Here's the same code in Ruby: def quicksort(array) return [] if array.empty? p, *xs = *array lesser = xs.select { |x| x &lt; p } greater = xs.select { |x| x &gt;= p } quicksort(lesser) + [p] + quicksort(greater) end I don't think Haskell's syntax will blow anyone's mind if he/she is familar with Ruby (partial function application is nice, though). Haskell's expressive type system (which helps writing very robust code) is IMO much more impressive to Rubyists who seem to constantly fight `nil`s in their code base.
[TryRuby](http://tryruby.org/levels/1/challenges/0) first. This should take you 15-20 minutes. Then [RubyMonk](https://rubymonk.com/). I can't recommend this enough. When you finally feel capable enough to dive into Rails, check out [Rails for Zombies](http://railsforzombies.org/). 
Looks good. I opened it on my cell and works perfect. Would you mind sharing with us how you approached building this site and how you learned Ruby, Sinatra. Being a beginner in ruby, this is something I intend to create and your insight would be helpful.
Haskell's syntax is a lot less noisy in many other ways as well however. In fact, I find that Haskell has the most well designed syntax out of all languages out there. For example, you can kill pointless parens with `$`, pointless lambdas with `.`, infix function application, `where` clauses. Once you start piling on pattern matching and all of its various extensions then ruby is very impoverished in comparison.
I usually just use: Hash[a.zip b] If you pass an array to [], it'll expect an array of 2-tuples, which is what zip gives you.
I think Haskell syntax is mind-blowing - even to a Ruby champ, but the more interesting examples are admittedly not introductory or casually accessible, and rely on an implicit understanding of lazy evaluation or other Haskell fundamentals. 
Also, Ruby 2.1 has: a.zip(b).to_h
BTW, the Scala for-loop syntax is heavily inspired on Haskell's list monad. Here's the Haskell's equivalent of the OP's Scala: do i &lt;- [1..n] j &lt;- [1..n] guard $ isPrime (i+j) return (i+j)
You can save a line with: lesser,greater = xs.partition { |x| x &lt; p } Maybe another with def quicksort(p,*xs) but I guess doing the check becomes problematic if you array may contain 'nil'. I do like the Haskell focus on the output line at the front though.
I don't know what your use case is of course, but I'd say Reddit::Thread / Reddit::Comment, etc. I'm surprised Snoo doesn't do any parsing.
You can clean it up a little by using `flat_map`: (1..10).flat_map do |i| (1..i).map do |j| [i, j] if (i+j).prime? end.compact end 
Even though this is do-notation for the list monad, it's more commonly known as a 'list comprehension', no? :) Python supports them too, without explicitly mentioning monads.
This is my first project that I have completed start to finish. I have been doing tutorials and reading books for a couple of years, but have never came up with an idea, implement it and go through the entire process of registering a domain name, using a site like heroku, doing all the development. I think when I was reading and doing the tutorials I was learning some things, but I was never getting to another level. I think when you do a project like this, you come across problems and you have to solve them yourself. For example, It was just going to be a form at the beginning, then I thought it might be cool to implement a graph with the data. I then had to research, try a few different things until I was able to get something to work, In the end I used Chartkick.js. I don't think a book taught me that kind of thing before. Personally, I don't find programming that difficult, what is difficult for me is that problem-resolution aspect of it. When something breaks and I have to fix it, that's were it gets tricky, or if I have an idea, how do I get it in the application. I think that is something that is hard to find in a book and you can only learn by doing a project like this. As for your question I guess I have been studying ruby for a few years in my spare time, never really serious. I might read a book do a few tutorials then forget about it for a few months. This project was done in my spare time over a week, perhaps 20 hours I didn't really keep track. But it is really hard to say, because when you own a project like this you start to think about it all the time, I know when I was in my car or getting ready for bed or whenever, I was thinking up ideas. I am still thinking of stuff to add even as I write this. If you count that as time I would say the time was much greater.
Me too. There is so much you can do with it without having to code much. I really like the documentation for it.
Honestly, the hardest part was coming up with the idea. Once I found something I was interested in(I do crossfit), the project was pretty easy. I mean easy in the way that it didn't feel like I was doing work. It felt more like play. Reading books and tutorials on this kind of subject is pretty boring. How many times can you read about a todo or blog app, and who's going to use another crappy blog or todo app anyways. There are already so many great sites that do that kind of thing. This kept my interest the whole time, and was actually pretty fun. As for the actual build, I went on github found someone who had a sinatra-bootstrap template(don't remember which one but there were lots to choose from) and used that as my starting point. Then it was a matter of tinkering. I started with just capturing the time. Then I had the idea that perhaps it would be neat if people could enter age, weight ect.. So I added that stuff to the site. After that I thought maybe a graph would be neat, so I searched and tried several different options. Some I couldn't get to work, some looked to complicated, then I went with chartkick.js, Then I found a template to use to make it look a little different then the standard bootstrap template. Once i had the site almost ready, I looked at hosting it. I knew heroku was what I wanted to use. I tried it in the past to host some of the tutorials that I did, but could not get it to work properly, but I think that was because I would try it when it didn't go then I would give up. But I really wanted this app to get out there for people to use, so I kept at it until it was up. Went to GoDaddy paid a couple of bucks and registered the domain name. Got all that working. The last couple of things I did was go to Google and install Analytics, and AdSense on the site. I don't think there was much in this app that didn't teach me something new. 
Rubyista are just crazy obssesive people.
Snoo makes api calls and returns the massive JSON like objects. I just finished organizing all of the comments (limit: 1000 per post) for a given subreddit so that I can check for proper use of the words "your", "you're" and "you are". Look out for "yourwrongbot".
Implementation isn't that elegant, i was expecting to be blown away by something so clean and simple.
This looks like a list comprehension and ruby doesn't support them. The problem can be solved in ruby just not as succinct. 
thanks a lot for the comments @farsightxr20 and @colonpee. My post was mainly to show how it works basically. But in real life one would use your suggested versions :) 
&lt;3
There's no really good way to do this that I can find. You have to basically find a good interval where you're not spamming the API yet you don't have to wait too long for updates. You then make the query every interval. This is the only generic way I know. now specifically based on the API, if there's an rss feed that you can use to act as a catalyst to start a query that'll work. Other things that may work are if webooks or push notifications may work.
You're right of course, but I'm speaking as a beginner. Learning Ruby first taught me about OOP, methods, classes, symbols, gems, and various other (obvious to someone experienced like you) goodies. That kind of leg-up at least opens the door. The black magic you speak of can be learned later as needed.
If you're just looking on information on using Twitter, Twitter has a [page on its limits right here](https://dev.twitter.com/docs/rate-limiting/1.1/limits) . After looking at this, you can figure out what your rate limit is depending on what kind of queries you make from what kind of app. If you want more Twitter beginner pages, [here's the general docs site](https://dev.twitter.com/docs)! Also, here's the page on [Application Only Authentication](https://dev.twitter.com/docs/auth/application-only-auth). If you're making a generic app (as in that isn't using your personal account), this is a step by step guide of how to form your requests and what your requests sent back will look like
Yeah, if there's no way you can register a push recipient (via RSS or anything else), the only option is to pull on a time interval and check for your desired changes. As /u/wmcscrooge said, you'll have to either experiment or read documentation or something to figure out how often you're allowed to hit the API. If it's a smaller third-party thing, you may even be able to contact them about building support for a push system, but I wouldn't hold your breath on that.
&gt; It's not really meant for serious real world use, it's more so just fun to think about "oh how would I do that". So, don't make it a gem (or at least don't publish it)?
Websockets (event machine) &amp; something like pub/sub is solution typically but since you don't have control over the API, a resque + resque scheduler setup and poll the API at an interval (via resque scheduler) with a resque job. You could then have the resque job use pusher or redis pub/sub to notify your services of the change. So everything is realtime on your end and if the API does eventually support websockets or pub/sub the upgrade would be obvious.
Yes, it's totally doable - you just need the right methods defined. It's totally non-idiomatic, but there are libraries like [do_notation](https://github.com/aanand/do_notation) with this purpose in mind. Here's an example from the github: require 'do_notation' class Array include Monad def self.unit x [x] end def bind &amp;f map(&amp;f).inject([], &amp;:+) end end Array.run do x &lt;- ["first", "second"] y &lt;- ["once", "twice"] unit("#{x} cousin #{y} removed") end returns: ["first cousin once removed", "first cousin twice removed", "second cousin once removed", "second cousin twice removed"]
Are you trying to use Dir.pwd to set the location of the text.txt? If so run File.open(Dir.pwd + "text.txt").each { |line| puts line } This will add the correct directory to the text.txt location. If not, check where text.txt is located and send File.open to that file. You can choose to either do this absolutely or relative to the location of your ruby script. 
Are you talking about when the API Version changes (1) or when the data from the API Request is different from the previous request (2). 1. See if the API has some sort of version number with the response. If it does, then you could set up an email notification. Also, check/subscribe to the blog/newsletter of the developer/provider for continued updates to their API. 2. You could have a model for the past requests and compare it to the request last made. If this is too much for your purpose, you could create a temp file whose contents are the last response. On the next request, compare the response to the contents of the file.
It isn't going to check the current directory by default. Do what /u/Karrde00 suggests or change "text.txt" to "./text.txt". 
I think Python list comprehensions (inspired by Haskell) is even better: [(i, j) for i in range(1, n) for j in range(1, i) if is_prime(i + j)]
You could also use case statements! :) [tutorial!](http://stackoverflow.com/questions/948135/how-can-i-write-a-switch-statement-in-ruby)
 &gt; Using Haml requires full knowledge of HTML Of course it does. HAML is not a replacement for HTML, HAML *is* HTML. HAML forces you to understand HTML, to see and implement hierarchies, indent your code properly, etc. You wouldn’t believe how many weird layout issues can be resolved by simply fixing the indentation in an .erb file to see misplaced closing tags. HAML doesn’t even allow for that to happen. Yes, HAML requires preprocessing. But then, it’s not really made to be used with anything that does not have some form of ruby backend. HAMLs full power is unlocked when iterating over arrays for example that come from the controller and so on. It’s supposed to be used with Rails or Sinatra. Another nice extra you get when using HAML is the so called "ugly mode" that removes almost all the whitespace from the rendered page. &gt; No big deal? Try giving this to a graphic designer or worse your client. Hope they have the right Gems installed! This is ridiculous. 
Personally, I don't like HAML because it just is shorthand HTML. It doesn't bring any new ideas to the table. I'd rather write plain HTML or use a DSL like in Camping.
Most of the pitfalls in the article can be addressed by switching to [slim](http://slim-lang.com/), which is sort of "haml fixed". But really, almost all of these complaints seem like bollocks. There are a few real complaints with HAML, and they are, in order of severity, difficulty managing whitespace, difficulty with inline elements, and the fact that typing % all the fucking time (particularly when doing HTML5 that uses all those `article` and `section` tags) is frustrating. But again, SLIM fixes that. It doesn't use alligators to control white space (but they are there, just in case), it has a syntax for automatically putting whitespace around a line (the `'` syntax). As for inline code, just use basic HTML within the SLIM file. As for the `%`, slim doesn't use it
[Here](http://mashable.com/2014/06/23/yo-million-users/) is a Mashable article about it. It's essentially a one-way notification service.
To add to the rebuttals: &gt; Doing data attributes is totally weird. You need to do a nested hash within your attribute list! Wrong. `%a(data-this="works just fine")` 
Interestingly enough, I read it more as grumpy person who doesn't want to adapt. Not really noob.
Should they have to start the application to work on page designs? In many workflows, they could do their work on static files without needing to run anything.
I *do* like HAML because it's a shorthand HTML. If ever there were a language in need of a redundancy reduction, it's HTML.
I don't mean any offense by this, but that seems like a pretty arrogant stance to take. Are you implying that HAML is a technological shift that will entirely eclipse HTML? If I'm misunderstanding you, I apologize. Having been using HAML (or slim) on a regular basis for over a year now, I do appreciate that a "whitespace significant" language is preferable for writing markup. However, I think it's a stretch to claim ERB to be inherently inferior.
Thank you, trying this now. 
Honestly, I have no idea what Dir.pwd does.
Ok, I got the absolute path reference to work. Now I just want to figure out how to set the default path. But this will work for my learning exercise for now. Thank you for the help. I was stuck on this for like an hour -_- 
We found it to be much easier to provide a runnable application with some sample data to allow designers to integrate their stuff directly into our application / the asset pipeline. Before we did that, we'd have the designers create an HTML prototype from our application (which would take a few hours they'd bill us for), and we would have to do edit in their HTML / CSS / JS changes by hand.
No, it was commentary on the person not the technologies involved. The person wanting to stick with what they know instead of using something new to them. Apologies for being unclear in that regard. :)
pwd stands for "print working directory". Meaning to echo out the directory you're currently in (Comes from the shell command pwd which does the same thing). 
Haml is just abstracting over html, not really replacing it. I found ruby's lack of curly brackets liberating when coming from php. Not having to close tag my html gives me the same sense of liberation
&gt; They seem to be more like comments to tell the reader what the test is rather then instructions for the actual test. Exactly :)
First off "do" is a ruby keyword for defining a block which is an expression which encapsulates and evaluates another expression this is fundamental to ruby's model for metaprogramming which allow one to build a library like rspec with its own DSL (domain specific language). This takes the form of: some_method "some object" do "An expression to be evaluated" end describe and it are part of rspec's DSL they are effectively keywords which allow you to compose expressions which help you structure your tests. describe is a context declaration for a class or some case. You supply a class name or a string eg describe SomeClass do end it is the keyword for framing a test expression it lives inside the describe block describe SomeClass do it "evaluates some other expression" do end end should is a method by which you define assertions on an expression describe SomeClass do it "evaluates some other expression" do (1 + 1).should eq 2 end end As you can see it's all blocks. If you find the idea of DSLs too daunting stick with test unit. It's all ruby classes and method definitions. 
I agree, `slim` is my favorite of the HTML preprocessors. `slim` is also pretty versatile and doesn't try to lock you in to one syntax, so you can do attributes like: a href="/" title="Root" Link description Or you can do it like: a(href="/" title="Root") Link description for more readability. Or you can do: a*{href: "/", title: "Root"} Link description for easy inclusion of pre-existing hashes. All that on top of inline HTML, as you mention.
This kind of structure is most easily represented as a list comprehension. Ruby doesn't support list comprehensions, but I'll show you how it looks in a similar language (Python) and how it very well could look in Ruby if it's ever added. In Python: [(i, j) for i in range(1, n) for j in range(1, i) if isPrime(i+j)] (Or for slightly more readability) [(i, j) for i in range(1, n) for j in range(1, i) if isPrime(i+j) ] I wish Ruby had Python's list, set, and dict comprehensions, honestly. If it did, you could do: [(i, j) for i in 1..n for j in 1..i if isPrime(i+j] Or if Ruby were to adopt a more Haskell-like comprehension syntax: [(i, j) | i &lt;- 1..n, j &lt;- 1..i, isPrime(i+j)] Personally, I don't think you can get much better than that last line. If I'm not mistaken there used to be an effort to add a Haskell-like list comprehension syntax to Ruby, but the proposal was shot down.
I gave some examples later down in this thread: http://www.reddit.com/r/ruby/comments/299pmq/is_there_any_way_we_can_get_ruby_to_do_this_scala/cik56cq There have actually been official proposals to add list comprehension syntax to Ruby before, but so far they've all been turned down I think.
Haskell's syntax is even a bit nicer. There's been a proposal to add Haskell-like list comprehensions to Ruby before. If it were to be added, you could have something like this: [(i, j) | i &lt;- 1..n, j &lt;- 1..i, is_prime(i+j)]
&gt; Most of the resources I've seen online don't really talk about this in terms that I get, they spend more time trying to sell you on the idea to use this framework and go on about the benefits of test-driven development then anything else. You're doing fine. People who have been programming for awhile forget how completely arbitrary and unintuitive so many things are, forget what a good beginner's explanation entails and forget the struggles they had initially. Let's break Rspec specs down into two parts: 1.) writing stuff to describe what we're trying to test, and 2.) the actual assertion (`zombie.name.should == 'Ash'`), which is what makes sense to you. &gt; What's the point of the other things? We write so much stuff to describe what we're testing so we know what's going on. If I see `describe Dog`, I know the tests I'm looking at will tell me what the Dog class (or its instances) should do. Sometimes I want to test that a dog object acts differently under different circumstances, and for situations like that we have `context` blocks. Sometimes the actual assertion, e.g. `zombie.name.should == Ash`, is not short and clear like that one. When the test is less self-explanatory, then we can use `it` to write our own explanation of what is being tested. The do/end bits are keywords in Ruby. They start and end a block of code. I understand why that's confusing; it looks like it's trying to be part of the test. It's just syntax, though. The file still needs to be written in a way that the Ruby interpreter can understand. Please let me know if this was helpful. I think it's a very positive thing that you're determined to understand why things are the way they are, and are questioning beliefs like what is "readable". Edit: another commenter suggested Ruby's built-in test/unit library if the Rspec DSL is taking too much of your focus away from actual programming. Try that too. 
Most of these are non-issues, gripes, or otherwise incomprehensibly bad form. Let's go through this piece by piece. **Easy to learn** You're learning new things every day as a developer. Griping that you have to learn something with an easy learning curve seems off when there are hundreds of other things to learn that are far more difficult. **HAML code takes less time** The point of having to write less is that you have less boilerplate nonsense to deal with. Even WITH an IDE, you still have to deal with the generated code afterwards. HAML takes away that need, and gives you something far more valuable: readability. You're going to spend far more time reading that code than you ever will writing it. Define edge cases, it's simple to indent in a span tag. **Best practices** It also makes it extremely difficult to use a lot of logic in the view. No language or tool will ever make programming error-free, but I'm reasonably sure that there are better standards of keeping people honest. **Multiline content** That's called bad design and poor abstraction and separation of concerns. **Full knowledge of HTML** You mean what you're supposed to already know? If you don't know HTML by heart, why are you a web designer / developer? **Requires a compilation step** Rails makes this pointless, as things are translated down with the asset pipeline in production. If you're giving your designers and clients your actual source code, there are a lot bigger issues than snips about gems being installed... **Inconsistent Syntax** Why in the world are you inlining scripts and styles? That's horribly bad form and you should know better. The asset pipeline is nice enough to give you page specific files, use them. **Whitespace** You mean you don't have a standard on spacing set in editors. It's a non-issue with proper configuration. **Ruby attribs** You're working in a Ruby framework and complaining about things looking like Ruby. You can understand why most would scoff at that. **Readability suffers** No, that's your fault for writing bad code and css. Blaming the tool isn't going to do you any good. The erb would look just as bad. **Not a W3C standard** You're serious aren't you? How is this remotely relevant? Neither is ERB by technicality, or any other abstraction on/from HTML **Not every project is Ruby** You don't say? Then why are you using a Ruby tool? **Slow** Then use Slim, but again this is a non-issue with the asset pipeline in prod. **Final tally** I still stand by what I said about this being incredibly ignorant and more of a whiny rant than anything.
I've actually been trying to read from the spec file and glean what I'm supposed to do from the way the tests are written. It was suggested to me to just run the specs and then backwards engineer from the output that rspec gives. Now everything seems MUCH more clear. The pitfalls of studying on your own.
I'd like to thank everyone for their answers, by the way. I really appreciate it.
It's a rare person indeed who can work on a design in pure markup without being able to look at it. Booting a rails instance is probably overkill, but they definitely will need to be able to render templates for review. 
That's great to hear! What you're describing is a core part of test-driven development. If we want to write a Dog class in a test-driven way, we could first write a test asserting that Dog instances have a method called "bark" which returns the string "woof". The test would fail first because the Dog class doesn't exist. So we write it. Then the test would fail because there's no instance method called "bark". So we write it. and so on. You've got this. I'm self-taught as well but now write Ruby professionally. Let me know if I can help you understand anything else. Your post reminds me of my thoughts when I started.
Thanks for the help. Teaching yourself can be pretty painful but help alleviates much of the frustration. I didn't really understand the purpose of test-drvien development till now. I just thought that it was an alternate way of debugging. I can't say what I think about it, don't have enough experience. It does add a methodical quality to development that I do like: I like bottom-up development. Course, if I'm writing my own tests that's a different story, haha. It doesn't help that the project I'm working through has lots of depreciated syntax that rspec whines about each time I run the test. I guess I could figure out how to go in and update it, but the sooner I can put this behind me the better. 
You're welcome. Like I said, you're doing fine. I think it's possible to be introduced to testing too early. IMO the usefulness of it isn't really understood until you've spent time writing projects and programs with NO tests, make changes to them, and then realize you have to exercise it yourself to make sure it still works. Then you realize an automated set of tests saves you time, or helps you think through what your program actually needs. I think the first approach (feeling the pain and realizing there's a better way) is better than saying "Just write these tests because that's how things are done", with no explanation as to why. I think a lot of tutorials fall in the latter category.
This is a little off-topic, but since it hasn't been said yet, get ready for RSpec 3.0. ._. For the most part, it just means a syntax change where the .should method will go away. So instead of: a_dog.should bark you'll have: expect(a_dog).to bark But yeah, other than that, you'll still have the describe, then the it...do examples, maybe with context...do in between the two.
That's friggin' awesome. It's a source rewriter? Nifty.
The real problem with translating it into successive layers of `map`/`collect`/whathaveyou is that, even though you maintain the semantic meaning, you add syntatic noise, not the least of which is that your code starts resembling an arrow.
I'm not a fan of them changing the API like that. They've also changed the code that exposes exception codes, which sucks for me. There's a nifty upgrade script out there, if you like. It worked pretty well for me, except that it missed the way RSpec changed exception handling. https://github.com/yujinakayama/transpec
Even nicer Haskell syntax for building lists: list comprehensions. [(i, j) | i &lt;- [1..n], j &lt;- [1..i], isPrime(i+j)]
Thanks a ton. This is nice roadmap for me to follow. I was bored to create blogs and to do apps. 
yes, shorthand HTML is the entire fucking point of HAML
method names that make the code read like English (i.e. "it" and "should") are trademarks of ruby code. I personally found it really confusing. Easy to read, but terrible to write. again, in my opinion. I started using Python and found it much clearer from my perspective. Less magic, easier to follow what's happening.
A one-way, context-free, content-free notification service. Think of anonymous Facebook pokes, only less informative.
The *real* fix is to switch to a view-rendering system that lets you write clean POROs to generate markup; [Erector](https://github.com/erector/erector) is the best attempt at this I've yet seen in the Rails world, and it's got [Issues](https://github.com/erector/erector/issues?state=open) of its own. The possibility of getting away from the whole Rails-botched-OO mess is why I'm keeping tabs on [Lotus](https://github.com/lotus/lotus). Money quote (from the README for [Lotus::View](https://github.com/lotus/view): &gt; It's based on a **separation between views and templates**. &gt; &gt; A *view* is an object that encapsulates the presentation logic of a page. A *template* is a file that defines the semantic and visual elements of a page. In order to show a result to an user, a template must be *rendered* by a view. Apparently it's possible to use `Lotus::View` inside an app written in another framework. If anyone happens to know of such, I'd greatly appreciate a pointer.
j goes from 1 to i, not 1 to n.
100.times {puts "Thank you!"}
The title of the post doesn't reflect the content of the article
Fixed. I was copying the code of the person I was replying to.
I tried `File.open("./text.txt") and File.open(Dir.pwd + "text.txt") and neither will open the file even though the text file is in the same folder as the .rb file. The only way I can get the .rb file to reference the text file is by using a direct (?) path : ("c:/Users/Owner/ruby/text.txt") I understand that a relative path is better but I just can't get it to work. I have the text file and .rb file saved in the same folder.
Your best option there would probably be a book. This one's online for free: http://ruby-doc.com/docs/ProgrammingRuby/ I'd suggest reading a chapter, writing a toy program that uses the concepts in the chapter, try some variants, and then repeat.
Try adding a "/" before text.txt when using Dir.pwd. Eg File.open(Dir.pwd + "/text.txt")
Can you post a gist of your code here? Thanks Just paste your code in here https://gist.github.com/
That these things are identical: "#{@username}" "#@username"
 users.map(&amp;:email) # instead of users.map { |u| u.email } User.find(some_id) rescue nil # inline rescue user.age &gt; 40 ? "old" : "young" # ternary operator 
Co-routines are severely under-utilized in Ruby. There's a truly magical line you can add to the top of a function that yields a bunch of values, return to_enum(__callee__) unless block_given? which makes the function return an Enumerator enumerating its values if you don't explicitly pass it a block. As a simple example, consider this, def numbers return to_enum(__callee__) unless block_given? yield 1 yield 2 yield 3 end You will now have `numbers.to_a == [1, 2, 3]`. This allows you to do some really sexy stuff, though it may not be obvious at first. Imagine you're interfacing with an external API (maybe for fetching Reddit posts). The API allows you to check whether there's another post (`has_next_post?`) and if so, to fetch it (`next_post`). Normally, you might end up with various methods for fetching various numbers of posts according to different criteria. You might need to fetch the first 10 posts within the last week, etc. But using this trick you only need one basic method: def all_posts return to_enum(__callee__) unless block_given? while api.has_next_post? yield api.next_post end end For fetching the first 10 posts within the last week you can now do, all_posts.lazy.take_while{ |p| p.date &lt;= 1.week.ago }.take(10) The magic is that you can verify that this will only make the number of API calls that are actually required. The execution of the method pauses and ends when the final `take` gets everything it needs.
def do_thing # do your thing ensure # ensure your thing end This is good for file exception handling.
Whoa whoa whoa what?! The curly braces are optional?
also "#|@username|" and there are a few more characters that work which i currently can't remember
https://gist.github.com/a5b31707c6d415808764.git 
That you can leave just the splat symbol in method argument declaration if you don't care about them: def foo(*) .. end
You hinted at an obscure feature in your text post. The question mark is used for single character literals. E.g. ?a #=&gt; "a" Any single character you put after the ? Will return a string of that character. Useful for flags and people that are too lazy to type that extra ". 
The limited retry pattern: def api_call(args) @retries ||= 0 begin do_api_call rescue ApiError, Timeout @retries += 1 retry if @retries &amp;lt; 5 end end I noticed that not many devs know about retry, and I decided to add the retry limit to illustrate a useful example. Edit: clarified example. Edit 2: Made this pattern into a gem: https://github.com/DiegoSalazar/DefRetry
Using `@retry ||= 0` like that would only allow #api_call to fail 5 times for the lifetime of the class instance, not 5 times per call.
Yeah, it's just an example. Not all methods and cases where you want to rescue have an exception-free alternative.
Every time I try to understand coroutines (and related stuff such as callcc) I don't really grok it. Would you mind elaborating a little bit on a) how exactly coroutines work and where they come in here. and b) what \_\_callee\_\_ is and how to_enum workso n it? I think I follow everything else. Certainly once we've got an enumerator, I can follow from there. Also also, this might just be because I'm stuck in ruby 1.8.7/rails 2 at work, but how does all_posts.lazy work? 
Indeed. The brevity of the example left many nuances lingering. There's many places to put this instance variable and in this case, left as is, it would only work if you re-instantiated the api caller instance every time you wanted to call api_call. Use at your own discretion.
`__callee__` is just a magic variable that returns the name of the current method. (In the above example, just the symbol `:all_posts`). The `to_enum` method takes the name of a function and returns an enumerator which lazily enumerates the values yielded by that function. The basic idea is that it pauses the execution of the `all_posts` function after every yield. So if you only ask for its first three values and then throw it away (for example, using the `take` method), then the function will only ever execute those first three yields, and stop after that. You can think of it as taking a function (which normally you would expect to have to execute completely before returning) and turning it into a stream of values that can be read value-by-value, and stopped if needed.
Great post! Thanks!
My favorite of those is #inject/reduce.
Here's my favorite specific trick: a one-liner for combining two arrays into a hash. animals = ['lions', 'tigers', 'bears'] counts = [34, 12, 42] Hash[*animals.zip(counts).flatten] Result: {"lions"=&gt;34, "tigers"=&gt;12, "bears"=&gt;42} I haven't had too many occasions to use it, but it can be pretty handy in certain circumstances.
No need to flatten: a = [1,2,3] b = ['a','b','c'] Hash[a.zip(b)]
As a new ruby adoptee with experience in other languages, this thread is awesome!
I feel a Venn diagram could illustrate the point here quite succinctly.
One of my favorite tricks is memoizing larger code blocks. Usually, the example of memoization you see is: def foo @bar ||= some_value end This also works with a begin/end block. def foo(force: false) @bar = nil if force @bar ||= begin gold = SomeClass.expensive_method silver = AnotherClass.expensive_method gold + silver end end That makes it really easy to cache "expensive" calculations in memory and even have an option you can pass to bypass the cache. I variations of this technique all the time. 
 (array1 + array2).uniq == array1 | array2
There's also `__method__`.
I guess it's been a long time since I discovered that trick. I see now that support for 2d arrays was added to Hash::[] in Ruby 1.9.x. The syntax I used was held over from 1.8.x, which did not support nested arrays but did support an indefinite series of individual key/value arguments.
It's better not to treat them as optional.
inline `rescue nil` is great for hiding nasty errors that you should be aware of, too.
Is there an actual useful purpose for this? Feels a bit Javascripty to me...
Are set operations on arrays a lot slower than set operations on proper set objects?
I can see this being useful in short cases, but if you're doing a lot of this you probably should just abstract the block out to a separate method and do `@bar ||= method_call`.
Since no one mentioned it yet [Hash#fetch](http://rubydoc.info/stdlib/core/Hash#fetch-instance_method) accepts a block: hash.fetch(:key) do # executed if key is missing end Also [String#gsub](http://rubydoc.info/stdlib/core/String#gsub-instance_method) accepts a block as well: string.gsub(/pattern/) do |match| # transform match end
I'm confused. Are you saying it is alright to use for instance variables, but not for class and global variables?
No need to `Hash[]` either ;): a = [1,2,3] b = ['a','b','c'] a.zip(b).to_h 
Hey, just got the chance to look at this. The link you posted isn't working. Can you resubmit one? edit: nvm, got it working. didn't notice the extra .git at the end. I posted a solution to your problem on the gist for you. Essentially you take add a slash before text so that it concatenates correctly. I also tested out the relative path and even just having text.txt and they work as well for the file being in the same directory. Let me know if you have any questions about the changes and I'll be happy to explain further
You should probably use [the underscore](http://po-ru.com/diary/rubys-magic-underscore/) instead of a plain old splat
Why don't you just read this? http://stackoverflow.com/questions/63998/hidden-features-of-ruby
Not a quirk I like, but the `uniq` method drives me nuts! Why isn't it "`unique`"? Such an outlier.
I left this on the gist as well. I tried what you said, and basically understand it. When I am in the command prompt (windows) I am calling (?) the file by writing: ruby ruby\analyzer.rb analyzer.rb and text.txt are in the same folder, thank you for taking so much time on this. edit: it still doesn't work, unless I name an absolute path. 
 def one(_) end def many(*) end &gt; one(1) # =&gt; nil &gt; one(1, 2) # =&gt; ArgumentError: wrong number of arguments (2 for 1) &gt; many # =&gt; nil &gt; many(1) # =&gt; nil &gt; many(1, 2) # =&gt; nil
You can use it to overwrite a method to take some action before calling `super` and not worry about the args. def some_method(*) some_stuff super end
Guess I was wrong
even the relative path replacing Dir.pwd to ./text.txt? try running the file from inside the directory as Dir.pwd might be grabbing the directory you are in and not the one that the script is in. When I get home I'll try it out on my windows machine as I just have my mac on me right now and no windows VMs on this machine to test it out. What error is it throwing out at you? 
expect(a_dog).to receive(:bark)
Ruby Sets are in fact just Hashes. So Set#union is just Hash#merge: https://github.com/ruby/ruby/blob/f8a38a36eba27f0e4a9f62f319496354e51bcc8f/lib/set.rb#L383-L385 At first sight I'd say complexity is O(n), while array union is probably O(n^2) in worst case. Disclaimer: I'm not very good at big O 
I like doing this mostly when splitting apart a single long line into a few smaller ones for clarity.
ok, i messed around with it for a bit now it will load fine. Thank you for the help. I'm not really sure what fixed it. I put the ruby file in the owner directory and ran it and it found the text file fine. Then I put it back in the ruby folder and it worked there as well. Thank you for the help. 
!! Say you may have a big block o' data in a class, and you want to see if that data is there without actually returning it: def has_big_block_o_data? !!@big_ol_data end It's not necessary a lot, but when it does come up, it's very handy. Also useful for turning nil into actual false.
i used the relative path, I just called the file by writing File.open("text.txt").each { |line| puts line}
Since you are calling this recursively, whatever you type the first time will ultimately be returned. Note that any string without a valid number in it will return 0, which is why you get a return of 0 when you first type 'a'. The following will return integers only, other than 0. def get_string while input = gets.chomp.to_i return input unless input == 0 end end irb(main):071:0&gt; get_string afd fl 5.6 =&gt; 5
Names in Ruby (as in most languages) can't begin with a digit. Only pain lies down this path.
I just want to add that this may not be the best use of a recursive function. It has the potential to never exit and run out of stack. You should use a loop instead.
Using procs in case statements. http://batsov.com/articles/2013/09/24/lambdas-slash-procs-in-case-expressions/ 
It is not available for locals, since they don't have a glyph. It is available for @instance, @@class and $globals. However, leaving off the braces in any string interpolation is probably not wise to use, as it reduces readability and increases the probability of making an error.
I would disagree that it behaves like a goto, depending on what your definition of "behaves" is. You can conceptually treat it as equivalent to a while(retries&lt;=5) loop, so it's not as hard to reason about as gotos often are Your point about exceptions as flow control is a lot more valid. However, in every case where you'd use this pattern instead of a simple while loop, you're usually dealing with external APIs that might return errors. Like the ApiError in the example. So you don't really have a choice, the exception is being dropped in your lap whether you like it or not. Using exceptions as flow control is only problematic when you're *intentionally raising errors* as a way to break normal program flow.
* To quickly serve local directory: ruby -run -e httpd -- . -p 8000 runs a web server and serves the current directory at http://localhost:8000/ . There's more that you can do with it, but this is the most useful one (apart for `mkmf`, for extension writers). You can do `ruby -run -e help` to see what else is in there. * Avoid escaping slashes in regular expressions using `%r{}`. Index pieces of strings with regexp. url = "http://example.com/not/very/interesting" host_regexp = %r{^https?://([^/:]+)/} url[host_regexp, 1] # =&gt; "example.com" (of course, this is just an example. In this case, `URI#host` is better.) * Autovivifying hashes are cool. autohash = Hash.new { |h, k| h[k] = Hash.new(&amp;h.default_proc) } autohash[1][2][3][4][5][6][7] = 8 autohash # =&gt; {1=&gt;{2=&gt;{3=&gt;{4=&gt;{5=&gt;{6=&gt;{7=&gt;8}}}}}}} 
symbol syntax cannot begin with a number. However, as you have seen you can do :"2B" instead, they are functionally equivalent but not a pretty to read / write.
uniq drives you nuts?? are you forgetting 'elsif' ??
why don't you? then post your favorites. grumpy gills.
I'm surprised nobody has mentioned James Edward Gray's [~~~10~~~ ~~~42~~~ 101 Things You Didn't Know Ruby Could Do](https://www.youtube.com/watch?v=aBgnlBoIkVM). Viewer advisory: don't try to absorb all this at once. :-)
The basic structure of gems (lib/bin/spec/test directories, gemspec, Gemfile, Rakefile, etc.) is pretty standard and is probably not something for which you need attribution. That being said, if you feel a particular gem served as a good reference then it won't hurt to add a thank-you in the README of your new gem. As for the existing code in the gem which you want to improve, attribution requirements (note: we're not talking _etiquette_ here) depend on the gem's license and how closely your work is derived from it. For example, if it's licensed as Apache v2, you don't need any attribution as long as you leave the original Copyrights/Disclaimers in place. _Most_ gems are published under similar permissive licenses (even when used for commercial purposes), but you'll still want to verify that your usage is allowed. And again, a thank-you in the README doesn't hurt if you drew significant inspiration from the original source.
Thanks! That's really helpful. I just want to make sure credit is given where it's due. Thanks again!
More options that are cleaner than the first example: obj.is_a?(String) obj.kind_of?(String) obj.instance_of?(String) # this one only matches exact class, no superclasses
1234.to_s(2) =&gt; "10011010010" 1234.to_s(16) =&gt; "4d2" 
You can use the splat operator in regex matches, ie _,cat,no_match = */(cat)|(42)/.match("catdog") yields in cat being cat and no_match nil, thus easier variable assignment (or at least quicker)
Yeah, it can make sense to do it that way. Getting someone's system up to speed to do that can be rather tricky, though - especially if they're working on Windows.
I like your force thing, very simple. Nice pattern.
There is also a fair amount of those that really should be avoided. 
Also, [heredoc](http://rubyquicktips.com/post/4438542511/heredoc-and-indent) and how it starts on the next line regardless of what's on the current line. ERB.new(&lt;&lt;MSG).result(binding) Blah ID CODE -------------------------------------------------------- &lt;% @codes.each do |id, code| %&gt; &lt;%= id.ljust(20) %&gt; &lt;%= code %&gt; &lt;% end %&gt; Blah MSG
Gah. That just seems like it'd make an unreadable mess if used extensively.
The various % expressions are super useful to know about.
The "lazy" part is an awesome magical tip for me!
True! But it is nice for short scripts and stuff, just like DATA.
Best trick when using IRB and you forget to assign a variable: irb(main):001:0&gt; "hello" ..shit forgot to assign it to a variable dang... oh wait, irb(main):002:0&gt; hello = _ irb(main):003:0&gt; puts hello 
Make a comment in the code saying "This chunk of code was taken from xxxx; Author: xxxxx"
probably because you have semicolons in ruby code just kidding
doesn't work for me. Also, never heard of that.
Nice! Speaking of regexes, I like Regexp#union. Regexp.union(/dogs/, /cats/i) #=&gt; /(?-mix:dogs)|(?i-mx:cats)/
Better than `fetch` with a block, to me, is `Hash.new` with a block. It lets you lazily compute and cache values: irb&gt; values = Hash.new do |_values, _key| _values[_key] = expensive_api_call(_key) end irb&gt; values {} irb&gt; values[:hello] "you sent me :hello" irb&gt; values { :hello =&gt; "you sent me :hello" } 
You can also do `not @big_ol_data.nil?` if you want to distinguish `false` and `nil`
autohash with h.default_proc is cool, I used external lambda for that.
So like a generator in Python?
~~Virtus~~ Scrivener is a great gem for writing validators. If your code is Ruby-only however (e.g. you don't need to dump your options to something like a database), I'd advise against validating. If you start requiring them to be of a certain Class for example, you completely break duck-typing. Checking for presence is enough, imo: `[:foo, :bar, :baz].all? { |opt| opts.key? opt }`. Do document the type of Object you expect though.
Creating a hash from arrays. array = [:a, 2, :b, 3] hash = Hash[*array] hash == { :a =&gt; 2, :b =&gt; 3 } Also, `%[...]` works great for multi-line string quoting, and you don't need to care if `[` or `]` appears in the body, as long as its balanced. You can even use a different bracket (eg, `%{...}`). instance_eval %[ def #{method}=(val) @#{method} = val end ]
A thing to keep in mind is that hashes with default procs are not marshalable.
Exactly. while input not in [1,2] keep looping.
Hash.new is pretty cool. Mix in some recursion and you get never ending hashes! # Makes a Hash that will never return nil so you can do something like # hash['name']['color']['number'] without raising any exceptions from nils def recursive_hash Hash.class_eval do def self.recursive new { |h,k| h[k] = recursive } end end unless Hash.respond_to? :recursive Hash.recursive end I use this when traversing large JSON objects retrieved from API calls where sometimes some keys are not present.
There's a Rails gem which provides automatic retry for database transactions when it detects a deadlock or timeout. However, it can reeeeally mess you up if you're not aware of it; when it does the retry, the database has been rolled back, but all of the models (in-memory versions of the database contents) you're working with have *not* been rolled back unless you do that yourself, leading to an entire class of bizarre errors.
How about [something like this](https://gist.github.com/ledbettj/7039d9b73ee513df263a)?
No need to `zip` either ;): { 1 =&gt; 'a', 2 =&gt; 'b', 3 =&gt; 'c' }
I am a big fan of the partition method, which combines select and reject. Best combined with multiple assignment: odds, evens = 1.upto(7).partition(&amp;:odd?) =&gt; [[1, 3, 5, 7], [2, 4, 6]] You can even do partition.each_with_index, if for some reason you wanted to do a partition that used the array index: evens_among_top_three, rest = 1.upto(7).partition.each_with_index{| val, index| val.even? &amp;&amp; index &lt; 3 end There's also each_cons, which lets you iterate through adjacent values in an array: 1.upto(4).each_cons(2){|i,j| puts i + j} prints 1+2, 2+3, 3+4. 
`Hash.new` for accumulating: groups = Hash.new{|h,k| h[k] = [] } groups[:x] &lt;&lt; 1 groups[:y] &lt;&lt; 5 groups[:x] &lt;&lt; 2 groups[:x] #=&gt; [1,2] There are a [ton of interesting uses for Hash](http://monkeyandcrow.com/blog/hash_tricks).
Unfortunately, unless you're running a very recent version of ruby, hahses are not ordered and the array-to-hash conversion loses any ordering information. Rails adds ordered hashes, so I added a to_h method which specifically returns an ActiveSupport::OrderedHash and retains the ordering.
True. But JSON works, as does YAML. If you really need to Marshal it, you can clean it up rather easily: def unauto(h) Hash[h.map { |k, v| [k, Hash === v ? unauto(v) : v] }] end
what version of ruby are you using?
i agree with you. for those unable to google, #2 is well explained on the internets, for instance here: http://c2.com/cgi/wiki?DontUseExceptionsForFlowControl for #1, i agree sort of. the question to ask yourself is, if you were debugging this, and you got to the method call, where did the method call come from? using retry would mean you essentially could be calling from external OR internal to the called method. (yuck.) whereas afaik, goto was mostly used externally (but could be used internally prob?)
.inject({}) {|a, e| } is one of my faves, though isnt the most readable :)
No, its pure Ruby. I learned it in the Pickaxe, and now I like to do it to confuse people, or see if they are awake when they are reviewing my code :-)
wow i prefer this to heredocs actually
If you want to keep your code Ruby only, you can try the [suggestion](http://www.reddit.com/r/ruby/comments/29kaxo/whats_the_best_way_of_validating_multiple/cilqwnu) of /u/johnjohnjohnjohnjohn. However if you don't mind using a gem I suggest you should take a look at `ActiveModel::Model`. This makes your class basically a Rails model, without the persistent database layer. Thoughtbot wrote a [blog post](http://robots.thoughtbot.com/activemodel-form-objects) about it, demonstrating it with a form object. References: * [Active Model on Github](https://github.com/rails/rails/tree/master/activemodel) * [`ActiveModel::Model` documentation](http://api.rubyonrails.org/classes/ActiveModel/Model.html) 
Ran across date shifting the other day. require 'date' Date.today &lt;&lt; 1 #=&gt; #&lt;Date: 2014-06-01 ((2456810j,0s,0n),+0s,2299161j)&gt; Date.today &gt;&gt; 1 #=&gt; #&lt;Date: 2014-08-01 ((2456871j,0s,0n),+0s,2299161j)&gt; Date.new(2014, 2, 28) &lt;&lt; 1 #=&gt; #&lt;Date: 2014-01-28 ((2456686j,0s,0n),+0s,2299161j)&gt; Date.new(2014, 2, 1) &lt;&lt; 1 #=&gt; #&lt;Date: 2014-01-01 ((2456659j,0s,0n),+0s,2299161j)&gt; 
isn't this a very common language feature or am i missing something?
i was using 1.9.3. just tested in 2.1 and it looks like only #{} works. huh, guess it's the cost of progress.
I've just tried it in 1.9.3. nope. I think you've mixed up something. %|foo bar| syntax, maybe?
oh god.. thank you for being kind to a man who is so clearly multitasking and getting everything wrong. yeah.. i mean %{qQwW} type syntax. how could i read this a dozen times and have my brain substitute % for # each time i typed it is beyond me.
i hadnt seen it before, where else have you seen it? i wouldnt be surprised if it existed in perl or awk i suppose :)
Also fun is when you need to omit that `hash[key] = ` assignment, so the block fires on every miss but doesn't populate the hash. If you need to mix predefined values with a default block, you can use [Hash#default=](http://rubydoc.info/stdlib/core/Hash#default%3D-instance_method) or [Hash#default_proc=](http://rubydoc.info/stdlib/core/Hash#default_proc%3D-instance_method). And finally, Procs alias `.[]` to `.call` so you can use them as infinite hashes: https://github.com/postmodern/hexdump/blob/master/lib/hexdump/dumper.rb#L9-L25
Correct, both examples demonstrate deferred execution. However, `hash.fetch(key,value)` is acceptable for constant values like defaults for `:options`: def initialize(options={}) @var = options.fetch(:var,42) end 
Thank you for sharing this.
Eh, they followed the relevant SemVer rule and created an incredibly seemless upgrade path, so I can't be too mad about it.
Usage info is on BitBucket: https://bitbucket.org/Aeoxic/yo It's... not that useful.
They did do that. I'm pretty happy with the 2.14 -&gt; 2.99 -&gt; 3.0 path. They did make it as painless as they could, so that's fair.
You could also use a [Reform::Contract object](https://github.com/apotonick/reform#contracts) which lets you define validations in ActiveModel::Validations-style. class CommentContract &lt; Reform::Contract property :text validates :text, presence: true end contract = CommentContract.new(your_object) result = contract.validate result.errors
Awesome - thanks! I noticed that you marked the Pragmatic Studio courses as an "Editor's Choice". Did you take any of the courses? If so, what were your thoughts on them? They are pretty expensive - at least for me they are (around $180).
How was the course paced? And how much it helped you since the course is finished.
This is really great. I know it might seem obvious but the Rails guide is really good, amazingly good (and free). It probably belongs up there unless I just didnt see it there already.
I'm about a year and a half into Ruby as my first language. I have had a bad time trying to learn RSpec. I feel like the documentation doesn't read linearly, like I end up in circles. It hasn't been easy finding good secondary resources, and now that 3.0.0 released I just don't want to try any more. I'm going to try MiniTest for now.
"2B" || !"2B"
&gt; Any tips to compliment Codecademy? Try "Codeacademy, you are awesome", that's pretty safe. You could also go with "Codeacademy, you just might be the best course site I have ever seen", although that might be crossing over from a compliment into blatant lying flattery. If you are trying to *complement* Codeacademy, you can try [Ruby Koans](http://rubykoans.com/), [Ruby Monk](https://rubymonk.com/), [Ruby Warrior](https://www.bloc.io/ruby-warrior/#/) (or the [plain command-line version](https://github.com/ryanb/ruby-warrior)). While you're doing that, you can also read [_why's Poignant Guide to Ruby](http://mislav.uniqpath.com/poignant-guide/book/) to give you a laugh while you're starting. And never be far from [Ruby API documentation](http://www.ruby-doc.org/). When you're comfortable with the language itself, you can start playing with [Sinatra](http://www.sinatrarb.com/) web framework. Then learn about Rake and RSpec (not sure about good online books though). Then learn about [Heroku](https://devcenter.heroku.com/articles/quickstart), where you can deploy your application for free (as long as it is not too popular). Graduate to Rails if you outgrow Sinatra, for example using [Rails for Zombies](http://railsforzombies.org/) to get you going. Making a cool app can make a good showcase for your portfolio (or even eventually launch you into millionnaire territory, if you prove to be good and lucky).
Here is my try that aims for readability. x = Enumerator.new do |y| (1...10).each do |i| (1...i).each do |j| y &lt;&lt; [i, j] if (i + j).prime? end end end puts x.to_a.inspect I think this solution is inferior to the others posted here, being less terse and not really functional. At least it does away with `map`, `compact`, or `flatten`.
As you gain more knowledge in coding, you'll probably find yourself inspired to solve problems you never knew you had, and can't envision now.
+1 for Ruby Warrior. Forced me to go back and look up a lot of the stuff I didn't absorb properly during the CodeAcademy course. And it was quite fun, in an obsessive "it's midnight on a work day and I'm not going to bed until I solve this" kind of way.
Start small, do little programs to test the concepts you are learning. Then put it into practice in something a bit more complex, one of mine was a command line pontoon (blackjack) game.
I didn't take any of these courses, but I've recently watched Ruby Metaprogramming screencast by Dave Thomas and found it very deep and detailed (http://pragprog.com/screencasts/v-dtrubyom/the-ruby-object-model-and-metaprogramming). He is a good teacher, and the technical quality of Pragmatic's learning materials is satisfying. There is another Ruby course taught by Dave at Pragmatic Studio that attracted my attention: http://pragmaticstudio.com/ruby-ii I believe $180 is a reasonable price if you learning Ruby for professional use, and at least half of the curriculum topics are new for you. Otherwise a good book will be enough.
thats awesome, thanks for info :)
tap For example: [:z,:b,:q,:s].reduce({}) do |a, e| a.tap do |acc| acc[e] = e end end tap always ensures the hash is returned. 
Why not just do this: it "extracts emails" do expect(subject.email).to eq "john_doe@email.com" end
Layout is the main feaure there. You want to get the layout right if you are to generate readable/manageable code (not even speaking of generaing Python code). Afaik, there's no other code generator which is capable of that.
Thanks! Just added the link to the page.
Yes - there are better syntaxes than the one in the OP. `specify { expect(subject.email).to eq("john_doe@email.com") }` is another correct one-liner solution. I wanted to know how to accomplish what Myron Marston pointed out, but still I'm kinda confused.
+1 for _why's Poignant Guide! You could also try learning Ruby the hard way, but that's probably better for your second language: http://ruby.learncodethehardway.org/book/ I loved playing with Sinatra, but I'm curious about dabbling in Rails a bit more, so thanks for the Rails for Zombies reference. :D *ETA* If you start playing with Sinatra, once you get a solid little practice app together, you can stick it up on the web with Heroku for fun. It's super easy, and you don't have to worry about dev/test/production environments or anything: https://www.heroku.com/
You can save another character by dropping the ampersand and just using `users.map(:email)`. 
Except...steveklabnik doesn't write gems, he just ingratiates himself with the owners of popular gems and sits there merging pull requests, taking credit for other people's work while tweeting mindlessly about feminism. Biggest fraud in the Ruby community bar absolutely none. 
yup. i tell people learning ruby to just grok everything about enumerable/enumerator/yield/blocks. curse any ruby tutorial that even mentions introspection. 'computers store large quantities of data, and so we need sick methods to process that data': boom.
i like this. i was always annoyed by having to run the python simple web server to work on JS apps for some reason...
i want to do this so badly at work, but there is always a "more readable" way. I almost had one yesterday but I realized it was just a simple regex :&lt;
OH because acc[e] = e returns e? NOW I GET TAP.
Is this for real? I'm curious of the history/reasoning. I googled it quickly but didn't really look into it.
`elsif` also drives me nuts, yes.
Yeah - the point is that `a.tap` returns `a`, whatever the block returns. The alternative is to write [:z,:b,:q,:s].reduce({}) do |a, e| a[e] = e a end 
Completely agree on almost everything he said. Mutability and open classes are a mixed bag. Incredibly powerful but also incredibly easy to abuse. My biggest concern with immutable objects is constructor complexity. If you move all responsibility for object mutation to the constructor and the moment of object construction, you have to be much more deliberate if you want things to stay maintainable. There's also the simple reality of economics. Good luck hiring Haskell people. Hiring Rubyists is already hard enough. I tend to believe that recognizing the problems of Ruby and fixing Ruby is the more pragmatic path.
AWESOME for some reason i thought it returned the OG object unmodified but that would be silly...
I started off reading this defensively but found myself agreeing with everything. Ruby get a lot done and it gets it shipped fast. That is why I still cling to it. I am however also sipping the Go koolaid like you are to Haskell. I found it to be quick to write like ruby but type safe and concurrent. I see a lot of fellow rubyist in the Go community, so I think the sentiments in this article are wide spread.
Yes. I started writing more and more Go as well and working towards extracting and rewriting some parts of an existing rails app in Go. 
The dangers of mutability and side effects are over-hyped. Simply avoid writing highly coupled stateful code. By breaking state into many different objects (just like you'd write a bunch of types in Haskell) you make state transitions more explicit and easier to test. Value objects also help for when you want to separate data from functionality (author even mentions [adamantium](https://github.com/dkubb/adamantium#readme)). Unit-tests are nice but no replacement for actual documentation. Annotate the acceptable inputs/outputs of methods using [YARD](http://yardoc.org/) tags. Testing doesn't have to be difficult, just use better tools such as [mutant](https://github.com/mbj/mutant#readme). We have some awesome tools, we just aren't using/improving them. &gt; The majority of my job consists of maintaining about a dozen legacy Rails 2 / Ruby 1.8.7 applications, written between 2008-2010, with essentially zero tests amongst them (when I started). There's your problem right there. Technical debt sucks and ignoring it won't make it better. Thankfully there is the [backports](https://github.com/marcandre/backports#readme), various linting tools (ex: [rubocop](https://github.com/bbatsov/rubocop#readme)) and various tools for auto-upgrading syntax. Upgrading apps to newer versions is always easier when you have full test-coverage (see mutant). Also it's never a good idea to start a blog post by quoting yourself... tl;dr Ruby doesn't have to suck. Up your game.
The issue here is that you are doing TDD instead of integration level tests. If you write tests to your API/external interface and write no tests for the internal functions you have a lot less testing to write and still can sleep soundly knowing your code works.
As someone who is JUST beginning to learn Ruby (and eventually Rails), thanks a ton! *air five*
What's your...
&gt; If I had more substantive experience with Haskell I would certainly list its warts. This is what I refer to as "the new language smell". At first you see all the awesome features. Then after some significant usage you start to discover the warts. There are many blog posts on reddit/HN where the author is an expert in language A and critiques it's warts, but makes the mistake of comparing it to language B which they lack expert knowledge in. Apparently reddit is not updating my comment. Your critique seems to focus on legacy Rails apps which raises the uncomfortable question, what if Rails is the problem and not Ruby/TDD.
I think the problem with Ruby is the way Ruby is commonly used, not so much the language itself. I don't have the same issues in Python, even though I can do all the same things. The difference is at least partly cultural. If I could have Python's community and Ruby's language features, I would be very happy.
Well channels are the preferred concurrent communication mechanism and that's not exactly what I'd call "shared memory".
No need for Haskell kool-aid. Elixir solves the problems of testability, state, and not clogging your workflow with massive cognitive overhead just fine.
What would it change?
I've used this trick before, but using __method__ instead of __callee__. This link has an explanation on the (lack of) difference between the two: http://apidock.com/ruby/Kernel/__callee__
Linters/code-metrics will help you identify problem areas of the code-base. So you don't have to run them under the same Ruby version the app requires. Also you should plan in advance for when to upgrade dependencies. Running EoLed code is technically a security risk. Not to mention 1.8.7 lacks a byte-code VM and has terrible GC compared to 1.9/2.0. Note that I never recommend a grand refactor. I prefer to do incremental refactors over the life-cycle of the project. My first step is to improve code quality and test coverage; which also helps familiarize myself with the code-base. Then I start extracting complex logic into other modules/classes in `lib/`, then eventually moving them into smaller gems which other developers can work on in isolation. I've done this on a few pretty massive projects. Although one time the requirements changed so fast that all my code got scrapped anyways.
LoL this is just ridiculous indeed. I mean come on you're bashing against a tool that many people love and that someone invented just because he thought "hey let's make work easier". What do you bring to the table?
&gt; Testing in Ruby requires a great deal of effort that doesn’t seem to get acknowledged much. You'll be astonished to see it's the same in other languages. Java springs to mind. Really I understand your frustration and the need for a new shiny. But after a few years it's just more of the same. There is no perfect design, code will never be bug free and stuff gets complicated fast. 
 [:z,:b,:q,:s].each_with_object({}) do |el, hash| hash[el] = el end
Scala is also a nice alternative, has some ruby-like conventions with static typing and good performance. However Scala is also quite complex when you dig deeper and I think Elixir/Erlang has the edge in concurrency. 
You're using Ruby 1.9.3 and not displaying exceptions. My code, which ran fine on my local Ruby, was failing silently on yours. (I was specifically using [`Enumerable#lazy`](http://ruby-doc.org/core-2.1.2/Enumerable.html#method-i-lazy), which was introduced in Ruby 2.0; but there are an infinite number of other places this silent failure could cause problems, version-related and otherwise)
Interesting, I'll check it out, neat name. The original exception currently is not reraised, although that makes sense, I'll probably put that in next. There is however, an on_retry callback that gets the exception as the first arg. Sleep accepts a proc as well as a symbol for a predefined strategy. The proc should return any integer you want to pass to the sleep method. I should allow passing a plain integer, thanks for the suggestion :) 
ruby is quite a capable system glue language. it could be almost as terse as shell, and is a replacement for shell in many scenarious. unix tools are known for their shortened and cryptic names, and there's "uniq" program in unix. I think it was the inspiration.
1. Something happened to your indentation. (see https://github.com/ilanasufrin/subreddit/blob/master/lib/subreddit_generator.rb) 2. Make sure you don't check in files like `.DS_Store` (https://github.com/ilanasufrin/subreddit/blob/master/lib/.DS_Store). You can add it to your global gitignore (https://help.github.com/articles/ignoring-files).
As a Rubyist I love Elixir to death. I just wish Elixir had mocks, or maybe I'm just having a super hard time testing my use case. But :gen_tcp, I want to listen for connections but would rather have a fake and verify messages on it. I don't want to use Meck and I can't think of any way to successfully test it without integration testing it. Every language has gotcha's. You just have to decide which ones you want.
I'm just starting to learn Ruby and will be using Ruby on Rails Tutorial by Hartly. Pretty much everything in the article and these comments is greek to me. It seems there are TONS of different things/languages/etc going on. How long will it take me to understand what everyone here is talking about? Also, how can I make sure to test properly, etc so I don't run into these problems?
I thought that it was clear he was referring to functional languages as part of the solution, instead of statically-typed languages like Java.
I believe that was the entire motivation behind Scala. The "scala-ble" language. It has a good amount of the simplified syntax like Ruby, but it also lives in a largely functional neighborhood while still being built to run on the JVM. 
A lot of what they are referring to are the benefits of [functional programming](http://en.wikipedia.org/wiki/Functional_programming). That would be the best place to start understing what they're talking about.
Thank you for the reply. I'll read through this a few times so it sinks in.
Also, one of the best ways to understand functional programming is to install a language like [Scala](http://www.scala-lang.org/) or [Clojure](http://clojure.org/) and just start playing around with it, trying to solve simple problems using functional tools.
Upvoted for progress.
In my drunken state...I saw the grammatical error but had no idea what you were talking about. Then it hit me. We are one in the same. +1.
After you get the basics down, Eloquent Ruby and POODR are two of my favorite Ruby reads. I personally would steer clear of these "online courses." I've yet to find one that brings you the breadth of information found in a book. In my experience, online courses give you enough information to get you excited...and then have no clue what to do next. Books will help you put it all together. Read books. Watch videos. Read blogs. Write code. Search Google when you fuck up.
I've recently been learning Ruby and the Rails framework, and I've heard quite a few horror stories about people inheriting older Ruby projects. I've also heard about the nightmare of testing for every possible situation and how no one ever writes tests. I've worked at a couple of places that did C# and Java and - to be honest - there were *very* few tests. Your article seems to show that Ruby is *inherently* difficult to maintain. All of this talk kinda scares the bejesus out of me because, so far, I'm really enjoying Ruby. When I read things like this - which are fairly common - it makes me wonder if I'm just wasting my time. What about C# and .net mvc? What about Java and spring mvc? Why shouldn't I just focus on that. You talked about Haskel - hell I don't even know if there's a web framework for that. Isn't *every* platform a pain in the ass to maintain, or is it really just Ruby? I'm not trying to be facetious, I just want to make sure I'm making a good investment in time. I mean, isn't this a problem for JavaScript too? TypeScript is starting to really make a name for itself by offering static typing for JS... could it be possible that there could be a dsl that compiles down to regular Ruby code just like TypeScript does for JS? I'd like to think that there are some solutions and that starting a project with Ruby isn't just the fucking catastrophe that everyone makes it out to be. 
What's the problem you're having?
Functional languages don't require testing?
&gt; The dangers of mutability and side effects are over-hyped Ok.... &gt; Simply avoid writing highly coupled stateful code This statement is meaningless. The word "coupled" seems fashionable nowadays but it seems like its loaded to turn off the reader's critical thinking. Using better defined terms, what tools does Ruby provide to reason about the runtime behavior of a program apart from actually running it? Haskell provides 2 such tools: * Equational reasoning. Equality between expressions &lt;=&gt; the expressions can always be substituted for each other. This is what you get when you are disciplined about side effects. * Static typing. The compiler enforces many static invariants and allows you to define your own. &gt; By breaking state into many different objects (just like you'd write a bunch of types in Haskell) you make state transitions more explicit and easier to test That's true but there's a massive difference. Haskell makes these transitions explicit using its type system. I know exactly the kind of state a function takes and outputs. &gt; Value objects also help for when you want to separate data from functionality That's a good suggestion but why would you give it if you've clearly stated that "the dangers of mutability are over-hyped"? &gt; Annotate the acceptable inputs/outputs of methods using YARD tags Even better, let's have the compiler enforce these contracts for us and even infer them so that we need not type them. Of course you all can substitute haskell with your favorite statically typed functional language. Pick from Scala, OCaml, F#, (Rust soon).
I like how you went out of your way to specify your gender. This ensures nobody will actually be able to be critical of anything.
A couple months to a year of consistent study/practice. Doesn't even need to be that intense. Just give your mind time to wrap itself around all the concepts.
Yeah, I tried some stuff. You can see my continued adventures elsewhere in this thread. http://redd.it/29pvox
Because it's [easy](https://github.com/regularfry/rake-dpkg).
Thanks again. I await your response, but will continue to look into this as well.
Good script, any tutorial on how to make it into a command line application. $command 
Rust **is** really awesome
There's just way less to test. Since your objects are ideally immutable, they never change. The kinds of testing you'd normally be doing would become trivial. [Rich Hickey](http://www.youtube.com/watch?v=-6BsiVyC1kM), the creator of Clojure, describes, in part, why this is valuable, by explaining that it takes time into account in a way that object-oriented logic does not, and in a way that better reflects the real world. In object-oriented code we have a President object reference, and we would need to test to make sure its data was correctly updated everytime something about the current President changed. But from a functional perspective, you'd have a value, President in 1976. Now, you no longer have to check to make sure the President in 1976 is a Republican. It will always be true, there's no reason to check. In 1977, a new value is created to represent the new President without changing anything about the President in 1976. And the thing people really like about it is that no one else can change anything about the President in 1976. Everybody will always agree it was Gerald Ford. At least that's how I understand it.
I don't think you'll complain much about writing types in haskell, its type inference is really good, some times it feels more like writing in a dynamically typed language.
A hash of arrays.
First of all I'd recommend restructuring. Your Books class is trying to do too much; its a representation of a book, a library *and* an interface to interact with the user. It's better to separate those things. All the Book class (notice that it's singular) should do is represent a book. class Book attr_accessor :author, :title, :rating def initialize(author, title, rating) @author, @title, @rating = author, title, rating end end You can create a Library class, but it'd be easier to use a simple Hash. (Don't do this for any serious project however, as two different books can share the same title. This system does only allow one of them to exist. When you add a second one, it simply overrides the first one.) class Library attr_reader :library def initialize @library = {} end # #add, #update, #delete here, make sure not to use puts in here, # because that's interacting with the user and not a job for a library. # Remember Book represents your book. def to_s # here goes your string representation, no putsing again end end For interacting with the user, what you did looks alright. The thing to do now is add some puts statements based on the *result* of Library#add, etc. To print the library, `puts library` will be enough. Your original problem had to do with `library[:title] &lt;&lt; { :key =&gt; "value" }` not being valid. You should have used something like `library[:title][:key] = "value"`. Hope this has been useful. Feel free to ask questions when you're stuck.
It's probably because you're running 64 bit ruby which is still kinda wonky in Windows. I tried running it on my old 1.9.3 installation and it didn't even need DevKit. http://i.imgur.com/iSjUQbg.png Will edit this once I try it on 2.0.0 32bit.. EDIT: It's working on 2.0.0 32 bit. Try downloading a 32 bit 2.0.0 or 1.9.3 and run the commands in the screenshot below: http://imgur.com/MeOjajo.png
I think the real underlying issue is that encapsulation is not something most rubyists (or programmers) ever really practice. Functional programming seems to offer a good set of training wheels, although I don't have a lot of personal experience with it. When folks learn to write abstractions that aren't leaky, and properly reduce a problem set to the minimum input/output signature necessary, they also tend to do a lot less testing. Functions seem to fit that bill, but my experience with ruby is that you can learn to consistently achieve that in an OO language as well. IMO the cargo cult that TDD has become has set us back years. It doesn't stop us from writing non-reusable code, but it gives us such confidence in whatever we *do* write. The general push to build "minimum viable" features leads to engineering teams that avoid even discovering what they're building "Hey, we've got tests. We're good." So they never put in place the right kind of encapsulation around different components. SOLID is a neat set of guidelines for writing objects. It makes for great Sandi Metz talks. But their inspiration should be applied to larger components of the system. Unfortunately, most rubyists don't do this, and they wind up with a test suite that actually helps glue together the giant ball of mud that's been built. **TL;DR** those of us that are in a similar place as you... we're not going to enjoy programming again unless the whole community (including us) improves our design and encapsulation skills.
You'll probably want to look into installing the DevKit for windows so you can build Ruby Gems from source. Sometimes when you do a gem install, it still builds from source. If you were using Cygwin, or Linux, you wouldn't have to worry about this, but with Windows Ruby environments, you'll want to look at the DevKit, judging by your screenshot.
Hi Peter, author here, sorry, I've just added your book (the first Ruby book I ever read btw!) and will add other apress books. I had not finished the page actually, not sure how Categoria came across it, but I'll soon add the possibility for visitors to add new books and fix errors if any.
indent with 2 spaces :D why the class variables? You might want to check out the Hartl Rails tutorial, as this would be a great first rails app (you know, after suffering through Hartl's twitter clone). In this instance, couldn't you do @@library = Hash.new { |library, title| library[title] = {} } @@library[:title][:author] = "A Book" ? Still better to do this OOP as sandinyourbed suggested. A book stores book data, a library stores books, and a _____ does ____ with them. Follow the convention of #add #update #delete #find #all because that's what crud/rest/web apps all are. 
To combine two arrays? there is a need. obviously you can't manually write out a hash every time you need to combine two arrays to a hash. 
I still trying to understand the logic and structure of OOP. I had some previous help with refactoring the above code. I getting a hang of the class objects, what they are, and how to separate them.
Start educating yourself about automated/unit testing and more specifically test driven development. 
Except, it's not. Your gem doesn't actually export its rake tasks that I can see, it merely provides rake tasks to enable one to build Debian packages.
Let's try a completely different approach. Go to the Gemfile in the `mumble-dicebot` repository and change gem 'protobuf', '1.4.2' to gem 'ruby_protobuf', '0.4.11' After that try running `bundle install` again. Then the ruby script itself, `ruby mumble-dicebot -h` There is a problem compiling `eventmachine 1.0.3` on Ruby2-64bit. The bug [has been patched on `eventmachine master`](https://github.com/eventmachine/eventmachine/pull/497), but a new version with the fixes hasn't been released. OR If you're feeling really brave you could add to this to the `Gemfile` instead. gem 'eventmachine', :git =&gt; 'https://github.com/eventmachine/eventmachine.git' That will get the master `eventmachine` branch and compile it, which would let you use the `protobuf` gem instead of the pure ruby implementation. This usually isn't considered a good idea because there is a chance that the `eventmachine` master branch isn't stable. But, I've done it before because of Windows compilation fixes.
It was merely a joke
I see you have a mumble bot there. Here's a plug for my ruby based mumble client api. https://github.com/perrym5/mumble-ruby
Thanks for the advice. Fixed the indentation :)
Thanks for the advice. I've fixed the indentation now :) And I'm currently reading up on gitignore. I'll be sure to add that folder to future repos
You should come back and visit! My current classmates and I are all curious about what comes after Flatiron! 
It looks interesting, but I want to see if I can get this bot working first since it's already set up for what I want: dice-rolling. Playing audio files will be worth checking out later.
I uninstalled everything to have a fresh start. I installed 1.9.3, and it worked. At this point I have the bot in the server, and it responds to the help command, but not to the trigger for actually rolling dice. http://i.imgur.com/WecRJeg.png Not quite sure where to go from here.
since you said baby programmer.. write your functions in a file. let us call it 'imba_method.rb'. while, in the same folder as the file, in the console type irb. This will start irb (no surprise there). type: require './imba_method' and now call your function. I think this is what you want, but there are better ways. google minitest tutorial. this should get you started class TestTruthiness &lt; MiniTest::Unit::TestCase def test_your_method call_your_method # might wanna look into assertations end end
yeah yeah, i know :(
[The RSpec Book](http://www.amazon.com/The-RSpec-Book-Behaviour-Development/dp/1934356379) is what I used when I first starting learning how to test. It's a great book that covers not just how to test plain ol' ruby, but also TDD/BDD methodology. The syntax is a little dated, but it's super easy to find and learn the new syntax. PDFs are also floating around online if you don't care to buy it (although it's definitely worth the money for a used copy IMO).
You want [Eloquent Ruby](http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104)! This book is perfect for someone that is coming from a different language and has some of the basics of Ruby down already.
+1 The list OP gives is basically an ad for what Eloquent Ruby covers :p
["test", "test2", 1] * " what "
woosh!
Destructuring with inject/reduce is pretty sweet: {a: 1, b: 2}.reduce({}) {|result, (k, v)| result[k] = v*2; result} =&gt; {:a=&gt;2, :b=&gt;4}
This is awesome, thanks for sharing!
I agree...I haven't yet encountered a situation where using a proc was the BETTER solution...no matter how badly I've wanted to do so. This is probably why it remains so obscure.
The Well Grounded Rubyist just released its second edition. Great book!
ThoughtBot guides: https://github.com/thoughtbot/guides
Range to infinity [1] pry(main)&gt; inf=1.0/0 =&gt; Infinity [2] pry(main)&gt; 0..inf =&gt; 0..Infinity [3] pry(main)&gt; (0..inf).include?(98123981723981723981723981723981723918273918273198237192837) =&gt; true [4] pry(main)&gt; inf.class =&gt; Float The beauty is that it behaves like a number. 
I would like to know the answer to this also.
 irb [2.1.1]$ [[1,2], [3,4]].flat_map { |n| n &lt;&lt; rand(10) } =&gt; [1, 2, 7, 3, 4, 5] irb [2.1.1]$ "abc".gsub /(.)/, "a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3 =&gt; "123" irb [2.1.1]$ [["A", 1], ["B", 2]].rassoc 2 =&gt; ["B", 2] irb [2.1.1]$ [["A", 1], ["B", 2]].assoc "A" =&gt; ["A", 1] irb [2.1.1]$ x = -&gt;() { 123 } =&gt; #&lt;Proc:0x007fd1fa356578@(irb):142 (lambda)&gt; irb [2.1.1]$ x[] =&gt; 123 irb [2.1.1]$ "b".prepend "a" =&gt; "ab" 
Excessive white space is also a problem. Try not to add newlines between everything; instead, group code into logical paragraphs. There's also a couple other formatting tweaks I'd do. I'll just show you the changes here: http://pastebin.com/NFQBfswc 1. avoid excessive whitespace 2. I think the "else" in the begin..rescue clause is unnecessary. Instead, I'd just rescue from specific exceptions instead of globally. In general rescuing all exceptions is bad practice. Some other comments: 1. Not sure Subreddit needs a class. It seems like the only method would work equally well as a class method, and a class with only class methods may as well just be a module. 2. Regarding your idea for further exploration, check out http://ruby-doc.org/stdlib-2.1.2/libdoc/optparse/rdoc/OptionParser.html. 3. Try RSpec! It's great. 4. I believe you could change the require relative ([here](https://github.com/ilanasufrin/subreddit/blob/master/lib/subreddit.rb)) to just be require 'subreddit_generator'. I've never been a huge fan of require_relative, it feels hokey. 5. I don't think you need to include mechanize in both the Gemfile and gemspec. Just the gemspec is convention. Hope you enjoy Ruby!
[The Ruby Way](http://www.amazon.com/The-Ruby-Way-Techniques-Programming/dp/0321714636) 3ed!
Also, -1/0 is -Infinity
What does this do? At first glance, I would assume it would evaluate to empty hash.
What's wrong with the railtie approach? Works pretty well and cleanly for me.
There are ten lessons, released weekly. You work at your own pace. It helped me a great deal. It gave me the ability to use Ruby to glue gems together and build things on the web. Things that are useful in the real world, unlike some other tutorials that I've gone through. You are not going to learn Rails in the course, but you will learn Sinatra, which allows you to start small yet still be able to easily create simple web apps.
so why do you post that in the thread if you're new to ruby?
whitey
Does anyone know how to get {one: 'one', two: 'two'} from ['one', 'two']
I've become a big fan of each_with_object. Very much like #inject, but without having to return the accumulator at the end of the block.
Fetch is very useful, and generally safer than using the "v = hash[key] || default" pattern if nil or false are possible legitimate values in your hash. Which reminds me that the best tip or trick I have for Ruby devs is "Read the Sandi Metz book" :)
Hi Ilana, great to see you're interested in open source! Welcome to the Ruby community. I won't talk about white space and indentation fixes, all I can give you is a pointer to an established style guide for GitHub: https://github.com/styleguide/ruby. Never mind about using only TomDoc, you use whatever documentation tool you like, either RDoc or YARD is fine too. Anyway, I would rather focus on a couple of other things: 1. Look into Thor. http://whatisthor.com. It is a library that allows you to create solid CLI applications, like Subreddit. You can then pass options to it in order to not requiring you to change the gem like you mentioned in the README. 2. You are using the same class name for both features, did you intend to refine Subreddit? Meaning, did you want to override the `random_subreddit` method that way? If you didn't, then probably you should create a different method inside one single class. You would have a single class called `Subreddit` with two methods: `random_subbredit` and `random_subreddit_with_link`. 3. Once you consider point 2, you might want to consider a refactoring, in the way that the `random_subreddit_with_link` is running the same code that `random_subreddit` is using. Try and extract the common piece of code into its own method and call it from the other two. The only difference would be the extra code of providing a link. 4. One common and really important aspect of a gem is that you keep classes in their files which you are doing great. What you could do to make it even better is to extract execution from the class. Below the class you are running it, which is probably not the best idea. Instead try and keep classes isolated and run your code in your bin/ file, for instance. Let me know how it turns out okay? Was I clear enough or do you need any help on what I wrote? I hope I could help you further in the art of writing software. Cheers!
I'm not sure it's exactly a trick, but something \I don't see being used much is the Set class. I've often seen people implement set-like behaviour with arrays and hashes, trying to find the common items in two sets perhaps using iterators when a simple "set1 &amp; set2" would have done the job.
Great job! I would move a "How to install" section from the very bottom to the top
Can you give an example of what you expect, then? I don't understand how what rake-dpkg does differs from what you want. Do you want the task under your own namespace, for instance?
`users.map(:email)`doesn't work for me (1.9.3-p448)
to achieve the same result as `map(&amp;:email)`you can use `pluck(:email)` too. And this can be applied to the class, so you can write `User.pluck(:email)` instead of `User.all.map(&amp;:email)`
 Range::INFINITY exists as of 1.9.3-p545 at least, if not earlier in the 1.9.3 releases. Saves having to do the 1.0/0 trick to get ahold of it.
You could lose the underscore and the splat by using `captures` on the MatchResult instead: cat, no_match = /(cat)|(42)/.match("catdog").captures cat # =&gt; "cat" no_match # =&gt; nil 
You're confusing the SO code - dealing with converting a symbol into a proc and attaching the proc as a block to a method (which is what `&amp;:symbol` does) to selecting symbols from an array. `&amp;:symbol` will create a proc of the form `{ |object| object.send(:symbol)}` - This is what SO is talking about `&amp;lambda` will just return the same lambda - This is what you are doing. You're getting an error because your passing a lambda as a block to select without an argument, which is a requirement for select as it passes each element from the array into the block.
I revised the post cause I thought it was so confusing no one would even attempt to answer it hang on here I've still got my code up here in Codecademy I'm gona read your post and try and figure this out. I haven't read your post yet just wanted to give you the heads up that I edited it.
It's been a while since it was last updated, but http://rubyquicktips.com has loads of nice small ruby tricks.
Cool! When it comes to styling and formatting, it's good to follow conventions, and tools can make this easier. Consider installing [rubocop](https://github.com/bbatsov/rubocop) and seeing what its says about your code. Making your code adhere to common standards is a good first step as it lets reviewers more quickly get to the main ideas behind what you've written. I don't know about you, but when I see a [styleguide](https://github.com/bbatsov/ruby-style-guide) or [two](https://github.com/styleguide/ruby), I begin to glaze over-- there's too much for me to consume in one setting. A tool like rubocop will show you, explicitly, what is "out of line" and if you "fix" it you'll see immediate results (ie: one less warning when you run rubocop again). I look forward to seeing your progress!
array.each(&amp;:symbol) just expands itself to a block that calls the "symbol" method on each element of the array. This allows us to do point-free programming in Ruby. array.each(&amp;:symbol) expands to... array.each { |item| item.send(:symbol) } which is the same as array.each { |item| item.symbol } More examples here: http://codingvalue.com/blog/ruby-symbols-instead-of-blocks/
Struggling with the same problem as OP. Codeacademy was good, but it is difficult to choose where to go afterwards.
My vote is really to just build something. IMO that's one of the best ways to really nail down a language—find something you want to automate and look up stuff as you go. You learn a lot of the subtle nuances of languages that way. Look up some practice projects online or visit a site like Project Euler.
Check out the [Ruby Foundations course over at Treehouse](http://teamtreehouse.com/library/ruby-foundations) When I was first learning Ruby I built simple command line apps first then stepped up to Rails to start adding web UI to those concepts.
Search for these: rubymonk codewars ruby koans ruby warrior And, of course, just build something and when you get stuck research your pain points.
Thank you. I thought maybe there's a shorter alias or something.
Recommend Treehouse also!
That was my original intent. I got an IDE for ruby and tried to only to discover very quickly that I didn't know how to deal with code that ran through multiple classes when those classes aren't on the same text document.
I haven't done it yet, but that's the direction I'm going in. Then after Code School I plan to do Hartl's tutorial.
Also `fetch` is safer for working with booleans: opt = options.fetch(:opt,true) .... foo = Foo.new(opt: false) foo.opt # =&gt; false 
When you do `&amp;some_object`, it means `some_object` will be passed as a block to a method. To turn an object into a block #to_proc is called. So `&amp;some_object` is equivalent to `&amp;some_object.to_proc` and `&amp;:french` is equivalent to `&amp;:french.to_proc`. Symbol#to_proc is a really neat hack, its implementation goes something like this: class Symbol def to_proc proc { |obj| obj.send self } end end So what happens in your example, is similar to `translator.speak { |transl| transl.send :french }`. Translator#speak passes `self` to the block it receives, so `transl` is `self`. Then we use #send to invoke the method `:french` on `self` (e.g. the Translator instance), et voilá, we're being greeted in french.
As someone who is learning ruby and has did the codecademy track on ruby not to long ago. Here is what I i have done so far: Read Chris Pine's Learn to Program and be sure to do all the exercises. Ruby the hardway (i did the first 25, but will finish the rest after cementing the current concepts i have learned) Learnstreets ruby courses Treehouse ruby foundations (up to procs and lambas) I am currently applying what i have learned so far before i finish learning the basics. The building of something can't be stressed enough in my opinion. The whole trial and error process of a small program i am working on is teach me so much. Also use any resource you can as reference, I highly suggest ruby monk for this. And as for finding something to build, what i did was abstract and idea from codecademy movies track and looked for away to apply the CRUD process. Hope this helps(Bad grammar and all) EDIT: As a fellow beginner feel free to pm. This subreddit has helped me out a lot with getting started.
They are also chainable: render_my_things(&lt;&lt;-EOS1.gsub(/^\s*/,''), &lt;&lt;-EOS2.gsub(/^\s*/,'')) &lt;p class="foo-bar"&gt;&lt;b&gt;foo&lt;/b&gt;: bar&lt;/p&gt; EOS1 &lt;p class="foo-bar"&gt;&lt;b&gt;foo&lt;/b&gt;: bar&lt;/p&gt; EOS2 And some editors (SublimeText among other one) can highlight the inner data syntax when the heredoc is well named : foo = &lt;&lt;-HTML.gsub(/^\s*/,'') &lt;p class="foo-bar"&gt;&lt;b&gt;foo&lt;/b&gt;: bar&lt;/p&gt; HTML class Foo class &lt;&lt; self def setup_my_foo(foo_name) class_eval(&lt;&lt;-RUBY.gsub(/^\s*/,''), __FILE__, __LINE__ + 1) def #{foo_name} ["bar"] end RUBY end end end Very handy.
I'm a bit disappointing seeing most of the answers on here suggesting resources like ruby monk and code school. These resources should be used for setting up the basics of a foundation, but once you have the slightest idea of what you're doing, it's best to work on projects (not tutorials!) to solidify the knowledge and find missing gaps. I do have to disagree with /u/proofeh on how to choose the projects though. He make it sound like you can just jump into anything. Odds are that anything you'd want to do will be far too complicated at your skill level. I'm under the belief that beginners should look for something in the range of 85% what you already know and 15% something new when choosing projects. If I were you I'd write a terminal based tic-tac-toe game with an object oriented design to make sure you have that down. Afterwards try learning some file i/o and make a hangman game where you can save and load previous games. After that you've got some choices. You can play around with API's and make a twitter or reddit bot. You can dive further into CS and learn about some basic data structures and make a binary search tree and write some sorting algs. You can learn about TDD and start using rspec. Or you can just jump into rails if you're feeling frisky.
start messing with ruby on your own computer. Don't use an IDE, get a text editor like &lt;text&gt; for chrome, or sublime, and learn to run code out of the command line (terminal, if you're on mac, or some terminal clone if linux. I don't know about windows.) practice doing that by doing some of the excersices on r/dailyprogrammer. Those are basics that you need, and don't get from any interactive online playgrounds. Not saying those are bad, just that they don't teach you about your own computer.
Go through Hartl's rails tutorial - it's free. Personally, I prefer Treehouse over all other free and paid online learning services.
I'm enjoying Ruby Warrior, especially now I'm into the intermediate levels, which is great for solidifying your knowledge. Otherwise though I'm in the same boat - I've looked at projects on Github and most real world programs seem to be mostly a series of linked calls between different files and libraries. No idea what's going on. Keen to learn though!
I'm going to give the same advice as I got when I started "Tests, you need them!" Look into minitest or rspec, minitest ships with the stable version of ruby. You are sharing a lot of similar code with how you fetch and handle pages, maybe that can be extracted into a class of it's own? Objects are made to send messages between one-another, this is a perfect example to try that out. This a bit of a nitpick, but you're mixing abstraction-layers with exposing Mechanize(this also goes hand-in-hand with my previous point). I would extract that out so I easily can replace mechanize with another adapter in the future. It also makes testing easier, which usually is a plus Besides that, welcome to ruby land. You are going to make great things, I'm sure of that!
Consider major components of the standard library. Go make a GUI, cross platform for bonus points. Handle some JSON. Parse some XML or YAML by way of a config file parser. Do some network stuff..? We're at the same point on the path except ive come from proficiency in other languages, if you want to chat further Skype?
Nope, both are O(n). Array unions are implemented by building a temporary hash table.
http://stackoverflow.com/questions/5128200/how-to-count-identical-string-elements-in-a-ruby-array/20411775#20411775
Does `ClickListener` only exist to bear the `clicked` method, or does it have other methods/behaviour? Because it would probably be more idiomatic Ruby to override `addListener` to call a provided block or lambda, which would capture the scope you want.
Oh I didn't know that. Thanks!
I'll suggest Codewars. It gives you small problems/projects to work on. As you get more confident, you can pick from harder problems. You can even choose what type of problems you want to work on, be it algorithms, oop, and a few more. And it's free, so that's nice
The listeners have more than one method (although I've noticed a lot people seem to think that is strange outside of libgdx). On the Ruby forum, I got a similar suggestion to pass a block that worked, except when I tried to expand it to deal with the multiple methods. For instance, ClickListener also has a enter and exit method I use to check for when the mouse is over an actor.
This is awesome, thank you! I also sent you a pull request for some small changes to your readme, mainly just grammer and formatting.
Hmm... well, I'm not aware of any idiomatic and sufficiently "clean" way to do this, but you could probably also get something going by subclassing `ClickListener` into something that takes a hash of lambdas to delegate these methods to (by name). Kind of grafting on a Python-like object system.
Could you do something like (untested); actionsCraftingButton.addListener do |clicklistener_object| def clicklistener_object.initialise(switch_actions_mthod) super() @switch_actions_method = switch_actions_method end def clicklistener_object.clicked(event, x, y) @switch_actions_method.call(:crafting) end clicklistener_object end so you're just reopening an instance of the class and passing it back? 
I've been a Rails/Ruby developer for 1.5 years now and was a PHP developer for 1.5 years before that. I actually started with Hartl's tutorial then worked my way to Code School, though it isn't so much about the tutorial as it is practical nature of building an application. I've continued to use Code School regularly throughout that time period, and I've found BY LEAPS AND BOUNDS, the best way to learn is to be developing an application and applying what you learned in code school. My suggestion is to do the Hartl tutorial simultaneously with Code School (do the Ruby tree), such that you'll finish the basic Ruby, Rails, and Rspec courses when you finish his 13 chapters. It will take longer, but you'll actually have retained it all. The more advanced courses are vastly more complex then you'll need to know for now. After that, find another application to work, and continue with the classes. Maybe do some of the front-end work and build a basic application with some jazzed up UI. Rinse and repeat - building something + expand your knowledge base in tandem.
Pretty sure I understand it now. But holy shit is it complicated. So this &amp; operator...it just behaves differently for different objects? I really wish there was a good video explaining this so I could absorb it better. I did read the codingvalue.com post and that was a bit helpful as well as your post. So thanks guys.
Yes goto [TeamTreehouse.com](http://referrals.trhou.se/davideichel) (would appreciate if you clicked my referal link if you are going to use them. :) and then go to tracks and pick the Rails Development Track. You will need to sign up for treehouse to access the courses but theres tons of content on there for programming. In the Rails Development Track you will learn ruby and then move on to ruby on rails. They will help you get your environment set up and everything so you can start to build real world applications. But ya treehouse is awesome I signed up to refresh my PHP development skills and ended up learning CSS, JQuery and Bootstrap/Foundation which help me to build awesome looking sites.
Curses is one approach, [Highline](http://rubygems.org/gems/highline), which uses readline, is another.
Windows Command prompt or Cygwin, and Notepad+ on windows is ok. I loved that you (acted like you) didn't know this for windows. Cold hearted bitchy awesome if faked and hope for the future if true.
When you step up to an unfamiliar modular collection of code like this, you need a different skill set than just coding: build and collect object diagrams. There are tools that will build out charts showing how things link together, or you just draw boxes and make notes on blank paper or a graphics app until you get enough understanding. You can do this with following calls, intuitive guesses based on calls and filenames, traces, debugger output, googling, API documentation, or inserting code to help find where you are. This is a rare and underrated skill, btw. Pain in others' poor labeling helps you recognize good labeling, good docs. It helps you not write write-only-code. And I can't count the good developers I know who rewrite because they can't grok complex code.
Sounds like you have a .to_s on an object that is nil.
nil.to_s #=&gt; "" Implicit type conversion sounds more like trying to concatenate nil to a string.
...but you _do_ have to pass in a block that actually does something
Did you try the method "sendkeys"? For example, class.sendkeys('enter')
If it is just driving a web browser then you could look at [Selenium](http://docs.seleniumhq.org). 
I've seemed to fix it. I imploded rvm and then started back at square one. I used homebrew to install everything instead of git (just to do it a different way). Then once I was ready to start installing gems I followed the instructions of the video the way I did before. When I created the testapp no errors and I got the welcome page. I think the issue was with SQLite or something conflicting with rvm. Either way I'm not messing with the dev environment as long as it's working. Now on to figuring out how to program with ruby and rails. I love a good challenge and I've already troubleshooted a big one. Wish me luck!