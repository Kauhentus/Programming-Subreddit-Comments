&gt; Small size rather than execution speed Just to clarify, is this saying it's slower or faster than regular ruby/mruby?
So letting methods be stored in variables and getting rid of procs would change the look/feel of the language? Can you give a short of example to demonstrate this? It seems to my novice eyes like it wouldn't be much difference appearance-wise at all--just 1 less syntax to memorize.
Let's look at this code: (1..10) .select { |i| i.odd? } .map { |i| i**2 } .take_while { |i| i &lt; 30 } .each { |i| puts i } (Try to play with it, if it is not obvious what it does) What options do we have if we want to ditch blocks from the language? **Option 1**: Rewrite it with "just methods" (1..10) .select(def(i); i.odd end) .... It looks pretty odd already (OK, we can say it is because of Ruby's method syntax, it "could be changed" too), but more important -- what I've written above, that it _feels_ different: "I don't want to create a method every time I need to map 5 numbers to their squares, it feels so ineffective!" **Option 2**: Leave this syntax as is, but say that when block code is passed into a method, it is just a method, too. This will change the language system significantly, too -- we will have "methods" with, in fact, different behavior (ones that defined explicitly with `def`, and others that are born from code blocks) -- their scope, closure behavior, "owner object" and so on. In fact, we will _still_ have two different "method types", just named the same way. (And yes, other languages solve the problem in different ways, that's how they are different :)) The point is, Ruby is **not simple, but pretty consistent**, almost no part of it can be "simplified" without significant loss of this consistency. So, my advice if you are just studying Ruby is to try just "internalize" how things are working here, not "fight" them (with "Why is this so dumb?"). Eventually you'll feel how it all fall in place (and then, after 8-10 years of Ruby, you'll be irritated by completely different things :)) PS: BTW, methods COULD be stored in variables and passed instead of blocks, just the construct is not atomic: m = method(:puts) # =&gt; #&lt;Method: Object(Kernel)#puts&gt; m.call('foo') # Prints "foo" ['bar', 'baz'].each(&amp;m) # Prints "bar", then "baz" 
As a general rule of thumb, less memory usage means more CPU usage. &amp;#x200B; CPU x memory has been a long time tradeoff.
That’s a pretty ridiculous assessment. Have you heard of Sandi Metz? Or Avdi Grimm? Or Jim Weirich? 
I am not saying that there are no good OP people. But in a mature OOP environment we would not need something as obvious as Sandi Metz books. And yes I have met them, talked to them and read their books/blogs. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [mrubyc. Targets one chip microprocessors, &lt;40kb memory limit](https://www.reddit.com/r/RubyLang/comments/axy65t/mrubyc_targets_one_chip_microprocessors_40kb/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
In my experience, learning another language's syntax isn't as hard as learning the stdlib. And Node and browser stdlibs are two different beasties.
This is quite cool but .... really. I think it would be better to have one unified code base and from that code base allow people to customize it as-is; a bit like the linux kernel + combination of e. g. glibc, dietlibc, muslc (or however the abbreviation was). I personally use only MRI so far and while I think mruby or mrubyc are a cool idea, it is super unlikely that I will really use mruby, for many reasons. One obvious one is that you need to be a good C hacker to use mruby, but other reasons are that MRI by far has the most momentum. And momentum really is extremely important.
Can we please: a) ban bots - they steal time from humans, and most bots are useless but even more importantly b) remove voting on bots. It is a disgrace that bots can have more reputation on reddit than long-term human contributors.
&gt; confusing having procs &amp; methods That depends. I don't use procs myself deliberately (if we ignore e. g. handling blocks and &amp;) but if it may fit into your style of writing ruby, then this is ok from the point of view of ruby being "multi-paradigm". Not that I agree with the functional crowd, mostly because the syntax is so terrible, but if you agree that ruby embraces a "more than one way" philosophy, then there is no way to go against it. &gt; that I've decided to leave well enough alone though That is actually a good approach in general. I use what I like from ruby and reject the rest. Many of the syntax changes in the last 3 years are absolutely terrible. Since I am not FORCED to use any of them, I can avoid them and not taint any of my code base with that. Others can decide to use it. Being flexible is actually a good thing. I'd just wish most of these changes would not have made it into ruby, even more so as I also don't feel that any of them are super-important. None of them will make ruby skyrocket above python; conversely, none of them will be the primary reason why ruby were to NOT sykrocket, either.
What does any of this have to do with the article? The article is about Value Objects, ant it explained it quite clearly. There’s not even any OO concepts in the article. Why are you bringing this up?
&gt; Yes, grasping procs could be a bit confusing for the beginners (though, as a long-time mentor for &gt; the beginners, I can assure you it is not that hard You can literally teach just about everything to anyone. The thing is that ruby is most definitely not the simplest language out there, even less so with the additions in the last few years. This may be good or bad depending on your point of view, but I would not want to go and potentially mislead newcomers into assuming that ruby is super-simple. There was another recent article with which I disagreed from the point of view that "ruby is so simple so it will dominate". Ruby is not simple. Ruby is (or can be) elegant; and it has a certain style of logic and design that is quite logical, for the most part. Ruby code can be super-elegant too. But I would not necessarily say that ruby is the simplest language out there. There are many other design decisions that are not making ruby necessarily simple. The distinction between classes and modules feels like that. It is a design decision, yes, but I often wonder why it has to be that way. Why can we not take functionality from a class, and "include" that onto another class? Only because "include" does not work on classes? That feels very arbitrary. I have no real problem with it but I would not call any of ruby necessarily super-simple. Some of the syntax is quite difficult to grasp, and with recent awful additions this is only becoming harder. Which will make it harder for newcomers to learn ruby too. Another example for this is - file foobar.rb: module X class Foo end end And in file barfoo.rb, we require foobar.rb and then have: class X class Foo end end Ruby will fail because we specified class X rather than module X. BUT! If we only want to extend class Foo, with say a new method, then why would it matter that we specify the correct toplevel "class X" variant? Of course we can work around it by doing: class X::Foo And many people do. But this is still different since it sort of forces or encourages you to write that style. And not everyone wants to use that style; I prefer spacing out code, mostly because it is easier to read (for me). That problem only occurs because of class versus module distinction. If we were not to have that, we would not run into such a (small) problem ever. &gt; And from just syntactical point of view -- note also that at the Ruby's early &gt; years -&gt;(args) { code } syntax haven't been invented and widespread in &gt; any mainstream languages, Yes - the syntax used to be better way past. :) I often said that the last really great ruby version was the 1.8.x branch. I am still using ruby today and there were lots of improvements, but if I have to pick my own personal favourite then it was the 1.8.x. Oddly enough I write more ruby code these days and while I think ruby is absolutely awesome, I am nowhere near as much attached to it anymore. It's strange. &gt; So, summarizing, any attempt to imagine Ruby without blocks/procs &gt; will create absolutely different language (and I will boldly imagine &gt; that it will direct the entire modern languages evolution into a different &gt; course, I believe that a lot of modern ES, for example, is subconsciously &gt; shaped by desire of repeat Ruby's expresiveness.) I think it is too late to completely change ruby past this point too, but I do not fully agree with your comment either. Blocks to methods are absolutely great. I love them. I think I always loved them. I can not say the same about e. g. Proc.new / lambda. I have no strong feeling against them but I tend to not use them, mostly because they do not fit well into the rest of the code. That is also a reason I do not use -&gt;() {} It looks alien and feels alien and I am glad I don't use it. 
&gt; The point is, Ruby is not simple, but pretty consistent, Finally I can agree with you.
&gt; Methods are not first class in Ruby, meaning they are not objects. Please, dude. https://ruby-doc.org/core/UnboundMethod.html We can of course go the theoretical route "bla bla bla python has first-class functions and ruby does not bla bla bla" but this is all pretty arbitrary. You can essentially do just about everything. We even had evil.rb in the oldschool days to shapechange objects into other ones (or was it classes .... I do not fully remember all of evil.rb's functionality).
It’s empty. The game engine is self contained and built on top of an LLVM implementation of Ruby. 
Hi! Thanks for the great feedback! :) &gt; Note that prepend is not available on older Rubies. - Yeah! That's actually the only constraint that defined my min ruby version 2.0! :D I'm also curious if we could still refactor/find ways to make this compatible with older Ruby versions without the alias trick. &gt; what happens in cases with inheritance? - Concerning "inheritance", I'm not too sure what you meant by that, because `before_*` is called on the `Module` (and not a `Class`), and not the `base`. I'm not sure if it's possible for a `Module` to inherit from another `Module`... if that's what you meant when you said inheritance, though if it's possible then `singleton_class.instance_methods` should not return the `superclass` singleton methods, but only instance method (but `before_*` are to be defined with `self.` and thus are singleton methods). Although I don't think we can "inherit" module from another module, a similar approach to your question maybe is through the use of "extend". I've updated my spec file, and added this an [extra spec when Module is extended with another Module](https://travis-ci.org/jrpolidario/before_hooks/jobs/502608837#L524). &gt; Using `respond_to?` might be a good solution - YES!!! You're absolutely right! :)) ^ [I've added you to "Special Thanks" section :3](https://github.com/jrpolidario/before_hooks#special-thanks) Thanks again for the feedback! :)
\`@status\` is scoped inside \`Game\` class and not exposed in the public interface of \`Game\`. If you want \`status\` and other attributes being accessible you need to expose them: \`\`\` def status @status end \`\`\` ruby provides a shortcut for this: \`attr\_reader :status, :other\_attrs\` 
Off-topic. If you're not interested in low-level subjects or plan to embed mruby in one of your programs, you're probably not the target audience anyway.
Thank you! Surprised there's no quick answer from Google
I like this answer! Good job! If I'm dealing with billions of guesses, this line: ​ one_guess_odds ** guesses would have a huge exponent. How do you think that would do performance-wise?
Ha, I knew someone like you would show up. Did you even read the full message? I told him to look at the `Method` object to get first class function like features. Why would you want to miseducate someone? I gave him the truthful answer to his exact question.
❤️ i will change to pagy gem
What are the trade offs? Are there any missing features? You could fit the whole thing within a Desktop CPU L2 cache. Although I guess not for the target processor . &amp;#x200B; 
1st time learning about it. made me want to change as well!
If you use just symbols for your enumeration typ, for example, than there's no guarantee for "anything". e.g. :grey or :gray - "nobody" will check your spelling or if you add new colors - why not :wit or :blanche or :whatever. If you use a "mutable" member than you can reassign the integer value to anything or to nil or to any type and so on and so forth. These are just examples. By definition ruby is not type safe (in a strict way).
That's handy
What the hell is a "negative scope"? Not only Rails code is alien but the terminology they use is weird. .blank? is also a rails oddity. https://blog.arkency.com/2017/07/nil-empty-blank-ruby-rails-difference/ Absolutely horrible name. Rails is like the PHPification of ruby. Although I do not refer to ALL of it that way; just a lot of it. Some functionality stored in the active* components could be added to default ruby.
Is this pasta? This should be pasta.
The trick is to ask a proper question and Google will provide :D
The naming for negative scope probably comes from the idea of Negation in logic. https://en.wikipedia.org/wiki/Negation http://www.math.toronto.edu/preparing-for-calculus/3_logic/we_3_negation.html This is why you see the "not_foo", because it goes with the idea of "P" and "not P". "foo" would be the proposition. "not_p" would be the negation of that proposition. Just like the example of "drafted/active" and "not_drafted/not_active". "drafted/active" are the proposition, and the "not" counterparts are the negation.
thanks for this. TBH I always wondered why I hated unless versus ! if so much as a concept because usually unless is more readable. But I never really gave it much thought. Now that you point out the not p idea in logic I realize it's my background that's triggering that LOL (am engineer by degree) 
Ya, I actually like to use unless in very specific situations, but it can be challenging to read most of the time. If you don't know about De Morgan's law, I highly recommend it. One of my favorite things I learned in college, and I use it frequently at work. https://en.wikipedia.org/wiki/De_Morgan%27s_laws
yeah that brings back a lot of memories LOL 
What's the counter argument here? I haven't seen any attacks on Rails, but I might have been living under a rock
I am seeing a lot of development teams choose MEAN or bare NodeJS/express stacks to develop APIs. It's a little painful for me to watch colleagues and clients spin their wheels trying to implement adhoc solutions to what I would consider "solved problems". Things like database migrations and running tests in database transactions... Testing factories... Test mocks. The few times I've suggested Rails, I have gotten the response: "but Rails is slow", or "it's better to have the same language on the frontend and the backend". I don't dislike javascript but I think npm is painful and nodeJS' event system convoluted and ill-suited to backend tasks. 
Performance shouldn't be an issue, as exponentiation with floats is very fast. However, once you get to a certain number of guesses, the odds of losing get so small that it can no longer be stored in a floating point number, and it effectively rounds it down to 0 (meaning a guaranteed win). For 1,000,000 possible numbers, this will happen around 750,000,000 guesses. To put it in perspective though, at just 100,000,000 guesses, your odds of losing are roughly 3.7*10^-44 , which is slightly worse than the odds of winning the lottery jackpot five times in a row. If you're really concerned about that though, you would need to use a more precise means of calculation, such as BigDecimal or Rational, but that will kill performance. Also, keep in mind that you would need a way of generating more precise random numbers, as the random number generator built into Ruby can't generate anything smaller than about 10^-14, which is still worse than your odds of hitting the lottery.
The Asset Management section brings a tear to my eye, with webpack (via webpacker) becoming the default asset packager in Rails 6 and the sorry state of ES6 support with good old sprockets. Makes me wanna stick with Coffeescript.
PS: require_relative "game" require_relative "result_printer" require_relative "word_reader"
Am I being contrarian by saying I don’t feel like Webpack(er) is that tough. It’s pretty good to go out of the box and after that it’s just yarn add and imports in ES6. 
The Rails 2 startup process. Not very useful now that we're on Rails 5/6
I think the JSON part is trying to get across that ActiveModel Serializer is slow, and one should switch to something else but I with they hadn't put "Ditch .to_json" in the subheading. To my understanding (perhaps naive), `.to_json` should be the fastest way possible to get JSON generation (especially if you're using oj as the article itself points out that oj replaces the implementation of `.to_json`). From previous benchmarks I've seen, `.to_json` usually will beat serializers or other framework DSLs. One example: https://medium.com/infosimples/performance-comparison-for-json-generation-in-ruby-cc2cce55cf0b
With rest apis, I find that the api testing rack and rails provide is very helpful. My rule of thumb is: - test the correct case - test the edge cases you can think of - as you find more edge cases or errors, add those edge cases to cover the regression. We had a disgustingly complex controller (and not enough time to rip the whole thing down and refactor), and taking the time to set up end to end testing was incredibly useful. I spent about a day getting the initial cases put together, but once I did, adding a new regression case took 10 minutes max and we made it to production with minimal issues. All of that being said, it sounds like thorough manual testing in a staging environment would have caught this before your pager blew up
How many times do we need to solve already solved problems?
Ok thank you, will check it out.
great article! another reason i think rails is still relevant in 2019 is that i have a great job as a rails developer, i have friends with great jobs as rails developers, and took my linkedin down because i was getting hammered with inquiries about rails developers. its easy to read a lot of hackernews and programming blogs and get the feeling that rails is on the outs, but in my experience that is absolutely not the case in the real world.
Lots of folks see more strict typing as the future, they argue that the ergonomics have been improved sufficiently enough by modern type inference/etc. and can't imagine solutions where the additional support from types isn't a winning proposition. Ruby doesn't conform to these people's vision of the future. Lots of folks see the full-combo of having all of an AOT compiler, a bytecode interpreter and a JIT as the future and see the complexity of implementing and maintaining such a language and runtime as minor compared to the gains. Ruby (currently) doesn't fit in these people's vision of the future. Lots of folks see Javascript as the future, as homogeneity is always a good thing and it can run both in the browser and most of anywhere else too and hardware has progressed to the point where a rasberry-pi type device is the smallest viable platform for computing and basically no interesting project would ever target a true embedded hardware device where a C all-in-one-binary or a feature-limited OS+small traditional interpreter are all that might fit. Ruby obviously isn't Javascript. Lots of folks see http-adapters plus functions-as-a-service plus document-databases as the future and find no value in designing explicit infrastructure and operations as part of their solutions, it's worth the cost in warm-up latency to be able to scale down to zero, and it's worth the cost in data-center round-trip latency and complex data access pattern design to be able to scale horizontally without snags (aside from the ongoing investment of effort around data access/distributed systems design). Rails and ActiveRecord don't fit in these people's vision of the future. Lots of these people are failing to see how wide of a variety there is in problems to solve or solutions to those problems and others are failing to see anything past their own specialized interest areas, some of them might be right-ish, some of them might live to see a future where things have changed enough such that they become right, all I can do is try to avoid any of that becoming my problem.
You didn't mention the one thing I miss most in Rails (compared to Node and other modern tools) which is the lack of async programming. Combine that with an interpreted language and GIL, and you end up with a stack that's very difficult to parallelize. If scalability isn't a huge concern for you, by all means, Rails is great. But it's a major limitation.
There's one line code solution. Just use cdn link
Ah, yes. There are probably some other things I forgot as well.
\&gt; If scalability isn't a huge concern for you, by all means, Github and Shopify would like a word.
&gt; Lots of folks see http-adapters plus functions-as-a-service plus document-databases as the future They've done that 20 years ago and called it cgi-bin backed by disk file storage :-)
I like Ruby, I like Rails. I've been using both for almost a decade now. That being said, I'm tired of keeping a complex Rails codebase clean and manageable and I'm tried of constantly making it "fast enough". At work, we recently replaced one of our higher scaled Rails project to Scala. All our `nil` and `NoMethodError` and all the common footguns became a compiler problem instead of a Pagerduty in the middle of the night. The replacement of hundreds of servers to 2 (for redundancy; one can easily handle the load) was a very nice cherry on top. But I still recommend greenfield projects start with Rails. Most projects don't reach the scale where scaling is _the_ problem. 
https://github.com/socketry/async is a thing.
Look up the Concurrent Ruby gem, it provides most flavours of concurrency primitives with a decent API. Not that it helps Puma or whatever compete against Erlang (for instance), but it’s there if you need it.
Same here. To me, Rails is very, very strong yet.
Judging by the way we still manage to shoot ourselves in the foot repeating the same mistakes Fred Brooks outlined in 'The Mythical Man Month' (1975), the sun will be a cold cinder by the time the IT industry sorts itself out.
[removed]
freecodecamp.org allows anyone to do work for non-profits for free to gain experience and make a portfolio/resume out of. It's unpaid but given a year it could be a great jumping-off point. Also, for juniors in Rails, I've noticed that networking locally helps more than online job posts. She should attend local meetups and network there. Good luck!
I just got a Ruby job after years of working in JS’s ever-changing landscape and I’m SO FUCKING PUMPED. Finally there is a “best way” to solve problems and an opinionated framework where our “quick meetings” won’t turn into a 3-hour debate. Fuck my body is so ready to just write good ruby code. 
When you say you took your LinkedIn down, do you mean you deleted your account?
Counter-arguments: - Real-time web that doesn't suck - An ORM that isn't inclusive and tightly coupled to the framework. - Concurrency - Assets Pipeline / Turbolinks dependency - Metaprogramming - Callback hell I can keep going. The biggest indicator of this for me was when I went to RubyConf last year, and there were at least 4 or 5 'Ruby isn't dead' talks. It may not be dead, but it's no longer the juggernaut that it once was, and people are starting to realize that. I think this is mainly because DHH has become complacent with Rails. I know Rubyists don't like to admit it, but Rails is the main driving factor for Ruby and with DHH simply no longer giving a shit because of that cash money, the ideas have stagnated, and the community has moved on. 
Generally agree with the article. Excellent points all around. I do want to point out that Webpack/Yarn/ES7 has *very recently* evolved to the point of not being terrible, nay, of being actually pretty darn good for managing front-end assets and JS, so it's a good time to migrate from Sprockets to Webpacker. I have a few small beefs with Webpacker, but overall it's a great step in the right direction. I love how easy Stimulus (and Turbolinks 5) make JS dev alongside Rails code.
DHH has never been the one to really crank out the advanced features of Rails or the performance optimization ones. The work to make Rails mature has been done mainly by Yehuda, Patterson, Valim etc. DHH is perhaps the visionary, but the framework has not depended on his ideas or implementations for a while now. Also there is no asset pipeline/turbolinks dependency. Nothing is stopping you from not using sprockets, and I don't think i've used turbolinks in any Rails project to date.
&gt; Yehuda, Patterson, Valim Case in point - Yehuda is on the Rust team; Valim founded Elixir. 
yeah, im not sure if other people have the same experience but it seems like a lot of tech recruiters just take shotgun blasts at everyone who has experience in `x` framework and the spam was just an annoyance. I felt like it probably wasn't good to just ignore everyone because I did make some meaningful connections on there, so I deleted it for the time being.
&gt;The replacement of hundreds of servers to 2 That seems hyperbolic. Can you give details? Was it purely a language switch or a large architecture change as well. 
I definitely think it's tougher than Sprockets, and don't _love_ having to use "modern" (ie, confusing) JS toolchains at all. But I have to anyway. You don't really have access to the useful JS open source ecosystem unless you can manage your dependencies with yarn (or npm, but thank heaven Webpacker standardizes on yarn, it's at least close as good as bundler). And that's not even using react/vue/whatever. Just the kind of stuff we used to be able to get from rails-assets.orgs before bower died. I don't love it, but we need it, so, yeah, I don't find "we don't need webpack we've got sprockets" to be one of the things I love about Rails, and am happy the webpacker devs agreed. I hope it continues to get support and developer UI improvement, it can still be a bit mystifying. I neither love it, nor would be 
The market for entry level developers is definitely a bit saturated. Try to stand out by working on projects (specifically outside of bootcamp projects). I know my company really likes people who regularly attend meetups. (it's a lot easier to get an interview once you have a referral, too) I would also consider applying outside of Iowa. Larger companies are better suited to taking in junior developers and mentoring.
The gist of what it did was data collection: parse some strings, look up some stuff on Redis/DynamoDB, then essentially spit out binary into a queue for it to be journaled. Async IO in Scala absolutely shrugged off the multiple network hops. String parsing and manipulation isn't exactly fast in Ruby either. Our benchmarks pretty much looked like the TechEmpower JSON benchmark result, except the (de)serialization wasn't JSON, so it didn't even have the benefit of being implemented in C wrapped in Ruby and was pretty much pure Ruby.
There’s no best way to solve problems. Teams that buy that bullshit often end up with a tangled mess on their hands. Document your choices trade offs made. You will need that information way sooner than you’d imagine.
Thank you. I guess I'm learning with a poor course
In London at least, there's no direct attack but the resurgence of Python's popularity (for several reasons) has led to a decrease in Rails (and thus Ruby) jobs.
Rails is still rich and easy to get project running solution. Everything else requires time and setup to even begin. But rails isn’t as speedy as some competitors which could be a problem for some scenarios. 8 years ago I picked rails for most projects now I use it only for few. Still like it just don’t feel like it is solo leader now. For me the biggest competitor is Golang and Nodejs. First maybe less prominent but in most cases when people start to think about node they can use go and go has crap tones of performance and safety improvements over JavaScript. Side node: bode promise of server side and front side sharing code is 100% bs imho.
It helps that in Ruby, good often means readable/maintainable but sometimes it means magic.
For a brand new project with no old JS to drag along, maybe that’s true. I recently had to do several webpack(er) config things that were not as obvious or clear as a yarn add and an import, and I’m not having a lot of fun with the additional deployment baggage, either.
I don't think an ORM is a good argument against Rails. Most "alternatives" you end up building or using from a package; here and there to fetch or store some data. Then wham-bam your right back to having a backend "tightly" coupled with a framework. Except maybe it's not... Because it's not Rails? ¯\\_(ツ)_/¯
I think webpacker needs a few more trips around the block to shake out the glitches and gotchas, but it's definitely close to prime time. I've been using it for vue.js components in a production app without too many bushfires and I'll be prepared to flip all the JS assets into packs around Rails 6.0.1.
This "vision of the future" is practically a recapitulation of the architecture of Lotus Notes. 
Definitely noticing a lot of the Ruby brain share going to Rust/Elixir. 
enums are still something of a second-hand citizen in Rails. One of my favourite refactorings in &lt;current major project&gt; was extracting an enum into a type via the Attributes API that marshalled each literal value to/from proper objects (one class per possible enum value), with methods then delegated through to them. This is effectively the State Pattern, for fans of the Design Patterns GoF book. What's more those objects implemented `to_partial_path` for easy view refactoring. 
I don't have a problem with ActiveRecord. My problem is of deeply integrated it is with Rails. Other ORMs are separated so that you can use it outside of the framework. Check out Hanami and ROM or Phoenix and Ecto. 
This is not unique to Ruby or Rails. The average job length held at a company for programming is about 2 years. First 6 months is spent investing into a developer to become adjusted to their work environment. The reason why many companies do not hire junior developers is because of the risk involved. &amp;#x200B; A great portfolio speaks volumes. Source code should be available, but don't worry too much about code quality. If she is willing to grind, then freelancing is an option until a job is available. It will let her apply her skills, in exchange for some amount of money. Doing this will teach her the importance estimates, project management, client communication, etc. An issue with freelancing is that your competing against India and China, with local companies that offshore their development and lie about where their programmers are located. So its a race to the bottom of who charges the least and can get it done in the shortest time. Having done this myself, its possible to make money this way as you can slowly charge more and more and weed out bad or cheap clients. I learned more freelancing then I ever did at any other job, but it was brutal. &amp;#x200B; Also get her invested into writing articles, producing videos about her working and what she has learned. Then as the others have suggested join meetups locally, but given the location, there may not be a Ruby specific one, so I'd broaden the scope to anything programming related. Online meetups work too. &amp;#x200B; From all the people I've interviewed, the ones with the unique portfolios often win. I go absolutely crazy when I need to interview 10+ people that all came from the same boot camp or college AND they all have the same projects. Most of them didn't even care about the project enough to have a discussion about it. &amp;#x200B; Also if she is locked down to her location, then research jobs on .Net, PHP, Java, and JavaScript development. Knowing a specific language matters to a company. Use online job searches to get an idea of what companies are looking for. &amp;#x200B; &amp;#x200B; &amp;#x200B;
But then you can not easily modify or extend it, or select the parts you want to include from the framework. So it is less (or should I say sass) fun.
&gt; Rails (and Ruby) Have a Deep Culture of Code Quality Sorry but that is crap. A language on its own has very little to none "culture of code quality". Code varies immensely if you look around, due to many reasons. To assume that there is an intrinsic quality to any of it is just totally wrong. &gt; Writing clean, readable code has always been in Rails’ DNA. I always felt that rails code feels super-alien. Ruby can be hugely elegant but it can also be abysmal shit. Not all parts of the syntax are pretty. @@foo variables? What does this tell us about repetition of "identifiers"? Now in fairness, class variables aren't the worst. We only have to look at additions in the last ~3 years to get more serious syntax crappers. It's possible to avoid all of this, which will lead to a much saner and more readable code layout - but to assume that you have a high automatic "code quality" is just totally rubbish. Even in a good language such as ruby, people can write horrible jokes with. &gt; But in fact we need to focus on humans, on how humans &gt; care about doing programming or operating the application &gt; of the machines It's the philosophy of ruby and matz is right here. On the other hand ... the focus for ruby 3.x also has been on speed, so ... :\ :/ :\ :/ &gt; Rails automatically generates tests as you build code, &gt; encouraging developers to write well-tested, clean code. I actually hate rails being that opinionated. I don't let ad-hoc frameworks dictate how I write code in ruby in general, so why should I abandon that and "embrace" the rails way? How does that fit into the "there is more than one way to do it"? The TIMTOWTODI also means that I can avoid and reject horrible ways. Autogenerating boring boilerplate code is not a good idea. &gt; Some would argue that Ruby and Rails were the combination &gt; that pushed TDD and BDD principles into the development &gt; lime-light. I don't use either one and I am doing just fine. &gt; Why does TDD seem to be more prevalent amongst Ruby &gt; developers than Javascript developers? Because JavaScript is a complete and utter joke. Actually JavaScript is the number one reason why JavaScript has not taken the world yet. Who wants to use that joke of a language for projects? The only reason JavaScript got big is beause it is abusing its monopoly situation in the browser segment. And the browser + www are the most important components by far. &gt; Javascript’s webpack is notoriously difficult to configure. JavaScript is a terrible spaghetti mess. There is a reason why we read about idiocies from npm daily. It makes for entertainment, but boy do I pity the poor souls writing JavaScript for a living. &gt; Ruby is a Pleasure to Use &gt; Ruby as a language is simply gorgeous. It depends. I think in general ruby is great. I do NOT think that all of ruby is great. And I certainly don't think that there is that much awesome code to begin with out there. A lot of code is really really crappy. I think ease of use partially encourages laziness - and lazy folks are those who end up saying "hahahahaha I am so uber great, my code does not need comments or documentation because it is self-explanatory hahaha". These are the folks you just don't want to have in any team really and unfortunately ruby encourages this by being elegant and concise. Which is, on the one hand, great; but that this breeds laziness is terrible. And while conciseness is great, when conciseness happens to lead to shitty code, then it is the wrong way to go. See some of the additions to ruby in the last 3 years for that. &gt; It gets out of your way, supports flexible and concise metaprogramming, &gt; and has a fantastic standard library. Eh. And, by the way - metaprogramming often leads to worse code layouts. People seem to want to believe in magic. "Meta"programming can offer more flexibility, which is good; but it is bad when it comes for increased or added complexity. &gt; RSpec is quite simply the gold standard for behaviour driven &gt; development, and almost single-handedly created the BDD movement &gt; that is still raging in the industry today nearly a decade later. Yawn. But if it works for you ... that's fine. &gt; Rails is all about getting on your feet quickly and being ultra-productive &gt; by leveraging it’s OpenSource community. Rails provides you with the &gt; tools (and the documentation) to get up and running immediately. Now I see why bundler got big - the rails folks add so many dependencies that they get confused as to what is used how and when. Poor lost souls. &gt; While certainly a bit expensive when compared with AWS, Google Cloud &gt; Platform or other solutions, Heroku is something entirely unique. Ugh. So now we do company-promos too? What happened here? Do we now need company saviours and preachers to "show us the way"? That didn't happen in the old days. Financial support is great but financial influence (in the sense of doing change because of it, rather than doing changes because it makes something better) is terrible. &gt; Heroku embraced Rails’ “batteries included” philosophy and revolutionized &gt; development operations almost overnight. Useless promo-ad. By the way, why is this even needed to advertise for this company or ANY OTHER COMPANY? Either rails is good - then you can focus on it, and ruby. Or rails is not good - then focusing on companies is useless even more so. &gt; Rails is battle-hardened and industry-proven. Buzzwords. Not everyone is being the next twitter. I think these points are pretty terrible. Rails is a success story though, there is no denying in that if you look at who used it, who sold which startup for profit etc... but all the money in the world isn't making something SUPER AWESOME. Momentum counts a LOT, too, otherwise people would not even COME to think writing articles such as "rails is dead". Besides, it usually takes a long time for anything that has been popular at any moment in time, to "die". And a lot of the analysis is incorrect. The biggest drawback in using JavaScript is called ... JavaScript. And the biggest advantage for Rails is called ... Ruby. I distinctly remember having once bought a book in rails where you built a webshop. It even worked but it was boring to no ends. The pickaxe was interesting to read, the web-shop book was a terrible bore - and that has been my impression with rails still today. Ruby is fun, rails is boring. It's pretty strange that people like rails really.
LinkedIn is pretty terrible and spammy. I hated that too. I used it for a very short while until I realized that this does not help me personally. It is much better to build and advertise a portfolio elsewhere.
JavaScript is an utter ghetto mess, but it also has a lot more momentum than ruby + rails has right now.
This assumes that JavaScript "solves" anything. I feel that it adds to the problems rather than solve them.
Nothing wrong with cgi per se! It's quite simple after all. Not popular anymore and has had speed issues, we all know that - but it was simple. PHP sorta originated from that .cgi world too.
Microsoft said that they want to remove ruby and rails, though.
&gt; I think this is mainly because DHH has become complacent with Rails. While I do not completely disagree with you per se, I find it hilarious how you elevate DHH to be the next Jesus. I couldn't care any less about DHH (not that I have anything against him either, mind you) or Rails. So your claim of "DHH has become complacent" is so utterly irrelevant to me. Why would I care about that when I use ruby? It is, however had, true, that ruby lost some of the momentum. This is also not solely the fault alone of rails by the way; and neither DHH either. He is not the messiah to "fix it all", rails is just one giant framework that is used by lots of folks, but rails is not ruby. Oddly enough, I have seen a lot of efflux from ruby into Go, which I find odd. But there is more competition - elixir is one, crystal is another one. People also change their patterns or what they do. JavaScript has been climbing, despite being shit. PHP has declined even more than ruby has stagnated (well, ruby declined a little bit, but not as massive as the claims of "ruby is dead" crowd - these are just hipster-hypers). &gt; I know Rubyists don't like to admit it, but Rails is the main driving &gt; factor for Ruby Because it is simply not true. I have been using ruby before rails and rails plays absolutely no role in what I do nor the code that I write and publish under a permissive licence. People just LOVE hype. They confuse hype with momentum, which is not necessarily the same. &gt; with DHH simply no longer giving a shit because of that cash money, &gt; the ideas have stagnated, and the community has moved on. That is also a total crap statement. The rails people do not even suggest ideas to ruby core, so how should that even factor into the ruby core team and decisions made? And "the community has moved on", no, that is another incorrect statement. The hypesters moved on, no wonder - they never cared about the framework or language. You don't even want to have these clowns in any language. I never understood why haskell was so snobbish and elitist but it really is better for those who like and use a language if those who don't DO NOT EVEN USE THE LANGUAGE OR FRAMEWORK TO BEGIN WITH. But again - hype is NOT equal to momentum. As for "ideas have stagnated", well - what idea exactly? Many ideas are CRAP. Many other ideas break backwards compatibility. You want to be the one who breaks code massively and has to explain why you do so? There is a reason why my favourite ruby was 1.8.x. I could adapt to the latest ruby, but it was annoying and painful and in some ways the newer ruby behaves differently and WORSE. Ruby is still great, and many changes were good (no more require pp, did-you-mean gem, even the foo: :bar hash syntax etc...) - but I still liked ruby 1.8.x more than the later rubys. Annoying circular warnings, annoying encoding issues to deal with (which you never had to deal with in the past, just about) and so on.
I've heard people say rails isn't scalable and is slow. It's a load of crap in all honesty. You can always find ways to speed up your app no matter what language your using, what you really want is efficient development. It's easier and cheaper to throw money at hardware resources and smarter implementations, than throwing money at more developers because your writing in a language or framework that requires more developer time. 
While I do not necessarily disagree with your "case in point", it should be pointed out that there are significantly fewer users of rust and elixir than ruby. So if it were true, how comes that these have even a smaller user base? They are not exactly new anymore either; Rust is soon 10 years old; elixir too. So IF you were to make your point, you'd have to claim that ruby and rails died 8 years ago already ... which makes little to no sense really. Also, Rust ... created by Mozilla. An organization that has been completely obliterated by Google+adChromium, the latter being primarily written in C++. Isn't that strange too? Is that the new vision or just another hype train that will go away, anyway? I don't like Rust, true; Elixir however had is interesting since it makes Erlang acceptable. If I were to have available the time etc... I'd design something similar to ruby, incorporating some ideas from Elixir/Erlang.
Better than wasting your life with JavaScript for sure. Best of luck to you there.
Is that the "every tool is useful so use everything" claim again? That's why COBOL never dies - people just keep on using legacy shit.
Frankly, I have seen way too much awful ruby code to buy into that. 80% of course has to do with the one writing that, but different languages can also encourage sloppiness or craziness. Ruby is a lot of fun so people get tinker-driven like little kids. This can be fun but it can also lead to horrible no-comments no-documentation situations. And the inevitable "my code is self-explanatory so I don't need to explain it". These people should just be banned from every language really.
I like ruby, for the most part. I never liked Rails but it's not that I hate it. I would however had hate to maintain a large rails appliance. That would take away a lot of the fun from ruby. I disagree with your worship of a type system though. As you reveal, it just shows that you respectively rails lacked competence. I don't run into magical nil problems, so how is it that you do? May it be because rails is too big and too complex for its own good? Or that you guys are just incompetent? Either way I fail to see how this is necessary. Every type system leads to longer write cycles too. IF lack-of-types were the problem, you could use crystal right?
&gt; For me the biggest competitor is Golang and Nodejs These have two huge drawbacks: 1) Go + Google 2) JavaScript Ghetto Not disagreein with your comments per se but often you just end up exchanging drawbacks rather than finding the "better" replacement.
Can you elaborate ? Its like Saying React drawback is Facebook and C++ drawback is Ritchie and Kernighan or Drawback of Java being Oracle. Doesn't make a cent of connection / sense. Company behind some technology like a general purpose programming language means only that there is a chance language will be supported long term.
... also, what on earth does it have to do with paragliding?
Just saying that "Rails doesn't scale" is such an overly generic statement, it doesn't give me confidence that the person saying it knows what they're talking about. First of all, that statement is usually followed by the company switching to an entirely new programming language. But what about the rest of the Ruby ecosystem? We have many powerful and fast web frameworks and libraries outside of Rails (Sequel, ROM, Hanami, dry-rb, Roda, Rodauth and so on). If they switched despite of that, then it doesn't seem like that person like writing Ruby much to begin with. That statement is also *never* accompanied with *what* is it that didn't scale. Is it he Ruby language speed? I highly doubt that, it's rare to have to do something CPU intensive in Ruby. Is it the web server? Unlikely, you have so many options to choose from. Is it Active Record? You have Sequel, ROM and Hanami::Model, all of which are much faster, just use one of those. Maybe it's the Rails directory structure and/or autoloading? How about trying Hanami or dry-system instead? Or the lack of abstractions? Again, go look at Hanami and dry-rb ecosystems. Ok, maybe it's the lack of concurrency abstractions? Go look at concurrent-ruby and `async` ecosystems and prepare to be amazed. Given that the Ruby ecosystem has so many options to choose from, it's no longer enough to say "Rails doesn't scale". You *have* to be more specific than that. ---- The article is a nice overview of things that Rails can offer, but people always forget to look outside of the Rails ecosystem, which offers more than enough tools to "scale" your app.
Rails is boring by design though. It’s supposed to be easy. You get to spend time on features and business logic instead, without sweating the nuts and bolts. Generating boilerplate, including tests, is a benefit. Firstly, you only get that if you use generators. It’s way easier to delete or modify unnecessary boilerplate than to write entirely new code yourself for the same boring things.
From what I read GitHub has been actively replacing Rails with Go code since long before the acquisition. 
Yeah, it's been useful to me, but it's not useful right now. Wish you could disable your profile.
Might be, but things are still good, I see 1800+ mentions for Ruby in London area (Linkedin) , and 2000 for PHP. To me this shows Ruby is quite mainstream in London. If you do the same check in the Netherlands, PHP has x7 more jobs than Ruby.
The problem with mruby is that the mruby community really doesn't want widespread usage and adoption of the language. That's why they don't have any documentation, a mailing list, a subreddit, a community site of any kind. That's why don't blog regularly or hype it in any way. I think they want play with their toy without interference from the rest of us.
Correct me if I'm wrong but Scala can get Null exceptions [https://blog.scalac.io/2015/05/31/dealing-with-npe.html](https://blog.scalac.io/2015/05/31/dealing-with-npe.html), as can java. There's techniques to deal with them of course, but they do pop up in static land as well.
Last time I had to configure Webpacker I was dismayed to learn that rather than using the well documented and understood Webpack config file, it instead has its own (poorly documented) configuration system that combines configuration from Ruby and JavaScript files along with defaults built into the gem into a generated Webpack config that you never get to look at and can't easily debug. Spent hours messing about to find out how to set configuration that I knew how to do easily in a Webpack config, but was broken for my use case by the gem defaults. Webpack itself used to be a huge mystery to configure, but its documentation has improved significantly in the last year or so.
Ruby is declining because people want typed languages these days. 
I'm going to have to agree... hundreds of servers to two seems like the biggest tell. 
There are multiple living proofs that rails does actually scale anyway. Github, airbnb, hulu, zendesk and others are here to prove it.
IMO the best thing is a good portfolio. Make a website with decent complexity and put it up at GitHub, that will already give you a heads up vs most other candidates.
Yeah, it shows that it's possible to scale Rails. But it doesn't really say how *difficult* it is to scale. I think that's what people actually mean when they say "it doesn't scale". I think these big companies can afford to spend more effort on scaling, because they did other things right. Note that GitHub pays people to work on Ruby and Rails, and even maintains its own Ruby fork. Some other companies might not be really afford spending increased effort on scaling once a certain point is reached. It's also worth noting that some companies like Heroku have switched to Sinatra &amp; Sequel for its microservice APIs. I think that also says something. I know that I personally would have a tougher time operating big amounts of data with Active Record compared to with Sequel. Might point is that it's not helpful if keep viewing Rails as the only feasible way to build web applications in Ruby, and other stacks as some unwalked path. Especially when these stacks offer significant advantages, which might persuade a person to stay in Ruby.
https://rubygems.org/gems/activerecord/versions/5.0.0.1
I think you can create separate components, which may be reusable in other parts of your applications also. You can use the logic that generates your complex HTML, and send props to generate the html accordingly. You should use the root point i.e.`&lt;div class='something'&gt;` in this case.To add react_render component using `&lt;%= react_component("ComponentName", PropsObjectHere %&gt;` Now in this particular component you can call smaller components based upon your logic. Hope that helps.
Where and when did they say this ? Oh nvm shevy commented.
The link to the Ruby github repo seems to be broken. Update, please?
Please report back after your first "put everything in an ActiveRecord callback" VS "put everything in a service object and make it explicit" battle.
Do you ever feel uncomfortable with how much better at coding you are than the countless people who really appreciate type systems? It seems like quite a burden, that level of Alpha Code Superiority.
I can get that. I still find it useful to some degree, but I do wish they had a way to let you simply disable your profile the way Facebook does rather than just delete it entirely. As far as responding to blasts from recruiters, if they appear to have at least taken the time to read my profile and wanted to talk to me about a job I'd actually be qualified for but am not interested in, I'll be courteous and let them know. If they sent me a job description for something I'm clearly not qualified for or would have no interest in (like support/admin simply because that's what I did to float myself through the recession) then they don't get a response.
Can you give an example of what you'd like to do? How would it be different from `m = method(:foo)`?
A lot of the excitement has moved to JS and, particularly for Ruby devs, to Elixir and phoenix. However this is currently more a symptom of Ruby being mature and the other ones not. It will be interesting to see what happens to Rails when Phoenix gets to feature and dev parity. 
There’s lots and lots and lots of details and exposing them all at once will be overwhelming. Just because they skipped this detail or that one that you get a third-person tip on doesn’t mean the course is of lower quality. Feel free to skip tips you’re not ready to implement if you’ve got more immediate problems. 
Yes, they can still pop up in Scala land, typically if you have to interface with Java. But the Scala libraries and ecosystem generally frown upon null usage which generally makes it a non-issue.
Hey. Thank you. That's what I ended up doing. To change my thinking from rails way to react way is still a difficult thing. 
Hah, I've just picked up a project where everything was dumped in ActiveRecord callbacks (Including calls to external services). We are now moving stuff off to more sensible places because testing was impossibly hard.
Hate to be "that guy," But Elixir+Phoenix offer almost all of the same pluses the article mentions, with very few minuses. I still love ruby, still use it for tons of scripts and even small websites. But I feel that Elixir is just better suited for larger development.
Great. 
I think the idea of Ruby for Good is pretty neat. We have a similar civic tech hackathon here in Houston, but those projects tend to be user submitted rather than focused on existing nonprofit needs.
Can we spread this to the midwest? I'm certain at least the Milwaukee area would benefit from this.
I agree with others that local in-person networking is huge. http://www.iowaruby.org/meetings/ https://www.meetup.com/Women-Who-Code-Des-Moines/
I just joined this sub. I have been using Py for years, got bored, wanted to try out Ruby. So I joined here to lurk while I do. &amp;#x200B; I just want to say, this is so frickin awesome, and it's gonna be part of my drive to learn. Thanks guys.
All skill levels are welcome at the event!
We definitely need more folks doing good and you should totally run something similar if you're interested! We have quite a few attendees from that area so I imagine you'd have no problem getting folks to come.
I'd recommend she do the following: &amp;#x200B; \- Start by learning a bit about how to write and manage clean code by reading the [Ruby Style Guide](https://github.com/rubocop-hq/ruby-style-guide) and learning the basics of using Git for version control (preferably in the command line). You don't want to be messing up on the absolute basics when demonstrating your work. \- Then do a few small side projects (maybe with some friends). Make sure to use a tool like Rubocop to check for code quality. Push them to a public Github repo with a readme file and clean commit history. Many employers care more about a candidates' Github portfolio than their resume. \- Lastly I would advise her to contribute to a few open source projects. This is an easy way to look REALLY cool. &amp;#x200B; Pro tip: Don't give up right when you get filtered out by HR. Instead, courteously explain that the limited number of years experience doesn't reflect your skills/knowledge, and that if there is a technical part of the interview, they will be happy with what they see.
I'm mildly disappointed it's not using an inflector to generate "undrafted", "inactive" ;)
Does anyone know of a similar event in Europe?! I'd love to participate but Virginia is a little far far away...
I've been onboarding and after your comment I went digging and omg this is totally something that needs fixing. Thank you, kind stranger, for not only nailing the nail on it's little nail-head, but giving me a way to reach a bit and be more valuable.
Wow I love this idea. I’m not very adept in app developing at all, but I’d love to go to learn and see some really cool projects come forth. 
Wouldn't bet my career on Elixir. Ruby is niche enough, why go for such esoteric languages?
Apropos sass - since they abandoned ruby, I don't think anyone should advertise for these Google drones. To the topic at hand - I find the whole syntax decisions in erb retarded in general. I never understood how people can use it. Here you have a rather pretty language (ruby) and then you fudge it up by adding crap like: @import '~bulma' &lt;%= stylesheet_pack_tag 'application' %&gt; Horrible. And that is just a short amount of code - it gets really really terrible the more of these embedded code constructs are used. It is still better than PHP but it also reminds me of PHP. People should really not propagate what is terrible.
In general I would recommend to not act on delegee e. g. let the person at hand try on their own. This may sound more rough but it is also more authentic and ultimately will lead to a more realistic prospect and outlook. There is a general saying that I think holds mostly true - one closed door/window often opens another one.
I believe the problem is the concept of "bound"/"unbound" methods. Instance methods, received with `method` is kinda-like-lambda, but they are still "bound" (which means they have a concept of `self`, referring to the original object, and `instance_eval` does NOT change that fact). But it is just logical reasoning, currently, I can't find any particular statement in docs supporting it (though, `Method`s docs aren't very detailed, probably that should be fixed; ...or the behavior itself should be). I'd ask about it at https://bugs.ruby-lang.org/, it is a genuinely interesting problem.
&gt; # Reason to not to extract is "Why create a seperate module just for one mixing one single method ?" Because modules are the mechanism by which you mix in methods?
Hey, method objects without any arguments shouldn't be given as blocks to BasicObject#instance_eval as it throws ArgumentError because method objects are lambdas and instance_eval will implicitly pass the receiver as a block argument and in such case method throws ArgumentError and this is the reason I had to use BasicObject#instance_exec method. I was looking into Function.prototype.call() method and in that we can borrow methods of one object to another object without using inheritance and I thought to check if Ruby has such ways and tried it here to borrow methods and this was the result 😅😁
Hey, I was giving this as an answer in case someone suggest me that instead of using inheritance, you can use modules. I was searching for ways where I don't want to use inheritance nor modules as well 😅😁
It might already exist.
Grade A security testing. if you get it to work file a bug.
Ruby toolkit I think it is called
Hmm In no particular order: - Pretty syntax for the most part (you have to reject some shit of course, but if you do then ruby is really by far the prettiest among the programming languages). - Blocks aka {} to methods. They are absolutely AWESOME. - Flexibility. I can change everything at any moment at time, in any way that I want to, aka duck patching (patching ducks). There is a little bit of ... a double-edged sword here, aka you have to carry modifications; if others are to use it. And you can not prevent "outside" influence easily. There are ideas to change this, such as ... refinements, but refinements are quite strange. Anyway, I digress here sine the question is of advantages. Some other advantages I can think of: - An extensive gem ecosystem. Best thing also is I can avoid bundler. :P - I think another advantage is fast prototyping. I don't have to waste my life fighting the language or a type system. Yes, I do create bugs or write terrible code too but it is a LOT easier to go on with ruby than say, the abomination that is PHP. "is it worth the time learning it?" To be honest even shitty languages are "worth" learning if you have a net benefit from them. You can automate stuff, which is always good. Ruby may spoil you though. For example there is no way for me to go back to php or perl. Ruby beats them. Ruby also beats python. :) This is actually not perfect, because it also means switching AWAY from ruby is DIFFICULT, since the other languages are so utterly terrible. Actually most programming languages are awful. So ruby is in many ways the least awful one. Ruby is pretty good though. I am not sure an iOS developer benefits as much. You may stick to the swift ecosystem if you depend on Apple really. Some people have no choice ... and while I think ruby is massively superior to swift, I guess you can write excellent applications in swift too. Writing ruby code is probably more fun than swift, but your mileage may vary. I think it really depends mostly on what YOU really need to do. For me, I used perl, then PHP and wanted a better language. I had the choice between ruby and python and chose ruby because of an interview matz did in 2003 or so. Ruby's philosophy is superior to python's philosophy. I think python is a fine language though, even though it is weird (python's OOP is really weird ... mandatory self is AWFUL, I hate that shit; it feels like python is too stupid to know where self is; you don't have that problem in ruby). I should however had admit that, while I write more ruby code than I used to, my favourite all-time ruby branch was 1.8.x The new ruby is fine, has significant improvements, but it does not feel as much as 1.8.x did in many areas. Circular warnings, you now have to care about encoding, frozen strings (I understand the benefits but still) etc... I am just not that enthusiastic as I used to be. May be because I got older too - but don't get fooled. I still think ruby is really by far the best programming language out there. Which makes switching AWAY from it very hard. :)
https://awesome-ruby.com for widely used gems?
Not quite the same thing as it doesn't recommend based on the gems your using.
Not quite the same thing as it doesn't recommend based on the gems your using. &amp;#x200B;
sounds good, like if u have a gem it would check for better alternative?
Yeah that's a possible use. The reason why is because most applications of a particular category will probably use the same sort of gems and so it would be a neat tool to have; will save people from having to search around. Also, sometimes you don't realise that there is a gem for something that you've developed.
Yeah we need less freedom. We have already put our flexible language under shitty codestyles made by people with small coding experience. Now we need to "recommend" to use the same gems everywhere.
I'm glad to have contributed something! If I may offer some thoughts about this... I used to argue with a coworker about this a lot. He was pro-callback, I was anti. When I left the job, I was a bit more flexible. He used to make the point, "The model is responsible for maintaining data consistency, callbacks are a reasonable way to ensure that." I think he was mostly right. One of the litmus tests I use now is to ask myself how screwed up things would be if I was working in the console and forgot to call a service object as part of some CRUD action. If the answer is "very," I'll explore use of a callback to keep me from shooting myself in the foot. Another good question to ask is how many other classes your model's callbacks need to know about in order to complete their tasks. If saving a User also needs to trigger complex interactions with half a dozen other classes, maybe a service object is a good idea, even if your callback is triggering that service object. Finally, don't forget that actions performed within callbacks are protected by the same transaction that is performing the CRUD operation! If your CRUD operation and the behavior extracted into a service object must either all fail or all succeed, you'll need to manage the transaction on your own. Service objects are a great way to limit responsibility and keep your models from becoming god objects, but callbacks can be helpful for enforcing business logic so you don't have to be quite so diligent about trivial and/or crucial things. Someone is going to comment to this and say that I'm an idiot, I'm all wrong about this and that, which just goes to prove the point that there are a lot of views on this, and a lot of people feel strongly about theirs. All my thoughts above are just one person's ideas and you're welcome to consider them or tell me to fuck off. Either way, good luck in your new role and congratulations!
I'd make a strong argument that there are better languages to learn if your goal isn't specifically to work on a Ruby-related thing. Learning a language like Haskell would teach you a lot more. Ruby is too similar to what you already know.
Ok.Question. How would your gem even know what I developed in the first place to make a recommendation?
It's exactly the same thing. I can find `devise` gem that I'm using there and I can see all other gems in the "Authentication" category.
I guess my question is a simple “why?” Ruby has the concept of mixing in Modules exactly for this reason. Why does having just a single method to mix in make you want to do this in another way?
It works nice =) ... &amp;#x200B; I think something that you can try to make you code a little more readable, at least for me =), is to try to create an object or some objects to manage the data instead of using an Array... @data = [@username, @password, @email, @task_list, @completed_list] You are using this @data doing things like @data\[0\], @data\[3\]... and to know what each one of this means you need to go to the initialize method. &amp;#x200B; Actually at the bottom you wrote some access methods... #accessor methods def get_data @data end def get_task @data[3] end def get_completed @data[4] end &amp;#x200B; If for you this `@data` is the user data, maybe you can create a user object with methods like... &amp;#x200B; user.email user.tasks user.completed_tasks user.from_record(file_line) user.to_record Try to do something like this, and also try think in another name different than user, I think that can help you.
Yes that's the thing it needs to communicate with some sort of server to make a recommendation based on what other people are using. It will also be looking at your current Gemfile. When I say "a particular category" - for example a e-commerce site with a marketplace will probably use the same gems as another type of e-commerce site.
Not quite in that it doesn't recommend based on a particular Gemfile. Also that list is not exhaustive of all the possible gems out there.
Can you explain why procs and lambas are added into Ruby language ?? You didn't get my point actually .. I was trying check if there is any way if ruby has provided us to use Function.prototype.call() behaviour 
I’m not as enthusiastic these days either but I tried doing something in Java (which I worked in for years prior to Ruby) recently and it was such a pain in the butt doing things like doing http calls to a rest service that I renewed my appreciation of Ruby.
Well, Ruby is for web, and web-related automation/server hacking. If you are not into backend, it's not that worth it I guess. Now, from a language ecosystem point of view, it's great. I've learnt a lot of object oriented principles when learning Ruby. It has an OOP style similar to Smalltalk, which is a breath of fresh air when compared to Java and C#-style OOP. Stylistically, good Ruby code is also elegant, one of the most elegant I've seen actually, maybe only below some functional languages :P The dangerous thing about Ruby is that it's so free, you can easily mess up basically anything you touch. So, for a team of juniors, it's not ideal. But for a small team of senior devs, you can do magic. When used correctly, and the Object Oriented Design Principles are followed (this is more an art than a science) you get very maintainable software. Which if it isn't your first priority, it should :p at least if you plan on maintaining the app for a few years.
Dude, I spend most of my time in chef these days. I had a project in c, and I was miserable. It's been so long since I've needed to write c, I forgot how awful it was. Oh? You want length? Better iterate through and count it. While you look for the null in the string. Whereas in ruby... var.length. That project solidified my love for ruby.
I'm learning Java right now after coming from Ruby training/studies. I really love and appreciate Ruby, just a beautiful language, and very expressive and succinct. 
8 years experience using ruby, mainly with rails but also with serious projects building ci tools and even one using the shoes gem as UI. So, sure as hell I am not the most experienced person in the community , but I think it’s enough to give you an opinion to ponder on. First of: I love Ruby. It’s such a blast to work with and (even though people might argue it’s dwindling) a real nice, big community. If you are just looking to get involved in open source projects for fun, I can only recommend it. But: there are some things you should consider. You said you are an iOS developer, in that environment there might be other languages that come in more handy than Ruby. It is usually not the first language pick when it comes to developing native apps, even though there might be some frameworks for iOS (I don’t really know), they might suffer from performance penalties compared to other languages. So, if you are looking to improve your professional portfolio in the iOS developer field, Ruby might not be for you. — That being said, here is my opinion. Ruby is maybe the most developer friendly language out there. If you have a problem, the stdlib might have you covered, if not, there is probably a gem to help you out. If you do not like the harnesses other languages impose on you, like strictly OO/functional, being overly explicit, or ceremony heavy boilerplates, Ruby will give you all the freedom you want. You can add add methods to objects with runtime dependencies, throw down a quick and dirty - but still readable - script for one time usage, or build massive applications following OO best practices (arguably) with relative ease IF you know what you are doing. But (there is always a but) with great power comes great messy code potential. Because Ruby makes things so easy and has an extremely powerful, yet quite easy to use, meta programming api, it is easy to produce user friendly gems, that are quite impossible to maintain. I love using rails for proof of concepts, or small projects with clearly defined boundaries. It’s more or less a matter of using rails generators and tweaking views/controllers. But I prefer other languages/frameworks to build apps that I know will grow, have potential for feature bleed and other development realities. When it comes to writing throwaway scripts or ci tools, there is no better language than Ruby (IMO, and unless the task is performance heavy)! Also, there are some seriously good resources out there on how to utilize OO Ruby, for example Sandy Metz, Avdi Grimm, or “Uncle Bob” Martin, if you want to build larger, maintainable apps in Ruby. Last but not least in my list of pros is the big and friendly community. Most of your questions have probably already been asked in SO, and if not, don’t hesitate to ask. I don’t know any other community that is this beginner friendly. — To complete my messy shit sandwich, here are my cons. Ruby has too much going on in the stdlib, too many aliases, and too many methods with very obscure use cases that basically just hide the implementation and make it harder to debug. It is still comparatively slow and memory heavy. However, on most modern machines and many use cases, the speed difference does not matter. A difference of 0.5 seconds is usually not relevant for the end user. Rails. Rails is Ruby’s curse and blessing. There is so much to say about this, if you are interested we can discuss rails in detail, but from what you wrote about yourself, it might not be if any interest. — If you made it through my wall of text, and are still interested, I would love to welcome you to the community :)
Very valuable feedback! Sounds like you have a lot of experience in the language and with other languages to be able to have a good point of reference. as I start to build experience as a dev, I find myself thinking more and more how I can automate my workflow. I've been using bash for simple little scripts that make small tasks quick. But I do find that larger things can get hairy very quickly. I think Ruby might be a good language to pick up to help with some of that. 
The answer depends on your actual situation, do you depend on somebody else decisions or not ? If you don't (eg. it's your own business) the Ruby / Rails is a very good solution. Do you want to earn money or spend 2x 3x time developing with tools about your clients don't care ? Sometimes I think I should go the GoLang route (because I love Go), sometimes it's about React, but at the end I really enjoy making music or going at the pub instead of crafting the best in the world go+react solution. Once again, because our customers don't care, as long as they're happy...
I'm definitely interested in back end web. I'm excited to start hacking around!
Hot damn, Definitely a warm welcome! I appreciate the well thought out opinions and advice! I appreciate it! I think a large part of my desire to learn Ruby is driven by my instinct to keep expanding my skillset and keep learning new things so that, should I get sick of what I'm doing right now, I haven't dug myself a trench as to what I am able to do professionally. Thanks again. Glad to be a part of the community :)
TBH the main reason I like it is the syntax reads like english, which is odd given most of its core developers are Japanese. There is also a lot of that Japanese design influence throughout it which may be some of the appeal too. However it's descended from PERL, Smalltalk, and LISP so it shares a lot of similarities with its cousin languages, e.g. python, java, Obj C. So in learning ruby, you're also learning a lot of the concepts those language share. While I think there is definite value in learning any language and time spent in ruby won't be wasted, you probably already know a lot of the concepts it will present. Ruby isn't front end code, although rails has kind of made it synonymous with front end development, the reality is a bit different. It's a language that is used to on the backend (server side) code that ties to the front end (client/browser) and the same can be said of python, Java, C#. At some point true front end development devolves to some variant of JavaScript + CSS + html + SQL and figuring out how to modify the server side code to serve up or do the thing you need to JavaScript, e.g. JSON, persisting data to a datastore. Since you mention you want to learn more about different topics. A topic you might want to explore that will stretch your imperative thinking is FP (functional programming) or the lambda calculus influence on current languages, e.g. Haskell, Clojure, Elixir/Erlang. In essence, the past language design is becoming the way to scale the future. Given given current hardware design, where the scaling is done via multi-core (perfect for erlang's model) vs a faster single core (perfect for ruby's single thread model), that's where the massive scaling will be achieved via language features such as data immutability and concurrency/parallelism. You've probably already seen a lot of the influence of this as it relates to iOS with the introduction of Swift. But things like erlang's hot code loading and OTP, haskell's type system, clojure's states, will be much more influential in tomorrow's language landscape. Another honorable mention of things that might interest you specifically, [Elixir's Nerves project](https://nerves-project.org/), [Kotlin for Android](https://developer.android.com/kotlin) development. Having said all of that there will still be a place for ruby in the future, and I'll still be using it. :) 
I can get job done faster in Ruby than compared to any other language,
That's nice, take your time. Once you are comfortable, give this book a shot to level up: https://www.poodr.com/
Thanks! I'll save that and hopefully will get to it. Any good resources you suggest for getting started with the basics of learning the language?
Mm the language itself is not hard, but I'm the kind of guy just reads a cheatsheet and starts hacking. When I get stuck, I read, not the other way around :p That's the only way, at least for me, to really learn.
Hmm... Yeah I am not aware of gem recommendations based on gems used
For that purpose, I think Ruby is a really nice language to learn (IMO of course). I guess there are people who will tell you Ruby is not a good language if you are looking for anything but web development, but I disagree. Ruby is extremely well suited for proof of concepts, or simplified architectures (because you can hack in solutions that are not relevant for what you want to proof). And as i said for everything not UI heavy, Ruby can provide a real nice environment to implement your ideas. For example, every time I have to write a script to migrate data, I reach out for Ruby and the according database gems. Every time I have to write tasks that have to run once a day with very fussy boundaries, I reach out to Ruby. I also think Ruby is a better learning tool for OO than java - don’t know about everyone else, but most people including me, was taught java as the go to language in university. Horrible language to teach the concepts oif you ask me, because you have to buy the whole cow every time you want a Glas of milk! We have one big non-rails Ruby app running in our company. It is more than up to the task, and talking concepts about that app is usually fun, because we can use different approaches to the same problem and just focus on the conceptual pros and cons, instead of having to worry about what the language dictates. This of course is a very biased view, but... you know... in the end, in many cases the choice of language is more a question of personal preference than actually utilizing a languages strength. And Ruby’s core concept is developer happiness. So, yeah. I am biased :)
Ill have to go back and take a look. I honestly want to re-write it using SQLite and rspec for testing. (Ive started learning how to implement it, and im piecing it together) I really like your idea of accessor methods fo easy of reading!
If you are going to rewrite it to use SQLite... other thing that you could try is to make the storage interchangeable... try to make easy to change the storage mechanism... Maybe something like... &amp;#x200B; store = FileStore.new record = store.find_record(username) User.from_record(record) store = SQLiteStore.new record = store.find_record(username) User.from_record(record) # or directly return the user like store = FileStore.new user = store.find_user(user_name) store = SQLiteStore.new user = store.find_user(user_name) # or if you want to have a record for each task... user = store.find_user(user_name) tasks = store.find_tasks_for_user(user) # or if you are more in the ActiveRecord pattern... User.store = SQLiteStore.new user = User.find_by_username(username) I don't know there are many options... but in my opinion is a good exercise =)
That you can redefine the basic math, w͙̦̲̦̲̥h̺͙̺̝e͉̤͎n̙̫̘͔ ̟͈͖̳̖ͅỵ̲̖o͔̗̺̯͍͉̤u ̮̪͔̠̞̝̟ha̮̭̖̥̲v̞͓e̞ͅ t̯̭̪̫͖̳̯̩̜̱̮̺͓̭h̖̬̯̫̜̘̬̩̮͈͕ͅe̝͎͇͍̥̻̙̻̘̪ ̝͍̲̘̟̳̘̗͉̥̥̩̟͍a̘͉̰̣̗̜̭̰̯͓̣͎̫̙̯͎b͖̩͈̳̥ͅi̩̪̙̮͚̥̪̹͔̫̞̙̹̮̹ͅl̲̺̱̯̯̙͙̥͇͚̲͔̲̙͇ͅi̭̳͍̮̜̻̬͎̹̱͙̫̙̲̠̞͓͈ͅt̙͕̝͈͈̙̟͙ͅy̺̥̼̲̲ t̠͓̗̃̐̌́ͨo̞̻͙̰̺ ̙̖͎̺̙ͦ̑ͥd̲̬̳͖̜͇̆ͩ̈̽̔̈͌o͙͌̚ͅ ̲̩͕̲̻̺̮͒̓́̓s̱ͤ̾o̬̙̬̝̹͍͉ͧm͎̑͂eͫͥ̔͐t̘̺̬̝̯͒h̹͕̩i̼ͯ̏͐ͬͥ̓n͇̪̜̝̲̳ͥ͋ͦͣg̭̭͖͍͉̤ͤ͆̅ͪ a̬͍̞̲̫͂̑ͅṡ͋̽ͣ̚ ̈́҉ȋ͈̪͉͑̅̒̆͑̀n̵̤̤̈͛̈́͐̊̎s̯͚̘̣̦̠̙͛̓a̷̳̦̤̙͍̭͊͌͂ͯͭ͗ͭṋ͓̳̳́͒ͨ̔̿ͯe̳̖͙̿̅̐͑ͫ̀̒͢ ̹̪͓̰̞̺y͍̝̝̝͈ͅo̦̠͖̠̺̯̙̗̻̝u̞̪̦̜̺͍͕͈͕̗̪̳̯͈ ̝͓̜̘̼̗̪͙̖͕͈̬̩̩͙k̠̰̹̥̪̣͙̹͕͈̯̤͇̻n̺̟̳̮̣͕̹̟͉̙͎̙ͅo̰͉̺͇͉͔͎͙̙̤͈͙̪̫ͅͅw̻͕̝̻̬̪͖̹̪̥̣̺̣̠͓͍ ̭͎̯t̥͈̬͓̫̣h̠̹̖̳͔̖̗͙̼̥͕̜̯̼͈̫͈e̟͙͍͕̣͍̤͔ ͕̪͔̳͍̰̯̠̫͕̗̤l̖̼̳͍̘̟͉̦̜͓̟̯͔̙͚͕a̼̬̹̪̠̣̞͍͓͇̼̫̫̥̦̳ṇ̗͇̮͙͓̙͚͎̣͔̖̰̺g͈̭̳̗̜̬͖̠̻͎̮u͚̪͇̤̘͙̞̗͖͖̠̗̘̰̟͚̜̟͈a̲̼͍̱̜͇̝͎̙̰͇̬͉ͅͅg͎͈̱̯̙̱͇̰̻̱̟̝̤e̥͎̼̖̫ ̹̬̯͍̳̭͇̻͙͚̰̬̗̩̙ͅi̭̠̘̦̘̙͉̹̙͚̹ṣ͓̬͖̩̞̟̲͕̦̺ ̗͔͔̲̞̹͉͉̫̯̞͚͖͇̱̝͖̖g͚̟̤̯̗̼͈͉̦o͓͙͍o̩͙͈̯̗̫̭̹̠̮̜͙̹͈̱̺̥̖d̜͉̯͙͈͎͇̺̣̼̬
I've been writing code for roughly 30 years now. I've written x86 Assembly, BASIC, C, C++, C#, Elixir, Java, Javascript, Perl, Python, Ruby and probably a few more. Of them all Ruby is my favorite, with Elixir a close second. As ao iOS developer you likely couldn't get a lot of use out of it. There's Ruby Motion but I'm not at all sure how good that is. What I like about Ruby is that it makes it easy to get work done. The language doesn't get in your way with unnecessary verbosity and allows you to extend it in interesting ways. It's a nice middleground between a perl one-liner that's impossible to read and something like C#/Java where you have tons of boilerplate shit you have to write. It's NOT a language to pick if performance is critical and Rails is it's own hot-mess that I try to avoid whenever possible. It's also not great on memory consumption. 
A lot has been said so far so I'd only add that you should give r/DragonRuby a look. It's being rebranded to that, was called RubyMotion. Right now it favors Mobile and Mac. Ruby was originally about being a joy to code in the language. I personally love it. And with jRuby in the mix, you can leverage the power and code of Java as well, in a beautiful syntax. I agree that different languages serve different needs, but the Ruby syntax is separate from the "language platform" at this point, with projects like Rubinius intended to allow new language behavior under the same or slightly different syntax. Rails still dominates the reputation of Ruby, but the ecosystem is diverse. I'd say it's the best time ever to get to know Ruby.
My enthusiasm has moved to Crystal these days, as it has everything I like about Ruby, but a lot of other stuff too. 
That I'm not using it ¯\\\_(ツ)\_/¯ 
So, I'm weird but I love Ruby because it's written in C and is incredibly easy to extend. No one does this in web dev though. The philosophy behind ruby is to make developers happy though. That's a pretty cool place to start.
In not particular order: Ducktyping, strong polymorphism, graceful blend of OOP and Functional programming, strong gem/framework ecosystem, SINATRA!!!!, ease of implementation, embedded C modules (if you are feeling hardcore), ease of extending core lib classes, sexy syntax, [why's poignant guide to ruby](http://www.rubyinside.com/media/poignant-guide.pdf), great testing libraries and so much more! I've been working on and off with ruby for about 10 years and every time i get to do a new RB project I'm happy, motivated and efficient. It doesn't do anything for front end or native apps but if you want to build a good API to serve data to your swift code ruby is a pretty solid contender.
FYI - it's duck-typing and monkey-patching.
30 years! Mad respect to you. Thanks for taking the time to give your thoughts! I really appreciate that. I plan to pick up Ruby and see if I can use it to automate some of my daily workflows. Or maybe I can use it to prototype some of my ideas for web services. We'll see if it fits in my toolbelt! 
Thanks for the feedback! As useful as Node is for app backends, I just haven't quite figured out how to wrangle all of JavaScripts oddities. I'm excited to give Ruby a try. 
Checkout [Sinatra](http://sinatrarb.com/)
That still, after over a decade of coding in it almost exclusively, it still surprises and delights. In the early days it was always an issue of "how can I do this is Ruby?" followed by "Well, what's the most obvious way?" followed by "WEEEEEEE!" But if you had to press me, blocks and the `yield` statement. I come from a Smalltalk background but couldn't get any reliable work. After a decade of coding in Delphi, C++, _etc_ Ruby was like coming home. I'm probably coming into the twilight years of my coding career. It's nice to think that I'll finish up still coding in Ruby... and from there on, it'll just be a hobby. :) Oh.. the community. That's another big plus. Oh, and how easy it is to prototype stuff... oh, and how everyone keeps stealing our ideas. OK, there's a lot I love about Ruby.
The fun of coding is one of the most important things for programmers. And when I was a Java programmer, I had to struggle with boredom. But when programming with Ruby, I feel very little. Ruby and ecosystem do not force the correct answer. It aims to provide a number of ways that you can easily do what you want to do. This is the basis for pleasure. &amp;#x200B; Ruby programming has its drawbacks: performance, dynamic type, slow growth, and web programming-oriented communities. However, there are meta-programming, blocks, Enumerable modules, open classes, Gem, etc. that go beyond these disadvantages. &amp;#x200B; I highly recommend Ruby learning in terms of expanding experience and having easy and enjoyable tools.
How can you say that Ruby is good for fast prototyping unlike PHP? Nearly every web host in existence runs PHP and you can "apt install php" just like Ruby, and in fact it is far easier to deploy a PHP app to a web server than it is with say a Rails app. 
I've thought implementing that as part of https://ruby.libhunt.com. It's on my TODO. Just haven't had the time...
Maybe it's time to buckle up and get it done :)
Why do you avoid Rails? Everyone tells me Rails is awesome and that I should use it and that Rails is the future yada yada
Good to see this has been a similar experience. I wrote quite a lot of python in the last ~2 years but it still feels so much stranger compared to ruby. This has partially to do with me being less efficient in python; but mandatory indent levels, especially mandatory () and explicit self ... all makes for a quite strange flow in code. I also find it less natural to not have a method such as .each on any collection/inventory. In ruby this is so much simpler ...
&gt; I'm probably coming into the twilight years of my coding career. Heh - that's been my feeling too. I am getting into the grandpa stage finally. Not quite there as of yet but far away from younglings age. Ruby is still cool though.
Hmm. How would you actually value which gems to recommend, based on which factors? Just on the gemfiles alone? Some gems don't have a Gemfile by the way.
Do you mean like “Your Gemfile in Claude’s Rails and Devise. Other Gemfiles that include Rails and Devise also often include Pundit and Whatever.”?
It works they way our brains think. So: 5.times do puts ‘hello’ End Does exactly what you would suspect. That’s just a simple example. You can define methods with special names, like “[]=“ that lets you use an array/hash-like accessory for *your* objects. I don’t know if any other language that allows that. Oh, and look into how you can use a mixin to solve multiple inheritance. It’s beautiful. I hope you enjoy Ruby as much as I do.
Unpopular opinion but I don't actually think ruby is a great language for the vast majority of what it is used for, but the Rails community is so valuable that it basically doesn't matter. Most people use Ruby for some kind of web development and it's really not suited well for that: sure the stdlib is nice, but the memory footprint is huge, it's not particularly fast, it's memory management is a complete and total joke etc. Syntactically the things that make ruby really academically interesting also make it dangerous and ill-suited for larger groups of engineers (for instance being able to redefine methods at run time with no warnings, and a complicated inheritance/module model are a recipe for disaster, and indeed you'll sometimes find gems that have rewritten like Object.present? without telling you.) So if you want to use Rails, I would suggest learning Ruby, otherwise it's basically not the best language for any particular task and you can probably find something better suited.
Because 99.9% of people who diss PHP either haven't looked at the language in literally a decade or have never actually used it. PHP is fast, has a low memory footprint, now has many of the language features Ruby boasts about, simple Java-like syntax that is easy to pickup, is extremely easy to deploy, has a decent community, etc. I worked professionally with PHP serving hundreds of millions of requests per month for years extremely happily. It's actually a pretty nice language now.
I ran into this as well after switching my environment over to vim. my \`\~/.inputrc\` had \` bindkey -v\` which provides vim bindings in most contexts. irb/pry is the only application that seemed to blackhole my b key, couldn't figure out why
Most web frameworks are garbage. Rails happens to be one of the least shit ones. It’s still the framework I choose if I have a web project. 
Yes exactly.
The syntax
Both my teenage sons are into Ruby now, so I'm hoping for a multi-generational thing. They use it for wildly different things than I would have (discord bots and stuff). Some of the things they get to do look like mad fun. This one you get to programme pod-racer kind of things against other players. You don't have to use Ruby, but it's one of the options. https://www.codingame.com When I started it was typing out of mags into a VIC-20. :)
Ruby is, and I know it’s been said before, MAGICAL!!!. It’s just so reliable, there’s such a vast list of ways to do things and programmers coming from other languages will always be presently surprised that the syntax they’ve grown accustomed can be found in some form or another in ruby. That, and the fact that requiring an external file can so heavily impact our development experience by adding methods and features into our local scope and regularly accessed (and already instantiated) variables, and ruby is just that magical unicorn of a language you’ll always be fond of. I’m still mainly a python programmer, but ruby is quite certainly not second to python, they’re both on equal footing.
Actually a lot of languages have operator overloading, though I’ve yet to encounter ① in which it’s so normal that it’s basically like defining another method (and u can still explicitly call that method by doing object.[]()). For example python has hidden magic (__name__) methods which are called when an operator such as [] or () or &lt; is used. C# also has this, but it’s horribly verbose. Ruby has the nicest implementation I’ve ever seen.
I had a similar idea that I began building out. I ended up struggling due to rate limitations on the GitHub API. The goal of my project was to find other projects that contained certain gems. The idea here was if you want to see how someone implemented a open source project with for example Rspec and Capistrano it would return the most starred projects on github that use both of those gems. https://github.com/mjrode/stack-searcher
Rails is just a behemoth that gets in my way for a lot of the things I do. I don't do a lot of front end work and when I do, I decouple the UI from the server and use json with client-side templating.
I'm an iOS developer too! I use Ruby for a few different build scripts. We use twine and fastlane, both Ruby gems, for localization and automated deployment, respectively. Most recently I wrote a tool in Ruby for converting our unit test reports to a format that Jenkins understands: [https://github.com/silverhammermba/plist2junit](https://github.com/silverhammermba/plist2junit)
Programming horrors exist in all languages. Just because a language let's you do something terrible in terms of design doesn't necessarily means everyone will end up doing it. Similar things can be said about JavaScript or other languages. Point is unlike JavaScript, Ruby doesn't makes it stupidly easy to shoot yourself in the foot. You can be overly clever and redefine methods at runtime but you have to know what you're doing. Most interpreted languages are slow and memory inefficient. Those were never Ruby's strong points and no one recommends Ruby for those points. Ruby is supposed to be fun to work with and most applications are not memory or speed dependant. If speed or efficient memory is what you need, then you should look at compiled languages like Swift, Go or Crystal As an iOS developer myself as OP, I first picked on Ruby when writing post install scripts in my Podfiles. Second interaction was Homebrew. Then later I picked it up as I transitioned in backend development. So saying stuff like it's only good for Rails is also a gross understatement. Rails is the most popular, true. But there are a lot of other applications for Ruby
&gt; Point is unlike JavaScript, Ruby doesn't makes it stupidly easy to shoot yourself in the foot. I'm not sure what difference you are drawing here but both languages allow you to redefine class methods at runtime with no warning. Beyond that, Ruby's module inheritance pattern makes it very difficult to predict what happens when two modules have the same method name and are imported. Again, I've had gems redefine Object.present? before. That shouldn't be possible in a language that is used for production engineering. &gt; Most interpreted languages are slow and memory inefficient. Python and PHP are both significantly less slow and memory inefficient, and both have far more effective garbage collection models. Ruby's "Grow until the OS stops me and never release" pattern is horrible, and neither PHP nor Python (nor Java, for that matter) have this issue. &gt; So saying stuff like it's only good for Rails is also a gross understatement. For production level engineering I think this is true. For other things, like install scripts, sure, it is fine, but offers zero advantages over something like Python, and significant disadvantages (memory, install frequency etc.)
Hmmmm. These are valid criticisms. I have worked with Python and PHP as well. I keep coming back to Ruby even for the stuff that other languages are more popular for e.g. serverless functions because it's fun to write and almost all my apps never needed the better speed and memory efficiency other offers.
Currently using this as my guide. I've upgraded my work development to codeanywhere, and it is tons better. I'll hopefully have the SQL acc storing tested and finished by tonight. You'll be able to find it on my sad sad [github](https://github.com/JulianWeidner/Miny_piggies) 
Feels good to know I have brethren out there :D And that's actually what I'm hoping to use Ruby for, at least initially. I find a lot when I'm at work there are a lot of little things I want to be able to automate, but just haven't ever taken the time to become more than proficient at bash scripting. And even if I did take the time to do that, you're absolutely right - an unwieldy bash script is a nightmare.
Check out Sandi Metz books for good overall OOP principles. She writes with code examples that are really easy to follow. RubyTapas and GoRails are also cool sites (mainly paid subscription but with some free materials) that have pretty bite-sized digestible videos on all sorts of concepts related to Ruby/Rails. Ruby Koans is also helpful for language basics, getting experience using the language. 
Came here to say this. Otherwise, great post though. Covered nearly everything.
I think this is the main problem with coding Ruby TBH — you get spoiled as fuck. It should be mandatory for every Ruby coder to go and try to code something useful in another language every 3 months or so, just so you don’t forget how fucking spoiled you really are. 
If only it had decent concurrency. Other than that, I’ve got to say, it looks pretty damn sweet. 
Nice try, Rasmus.
FYI you can actually build iOS (and Android) apps in Ruby. Check out [RubyMotion](http://www.rubymotion.com/). Note: I’ve never actually attempted it, so I don’t know how easy/difficult it is, and what kind of app quality you can expect. But they’ve been around for a number of years, and are apparently still alive and kicking, so there’s bound to be *some* people out there making money with it.
Rails is great, but it’s been around for so many years that it inevitably acquired a bit of bloat here and there. Performance isn’t stellar (both memory- and CPU-wise), but the ease of development *generally* beats out the performance issues. Programmers tend to cost more than servers, unless you are running at Twitter scale. On the other hand, Rails is quite opinionated in the way it likes to do things, which rubs some folks the wrong way. Other than that, it is BY FAR the most productive web framework I’ve ever used. 
Fucking amazing post. Thanks again! I have a lot to learn. 
Niche market with diminishing interest == more money. I love Ruby and I stuck with it and I got a fantastic job as a junior that was WAY higher than the average rate. Lots of people are looking for Ruby devs and there aren’t enough of us to do it. That’s a place you want to be in. 
I’m not sure what you are all talking about. I love Bulma and integrating it into my Rails app was super easy using sass and the pipeline. And I could easily overwrite presets with my application.scss
I like that most Ruby/Rails devs are old guys like me who don’t get transfixed by a “hot new language.”
Neat!
Lol my god. Everything in Ruby is an object. Even Nil. I’m so sad for you. 
You might want to take a look at cron. There are ruby cron related things https://github.com/javan/whenever
If you really don't want to use a gem try using a loop that sleep for every X seconds and checks if it is or past the time you want it to execute
Using the [Chronic](https://rubygems.org/gems/chronic) gem ```ruby require 'chronic' # OP wrote # &gt; Im trying to schedule a program to wake up exactly at 12 am every day loop do # do what has to be done sleep(Chronic.parse('midnight') - Time.now) end ```
Or they can use cron without a gem :)
The community. I lived in Japan for over a decade and the Ruby community where I lived welcomed me with open arms despite the language barrier. We had BBQs and hackathons and my experience with the local "geek house" is one of my fondest memories living there. Ruby is fantastic as a language, but its community is absolutely top notch.
Writing in objects and writing good OOP code are 2 different things. And I have a feeling that Ruby community slowly but surely is learning from the old guys (Java for example) how to write well structured code. Rails is a big culprit IMO because it gave us sort of a location to put most of the code and the rest (I am talking about business logic here) can be just thrown everywhere. And rubyists firstly placed everything in a controller. Then came Fat Modal thing. Then Service objects. And all of that because we didn't take a good long look into how others do things and we needed to re-learn all of that through trial and error. Maybe I am delusional but I clearly saw this migration of ideas from other communities into ruby.
Just that articles like these should be in Learn to code 101. I mean value object is as basic as you can get and in ruby we do this knee jerk reaction when we need one - I will use hash. 
I do this. I have a cron that executes a Ruby script. Ezpz. Let's my Ruby focus on being Ruby and not on being cron.
I feel ya dude. Just pullin your leg a bit. 🙃
sleep is a Unix syscall and can/will return early for quite a few reasons, by design. Most likely that’s what you are seeing. It’ll return the number of seconds it thinks it slept for. It’s then up to your program to sleep some more if it needs to. There’s no way ruby’s time arithmetic is wrong. 
It has decent concurrency. It is parallelism it lacks.
Okay but is there a Ruby for Chaotic Neutral I can sign up for.
One really appealing thing about Ruby is that its so well designed as a language. Matz really took a lot of the best ideas from several languages and made it into a really consistent package without any of the core architectural problems that plague most other popular dynamic languages. Its a cool language to learn if you want to try something which is not just a another flavour of c/java and you don't really care for the eccentricities of python.
`sleep 1 until Time.now.hour == 0` The other benefit of this is if you're late running it, it'll still trigger if within the midnight hour. If that's undesirable, then.. `sleep 1 until Time.now.hour == 0 &amp;&amp; Time.now.min == 0`
&gt; I don't really want to use that gem rufus-scheduler or any other. OP has explicitly said he/she doesn't want to use a gem to do it, so you suggest him a gem that not only doesn't solve his issue, but does exactly what `Date.today.next.to_time` can achieve? If I were OP I'd either use something like `cron` or /u/petercooper's suggestion that solves it by doing many small sleeps instead of a big, potentially unreliable one.
If you don’t want to use a gem, despite the many great (and lightweight) cron options out there, write cron tables manually.
You are right.
**Consistency and Conciseness** There are languages looks like a patch-design language. It looks like they just keeps adding statement keywords to do specific jobs. **Block and OO** imo, Ruby would be a 99.9% perfect language if function is first-class citizen. But we have blocks and consider the OO part of Ruby, I would totally forgive it. *Dear Matz and ruby contributors, may we have the chance to support it?.* **Freedom and Power** You can feel the freedom when you write ruby code. Though occasionally I think it goes far at some place. But overall, I am enjoying it. 
It's interesting to see crystal and (particularly) elixir as "rubies".. 
Hmm. Not sure about others but I think these three are very important for my workflow: - coderay - kramdown - hmmmmmmmmmmmmm .... can't come up with one here... perhaps rack a bit in the sense that it would act as abstracter. I'd like that for classical desktop GUIs too so that I can write in that DSL, then translate it into ruby-gtk, ruby-qt etc...
https://github.com/jeremyevans/sequel Sequel: The Database Toolkit for Ruby ... https://github.com/ankane/pgslice GitHub - ankane/pgslice: Postgres partitioning as easy as pie https://github.com/heroku/barnes GitHub - heroku/barnes: Tell StatsD about request time, GC ... 
Just started using doorkeeper for oauth. Good stuff. 
One thing we use a lot is AASM which is a state machine you can attach to your models. It makes certain types of business logic easily enforceable and prevents subtle bugs when a record has different stages of processing.
guard statesman react-rails
Just curious but why sequel over activerecord?
cron can only start a new program each time. OP said they want their program to wake up, so it is already running. 
I don't use ActiveRecord when I - work with non-rails Ruby apps - have the need for a more flexible query builder without having to use SQL - I need to perform bulk inserts - I need to perform Upserts queries
https://github.com/googleapis/signet signet - Google's OAUTH implementation over Faraday. Has been very pleasant to work with, building REST clients for B2B APIs. 
Have you tried Sequel? I've used Active Record for quite a while, and a few years ago I switched to Sequel as I moved away from Rails, and I like it so much better! It's faster, simpler, and supports more database features.
&gt; Colorize - Print in color easily. (https://github.com/fazibear/colorize) 1. I've recently tried [Pastel](https://github.com/soveran/scrivener), and I like it a lot 2. [Scrivener](https://github.com/soveran/scrivener) – Simple validations 3. [MicroMachine](https://github.com/soveran/micromachine) – Finite State Machine
Elixir has this footnote: Note: Elixir is not a Ruby-to-Erlang compiler. Elixir started off with a Ruby-inspired syntax. The language semantics differ e.g. dynamic pure functional vs dynamic general pragmatic "multi-paradigm" language.
Yes I know this.. But it's kinda interesting that us (Rubyist) still wants to appropriate elixir..
I'd say it is the other way around - the elixir guys (and girls and non-binaries) want the rubyists to move on to elixir :-) by highlighting its roots in the ruby (and rails) community.
Yes.. Indeed! Ruby advertising is working the other way too ;) And yeah, as a former embedded systems engineer, I'm planning to try elixir from more than a year now.. Still waiting to have plentiful spare time...
No I haven't. Definitely interested after what you guys are saying here
sequel nyancat sinatra
* [Pry-Toys](https://github.com/ariabov/pry-toys) - Pry not required * [Bond](https://github.com/cldwalker/bond) * [TestXml](https://github.com/alovak/test_xml) (Omitting the ones I've created –which you all should be using 😜) 
I'm gonna be biased 😉 and say [hal_presenter](https://github.com/sammyhenningsson/hal_presenter) [shaf](https://github.com/sammyhenningsson/shaf)
- +1 for Awesome Print - stympy/faker - for generating completely bonkers datasets on demand - mongo - makes it ridiculously easy to work with data
1. Letter Opener was super helpful recently ([https://github.com/ryanb/letter\_opener](https://github.com/ryanb/letter_opener)) 2. I include Awesome Print with almost every project ([https://github.com/awesome-print/awesome\_print](https://github.com/awesome-print/awesome_print)) and include [this](https://gist.github.com/chaserx/e4302877fc550001ff8bf21730a23417) in my .irbrc file 3. Injecting a little whimsy into my terminal with lolcat ([https://github.com/busyloop/lolcat](https://github.com/busyloop/lolcat)) and the following \`fortune | cowsay | lolcat\` Honorable mention: I made a gem a while back, gems-cli, for searching [rubygems.org](https://rubygems.org) on the command line [https://github.com/chaserx/gems-cli](https://github.com/chaserx/gems-cli) 
I don't use Rails, so I appreciate a standalone library that has *never* assumed I do. AR's query builder seems to [play an awful lot of painfully slow catchup](https://twin.github.io/activerecord-is-reinventing-sequel/). It has a nice [plugin system](https://sequel.jeremyevans.net/plugins.html). It isn't just an active record implementation - Sequel::Model is an optional layer on top of a lower-level SQL dataset API. You can ignore it, or mix and match, or use [ROM](https://rom-rb.org/) instead. It's traditionally had much better multithreading support, and in particular has never needed hoop-jumping like `connection_pool.with_connection { ... }` It's also had a better reputation for [performance](https://hmistry.github.io/software/2017/12/11/activerecord-vs-sequel.html). 
1. [Scenic](https://github.com/scenic-views/scenic) for DB views 2. [Cells](https://github.com/trailblazer/cells) for a much better alternative to Rails helpers 3. [Webpacker](https://github.com/rails/webpacker) - it takes some effort, but I love bypassing the Rails assets pipeline completely
https://github.com/etiennebarrie/kwattr - removes a ton of boilerplate when working with POROs. I wrote a small wrapper to remove even more boilerplate for a common pattern I use: https://github.com/ActionSprout/action_sprout-method_object
Can't survive without [Pry](https://github.com/pry/pry).
You linked to Scrivener twice. [Pastel link](https://github.com/piotrmurach/pastel)
I'll give you a use-case. We have a Rails application at work that is essentially a front-end to an ETL ([Extract, Transform, and Load](https://en.wikipedia.org/wiki/Extract,_transform,_load)) job queue. Our first implementations of the jobs themselves were using ActiveRecord to pull _very_ large amounts of data, do some work on them, sometimes, and then move that data to some other persistence layer. Anyone familiar with ActiveRecord should realize that it is a bit of a bear for work like this. And it was. ActiveRecord was routinely running the jobs processor out of memory, falling over to swap, and leaving the machine in an unusable state. There was also _a lot_ of cognitive overhead involved in working on this code. We set up instrumentation and handling automatic restarts when the process ballooned out too far and then set to work cleaning up. This is where Sequel came in, in a big way. Sequel has something called datasets, which I think of as being a layer of ORM-style database access that exists _beneath_ ORM models. There are a lot of other features behind datasets that make them attractive, but I won't butcher those explanations. The Sequel documentation does a great job of explaining these things, if you're interested. What we also get with datasets is batch/bulk reads and writes. So, these 2 things, when combined, literally solved our problems. Our ETL jobs are now memory stable (the job processor will move GB+ yet runs ~1!0MB RSS) and are actually much, much faster than they were before. I _do_ think that we could've put more effort in to cleaning up the code that used ActiveRecord to do this work but I _don't_ think that we would've had the same nice and tight finished product that we have today by using Sequel.
Just piling on with 3 that I didn't see mentioned here yet, but that I find myself using often. * [Chartkick](https://github.com/ankane/chartkick) * [Groupdate](https://github.com/ankane/groupdate) * [MessageeBus](https://github.com/SamSaffron/message_bus) Honorable mentions: * [rack-mini-profiler](https://github.com/MiniProfiler/rack-mini-profiler) * [MemoryProfiler](https://github.com/SamSaffron/memory_profiler) 
I do a lot of DB stuff with Rails. And these have helped make like a little bit easier to comprehend. https://github.com/GeorgeKaraszi/ActiveRecordExtended https://github.com/scenic-views/scenic https://github.com/alekseyl/niceql https://github.com/zdennis/activerecord-import
Roda: https://github.com/jeremyevans/roda Very fast, simplistic and easy to extend web microframework Pathway: https://github.com/pabloh/pathway Service Objects implemented in a minimalistic, framework agnostic fashion SequelTools: https://github.com/rosenfeld/sequel_tools Very convenient set of rake tasks for the sequel ORM
Is it an either-or thing? I am considering using both alongside each other in the same app. I would use it in areas where I need more performance and don’t need objects in memory. 
And that’s how it’s meant to be am I right?
If you have no programming experience, you'll be well-served by a course designed to teach you programming fundamentals while teaching your first language. If the level rating is accurate, the course you linked in intermediate. I can recommend [Launch School](https://launchschool.com) 
I think you're gonna like Rails 6.0
cool example! 
I second that. Sequel's easy support for bulk inserts and upserts made 30min jobs take seconds in a rails project I used to work with, and afterwards I decided to rewrite all models into sequel. One of the best decisions I did. 
I just read the Pastel readme. I’m sold! Nice API. 
UP BOAT
The basics of ruby are the same. Nothing will have changed that would prevent what you learn from being relevant, however there are syntax features and methods that have been added. If it was released in June 2013 then hopefully it is based on ruby 2.0 but it could also be based on 1.9. But like I said the differences aren't major, and almost anything you learn on ruby 2.0 will work with ruby 2.6. &amp;#x200B; However I'd agree with the other comment, if you don't know anything about programming you might want to start with a beginner friendly programming class and then come back to this ruby course. It sounds like this course will cover ruby specific syntax and features and not start from 0 with basic programming concepts. 
First, I don’t think that course is too old. For language fundamentals, it’s fine. You can pick up some of the newer language features after you’ve got the fundamentals. I did just post a list of Ruby learning resources, some free, some paid, that you might find useful here: [Next Steps for Learning Ruby](https://www.wndx.com/blog/next_steps_for_learning_ruby/) 
Care to elaborate? 
Just checked out kwattr for the first time (from your link). I wonder if using `Struct` with `keyword_argument: true`gets you the same thing but without a gem? More info: https://blog.bigbinary.com/2018/01/16/ruby-2-5-allows-creating-structs-with-keyword-arguments.html
All io operations are asynch by default, you have access to channels for intrafiber comms, and (single thread) performance doing great. It is preemptive scheduling of the fibers though, so things can go wrong if you have something very CPU intensitive going on in one fiber.
For some reason I try to avoid installing too many gems... I guess it's because I don't want to add too much third party code that I don't have time to review the implementation for. But I do install gems, idk I was just curious about a more standard option... 
Yeah I want it to "wake up" basically implement waking up behavior by using sleep. It is exactly daemon so for now I need some quick way implement this behavior. 
first, ...thanks for that fun fact ! secondly, I deleted the code and this is a SUPER side project ... But I think I was using Time.now , I was subtracting it from a specific time like `"24:00" - Time.now` ? .. or something. Each time would be off by like a minute or two (too early). While I was testing the code I was also keeping in mind, conversion to seconds. So maybe my math was a little off? Ill give it another try , and try your example + explore some of the other reddit users' suggestions. thanks
syntactical sugar. I like this , but don't really understand this statement. What does `Time.now.hour` return? the current time? so sleep until current time?
wouldn't that cost a lot of CPU energy ... I would also have to start the program and loop, at the exact time I want to ensure accuracy. I want the program to run forever. It will be a daemon.
I've done this course it's not for beginner programmers, it's a fast paced intro to Ruby for people who have already programmed. 
exactly what I need!
- mina: https://github.com/mina-deploy/mina Ridiculous fast deploy, alternative to Capistrano - knock: https://github.com/nsarno/knock JWT Super easy to use - rack_attack: maybe is used by a lot of people, but I discovered recently and I loved it. 
https://rubygems.org/gems/ougai because unstructured logging is for chumps
Would also recommend that course on Udemy, it was really helpful for me when I first started out. 
Have not seen php or python in any benchmark to be more performant or consuming less memory than the new mri. Source ? This was true some years ago but it is completely different today. Are you perhaps parroting an outdated perception for mri?
I believe they should be able to run side by side just fine, just be aware that each will use their own connection pool, so the total amount of concurrent connections to your database will likely be increased.
OGA!!!!! [https://github.com/YorickPeterse/oga](https://github.com/YorickPeterse/oga) It's shocking to me how many people are still using nokogiri when OGA exists.
Don't forget '$' which is an alias (I think?) for show-src(?) (I don't use the long-version.) It's amazing!
I think there are three reasons for this: 1. Nokogiri (well libxml really) is faster 2. Nokogiri has been around for much longer, resulting in a more established foothold 3. Nokogiri has better support for incorrectly formatted HTML documents. Oga supports this to a certain extend, but not as well as Nokogiri. It's worth mentioning that the GitHub repository is not the canonical repository, as I moved all my repositories to [GitLab](https://gitlab.com/yorickpeterse/oga) a while ago.
It should be ok, even though it is 6 years old. The core of ruby does not change that much; a few syntax differences may occur every now and then, but for the most part you can avoid these too. Even the old pickaxe for ruby 1.8.x would still be very useful - just some parts that may no longer work. But even old ruby is very, very similar to "modern" (current) rubyr eally. In my opinion, the by far most important thing to do is to practice on your own. Like really write as much code as possible that solves certain tasks, no matter which task (but start with simple things... creating directories, files etc... from ruby, would always be useful; and spend a bit of time thinking about how to structure any project the moment it becomes larger aka more files that you may have to load up). Practice is really the most important thing IMO. It literally helps by far the most.
Great idea! But I prefer to use Tower. I look in the master branch and scroll back looking for branch names. If any appear, they are local branches to prune. 
Isn't git tower paid? 
There are some interesting paleoarchaeological links on that page. The "Gem of the Week Series" hasn't been updated since April 2015. No notice of discontinuation; no indication of any other team picking up the torch, just radio silence. The link to [Planet Ruby](https://planetruby.herokuapp.com/), once a very valuable resource, is also showing the End of Project Time was some time ago. The _Awesome XYZ_ links are still almost universally awesome indeed, and I fully understand what it feels like to suddenly run out of free time and/or to get completely burned out maintaining something when you feel like the lone voice in the wilderness, shouting "Doesn't anyone _care?!_" and receiving no answer but the wind. Ruby and "Ruby-like" languages have lots of projects with passionate, vibrant communities — but as far as building anything larger, more ambitiously inclusive, that ship appears to have sailed off the edge of the world somewhere between 2011 and 2013. What to do?
This is neat. The other piece of info I need to determine what I want to do with a branch is: Does the branch have a `remote` set, and if so, is the remote head the same as the local head?
Why did you move them? 
Firstly, floating point math in any programming language is subject accuracy limitations. See https://0.30000000000000004.com Also, in Ruby String#to_i is implemented such that it tries to return an integer resembling your string. It will return zero in cases where it cannot parse the string as an integer. In your case you probably want to use String#to_f to convert to a Float, otherwise you’ll discard everything after the decimal point. 
Damn! Good eyes! I'm locked at 2.3.3 for this project...
FYI: The Gem of the Week Series @ Planet Ruby will get back in the next weeks. I'd say it's not ruby-related (or about 2011 or 2013) - it's the "tragedy of the commons" - in this case - everyone is just enjoying the freebies and updates. Anyone even thinking about offering freebies or updates yourself? Very, very rare indeed. 
I moved all my projects to GitLab.com a while ago, as I find it a superior platform compared to GitHub.
`Struct` with `keyword_init: true` would probably work in many cases. I haven't used ruby 2.5 much yet, so I could be wrong about some of this, but here are some things that I like about using kwattr that don't come with Struct. * `kwattr` allows defining defaults. I use this for DI a lot. ``` class Customer kwattr :name, :email, repository: CustomerRepository.new end ``` * With `Struct`, it is possible to create instances without providing a value, resulting in the attribute being `nil`. For example: Customer = Struct.new(:name, :email, keyword_init: true) Customer.new(name: "John") # =&gt; #&lt;struct Customer name="John", email=nil&gt; This might be fine for your use-case, but with kwattr, missing attributes will cause an error, which offers a valuable runtime check. If you want an attribute to be optional, you can explicitly set its default to `nil`. class Customer kwattr :name, email: nil end * See https://thepugautomatic.com/2013/08/struct-inheritance-is-overused/ for a few more arguments on when not to use `Struct`. Also check out https://idiosyncratic-ruby.com/18-con-struct-attributes.html for a big list of alternatives. That's actually where I originally found kwattr. All that said, I still use `Struct`s, and find them very useful, but usually for temporary value objects, and rarely for classes with behavior, because of the reasons above.
* https://github.com/ankane/blind_index makes it easy to search encrypted data. I use it for phone numbers. That’s it. Nothing else that I use is all that interesting.
Nuking the remote would be good too. 
&gt; Like really write as much code as possible that solves certain tasks, no matter which task I really like [Codewars](https://www.codewars.com/) for this. Fun little challenges that get progressively harder and you also can see and vote on other solutions once you submit yours, which is great for learning as you can see more clever ways of solving problems from others.
[monotime](https://github.com/Freaky/monotime) might be of some interest. You could even make your `Timedelta` compatible with it by implementing `#to_nanos`.
Wow. Can’t wait to try it!
`to_i` is not rounding. It *always* strips the precision part of the float and converts to an integer. If you want rounding, there are `floor`, `ceil` and `round`. Also, if you really need the precision when adding decimals, you should stop using floats and switch to Rubys `BigDecimal` library
Thanks for highlighting the monotime library. The unit-time library first usage is in secure ruby (sruby) where seconds is the base (and smallest) time unit (for now).
I've been using the Baeecamp equivalent for a while and it's suuuuuuuper helpful (https://github.com/basecamp/marginalia). Does this offer any extra functionality?
If you stick with Rails long enough, you start to have some freedom, or, start thinking in a Rails-way. It makes sense eventually, it sucks at first because they make a shitload of decisions for you. You can use basically anything, value objects, form objects, service objects, non-ar models, your business logic can be fancy and well-designed. It's not trivial though, and I agree Rails is not a silver bullet and it's not the best for starting out, it's good to start with a "do it yourself" approach, from scratch. 
Exactly my point :) Thanks for the kind comment
This one is different: it prints the stacktrace, not the metadata (like Marginalia does). It’s like Rails 5.2+ [verbose_query_logs](https://edgeguides.rubyonrails.org/debugging_rails_applications.html#verbose-query-logs) but more flexible (you can configure the number of stacktrace lines, filtering logic).
Yes, sleep for 1 second over and over *until* the current hour is 0.
Docker makes Bundler obsolete and Bundler adds unneeded complexity especially when using local volume mounts and Gemfile.lock files. 
If you want to go this route you're better using https://bundler.io/v1.6/bundle_package.html and mounting that.
Indeed.. I was thinking about this command.. Do you have resources about how to set up docker containers (for development but also production) using this to embed the gems in the image and if this will allow to have a multi staged build?
This article gives a great highlight about actual daily usage practices. However it would have been better if for documentation purposes the `dockerfile.prod` file was shown too.
Oh yea I have covered it in [previous post](https://anonoz.github.io/tech/2018/05/01/rails-dockerfile.html)
&gt; After this, you can just run the 2nd command in the listing above whenever there are changes in Gemfile/Gemfile.lock. Any time there’s a process that requires one to remember to run manual steps, I can guarantee one or more members of the team will waste hours and hours trying to figure out bugs caused by missing those steps when they were needed.
Well ruby and win is always a mess. Much better in mac and linux. 
But this is the best solution I came up with as alternative to redownload all the gems in `docker-compose build` everytime there is a tiny change. If you have other ideas I have missed out, let me know.
There's a ruby distribution for windows called 'rubyinstaller' which bundles mingw and all the crap you need to build gems... but honestly the best thing to do in windows10 is just [install the Windows Subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/install-win10) and use ruby on *nix from within windows. Note this isn't a virtual machine, WSL is a syscall compatibility layer much like WINE, so it's pretty light on resources and can do cool stuff like access your local filesystem.
Sounds interesting. How would you deploy it?
I see. Thanks for your response.
There's a common trick where you create a gem cache volume. Essentially you define a volume in the compose file that you will mount where bundler looks for gems. This ends up feeling very similar to your own local gem cache when you jump between projects. If bundler can find a candidate in the mounted volume, it will use it. Search for Ruby docker gem cache.
I’ve worked with 3 different teams, with 3 different solutions to this problem. This was one. All of them ended up flawed. I’m not convinced there is a “good” solution.
If you are talking about bundling it as installer or executable, I don't have an answer. But I guess since Ruby is not bulky, I would say it is possible, if one spends enough effort. As of now, it saves the user opening the browser and navigating to an URL. Further, it allows a Rubyist an alternative to Javascript.
Also what "dabbling in linux means here? Did you go kamikaze and installed arch as first distro? If so I'd reconsider... Also most devs are on some Gnu/Linux distro and that's what you will find tutorials for... Maybe WSL as someone mentioned does copy the environment ok, though that I do not know. 
There's also [Timerizer](https://github.com/kylewlacy/timerizer), which I've used on a couple of projects. But it's got the same conflicts with sruby that Monotime has; seconds are a freaking huge "minimum time unit".
I recommend WSL and RVM to you
Agreed that Docker and Bundler step on each other's toes, but developing Ruby apps without Bundler is just madness.
How do you propose to use Gemfile.lock without bundler? 
Thanks for clarifying. It sounds really useful, especially for finding pain points in legacy code. 
Thats why, instead of long complex readmes, you write `setup.rb` and make people run it
I am not sure about that. I see people who write rails code for a long time, write ruby code in quite different ways as to how most who would only use ruby for many years do. It's almost as if there are two different languages employed here.
You could try WSL. For the gems, I bet you only have problems when you have to compile something on windows. This is always a pain in the ass, not restricted to ruby alone. You have to setup a proper working toolchain e. g. mingw and what not. It's not easy so it may take some time. I abandoned windows many years ago for linux and would not go back. WSL makes windows more usable though. Since you can also access the windows filesystem, is there a reason why you would not want to use the WSL?
Hello! Have you tried this? [http://railsinstaller.org/en](http://railsinstaller.org/en) . 
It's unwise to dismiss the windows market share, it's very big. Many first timers still choose php as their first language just because they're on windows and php runs relatively smoothly there.
Any plans to support Semantic Logger ([https://github.com/rocketjob/rails\_semantic\_logger](https://github.com/rocketjob/rails_semantic_logger))? I've tried it the gem and I get no tracing, but I'm assuming thats because I'm not using the default rails logger. 
[https://github.com/ddnexus/pagy](https://github.com/ddnexus/pagy). An ultimate pagination gem that outperforms the others in each and every benchmark and comparison. Loved it.
Done.
**Update**: I've just released v0.4.0, which adds a column showing a comparison, for each branch, with the upstream (remote) branch it is tracking (if any).
If you don't want to use the subsystem yet, another alternative is to use Docker. Unless you're doing to deploy the Ruby application on a Windows machine, I wouldn't install the interpreter on Windows. https://www.driftingruby.com/episodes/intro-to-docker-on-windows
Very simple solution: Make a copy of your gemfile and lockfile with an extension of "ref" or something . Add a step to your dockerfile that copies the ref versions over stipping their extension and run bundle install. Then proceed with copying over everything amd running bundle install. Now from this point forward you have the majority of your gems in the container via the ref step. If anyone changes the gemfile to add new gems they'll get picked up in the second bundle install.
sweet!
The `"0.9999999999999999999999999999".to_i` example is a bit different, because that's converting a *Sting* to an Integer. As for the first four cases, this is in no way ruby-specific; it's a very well known and defined limitation of Floating Point Arithmetic. `0.99999999999999995` does not simply *round* to 1; it is **equal** to 1! [1] pry(main)&gt; 0.99999999999999995 =&gt; 1.0 This is because of how floating point numbers fundamentally work. They are defined with "finite precision" and therefore there are a finite number of values defined (for example) between 0 and 1. There is actually a built-in method to see what the "previous" and "next" floating point values are for a given number: 1.0.prev_float =&gt; 0.9999999999999999 These are defined according to the [IEEE754 standard](https://en.wikipedia.org/wiki/IEEE_754), and is once again, not ruby-specific. If you want a more "accurate" decimal representation, then you can use [`BigDecimal`](https://ruby-doc.org/stdlib/libdoc/bigdecimal/rdoc/BigDecimal.html) from the standard library.
What you talking? The real truth is you can install ruby on windows but is always a mess is the real thing. I am not dismiss nothing. The solution :) is use cloud systems to use ruby on windows :) like cloud9. Sorry for hurt your feeling and the market share &gt;.&gt;. 
The code knows a \*lot\* about the structure of the hash. You might consider using a bespoke object instead. The rest of the code will become much simpler. I do my best to avoid working with Hashes if at all possible. Sometimes I'm getting data from JSON or whatever, but I almost inevitably write an Adapter class. &amp;#x200B; Also, why are you using looping to get at Hash members? You might want to see Hash#\[\] or even better Hash#fetch.
It's part of pre-coursework I have to do for a coding bootcamp. I have to use loops because that's part of the exercise.
I guess the first improvement would be to not iterate through a hash if you know the key for which you're looking. Given your hash and the name of the season, you can look up the relevant array with `thebachelor[:'Season 30']` Similarly, you needn't iterate through the contestant data, instead just use `contestant[:'Winner']` Note, using the colon hash syntax with a string key `hash = {'a': 1}` requires you to access it somewhat weirdly like this: `hash[:'a']` You can either use a symbol as the hash key as in: `hash = {a: 1}; hash[:a]` or use the hashrocket syntax `hash = {'a' =&gt; 1}; hash['a']` You'll still need to loop through the season data, as its an array of hashes.
I see, what would the code look like in that case?
There's no sense in my writing it for you. Try rewriting one of your methods but access the keys directly, instead of iterating through.
You just need to know the standard library: https://repl.it/@zernie/StupendousSpecificConsulting
I'm having trouble understanding what you mean thats why I am asking you. 
Hash#find (Enumerator#find) method is your best friend def get_first_name_of_season_winner(seasons_data) seasons_data.each do |season_name, participants| found = participants.find {|participant| participant[:status] == 'Winner' } return found[:name] if found end nil # prevent the method from returning an Enumerator object when no results are found end
Have you checked out [Hanami](https://hanamirb.org/)?
How would you do it without bundler?
Thanks for highlighting the Timerizer library. Good point. For performance profiling or high-frequency trading etc. seconds are freaking huge :-) but for blockchain programming a second is good enough for now (some more modern blockchains already have a blocktime less than 1 second(!) but bitcoin has 10 minutes and ethereum about 15 seconds).
I used to use it. WSL makes windows less shit. Unfortunately the rest of windows is still way too annoying to want to use and I admittedly have gotten to a point in age where I don't really want to use windows anymore. I have been using linux since ... hmm ... 15 years by now and it's a great operating system. Execution speed in WSL is a problem but the WSL team is aware of it. I recommend doing other things when something seems slow. :P In the long run I think they will improve on the speed-related issues. The appeal is simple - it works very well. None of the described problems affect most people really. All my ruby scripts work on linux and WSL just fine. I compiled everything from source too; got kde konsole working via xming as well. Really, I don't understand why you find WSL not useful or usable. Also I am not sure why you think the windows desktop is faster than gnome. Take mate-desktop - works super-fast. Gnome2 legacy. I don't know of what "sacrifices" you talk about. WSL simply makes windows less shit. It still remains a clusterfudge but frankly if you HAVE to use windows, for whatever reason, then WSL makes it suck less. And that's a good thing.
You're in way over your head. Hire a professional.
Absolutely. You don't need a virtual box. Just download scoop, use it install ruby, keep click 'next' and follow the instructions on the command line :) then your machine will be installed ruby, msys2, mingw64, then you are good to go. Plus, you can install bash on ubuntu on windows 10, the performance is better than a virtual machine. 
Interesting. I’m going to be implementing notifications in my client project soon, but there is a case I have which can’t be that uncommon, but I don’t see how to implement it with your gem. I have two STI user models, Client and Service Provider. I need to have them each as subscriber &amp; publisher for the AccessRequest. Any thoughts on how you’d handle that?
I use it for some trivial tasks. I've found MongoDB couldn't run on it, so there may be more.
&gt;Really, I don't understand why you find WSL not useful or usable. Also I am not sure why you think the windows desktop is faster than gnome. Take mate-desktop - works super-fast. Gnome2 legacy. I'm just saying it is not possible for me to use it during the workday for Ruby on Rails development. With all the ravings, I wondered if I'm missing something. &gt;Also I am not sure why you think the windows desktop is faster than gnome. Take mate-desktop - works super-fast. Gnome2 legacy. It just feels significantly snappier on my machine than Ubuntu 18's desktop. Less perceptible lag on almost everything. Has always seemed to be somewhat the case to me, even since I used Gnome 2 and XP.
It works fine for me, but I use a single Vim instance with split windows for terminals. Also I use mysql instead of pg so I haven't run into any major issues yet. I have had some issues with WSL though, it's not perfect, it has some rough edges, but I hope it will get there, it's a nice tool. Now, for everyday development and work, I use macOS or Linux. There is no way around that, at least not in the foreseeable future.
A popular alternative to Codewars is [Exercism](https://exercism.io), which is a very newbie friendly site with mentors who help you when you run into problems.
The classification of RubyMotion is somewhat out of date as well. It should be slotted in as Ruby-to-LLVM. 
Would you please explain further? I'm not sure I fully understand the use case, but I'm very interested so that I can get the gem to cover it. &amp;#x200B; In your case, Client and Service inherit from AccessRequest? And what would trigger the notifications?
- It is noticeably slower due to the filesystem translation layer, 2x might be a stretch but yes - You can install Postgres, redis, elasticsearch and other things as using the distro's package manager? - This was far and away my biggest paint point. It gets a little schizophrenic. VSCode itself has all the workarounds needed for WSL in its current state, but outside of some of the most popular extensions you're gonna hit this one a lot. Most times there was a workaround, but still it's not a great story yet. So, yes I was able to run everything I needed for my Rails work. Which is kinda amazing and why people rave about it. If Windows is your primary OS, you can get a lot done without a VM or booting another OS. My main dev laptop went back to only Linux, but my gaming desktop can also be a quick workstation should I need it.
No. Client and ServiceProvider inherit from User. Clients make requests to get onto a service providers client list. Service providers request access to client’s info. It’s one access request, but it can be initiated from either side.
You are in over your head, but you can still learn to swim if you try enough. I'm not sure who "the" are, but they're misleading. Ubuntu **is** user-friendly, but it is still a complex, modern operating system. Every modern OS has the moral equivalent of 10's of thousands of moving parts. So a "user friendly operating system" is like jumping in a user friendly airliner and learning to fly. "They" are probably a programmer who has forgotten what the rest of the world is like. Once Ruby is second nature to them and they've been using *NIX systems for years, they may indeed seem intuitive. I can guess at your errors, the following: &gt; localhost:3000 access denied for user 'root'@'localhost' Likely means either the port is closed on the system's firewall, or sshd is not configured to allow access on port 3000 and/or for root. &gt; brew install yarn &gt; brew install honcho # https://github.com/nickstenning/honcho These both assume the [package manager "homebrew"](https://brew.sh/). That is probably not installed on your Ubuntu VM. You can install it via the linked instructions. &gt; yarn install This will fail until you have successfully installed yarn, from the above steps. yarn relies on Node &amp; NPM &gt; bundle install This may or may not depend on the proceeding steps, if it still fails once you have the above working, you may be on the wrong version of ruby or bundler. Both can be updated through the system default package manager 'apt' and/or 'aptitude'. &gt; honcho start Depends on honcho, should work after the brew install of honcho succeeds. 
I see. With the current implementation, you could do it in two ways: &amp;#x200B; 1. Define separate triggers for Client and ServiceProvider. In each class, use notifies and define separate triggers. 2. Define a trigger in AccessRequest and invoke it from Client and ServiceProvider &amp;#x200B; This is an interesting use case. Do you have a proposal of how this would ideally be dealt by Correspondent?
If I understand what this does (and I may not), I think maybe [wisper](https://github.com/krisleech/wisper) may be an already existing more general and mature solution?
I think [rack-mini-profiler](https://github.com/MiniProfiler/rack-mini-profiler) may also do this. 
I see what you mean. 2 would have the AccessRequest as the publisher, with Client &amp; Service Provider as recipients. That could work, although it feels a bit strange. I’ll need to put more thought into it.
I agree wisper is more general and more mature. The goal was to be more specific in respect to notifications (instead of generic callbacks) and require less configuration. &amp;#x200B; As I mentioned in the post on [dev.to](https://dev.to), the gem is not yet production ready. It is more of an experiment at the moment and I am just looking for some feedback and ideas.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubyonrails] [Could you walk me through any improvements on this code? Its mainly involving iteration of nested hashes and arrays](https://www.reddit.com/r/rubyonrails/comments/azvoeq/could_you_walk_me_through_any_improvements_on/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Your tone is all wrong buddy.
I have found WLinux to work great. Much faster than my first attempt with Ubuntu. 
https://www.theodinproject.com/courses/web-development-101/lessons/prerequisites Check virtual-machine section, it's step by step guide how to instal VR in windows, and then install ruby and rails inside
Your `count_contestant_by_hometown` method never uses the provided `hometown` parameter. `hometown` is not the same thing as `:hometown`. Your code as written is only counting the number of people who *have* a hometown, and is not concerned with what that hometown is. You also need to put more thought into your variable names. In `contestant_data.each do |a|`, what is "A" here? Do *you* know what it means? When you call `a.each do |attribute,value|`, why are you checking the attribute against a symbol and then ignoring the value itself? `occupation` and `:occupation` are not the same thing, please review the difference between symbols and variables.
I disagree. His tone sounds like he's lost and doesn't really know what he's doing, which he admits himself. /r/ruby sounds like the perfect place to ask these kinda questions. Keep in mind not everyone writes the same way you do, because we all come from different countries and have learned English a different way. Even between native speakers, tone is also cultural. It's wrong to assume a problem with his tone, when it could just be his way of speaking
That might be a great first-timer contribution :-).
There's also this one [https://github.com/rails-engine/notifications](https://github.com/rails-engine/notifications) 
What things do you see this making easier than wisper? Have you considered adding convenience API on top of wisper? wisper is already going to have dealt with a lot of things that you wouldn't have to reinvent. That's my feedback and ideas. :)
What is your background and why are you doing any of this? If you don't have any programming experience this is way over your head. 
&gt; They said: you don't need even programming experience. To do programming? That was mean advice. Setting up any new language is tricky without help, let alone a new framework. Best I can suggest is try to get someone with experience to pair with you to help you get setup (Have you searched for a nearby Ruby Meetup?). Each project can be a little unique, so help from an experienced eye will help you get started. 
Sadly Linux will always going to be behind on graphics card drivers due to the closed source nature of the newest drivers, e.g. trying to drive Gnome on my monitor via Display Port on an ATI card means flickering, I've sure I can fix it by tweaking arandr or some other setting but TBH I'm unmotivated to do it. This is just the downside of being a tiny portion of the desktop market and thus nVidia and ATI not really giving AF about Linux. IMO though it's hard to blame Linux for the issue until the graphics card companies stop being unwilling to open source their driver code and thus forcing developers to reverse engineer it OR you to accept their version of a linux compatible closed source driver. In general, it's best to not be leading edge graphics card wise if you run on Linux. Eventually the community catches up, it just takes time. 
WSL is the last option for developers who rely on development tools running on Windows. Use tools that work in the same OS as your development environment. If you can not endure using WSL, choose another OS.
It works well enough albeit not the ideal platform in general for development. Like you said it gives you options in Windows to do most of what you need to accomplish. I also think it's good tool to have though as some companies' IT departments still insist their people (including developers) use Windows only for their workstations. As crazy as it may seem they do exist, luckily I no longer work for one. 
Also important to note is that people aren't writing things in the mindset you're reading them. IME people tend to forget this when reading text online and it leads to people getting triggered fairly easily.
I use it, but end up running everything through Vagrant or Docker
The one thing I’d say is I’m not a fan of the #to_notification method. That’s really view-level stuff. I think it would be better for that to go into a locales .yml file. It’s not just cleaner - the content for all notifications live in one spot - it’s also ready for internationalization. Same thing for emails. It would be better to be able to define the subject lines and body content in a locales file and not have to create controller methods for each email. Mah two cents. 
You must've had a botched linux install, because Linux distros - including Ubuntu - are absolutely, 100% more performant than Windows or MacOS. They use about 1/4-1/8 the memory because they are much more lightweight. You could try another distro, like Fedora or Elementary. I can't say much for WSL, but I will say Ruby is generally designed to run on *nix OSes first. This is why macOS is generally preferred for Ruby development. Not to say you can't use Windows, but... it's not a priority for many to support Windows. Personally, I'd do a little "distro hopping" and find a Linux distro you're happy with. Even with a few year old computer, you should be able to boot into Linux in less than 30 seconds, generally much, much less, and it should be every bit as performant as Windows (if not more so). Have you considered getting a server (from DigitalOcean, for example) and doing your dev via SSH (or Mosh for crappy connections)? You wouldn't have to screw around with things not running right under an emulated Linux shell, because you'd be working in a real Linux shell. The only downside is you'd have to be connected to the Internet for it to work. But you could run Windows all the time and just SSH into your remote box to run tests, enter the console, etc. Almost any editor will do remote files too.
Interesting, I was not aware of that.
What version of Ruby and Rails are you using? Currently, there are no plans to support rails_semantic_logger but PRs are always welcome.
Yeah I'll have to try pastel for sure. Thanks!
Chartkick looks amazing! I gotta try that in our app.
So this task, in general, is very DevOps-ish. To take an application and deploy it on a server is what DevOps is. It seems that you are missing a lot of the core fundamentals on servers, command line usage, and basic application architecture, which is OK, we all start somewhere. Working through this should help you understand a little more on what to do. Also, why does it have to be deployed on Windows? The majority of today's applications online run on Linux distributions (Ubuntu, Centos, RHEL, Fedora, etc). Of the popular Linux distros, Ubuntu is the easiest to get around (maybe alongside Debian). If you plan on taking your tech career far, it is far more valuable to learn a Linux distro (imo), then to bother deploying this on Windows. You're not really doing yourself a favor by using Windows as a development OS. As a matter of fact, you're giving yourself more work. VirtualBox is a good way to start learning and understanding about virtualization, but after you get an idea of what virtualization is, I would start learning about Docker (maybe in the far future). Regarding your question (Will I be able to make a local run of a website), it really depends on how the developer created the application, but the answer is yes. If this deployment runs on a server now, then it _can_ be deployed on any other machine. Did they develop it on windows? did they develop it on linux? this matters because the dependencies are dependent on the OS and architecture. Also, you don't necessarily need Ubuntu, but it _is_ the easiest distro to work with. Don't give up. If you're stuck, you can PM me and I'll try to explain as best as possible. I was once where you were, and I was only able to get out of my ditch once I had someone explain to me the pieces I wasn't understanding. 
Thanks for the update! I'll see if I can organize something in the next eight months. Mobility limited at the moment.
Why do you have a comma in front of the home town? You're passing hometown to your method and trying to use as :hometown, which is a different thing. :hometown is the symbol called hometown, your parameter is simply hometown. That's a major mistake I see looking through my cell, but the code in general is really weird. Is this your first time coding? 
Oh my gosh, the documentation alone is worth it. Amazing!
I understand your concern about having all the configuration centralized, but how would you use instance specific information? &amp;#x200B; Using the example in the README, if an instance of purchase triggers a notification, how would you use the purchase ID in it using a translation file such as en.yml? &amp;#x200B; Thanks for the feedback!
Building the API on top of whisper is a great idea. However, the meta programming involved in creating the hooks for the notifies method was something I wanted to learn and explore. I suppose that's pretty much why I went with writing my own version. &amp;#x200B; Thanks for the input!
Yeah it is my first time, with ruby at least. I only started coding a couple months ago
I really wanted to hear his thoughts on mocks and integration testing. I think that’s where people really take divisive sides. TDD: By Example really only implements simple code and tests. There’s no networking, database access, etc. This is where people start to go crazy on what’s the “right way” to test. I just want someone to share the answer. I’m an extreme fan of testing, but 100% coverage and end to end testing seem crazy to me at the moment. A lot of scenarios seem not worth it.
I think maybe I wasn't clear with the context. I've been developing on Macs and Ubuntu happily for years, but I'm sick of switching my PC workstation back and forth so I just thought I'd try something new and talk about it. I'm well aware of the shortcomings of Ruby on Linux, what WSL is is a Linux VM with direct integration with Windows. The reality is, for large projects I found it be exceedingly slow probably due to file system performance issues. The experience is generally crappy, but I agree with the thread consensus that it is better than nothing. My performance issues are just the generally UI snappiness. Windows 10 makes it feel like tasks switch and applications open almost before I click on them. I do not measure perceptible performance in memory usage. I don't care about that unless it is swapping.
Nice one Jason!
You're right, I haven't seen benchmarks comparing the latest MRI to the latest PHP. If you have them I'd be happy to look, but Ruby has been more than one order of magnitude more resource intensive than PHP for a while so I would be surprised to see them overtake. Again, please share any benchmarks you have. As an aside: don't phrase disagreements as condescending questions. If you think I'm wrong, say so, don't ask me the equivalent of "have you considered that you're actually a fucking idiot?" My comments in this thread clearly show I'm not just parroting bullshit. Please show some respect.
&gt; I highly recommend not to use this approach, because disabling TF-IDF isn’t the thing which you usually do with a full-text search engine. What other approaches people got, what actually ends up working well? I have been trying to run a live (in my case) Solr for tests and CI, but I haven't really found a non-painful way to do that either. Anyone found any approach using any tools that they like?
What does this have to do with Ruby?
r/lostredditors ?
... hmm , but then your'e calling sleep() way too many times. 
Mimic what Rails does. Rails has a method, I18n.t, that accepts interpolations. So you can write it your yaml file “Hey there %{name}” and you can then pass the I18n.t method a value for “name”. Correct? So mimic that. Make a new pattern, like ^[name] where “name” is the instance method name to call. Your code fetches the right locale yaml string for the notification (you just use I18n.t for that) then uses a regex to find instances of your pattern ^[...] and replaces each by doing instance.send(name) This would allow you to write things in your yaml file, for example, like “Purchase ^[id] was just shipped; total was ^[total] and shipping amount was ^[shipping_total].” and *id* *total* and *shipping_total*’would be automatically replaced with the correct instance values because your code called purchase.send(:id) and so on. 
Agreed. I'm a fan of fewer tests, mostly integration. If you need dependency injection to stub out 3rd parties, great.
I think the easiest for you would be to install vagrant and use a premade Vagrantfile or create one on your own. Something [like](https://github.com/Rojo/vagrant-for-rails-apps) this should help you move forward.
OP, I think your boss is reading this.
Others have written extensively about this. For instance if you have a [clean architecture](http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) where business logic is completely independent from the DB/network/other services then you can just go with the generic [test pyramid](https://martinfowler.com/bliki/TestPyramid.html). The problem that you might run into with Rails, specifically ActiveRecord is tight coupling between the DB/business logic. Or if you use any gems mimicking/using AR (Paperclip, Her etc.) then network/storage/etc. with business logic. A bad test suite is usually because the code that it tests is also badly abstracted/tightly coupled etc. 
I know. In fact, that is what I have wished for from the start.
"They" - a task giver and a programmer who gave major instructions and said that everything would be easy. Thank you for commenting on problems. Though I won't get to them any soon, I will use your answer when or hopefully **if** I get to them once again.
Thank you. Installing VM was actually the easiest part.
I have a few years of programming (not Ruby and mainly PC-oriented) but that didn't help me even a bit with the task.
Thank you. I kind of suspected the same about programming experience but was not sure. As for meetups, I don't think somebody will like a total newbie coming with little to none understanding and a ton of questions just to solve one's own problem and leave.
For me, lately, it would be: * [dry-transaction](https://dry-rb.org/gems/dry-transaction/) \- for any complex workflows which are supposed to fail when one step fails (railway) * [dry-container](https://github.com/dry-rb/dry-container) – for handling any kind of project-wide dependencies and configurations * [hanami-validations](https://github.com/hanami/validations) \- my library of choice when it comes to validating input
Thank you for the answer! Well, I have a fairly basic task: run locally and explain how to run locally. This is why I believe that Windows which I am accustomed to will help me achieve the task faster. Besides, I don't know whether the task giver will use Windows or Ubuntu. However, I might be asked later to maintain the thing. Therefore, it may really make sense to use Ubuntu. But I plan to use something intermediate: run it on Windows, get along, run on Ubuntu in Virtual Box, get along. Maybe I will switch later to something more suitable. And thanks for offering help. If I get to it again and get stuck, I know who to ask questions. I will try not spam you.
Thank you. If I understand correctly, that is an alternative to Virtual Box with included software?
I, a professional Minecraft Linguist, have found some errors in your comment and have recrafted it. &gt;thank you. if i understand correctly, that is an alternative to virtual Chest with included software?
If your project doesn't rely on Inverse Document Frequency, you can change scoring model as we did. Otherwise I don't know any less painful solutions besides creation of stubs manually.
From the article: &gt; The situation with every project has been almost the same: a single search query is stubbed, then one spec checks that system has sent a request and received mocked data. This spec has a problem, it checks if a query has been sent to Elastic, but it doesn’t care about search results. Why should it care about search results. I thought mocking external API responses was standard.
I think it depends on a complexity of a search logic. If it is simple, then maybe checking that request is sent is enough. 
It's a shitcoin post, and shitcoin posters believe shitcoins are relevant to everyone.
Yea I’m not in that camp. 
I definitely think Rails gets in the way of isolated unit testing. No wonder DHH started rallying against isolated testing, because you simple can’t do it with ActiveRecord. You can’t do anything approaching clean architecture with Rails, because every step of the way it chooses ease of talking to infrastructure over isolating the domain from infrastructure. 
No, it sets up a virtual machine in VirtualBox for you. Read up on Vagrant [here](https://www.vagrantup.com/intro/index.html).
Yes, this is my main takeaway after using Rails for 5+ years. We can harp on about best practices and software craftsmanship all we want but the underlying architecture of the framework simply sacrifices long term maintanibility/clean code/etc. on the altar of ease of use. That said, I've recently started a project with [ROM.rb](https://rom-rb.org) and it works perfectly with Rails. For others, there's Hanami. 
I read this and all I could think was, "boy you missed a real opportunity to make a hackers reference to the 'garbage' file".
many thanks
It's extremely negligible CPU-wise. I had to run `sleep 0.01 until false` before even hitting 0.1% CPU on the process and that's running the loop 100 times a second. `sleep 1` every second is going to be using somewhere in the region of 0.001% CPU which is essentially nothing.
For example, data.each do |season, contestant_data| contestant_data.each do |a| a.each do |attribute, value| if attribute == :occupation return a[:name] end end end end could be replaced with: data.each do |season, contestant_data| contestant_data.each do |a| return a[:name] if a[:occupation] == occupation end end
This will also solve the bug where you are not using the `occupation` parameter.
Excerpt from my `.gitconfig`: [alias] mbd = "!f() { git fetch -p &amp;&amp; for branch in `git branch -vv | grep ': gone]' | awk '{print $1}'`; do git branch -D $branch; done; }; f" Deletes all local branches that have no remote equivalent. Run it with `git mbd` (**m**erged **b**ranch **d**elete). I've been using this for years without any issues, YMMV.
&gt; just to solve one's own problem and leave. Hah, no one likes someone who just leaves. However, meetups normally have lightening talks &amp; a little bit of networking. You might not answer 100% of your question, but you'll get some ideas of the solution &amp; get a feel for the industry (Which is pretty friendly!).
I am sorry I have replied in a bad faith because I was in a bad mood and found your comparison to python or php to be an old stereotype. &gt;Also, as far as I know the memory management model for MRI has not changed at all, which puts it in a very different category than a language like PHP, which releases memory after every request. If that hasn't changed, the performance may be improved, but you're still dealing with a memory hog. I am not aware of "the memory management mode has not changed". I am sure there had been some optimizations regarding allocations and releasing memory for a lot of things (mainly the improvements behind 3x3). You can check some of the benchmarks on alioth and similar.
In my experience, most code out there is not suffering from too many tests but too few. I'm an advocate of the [test pyramid](https://martinfowler.com/bliki/TestPyramid.html), although I also realized that the ratio of integration tests to unit tests (or model tests or whatever) that makes sense for an application can depend heavily on what kind of application it is.
Thanks man!
Here is one link for you https://weworkremotely.com/remote-jobs/search?utf8=✓&amp;term=ruby
nothing definitive. you can search "ruby" jobs on glassdoor in your area.
There is a subreddit you can try. r/railsjobs
PHP destroys Ruby by your own benchmark source: https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/php-yarv.html I don't know enough about 3x3 to know if it changes the memory allocation model, but 3x3 is not even scheduled to be released for another two years, and I don't see any benchmarks for it. Let's say they hit their 3x improvement goal, though: PHP will still be significantly faster, assuming it makes zero improvements between now and sometime in 2020.
Adie?
&gt;PHP destroys Ruby by your own benchmark source: https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/php-yarv.html Ruby here uses JIT which naturally has some memory implications and JIT does not really have a time to kick in. PHP is already "fast" with HHVM. 
Do you have a commercial agreement to distribute Brakeman? https://brakemanscanner.org/blog/2018/06/28/brakeman-has-been-acquired-by-synopsys/index.html (Previous thread: https://www.reddit.com/r/rails/comments/azdq7p/is_anybody_interested_in_finding_vulnerabilities/)
Just search for it in your favorite job site. There isn’t gonna be a nice list for ya. 
The guy does come across as being extremely touched in the head.
remoteok.io is a good job listing site.
I agree that it's better to learn Sinatra first. It's kinda nuts how so many beginner Rails devs don't know how to do anything outside of MVC, or use non-rails gems. 
There's the github remote jobs repo - [https://github.com/remoteintech/remote-jobs](https://github.com/remoteintech/remote-jobs) &amp;#x200B; Not all are Ruby, but there are some
Hmm. He asked for ruby though - while rails uses ruby, I assume the total number of all jobs using ruby will be higher than merely the subset of rails alone, even if rails may take the bulk of the jobs offered.
\ is a special character in regular expressions, so you must escape it. Ironically the \ **is** the escape character for ruby regular expressions. So to match double backslashes you actually need "\\\\". Try [playing around on Rubular](https://rubular.com/r/0h4Hp8bQTk2r1a).
Use the block form of gsub, and all your troubles will go away. I.e., do this: ``` "Access \\My-Server\Scripts".gsub("\\"){ "\\5C" } ```
This does not solve the issue. The issue is, that in a ruby string, backslash is used as an escape character and therefore here it is only interpreted as one backslash. You can use `%Q(\\)` because %Q string literal does not require you to do escaping.
Ah, right. Regardless, if the OP wants to substitute backslashes out of a string, and doesn't want to have to deal with weird issues, he should use the block form. ``` puts "Access \\\\My-Server\Scripts".gsub("\\\\", "\\\\5C") Access \5CMy-ServerScripts ``` vs ``` puts "Access \\\\My-Server\Scripts".gsub("\\\\"){ "\\\\5C" } Access \\5CMy-ServerScripts ``` The tricky part isn't the escaping. The tricky part is telling gsub not to use the escaped characters as substitution instructions. That requires the block form, or a lot of frustration playing around with escaping. I suggest the block form.
post says rails
Whoops, sorry you are correct in that in some of those examples the memory foot print is smaller for Ruby 2.6 than PHP. However, there are also many where PHP still wins, and there are zero where Ruby wins in time execution (usually by an order or two of magnitude). So you have to consider a few things: Ruby may not have had time to kick in JIT, but also PHP releases 100% of memory after each request, whereas Ruby hangs on to it indefinitely. This functionally makes it much more of a memory hog than PHP in production. But I will give you that I was surprised to see Ruby win at all in some of the mem alloc benchmarks.
Php does not use it in those benchmarks but i thought you were arguing that php is only getting faster and my response to that is that php with hhvm is arguably already fast enough. Ruby might not release memory immediately but that might be to a large extent a strategy especially with JIT enabled. I have seen benchmarks for mri vs php vs python where mri was the one leas hungry. But all of those were not as recent as the one i posted so was not really sure if it is relevant for this discussion. 
 s = "Access \\\\My-Server\\Scripts" s.sub(/\\\\/, '##') #=&gt; "Access ##My-Server\\Scripts" 
If the backslash was properly escaped, they wouldn't have the inadvertent backreference. 
Looks like it's just a subclass of `Timeout::Error`, which you can get by requiring `'timeout'`: https://github.com/ruby/ruby/blob/trunk/lib/net/protocol.rb#L69
have you tried it without the `require`? if you're getting an uninitialized constant error without the `require`, it's likely that rescuing from `Net::OpenTimeout` there won't do anything - as any code that's raising that error would have to have that constant defined (and therefore available for you to use) in order to raise the error.
Yep. How else is your app going to know about it?
Instacart is hiring experienced Rubyists for remote positions, although we typically fly people out for a week a month or so. DM me. 
Do it master. Site looks good.
table\_print [https://github.com/arches/table\_print](https://github.com/arches/table_print/) solargraph [https://github.com/castwide/solargraph](https://github.com/castwide/solargraph) komponent [https://github.com/komposable/komponent](https://github.com/komposable/komponent) &amp;#x200B;
And funny too. That's always a plus, no? :) 
Normally yes - the reason goes something like this: "If we don't need the code at hand, then it is not necessary to let ruby load the code and thus become slower (the more and more code/lines are loaded; parsing the file takes time too)." There are some exceptions - for example, the useful debug-tool pp is required by default. In the past one had to use explicit require 'pp', which was annoying. The more common exceptions are available by default but for less frequently used ones, you normally have to pull it in via a require. Ruby's load/require system is not great, not very sophisticated (for example, one day I may suggest to the ruby core team to add a way to load files WITHOUT necessarily specifying hardcoded paths/names, based on identifiers), but on the bright side, the load/require system is SUPER SIMPLE. The syntax in ruby is unfortunately getting more and more complicated with the additions in the last 3 years :( but core mechanics such as require/load really stay simple. I once also suggested to add a one-liner to load+rescue, so that we don't have to use begin/rescue LoadError/end clauses. Not sure what happened to the suggestion.
That may depend on the exception at hand. For the one mentioned above, yes; but not for all exceptions, so the app may know other exceptions of course.
Strange name. Also ... that names reminds me of coreutils touch. Is the definition they use the one that is also true for touch? "we need to understand what touch method is. touch is used to update updated_at timestamp by default to current time. It also takes custom time or different columns as parameters." As far as I know touch can modify timestamps AND create files. But either way, that name is strange too.
A video would be great! I've messed around with it, and I just don't understand serverless at all.
I think the idea is that when you touch a file or a record, you changed it by touching it. It's useful because you don't need to know what attributes to change or how to edit the file, you just touch it. I've had little use for the unix command, but I had to touch records to activate database triggers, so being able to do that without a loop is nice.
See it like this. An object was last touched by someone. Now you touch it to look at it. It might not have changed anything, but you touched it last.
I googled the performance issue and it is caused most of the time by windows defender rescanning your "disk file" in windows on every change. Whitelisting this file gave me performance of a native running ubuntu, at least it feels to me this way. &amp;#x200B; Why would you need a vm for postgres? Just install it, you just have to start it manually and postgres throws some funny warnings. These warnings are announced to be fixed soon by postgres. And they are harmless. Redis for me works like i am used to. &amp;#x200B; I use atom on windows. I actually run rubocop from the bash inside wsl but you are right that this can be troublesome. Besides this, i have my projects in C:\\Users\\\[User\]\\Documents\\\[Project\] symlinked to my homefolder inside wsl and it that works pretty well so far. Although i dont use anything but token based autcomplete. &amp;#x200B; Actually my app is some parts api with native windows clients so the windows part is super important for me and i can live without linters and stuff.
Very usefull for besting caches reling on updated_at
PM me! We're a health tech company in Toronto looking to bring a senior Ruby dev on board, open to remote.
Do it Ivan! 😆 Thanks for the support!
Have you tried FaaStRuby Local? It comes with v0.5. I am in the process of updating the docs for it. I will make a post on /r/ruby here once I have better docs up.
I would love to have a write up on how to implement a basic app with faastruby
Hey guys, I wasn't sure what areas of the certification should be covered in a blog-post. Please, let me know if you think I've missed something
If the app depends on an exception, then the file is a dependency and should be required. Period.
&gt; Most of the pages on the official website are in Japanese &gt; and you can hardly find any resources on the web on how &gt; or why you should take it. This is a general problem. While there is quite a lot of documentation available in english, a lot of ruby feels as a "japanese first" approach. I can not say whether this is deliberate or not; may be coincidental due to how the japanese communicate (and english is not the strongest point of most of the japanese, although there are exceptions of course). But it definitely exists. Personally I find these "certificates" to be utterly useless. What does a certificate really mean? Ideally that you would have been able to pass some test. Ok. Does that mean much at all? Does it demonstrate that you can write and maintain a ruby project actively for a longer period of time? &gt; In real life, you won’t ever need to change constant (I mean, that &gt; what constant means, right?). See, that is already one source of confusion because constants in ruby CAN BE RE-DEFINED. And people don't understand that because they approach it from a "a constant means constant", such as the math constant PI yes? This also shows that people do not fully understand the ruby way. The orthogonal issue is the question as to whether you SHOULD be able to re-define a constant IF YOU WOULD LIKE TO. And this is where the ruby philosophy kicks in - ruby thinks if you know better than ruby THEN YOU CAN RE-DEFINE CONSTANTS. A warning will be issued and you can obviously check on the code that leads to this issue. There are similar examples. File.exist? versus File.exists? - the latter reads better in a sentence. But the former is the way how queries to an object are posed, via a message: - Object file xyz, do you exist? Hence why File.exist? exists. It is not a big issue because you can alias File.exist? to File.exists? anyway and use whatever you prefer. But people should first try to understand something before they go to want to disagree with. (Except when it comes to syntax, because some syntax, even in ruby, is really crappy.) &gt; I suggest you to take prep tests and if you find out that you &gt; scored 85-90%, you are all set and ready for the test. Frankly, no genuine person would want to suggest to anyone else to "randomly" take a test. So there must be a financial incentive behind the post. I have no problem with ad-lib advertisement; that is partially a reason for reddit too, but there is also a no-ad clause and this, IMO, is borderline advertisement. &gt; One more thing. If you conduct an interview and not really sure &gt; what questions to ask. Pick a few from the tests. They are good Not really. If I were to ask questions in an interview, I would ask for projects that have been taken and then demonstrate a few things there. (A few different projects that is). During that you can quickly establish whether someone knows something or not. 
Thank you for providing a serverless computing environment for the Ruby community. I followed FaaStruby's sample twice and found that it was very convenient. However, I do not know the merit of server-less yet. If you write about the benefits of server-less on your blog, you can inspire people like me who are not familiar with cloud computing. &amp;#x200B;
Could you try something like: def getOccurances(array) array.each do |element| element[:count] += 1 end array.each do |element| puts element end end (Haven't had the chance to run this, so can't guarantee it works.)
I am confident it's not deliberate, and English-lang documentation has gotten a lot better than it was ~8 years ago. Just a consequence of ruby originating in Japan and so much of the core team being Japanese. I guess it just gives us a taste of what it's like for most English-first projects for those who don't speak English well. In other news, I think it's really quite rude for you to suggest the author "must" not be a "genuine person" and have a hidden financial incentive to get others to take the test. They were pretty clear that they didn't think it would have much effect on your job prospects, at least in the U.S. They were just curious what was up with the test. I find that quite plausible. Certainly plausible enough that I wouldn't come out that suggesting they "must" be scamming us. I'm curious too, and appreciated hearing about it. Seriously buddy, you continue to be one of the rudest people on the subreddit, shevy-ruby.
&gt;Why would you need a vm for postgres? Just install it, you just have to start it manually and postgres throws some funny warnings. These warnings are announced to be fixed soon by postgres. And they are harmless. Redis for me works like i am used to. It did not used to work in WSL. WSL could previously not run daemons reliably. I'm guessing this has been fixed. &gt;I googled the performance issue and it is caused most of the time by windows defender rescanning your "disk file" in windows on every change. Whitelisting this file gave me performance of a native running ubuntu, at least it feels to me this way. My Ruby code is in Windows, not a WSL disk file, so that I can use RubyMine with it.
Hi, thanks for the feedback &gt;Frankly, no genuine person would want to suggest to anyone else to "randomly" take a test. So there must be a financial incentive behind the post. &gt; &gt;I have no problem with ad-lib advertisement; that is partially a reason for reddit too, but there is also a no-ad clause and this, IMO, is borderline advertisement. As I said I was motivated by Yegor Bugayenko's talk to look into ruby certification. I found amount of any feedback about it in English lacking. So I thought I'd raise a general awareness about it with the blog-post. To be honest, I didn't thought that it would be considered an advertisement. Maybe, I should update a post with disclaimer saying that I'm just sharing my feedback and not anyhow affiliated with Ruby Association ( /u/jrochkind ) &amp;#x200B; &gt;Personally I find these "certificates" to be utterly useless. What does a certificate really mean? Ideally that you would have been able to pass some test. Ok. Does that mean much at all? Does it demonstrate that you can write and maintain a ruby project actively for a longer period of time? As I said in the blogpost, I bared the skepticism as you, but test turned out to be pretty good and challanging. What it demonstrates is that you know ruby pretty well. And I don't think it's ought to do anything else besides that. &amp;#x200B; &gt;If I were to ask questions in an interview, I would ask for projects that have been taken and then demonstrate a few things there. (A few different projects that is). During that you can quickly establish whether someone knows something or not. Well, I've participated in dozens of interviews and lots of candidates doesn't have any *(or any meaningful)* OSS contributions and have NDA with their current employer that doesn't let them show any code from their work. Moreover, their pet projects doesn't really show how good their level of knowledge is. Ultimately, it comes down to general questions about ruby and patterns. What I suggested is, If you need to test depth of ruby knowledge questions from the test are really good.
Jamis Buck has an old blog post about this where he compares Java to Lego and Ruby to Play-Doh. http://weblog.jamisbuck.org/2008/11/9/legos-play-doh-and-programming
Your best bet is to drink what you consider to be a liberal amount of whiskey. That should put you in the proper frame of mind.
interesting, may check this out. 
You could try a website I build that indexes posts from Hacker News: [https://hnhiring.com/search?technologies=ruby&amp;locations=remote](https://hnhiring.com/search?technologies=ruby&amp;locations=remote)
I know we're not on /r/rails but this seems important enough to bring it up here too. Upgrade your apps!
We just posted a quick 5 minute demo that should be helpful in understanding how to build a simple app with functions using Faaastruby. Here you go! https://youtu.be/ZOlkeHVcoso
I tried applying but there aren't any test centers near me
and I just updated to 2.6.1 last week. 
Hi ``` my_array = [{:name =&gt; "blake"}, {:name =&gt; "blake"}, {:name =&gt; "ashley"}] my_array .map { |name:| name } # =&gt; ["blake", "blake", "ashley"] .group_by(&amp;:itself) # =&gt; {"blake"=&gt;["blake", "blake"], "ashley"=&gt;["ashley"]} .map { |k, v| { name: k, count: v.length } } # =&gt; [{:name=&gt;"blake", :count=&gt;2}, {:name=&gt;"ashley", :count=&gt;1}] ``` as an interesting side note, in 2.7 [tally](https://medium.com/@baweaver/ruby-2-7-enumerable-tally-a706a5fb11ea) is coming up. Unfortunately it's not there yet.
The benefit is you don't have to manage the server (or container) yourself. If you have a blank slate server and you want to run an app on it you have to install and configure: Ruby Certificate (encryption) Webserver (nginx, etc) Something to manage your deploys (capistrano) 
[ooooooo_q is on a rampage](https://blog.rubygems.org/2019/03/05/security-advisories-2019-03.html)
Java is a terrible language. Working with arrays and hashes in ruby is super simple. accessing: [number] for arrays for hashes I typically may query via .has_key? and then also use [key]. I think these are the most commonly use cases for me. For hashes I often use .update or merge (I can never remember which one updates i place). Also .delete. Java seems simple though, mega-verbose but not hard.
For Java this is good advice.
yeah.. its so verbose and I'm reminded again of how beautiful Ruby is
Arrays have a fixed length in Java, while dynamic length arrays are called lists. Yes, Java is verbose but it will make you a better programmer. You will understand many design decisions of Ruby much, much more and appreciate the convenient Ruby "magic"
ah so basically a "list" in Java is a plain old array in Ruby? and an "Array" in Java is something fixed, which I guess we could do in ruby with `arr.freeze` perhaps? (I don't use `.freeze` much in Ruby that I have done). &gt; Yes, Java is verbose but it will make you a better programmer. this is very good to hear, hence I gotta study more. am on /r/learnjava and using their Helsinki MOOC recommendation so far. Just have all kinds of things to learn but gotta finish things is key. I already appreciate the "syntactical sugar" of Ruby. one guy today was telling me how he was struggling to answer some interview question in Java and lickety-split it was super simple in Ruby.
Given you don't care about callbacks, or validations for that matter: `User.update_all(updated_at: Time.zone.now)`
This update is trivial - very unlikely to cause you any trouble updating.
Thanks for the demo and details!
neat
I was under the impression that `where().first` was now preferred over `find_by` and the like. Is this something that's intended to be widely used, or just to avoid inconsistency in the library given that `find_by` isn't going anywhere?
If it helps with readability and feels suitable to you then have at it and use it, otherwise feel free to stick with where().destroy_all. I still use and prefer `find_by` (and other syntactic sugar helpers) over `where().first` :).
wow really? I mean, I had no idea but that's interesting , its a lot lower than I would expect . Good o'l one liners ... seems to be really popular among Ruby programmers.
Appreciate all the hard work and dependencies your forefathers brought.
If I were to guess you have some custom build settings for nokogiri set in bundler, probably the `--use-system-libraries` option. Run `bundle config` to check. When you run `gem install nokogiri -v '1.10.1' --source 'https://rubygems.org/'` it's using the libxml2 included with nokogiri instead of looking for a system provided version with pkg-config. 
&gt; If I were to guess you have some custom build settings for nokogiri set in bundler, probably the `--use-system-libraries` option. Bam, you are a mathematical genius. In addition to not having `libxslt-dev` installed, I needed the following flag (per [this blog post](https://7in4tranlh.wordpress.com/2016/10/26/trouble-of-nokogiri-gem-installing/)): --with-xml2-include=/usr/include/libxml2 So while we're on the subject, is there any advantage to installing with system libraries versus included libraries?
The error message is pretty crappy since, as you wrote, pkg-config exists. But the other part of the message says that libxml2 can not be found; most likely not everything is installed. Debian is famous for crippling packages by default, meaning that you have to uncripple them. This is why I use an AppDir approach, similar to the one in GoboLinux. When compiled from source, all of libxml2's components go into a versioned directory; from that point on, some ruby scripts will automatically symlink (or I call a ruby script from the commandline that does so). 
libxslt is part of http://xmlsoft.org/sources/libxslt-1.1.33.tar.gz though, not libxml. It's always hugely annoying to have to find out how debian crippled packages. 
&gt; So while we're on the subject, is there any advantage to installing &gt; with system libraries versus included libraries? You have to ask the debian team as to why they are crippling programs by default. Their usual fake arguments goes like so "bla bla bla bla bla bla" and then "bla bla bla - most people won't need header .h files on server systems bla bla bla". The problem with this is that it is bogus, because THERE IS NO SIMPLE WAY FOR YOU TO TELL DEBIAN TO STOP CRIPPLING STUFF YOU apt-get / aptitude install. Additionally you could use an AppDir approach but debian does not allow you to do so either. I switched to compile from source many years ago via versioned AppDirs. While this indeed takes time, I don't have to depend on random upstream developers and maintainers dictating their world view onto me (like debian did when they forced everyone to use shitd aka systemd; devuan became the real debian since that day). By the way, having to define --with-xml2-include=/usr/include/libxml2 sounds like a bug to me. It also seems to be an incorrect path - the C headers are referring to libxml/xmlversion.h and so forth and NOT to libxml2/libxml/xmlversion.h. You can compare this if you compile libxml2 into some directory and have a look. I guess the path you have is something like /usr/include/libxml2/libxml/*.h right? 
What "hard work"? The LFS/BLFS team is essentially doing what the debian team is doing, except that they don't cripple stuff by default, forcing the end user to work around the limitations of debian.
Rubocop suggests find_by() over where().first by default. https://www.rubydoc.info/gems/rubocop/RuboCop/Cop/Rails/FindBy It also suggests find_by(arg:) over the dynamic find_by_arg: https://www.rubydoc.info/gems/rubocop/RuboCop/Cop/Rails/DynamicFindBy 
&gt; So while we're on the subject, is there any advantage to installing with system libraries versus included libraries? There are edge case situations where using system libs is useful but in general you're better off using the libs included in nokogiri. Unfortunately nokogiri has been around a long time and libxml2 has been a PITA for a long time so the web is littered with examples telling people to use `--use-system-libraries` for no good reason. 
Once you've learned the Java syntax, I recommend focusing on Design Patterns. There is a book "Head First Design Patterns" which helps a lot.
Because you're using Ruby.
I haven’t used it in production yet, but did some research on a similar move away from SQS recently and the option I liked best was to use Apache Kafka via the Karafka gem. Liberates you from the AWS platform and Kafka is really interesting and powerful.
We considered using Kafka a few months ago, but we really realized that the piece of SQS was fulfilling the function (stacking a series of tasks in FIFO). &amp;#x200B; Actually, the problem is found in the management and processing of the tasks in the queue :(
We're running Shoryken in ECS containers and didn't have any issues with it (2 years almost). That said, have you considered just using Lambda? I want to give that a go when I have some free time. 
Are you thinking of find_by_x(y) ?
oh cool, ty!
Kafka seems like an overkill if you just want a dumb message delivery pipeline.
According to me its laravel or angularjs development will be the future for web development. 
I think `use-system-libraries` used to be a LOT faster. It might still be? But I think everyone decided any extra trouble wasn't worth it. 
I like these methods, but I don't like the name. `find_by` finds one, and `delete_by`, `destroy_by` delete all of them. That's going to be a surprising experience.
Have you looked at Rails Application Templates? https://guides.rubyonrails.org/rails_application_templates.html
A good example why many of these methods won't make it into ruby core. They are way too specialized and domain-specific.
I haven't but it is only for scaffolding Rails applications, right? `create-ruby-app` is specifically for non-Rails projects (for instance, a Sinatra app or non-web app for that matter). The `bundle gem` command is similar in some ways but, in my opinion, it is too gem-centric and includes files, e.g., .travis.yml, .rspec, bin/console etc., that many people may not need.
Ah, I see! Right on. 
This is quite awesome!
And I wonder when it will be patch for real!
It really should be something like `delete_where`
Really interesting read
Strong contender for /r/ruby Blog Post of the Year. The more I learn, the more it seems that glibc internals are a nightmare. 
Ruby's Array should not be thought of as "plan-old" anything. An array, as a data structure, is a sequential set of locations in memory. Ruby wraps that up with a ton of magic and functionality into it's Array, where as Java implements an Array as the classic data structure. And it shoudl be noted its a primitive, not a class. Int[] numbers = [1, 2, 3, 4] Defines an Array of Ints and declares a variable, numbers, pointing to it.
&gt; And it should be noted its a primitive, not a class. meaning in Java, an array is a "primitive"? I still haven't quite gotten to differentiating what is a primitive and what is not, in Java, if so. thank you. 
Not quite sure I agree, the '_by' isn't the important part of the name in terms of one or many, it just suggests by a given argument. It is the 'find' that tells me that only one will come back, consistent with the find method. So things like destroy_by make sense I think: identify by an attribute and destroy them.
Thanks for pointing it out, though! I should probably add a note about it in the README.
I can't think of a reason that would be the case. By default the nokogiri install just downloads the source code based on this file: https://github.com/sparklemotion/nokogiri/blob/master/dependencies.yml then applies a couple patches: https://github.com/sparklemotion/nokogiri/tree/master/patches It should perform the same as a system libxml2 assuming the same compiler optimization level is used. 
What a post! You should submit a talk to rubyconf for this
Its been years, sigh... decade+, since I've done Java, so don't take me as an expert. But unlike Ruby, where everything is an object, this is not true in Java. If you don't explicitly create an object by calling new, its probably not an object.
I sorta wrote something similar combining two mini-gems; one is an "input sanitizer" that will e. g. change input such as "wikipedia" into the link to wikipedia directly (without using any search engine); and the other gem is one that opens in the browser (predominantly palemoon for me). I don't really know of other gems that do so and my own gems are really just mega-ugly hacks, but the functionality is quite simple to write by yourself really. If you can tap into a local program then you can always use system() or `` from within ruby itself. I don't have experience with Mac, only linux, and on linux getting things like that is quite easy - one could even use xdo or xdotool or whatever the name was, and xev for copy/pasting the xorg buffer. It requires a bit of googling perhaps and manually stitching things together - hence the hackish nature. But it works very well. For example, in KDE Konsole, when I type "copp", this stands for "compile_opportunities" and it opens some remote websites in my browser for me to look for new updates to source archives (I use ruby to compile everything from source). Or when I type "rall" or "ruby_all" on the commandline, hit enter, then it opens several ruby-related sites, including the bug tracker, matz twitter and also ruby reddit here. I do this for many many different topics really. Every time I seem to be visiting some websites more than once, I slap some name to it and store it into one giant case/when structure (this is probably the biggest case/when structure that anyone has ever written manually).
I’m such a newbie idk if this really applies to me or not. The specific error I’m getting is “unable to find browser command”, and I think it’s maybe because I’m using IDEs with built in terminals? Thank you anyway! 
yeah I'm used to all being an object in Ruby (except of course reserved/keywords correct?). &gt; If you don't explicitly create an object by calling new, its probably not an object. Ah, that is a nuanced difference. Java seems so verbose so far.
It's possible it used to be true but no longer is? I'm having trouble finding confirmation googling, but I distinctly recall everyone was doing that for a while because otherwise it could take several minutes to install nokogiri, and was significantly faster to use system libraries. But part of what I'm discovering/remembering is that nokogiri seems to have changed it's approach to how it links to libxml/libxslt several times over it's lifespan, in major ways. I remember at one point they changed how nokogiri install worked which is what _made it slower_, then the system libraries thing was what people did to try to make it fast again... then after that they may have changed it again? Or maybe "slow" just became the new normal. Here's [one ticket](https://github.com/sparklemotion/nokogiri/issues/1220) where a nokogiri maintainer was suggesting using system libraries by _default_ (I don't think that ever happened), and I have a comment saying one nice thing about that would be faster install times. :)
Except for the hooking into the GC you can probably do this from a gem, I will play with it tomorrow at work to see if it can somewhat reduce memory usage of some of our containers.
Ah, you mean the install is faster. I thought you meant nokogiri's performance was faster. Yea the install will be faster with system libs since it doesn't have to compile them during the install. 
yeah, the install. Def not the runtime perf. 
Yep, verbose is what it is. There is explicit static typing as well, you probably realized that immediately though. Also, java can thread really well. No GIL in sight.
yeah I have yet to learn about threading. is there such a thing in Ruby? 
It will definitely be interesting to see if the performance claims holds water. 
My research results indicate that trimming is only effective right after a GC.
I saw your stackoverflow post too :) It might be an issue of PATH, possibly because of how your shell is set up (`bashrc` or `bash_profile`) it's being loaded from shell and not the IDE. This is just a hunch though. Try comparing `echo $PATH` when run from the IDE vs from terminal.
Perhaps you are confusing the AR generated methods for each db column? E.g., \`find\_by\_some\_attribute\`.
Rails 6. The future is here! Just kidding, there doesn't seem to be any big changes there.
Lol yea I’m looking everywhere, really want this to work. I’ll try that as soon as I get back to a computer! 
Whoa! Finally, the "rails way" will no longer be N+1 creates/updates. This will definitely improve the performance of future rails apps. Of course it has been possible to do this for a while (I use the `activerecord-import` gem) most people just overlook it because it's not in rails core.
Yes, and it looks as if Ruby is not the only affected: [http://notes.secretsauce.net/notes/2016/04/08\_glibc-malloc-inefficiency.html](http://notes.secretsauce.net/notes/2016/04/08_glibc-malloc-inefficiency.html) . Includes a script that use gdb that applies it to a running process. 
It would be very interesting to know if the performance improvement also holds for the Ruby 3x3 benchmarks like the emulator. The Ruby team notoriously rejects patches that improve server performance but hurt general performance. That this does well on Rails might be a quirk of the application. Maybe we're in the market for another REE.
This is really wild. I figured optimizations of this scale would've been done long ago
It is, but I'm not able to reproduce it, so \*shrug\*.
They're totally different. How do I address this?
Did you ever figure out the issue with rails console? I'm just running into this as well. pry/irb work just fine for me outside of rails.
As the patch only seems to be run trim on full GC, it looks like the cost could be quite negligible. 
Aren't there alternatives to glibc that things like Alpine Linux are based on that Ruby could be compiled against? I guess I could give it a shot. 
Might the workers benefit from being written in crystal or another more perform any logic? Ruby is awesome for business logic, not so much for computationally heavy stuff.
You haven't described the failure mode(s) so . "it has been degrading the performance" tells us nothing, I'm afraid. We're even having to assume you're running workers on EC2 from the reference to autoscaling. Very high CPU usage? Doing what _exactly_? Is it throwing failed requests back into the queue? What's the duration, frequency, request pattern of the work? What's the memory consumption? The queue depth? The external service has "variable availability" - how does it fail - rejecting requests, ignoring requests, hanging, taking longer. Every suggestion anyone gives you will be a wild guess because all we have to go on is "I'm using Shoryuken". 
It's a mistake to conflate message queues with job queues. At the margins of behaviour their differences are amplified. You've implied the problem is caused by a failing external service. A service mesh is an internal pattern and won't help you coordinate external services. A FaaS like Lambda would likely worsen the availability symptoms. You probably need a circuit breaker, an exception pile, and a backoff mechanism. 
OP: Why does a problem common to Mac OS and Linux exist? You: Debian did Mac OS.
Heh... my story too. I'm waiting for a chance to play with [Nerves](https://github.com/nerves-project) and doing some automation around the house. But getting time to play, that's always the problem.
Yes, I'm not an expert, but my understanding is this is all just typical behaviour for most \`malloc\` implementations, e.g. see the redis docs on memory allocation - [https://redis.io/topics/memory-optimization](https://redis.io/topics/memory-optimization) note about RSS. 
Yeah, certainly. It just has limitations. You use it when you have a lot of blocking IO in Ruby. With Java you can do all sorts of things parallelized across threads.
Any multithreaded program using glibc malloc is affected.
interesting, thank you
[If you get curious](https://ruby-doc.org/core-2.5.0/Thread.html)
oh sweet, thank you, yeah may check that out. I don't recall having run into it in my Ruby training, but then again, I've had to study in Java lately and do other things.
It's not in Ruby's strengths, I can only think of a handful of times we eve rused it. And when we did use threading more, we wsitch to jRuby, which uses the JVM and can use it's threading model rather than MRI Ruby's.
ahh, interesting, ok thank you for that explanation.
Can you tell us how you determine which are "most popular"/"trending"?
advertorial for a recruitment company
You are right. I was aware that it's advertorial, but still thought it was helpful. Note that I'm not related in any way to that company. Just stumble upon that report 🤷‍♂️
Just curious, what center have you taken the test at? 
Affected, yes. But not necessarily d
Seriously though, Ruby's memory consumption is close it, if not the top issue for the language. Hopefully this is as promising as it appears on the surface. It could be a game changer.
From the site: &gt; This release includes a bug fix for the deadlock in the multi-thread+multi-process (using Process.fork) applications (ex: puma).
Updating my project's base Docker image as I am typing :)
Doesn't that indicate an allocation problem somewhere? As in trimming should be *the most* effective after gc, but decline linearly at first, since allocations should be mostly concentrated to the half full 'OS pages'. If efficiency drops sharply, it'd seem to me that the allocations happen randomly in any available OS pages, disregarding the idea that we might want to return some of them. 
This beautifully shows that most news related to ruby is about ... Ruby on Rails. And this is bad. Unfortunately I have no list of non-ruby-on-rails related repositories myself, which only exacerbates this ... :(
I think there was a bug report where someone specifically asked for a fast bug fix release. And it happened! \o/
&gt; Only 17% of engineers surveyed believe a decline in popularity, &gt; or development of better languages, would be a viable threat to &gt; Ruby on Rails. Ruby has lost some momentum BUT ... "development of better languages".... WHICH ONES??? And I really mean this quite objectively. JAVASCRIPT? Really? Anyone suggesting it as a "better" language? JavaScript's popularity is due to the browser + www becoming the single most important catalyst (and now essentially under Google's control due to adChromium's world dominance). &gt; A third of engineers believe that addressing Ruby's current &gt; weaknesses will be instrumental to its wider adoption. Ok WHAT wearkness exactly? And I mean SPECIFICALLY? Everyone seems to have a crystal ball. I don't think the loss of momentum has much to do with intrinsic changes to ruby, even though I myself dislike many syntax decisions made in the last 3 years (but I can avoid them, so ... I just never want to have to explain to anyone how certain syntax choices work, since they are so butt ugly that nobody sane in mind should use it). I just really really would like to know WHICH EXACTLY is the "better" language here. Popularity is hardly a deciding factor. PHP is still more widely used than ruby, for example, but it was designed by clowns and this shows in its spaghetti-mess approach (and erb/erubis copying the same crap - people need to understand that spaghetti templates are just a terrible idea in general). &gt; Top 4 Languages to learn to stay relevant in 2019 Yeah sure ... *rolleyes* &gt; There were 4 clear winners with Node.js topping the table &gt; for top language to learn in 2019. WAIT a moment ... Node.js is now its own language??? &gt; From a recruitment perspective, the desire to learn Node.js, &gt; Go, Python and Elixir matches the demands of our client &gt; base - these skills, along with Ruby, are in high and constant &gt; demand. Yeah yeah yeah in short LEARN EVERYTHING USE EVERYTHING. People have infinite time! And they all instantly write perfect idiomatic code whenever they insta-learn a new language, too! Obviously...
I am not quite sure how it is "helpful"? The statements they make are bland, generic, head-scratching and ... really. I am not sure how this is useful to anything or for anyone. The StackOverflow queries are much better than this joke. You may not be related but you still had enough energy to link in this low quality article so ... :P
Moar method bloat
https://github.com/puma/puma/issues/1744
Hi 
I looked at the commit logs out of curiosity, and it's literally a one-line addition. It's so insane how one omission has such far-reaching consequences.
I've never used rails and would love to hear your favourite list. 
"could be a game changer": Don't think it would matter much actually, but of course it's a nice to have. Companies that avoid ruby either want an enterprisey stack like java or some shiney new tech like Go/Nodejs. Improved Ruby won't change that. &amp;#x200B;
Let’s hope they’ll do [this one](https://reddit.com/r/ruby/comments/b1071z/what_causes_ruby_memory_bloat/) next.
Honestly man, I’d just use Shopify, especially if your budget is low. The money you spend on their service will be exponentially less than the cost of supporting spree or another self hosted framework. 
I dun know man, glibc malloc has issues with pretty much every multi-threaded app which does a lot of periodic allocations, e.g. anything doing web request handling. Java users have been switching to jemalloc for years due to this. 
Since their all of the sudden releasing new versions almost every day, what's the probability it could be done by next week? I have a project I expect to be done by the end of next week and Im using 2.5.3. If there's a fix before next Friday, I can fit it in. Otherwise the project will be locked to either 2.5.3 or 2.5.5 for years. 
Thanks, but i don't think that's an option.
That has not answered the question, though.
Hi! I'm on the Solidus core team. In my opinion, you should use Shopify unless you really want to build something custom. If you want to build something pretty unique, or need extra control, Solidus/Spree are fine options. Personally, I am biased, but I recommend Solidus. That's because there is a lot of funding behind Solidus and there are more companies actively contributing. People have strong opinions about the two projects so I'll leave it at that. It's also important in my opinion to note that Spree was left derelict for a long time before being reclaimed by the current maintainers. Most of the original Spree developers moved to the Solidus project during that period.
Thank you. It should be custom, but because of the limitations I pointed, we can't afford to invest in building everything from scratch, so we need a base that we can customise. Maybe i should have been more clear in my OP. 
The truth is that if we use Lambdas we remove many problems (we avoid excess memory, we control the accesses better and we continue with the uncoupled back of these heavy tasks) &amp;#x200B; I'm going to get volumetric data to see the cost. It's a great idea. Thank you :)
So many primitively-obsessed do-my-homework-for-me questions in this sub lately.
I just want some help? 
The downside of Lambda, out of many, is that you can't really rely on your Rails app and any business logic that cannot be extracted to a gem is unusable. That said, you _can_ use gems now if I understood it correctly. 
Game_hash each &lt;- You missed a .
The challenge here is to delegate the minimum in the Lambda. In this particular case, Shoryuken is only used to access external services (Through HTTP requests), therefore in the Lambda will be responsible for making such requests acting as an intermediary.
Then it should be ideal, at least from this point of view.
There are dozens of issues on the Java, python, and malloc bug trackers over the last decade on these topics, all exhibiting the same memory growth and behavior.
My bad, Ive fixed that, also a couple of other issues I saw on the code but now I get no output?
I'm currently using Solidus on my store. I've used woocommerce before but wanted to move away from wordpress. I came to my decision based on what others here have said more development is being put into solidus. Just know its not quite as turnkey as using shopify or woocommerce but you can get up and running pretty quick with little customization.
If you don't know how either works, it seems pretty bold to dash into Solidus or Spree under resource constraints. Professional development decisions should be driven by experience - not hope. You should do exploration projects in either Spree or Solidus (or both) and know the implementation scope of your requirements before providing anything resembling a budget to your customer/employer. Don't make promises you can't keep.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/codinghelp] [How do I select the largest key: value pair in a nested hash?](https://www.reddit.com/r/CodingHelp/comments/b1fs2a/how_do_i_select_the_largest_key_value_pair_in_a/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I wouldn't be so sure about that. The amount of people I hear in the industry, poking fun at Ruby's memory bloat problem. Isn't something I'd say is insignificant.
I think Solidus is a great option if you're looking to have a lot more control over your store, but if you're just building something to sell widgets online Shopify is the cheapest answer. If you're successful enough, you'll outgrow Shopify and that's when things like Solidus make sense imo.
This is why i'm asking for opinion on both. I'll have to remove the part about the budget and time, because apparently it drives the attention away from the point of this post. It was only explanation on why i'm looking at using one of the frameworks as a possible solution.
[https://github.com/markets/awesome-ruby](https://github.com/markets/awesome-ruby) is a pretty good list, not specifically non-rails related but a lot of the gems on there are not targeted at Rails. 
&gt; if player_data == [:shoe_size].max This isn't what you want. The [] would be applied to the program as a whole as far as I can tell, and conceptually it isn't what you want. I would break it up like this: 1. Write a method to get the [player_number, shoe_size] with the maximum shoe size for a team (probably use max_by on the player_numbers). 2. Compare the home vs. away maximum shoe size to see which one you should dig into to get the rebounds with team[team][:players][player_number][:rebounds]
Think in transformations, not in "how do I write a lookup and comparison all in one" ``` # 1. Unify the data all_player_data = game_hash[:home][:players] + game_hash[:away][:players] # 2. Extract the data you want all_shoe_sizes_and_rebounds = all_player_data.map { |_id, player_data| [player_data[:shoe_size], player_data[:rebounds]] } # 3. Filter the data max_shoe_size_and_rebounds = all_shoe_sizes_and_rebounds.max_by(&amp;:first) # Extract what you want max_shoe_size_and_rebounds[1] ```
Thank you! Hopefully it has enough detail to be helpful.... I wasn't sure if I was glossing over too much or not.
How about simply renaming it to "most popular ruby repositories"? I wouldn't call Bundler a rails library so that actually seems more accurate to me.
[removed]
I hear you, and I don't want to seem dismissive, but thats what professors/TAs/teachers are for. Go to office hours, asking strangers should be a last resort.
I'm learning how to code by myself, if I could ask teachers I would lol
Well, thats totally fair then, my apologies for assuming otherwise. Your question reads like you copied and pasted a homework assignment in, but I suppose thats what programming challenges read like as well.
Well do be fair, it is an exercise I found online but it's alright, you didn't know 
&gt; when I run this method, there is no output, i'm confused why this is the case? There are no puts statements in the code that I see. Your logic is just running and completing.
Even if i include puts statement, it gives no output. So I'm really confused
JSON stands for JavaScript Object Notation. The useful/actionable piece of data in that is that it is specifying objects. What I would do is create player, team, and game classes, and deserialize this data into actual objects that reference one another. This will make it much simpler to work with the data and to do operations on the objects. 
Once I get some shit done here, i'll take a crack at your issues. What are you using to edit and run the code? Are you familiar with [pry](https://github.com/pry/pry)?
Thanks man I appreciate it. I'm using Repl.it to edit the code, sometimes Sublime Text. Yeah I'm familiar with it but I'm not sure how to use it
People already provided answers below, so I will skip the answer-part. I should, however had, like to recommend to, ideally, keep all data structures as simple as possible at all times. For deeply nested hashes it may often be better to try to flatten them downwards. If your initial data structures are: (1) correct (2) simple Then it makes a lot of the following code written in any language a lot simpler as well, usually.
Even if this were the case, there was no help involved, so it was a waste of time by you and riddley too. In general it is best to assume nothing and either try to help answering; and if you can not or do not want to, that is fine too. But just making a random comment about something assumed is just wasting everyone's time.
no, I moved on and just decided to go without vim bindings in these contexts look into any inputrc settings you have (~/.inputrc) and/or your INPUTRC environment variable. maybe try `INPUTRC=/dev/null rails c` 
Do you have a latest version that addresses things others have said? if player_data == [:shoe_size].max Does not do what you want, for instance. In fact it does nothing. [:shoe_size] returns [:shoe_size] [:shoe_size].max returns :shoe_size
Everything there on the post is the most up to date one
I think this is a great suggestion. Maybe mention it to the team?
And yet because we had this discussion, i'm going to put in more help than i would have otherwise. So, while it may be a waste to you, it was helpful to me.
Semantic Logger, hummmm going to check that out. I use [Logging](https://github.com/TwP/logging) a lot and am not happy with its Rails integration. This looks comparable, yet possibly better... 
I asked the author, and the article has been updated with your comment. Thank you!
Well
 User.update_all Why call .all?
This is a flatiron assignment, yes? You should be able to look at all the solution files and pull requests in GitHub if/when you get stuck. 
I've been using Roda for my side project and definitely loving it. It's easy to write and great for small applications and does scale well. I think it's a good alternative to micro applications and services.
Been working on this gem and running in prod for a few months. Note: it's not dependent on Hanami just hanami-events https://github.com/adHawk/hanami-events-cloud_pubsub
Using `jemalloc` (3.6) or setting `MALLOC_ARENA_MAX=2` **now** avoids most of the memory bloat which are primarily due to the Linux glibc memory allocator. I think we will get both, 3x performance AND much less memory bloat (once a patch lands). Ruby is getting better.
Because of a typo is why
Doesn’t make sense at all !
Memory bloat and leakage is not a unique Ruby thing, [https://serverfault.com/questions/109362/is-it-a-best-industry-practice-to-restart-web-servers-periodically](https://serverfault.com/questions/109362/is-it-a-best-industry-practice-to-restart-web-servers-periodically) . If you think that question is too old only a few months ago I understood we have a memory bloat/leak in a very simple scala app in our company. Here's one with php [https://stackoverflow.com/questions/27206663/how-to-force-php-to-release-memory-after-script-is-finished](https://stackoverflow.com/questions/27206663/how-to-force-php-to-release-memory-after-script-is-finished) I'm all for this change, of course, I just don't think it's a unique to Ruby problem, and also don't expect people to flock to Ruby once and if it's solved. But overall it could be a great change that will save developers and companies a lot of hassle, time and money.
It was already suggested and rejected by DHH because he said "it didn't bother me when I tried it", ignoring all of the feedback from other people, like he does.
Looks like you onboarded rails on 1.2.3 like me. ;) But on the contrary to you I really like all in one solution so I keep all feature as in. Action Text is really their only to attract people from WP, without it enabled by default WP people would stay in their old PHP world.
I don't know anything about Windows, but you certainly have Ruby installed if `$ ruby -v` gives you `ruby 2.5.3p105 (2018-10-18 revision 65156) [x64-mingw32]`. How are you trying to run the program? Something like `$ ruby ./hello_world.rb`? I suspect the issue is with the IDE.
I have a similar set up and while there are ways to do what you are doing inside of windows. It was MUCH easier for me to install Ununtu on my machine to use for these things. Ubuntu is a very user friendly version of Linux. Since it's Unix based unlike windows, you will have a much easier time doing these things. Look up, dual booting Ubuntu with Windows. I'm no expert but it seems like windows sucks for building a good develepor environment and I was going in circles like you before I discovered Ubuntu. 
With `has_secure_password` \+ `authenticate` (see [https://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html](https://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html) ) we already have some kind of authentication inside. Plus in my opinion ActionText is there to attract people from WP . Staying true to its core value is really nice but ... sometimes the cost is to loose "casual" developper. That is probably why to attract them, more gems are going to the coreby default . I think it is a (desesperate?) move from DHH to try to get people coming to rails, and get rails to compete with js (with rails 5's webpack) as well as WordPress.(with actiontext)
Or just download VirtualBox and install Ubuntu in a virtual machine in Windows.
I don't see any problems with ruby, that error is complained by Atom. I use vs code, and I installed ruby both on my machine and bash on windows. They both work like a charm. I prefer wsl. If you do want to re-install ruby, Just install scoop and run `scoop install ruby`, no need to give a shit, everything will be setup for you. 
Brew install Ruby-build Brew install Rbenv rbenv install 2.6.2 Rbenv global 2.6.2 
Windows is quite annoying - if you can, try to switch to linux one day. I have my ruby versions under /Programs/Ruby/VERSION_HERE e. g. /Programs/Ruby/2.6.2/. This is very similar to the GoboLinux approach. To your specific question - I tend to use the ruby one click installer if I have to use windows. It works very well from my experience. Another option may be to use WSL - then you can, sort of, use Linux; and installing ruby on linux is really really simple. https://cache.ruby-lang.org/pub/ruby/2.6/ruby-2.6.2.tar.gz To run ruby on windows, you also invoke it from the commandline e. g. via ruby.exe foo.rb or something like that. I tend to use cmder on windows since the commandline is so terrible: https://cmder.net/ In general windows is VERY annoying. You have to un-annoy it so that you can work productively. You can also use notepad actually for such simple tasks since you only try to get ruby to work.
Give reading a try before posting. He clearly says he's on Windows.
This might help https://www.digitalocean.com/community/tutorials/how-to-install-ruby-and-set-up-a-local-programming-environment-on-windows-10
You don't even have to do this if you have Windows 10, you can just use Windows Subsystem for Linux.
Also, fuck Brew 🙃 MacPorts over it any day 
While you're technically correct, your petulance is unbearable. 
maybe you can try with this guide that i wrote for rails girls: [https://lucas-aragno.github.io/railsgirlsguide](https://lucas-aragno.github.io/railsgirlsguide) its been a year but it worked for the girls' computers
That's nice.
Hi guys, &amp;#x200B; Here's the latest project I'm working on. It's a complete Rails-like framework that makes building and running Kubernetes clusters feel more like software engineering. &amp;#x200B; I'll be posting the repo so you can pull and play before summer. Let me know your thoughts, and if there’s any other ideas you have for the project. &amp;#x200B; Thanks! &amp;#x200B; Xavier
Niiiice. Does it just transpile to YAML? 
\`\`\` my\_array.group\_by(&amp;:itself).inject({}) { |new\_hash, (k,v)| new\_hash\[k\] = v.size; new\_hash } \`\`\`
 my\_array.group\_by(&amp;:itself).transform\_values(&amp;:size)
The price seems to have increased to US$150 (maybe it varies per location, I checked Toronto and NYC).
It looks interesting but I have a difficult time understanding what this is (beyond obviously outputting Kubernetes YAML with a different syntax) and what problems this solves. It would be great if you can publish more documentation or comparison documents because as the website is I have no idea whether I should continue to be interested or not.
I recommend this video https://youtu.be/1UYBAn69Qrk
\+1 I'm not even into web scrapping, but I started watching out of curiosity and it was well worth of my time.
Relax... 
this is fantastic
There's a typo in the second-last header. It is now `## Conclusio`
What did you use to help you learn from the koans?
Practically, I had emacs as my editor and I would run the koans in terminal. As far as learning, I went through the koans as the tests showed me: when a test failed it would tell me which one and I would go in, edit it, save, and then rerun the koans. The feedback loop helped me; it's my favorite way of learning.
nice but it wasn't obvious to me what summarizing data means. I had to look up [wikipedia](https://en.wikipedia.org/wiki/Merkle_tree) to understand what this is about. I suggest expanding on the introduction on your README.md, at least mentioning not trusted data verification, p2p download etc. Seeing a binary tree I immediately thought of search trees.
Are there any obvious advantages when compared to https://github.com/tj/terminal-table ?
As far as I'm aware, several of the [features](https://github.com/matt-harvey/tabulo#features) of Tabulo are not found in many or most other terminal table libraries, including terminal-table (for at least some of these features). In particular: * The initialization interface is structured around building up the table column-by-column, rather than row-by-row. I think this makes for DRYer initialization code, since the ordering of the columns is expressed only once, rather than being duplicated within each row (and, in particular, between the header row and the body rows). * You can "shrinkwrap" the table so that it automatically sizes each column, but stops at a certain overall maximum width (which you usually want to be the width of your terminal). I have found this really handy when outputting certain data sets that would otherwise become unreadable in virtue of wrapping around the terminal. * You can the repeat the header row every N rows (handy when outputting a very large table). * A Tabulo::Table is an Enumerable object, so you can make an enumerator for it and then step through it "lazily" a row at a time. This can be useful when tabulating large, open-ended data sets such as some ActiveRecord queries, where you don't want to load the entire underlying collection up front. There are some other nice features as well; and there are also some features Tabulo lacks compared to some other gems (such as the ability to add a title at the top); but I thought the overall approach and overall feature set was distinctive enough from the other terminal table generators out there that it was worth publishing a new gem.
Glad you like it :)
Sorry I can't find the type (I don't see it). Do you mean conclusio? That's latin for conclusion (and I assume on purpose). 
Do you plan on doing active development? Terminal tables are big part of my daily workflow. I have several issues with my current solutions, but none of them are sever enough to start my own thing. But I would gladly check out if your gem solves any of them, and create some Issues. ;-)
Fantastic to see another merkle tree library. See merkletree &lt;https://github.com/openblockchains/merkletree.rb&gt; for my humble alternate library that lets you grow money on trees.
I plan on maintaining it, yes, and I am open to considering new features. I can't promise any particular pace of development though. PRs are of course welcome, as well as Issues ;)
Great point! I do care about documentation and want it to be clear. Would you have time to send PR with improvements? Your experience will defo help make the docs better!
Really nice conversation! ... Thanks =)
*Today I Learnt!* You could've opted for `conclusió` to avoid the confusion.
Did you know programming before? How did you know what to fix in Ruby? 
I still don't really have any clue as to what this all is about, be it containers, kubernetes, microframeworks and so forth. Great that more is written in ruby but ... if I don't grasp what something is all about, it is of very limited use to me.
Ah! I *just* wrote something that is almost the same above - I swear I did not see your comment before; only saw it right now as I was scrolling down. And I completely agree with you! Actually, I am a slow learner in general, but I am glad to see that I am not the only one who is not completely sure what this is all about ... not just in regards to kubernetes, but the whole part all around kubernets and co, including "containers". Every time I have been reading about it so far, I have wondered "why would I need it". I don't have any problem installing anything here on my linux box anymore really - everything that can be compiled, will be compiled, and a versioned AppDir approach ensures that I can use multiple versions of any program side by side if I want it too. Possibly I may be missing something ...
On a side note - there is a LOT of information density in the API. Ruby is nice for DSLs but ... DSLs that are very complex, are not good, in my opinion. Rails has a similar problem - it's not very light on the mind. class APIRouter &lt; Nectar::LoadBalancer open to: Dashboard, at: '/api' do routes path: '/v1', to: LegacyAPI routes path: '*', to: MasterAPI end end It condenses so much that I have to keep in my mind and I don't think that is a good thing because my mind is not a great worker. It's very lazy and favours simplicity over complexity in most situations.
I think that the problem is that he is talking about testing in a larger context than us... We normally try to find a "right way" to test business web applications, or maybe not only for business but to implement some kind of process... But I think that he is trying to define tests also for other kind of code... like in the example he used about the VS code plugin... I am not sure if is what you are looking for, because is not in the context of this kind of "business app"... But he, Kent Beck, actually has some videos on PragProg ([https://pragprog.com/screencast/v-kbtdd/test-driven-development](https://pragprog.com/screencast/v-kbtdd/test-driven-development)) where he implements a Database cliente doing TDD... Maybe you can find the content interesting.
I'm not the author. It's Thomas - an academic I suppose :-). But you're right conclusio and conclusion is pretty confusing. It makes more sense in German (the native language of the author) e.g. Zusammenfassung and Conclusio (the differ more :-).
I believe in the game_hash, you are missing a closing brace for home players. After I fixed that, here is the solution I came up with: ```Ruby def all_players(game_hash) game_hash[:home][:players].values + game_hash[:away][:players].values end # Equivalent to your STEP 1: find the player with the biggest shoe size def player_with_max_shoe_size(all_players) all_players.max { |p1, p2| p1[:shoe_size] &lt;=&gt; p2[:shoe_size] } end # Equivalent to your STEP 2: return that players number of rebounds def big_shoe_rebounds(game_hash) player_with_max_shoe_size(all_players(game_hash))[:rebounds] end puts big_shoe_rebounds(game_hash) ```
In your solution, you start to go off the rails in this line: `data.each do |attribute, values|` To iterate over all the players like you are doing would look something like this: ``` h.each do |team, data| data[:players].values.each do |player| # Do something with each player end end ``` Combining the players from both teams into one array of players would make the logic easier to comprehend and allow you to leverage the Ruby `Array` and `Enumerable` methods: ``` def all_players(game_hash) game_hash[:home][:players].values + game_hash[:away][:players].values end ``` Now finding the player with the biggest shoe size is just a call to `Enumerable#max`. The following method returns the complete player hash so you can display any attribute you want for that player: ``` def player_with_max_shoe_size(all_players) all_players.max { |p1, p2| p1[:shoe_size] &lt;=&gt; p2[:shoe_size] } end ``` `big_shoe_rebounds` can now be implemented by calling `player_with_max_shoe_size` and returning the :rebounds of the player returned: ``` def big_shoe_rebounds(game_hash) player_with_max_shoe_size(all_players(game_hash))[:rebounds] end``` 
[Kimurai](https://github.com/vifreefly/kimuraframework) 
Merkle trees are a data structure that is very useful to know and has a lot of applications outside crypto-currencies. I think I've written more merkle trees than I have linked lists in my life. Though linked lists are weird, so heavily taught yet it's extremely rare that they are the correct tool for the job. 
As someone who doesn't have the background to understand this, I wanted to read the reference - http://yukimotopress.github.io/blockchains - but this appears to be very weirdly formatted? Or at least also impossible to understand. It seems to be a series of bulletpoints without any explanation before launching into code further down?
I knew some programming: python and visual basic. I didn't know testing, which was the big learning curve. And it's also the answer to your second question. Testing and writing code go hand in hand when learning from Ruby Koans. To start you run ruby path_to_enlightenment.rb and read the output from the command. $ ruby path_to_enlightenment.rb AboutAsserts#test_assert_truth has damaged your karma. The Master says: You have not yet reached enlightenment. The answers you seek... Failed assertion. Please meditate on the following code: $HOME/koans/about_asserts.rb:10:in `test_assert_truth' mountains are merely mountains your path thus far [X_________________________________________________] 0/282 Notice how the output shows you what file and where in the file the error lives. Also notice how the file name and the test tell you what you are meditating on: "asserts", which is fundamental to test: assert(1+1,2) assert(true,true) assert(nil,false) As you progress, your files will become error free and you'll progress to new files, which will teach you new facets of ruby. 
I didn't know them. And that's my own fault and I should learn about them. However after being in the industry as long as I have been never coming across Merkle trees forgive me that I find it hard to believe that it's a wildly known concept that needs no introduction. If that's what you are suggesting that I disagree with. &amp;#x200B;
Is there a reason this is better than any of the other feature flag gems?
They were created in 1979 so they are not a new concept. If they are widely known, I guess I don't know, every time I've used them had nothing to do with crypto-currency and the use case is also pretty old so I doubt this is some untracked territory. If you haven't run into them, it's likely due to your choice of development tract. 
IIRC it runs *both* paths, and warns you if they return something different.
What is 'it' if your reply?
Scientist lets you try two implementations side by side. It will rescue any exceptions that occur in the experimental code. You can configure how it publishes results to do basically whatever you want, log a bunch of metadata, statsd, etc
I would be a little more complex but I would find an opensource API like a weather API and write something that fetches data and presents it in a smart way. I would bet they probably write against a lot of XML or JSON APIs. They might do a lot of data transforming too so something that can query one API combine the data with some other data and present it as a new API might be good too. &amp;#x200B; Otherwise if you just need something simple, the job will probably revolve around fetching and presenting JSON/XML so maybe something related to that...
Scientist. So if you have some complex logic that you refactored, Scientist will run both your old code and your new code, and log a warning if the two implementations return a different result (but still return the result from the old code).
So we have to choose between two gems because they have a slightly different, and non-configurable, if/else block somewhere in there?
I'm all for not rebuilding stuff and leveraging community code, but this is just an entire gem that acts as a simple conditional. I've built systems like this before and how to check a global attached to some namespace is never the problem nor is how to route control, this is Ruby after all, it's what we're good at. So I guess I don't get gems like this, if you built an end-to-end thing that connected to Consul(etc.) and had a web UI that would be great, but just replacing the conditional with a random name doesn't fix much.
On my phone, but is hashes a method on an array? I don’t think it is. Would seem that you can map over the array and get what you need. `array_of_hashes.map {|hash| hash[:city] }` or similar
keys = hashes.map {|x| x[:city] }
yeah you're trying to access an array of hashes here as a hash. If you replace the \[\] with {} the behavior will work as you seem to be expecting 
You don't seem to be grasping what the gem does. It's not about control flow. It's about confirming that two different implementations achieve the same results.
One is: res1 = Imp1.call res2 = Imp2.call call_error_handler unless res1 == res2 MyGlobal.what_do? ? res1 : res2 The other is: MyGlobal.what_do? ? Imp1.call : Imp2.call No?
At a very simple level yes but they have an entire API designed so you don't have to reinvent the wheel.
Scientist is legit. I used it a bit at a previous job and started re-implementation in Scala that I, unfortunately, had to leave behind when I departed. It's on my list of side projects to restart that project as a weekend open source project.
Whatever you choose make sure it is clean and well factored. I run this interview often. All I want to do is talk about your code. 
Were you using any resources to help you solve the puzzles? At the very least, to help with the syntax?
That is bad advice x 2. The first suggestion won't give the described outcome - it'll install 2.5.1, not 2.6 as claimed - and the second version is compiling Ruby in production, terrible for provisioning times (and most 18.04 installs are production servers). If you want Ruby binaries for Ubuntu 18.04 LTS, go to https://www.brightbox.com/docs/ruby/ubuntu and follow the instructions to add their repo. 
Not quite sure what I think of it yet. In some cases this can lend an extra bit of conciseness to code, but in other ways it can easily obfuscate meaning. I'd be tempted to add a rule of thumb that anything beyond 2 numbered params is overkill and likely to cause confusion. It's similar to the Scala placeholder syntax: ``` List(1, 2, 3) map (_ + 2) ```
Scala was definitely what came to mind as I read the post. `@1` and `@2` is much clearer and more flexible than Scala's `_`, which still trips me up when used like `.reduceLeft(_+_)` Agreed on any more than two variables or two usages would probably become perl madness. 
The only thing I want it for is to replace: all_goose_bridle_wigwams.map { |goose_bridle_wigwam| whatever(goose_bridle_wigwam) } into: goose_bridle_wigwams.map { whatever(@1) } If that's all I could use it for, I would be very happy.
Most of my current thoughts are around a gem of mine, `Mf`: https://github.com/baweaver/mf ``` numbers = [1, 2, 3, 4, 5] # =&gt; [1, 2, 3, 4, 5] numbers.map(&amp;Mf + 5) numbers.map { @1 + 5 } # =&gt; [6, 7, 8, 9, 10] numbers.select(&amp;Mf &gt; 3) numbers.select { @1 &gt; 3 } # =&gt; [4, 5] numbers.select(&amp;Mf == 3) numbers.select { @1 == 3 } #=&gt; [3] numbers.select(&amp;Mf === 1..10) numbers.select { 1..10 === @1 } #=&gt; [1, 2, 3, 4, 5] %w(foo bar baz).map(&amp;Mf[0..1]) %w(foo bar baz).map { @1[0..1] } =&gt; ["fo", "ba", "ba"] ``` It's nice for short predicates, which seems fairly useful for REPL-type development in filtering down datasets, as I tend to to that a lot.
I'm also waiting for this very feature only (or at least)... And I'm still wondering why it was never implemented until now..
You could use &amp;method for that. goose_widdle_wigwams.map(&amp;method(:whatever)) On mobile, so sorry for formatting.
I recommend using the feedback loop from the tests to be your guide. 1. It helps track your expectations of what the right answer should be 2. It trains you as you learn the ruby way of doing things 3. Repitition helps build a familiarity of the semantics used in ruby I agree on looking at another reference if a puzzle becomes too hard. Look at the ruby docs first when you're stuck. The nice thing about the test is that they are descriptive: test_about_generating_hashes They follow a structure where the prefix is "test_" and the description follows afterwards. TL;DR: read ruby docs if you get stuck
Yes Tile is not ugly on Windows. Tk is lightweight and fast. I like it. I think it is undervalued. But it is ugly on Linux and Mac.
Oh, It's my mistake, sorry. I was sure it costed me a $100 and haven't double checked the prices when published the post 🤦‍♂️. Thanks!
In Moscow, the one on Bolshaya Dmitrovka st.
If you only want to pass it to a method that takes one argument you can do goose_bridle_wigwams.map { &amp;method(:whatever) } if the method is in the same class or you will have to prefix method call with the class like array_of_times.map { &amp;Time.method(:parse) }
Nnnnoooooo. Please no. This is some kind of weird bash-ism that IMHO isn't necessary at all in Ruby.
Thank you for the clarity!
Thanks! This helped me out a lot!
&lt;&lt; harsh criticism for seemingly minor change &gt;&gt; It's just more syntax garbage targeted at writing ever-more esoteric enumerator code. Every fucking time, every release. We can happily do without it. The core ruby spec needs defended, not mutated. &lt;&lt; embrace destructive power of big change writing on the wall &gt;&gt; Despite the slick design, very little code in Ruby gets passed as object references in arguments. Secondly, all the hot startup talent in is on a march against OO design. It's no accident that a lot of Ruby shops have turned to Go. Rewrite MRI to use LLVM, and invest in adding typing-with-training-wheels instead of enumerator sugars. If we had a smattering of real types that actually allocated on the stack and could be passed as method arguments then we'd be cooking with gas. After that, give us a real match statement that can work with types and values in the same statement. The canonical way to write Ruby is to keep swapping hash objects around with :symbols. I think this is likely a big source of performance problems in MRI Ruby. I'm also tired of the endless DSL hell that fueled Rails and thousands of slow, virtually useless spaghetti code projects. Enough is enough. 
That's is pretty silly and nobody in their right mind writes code like that. Correct pattern (along with the rest of the programming world) is: just\_descriptive\_enough\_name.map {|x| do\_something(x) } &amp;#x200B;
Thanks. What’s curious - this offic is absent on their [site](https://www.reddit.com/r/ruby/comments/b0n18j/about_ruby_certification/?utm_source=share&amp;utm_medium=ios_app) 
We already have something similar with regex. I like it.
I dislike several changes syntax-wise to ruby in the last 3 years; however had, numbered parameters is something I actually support. The syntax is not terribly pretty, I admit this too; HOWEVER had, there is something to be said when it is short and concise. For example: - We can use $1 $2 etc... for regexes. Also not very pretty, yes, but I love these $. They are just the only $ I really like. I can not remember the $: $&amp; $/ easily without having to look up, but the $1 $2 I can remember just fine. (We can use MatchData and [0] [1] etc... and avoid $1, which may be cleaner, but I actually found MatchData more cumbersome to use compared to $1 $2 etc...). So using @1 @2 is actually good too, if you come from this point of view (e. g. $1). The, in my oipnion, really good thing is when you write code quickly and you happen to have quite a long method, a large dataset, and several block arguments that you named. Now you can of course always keep on typing any possibly longer name - or just keep on using @1 @2 and don't worry too much. And I think from THAT point of view, too, that is actually very good. Even if I am not yet completely convinced that @1 is the best but I think it is also quite simple, so this is IMO finally a good, or ok, change, syntax wise. Better than many other ones in the last 3 years in regards to syntax. :P People still have to be quite disciplined when writing ruby code, though - the tinker-factor encourages people to write sloppy, chaotic code where they become too lazy aka the crowd that says "hah my code is so good that it needs no comments and no documentation". That crowd is terrible.
I gave my opinion above already so I won't comment much on it here. In my opinion the biggest argument is that $1 and @1 is similar in "feeling" to use, which I think is good. Both is short. It may not be too terribly pretty, yes, I agree; and it may be better to not use it possibly, however had for fast prototyping and debugging, I think this is actually good. I myself also made similar suggestions in the past but I was not sure of the syntax; @1 @2 have one advantage, though - they are short. (Actually I just realized that we can completely omit |foo| definitions, so it is not quite what I had in mind ... I actually had in mind to still mandatorily define |foo| but then ALSO be able to refer to them with @1 etc... or something similar. Now I am a bit confused ... guess I have to read the original suggestion to this again).
Oh this is unfortunate in scala then - the _ is my favourite throwaway variable in ruby actually. I use it when I can not even want to be bothered to come up with any name to a variable. Seeing _+_ in ruby would totally confuse me - I would assume this means to add two times the variable _ here.
Hmmmm. I actually misread the original suggestion. I thought that the || definitions in the parameters of the block would remain as-is, but now I realize that they can be completely omitted. So now I am confused. What happens if we still use the param definitions? I actually want to use both param definitions AND @1 etc.... 
Now that is a bit funny because, above, you also wrote that the @1 that was added is not very readable (I sorta agree, somewhat), but in your own example here, with your own gem, that has the same problem, IMO! ;)
That is actually worse, IMO, syntax-wise. If we also add the safe navigation operator then we have really really something even perl-users may proudly sniff in disdain at!
I agree! Your variant is more readable. I do sometimes use the .map(&amp;) variants due to them being so terse: ["abc ","def "].map(&amp;:strip) # =&gt; ["abc", "def"] 
Hah! :) I felt that way with many other suggestions, syntax-wise, that made it into ruby; HOWEVER had, on that particular example, I think it is fine. It won't win a beauty contest, yes, but for fast prototyping I think it is actually fine. People can still use the longer variants, and I actually will do so almost always, but for testing, prototyping etc... I think it can be fine. (Note that I actually refer to defining both |params| AND then using @1 ... I am a bit confused that the suggestion meant to completely omit |params| altogether, that is strange).
If you mean the `$1`, `$2`, etc., then I don't like it. It's Perl's legacy which, in my opinion, again, isn't necessary in the rich OO language.
The challenge now is to write list comprehensions using all of `$1`, `@1`, `\1`, `?1`, `!1`, `-1` in the same expression.
I agree with you to some extent; I actually said something similar about many of the recent syntax changes in the last 3 years. In this particular case, though, I think this is actually an ok change. The primary reason is that we can already use $1, which are not very pretty (but I use them too), so from $1 to @1 is not a really that huge change, IMO. Although I can't say whether I like that people can completely omit the |param| - I thought before that, if implemented, it would still mean that people have to define |params| and then be able to just tap into the param via a positional argument, as is the case for many other things (string accessing [] and array accessing [], and we can define [] for our own custom classes too). &gt; Secondly, all the hot startup talent in is on a march against &gt; OO design. It's no accident that a lot of Ruby shops have &gt; turned to Go. I don't think this is the primary reason for any change. Go is much more a simpler C. So people moving to Go is a LOT more about gained speed rather than because they would hate OOP. &gt; Rewrite MRI to use LLVM While I agree that LLVM targeting is nice, and we could need an additional ruby similar to crystal, but retain the "scripting" origin, I actually disagree that ruby should depend on LLVM. I could expand on the reasons against this, but this is mostly a matter of choice; matz also explained this in a presentation some time ago. &gt; After that, give us a real match statement that can work with &gt; types and values in the same statement. Now this confuses me - are you even using ruby? If so why do you write "work with types"??? What types? case/when menus are already super-flexible; and matz gave his go-ahead to additional pattern matching (the people who suggested it, have to improve their suggestion though - matz can not solve everything when people don't follow up adding more details to their suggestions). &gt; The canonical way to write Ruby is to keep swapping hash &gt; objects around with :symbols. ??? &gt; I'm also tired of the endless DSL hell that fueled Rails and &gt; thousands of slow, virtually useless spaghetti code projects. I agree partially. But there are examples of good, simple DSLs too; and flexibility is a good thing. (I did not upvote or downvote your comments since I agree and disagree with various bits at the same time.) 
It's just easier for me. I don't even remember the other way to do it (I suspect Rubocop sometimes changes this on me for repos where it's enabled). Ruby's all about developer happiness. There are multiple ways to do everything, so you choose the way you want. It's a blessing and a curse, but it's very Rubylike.
Ruby does not follow the same philosophy as e. g. Java does when it comes to OOP + accessing data. The ruby philosophy is a lot less restrictive, e. g. .instance_var_get and set at "runtime". From my experience, people who want strict separation almost always come from Java. I think that Java sort of messes with their mind because they often dislike flexibility that is not within their control - but that is a lot what makes the philosophy in ruby. It is a bit hard to explain but let's give another example. Take constants. Constants in ruby are actually not really "constant" in the sense that ... people can change it. And that confuses many people too, which I can understand (since the term is a bit of a misnomer in this case). HOWEVER had, it also fits the ruby philosophy of not getting into your way IF you want to change something. Another example is File.exist? versus File.exists? - I explained that one before and it is so minor that it is almost not even worth explaining it, but it also explains the ruby philosophy and how to "think" within that philosophy. When you do, a lot of things make a lot more sense than when you come to apply patterns outside onto ruby.
In ruby you need good eyes because you have to look carefully. {} is also for hashes; [] is for Arrays. In your example you passed an Array rather than a Hash. By the way, you can add a few more lines of code to check for this, e. g.: if hash.is_a? Array puts 'This is an Array. The method only works with a Hash.' exit end (You could also use raise, but I find simple text-messages output + exiting often much simpler than raise/rescue variants.)
Not criticizing Tabulo per se, it's an awesome tool, but the more I see this kind of projects the more I feel one of the greatest problem in Ruby is the lack of a decent, modern, runtime-independent, x-platform, GUI toolkit... Hopefully RubyMotion ([http://www.rubymotion.com/](http://www.rubymotion.com/)) will finally deliver that... 
I wrote a couple of tutorials you might find useful: https://readysteadycode.com/howto-scrape-websites-with-ruby-and-watir (watir) https://readysteadycode.com/howto-scrape-websites-with-ruby-and-headless-firefox (selenium-webdriver)
Tired: brogrammers, endless medium articles about artisanal code and latte quality consistency at Blue Bottle. Wired: Get shit done cultists, using 80% fewer AWS instances over ruby/python/nodeJS. ReactJS now occupies the space that RoR once held. Swift/Kotlin will prevail on mobile. So many gems haven’t been touched since 2016. I’m sorry but Ruby looking kinda dead as the 3x3 perf plan has stalled and shops are moving on to other languages with strong type systems and compiled performance. Any time savings won by scripting is getting wiped out by the reliability and performance of GCd compiled code. 
Wait, I thought Ruby 2.5+ already had a safe navigation operator, the `&amp;.`
Thanks u/timcraft ! I already read your Watir cheat sheet and applied your tutorials, they are great and helped me a lot for building my scraper! Right now, I'm looking for something a tad more complex as I'm scraping reviews and fail to click on a javascript element. If you wrote any other tutorial, please let me know !
I have much more of a problem with `$1`, etc. than with `@1`. `$1` is awful - it looks like a global but doesn't act like one, while `@1` at least suggests it is local and so is a lot less misleading. 
Funny, I was actually thinking that numbered params were reminiscent of Perl. 
But &amp;method is very ugly IMO. And verbose.
This seems to be a spam bot. When I visited that website to test and try out (I did!), a malicious pop-up attack happened. I thus conclude that the website is not genuine since normal websites do not attack people with websites. In general I think it should be forbidden for content to be linked in WITHOUT any comments, like the fake MasHary911 account did. The reason is simple - if people have something to say, they can say so. Of course bots can also auto-generate text but often these can be identified for zero real interaction.
The account MasHary911 seems to be a spam bot. Normal people don't just link in a link without any comments, only to then get attacked by a pop-up - that must be a site that generates revenue. Thus a selfish link. People could very easily put the advice onto reddit too, so this makes it even stranger that just a link was posted by the above. To the topic at hand - I found debian to be truly terrible when it comes to handling of ruby in general. Considering the proliferation of things such as rbenv, rvm, chruby etc... I may not be the only one to think so.
It looks like another sweet Wolfram Mathematica thing (dude from the method `tally` thread told me it's just a coincidence that it has the same name, but that's a bullshit). But it's an antipattern for Ruby. Every time I do `.each do |a, b|` I feel that I should better iterate over some `Struct(:a, :b)` elements because otherwise it will break when structure changes. Now this feature will allow and teach shitty coders just another bad practice for Ruby.
Sorry, link is broken 😕
Now Ruby *looks more like* a Perl, IMHO it's bad (((
More shitty worthless features 🎉 
Please not that
Try Programming Blockchains Step-by-Step Book / Guide - Let's build blockchains from scratch (zero) step by step. Let's start with crypto hashes ... from my humble self (that is, the same author) for a step-by-step from the very beginning guide with many ready-to-run code samples -&gt; https://github.com/openblockchains/programming-blockchains
&gt; However after being in the industry as long as I have been never coming across Merkle trees FYI: Did you know? Git, yes Git (- the stupid content tracker) uses Merkle trees - that's why Git really is an (awesome) blockchain, see -&gt; https://github.com/openblockchains/awesome-blockchains
Yessssssssssssssssss. Please yesssssssssssssssssss. Use Elixir &amp;-style might be an alternative e.g. `(1..9).each_slice(3).map { &amp;1 + &amp;2 + &amp;3 }` instead of `(1..9).each_slice(3).map { @1 + @2 + @3 }`. Or even using a new Elixir-style `do:` one-liner shortcut e.g.: `(1..9).each_slice(3).map do: &amp;1 + &amp;2 + &amp;3` Beautifulllllllllllllllll.
Oh I never said my own gems are readable. Mostly I use then for my own patch hack scripts rather than in production. The two letter names are mostly a signal that it's a proof of concept. Qo, for instance, is getting a more full name. Xf is about to as well. 
You probably meant parens there instead of brackets: ``` goose_bridle_wigwams.map(&amp;method(:whatever)) array_or_times.map(&amp;Time.method(:parse)) ``` Though in 2.7 you could also do this: ``` array_or_times.map(&amp;Time.:parse) ```
Why would you opt for `do: ` 1 liner shortcut when you already have an even more terse 1 liner shortcut? `{}` that is already known to Rubyists? I don't mind the `&amp;1` syntax too much, but it is nice that @ already implies some sort of var, and it's not too much of a stretch to think of it like "oh, that's kind of like an instance var for a block".
What's the rationale behind starting at 1 instead of 0? It feels almost like a splat, in which case the arguments would be housed in an array, and the first argument would be at index 0, so it feels wrong to me that `@1` is the first parameter. 
I always wanted something like Kotlin's `it` implicit parameter and this is that plus more. It could potentially cause confusion with instance variables.
Because `do:` has different semantics (meaning), that is, it means until the end of line - using `{}` you can use (in theory or practice) multiple lines. 
I love perl. =)
Kotlin can use the typing to predict the lambda's arity though. How would you distinguish between a 0-arity block and a 1-arity block with an implicit `it`?
I didn't actually see a pop-up, just the article, but I run uBlock Origin in aggressive content blocking mode.
so like swift closures. short hand arg names $0, $1, etc.
Groovy uses `it`: [1,2,3].collect { it ** 2 } For more than one arg one must name them: [1,2,3].inject { total, i -&gt; total + i } 
Groovy uses `it`: [1,2,3].collect { it ** 2 } For more than one arg one must name them: [1,2,3].inject { total, i -&gt; total + i } 
You are not reassigning to `i` or to `sum`
You must store the changed value in i. What would be even better is if you could get rid of i altogether. Possibly you could come up with something via .step or some similar more idiomatic variant.
 Other posters are correct that you are missing an assignment. Please don't think you have to write code like this. I just think it's fun to demonstrate how a language like ruby can be thoughtfully concise for problems like you are solving. `puts (0..999).select { |i| i % 3 == 0 || i % 5 == 0 }.reduce(:+)`
sorry, valid link is https://www.prometric.com/en-us/about-prometric/pages/offices.aspx
Safe navigation was actually added in 2.3 IIRC! I forgot about it, as at the time my main Rails app was pegged on 2.2 (I think) for some dependencies and then recently remembered it. I absolutely love it. It's causing me some nice internal debates going on about how much of a good thing becomes a bad thing...
&gt; serverless applications in your local machine wat?
Once you have 3 or more capture groups, use the named captures, ffs. This looks like another sweet Wolfram Mathematica thing (dude from the method `#tally` thread told me it's just a coincidence that it has the same name, but that's a bullshit). But it's an anti-pattern for Ruby anyway. Every time I do `.each do |a, b|` I feel that I should better iterate over some `Struct(:a, :b)` elements because otherwise it will break when structure changes. Now this feature will allow and teach shitty coders just another bad practice for Ruby.
Yeah thanks, was responding on the phone so makes things a little tricky when trying to write code...
For *development*. If you have worked with lambda before, it's actually a pain to develop and debug it.
Nice -- more tempted to use this with every day. Does FaastRuby Cloud deploy on AWS infrastructure? And if so, can we choose which region? Also, has anyone done a pricing comparison to Lambda?
Then it should be called an emulator like https://cloud.google.com/functions/docs/emulator
Any luck? 
Oh, I see. I haven't taken the test in their office, but rather in a test center. I believe some of the centers may be run by smaller local companies. Nevertheless rules are very strict there, no phones or anything is allowed and, cctv is everywhere.
\`i += 1\`
That's great feedback. Thanks!
We don't currently have a region on AWS. But it is coming soon. Just curious, which region would you like to see?
PS: For more Jekyll News Bytes, see [@PlanetJekyll](https://twitter.com/planetjekyll).
If a framework was easy to use, had has many gems/libraries as ruby and would produce twice the productivity, we'd know it.
This comment is exactly why ruby sucks now. It’s a programming language - NOT a framework! 
My priorities would be: **us-east-1**, followed by **ap-northeast-1** I’m running stuff on AWS (mainly through Heroku), and having functions on demand on the same region would be a no-brainer for me at the price point you have. Especially if I can avoid the monstrous setup/interface of AWS Lambda, etc.
What the hell, you are talking about frameworks - ReactJS and RoR in the original comment. Quit trolling. I am framework and language agnostic, I don't care. All I care about is shipping stuff to happy customers and users. Maybe you're the brogrammer after all.
Wow. That sounds like a PR for Ruby core
Agreed - I tried to file a bug report but bugs.ruby-lang.org isn't letting me register.
I got "Internal error" when trying to create the issue on the ruby bug tracker, I will try later, here is the text I was posting for the record. DateTime#=== should be defined and compare date and time instead of just the date DateTime#=== is inherited from Date#=== without overwriting the #=== method, this leads to DateTime#=== comparing only dates and ignore the time part. ``` DateTime.new(2001, 2, 3) === DateTime.new(2001, 2, 3, 12) =&gt; false ``` I think this is not the expected behavior but existing code might rely on this. Date#===: https://ruby-doc.org/stdlib-2.1.9/libdoc/date/rdoc/Date.html#method-i-3D-3D-3D Source: https://medium.com/@dvandersluis/an-rspec-time-issue-and-its-not-about-timezones-a89bbd167b86 ruby 2.7.0dev (2019-03-18 trunk 67296) [x86_64-darwin17]
Your website links to [@awesomejekyll](https://twitter.com/awesomejekyll) which is presumably your old twitter handle. Also `ul { list-style-position: inside; }` would make it a bit nicer.
I thought this was going to implement a generic \`find\_each\` (also \`map\_each\` would be useful), based on a \`first(n, start\_at:)\` method implemented on the classes including this module.
I kinda don't want any more ruby syntax. 
Thanks for reporting. Good catch on the css list display. The Planet Jekyll website would need some fixes / updates - that much I know too :-). Not sure what's all the hate about (see above).
It's because it's self-promotion without adding value. e.g. "Follow me at @iwantfollowers" vs "For more information about Jekyll updates, I analyzed the changelogs and curated it, see this Twitter thread: twitter.com/ohthatsinteresting/123"
Not sure I get your point - I posted the Jekyll story thanks to Planet Jekyll and Planet Jekyll is a self-promotion in what way? It promotes Jekyll - an open source ruby (static) website compiler. Get real.
It's worth noting that `DateTime` should almost never be used. Its only purpose is to handle non-gregarian calendars. If you aren't dealing with this (and very few are), then you should always use `Time`. It _may_ actually be intentional that `===` only compares the data component here since the time component of `DateTime` is rather nebulous in its intended use case. There was no standard concept of the time of day way back when, it was pretty much determined by what time the sun was the highest in the sky. 
`DateTime` also has really wacky `+` and `-` semantics. To add a second, you need to add `1/86400`. Whenever I see someone using DateTime, I recommend changing it to `Time`.
Oooh! That makes sense! Thank you for your time :)
You're welcome!
oooh that looks really good. Thanks!
The pull request states about a refactoring of the configuration regarding the update for multi database handling.. But otherwise I wouldn't understand why they changed from the hash since accessing per-environment configs was already possible with the hash..
is there any particular benefit to having it be a hash instead of an object?
I would ask the question the other way... Since it was already a hash, what's the purpose to make an object just to return a hash? Yeah, they put some methods that take an argument (which turns out to be a regular key of the old hash) to return a sub part of the configuration.. And I admit that since they updated the overall database connection stuffs to adapt to multiple databases it made sense to make this change as a refactoring. But otherwise, I just don't understand why people love to make things more complex than it should be.
Did the security improved since you got hacked last time?
They did the same with params hash =&gt; ActionController::Parameters. 
Yeah but in this case they added the ability to `.require` and `.permit` some parameters.. So why not.. For those who needs a regular hash they still can `.to_h` it...
Control of interface `HashConfig` inherits from `DatabaseConfig` which has a few extra methods `UrlConfig` also inherits from `DatabaseConfig`
Offhand, two thoughts are, 1. Upload a temporary file that has the Ruby code and then run that as a shell command; 2. Write the command line Ruby directly if it's short enough to write intelligibly. In both cases, you'd have to make sure the Ruby invoked is the right version. I can't say for sure what shell Net::SSH will invoke, what the path variable will be set to, etc. But trial/error will get you there. Hth.
There is a rails conf video by Eileen about this topic. She explains why she needed to change it this way. 
Thanks a lot for those posts, much easier than to follow rails commit log / mailling list / PRs
Do you have a link? Thanks..
Ruby 2.7 also gives us the following [syntax to shorten method references](https://dev.to/hanachin/ruby-27-new-feature-method-reference-operator-38l2): goose_bridle_wigwams.map(&amp;self.:whatever)
I'm not sure how I feel about this, but I do want more terse blocks. `things.map(&amp;:do_something)` is really useful, but sometimes I want to add currying or something and expanding to `things.map { |thing| do_something(other_arg, thing) }` kind of sucks
It seems like you are referring to the incident that happened when I first posted the project here, 6 months ago. That was not a flaw in the project's design though, but a bad default by Docker. And yes, it has been fixed since then. Security is an on-going effort for every project, and new ones are especially more demanding. I'd be happy to exchange some ideas about the platform's security. Why don't you come over to our Slack? [https://faastruby.io/slack](https://faastruby.io/slack)
Support Pewdiepie's effort against T- Series and Subscribe [Here](http://bit.ly/9yrolds) 
I heard from the one that looked at it that is was not a bad default config, it was just an humongous mess with credentials littered everywhere, not an hint of a sandbox, all of that wrapped up in same pretty bad code. The fact that didn't publish a postmortem or notify your users except with a quick message on gitter speaks volume.
Not directory through SSH, but if you can install `sshfs` on the system running the script you can mount the remote location then use normal file operations. 
\&gt; How do I select and compare a specific value in a nested hash and manipulate it to get to get the desired result? You could just \`.map\` your hash to only have the key, value pairs you want to compare. For you example, you could go \`players = h\[:home\]\[:players\] + h\[:away\]\[:players\]\` and then \`players.max\_by { |p| p.something }\`
https://youtu.be/8evXWvM4oXM
You are talking about the first version of something that was meant to be a proof of concept. Obviously had holes in it. This project is not funded. It is just me and some awesome contributions from the community. So, do you want to get out of anonymity, stop complaining and help me with the audit? Help is greatly appreciated. Come on over to Slack!
Your data structure sucks. However had, you say that it obtains what you need, so you can use .select, or simply .map and work from that. If you have errors such as: comparison of Integer with String failed Then you use some comparison that has an unexpected "type". &gt; finds the player with the highest points and returns &gt; the name of that said player. The simplest would be to correct this crappy data structure; or to work on a data structure that is much simpler. A simple hash that keeps track of the points, based on a single key, e. g. :player1, :player2 and so forth; and the method that you wish to use to return, as String, the name of the player. With the terrible data structure that you are working with you only end up confusing yourself. Simplicity works in your favour - when a data structure is crappy and handicaps you, abandon it, just as you should abandon complex code that misbehaves.
``` def most_points_scored(h) h.values. flat_map { |team| team.fetch(:players).values }. max_by { |player| player.fetch(:points) } end ```
Bro Thank you!!!, could you explain what each part of your code does?
SSH like that pretty much just lets you run commands on a remote server, as if you were logged in typing those commands. So to run ruby there, you'd have to have ruby installed there (the version you expect, any gems you expect), and perhaps a custom ruby script there that you could execute (you could copy over the custom ruby script). So there's no simple way to do what you want. For the really complex case, you could look at [capistrano](https://capistranorb.com/), or the gem that powers it's ssh stuff [sshkit](https://github.com/capistrano/sshkit). The capistrano/sshkit approach is sort of to copy a whole ruby project/script/application over to the remote server, so you can then execute it on the remote server. Obviously a somewhat complicated thing to do, but that's where people end up trying to follow the path you're kind of describing. You might be best off just doing what you're doing now. :)
Hey, Sorbet is actively being worked on and prepared for open-sourcing(no specific dates though). If you're interested to be among the first companies that we'll reach out to when we open a wider beta, please reach us at sorbet@stripe.com
Great idea! Sent you a nitpicking PR. I didn't know about `git checkout .`.
Nice, this is what I was thinking too. I liked your use of adding array elements: I love that trick with Ruby arrays. So flexible! I personally ended up with (after fixing what I assume to be a misplaced `}` in the data structure above, so that the home and away teams are separate keys): [34] pry(main)&gt; %i(home away).map{|team| data[team][:players]}.flat_map(&amp;:values).max_by{|player| player[:points]} =&gt; {:name=&gt;"Ben Gordon", :number=&gt;8, :shoe_size=&gt;15, :points=&gt;33, :rebounds=&gt;3, :assists=&gt;2, :steals=&gt;1, :blocks=&gt;1, :slam_dunks=&gt;0} 
The pull request in question: https://github.com/jnunemaker/httparty/pull/647
Useful pr and inspiring article. Great Job!
FYI, I've been thinking about some new features I'd like to implement for v1.3. I've added some [Issues](https://github.com/matt-harvey/tabulo/issues) in GitHub for these. Feel free to comment on these, and to raise additional Issues for other features you would like to see added.
Nice, yeah should have been \`|(key, value)|\` actually but \`flat\_map(&amp;:values)\` works fine too :)
Thanks for the PR, any improvements/advice appreciated
Have you tried talking to the bundler / rubygems / rails folks? That seems like quite an essential part a Rails app life for instance. And they are external services for it but they are all paid AFAIK.
Very nice. I love that gem because Net::HTTP is nearly intractable.
&gt; `game_teams.values` Returns an Array of each value for each key in the Hash. For `game_teams` each team hash. &gt; `flat_map { |team| … }` Enumerable#flat_map concatenates the results into a single Array if an item in the result is an Array. `[[1], [2]].flat_map { |i| I }` ⇒ `[1, 2]` &gt; `team.fetch(:players).values` Inside the #flat_map block we fetch all the player-data hashes. The ones with the name, number, points scored, etc. The result of this #flat_map is the player-hashes from both teams in a single Array. &gt; `.max_by { |player| … }` Enumerable#max_by returns the item with the maximum value after applying the block. A Hash has no ordering (doesn't respond to #&lt;=&gt;) so we need to use #max_by to define the criteria for how to order each player-hash… &gt; `player.fetch(:points)` The value of the points key is used to define the ordering criteria and select the player with the most points. Because #max_by returns the item, not the selection criteria from the block, you get the player-hash back instead of the number of points they scored. PS: If the player-hash were an object implementing the Comparable protocol (#&lt;=&gt;) that ordered players by number of points scored you could use Enumerable#max here instead.
Is there any advantage to use over services such as https://depfu.com, https://dependabot.com/, etc.?
Thanks man :) :)
Maybe you could ask Martin Fowler directly? [https://martinfowler.com/aboutMe.html](https://martinfowler.com/aboutMe.html)
It was missed in the printing. It's referenced in the [Errata](http://jayfields.com/rre_errata.htm) and you can find it [here](http://users.csc.calpoly.edu/~jdalbey/305/Lectures/SmellsToRefactorings). Be careful with the Ruby edition of Refactoring - there are some howlers in which the refactored example doesn't actually have the same behaviour. Personally I'd still prefer to read the original (now in its 2nd edition). 
I think you need some specs :)
Thanks a lot, that's exactly what I was looking for :) Also, thanks for the heads up!
If you're on a newer ruby (&gt; 2.3) there is also [Hash#dig](https://www.tiagoamaro.com.br/2016/08/27/ruby-2-3-dig/) to fetch nested values in a hash. Note you have to access the keys as symbols if they're symbols. 
Thanks for smooth collaboration :-) 
That's all true, but remember in real-life responses you usually get utter nonsense out of external APIs, and you have no control over them. We all have to make due with what we've been given. 
The advantage is its free :) I did take my inspiration from them, but thought that it shouldnt be a service that you pay for
Maybe ;)
This does not seem like the appropriate behaviour. My understanding was that "missing attribute" is raised when a valid column getter method is called but the attribute was not retrieved from the db, e.g.: &amp;#x200B; `Post.select``(:id).first.title` `#=&gt; raises ActiveModel::MissingAttributeError` &amp;#x200B; Here, `id` and `title` are columns on `Post`, and we've only selected \`id\` so the \`title\` attribute is "missing". But the change to Rails 6 is now raising this exception in a case where the attribute name is not even a column at all. This doesn't seem consistent to me...
Havent yet, dont know if it is something they will want to do. Bundle already provides the outdated command which i use to work out which gems are out of date whether they want to take on any more responsibility i dont know
Can't remember/google what `\1` is, how can I use that?
Very very loosely tangentially related to ruby...
Nope. gsub backreference. 
While this post is mostly about Elixir, the reason I wrote it was because how Elixir's "function lookup" (doesn't really exist, I got confused) differ to my understanding of Ruby's method lookup. In the post I also give a quick refresher on how Ruby's method lookup work, would love your feedback!
As a ruby dev also interested in elixir I really appreciate this kind of "dive deep" exercises! Great article, thanks!
There is a nuance in function calls on the BEAM that I don't see covered often but it is important in the case of code upgrades (something I've done in Erlang with good mileage, but it requires a lot of discipline). ModuleX.foo and foo These two cases might seem like it only involves scoping and qualification of the module but if you're in `ModuleX` and use the two forms, they mean different things. The first module qualified call means call foo on the newest version of ModuleX that is loaded while the second means, call foo in the currently executing version of ModuleX. This is very handy to know when managing long running code which might need to do a hot-code upgrade. For example, you might have a recursive loop somewhere doing some processing and if you want to update that code, you'll be in for a surprise if you use the second form (called a local call). The local call will keep using the old code and if you upgrade a second time, the process will crash as the BEAM only keeps two copies of any given module loaded at a time. The latter form is called a remote call (not to be confused with RPC or distributed erlang stuff), and will jump to the new module. Why is this important to know? Well, it mostly deals with upgrades and how those work. It might also help you understand how live reloading in `iex` will behave if you have stuff running during the development process. Last note, it is also useful to understand how anonymous functions get compiled and what that means for reloading. The general term for it is called "lambda lifting" but it's just a fancy name for an auto generated function name at the top level which takes the closure as an implicit argument and then the rest of your function arguments. If you're interested in how this works, there are a few talks online which cover this (I gave on a few years back at empire elixir but I believe there are more up-to-date ones now if you search around).
Interesting approach to solving the problem! &amp;#x200B; We're the makers of [http://www.gemprospector.com/](http://www.gemprospector.com/), some similarities in the fact that we don't require access to a repository to run, although we offer a full suite of online functionality and organization access outside of just a project codebase. &amp;#x200B; Again, cool work!
Thanks so much for the kind words man :D
&gt; What should I consider showcasing? Hopefully something that you've already written? I'd be quite concerned about an applicant applying for a job who has *no good examples* of code they've written in the past. (And yes, this has happened to me before.) If I were the interviewer, I wouldn't care about any "boilerplate" code, such as a regular rails application, but in something - anything - unique, which we can talk about. Maybe you've written a bot using the reddit API? Or a set of custom Alexa abilities? Or a game, using Gosu? Or a non-trivial command line application using Thor? Or maybe you've built some *unusual* rails application, which includes some clever solution to a complex problem? ... Ideally it should be something unique; memorable; relevant to the company's tech stack; but most importantly *cleanly-written* and *well-tested*.
&gt; I have actually blogged about this before, which was retweeted by Matz himself! &gt; (I actually have no idea how much this actually means, but I'm still going to wear &gt; it like a badge of honor It puts you above those who haven't written an article/blog. ;) I am not sure it is necessarily any quality control per se, though - matz tweets about a lot of different things. Actually a lot of the tweets appear to be also about non-ruby related things in japan, including stuff politicians do (when it impacts people there). What we did however had learn about twitter is that matz has a dog (or probably the whole family does)! We don't seem to have pictures yet (we do have pictures from tenderlove's cats though ... one of his cats also used to twitter https://twitter.com/tenderloves_cat )
I am try first and second example in Ruby 2.3.1 and Ruby 2.6.2, all same. so, those guess not work.
First (with dates) should NOT be the same, just checked (it is "win" in 2.6 and "fail" in &lt; 2.6). About strings -- it is a bit more complicated than that (see notice [here](https://rubyreferences.github.io/rubychanges/2.6.html#range-uses-cover-instead-of-include)), so strings do not work indeed, but this will: case Gem::Version.new('2.4') when Gem::Version.new('1.8.7')..Gem::Version.new('2.5') 'win!' else # in Ruby &lt; 2.6 you'll never get here, rather TypeError: can't iterate from Gem::Version end
Awesome, glad you found them helpful! Failing to click on a javascript element sounds like it could be the selector that's the problem—I'd suggest double checking the selector is selecting the element you want to click on. Hard to do tutorials on specific problems like that but I'm hoping to do more javascript based tutorials in future.
In the previous thread, I've posted a [solution](https://repl.it/@zernie/StupendousSpecificConsulting) that uses the Enumerable module. Have you tried to use it?
\`sum\` is implemented in Rails not Ruby, you need to use \`inject\`, e.g. \`attribute.values.inject(&amp;:+)\`
[Enuerable#sum](https://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-sum) is part of Ruby since 2.4
Hmm, right, there is even \`Array#sum\` since 2.4: [https://ruby-doc.org/core-2.4.1/Array.html#method-i-sum](https://ruby-doc.org/core-2.4.1/Array.html#method-i-sum)
The difference here isn't that the RSS is different, it's that one is RSS and the other is an Atom feed. You can tell which one you've received based on the root element. Nokogiri `Node#content` (aliased to `#text`) returns the content data from a tag, this works for RSS's `&lt;link&gt;` because the URL is in the CDATA of the tag. In Atom, the URL of a `&lt;link&gt;` is in an attribute -- you will need to use `Node#attribute` to get it. While in most cases, &lt;link&gt; in atom will be `rel="alternate"` which is the "alternate" representation of a piece of content (a.k.a the published page) technically there are other relation types, you should probably make sure to find the link you select is the one marked `rel="alternate"` `&lt;tag attribute-key="attribute value"&gt;content&lt;/tag&gt;` `tag.content` = `content`, `tag.attribute('attribute-key')` = `attribute value`
You want `css("link")[:href]` instead of `css("link").text` ;)
Any reason why you don’t use their [Rest Api](https://api.producthunt.com/v1/docs)?
I think you have a formatting issue with your \`game\_hash\` which might be throwing you off. I think the \`away\` key is actually nested under the \`home\` key. &amp;#x200B; This is what I suspect you want: \`\`\` game\_hash = { "home": { "team\_name": "Brooklyn Nets", "colors": \[ "Black", "White" \], "players": { "player1": { "name": "Alan Anderson", "number": 0, "shoe\_size": 16, "points": 22, "rebounds": 12, "assists": 12, "steals": 3, "blocks": 1, "slam\_dunks": 1 }, "player2": { "name": "Reggie Evans", "number": 30, "shoe\_size": 14, "points": 12, "rebounds": 12, "assists": 12, "steals": 12, "blocks": 12, "slam\_dunks": 7 }, "player3": { "name": "Brook Lopez", "number": 11, "shoe\_size": 17, "points": 17, "rebounds": 19, "assists": 10, "steals": 3, "blocks": 1, "slam\_dunks": 15 }, "player4": { "name": "Mason Plumlee", "number": 1, "shoe\_size": 19, "points": 26, "rebounds": 12, "assists": 6, "steals": 3, "blocks": 8, "slam\_dunks": 5 }, "player5": { "name": "Jason Terry", "number": 31, "shoe\_size": 15, "points": 19, "rebounds": 2, "assists": 2, "steals": 4, "blocks": 11, "slam\_dunks": 1 } } }, "away": { "team\_name": "Charlotte Hornets", "colors": \[ "Turquoise", "Purple" \], "players": { "player1": { "name": "Jeff Adrien", "number": 4, "shoe\_size": 18, "points": 10, "rebounds": 1, "assists": 1, "steals": 2, "blocks": 7, "slam\_dunks": 2 }, "player2": { "name": "Bismak Biyombo", "number": 0, "shoe\_size": 16, "points": 12, "rebounds": 4, "assists": 7, "steals": 7, "blocks": 15, "slam\_dunks": 10 }, "player3": { "name": "DeSagna Diop", "number": 2, "shoe\_size": 14, "points": 24, "rebounds": 12, "assists": 12, "steals": 4, "blocks": 5, "slam\_dunks": 5 }, "player4": { "name": "Ben Gordon", "number": 8, "shoe\_size": 15, "points": 33, "rebounds": 3, "assists": 2, "steals": 1, "blocks": 1, "slam\_dunks": 0 }, "player5": { "name": "Brendon Haywood", "number": 33, "shoe\_size": 15, "points": 6, "rebounds": 12, "assists": 12, "steals": 22, "blocks": 5, "slam\_dunks": 12 } } } } \`\`\` &amp;#x200B; Assuming you use data which is formatted correctly the following will answer it for you: \`\`\` final\_score = game\_hash.each\_with\_object({"home": nil, "away": nil }) do |(team, game\_details), score| score\[team\] = game\_details\["players"\].values.map { |v| v\["points"\] }.sum end puts "Home Team: #{final\_score\["home"\]}\\nAway Team: #{final\_score\["away"\]}\\nWinner: #{final\_score\["home"\] &gt; final\_score\["away"\] ? 'Home' : 'Away' }" \`\`\`
I had the same problem, it was because I was trying to use my email to login, but I actually needed to use the username.
Unless you're trying to learn how to use these components, \`RSS::Parser\` might be a better solution to this - it's part of Ruby's standard library and reasonably easy to use
So much this. Just `include 'rss'` and `RSS::Parser.parse(body)`. Here's a link to the (admittedly sparse) docs: https://github.com/ruby/rss No gem needed, like /u/nordrasir says it's part of the stdlib
Haha yeah I think you're right. That is hilarious hahahah. WHERE IS THE CAT NOW?!
Product Hunt is a scam.
Really cool, how long did it take you to get here?
thanks :) not that long actually. It was a project for a course in university which taught us some of the basics, but then it was just a lot of trial and error. i have more knowledge in music production than in programming so that helped in cutting the time spent to get specific sounds, i guess. to answer the question: the classes were 5x1.5 hours and the coding of the track took maybe 15-20 hours. Time flew by though, i have no idea of programming and really liked the problemsolving aspect of it.
Wow that's awesome! I was introduced to Sonic Pi on Ruby on Ice last year. had a lot of fun with it!
&gt; i have more knowledge in music production Oh, now I don't feel bad about that I can't make a thing in Sonic Pi. 
Looking very nice! I'll upvote anything stranger thing anyways, but that video / system looks awesome! Never heard of sonic pi, but now I wanna know more!
haha thanks. This was just my first project and I am no programmer but feel free to ask!
Never heard of this but I’ve been a producer and musician almost my whole life and just started getting into programming so I feel like this is about to change my life.... 
this is fucken awesome , love it 
Thanks for discount hahahahah 
There is a good [Ruby Rogues podcast a while back](https://devchat.tv/ruby-rogues/215-rr-sonic-pi-with-sam-aaron/) that introduced me to it.
There is a good [Ruby Rogues podcast a while back](https://devchat.tv/ruby-rogues/215-rr-sonic-pi-with-sam-aaron/) that introduced me to it.
Do you have a github repo you could share with the code?
Wow this is super cool. I wonder if you could write a program that could read sheet music and recreate symphonies etc.
You need to update that thread, the maintainers are asking you questions.
Not sure what a repo is. in the video description is a google drive link to download the code. If that's not an option for you just tell me what I have to do on github to make you happy haha
Start with learning ruby first.
is there any roadmap that can help me ? 
and i had start with "[rubymonk.com](https://rubymonk.com)" is this a good start ? any recommendations for books ? 
I’d start with ruby-lang.org and free codecademy.com Ruby course to get a feel what this language is about.
Thank you
I am not sure if this is a good foundation to start with. I also came from PHP to ruby but my motivation was quite different - I wanted a better language than PHP. Ruby fit that criterium. I would not (want to) learn ruby or another language because of a "career" path that would put me into a pen tester or any such things. But your mileage may vary. I would try to create a seizable number of ruby projects, say something in the range of 10-20 or so; that should not be impossible while not being too few. Start with some smaller projects, and in the last ~5 or so go to work on larger projects that can actually be useful to your case, e. g. related to testing. Add as much information to these projects so that you can talk about them in interviews too. Ideally these projects should fullfil some use case; not sure what that should be, you'd have to find use cases that may be useful. Actually you could also translate existing projects you have with php and translate them into ruby; js can stay the same so ruby would only replace php. You can get into rails too, but if you want it simpler, start with sinatra. You could even re-use the same ruby classes, just adapt them when you go from sinatra to rails.
There is a site call bug crowd that does crowd sourced pen testing. Might be a good way to get your feet wet in that world.
Thank you 
Thanks, I didn't check it.
Thank you 
https://www.launchschool.com/books is a good place to start. If you really want to get going, you can do their program. Master-based approach to learning. Highly recommend from what I have taken. 
That link is sufficient, but, it may be of interest you to set up a github account. A repo, which sorry for jargoning on you, is a repository. A place to keep code. With github, you can put your code up there for free. But not only that, I could then 'fork' or 'clone' your repo, make suggestions/changes/etc, then submit them to your for approval. Maybe, I'd make another song from Stranger Things, or a dubstep take on it. And it could be added to the repository by you accepting my 'Pull Request'. For people who do a lot with code, github is a more natural feeling way to share code. 
[removed]
`@` is for instance variables, you aren't in the same instance, in your script you are in the main `Object` and in the test you are in some RSpec class. This could work if your primes thing was wrapped in a class, e.g. ``` class Primes def initialize @primes = [] end # your code end ``` And then you do `let(:primes) { Primes.new }` and do things like `primes.is_prime?(-1)`.
You can try out metasploit while learning ruby. It's one of the main tools for pentesters.
Yeah it really an awesome framework, cause this kind of tools I had chosen ruby 
Also might want to look at nmap, exploit db and seclists / fulldisclosure
I will check it out thank you 
&gt; But I'm still not sure what the best way is of reading files in a performant and memory lightweight way. `File.read` is fine most of the time, otherwise `File.readlines('foo').each do |line| ...` can work for much larger files. 
Consider using `Prime`: https://ruby-doc.org/stdlib-2.6.2/libdoc/prime/rdoc/Prime.html ``` Prime.first(10) =&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` As was mentioned in other commends, `@` is an instance variable. If you want to have a cache of values I'd make a class around this as others have suggested.
I see, thanks for explaining! I'm not sure if I will do anything more in the near future but i will keep it in mind.
It is very bad, in my opinion, to just link in an URL without any comment. That means to me that the one suggesting the link did not want to bother to communicate with other human beings - otherwise, why would this person not comment on anything at all? There is no real way to comment on it "randomly", in regards to whatever was the assumed intent of the link. It's like a link-bot.
It is not a bot :D. "It is very bad"... come on mate, what's that negativity. Just have a look around, and you'll see that many people do in fact post links without comments. It's like - "See, I found something that I believe will be interesting to you guys". If you wish, we can communicate 🤓.
https://old.reddit.com/r/ruby/comments/b3fhcz/how_ruby_26_allowed_me_to_do_another_open_source/ Did the person posting wrong a comment? I can't see you pouring your condemn there?
wat? :D So people can't submit links? :D
Is it able to deal with native extensions now? Or is it because Sinatra is pure ruby?
Try to isolate your issues to the minimum of code possible (test case), you might actually find your solution on google/stack overflow. &gt; undefined method `max_by' for "Alan Anderson":String That should be enough, with the stacktrace to debug it.
This was fn creative and cool... Nice job.. i want to steal your code.
A few things you should know before getting into infosec. While most of InfoSec is very Python-centric, you can still leverage Ruby. Most pentesters use some kind of scripting language to automate tasks that tools cannot perform by themselves (ex: send output of tool A into tool B, or some kind of ETL). Next, majority of "pentesting" is really just glorified scanning where you run a bunch of tools (recon and automated exploitation), see if you can find any weaknesses and what access they grant you, write up a report of your findings, collect your paycheck, repeat. If however, you want to take part in Bug Bounties, this implies you'll need code auditing and reverse engineering skill-sets, as you'll be trying to exploit custom software, usually without access to the source code. Checkout /r/netsec's [Getting Started in Information Security](https://www.reddit.com/r/netsec/wiki/start).
I think it can. But not with all. For example, it cannot deal with nokogiri yet. As far as I'm aware.
Reading and parsing a file should be quick. What I mean to say is don’t spend time on threading, but instead read the docs on Enumerable, Hash, and Arrays to see if there are ways to make the SQL-like coding easier. Ruby makes tasks like this fun to do, but the effort will take some time regardless. Good luck!
That is really cool.
Honestly, just learn to learn. Once you can pick up whatever language and get going, you're in a better spot. Ruby is great to learn, but get the basics down, and move on to something else. Ruby doesnt have a huge demand without all of the secondaries that usually come with people interested in those positions. For example, its big in devops, because of chef. But if you dont know how linux, what use is automation? Another example is metasploit... But if you dont know how the exploits work, or the basics of being undetected, and trying to retain access... then what use is it? If you want to be a pen tester, you might want to learn c/c++ so you can understand the concepts of buffer overflows, shell code, rootkits, etc, and really get why/how they work. I would also learn to linux and windows system administration, since you will have plenty of time setting them up in your lab to test your exploits. 
I'd suggest you do this the other way around, write tests first, that way you'd be forced to make sure tests simple, leading you to write code under the constraint which will lead you to write code the way it should have. One of advantages of tdd. 
At Rubyconf last year, [Joseph Wilk](https://twitter.com/josephwilk) AKA [Repl-electric](https://www.repl-electric.com) live-coded some pretty awesome music and visuals using Sonic Pi. His performances are [open source](https://github.com/repl-electric) too, worth checking out if you're in to this sort of thing.
undefined method `max_by' for "Alan Anderson":String this says: `string` doesn't have method `max_by`. And if you look up `max_by` it's a part of an enumerable. So you should call it on an array. [Here is an example](https://apidock.com/ruby/Enumerable/max_by), where it uses the `%w( ... ) syntax instead of writing `a = ["albatross", "dog", horse"]` So you have to take all the player names, put them in an array and then call `max_by` on the array, not the individual strings.
Thank you so much , that so useful . 
That's the show-stopper for us; literally every app we've written in the last five years has used Nokogiri or [Ox](https://github.com/ohler55/ox), which I suspect likely has the same issues for similar reasons. It's starting to look like the easiest/cheapest/most effective way to get better performance than your MRI Ruby code gives you is to move to [Crystal](https://crystal-lang.org/) if you can, or either Go or Elixir if you can't. That sucks with a perfect vacuum.
Please stop spamming the sub with identical questions, and read the comments.
It does now work with nokogiri, with a couple of patches that we're looking at upstreaming. It also currently links to the system dynamic library, rather than the bundled static library. Other C extensions we support include openssl, pg, sqlite, and most of mysql2.
That title could use some work if you’re looking to get some eyeballs on the article...
So basically don't use `nil` use `0` instead? I don't understand how this would make anything better. You still need to check for `zero?` everywhere instead of `nil?`
Is TruffleRuby actually used anywhere in the wild that you know about ? I am just curious I have not seen anyone talking about it as something that they use in production.
No it’s a research project. We’re working with a few people to test on their applications though.
The title and the grammar in the README was hard to follow. By the way: "Let's" means let us. "Lets" means allows. &gt; Let's you do the thing. _Allow us you to do the thing._ &gt; Lets you do the thing. _Allows you to do the thing._
I'm from Austria (and speak German). Anyways, thanks I fixed the three lets typos (if you can find some more, please tell). Greetings from Vienna. Cheers. Prost.
You can access nested structures or multi-dimensional arrays without ever getting a nil reference, for example. Anyways, the technique is the standard practice in contract-oriented programming languages (e.g. the default in solidity / vyper for example). Zero for a struct is `Vote(0)`, for example, that is equal to `Voter.new( 0, false, 0, '0x0000')` and so on. Not sure if you see the point. 
FYI: On reddit you cannot edit / change the title (once posted) - you have to bear it.
It works fine with nokogiri, at least in my limited testing. I've been able to stand up a Rails app with PG (also C extension) without much issue as of 1.0.0rc12. 
Every proposed Ruby type system or type constraint model seems to conflate Type with Class, which is why I never use any of them. This structure seems additionally flawed by its primitive obsession and apparent total bypass of the Null Value pattern and its upgrade the Substitutable Whole Value which is the true antidote to nils. A variant of the Ruby language that _fundamentally_ eliminates NilClass and nil as a value would be interesting. Especially if it were combined with true message passing. I think everyone trying to work on providing a type system in Ruby should first read/watch Avdi Grimm's series on [Whole Values](https://www.rubytapas.com/tag/whole-value/) over at RubyTapas. [subscription required but worth it]
This is quite helpful with working with Postgres and AR, I'm surprised I haven't heard of it before to be honest.
The main issue I've seen is interpreter/runtime specific optimization, some frameworks/apps are designed more for MRI and make stuff like the 2.6 JIT and truffle run slower than just the base non-jit MRI. Hopefully these deviating design choices can work towards an optimal solution in the near future.
Thanks. I've been working really hard on this in an effort to stay as compatible as I possibly can while introducing new API's.
Interesting example (understanding smart contract is on my things-I-should-learn-when-I-have-time-list). Though I still don't see the benefits ☹️ So there's a `Mapping.of` which just looks like cleaner way of creating a `Hash` with a default value of 0 instead of `nil` and `game.nil?` is replaced by `game == Game.zero`. If you aren't careful you could potentially do something that would result in a `nil` value and then you would have a bug in your code if you expect that there should be no `nil` values. The way I see it, you always need to be careful not to introduce unexpected behaviour, regardless if check for `nil` or `zero` values.
I don't work much with PG so I didn't know about the original gem, but to me the naming of this gem seems a bit off. ActiveRecord works out of the box with several database engines, however this gem only adds functionality specific to PG (at least this is what the Readme indicates). Naming it something generic like "ActiveRecordExtended" is, in my opinion, misleading. In your defense, though, you state several times in the README that this is unique to PG, so there's that.