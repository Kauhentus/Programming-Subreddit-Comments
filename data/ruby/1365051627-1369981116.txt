I wanted to go, but have class all week. I might stop by the library later though
I live in the LA area. What class do you TA for?
This is very realistic, I've worked with great programmers that don't have a CS degree, and great ones that do. More important than a degree will be experience, as others have said contribute to GitHub projects, but also try to start your own, especially if you have an idea for something novel or useful. 
Yes! Anytime you're writing longer/more advanced regular expressions, checking as you go is a critical step.
There isn't anything gmail specific here, this is exactly how you'd sent email using any SMTP server protected by TLS with Net::SMTP.
That seemed odd to me too, but it's handled by fallback cases. For example, line 55 does an unchecked CAS. If that fails, the next run through would trigger the else block repeatedly, until the tail was properly updated.
I started teaching myself to code at 27 (30 now). While I have a non-related BA I don't use it nor did I need it for any of my jobs (I'm sitting next to a junior dev with a GED right now). I learned enough to get a junior Rails dev job making $80K with no programming experience and no major open sources projects or anything to speak of. I eventually took the job I have now making $100K+ and am now Senior Engineer. **Total time spent teaching self:** 1 year **Total professional experience:** 1.5 years Learning to code can change your life, if you love it and keep developing yourself with enthusiasm. Don't give up. You've already done what most won't/can't...took the time and effort to teach yourself an extremely hard and non-intuitive skill. Keep it up and you'll be in a much better position in no time!
Sadly Unicorn is now suggested by Heroku
This is an interesting trick, but I don't advise using it in production. Years ago, there was a php CMS called e107. It had an option that did this, and while it sounded very good in theory, checking it would generate tons of problems for people using services like gmail. This may have been fixed, but I don't doubt it still persists in some cases. You're probably better off using some BL, like DroneBL, DNSBl, etc
Most people would probably use a MX record to set up their mail servers, but a A(/AAAA) is enough to have email delivery to a domain name, so both should be checked so as not to exclude people in that configuration. (and just as a note that regexp is not entirely correct, but there are already existing gems for handling that parsing)
Why do you need that? * If you want to check the validation of the input format then this gem doesn't help because it simply split at `@` character. * If you want to make sure that user does not intentionally enter invalid email. Then it doesn't help because they will simply enter "dummyemail@hotmail.com". You are better off sending confirmation email. The benefit of checking with regex is offline check, the benefit of confirmation email is only real email is confirmed. This gem gives the worst of both world, requiring network request and no actual confirmation.
I doubt you'd need Rails specifically for that (might be overkill if it's a single-use project). I think you'd be good to go with Sinatra. You could even use Sequel as an ORM, but it wouldn't be necessary. PM me and I can get you started, if you'd like. [Sinatra](http://www.sinatrarb.com) [Sequel](http://sequel.rubyforge.org/) 
This seems unnecessarily complicated. Email validations are only there to check for typos; if you want to ensure the user gave you the correct address, send them an activation link.
edit: Be sure to read the child comment, in which the project's creator explains what a slim Gemfile *actually* means. (Hint: it's not what I originally thought.) Hmm. Neat tool, but I don't think I accept the slim Gemfile premise. A Gemfile, from a semantic perspective, should describe the gems upon which a project directly depends. If my project uses both `devise` and `i18n` for independent purposes, it should say so explicitly for a few reasons: * **Future maintainability.** If I later decide to replace `devise` with another authentication system, I need to go through all of the `devise` dependencies to decide which of them I'm also using and manually add them to the Gemfile (or just forget to do that and resolve the runtime errors as they appear). That's bad news. * **Semantics.** Sure, shorter Gemfiles can be read more quickly, but it's more important that I'm getting all the information I actually need. If I'm looking at a project's Gemfile, I'm probably interested in what gems this project uses. In that case, I want to see *all* of the project's direct dependencies—I want to know that it both uses `devise` for authentication and `i18n` for internationalization—and I don't want any of them to be hidden from me by dependency trees that, for my purposes as a developer, are pretty thoroughly arbitrary. (The fact that this tool *exists* implies that a developer couldn't just look at the `devise` line and understand that `i18n` is also included. Heck, it could even confuse a developer who doesn't get where the `i18n` dependency is specified and has to go around looking for it.) * **Conflict resolution.** If `devise` updates to a version of `i18n` that's incompatible with the rest of my project, I want to know that at bundle-time rather than runtime. This problem is solved by explicitly including the `i18n` dependency and which version I need: I still have to resolve the conflict manually, but there's absolutely no way I'll miss it before deploying, and I'll understand exactly why it happened. Heck, `devise` could even drop their `i18n` dependency entirely, and then I'd be even more stumped—what happened to the gem, and exactly what version do I need? Or maybe I'm just misunderstanding what a slim Gemfile means here. Still. Cool tool, and I'll probably end up using it in the future. But not for removing a few lines from my Gemfile.
Thanks for the feedback, matchu. I'm not at all advocating that you should remove anything from your Gemfile. For all of the reasons you mention I think you should be very explicit about which gems your own code depends on. I built the tool just to have an easy way to determine the "relative weight" of a gem. It's meant to be an easy way to get a feel for how much "bloat" you might be adding to your overall project by including the latest new gem you found. I hope that makes sense, and thanks again for the input. (Maybe I need to include this type of a description somewhere on the site...)
Ahh! Yeah, that makes way more sense. It'd definitely be nice if that were more explicit :) Thanks!
Submitting this to /r/ruby after the fact because the Padrino team are a bunch of great guys and the framework itself is pretty fun to use.
Yes, I was wrong. Algorithm is correct. See comment in gist. Cool algorithm, by the way :)
looks nice, but it works only on very popular gems (i hope so) -&gt; ergo useless
Hi, le_fnord. It should work for any gem that is published at rubygems. Is there one that gave you a problem?
I don't have a problem. I was thanking all of you for fixing *other* problems. :)
Is there a call for proposals?
Huh? Bundler *already* solves "Semantics" and "Conflict resolution", no matter how big your Gemfile is. In fact Bundler was explicitly designed to solve those two problems. Semantics: Bundler generates the entire dependency graph for you and stores that information in Gemfile.lock. Conflict resolution: Bundler resolves conflicts for you automatically. If there is a problem, 'bundle install' will fail. You don't need to explicitly specify a version in your Gemfile.
We had one open through March, but it just closed. We tried to get the word out through as many channels as we could think of, but would love suggestions on other places to post it next year.
Aw, that's a shame. The best way to advertise a CFP is through intensive twitter spamming and stuff like Ruby Weekly, they'll post links to open CFPs often. :) 
That's pretty much what we did. We were in Ruby Weekly, Ruby Flow, and had a ton of traffic from twitter. We ended up with about 10x more proposals than speaker slots so I think we did pretty well. :)
Ah, cool then, it was my bad I missed it. Maybe next year! Best of luck with the conference! :D
Mhm. However, Gemfile.lock doesn't mention which of the gems are *directly* used by this project, which is what I mean by semantics here. Bundler also will *not* resolve implied conflicts. Suppose I use the i18n gem's 0.5.0 API, but then upgrade devise to a version which in turn upgrades i18n to 0.6.0. If I hadn't explicitly specified the i18n dependency, then i18n will update along with devise and the implied conflict will *not* be resolved. Thankfully, the whole thing turned out to be a straw man anyway, and nobody is actually suggesting omitting direct dependencies. Phew. 
Thanks!
This is awesome!
Sweet.
Sweet. I have a Pi with a Piface attached. This could be fun.
Why thank you! [résumé](http://hire.kerricklong.com/) / [github](https://github.com/Kerrick)
I shall do this tomorrow. I've been a busy chappy the last few days, sorry!
Have you tried rails installer ? 
Rails installer bro
thanks
Side note: Last year I tried Sinatra on Windows and I had the worst time. Sinatra worked fine, but there were multiple gems - or at least gem dependencies that I wanted to use which wouldn't work because of Windows. In general I felt I had to jump through hoops to get stuff done. If I was lucky I would find an alternative or a work around otherwise I'd just give up. I have since converted to Mac / Linux (not specifically for Ruby although it was a factor) but I wouldn't expect others to have to. It is a shame Windows doesn't get much love in the Ruby world.
Any good guides out there that are Vagrant oriented? Not that *I* need it but this might come in handy for helping setting up the development environment for a project I created for friends.
[the railscast](http://railscasts.com/episodes/292-virtual-machines-with-vagrant) should be ample to get anyone up to speed, and the process should be about the same on Windows. This is definitely the route I'd use if I was stuck on a Windows machine. The tl;dr of it for anyone unfamiliar is that you develop your software inside of a Linux (or whatever your production env uses) VM managed with a simple command line tool.
That's all fine and dandy, but there's no explanation of WHY other than "it's not unix-y enough". 
Out of the entire stack of tech that I work with, RVM is one of the components that tends to give me the least trouble. 
I really don't see any advantage to one or the other, although I can understand the appeal of "let's switch to something else" every once in a while. 
This is basically my workflow. I tried rvm, and decided it wasn't for me, with the myriad of cryptic commands. Yes, I sometimes miss rvm's features, like the ability to install particular patch sets on top of ruby, such as the falcon patches, but they are easy enough to get working with ruby-build, and sste… has said he might add build targets for them in the future. Also, I was going to comment here and say something along the lines of "RAGE DONT USE RVM/RBENV USE BUNDLER WAAARGAAARBBLLL" but then I read the article
I don't think the Unix philosophy is always a good thing. For one, the "simplicity" part of the Unix philosophy often refers to *implementation simplicity*, not *simplicity for the user*. These two things can sometimes be at odds with each other. For example, [Phusion Passenger's](https://www.phusionpassenger.com/) codebase is huge compared to Unicorn, Thin, Puma, etc. But that's because lots and lots and lots of code was written to make things easy for the user (and, consequently, hard for the authors of Phusion Passenger). I believe rbenv falls into the implementation simplicity camp. Last time I worked with it, yes the tool is small and lightweight. But it lacks so many useful integration features that RVM has, resulting in me spending more time than I would like to just to get it working properly in different situations. My philosophy is that computer programs should serve humans, not the other way around.
A better reason would be: RVM replaces cd with a function in order to work, which can sometimes cause problems.
Yes, this was my problem. I use tmux and opening new window puts you in the current directory, thus the cd_hooks do not run. Caused me some annoyance.
If you are looking for simplicity and something that follows the "UNIX philosophy", checkout [chruby](https://github.com/postmodern/chruby#readme).
My favorite monkey patch I use on everything :) ##Class extension to get the inverse of a Chomp. class String def pmohc(string_to_remove) len = string_to_remove.size if self[0..(len-1)] == string_to_remove return self[len..-1] end self end end
Thanks again for authoring chruby. Makes life so much easier.
This would be a lot more interesting if it were a Ruby-to-JavaScript transpiler, or even MRI compiled with emscripten with a reasonable JavaScript integration API. I'm afraid that a fork of Webkit is pretty much a nonstarter. This is probably going to be about as successful as VBScript in the browser
While I agree that this is not going to be adopted, I still think it's a cool proof of concept.
Shooow meee Scala in the DOM! Now that would be wacky.
I'm just learning Ruby- Someone please explain like I'm 5?
Basically the only scripting language supported by modern browsers is Javascript. This guy rewrote parts of a browser to allow it to run Ruby instead of Javascript.
Thanks!
I wish this were the future
Between coffeescript &amp; rubyjs, I'm not sure what I'm missing.
I teach at General Assembly in Santa Monica
Suppose you'll be hosting on Windows, too? No, you won't. Use an operating system that is close to your final host environment. There is a reason Ruby/Rails are broken on Windows: nobody cares.
Yes, this is true, but I feel it's solvable case, either with harmony proxies or a try-catch. You can try es6 stuff here: http://benvie.github.io/continuum/ 
I see startup time was listed as improved, but no numbers. Has anyone checked that out yet?
Excellent work!
&gt; **Todo** &gt; Write tests This should be illegal.
If you look at the source, there are some basic tests. If you have ideas on how to improve feel free to send a pull request :) 
I'll take a look at what I can contribute later this week. I would like to point out, however, that your tests aren't actually testing anything. You've stubbed your entire code base, and then just asserted that various internal methods are called. Rather than obsessing on internal implementation details, you should consider focusing on externally visible behavior
Awesome, I'd love your feedback! I'm not very clear on what/how I should test something like this. 
It might be worth comparing your solution with the existing [backup](https://github.com/meskyanichi/backup) gem.
Great stuff. How does it handle the parent dying due to a SIGKILL? Do the children know to terminate themselves in that case? Also "From 2.0, Ruby does not allow to use a mutex in a signal handler." is not correct I think. I remember breaking the MRI when trying to add a mutex to a signal handler in Ruby 1.9.2.
Since Ruby is not guaranteed to have tail recursion, calling run inside run will eventually lead to a Stack explosion. Why not a good old loop? Anyone named a worker squarepants yet?
Over reacting should also be punishable by death.
If you've never seen Symbol#to\_proc or the Ruby 1.9 arrow-style lambda syntax, I guess this could be marginally useful.
I'm not sure I would use this library, but I'd pay a few bucks to play "Sponges vs. Demons" on my phone...
That gem looks pretty awesome.
$29 - $279, are you serious?
LOL! Apparently the author thinks ebooks sell for academic hardcover prices. They don't.
$29 might be very ok. I read the sample chapter, and it was okish for me. Maybe its only me, i prefer "read the book online for free", buy a hardcover for a good price if you want to have the book around and support the author. 
You get that the $279 version comes with a 2 hour 1-on-1 tutorial, right?
$100/hr tutoring and a $79 book is still pretty unrealistic.
is it actually programmed in Ruby or that's just the name ? If so, what gems have you used .. also, youtube link with gameplay would be nice
Have you read the page? You get the book, tutoring, plus 4 video interviews plus transcripts. Working through the tiers, the cost is as follows: Book: $29 Videos: $30 Tutorial: $220 ($110 an hour) $29 is perfectly reasonable for a decent programming book, and if you don't like the price of the extras, no-ones forcing them on anybody.
Having been a tutor, I know that $110/hr is exorbitant, and even the Pickaxe book is only $25. If the author can find enough suckers, more power to him, but I'm not one of them.
anybody remember red? https://github.com/jessesielaff/red/wiki
Check your email. Sorry about the delay!
This author is actually pretty good. It is worth it. I read his unix processes book.
I see what you did there...
The tutoring is an option. You can evaluate it separate from the ebook. I'd wager a guess, though, that if $29 is more than one is willing to pay for a well-written book, they're not the target demographic. I desperately wish there were more good code-heavy instructional materials on semi-advanced topics like these that didn't amount to a "fly here and pay me $4000" seminar/workshop/masterclass, and I'm happy to do what I can to support the people producing the few examples that exist.
Why would you name a framework teabag!? I lol'd @ "rake teabag myapp"
The likely difference between your tutoring rates, and jstorimer's rates, is that 1) You were not also selling the book, interview videos, and transcripts 2) You were not jstorimer, a well respected, well known rubyist who has garnered a lot of clout in the community. This is not hiring some schmuck off the street, it's more like a master class. I also imagine that the 279$ price point might be targeted towards small businesses who might want jstorimer to come down and train a small team in the content of the book.
Because programmers are often immature.
Pro: It looks nearly identical to Sinatra. Con: It looks nearly identical to Sinatra. What was the motivation behind Bonsai? Or better yet, why would I choose it over Sinatra? That would make a great section or link in the README.
Jasmine is a JS framework. Jasmine is also a tea, there is your naming history. Not everything comes from HALO
Including teabagging.
I agree it's an unfortunate choice, but I think it was intended to refer to the coffee/tea theme of JavaScript programs rather than the sexual term.
There's a discussion about it on [HN](https://news.ycombinator.com/item?id=5540796). They've uncovered some info based on his update.
The most interesting revelation from the HN thread is that the site appears to be hosted out of (or at least being mirrored by) this public github repo: https://github.com/cwales/cwales.github.com
In fact Im turning in one. (kidding) Thank you ruby.
I understand hash tables, but it was Googling your first answer that explained its use to me a little more. Thanks!
Here is one side of the many facets that are symbols. Ruby strings are modifiable. Modifiable strings come with pros (Can modify it simply) and cons (every string is separate, thus more memory). Some languages like Java don't allow you to modify strings. Ruby symbols are like strings, but they cannot be modified. Strings which cannot be modified have pros (:foo is and always is :foo, thus saving memory since the runtime never needs to worry about :foo not being :foo) and some cons (you can't modify :foo). What else does a symbol being unmodifiable grant you? Similar to the difference between == and .equal (object representation vs object contents). Comparing a symbol to another symbol is always constant time. For simplicity's sake, comparing a string to another string is a linear operation. Also, symbols have to_proc which is nifty.
I haven't kept up with the JavaScript test runners. How does Teabag differ from the others?
This is a nice [video](http://www.youtube.com/watch?v=mBXGBbEbXZY) explaining symbols.
Love it--was thinking along the same lines. Would .inspect be better, though? Some items don't give you the full output with .to_s
How does it compare to Sinatra and Cuba in terms of speed?
Fantastic. Learned a lot--thank you.
Anyone know how to get a view on those "HP PCL printer data" type files in the SPOOL directory?
Check the HN thread, they've got images pulled from them.
It finally clicked when I read "they are literal strings". In javascript you would write "this_is_my_string". In ruby you would write :this_is_my_string The only caveat is that it can't have spaces (of course).
I think the association with the coffee/tea theme is the "out" for the developer, but I suspect the intent was the innuendo. Less than a month after the Adria Richards fiasco, I'd have hoped that open source software developers would have shown a bit more tact... It gives all of us a bad name. 
Actually started building something similar in raw rack because sinatra was actually way more than i wanted. This looks like exactly what I need for a bare bones API service. Thanks! Edit: if you're still watching the thread, can you comment on how it cooperates with large numbers of unrelated threads?
&gt;The only caveat is that it can't have spaces Yes it can: 1.9.3p125 :005 &gt; :'this is a symbol'.class =&gt; Symbol Kind of counter-intuitive, but symbols can have just about any characters in them if you put them in quotes.
In IRB (sorry, mobile, please disregard my formatting) :foo.object_id :foo.object_id "Foo".object_id "Foo".object_id Yes, repeat both :). You'll get a number back for each line. This is an identifier ruby assigns to unique objects. You'll notice that the first two numbers are the same, and the last two are different. That's because :foo is always the same object, and those two strings are different objects. Symbols are usually faster for looking things up as a result (think hash table keys). Hope this helps!
*_why*? **What?!!** What a good day today is.
That was excellent. 
I'm the author. The gem name is html_validation and it is up on rubygems. It uses html tidy from W3C under the hood...
...k
&gt; What else does a symbol being unmodifiable grant you? Similar to the difference between == and .equal (object representation vs object contents). Comparing a symbol to another symbol is always constant time. Immutability is not enough for this. Strings are immutable in C# and Java, but still have O(n) comparison. To compare by pointer, they also need to be [interned](http://en.wikipedia.org/wiki/String_interning).
The literal answer: they are immutable, [interned](http://en.wikipedia.org/wiki/String_interning) bits of text. The Ruby VM (like many languages) has an internal data structure called a [symbol table](http://en.wikipedia.org/wiki/Symbol_table). It's a pool of strings with one key property: *any given string only occurs in it once.* A *symbol* is just a reference to a string in that pool. This seems like a random and arbitrary data structure, but it has a couple of consequences: 1. The strings must be immutable. Since every symbol is pointing to the same string, if you could change it, it would change all of them. 2. You can test equality of symbols just by comparing their pointers. Since you know a given string only occurs in the table once, if two symbols are the same string, they will be the same pointer. 3. They are created at *parse* time, not at runtime. When the interpreter is parsing your code, any symbol literals encountered will be added to the symbol table right then. This is why there is special syntax for them. 3. They are (usually) never garbage collected. Most language implementations never remove symbols from the symbol table. This means you wouldn't want to dump *every* string into your symbol table or bad things would happen. In most other languages, symbols and the symbol table are implementation details of the compiler or VM. Ruby just exposes the functionality to users. (Java does a tiny bit too, by having an `intern()` method on strings). You can think of them as lightweight, fast, string-like things. They have the user-friendliness of text, but the performance of a simple number.
Really, you want to infer on my behalf? [edit] The reason I think this is absolutely ridiculous is that it took you all of 10 seconds to write a message like this, when I've spent many hours on a project that I clearly take pride in. Read here https://github.com/modeset/teabag/issues/40
Yeah , I suppose that when the ruby interpreter sees a colon it treats the next token as a string literal and calls `intern` on it (or something equivalent) internally (heh). Anything inside quotes is considered a single token in this situation.
Strings are for data, Symbols are for concepts.
save.
Does anyone know what this means?
Baby is born: "class &lt;&lt; self"
The way you guys stalk this guy is fucking creepy.
So is the speed the main advantage? More particularly, let's go with the example of haml. Was the choice of using strings in %h1{:class =&gt; "header"} merely for the speed, or was there some other logical reason?
Aha! *This* is what I was looking for. This pretty much answers all my questions about the use of strings (see my reply to/u/munificent)
I think the easiest answer is that they are immutable strings and their value is their name. So, if you had a symbol *:my_symbol*, it's value would be *my_symbol* if you print it via *puts*, for example. Also, symbols are unique entities in a ruby program. If you use a symbol with the same name in two different places, it is actually the same object.
I'm not a real Rubyist, so I'm not the best person to ask. I believe they're idiomatic to use in cases where the string is conceptually a *name* for something, especially when the name is an identifier in some programming language. Here `:class` is an HTML attribute, so it's an identifier and it would be typical to use a symbol there.
Ironically it's likely that this kind of pathetic behavior motivated him to disappear
Summarized as "symbols are immutable."
I'm about to perform some benchmarks about this. Please look at the wiki in a few hours. I'll publish the results there.
Expanding on this, many languages (Pascal, C, Java, etc.) have a concept of enums. Ruby symbols can be seen as enum constants belonging to a global, implicit enum.
If you'd like a full explanation, you can see the video of my talk at cascadia: http://confreaks.com/videos/618-cascadiaruby2011-size-doesn-t-matter My slides are on my website.
I was writing ruby for a few years before this finally clicked. Symbols are just immutable strings. That's it. There's a couple extra little bits of technical info for them, but they're just immutable strings. Being immutable means that you can't append to them or modify them in any way. In order to do so, you must convert to a string (`#to_s`), then do your modification, then convert back into a symbol (`#intern` or `#to_sym`), but that creates a *brand new symbol*. The aforementioned technical bits of info are: 1. they are never garbage collected, so if you reference billions of different symbols, your process will eat up memory 2. any 2 symbols with the same value are the exact same object. This can be seen by calling `#object_id` as demonstrated up the thread. Because they're immutable, never garbage collected and all identical, using a symbol is less computationally intensive than referencing a string with the same value. The ruby process does not need to allocate memory, it simply does a lookup in its internal symbol table, finds it and assigns that value. The above are the primary reasons one sees symbols used as hash keys and to reference "things." (eg: using :pdf as a format parameter rather than 'pdf'). Also because it serves as a hint to someone reading the code that this value is special in some way and not some arbitrary value.
I'd read about the Rails exploit but didn't know it was related. Didn't read too much about it. I'm glad you brought this up, because I haven't read this as one of the disadvantages of using symbols.
Got it. 
Well first off, you can use ActiveRecord without Rails, so if you just need persistence, install the activerecord gem and move forward. Otherwise: What are you trying to learn here? You could use a variety of methods to store data for later (relational database, flat file, nosql database, etc)
&gt; The database doesn't have to be present after the program ends In that case you don't really need ActiveRecord; you could possibly use ActiveModel to get some of that Railsy magic without using persistance, but pure Ruby classes would be more efficient, and more elegant. 
This seems like the way to go. Instead of looking into premade classes or gems, doing some research on data structures and making your own is the best way to learn. And in this case it doesn't sound like you'll need any super complicated data structures.
You can have two immutable strings with Object#freeze. Symbols are never a different object for the same value. One other thing. Immutable strings can get gc'd. Symbols and certain classes of integers will exist for the lifetime of the interpreter.
They are different than immutable strings: mutating them always creates a new object. See my other comment on how to create actual immutable strings and other objects.
Yeah, this is spot on.
You *could* use active record, but it's too bloated and tied to rails. Try [Sequel](http://sequel.rubyforge.org/) or [DataMapper](http://datamapper.org/)
This is similar to my current setup minus having a class for the user I didn't see a need for one. (Not going to be web based)
You have several globals in the repo. The one I imagine you're talking about is $courses. Turn $courses into a variable inside the appropriate class that manages courses, then add an accessor method to that class. If you don't want to instantiate an instance of the class in some other file in order to retrieve the courses, make it a class method. However, be aware that class methods all other people access into some piece of your code without calling the constructor first. As you're returning a collection of courses, this might be bad in some cases.
I see what you are getting at with the accessing of the global variable. The $courses is only there so i could look at a display with info that was inputted (I was pushing the info to an array). The problem I am having is that I am unable to access information from the instantiated class after the user finishes inputting multiple courses. Essentially, it would be ideal if each class instantiated would have an incrementing ID for ease of access. I just don't know what this is called and so I have not been able to Google it. It almost seems as if my app needs a temp DB but I feel like there is probably a better way and I just don't know what that is.
Thank you very much. The structure you guys both explained now makes significantly more sense to how and why it is a good setup. You really explained out what was going on and reasons on why/how to really separate the problem out. Really appreciate you taking the time to explain things out to me and also explaining the philosophy behind the choices you made. This community really earns its reputation for being friendly. :)
Will do. Going to take a step back and essentially re-look at my overall program and separate it out into the self contained classes and objects to have it follow the correct philosophy(and make more sense). And the gold is the least I can do. Kindness is priceless and you really took the extra time which improved my understanding of the subject of OOP/OOD. 
Hmm, I think that's a weird way to think about it. We certainly still use string literals in ruby, it's not true that you always use symbols instead of string literals in ruby. I think longoverdue does better above, "Strings are for data, Symbols are for concepts." 
There's a good discussion on [this issue from betterspecs](https://github.com/andreareginato/betterspecs/issues/15) as to whether this is a good idea -- but if you're on the side that specs should not begin with "should", check out my new gem!
There are so many good Ruby developers doing interesting things out there. What is with this pathetic hero worship of one particular person?
I have no idea how you would get the original structure into the derivative structure programatically without seeding it an additional construct representing the rearrangement. They are not equivalent and so you will need to solve the problem specifically, not generally. 
check this out - http://stackoverflow.com/questions/1230741/convert-a-nokogiri-document-to-a-ruby-hash
So if I understand correctly, you want to group the set of &lt;item&gt;s based on the text in their &lt;subitem1&gt; elements. If that's the case, then you should probably just iterate over the &lt;item&gt; elements directly. Something like: myhash = {} doc.elements.each('xml/item') do |i| si1, others = i.elements.partition{|e| e.name == 'subitem1'} (myhash[si1.first.text] ||= []) &lt;&lt; Hash[others.map{|e| [e.name, e.text]}] end (this could be written a lot clearer of course)
Unfortunately I have no control over the structure, it's from an external source but it will always be the same. I understand the XML structure is a bit "dirty" but that's the set I've been given. there are indeed multiple &lt;items&gt; in the dataset (it's a proprietary dataset with sensitive data, so I can't post the actual dataset) As for why the subitems are named without an attribute, your guess is as good as mine. I'm happy to restructure the data into a ruby-friendly format, as I said I'm just starting to learn here so my terminology might be a bit..off
This is almost exactly what I was thinking. Not a super hard problem in the slightest. The only real problem is that he doesn't tell us if the structure is 100% predictable. If every listing is going to be a child under &lt;item&gt;, that's fine. If we're trying to build a hash out of all name-text pairs, that's different. We're also assuming here that text bits won't be interrupted by other nodes. 
This is absolutely perfect, thanksyou! Is there any chance at all that you could break down what is happening in this lines? I kinda has an idea, but some of it is a bit confusing. si1, others = i.elements.partition{|e| e.name == 'subitem1'} (myhash[si1.first.text] ||= []) &lt;&lt; Hash[others.map{|e| [e.name, e.text]}] 
I read the comments and blog posts from the issue you linked. I was sure the opinions would be mixed, as I think this is mostly a matter of taste. While I can see how this would make some developers happy, I can also see how it would piss a lot of them off. And using this in an existing code base, would give the developers a bit more work. (changing to a good desc that does not contain the word should) Could you please tell me an advantage that could justify that change? From the client's perspective, that doesn't provide too much value..
A truly fantastic explanation, thankyou!
Certainly more useful than your comment.
Very nice! A quick critique: d3js supports a number of [color scales](https://github.com/mbostock/d3/wiki/Ordinal-Scales) that are better for visualization than [rainbows](http://blog.visual.ly/rainbow-color-scales/). I think your visualization would be improved if you switched to one of them.
Oh, snap!
This is a great question, I really enjoyed reading this.
It's more of a coding standard than anything else. It has about the same value as any other tool you might use to enforce a coding standard, albeit more focused. So if you have a tool that enforces you to code in a particular style and it ends developers mulling over whether you should do A or B, I would argue that it has a small value to the client. I'm sure some people will disagree with me on that point, but nobody is being forced to use `should_not`.
I really don't understand why Rubymine doesn't get more love from the community. I'm the only person I know of my friends that code ruby/rails that actually uses an ide. Feels like I'm the only one not infatuated with Textmate. I've nothing against Textmate and I actually use it for basic text stuff sometimes... but for my rails projects I use Rubymine extensively.
I fell in love with ruby/rails. It just got that much better when I got my hands on rubymine. All rails command line methods are available, git integration is fantastic. Even the little stuff like it alerting you when you have used a translation symbol that hasn't been put into the local file make it super convenient. 
Rubymine is popular at our office. It's very hard to use anything else once you get spoiled by it's features. 
Textmate is not even that widely used anymore...everyone I know uses either Sublime Text 2 or VIM (me included).
I believe it has just done been broughten.
I'm thinking the same thing. RubyMine is a lot smoother and feature-rich (without needing tons of plug-ins, etc.). I also feel like it's highly underrated.
Sublime Text 2 is also awesome (I use it a lot), but I honestly feel like RubyMine is much better for Ruby development. There's no need for plug-ins/addons and the IDEs feature set is tailored for Ruby; it "just works out of the box."
Does IDEA actually support everything from RubyMine and all features of the other JetBrains IDEs? I'm currently using RubyMine and AppCode myself, so maybe it would be worth it to switch to IDEA, just to have it all in one place.
Highly recommend. Bought it back in Jan and haven't looked back. I've made a horrible keymap that's a mix of emacs, osx and whatever defaults where originally there, but despite that, its still quite useable.
I tried it on Ubuntu and can't stand it. Font rendering was horrendous, it was slow, kept showing all kinds of messages I didn't care about, some features were just not working and it completely sucked at code navigation and syntax completion (although I didn't expect any better with a dynamic language). I guess I've just been spoiled with Visual Studio for so long.
As far as I know, it supports adding plugins for all of the other ides (they are just skimmed down versions of idea). I know for certain that the Ruby and Python plugins are there.
AppCode and the c# thing are not included in idea because they are not cross platform I guess. Idea can do all others like python, ruby, php, node but it's a bit more complicated to set up the projects
Rubymine is great. Nothing wrong with Rubymine except that many of the stock key combos don't provide a lot of keyboard-only means of navigation. And extending it with plugins and the like is more opaque than it would be with Vim or Emacs. The benefits it provides over those two (and Sublime et al.) are substantial, though. But you can throw in some Emacsy or Vimmy keybindings on top of it, probably.
I think you're overengineering this very simple task. this little peace of code fetches events with corresponding times (works for me): require 'open-uri' require 'nokogiri' html = open("http://www.nga.gov/programs/calendar/cal2013-04_w16.shtm").read document = Nokogiri::HTML(html) document.css('.coe-list').map { |x| [x.css('.time').text, x.css('.event').text] }
Jumped on RubyMine during their end of the world sale in December, and it's been great. It is chunkier than it's text editor cousins (TextMate, Sublime), but well worth it. Great git integration, gem and rvm aware, even got an upgrade to 5 when that came out. For anything other than a small tweak, it's my go-to. 
My real goal is a content aggregating "upcoming events" kind of website, so I'd like the event links to be tagged with dates and times so I can display them correctly alongside events form other sources. I'm using curb so I can follow the redirect to the current event listing, and the long function is trying to do stuff like "take all the events between two consecutive date headers and tag them with that date". I'm open to a more concise way to achieve this!
Yep. The other IDE feature sets are all plugins.
The content headers on the page: http://www.nga.gov/programs/calendar/cal2013-04_w16.shtm Indicate that it's already in utf-8: "Content-Type:text/html; charset=UTF-8". So you don't want to force the encoding to ISO-8859-1. 
**Up to** 50% off. Since the site currently lists a discount of 40%... (Normally $100, now $60)
I noticed that too. On the site it says up to, but the headline here deff did not.
That's pretty nice! Wasn't aware of that.
yay moar tickets
Okay, encoding problems are really confusing. Really, you have to figure out what's really going on. Is it _really_ in ISO-8859, but it's being false advertised as UTF-8? Etc. That is, is there a bug in the upstream content provider? But, okay, bad data happens. Let's say it's being advertised as UTF-8. And 99% of the time the data really is UTF-8. But occasionally, there is a byte that is illegal for UTF-8, because of bad data coming from the upstream content provider -- maybe because of bad data coming from _their_ upstream content provider(s) that they haven't properly detected/sanitized. Okay, bad data happens. If you open up a UTF-8 file that has some bad bytes illegal for UTF-8 in a word processor or editor, what usually happens? Usually you see the bad bytes replaced by a little question mark icon (likely the Unicode Replacement Character) -- rather than have the word processor simply crash, or give you a message "I can't show you any of that file, it has a bad byte in it!" You can do that too, in ruby, although it's under-documented how, and took me a while to notice it! some_string.encoding # =&gt; assume it's already marked UTF-8, but has bad bytes str.encode!( "UTF-8", "binary", :invalid =&gt; :replace, :undef =&gt; :replace) # Or, that is, encode to whatever it already is, replacing bad bytes for # that encoding: str.encode!( str.encoding, "binary", :invalid =&gt; :replace, :undef =&gt; :replace) That will replace all 'bad bytes' illegal for UTF-8 with the unicode replacement char. that second argument `"binary"` is key to making `encode` do what you want, instead of just doing nothing because the string was already in UTF8. Want to replace it with your own substitution string instead, like an ascii question mark? Or replace it with the empty string to simply delete it entirely? Sure. str.encode!( str.encoding, "binary", :invalid =&gt; :replace, :undef =&gt; :replace, :replace =&gt; "?") This is little known, under-documented, most people (including in this thread) will insist that why would you ever want to do something like this anyway... But I have to do this all the time too, because sometimes the upstream content has problems in it like this, and you've got to make the best of it. **Note** This is not really a nokogiri problem, it doesn't have much to do with nokogiri. Or at least, that's how I'm interpreting it/assuming. You want to remove these bad bytes before nokogiri ever touches anything. it's a ruby 1.9 issue, where if a string is tagged UTF-8, but has illegal bytes in it, all _kinds_ of operations on the string will end up complaining. Ruby 1.9 needs legal encodings. You can also check if a string has any illegal-for-it's-encoding bytes in it with `some_string.valid_encoding?`
Ah, thanks, I guess I was just hoping it was a known glitch that could be solved by a magic spell.
I'm a little late to the party, but here's how you might use ActiveRecord to model your gpa calculator: https://gist.github.com/benolee/bc1ac4df35cc3fba0e08
Thanks for your informative response! Your suggested incantation did the trick. The reason I thought this might be a problem in Nokogiri is that the string returned from by the Curl object doesn't have have any invalid characters. It seems that the invalid characters are being returned by the call to Nokogiri::XML::Node#text. Based on the position of the invalid characters, I wonder if the \&amp;nbsp; is being mangled somehow. Edit: So it looks like the problem was that ruby doesn't add a byte-order mark to the files it creates, so when I later read the created file back in it was treated as ASCII. I'll add some more info in an edit to the main post. 
Based on the way I looked at this (and correct me if I'm wrong), if I was using the command line I would need to manually have to remember the variables and required input. However, this would make for an easy way to transition this app into a web application (which is a likely way for this to go). I do like how utilizing active record provides easy validation of an input of all the variables required by each course as well as an easy way of viewing the relationship between course and student. Thanks for the input on this. And the cool kids always show up fashionably late to the party :D
An interesting gem, fun name, plenty of possible use cases... and of course HN rips it apart. What a bunch of sad bastards.
The latest message says: "This thing will open in two days. Which means it isn't open right now. Sorry, it just isn't." So the good news is that in some form or shape _why is coming back. Right?
For those who don't bother to click through, it's the standard "sex vs. gender" thing, plus some low-probability mistakes.
You do NOT need a byte order mark in UTF-8. See [[1](http://www.unicode.org/faq/utf_bom.html#bom5)] [[2](http://en.wikipedia.org/wiki/Byte_order_mark#cite_note-3)] It is _not_ a problem that whatever tools or libraries you are using in ruby do not add one, if you are outputting UTF-8. UTF8 does not require a BOM, a BOM is not recommended for UTF8, and in some contexts a BOM can cause problems in UTF8. If you have some (mis-behaving) software that requires it, you certainly can add it yourself though. But if you are suggesting that when you read the file back into _your ruby code_ it was "treated as ascii" -- that's got nothing to do with a BOM. Ruby stdlib does not use the presence of a BOM to determine encoding. I still completely don't understand your problem, don't really understand what's going on, but glad you are making progress. Character encoding issues are confusing, the key is to understand the basics, and figure out exactly what point the encoding corruption is coming from (unless it's coming from an upstream system already corrupted). Also, if you are working in ruby, as you are, it's really helpful to understand, generically, how ruby 1.9 deals with character encoding. There are a variety of tutorials and primers if you google for em. [here's](http://nuclearsquid.com/writings/ruby-1-9-encodings/) one. Whether or not you are working in ruby, it's helpful to have the basics of character encodings as a concept ; I find [this](http://kunststube.net/encoding/) article helpful. 
What do you expect. Its like the worst of /r/programming. If it aint haskell or python, you can bet they're going to shit all over it
 &amp;nbsp; is not a unicode sequence. It's a HTML escape for non-breaking space and 100% ASCII. You may very well have had unicode in the file, but that wasn't it.
Here's the program _why wrote out in the HOMEWORK file: https://github.com/iandennismiller/cwales.github.com/blob/master/just_let_this_sit.ml It's an OCaml program that polls his website's SPOOL file, then sends the .PCL directly to a printer.
_why's HOMEWORK file (see http://www.scribd.com/doc/135658986/-why-Homework) contains a handwritten OCaml program. It's actually partially in cursive, which is really hard to read. I may have made typos, but I typed it up and made some installation notes. I know this is /r/ruby, and _why definitely wrote the script in OCaml, but this is almost certainly the correct subreddit for it. 
Thank you for doing this! 
So is _why becoming active again? 
My pleasure. I'm travelling tomorrow so I am not sure if I'll be able to participate. I wanted to make sure this code was out there so other people could record whatever happens.
For certain definitions of "active," definitely. I think it's really interesting that he's intentionally using unpopular, difficult, or unexpected methods of communicating right now. Like bitcoin, it's a proof-of-work system that requires some active participation from the reader in order to decode PCL, transcribe from cursive, and install/execute an OCaml script.
Meh, I don't have the patience for this guy...if you have something to say, just say it.
Because he's a smart guy who contributed a lot to the community. And everybody likes a riddle.
bingo - shit is fun!
Because he taught Ruby to a lot of us. 
I was under the impression that he had died!
This. _why's guide to Ruby is still the best beginner's book to any computer language that I've ever read. I really hope he's coming back.
People seem to not like your question here and while I totally understand their disapproval I do think they missing the point. _why did peace out unexpectedly much to the chagrin of other prominent people in the tech world. Some people were very pissed that he just vanished and took some of his work with him seeing as he was part of a community that was building something. You are right. The community has done fine without him. The community has almost done fine despite him. Hopefully, if he comes back he sticks around and continues to make awesome contributions. And that's why it matters. In the past he made big contributions and people are hoping for more of the same in the future.
so has he dropped ruby for OCaml? I have only ever associated him with Ruby. 
I do have patience for the guy, and I'd rather he not just say it.
Perhaps he's merely added OCaml programming to his skill set. Most experienced software developers can write code in multiple programming languages.
I figured he knew more than one language...I was just wondering if this "comeback" is not a comeback to the ruby community. Maybe I've fallen victim to the curse of speculating about him...but the use of OCaml seems to be a statement by itself.
_why is one of the founding members of the ruby community. he popularized ruby with many people (including me) who then went on to evangelize ruby to others (as i have done). his contributions to the community have been immense, not just in terms of teaching people the language but also in communicating a proper sense of light-heartedness that makes ruby programming FUN (as programming should be). he had a lot of influential and interesting stuff to say before he vanished. it is reasonable to assume he will have influential and interesting stuff to say when he returns. even if he doesn't, when he pops his head up, that's a good time for some thankful applause.
You're right, and I think it's fucking hilarious. I hope he goes to conventions again before I get too old. He's pretty brilliant, and I'd love to thank him for _why's Poignant Guide in person. 
When you are reading a file in ruby (whether it's a file you created or a file someone else created), you need to tell ruby what the encoding is, if it's not ascii. You can set it as an app-wide default to be UTF-8, or you can set it in every File.open. Some of the links I provided, or other things you can find on Google, will tell you how to do these things. but I see you figured it out yourself on your line 10. So all good? A BOM won't help, ruby won't auto-detect encodings using a BOM, and it's not generally recommended to include a BOM in UTF-8. Whether nokogiri touched the file doesn't matter. Whether you originally created the file yourself doesn't matter. Any file you open that's not binary or ASCII, you need to tell ruby what the encoding is, either when you open it, or as an app-wide default.
Actually, he turned me on to IOLanguage a couple of years back after his post http://web.archive.org/web/20080212010904/http://hackety.org/2008/01/05/ioHasAVeryCleanMirror.html And I also remember him making some posts about this language he was working on entitled: potion https://github.com/fogus/potion Actually, come to think of it, on numerous occasions, he would refer to other languages. His site was practically my home page
Could: "come on give me a push here." Be asking people to show that he's wanted back?
I love how they are selling a Rails project, yet the extension on a lot of their pages is .jsp.
I share the same sentiments. I came into the ruby community after he left, and was curious to see what he did. The wikipedia page listed several projects he worked on, most of which are dead or obsolete
Has anyone else bought this today? I just purchased it but never got a license key email. EDIT: It finally came, email jobs must be backed up. cheers =)
there are some gdb macros in ruby's repository https://github.com/ruby/ruby/blob/v2_0_0_0/.gdbinit that work well there's also a make target for gdb but i was apparently missing deps and didn't feel like spending time on it https://github.com/ruby/ruby/blob/v2_0_0_0/common.mk#L990-L994 also, your use-case of inspecting a live process without needing to actually modify its memory sounds like you'd want https://github.com/tmm1/rbtrace
Fun. I love ruby.... but one of the things I love about Ruby is how it shamelessly has borrowed (stolen) many excellent ideas from other languages! Public Print Queue SPOOL/PRESENTLY 2013-04-16T23:04Z SPOOL/LEVELS 2013-04-17T13:46Z This is currently what is on http://whytheluckystiff.net/ Curiously he still has the content type as text/html even though this clearly isn't... I haven't a clue about OCaml so here are some wild arsed guesses.... The "q ....." looks vaguely reminiscent of lispish (quote ...) ie. Don't evaluated it, this is just a chunk of data that I may choose to evaluate later. The stuff taken from the server is newline and tab seperated hence the regex match on "\t"
"lp -o raw -d " ^ private_press ^ " _tmp" Hmm. scaryish.... print file where? -d destination Prints files to the named printer. print file to printer H12230?
Google nyman - minimalist composer. Google ocaml nyman - Get ocaml forum post spam packed with spam filter evading junk.
Eh. No. q doesn't seem to be quote, looks more like plain common or garden function parameter
How timely. I've been checking out OCaml lately.
I have no idea what this thread is about.
Damn. Googling for "Public Print Queue" turns up hundreds of hits.... on people trying to figure out _why's puzzle. I was hoping for something on CUPS / print spooler internals.
_why wanted to be left alone. Why are we still stalking him? How is this relevant to Rubyists?
I totally needed something like this a year ago. I was trying to go from `"Firstname Lastname"` to `"(Mr.|Ms.) Lastname"`.
Because he made a new web page.
How do you know iandennismiller or cwales is _why? Still, why should Rubyists care about a potential _why sighting?
&gt; How do you know iandennismiller or cwales is _why? I don't. &gt; Still, why should Rubyists care about a potential _why sighting? Because he contributed to the community.
It seems that nokogiri converts \\&amp;nbsp; to \\u00A0 when they appear in a utf-8 encoded file. I posted an irb transcript in my discussion with jrochkind.
A bit of a more simplified way of looking at it... A symbol is like a variable that cannot be equal to anything but itself. This is very useful because of its immutability property. You know that :red will always be :red, and that unlike a string it cannot be manipulated in any way to return something other than :red.
link?
 if line.match(/\d+:\d+:\d+/) #parse the line else #gtfo end
I &lt;3 \_why, but he wasn't a great programmer. He's inventive, challenged people to do what needed to be done, but his code was pretty awful. That's okay though, that wasn't \_why's greatest contribution. \_why's contribution was making Ruby look friendly, when the biggest faces on Ruby were DHH and \_why, \_why was the reason people weren't scared to do Ruby. DHH is a polarizing figure, he's got a lot of opinions, and not a lot of room to be convinced. That's what you need if you're going to manage an OSS project at the scale of rails, but it's not exactly a welcoming personality. \_why was _friendly_ -- his code may not have been great, but he presented an aire of "Why not try this out, I'd bet you could do it, you're awesome, ruby's awesome, why not ruby?" It's that sort of personality that pulls in new talent into a community. I imagine many of the older Rubyists can trace what drew them to ruby to something \_why did or said, but look now -- virtually none of his code survives, much of it being whole-sale replaced by a fresh codebase. Look back at hpricot, or early versions of Shoes (before Klabnik got a hold of it and started ripping out portions and restructuring them). \_why is a bit like Frank Lloyd Wright -- Look at *fallingwater*, beautiful house, amazing example of what the Modern style of architecture can do. But it's a maintainence _nightmare_. It's been restructured a dozen dozen times, it's better called *fallingdown*. But we still hold it up as an iconic example of Wright's brilliance. Many of Wright's buildings are this way, and the ones that aren't, aren't quite as iconic. What made Wright great was that he was a visionary, a brilliant man who dared to try, he had no inhibitions when it came to design. That sort of mind draws engineers to it. Engineering is precisely the opposite of what Wright did. Wright put in whimsy, art, and flair and made buildings beautiful. Engineers make buildings strong, stable, and easy to maintain. They find ways to bend the laws of physics to their will. \_why attracted engineers to his projects. He used his vision to pull in people who could realize his vision and others. He is (one of) our Franks Lloyd Wright. He's a visionary who pointed the way, painted the picture, and pushed the boundaries of what we thought was possible with ruby. In short, it wasn't his code that mattered, it was his ideas, his pioneering spirit, and his personality.
* Dirty method: Wrap Time.parse() in a begin/rescue/end block. * Cleaner method: If you have a consistent time format (and I hope you do!), do a regexp check on the line for the time pattern (e,g, =~ /\^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d/ )
 lines.each do |line| time = Time.parse(line) rescue next # DO STUFF end
This worked. Thank you very much. 
Yeah - you're definitely on the right track about the regex parsing stuff. Speculating, what kind of input do you think be suitable, given the other stuff already known about the content that has been available at whytheluckystiff.net/index.html? In other words, what sort of data or content do you think a tab/newline delimited file lends itself to?
_why wrote http://mislav.uniqpath.com/poignant-guide/ which is where a lot of people got their start in ruby. He was also one of the early big contributors to Ruby projects.
&gt; I didn't think anybody was pissed _why took a large corpus of his work offline, suddenly, in an era just prior to totally ubiquitous github forks. It was annoying to have to restore the things that people were using, like the *Poignant Guide* and Hpricot and hacketyhack. See a little more at http://whymirror.github.io/ 
Very cool!
I recommend it but with qualifications. I'm one of those for whom his book did nothing for me. The cartoons and little narrations actually got in the way of me trying to understand the material. In the end, I lost patience and tried other sources to learn ruby. So, I do point people to the book, but I always say that while it's hugely popular, it's not for everybody.
Can anyone explain this?
Thanks a lot!
As far as I can tell he setup a 'print spooler' of sorts and is effectively printing some novel or writing of some kind to the internet one page at a time. _why is a crazy man, and this is pretty awesome.
It's a serious rabbit hole he's created. Just look at the stuff people are finding: https://news.ycombinator.com/item?id=5572743
yeah.. was looking at that site figured out that gif last nite. couldn't find any clues about anything on it... oddly enough, the first time i clicked on thdvl.com the site didn't come up
I for one would be interested in reading it (I have emailed you about it too). I would like to see a combination of common tasks that could be automated, examples of where you can greatly reduce the complexity of bash scripts that perform the same thing and maybe some stuff that ruby allows you to do that you wouldn't have considered with a bash script.
Thanks for the feedback! When ou say reduce complexity, do you mean increase readability? As in you're looking for more elegant solutions?
In a pull request by _why for _why, [here](https://github.com/cwales/cwales.github.com/pull/3), I found the commit notes: thdvl opened this pull request 5 days ago i am available did you ever read fravia's websites? I'm assuming he's talking about this?: http://www.woodmann.com/fravia/ (thdvl is _why, and he appears to be using multiple accounts to interact with himself) If you go to thdvl.com you get redirected to http://celebsbukkake.com/thdvl/ (I know the link looks worrying, but it's sfw). I noticed that if you go on https://github.com/thdvl, it says "how do i contact you"
fravia was awesome. Didn't he threaten to remove all his archives from other peoples hosts? Like, I seem to recall that he implicitly threatened to hack into other peoples boxes if that was what it took to remove archives of his work.
Absolutely. The next books I always recommend are the Well Grounded Rubyist - then Metaprogramming Ruby
Several years ago I adopted [an imgur rubygem](https://github.com/xiongchiamiov/limgur) from someone else, fixed a few bugs and added a few features; I haven't kept it up because imgur changed their ToS and banned my particular usage. It is MIT-licensed, just as yours is, so feel free to take a look and incorporate anything of value into your project.
I installed vim-ruby a while back, but I started with a simple .vimrc: set smartindent set tabstop=2 set shiftwidth=2 syntax on
I only took a brief look, but it looks great! Good job!
Here's mine. https://github.com/docwhat/homedir-vim/blob/master/vimrc/.vimrc I set it up to auto install vundle and get you running. Even with older versions of vim. Tho I recommend the latest. 
I use Ruby pretty much every damn day in my job as a sysadmin; I'd love to read drafts as you go and provide feedback. Should I put my email in the "I want to read this" box?
Yes, I'll periodically update the list with progress and info along the way. Any particular uses or tasks you want to see?
I found this [dropbox link](https://www.dropbox.com/sh/r9m1nlo4c7i7umf/cpUb9PU6pJ) on HN, it's updated regularly and the documents are nicely organized into separate folders. Hopefully someone will find it useful.
My favorite key-mappings: 1) set mapleader to the spacebar 2) set escape to jj 3) (not quite vim related, but) remap capslock to control.
I just switched to Vundle at the advice of thoughtbot and already prefer it to Pathogen.
I guess a mixture of more elegant, readable solutions to well established problems and also reducing the complexity of the general administrator workflow (creating users, handling permissions, things like that.)
if your development machine has some juice under the hood (oh god), make sure to check out this guys vim distro =&gt; https://github.com/spf13/spf13-vim
Maybe he's arrested or something and this is his only way to communicate to the internets. That would also explain his sudden disappearance. 
Vundle looks like a really promising project but have you looked at [VAM](https://github.com/MarcWeber/vim-addon-manager)? It's mature, well maintained, and unlike Vundle it will take care of dependencies when installing packages.
Vundle already *is* a great project. It all depends how much you like your vim plugins managed. Especially since vim plugins hardly ever have internel dependencies on other plugins, sometimes VAM seems like a little overkill. Pathogen leaves absolutely everything manual, you do your own updating. Vundle at least lets you update stuff, which is often all people need.
`jj` = `esc`.
Yeah, I wasn't meaning to put down Vundle. It's a great addition to the vim community. I'm just amazed sometimes at how little attention VAM gets when it's a damn good package manger.
I see you've got a section for Puppet. I'd also mention Chef - if you're focusing on the Ruby part, Chef makes better use of the Ruby language than Puppet does. (Although they're both fantastic products) Also, it's useful to be able to use Ruby when extending things like Nagios or Zabbix for monitoring - both can call external scripts to report status updates.
I've never heard of that, and it doesn't seem like the type of thing he'd do / want to do.
I use 'jj' too, but I do not recommend. I've considered trying out some IDE's with vim plugin-ins and most of them make it impossible to properly map jj to esc which means I never actually try the IDE to see if I like it better. So now I use vim without knowing if there is a better match out there simply because if it doesn't have 'jj' - I'm not using it. 
I've been using Vundle for quite a while now. It really beats out using git submodules (which are a huge pain to update) or manually with pathogen.
Exactly what I would add. More things: ruby system wide installs with rvm / rbenv. Using ruby from cron (w/ rvm/rbenv) and in shell scripts.
Good stuff - I agree (mostly) - I honestly don't like rvm for production servers - I'd rather either build packages or pull from a community repo to ensure consistency and not have to put a build environment on the box.
Okay, I suck at algorithms. Could anyone explain the principal behind memoization to me like I'm five? I looked at the wikipedia article for it, but I'm still lost on concept.
And my [.vimrc](https://github.com/bobbyrward/dotfiles/blob/master/.vimrc)
Tim Pope.
Agreed, chef basiclly runs it's recipes as ruby files. Puppet is more python light. Writing nagios checks via ruby instead of say bash, would also be a great addition.
Try 'xcape' - https://github.com/alols/xcape Linux utility to make control key send escape key events when pressed on its own. 
For adequately large numbers, memoization saves loads of time, especially in recursive functions. Why? Because you don't recalculate values you've already calculated. An example will help. Assume you want to calculate the 100th Fibonacci number with the following recursive method. def fib(n) return n if n &lt; 2 return fib(n - 1) + fib(n - 2) end We start with 100 and immediately branch into two recursive calls: 1a) fib(99) and 1b) fib(98). So far so good. In the call to fib(99), we branch into two more recursive calls: 2a) fib(98) and 2b) fib(97). In the call to fib(98), we branch into two more recursive calls: 2c) fib(97) and 2d) fib(96). Do you see how we're wasting time by recalculating values (e.g., 1b and 2a; 2b and 2c)? If we use memoization, before we even calculate a value, we ask our memo, have we already calculated this Fibonacci number? If so, tell me the result. Otherwise, go calculate it and save the result in the memo. This takes out all the wasteful recalculation and speeds up our recursive method considerably.
Alright, that makes perfect sense. I think part of my confusion stemmed from my inexperience with dynamic method assignments. I appreciate the explanation. The memory used memoizing should be smaller than its non-memoized counterpart as well, shouldn't it?
I use NerdTree to open new buffers without :cd/ls/e-ing myself crazy. Can't live without it.
I was using the pivotal `vim-config` for a long time (we worked out of the NYC Pivotal Labs for a while and I got used to it), but started getting fed up with some missing things and some limitations, so I forked their repo, learned some vimscript and started making changes It uses Pathogen (which is AWESOME), so adding new plugins is a breeze. This is my current incarnation with a lot of changes to support vim in a terminal (as opposed to macvim) and to work on platforms other than OSX: https://github.com/spikegrobstein/vim-config I think some of the big things I can't live without are `ctrl-h,j,k,l` for moving the cursor between panes, ctrl-t for creating a tab, spacebar for clearing the highlighted text, the command-t plugin (I wasn't a fan of the ctrl-p one) and NERDCommenter. I have to say that the more I used vim, the less I wanted the NERDTree plugin. I've grown to despise it and I don't even know why. Maybe it was just too buggy for my tastes.
Ruby gems has a nice guide too: http://guides.rubygems.org/make-your-own-gem/
Interesting. I'll have to play with the memoize module some. If it can't handle bigger numbers, it's almost useless. :-)
I spent lots of time writing unit tests, which after awhile begins to feel pretty natural. The next step is trying to write integration tests with capybara. That part is a little harder since you have to visualize your app one page at a time.
This is one of the craziest things I've read in a long time, but I love it. I can't stop thinking about it.
If you like this, go back and read _why's code. A few people have approached code itself as a medium of artistic expression, but none have captured the imagination like _why did.
For RSpec, specifically - To learn the best practices for syntax, read [Better Specs](http://betterspecs.org). Most of what's in it is int he Rspec book, but it's condensed down. - When running specs, it's immensely important that you can debug properly. Throw '[pry](http://pryrepl.org)' into your Gemfile, and put in 'binding.pry' either from your specs, or in the code they're testing. Run 'ls' on your current context and other methods/objects, and use $ to inspect the source of them if it helps. Check the [railscast](http://railscasts.com/episodes/280-pry-with-rails) for more help. - Peepcode re-did their [rspec videos](https://peepcode.com/products/rspec-i) within the last year. I haven't watched the revised editions, but it should easily walk you through the important points. - Read through the [official documentation](https://www.relishapp.com/rspec/). - Skim the [rspec source code], especially after digging into it with pry. However, your problem probably isn't just learning rspec; it's learning how to test, period. Writing any tests is hard, and it's a long climb to learn what's worth testing, in how much detail, crossing which boundaries (i.e. mock or not?), avoiding stupid regressions, and keeping the whole test suite running quickly. You'll probably need to re-learn the patterns you use for your main implementation too. Messy code is much more difficult to test than clean code. One of the reasons people advocate for TDD is that it forces you to write code that's less coupled because it's easier to get through the tests that way. You may also want to read [Growing Object-Oriented Software, Guided by Tests](http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627) or check out some more testing talks on [confreaks](http://confreaks.com) Really though, just dive in, make the mistakes, and be prepared for some gradual learning. Just make sure that you don't make yourself frustrated and abandon running and writing them. Start now with the easy stuff, like easy [smoke tests](http://en.wikipedia.org/wiki/Smoke_test#Software_development) before building out to testing the harder details. Don't bite off more than you can chew your first time project; you can probably do without fretting over test performance, and mocking, etc until you're more comfortable.
http://mislav.uniqpath.com/poignant-guide/
Great point about Puppet vs Chef. I will update the page with the feedback here that I plan to add. Anything specific about Chef that you're interested in?
The ONLY way to learn ruby (that includes bacon).
Great idea with Ruby and Nagios, I'll add it to the list!
At first glance, this sounds like an incredibly stupid idea. However, in apps with a lot of gems (and therefore a very long loadpath), this strategy has a depressingly significant effect. EDIT: Weird that this wasn't implemented by means of a `require` monkeypatch.
For actually learning ruby, I found this book helpful: http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/0596516177
Does this include bacon?
I use Ruby as a thin wrapper around shell commands I've already started making - that is, I use it as a Perl. The ease of execing commands and getting their output as a string, combined with the convenience of having regular expressions so baked-in, means that doing things like [this](http://itbrokeand.ifixit.com/2012/08/16/simple-apache-access-log-analysis.html) a lot easier than doing them purely in shell or in something like Python. Now, whether you want to encourage that kind of behavior is another thing altogether - many people seem to believe that you should start out writing the whole thing in Ruby, or rewrite the components in Ruby, instead of having an unholy mash of Ruby and shell. Your choice. :)
How is this relevant to /r/ruby?
[_Why's wikipedia page](http://en.wikipedia.org/wiki/Why_the_lucky_stiff) has links to most of his notable projects. Shoes and Camping are both maintained, but you can check out the original versions to see his personal contributions. 
" My Bundles Bundle 'Align' Bundle 'L9' Bundle 'Lokaltog/vim-easymotion' Bundle 'Lokaltog/vim-powerline' Bundle 'Yggdroot/indentLine' Bundle 'Rykka/colorv.vim' Bundle 'Shougo/neocomplcache' Bundle 'SuperTab' **Bundle 'Syntastic' ------ Syntax checker** Bundle 'Tabular' Bundle 'Tagbar' Bundle 'The-NERD-Commenter' Bundle 'The-NERD-tree' Bundle 'altercation/vim-colors-solarized' Bundle 'bitc/vim-bad-whitespace' Bundle 'chrisbra/histwin.vim' Bundle 'coderifous/textobj-word-column.vim' Bundle 'git://git.wincent.com/command-t.git' Bundle 'gmarik/vundle' Bundle 'kien/rainbow_parentheses.vim' Bundle 'leshill/vim-json' Bundle 'terryma/vim-multiple-cursors' Bundle 'matchit.zip' **Bundle 'mbbill/undotree'** **Bundle 'mileszs/ack.vim'** **Bundle 'mru.vim' -------- List recent docs. Mapped to Leader h** Bundle 'myusuf3/numbers.vim' Bundle 'paradigm/vim-multicursor' **Bundle 'ruby-matchit'** Bundle 'robmiller/vim-movar' Bundle 'skammer/vim-css-color' **Bundle 'scrooloose/nerdtree'** Bundle 'scrooloose/syntastic' Bundle 'sickill/vim-pasta' Bundle 'tpope/vim-endwise' **Bundle 'tpope/vim-fugitive'** **Bundle 'tpope/vim-rails.git'** Bundle 'tpope/vim-repeat' Bundle 'tpope/vim-unimpaired' **Bundle 'vim-ruby/vim-ruby'** **Bundle 'tpope/vim-surround'** Bundle 'tsaleh/vim-matchit' Bundle 'vim-addon-mw-utils' Bundle 'vim-scripts/Colour-Sampler-Pack' **Bundle 'vim-scripts/dbext.vim' -----Connect to your database!** Bundle 'vim-scripts/vim-multiedit' **Bundle 'wincent/Command-T'** 
tl;dr anyone?
it's not one of those things. It's a bunch of creative writing. There's no really truly important information in it. If reading for enjoyment isn't your thing, then yeah, move on.
I think the idea is more about removing external dependencies, for example when deploying to a machine without bundler. I can kind of see the point, I suppose. I'm struggling to think of a case where I'd ever need it, though.
In 2011, I was using 1.9.2 for a project with about 140 gems. In 1.9.2, each item on the loadpath was expanded into a full path each time the loadpath was traversed. This added over 30 seconds to our project's boot time on my laptop. We never got around to implementing this strategy, but we did benchmark it, and it cut off 30 seconds. The next day, a release candidate for 1.9.3 came out, so we switched. It still would have saved over 20% of our boot time, even with 1.9.3. Removing external dependencies makes a lot of sense in a slightly less conceptually-offensive sort of way.
Cool! This really makes me want to play around with gosu.
He deleted his copy of his work, but git is distributed so all of his work actually did live on and have other maintainers.
The screenshots are Mac OS, does it work anywhere else?
Nicely written article, but I am wondering what makes this solution not viable for industrial code? There is the point that the algorithm is written in ruby and therefore not the fastest, but i don't see anything wrong with the algorithm itself.
I'm 41 and have fond memories of this game circa 1995 or so. I have to wonder who here even gets the reference...
Ran fine for me in win7. Nice job, op.
I'm 10 years your junior and I get it. One of the first PC games I ever played.
Yeah I'm 31 myself but I still remember houuuuuuuurs of positioning my napalm.
Nice work, OP!
This is really a fantastic post. Thank you for the information and especially the links. I've been trying to learn Ruby on Rails for the last year, but since I have been working 2 low paying jobs to make ends meet, my time has been fragmented. I just quit one of them because the owner was crazy, so I'm treating learning rails as a full-time job, at least until I can get a real rails job. It seems that the best way to learn software development is through the BDD/TDD methodology so this post was really great to get focused on that. Better Specs is awesome but the best practices are a little difficult to understand without a better "why" with examples of implementation rather than just this line is better than that line. I'm drooling over the Growing Object-Oriented Software, Guided by tests but it's pretty expensive for me right now. Are there any other resources that use RSpec/Cucumber/whatever to build an application completely using the TDD/BDD style? I know red/green/refactor is a big thing, but I have found very few guides that really explain the process, and what the developer is thinking and why. OK, maybe I'm just too dense to figure it out on my own, it's been really rough going without any mentor or somebody to walk through an application with once or twice. 
Thank you for that interesting point.
I played this on an Apple ][e :)
Agreed that you don't need to test that validates_presence_of works, although Rails has broken basic functionality when they rush out security fixes. But I think you might want to test that "title is required". This is made very easy with [shoulda matchers](https://github.com/thoughtbot/shoulda-matchers). You can write one-line specs like: it { should validate_presence_of(:title) }
Remember playing it on my Amstrad 286 when I was about 9. I miss that machine.
My use case was I had an application that would create, verify, and otherwise manage "pre-compiled binary" packages to speed up builds. I wanted to develop this tool with rspec, good SOLID rules, each class in it's own file, etc. I also wanted any build system or developer to be able to get these programs very easily. Since, at the time, most developers didn't use ruby and weren't familiar with gem (bundler and rvm were new at the time) this was the easiest way to get my apps to various places and be sure they worked. So with mergit-created-programs, you can just use curl to grab the single script you needed, chmod +x it and away you go! The only external gem I bundled was `minitar` and I made sure the rspec tests passed for ruby 1.87 and 1.9.1 (and later 1.9.2). I have to admit, I was influenced by the fact I wrote something similar for Python even earlier (.eggs didn't exist yet) to merge all the python code into one place.
I wouldn't recommend that, since some gems do things like catch LoadErrors as a compatibility/feature test or do require in weird places. But it would be interesting to try it out on a big project anyway.
Removing rails doesn't alter what you're responsible (or in this case, not responsible) for testing.
27, and that game was most excellent.
You created a game in ruby, impressed! Mind if I PM you for some tips?
Go ahead.
Just google the book. Free PDF http://it-ebooks.info/book/1503/ Hopefully no one gets upset I'm posting that, but it came up as the first link. 
Is your name really James Moriarty? If so, how often do you get asked that question?
1. Yes. 2. Often.
Pretty cool, i messed around with gosu a bit in around 2010 and wrote the following two games (low FPS is just due to crappy screencasting software :/) [selene: a spaceship game](http://www.youtube.com/watch?v=VLR4J77RWTU) [tremolo: kind of worms a-like](http://www.youtube.com/watch?v=FngoadE1nEc)
It looks like everything this week on _why was purged from HN, was there any explanation?
as many of the [comments here](https://news.ycombinator.com/item?id=5585590) point out, the real issue is the naive brute force solution. perhaps a better title would be "Bad algorithms are too slow for programming competitions" :)
there's no question that ruby can be orders of magnitude slower than Go, depending on what you are doing. but the point of these programming competitions is to come up with the best solution. Google attempts to "[make it so that all languages are fast enough to solve the problem](https://code.google.com/codejam/problem-preparation.html)", and i've seen the same in other contests i've helped run and participated in. while brute force works in this case for Go, that may not hold true for other problems, and you definitely won't win competitions that way.
And the hilarious part of this is, one of the first paragraphs in the article implies that this is the "right solution". &gt;Sure, I knew Ruby wasn’t going to be zomg fast, but I always assumed that if I chose the right solution and wrote in an efficient manner, my ability to write code quickly and concisely mattered more than sheer processing speed.
No, the real lesson is ["when you feel threatened by the message, attack the messenger"](https://news.ycombinator.com/item?id=5585826).
&gt; If you are like me and don’t always come up with the best solutions, you may want to consider other languages too. Good thing I write better code than that. I guess I can stick with Ruby. edit: just to be clear, I was just being snarky/joking and I probably don't actually write code any better than that. Still sticking with Ruby though.
Do you mean pass variables to the template? If so then you just need to use instance variables ie: app.rb get '/:name' do @name = params[:name] erb :home end views/home.erb: Hello &lt;%= @name %&gt;
&gt; If you are like me and don’t always come up with the best solutions, you may want to consider other languages too. Obviously the one thing you should never consider is coming up with better solutions.
This is going to go against every other comment here, but I thought he set out to prove a point that Ruby compared to other languages can be significantly slower, and he did that pretty well. I don't think his solution is great, I don't think he should have won if he had submitted the Go solution either, but the disparities between the same algorithm in two different languages are worth noting.
Good points. There is something to be said for a language's innate ability to pigeonhole you into a realm where naive solutions work orders of magnitude faster than they would in other languages. I think that's the gist of what this post gets at. Yes, it's a suboptimal solution, but hey it's so much faster on Go. Not like I'm running to switch to Go, but it is what it is.
I agree. The point is noting the stark difference in performance between the two platforms with essentially the same algorithm. The implications are there, but really that's an exercise left to the reader.
Regardless of the algorithm used, I think the real story is "no one builds things that matter from code competitions." Have fun at such events (I mean that sincerely), but remember that you are not writing production code. Optimizing for fun CS problems naturally favors a lower language like Go. Building a web framework? Probably not the best choice*. Ruby makes performance sacrifices so that it is more developer, and abstraction friendly. That's why we have all the 'magic' of Rails, but also why its components are often slower than parts rewritten in more efficient languages. Though it is interesting that you compare Ruby to Go, specifically, as Go was built to be a more modern, thought out, and developer friendly version of C++. The designers (as Matz did with Ruby) made performance sacrifices in the name of developer productivity. Garbage collectors will never be as efficient as manually deallocating memory – in which case memory is freed literally as soon as no longer needed – but they saw that it was too much of a pain in the ass to be worth the trouble. A GC is not wildly inefficient, and neither is Ruby. *Go is built to be friendly to web development. As your application grows, it would be an excellent choice to break off chunks of functionality as their own service in Go. For the most part, though, abstractions like Rails will work fine out of the box.
I bet you're almost as smart as [this guy](https://secure.flickr.com/photos/planetargon/127984254/)!!!
Turns out the Go solution was incorrect, because it wasn't using 64bit integers: https://news.ycombinator.com/item?id=5586152 Edit: or was the commentor just running 64bit ints on a 32bit arch?
quite the opposite, imho, until we live in a world where most languages magically optimize poor algorithms. over the course of a career, the typical programmer will have to work in several languages. if he is trained to consider the language choice/features as a substitute for writing efficient code, then when he needs to work in a language that does NOT have such features, the code will suffer. the blogger is essentially saying "hey, my bad algorithm runs faster in language X than language Y". if he had chosen a good algorithm, it would be fast in (almost) any language.
A naive brute force solution isn't "bad" if it is fast enough for the expected inputs and resource constraints.
Comparing interpreted languages to compiled ones, is like comparing pineapples to pinenuts. The author should have compared Ruby to Python, Perl or even JRuby.
Just for comparison.. The Smalltalk version: (using Pharo: 14.8 seconds) Smalltalk is a language very much similar to Ruby. Code: &gt; | max col str str2 rev count start | &gt; start:= Time now. &gt; max:= 10000000. count:=0. col:= Heap new. &gt; 0 to: max do:[:x| &gt; str:= x asString. rev:= str reversed. &gt; (str=rev) ifTrue:[ &gt; count:= count+1. str2:= (x*x) asString. rev:= str2 reversed. &gt; (rev=str2) ifTrue:[ Transcript print:str; cr. col add:x ]. &gt; ]. &gt; ]. &gt; Transcript &lt;&lt; 'Total palin:'&lt;&lt;count;cr; &lt;&lt;'Total palin sqrd:' ;&lt;&lt; (col size);cr. &gt; Transcript &lt;&lt; start; cr &lt;&lt; Time now;cr. Fastest version: ASCII 0 1 2 3 11 22 101 111 121 202 212 1001 1111 2002 10001 10101 10201 11011 11111 11211 20002 20102 100001 101101 110011 111111 200002 1000001 1001001 1002001 1010101 1011101 1012101 1100011 1101011 1102011 1110111 1111111 2000002 2001002 I hope these numbers are correct? The code may be optimised using only numbers with 0,1,2
After looking at the Go code, I'm not under any impression that it has sacrificed much in terms of developer friendliness in order to get its amazingly better performance. A little, yes, but not anywhere near the amount needed to make this look like a Ruby vs C comparison. Rails may still be a better choice vs some random Go framework, but as far as I can see, it is only because Rails is a more mature *framework*, not because ruby is a better web *language*. 
Eh? Ruby compiles to bytecode just like Java which is extremely fast in comparison. That means it pays a small penalty on startup which is meaningless for these kinds of programs anyway. It's the quality of the VM that matters and how friendly the language is to optimizations.
Ruby doesn't optimize it's IR bytecode, unlike the JVM. Even with the JVM's aggressive optimizations, it almost comes close to native code. This is usually due to having no GC overhead and most of the memory allocated are primitives on the stack.
I feel like you're violently agreeing with me. FWIW languages don't optimize anything, compilers and runtime environments do. Even then they don't optimize whole algorithms in the general case, if ever. Now if its stuff like tail recursion elimination type stuff (which some but not all popular Rubies do) you're talking about it still wouldn't matter because the algorithm is still the same underlying algorithm...just transformed by a fixed rule. I also think Go probably would still hands down beat ruby in the best case algorithm, let's get real here. That said I still don't use Go.
Do you think we(as a ruby community) should be rallying to create a faster VM OR remove the GIL? I am aware that JRuby and Rubinius are options, I just think that CRuby should at least have respectable performance.
&gt; The JVM beats quite a few native code compilers. Citation needed. &gt; Manual memory management has quite a bit of overhead as well. Compared to the multitude of GC algorithms, no it doesn't. Additionally, with memory mapped languages, you can take advantage of the CPU's cache by doing block processing of contiguous memory.
FWIW, I have a good use for `exec`: Scripts whose sole purpose is to build up the environment/arguments list for another program. I store backups on a few targets using [Duplicity](http://duplicity.nongnu.org/), which tends to have a pretty long command line (due to the various excludes) and a few required env variables (for cloudfiles). I build those using a ruby script that just `exec`s in the end. All else being equal, is better to have one process than two hanging on the OS.
Interesting note: his example (https://gist.github.com/clifff/5401367) performs *a lot* better (when using the integer based method) on Rubinius 2.0 dev than it does on MRI, especially after you run it a second time (most likely due to the JIT). ## Rubinius First run: $ ruby bench.rb Rehearsal ------------------------------------------------------------- Integer palindrome method 2.223334 0.003333 2.226667 ( 2.230329) String palindrome method 6.979999 0.006667 6.986666 ( 7.000019) ---------------------------------------------------- total: 9.213333sec user system total real Integer palindrome method 1.236666 0.000000 1.236666 ( 1.242749) String palindrome method 6.616666 0.010000 6.626666 ( 6.641757) Second run: $ ruby bench.rb Rehearsal ------------------------------------------------------------- Integer palindrome method 1.893333 0.000000 1.893333 ( 1.897876) String palindrome method 7.143332 0.003333 7.146665 ( 7.160379) ---------------------------------------------------- total: 9.039998sec user system total real Integer palindrome method 1.249999 0.000000 1.249999 ( 1.255884) String palindrome method 6.389999 0.003333 6.393332 ( 6.404404) Ruby info: $ chruby 1.8.7-p371 1.9.3-p385 jruby-1.7.3 * rbx-2.0.0-dev ## MRI 1.9.3 First run: $ ruby bench.rb Rehearsal ------------------------------------------------------------- Integer palindrome method 7.910000 0.000000 7.910000 ( 7.922222) String palindrome method 4.310000 0.000000 4.310000 ( 4.318695) --------------------------------------------------- total: 12.220000sec user system total real Integer palindrome method 7.680000 0.000000 7.680000 ( 7.687161) String palindrome method 4.170000 0.000000 4.170000 ( 4.182967) Second run: $ ruby bench.rb Rehearsal ------------------------------------------------------------- Integer palindrome method 7.950000 0.000000 7.950000 ( 7.958803) String palindrome method 4.240000 0.000000 4.240000 ( 4.246885) --------------------------------------------------- total: 12.190000sec user system total real Integer palindrome method 7.570000 0.000000 7.570000 ( 7.581871) String palindrome method 4.150000 0.000000 4.150000 ( 4.154533) Ruby info: $ chruby 1.8.7-p371 * 1.9.3-p385 jruby-1.7.3 rbx-2.0.0-dev
It also doesn't take escaping into account. The following string would evaluate to false. When you could argue that the second paren is escaped. ('foo\)bar')
I actually think this is a great reason one should use Ruby for something like this (or any other 'slow' language). By using Go the fact that he's solving the problem in a really stupid way is completely hidden. What he should have realized, after finding the solution took 50 minutes in Ruby, was that he's doing it wrong, not that he's using the wrong language. In this case even though Go is faster, all that speed gets you is a glossing over of the fact that your solution sucks.
This would be useful to print out and hand to your interviewer at the start of an interview, to head off dumb questions.
I think that better performance is always a good benchmark to achieve, but I don't know if it should be a core focus for the various Ruby teams. When I choose a language for a project, and I consider myself proficient to skilled in maybe 8 - 10 languages, performance is just one field in a matrix of features that I run through in my head. Sometimes the raw performance of the language won't matter if you're doing a lot of network activity and are I/O bound. I think that I will be reaching for Ruby for a while still because for some things, like a quick experiment, I'm incredibly productive in it. I can test out an idea that is quite complex and start iterating quickly once I get some results. If I was a better Python programmer I would use that language more.u OTOH, sometimes I'm in the initial planning stages of a large data processing system, and I start leaning towards something like Scala for it's parallelization features and raw performance. I think it's one of the interest challenges of programming that we have a *lot* of tools to use, and selecting an appropriate one is part of our job.
I really like the idea, but I'm not sure that some of those would help determine if the candidate is a good Rubyist (looking at the Core Language section).
single colon answer is wrong f(g()) doesn't need the parenthesis and Q: Explain how Ruby syntax supports object specifiers in parameters lists? A: You can leave off the curly brackets from a hash in a parameter list, assuming it is the only argument in the list should be (...) assuming it is the **last** argument in the list 
Are you trying to hire engineers or compilers? Questions that can be answered by a quick google search are worthless.
[Citation Needed]
There are some trick questions in here. I'm not sure I'd be too happy if an interviewer spouted some of these at me. From a quick readthrough: Q: Is everything in Ruby an object? A: No. Methods are not objects. Blocks are not objects. Which technically true, there are first-class methods (via the Method class) and blocks (via the Proc class). A better answer would be "keywords are not objects", as this conveys the intent of the question better without room for ambiguity (blocks, after all, are simply a syntactic construct like `if` or `when`, but the latter cannot be bound into first-class objects). Q: What does the single colon syntax do? A: The colon is an initializer of the class Symbol. The lack of context here is awful. I'd answer "it's used as an alternate hash key delimiter in Ruby 1.9". How is a candidate supposed to know what you mean by "single colon syntax"? Q: True or False: It's possible to initialize a symbol with Symbol.new A: False This one just seems like it's esoteric for the sake of being esoteric. In what case would you ever need to discover this? I'd expect most candidates to answer this "True", on the basis that symbols are objects of the class Symbol, and classes have initializers. A failure to answer this one correctly doesn't really tell you anything useful about the candidate. Q: What method might you use to remove duplicate values from an array? A: #uniq This one's wrong. You want `#uniq!` if you want to remove values from the array. `#uniq` returns a new array with duplicate values removed. The original array is untouched. Q: Name one instance when parenthesis are required in method invocation? A: In the case of nested method invocation such as f(g()). Nope, `f g` works just fine in this example. They are only required for nested invocation when you want to pass additional parameters to `#f` beyond the return value of `#g`. Q: What is the default encoding in MRI? A: ASCII Default encoding for *what*? In 1.9, the default encoding for strings is UTF-8. The default encoding for source files is US-ASCII. Q: What method in Dir is used to list the contents of a directory? A: #entries or #foreach Or `#glob` or `#[]` or `#each` or `#read`. Anyhow, some good stuff in here, but there are enough rough spots that it would be a really dangerous tool in the hands of an unexperienced interviewer.
&gt; Q: Is everything in Ruby an object? &gt; A: No. Methods are not objects. Blocks are not objects. Meh. Philosophical question. I maintain that blocks are visual components of the syntax, and that they're always procs. "But what about when you use the &amp;!" you cry out. So then what about regular parameters? &amp;block just makes it a *special* parameter/argument. But meh.
Congratulations! You're hired!
I would use this only if I never wrote a line of code. In interviews it is far more important to show that you understand concepts rather than playing the role of a compiler. Also, your personality is really important. And if they are interested in technical stuff show them some open-source/self-made project you are working on. Explaining some code or the architecture should be enough to impress.
i'll bite... why is this a good idea?
The library is good because it frees you from the constraints of bash. It means you can deploy it anywhere and not worry about the underlying shell. The shell is good because it's cool and lets you use Ruby.
&gt; A better answer would be "keywords are not objects", as this conveys the intent of the question better without room for ambiguity One could also say variables are not objects, although clearly they do refer to objects. I only bring this up because if variables *would* be considered objects, due to this link, then while `__FILE__` is considered a [keyword](http://ruby-doc.org/docs/keywords/1.9/) it also refers to an object. TBH, I think the question should be removed *or* at least allowed to introduce ambiguity for a candidate to explain adequately. &gt; Default encoding for what? In 1.9, the default encoding for strings is UTF-8. The default encoding for source files is US-ASCII. Specifying the version number is certainly important for these questions, IMHO. Since in Ruby 2.0, it's UTF-8 everywhere. Quite the number of fun landmines in this set of questions, for sure! :-) I have to wonder, though, that while some of the questions and answers here are flawed, in the right hands the ability to explain the ambiguities would be a great indicator of how well someone knows Ruby.
Another case where parens are required is when using the literal hash syntax (my_method {thing: :val}) as the first parameter to a method. Ruby thinks it's a block and throws a syntax error.
My first programming instructor in college never tested on specifics around syntax, because (as he pointed out), in the real world we can program with reference book. You can teach syntax, but you can't teach thinking. Knowing conceptually you want to do to make a program work is a much better test in my book, and syntax can be sorted later. 
I think if I sat down for an interview and they started asking me a bunch of questions like this, I would smile, thank them for their time and let them know that I don't think this company is a good fit for me.
I don't know if these would make for good interview questions but I learned a couple of things reading through this!
maybe we have different constraints.. all my servers have bash/sh already, not all of them have ruby. 
The tl;dr of this release is basically "changed everything". It's worth mentioning that there will most likely be a lot of false positives. If this is the case *please* submit an issue on the issue tracker so I can actually fix it. You can install this release as following (see the README for extra info): $ gem install ruby-lint
I don't get why you committed checksum of a gem. 
It's a simple way for people to verify if said Gem has been tampered with or not. It's by no means bullet proof but it's better than nothing. The Gem is also signed using OpenPGP but it requires a RubyGems plugin so for most this won't really mean anything.
Thing is, I'd probably fail an interview based on these questions. I don't know half of these things by heart, because I don't bother committing to memory things that are easily found in documentation when needed. If you asked me for the Bignum inheritance hierarchy, I'd look at you with a blank look and probably guess Fixnum -&gt; Object -&gt; BasicObject (missing Numeric). I didn't know that you can't subclass modules, and I would say that `attr_reader` is not a metaprogramming method (it is, technically, but I feel like it's in a totally separate class from `define_method` or `alias`. That said, if you gave me a problem to solve in Ruby, I'd be able to knock it out easily. Measuring ability based on your knowledge of how to be a human interpreter seems misguided.
good summary. i always forget which one does what. i'm a programming noob still, but i do have one thing to share: exec may be more useful than you think :) exec is usually used after fork, that's actually how all processes are created on unixes (exec and fork system calls), except for the first one, "init". backtick, %x, and system all use fork and exec internally. i made a gist using them in a silly way: https://gist.github.com/benolee/5439579
Regarding #uniq, you're quizzing on the API, and knowledge of the difference between #uniq and #uniq! is pretty critical - for example, #uniq will always return an array, whereas #uniq! will return the array, except when no changes are made, in which case it returns nil! (This has accounted for far more bugs than I'd like to admit!) You could rephrase the question to something more general like "given a list of values, how would you ensure that there are no duplicates?" - this leaves the door open to both methods as potential answers, though each method would have a slightly different answer. Additionally, rather than quizzing specifically on API documentation, this gives you the ability to let the candidate expose a little bit of how they think about the problem (do I make an array and #uniq it? Do I do an O(n^2) iteration of the list and construct an array for anything not found? Do I sort the items and iterate them and reject anything that matches the last item found?) - in my experience, understanding how a candidate *thinks* is immensely more valuable than understanding how much documentation they can recite.
I am new to Ruby is this a better group of questions: https://gist.github.com/ryansobol/5252653 ?
Q: True or False: It's possible to initialize a symbol with Symbol.new? A: I have no idea. I have never tried.
&gt; Instead of getting pissed, we should just try to help the MRI/JRuby/Rubinius/Topaz teams to make our Ruby faster. Absolutely. I was asking for a citation only because one was needed, not because I was pissed. :) EDIT: Also, [this](http://www.unlimitednovelty.com/2012/06/ruby-is-faster-than-python-php-and-perl.html) from tarcieri (the celluloid guy) is interesting, and another nail in the coffin of meaningless benchmarks. 
&gt; I would argue that it is paramount to know the behavior of the language you are using. There are a lot of features of a language that you absolutely do not need to know to program well using it. Further, these are simple things someone can readily learn and apply, unlike, say, how to program (well). The problem with interviewing like this is that you are doing absolutely nothing to determine whether someone can actually program. It's sort of like hiring someone based on professional certifications. Ok they managed to memorize facts and pass a test. Does that mean they can program? Nope. If you want to hire quality talent, rather than sitting them down and asking them a bunch of questions like this, having them actually write some code to solve a non trivial problem. I can tell far more about someone's ability by looking at their code than I can by asking technical questions for an hour (though a few technical questions over a phone interview are useful to weed out the obviously poor candidates).
I'm going to throw in Everyday Rails Testing with RSpec. https://leanpub.com/everydayrailsrspec
I have had many interviews where nearly every reply would be "I don't know off the top of my head, I'd look at the documentation" and it's been painful for everybody involved. But that's what I'd do. Now it's the other way around and I'm hiring, I refuse to ask questions like this. Questions like "how does an object get initalised?" shows a familiarity and a way of thinking through a problem, but I'm not expecting anybody other than the core interpreter teams to get it right. I'm more interested in getting them to problem solve, or work through a couple of example coding tests than I am having them memorise the entire contents of RDoc.
I almost want to start a podcast where I invite on esteemed Rubyists and ask them every question. But I know no-one would want to come on, lol.
Good point, there are many ways to achieve the same effect, not all of which I've covered. Great idea for a future post.
Yes they're basically useless for application developers, but they're relevant for programming competitions, where you have CPU intensive problems. 
&gt; This is usually referred as dynamic metaprogramming Is it really? Do you have any citations for prior uses of this phrase? It's a bit confusing to try and establish 'dynamic metaprogramming as a term like this, as there is a very old (in computer era time) thing called [dynamic programming](http://en.wikipedia.org/wiki/Dynamic_programming), which has nothing to do with what OP is talking about. I am not sure it's true that anything along the lines of what the OP is talking about "is usually referred to as dynamic metaprogramming". 
You might want to learn to just manage your system instead. 
 sudo apt-get install vagrant vagrant box add &lt;distroXX&gt; http://files.vagrantup.com/&lt;distroXX&gt;.box vagrant init &lt;distroXX&gt; vagrant up
Kinda weird to have a post titled "Ruby Versions Demystified" and then tell people to google it if they want to know about the versions.
I wish we had a gem that took an input file and a set of style rules, and then rewrote the input file to obey those style rules. inb4 "why don't you write it" i will, just give me time.
I disagree that library authors should continue targeting 1.8. MRI 1.8 will be [EOLed this June](https://blog.engineyard.com/2012/ruby-1-8-7-and-ree-end-of-life), 1.9.3 is stable and JRuby has already switched to 1.9 as it's default mode. Supporting the use of an unmaintained Ruby version is a bit irresponsible, imho.
To touch on this, he also states that most ruby learning is done on 1.8? As someone who is just beginning to learn ruby? I haven't seen any YouTube tutorial or decent guide that's not 1.9. 
I suspect this will change over time, how quickly I'm not sure.
If you want to quiz yourself, you can use: lines = File.readlines('README.md') q = lines.select{|e| e.match /^Q: /}.map(&amp;:strip) a = lines.select{|e| e.match /^A: /}.map(&amp;:strip) loop do i = rand(q.size) print q[i] gets puts a[i] puts end have fun :)
If this is something you're interesting is using (not just building), then check out [viewabill.com](http://www.viewabill.com), which supports Harvest.
fravia never threatened to forcibly remove other people's mirrors, but he did publicly request that people take mirrors to his reversing site offline: &gt; I wish to "close the ride" and retire definitely my old site from the web. Easier said that done, without the help of all my readers and friends: once something has been put on the web, as all good searchers know, it "goes forth and multiplies". &gt; That's why I would like all friends at least to 1) Contact with me all mirrors' owners and ask them to pull their mirror off the web. 2) Redirect cjb and other re-locators to this page 3) Do not open new mirrors any more and do not put the copies you have made on the web again. It may be impossible, but if you want to help me, just give it a try. As anyone that has followed the history of my site knows, this decision is due to a slow evolution that began long ago (remember the "september thoughts" back in 1998?). Please respect it. &gt; See you elsewhere next month. Fravia+ is signing off now. A bit of an odd request, really, but he seemed to really lament his efforts on the reversing project, regarding it as a failed experiment. He wanted to encourage a younger generation of crackers to become software engineers, and he mostly just succeeded in generating a new breed of young crackers. I think he saw his "searchlores" as something less ladened down with ethical dilemmas, and more valuable to "seekers" than something as specific as reverse engineering. As futile as it was, he just really wanted a clean slate. 
System-wide, or local user? Are you receiving that error when running as a normal user, or root? I think the biggest confusion I see in system-wide installations is that rvm does not translate over when you sudo, unless you're running rvmsudo. In the worst case, you should be able to fix any missing rvm scenario for your current login session by running `source /etc/profile.d/rvm.sh` to load rvm into your environment.
What does your .bashrc and/or .bash_profile look like? Maybe your environment isn't getting set up?
From what I've found, running as a login shell means my .bashrc gets skipped completely.
I was inches away, then I found what looks like a solution, so I'll see if this works. Any more problems and I'm switching, though.
Single user, nonroot, solution in edit above although I ran the source command and it didn't help.
If that's the case, you should have a line like: ``` [[ -s "/home/foo/.rvm/scripts/rvm" ]] &amp;&amp; source "/home/foo/.rvm/scripts/rvm" # Load RVM into a shell session *as a function* ``` in your ~/.profile (or similar)
Nothing like that in there.
is there a reason you're not attempting to do this more as a paid for service ?
The first batch sold in under a minute, be prepared!
Merry Yaksmas
I was thinking the same thing. Its really clever.
I just made this... what do you think?
This is a fairly complete rewrite. I'd love feedback.
thanks for all your recent work on the seattlerb projects!
i heart minitest
you're very welcome
thanks! Is there anything about it you _don't_ love?
I'm not a huge fan of refute and I would certainly love to see context blocks in unit (not in a separate gem). Other than that Minitest is amazing.
context is an alias for describe https://github.com/rspec/rspec-core/blob/master/lib/rspec/core/example_group.rb#L235 so here's how you could add it to Minitest (I think) module Kernel alias context describe end
Looks great, even if it means that I won't have code in the stdlib anymore :-/ Seriously though, it seems smaller, simpler, and more consistent. Looking forward to trying it out!
That's RSpec. I mean have context blocks in Minitest::Unit like shoulda.
ah, sorry, I didn't know about shoulda contexts
Well, since you asked...I would love to be able to focus or exclude tests using fdescribe, fit, xdescribe and xit. I know it's a minor thing, but I've gotten used to it from using [Cedar](http://github.com/pivotal/cedar) for my iOS projects and now I'm kinda spoiled. Not having it in my Ruby projects makes me sad. I keep thinking that some day I'll implement it myself, but I just can't ever find a round tuit. Thanks for making minitest.
I thought about it, but I have another project that's been keeping my interest. I'm presenting at RailsConf on Monday. I made a promise to myself if I ever had any code sitting on the shelf that wasn't making me money, that I would open source it. So opened it up just in time for the conference. I'll probably do a brief highlight of it in my talk. P.S. If anyone is going to RailsConf, stop by my talk "No traffic, no users, no problem!" and say hello.
Thank-you, I sincerely appreciate it. There's a lot of potential there for a service; if you ever do anything with it, drop me a line, I'd love to see what you end up with.
Sure, why don't you build a service though? Seems like you know the domain?
I'm confused by your stdlib comment. What does that mean?
focus is provided via the minitest-focus gem. Patches welcome.
I guess I don't see the difference between shoulda's context and describe. Teach me?
&gt;minitest was part of the ruby stdlib (or bundled with it, at least) Is that not still the case? 
Sublime with Vintage mode seems like the perfect editor for me, unfortunately the plugin still has a lot of quirks. Hopefully, the upcoming release will address those.
/r/sublimetext
I missed that one, thanks. I'll give it a try.
https://github.com/seattlerb/minitest/blob/master/lib/minitest/spec.rb#L94
I still love emacs. RubyMine was crazy slow last I looked.
I love rubymine. Works great on windows and my Linux VM's.
Yay for more ruby projects in the bitcoin world! I don't have any experience with SocketIO, or the Mt. Gox API, but I figured I'd take a look anyway and see what I could see. First, I think I installed a different SocketIO gem than you, because I had to type in `require 'SocketIO'` (capital 'S') to get it to work. I used [socketio-client](https://github.com/lyondhill/socket.io-ruby-client). Nonetheless though, after making that one small change, I got the same results as you. It connects and receives heartbeats successfully, but that's it. Looking into it further, I think that `emit` is the wrong method to call when subscribing to a channel. [Looking at the underlying ruby code for `emit`](https://github.com/lyondhill/socket.io-ruby-client/blob/master/lib/SocketIO.rb#L127), it seems to be expecting different arguments than your code provides. [The javascript Mt. Gox API](https://github.com/olalonde/mtgox-socket-client/blob/master/mtgox.js#L66) just calls the `send` method in order to subscribe. So, I tried switching line 21 of your code to call `send_json_message` instead, but to no avail. I tried a few variations of: send_json_message({"op" =&gt; "subscribe", "channel" =&gt; 'dbf1dee9-4f2e-4a08-8cb7-748919a71b21'}) At this point, I'm somewhat at a roadblock, but I figured I'd let you know what I found out so far!
Debugger gem
I remap esc to capslock and tab to autocomplete. I can even call rspec from vim (I think Tpope wrote a plugin for integrating vim with rspec a while ago, but I haven't tried it yet). With a fairly straightforward vimrc and xmonad as my desktop, my hands rarely leave the home row and my wrists / back have never been better. I'm really tall and prone to excruciating back and wrist pain, so for me an efficient editor and desktop environment is a health issue. There's a steep learning curve for sure. And at first most people will be slower in vim, and that's where they'll leave it. But there's an immense payoff for those who put in the effort http://stackoverflow.com/a/1220118/1632175 
I tried vintage mode in semblime and evil mode in emacs because modal editing rocks. But they both aren't near close to vim flexibility.
Vim is a great text editor but it's usability is inversely proportional with the number of files you have to work with IMO. When I need to edit one or two files, nothing beats Vim; for projects I need ST2. 
read the top part https://github.com/seattlerb/minitest/blob/master/design_rationale.rb -- is that what you're looking for?
For unit test, I have some functions in my vimrc file that will fire off the spec file for whatever I'm working on. I saw a few screen sessions with Gary Bernhardt and I picked a few things out of his vim workflow. So basically typing ",t" will fire off the unit test I would like to run, I'll see the results and then jump right back into the code. Links if you're ever interested in checking his stuff out: * https://twitter.com/garybernhardt * https://www.destroyallsoftware.com/screencasts
Let me make it a bit more clear. Thinking about it, context blocks to specify what method your're testing on and a "test" method like Rails adds would be nice. So in the end you would end up with something like this. context "#show" do test "" do assert true end end Arguing about myself with it, but I don't think they should not be allowed to be nested. I just think it would keep your tests more organized and would be really convenient to just include 'minitest/context' or something similar.
LOL! That is fucking awesome :)
Again... what's the difference with minitest/spec's describe? describe "#show" do it "" do assert true end end It looks like everything you want is easy with a couple aliases.
Oh. right. **Sorry!** After mulling on this for more than a year, having Runnable classes that know how to run themselves seems a lot cleaner than having a manager object responsible for running things, collecting the results, and reporting it.
That's what `def` is for. Use ruby. It's a great language.
HAH. Or that. I guess I misread the OP.
Ah, I see what you mean now, sorry. I'll play around with that and see how that works out. Thanks.
The latest version is MUCH faster. It's also one of the few editors with decent Gherkin support.
Ruby mine kinda sucks. Every time that I've used it (when it first came out, then about a month ago), I think its amazing for like the first few days. then I slowly start using terminal a bit more, then i finally switch back to sublime + terminal exclusively. I dont know why, but ruby mine is just so clunky. It's got a lot features that could save time if you teach yourself to use them I suppose. but I'd rather spend that time learning a universal editor like Vim, not an ide for a single framework.
It's quite fast on a 16GB iMac.
This sounds kinda like how a lot of my weeks go...
Emacs: * Evil-mode to emulate Vim. * Auto-complete for completions. * Inf-ruby to get a ruby repl * Robe mode for code navigation, intelligent completions and easy access to documentation * Rspec mode to easily manage and run tests * yard-mode to get that nice syntax highlighting for method docs * rvm (the emacs minor mode) to manage ruby versions from emacs. * yari to access ri docs from emacs. * rinari to interact with Rake (rinary is intended for rails work; it has a lot to offer if you do that kind of work, but I don't atm) * Magit to interact with git. Magit is so great I just want to mention it, even though it's only tangentially related.
I've spent a few hours trying to figure this out without luck (my pride's at stake since I'm working on a websocket project right now :P). My only thinking is that the MTGox socket.io api states that it returns pure javascript objects, not JSON which could potentially cause problems. This would explain why your html page works but the ruby script doesn't. My ruby knowledge isn't extensive enough to know if there's a way around this particular issue using the stuff you want to use...
Does anyone know the current state of Redcar? It looked promising back when I first saw it at Rubyconf 2010 but it was still a little buggy and slow back then.
Yea, I can get anything into my DB trivially, but just having problems getting the raw trades of any sort to return. Will mess more with the Websocket one, but most of the websocket gems are for making servers, not clients. 
I tried a couple of weeks ago and had similar problems. I was also trying with a few different Ruby websocket gems. It may be time to pull out Wireshark to see exactly what's going on.
I tried to do that yesterday (Wireshark), but I need to reinstall X11 or run it in a VM. Something *odd* is happening. I've done plenty of Websocket stuff in the past and never had issues. I do have some weird feeling that the API is misbehaving, but unless there's some user-agent thing that allows a browser and not Ruby...
[Pry](http://pryrepl.org) + emacs tools (SLIME-alikes) like [robe](https://github.com/dgutov/robe) and [ruby-dev](https://github.com/Mon-Ouie/ruby-dev.el) are more than enough to compete with ruby mine, in my opinion. 
I love minitest. It needs better documentation. It's difficult to tell what is possible with it. It's difficult to tell how it works. From these release notes, I'm not even sure if it'll break things I've done, because I don't really understand what's what. Better docs, including more examples/tutorial as well as reference docs.
I'll second this. When you're dealing with a giant system with lots of components, being familiar with the debugger gem is important.
Thank you!
FINALLY! I was about to write something myself that could enforce style guides! The output of ruby-parse is kinda impossible to understand (for me), but the fact that it does precisely what I want means I'll spend the time to learn it.
The AST is formatted as a collection of S expressions. The exact documentation of parser's use can be found here: https://github.com/whitequark/parser/blob/master/doc/AST_FORMAT.md
I also think minitest/pride and minitest/spec should be their own plugins.
&gt; Now, Fog and Sinatra have been packaged (oh yeah!) and are available in Ubuntu Precise repositories. Unfortunately, I need a newer Sinatra version coz I want Feature X, available in version 1.4 and the packaged version is 1.3.2 (shit). What? These are gems, aren't they? gem install sinatra -v"~&gt; 1.4.0" 
apt-get (or yum) is superior to bundler in a lot of ways. Besides sinatra, a database driver will probably also be required, meaning you'll still have to use apt-get (or yum on redhat/centos) to install some dependencies. Seems this tool allows you to make a debian package for your app (including any dependencies), reducing deployment to a single command: sudo apt-get install my_sinatra_app. The best part is, if you manage to setup a private debain repository (which is hard), updates (for the app and any OS packages) would be just as simple (apt-get upgrade).
ST2! ST2! ST2! ST2! ST2! ST2! (or TextMate)
Oh right, they indicate what type of data (e.g. an expression) is located in what position.
Yeah, the whole point is to avoid installing a large number of deps (plus the toolchain to compile some of them) in a server just to run a simple script (or your app). When deps include native gems, things start to get hairy. Also, you can make sure the versions installed are the ones you (the distributor) have tested. Cleaning the war zone is also easier, since 'apt-get remove mypackage' is all you need to remove all the new stuff. @jemminger, 'gem install sinatra' requires a large amount of deps to be (manually or not) installed before being able to do that. At least in a Debian/Ubuntu OS. 
Why? What does it help to move these pieces out from the minitest-gem?
I wish these misconceptions would stop. Apt-get is not "superior" to Bundler. Neither is Bundler "superior" to apt-get. That is because both tools *solve completely different problems*. It just so happens that a part of their problem domains overlap, so they appear superficially to solve the same problem. Bundler is designed to lock down dependency versions, to solve versioning conflicts and to prevent accidental (non-explicitly specified) dependencies, in the face of a world in which people use many different library versions. Apt-get is designed for managing system software. Apt-get cannot solve Bundler's problem domain because it has no support for installing multiple versions of the same package. Bundler cannot solve apt-get's problem domain for reasons you already know. You're supposed to use apt-get together with bundler. You need both tools. I noticed that the guy in the article uses apt and 'gem install', but without bundler. He may run into trouble later on.
Pry by itself most of the time (`binding.pry` works inside unit tests), with [pry-debugger](https://github.com/nixme/pry-debugger), and [pry-stack-explorer](https://github.com/pry/pry-stack_explorer) if it really calls for the full `debugger` gem functionality. Not really specific to vim though, I use it when working with SublimeText too. There's also Pry's [`edit`](https://github.com/pry/pry/wiki/Editor-integration) command that invokes vim from inside your Pry session if you're working with a ruby script at a smaller scale. 
How long until 5 is released? With everything on the github page pointing to v5 docs - and no clear reference to v4 - it's a bit weird to not have this coming in on bundler but all the formal docs updated.
You're not wrong about bundler (in general), but I'll just clarify that I assumed the context of a production deployment (where having multiple versions of a gem wouldn't be required) and by "bundler" I meant "bundler and friends required to deploy a ruby rack app". So in a context of a deployment, just apt-get is superior to using install_dev_deps/compile_from_source/rvm/bundler. And apt-get is not just for managing "system" software (its for installing software and managing dependencies); I guess the problem is that not a lot of ruby-ists (including me) know how to properly package a ruby app and it's dependencies. For example, [redmine](http://packages.ubuntu.com/precise/redmine) can be installed with apt-get install redmine. Sure, the package is old, but anyway I love the idea of deploying an app like this (including init script, logrotate confs, database setups, etc.). Too bad there's not a lof of info (and interest) on how to do this with ruby web projects.
&gt;Q: What are the only two values that are falsy? &gt;A: false and nil I would've answered the same yesterday, but try running ruby -e "p /chocolate/ ? 1:2" Question lists like this are dangerous because they promote the false belief that non-experts can test experts. That would be cool, but almost every multiple-choice programming test I've ever seen has been worse than useless, because it's passed through at least one revision by someone with no domain knowledge.
Also, Coby (who runs Confreaks) is a super-nice dude! I had a chance to have a quick chat with him at the last LARuby Conf at the lunch break. I'm glad to see the site promoted, here. 
This is awesome. Thanks!
Refactoring from good to great, is a great one. 
Hey, that's me! Thanks!
Sublime Text 2, Vim, Emacs and Textmate try them all see what you like.
+1 for rubymine. This IDE can refactor across a project with every simple variable change as well as point out every mistake pre execution. The built in compiler is shit, but as an Editor I prefer it to sublime text 3.
Have you looked at OpenSuse's Open Build Service? Might be useful to greatly expand the number of target distributions
Not yet. RPM packaging is a whole different world.
I used to use VCR, but then ended up just stubbed everything out (copy paste the output of successful calls). 
Hm it looks like OpenSuse Open Build Service also appear to support non-RedHat distros. Interesting, I should investigate this further. [EDIT] So it appears that Build Service has limited support for building .deb packages. Unfortunately no support for creating APT repositories. Build Service remains primarily useful for RPMs.
gem2deb is the tool most Debian developers use for the task I think. It only needs the gem and some small modifications to the control, license, changelog, etc. Investing in learning it is worth every second. It's available both as a gem and also native packages.
That's pretty darn neat, thanks! =)
Gem2deb works, but is not a complete solution. There are still lots of stuff you need to do by yourself. Both my examples use gem2deb as part of the package building process.
Looking for feedback! In particular, I want some feedback on my tests, as it is the first time I have written some.
More reasons not to use MRI
'gem server' is always available. No ETA at this point.
My pleasure! I'm reading through the hash function source code, trying to find out more about it.
Excellent talk. Interesting how Sinatra is used more than Rails. Sinatra &lt;3
While you're right `gem server` exists, I do hope you take this into consideration a bit more than that. At the very least, I'd say it's fair to put a giant warning at the top of the github readme that the examples and such are for an unreleased version and go here for docs blah blah blah. Consider a new user looking into minitest and wanting to get started. They: * Google `minitest` * Go to the first hit since github pages are usually a decent place to start * See examples, and try to work from those * Quickly hit a brick wall for unknown reasons I completely concede that intelligent and awesome programmers should be able to work themselves out, but ideally documentation should be *better* than that. I don't mean to start any argument, but I did want to respectfully make this point. :)
I can try, you are encouraging me by making me think someone cares. :) But it's hard because I don't know what I don't know, you know? It might be easier to tell you the things I'm having trouble figuring out from the existing docs, is that helpful at all? Also, a start would be changing your README.txt to README.md (or README.rdoc, if you'd prefer to keep it in rdoc), so github will actually render it as HTML at https://github.com/seattlerb/minitest, instead of showing the markup source. That at least makes it look like you care, you know?
Generational garbage collector?!
Oh yeah, I know what it does, I just never thought I'd see Ruby get one.
Thanks for your explanation anyway, I found it useful :)
The 2.2 release is due in 22 years?!
I'm no expert when it comes to testing but I'll give what feedback I can. 1) It's not set in stone but it's fairly common to prefix class methods with "." and instance methods with "#". describe '.new' describe '#dump' 2) [While lots of people still use the `should` syntax Rspec is moving away from that toward it's `expect` syntax.](http://myronmars.to/n/dev-blog/2012/06/rspecs-new-expectation-syntax) 3) [The use of `let` is preferred to using instance variables.](http://stackoverflow.com/questions/5359558/when-to-use-rspec-let) 4) Your tests for the default values upon instantiation should be done when you test the method. It's the responsibility of `code` to know that it is an empty string by default. In fact you're already testing that twice in your spec. 5) Don't test private methods. You want to test that `parse!` handles each command. You should be able to rewrite all of the internals of your code (which includes private methods) and still pass your tests. Imagine for a moment that you refactor the code so that each command is a separate class. It gets instantiated and then executed to perform its duty. All of a sudden `describe '#minus'` doesn't make much sense. You just need to rearrange the tests you have so they describe what they are really doing. Testing `#parse!`. describe '#parse!' do it "decrements the current memory position" do @br.code = "-" @br.parse! @br.memory[@br.cursor].should eql -1 end it "increments the cursor" do @br.code = "&gt;" @br.parse! @br.cursor.should eql 1 end ... end I hope this helps.
Given Ruby 2.0 took like 12 years to develop, it may be a pretty realistic release date. ;) 
Nevermind. I really don't need this.
Neat. I'm really new to ruby how would one host this without heroku?
 git clone &lt;place&gt; cd &lt;place&gt; bundle install bundle exec foreman start
 Invalid gemspec in [/usr/share/rubygems-integration/1.8/specifications/actionpack-3.2.13.gemspec]: Illformed requirement ["~&gt; #&lt;Gem::Version:0x8071f40&gt;"] /home/me/stringer/Gemfile:6:in `evaluate': compile error /home/me/stringer/Gemfile:6: syntax error, unexpected ':', expecting $end gem "sinatra-contrib", github: "sinatra/sinatra-contrib" ^ (SyntaxError) /usr/lib/ruby/vendor_ruby/bundler/definition.rb:18:in `build' /usr/lib/ruby/vendor_ruby/bundler.rb:135:in `definition' /usr/lib/ruby/vendor_ruby/bundler/cli.rb:220:in `install' /usr/lib/ruby/vendor_ruby/bundler/vendor/thor/task.rb:22:in `send' /usr/lib/ruby/vendor_ruby/bundler/vendor/thor/task.rb:22:in `run' /usr/lib/ruby/vendor_ruby/bundler/vendor/thor/invocation.rb:118:in `invoke_task' /usr/lib/ruby/vendor_ruby/bundler/vendor/thor.rb:263:in `dispatch' /usr/lib/ruby/vendor_ruby/bundler/vendor/thor/base.rb:386:in `start' /usr/bin/bundle:13 There was an error in your Gemfile, and Bundler cannot continue. I tried updating rubygems, sinatra (and its dependencies) and still can't get this to work for me. I'm suspecting that there's something off with the way ruby is configured locally. 
`github: "sinatra/sinatra-contrib"` is 1.9 syntactic sugar for `:github =&gt; "sinatra/sinatra-contrib`. Update your ruby to 1.9. If he used it in the gemfile, the entire app will be written in 1.9 style.
Are you using Ruby 1.8? The app works with 1.9.3+, sorry about that!
Aha. There's the issue. 1.8.7. Only had ruby installed for redmine and never put much thought into the version. Thanks!
Non-breaking space is character code 160. ASCII is a 7-bit encoding, its largest character code is 127. So no, non-breaking space is not ASCII.
Really great! Needs some work on the responsive layout for sure, but truly nice!
If it uses the heroku scheduler, then doesn't it cost money to run it? I thought scheduler wasn't part of the free dynos. Or is there something I am missing?
You get 750 hours per month for free on Heroku, so even on months with 31 days you have 6 spare hours (if you run the web dyno 24/7). If you do start incurring small costs, you can turn down the frequency of polling.
It is still the case. I just pushed 4.7.4 to stdlib. I'm debating towards _not_ pushing 5 to stdlib ever.
The normal time in minitest that it takes for something to go from thought to released is usually measured in minutes or hours, not days or weeks. This is an aberration because I'm trying to get feedback first and get it approved for rails before they release 4.0.
Thanks for the feedback! I'll get to it when I have some time.
On a mac you can just use 'open http://google.com' you can use bash aliases to create shortcuts.
The point is to store more "difficult to remember" stuff. Like api calls to an app of yours or to some gists (Google is just an example) and also to avoid filling your shell aliases with junk
This would allow you to have duplicate entries =&gt; bloated files
Great observation, time to add one more line! Edit: rereading my comment it sounds rude and sarcastic, though I didn't mean to say it in a tone like that. Sorry.
Also no backup/gist functionallity
It's not rude. We are having just some tech conversation! 
That's true, you're right that the "does it all" claim was exaggerated, but I guess you also see how they can be added quite easily. My point was that IMO these things are best kept in the shell; one less dependency to take care of. Also, instead of the gist backup I'd just check the file in to a git repository; you can then just do a pull on all your workstations to get the updated dictionary. It can even be automated, so you get synchronization for free.
Go read test/unit.rb
Wouldn't installing pop, cause the unix command pop not to work (depending on which is found first in your path)? That doesn't sound like a good idea...
Haven't heard of pop actually, can you provide me a manual?
http://en.wikipedia.org/wiki/Pushd_and_popd If you mean this it's popd ...
Reminds me of [boom](http://zachholman.com/boom/).
Runs on [pay_dirt](http://www.reddit.com/r/ruby/comments/1d9uci/pay_dirt_an_effective_service_object_pattern/)
Other examples: [Rubeuler](https://github.com/rthbound/rubeuler) - whipped up for benchmarking my Project Euler answers. [Konamio](https://github.com/rthbound/konamio) - Runs an arbitrary block of code when the konami code is entered.
It's not junk, it's just open, zsh: if [[ -e $(where xdg-open) ]]; then alias open='xdg-open' elif [[ -e $(where gnome-open) ]]; then alias open='gnome-open' fi open http://google.com open ~/ open duc.png I was going to blame you, but the code style is nice. Don't forget to use rubocop.
Please, read my comment, the aliases are junk. What do I mean alias apps='http://api.wat.wat/v2/app?country=GR&amp;platform=ANDROID&amp;category=WAT" alias wootapps='http://api.wat.wat/v2/app?country=GR&amp;platform=ANDROID&amp;category=WOOT" etc.. I use popme in when I develop stuff.
Thanks
I usually have to do bash --login for my session to kick in. Then rvm and installed gems work. 
Oh, wow, I wrote this gem, was just looking up my own documentation and found this thread ;) Let me know if y'all have any questions or ideas
"The process is still reasonably manual at present" ... err thanks. That's like 90% of my good automation ideas.
Checkout this new Phusion Passenger 4.x series. It has much, MUCH improved performance, stability and features that rivals that of Unicorn, Puma, etc. It's used by the likes of New York Times, Symantec, AirBnB, etc. Here's also an interesting testimonial from a happy user: https://news.ycombinator.com/item?id=5662569 :)
Does it still rely primarily on liquid templates?
Funnily enough, I did originally use Wordpress. The three main benefits of using a nanoc / markdown - for me at least: * **Less plumbing.** Wordpress needs MySQL, PHP and a web server. A static site built with nanoc needs a web server. * **More secure.** Very little to hack, whereas I was forever having to patch Wordpress. * **Easier editing.** I can work on the site as a single text file, instead of having the novel's pages split over numerous entries. There are other less-tangible benefits. I get to play with Ruby, which I love, and since moving into management any chance I get to play is teh awesome. 
I could not reproduce this issue (https://github.com/swanson/stringer/issues/26) - please reply with more details on github if you are still having this issue.
Since I am developing a site on Shopify, I've grown quite used to liquid...it is not bad, but it is not great either.
I guess I must be a Neanderthal. I'm quite happy with SciTE.
He could call it "Webbit" :-)
https://github.com/rails-sqlserver/tiny_tds#tinytdsresult-usage I'm 79% sure you don't even have to do that, you could just do something like result.each do |row| puts row["column_name"] puts row["column_name1"] end 
I think the author might be one preprocess block away from filling in that 90%.
I was expecting this to be terrible. It wasn't.
To bad their servers are in europe only.
Nanoc is pretty nice, but lately I've been turning to [sinatra-static](https://github.com/paulasmuth/sinatra-static) to generate my sites. For deployment I usually write a rake task that syncs to S3 using fog
I have used Goliath recently, and while it's low level, it's very fast and integrates seamlessly with EM-Synchrony (which will become your best friend for async stuff). It doesn't actually implement any router, but you can use Grape or http-router on top of it. Just make sure any libraries that might be slow (database libs mainly) will work asynchronously.
Which are you suggesting is slow? Rubymotion or a Rails backend? I've been considering Rubymotion and would like to know.
Rails is slower than molasses. Which doesn't matter too much for web sites because network latency is a bigger problem. I don't know about Rubymotion, so no comment there.
I've been quite happy with Thin + Sinatra.
Hm... "I don't know how to develop for platform X, but I know how to write code to generate glitzy web pages in language Y, and I can pay $200 for something to make my web pages act kind of like shitty applications on X." No, thanks.
Why are you convinced AIO is the best option for serving APIs? Puma + a threaded approach is probably just as good unless you truly do have long-lived connections.
Rubymotion compiles down to the same llvm instructions so performance is not really an issue. Having said that, learning to program for iOS is more about learning the frameworks and patterns used, which are the exact same for rubymotion. Plus, objective-c is not a difficult language to learn (and quite fun as well). Just my 2cents though.
What's with the trolling here? This is a *ruby* subreddit...
"I have no idea what I'm talking about, didn't read the article and don't understand what RubyMotion is, but I'm gonna bitch about it on the Internet like an entitled idiot anyway" No, thanks.
According to my own benchmarks (although I haven't updated them recently on the web page) my Celluloid::IO-based server Reel is faster than both Thin and Goliath (when running on JRuby with InvokeDynamic enabled): https://github.com/celluloid/reel It allows your choice of mix-and-match evented or threaded I/O, the former handled via Celluloid::IO. For a RESTful framework atop Reel, consider Webmachine: https://github.com/seancribbs/webmachine-ruby
Pray tell, to what am I entitled?
Its results can occasionally be a little funky, if you do tricky stuff, like use pjax, but for the most part, its pretty goddamn reliable
Goddamit. I don't know what Jekyll is. But if the author doesn't bother writing one single line somewhere around such an announcement .. its hard to imagine it's something worthwhile. 
Yeah I love RM. It allowed me get into iOS dev by smoothing out the learning curve - instead of having to learn Objective-C, Xcode *and* all the APIs, I could limit myself to just APIs. And even then, there are loads of gems and libraries emerging that wrap UIKit and other stuff into nice Rubyish DSLs.
I guess you could fork it and add support for other templating languages. I use liquid for a lot of things so it's comfortable to me, but if you have something else you like better you should totally add it.
Yeah, its not that hard to extend, but as I said earlier, Sinatra-static tends to give me more control
Exactly my same feeling: smoothing out the curve.
Thanks! I will add that thing about BW, I didn't explained the code too much but the idea was to use an async request to the server inside the block.
The only issue with the preprocess block - and I may have this completely wrong - is that nanoc already has built the @items array before it gets to it. Because I'm dropping everything into the /contents folder in the import process it possibly is too late to try and import in the preprocess block, as nanoc won't see the new files. Again, may have this wrong so I'll give it a try and see. Worst case is a separate 'nanoc build' command to import and then run 'nanoc compile'. 
For restful APIs you do not necessarily need an evented server. As a rule, you only need evented servers if have long-running, slow responses that are more I/O bound than CPU bound. For example think about responses that may call other HTTP services, or responses that stream data from a source that they have to wait a lot on. For everything else, multithreaded servers or even single-threaded multi-process servers will do fine. If you do not have any responses that block on I/O, then [Phusion Passenger](https://www.phusionpassenger.com/) is an excellent choice. The recently released version 4 has much improved performance and is much better capable of handling slow clients and response buffering. Phusion Passenger has an *evented internal core* and a zero-copy architecture which aid in this, and integrates directly into Nginx (or Apache, if you prefer that), making it very very easy to use. You can get it up and running in production environments in minutes. If you do have any responses that block on I/O Phusion Passenger's [Enterprise variant](https://www.phusionpassenger.com/enterprise) would be a *very* good choice. This is because it supports a *hybrid multi-process/multi-threaded I/O model* for applications, in addition to having an evented I/O core by itself. This combination gives you the best of both worlds. Multithreaded servers like Puma require you to use JRuby or Rubinius if you want to leverage multiple CPU cores, or require you to run multiple processes. But managing multiple processes adds more administration overhead for the user. Phusion Passenger manages all processes automatically, and Phusion Passenger Enterprise leverages this to not only offer multithreading for MRI but also to fully leverage all CPU cores. Of course you can also just use JRuby or Rubinius (which Phusion Passenger supports too!) but not all gems are compatible with it. Phusion Passenger Enterprise also comes with a myriad of other useful features like fully automated rolling restarts, an IRB console that you can live attach to any process, deployment error resistance, etc. Some of those features are found in other servers as well, but not in an as polished manner as Phusion Passenger Enterprise. The only caveat is that the Enterprise variant is not free. That may or may not be a problem for you, but [here's what a happy user](https://news.ycombinator.com/item?id=5662569) said: &gt; Our reason to use the Passenger Enterprise version is that it's the only truly reliable application server for Ruby that handles threads good enough. The administration tools and how it handles stuff like deployment upgrades to a huge application server are done remarkably better than in any other Ruby app server. &gt; Update process loads our application once and forks it to all the workers like Unicorn does. Puma wanted to load the application as many times as we had workers, which caused a huge spike every time we deployed. &gt; Same goes to the thread handling. It really seems Passenger is the only Ruby server able to handle massive loads with threaded Rails app. Money well spent.
It is threaded, 1.9 uses posix threads. There's a GIL so you can use can only execute on one core using ruby core, but IO yields. EventMachine/Goliath face the same issue. 
It's interesting to know that I'm being downvoted because people can't read. I never intended to compare a language implementation to a framework. What I said is: 1. Rails is slow 2. I have no clue what rubymotion is (I do now), so I won't make any comments about it.
Downvotes, apparently. 
Only thing is, it's not "single table" inheritance! There's more than one table involved, one shared one and one for each subclass, that's not 'single table'. It is a good fit for some use patterns though, and something that's been done before -- 10 years ago when I was using NeXT/Apple's WebObjects/EnterpriseObjectsFramework, EOF offered this pattern. I recall EOF supporting actually three implementations of inheritance. Another way to map inheritance is to actually have a completely separated table for each sub-class, with duplicated shared attributes in each table. Ah yes, look, the old [old EOF manual is still online](https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_4.0/System/Documentation/Developer/EnterpriseObjects/Guide/EOFDevGuide.pdf) It calls the three approaches: 1) "Vertical Mapping": "each class has a separate table associated with it. There is a Person table, an Employee table, and a Customer table;" (what OP has just re-discovered) 2) "Horizontal Mapping": "you have separate tables for Employee and Customer that each contain columns for Person." 3) "Single Table Mapping" -- what AR supports now, single-table inheritance, NOT what OP describes as improved. The EOF manual is also a good place to look to see the trade-offs and plusses and minuses of each one, depending on your use patterns. (Back then, Apple/NeXT wrote great developer documentation, I don't know if they still do). OP implementation seems reasonable though for sure, and this is sometimes a useful pattern. OPoster might consider make it into a general purpose gem, sure. Or theoretically it could go into AR as another option, sure.
I'm new to rails. I'm wasn't sure what I had just read, so I did a bit of (other) reading.... I'm puzzled. - Isn't the rails way to think in terms of models rather than tables? - Whats the problem with STIs apart from a few null fields? - If there are a LOT of null fields, shouldn't this suggest a problem with the model rather than STIs per se? 
I might be missing something, but I don’t think the orders.uniq is in your last example is necessary unless customers can share an order. Looking past that, I’d suggest this could still be simplified a bit: https://gist.github.com/Rio517/01f193794402b9aa734d ^ Rails 3 syntax. Rails 4 always requires a Proc is passed to scope.
[Pragprogs do a pretty good job of explaining this in the metaprogramming videos](http://pragprog.com/screencasts/v-dtrubyom/the-ruby-object-model-and-metaprogramming). Especially with walking through the "ghost" class.
The title is slightly misleading. There is nothing different about setting up a server for Rails 4, these instructions would work equally well with Rails 3, Rails 2, etc.
Setup Ruby from source? Just use rbenv or RVM and you're set. Also not a fan of using Apache with Rails, but that's more preference.
*"the only coding education provider that guarantees a $60,000 tech job after graduation"* Wow, that's a bold claim... *"announced today that it has launched a Ruby on Rails bootcamp designed exclusively for women interested in breaking into the software industry"* ...which, combined with this, means that $60,000 tech jobs guaranteed after graduation are only available to women. That's what I call fighting inequality! *"a unique learning environment that appeals to women who prefer to learn among other women. "* Yes, because segregation worked so well for the blacks. Oh, come on... *"experts in a number of programming languages, including Ruby on Rails,"* ...but they still can't distinguish programming languages from an assortment of libraries. Way to go, experts!
Thanks for posting this, because I came here to do the same thing. There are so many articles on setting up Rails production servers that you can start at any of them and wind up in the same place. I open an article like this to find out if there's any of note about deploying a Rails 4 environment that differs from the last major release. Whatever useful information was there is now lost to me as I close the browser in disgust.
This article should have been about the actual differences in rails 4 which have ops implications. ActionController::Live, for one, prefers an application server which will efficiently handle long-running connections (personal favorite: Puma). Front it with a evented webserver like nginx. Also, although I run MySQL myself, the rails community seems to favor Postgres nowadays.
He should check out ssh-copy-id. Avoid all that scp pipe cat copy rubbish. His password is so secure, it's impossible to use, so he set up an auto-login key on his laptop. That's fine, we all do it... Security is such an annoying thing to consider. Imagine the kind of stuff we could make if half of us weren't always trying to hack the other guy's stuff. 
Code Fellows also offers bootcamps that are co-ed, so there's no "segregation". However, the women-only bootcamps are a unique offering that can ultimately help a number of Seattle-area companies diversify their engineering base. It's a program that's fostering diversity, not discrimination.
R.I.P. MacRuby
You mean the MacRuby that RubyMotion is based on?
I couldn't even use it on my iPhone.. 
Same.. 
nice ... !
First thoughts: 1) I opened it on my iPhone expecting to be sad. +1 for responsiveness (even if you didn't write it, still awesome.) 2) I like that you break things into pretty bite-sized pieces. That's nice and easy to find what you are looking for. Also good titles for people who aren't Rubyists or even programmers. 3) If you want to teach someone a new language, especially their first, ignore as much as possible. I write Ruby professionally and have never written a while or until loop. I have used #times iteration rarely and upto/downto never. Always remember that beginners are digesting a ton of stuff, so delete as much as possible. For loops, while they exist, are never the correct choice. Not just in comparing to the more idiomatic #each, but also missing out on all of the Enumerable methods based on #each. There isn't any reason to know about for and in. That said, I think it is awesome. I like the More Reading section – try to link to the docs as often as possible. Getting comfortable with that resource (not just specifically Ruby but in software in general) is a great habit and solid knowledge to have. Keep up the good work!
Indeed, the MacRuby which is not benefiting from return contributions from RubyMotion.
- use discus or something alike for comments - in one of your hash guides u suggest a user to initiate it with =Hash.new vs ={} ... wtf - tags system seems sloppy
Thank you so much. This is exactly the kind of feedback I wanted :)
I wrote the article, and I agree that it's not exactly a replacement for Rails STI. However, the only time we'd need to query by a field that's not in the main table is if we're limiting our query to a particular subtype, in which case it's a simple JOIN. Mostly we're only querying by fields in the main table, though.
 I would ditch the Twitter box, and just link to your Twitter handle. It just junks up an otherwise clean site, and is of no interest to someone looking for tutorial articles.
Requires JavaScript to render anything :( -1
thats cool. seems great so far. just started with Ruby. will try out ur site. 
Anyone with NoScript (http://noscript.net/)
will fix that
The stars in the main navigation seem really weird since they scroll horizontally. Maybe use CSS3 to scroll them vertically on hover? Like the gray scrolls up to reveal blue.
same in chrome.
To start off the site looks great. The design is beautiful color-wise and layout-wise, if your target audience is someone looking for something specific. However, if your goal is to have a site that teaches the reader about Ruby from A to Z there really isn't a cohesive path to follow. You basically just hop around from blog post to blog post hoping to collect random bits of information. When I was learning Ruby I loved being able to google and find results, but I also really appreciated sites that followed a pattern of "learn this first and then keeps building on top of it." The Pickaxe book does this incredibly well. Overall, it's a great start. Keep fighting the good fight.
nobody worth catering to that's for sure
Is this a custom made blog / site or are you using a specific rails app? I like the design, it is clean looking. 
Looks great, Only one thing i could think of other than what's already been said. I read the 'Getting started guide' where then do i go? Is the top nav in order i should read through? if so that's great but you need to reorder the guides section so it has some sort of order about it. I see 'Getting started' is not the first item in that list. Great site.
can you give more details on your simple script option? (i.e. a gist of your actual file). I am currently doing the same rake/testtask and I dislike the extra garbage output.
Looks good, but the writing is a little bit off. Did you write it? I clicked "Getting Started" -- and this is the first sentence that confronted me: &gt;This page is supposed to be a starting point for completely beginners of Ruby. You mean people who are completely new to Ruby, or complete beginners, I assume. These sorts of things make the whole site feel a little hokey, and are pretty easy to fix. If it were me, I'd ask a friend to edit the copy and do a little testing. It's a nice-lookin' site, though!
Thanks for the response, that's actually more than I expected (the add on page is even showing close to 100 mil individual downloads). As you say there should at least be some sort of feedback for visitors without JS. I disabled JS in chrome to see for myself, and sure enough I get a completely blank page.
I agree, the content font size is the main thing that stuck out for me. Also, as far as the different colors in the header text, it works with the headers with multiple words, but looks off when it splits a word. For example, the effect seems more appropriate for color splitting "Our Ruby Guides" in the sidebar than "Search" above it.
Thank you :) Fixed now. 
Thanks. I will try to make it easier / clearer to navigate. 
for someone who learned ruby recently, I will agree with 3). Also, I do now write ruby full time in my work, and do agree; It's the first comment I made to myself seeing your website; for loops, etc.. are rarely (never?) used irl, so maybe its a good idea to focus more on each, maps etc... :)
My experience is biased toward very large sets of very related data, so most of my criticisms don't apply to a typical rails app. Feel free to ignore me if your tables stay under a 10k records in a join, for example. But from a performance perspective, joins are never simple, especially when your conditions and orderings involve both sides of one. That's because you cannot have an index that includes both tables, so it's going to be at least partially a scan, and scanning a join requires the rows to be looked up. While that's fast, it's not *fast*.
This is just like, my opinion man, but I don't like the slide-in effect on hover for many of the nav links. I'm not fond of waiting for the animation. IMO, a fast color change is better. Also, if you do want to keep it, why do the main nav link slide in from the right but the side bar slide in from the left? (Same comment applies to the hover effect on links)
Yup, I'm using Reel to route web socket requests &amp; regular HTTP requests through Reel and onto webmachine(if regular) or onto a object to handle the web socket. I had the most success on Rubinius(HEAD), not in terms of performance but because I saw a SIGSEGV on MRI 1.9.3 and JRuby stopped accepting connections after so many refreshes. Really enjoy building my application with Reel though.
 class Credentials &lt; Struct.new(:login, :password) end All other arguments aside, it's unnecessary to subclass this. It creates an extra class that will never be GC'd, and it takes an extra line. Credentials = Struct.new(:login, :password) If you later need to extend it, Credentials = Struct.new(:login, :password) do end
= {} seems way more noob friendly to me
How much actual work does this person get done? The original was clear and worked. Spending hours thinking about and removing anything vaguely resembling a code smell is a great way to accomplish nothing.
Looks interesting. I'm curious as to how DRb didn't serve your purposes...?
I just updated the article adding a section referencing exactly how I am using the script: http://crashruby.com/2013/05/10/running-a-minitest-suite/#update-2013-05-11
That's funny, I just wrote one of these yesterday! Looks good! You might want to double check your implementation of “[” though, as it should skip to the end of the loop if the current byte is 0.
The `to_s` part is just unnecessary. It is done transparently when interpolating the string. Simply use `"string interpolation: #{my_var}"`.
I created Active Reload (https://github.com/paneq/active_reload) so that everybody gets done a little more in our limited time and it was incorporated into Rails. So I don't know... Perhaps I get something done and care about delivering value. And I did not spend `hours` thinking about it. The change did not even take 5 minutes...
I totally agree, though I do actually like defining a self.new sometimes. Seriously, when I got to the point where the author draws the conclusion that it's time to Extract class, I chuckled to myself.
I totally overlooked the `to_s` bit and thought you were speaking of the `#{}` bit. I need sleep.
This is why I left CS. These type of academic solutions so far separated from the real world no real work is done
subclassing also makes it difficult to reload the code in the file.
hey. I don't know a lot about drb internals but ichannel is a channel that can act as a message queue for interprocess communication. It doesn't depend on a client-server model when used with an (unbound) unix socket, and redis can be used to add network support. I believe the server side is implemented in Drb &amp; pure ruby but ichannel leverages redis instead. I think drb also has a much bigger scope and is more like a framework instead of being just a channel or message queue.
Yeah. Just sometimes it is very hard to decide which code smells we want to live with and which should be refactored right now. And of course my example was just trivial (although real). I hoped people would focus more on whether there is any usecase for overriding MyClass.new .
I have no problem with academic solutions/discussion after work. No customer was charged for writing this blogpost and my answers to comments about it in the Internet. And I surely believe that world with more discussion is a better one. I feel little sad that you think my post is a good example of what is keeping us (our industry) from getting the work done. From what I see in the Internet, people who talk a lot, blog a lot, and discuss on conferences are those who are most active in open source community and provide lot of value. But I also know some very good programmers who are not much into blogging but they still create awesome code for the customers.
&gt; How much actual work does this person get done? I imagine he bills all the hours he wants. That's the beauty of "refactoring."
It seems kind of sad that a piece of software (1) brags about breaking backward compatibility, and (2) cross-compiles to a semi-implementation of a VM designed mainly to skirt a trademark. 
I think the problem in this case, is you fixed one smell (paired concerns), and introduced a new smell (excessive indirection). And, the new smell is worse than the old smell. Then, not only did you make the code worse, but you also spent a ton of time thinking about it and justifying it. Now, since you're just blogging about it, this extra time is fine (and actually healthy). I think the reason people think things like "How much actual work does this person get done", is because many of us have had co-workers that basically do nothing but theorize about code quality, and spend time refactoring. This type of thing is especially annoying when the critiques on the code quality are marginal at best, and sometimes even just wrong.
thanks :) I've built a few things but i haven't taken advantage of redis in any of them yet. there's a process pool &amp; a project called "ifuture" which implements futures on top of subprocesses. 
Does it do anything new or better than Nokogiri or Mechanize?
It combines Nokogiri and a bunch of other libraries to help you with converting lots of HTML files to xlsx/csv/whatever output format you wish to use.
The point is that the anonymous class returned by `Struct.new` won't be used for anything *but* subclassing and is therefore unnecessary. It's equivalent to doing the following: class X attr_accessor :some_instance_variable end class Y &lt; X; end instead of simply class Y attr_accessor :some_instance_variable end If you don't intend on subclassing X again, there's no reason for `X` to exist. The same goes for Structs. If you don't intend on subclassing the anonymous class `Struct.new` returns again, there's no reason for that class to exist. Plus the syntax is not very pretty :P
like this? class ApiProvider DEFAULTS = { usr: ENV['APIPROVIDER_LOGIN'], pwd: ENV['APIPROVIDER_PASSWORD'] } def initialize(credentials = DEFAULTS) credentials.assert_valid_keys(:usr, :pwd) @uri = Addressable::URI.parse("http://api.example.org/query") @uri.query_values = credentials end end
That and it doesn't match the width of the lines between the links on the menus above the Twitter box (at least on my resolution) so the entire box makes the website look 'off.'
I suggested that the api provider have no knowledge of the ENV. It should insist on a username and pwd. That makes most sense to me.
Have you done any performance testing on this? 
Where do you typically put the publisher and listener definitions in Rails? Under models, lib, or somewhere else?
I got lost right at the beginning, not understanding what OP thinks the benefits are of splitting logic that started out in #initialize into both #initialize and #new. I don't understand how/why splitting the initialization code between #new and #initialize makes anything more clear; OR how it leads to more possibilities for flexible re-use. What is the benefit supposed to be? Personally, I would and do not over-ride the default #new unless I need to do something odd that can only be done there -- like actually return a different class from #new than would usually be returned. Which is something I've _maybe_ needed to do once, although I'm not sure it even lasted in my codebase that once. I am not neccesarily opposed to passing in arguments as a Struct instead of a Hash, although likewise I'm not clear on what it's supposed to gain. But I can't even get that far, I'm still stuck puzzling over the new/initialize. 
reminds me a bit of my [cross-talk](http://github.com/jfredett/cross-talk) gem. Which is similar except that: * it triggers a notification to the manage for ever public method call on any Cross-talk object (ie, anything that includes the module) * Provides a different API (instead of Listener objects, there's a class macro) * Uses a weird feature of ruby -- wherein you define a method with a name that couldn't be used in a `def` statement. * Probably has terrible... terrible performance implications. It was a harebrained idea I had while hanging out in [#lpmc](http://learnprogramming.github.com). I wrote it up in an afternoon or so using Celluloid to do async stuff without configuration. I sometimes think I should go and try to see if I can make it performant, then I decide it would be a terrible idea.
What is the error message? Without seeing the error message my guess is that "words.split(" ") is not doing what you want. That will return an array of strings, but it will not change the existing words variable. To do that you need to use the split! function instead. Also, unless I'm mistaken, split and split! both use whitespace by default, so you can just use "words = gets.chomp.split" on line 2.
There is no `String#split!` so you'll have to assign the result of `words.split` to something in order to get the array that gets returned by it: words = words.split(" ")
I'm fond of app/modules, or app/lib.
Hey, my nickname is Jester... (retsej backwards even). The error message is &gt;undefined method `each' for "(whatever is entered in 'words')":String 
not saving the result of your split `words = words.split(" ")` or ~~`words.split!(" ")`~~ or ~~`words.split!`~~
 words = words.split I think that should do it? EDIT: Oh wait... I don't think you'll be getting an error but the program probably won't do what you want, unless you just enter one word to redact.
The problem is this: most methods are not "destructive" -- that is, they don't modify the thing you're working with. Methods that ARE destructive often have exclamation points in them. For example: sentence = "This is a sentence with secrets that needs to be redacted." sentence.gsub('secrets','HIDDEN') #=&gt; "This is a sentence with HIDDEN that needs to be redacted" sentence #=&gt; "This is a sentence with secrets that needs to be redacted." The *sentence* variable isn't modified here; the gsub method just finds all instances of "secrets" and replaces them with "HIDDEN". Contrast that to this: sentence = "This is a sentence with secrets that needs to be redacted." sentence.gsub!('secrets','HIDDEN') #=&gt; "This is a sentence with HIDDEN that needs to be redacted" sentence #=&gt; "This is a sentence with HIDDEN that needs to be redacted" The gsub! method (note the exclamation point) is destructive; it modifies the *sentence* variable in place. Thus, the following statements are functionally equivalent: sentence = sentence.gsub('this','that') sentence.gsub!('this','that') There is no such method for "split" -- so you need to specify it like this: words = words.split(' ') But using split and each is way less efficient than just using gsub.
That means that it is calling "each" on a String, instead of on an Array - the 'each' method only works on Arrays. you might need to do words.split! (to make it change and save to the "words" variable) or save words.split to a new variable ( wordArray = words.split(" ") ) Sorry, I'm busy. I can clarify if that makes no sense/didn't work. Reply here.
Is the value of redact just a single word, or a series of words?
 words.split (" ") This returns an array but you aren't doing anything with it. All you had to do was: words.split(" ").each do |word|
Don't limit yourself to the rails default directories - if it makes sense to have app/listeners or whatever, go ahead and define your own structure.
in the case of gsub! a little gotcha is that if the pattern isn't found, it returns nil. Can't remember the context in which that screwed me up, but I always remember that one.
Whoa, that is absolutely weird. So actually, those statements are not equivalent. Who made THAT decision? Crazy that gsub would return the string if no match is found, while gsub! would return nil... Thank you for telling me! That's crazy! 
The Codecademy message boards are moderated, so most questions get answered by experienced programmers soon after they are posted. "#{word} "
Completely agree. Nil is actually insane to return...
Agreed. gsub! is better because it leverage also regular expression, a powerful *and* painful method for string matching. Something like this may be a better solution: puts "Text to search through: " text = gets.chomp puts "Word to redact (separated with spaces): " # this split already the words, so redact is an Array redact = gets.chomp.split # because we want to redact a bunch of words redact.each do |word| # We replace every occurrence of the words, despite the case text.gsub(Regexp.new(word, Regexp::IGNORECASE), "REDACTED") end puts text The only weakness of this implementation is that the words, in a real world scenario where inputs come from untrusted sources, **MUST BE ESCAPED** before giving them to the Regexp constructor because there could be some special characters that need to be redacted[¹](http://ruby-doc.org/core-2.0/Regexp.html#label-Metacharacters+and+Escapes). example: Text to search through: The quick brown fox jumps over the lazy dog Word to redact: jum.s The quick brown fox REDACTED over the lazy dog So, a correct implementation could be: puts "Text to search through: " text = gets.chomp puts "Word to redact (separated with spaces): " # this split already the words, so redact is an Array redact = gets.chomp.split # because we want to redact a bunch of words redact.each do |word| # We replace every occurrence of the words (escaped), despite the case text.gsub!(Regexp.new(Regexp.escape(word), Regexp::IGNORECASE), "REDACTED") end puts text But, there is a small issue using this implementation (or gsub in general). We are going to substitute every match of the word, and not only the complete word. *Hello*, matching *hell* will become **REDACTED***o*. A way to do the correct word substitution (still leveraging regular expressions and group naming[²](http://ruby-doc.org/core-2.0/Regexp.html#label-Capturing)) could be: puts "Text to search through: " text = gets.chomp puts "Word to redact (separated with spaces): " # this split already the words, so redact is an Array redact = gets.chomp.split # because we want to redact a bunch of words redact.each do |word| # I'm doing the interpolation on another line for sake of clarity regexp_pattern = "(?&lt;pre&gt;[\s\A])(?&lt;word&gt;#{Regexp.escape(word)})(?&lt;post&gt;[\s\Z])" # We replace every occurrence of the words (escaped), despite the case text.gsub(Regexp.new(regexp_pattern, Regexp::IGNORECASE), '\k&lt;pre&gt;REDACTED\k&lt;post&gt;') end puts text If there is anything i have left out or need to be more detailed i will be happy to help.
I guess the way I tend to use `gsub` I want the full string returned regardless if the pattern was found. I want it replaced if the input string has it, otherwise leave it alone. This is why I use the alternative form. Having it return `nil` is useful if you want to check whether something was replaced or not.
This is a fantastic explanation and helped me understand some workflow and ruby features I hadn't thought of or knew about before. I really was able to follow the way you explained it and am grateful you took all the time to write that out. Do you do any teaching? Write a ruby blog or anything?
The content of the *sentence* variable will be the same, so they are more or less equivalent; The caveat is that in the first line, the **gsub** one, we cannot know if a substitution has been performed without writing other code, but in the **gsub!** version we have a feedback on the action performed (*nil* == *nop*).
Thank you for the feedback. :) Nope, i don't have a blog (for now), but i plan to create one (I think that sharing the knowledge is one of the most beautiful thing a developer could do).
I think that could lead to a greater use of resources. As a rule of thumb i would say that **gsub** should be used to create multiple versions from the same string, and **gsub!** when we don't care to keep the original string (so i would exclude the case: sentence = sentence.gsub(/rxp/, 'text') ) Sadly now i'm too tired (2AM+ here) to write thorough tests to verify my point (i wrote a response and then i deleted it because it was too partial and doesn't cover the entire spectrum of the problem) or that i'm wrong. I hope to be able to test my supposition tomorrow. :)
This is a fine place to ask questions, but make sure you check out http://stackoverflow.com, it's well suited to Q&amp;A.
Here is mine for comparison. I would say it is because your not saving your words.split to anything puts "Enter original sentence: " text = gets.chomp puts "Enter word to be redacted: " redact = gets.chomp word = text.split(" ") word.each do |x| if x != redact print "#{x} " else print "REDACTED " end end 
I wouldn't say I'm frustrated, but I wish it was already here and usable in production. :) To a certain degree I think it's not bad that ActiveRecord has this monopoly position in the rails community, it drives a lot of easy to use libraries. Obviously the cost is also apparent. But hey, that's part of reason why Datamappify is here for. :P
A good place to ask questions for a quick response is irc. Particularly #ruby or #ruby-lang on irc.freenode.net
I'm using `app/listeners` also, but pretty much anywhere is good.
It's more curiosity at this point. One project I am working on has very high throughput and needs spiffy response so I would need to look at performance before using it for that.
it's p429. Your link doesn't work. http://www.ruby-lang.org/en/news/2013/05/14/ruby-1-9-3-p429-is-released/
I figured the most likely source of perf issues is actually the notification loop on every public method call (I told you it was a harebrained idea. :) ). I've not profiled it, so I don't actually know that there is any, it just seems reasonable to assume one would exist. The aliasing bit isn't so bad, since it really only happens once (when you add the method) at startup time. I suppose there is the layer of indirection introduced, but method calls are pretty snappy in general, so I imagine there is likely *some* performance degradation, but not much, due to that.
Good point. Now fixed :)
Thank you so much for all the feedback!
This is not really a comment on the release itself, but I just found this pdf of zenspider's (in a GitHub issue comment), and I'm finding it helpful. It visualizes the differences between minitest 4 -&gt; 5: http://www.zenspider.com/~ryan/minitest4vs5.pdf
I felt this was appropriate for the ruby community in that * we program with a dynamic language * there is some amount of flexibility in language choice * we like learning from ruby programmers * we hired one of your community * it's a job opportunity to facilitate research in diseases like cancer :) 
Ah understood, I'm mainly working with Rails so the latency of TCP is the bottle neck over any Ruby performance - without adding malicious `sleep`s anyway :)
We're lucky to have not one, but two great package managers. I've already updated on my desktop $ rvm get stable ... $ rvm install 2.0.0 ... $ rvm use 2.0.0 $ ruby -v ruby 2.0.0p195 (2013-05-14 revision 40734) [x86_64-linux] and on my laptop $ cd .rbenv/plugins/ruby-build/ $ git pull ... $ rbenv install 2.0.0-p195 ... $ rbenv rehash $ rbenv global 2.0.0-p195 $ ruby -v ruby 2.0.0p195 (2013-05-14 revision 40734) [x86_64-linux] and I only read this a few minutes ago! 
What about chruby – I've heard it's a good strategy, too! (Though I suppose it's not classified as a package manager)
I haven't tried chruby. [It looks neat](https://github.com/postmodern/chruby)!
It's exactly as much of a package manager as the other two. Which is to say, not very much.
lol - understood, well it got me thinking about a way I could setup some form of detached pub-sub such as `Wisper::Broker.subscribe(ActivityListener).to(CreatePost).on(:all)`. Any messages emitted by instances of `CreatePost` could be forwared with args on to an instance of `ActivityListener`.
... aaaaand CloudFlare is only being partially successful keeping my cheaply hosted WP site running.
Yah -- The original idea for cross-talk came from talking about a game engine. Ideally you want to be able to listen to arbitrary messages from arbitrary objects. Right now, `cross-talk` requires you to specify the class sending the message, the eventual idea would be to have some kind of wild-card system, so you could say "For any class, listen to the 'foo:before' event", and it would happily notify you for any such event. Then extend that by saying, "For any class which implements #bar and #baz, listen for #foo:before" and so on. As far as performance goes, it actually might not be so bad, since it's designed to be asynchronous. The real worry is that 1. There are potentially tons of events. In fact an unbounded number. 2. The Event Dispatcher is single-threaded. It would be pretty cool to set up a worker pool for the Event Dispatcher (called the `Manager` in `cross-talk`). As far as the unbounded number of events, it's really a matter of making the dispatch as efficient as possible, and encouraging a style where events tend not to trigger to many others. Since each event is basically a string and a pointer to the sender, it should behave well wrt GC (ie, not spawning new symbols all over the place). The question really boils down to how many of those objects there might be at any point. If you have each event spawning 2 more, and no 'sinks' (events which consume an event but trigger no new ones), then you have an unstable, diverging system which will eventually consume all system resources and crash. Similarly, if this is the only communication mechanism in your program, and you have more sinks than faucets (faucets = consume 1 event, produce &gt;1), then in theory you should always 'run out' of messages. This of course is not hard and fast, you might have +infinity sinks, and 1 faucet that calls itself twice, now you have divergent behavior despite all your sinks. I've gone off on a tangent. I guess what I'm saying is the _real_ 'performance' problem comes from the fact that it's pretty hard to reason about the performance characteristics without knowing every potential listener object. I think that's not hard to overcome, but I don't know of many sources of research on the topic. I do know that in *Object Thinking*, David West describes what I perceive as a similar system, through the lens of Smalltalk. That was definitely an inspiration for `cross-talk`. I think one thing I'd like to try is automating some sort of faucet/sink diagram based on the same DSL used. It shouldn't be *too* hard to analyze what gets called via a proxy object, and generate a pretty rich diagram which could help identify sinks/faucets and generally analyze the probability that you'll have unbounded message explosions/network death (the latter being every object stops 'talking' and messages stop being sent). It's a really fascinating way to think about programs which reminds me a lot of Erlang and Smalltalk. I think it could be made more efficient, and it even (should) play well with remote, distributed objects a la DCell.
Do you run off a VPS, or are you on shared hosting? If you have administrative access, I really, *really* recommend setting up Varnish - you don't need to spend more than 30 minutes to get it in a state that will almost entirely negate Redditting. It's wonderful.
Since the site is down, I'll just make speculations - reading large files into memory can cause you to run out of memory on the machine, which is a Bad Thing. We have tools to not do that - pagers for file viewing, and line-by-line reading inside programming languages. Use them.
CloudFlare and WP-Cache should be sufficient to handle /r/ruby's load. Sadly, it turns out that the real problem is that [DreamHost's network has shit itself](http://www.dreamhoststatus.com/2013/05/15/networking-issues-affecting-us-west-data-center-los-angeles-ca-2/). Varnish, as cool as it is, wouldn't save me in this particular situation either.
you can also do a similar thing with the ruby aws-sdk: File.open("output.txt","w") {|f| s3.buckets['my-bucket'].objects['path/to/my_large_object'].read {|chunk| f.write(chunk) } } 
Pretty much it, yes. But this in particular is about Fog and reading/writing across the network with S3. I wrote it since the Fog docs are a little terse, and I've repeatedly had people punt on writing stream-based code because they didn't think it was necessary or even supported.
`$POSTMATCH` is part of the gem `english`. In order to use it as `$POSTMATCH` you need to `require 'english'` at the top of your file.
Is this something that different ruby implementations handle differently? Like I said I wasn't able to reproduce the problem under JRuby 1.9.3 but under the windows build it was there (linux doesn't seem to care either).
Line by line reading is horribly slow if you are using the builtins though. - a buffered readline implemented in ruby is way, way faster than a using the stock version. 
Well CRuby is really the reference implementation. It's not really broken in CRuby. You just need to include the "english" module. I bet that JRuby just defines that global variable by default. Checking this file confirms it: https://github.com/jruby/jruby/blob/master/src/org/jruby/RubyGlobal.java#L262 So if it works in CRuby but doesn't work in another implementation, it's a bug in the other implantation. In this example, since CRuby requires the import, if it also works with the import in JRuby, then there is no problem. If it doesn't work with the import in JRuby, then it's a bug in JRuby.
 require 'English'
Ahhhh . I understand now. Thank you for the insight!
This great information, and the illustrations are wonderful. Nice post!
Love it!
Looks useful, I'll consider it next time I do scraping.
&gt; I am using Ruby on windows There's your problem.
Nice, wish this was around when I was taking CSCI. Really good explanation of Locks, Actors, and STM
You mean when the next release comes out? Yes. You can do [rvm list known](https://rvm.io/rubies/list/) to see the available rubies. Mine currently has $ rvm list known .... [ruby-]2.0.0-rc1 [ruby-]2.0.0-rc2 [ruby-]2.0.0-p0 [ruby-]2.0.0[-p195] ruby-head The square brackets mean optional, so saying just 2.0.0 means ruby-2.0.0-p195. When there's a newer one, then 2.0.0 will mean that after the [rvm get stable](https://rvm.io/rvm/upgrading/). You can always use the full name if you prefer.
Where have you been all my life?
Little tip for testing the gem without building it: bundle console It open a IRB session loading your gem. It has been very helpful to me from time to time when i only do small changes and i need to code fast. :) relevant link: http://gembundler.com/v1.3/bundle_console.html
It wasn't
Agreed.
who put the book in the book (dot) book (de book)?
Ruby 1.8.7 is very old now, I doubt its supported. The github repo you linked to has no real compatibility info, but i would guess that it will only run on ruby 1.9. Install ruby 1.9.3 (ruby-lang.org) and try again.
Goddamn CentOS repo's screwing me again.
I don't really want to use RVM for a prod, stable environment. We also run puppet which is much more critical for our infra, so screwing around with RVM on rbenv just to get a monitoring script working sounds like it's just going to cause me hassle
No matter what changes you made, the most numbers I could make out at any one time were three (counting the control number 25). I never could make out the bottom left number, and the top right was very fuzzy but, using the fact that I know what it is already my brain says it must be 20. Either way this helped me to see the 8, 45, and 56 (56 is the only one I can make out with no processing). What would you use this for?
did you look at the individual examples for deuteranope/tritanope/protanope? (based on the wikipedia images) Depending on your type of colour-blindness, this implementation can help you distinguish between colours that otherwise you won't be able to tell apart. It should provide even better results than the existing implementations of daltonize. However, we didn't have enough volunteers / time / budget to do a proper test. It was mostly from anecdotal evidence.
Ok, take into account that not all images are 'proper' tests for all colour-blindness. The Ishihara test, as far as I'm aware, is only meant to cover deuteranopia. So whilst there are examples of different processing, they are not necessarily meant to work. i.e. if you have tritanopia, then looking at the numbers on the Ishihara test is not going to help you. However, if the tritanope processing is done on other images, you should be able to separate colours better. That's my limited understanding of it. I'm far from an expert on this, and it's hard to tell which deficiency you might have or what's the best 'test' for it... As I mentioned, the anecdotal evidence we got from other colour-blind people (mostly deuteranopes I believe), was that the algorithm performed better for them than other implementations (which might not be perfect anyway).
CentOS does not support versions of Ruby other then "1.8.7". You will have to install Ruby 1.9.* manually unfortunately. You might want to try to https://github.com/postmodern/chruby or https://github.com/sstephenson/ruby-build#using-ruby-build-standalone
&gt; although I would have preferred 12.04.2 LTS, but 11.04 is the newest version of Ubuntu MT offers Whelp, I'm sold. "Hello, Linode? Yeah, it's MediaTemple. *YOU WIN.*"
use rbenv, seriously. do not rely on centos' repos (or epel or whatever) for a production ruby environment. otherwise, you could build from source.
Or find a RPM of 1.9.3 or 2.0.0
This is my first time writing ruby, so any thoughts on the actual code would be helpful. 
This is really a matter of pick-your-poison. Long methods and classes are brittle and don't lend themselves to apps that grow a lot over time. In my experience your typical business app will scale out and need new paradigms. Linear code is bad for this. On the other hand many layers of indirection come at a performance penalty both in the code and in the developer. While it may be trivial to implement yet another WidgetFacadeStrategy it is a real challenge to add a truly new feature or understand what the hell is going on. Manufacturing systems tend not to change too often so linear code works really well for them. In your case I suspect your code fits your domain very well. Refactoring your code to follow rules such as these would come at a huge cost to the business with little benefit. My domain tends to be business management and ecommerce, where the rules and paradigms change fairly often. I cannot tell you how many times I have wished that my predecessors had used rules like these to build the systems I have maintained and updated.
hard limits are silly, i like sandi when she sticks to the reasons behind these rules.
Arbitrary rules like this are hugely counter-productive.
Nice! I had no idea that existed, thanks! I'll add it in as an edit at the bottom next time I make an update : )
5 lines per method? Seriously? I write methods that get the job done, and try to make them readable and well commented. 
I'm pretty new to minitest but I think it was a good call to shorten/simplify module/class-names. Minitest::Test is better than MiniTest::Unit::TestCase and so on.
Yeah, but because many will be too lazy to do so, I'll try to summarize. Basically, first of all these are not hard rules. If you can explain why the rules only make things worse for a piece of code, ignore them. Secondly, she doesn't really want to give rules at all. For the people she talks to, she tries to make them get a feeling for clean code without setting any rules. These rules are only given to those adamant that they should be given rules. And even then she is up front about the fact that these are arbitrary.
&gt; We recently concluded our experiment as a success, published results in our research newsletter, and have incorporated the rules into our best practices guide. "We" think you're kind of a joke, [Caleb](http://www.reddit.com/user/Croaky.compact).
middleman for static stuff. actually, middleman and backbone for dynamic stuff too.
rails for most crud apps sinatra for pure API apps rails + grape for crud app with an api standard rails toolkit for me is: Rails, Devise, Cancan, Kaminari, Slim, Simple Navigation, twitter-bootstrap-rails, simple form, minitest, capybara, cucumber, database cleaner. Depending on the type of app, Mysql or MSSQL (the latter for 'serious' apps mostly because that's what our DBA does so that's what we use). I honestly can't say I really do much in the way of static websites. If I had to, honestly, I'd probably just do plain old html. And though not very /r/ruby friendly, if I need a mostly static website the customer can manage, I usually use drupal.
I'm just switching from years of PHP development to ruby/sinatra/rails, rails ecosystem has gone wild since I last saw it, no there's at least a couple of gema for everything, every single one with is pros and cons is overwhelming
I love middleman so much. I use it on static sites as well as prototyping templates. 
Meteor! It makes developing fun again. Rails is like a giant RV that can be customized and depended on. Meteor feels like a BMW. Definitely pitfalls but I am tired of massive crud frameworks now. 
FreeBSD + Nginx + Passenger + Sinatra + Sequel + PostgreSQL done...
until is stops your inspector from working because it rerenders the template every damn second.
Ubuntu 12.04, Nginx, Postgres, Rails w/ Devise, CanCan, SimpleForms, Zurb Foundation SCSS, rspec/cucumber Oh and a crap-ton of pry :)
Sorry, but just because a project have old commits and haven't released in a while, doesn't mean it is inactive at all. It could mean that the implementation is stable, and no-one have experienced issues. If 200 gems depend on this software, and are not complaining or switching it out, it would seem that it does it job. &gt; That all shows me that it’s still active and I feel better if I know that there developers fixing bugs Sure that is a nice feeling, but that may also introduce new bugs.
I agree with your sentiment but in this case the project doesn't look particularly active. There isn't any place to report issues and pull requests aren't being responded to.
maybe. wait until you hear about using http://parse.com or http://firebase.com
Sure. I do not say that the project is bad or buggy. I used it for 1 year and it worked out quiet well. But at the time the newest version was released rails 2.X was kind of new. That means the GEM doesn't have support for rails 3.X. And if there are issues in future, where do I get support? There is even no active issue tracker. I made already bad experience with old "dead" libraries. That's why I am more sensitive to this topic. 
&gt; That means the GEM doesn't have support for rails 3.X. That is a reason for writing yourself out of it, but your article didn't state anything about that. I just see a lot of people rewriting away from working solutions to "the next popular gem" just because it is the most popular. 
Pretty much the same except Haml over Slim, Rspec over minitest and Postgres as a DB. Cancan is starting to get on my tits though. I'm looking at 'authority' to replace it.
I'm curious, why several people said they use Sinatra for API's with or alongside Rails apps? Why not make the Rails apps restful and get the API for free? Pros, cons? What should I know--what am I missing here?
I was wondering this too. 
I've found cancan to be problematic too, especially when things get more complicated than a simple check one property or relation for access. I have some pretty gnarly cancan rules which I hate. I was thinking of giving [Pundit](https://github.com/elabs/pundit) a shot for my next project, though Authority looks like a similar idea and perhaps a bit more mature.
There are a few reasons you might not want to... For most of my rails apps that need to serve up an API, I mount a [grape](https://github.com/intridea/grape) controller in the app. The reasons for this are: 1. Can implement separate authentication system (e.g. token auth) without it being available to the web app 2. Can serve up a read only API through said authentication system, without any concerns that something mis-configured might allow access to something I don't want exposed through the API. 3. I have the flexibility to massage data easily for API only clients, or rename endpoints, or even make a not-entirely-rest endpoint if it makes sense.
This definitely works for me: #= require jquery.scrollTo in my application.js.coffee includes vendor/assets/javascripts/jquery.scrollTo.js.
Looking a little closer the author is using ```require_tree``` instead of ```require```. I'm not sure about the behavior in that case.
 1.9.3p392 :003 &gt; "2013-05-19T23:11:10-04:00".to_time =&gt; 2013-05-20 03:11:10 UTC Edit: this was done in a rails console, and to_time is is part of [ActiveSupport's String Conversions](http://apidock.com/rails/v2.3.8/ActiveSupport/CoreExtensions/String/Conversions/to_time)
FYI, this requires ActiveSupport. You can achieve the same without outside gems by requiring the time library and using Time.parse: require 'time' Time.parse "2013-05-19T23:11:10-04:00" =&gt; 2013-05-31 21:11:10 -0600
already edited to reflect that, sorry ;)
this is prolly better than having to include AS! Mind you, it even returns a time object in your local timezone, if that is intended. 1.9.3p392 :001 &gt; require 'time' true 1.9.3p392 :002 &gt; Time.parse("2013-05-19T23:11:10-04:00") 2013-05-20 15:11:10 +1200 
Your timestamps are in the `xmlschema` format. So just do this: Time.xmlschema("2013-05-19T23:11:10-04:00") #=&gt; 2013-05-20 03:11:10 UTC It's faster and more foolproof than `Time.parse`. `Time.parse` will try a variety of formats, and pick the first one it thinks is right. Often that's fine, but in this case you know ahead of time what the format is.
I didn't know about Time.xmlschema. I'm downvoting myself and upvoting you for this. :)
The chronic gem will parse almost any time format that gets passed to it. 
I am not a hipster. The "next popular gem" is for me not so important. I just want to have something working. And an active project has the advantage that I get support if needed. I am even willing to pay for important BugFixes and new Features. But if the core committers are not responding since 2 years, than all hope is gone. 
The best answer for this is separation of concerns. Utilizing your already RESTful routes in a rails app is totally doable. However in most cases your external API doesn't need to or wont map directly to the same routes that your rails app does. You may have custom routes in your rails app that don't need to be exposed as an API. Likewise, you will probably want to have some custom routes (returning custom data) in your API that you don't need in the core web application. You also have to worry about things like token authentication and versioning for the API. If you have to do those in your rails controllers it can quickly complicate your life. Separating those concerns simplifies your implementation. I use Sinatra specifically for APIs because it's a quicker solution then using Rails controllers or Rails API IMO. And since Sinatra rides on Rack you can easily mount your Sinatra API in your Rails application and deploy them together. TL;DR - It's quicker and simpler to build an API in Sinatra than in Rails
The quickest way to find the good gems is to check out [Railscasts](http://railscasts.com). Ryan does a good job of overviewing the most popular ones for any given problem.
I am re-upvoting you out of whimsy!
You can use just ruby-build to build a newer version of ruby. 1.8.7 is falling out of support _very_ soon (if it hasn't already). Running on it in prod is not a good idea. There exist wrappers, I'm sure, for puppet around ruby-build, use it, you won't regret it.
Railscasts is a valuable asset, but he can only do so much and many of them are out of date by now. https://www.ruby-toolbox.com/ is a better resource for gem discovery IMO. There are many gems out there that are too niche to warrant a Railscast episode or are one of many alternatives for the most part, but maybe do something more to your own liking (like triggering Google Analytics events server side or something).
It doesn't matter, none of these contortions should be necessary. Something else is going on. On second look, OP only linkspams this one blog, and its other articles are no better. Downvoting.
Why put it on Heroku? Isn't the point of a Jekyll blog the static output?
Free hosting with git deployment? 
[GitHub Pages](http://pages.github.com) seems like a much better solution then
You can host static files on Heroku fairly easily.
Yeah, it seems dumb to pay for a dyno to generate your site when you can do it locally and just upload the result. I'm struggling to see the upside of using Jekyll on Heroku.
Except you can't use jekyll plugins on GH-pages. So it's not perfect. S3/Cloudfront, on the other hand...
Well... That was completely bonkers.
EDIT: You actually are correct with a caveat, see my response below. You're only half correct. You can only set up a custom domain for `yourusername.github.io` (note, it's no longer `yourusername.github.com`). So, for example, you could have `yourdomain.com` point to `yourusername.github.io`. The rest of your gh-pages in that case will still be at `yourdomain.com/repositoryname`. In other words, as my original comment stated, you can only have one "site" per account, where a site is defined as a unique domain. That site, however as you pointed out, can have multiple pages, including separate pages for each repository. Source: I've tried to set up a unique domain for multiple different repositories; it doesn't work. Also, [Github's documentation](https://help.github.com/articles/setting-up-a-custom-domain-with-pages) actually states that it won't work.
&gt; Exactly how you would if you were deploying to Heroku or S3. You *can* generate them locally when deploying to Heroku, but this article actually describes how to have Heroku compile your Jekyll site dynamically. In other words, Heroku will allow you to use Jekyll plugins *without* compiling locally if you follow this article. +-------------------+----------+--------------+-----------------+ | | Heroku | Github Pages | S3 | +-------------------+----------+--------------+-----------------+ | Compile locally | optional | optional | required | +-------------------+----------+--------------+-----------------+ | plugins supported | yes | if compiled | always compiled | +-------------------+----------+--------------+-----------------+ EDIT: I should clarify that Heroku's remote compiling isn't the same as Github Page's remote compiling. Github Pages actually compiles to static and then serves the static site. Heroku, however, does not allow permanent writing to the remote filesystem, so this isn't possible. Therefore, the only way to have Heroku dynamically compile the site is to have Heroku run the jekyll gem, which is a Rack server that compiles on the fly with each request. This is not optimal.
Good article, but a deeper question that wasn't quite addressed is the whole point of using public, private, and protected in Ruby. I was confused about this because if you send(:method), you can disregard any scope rules and use whatever message you want, regardless of how it's been scoped. I think Giles Bowkett said something to the effect that method scopes in Ruby are like locking your doors when your next door neighbor is Dr. Manhattan. What's the point? As with many things Ruby enforcement is not the point but rather convention and communication. I quit using method scopes altogether and have returned to using them in the manner in which I think they have utility in Ruby: Communicating what you intend to be the most stable (public) parts of your class vs. the parts that are apt to be changed (protected, private). I also only provide unit tests to things that are public, and put care into deciding what I will make public. Private stuff is completely malleable, if you want to fuck around with the internals go ahead, nobody can stop you, but at least you were warned about depending on them.
You know, I haven't actually tried this since probably a year and a half ago, and at the time, it wasn't possible. You could include a CNAME in each repo, but it would ignore all but the first CNAME file (i.e. the one under `github.com/yourusername/yourusername.github.com`). It appears they've since added support. From their updated documentation: &gt;A custom domain on User or Organization pages will apply the same domain redirect to all project pages hosted under that account, unless the project pages use their own custom domain. &gt; &gt;Warning: Project pages subpaths like http://username.github.io/projectname will not be redirected to a project's custom domain. So, it seems you can now have a unique domain for each `gh-pages` branch, but the redirects won't all work. So, for example, you could have `yourfirstdomain.com` point to your user/org repo, and then have `yourotherdomain.com` point to the `gh-pages` for one of your projects, and it will work, except if someone directly visits `yourusername.github.io/projectname`, it will *not* redirect to `yourotherdomain.com`. I imagine you could get around this by including some javascript on your project page that performs the redirect if the viewer is accessing the page via `yourusername.github.io/projectname`.
The only benefit of compiling remotely is that deploying updates is simpler. If you compile remotely, you just save your changes and deploy. Otherwise, you must save your changes, compile locally, save the compiled result, and then deploy the compiled site. However, because Heroku actually compiles a Jekyll site on each request (see my edit in my previous comment), the benefit is definitely not worth it. That's why my comment elsewhere in this thread is that the linked article probably isn't the best way to host a Jekyll site.
you could probably spare yourself from the nested if/else by using a couple case statements http://www.skorks.com/2009/08/how-a-ruby-case-statement-works-and-what-you-can-do-with-it/
Sure, I took a look. It's very procedural...your Ruby journey is just beginning. I hope you stick with it! Some things I noticed: * Use 2 space tabs on your editor. No hard tabs. * Don't end method definitions or calls in () unless you absolutely have to. * It's just a game, but globals are still scary. I'd rather see objects or even a singleton. * You can use %w() as a shortcut to make arrays of strings. You can use heredocs to simply output of multiline strings: puts &lt;&lt;-EOF Here we go! - -- --- ---- EOF You could use case statements to clean up lots of repetition with checking the same variable over and over again: case $current_room when "airlock1" airlock1 when "science_lab" science_lab end It might be cool to consider an object design for each room. If each individual room is a subclass it would be a lot clearer, and you could consolidate the logic of navigation into one place (Hopefully another class...try to have one class do one thing!) An idea of what this could look like... # empty room class Room def contents [] end def up false end alias :down :up alias :left :up alias :right :up def move(direction) if room = send(direction) # Move to room! else puts "You can't move that way!" end end end class Airlock &lt; Room def contents %w(Spacesuit Clipboard Flashlight) end def up :science_lab end end Here's a fun game I made using Shoes a while back (5 years ago, geez!), maybe you'll get something out of it :) https://github.com/qrush/snake
cool! a command line game, making me nostalgic :) some ideas for improvements: * turn it into a Gem with an executable to start it. * look at the concerns of your game, you currently have one file with everything in it, similarly you have functions that do a lot!; can you separate out things like actions from your world variables from the state? * use case statements! if elsif is for chumps. * tests! I'd recommend starting with Rspec; tests help you reduce the liklihood of stupid bugs like.... if $inventory.include? "Spacesuit" --- snip--- elsif $inventory.include? "Spacesuit" or true -- snip -- else -- I can never get here since if X or true always equals true. end will also limit the time to troubleshoot EscapeZeta.rb:325:in `airlock1': undefined method `any?' for "wear":String (NoMethodError) from EscapeZeta.rb:204:in `wear' from EscapeZeta.rb:71:in `room_actions' from EscapeZeta.rb:53:in `room_actions' from EscapeZeta.rb:53:in `room_actions' from EscapeZeta.rb:274:in `start' from EscapeZeta.rb:498:in `&lt;main&gt;'
I'm fairly new to rails and i'm probably doing it wrong, but there are are several stack-overflow posts where people are asking this exact question. 
What you've got is a bag of methods. That's a perfect usecase for a [Module](http://ruby-doc.org/core-2.0/Module.html)!
Ah, I've only used vanilla Jekyll for the stuff I've done. 
You criticize the parent comment for suggesting 2-space tabs, because as you said it's a matter of personal preference (and I agree with you on that), but your opinion on singletons also seems like a personal preference, especially since you didn't explain *why* they are such a bad idea. Do you want us to take your word for it, or would you care to elaborate and provide some alternatives? I've always had a problem with structuring my programs, and keeping state in a singleton have always been tempting.
Singletons tend to be very difficult to unit test. When you're writing a program and want to be able to assure some level of correctness, this matters a lot. And while indentation is indeed a matter of preference, the convention is 2-space tabs in the ruby community.
You could post it to /r/DailyProgrammer_Ideas
&gt; your opinion on singletons also seems like a personal preference I just stated the general consensus among programmers; see [here](http://stackoverflow.com/questions/1392315/problems-with-singleton-pattern), [here](http://blogs.msdn.com/b/scottdensmore/archive/2004/05/25/140827.aspx), [here](http://code.google.com/p/google-singleton-detector/wiki/WhySingletonsAreControversial), [here](http://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons), [here](http://www.softwarereality.com/design/singleton.jsp) and [here](http://c2.com/cgi/wiki?SingletonGlobalProblems). Do I need to keep going?
Fair enough, I didn't know it was such a controversial subject, I'm still kind of new to all of this. Thanks for the links, I'll definitely read these.
Oh wow, that looks like fun (seriously)! I miss 1985 :) Your movement code could be improved considerably by making the room a class (containing room name, contents, descriptive_text etc. attributes) and then instantiating objects based on that class. You can then put the room objects into an 2D array which would represent their locations. Your movement code then can just track the players position in the array and call the appropriate methods on the class. One of the underlying tricks to good programming is represented by Rubys DRY philosophy - Don't Repeat Yourself, and if you find that you are cut and pasting code, or several areas of code look very similar; that's usually an indicator that you have an opportunity to improve your code by refactorisation. Keep at it, looking good for 1 week :)
I'd avoid subclassing room....for many reasons which I'm sure you understand. Far better to instantiate room objects with their data....
If you are saying some people like to indent 2 spaces and some like to indent 4 and that's fine, then I agree with you. The OC however was more talking about not using hard tabs ( ie replace tabs with &lt;some number&gt; of spaces). On that I agree with him/her. Hard tabs are awful. 
What about the general consensus among ruby programmers to use 2 space tabs? It's personal preference, but there are also language based recommendations to make working with that language consistent.
Great job! A quick little style tip, you don't need () after a method definition if it takes no arguments :)
Fun fact: you don't need them at all. You can define a method without any parentheses: def foo bar, baz bar + baz end But I find that *really* jarring to read.
Hehe, yep, GitHub pages is what I use for this blog (ironically enough).
If you don't have a running dyno on Heroku, it's going to be a Bad Time™ for you because of the recompilation and start-up time on every request, I agree. In fact, the article in question isn't hosted on Heroku but with Github Pages. Bless them. :) I used Heroku with jekyll recently so that I could privately share some stuff I had written with other people, be able to give them a link and take down the site easily later. Pretty useful (and free!).
 If you haven't already, start the game by typing 'start'. --&gt; start EscapeZeta.rb:74:in `room_actions': undefined method `any?' for "start":String (NoMethodError) from EscapeZeta.rb:53:in `room_actions' from EscapeZeta.rb:274:in `start' from EscapeZeta.rb:498:in `&lt;main&gt;' :(
i've started using () after no-argument method calls (though not definitions) to differentiate methods from variables, as the former may cause side effects. Edit: Downvotes, really? If you don't like my approach please provide a reason.
I'm aware of case statements and how to use them. DOn't really know why I didn't use them this time. Thanks for the nudge in the right direction.
Exactly what I was looking for. I really wanted to put room movement into one object, but I just couldn't wrap my head around it yet (even if I did have *some* room actions in one object...) I considered using a couple of your suggested techniques, but I was a little scared to venture too far outside my comfort zone, even if I did sort of know how to use them. Your construct "alias :down :up" is new to me. I'll research that. How would you typically use something like that? 
I suppose the initial level is free.
I'd love it. Some folks have already started to re-write parts of the code. I'm learning a lot just seeing what I wrote, but written better.
I couldn't get it to work. I tried to separate the roomactions method out into a module, but when I tried to include it, none of it seemed to take. def foo include roomactions.rb other stuff end That's it, yes?
I know, it was super fun putting this together. I loved Zork. Ok, I'm going to try to refactor this using classes. And your tip to put the objects into an array is probably what I was trying to wrap my head around when I started to put those several actions that could happen within any room within that roomactions method. DRY, I had a few examples of that, but yes, I need much more of it. And you cut/paste test is a great one. I know exactly what you mean. :) Thanks.
So, in qrush's example *class Airlock &lt; Room*, that's a subclass example? You're suggesting that instantiating a *new* class of the room is better? I'm unsure what the difference is and why one is better than the other.
Good luck bro. Ruby can be a fun language to build shit in...
As a subclass you could make multiple Airlocks which may or may not make sense. If you just instantiate a bunch of Rooms and set their attributes you don't have that added complexity. You could also make a few mixin modules that describe roomlike behavior 
Right on. Thanks. So far, it's pretty cool.
There are a couple fundamental things I don't think I quite have yet for me to feel like i really understand what's going on here. I'm still having a little bit of trouble with the whole class/module/function difference. Just a little bit though.
I was looking over the code for Snake and about a third of it made sense to me. I guess I've still got a loooooong snake to go yet.
Ok, I have no idea how to get user-defined variables into and out of the class. For example, how would I pass user movement choices to the class? Am I passing them to *class Airlock &lt; Room* or *class Room*? How do I share variables between the classes. For example, how do I let the *class Airlock &lt; Room* know that the player is carrying something from the *class Science_Lab &lt; Room*? Aren't variables restricted to the class? Thanks again for taking the time to help this poor newb.
Yes, *Airlock* is a subclass of *Room* - it basically say "The Airlock class gets all the properties and methods of Room class" (there's a lot more too it but that will do for now). Sadly its quite complex why one is better than the other - its one of these things that you get a feel from once you have programmed for a while. As a rule of thumb, always consider what the alternatives are to using inheritance but it will be a while until you know what they are.... I'd suggest having a good read up on object orientation so that you can get a better grasp of the basics. In the meantime and to be fair - here is what I would do with *Room* from a more object oriented stand point : [adventure sample](http://pastebin.com/Yfr6cpc9) There's a lot of room for improvement there but I wanted to demonstrate initializers, how to declare and access attributes/properties, and how I would have handled movement amongst the rooms (only up/down works). PLEASE DON'T TAKE ANYTHING THERE AS BEST RUBY PRACTICES - I'm a Ruby hobbyist myself and I've done several things there both in a rush and to write explicitly. Ask if you don't understand anything but those are some early basics of OO (Object Orientation)
That's not what is called "a consensus". A consensus is when a bunch of people gather, discuss a bunch of options, their respective pros and cons and then decide on one solution that will be more-or-less objectively best for them as a group. In this case no discussion took place; a lot of people don't even think about other possibilities - they just use 2-space indentation because everyone else does. Because it's "a language standard". And then they shove this down everyone else's throats. "Use 2 space tabs on your editor", **no**, use as much (or as little) spaces as you need to make the code the most readable for you, to make the best use of your screen real estate and to be best suited to your workflow. (Editing multiple documents at the same time vs only one, etc.) I prefer to use 4-space tabs as I have a huge screen and my workflow tends to consist of working on a single document one at a time, but **I don't try to shove it down everyone's throats**, even though I do subjectively think that this way is "better". (Whatever that means.) And you know what? When I'll edit your code I'll just get my editor to reindent it for me if, edit it, reindent it back for you and send you a patch. (Hell, this can be automated with some git scripts.) Sigh, I don't even know why I'm even wasting my time writing these comments. Going against the hivemind (especially here) and not being ultra-super politically correct always results in being downvoted to oblivion, regardless of how valid your arguments are. I'm done.
Could this be easily modified for Litecoin? I'm not too great with rails/ruby myself but I'd assume just utilising litecoind rather than bitcoind would be a start? :)
Or you could just follow standards.
You could just replace the T with a space, use gsub then strptime
Interesting. What's the use case for something like this?
also had this error, reproduce by entering name, answering "y" to instructions then entering "start"
I took a crack at refactoring some of this. Here's my take at it: https://github.com/alexbartlow/escapezeta Let me know what you think!
Close. You `include` Modules into Classes, not methods; and you do it by module name, not file name. Example code: # escape_zeta.rb require 'room_actions' class EscapeZeta include RoomActions def run # ... end end EscapeZeta.new.run # room_actions.rb module RoomActions def room_action # ... end end You can see how this 1. Starts you off in the object oriented direction by making your main program an object 2. Encourages you to group similar methods together. This will lead to more maintainable code as your game grows, and when you have enough behavior grouped together, suggests a good place to create a new class.
Ah. That makes sense. Seems like it might be fairly easy for me to factor that in and switch things around so that the room_actions could exist in a module. I'm confused about making the main program a class though. I can see how a class is useful for more complex programs, but in this case, since I'm not going to instantiate the main program more than once, isn't it just as easy to keep it a...wait...oh...I need a class in order to include a module. Ok, got it.
You could make the main program a module. But there are several longer-term considerations that might make a class more useful. Plus, it's more Ruby-like, and that's the point of this exercise, right? The real learning Ruby the hard way is having to listen to Rubyists tell you the Ruby way of doing things without context. So here's some context: 1. Treating `Games` as objects recognizes that `Games` are entities that can be created using a basic formula: a `Class`. 2. With a core `Game` class defined, it'll be easier to make future games from your game class that use the same core class with different behavior modules mixed in. 3. The ability to instanciate multiple games allows you to create many different games that follow the same pattern. Imagine, if you will, if your program had many different types of similar `Games`: one a sci-fi text adventure, one a medieval fantasy, another a gritty modern-world game. You could just prompt the user for which game they want to play, then instanciate `Games` with different properties based on their selection. 4. The act of instanciating a game suggests multiple game objects could exist at once; for example, if you decided to make a multiplayer game. 5. The act of instanciating a game more easily allows for configurable runtimes. Imagine, instead of defining a `prompt` method, you define a `prompt` variable on the class that can be set during runtime, loads from an external settings file, or is populated from a database. You've given yourself many different ways of establishing a configurable prompt, your choice of implementation. Indeed, treating `Games` as objects allows to think about all of the properties of your game as either a setting (a variable) or a behavior (a method). In general, making things objects encourages you to decide what's an inherent property of your game that's configurable from runtime to runtime (say, the prompt string) and what's a predefined behavior (say, the act of prompting a user for input). This pattern will come in handy when you're trying to implement a save file mechanism. If a player is an object, it's properties can be loaded from a file and its behavior can be the same across all games.
In our case, we plan to add it to our online anatomy atlas at kenhub.com. We've had people tell us that they are having trouble identifying different colours in the anatomy illustrations. Separating different elements in those drawings are important, because you need to distinguish between nerves, vessels, muscles and bones. The best way is to colour-code those, but if you're colour-blind - it's hard for you to distinguish between those colours some times. So if you have any images that are colour-coded or use different colours to convey some meaning, then using this gem can help you generate images that will allow colour-blind people make this distinction more easily. Hope this answered your question.
I've found the hard way that which formats Time.parse accepts sometimes changes between ruby versions too. I avoid it. 
I don't see what this has to do with ASP.Net.
Should be renamed to "Sandi Metz' helpful guidelines that are certain to be hijacked by absolutist developers who believe that our job is to mindlessly cargo cult patterns repetitively under the mantra of 'Best Practices.'"
&gt; You must sign in to continue Wat?
Quite!
"You must close this tab without reading the content." Edit: Actually it looks like this is part of an online course and wasn't intended to be distributed like this.
Before using mechanize, I used selenium (I haven't heard of watir before, but it looks similar to but much better than selenium), but mechanize was a lot (~5x) faster. I don't whether the slowness was due to selenium or having to render everything in the browser, and I'm on my phone now so can't test it, but if watir performs at a similar speed to mechanize it would certainly be a much better solution. Thanks for the pointer! 
nice
Nice work on the gem. Initial thoughts, [you should keep it to two spaces](https://github.com/dorkrawk/darwinning/blob/master/lib/darwinning/population.rb). Checkout the [Github styleguide for Ruby](https://github.com/styleguide/ruby). 
Yeah, I'm just starting to get the hang of testing for the negative instead of multiple positives. You can see where I did that in a couple spots, but I could have used it more, like your'e refactoring. The send function, how exactly is that working? Where are you sending the $current_room variable? How are we determining to which room to send the user? And a nowhere state exists when the user hasn't started the game yet. I suppose I should call it something a bit more descriptive, like lobby or pre-game or something... Thanks for taking the time to refactor that part. I really appreciate it.
The lightbulb just went on with regards to classes. Example #3 is really what drove it home. Thank you so much for taking the time to explain this.
This is starting to make sense. Thanks.
If you have an object 'foo' with a function 'bar', calling foo.bar is equivalent to calling foo.send(:bar) or foo.send("bar"). Well, almost equivalent--you can call private functions with send, so it's a little dangerous. The reason I refactored this bit of code is because you have a giant chain of elsif statements, that all pretty much do the same thing: call the function that has the same name as the value contained in the variable. You can use send to do exactly that.
The change of self is really broken, i prefer something like this: def let() yield end And then use it like this: let do |f1, f2| f1 = -&gt;{ "hello world" } f2 = -&gt;{ rand(100) } [f1.(), f2.()] end This both maintains self, and restricts the scope of `f1` and `f2`. Regarding syntax, the little `.` before the `()` doesn't bug me that much :) If you prefer to avoid setting variables you can also do this: let do |f1 = -&gt;{ "hello world" }, f2 = -&gt;{ rand(100) }| [f1.(), f2.()] end Nesting also 'just works'.
Also look into Phantomjs in conjunction with watir-webdriver. One thing to note about ASP pages. Microsoft decided developers were too stupid to use unique IDs so, by default, they prepend the IDs of the parent controls up the chain. A lot of folks thing that those prefixes might change and resort to using regexes to find the elements. That's REALLY slow.
there you go: https://github.com/dorkrawk/darwinning/pull/1
Awesome! Thanks!
you're welcome! I will also give your gem a shot, when i will have time to try it. I wrote a little gem not so long ago that create a word clock of various sizes using GA, it will be a nice exercise to rewrite it using your gem. :)
In my opinion, you shouldn't need to comment a method, the method name should be the documentation. Unless of course the method is doing more than one thing, which would be more difficult to write tests for. 
It's easy if you use save_and_open_page provided by the Launchy gem. 
This is a great little hook! Another trick I like to use is `git --assume-unchanged Gemfile` (I also do Gemfile.lock for rails apps if I don't want to update the bundle before pushing to other envs) which will tell git to temporarily "ignore" that file. It won't show up as modified or get committed in an accidental `git commit -a` and if you do decide you want to commit a version of it, you can unignore it with `git --no-assume-unchanged Gemfile`.
Neat! Two ideas: Instead of `Darwinning::Population#best_member` use `Darwinning::Population#winner` to be consistent with the Gem's name. and change `Darwinning::Population#evolve` to `Darwinning::Pupulation#evolve!` because it changes the state of the instance, right? I might be wrong about this but I think that's how bang methods should be used. What are you using it for?
I think I'd like to keep best_member because you could pull the best member from the population at any point in the evolution, not just at the end. I like the evolve! idea, that would be right for that method.
"And I hate stackoverflow too much to go there." There's your problem, StackOverflow is awesome
You're probably better off using Java's GUI libraries via JRuby (ex: [ruby-processing](https://github.com/jashkenas/ruby-processing#readme)) or one of the many Ruby GTK libraries (ex: [Visual Ruby](http://visualruby.net/), [ruby-gnome2](https://github.com/ruby-gnome2/ruby-gnome2#readme), [ruby-gir-ffi](https://github.com/mvz/ruby-gir-ffi#readme)). 
The main thing I like about Shoes is its very Ruby like. I don't want to use Java's Libraries.
Yeah I know it's awesome. I just don't like it. Personal choice. 
ruby-processing uses [JRuby](http://jruby.org/), which lets you use Java classes with Ruby syntax. Checkout the [examples](https://github.com/jashkenas/ruby-processing/tree/master/samples/contributed).
Synopsis for you: Roald: I like Shoes, but seems dead. I also think Tk is ugly. postmodern: Yeah, use Java's GUI using JRuby or GTK bindings. Roald: I like Shoes since it's very "Ruby." I don't want to use Java's Libraries. I know what JRuby is. I know I would still be writing Ruby, I just don't like the ugliness of Tk or the Java libraries.
I appreciate your answer, but I do not mean syntax in the direct manner. I mean that while programming in Shoes it feels very much like Ruby while using Tk or Java Classes would feel awkward.
I see your point. Going through it.
i would skip ruby for that and use coffeescript + a web framework like marionette/backbone
That is quite possibly the dumbest personal choice I've ever heard of.
What's there to ****ing downvote for in this post? The fact that I don't like Stack Overflow? OMG, fan boys. 
So yeah, I'd appreciate if anyone who actually knows the answer can drop by. My questions: Where can I find documentation about **para.cursor?** Any special **Shoes** forums or mailing list you know of? The mailing list mentioned in the website does not work.
Sorry about that.
"yeah I know it's awesome I just don't like it" Sorry but it's kinda called for... 
OK seriously, I am not even being sarcastic or angry. So the fact that I said that I don't like Stack Overflow makes you people think someone can call my choices dumb? I didn't take personal stabs at anyone, I was just citing my opinion. I didn't criticize Stack Overflow. So yes, that was uncalled for. Sadly, no one seems to appreciate the hacker ethic anymore. The simple idea that FreeBSD, Unix and Linux are founded upon, the matter of freedom of choice when it comes to technology. I simply stated that I didn't like a particular website; lo and behold, people getting mad as if I called thier sister ugly. Hacker spirit is based on freedom to use any software you want, any OS you want and any *website* you want. *I* respect this freedom. People all have thier pet peeves and personal choices, many great programmers I know would never use Perl for even the most obviously "Perly" work. I don't go around calling them dumb. If they wanna use Perl it's fine, if not I don't care. Everyone uses the tool they like. There. Stop acting like dogmatic monkeys.
This looks like a good choice, it has its own pragmatic book. I'll investigate it.
So I have to justify here in *Reddit*, why I don't want to use StackOverflow, OMG! And why it is fanboyism: Look at my question, no ones wants to answer it, all people come here for is to criticize the fact that I don't choose to use StackOverflow. &gt;&gt; I don't really care whether ... Exactly, why don't people try to answer my questions?
THe distinction is fast becoming artificial.
[Here's the documentation for Green Shoes' TextBlock class and its method #cursor](http://ashbb.github.io/green_shoes/TextBlock.html#cursor). I assume you're using the regular Shoes but Green Shoes (it's a pure Ruby implementation of Shoes pretty much) should work the same.
The shoes mailing list I use is shoes@librelist.com. The instructions for subscribing to librelist mailing lists are on [librelist.com](http://librelist.com) - basically, post 'subscribe' to shoes@librelist.com. Once you have subscribed, you can post. The archives at http://librelist.com/browser/shoes/ seem to be very slightly laggy in what is viewable (like, they don't have stuff that was posted in the last few days archived for viewing on the web). The shoes website was recently reworked and put on github pages, so there may be a few broken links - both pull requests (to http://github.com/shoes/shoesrb.com) and mentions on the mailing list are super welcome.
Thank you very much. I'll probably use Green Shoes from now. It's documented way better. [edit:] Hey! The documentation is great! I found exactly what I was looking for, thanks man! 
Hey, this is what I get: A message that you sent could not be delivered to one or more of its recipients. This is a permanent error. The following address failed: "shoes@librelist.com": domain has no mail exchangers when I try to join the mailing list
That is really strange. I received some mail from the shoes@librelist.com mailing list less than an hour ago. Hmm. Are you using an anonymous email service, or using google email to send email from a domain that isn't google by any chance? The MX records for librelist.com seem to be fine - you can check with a tool like http://mxtoolbox.com/SuperTool.aspx?action=mx%3alibrelist.com&amp;run=toolpage
Hey, works now! I guess it must have been my ISP (for some strange reason). Thanks!
For the curious but lazy, `Range#===` calls `include?`.
I imagine this is because #include? is a result of ranges being 'enumerable'. Is there a functional difference between the two? I mean (on my phone, so I can't test this), does (1..10).include? 5.5 == true? What about #cover??
You probably want to use the new [SecureRandom.random_bytes](http://rubydoc.info/stdlib/securerandom/1.8.7/SecureRandom#random_bytes-class_method).
Hmmm, I thought I was being stupid (I may well be being so; insufficient sleep) but the more I look at it, the more I cant help but wonder why *cover?* isn't *between?*. I know that *between?* is part of comparable and has a different signature but then given it's necessary to write : 5.between? 1, 10 rather than 5.between? 1..10 ...meh, I guess its just one of those things that bugs me. EDIT: Having rested I've decided I am being stupid. sleep. good!
What exactly does Rubocop do? Neither the article nor github clearly describe it.
I like to screw around with new frameworks when I'm building something for fun, but for practical use, I use this: * Sinatra * Sequel (I usually use SQLite for development then switch to Postgres for production) * Haml Design isn't really my specialty so I usually get page design started with Bootstrap and then use jQuery and jQueryUI a fair bit. I've been reading a lot about Backbone.js lately, which I'd like to start using.
code-style checker for Ruby code
I found out by going to his homepage and skimming down the page. http://batsov.com/articles/2013/04/15/rubocop/
Any particular reason you suggest it? It uses /dev/urandom, *pseudo-random* number generator with less entropy than /dev/random.
Is Krypt production-ready yet?
You're right, its good enough for most situations. I'm not saying its necessary to always use true randomness, but I found it an interesting way to use it when it is available.
Can you give your definition of 'production-ready'?
Whoa, Ruby has only ever had the one OpenSSL-based crypto library? After all this time?
Every other library out there pretty much just wraps OpenSSL so I don't see how this is a problem. Only recently are we starting to see some friendlier solutions like krypt and NaCl.
Problem being, as pointed out on the page, OpenSSL only generally implements SSL relevant crypto, not others.
I suppose my definition would be "Krypt can be used in a process to secure the gems and make sure the Rubygems exploit problem doesn't happen again."
Is what lawyers from NZ do?
I'm pretty happy using vim + rbenv + whatever the latest stable ruby is (2.0.0-p195 atm, I believe). You really don't need a super complicated IDE unless you're maintaining an absolutely massive project, and even then, if you've structured your code right, it should still be pretty easy to navigate... focus on learning the language first, then gravitate to an IDE if there's a particular feature that you need that vim/emacs/nano can't satisfy. ^edit: one piece of advice though.. even for beginners, try to stay away from modifying your system ruby too much. Definitely look into using something like rbenv or rvm to manage a ruby version in ~, so you're not constantly installing new gems to your system ruby. Things can get hairy when you have a bunch of gems installed for 1.9.3, then you do a system update and get upgraded to a new version. And, especially in the case of debian/ubuntu, there are so many 3rd party patches applied to mainline ruby, that if you run into a bug, the first thing you'll be asked is if you're running a vanilla mri, or if it's a system ruby. tl;dr: It's better to have an environment that you have full control of.
Use sublime. It's extensible through plugins. If you get tired of code editors try text editors such as emacs or vim. Stay away from them, they'll be an expensive overhead for a beginner.
While technically true, and probably helpful to some it seems suspiciously like re-implementing [Go](http://golang.org/) but with 1/10th of the performance.
vim
I use vim with ruby 2.0. I don't like IDE, but I do use syntax highlighting with vim. It's best to start with vim, I think, but if you don't want to Geany is always a good option. However, if I had to start over, I would suggest using rvm so that you can easily switch between versions of ruby. Some projects (octopress, heroku/rails) use 1.9.3 and so its easier to be able to switch between up-to-date ruby and a required version.
EventMachine on it's own is reasonably fast and competes well with NodeJS and Twister in terms of performance, but comparing anything Ruby to Go is comparing apples to oranges.
Only if you're angry at apples and oranges. Yes of course go is compiled, not interpreted, declared types and interfaces not duck typing, they are different languages. But if you back up and squint, the message I see is "I want to implement asynchronous event handling, and I'm going to do that by message passing between threads." That is *exactly* what goroutines and channels are for - both of which are defining features of Go. There could be a dozen good reasons that Ruby is used for a project or not - and thus this arrangement makes sense there. But presented in a vacuum, they are basically excellent instructions on how to best shave the corners off of a square peg. I'm not knocking Ruby, or the post - the instructions are clear and the code looks great. It just seems to presume a lot. * You're using Ruby. * You have the evented libraries you need for EM. * You don't want or can't have a polyglot system. * You don't want or can't have external message passing like ZMQ or JSON to call between processes or machines. * You don't mind the limitations of threaded Ruby (depending on the interpreter used) - although the article addresses this point. Given those assumptions the article is great, I was just commenting that those assumptions seem surprisingly specific for the end goal, given other available tools for eventing, message passing, etc.
I understand what you mean, but the usefulness of the presented information is really only applicable to projects which are already in progress with Ruby. The case that you present implies that the developer has a clean slate to start with, and is only approaching the singular goal of "I want to implement asynchronous event handling, and I'm going to do that by message passing between threads." In that case, yes, forgo Ruby, go straight to Go, Erlang, Clojure, Elixer, et al, where there's support for such functionality built into the language. I would argue, however, that most are not starting from a clean slate, and are already working in a Ruby or Rails project and then have to implement asynchronous event handling. This is the target audience of the post, those who have to, in fact, "shave the corners off of a square peg."
I think we're in violent agreement then. My comments are mostly for green-fielders (as you might find wandering even /r/ruby), who may not know about the forms evented or asynchronous systems can take.
Turn it into a [Thor](https://github.com/wycats/thor/wiki) app! Basically, you're going to try to separate your concerns: try to keep output parsing separate from logic, etc.
We are in violent agreement =) You're experienced with evented systems as well, but also aware about trade-offs, which is what I tried to talk about in the article in terms of performance.
Emacs + rbenv
You can also use [gem release](https://github.com/svenfuchs/gem-release#readme), [mg](https://github.com/sr/mg#readme), or even [rubygems-tasks](https://github.com/postmodern/rubygems-tasks#readme) which requires you have a `*.gemspec` file. You can also use [ore](https://github.com/ruby-ore/ore#readme) to generate new Bundled or non-Bundled projects.
Honest answer: probably not yet for what most people would need it for. While the JRuby team has integrated krypt in 1.7.3 to provide missing features of the OpenSSL extension, the current "production-ready" part is very specialized. But we're working towards a major release where we at least publish the low-level API that gives you access to digests, ciphers and signatures. But the biggest gain for everyday development will be the high-level API that we are going to build on top of the lower-level primitives. It will feature secure defaults while keeping the API on a sane level - no more parameter overload, as few parameters as possible to not bother developers with details anymore. I'm giving a [presentation](http://rubykaigi.org/2013/talk/S29) tomorrow that has more details, I'll make sure to publish the slides and hopefully there will be videos of the talks as well! 
Pretty much every other C-based programming language implementation has the same problem. Wrapping OpenSSL is the sane thing to do at first, but it generally causes problems on platforms where OpenSSL (the library) is not available or at least not available by default. This is traditionally the case for JRuby (Java has its own security API and Bouncy Castle) or Windows, but OS X also deprecated OpenSSL recently, and we might see the same thing happening on Fedora. This means that OpenSSL will no longer be there for granted, even on Linux systems. That's why the plan for krypt is to use whatever library is available in the background by default, so you won't have to install OpenSSL first in order to be able to use https or other crypto-related functionality - just use the platform default library instead of depending on OpenSSL exclusively.
May I ask what you have against http://shoesrb.com? I've made a couple contributions to it and I'd love to make it more useful for you.
Haha, I often struggle to find a satisfactory midpoint between overengineered systems and helpless scripts. For now, I'm using `Gemfile` to setup dev tools like reek, flay, and guard. Bundler is a good way to get these dependencies setup in [non-Ruby projects](https://github.com/mcandre/beauty).
Yeah, I did indeed read the article, even if that's a rare thing to happen on reddit these days. I'm surprised because the one of the first things you need to do to get yourself considered as a serious language is have complete crypto support. And the ruby community in general seems desperately to want itself up there with the big boys. OpenSSL is a good part of the way there, but its nowhere near complete. In fact, this very thing is one of the reasons I'm now learning Go, instead of trying to improve my ruby skills. 
Hello, thank you for posting this. Author of post here. I am incredibly happy about DTrace support in Ruby 2.0 and been playing with it for awhile. If anyone has any questions feel free to ask.
Nothing against shoes james! I definitely love it! The Shoesrb.com documentation is a bit off; that's what bothered me. I couldn't find the methods for some classes, like for the para. However I've found that the Green shoes documentation is useful for stuff like this. I hope you release 4 soon! Thank you for dropping by!
&gt;But yeah, if you have to stop and learn vim, hell, use whatever you're already comfortable with. If you have to stop and learn vim, learn vim. It's awesome. If you really think it's too much than stop, but please try. It's one of those things that is sooo Linux. BONUS ANSWER: Sublime definitely. Be sure to enable the vintage mode, map tilde to escape and start vimming. (If you have no clue what I'm saying just google "vintage mode sublime" and also google "xmodmap map tilde escap") GL have fun. Ruby is such a great language.
Wow looking at his profile this guy doesn't sleep. Pretty amazing projects there. 
I use RVM for rubies + gemsets and Sublime Text as an editor.
I'm looking forward to it!
I hope it's a bugfix.
Use trollop instead of the ad-hoc ARGV stuff you're doing now.
From the source, you can see it's a countdown until the new ruby-lang.org launches... echo(" From https://github.com/ruby/www.ruby-lang.org"); echo(" db87417..bc5c796 master -&gt; master"); echo("-----&gt; Using git branch 'master'"); echo(" Cloning into ...."); echo(" done."); echo("-----&gt; Using this git commit"); echo(""); echo(" Marcus Stollsteimer (bc5c796):"); echo(" &gt; Going into production: adapt README"); echo("-----&gt; Installing gem dependencies using Bundler"); echo(" Configuration from /var/www/www.ruby-lang.org/tmp/build-136618062421361/_config.yml"); echo(" Building site: /var/www/www.ruby-lang.org/tmp/build-136618062421361 -&gt; /var/www/www.ruby-lang.org/tmp/build-136618062421361/_site"); echo("-----&gt; Build finished"); echo("-----&gt; Introducing the new www.ruby-lang.org", function() { setTimeout(function() { document.location = "https://github.com/ruby/www.ruby-lang.org"; }, 2000); }); 
Haha yeah, kinda lame
But Sublime isn't free, right? You have to buy it, no?
Sublime isn't free though, is it? It says you have to buy a license to use it... Does the "demo" version have any constrictions?
None that I have noticed. I just press cancel when the message appears.
Well, it doesn't force anyone to buy it. Sometimes when you save your documents you get a notification which says "Unregistered version.....". I close it by "esc" and it doesn't annoy me. Of course if you feel uncomfortable with it, use editor of your choice - I also like Geany. Some people use great "code processors" vim or emacs, I've never could set them up and had to think about editor more than about the code I write.
 echo("-----&gt; Introducing the new www.ruby-lang.org", function() { Oh man, this shit is so cryptic. Someone get the NSA on the line.
Yeah, Rubinius has some interesting additions, and of course JRuby has mapped threads onto JVM threads for a while now, but I don't know if they added any synchronization primitives like channels.
I think a good aphorism to think about is: you will spend far more time reading your own code than writing it. As your example stands now, it is extremely difficult to tell what it actually does. And even if you commented each line, wherever the "business" happens is still obfuscated because of all the conditional code that surrounds it. Here's a place to start: Wrap all of the file-system-setup code into a command-type method (a method that has side effects but returns nothing): unless File.directory? TEMP_DIR Dir::mkdir TEMP_DIR end unless File.file? TEMP_FILE f = File.open(TEMP_FILE, 'w') f.write("id: -1") end unless File.file? CONFIG_FILE f = File.open(CONFIG_FILE, 'w') f.write("") end It should just be something as simple as: `setup_file_system_env(TEMP_DIR, TEMP_FILE, CONFIG_FILE)` The rest of your program's logic has no need to know what actually happens in there. 
so... what changed?
It was running on Jekyll before right?
https://github.com/ruby/www.ruby-lang.org/commits/master
It was using [Radiant CMS](http://radiantcms.org/) before, which made it hard to submit changes. We did do a Silent Migration to the new Jekyll site a month ago, once we made sure the new site was content-complete.
I guess this is what I get for not packing my JavaScript ;)
Expect to see more frequent news posts. We have already started updating the content bit by bit. The translations are horribly unmaintained, and we are looking for [new maintainers](https://github.com/ruby/www.ruby-lang.org/issues/120).
The new [100% Markdown + Jekyll www.ruby-lang.org](https://github.com/ruby/www.ruby-lang.org) was officially announced and ready for contributors. Now making changes to the [www.ruby-lang.org](http://www.ruby-lang.org/) is as easy as [submitting a Pull Request](https://github.com/ruby/www.ruby-lang.org/fork).
Learned this the hard way.
As promised: [slides](https://github.com/emboss/prez/tree/master/ruby%20kaigi%202013)
What do you have trouble understanding? The syntax, concept, implementation, something else?
I don't get the syntax, probably because I've never seen hashes in any other language, and I don't understand how I would implement them into a program.
Hashes are awesome and they are used a ton in ruby and rails. They are essentially a key value store. If you are familiar with arrays at all, understanding what a hash is should be easy. If you have an array it would look something like... array = ['dog', 'cat', 'snake', 'mouse'] And if I wanted to get the cat from the array it would look like... array[1] Ruby arrays are zero indexed. Meaning the indexing on the array starts at zero and goes up. Now if you had a hash it might look something like... hash = { 'dog' =&gt; 'fido', 'cat' =&gt; 'socks', 'snake' =&gt; 'snape', 'mouse' =&gt; 'remy' } Instead of using the index to reach into the array and pull out the value you can use a key instead. So if you wanted to get the value of cat you would... hash['cat'] Which would return 'socks'. Hashes are great because you can store values by a named key which can make finding what you want a little easier. You can use strings, integers, and symbols as keys. There are all kinds of things you can do with a hash. In rails you see them used a lot for setting variables in methods. Hope this helps a little. Its also good to read through the docs http://ruby-doc.org/core-2.0/Hash.html and look at all of the examples. Good Luck 
Every language has hash-like datatype. Hash is HashTable in Java, Dictionary in C#, object in Javascript and `array` in PHP. What language did you learn before that does not have hash?
I've just never seen them before.