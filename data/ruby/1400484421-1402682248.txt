You are doing something else wrong : irb(main):001:0&gt; foo = Class.new =&gt; #&lt;Class:0x007ff429360018&gt; irb(main):002:0&gt; def foo.bar irb(main):003:1&gt; puts 'baz' irb(main):004:1&gt; end =&gt; :bar irb(main):005:0&gt; foo.bar bar =&gt; nil 
you must have copied this incorrectly, because that last `bar` should be a `baz`.
You are correct.
From your example code it seems like #add_listener expects a Class rather than an instance of a Class. You could try passing the singleton class of listener. I'm not familiar with jruby and using java libraries from it, but I would expect it to use snake_case instead of camelCase. Naturally #touchDown wouldn't be called then, but #touch_down would.
Very nice! I'd like to point out that my experience running a bot on Heroku's free plans has not been enjoyable. Using git for a push mechanism seems awesome, but you inevitably end up with a ton of not-for-public-consumption stuff in there that's a pain to separate and push out later. On top of that, the Heroku dynos run very very slowly, pool database connections in an odd way, and restart once a day whether you want them to or not. Eventually I just moved it onto my VPS. What is the license for this code, though? I'd love to bring in this functionality (I have a [cinch-based bot myself](https://github.com/Karunamon/rbreibot)), but without knowing if it's acceptable to do so, I can't.
What makes this (or *will* make this) gem better/different than Celluloid?
oh shoot, yes i will put a license on there. thanks for reminding me. :) as for heroku, it's a pretty minimal set of environment variables atm, no more than 5. so i think that's acceptable for a deployment set up. i may also just make a configurable script to help make that setup super easy and quick. can you tell me more about your experience on vps?
Thanks! Pretty easy - once you're set up for Heroku, really the only thing you need to do is install the Foreman gem separately and do some minor configuration on it (environment vars, etc). You can keep using the same Procfile that you were in the past. The worst part was moving the database, everything else was cake. I'd recommend something like [ChunkHost](https://chunkhost.com) for a provider. It costs $10 a month for a gig of memory, 30 gig of SSD, and more bandwidth than you'll know what to do with. ([Referral link to same](https://chunkhost.com/r/karu-reddit) if you decide to do so, would be super appreciated :D) It's definitely faster - I think (but can't really prove) Heroku greatly de-prioritizes compute and network for non-paying users to the point where it's painful to use. And a paid plan on their system will run you absolutely no less than $34 a month.
Sorry, there was a typo. The last end needs a .new to instantiate, and you left off that end completely: Class.new(InputListener) do def touchDown(event, x, y, pointer, button) puts 'working' end end.new
add_listener officially takes an interface called EventListener. InputListener is a java class that implements EventListener. [Here](http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputListener.html) are the specs. JRuby does allow you to use snake_case when referencing Java methods, but I've found when overriding a method or referring to a field within a Java class that it needs to match the Java camelCase exactly or it thinks you're talking about a different method. The reason I know everything else is setup correctly is because it works when I use: @inv_button.add_listener( Class.new(InputListener) do def touchDown(event, x, y, pointer, button) puts 'working' end end.new ) But the problem is that I'm stuck in the scope of the new InputListener class then, and I can't reach any of the data I need while in touchDown. When I subclass InputListener so that I can override the initialize method and pass it arguments, then this method no longer works and it stops responding. There must be something subtle I'm still missing. 
Whoops, thanks, I was wondering and I missed that detail.
I assume you already have a web application running in ruby? If not, you might want to look at http://www.sinatrarb.com/intro.html or http://guides.rubyonrails.org/getting_started.html. (If you are using some other backend language like PHP or python then you probably want to go the system exec route below except using that language's exec) The obvious (and, in my personal opinion, wrong) choice would be to use one of the many forms of system exec: This is a relatively good source: https://stackoverflow.com/questions/6338908/ruby-difference-between-exec-system-and-x-or-backticks. However, what you really probably want to do is refactor the external script to where you can require it and then use the object it provides. That or just write the same code into your web server backend ruby code.
I'm not sure how it could be interpreted that way if you read past the headline.
Wow, that's a rather confusing use of the word facade. Ruby has a `SimpleDelegator` class built-in that can do this for you, and can delegate to any object, not just classes. [Here's the terrible documentation for it](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/delegate/rdoc/SimpleDelegator.html).
This is ridiculously dumb. What is the point? Also why not just map directly to the constant instead of a string representation that needs to be looked up at runtime? Also why a class method? Ugh, just no. Also what if your underlying object has a constructor that requires arguments? 
Well ... how about this: pairs = binary.to_s(2).chars.zip(multiplier.chars) # Now pairs will be: # [['1', '2'], ['0', '3'], ['1', '4'], ['1', '2'], ['0', '3']] # Now, do the following: # - select the elements in 'pairs' where the first value is '1' (so, ['1', '2'] but not ['0', '3'], and so on # - map the last element - we no longer care about the first # - map to_i # - sum pairs.select {|x| x.first == '1' }.map(&amp;:last).map(&amp;:to_i).inject(&amp;:+) 
Also, I sometimes think it's a bit clearer to put each enumerator method on its own line. Let's see if I can get reddit to do the right thing with indenting: pairs.select {|x| x.first == '1'} .map(&amp;:last) .map(&amp;:to_i) .inject(&amp;:+)
Morning golf : "23423".chars.each_with_index.map { | c, i | 22.to_s(2)[i] == '1' ? c.to_i : 0 }.inject(&amp;:+)
Hey, glad you found it useful and thanks for getting the book. The tie in between versions is probably actually far looser than the average Rails app. The only gem which is part of the the production app is Capistrano. Knife and Chef Solo are standalone so you don't really get security/ middleware issues. The reason I stress the importance of versions so much is that on quite a few occasions people didn't use the Gemfile (because they were used to only using Gemfiles for rails apps) and instead just did "gem install" and so ended up with a fairly random assortment of versions, e.g. chef from 2 years ago, the latest knife etc which just didn't work together in the same way Rails 2 and the latest Devise probably wouldn't. I was getting a lot of support requests to which the solution was basically "use the Gemfile(!)" so the emphasis was just to try and save people the time/ frustration of having to get in touch with me when it didn't work.
Thanks a lot! Its really helpful.
Faceting support?
Why don't you try an elsif statement instead of starting a new if statement every time... or a switch/case statement. It would also be more efficient because once you find an answer once, you don't need to test the value again and again.
a couple things you can benefit from @ageOfTree = @ageOfTree + 1 is equivelent to @ageOfTree += 1 there's a case statement that can be used to clean up your large conditional. It also has a concept of else, which is the "it didn't match anything else", which will clean up line 44 http://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-case
Some small observations: * Use a case statement in `checkInput` to get rid of all of those `if` statements and this monstrosity `if @input != 'pick fruit' and @input != 'wait a year' and @input != 'check height' and @input != 'check fruit' and @input != 'end'` * You code has a lot of side effects - methods should generally accept a parameter and return a result. This makes testing them easier and it makes it obvious what they do * Don't call `check_input` in your initialiser - call it manually 
update here http://pastebin.com/cMLU6JWb
I usually do something like this: class OrangeTree ACTIONS = { 'pick fruit' =&gt; :pickFruit, 'wait a year' =&gt; :oneYearPasses, 'check height' =&gt; :treeHeight, 'check fruit' =&gt; :checkFruit, 'end' =&gt; :endTree } ... def checkInput while @ageOfTree &lt; 100 @input = gets.downcase.chomp if ACTIONS.keys.include?(@input) self.send(ACTIONS[@input]) else puts 'Command not understood. Please use "pick fruit" "wait a year" "check height" "check fruit" or "end"' end end end end
Because no one mentioned, do not use `and` in a conditional check. As per http://devblog.avdi.org/2010/08/02/using-and-and-or-in-ruby/, `and` is used for doing multiple operations. For conditions, be sure to use `&amp;&amp;` `||`.
You could also store commands and corresponding methods in a hash constant. That way you don't have a fat method checking a million things. It just ensures that the key is valid and then calls the method. And match the command name as closely as possible to the method name to avoid confusion. COMMANDS = { 'pick fruit' =&gt; :pick_fruit, 'wait a year' =&gt; :wait_a_year } def check_input while @age &lt; 100 # input is local so no need to make it a class variable input = gets.downcase.chomp if COMMANDS.keys.include?(input) send(COMMANDS[input]) else puts 'Command not understood. Valid commands are:' list_commands end end end def list_commands COMMANDS.keys.each { |k| puts k } end
I always forget about self.send
You might want to start learning to use the Interpolation notation instead of the classic Java notation for concatenation. puts 'The tree has a total of ' + @fruitOnTree.to_s + ' fruit.' becomes puts "The tree has a total of #{@fruitOnTree} fruit" note: to use the interpolation notation you had best use double quotes. Single quotations won't inject the reference value and will treat #{@fruitOnTree} as a literal string
While I agree, this is also very nitpicky considering the other issues with the code.
Aye. I'd looked it up expecting it to be some form of implementation of the [Facade pattern ](http://en.wikipedia.org/wiki/Facade_pattern). PHP, as special as ever.
Take a look at Sandi Metz "rules for developers". it will force you to re-think how you write your methods and structure your code. If anything it's a very good execrcise if your just learning.
Wow, I love this solution! Thanks! I didn't know about inject (I've only recently started learning Ruby). Inject seems very powerful. And I guess the multiplication action is more expensive than a conditional check?
Mind blown! Great solution! Had no idea that there was a way to reference bits in Fixnum. I guess I'll be using the golf'd version because it saves a reverse operation. Thanks! (UPDATE: Your updated golf'd version is even better!)
What you've got here is a hand-rolled state machine. You can ditch a ton of boilerplate by using a state machine gem.
Since you've already got some pretty good feedback I'm just going to mention a few things with regard to general Ruby style. First, snake_case instead of camelCase. Second, you can use string interpolation instead of composition: "The tree has a total of #{@fruitOnTree} fruit."
never forget about send()! its the one most amazing thing in ruby, because it reminds you that its all just objects and (sending) messages! but be careful, its hard to grep for metaprogramming.
&gt; Had no idea that there was a way to reference bits in Fixnum. Me neither :)
I created a site. It's RubyNewbies.org
This is actually one of the sites my boss has given me to work on. Thank you! 
Looks like it needs a small correction: (0..4).map{|i|"23423"[i].to_i*22[4-i]}.reduce(:+) You can easily test the correction by replacing 22 by 23.
To avoid repeating all the valid actions, maybe something like: puts 'Command not understood. Valid commands are ' + ACTIONS.keys.map(&amp;:inspect).join(', ') The "inspect" part gives you the quotes around each one. I'd probably wrap this up in a valid_commands method. The point of this (for OP's benefit) is that as the app gets more complex you'll probably add a command and then forget to add it to the message about valid commands, or other places where you've listed them out again. You should eliminate this kind of repetition wherever possible; [Don't Repeat Yourself \(DRY\)](http://en.wikipedia.org/wiki/Don't_repeat_yourself).
You can omit the braces for globals, instance vars and class vars, so it can be even shorter: puts "The tree has a total of #@fruitOnTree fruit" For strings with a mixture of quotes included, there's a syntax that allows you to specify the container characters and still do interpolation: puts %Q`This string has 'lots' of "unnecessary" quotes of 'both' "kinds" with #@interpolation and no escaping`
lotta good tips so far so I'll just say: Line 22: puts 'The tree has ' + @fruitOnTree.to_s + ' fruit ready to be picked.' You could/should use string interpolation. puts "The tree has #{@fruitOnTree} fruit ready to be picked" You should also look into the pros/cons of using double quotes vs. single quotes. Also, Ruby convention is to name variables in snake_case &lt;which looks like that, rather than camelCase, which is what you used. So I would've done puts "The tree has #{@fruit_on_tree} fruit ready to be picked"
rubymonk.com is a great place to get started.
I really recommend the [ruby koans](http://rubykoans.com/), they helped me greatly when I was learning. Also the community is pretty nice - @avdi and @jeg2 (they do some screencasts and are active on twitter/mailing lists/etc) are super nice. Welcome!
First of all: kudos for learning and facing the angry Reddit crowd. Some congratulations: your code is split in various classes, and your methods are not that long. Good job. Some comments (probably not in order). * Your scope look big to me. It's ok as long as you can go toward there in small steps (which you are doing for now). Just be careful not do get discouraged by the amount of work. If you can think of a subset of your game, try to implement it first. * Add tests: If this is a learning excercise, it's a perfect place to start using some unit tests, and your project looks a good fit for that (no external dependencies). Get started with MiniTest, it will help you improve your skills &amp; design. * If you require a file from another one, require_relative is your friend * Your GameData is just constants (good job for putting them in an apart class), you could go one step further and just make all of this a yaml file, and then have just a small method to load it. * Tiles: your subclasses (Ridge, etc) are not really needed. You are using inheritance where you just need types. This could work as well with a Tile having a TileType that contains the specific information. If this make no sense, disregard (most of us abused inheritance at some point in our learning). Enjoy, Martin
That reason is why I don't compose in sends, as I've seen some people do. I'll just let tables explicitly drive stuff, like in /u/siomi's example, so that those lines show up in grep, and that pretty clearly tells me there's a send somewhere.
Instead of if ACTIONS.keys.include?(@input) self.send(ACTIONS[@input]) else You want: action = ACTIONS[@input] if !action.nil? self.send(action) else If you are going to use a hash, you might as well use it for lookup.
ya, I really like the idea of the hash translation table. Seems nicer than a large case statement for some reason. Not to mention you get the benefit of being able to use it in other spots of the code. Oh, and you can use the .invert() method to do some cool things the opposite direction as well.
If only there were a formulaic approach that could replace the need for talented experienced people /s
No. `ACTIONS[@input]` could possibly be `nil`, but it'd technically still be valid (even in this case it'd also be bad, but checking if the value is `nil` is a bad habit to get into - plus, [`send()` errors if you pass it `nil`](https://eval.in/154454)). `has_key?` is also not good, because it doesn't follow the naming convention. Just `key?` is sufficient: send(ACTIONS[@input]) if ACTIONS.key?(@input)
I also suggest using snake_case for variables, since that is the naming convention of ruby.
Thanks for the reply, much appreciated. I started reading about tests, but I'm not really sure how to add to an already existing project, should I write tests for stuff that already works as intended?
I work for a former php shop now focussing on nodejs. I'm the currently the sole advocate for Ruby. From my view, I foresee a lot of abandoned node apps because the people who built them are gone and no one wants to walk into a total cluster fuck of a project that is a full featured express app.
Omitting the braces isn't necessarily _good_, though. It's probably better if you don't.
"it doesn't work as intended" is kind of vague, but: output = "int notes[] = {" notes.each do |note| output += "NOTE_" + note + "," end output += "};\n" will result in something like int notes[] = {note,note,note,note,} Note the extra comma at the end... don't want that! Same issue with the int durations[] block below it.
Self is a trickier example, as that can be used for readability as well :). I state the &amp;&amp; over and purely for conditional logic. Yes I agree if you know what you're doing it can be fine. But to have someone new to ruby on a team, it's typically better to make code that's easy to understand :)
Yeah, we use it a lot to do exactly what the use case here is: elegantly allow only certain user-inputs to trigger actions without having a big case statement or having to rely on an else. We can capture effective elses in a way that fits with our raise-heavy conventions by doing: method_table = { 'foo' =&gt; :foo_call, 'bar' =&gt; :bar_call } return object.send(method_table[user_input]) raise "Bad input"
Commit early, commit often. .. This rule hasn't wrecked me yet!
Everything you said can be done in web apps.
&gt; I'm not aware of another case where prefixing a statement with self-dot is necessary When one sends the `class` message, one must use explicit `self`, owing to it also being a keyword.
If it's public, please prefer `public_send` -- `send` will send to private methods too. `public_send` is available in 1.9.3+
As someone who was in OP's footsteps less than a year ago, I can tell you this feedback is gibberish.
Your project is not that big, but you could start with your next functionality. One problem you'll probably face is interacting with the UI (the command line in your case). Now this could be a good opportunity to split the UI part (printing things, reading things from the keyboard) from your game logic (have the player take action, collect resources, etc). The idea there is that the command line is "just" a way for the player to interact with your game - it could be something else (like a web interface, or a rich gui, etc).
For starters, don't inherit from struct.
I got the idea from here: http://stackoverflow.com/a/2687553 Can you elaborate on why you think this is not a good idea?
No, I mean calling class methods from an instance.
Really excited to finally have this out there! If you're looking to upgrade, be sure to give [transpec](https://github.com/yujinakayama/transpec) a shot - it makes most syntax changes automatically. If you come across any issues, please report them in one of the [RSpec repos](https://github.com/rspec).
Love these talks, very insightful to see the various perspectives play out. 
http://www.ruby-doc.org/core-1.9.3/Regexp.html#class-Regexp-label-Capturing &gt; When named capture groups are used with a literal regexp on the left-hand side of an expression and the =~ operator, the captured text is also assigned to local variables with corresponding names. If you want to store your regex in a variable, you can use x.match("123 456-7890")[:area_code] to access the capture groups 
Why exactly is an anonymous class a problem in this instance?
Cool thanks. Any idea why it matters or why they did that? I'm capturing in a loop so I was hoping to avoid the object creation each time.
I've no idea about this case, but Ruby has lots of strange/magic regex features to make it feel more familiar to users of other programming languages (usually Perl).
In Ruby an identifier that appears as an expression¹ can either be a local variable or a method. The decision which one it is is made statically (that is before run time). When you have `/bla/ =~ "bla"`, the interpreter can easily see which local variables will be introduced by the regex without running the code. But if you do `x =~ "bla"` can't see which variable names would be introduced without knowing what `x` is (which would require running the code in the general case), so it was simply decided that no variables will be introduced. The alternative would be to make the variable/method distinction at runtime rather than statically, but that would presumably require too much changes to the implementations' guts and/or be too bad for performance to be a good option. ¹ As opposed to after a `.`, in which case it would definitely be a method call. ² Or compiler or whatever.
If I have the time, I'll try to fork and refactor this later for fun, but the first thing that makes me a bit squeamish is the monkey-patching of DateUtils. I wouldn't consider myself a Ruby master by any stretch, but I make it a point to avoid doing that in my own code, and I've always felt happier for it.
Agree what you said is unintuitive, but if this is your actual code, I suggest wrapping the string in an object instead of using a refinement. Refinements are no more than monkey patching and are generally not good form. 
Why the monkeypatching hate? I think monkeypatching can be great form.
Like all forms of metaprogramming it introduces indirection in your code, where the definition and implementation of something are separated. It also violates general object oriented best practices and adds to a class's public api, instead of making singly responsible objects. I don't take any hard-line stances, but the example given is both easy to avoid/fix, and also shows the idea of cluttering String with domain specific behavior. 
In general it's a problem because `Kernel#load` will blow up (`TypeError: superclass mismatch for class InheritedStruct`) if you try to load that file twice. Then again, assigning to a constant gets you a warning on double load so there really is no winning. I think the best solution would be for Ruby as a language to recognize what the community does with Struct and take what steps are necessary to support it.
Some people would argue "performance" over that anonymous class, instead I'll say that it's because `load "day_night_consumption_calc.rb"` will throw an exception if it's called twice. Changing it to `DayNightConsumptionCalc = Struct.new(:year, :month) do` has the same result but trades that exception in for a warning about redefining constants.
&gt; so I would like to understand how to use them effectively. *this* is not an effective use of them. there. &gt; Matz would feel the need for expletives in any discussion of a programming language Matz is probably the *only* BDFL who doesn't curse. 
Ah, my mistake then. I thought you were using the gem, then monkey patching it, which would be a big no-no for me.
This is how I did it before I saw /u/jabbaroni 's answer: Regexp.last_match[:area_code] Regexp.last_match will always have the result of the last regexp match you executed, I believe.
Friend, this code, and this post, have only one purpose: to highlight what I thought was unexpected behavior in the current implementation of refinements. Your comments are off-topic. Feel free to take your opinions on the worthiness of my code and the rest of Ruby and start your own thread with them somewhere else. I'll join you there.
The right way is to use RVM
I like the explosion ASCII art ;-) And this is very cool too: class String def red; "\033[31m#{self}\033[0m" end def cyan; "\033[36m#{self}\033[0m" end def magenta; "\033[35m#{self}\033[0m" end end Few comments: * There is repetition in the method `theme_questions`. You can bundle the things that are common (`print`, `answer = gets.chomp.strip.downcase`, `Builder.`) into a new method, and then call that method every time you need it with the needed text and instructions to `Builder`. * I would store all answers during the question time, end with "Are you sure?" and then execute all replacements, file deletions, git commits and everything else you want to do in one go, instead of having to do `git reset --hard` etc. * On a few places the `if answer == 'y' || answer == 'yes'` could be done in a way that answers holds either a boolean, or an object with methods that would return booleans: `if answer.confirmative?` `if answer.blue?`. It looks like a project you had fun to build, good job :-)
I wouldn't recommend casually extending String class like that. After ignoring other people's advice on this previously I've learned the hard way that a more obviously namespaced module, even though less pretty, makes it easier for yourself and others to work with later - and less likely to clash with any other gems that you may be using. 
In ```tag_replace_delete``` you've got some nested ```if``` statements that are almost identical - that code can all be pulled out in to another method and reused. Also it's not obvious what those nested parts do, so you can use the method name you pulled them out with to explain e.g. ```open_tag_and_replace_then_close()``` Same pattern in ```def theme_questions``` you are using comments to explain what the code does and it's a massive method. If you pull out the commented sections in to new private methods like ```display_welcome_message()``` the code will be easier to read and you can lose the comments.
You are changing behaviour of some methods with a boolean: ```Builder.tag_replace_delete('GULP', answer, true)``` This makes it really hard to work out what is happening, better to use two methods: ```tag_replace_delete(tag_var, answer, inverse_delete = false)``` Becomes: ```tag_replace_delete(tag_var, answer)``` ```tag_replace_inverse_delete(tag_var, answer)``` 
It was much more for how the colouring itself works, I did not know it worked that way. I agree there are more elegant solutions for executing the code than extending the String class.
I can't really see the point of packing up such a small and specialised block of functionality as a gem. 
Unrelated: The &lt;title&gt; of the page is confusing.
huh wow, I've never noticed that. I just fixed it thanks for pointing it out.
I'd suggest putting the site title after the post title so the post title is always visible when there are multiple tabs open.
I don't see the fact that it's small or specialized as a problem. Having a wrapper for an API is usually handy and there's no sense in people rewriting the code independently. It's not like it's taking a really good gem name that someone else could use.
Care to be more specific?
[TryRuby](http://tryruby.org/) is a basic, interactive tutorial
If you are doing small throw-away projects, the last example will be sufficient. However, if you are programming ruby professionally (you have to answer to customers), then I would recommend the first example. (BTW, there is a better pattern for the first example later in the chapter) Why? Well, as a "professional" programmer, you will be answering to many customers. Each customer has their own ideas and needs. It is this variability that makes programming hard. Lets take a look at the last person class. What if you have customer1 that doesnt care what a person's job is? Will, you be ok instantiating a person as Person.new("bob", nil) for each case of customer1? You also have customer2 and customer2 wants to know what a person's sleep cycle is. Would you be ok with have a special case for instantiating a Person as: p = Person.new "bob", "who cares" p.cycle = "8 hours" or maybe adding a parameter to initialize: class Person def initialize(name, job, cycle) @name = name @job = job @cycle = cycle So, now you get customer3. This customer's business is women's health, so customer3 cares about a woman's cycle. So, you would have to change the previous code to: p = Person.new "bob", "who cares" p.sleep_cycle = "8 hours" or class Person def initialize(name, job, sleep_cycle, womanly_cycle) @name, @job, @sleep_cycle, womanly_cycle = name, job, sleep_cycle, womanly_cycle And add a #womanly_cycle method. Now, thats just only three customers, imagine 100 or 1000. You would be changing code all the time. TLDR; the first example for code that changes frequently and the last example for code that never changes. 
I'd give Rails another chance considering the Merb core contributors went over to the Rails core team a few years ago. If not, look at Padrino: http://www.padrinorb.com/
Ruby 2.0 added keyword arguments, and 2.1 added required keyword arguments. I've started using these in place of either of these patterns for most new projects, since you get the best of both worlds: class Person def initialize(name:, job: 'default job') @name = name @job = job end end Person.new # =&gt; ArgumentError: missing keyword: name Person.new name: 'Steve' # =&gt; #&lt;Person:0x000001018293d8 @name="Steve", @job="default job"&gt; Person.new name: 'John', job: 'CEO' # =&gt; #&lt;Person:0x000001018432b0 @name="John", @job="CEO"&gt;
Thank you; I'd heard of it but had not looked for some reason
Cool, how long have you been in the industry? How do you like rails?
While I haven't yet had a chance to use it, I am very excited to try out Lotus. http://lotusrb.org/
Looks cool, I wouldn't worry too much about commits after only 4 of them. camelCase naming is something you should be careful with. while it's okay to use it in JavaScript (notice the case :P), although even JS uses snake_case for folder/file names, it's not that okay to use it in Ruby. Following conventions and going mainstream is something I would recommend for someone getting started with any programming language, they are just a result of other people's invested time in that language - respect them. Here's a good resource for Ruby conventions: https://github.com/bbatsov/ruby-style-guide Games are fun and Ruby is fun, you definitely have a good taste! 
Unless there is a reason to do so don't use hashes as a substitute to arguments. It takes more to type, ties you to argument names, reduces code readability, requires greater adherence to rigorous documentation of parameter names... etc. The only positives I can see is that it lends flexibility in parameter ordering whilst decreasing the signature length. I suspect I would throttle someone who did this on a project.
Too many parameters in a method signature is a good indication that the method/class needs refactoring, not that the method needs a hash as a parameter.
News just in: Ruby linked to sudden increase in visits to opticians. Scientists baffled!
See my answer [here](http://stackoverflow.com/a/19459775/191741), I think it has everything you need. Essentially you need to create on the sending machine (typically your web server) is a virtual serial port that you can write to. This port connects to a virtual serial port on the client machine which has the printer installed and an HTTP &gt; Serial virtual port that connects to the printer itself. i.e., Virtual COM (server) &gt; Ethernet (server) connects to ethernet port on Ethernet (client) &gt; Virtual COM (client) &gt; Physical COM (client printer) So essentially a client using the POS web application sends the 'display text' back to the server. The server then writes to its virtual COM port. Whatever is sent to the virtual COM port is sent over the LAN to the destination IP address. That destination PC (the one with the printer attached) has a listening port which connects to its own virtual COM port. That virtual COM port is connected to a physical COM port and writes the data to the display pole. I'm sure the type of data being transferred is irrelevant. I use it for a display pole, you can use it for a printer. I think there might be options for LAN &gt; USB emulators as well. Addendum: What do you even mean send a POST to a printer? Are you just trying to print over a network? Why not just set up the printer on the web server machine as a local printer and get some sort of ruby gem to just print a rendered document? Instead of getting us to answer your question, why not tell us what the problem really is?
As far as printing receipts go, is the device attached physically to the machine you're using to print the documents? You can just create a 'receipt' page which is printer friendly. In Firefox there's an addon called [JSPrintSetup](https://www.google.ca/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0CCoQFjAA&amp;url=https%3A%2F%2Faddons.mozilla.org%2Fen-US%2Ffirefox%2Faddon%2Fjs-print-setup%2F&amp;ei=DHF-U7qCFcbt8QH0uIFQ&amp;usg=AFQjCNFbTMhjZj0mRbdix-V2pl_keJb3cg&amp;bvm=bv.67229260,d.b2U) which can silently print to the printer name specified in your javascript. So what I did was when an invoice was made, the server redirected the client to a receipt page which had javascript that auto-prints using JSPrintSetup configuration. After printing was executed it uses javascript to redirect to a new invoice page. The only shitty thing is that I can only find that sort of addon for Firefox and not for Chrome.
&gt; ties you to argument names, ..., requires greater adherence to rigorous documentation of parameter names a.k.a. making your contract with your callers explicit. this is a bad thing, why? &gt; parameter ordering the order of parameters is entirely meaningless, whereas the names (i.e. concepts) of your parameters is extremely meaningful.
&gt; a.k.a. making your contract with your callers explicit. this is a bad thing, why? Seriously? **1) You have increased the surface area of your public interface**. And not just a little bit. Seriously this alone is enough that it should tell you how bad it is. But I can see that you're not convinced so a couple of other random reasons why its bad: **2) If you refactor a methods "parameter names" (e.g. [:name]) you also have to refactor the caller.** "WOW! I would just so love it if every bundle update I had to correct my code because someone decided a parameter name could be slightly more meaningful!" no-one was quoted as saying. **3) Arguments must be of a type which responds to element reference semantics.**. Lets forget about everything being an object and make everything a hash or have hash like semantics because languages that do that are so wonderful to program in. **4) The method signature is no longer sufficient to describe your method.** Because everyone writes wonderful documentation. Oh and I so look forward to the joys of: def initialize(args) @args = args end &gt; the order of parameters is entirely meaningless Order currently does have meaning (to the computer) &gt; whereas the names (i.e. concepts) of your parameters is extremely meaningful. You wish ;)
Which is why I use named parameters and use Hash.fetch when not in Ruby 2 and 2.1 None of your concerns are valid for named parameters. 
Hi Nick! We exchanged ideas a while back regarding forms, as I currently have another form model gem called FreeForm (https://github.com/brycesenz/freeform). I also realize that I owe you a refactoring of the DateParams parsing for both of our gems, so I apologize that I've been too busy for that. Anyway, I think I see things a bit differently than you, and I'd love your thoughts. I'm with you in that I think the current **validate** method is useful, and that it would be silly to only have methods for the component parts (attribute assignment &amp; validation). But I think worse than having a lot of methods is only having methods that do complex functions, with no way to just do the simplest bit. From that persoective, it seems like a valid ask of an API to at least have some method for assignment without validation. &gt; there simply is no case where you wanna fill out a form but then leave it unvalidated. Eh, not sure that I can agree. Say you write in some "before_validation" hooks for your forms - I can see actually being interested in making the assignment and doing *something* with that form before you do the validation and alter the form's state. Also, to the extent that people are using form object in a Rails app, I think it makes sense to give them a lot of the common methods that one expects of Rails model object, such as an equivalent to "assign_attributes".
Set up a ~~VPN~~ VPS and deploy your projects there, you'll both learn a lot about deployment and have something to show potential employers. Make a point of giving links to them in your initial email to whomever you're applying to. Doing this, having decent code on my github, and talking confidently about my code got me my junior position. Apparently it's fairly difficult to find a good junior developer, so if you can show that you have a good foundation to work off of, and are eager to learn/contribute, you should be able to get a position. If your're self taught and don't have a degree(like me) don't let that discourage you, it's actually a strength and a very good talking point during your interview(just talking about how you taught yourself programming is a chance to show your learning process). How many people are hiring at the time and how quickly you get an interview though are matters of luck, so persistence is key too. I also recommend that you start applying as soon as you can, even if you're not fully comfortable yet. 
When I read the title, I thought it was some kind of joke. But I suppose that if I needed this functionality, I would appreciate having it packaged as a gem.
Glad to see an update with progress, but it's really not ok that someone had to call this out just to get it. Basically no progress reports and the timeline for "reimplement basic rvm functionality" has already passed. Not cool. 
learning to program is largely about recreating simple concepts that other people have already done. Rather than using the gem maybe he should just see how the gem does things differently
Hey Bryce, of course I remember you!!! If you want to do something before the validation you're free to override either #initialize or #validate and then call super. This is way more forward-compatible then to provide hooks that change. Remember, both methods are public and will always stay in Reform. In case you don't want all of the Form's functionality, you might be interested in using the Contract only which Form is based on: https://github.com/apotonick/reform#contracts Sorry, but I completely disagree on your last statement. I don't think we have to inherit all the behaviour, APIs and associated magic that Rails brought us. I've seen too many Rails projects failing due to bad architecture, which is a result of a fuzzy and bloated API and the lack of abstraction layers in Rails. Modern gems and frameworks should provide solid, simple APIs. I see your point, though, that it sometimes might be handy to have something like "assign attributes", however, currently, I would override/extend the validate method for that. I seem to have nailed it with Reform's descriptive API, your project is the third gem I know of that has copied the API 1-to-1 :P Yeah man, when are we working on that DateParams refactoring? Also, I'd love to see what makes you write your own form gem over Reform? Would love to see some examples!!!
I got lost from 3:38 to the end. Not the example but the concepts (message and methods)
+1. Named parameters are awesome, for the reasons you describe. The have none of the drawbacks that /u/morphemass describes.
 E: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied) E: Unable to lock the administration directory (/var/lib/dpkg/), are you root? you forgot sudo
To quote myself: *"unless there is a reason to do so don't use hashes as a substitute to arguments."* None of my points were levelled at named parameters. My point was that using a **hash** as an argument is incredibly bad practice for all of the reasons I have listed *and others*. 
You could always make your own 'refine' implementation, not that it would be efficient. Personally I haven't found any uses for refinements yet, but then again, in the past I think I did have places I would have used it if I had it.
/r/cringe
I've been coding Ruby since version 1.8 I think. Just want to throw out something slightly different. The way I like to do things is like this: class Person attr_accessor :name,:job,:email def initialize() # create an empty object end def with_attributes(name:,job:,email:) @name=name||@name @job=job||@job @email=email||@email return self end end people = [] # =&gt; [] people &lt;&lt; Person.new.with_attributes(name: 'Bob', job: 'Clerk', email: 'b0b_r00lz@yahoo.com') # =&gt; [#&lt;Person:0x00000001dee9b8 @name="Bob", @job="Clerk", @email="b0b_r00lz@yahoo.com"&gt;] What I've found is that it tends to be more useful to keep :initialize as small as possible. Although, depending on the use case you might need to require setting attributes through initialize. Sometimes, it makes your object more flexible if you have something like I just wrote. You have to then account for missing attributes in relevant methods though (as opposed to just always raising an error if the object doesn't get initialized with the attribute) Another approach that is less common in Ruby, is to have multiple initialization methods. So like Person.new , Person.new_with_name ... Usually it's not preferable though, that is more common in some other languages that aren't so dynamic.
100 hours per week? That's craziness. Don't do that.
&gt; is the same for named parameters as hashes. Yes, however the fact that they do not share the other disadvantages, combined with the fact that they should not be used in every method signature means they are a beneficial addition: def initialize(first_name:, last_name:) # BAD, BAD, spanky time! def initialize(args) # BAD, BAD, BAD! Spanky time with Joffrey! def initialize(table_name = nil, database_connection_string:) # GOOD, Spanky time with Oberyn (but still needs documentation) &gt; I don't think this is true Take a look at the original post and recall, I was specifically referring to the idea of using hashes, not named parameters. You've just supplied yet another reason why hashes are bad.
thanks, I'm looking forward to your feedback
Imagine your entire programming language was based on email. You fill out the to: bit, you add some email content as the 'arguments'. Does this mean much to your email client? Nah. But the content of the email starts explaining things that are understandable to a human - a set of orders, or it contains attachments. Passing methods around, what the heck is that about! You can only pass variables around, right? Going back to the email example, could you add another email as an attachment and forward it to someone? Hopefully, that makes a lot of sense, and at the end of the day, that's all this is conceptually - an "address" and an email body (data in a structured format) going from A to B; and you can attach/stick more emails/snail mail into the same envelope. Anonymous functions in javascript are just letters in envelopes stuck inside of each other so some extent - so are blocks, procs, lambdas. What will make things confusing though is when you make a variable that refers to a whole letter/envelope ie: a = def foo(arg) puts "bar: #{arg}" end is "a" something you can resolve? Not... really any more, it's just something you can call. It's a pointer to where the executable bit can happen. 
Imagine each object as it's own program that keeps it's own state and has it's own interface. Every method in an object is essentially a subroutine in that object. When you send a message to an object you are using that object's public interface. It is up to the object to implement the behavior associated with the message you send it. Most commonly, defining a method means that sending a message with that method's name will call the method. Ruby doesn't have to work this way though. Ruby allows you to create closures which are basically objects representing a method (and the environment that method executes in.) Ruby also allows you to define method_missing which is a special method that recieves any messages that the object gets which don't have a matching public method. Let's make a simple test: # add the public method :foo to Object def Object.foo() 'bar' end Object.foo() # =&gt; "bar" Object.__send__(:foo) # =&gt; "bar" # create a Method object from Object#foo myfoo = Object.method(:foo) myfoo.call() # =&gt; "bar" myfoo.__send__(:call) # =&gt; "bar" # now change Object#foo def Object.foo() 'narwhal' end Object.foo() # =&gt; "narwhal" Object.__send__(:foo) # =&gt; "narwhal" myfoo.call() # =&gt; "bar" myfoo.__send__(:call) # =&gt; "bar" Object.foo() == Object.__send__(:foo) # =&gt; true Object.method(:foo).call == Object.method(:foo).__send__(:call) # =&gt; true Object.foo() == Object.method(:foo) # =&gt; false This demonstrates the same thing the video was showing, but hopefully in a clearer way. To continue on the same subject, you can create a function without an object. my_function = proc { 'foo' } my_function.call # =&gt; "foo" Then you can confuse everyone that you work with by doing something like # Inherit BasicObject so we don't have all the usual methods class Wizard &lt; BasicObject @@spell_caster = proc { |*args| puts "Wizard casts #{args.join}" } def method_missing(*args) @@spell_caster.call(*args) end end melvin = Wizard.new melvin.fireball! # =&gt; Wizard casts fireball! Also relevant, Ruby has "bound" and "unbound" methods. A bound method has a specific environment it runs in, an unbound method does not. A common example of unbound methods would be when you have a module with a bunch of methods that can be included in a class. Those methods are bound to the class once you include the module. It's a little confusing, but calling Object#method creates a new bound method, it doesn't reference the existing method (because methods aren't objects)
By the way, where in exactly POODR is this advocated? As said, I believe it is terrible advice and will be surprised if SM was actually advocating this.
Not millions and not really experiencing poor performance. I have some lines which don't split on whitespace/string easily, so I was using a regular expression and didn't want to use numbered back references for clarity. The code in the OP is a much simpler example.
Thanks ara.....where are you located ? im in Chicago
YOSHEEK I have been getting some great suggestions/feedback from a few people. I will definitely be putting all this great input to good use. Mostly everybody has suggested GITHUB. You are the first with the VPS. DO have a specific service provider that you recommend for VPS? By doing both GITHUB and VPS, does that give the employer a chance to quickly see the code written on GITHUB and the execution of the project on the VPS ?
Nice pointer thanks! lotusrb looks very promising wrt to our wish to keep the lightness of Merb. p.s. BuckMeUp.com looks a great idea brought to life...
Cheers; now if only I could find my copy of POODR! 
It comes from taking functional approach a step too far, as far as I can tell.
Seriously. Even in Japan, working more than 90 hours a week is frowned upon (and illegal although some people do it anyway). 
Oops, perhaps I was unclear - I don't think Form object should support every single part of the ActiveRecord API. But when I tend to fall back on their naming convention for consistency, and still think that there is value in having something like "assign attributes", or having before/after validation and save hooks. I personally like to build gems that encourage use of predefined hooks vs. just saying "extend this method on your own". I don't really know why I feel that way, but it's probably worth talking through at some other point. But yeah, Reform's API is super solid, and definitely had a lot of influence on my own form gem. &gt; I'd love to see what makes you write your own form gem over Reform? So many things! The primary driver was just that I saw a lot of value in form objects, and felt that I'd personally gain a lot from writing my own gem, seeing firsthand what some of the challenges were, and basically just all of the fun that comes from doing something on your own. Ultimately, I'd love to see just one, ultimate form gem out there to rule them all, but for now there are a few things about my gem that Reform doesn't have that prevents me from switching: 1) **Composition as a default/composed nested forms**. In my mind, form objects should allow you to coerce params into however complex a mess of domain models as you need. How would reform handle the following case? https://gist.github.com/brycesenz/0ea951cbaecd30b791f2 2) **Delegating validation to the models**. I know this was a point of contention in Reform for a while. I like it, and I made it a point to support it in my own library. I don't know where Reform ended up on that issue. 3) **Helpers for dynamic nested forms**. This is pretty Rails specific, but I really liked Ryan Bates' nested form gem from back in the day (https://github.com/ryanb/nested_form), and I wanted my forms objects to have similar helpers available out of the box. Honestly, I'd love for #1 and #3 to be a part of Reform at some point. Thoughts?
Thanks, found it.....ouch. Its been a good while since I read poodr, and didn't recall that. Yup, she's advocating it and it is still *absolutely terrible advice* for a great number of reasons.
thanks!! that's a great explanation
Yeah it comes from turning each method into its own class, because functions aren't really first class citizens in ruby.
Pretty neat, but why should I prefer this over [activerecord-import](https://github.com/zdennis/activerecord-import/wiki#an-introductory-example)?
Yes, the approach you are asking about is a good way to go. But you don't necessarily need to show the code as well, if you do make sure it's well commented and doesn't look like crap(Rubocop can help you). As for providers, I recommend DigitalOcean. It's $5/month(but pay as you go), and very simple to get things going. When you deploy your app, I recommend you do things the right way e.g. use a production database(mysql or postgresql), have a deployment mechanism(capistrano and or docker), use a production server(passnger/unicorn/nginx whatever). It'll be harder than just doing `rails s` with sqlite3 but you'll learn a lot in the process.
Thanks for asking, just 1 month in my job. Still learning the ropes! Though I need to learn server deployment if I am to get further, can't keep working on localhost/Heroku.
I am interested to read that book, too!
Similar note, check out parsing expression grammars and a ruby implementation: http://treetop.rubyforge.org/ Super easy way of defining a grammar and parsing out an AST from it.
The truth is that I didn't know about activerecord-import when I was implementing fast_seeder. Thanks for the reference!
Use tap if all you're doing is setting publicly accessible attributes : person.new.tap do | p | p.name = 'bob' etc.. end
Benchmarks would be interesting.
Good stuff. Usually we would run a subset of tasks as pre-commit hooks on git and svn repos. Then we would have all tests, code analysis, profiling tasks run on each major branch on a Hudson server. It only takes 5 minutes to setup a decent pre-commit hook script. No one should operate without one.
Wait- so Ruby is not going to have any testing tool in the standard library?
Well I actually had like 30 more commits that I accidently deleted when I restructured the folders :P And I did encounter the naming convention since then. I did some scripting in AS3 before where the file name had to be the same as the class so it sort of stuck :P Thanks for the reply, much appriciated :)
The issue (as I understand it) is that Ruby _also_ tests itself with MiniTest, and therefore there's a situation where Ruby's internal testing stuff clashes with the need to ship one with users. Until some solution is found, minitest is out. The commit has already landed on master.
I didn't read official docs about SRP - this is my interpretation. I find it helpful to classify a class by its public interface and not by its behaviour. It doesn't really say something if you tell me a class has "a single reason to change" - that could mean it does exactly one thing (that's what you mean and that's a good thing) or it could mean it handles one concern in your domain (which is completely useless information from an architectural point). I should have added a note that this is my conclusion, based on Uncle Bob's talk. Whooops.
I'm guessing a ruby DSL has been ruled out for your application? I'm interested in hearing about what you plan on building ( if you can share )
Solution is found, just not implemented. (if I can help make this happen), we're gonna ship with real gems installed normally. I'm gonna try to make this happen for all 3rd party libraries except rubygems itself. ETA: see https://bugs.ruby-lang.org/issues/9852
It's actually not for a project at all. It was something I browsed through on the web and went "huh...this looks cool..too bad I don't have time to pick up a non-immediately-pragmatic technical book". Fast-forward 1 week and I realize that my awesome employer has an open-dev Friday once every 2 weeks and I could just pick up that book for it. And now I can't figure out what the book was called :(.
If it was posted here I recall it but damned if I can find the post.
I don't recall where rvm installs itself, but if you can get vim to open .bashrc or .bash_profile, you should be able to find and remove the brokenness at the bottom of one of them. This precision surgery will retain any other profile changes you've made (e.g. enabling color, or adding Heroku/Postgres.app/homebrew to your PATH). If you haven't customized anything else (or all else fails), the nuclear option is: rm ~/.bash* This will wipe out any other customizations you've made to your shell but leave your system otherwise intact.
I have no idea what half of this means, but your nuclear option worked. Thanks!!
I explicitly add the minitest gem to every project I'm on, because ruby's minitest is pegged to an old version (4??).
It's a terrible idea but ruby does not have named arguments and optional arguments have to be ordered properly so people do this instead. What you should probably do instead is to use one of the pattern matching gems.
This is what rubinius does for the ruby-sl stuff and it works well.
This is a great article.
I always forget that there's such a strong Japanese Ruby community who helps maintain Ruby. I find that really interesting.
So this how ruby programmers are, huh? Yeah, I will stick up with Java.
friednoddle obviously had good intentions but be careful when running any command with `rm` and the wild card `*`.
Chris Pine's Learn to Program is excellent: https://pine.fm/LearnToProgram/
So, how will this be SemVer compatible? Removing functionality is a breaking change, and should be Ruby 3.0 then, not 2.2.0. Maybe I am misunderstanding something.
Yeah but how many hidden bash folders were you expecting to have?
hahahah ruby and semver. every time someone asks them why they claim to be semver, when in actuality it's some half-baked made-up versioning scheme, they just throw up their hands. Major version changes apparently are only done "when matz feels like it" why? "because tradition" was the answer I got.
Uncle Bob actually recently [posted another blog post](http://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html) about his thoughts on SRP.
SRP means that the class serves one actor in the organisation. It's about making the system easy to change in future by limiting the directions from which requests to change that class can possibly come. To a first approximation it means that any class will only have one person bugging you to change it. I can quite happily write single-method interfaces which violate SRP.
As an alternative you could always use [heroku](http://www.heroku.com), it's free for hobby development apps, and has some great documentation that extends beyond how to set up an application with them. You'll also flesh out github a tad as to push apps to to it you add heroku as a remote. If you get a chance I'd also look into the delayed job solutions out there. Getting the basics of Delayed::Job and resque down might be useful.
I seconded the LTP book and after that join the RubyNewbies.org study group 
every week the same question … but the simplest and most effective way to learn is, solve a problem you have, that's all the first think you will learn is, to analyze your problem (this task is more important then coding, cause if have done, coding is only simple typing), abstract it from spoken/written language in which you described your problem, implement it in your programming language 
Second Ruby Monk. For an online tool, it is one of the best I have ever come across. Clear, concise, and extremely helpful. If you are looking for something a little more fun, I recommend Why's Poignant Guide. It is a solid technical book loaded with stupid jokes and irreverent humor.
Http://pghrb.org scroll to **Learn** section
The Ruby Koans http://rubykoans.com/
If you're already an accomplished programmer (as in, you have a few languages under your belt), check out Matz and Flanigan's O'Reilly book. It's a little dated but I'd still recommend it - it was the best book I found for teaching the syntax and concepts of Ruby (I really don't want to skip the first three chapters because they explain what a loop is, for example, and this book doesn't do that.)
There's a subreddit for that =&gt; /r/learnruby
Find a meetup group or some other group of developers. It may be that a little face to face conversation and looking at some examples with another person might help. There are some great bootcamps out there, but it sounds like you're further along in your career than needing something like that. Thinking back to Python and JavaScript, what made those languages click for you?
I second Learn Ruby THW. I had never coded before going through it. Now I'm writing stupid but functional cli apps e'ry day. If you really do all the work, you will learn in no time.
This is right on the money. Learning a programming language is very similar to learning a foreign language. You can read about Spanish in books all you want. But, you're never going to be able to have a conversation with someone unless you go out and talk to people in Spanish. Same thing for programming. You'll never "really" understand it until you go out and build something.
Thanks. Just figured that out a couple mins too late.
www.exercism.io is good for learning the basics of a ton of languages. 
Is Ruby really so difficult? I came from 10+ years of Perl and PHP, watched "make a blog in 10 minutes" tutorial, never wanted to go back to PHP again. The "element of least surprise", design philosophy of Ruby, for me was mostly "constant stream of positive surprise", as all the time I found myself thinking "Hmmm, would be cool if it worked like this, let's see.. wow! it did work like that". Writing simple stuff shouldn't be any different from Python. A series of commands and storing things to variables, executed in order. Row by row, "What's the ruby equivalent of looping through an array? aha, .each. Next!" Writing elegant stuff is more of a mindset, noticing that "this thing I wrote or am planning to write is too damn complicated and ugly as a single chunk of code" and deciding to / recognizing what to break it into smaller logical entities. Best way to learn anyways is having a project or a need. Why learn if you don't need it, it's not that much fun. 
I am writing this here instead of replying to someone else because this isn't pointed at anyone here. I realize that books like *'Learn * the Hard Way'* have been a boon to many beginners, and I salute the authors of that series for it. But even as an eternal beginner, I would not recommend it to anyone for learning Ruby per se. Its a great book for learning coding so read all such books for whatever language piques your curiosity, but books such those may send you the wrong way with Ruby. The *'Learn Ruby the Hard Way'* in particular seems to teach Ruby in a simplistic way that ignores the idiomatic way in which Rubyists think and write in practice. For example, it introduces looping through arrays by showing how to use `for` loops. And persists in using `for` loops and then introduces `while` loops to do more things. I have yet to really see a `for` loop or a `while` loop in Ruby in the wild. Put simply, the book reads as if someone translated the classic Spanish language textbook 'Puntos de Partida' word-by-word into Chinese and passed it off as a book to learn Chinese from. Yes, you would learn Chinese words (你好！）to the amazement of your spanish-speaking friends who by now thought you were one of them, but Chinese speakers would wonder why hell you speak so damn weird. If you know even just one other computing language, my suggestion for learning Ruby is two-fold: 1. Just start writing Ruby ad hoc by querying on Google and finding excerpts on Stackoverflow and from the blogs of highly cited Ruby coders you stumble across (top google hits). This will be a bit like just copying what Chinese speakers are saying (and probably slaughtering it without knowing it). At first you may fly happily and be proud to write such 'different' code. But if you are nearly anywhere as much of a self-doubter as me, it will slowly drive you crazy how Rubyists code. You'll struggle to justify why a language that preaches Don't Repeat Yourself has so many ways of doing the same damn thing. You'll ask aloud why a language that its fans call 'simple' and 'elegant' seems anything but when it has these indecipherable blocks all over the place. Why the hell are they always returning hashes instead of objects and taking hash parameters? Why don't gems just let me create an object a1 of class A that I can pass it to object b1 of class B -- why a block to call methods instead?? And why the hell is it so hard to remember Ruby code I read online and copied into my fledgling codebase just yesterday? You may begin to wonder if you're the dumbest guy in the Ruby room (but don't worry, because that's me). 2. When you have both made some solid progress with writing Ruby but are finally frustrated enough by Ruby and are ready to demand answers, go buy, beg, borrow, or steal a copy of *"Eloquent Ruby"* by Russ Olsen. He must know exactly who I am because he clearly lays out in the simplest and kindest of words why Ruby is written the way it is, why I was struggling with it, and how I needed to tilt my head just so, so that I could finally see Ruby for what it is. If you're ready for answers, you're gonna get them and oh boy will the lightbulb finally turn on. All those Stackoverflow snips are coming back to me now and I know why they were done that way. I am beginning to get why Ruby is so loved by people who get it, so hated by people who tried to cram it, and everything else in between by others. Also the biggest crime I committed as a programmer was settling into being an unquestioning and dogmatic coder. Learning Ruby broke that for me and it will make me a better programmer in the next language I learn as well. I don't know how long my love affair with Ruby will last, but I'd hate to be the guys and gals designing the next language I learn, because they better have some damn answers for me as well.
Read code and write code. Then read more code and write more code. Then keep doing that. It is literally the only way to learn a programming language (or basically any skill).
Doesn't this cause a runtime warning or error? I'm pretty sure I've tried to add to a constant before and it complained 
You shouldn't do this! You defined people as a constant which means it should never change. Now you're breaking that contract and if anyone was going to work with your app they would be in a heap of trouble if they expect it to be an empty array. I think you want an static variable. @@people would do the job and you wouldn't be breaking a cardinal rule of programming. 
It looks like it does a raw SQL insert, right? Unless I missed something it's going to skip callbacks so the "Technically it equals to" section isn't entirely accurate.
I agree. Constants should not change. Op Check this link out http://rubymonk.com/learning/books/4-ruby-primer-ascent/chapters/45-more-classes/lessons/113-class-variables
Thanks. This was an example from the book and I'm not sure why they defined it as a constant. Often times these examples don't follow best practice in order to illustrate a point but I don't see what they had hoped to point out by using a constant instead of a static variable.
as an addition to that, you can always add '-i' to any rm command to make it interactive and prompt you for every file to delete. Can really help with preventing accidents
Well, like many, Python was my first language, so I think my learning is still a bit biased towards its syntax. The Python layout and patterns still seem more intuitive to me. With JS, it just seems so black and white to me, everything has its neat little brackets to fit into, when to use : vs. =, even object constructors just came so easy to me in JS. With Ruby, I am just having such a hard time spotting the patterns in the syntax. I know it will come, eventually. And from what I understand, Ruby is supposed to be extremely intuitive, I am still just trying to make sense of it. I think I just need some resources that will throw me the structural ideas so I can start making sense of them.
Yes, it just performs SQL query.
Yes, but how?
I expected there to be some actual parsing of the ODP file, rather than just unzipping it...
A constant just means that the name will always point to the same object. It doesn't get frozen so you can still modify its contents. Reassigning a constant will throw a warning.
1) Do you have a link that explains this Trailblazer architecture? I'd like to understand it more before, if only because learning about new architectures is fun. 2) I agree with you that models should be dumb, but I think part of their "dumbness" should include data validation. In the same way that we impose validation constraints on our database (not null, index), I think it's fair to impose it on a model. Being able to say "Dog, are you a *valid* dog?" seems like the correct place to put that responsibility. I don't want my dogs having eight legs and four eyes, just because my form validation was lacking. That all said, validations in the form make sense as well. Things like field confirmation are a great example of validation that only makes sense in the context of a form; if other parts of my program want to change a user's email, they shouldn't have to bloody confirm it. 3) By "helpers", I just mean jQuery elements that make dynamically adding/removing nested forms a pleasant UI. Nested forms really only make sense to me in the context of not knowing a priori how many elements a user will add, so being able to adjust the form dynamically makes a lot of sense in my mind. It's really just this functionality, but recreated so as not to depend on ActiveRecord models (http://railscasts.com/episodes/197-nested-model-form-part-2) 4) Dude, I cannot keep up with the number of good blogs out there on Rails stuff. I probably have 50 articles bookmarked already just of things this month that I want to find time to go back and read. Plus, I'm really hoping that this subreddit will actually catch on...
Not sure why it's coming up as true, as I just ran it on my computer with that input and it came out "false." I did notice, however, that your input didn't work for 17935 (one of the examples), as it looks like their examples just skip the middle number in the case of an odd length. I think yours should be y, z = digits[0..x-1], digits[-x..-1] for both even and odd That doesn't necessarily address your input problem though, so I'm guessing that must be an issue with their site
It sounds like you are fairly new with Sinatra. If this is true, I would suggest following some ruby / sinatra tutorials and getting closer to your end goal one step at a time. Here's a tutorial on creating a blog in Sinatra: http://www.danneu.com/posts/15-a-simple-blog-with-sinatra-and-active-record-some-useful-tools/ Perhaps after you understand how the inner-workings of a blog engine work, you might be able to customize it in a way that is better suited towards your desires.
If I'm reading what you're writing as you intended, then it sounds like you've got a lot going on that you'll need to manage. I'm going to attempt to break it down in to pieces. If it were me, I would use some form of template language here, because you're going to have a lot of similar things fed by some data. I've use [Handlebars](http://handlebarsjs.com) successfully in the past for this feat. Basically, you'll describe your 3x4 box in a template, then start populating them and prepending them to a div in your page. I say prepend as opposed to append, because it sounds like you want newest on top. Jquery should be your help here. Speaking of, I'd use JS to populate your content. The way you can do this is having one Sinatra route that posts up a static HTML page with some JS sprinkled in, and a second route that just returns JSON entities that you'll populate in to your main body. Jquery facilitates all of that, with your get method iterating through each of the objects in the result array and prepending them to your page. When you say "generate new pages as posts come in," are you referring to real time updates or pagination? Paging is much easier (I think) than realtime updating, since you can basically pass in your count and offset as query string params and put them in your query. Realtime would require either timed polling (blech) or web sockets (blech). I hope you mean pagination. As for the database, I've very happily and successfully used [DataMapper](http://datamapper.org) in the past, but it's apparently abandonware. If your SQL-fu is strong, there's [Sequel](http://sequel.jeremyevans.net), but that's bare metal stuff. Or if you want to be like the cool kids and use Mongo, [Mongoid](http://mongoid.org/en/mongoid/index.html) may be the right route (although I prefer the vanilla driver, because I hate myself or something). Hope that helps. You're undertaking an ambitious project that seems deceptively simple, so good luck. You'll probably be writing surprisingly small amounts of Ruby relative to the HTML and JS needed to make the UI work. Just do one thing at a time. Start static and make it dynamic, etc. It's doable. 
start simple says the guy who wants you to use JS and JSON to get it done lol. 
Yeah, I may have gone a little nuts. Rereading it, I think he just needs an erg primer. But oh well, I'm not going to delete that wall of text, I'll just let it get downvoted to bottom in case someone finds it useful. 
You're not wrong. Im just saying based on his perceived skill level that may be a bit above his head. 
FYI, your second check for string validity should probably be: rts = str.scan(/\D/) which tests for anything that's not a decimal. Right now it wouldn't catch passing in the string "!#@&amp;"
All that code can be condensed to be a few lines, and more readable too. raise :error if str.size == 0 rts = str.scan(/[a-zA-Z]/) raise :error if rts.size &gt; 0 Could be simplified to: raise unless str.match(/\A\d+\z/) This is better anyway, since you're only raising errors for letters, but any non-digit should raise an error. This is why your solution fails. It should pass all tests if you make sure that any non-digit raises an error. All of this: digits = str.scan(/\d/) x = digits.size / 2 y, z = digits[0..x-1], digits[-x..-1] [y, z].each do |a| a.map! { |b| b.to_i } end Could be condensed to: half = str.size / 2 digits = str.chars.map(&amp;:to_i) y, z = digits.first(half), digits.last(half) Even that is a bit verbose, though, since you could forget about y and z altogether and just change y.inject(:+) == z.inject(:+) to digits.first(half).reduce(:+) == digits.last(half).reduce(:+) Hope that helps!
That is my current understanding of symbols and why they should not be dynamically generated. Normal use of them consume trivial memory.
Thanks, that's great. I will definitely go through that. 
&gt; Major version changes apparently are only done "when matz feels like it" why? "because tradition" was the answer I got. That's such a Japanese answer. I live and work in Japan and trying to get people on board with a positive change is one of the biggest challenges in the office. "The way we've always done it works fine". 
It's not just about straight converting the XML into a Ruby object, it's about converting it into a meaningful representation of the document, rather than just a direct representation of their data structure.
Insightful and I agree
Yes, but this hasn't been done. They've just created a crappy alternative to your regular unzip application.
I'm glad you found it useful. As I mentioned elsewhere, I feared I went overboard with my suggestions, but I think it's good to have a stretch goal, and with the stuff I linked to and some basic Googling, you could definitely do it and learn something along the way. Best of luck!
This is fixed in ruby 2.1 i thimk
FYI; Datamapper is being revitalized by Piotr Solnica; see: http://solnic.eu/tags/datamapper.html - blog pointing to: http://rom-rb.org/ #Ruby Object Mapper i.e. Datamapper 2 - looks interesting - see also http://lanyrd.com/profile/solnic/ for Piotr's previous presentations around Datamapper. 
Not yet. The issue has been [discussed](https://bugs.ruby-lang.org/issues/7791) and I believe there is a plan to do it but as of now they are still not garbage collected.
Optimized strings.
 @keys.each do |key, value| config.send "#{key}=", value end This should work, but your version is cleaner and more explicit. I'd keep yours.
You can directly pass the Hash to the constructor: https://github.com/sferik/twitter/blob/773d574c088584a735bd2b13e3b59f1319d39540/lib/twitter/client.rb#L22-L24 Twitter::Streaming::Client.new(YAML.load_file('config.yml')) But you have to make sure that your config file contain only valid parameters.
It passed for me with this exact code: def luck_check (str) raise unless str.match(/\A\d+\z/) half = str.size / 2 digits = str.chars.map(&amp;:to_i) digits.first(half).reduce(:+) == digits.last(half).reduce(:+) end Any whitespace in the string that's passed in will raise an exception, because it won't match the regex. Try it out on [Rubular](http://rubular.com) and see for yourself.
THANKS YOU GUYS! 
ah... `.send` was the method i was missing. good to know.
Love it. Thank you!
That's wonderful! I really liked DataMapper. It was just magic enough to be useful but understandable, but also stayed out of my way when I wanted to do weird stuff. Thanks for those links. 
I want to learn VIM but I think I need to start from square one. I am spoiled by RubyMine I think and I didn't make it untill 1 hour into the tutorial so I was pretty lost. 
Trying to learn to program by reading programming books is like reading a cookbook and expecting to be full. 
Any opinions on how developing on android using Ruboto is? 
i think the ruby way is not to use YAML at all , but require a ruby file 
You're comparing a string (gets) to a number. You want to cast it to an integer: until a.to_i == 0 do .... This is the part where you learn about irb, the interactive Ruby shell. You can type code in and see it executed live, as well as the return code: $ irb irb(main):001:0&gt; a=gets 1 =&gt; "1\n" irb(main):002:0&gt;
 a = gets 0 =&gt; "0\n" Gets is returning a string, which will not be equal to the integer 0. a != 0 =&gt; true
Great thanks both. Is there a version of 'gets' which doesn't assume type like raw_input in Python? 
thanks, and I just discovered gets.chomp -- very useful
Hey thanks for this man, I just installed it, but I had to install it by: gem install RubyRetriever in CamelCase, or else I couldn't find it. Thanks again, I'm gonna mess around with this now :)
Thanks for the feedback. Just realized this myself. What a pain in the butt! I had no idea it would be case sensitive when trying to install. I will try and switch in future, but looks like I'd have to 'yank it' to change casing now and I don't want to do that on launch day! Thanks again for checking it out!
Maybe not the wisest idea to use the name that's shared by another very popular project: http://jackrabbit.apache.org/
So fork it, and make your suggestions, and submit a pull request. I don't claim to be any elegant code master. I am a practical self-taught programmer. For me order of priority is: 1) get it working, 2) get it fast, 3) get it clean and pretty.
It just may make it a bit more difficult to get a positive google result ;) Good luck otherwise :)
I like your style. I recently worked on a project where the #1 priority was clean and pretty. It was such a horrible experience. The project lead was super anal and would overly nitpick every little commit. It took *forever* to get anything done and we always had tight deadlines we couldn't make because using single quotes instead of double quotes was more important than having functional code (this was a python project so quotes really didn't matter). I hated it. Oh, he had a hardon for TDD too. TDD is great if you understand the libraries you will be working with, but when I'm using stuff for the first time, I really just want to see working code first. It was so frustrating to have entire commits rejected because I didn't do tests first. I eventually stopped committing until tests were done, but then he was always on my back about why I wasn't committing. 
you gonna pay me for it?
i don't have to code for anybody but myself (what a life!). but i run rubocop with every test to makes sure the basics are in order. it doesn't catch lots of things, but just enough to keep me feeling that i'm writing ruby.
1. I'm in the process of finishing the gems involved in Trailblazer (mainly, Cells, Representable, Reform and Disposable::Twin) and writing a book about it. The architecture is layered, e.g. ActiveRecord objects don't do anything but persistence, the validation happens before that in a Contract or a Form (which is a Contract). That applies to all environments (console, REST API, form, Ruby API), e.g. you will always have the same entry point for changing state. As a side note Trailblazer just offers the layering, you can always go the Rails Way wherever you want. 2. See above. In this layered architecture, you simply don't need validations in the model as they sit one layer above. I understand that the inherit-validations-from-model feature might be helpful for transitions from Rails way to Trailblazer, though. 3. That sounds great! I'll have a look at it, maybe we can even use that in the reform_example app. Definitely up for providing support if it is helpful. 4. Right. :D
Ouch, probably wouldn't hurt to at a minimum provide some constructive comments on where you think there is room for improvement rather than just trolling someones open source work.
I'm busy refactoring it in a fork.
you should tag each release on github too :) http://git-scm.com/book/en/Git-Basics-Tagging
Keep in mind to_i will return 0 if it can't get a number out of the string: [2] pry(main)&gt; 'asdfasdf'.to_i =&gt; 0 [3] pry(main)&gt; 
You can follow along [here](https://github.com/chendrix/rubyretriever/commits/oo-refactor)
What are the main advantages/design differences over the sneakers gem?
Nice, watching with interest
Interestingly enough Integer() ignores special characters(as long as they don't interrupt the integer sequence in the string) so `Integer(gets)` will work for valid numbers as well.
https://i.imgur.com/dfuUaCE.gif
This is designed to be a simple wrapper around bunny + rabbitmq. Sneakers specifically says "A high-performance RabbitMQ background processing framework for Ruby." The difference is the word "framework". 
binding is not mentioned....
Thanks for the link. This is just a super simple script but I will consider this for my rails apps
Trust me when I say configuration files are the path to bald spots. All you have to do is switch the Hash you pull those configurations from to ENV 
Feel free to contribute to the script :) you may modify it and share as a new snippet.
me too
Sounds like some useful information, id be interested. 
I would definitely be in as long as it was at a time that I could attend. 
I'm in the very early stages of learning ruby so I'd be interested in about 6 months when I might fully understand it.
Awesome, good luck.
Yes please, this would be fantastic. I'm finding my feet in Ruby at the moment and would like to use it to build just this sort of thing. 
This sounds great. I'd also love to get advice on analytics, instrumenting and monitoring. e.g.: - knowing what features are/aren't being used - knowing what features/components are un-performant or raising exceptions - monitoring for downtime / pagerduty I've cobbled together all of these pieces, but I'm always curious to see how others have done it.
It looks very interesting. You might want to have a look at the CS169.xx over at edX to make sure you don't overlap with it. They could nicely complement your course. 
Great idea. I did not know about tagging. Just added a tag for vers 0.0.10 - the current version.
Check out softcover.io, it's a self-publishing tool chain that lets you write once in markdown and converts to all the ebook formats - and if you want you can use the platform to sell your tutorial. We built the system for Michael Hartl's Ruby on Rails tutorial and made it do anyone can use it. 
I meant the other test. The one that you have: rts = str.scan(/[a-zA-Z]/) raise :error if rts.size &gt; 0 Could be written like: raise :error if str.matches(/\D/) That way you're checking for non-numeric characters. The refactoring from hencethus also handles that issue.
then count me in. 
Yes. 
Maybe move up POODR up to second place. That book is the shit.
Consider linux. Begin with one running inside virtualbox. Ruby development under windows is a permanent pain.
That would be amazing. I'd even pay a small amount of money for it.
How do I install Linux? And is the learning curve for the OS hard?
If your objective is mainly to try your hand at Ruby &amp; eventually Rails, under Windows, the RailsInstaller is really nice - it's an all in package with Ruby, Rails and Git all bundled &amp; ready to use. RailsGirls's install guide (http://guides.railsgirls.com/install/#setup-for-windows) is pretty good, use it, and can be done in a few minutes. Installing RVM on windows will probably lead you to interesting problems, so I won't bother to do it now. As already said, Windows is not really fit for Ruby development. The above setting will allow you to experiment. Should you want to go further, you can always consider Linux at that time (I would go for Ubuntu, but you'll find opinions aplenty).
Thanks for the great reply! That's the second recommendation for Metaprogramming Ruby, so consider it done. If the RSpec book is out, what do you recommend for testing?
You should be able to use the JSON gem https://rubygems.org/gems/json to parse JSON into a Ruby hash and vice-versa. I would recommend something like Sinatra for a simple web framework.
I'm game, should be interesting :)
It would be gold.
Always remember cleaner and more readable code is easier to maintain than clever code. Someone else may end up supporting your code. I'd keep it the way you have it. Its really straight forward and easier to see what you are trying to accomplish. It's how I pass all sensitive info to my apis at work. 
It's a good idea. Count me in please.
Great idea! I am interested!
Absolutely.
I am in. You are a good person.
Is there a reason you're going to use a json file instead of an actual database? Learning the basics of how databases work is a really useful skill. Most web applications utilize a database of some sort. ActiveRecord is an ORM (Object Relational Mapping) library that is used in Rails, and makes it really easy to create tables and map them to ruby objects. Most Rails tutorials have a section on how to use ActiveRecord, though it's possible to use ActiveRecord in a non-Rails app.
I have wanted something like this forever! How do I throw some money your way?
Recently I've been writing a lot of articles targeted at motivated folks like you who are interested in getting a deeper understanding of Ruby. Specifically I've been writing about [Reading Rails](http://monkeyandcrow.com/series/reading_rails/) for folks who want to see the Rails source, and understand how various bits work. Lately I've just started a series on [Metaprogramming](http://monkeyandcrow.com/series/metaruby/) in Ruby, which I hope helps people understand the bits of Ruby that often look like "magic". I think your plan sounds good, but I might suggest skipping Rspec initially unless you really love it. I know some folks love it, but I think there are better introductions to testing. Start out with MiniTest, it comes in the standard library, and the source is pretty simple. You can probably read it, and understand what it's doing within a day. Next start using it. Learning to test well is better than learning a specific testing dsl. Definitely read Sandi Metz's Practical Object-Oriented Design in Ruby, it's probably my favorite book out there once you've learned the Ruby syntax. You'll learn not just about Ruby, but about how to design simpler programs. Your long term goal shouldn't be to know Ruby really well, learn to program really well.
I would love this!
Put me down as interested.
I would pay for this guide. However, I would also prefer a focus on Ruby rather than Rails, if that is applicable. There are plenty of gems and services that can assist me, but I'd like to see what handwritten methods and code you'd use.
Read this book http://www.poodr.com/ 
Short answer: Don't. If you want to learn a language, do it in the appropriate environment. Even though it can be done in windows, you'll spend more time "getting it to work" than in coding. You want to drive. Don't spend time modifying your car so it can be driven on water. I'm sure someone will (oh, they did) post that your best experience will be with virtualbox and a linux ISO. Don't worry much about the learning curve in linux. Getting used to the command line is part of using ruby.
"Confident Ruby" is also really good after reading POODR.
Appcast.io ? 
I hope this does not come across as rude as it is not intended that way. Whenever someone posts something like this my question is always "Who are you and why should we listen to you?". Could you do a little self-introduction? What projects you have been involved with? why you believe yourself qualified to write about this etc?
I installed the virtual box and have linux up and running, what RVM would you recommend me using?
&gt; I installed the virtual box and have linux up and running, what RVM would you recommend me using? 
Just use stable. \curl -sSL https://get.rvm.io | bash -s stable Then you can `rvm install 2.0.0` or whatnot. 
I wouldn't read the Rspec book as it's out-of-date now. Get https://leanpub.com/everydayrailsrspec instead. Number 4 should be **Build something** - a gem, a web app, a command line tool - anything!
Building SaaS applications is exactly why I got into learning rails and ruby so this sounds perfect for me! I have just started learning both so am at a very beginner level and would love to see something like this. The main problems that I currently get are understanding how my models should intereact (relationships) how many models I need and user roles/positions. I have sent you a pm as well
In addition to the already good choices, what about Ruby Under A Microscope?
Great response. I need to learn RSpec because we use it at my job. I've used it before, just not as comfortable as I'd like to be. And great blog by the way.
A list is just a list - I can't see how completing a list of tasks wouldn't make someone a master. Or any other goal, for that matter. I'm honestly confused by what you're saying. What methodology could someone follow successfully without involving a list of goals?
This sounds really cool!
I like system without database, easily "readable" and to copy and play with. But you're right about the skill to learn how to play with database. 
Anyone else watch this and just get constantly reminded in the code comparisons of how much cleaner/simpler ruby is to read and write?
 class ProgrammingLanguage &lt; ActiveRecord::Base has_and_belongs_to_many :code_editors end class CodeEditor &lt; ActiveRecord::Base has_and_belongs_to_many :programming_languages end &gt; editor = CodeEditor.new &gt; editor.programming_languages &lt;&lt; ProgrammingLanguage.new(:name =&gt; "basic") &gt; editor.programming_languages &lt;&lt; ProgrammingLanguage.new(:name =&gt; "c") &gt; editor.programming_languages =&gt; [#&lt;ProgrammingLanguage name: "basic"&gt;, #&lt;ProgrammingLanguage name: "c"&gt;] &gt; ProgrammingLanguage.find_by(name: "basic").code_editors.create(name: "notepad") &gt; ProgrammingLanguage.find_by(name: "basic").code_editors =&gt; #&lt;CodeEditor name: "notepad"&gt; get the idea? Models can belong_to :other_models or has_many :other_models or it can work both ways with has_and_belongs_to_many. 
First, you've got the debate over where to create the associated languages. Are they on every object? If so, you can use an before_create callback to instantiate any appropriate objects, provided you know both the objects and that they are valid. It could even be before_initialize if you absolutely always want them there! (note my use of instantiate rather than create) Alternately, are you accepting the associated languages from a form in the interface? In that case, you might want to be using "accepts_nested_attributes_for" to construct the editor and languages from one form update. There is a (not widely used in Rails) pattern called the Factory Pattern - which is essentially having an object that constructs other objects. If you have complicated logic around initializing objects, creating a Plain Old Ruby Object (a model that doesn't inherit from ActiveRecord) that can handle the complicated logic around creation can sometimes help you. If you are using a Factory, you almost certainly want to educate yourself on Transactions, to ensure that all your objects get committed together or not at all. It's a bit hard to help you more without more detail, but basically, 99% of the time, I tend to use before_ filters and accepts_nested_attributes for creating multiple associated models at once, and then break out a Factory if things get really complex.
You're asking questions of design, which means you'll have to develop a bit of personal experience in design to really get a handle on it. There is something of a saving grace: don't be afraid to refactor. Go with your gut or what seems the least reprehensible to you, and then down the road keep an eye out for over-convoluted code, repeated code, or too much switching. These are key signs that you should probably use a different design. But refactoring is the only way to get anything done when you don't know how a project will evolve, so use it help you when you're not clear on what first design decisions to make. I recommend [Martin Fowler's Refactoring](http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672). There's a Ruby-specific version that I haven't read, but I've heard that it's really not as good as the original. To help with language to search on, what you're looking for in particular are object and data relationships. You're trying to figure out how to properly relate the object which is a CodeEditor to the data which is a language. In this particular case, I would I would have two database tables that would be accessed by the classes CodeEditor and ProgrammingLanguage respectively. CodeEditor would has_one :programming_language and ProgrammingLanguage would have_many :code_editor. If ProgrammingLanguage only has data, I would then have a record for each ProgrammingLanguage that records that data. You can serialize complicated data that you probably won't search on (like syntax highlighting rules) into text fields. If ProgrammingLanguages each need complicated behavior (like you want to be able to internally parse the code and identify syntax errors, for example), I'd use the Rails STI mechanism to start sub-classing ProgrammingLanguage to capture that. Or, if it's MOSTLY behavior without a lot of data associated with the languages, then you don't even need to bother db-backing it or creating models or bothering about with STI. You can just create a class hierarchy and define the behaviors. I hope this helps. Also, as a nota bene: I am just one person with one person's opinion. There may very well be better Rails ways to do this. I'm a better programmer than I am a Rails programmer.
That is precisely why [RubyMotion](http://www.rubymotion.com) was created.
I actually had set something up similar to this, if not this same pattern, but was getting caught up on some error message that literally made no sense to me at the time. I will double back tonight when I get home to see where I left off and how far off I was. Thank you, much appreciated.
Then it can have_many. The basic principles don't change. I just misinterpreted the use. Personally, I like to start with relatively basic data and work my way up as the situation demands. So if you know that you're going to start with a short list--say, 10--of programming languages and you know you aren't going to have anything else attached to them, then you can do something as simple as build an enumerated types list inside CodeEditor and hang behavior that way. I'd search for something like "enumerated types Ruby" or something to see how people do that. On the other hand, this is the kind of thing that I think is likely to actually grow, at least into having some data attached, so you might as well database-back it immediately. Don't worry about the complicated stuff with STI or whatever at first. By "serializing complicated data" I mean that it's possible that at some point you might have some big piece of XML or JSON that can be used to define things like, in particular in this case, syntax highlighting rules. Rails provides ways (via a technique called "serialization") to store that data as a simple string in the database, but instantiate it as a more sophisticated object when it actually fetches from the database to create your ActiveRecord object. Give that a Google and you'll see what I mean. "Rails" and "serialize" are your keywords here, but this particular technique isn't immediately relevant to you.
&gt; How do you create a new object that also instantiates other objects and saves them together? Known as a multi object factory &gt; Continuing to learn more and more every day, but damn getting it done right sure would be nice. Hah, good luck. Wouldn't we all.
I work as part of a dev team on a Rails application and sit amongst many veteran developers. We have weekly meetings on programming principles and very recently have started reviewing SOLID principles to come to an agreement on many common day patterns. I believe I may have an odd perspective in which, I have a lot more theory and understanding behind me than most people who would be in my position. What I don't have is the actual design/building experience from the ground up, as I'm always in a position of extended existing projects. So I am out on a limb now trying to create my own. The POODR is the first book to help me understand many of the concepts I'm missing. As far as a Rails bible, I often reference http://guides.rubyonrails.org/ first then documentation, then SO, then I reach out on IRC or reddit :)
Thanks for the follow up.
So you basically wrapped a simple proportion into gem? Awesome!
Thanks for putting this out there, as for constructive criticism: it would be great to have a few 'real world' examples of why you'd need this over putting in your own formulas. Most of the time gems like this were made to solve a particular real world problem - would be great background to know at least generally what that problem was and how this solved it. Thanks again!
I found it convenient... pry(main)&gt; require 'numscaler' pry(main)&gt; Test = NumScaler.new(0../u/danila_bodrov, Helpful..Asshole) pry(main)&gt; Test.from(/u/danila_bodrov) =&gt; ?
I guess this could be useful if you're writing some sort of graphing thing 
It's probably just semantics, but to me, it makes "mastery" sound like a grade level you can get in school. "Just do this sequence of things, and you'll be a master!" This is how your list looks to me: **How to achieve basketball mastery** 1. Finished video about dribbling and learned how to dribble 2. Finished a layup-challenge course 3. Learned how to pass 4. Currently halfway through learning to shoot 3-pointers 5. Plan to read basketball strategy book by famous coach ... ... 50 . Now you're a master at basketball, go play in the NBA...?
There is just one RVM, there are many Ruby Version Managers. Check out first RVM. ( http://rvm.io ) Open a TERMINAL... if you're new to linux, it will look like a CMD window (Black screen) In there, just paste (ctrl-v) the following line: \curl -sSL https://get.rvm.io | bash -s stable --ruby This will install RVM on just your account (linux allows multiple accounts per machine) and will install the latest stable ruby. To go on, please read http://rvm.io/rvm/install Also, get a good text editor, such as [SublimeText](http://www.sublimetext.com/) or [Atom](https://atom.io/). Happy scripting
Hello, Have you looked at this? http://ruby.bastardsbook.com/chapters/web-scraping/
I think this may be the most interesting and insightful video of the series.
Use `.ruby-version`. It'll also tell other tools like rbenv which version of ruby to use.
Isn't your second example (using `&amp;block`) actually slightly different because ruby will turn it into a `Proc` before calling, while a simple use of `yield` avoids that overhead? I'm not trying to be a know-it-all... I am not quite sure about the details of the difference, but [this stack overflow post](http://stackoverflow.com/questions/1410160/ruby-proccall-vs-yield) clearly demonstrates that there is some additional overhead to the `&amp;block`/`block.call` method. Of course, for most applications this difference probably won't impact your overall run time in a significant way. Personally, I'm curious about how to properly implement an iterator method that takes a block or, if none is given, returns an iterator object. All the standard `Enumerable`s have this behavior, and I've implemented it in my own way, but never bothered to look up whether or not there's a standard way.
Is Gemfile only useful if you use jruby?
Radians - degrees, cm - inch, centigrade - fahrenheit, random math formula - palette color...
So you can use any text editor to open the file or even in the command line type 'nano ~/.bashrc' then add that line to the bottom. nano is a decent command line editor, my next post will be installing sublime text 2 a very decent text editor.
What would you consider a stylebook? 
Wow, I had no idea this was happening. Fowler, Beck, AND DHH all in a hangout together? I need to go watch this from the beginning.
And it's also handy to specify a gemset in `.ruby-version`.
What's wrong with rubygems to check if `.ruby-version` exists or just rely on current ruby version?
I think POODR should be added to the right list of books?
Why would I need rubygems to check on the .ruby-version file?
I saw this talk at RailsConf this year, he does a live coding exercise where he's scraping some HTML using CSS selectors. http://www.confreaks.com/videos/3325-railsconf-demystifying-data-science-a-live-tutorial
rvm uses `dpkg-query -s` to pool for installed packages and installs what is missing, RVM uses `sudo apt-get --no-install-recommends --yes install` for installation, if you prefer to do the installation manually you can tell RVM to stop on missing packages (instead of installing them: rvm autolibs read-fail 
Thanks for the video! I'll start watching it! 
There's also Nokogiri: http://nokogiri.org/ You can easily look through an html file with it for specific tags.
Rspec &gt; minitest imo
If you need javascript support, I have a [blog post](http://blog.chadcf.com/using-capybara-as-a-javascript-capable-replacement-for-mechanize/) that covers the method I use.
Use [this setup](https://gist.github.com/8bitDesigner/7570000). Works beautifully. 
You can also do things like scan for a specific tag that ALSO has a specific class or other attribute. Nokogiri is very powerful. Oh and if you need to scrape something with JS based content your going to have a bad time, because Nokogiri doesn't render it. Avoid at all costs but if you *must* you can get around it by using [watir](http://watir.com/) (browser automation) with [phantomJS](http://phantomjs.org/) (a cool headless web browser) sadly this is much slower than just using nokogiri but after trying many methods this is the best I have found.
Thank you &amp; thank you. Your comment is precisely what I was looking for. Apropos 5: first version was using Range directly and the math part was less readable, but my main concern was that I was calling a lot of '.to_f' methods every time a number was to be converted. With current approach all static parts are 'pre-prepared' in the hash. It's an open point, but even if there is no 'performance' difference I still find: (((num - a[:min]) * b[:range]) / a[:range]) + b[:min] Better to look at than equivalent: (((num - a.min.to_f) * (b.max.to_f - b.min.to_f) / (a.max.to_f - a.min.to_f) + b.min.to_f Points 1, 2, 7 are especially useful - I haven't 'seen that'. Time to write version 0.0.5. Thanks again!
You mean `.ruby-gemset`?
By style books, I mean any book where the author tries to teach you good coding style. * Practicing Ruby. * Design Patterns in Ruby. * The Rails 3 Way. The ones above are just the ones that I've read or purchased. I was disappointed with all three of them. Blogs, on the other hand, I've found to be extremely useful. They are usually short and to the point, and the code examples have syntax highlighting. Books rarely have that (because color printing costs $$$ per page)
For new version I provided, hopefully, better examples.
New version out. I must say I prefer the expect syntax with RSpec, it's more consistent. And thanks for the article, a good read.
I made a comment about this a [little while back](http://www.reddit.com/r/rails/comments/224yvp/looking_to_scrape_information_from/cgjyurs). I'll post it here, too, for the sake of convenience. &gt; &gt;**Disclaimer**: Use your common sense. There is nothing inherently wrong with scraping websites for personal use, in my opinion; no more, anyway, than it's wrong to use Adblock. However, doing so will violate most websites' ToS. Please abide by robots.txt and try under all circumstances to avoid putting unnecessary load on the server. Use APIs where provided. And, as always, it is grossly unethical to *steal* information for commercial use. &gt; &gt; --- &gt; --- &gt; There are a number of approaches you could use to solve this problem. For this particular scenario, you should check out the [Nokogiri](http://nokogiri.org/) library. It's an XML/HTML parser which you can use to select nodes in the DOM by xpath or css. &gt; &gt; As an example, take this comment page. One of the first things you see on the page is the title of this post, which is specified by the following HTML: &gt; &gt; &lt;p class="title"&gt; &gt; &lt;a class="title may-blank loggedin imgScanned" &gt; href="/r/rails/comments/224yvp/looking_to_scrape_information_from/" &gt; tabindex="1" &gt; rel="nofollow"&gt; &gt; Looking to scrape information from www.comedycellar.com Any idea how I should go about doing it? &gt; &lt;/a&gt; &gt; &lt;span class="domain"&gt;(&lt;a href="/r/rails/"&gt;self.rails&lt;/a&gt;)&lt;/span&gt; &gt; &lt;/p&gt; &gt; &gt; Now, we know the title of this particular post, so it would be an exercise in tedium to grab it with code. However, what if we want to be able to get the title of *any* comment page on reddit? Well, lucky for us, it just so happens that the HTML we just saw is more-or-less consistent across the site! You should be able to identify the parts that will change given different posts and other variables, but the part that matters to us - since we only want the title - is what's inside that &lt;a&gt; tag. &gt; &gt; &gt;Note: The following is intended for learning purposes only. Reddit provides its own API for accessing data like this, and you should use it out of courtesy. I'll leave the "how" as an exercise for the reader. &gt; &gt; So how would we start? Well, first, we should load the gems we are going to need to do this. &gt; &gt; require 'nokogiri' &gt; require 'open-uri' &gt; &gt; Next, we'll want to save the parsed HTML at our example URL, so we can work with it throughout the script inexpensively. &gt; &gt; url = "http://www.reddit.com/r/rails/comments/224yvp/looking_to_scrape_information_from/" &gt; page = Nokogiri::HTML(open(url)) &gt; &gt; Now that we've got everything set up, we can move on to the meat of the exercise. We're going to use CSS selectors to find our DOM nodes, because I am more comfortable with them than xpath. Since all we want is the text inside the anchor whose class is "title", we can finish our endeavor like so: &gt; &gt; puts page.css("a.title").text &gt; # =&gt; "Looking to scrape information from www.comedycellar.com Any idea how I should go about doing it?" &gt; &gt; And we're done! It's that simple. But wait! Titles are boring and should be outlawed, so we're never going to acknowledge them again. Instead, we're going to focus all of our attention on the comments on our comment pages - isn't that what it's really all about, anyway? &gt; &gt; &gt; If we look at the source, comments are ultimately contained in a div with the class "comment". Knowing what we do now, this should be like `gets`ing "Candy" from a baby. Let's give it a crack, shall we? &gt; &gt; puts page.css(".comment").text &gt; &gt; But at this point, we realize that something is wrong! Not only does it print out *every* comment on the page, it includes everything about the comment! But we don't care about usernames, or upvotes, or any of the nav links at the bottom of each post. What, then, can we do? &gt; &gt; As it turns out, this, too, is trivial. Nokogiri selectors actually return NodeSets for us, which are enumerable! That means we can use .each to loop through each comment, and isolate it from its friends. We can also look inside div.comment to find that the actual text of the comment is contained within a child element with the class "md". Perfect! &gt; &gt; page.css(".comment").each do |comment| &gt; puts "COMMENT:", comment.css('.md').text, "" &gt; end &gt; &gt; Now you know the basics, you should be able to figure out the rest on your own. Good luck!
Great, thanks. What benefits do you think Pickaxe and the like confer?
Also of interested, DHH's RailsConf '14 Keynote: http://confreaks.com/videos/3315-railsconf-keynote-writing-software
"The Ruby Programming Language" helps you get a full picture of the language, because it shows you everything the language can do. And it's co-authored by the original creator of Ruby, so it is authoritative. The only problem is that it's kind of dated now, since most shops seem to have stopped using Ruby 1.8. Does anyone who's read Pickaxe have comments about it?
I've always encountered issues with my namespaces. It's very minor and easily corrected, but annoying nonetheless. Great article that actually simplifies and explains the things I've experienced myself!
I used Jruby with Java and odftoolkit to work on ODP files.
I wrote a fast &amp; memory efficient ruby crawler a while back, give it a shot: https://github.com/dchuk/Arachnid
Why would you use this? Sorry forgive my ignorance I am not mocking i'm genuinely asking. 
As far as i know, no.
Wow this is pretty insane. I wonder how this is even done
An iOS version of ruby that builds Android apps? How about a Windows version of Ruby that builds Android apps without requiring a bunch of finicky workarounds?
Why is this good design and how are we meant to work with this nuance?
Pretty sure it's just been built for the Mac OS environment. Maybe they will eventually get Rubymotion to a point where it's platform agnostic, but it's roots are from MacRuby so there are probably lots of apple hooks in there that they rely on. Considering how "ruby developers use mac"* I don't see how this is a major issue right now. ------ *Not all ruby devs use mac I know
&gt; *Not all ruby devs use mac I know Myself included. I would use this setup in a heartbeat if I actually owned a mac. But I don't, I own windows computers. The one thing I don't understand is the downvotes I got for posing the question. Is there any half decent windows solution to code ruby apps for Android? The one I did find seems very outdated..
Didn't downvoted you but your dismissive tone explains the downvotes. Is your comment adding value to the discussion of Rubymotion supporting Android? That comment could easily come from a troll. "I would like to see a windows alternative" is so much more constructive. What do you think about Ruboto?
Anyone at the conference care to share some details for those of us not lucky enough to go? edit: Found this http://blog.rubymotion.com/post/87048665656/rubymotion-3-0-sneak-peek-android-support
No, I [really mean](https://rvm.io/workflow/projects#project-file-ruby-version) `.ruby-version`. &gt; When in RVM, `.ruby-version` also supports gemsets in the form of `ruby@gemset`
&gt; eliminate the `if...else` boilerplate Well, you can compress a bit with `return`: class Array def my_each return to_enum(__method__) unless block_given? self.size.times do |i| yield self[i] end self end end This way, you only ever have one semi-unchanging line of boilerplate. (semi-unchanging because for `def each_with_two_params(a, b)` you'd have `to_enum(__method__, a, b)`)
Slight correction - "Rubymotion SOON with support for Android" Laurent asked at the tail end of his keynote for help from the community to get involved with building/porting apps using the new android support. So - not quite production ready. 
I'll just leave this here... 2.0.0-p451 :001 &gt; 's\tring'.gsub('\\', '') =&gt; "string" 2.0.0-p451 :008 &gt; 's\tring'.tr('\\', '') =&gt; "string" 
I believe `.ruby-gemset` will work just as well, and it will inter operate with other tools besides RVM.
Good post! Food for thought, for sure...
How does this compare to Ruboto?
Pretty cool. Many people doing RubyMotion here? Any cool apps to share?
I'm right there with you on the testing framework. I've always thought whatever benefit RSpec might have provided, if any, was never worth the downsides. And since Minitest has a spec-style, I'm not sure there are even any upsides left any more. But I disagree on fixtures. The main problem they have is that they separate test data from the test itself, which makes it more difficult to read and maintain your tests. This is the same problem factories have and the reason I don't use them (among many other problems they have). I find the simplest thing that works the best is to just create the ActiveRecord objects you need in each test.
`gem install docx pdf-reader` might be enough. I'm more worried about the plagiarism detection itself as brought up by /u/le_fnord, as the "very basic idea" won't do.
My Rails dev flow usually goes something like this: 1. Use RSpec to write the first of the simplest possible feature specs that, together, will exercise all the views I know of as needed for the new use case/feature I'm starting; 2. Implement canned views that pass the specs, and trivial controllers that just satisfy the necessary routing; 3. Iterate until we've a full simulation of one path through one use case (initially, the "happy path"); 1. Write specs to push out (changes to) my model design for the new feature as needed to support the views/feature specs I just did; 1. Implement the model to pass the specs, and iterate back to the previous step until I have the minimum viable (skinny) model that supports the feature; 1. Spec and implement simplest-possible domain service objects ("DSOs") to encapsulate the business logic involved. Ordinarily, I'll have one that's invoked directly from the controller action, that may collaborate with other DSOs to fully implement the feature. [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design) is your very best friend here; 1. As the DSOs require changes to the (initially toy) controllers and provide data to be rendered in the views, update their specs and code to suit until no mocked/stubbed code remains that is exclusively relevant to/dependent on the current use case; 1. Select the next use case to implement and iterate back to Step 1. What you'll wind up with is the smallest, simplest code that accomplishes the mission. Since you haven't written any code that's not already covered by (passing) specs *and* you've written single-purpose, loosely-coupled, collaborative objects, you're free to make what may initially seem surprisingly large changes, because you'll *know* at every step along the way that all your code works (or fix what broke before you move on). You'll find your velocity improving nicely as you gain practice with this workflow; your wife/girlfriend may even appreciate you coming home from work at a reliably decent hour well enough not to go back to her mum's. Best of all, you'll have happier internal and/or external customers who feel comfortably in-the-loop with your progress. This *is not* The Rails Way "build-a-blog-in-15-minutes-and-take-15-man-months-to-implement-the-50th-feature". It *is* the way many, if not most, experienced developers in many, many languages have built things since decades before an Apple was anything other than a Fruit. The fact that Rails is actively hostile to good software-development practices does not mean that those *practices* are obsolete. Reimplementing the wheel *correctly* can often be tolerated; reimplementing a *better* wheel is lauded. Reinventions that are neither provably correct nor provably better are the [Milli Vanilli](https://en.wikipedia.org/wiki/Milli_Vanilli) of the software world.
I believe so too, but me and submitter both use RVM, so why bother?
Anyone else getting sick of Ninefold spamming/astroturfing /r/ruby and /r/rails?
Vim isn't particularly newb-friendly, but learning it can be worth the while. However, if you wanna get straight into coding, sublime might be a better option. The common ruby version managers are rbenv and rvm, which help you manage ruby gems and installations. These have their own tutorials/documentation. Try codeschool for a fair introduction.
Please don't ever use inline rescue.
Check your inbox -- just sent you a PM. I'm in Taiwan and can help out.
Ehh, it's an undergrad thesis. He could easily find a paper on it and use the same algo for it.
Offtopic but Trailblazer...a framework for a framework? Ouch! Cells looks interesting, I've never been happy with Rails views. *Personally* though I'm moving more to anglarjs for the front end - does cells offer anything for me unless I want to gradually decouple Rails dependencies?
I'm not an expert by any means but I did notice some things: * From what I have seen it is more idiomatic to just tell the user they need a gem than to offer to install it for them. It is also more idiomatic to use a Gemfile so they can bundle install. * Rather than figuring out the home directory yourself you should use Dir.home. This also makes your code more cross-platform. * User home directories aren't always /home/&lt;username&gt;. You should probably use the $HOME environment variable on the remote side, or just tilde. Besides that, at least on linux, there is a built-in command ssh-copy-id to do exactly what this does (it even does it in practically the same way). Not that that detracts from your own program in any way, just letting you know.
&gt; Because real men don't care about exceptions There's no easy way to say this. Please reconsider that phrase.
Just a thought, you may want to delay processing the external sites to avoid errors on the client side if there is a communication problem. Use a delay hook to send an ajax response back to the client when a form Post has completed.
Why?
This answer sums it up well enough: http://stackoverflow.com/a/15397057 It is slow and it's an 'expected' exception and in some cases it might even silence another exception. But I don't agree about the need to refactor. Sure it's a code smell, goes against lod, but if it stays trivial like in the example, it's not worth refactoring (yet).
&gt; About Miguel Palhas &gt;Loves programming since ever. Is obsessed with optimizing and automating everything he does. Yet proceeds to give an implementation of Fibonacci number calculation so horribly unoptimized, it won't calculate the 100th number in 2 million years on a MacBook Pro, without even mentioning why you shouldn't use the recursive approach ever.
Excellent. This is pretty much the feedback I was looking for. I appreciate it. I will certainly implement some of these suggestions.
The 281's answer is false. But when I give it in the logo keeps showing, seems something is wrong!
inline rescue is ~ 10 - 20x slower https://gist.github.com/deadkarma/5533060 inline rescue also uses a helluva lot more memory
probably mailing lists but I'm not sure
Too busy working.
Does anyone know if this is similar to Django's version of views? I watched a video [from Railsconf](http://www.techtalkshub.com/rails-conf-2013-sleeping-enemy-django/) where the speaker made a decent case for them (even if there wasn't anything substantive about how the ideas can be applied in Rails). But, at least superficially this seems similar in concept, although I could also just be misinterpreting either or both.
Just use if statements, try() or || . Easy to read, no unexpected side effects. If it gets to complicated maybe you should refactor that smell.
That's how knowledge and frameworks grow, building on top of each other.
I was coming here to type the exact same sentence. Thank you.
Not to mention it can swallow exceptions that you didn't intend for it to.
IRC On freenode, checkout #ruby, #RubyOnRails
Indeed, it's an anti-pattern IMHO. Our team calls it _Pokemon Exception Handling_ = you gotta catch 'em all!
Nested modules that are interpreted differently depending upon how they are declared. That *is* what the article is about.
How did I not know about `suppress`? Thanks!
Good point. I tried to implement a general Module instance method (sketchy territory already) that would let you define an enumerator with that behavior handled behind the scenes... something like this: class MyCollection &lt; Array define_enum(:every_nth) do |n| i = 0 while i &lt; size yield self[i] i += n end end end I got stuck because I couldn't figure out a way to both a) `instance_eval` the method block in the the instance rather than the MyCollection class itself AND b) pass *another* block *through* that `instance_eval` call that the method body block could yield to. There are kludgy ways around it (for instance, force any method defined in this way to accept a `self` parameter), but obviously that's way worse than just dealing with the boilerplate.
You're absolutely right, but most of the people I was woking with prefer to prefix all calls with `bundle exec` and don't use gemsets. Hey aren't aware of the global and default gemsets, they don't even care if they are using correct ruby version, they just prefix scripts with jruby or are making symlinks to the version they need. Some install ruby versions from packages, which is definitely a good thing to do, when it doesn't come to switching it when working on another project. This is a quite complicated topic. I still prefer to stick with rvm, but i have also used rbenv for a while and chruby+chgems by postmodern (who is in the comments below btw).
Most ruby discussions, I've found, happen here, in a couple of google groups, on IRC, or, mainly, in person at conferences and meetups.
Aye. I try to err on the side of "everyone can use it," but there's always those stinkin' tradeoffs.
The takeaway is that unless you absolutely know what you are doing, you should probably be declaring modules separately, not using the combined namespace syntax. 
Yes, THIS. Combined with https://github.com/ruby-jokes/close_enough I can now throw a cat on my keyboard and get back running code. Finally.
It's just a silly joke.
Cells was developed without knowing Django, but they're pretty similar and have a lot of common features like view inheritance and encapsulation.
Cells is not only an object-oriented partial, but it helps you to encapsulate a part of your application into a component. A nice benefit here is that often a cell maps directly to an angular/Ember/whatever widget and many people use cells in combination with a frontend framework. There's nothing to help you with that out-of-the-box ATM, so, to answer your question: Maybe. :) Offtopic: What's wrong with a framework for a framework? It's often better to improve existing concepts using a layered approach instead of rewriting a web framework from scratch, over and over again? I call Trailblazer a framework, it's more of a collection and integration of a bunch of gems, though, along with some generators.
Yeah, I know. But given the current conversations going on in the Ruby community regarding sexism and being aware of our choice of jokes, it's worth calling out that we need to consider what silly jokes we say. :)
I'm not capable of performing the mental gymnastics necessary to interpret "real men don't care about exceptions" as being sexist.
IRC wise, `#ruby` and `#ruby-lang` on Freenode. 
It's not overt. 
Nor is it covert.
They're *not* a good design, and you're *not* supposed to work with them. They have non-intuitive behavior. What about this are you missing.
This seems like a horrific idea. Am I missing something?
The joke.
Interesting, I'll have to try a test app with it. Right now I'm piecing together views with partials, and will have to refactor with Draper once I figure out my roadmap and logic a little more completely. But, I've been feeling like there has to be a better way. View inheritance sounds like it would be a natural fit with Russian Doll caching as well. You might want to reach out to the guy who did that talk and tell him there's an option like this, he seemed to like the idea.
Get in the habit of using a linting tool. Rubocop seems to be the most accepted standard: https://github.com/bbatsov/rubocop Running that on your code generates 70 complaints. Much of it is about whitespace (trailing, tabs, etc) but some of it will teach you good habits and expose pieces of the language you may have otherwise missed, like single line modifiers using if/else and a simpler/shorter way to use symbols as keys in hashes.
Well there's currently literally only one guy who has access to it, so yeah.... Nobody but Laurent Sansonetti can make a good comparison. But anyways, Ruboto is a port of JRuby to Dalvik iirc. Rubymotion is statically compiling ruby on both platforms, so it runs without a performance penalty, there's no memory overhead of the ruby VM, your distributables are smaller (the hello world apk shown was like 500kb), and most importantly, the need to mess with XML files has been all but removed from the development process. 
[Link](http://rubyrogues.com/parley/)
Check out /r/rubymotion There are tons of apps written in Rubymotion, A Dark Room and Basecamp are two high profile examples. 
You should probably be using your database's auto increment feature for the invoice id instead of setting the invoice id number in your code...
Definitely agree on auto increment. Alternatively, use one of the handy helpers in `SecureRandom` to generate unique identifiers such as `uuid` or `hex`: &gt; SecureRandom.uuid =&gt; "a30d7e9d-f5e8-4504-a9ae-6052f052659f" &gt; SecureRandom.hex(6) =&gt; "85f83c999e79"
Thanks, that's about what I figured. I never used Ruboto because it seemed like it has a lot of overhead and slow startup time (at least, from what I've read). I have messed around with JRuby and was surprised at how large the jar packages could get. Seems like Rubymotion will be a lot more up my alley.
Exactly, Cells have an object-oriented caching. There simply is no fragment caching, if you want to cache smaller parts, you're forced to extract that into a separate rendering method. It works great and many people use it. I've seen tons of projects where people use a cell view model to entirely replace Draper (and global partials) and embrace the decorated model in that cell. Thanks for that link, I've heard about it as some users told me that "Django does it similar to Cells" ;) I hope to provide some detailed examples how to use it in my book soon.
I was hoping it was a joke. The "close enough" gem was a little more obvious about it.
Number 6 doesn't make much sense. `Array(results)` is enough. You don't have to call the method `Array()` on `Kernel`. Other than that, great post!
You should really check out the [Ruby style guide](https://github.com/bbatsov/ruby-style-guide). They have some great tips for coding Ruby. Also, just by glancing at your code, you shouldn't assume that people call "sudo" on gem installs. Speaking of which, you really shouldn't be installing gems from within a Ruby script. If you package this into a Ruby gem, then you can add them as dependencies in the gemspec.
Excellent article. I think I'm going to start using "fail" instead of "raise" now too. 
It's definitely a good concept. I'm excited to try out something. I'm guessing I'll make a simple blog to get a feel for it.
Jim == obi wan
Great share. Thanks. 
&gt; Ruby, Python and Freedom &gt; Python is an experiment in how much freedom programmers need. Too much freedom and nobody can read another’s code; too little and expressiveness is endangered. &gt; &gt; Guido van Rossum (via Gary Bernhardt) &gt; Ruby, on the other hand, is an experiment in “give every toddler a chainsaw”-level freedom. And as Gary says in that talk, you get some things like RSpec, ActiveRecord and Cucumber that simply aren’t possible at the lower “reasonable” levels of freedom. &gt; &gt; 95% of what only Rubyists can do with that freedom is horrible, irredeemable crap. But the other 5% couldn’t have happened in any other way. Fin.
there is no special way to "get there", just do it, contribute everyone can do it, see for rails http://guides.rubyonrails.org/contributing_to_ruby_on_rails.html https://github.com/rails/rails adn you can contribute to ruby too https://github.com/ruby/ruby https://bugs.ruby-lang.org/ Writing documentation for Ruby is the easiest way to start in my opinion.
Another thing, the example at hand violates Law of Demeter. If you have a chain of methods, that all might fail randomly, you need to refactor, not rescue. Which is usually the case whenever you start thinking "rescue would save me so much time here".
&gt;Language designers want to design the perfect language. They want to be able to say, "My language is perfect. It can do everything." But it's just plain impossible to design a perfect language, because there are two ways to look at a language. One way is by looking at what can be done with that language. The other is by looking at how we feel using that language—how we feel while programming. &gt;Because of the Turing completeness theory, everything one Turing-complete language can do can theoretically be done by another Turing-complete language, but at a different cost. You can do everything in assembler, but no one wants to program in assembler anymore. From the viewpoint of what you can do, therefore, languages do differ—but the differences are limited. For example, Python and Ruby provide almost the same power to the programmer. &gt;Instead of emphasizing the what, I want to emphasize the how part: how we feel while programming. That's Ruby's main difference from other language designs. I emphasize the feeling, in particular, how I feel using Ruby. I didn't work hard to make Ruby perfect for everyone, because you feel differently from me. No language can be perfect for everyone. I tried to make Ruby perfect for me, but maybe it's not perfect for you. The perfect language for Guido van Rossum is probably Python. Yukihiro Matsumoto
Thanks, please do!
Just man up about it.
I mean in the context of his skills, the skills are good for web programming, but not for such a task. to find plagiats, first you cluster documents, to find possible candidates, in which you could find plagiats, then one must identify possible passages of text, which could be a candidate for plagiarism, this is done, for example, with techniques from discourse theory, next step is comparing the semantic, the meaning of the the text to decide if it is an plagiat or not … that is only a starting point to simple read an article/paper about is not a great help, cause, at most of them you couldn't find an algorithm which you could take to implement, on other hand are most papers only for trash can. (that is really my personal thoughts, with the background of a similar task as base for my PhD thesis in a similar field of NLP) 
yeah, i am curious on this too and would appreciate seeing some stats if anyone has them. only other thing i'd say to op is that titling it as "avoid rails" is a bit of a cheap grab, given this isn't just a rails issue. ;)
one other issue i would foresee is relying too heaving on a particular data-store. if you want to change that data-store later, or use multiple different data-stores, you will still need to implement the costly abstraction layers rightfully critiqued in this article.
Where do you live?
Maker Square is pretty awesome from what i hear. It's in Austin and SF. It's around 10 weeks for around $14k. Hear a lot of good things from them and from the people hiring the grads. 
I don't see `suppress` supported in the [`Kernel`](http://www.ruby-doc.org/core-2.1.2/Kernel.html). Where is it coming from?
Ah, sorry, that was perhaps a little unclear. [`suppress`](http://api.rubyonrails.org/classes/Kernel.html#method-i-suppress) is a Kernel method, but it's added by ActiveSupport. I tweaked the post to reflect that and linked up the method to its doc.
I'd stay away from the iron yard, at least the one in Houston. I went to an html/css/js workshop that they were sponsoring and teaching. The group I was in was incredibly disorganized and the main teacher was just awful. I actually walked out about 3/4 of the way through. Some of the other teachers seemed friendly and ready to help, but just the fact that our guy worked there would make me worry. I think their hiring practices are more focused on how good they can code instead of how good they are at teaching it.
Thanks for sharing. I will check this out.
Now that I've had a chance to look for more than half a second (still only a couple)... The first thing that caught my eye (after the mention above) is the gem_available? function. Jesse017 is right about sudo but more importantly, you're locking yourself into platforms that use sudo. You're probably better off just warning the user and exiting. You can do this cleanly by catch the LoadError exception. require_or_fail(lib) begin require lib rescue LoadError puts "Required gem missing: #{lib}" exit false end end Then you could "require_or_fail 'gem'" and get what you want without being OS locked. EDIT: code is untested... try at your own peril... this is just an example... etc etc etc
I did the SF app academy and it was amazing, most graduates are hired at &gt;90k within 3 months of finishing the program. They do ruby/sql/rails/javascript/backbone (it might be angular now...), daily pair programming projects, you build active record/rails from scratch as well as a JS mvc framework with jQuery and a 2 week solo final project.
Anecdotal evidence regarding sudo comment: As an rvm user, I don't sudo anything. I let yum manager OS level packages and make gemsets for work I'm doing.
&gt; File.open("clean-slate.txt", "r") {|file| puts file.read } and &gt; f = File.open("clean-slate.txt", "r") puts f.read Those are absolutely not the same thing. In the first example, the file handle will automatically be closed once the block is completed. In the second example, it's up to you to explicitly close the file.
Someone else can probably explain this better than I can but as far as I can tell, it's more of an idiomatic thing. It's more readable in a weird sort of way once you get used to it. When you open a file, you use the file's contents to read from it. Vs. storing an open file in a imaginary variable which is then read from. For the each thing: An each iterator goes through each element in a list and passes that element to the code held within. It's just a different way of thinking about it, and I got used to it just by repeatedly using it. It was easier for me because it was my first language and so it was what I was first exposed to. Either way, works if you have a preference. 
I really don't mean to be rude about this but I find it odd that a block is "weird." `for` loops can introduce a variety of nasty little bugs that can be hard to track down. An answerer on Stack Overflow gave a great example of it which you can read about [here](http://stackoverflow.com/a/10397030/2250543). Blocks are very simple and incredibly easy to reason about. You should prefer using `each` with a block to `for` loops.
I work at MakerSquare. Our program is 12 weeks. The price is currently $13,880 for the next cohort and is likely to go up a little by the end of the year. We have a fantastic program here. If you've got any questions shoot me an email. My job is to help incoming student get prepared for our curriculum (we have a lot of prework).
I work at MakerSquare in Austin, TX (makersquare.com). We're a 12 week program that goes over software design patterns in the context of web development. PM me if you'd like to hear more about our curriculum.
Howdy, Welcome to the ruby community! When I came to Ruby it was from c and Java, and I remember having the exact same questions. &gt;1, Why is everyone always using iterators like .each and then using the weird block thing wiht it? To me the simple for loop makes so much more sense. How did you guys get used to this? Iterators make life a lot easier, at least for two reasons. One they're expressive, it's very clear you're operating on *each* element in a list. Second, they are an abstraction why worry about getting an edge case in a for loop when you could iterate? &gt;2, Are blocks mainly there to have a shorthand sort of way of not storing the return value of a function in a variable and processing said variable after, but doing the processing code straight away? What is the real reason for this I don't see how this will make my life easier. Blocks are really, really cool, it's a syntactically easy way to use a closure in ruby. The other two ways to use a closure are a proc or a lambda depending on your needs. [This guide](http://www.reactive.io/tips/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/) shows some of the differences between each, [this article](http://www.skorks.com/2010/05/closures-a-simple-explanation-using-ruby/) does a pretty good job explaining why you would use them. For me it was a very different way of thinking, but it ended up really expanding how i thought of programming.
Cool, wasn't aware of that, thanks. Always guilty of forgetting to close files, so good to know.
I will play around a bit more with ruby iteration, it's just getting used to it I guess. Thanks for the great example.
Thanks very much for the articles, I will pore over them tomorrow and keep on trying to absorb this. Nice to hear someone was in the same shoes once.
&gt; Always guilty of forgetting to close files, so good to know. Yep, and this the exact reason blocks are so prevelant and ruby and so powerful. They basically allow you to define your own control structures with a nicer syntax. For example, if the if statement wasn't built in, we could define it ourselves with blocks like this: true.define_singleton_method(:if_true) {|&amp;block| block.call; self} true.define_singleton_method(:if_false) {|&amp;block| self} false.define_singleton_method(:if_false) {|&amp;block| block.call; self} false.define_singleton_method(:if_true) {|&amp;block| self} and use it like (1 &lt; 2).if_true {puts "hi"}.if_false {puts "bye"} "hi" =&gt; true or (1 &gt; 2).if_true {puts "hi"}.if_false {puts "bye"} "bye" =&gt; false
The first File open is in an object functional style, while the second is imperative. Map, each, and reduce (fold) are sort of the building blocks of functional programming when dealing with lists. 
I'd recommend App Academy as well. I was in fxthea's cohort and most of us got hired within a few months of graduation. His post is pretty spot on about the experience. Even after getting a job, I still look at new things in their curriculum because it just explains things much better than most places on the web.
Wat? Can you edit this wall of text?
I recommend [Code Fellows](http://codefellows.org) in Seattle. I learned an unbelievable amount in 8 weeks. There's an expected level of previous coding experience. It also has a job guarantee. Beware though, it's super intense. I would say I averaged around 80-100 hours a week coding or attending tech meetups, and related stuff. 
Just a few notes based on the following discussion and other things I've come across: https://stackoverflow.com/questions/5545068/what-are-all-the-common-ways-to-read-a-file-in-ruby If you want to read a small file, you can just use: contents = File.read('./myfile.txt') `File.read` opens and closes the file so you don't have to do worry about it. NOTE: Do not use `File.read` if the file is (or might one day become) very large, because it hogs resources to slurp an entire file in one go: use the block approach to read it line by line instead.
I will have a go at your first question. While a for loop and an each block essentially do the same thing, the former is very limited. If you use the latter it opens you up to all sorts of pssibilities, thanks to Enumerable. Given these two samples that show the titles from a list: for book in books book.title end books.each { |book| book.title } Say I want to return an array instead. With the first, I'd have to create a blank array and assign it to a variable, then append each item in the for loop, and return the array at the end. If I'd used each before, now I can just change it to: books.collect { |book| book.title } Or if I am worried about duplicates: books.uniq { |book| book.title } There's so much more, try reading up on http://www.ruby-doc.org/core-2.1.1/Enumerable.html and http://www.ruby-doc.org/core-2.1.1/Hash.html
Check out http://www.gotealeaf.com/
It depends. What are you trying to accomplish? If you're writing a gem that will be used by systems with varying storage, then I'd suggest writing your core logic in plain Ruby objects (maybe with Virtus: https://github.com/solnic/virtus), and then writing separate classes to deal with each storage mechanism. This is sometimes referred to as the Data Mapper Pattern. If you're writing a Rails app for yourself or a business, don't do this. Just pick one and go down that path. You'll spend way more time trying to support and troubleshoot this than it's worth. Projects rarely switch databases. I'd suggest Postgres for data safety and long-term adoption.
I'm creating a gem ( which I use frequently in my projects ) but I need it to support both active record and mongoid
 class User &lt; (Faalis::ORM.active_record? ? ActiveRecord::Base : Object) end
Question for native english speaker: Can you write stomache instead of stomach or does it have a entirely different meaning?
Syntactically this is nice but is still limiting. Because mongoid methods are inspired by ActiveRecord I think an abstract class that accepts a driver would be more future proof..
`Stomach` is the only valid English spelling.
Thats what I tought, thanks.
Wicked, yeah I think I'm starting to see your point. Will have a read around see what I can learn, cheers for the resources. Btw, do you know how expensive the .uniq method is? I have just made a Python script at work which is meant to remove duplicates from BIG txt files returned from a data warehouse. I ended up sorting the contents line by line and removing duplicates like that, couldn't come up with anything faster.
How does auto increment handle race conditions for DB clusters?
That's a good question. Perhaps someone could give more comprehensive answer, but from what I understand, it depends entirely on how your database cluster is set up, and what database engine you are using. For example, you could have master database that all of the writes go to, and then the data is propagated to a cluster of read-only slaves. On the other hand, if you have some sort of cluster of read-write databases with no master database, then I would imagine that things would get a lot trickier. Full disclosure: I'm not a database expert, so this is all just my rough high level understanding.
ARGV is an array containing the command line arguments for the ruby script when run. STDIN is probably an IO stream of terminal input, but I've always seen it accessed trough $stdin. 
Thank you fellow Redditors for: * reminding me of the podcast Ruby Rogues * pointing out the wordplay of rogue vs. rouge Especially the word, play. Red rouge rojo ... czerwony красный ;) Edit: regardless of language I still prefer '-' for unordered list, seemingly...
`ARGV` is the array of arguments the user passed when invoking the program. So if your program is called *fountain*, and the user invokes it with `fountain -large`, ARGV will contain the string `"-large"`. There are all sorts of situations where this might be useful. For example, what if you wrote a Ruby program that compressed a video file in a certain way? You'd want the user to tell you which video file they wanted. So they would say `fountain my_home_movie.mp4`, and you would use `ARGV[0]` to get the name of the file your program should be working with. As for STDIN, it helps to understand what a stream is. Streams are these things Ruby (and most other languages) have that are like magic things that provide a new piece of data whenever one is asked for, and/or consume a piece of data when one is sent to it. There are typically three: STDIN ('standard input'), STDOUT ('standard output'), and STDERR ('standard error'), but you can make more. STDIN, by default, is keyboard input to the terminal that opened the program. When you use a method like `gets`, it's actually saying *get string from STDIN stream* -- which means it waits for you to type something into your terminal, then uses that line. Try running this program: print "What is your name?" username = gets print "Hello, " + username Likewise, STDOUT is the terminal by default as well, and when you use a method like `puts`, it is saying *send string to the STDOUT stream* -- which means it displays that data in the terminal window. There are other input streams besides STDIN, though. If you open a text file with `d = File.open("my_diary.txt","r")`, then that will be a stream that reads input from the text file rather than the console. You'll be able to use all the same methods like `gets` to pull an additional line from it, exactly as you would to pull an additional line from the keyboard at the terminal. And if you open a file to write to, it is an output stream, and you can use `puts` or `print` to send data to it, as in: diary = File.new("mysecretdiary.txt","w") diary.puts "She just giggles and I don’t have the nerve to ask why things like that are funny to her." STDOUT is where error messages go. Although these are all the terminal *by default*, you can specify them to be anything. For example, STDIN might be a numeric keypad, STDOUT might be a text-to-voice point, and STDERR might be a log file. Your user would interact only using the keypad, and the program would send whatever output it had to a piece of text-to-voice hardware. The important thing is that it's a place Ruby knows it can go to get new input of some kind.
Can you give me an example ? i didn't understand what you exactly mean
Helps to think about what they are under the hood. A block is just an anonymous function you are passing to a method/function call as an argument. If that method includes the line `yield`, then whatever was in the block will be pretty much literally 'dropped in' at that point, and executed as if it were part of the method all along. So if I wrote def introduce print "Welcome! " yield end And then invoked `introduce {print "Sup?"}`, the output would be `"Welcome! Sup?"`. So imagine that the `each` method is just a shorthand for something like for (i = 0; i &lt; self.length; i++) { yield } It's the same thing, basically. Why have it? For one thing, it's closer to English, which makes it easier to read other people's code, maintain things, etc, and overall more pleasant to write. But it also gives you a consistent and accessible way to let other people use methods and objects included by libraries you provide, and to explicitly specify which variables/properties the block is allowed to access. If you've used PHP, you might know that to work with a database, first you have to produce it using a query function, then you have to write a loop that fetches an array from that freshly-produced record and increments an internal pointer tracking the current row in that record. In Ruby, the database query commands usually (always?) accept a block which they will perform on every row in the result you produce. It will also be the same method whether you'd use a `for i=0;i&lt;length;i++`, `for x in y`, or `while item = fetch_from_something` loop. Compare trying to find the track number of a song in PHP: while ($song_name = current($songs)) { if ($song_name == "New Dress") { echo key($songs); } next($songs); } to Ruby songs.each do |track_number,song_name| print track_number if song_name == "New Dress" end You don't need to know the actual internal structure of the object you're working with, whether it's a hash, array, database record, or some new data structure you or someone else has invented. It's standard practice to include a method called `each` which iterates over it in the most efficient way, offering up the variables you'd care about when iterating.
Well good news - ARGV and STDIN are conventions used in many programming languages, so by getting your head around it in Ruby, you're well prepared for trying other languages out too! ARGV is an object made available to any Ruby program you run. It is an Array (i.e. a 'list') that contains any options (known as 'arguments') that were given to the script when it was originally started. /u/Godd2 gives you a nice little Ruby script that demonstrates how this works. The name (as far as I'm aware) comes from a convention in the C programming language. In C you get supplied with a similar method for finding out what arguments were specified when running your program - but in C you have to also specify the size of a list separately from the list itself (or work it out by other means) so two things are provided to you: `argc` - the *argument count* (i.e. how many arguments there are), and `argv` - the *argument vector* (a *vector* is just another type of list, like an *Array* in Ruby). STDIN is another object supplied to your program. It is shorthand for 'standard input' and the purpose of this object is to give you access to any data input supplied to your program. In most cases, the default source for STDIN is your keyboard, but depending on how you run your program you may end up supplying input from somewhere else, e.g. from the output of another program, or from a file. Unsurprisingly, there is also another object called STDOUT - the 'standard output'. This is the default destination for any output from your program (i.e. when you run `puts "Hello, world!"`, it's the place that `Hello, World!` gets printed out to. If you run Ruby in a command prompt or terminal, the normal location for STDOUT is the prompt/terminal itself. Depending on the situation though, your output might be to a web browser, written straight into a file, sent to another window or you may even feed your output directly into the input for another script. As well as STDOUT, there is also STDERR (*standard error*). This is the location for any error messages you want to output. The default place for this is the same place as STDOUT, but you can change this location outside of your ruby script so that normal output gets printed to the screen and error messages get saved into a log file, for example.
I liked it. There are so few tuts really aimed at beginners that break this stuff down as explicitly. That said as someone with a little more than complete beginner status it was almost frustrating at times. I guess what I am saying is that you should consider calling these beginner tutorials and either recasting or editing for different tracks. All in all awesome job very specific and well explained. 
I don't really have any ideas for any projects off the top of my head, but if you head over to /r/progether, we're there to work on projects together. You can try and get some guys together on a project or see if you can find someone with a ruby project that needs some help.
You're welcome! Always happy to let people know about us and to get some more activity going. Of the few projects that we've done, there haven't been any ruby projects so it'd be fun to see one come up. Just post/ask if you need anything.
It would be trivial, at the beginning, to move the `#full?` check out of the conditionals. There are other ways to refactor this code. I get that this is a basic exercise in teaching subclassing. The problem is that, while in your example it's easy to see that `Animal` is an obvious parent class to `Herbivore`, `Omnivore`, etc., in the real world, it's not so simple. I've seen awful conditional messes. They weren't caused by the fact that the authors didn't understand polymorphism. It's that they didn't see the right abstractions. Using an example like this one, where the abstraction is so obvious, doesn't teach anyone how to avert conditional disaster, unfortunately. The key is practice, practice, practice.
I'd suggest setting up a lightweight web service using Sinatra in Ruby to handle the GET request. It would probably use datamapper to communicate with mongodb. Small correction: the Ruby app would not POST back to the Android app - it would send back an HTTP response that the Android app is waiting for. 
pretty sure it internally uses a hash, so it's very performative. There's also the [Set](http://www.ruby-doc.org/stdlib-2.1.2/libdoc/set/rdoc/Set.html) class which also uses an internal hash for uniqueness.
i'm in the same boat as you, so let me know if you find anything.
http://stackoverflow.com/questions/746207/ruby-design-pattern-how-to-make-an-extensible-factory-class
The best advice I've ever received for this is to find an open source ruby project that you use personally, and start working your way through the bug tracker.
I have no idea if there's a DSL or not, but I would love to hear what you're planning to do with it.
Help Jekyll implement a translation/i18n feature.
I would personally use it just to make my vimrc more readable. VimScript is a terrible language and VIM would be better off if it used LUA or really any other scripting language.
You might want to note that the concepts of stdin (*standard input*) and stdout (*standard output*) comes from the Unix family of operating systems (Mac OS, Linux, FreeBSD, AIX, Solaris, etc) where files are defined as anything the OS lets a program take bytes from or send bytes to. This particular pair of files normally correspond to the input and output of a terminal (including terminal emulation software) but at the whim of the user they can temporally be changed to accessing on-disk files or even other programs. For instance the command grep -n rabbit Will repeat every line you type containing "rabbit" with its line number grep -n rabbit &lt; file.txt Does exactly the same thing except that the operating system gives it the contents of file.txt rather than manually entered data text-generating-program | grep -n rabbit This time the operating system redirects the output of *text-generating-program* to *grep* rather than the terminal.
vim actually has native support for Ruby. It's not always enabled so check your vim first. Also it's somewhat limited compared to VimL. http://vimdoc.sourceforge.net/htmldoc/if_ruby.html
No, it's not and I'm a little shocked that no one has said so. In regards to the class declaration, if you need to express variability such as this via inheritance the way to do it is to encapsulate what varies* e.g: class User &lt; MyClassImplementsVariation end class MyClassImplementsVariation # perform initialization and vary implementation # present a common interface using this base class end However, I suspect that this kind of hocus-pocus is better expressed via module rather than class inheritance in Ruby. TBH I don't know enough about what you're trying to do to give decent advice beyond the above but you might want to look at ActiveModel since I *believe* (and may be wrong) that it underlies both AR and Mongoid. Also /u/JustinCampbell has made some good suggestions. (* Yes, I know but I don't want to confuse the issue by mentioning the obvious design patterns) ** Edit: Changed class name
The factory pattern can quickly grow unmaintainable in this scenario since it requires one concrete class per "base" class and persistence layer e.g. class User_AR, User_MGO ~ fine if you have one class and two persistence layers but what if there are 10 classes and three persistence layers? 
You might have to wait some time for them to implement it but https://github.com/neovim/neovim will use lua in the future.
Trying to satisfy 2 ORMs in a single class using metaprogramming seems like more trouble than it's worth. Instead, why not try implementing the core Faalis::User functionality twice, in two separate class definitions: module Faalis if Faalis::ORM.active_record? class User &lt; ActiveRecord::Base #... end elsif Faalis::ORM.mongoid? class User include Mongoid::Document field :email, :type String #... end end end Or something like this. As long as User is small, it's not worth it to DRY it up because you're only supporting two ORMs. Code that appears twice is usually fine -- it's only when you repeat yourself three times that it starts to smell. If you have so much code in User that even repeating it twice would smell, then you could just break it out into modules, like they do in ActiveRecord::Base. Metaprogramming is really used more as a last resort.
Edit : I'm not sure how I'd deal with ops requirements using an abstract factory - could you flesh that out a little for me?
Got as far as the first example and closed the browser with 'WTF is this?' NSArray* numbers = @[ @(42), @(14), @(73)]; [numbers enumerateObjectsUsingBlock:^(id number, NSUInteger idx, BOOL *stop) { NSLog(@"%d -&gt; %@", idx, number); }]; is the Objective-C way of doing it. That's exactly more wordy than the ruby way by the static typing of the array and boxing of the integer. 
Actually I'm not sure now that it technically does since the user class may not even be able to be substituted for itself! 
Take a look at [code triage]( http://www.codetriage.com). Projects looking for help are posted there and you can sign up for notification emails on new issues raised against them.
I agree with this. A really good way and public statement of how much you contribute.
Approximately what level of coding experience is required? 
What's the difference between developer and design?
This is sweet but I'm not sure where this would be used. I take it its not a bash replacement, and its not really a task runner... so what do you do with it? 
Your way seems appropriate for this case but, as materialdesigner mentioned, there's really no need to inherit from the same base class. But I think you should keep the base class since it serves as documentation. 
Unlike play, it can rerun Pry commands. With some hackery, it can do a bit more. Note that special variables like _ex_ have some odd behavior and throw a fit when you try and call them straight. That was a tinge of a headache to get around. # ~/.pryrc require 'uri' require 'launchy' def search_ex_url(ex) "http://www.google.com/search?q=#{URI.escape ex.message}" end Pry::Commands.block_command 'search_ex', 'Search the last exception' do _pry_.input = StringIO.new 'Launchy.open(search_ex_url(_ex_))' end Pry::Commands.block_command 'search_ex_lynx', 'Search the last exception using Lynx' do _pry_.input = StringIO.new 'system "lynx #{search_ex_url(_ex_)}"' end The trick here is that Pry will read from its input buffer, as long as the thing implements a readline method. For whatever reason, Pry doesn't behave if you reference a special local on multiple lines in a StringIO treated like Input, so I hacked it. This effectively passes the exception to a method, returns a not-special-anymore value, and all is right with the world. I still need to wrap my head around that one better... Currently working on another one that'll give you a +/- 5 line context for a git blame on the last exception so you know who you need to grab to get some answers on it. More than that, I have some things to play with go get more ideas of how to use it. Of the ideas I have off the top of my head: Cycle to watch the state of a variable: record next variable stop -n 'cycle_variable' I just know Macros are dang handy everywhere else, and I'm likely to quickly find more uses for it as I work knowing I have the option.
[Comprehensive list](https://github.com/railsjedi/opensourcerails/issues)
Inheritance provides no benefit here. A Strategy is the ability to swap between different implementations at runtime. Better to inject either GmailClient.new or HotmailClient.new into the MailClient initializer set it as @mailer (attr_accessor) Then have matching methods signatures that proxy to the mailer Then you could switch the mailer instance at runtime mail_client_instance.mailer = HotmailClient.new Have a look at https://github.com/nslocum/design-patterns-in-ruby/tree/master/strategy there are also some cool examples using Procs which are even more rubylike. 
There'a [gem](https://github.com/ianwhite/orm_adapter) for that.
Doone!
It's wonderful to see some innovative pry extensions.
After googling pry, I see its an irb replacement on roids. Very cool. Thanks for your reply
most of what other sites report end up here anyway. here are some of their twitter feeds: https://twitter.com/ruby_news https://twitter.com/RubyInside https://twitter.com/rubyflow
Have you looked at [refinements](http://www.ruby-doc.org/core-2.1.1/doc/syntax/refinements_rdoc.html), which are new in Ruby 2.1?
This doesn't use any meta-programming techniques but seems to get the job done. module Terms def say_hi ["Hi"] + say_hi_helper end def say_hi_helper [] end end class Foo end Foo.extend(Terms) class Fizz &lt; Foo def self.say_hi_helper %w(there, fizz) end end class Buzz &lt; Foo def self.say_hi_helper %w(, buzz buzz) end end class Boop &lt; Foo end p Fizz.say_hi p Buzz.say_hi p Boop.say_hi 
Not since 2.1 came out, which is to say I forgot about them. I'll look now.
Your title makes it seem you're talking about [these](https://wiki.python.org/moin/Generators) (the Ruby version is Fibers), when in fact you're talking about something specific to Thor. Have you tried using the code exactly as its given in the markdown file? You just make a new file and put the generator code in there. Sorry, I realize my comment isn't particularly helpful.
Yeah, that does the trick. Thanks a lot.
So, I looked at refinements. The problem that I saw was that it looked like I need to put the `using` method in each of my child classes. And my goal was to make my extension as seamless as possible.
Nice article! &gt; Meet Option pattern. Haskell folks call it Maybe monad where as Ruby folks seem to call it Null pattern. The [Null object pattern](http://en.wikipedia.org/wiki/Null_Object_pattern) is different from an option type. With an option, even the positive (i.e. "some") case wraps the object. This is necessary in a statically-typed language that lacks native union types because you need to have a single static type for the optional value. (It also lets you nest options, though I think that's relatively rarely used in practice.) With the null object pattern, when the object is present, it's returned unwrapped. When it's absent, only then is a special "null" object returned.
Some examples of blogs I follow: http://pivotallabs.com/community/ http://blog.codeclimate.com/ http://blog.carbonfive.com/ I also of course listen to the [Ruby Rogues](http://rubyrogues.com/) podcast weekly. --- As a test I added all my frequently visited blogs and sites to a collection on my new beta-ish side project: http://www.dodofeed.com/collections/1-ruby-and-rails/month Yay it sort of works? Good day today
I see. I've had a couple of 'false starts' with programming in the past, but it's only until recently that I've resolved myself to get over the hump of really learning a language for the first time. I'm currently working on Ruby and intend to go into rails soon (about halfway through The Well-Grounded Rubyist). It's going pretty well, I feel like I'm not learning much but then I surprise myself with being able to figure out some problem or other. I was told that coding boot camps weren't worth the time but the more I read about them, the more I like it. Self-teaching at this level is very difficult and ambling. I think I'm going to apply to app academy in SF but I'm actually up in Seattle right now, so code fellows would be another option. I just worry that my lack of work on a professional or casual project will be an obstacle at this point. 
About how much did you know of coding going into it? I want to apply but I worry that I'm not qualified enough.
no problem. We're pretty small, just starting out. Just passed the 1000 subscriber mark though which is awesome!
Check out the [speaker list](http://www.steelcityruby.org/#speakers) or [full schedule](http://www.steelcityruby.org/schedule) for what's in store.
What's the reason behind #map breaking Ruby conventions? It should return array, not a wrapper.
If `#map` returned an array, you would escape the Maybe monad. Then you wouldn't be able to use `#or_else` or the shorthand methods.
That's pretty standard behavior for monads in functional programming circles. If you're ever done any Scala you might see class M[A] { def map[B](f: A =&gt; B): M[B] } which is to say you define a function that operates on the value *inside* the monad type and wraps it up in a new monad type (which can be the same type as before). This lets you compose functions in really powerful ways: Maybe(2).map { |x| x * 2 } // Maybe(4) I hope that makes sense - it doesn't mesh so well with Ruby style as you noted, but that's the reason for it.
Except he hasn't implement `bind` here (`&gt;&gt;=`) so he can't 'compose' anything :) This implementation is really just a functor, not a monad.
Thanks for answer, that's the exact reason. You can think map as "apply to all", so that: [x, y, z].map(f) =&gt; [f(x), f(y), f(z)] That's analogous how Maybe works: Maybe(x).map(f) =&gt; Maybe(f(x)) (The examples are not valid ruby, I know :) )
To my understanding (correct me if I'm wrong), the map function Maybe implements really is a map, not a flat map. If you have a function that takes A and returns B, f(A) -&gt; B when you map it over an array you get List[A].map(f) -&gt; List[B] And that's how Maybe also works Maybe(A).map(f) -&gt; Maybe(B) Maybe also implements flat_map, so if you have g(A) -&gt; Maybe(B), with map you would get Maybe(A).map(g) -&gt; Maybe(Maybe(B)) ...but with flat_map you get Maybe(A).flat_map(g) -&gt; Maybe(B) Anyway, thanks for a comment and please do comment if you think this isn't right. I may have a lack of knowledge here.
I'm not completely sure what you mean. There are timed tests during the course (every 2 weeks I think). It basically covers what you learned in the two weeks. The admission test is timed as well, if I remember correctly. You're given material to study before you do the test. You can do it whenever you feel you're comfortable. It's just simple Ruby tasks. The challenges during the day (not timed) are based on readings you're supposed to do the day before, but the material is still usable during the exercises. 
Shouldn't this over-head be handled via BDD or TDD
Ok, thanks for explanation!
I'm talking about the application tests, that's what I'm concerned about. I'm cool with anything once I'm in the course, I just don't want to be blind-sided by something I'm totally unprepared for before I've had a chance to study. It says there are two code challenges in the application process: one that you do (I'm assuming this is the one that you can do at your own pace) and another in-person.
Yes it is. Thanks for the reminder, I'm quite lame and needs the beating on this specific aspect.
Huh? 
Meh, I think the gains of this refactoring isn't worth the cost of having to deal with the uncommon syntax of `flow(data) {}`. I think I'd be happy with the first example. Actually, I would do instead: def process(data, parameter) keyval = data.map do |point| [compute_key(point), compute_value(point, parameter)] end memo = Hash[keyval] end If the chains start getting really complex, I would consider creating a class to instantiate for each data to handle data manipulation: def process(data, parameter) datapoints = data.map { |p| DataPoint.new(p, parameter) } memo = Hash[datapoints.map(&amp;:compute_keyval)] end 
Map does not necessarily need to return an array, it needs to return an *enumerable*
The key concept here that I'm surprised nobody has named yet is "duck typing".
Yeah, so there's two challenges. All the study information is given to you prior. It's fairly easy, just variables, conditional and such. The second test is over Skype, and they'll watch you code (you have to explain what you're coding). Second test is easier and just serves the purpose of making sure you didn't copy the code from somewhere. You should be fine if you can do the practise problems they give you prior to the test. 
You're comparing apples and toothpaste here... totally different things for totally different purposes. 
They have prep material that they give you to work on, including a sample day of curriculum to work through. I wrote my first Hello World program while I was preparing for the AA entrance exams. Though I was unemployed and living at home at the time so I had endless time and motivation to study. Acceptance usually involves doing 1-2 online coding challenge where they give you 3 problems and you paste in your solutions, as well as 1-2 skype interviews where they open a text edit in a browser and have you work through a problem. Doesn't hurt to apply, though definitely study hard. Definitely focus on iteration/looping. If you can comfortably work with nested loops (stock picker is a good problem to practice) you should be good. Caesar cipher is good to get the hang of string manipulation... The chris pine learn to program ruby book is also an excellent resource for preparing. I'd send in an application and see if they invite you to do the exams, while working through the codecademy ruby curriculum to familiarize yourself with the language. The course is 80 hours a week for 9 weeks and after graduating they expect you to apply to &gt;200 jobs in 3 weeks. So it's a ton of work, and your preparation/study should match that. But on the other hand the payoff is huge both in terms of job/salary and the skills you gain.
I'm working through The Well-Grounded Rubyist right now. Just got to Part 2 where they begin to go into the built-in classes and methods in more detail. This is after I've worked through the Lyndia.com ruby tutorial videos too, so I'm starting to feel more solid on the fundamentals of the language and ruby's kind of pure OO (inheritance and mixins cascading down into the classes I'm instancing). As of now I have been spending all my free time working on this and have basically allotted the next two years of my life to doing nothing but focusing on work as much as I can without breaking myself. This path really beats the plan that I have of going back to school and finishing my Bachelor's in something like comp sci or software engineering while teaching myself specific languages on the side, which is a much longer path before I can get a job and start accumulating experience (not to mention more tuition). I'm 31 and feel like I need to get into a job that starts generating experience asap.
What exactly does that mean? I've been facing a require issue as well and it always errors on Gem_original_path off custom_require.rb 
I'm going to (respectfully) say that I am inherently wary of this pattern. It seems (based on the examples given) to mask poor code design. Take your first example: Before: - if @current_user &amp;&amp; @current_user.profile &amp;&amp; @current_user.profile.real_name.present? = @current_user.profile.real_name - else = "Real name unknown" end Proposed (in your article): = Maybe(@current_user) .map { |user| user.profile } .map { |profile| profile.real_name } .or_else { "Real name unknown" } Proposed (by me): = RealName.new(@currrent_user).display_name class RealName attr_accessor :user def initialize(user) @user = user end def profile user.present? ? user.profile : nil end def display_name if profile.present? &amp;&amp; profile.real_name.present? profile.real_name else "Real name unknown" end end end And honestly, even that last bit is ugly as hell because apparently your dummy user doesn't understand the Law of Demeter. Just my two cents, and obviously, I'd love to hear the opinions of folks who feel strongly opposed to me!
Why not just use the fetch command, with a default fall-back value?
Because a) that's baked-in, so b) follows established Ruby conventions so c) doesn't let someone who really wishes he were writing Scala to write Ruby *as* Scala instead. Different languages exist for (often quite good) reasons. 
In my eyes, imitating other language to word is not a good driving idea. Maybe needs to either drop the pretense that it "implements all the methods Enumerable module has", or use a method name, that doesn't break Enumerable convention. If a person doesn't know about this particular quirk, then simple `#map#map#inject` chain will confuse them, effectively making code an esoteric (to a point) mess. `#fmap`, mentioned by others, would fix the problem of breaking expectations, clearly indicating that something different is going on. Looking at library code, the way Enumerable calls are being wrapped will break behavior of e.g. `#zip`, returning Maybe instead of a definite and expected result. This pattern is awesome for cases where you can't enforce Law of Demeter, like external data structures traversal, but implementation that breaks expectations is a no go.
I could not disagree more. If the logic in determining a "real name" is so complex, it should live in its own class. If you're going to pepper that chain of 4 methods throughout your code, how will you deal with the inevitability of wanting to change the fallback from "Real name unknown" to "Name not provided", or handle the case where you want to append a prefix if the user is a Dr.? YAGNI isn't measured by lines of code. In this case, it's a given that you need the concept of a "Real name", and that the logic for it is non-trivial. That sounds like a separate concern to me. I've rarely been bitten by having too many classes, but chains of methods have often lead to maintainability problems for me.
I disagree that it is "so complex" at the moment. If the rules got more complicated, then you could move it into another class. A the moment though, it is only one line of code. I generally go through three stages when writing a bit of code: 1\. Just write it inline 2\. If the bit of code needs to be used again, put it into a method. Eg: def real_name Maybe(@current_user).profile.real_name.or_else { "Real name unknown"} end 3\. If the code for the `real_name` method starts getting pretty complex or needed in different classes, move it to a new class. It would approach your solution in this case. The fact is, most of the time you don't need to go from 1 to 2, and again, most of the time you don't need to go from 2 to 3. By only making the transition when necessary, you can save on a lot of unnecessary abstraction. This saves a lot of time writing code, and makes the code easier to understand. The only downside is the small amount of effort from migrating from 1 to 2 and from 2 to 3. Of course there are exceptions - if you immediately know what you are doing is complex and/or may need multiple implementations, then going to the more complex solution is appropriate. I would argue though in this case you can't be sure of that. It may be this bit of code is only used in showing a "Welcome &lt;user&gt;" message when you log in, and not used anywhere else. In that case it wouldn't be worth the extra effort in using a 17 line solution compared to a one line solution. 
Fetch only works on Hash's? Not objects? 
I think we do agree in a way, it is just I only go from step 1 to step 2 when it is clear that it is necessary (ie I need to use that bit of code more than once), and from 2 to 3 when necessary (when the logic becomes complicated enough). So there is no code repetition in either of our solutions. Our difference of opinion lays in how long we delay in going for the more abstract solution. The reason I delay going for more general solutions is by the time I truly need them, I have more information about what is required. For example, by the time I need to start getting full names working for different localities (for many local websites this is never necessary), I would have a better idea of the use cases for the system, and design a better solution based on that. For example, the solution in the article you mentioned still has the concept of a given name and surname. If I had to [localize for Portuguese names](http://en.wikipedia.org/wiki/Portuguese_name), I may need to take into account the two family names they will have, and which to use depending on context. However, maybe the usages of the full name is only used by the gui and not hugely important to be 100% accurate. Or another solution which may be necessary is to store the full name, short name, scientific name in the database, defaulting to an approximation, or using a database migration to fill in for existing users. Also, different formats may be needed for a financial website which may need names in certain formats for forms based on the laws for certain governments. Multiple formats may be required if the website deals with multiple jurisdictions. Chinese people often have an "English name" as well, how do we deal with this? Maybe use the full english name when sending a message to an English speaking person, or use their Chinese name when sending to a Chinese person. This means the target locale is needed, not just the person locality. Alternatively, the website may never reach the point where this is necessary. Therefore, the original inline or in a method solution would be fine, and I wouldn't have wasted time working on an unnecessary abstraction. Basically, by attempting to guess the right abstraction away to save the small amount of time required to go from 1 to 2 and 2 to 3, I can often end up with an abstraction which isn't right anyway, which would take longer to fix than if I just waited until the abstraction was really necessary. I feel that waiting until it is necessary reduces over engineering, which makes the code more maintainable, not less. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Portuguese name**](https://en.wikipedia.org/wiki/Portuguese%20name): [](#sfw) --- &gt; &gt;A typical __Portuguese name__ is composed of one or two [given names](https://en.wikipedia.org/wiki/Given_name), and two [family names](https://en.wikipedia.org/wiki/Surname). The first surname is usually the mother's family surname and the second surname is the father's family surname; however, the order of the surnames can be reversed and it is common to find people with three or four surnames. &gt;For practicality, usually only the last surname (excluding prepositions) is used in formal greetings or in scientific papers indexing, but in a list of persons, the first given name, not the surname, is used for [alphabetical sorting](https://en.wikipedia.org/wiki/Alphabetical_order). A married woman may add her husband's last surname(s) to the end of her own name, but this is not mandatory. The same may happen with men, though this is extremely rare. &gt; --- ^Interesting: [^Portuguese ^language](https://en.wikipedia.org/wiki/Portuguese_language) ^| [^Iberian ^naming ^customs](https://en.wikipedia.org/wiki/Iberian_naming_customs) ^| [^Portuguese ^Timor](https://en.wikipedia.org/wiki/Portuguese_Timor) ^| [^Portugal](https://en.wikipedia.org/wiki/Portugal) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chxu96z) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chxu96z)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I don't disagree with anything that you've written here, aside from this statement: &gt; Our difference of opinion lays in how long we delay in going for the more abstract solution. I think our main difference of opinion is in what constitutes "complex enough". Going back to the original example, I see a modestly complex bit of conditional logic. That, to me, represents enough complexity that it ought to at least be simple, tested method. Using a separate library to sweep nil conditions under the rug (I'm being a bit snarky here) seems like a worse way to address that complexity than creating a proper method on the current_user model.
Thanks for you comments! I've now updated the article and removed the lines that stated that this is an implementation of Maybe monad, which was incorrect.
Thanks for your comment! This is interesting, I’d love to hear more! First of all, I’d like to keep Maybe as an Enumerable. It’s easy to think Maybe as an array of no elements or array of one element. And since array is Enumerable, I’d like to keep Maybe also as an Enumerable. Now I have two options: Keep it as it is. It breaks conventions, but allows you to do neat tricks, like filtering: Maybe(@current_user).map { |user| user.age }.select { |age| age &gt;= 18 }.or_else { “You’re not allowed to see the content “ } Keep it Enumerable, but do NOT wrap the result in a Maybe wrapper. Instead, implement own #fmap and override some Enumerable methods, e.g. #select Maybe(@current_user).map { |user| user.age } #=&gt; [18] Maybe(@current_user).fmap { |user| user.age } #=&gt; &lt;Maybe::Some @value=18&gt; Maybe(18).select { |age| age &gt;= 18 } #=&gt; &lt;Maybe::Some @value=18&gt; Maybe(18).select { |age| age &gt;= 24 } #=&gt; &lt;Maybe::None&gt; Then the method missing shorthand could point to #fmap instead of #map, making the original chaining work properly: Maybe(@current_user).age.select { |age| age &gt;= 18 }.or_else { “You’re not allowed to see the content “ } The option 2 sounds promising to me. However, if I end up doing this, I’d like to know what are all the Enumerable conventions I should not break? I mean, as stated in the previous comment one convention not to break is that #map should return an array. Fair enough. What about other Enumerable methods? What are the methods I should/should not override? #select/#reject are at least two methods I’d like to override so that they’d return wrapper, not array, and I guess this is ok since Hash#select also returns Hash. Also #flat_map is something I’d like to override so that it would return a Maybe wrapper, not array: def find_something(id) # Takes an ID, returns Some if found and None if not found end Maybe(params).id.flat_map { |id| find_something(id) }.or_else { “Not found” } What do you think?
To me that feels quite a lot of code for such a simple task. So, just out of curiosity, what if the profile has other information, e.g. address, profile picture, age, phone number that you need to display? Would you make similar 17 line classes for all of them?
Well, it's very non-idiomatic ruby. Without any context, looking at the final "ChainFlow" version... * It's not obvious that `data` is passed into `group_by_key` and `compute_values` * It's unclear whether `data` is passed between the two functions * What if I wanted to call a method partway through _without_ passing `data` into it? If I do `puts "hello"`, does it become `puts(data, "hello")`? * looking at `process`, I'd "just have to know" `compute_values` expects an `Enumerable` of pairs and creates/returns(?) a `Hash` Also, I don't see how this is more functional if `flow` relies on state within the block. It sounds like the state monad in Haskell is used b/c Haskell is pure functional. Ruby already has state - is there really a need to use it functionally just to get it stateful again? I very much prefer the `chain` syntax: chain { data }.group_by_key.compute_values(parameter).fetch It's idomatic and monadic, and if you want to spread it out line by line (b/c you're such a stickler for style), why not just: chain { data } .group_by_key .compute_values(parameter) .fetch which _also_ is idiomatic Ruby?
Well, the whole thing with Enumerable looks a bit of a stretch to me. I.e. you have a neat method_missing, that allows user to call the encapsulated object as if they were accessing it directly. But what happens with expectations when I call `#each` on a Maybe, that wraps an Enumerable? Abstraction shatters. Wrapping Enumerable methods shouldn't happen in any form, in my opinion. If you check [Enumerable methods](http://www.ruby-doc.org/core-2.1.2/Enumerable.html), you'll see, that they return `nil` in well defined manner, that should not be overridden. E.g. `#cycle`, `#each` with block or `#detect` with no `ifnone` given. Every other case returns a non-nil value, that is safe already. Then there's another problem. What if I encapsulate a hash, run `#detect` over it and use the detected object to continue the chain? Or what if I get the answer from a `#detect`, written without ifnone, that I can't change for whatever reason? I would like to have a way to explicitly ask you to wrap the results, in a chain, until at some step in said chain I ask you to stop wrapping. It doesn't stop with Enumerable methods, either. For example: Maybe(@current_user).do_wrap.profile.payment_methods.dont_wrap.first.nil? Horrifying line, but things happen. Someone somewhere might vow to buy you a beer just because of this convenience trick. So all in all, I can't agree with making Maybe an Enumerable that is not quite an Enumerable. It's a bit too magical, and it might fizzle when you don't want it to. ---- I understand, that I'm acting quite picky here. I'm pretty much putting to word considerations, that me and my friend had while writing a simplest tsv parser gem. What at first looked like a simple thing, started shattering the moment we stopped thinking about it as developers, and started thinking as users or testers.
You're right, that sort of thing *is* pretty ugly. Monads might well be useful there. On the other hand, you *could* keep the native-style metaphors using something like [`hashie`](https://github.com/intridea/hashie), which is nicely placed in the Top Ten Gems I Evangelise About Regularly, because it's bailed me out of a few jams like that. I suppose the point is "there's (almost) always usable prior art, if you go looking." :-)
I know NeoVim, but wish their language of choice was Ruby instead.
I wish there was some easy way to have simple Ruby scripts run in vim.
If there is a DSL it would have made the vimrc and making simple extensions much better in experience.
You are right - it's not an idiomatic Ruby in case flow. But that's the point - if you familiar with State monad you'll get trick. Answering your points * you should be aware that state is passed silently - syntax sugar * you are building the flow: result passed as a argument to the next call * puts will work as expected, however I agree that this is not obvious * sure, if you 'composing' two functions you have to make sure interfaces fit with each other. The point of chain_flow is not to implement State monad (like you said Ruby has state already) but improve the syntax so that it looks like a State monad do-notation. Well, that's the matter of taste either you use do-notation-like syntax or the chains (that's why I've added both). I personally do prefer the do-notation. Anyway - thanks a lot for this discussion!
I've no idea, personally I think being able to write in Lua would be awesome.
andand gem and rails #try method are similar concepts (though a different approach). 
[Here's a list of student experiences at Dev Bootcamp](http://www.quora.com/Dev-Bootcamp/What-have-been-students-experiences-with-Dev-Bootcamp), where I teach. It's the program that's been around the longest, and is still the only one (I think) that teaches soft skills like self-teaching, communication and empathy in a thoughtful way. Locations in San Francisco, Chicago and New York City. 
I've been umming and ahhhing about responding on this. I ... have reservations and I guess I would ask, what does this offer me over the [NullObject pattern](http://devblog.avdi.org/2011/05/30/null-objects-and-falsiness/)?
very welcome
I wrote my first Hello World program around June last year, and I started working at a sweet web agency in March. It's a solid plan, though it'll eat like half a year of your life basically. Still faster and cheaper than college. I don't think you'll need to know about classes or anything like that to get in, certainly not mixins, the exams are more about array/string manipulation, iteration/enumerable, writing methods, using loops and if/else/elsif etc. https://github.com/appacademy/prep-work &lt;- this.
Shouldn't the site be in Farsi?
IMO, Title should really be: 10 common mistakes new developers make in an MVC framework. (with ruby code examples) Most of these points have very little to do with rails, and everything to do with good design principles: architecture, organization, DRY, Single Responsibility Objects, etc. All of these exist outside of Rails as well ;)
And they're symptoms of the same kind of mistakes that new developers will make in *any* environment. Telling beginners to "do it the way I've learned works better" is just asking them to cargo cult something different. Letting beginners write terrible code is sort of the best we can do as an industry right now, but I hope we can improve that eventually. I hope articles like this can show new folks how to identify potential growing pains, and where to look for additional answers, though.
I like it
I just finished #280 and do see any other examples. I did originally install this a months ago and only now got around to finishing. What is the file called that contains the problems in question? 
Actually, I think that's even a better example! I'd probably make a DisplayProfile class that accepts a user, and then has methods for age, picture, phone number, etc. That feels like better encapsulation to me than having a view littered with if/else statements. Just "DisplayProfile.for(current_user).real_name" and "DisplayProfile.for(current_user).address" is incredibly DRY. In fact, that's basically why the Decorator and/or Presenter patterns of code design exist! **Edit**: I guess what I'm saying is consider this - in the original examples, a dependency has been introduced that the view for some reason knows that the user has a profile object *and knows the properties of that object*. That is, objectively, a bad bit of coding. Masking it with objects that care/don't care about nil-ness doesn't resolve the issue. If anything, it tricks you into thinking that you've solved a problem rather than hide it. The params example is a slightly different story. In that example, I have less issue with the Maybe object. 
I do not really like this pattern, because it will be a lot more difficult to fix bugs this way. It's essentially the same as writing `@current_user.profile.realname rescue "Real name unknown"`, which is considered to be bad practice. Is "Real name unknown" displayed because `@current_user`, `@current_user.profile` or`@current_user.profile.real_name` returns `nil`?
Couldnt you just create a test object that runs the test and holds the result? require 'test1' puts Test1.run.results
It's a temporary website, We are working on a website project which is multilingual.
Thanks for the link to the prep work. I did all of the example problems on https://github.com/appacademy/prep-work/blob/master/coding-test-1/example-problems.md and thought they were pretty easy. Spent more time figuring the math out and fixing some syntax errors then anything else, I knew what I had to do pretty much right away by reading the problem. I also wrote versions that used code block and iterators in addition to the while loops just for the hell of it, and screwed around with putting them in classes too. I did have to look up some syntax though. My code probably doesn't follow DRY or best practice but I don't think they are worried about that. I have no professional experience or connections in programming or even any kind of formal online presence and that makes me a little uneasy. I'm working in a warehouse right now just to make ends meet until I can land a job with coding or get into a program like this. On their application page they asked for twitter and linked in profiles but I don't use anything like that. I'm a little concerned that things which don't have any bearing to my skills and potential as a programmer is going to be counted against me.
So the gist of 1, 2, and 3 is that you should make more classes outside of the scope of MVC to define functionality?
Are you sure it's not a rails users group? You know, because of the name. It's called Iran on **Rails**.
Sounds like you want [`system`](http://www.ruby-doc.org/core-2.1.2/Kernel.html#method-i-system), which prints the output of the command directly to the console and returns the exit code of the call.
eh, hashie is nice but it bears repeating that nested hashes are just one particular use case for the Maybe monad - it's great for *any* situation where you might instead return nil or have an empty value. In my own project I use it to wrap ActiveRecord calls which might return empty relations!
Backticks, popen3 and at least three other options.
Check into Openshift. http://www.openshift.com for your hosting. Rails apps are very simple.
We have our own server already which is cool. Are you saying Rails apps are too simplistic or being a nice guy and encouraging me?
I very much agree what you're saying! The HAML example may be pretty bad and it indeed feels a bit ugly to have those if/elses cluttering the view code. Maybe may help a little, but in the end it's just a nice way to hide the ugly if/else code, which maybe should not be there in the first place.
Thanks for the link of openshift.com . It helped me. Thanks.
I didn't know about Hulu. Good to know video is definitely viable. I've used Devise briefly before so I'll give the guides a look to fully embrace it. Are there any other similarly 'essential' gems to make development easier?
Yes, my question was the same. So there isn't 281 right? What happens when you complete the last example?
Okay.
... So the problem is that the output can be buffered before sending the data, and you need to disable that. If the other mechanisms don't work for you, look up How to disable output buffering in ruby, and modify the script you're calling.
This looks awesome! Been playing around with Docker recently, and though I really like it and it looks really powerful for deployment, there didn't seem to be a way to do a normal development flow with Docker i.e. making a change in your app running in Docker and having it reflected right away. Seems like this could resolve that! Excited to try it out. Look forward to the future blog posts too. edit: I wrote a quick blog post about setting up Docker on a Mac. The official Docker documentation is excellent but ran into a few small issues which I go over in the post. http://richardking.github.io/ruby/rails/2014/05/30/getting-started-with-docker-on-a-mac/
Thanks glad it looks useful! I found the same, a lot of the development guides out there rely on rebuilding from the Dockerfile after each change, which is admittedly really fast but still not really practical when you're making loads of little changes. There are two stumbling blocks for me at the moment. One, private indexes, it's easy enough to set one up but there's no auth/ registry in front of it so to control access you end up setting up SSH tunnels or binding it to a private network. Which is fine but still feels somewhat cumbersome for small deployments. That's the next one I'm going to try and tackle. The second thing is Service Discovery since container linking is confined to single hosts. etcd looks pretty promising for this but need to find a way to easily setup a minimal etcd based configuration which doesn't feel like adding a huge amount of complexity.
Haven't tackled those problems yet but definitely could see the need once you try and scale Docker out to your team, and multiple apps. Question- do you pre-bundle your Rails gems in your Docker image (like here http://ilikestuffblog.com/2014/01/06/how-to-skip-bundle-install-when-deploying-a-rails-app-to-docker/) or do you let your Dockerfile run bundle? By having the gems in my image, I got my Dockerfile run time down from 4 minutes to ~10 seconds. I have bundle run again in my Dockerfile in case there are any gem updates, but the process feels kinda hacky. Though since Docker is so new, a lot of processes feel that way :)
At the moment using the process from that post (I need to add a references section to the blog post). It's implemented in this bit; &lt;https://github.com/TalkingQuickly/docker_rails_dev_env/blob/master/Dockerfile#L38&gt; The bit that still feels hacky to me is that to update gems in the dev environment the process is; * run `bundle update gem` in a container to update the `Gemfile.lock` * rebuild the docker container now the Gemfile.lock is updated Which is two steps where there should be one...
1. Make a gem 2. ??? 3. PROFIT
Useful stuff here. I've not used the [regexp,capture] syntax before. It's a little neater looking to have s[regexp,1] than (s =~ regexp &amp;&amp; $1) which is what I've often done in the past. But I don't quite get the author's quibble ("what we've just seen is a lie") about string range specifications. Maybe it goes back to his *position* vs *index* distinction earlier in the article, which also seems needless. Positions as boundary markers between characters make sense to me in a regexp context, but do we need the concept when merely counting characters? It seems that is all we are doing with `[start,length]` and `[start..end]`. If a string starts with *index* 0, the range specifications are surely implemented correctly. *edit: formatting*
[**@Torben_TT**](https://twitter.com/Torben_TT): &gt;[2014-06-04 12:01:53 UTC](https://twitter.com/Torben_TT/status/474159101841530880) &gt;Here is a simple implementation in iOS of Flappy Bird made in no time and with [@RubyMotion](https://twitter.com/RubyMotion) [*github.com*](https://github.com/torben/FlappyMotion) [*pic.twitter.com*](http://pbs.twimg.com/media/BpSNMJFCIAAXux2.jpg) [^[Imgur]](http://i.imgur.com/PTUba9D.jpg) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/27b3va%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Stop posting flappy bird implementations, its not a measure of any programming language.
Right, the `...` one would produce the same result as the start/length. You can't think of them as a range of indexes into the string though. They're a starting and ending position. &gt; (1..-2).to_a # =&gt; [] &gt; 'test'[1..-2] # =&gt; "es" &gt; 'test'[1...-2] # =&gt; "e"
I thought it was neat to show how this was made with ruby. The tweet I linked links to the github repo of the project, so anyone can see the code.
Just the new logo. Very anticlimactic 
The way we do it at Phusion is to treat Docker as just a runtime environment, containing all the app's non-gem dependencies. The app code is mounted into the container on the /app directory. The container then runs the app located in /app, e.g. using Passenger. Is is much more workable than rebuilding the container on every little change. We tried that approach too, but it's horrible and lead to a 10x increase in development time, despite Docker's caching.
Huh. It never occurred to me that a string could be [0]'d over and over again. Amusing stuff.
That's what I've gone for in the tutorial, would be great to chat more sometime about how you're using docker at Phusion, don't suppose you're heading to Dockercon next week?
But I need to access the first character of the second element of the symbolic array. 
Uhh, what does this have to do with making a static site generator at all? This video is about refactoring out conditionals.
I'll take a look, thanks :) 
Flappy Bird is the new twitter clone
The one in the US? No, don't have time right now to make a transatlantic flight unfortunately.
You'll probably want to create a producer/consumer situation with a queue. So A sets a new thread B and then goes on to get user input. When A set up thread B it also set up a queue that is shared by both threads. As A gets user input, it puts it on the queue (which is a sort of list of elements). As B works, it checks if there is anything in the queue. If there is, then you can set it to take the item off the queue and then work on it. It's a pretty confusing idea to get your head around, but [the queue documentation page](http://ruby-doc.org/stdlib-2.0.0/libdoc/thread/rdoc/Queue.html) should help you get started.
If you don't want to do that, then just `ARGV.shift` then use `optparse`.
or `ARGV.shift` after parsing arguments, it doesn't matter.
It's the right way around. Also, can I say how much I dislike Swift's decision to make them the opposite? &gt;.&lt; And, about "position vs index", I wrote [this](http://stackoverflow.com/questions/3568222/array-slicing-in-ruby-looking-for-explanation-for-illogical-behaviour-taken-fr/3568281#3568281) once, which remains my most upvoted contribution to SO...
One particular case that seems to have been missed: How about when you want to get the entire last part of a string, starting from a certain index, but you don't know the length of the string? Example: 'This is a really long string that I do not know the length of'[15..-1] Returns: "y long string that I do not know the length of" Keep in mind, this only works with the Range approach. If you try it using an Array approach like [15, -1], you will get back nil P.S. Thanks for doing this dive-in on Strings. I found it to be very informative!
Someone has mentioned Thor as an alternative which is good. Another one is the Trollop gem for defining your options.
Phusion are based in the Netherlands if I recall correctly.
Bundler.setup(:group, :names) does the same thing. Useful to know outside of Rails. Also, are you sure Rails automatically loads your libraries? I was under the impression Rails only added the libraries to the load path and loads them lazily as they are used. 
We're in the Netherlands.
Rails application startup calls Bundler.require which does actually require the gem into your env. http://bundler.io/v1.6/bundler_setup.html 
Just looked at a rails 3 app I'm working on. It only requires the default group and the group of the current env name (:development, :test, etc). As far as I can tell, simply naming the group :toolbox should prevent them from being loaded.
Stick with ERB. It's part of the ruby stdlib and basically just adds special tags to the regular HTML syntax. &lt;h1&gt;&lt;%= @article.title %&gt;&lt;/h1&gt;
Definitely look into Jekyll. It's a Ruby gem. If you're looking for pure vanilla HTML templating, then Jekyll is the way to go. http://jekyllrb.com
Erb. Valid HTML is valid erb. It kind of reads like a non broken phone. But I'm kind of surprised. I love slim, and usually have to fight to use it somewhere. And here you are complaining that it's the default! Lol
It just feels and looks so wrong to me, as someone who reads and writes a lot of html. Thanks for the comment!
Thanks, I'll look into that!
If you havnt done so, install pry. The following is a transcript of how I figured out how to use nokogiri. BTW, I freaking hare xml! pry(main)&gt; f = File.open("your/path") =&gt; #&lt;File:your/path&gt; pry(main)&gt; doc = Nokogiri::XML f =&gt; #(Document:0x81186c90 { name = "document", children = [ #(DTD:0x811b3e70 { name = "nmaprun" }), #(ProcessingInstruction:0x811b36f0 { name = "xml-stylesheet" }), #(Comment " Nmap 6.46 scan initiated Fri May 30 16:35:51 2014 as: nmap -vv -A -oA web 198.23.154.4-6 "), #(Element:0x811b2ad4 { name = "nmaprun", attributes = [ #(Attr:0x811b2750 { name = "scanner", value = "nmap" }), #(Attr:0x811b273c { name = "args", value = "nmap -vv -A -oA web 198.23.154.4-6" # more stuff. I cut it off. pry(main)&gt; doc.xpath("//nmaprun/verbose")['value'] TypeError: no implicit conversion of String into Integer from (pry):25:in `[]' #well, I cant use the [] syntax. Fuck! pry(main)&gt; doc.xpath("//nmaprun/verbose") =&gt; [#&lt;Nokogiri::XML::Element:0x811687f4 name="verbose" attributes=[#&lt;Nokogiri::XML::Attr:0x81168484 name="level" value="2"&gt;]&gt;] # Hmm, its giving me an array? # pry(main)&gt; doc.xpath("//nmaprun/verbose").first # lets access it like an array =&gt; #(Element:0x811687f4 { name = "verbose", attributes = [ #(Attr:0x81168484 { name = "level", value = "2" })] }) # cool that worked pry(main)&gt; doc.xpath("//nmaprun/verbose")[0].name =&gt; "verbose" pry(main)&gt; doc.xpath("//nmaprun/verbose")[0].attributes =&gt; {"level"=&gt;#(Attr:0x81168484 { name = "level", value = "2" })} 
I like to go where the fence is the lowest so to speak. So instead of trying to figure out the Nokogiri nodes with XPath, we just use [ruby-nmap](https://github.com/sophsec/ruby-nmap) which does all the hard work for us. Result: require 'open-uri' require 'nmap/xml' # Add some convenience methods for our purposes module Nmap class Service def tunnel @tunnel ||= @node['tunnel'] end end end # Parse document n = Nmap::XML.new(open('http://pastebin.com/raw.php?i=fs72VDgN')) # Iterate each host n.each_host { |h| puts "=" * 40 puts "#{h.ip}: " + h.hostnames.map(&amp;:name).join(', ') # Select open ports that match http(s) op = h.open_ports.select { |p| p.service.name.match(/http/) } # Output port information op.each { |p| printf("%4s %-5s %s\n", p.number, p.service, p.service.tunnel) } } Output: =========================================== 198.23.154.4: test.co.uk 80 http 443 https ssl =========================================== 198.23.154.5: test.co.uk 80 http 443 http ssl =========================================== 198.23.154.6: test.co.uk 8443 http ssl If you still want to figure out how to traverse the Nokogiri XPath, then have a look at the [ruby-nmap source](https://github.com/sophsec/ruby-nmap/lib) to see how it does it. 
You know all those questions from people asking, "I just read all the Ruby books, what do I do now!?!?!?!?" This. This is what you are supposed to do, to apply your new found knowledge.
Thanks for the help. I'm having more trouble with a lot of the other challenges so I'm happy I found the whole prep work and curriculum. Right now I'm busting out some incredible janky and convoluted coding to get the result, including cheesy if statements to catch holes in how I've written my code and abusing variables that break scope. Lots of nesting with little regard for readability. I don't think they'll expect the code to be very clean in the beginning. It's odd because I'm at a point where I have a good amount of depth (relatively speaking) scattered around but I'm afraid that there are still some gaps in fundamental stuff. I think this comes from teaching myself and going all over the place. I hope they even have spots available in the courses for the rest of the year. Do you know if they fill up pretty rapidly, or do they accept people in waves? I don't feel ready to apply but at the same time I don't want to miss my chance and have all the positions fill up.
Hahaha that's a great point. I've actually built a bunch of much more serious stuff for us, but I took a few free minutes to settle the disputes that ALWAYS pop up with the AC at one side of an office. Admittedly, it's the first time I ever used sessions like this in a project, so I guess I did learn something :P
huh? String#[] returns a new string...
Well yeah I definitely knew that, but the infinite []'ing is still an amusing thing I hadn't considered before.
That's my endgame! I'm gonna be using a spark core with a big ass relay to control it automatically. You're right on my page.
For the challenges you won't have to worry about weird holes/edge cases. They generally give you like input/expected output, or will mention if they want it to do an edge case. Readability is more a factor in the skype interviews, but there it's more like you write beginner code, they suggest an improvement and see how well you implement it. I'd apply now, they send you a timed online coding challenge that you then do at any point in the next month or so. A new cohort starts up every 9 weeks, so they accept in waves. Beginning Ruby by Peter Cooper is an excellent book if you want a Ruby tutorial/overview written in a singular voice (referring to the teaching yourself/knowledge gaps thing). It's ~500 pages, and I think the suggested readings in the AA repo spells out which chapters are important. Though for the coding challenges you wouldn't need all of it. Just keep practicing everyday, doing all the prepwork they make available, and you'll do fine. From what you've said it sounds like you're more prepared than I was before I applied.
I like this and I have found a couple things I did not know about. It would be nice if it mailed you when one of your liked gems releases a new version.
How to handle states: a state machine gem. There are a few good ones. 
&gt; a state machine gem I am not a huge fan of state machines, just because I feel like they can obscure code a bit too much. I worked intensely with the Spree gem which heavily relies on state_machine. It was just a pain to work with. But I really think they are better than using bits to set state.
Just to get the obvious out of the way. You did set up the thread count etc when running puma right? Something like puma -t 8:32
This is a good idea. But explains what's going on a bit confusingly/inaccurately. Bundler doesn't "only loads a set of known groups." Rather, bundler does what you tell it to -- it'll put all the gems on the load path, yeah, but it won't actually "load" (ie `require`) any of them unless you call `Bundler.require`, and which groups will have their gems loaded depends on what arguments you give to `Bundler.require` -- if you call it at all (you don't need to, you can call Bundler.setup instead to just put the gems on the load path, and available for code to `require`, but not actually required yet). There is a single group called `default`, and gems that don't specify any other group end up in it. But there isn't a list of "default groups loaded by Bundler," and the group called "default" is generally only `require`d if you tell Bundler to, like any other group. Now, in a Rails app, it's Rails that does (and indeed it does) call `Bundler.require`. And Rails, I think, will require the `default` group, as well as the group with the same name as the current env, and no others (?). Honestly, I forget exactly what Rails does, get confused by it, am not not sure it's stayed consistent between Rails versions -- and generally think it was a mistake for Rails to call `Bundler.require` instead of just `Bundler.setup`, and then let the app `require` gems where they are used, as ruby wants us to. And if it did that, it would avoid the whole problem OP is solving in the first place. http://anti-pattern.com/use-bundler-setup-instead-of-bundler-require
Yes i did set the minimum thread count to be &gt;0. Also, setting the worker count to &gt;1 didn't change anything. The server still waits for the previous request to finish before it can handle the next request. I'm using MRI 2.1.2 if that helps.
Quite right. I only began using the state_machine gem during the past year, but I already find it invaluable. I don't even use half of the DSL/options though. I think one can try to do *to* much with it... I tend to think that this enum addition was a mistake. It could have been a useful gem I suppose, but putting it into Rails core? That's going to lead to abuse.
How not to handle data: Handing your application database over to your data analyst. Look if you're using any sort of ORM for data then the data model *is* in the code. And that database belongs to that application. Generally speaking it's best to handle any serious or heavy reporting needs from a database specifically setup for that purpose. OLTP vs OLAP. This same argument has been trotted out by database "experts" as a general argument against using ORMs for years back to Hibernate and nHibernate. That said, I don't love the implementation of enum either and agree that they probably shouldn't be used as designed, there are better ways. But please don't use the "reporting needs" argument.
I've noticed this same behavior in both Thin and Puma. And not just in Sinatra but in plain Rack apps. But it only happens to me *if* I go to the exact same URL in multiple tabs/windows. In other words it *doesn't* happen if: - I use two different URLs (even just adding "?foo=bar" to one) - I use two different browsers (even excluding the URL diff above) I never investigated it much beyond that, because it indicated to me that it wouldn't be a big problem in production. But I'd be curious to know if you get the same results.
I am not really understanding your case against the "reporting needs" argument. Could you elaborate?
Yeah, hopefully not to many people will notice it in the docs ha! The [role_model gem](https://github.com/martinrehfeld/role_model) uses bit masking for the roles, which makes me cringe for the same reasons as I wrote about.
Would you offer visa sponsorship?
Absolutely. I learned so much about programming when I was younger (not a comment on OP :) ) by choosing an annoying problem and tackling it. Books and tutorials are the means, not the end.
Gitignore.io
These are silly reasons to not use enums. For the first point (exporting to a data analyst), you can use a Sql case/when statement. For the second point, don't just assign your states the integers 1,2,3,4.... do 100,200,300,400 or whatever until you feel you have a safe enough granularity. Then you can put new states in whatever order you want.
The data shouldn't be dependent on the code base, and the code base shouldn't be dependent on the data. They are two different systems that work together. The analyst shouldn't have to reference the code base to understand the data. It should be inherently clear what means what. The code base could get out of sync from the database (e.g. it hasn't been pushed to production yet, thus making it a poor place to document the database). Yes, you could separate the integers giving them more space, but there is still a finite amount of adjustments you can make. What if they decide that they want state 300 to be at the beginning of the state machine? They would have to re-write all of the 100 columns to 101 columns and move the 300 columns to 100. Suddenly 100 no longer means what it originally meant and it leaves the database in this awkward state. Or you could say "oh, well move it state 1 instead of 100, since we haven't assigned a state yet for that number" Well now this 300 state kinda exists in two places (300 and 1), which is confusing and unnecessary. If this table were large, a replacement like that could become very expensive. Repeat that a few more times and you will eventually run out of numbers and your data analyst quits, because this is getting crazy.
And great refactorings.
Yes, it totally depends on the server used. There's an article at the Phusion blog that describes this very issue: [Tuning Phusion Passenger's Concurrency Settings](http://blog.phusion.nl/2013/03/12/tuning-phusion-passengers-concurrency-settings/). In short, you either need to increase the number of processes or the number of threads. Number of processes/threads equals the amount of I/O concurrency you have. If you're using Apache, you *also* need to tune Apache's concurrency settings. Thin also supports evented concurrency within a single process, but that only works if your app is specifically written to use Thin's EventMachine async API (which is usually not the case).
Is an HTTP status code not just a numerical representation of a state that has become well documented through necessity?
Agree on a standard temperature or at least temperature range first.
Jesus, man. We're not ANIMALS haha
Most data oriented developers/analysts will be quite used to working with data in 3nf (3rd Normal Form). ~~You're talking garbage.~~ Edit: Sorry, I should not post before coffee, I totally misunderstood what you were saying. **BAD ME! Apologies.** You're right it is bad, its providing a mock implementation of a lookup table and hence placing business logic in code. 
yup now you need to change it to be: "The current temp setting is: 70" enter your name and your desired temp setting. Then add user auth. Then permanent cookies so it remembers peopel (Who wants to log in for their temp change?)
I will agree, that enums would have their use. But I will say you should be very careful when using them. Most people probably don't have the large scale application required where the inefficiencies between strings and integers can't be fixed by more processing power and thus enums could be used.
This is just an example. It probably would be ok to just use the codes them selves. Historically, i have used enums to represent time (number of seconds in a minute or month) so you can end up with equations like enum TimeInSeconds { Second = 1, hour = 60 * 60, minute = 60, week = 60 * 60 * 24, month = 60 * 60 * 24 * 4 } costPerSecond = hoursWorked / TimeInSeconds.month where month would actually represent a month in seconds. Doing it that way makes your code a bit more readable. 
I've always thought this would be possible in Ruby.
I wrote an interactive ruby debugger on Sublime Text 3. Now its available on Sublime Text 2 as well. I hope you will find it useful. https://sublime.wbond.net/packages/Ruby%20Debugger[1] Shuky.
https://github.com/masidonion/jokr Tip: Don't add your .gem files to the Git repo. Instead you should tag the commits that you base your .gem on: $ git commit -m "update gemspec" $ gem build foo.gemspec $ gem push foo-1.2.3.gem $ git tag v1.2.3 $ git push --tags
I would either: * build this in Nodejs, a platform better suited for concurrent requests * return a 202, sent it to resque, and give the client and ID and estimated time of completion so they can check back later for the results.
Hahaha, yep, done :)
If I may suggest, you might want to stick this in an ENV variable and not have it in your code: set :session_secret, '61c191ce644fbfbc7a1340fb11f6cb9bdcc46da6' Edit: Made it prettier, I guess...
When you set something at the class level it's run when the class is evaluated. This is the same kind of issue Rails ran into with scopes. People would write `scope :past, where('date &lt; ?', Date.current)` which permanently locked the date at the time of the server starting. If you want to set something that can change like that at the class level you need to provide a lambda that can be run. heads -&gt; { rand(10) } Of course you'll have to also change the code to make sure you `call` the lambda to get its value.
Never checked, I am using byebug and debugger gems, so if they are working on JRuby my deugger will work too.
Thanks for the tip. Would you recommend keeping them in a separate file?
So wait I'm confused... was this just a problem with the way the binaries were compiled originally or something? How is that even possible? I typically avoid doing arithmetic with DateTime objects and opt for straight Time class so I've never even seen something like this happen.
First, you said "... a metaclass should just be the same as class ...". No, a metaclass is not the same as a class. Secondly, I want to say that you need to start thinking in objects. Classes are object definitions. Metaclasses are objects that exist only for a single instantiated object. Each object has its own metaclass object. Classes are objects. When you add a method on a metaclass, you are adding a method on the object's instance. A class has its own metaclass. So, when you are adding a method on a class' metaclass, you are adding a method on the class' instance. 
hear hear! As soon as I learned a little smidgen of Ruby, I promptly got around to automating the duller tasks that I have to do -- managing citations, collecting data for my website, heck even making a static generated website for myself finally. No need to tell people that its done in Ruby. Its satisfying enough to produce results that makes me look good.
It's the implication that any reporting concerns (hence the data analyst being involved) should dictate the structure or naming within your application database. This is a bad way to design application databases. They serve as a store of state for the application. Report from them if it's convenient but otherwise a separate OLAP database should be created for reporting.
It is a bug in ruby not in rvm, I guess it has to do with this bug: https://bugs.ruby-lang.org/issues/8879 - if you have a newer ruby version report the problem to https://bugs.ruby-lang.org/ - if older ten update ruby and try again
Okay that's what I thought. It didn't sound like something specifically tied to RVM.
I really don't know why they always say that Sinatra is for small apps... they never give any other argument. I feel that all these programmers are basically spoiled by Rails and they never took the opportunity to take out the head out of Rails hole they are living... saying: &gt;"When you need something tiny, Sinatra is awesome, but you can tell you've underestimated the scope of your project if you end up pulling ActiveRecord back in, and then you want migrations, or view helpers, and the bigger your little Sinatra project gets, the more you wonder if you shouldn't just have used Rails, because you're manually importing all its various features." What on earth!? They don't know that Sequel and DataMapper exists? just to name a few?... Sinatra or whatever other small Web framework let you make the choices it's like the perfect lego, many things available, abstract, small and clean, with no black magic attached. I'm tired of facing so many projects made in Rails that no one else want to work in because they became hell... It's easier to upgrade a 5 yrs old Sinatra project than Upgrade any outdated mid size Rails one... Good luck with that. Just my 2 cents
Great stuff. This, and [*The Myth of Convention over Configuration*](http://gilesbowkett.blogspot.sg/2013/02/the-lie-of-convention-over-configuration.html), another post of Giles' that he links to in this one, perfectly explain the mind-numbing swamp I've been bailing out with my once-trusty teaspoon for the last couple of years. When I started my current position some 2-1/2 years ago, I was not new to Ruby but *was* new to post-Merb Rails. *Oh, my aching head!* I've been doing object-oriented development for over 25 years now, and adapting what I understood about "good" OO design to Rails felt like the most Sisyphean challenge I'd been on until I encountered Matt Wynne, Robert C Martin, Jim Weirich and the other few, blessed, functioning adults who've taught me that (a) it isn't just me and (b) there are several ways to mitigate the more painful parts of using Rails to implement a non-Basecamp-clone application or set of applications. I just wish that there was real competition for Rails now, as Merb used to be. Mr Bowkett touches on this in the post, but I believe that had Rails not eaten Merb, and developed its present degree of indigestibility, that either Rails would be far different and "happier" (to use Matz' goal for users of Ruby) than it is now, or the Rails *core team leadership* would be far different than it is now, and the Rails-using community much happier. EDIT: Had key words in linked post title reversed. Posting after a 10-hour code session is *never* recommended.
IMO 1. Use [rubocop](https://github.com/bbatsov/rubocop) for checking style. 1. Write unit tests 1. Try writing in functional style with each_with_object. That way this: def mutate_string! string chars = [] string.chars.each do |char| if rand(100) &gt; 95 chars &lt;&lt; CHARS.shuffle.first else chars &lt;&lt; char end end return chars.join end to this: def mutate_string!(string) string. chars. each_with_object([]) { |char ,mem| mem &lt;&lt; mutate(char) }.join end def mutate(char) mutate? ? random_char : char end def mutate? rand(100) &gt; 95 end def random_char CHARS.shuffle.first end Why would you want to go from a crisp method like the original mutate_string! to a cluster of methods? It can be unit tested more easily and (arguably) it shows intention more clearly. 
I see where you are coming from, that is a valid point.
`rake release` is your friend. Just write `rake` and then press `tab` for the auto-completion to see what commands are available.
I love RubyMine's built-in project template for creating a new gem. Fast and easy.
&gt; the second request doesn't make it to (or at least isn't handled by) the server until the first is finished. That sounds exactly like a pipeline stall.
This is incredible! Thank you so much! Is it possible to add the common hover-over-an-expression to evaluate it in tooltip form? Neither of those are critical, but would be very convenient.
Neat idea! Here's a fork with some ideas for possible changes: https://gist.github.com/havenwood/46f6c0ed884e0f961cc3
Do you mean as in [opal](http://opalrb.org/) instead of javascript? Or did I misinterpret?
Have you had success building larger web apps with Sinatra? In my experience, it becomes pretty painful.
&gt; it becomes pretty painful. May I ask why?
Haha sure but its a fun adventure in sinatra-auth.
Well, what we're really contrasting here, imo, is building your application apart from your web framework (sinatra) vs. within your framework (rails). When I'm building an app by myself, I feel equally comfortable taking both approaches. On larger teams, a couple of problems crop up consistently: 1. Getting to your test feedback loop/CI/continuous deployment flow requires a lot more set up. And maintenance. There's never one answer for anything, there's a set of trivial choices to pick from. Lots of bikeshedding. 2. Figuring out where to put stuff. There's never one answer for anything, there's a set of trivial choices to pick from. Lots of bikeshedding. 3. "How do we want to expose this api?" "Let's follow Rails' RESTful conventions." "No, Rails' version of REST is stupid. If you read what REST is really all about, we should be using hypermedia." Lots of bikeshedding. 4. When you unravel the assumptions about, for example, how you wire up your router to your application code, you end up needing to sort of develop patterns as a team for how that takes place. "Should we use interaction objects? Commands?" Lots of bikeshedding. Everything that rails does, that sinatra doesn't do, ends up being a decision that costs more to make than you stand to gain. The productivity win you get from Rails' opinions tends to magnify the larger your team gets. Of course, the pain caused by rails' opinions not jiving with your particular domain also magnifies, which means you need strong leadership to know when to deviate from Rails.
I started Ruby with the online course on the ruby website with the online interpreter (sorry can't remember the name). Then I did the Ruby koans and some ruby monk. IRC #ruby was very helpful with some of the more complicated stuff. If you ask your questions nicely and try to figure it out by yourself first, people on that chan are very happy to help you. 
Thanks, good to know. I'm doing codecademy now, and will check out those ones you mentioned as well. Do you feel like the online tutorials gave you a pretty thorough understanding of the Ruby language? I'm wondering if I need to do a paid course, or if the free online resources are enough. 
Thank you, that's a great response! In some ways though I view many of your points as advantages in that it requires better thought through decisions and communication in smaller teams, but probably emphasis the need for exemplary architecture and planning for larger ones. I can see why that may become painful though.
It's called Codecademy. Also what network?
We're ALL still learning. Just post a link to a [gist](https://gist.github.com/) on this subreddit and ask the question, there are MANY others of many experience levels who are usually happy to help.
I wouldn't say you need to pay anything. Codecademy can give you the basics, the koans will show you the quirky stuff (take your time to wrap your head around what they're teaching you) and then the challenges on ruby monk (or project Euler if that's your thing) will make you understand ruby better. By paid course do you mean one of these 10k+$ boot camps or something like udemy etc? 
Or maybe you were on a team of bikeshedders?
Yeah, I was thinking of Tealeaf Academy (about $2,500) or one of those other courses to learn Ruby and also Rails. I was going to see how far I can get without paying first and then do one of those paid ones if I feel I need more help. 
If you can afford it then why not but the consensus seems to be that anything you learn in a paying course you can also get for free by yourself and that paying for a course doesn't give you any edge. But I didn't follow any of these boot camps so I can't really advise. 
Cool, thanks. I'd rather not pay to learn it if I don't have to. 
So what exactly is Rails lagging behind of? He didn't go in to much detail about that.
If people can see that you're genuinely putting effort in to moving in a given direction most forums (including this one) will have a lot of people who would be happy to help you. If you abuse help, and never do anything for yourself that generosity will run out rapidly. Always make a visible attempt to learn on your own first. Including what you've tried in questions you ask is a good way to show that you've made that attempt, and it often helps those who are trying to help you.
Freenode. 
What were you trying to accomplish with that comment? Just click the upvote button.
I think he vaguely argued that it lags behind the client-side MVC + server-as-JSON-API-only movement. While Rails hardly prevents that use case, almost everything about it encourages navigating from page to page of server-side rendered HTML. One could argue that Turbolinks is an explicit admission of this (arguable) failing.
I realy wanted to do that but I couldbt find how. If you saw any plugin who uses tooltip, let me know and I will add it
It already starts with simple stuff. There's no decent default logger for Sinatra, so I ended up having to write one myself. Rack::CommonLogger is not what I call "decent". At the very least, I want to see a log entry when a request starts, and another log entry when a request finishes, so that I can see which request intermediate log lines belong to, and so that I can see whether the program is stuck in some phase. Rack::CommonLogger doesn't do that and it took me a while to figure out how to do that in Sinatra. This kind of stuff should be default.
If argue the asset pipeline and ActiveModel::Serializers make front end development wonderful. 
Blue, obviously.
Thanks for your help! :) I don't know why I'm getting downvoted so bad, I'm not trying to do this to get some sort of risque photos some girl sent me, it's personal but I'm not being shady. Or maybe they just don't like my ignorance of Ruby, who knows. Anyways, so could I just enter the code in Notepad++ and add a .rb at the end? How do I get the code to target the specific files? edit: So I put the program and the files I want to decrypt in the same folder (desktop) and run the program through cmd, it all says decryption failed, the guy who posted the code said he couldn't get it to work on windows but he could on linux. So I'll try and boot up linux, which I have *slight* experience in, could I simply boot Puppy off a flashdrive and run the code with the files? If so how?
Yes, so far you seem on the right track. All Ruby needs is a textfile with .rb (technically the .rb is optional). So any text editor like notepad, notepad+ or similar (Aptana would be fine for that part too). Code seems to just use the current Dir. Whatever this exactly may be in a vertain context, current Dir from where the program was started or where it's saved? Putting everything in the same dir seems the best option. Seems to work for you if it lists the files it tries to decrypt. It should do this (puts command in line 11). The error message is not exactly helpful, since any error is handled the same, so 'file not found', or 'problems with openssl' would also say 'decryption failed'. Many linux distros have Ruby already installed (ruby -v). If not you would have to install the package. From there just start the terminal and than it's similar ruby myfile.rb. So maybe you can just navigate to your windows drive where files and ruby code are waiting and just run it there.
Sorry, I should've mentioned it listed the files and then said decryption failed. I'll boot Puppy with a flashdrive and give it another shot, thanks!
classical ubuntu or a bariation of this (kubuntu, xubuntu) should have it and you can boot them from CD or any USB.
Hmm, Ive always thought it functional. What do you mean?
I don't know why Postgres is storing more than two decimal places, but how are you persisting them in the first place? I would think that you'd have a callback (`before_save` or similar) that rounds to two decimal places before you're saving, right? If you're always rounding before saving, the issue of validation isn't so important. You can also store ratings as an integer type (e.g. 3.25 is persisted as 325), which is the recommended technique for storing dollar/cent amounts. That might be what you'd want to do anyway.
I've got a couple decimal columns. I'll change my price column to an integer. Can you elaborate on why it is the recommended way to store prices? Also, how would you write the before save to round to 2 decimals?
floating point numbers are not precise since they are stored using the binary system. In decimals it is easy to represent 1.03 but not so in binary. See this old movie about how an error in floating point calculations can lead to massive errors! en.m.wikipedia.org/wiki/Office_Space 
Okay, you're really all over the place right now in terms of things you're looking for. (disclaimer: most of my programming is backend Ruby on Rails and I do a lot of support/debugging and am very focused on refactoring techniques and other techniques for making literate code. The farther the topic steers from that set of skills the bigger the grain of salt you should take my advice with) First and foremost, what are you most excited about? If you're pursuing a career in technology just because it looks good on paper, you're going to have a bad time, even if you are really knowledgeable. If data science is your thing, then continue to focus on the data layer. Beef up your SQL skills, spend a little time learning to effectively query some NoSQL databases like MongoDB (and understand where each is useful) and focus on learning to effectively use tools like R and enterprise-y reporting tools like Tableau. If you're very statistics heavy I think you'd do well. If you are interested in learning to build things, then Ruby is totally worthwhile. I've yet to meet someone in the flesh who uses Cucumber in their organization and sings its praises but if you want to get into project management and you want to join a place hiring its first one, then knowing how to effectively use Cucumber will make you look like a boss because it makes everything so neatly organized. Ruby knowledge will come in handy there too because it ties into RSpec, though usually the engineers will be responsible for wiring that up. If you want to get a job building products, you want to spend a lot of time focusing on Ruby (and probably Rails). Understanding how SQL databases work will help shape a more healthy understanding of ActiveRecord, so that's solid. Understanding RSpec and Cucumber will help too, because both of those can help inform good design (that is, designing your application to be easily tested; good design and easy testability go hand in hand). Great that you know things like Xpath (I randomly needed to help someone with XSLT and my learning about XML/Xpath in a databases course really came in handy). But when it comes to building products don't just think about understanding the syntax. Well-written Ruby looks like English anyway. The truly important part with knowing a programming language is being skilled in hearing a problem that needs solving and recognizing patterns in the problem and knowing which ones to apply in the code you're going to use to solve it. That really is the essence of good software development, not knowing syntax or how a language works (though you can spend years mastering Ruby's object model and the innards of it, and I recommend that you do if it's the tool you use to build things). If you're really junior level you need to show a hiring manager that you are capable of building things. Do a few trivial Rails apps that solve some problem of yours, or write some scripts that help automate something tedious on your computer and put them on GitHub and write them in a way that doesn't just work, but that you're proud of. That gives the people looking at your background an idea of what you're capable of doing. There's plenty of demand for Ruby engineers, but the demand is super high for those who are well-versed in the language. There are a lot of boot camps producing large numbers of decent quality junior engineers so you really need to demonstrate promise and generally show that you're smart, excited about the work, and able to pick up on things. And it's great that your have mastered tools like Excel and VBA. Those might seem like "soft" skills compared to writing application code, but doing something simple with some regexes on a huge text document or a quick PivotTable on a big spreadsheet is going to look indistinguishable from magic to someone else in the business who you just saved 12 hours of work for. And better yet, whenever you get random tasks like that to do, you'll be able to do them quickly as well (it comes up a fair bit for me, as I work as a jack of all trades in my company). I hope this helps!
There are a ton of resources out there and it can be hard to choose where to start. The first book I read was *The Ruby Programming Language* published by O'Reilly. It's a pretty easy read and covers a ton. Other great books, though I'm not sure how great for beginners, are *Eloquent Ruby*, *The Well Grounded Rubyist*, and *Practical Object Oriented Design*. Happy studying.
Yes this helps greatly!!! Looking back at it, I should have pursued a CS degree as I've always built my own computers, troubleshoot problems, and remove malware/viruses. I pretty much live on the computer and believe I would feel most comfortable in an IT setting rather than a manufacturing sector. So would you recommend learning WATIR and would it be beneficial? What job roles should I apply for and what types of projects would you recommend? Also how difficult would it be to find a job once you know Ruby/SQL pretty well?
Ok so I got linux running, and oddly enough some of the pictures are instantly viewable, however there are some that aren't. I put the code into a text file and named it snapchat.rb, now how do I make it an executable and then run it? Also, I loaded Puppy, and ran a Ruby PET but when I type ruby -v in the console nothing happens.
An example: &gt; 12.34 * 1.06 =&gt; 13.080400000000001 
I teach computer science. I recommend to my students to learn the basic through teaching and tutorials. I have a list of such links here: http://programming.dojo.net.nz/languages/ruby/index One fun site which is a tiny bit beyond beginner is http://www.codewars.com so I'd recommend this after you've got the basics. The next step is to find an itch and scratch it. Nothing like the feeling of accomplishment associated with solving your own problems. Find some problem you have and try to figure out how to implement it. Feel free to ask others for advice or suggestions, but also don't be afraid to try your own ideas and solve it the way you think it should be solved. Creating your own birds nest and having to figure out bugs or why something isn't working is possibly THE best way to learn about programming. I also recommend reading other people's code once in a while. At first this won't be easy, but once you've got the basics you will learn a lot from reading how other people solved problems and finding their bugs/mistakes.
Codecademy seems to have a fairly decent ruby track. It helped me pick up some stuff when starting out. But for me, books for a bit better.
Personally, I started with: http://www.humblelittlerubybook.com/book/html/index.html
What do you mean nothing happens? Even you enter random gibberish on the console, you see something &gt;&gt; rndmGiberish zsh: command not found: rndmGiberish You need to install ruby which, by looking at some puppy forum, you can install through the package manager.
Codecademy, Codeschool, and Railscasts.
if you want to learn more realistic ruby you need to experiment with frameworks, but keeping the focus in the ruby code (what are good practices, learn about refactoring, testing, etc). Also read a book about object-oriented design in ruby, or some screencast (tutsplus, codeschool, etc).
Don't worry about the lack of a CS degree; I feel like I learned 5x as much after college. Honestly college is wasted on college age people; I would appreciate it so much more if I did it now. Watir looks cool and all (I honestly had never heard of it until now). There are other tool sets you can use (Capybara, Mechanize/Nokogiri are great as well in conjunction with RSpec/Cucumber) for doing user testing, but the truth is you'll actually get waaay more bang for your testing buck by doing unit tests that are close to the model. Automated integration tests are a lot more work and unless you're in a business that truly needs it (like something super critical like an EMR system) you'd be better off keeping your testing focused on individual units (that's just my 2 cents though). 
I think to best answer this we need more information about your background. Do you have a CS degree? What other languages do you know? What do you want to use Ruby for?
Sorry, I forget how literally programmers take things :p At first it didn't say I had permission, went in and changed it so it was executable but now it says it can't find it. Also, i successfully installed Ubtuntu. EDIT: I was drunk last night, so if that came off as rude I'm sorry :/ EDIT 2: had to install ruby, even though packages were already on the computer. EDIT 3: Ok, finally, got ruby installed, put the code in the same directory, directed terminal to the directory, enter ./snapchat.rb and I get this: ./snapchat.rb: line 5: require: command not found ./snapchat.rb: line 10: syntax error near unexpected token 'snapchat=' ./snapchat.rb: line 10: ' snapchat=Dir[''*'' + exts[i]]' EDIT 4: I run ruby snapchat.rb and it seems to run the code but for everything it just says 'Failed on decrypt for file'
Ya! I was also stumped! I though they would at least print a text saying its over!
What job roles should I look into? I think with my stats background I'd be good for QA testing but I'd have to learn some type of UAT. Would unit tests be similar to the automated tests in WATIR? So I should learn Ruby and Cucumber with what else? 
Thanks man, I'll take a look. How difficult would it be to transfer over to rails if I already know Ruby? Would it essentially be the same thing except I'd be scripting on a server? Also would 200 hours of Ruby be good to get me a general understanding? How's the job market for ruby/rails? What about after learning CRUD? Any other advice is appreciated Edit: I'll watch that 50 minute video tomorrow morning 
Build something! Build a web application with Rails or Sinatra, Build a command line tool to back up files or retrieve your IP address, talk to an API with a REST client and do something with the data. Just think of a low hanging fruit problem and solve it. Start small with a few puts statements or respond to a get request. Throw in an iteration, some arrays, and a hash and BAM you're on your way!
It isn't a bad thing if you actually like being forced to make a choice. Me, I'm on a deadline and just want to ship a product, so I just want sane logging by default without me having to do anything. I can still make the choice later, when I have time. And this is what Rails excels at: not making me make mundane choices until it matters.
&gt; I should have pursued a CS degree as I've always built my own computers, troubleshoot problems, and remove malware/viruses. If you think one has anything at all to do with the other, you should probably look at what CS actually is.
It was a generalization to save time reading.. 
Dig into eventmachine, specifically you should need an EM aware http client to perform external calls, I can recommend Faraday with EM-HTTP-Request adapter.
200 hours is a drop in the bucket honestly but people learn at different rates so YMMV. Rails is like 10x as powerful as ruby and, as a result is much more complex with more moving parts but knowing ruby certainly helps(that said I don't think 200 hours is enough for anyone to actually know ruby unless you are seriously gifted, less likely as well if you are self taught). Depending on where you live the jobs are out there if you have the skills. CRUD is the basics and you need it to get basically any job. There are a lot of skills to learn and you have to be comfortable with learning for the rest of your career if you are going to become a dev. If you are cool with that then time and perseverance are all you need. 
Touche, the reason I like using each_with_object over reduce/inject is exactly this reason. By mutating the object, ewo execution is faster. 
You must make sure that the line #!/usr/bin/env ruby is the very first thing on the file. No space before the '#'. You can also run your script with the ruby command. ruby snapchat.rb
I tried that, I have a feeling that the decryption key has changed or snapchat is using a new encryption method. Edit: yea, decryption is just constantly failing. Even when I use an online AES decryption app with the decryption key it doesn't work.
Yap, but I wouldn't call that 'functional' ;) cos functional to me typically means without mutation 
Cheers for the explanation. It's all starting to make sense now. I just need to get used to it and get into the mindset, but I can see how this can be quite friendly to work with.
If you google first (which will likely find you an answer or some better keywords) IRC can be a great resource. #ruby on freenode is a great and friendly place if you don't ask there for every little triffle.
Thank you. Once last question.. What would be the difference between a computer programmer and dev work? I'm seeing programmers are a different breed but don't see how
Thanks a lot for showing me this, really appreciate it.
This is exactly the behaviour and the workflow I did to test my implementation, although I didn't bother to check with both of the exception cases you mentioned. I didn't change my implementation, since I found out that it's more likely a pipeline stall problem, thanks to foobarwidget's answer.
I'd rather not use Nodejs, since it doesn't scale well with multiple cores.
Thanks for this. I'll put a bookmark on it for future reference.
To piggyback off of this comment. I completely agree with everything suggested, especially Codewars. For books, I started with Chris Pine's ["Learn to Program,"](http://www.amazon.com/Program-Second-Edition-Facets-Series/dp/1934356360) followed by the PickAxe book ["Programming Ruby."](http://www.amazon.com/Programming-Ruby-1-9-2-0-Programmers/dp/1937785491) If you're interested in a book, but would prefer a free one, then I would recommend [Learn Ruby The Hard Way](http://ruby.learncodethehardway.org). I have the ebook, but have not personally read it yet. Although, I have read his other book "Learn Python the Hard Way," which is outstanding. So I can only assume that his Ruby book is just as good. Codewars provides an excellent motive for learning though, as you're working towards an interesting goal and solution rather than pushing through a tutorial that may seem dry. It's a great deal of fun, and they (hopefully) are adding support for multiple other languages here soon. Honestly, Codewars (and similar sites such as Project Euler and [Codingbat](http://codingbat.com)) helped pave the route to learning a language better than anything else. They provide you with a goal, a fun one, you won't be able to solve it at first. So you figure it out, in doing so, you learn by doing, which I find to be most effective. In addition to Codewars, a similar resource would be the Koans. Ruby Koans provide you with a series of "lessons" where you're presented with an error, which you then figure out how-to fix. Through this immersion in the language, you'll learn better then any other method. Although, I would concrete your knowledge with a solid resource on the Ruby language with something like "Programming Ruby." Treehouse is another good resource, especially when introducing yourself to Rails concepts and frameworks. I'll grab the links to all the resources and edit them into the post. Good luck! 
Then I'd take a look at Java or .Net.
That was my background too. I started learning rails first since that's what I wanted to get into so I went with the Ruby on Rails tutorial. After that I realized that u really need to learn Ruby if I'm going to be worth anything as a rails dev. So I got myself elegant ruby and subscribed to Ruby off Rails (which is free now) I'm wanting to continue my learning and am contemplating signing up for the ruby course on Pragmatic Studio.
TIL. This is pretty sweet. 
My Railsconf talk this year might be useful, goes into what a typical production stack looks like; &lt;http://talkingquickly.co.uk/deploying_rails&gt;
This looks pretty cool and potentially very useful. In particular the use of a Bloomfilter [1] to track what pages have been crawled is really clever - if maybe overkill. From past experience, the biggest thing it needs is really some rate limiting options as it's way too easy to accidentally down a site. 1 - http://en.wikipedia.org/wiki/Bloom_filter 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Bloom filter**](https://en.wikipedia.org/wiki/Bloom%20filter): [](#sfw) --- &gt;A __Bloom filter__ is a space-efficient [probabilistic](https://en.wikipedia.org/wiki/Probabilistic) [data structure](https://en.wikipedia.org/wiki/Data_structure), conceived by Burton Howard Bloom in 1970, that is used to test whether an [element](https://en.wikipedia.org/wiki/Element_(mathematics\)) is a member of a [set](https://en.wikipedia.org/wiki/Set_(computer_science\)). [False positive](https://en.wikipedia.org/wiki/Type_I_and_type_II_errors) matches are possible, but [false negatives](https://en.wikipedia.org/wiki/Type_I_and_type_II_errors) are not; i.e. a query returns either "possibly in set" or "definitely not in set". Elements can be added to the set, but not removed (though this can be addressed with a "counting" filter). The more elements that are added to the set, the larger the probability of false positives. &gt;==== &gt;[**Image**](https://i.imgur.com/lZPRnPS.png) [^(i)](https://commons.wikimedia.org/wiki/File:AttenuatedBloomFilter.png) --- ^Interesting: [^Hash ^function](https://en.wikipedia.org/wiki/Hash_function) ^| [^Hash ^table](https://en.wikipedia.org/wiki/Hash_table) ^| [^Cuckoo ^hashing](https://en.wikipedia.org/wiki/Cuckoo_hashing) ^| [^MinHash](https://en.wikipedia.org/wiki/MinHash) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ci2ove1) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ci2ove1)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Thanks for the feedback, and the pull request! I like the bloom filter too. I agree, rate limiting is on the roadmap for near future. In a similar vein, I want to add the ability to use proxys at some point.
You are right. Pry is mainly a debugging and exploration tool. 
for the online exams...caesar cipher...reverse a string/array without .reverse... longest substring... The skype exams are more about talking through your code, so just get used to explaining what you're typing as you go through it. https://pine.fm/LearnToProgram/ &lt;- i think they recommend this book? I found it really useful http://www.theodinproject.com/ruby-programming/building-blocks &lt;- this is really good, i think a lot of these problems or variations end up in the tests http://testfirst.org/learn_ruby &lt;- also really good. Requires the use of git and rSpec which arent necessary to know but useful. http://www.theodinproject.com/ruby-programming/advanced-building-blocks &lt;- this is much harder and maybe not totally necessary to get in 
What I sometimes do is something like: hash.fetch(:foo, {}).fetch(:bar, []).first Instead of if hash[:foo] &amp;&amp; hash[:foo][:bar] thing = hash[:foo][:bar].first end 
As [#scan](http://www.ruby-doc.org/core-2.1.1/String.html#method-i-scan) returns an Array of results for each group when not passed a block, I think you can just do this: def get_hashtags(post) post.scan(/#+(?&lt;ht&gt;\w+)\s?/).flatten end
&gt; From past experience, the biggest thing it needs is really some rate limiting options as it's way too easy to accidentally down a site. Indeed, sites can specify crawl-rate in the robots.txt-file. 
The code is ugly (ugly code is fine if it works, but in the ruby world usually it's a sign of bad quality). Might want to use rubocop, codeclimate, etc.. Also, it's not really clear what the "main mission" of this gem is. To crawl quickly? Is it like a slower version of wget+grep+sed?
I will admit I have downvoted you. I think your suggestions is good and constructive, but you come out as very negative. I think it could be nice if you could point out some bad places, and come with some suggestions for improvements.
Two ways of doing this (don't use `inject` for this, use `each_with_object` instead): def get_hashtags(post) regex = /#+(?&lt;ht&gt;\w+)\s?/ return post.scan(regex).each_with_object([]) do |matches, array| array.concat(matches) end end get_hashtags('Hello #swag #sweg #fedora') More classic example that looks similar to what you already have: def get_hashtags(post) regex = /#+(?&lt;ht&gt;\w+)\s?/ array = [] post.scan(regex).each do |matches| array.concat(matches) end return array end get_hashtags('Hello #swag #sweg #fedora') By using `Array#concat` you avoid the need of having to also call `Array#flatten` on the resulting list of tags.
The most direct approach to replacing the use of array with an inject statement would be: def get_hashtags(post) regex = /#+(?&lt;ht&gt;\w+)\s?/ post.scan(regex).inject([]) do |array, m| array.concat(m) end.compact end http://rubyfiddle.com/riddles/76438
'each_with_object' is part of ActiveSupport, not the standard library. Your second example doesn't remove the use of the array variable.
&gt; very negative I'd rather not sugarcoat it (waste time). The code is bad, probably an exercise project; that would also explain the unclear purpose. &gt; come with some suggestions for improvements I did. Using a tool like codeclimate or rubocop would show a lot of issues and would allow the noob to learn. BTW a basic rule in code review is "don't take it personally. The review is of the code, not you".
You didn't do a code-review, you threw out an opinion "Your code is ugly" and named a few tools.
Sure I did, a mini 5 minute review. I looked at the source code, saw really ugly code and thought "this guy can't even write white-space consistently, better recommend some static analysis tools, would improve the code the most". I kept reading and thought "what's this for anyway, oh crawling and "quickly"; there's probably dozens of gems that do that already + countless tools in other langs; better recommend to better explain the purpose". The ugly code part is not just an opinion, if ruby code has tabs *and* spaces, most serious devs will say it's ugly even before looking at how bad the classes/methods are written..
No, that's totally incorrect for "modern" ruby versions. * [1.9.3](http://www.ruby-doc.org/core-1.9.3/Enumerable.html#method-i-each_with_object) * [2.1.2](http://www.ruby-doc.org/core-2.1.2/Enumerable.html#method-i-each_with_object)
Try www.questiondiscussion.com It's new and fresh with some active users. Most of the questions and answers seem to be of Learner's level.
In case you are following Twitter hashtag syntax rules take a look at [twitter-text-rb](https://github.com/twitter/twitter-text-rb).
Oh, awesome..
see this SO answer on [hash autovivification](http://stackoverflow.com/a/5878626)
And promptly started causing tests to fail for no reason this making us realize we'd forgotten to lock down the version of rspec in our gemfile. I've not dug far enough into it to determine the root cause but we started seeing “expected true to respond to ‘true?’” types of failures with 3.0.0 across a large number of our Watir based tests. 
Don't spend time on it. `rubocop -a` it and Rubocop will fix basic formatting errors for you, leaving the bigger stuff to deal with by hand. But also get in the habit of doing it right the first time. "Indent with two spaces" is easy (and your editor should do it for you). Not mixing indentation styles in a single file is easy. Giving variables and methods intelligible names is easy. Writing basic documentation is easy. If you want to make usable open source code, following the conventions of the language you're using isn't "silly as hell"; it's integral to getting the community to care at all.
Why is it always about Sinatra? When will webmachine-ruby (https://github.com/seancribbs/webmachine-ruby/) get its due?
While I totally agree with the notion to "build something," I don't suggest Rails or Sinatra as a starting point. For me at least, the world of Rails is very different from the foundational Ruby. I would get comfortable before moving into Rails. 
I started using this after you commented I figured I would probably go back to erubis or something I was wrong You have shown me markup god
After a few months of using HAML, you'll start to think "hmm, all those `%` are kind of ugly..." and come full circle back to Slim. :) That's the personal path I made, anyway. I thought Slim was *too* slim and that HAML was the best of the 3 after being a regular web dev for a while. Basically, HAML adorns markup (with `%` or `#` and `.` for divs) and leaves the rest as it is, while Slim adorns text (with `|` or `'`) and leaves markup bare. Considering almost everything is markup by default in an HTML page, I think the latter approach is cleaner.
I really like the idea, but I didn't get anything back trying to play rock, paper, scissors with the dumbstore. Any body else have luck?
Nice work! Got few comments though. First of all, replacing noise with grammatically correct words can ruin the whole meaning of conversation. The culture of social commenting is not only in spelling words incorrectly. Checkout urbandictionary and check some cases you've listed, you'll see that you cannot replace "wat" with "what" for example. We are running a simple comments analyzer in our product, it builds word cloud out of them and I can say, that aspell works fine in cases where moderate correction is required.
Thanks for the reply. Few points: - The main contribution of normalising social media (or *noisy text*) is that it allows previously successful NLP techniques to now run at an accurate rate. The Standard NER went from 90% accuracy to 48% when using a corpus of tweets. - The point of *cultural meaning*, has been made before. The original text can still be left intact, with the addition of normalised text which is far more useful in most NLP scenarios. - It completely depends on the level of variance displayed in text, and the common error patterns found. YouTube comments for example (focus of paper) have the highest level of noise of any studied text, so it is far harder to correct it at an accurate level. There are definitely areas of improvement, I'd love to do a PhD on the topic however I have a job in London starting this summer.
Yet another job has just ruined the good beginning. I am just curious, what NLP scenarios do you mean? Can you list few for example? I personally consider the "noisy text" more as a slang, rather than a 1-to-1 synonym connection. Like I wonder if any algorithm would be able to cope with some gangsta rap lyrics at all. Also, from my point of view, such context analyzing would be a brilliant idea in the scope of emotional content targeting. If you calculate emotional feedback of the topic comments, you'd be able to compare it with individual users emotional preferences and suggest kittens to "aww"-lovers and rough-ass debates to haters. That's what actually Reddit lacks right now.
Have a read of the Introduction section for my paper (linked in blog post), it goes into detail about the motivation and contributions of a system capable of normalising noisy social media text. An example would be the Stanford NER (http://nlp.stanford.edu/software/CRF-NER.shtml). It went from 90% accuracy on formal text to less than 50% on tweets. A pre-processing normaliser would help a lot with that.
I love tips like this. A simple but really useful way to exploit a feature you might have skimmed over when learning the language.
Congrats. Programming can be frustrating but very rewarding. Hopefully this is just the beginning for you. 
Interesting... I actually wrote a little javascript a long time ago to demonstrate the same thing (but using the premise as a card force): http://www.tchapin.com/wp-content/uploads/oldsite/cardodds/
Looks good.
I couldn't get any of them to work.
Doesn't matter if it was advanced or not, it's the thinking-through-a-problem, and codifying it that's the most important thing. Keep going!
I love seeing stuff like this. Thanks! 
Same here unfortunately.
I love the book 'Metaprogramming Ruby', as an intermediate guide to the language. I'd recommend giving it a try.
Absolute first step would be to set up a ruby development environment and learn how to run code through your terminal. After that you should start working on small projects as soon as possible. Some good small projects would be writing a bubble sort for an array of numbers, a random password generator, and an object-oriented terminal based tic-tac-toe game.
Visible counters on websites seem kinda weird in this decade -- I'm guessing you only wanted it just for your knowledge? If so, may I recommend using Google Analytics instead? Just stick their javascript into your header/footer so that every page sees it. I can help with that but frankly I've only done it in Jekyll. It will show you a boatload of info about where people were coming from, which path they took through your website, how long they stuck around, etc. etc. All you have to do is cut-and-paste one javascript blurb from Google. One last thing, if you use Google Analytics, is that I would really push you to include a link in your footer to an analytics disclaimer that tells people exactly what you are doing and how they can disable it (disabling cookies).
Practice, practice, practice. Just make a bunch of apps. Make a blog, a social network, a chat app, etc. Each pet project, try to focus on a technique, like TDD or design, or trying to make the best readable code.
Perl head here... Is it normal in Ruby for a variable and a method to have the same name? I assume the question mark is there as a "method hint". But, without a sigil, isn't that just a little too close to a ternary operator? When scanning the code that threw me for second. I normally find Ruby pretty clean but that seems unnecessarily ambiguous. Edit: as an aside, if you have trouble seeing the solution, imagine there are 100 doors and he opens 98 with goats behind them instead, and then making the decision. 
One thing I would do is put all those errors into one errors.rb file, assuming you intend to keep them as they are. There's no need for a file per class since this isn't Java.
Ruby methods can contain punctuation. In Ruby, the ? at the end of the method indicates that it will generally return a boolean. A common example is "foo.nil?" which the Perl equivalent would be "defined(foo)". You will also seem methods with a bang like "foo.strip!". That is a hint that the variable foo will be modified while "foo.strip" will return the result and leave foo unchanged.
I wouldn't start a new line with a call to an object on the previous line. I've never seen that done in Ruby before and it's confusing.
Not bad, but yarddoc is skinny and server responses are not stubbed. Check webmock for examples, or use bare `Rack::Test`.
http://blog.mediumequalsmessage.com/6-best-learning-ruby-books
I was going to keep it in the admin back-page. Mostly I wanted to make it just so that I could make it, in the future, if it's something somebody wanted. Thanks!
You mean constructs like that? &gt; qubell_request('/organizations') &gt; .get do |response| &gt; return handle_api_responce(response) &gt; end How should I keep line only 80 symbols long? I read [Ruby Style Guide](https://github.com/bbatsov/ruby-style-guide#source-code-layout) and an example there was: &gt;# bad - need to consult first line to understand second line &gt; one.two.three. &gt; four &gt; &gt;# good - it's immediately clear what's going on the second line &gt; one.two.three &gt; .four
It scales just fine with multiple core but okay. Keep using the wrong thing for the problem you have. 
Yeah, I get that, but the naming convention feels off, using the "same name" to describe a count and a method as unnecessarily confusing. won_staying? and stay_win_count / change_win_count feel better to me. I guess if I did more Ruby the ? in var name wouldn't look as strange, but I think the var naming would still feel strange.
Just did an application and put you as a reference. The thing about the online sample problems concern me is that some are easy as hell, some require taking some time to conceptualize the problem, and there is one that I still can't figure out how to do (transposing an array from rows to columns... dealing with arrays within arrays is throwing me). Thanks for the building block problems, I'll check them out. Did you attend the SF or NYC course? I put down that I'd go to either, but I'd prefer SF cuz it's where I'm from and where I'd eventually like to work.
I guess if you have a hard requirement to make lines 80 characters then it's *fine* but it's not something I've seen in practice even though it's in the style guide. If you want, you can do something like this to shorten up all of the various calls: %w(get post put delete).each do |meth| define_method(meth.to_sym) do |path, options = { }| qubell_request.send(method.to_sym, path, options) end end And then just make your calls like: def organizations get('/organizations') do |response| return handle_api_responce(response) end end That would shorten things up a bit.
wow, I was dreaming of using something like this. I felt this should be there in a dream. But wasn't able to see with clarity!! Anyways, thanks!
each_with_object is new to me, let me see! It looks exciting and new :)
Yup, I looked at Opal. But that just compiles to JS alone. Elm's compilation is mind boggling! 
I suppose that is a little ambiguous and I could have chosen better names, thanks for the feedback. I find it easiest to think "I'm going to pick the wrong door 33% of the time on my first pick". I really love the problem because at first its so hard to understand but once it clicks it appears much more obvious.
I think once you understand there's only two selections you can make - my choice, and *not* my choice, then it gets simpler to comprehend.
I've started writing Rcurse when I needed a really simple way of combining multiple html files into one, but in the last 2 days I've been working really hard to make it more like a template engine. It's not much, but I've learned a lot of things during the development, and refreshed my knowledge. Most importantly, I've learned the importance of tests, and how to write them. First I was using IRB for debugging but obviously it as a lot of pain and I re-learned how to write Rspec tests, Rspec is almost like written English, I love it. Also I've started documenting my code using YARD, it's awesome. BTW is there any simple way of adding custom CSS to YARD docs?
You learn by doing.
Nothing works.
Also, I would namespace them to your QubellAPI class since they have pretty generic names. Something like: class QubellAPI AuthenticationError = Class.new(StandardError) PermissionsError = Class.new(StandardError) ... etc ... end 
The closest gem I think think of off hand is [SciRuby](https://github.com/sciruby/sciruby) for you.
I just did a project like you're describing. After looking over all the options, I went with [statsample](https://github.com/clbustos/statsample). It may have more than you need, but at least it doesn't get crazy with connecting to R or anything.
I'm the developer of statsample, so I think I could recommend it. anyway, these methods could calculate mean and standard deviation fairly well for a given array def mean(x); (x.inject(0) {|ac,v| ac+v})/x.length;end; def var(x); m=mean(x); (x.inject(0) {|ac,v| ac+(v-m)**2})/(x.length-1);end; def sd(x); Math.sqrt(var(x));end
Use Python.
I had to really squint
Wow, how cool that you showed up! I thought to hit you up with a question before, but never did. I'll PM you instead of hijacking this thread.
maybe rack-counter fits your needs: https://github.com/ddollar/rack-counter
He wants to _do_ math, not typeset math.
Never used ninefold but every-time they have made an announcement here it always seems to be a very worthwhile improvement to their service. Looks like they are setting themselves up to be a very credible alternative to heroku for the "My app is just big enough to not be in the free tier of heroku" setup.
Seems like spam to me (maybe r/docker or something would be a better place to post this).
They are a Ruby on Rails hosting outfit so I wouldn't say posting here about them is totally wrong but I can understand people getting annoyed by it.
That's idiotic. The map that the author implemented is a perfect generalization of `#map` on collections. It's like saying `#size` is taken.
Your code is ugly (not you, just your code). Learn to follow a "styleguide", like [this one](https://github.com/bbatsov/ruby-style-guide/blob/master/README.md) and check out rubocop. Also checkout other static analysis tools/services for ruby (e.g. metric_fu, sandi_meter, codeclimate, etc.); they'll show you what is considered best practice, and what is not. Also check out what a "parser" is. Generally it's a bad idea to use regex for "parsing". Try to find out why.
I was at that presentation last night, and he presented it all from a mac. The sonic PI app runs on windows, mac and linux, not just the PI so you can make use of that :)
It runs on Windows also? I'll try it. EDIT: I looked into it a bit further, and it seems that it doesn't support Windows, at least without changing the codebase a lot.
Thanks for suggestions, but I have no idea why my code is ugly, can you point out some specifics?
It is possible, and it depends on what exactly you want. I know that if you use FFI, you can make raw frequencies play by wrapping the windows multimedia waveout function calls. The [Juicy gem](https://github.com/nicklink483/juicy) that I'm developing does it this way. So what exactly do you want to be able to do?
Try: gets.chomp.to_i Chomp returns a string by default. You have to cast it to an integer before performing the while loop. Hope that helps. 
Below works... def whileLoopFunc(i, x) puts "\n\n" while i &lt;= x puts i i += 1 end end puts "Enter i:" i=gets.chomp.to_i puts "Enter x:" x=gets.chomp.to_i whileLoopFunc i, x 
Thanks very much - i didn't realise i had to convert back to int
on another note - as a beginner programmer i'm finding that i'm learning the syntax of the language but still struggling to grasp the thinkings of a programmer. Does this just come with time and practice or are there things i can do to improve and help with my programming logic?
It works good on my iphone4. But you're right. On my Nokia 5530 it looks really horrible
How would i make a function that contains a FOR loop to go through an array but instead of coding in the array- i want the user to input the items? count = [1, 2, 3, 4, 5] for number in the_count puts "This is count #{number}" end
Actually, Node.js *can* scale to multiple cores, by using Phusion Passenger to run it in multi-process mode. Disclaimer: I'm one of the Phusion Passenger authors. ;)
I don't think you actually have to write chomp, I think you can just write gets.to_i because you don't have to worry about the extra space as it is an integer.
You are right. :)
It comes with time. I've noticed I slowly creep into speaking in code over the course of learning a language. And (personally) the awesome thing about Ruby is that it's easier making that transition since Ruby is so English-like.
The tab indentation I think is what he's referring to - you mix hard and soft tabs and it just ends up looking strange. Rubyists prefer two-space soft tabs, as the styleguide tastur linked shows. 
Thanks for the feedback, but I was more curious as to feedback on the code itself.
Hi thanks for the interest. I'm not 100% sure about the windows support but it might work in Virtual Box until something better comes along. It's in the final stages of a release candidate at the moment so that's why the Mac App isn't widely available yet. You can go to github project and compile your own but it's quite advanced. If you can wait a week or two, there'll be easy installers for Linux and OSX available. Sonic Pi is definitely the best thing I've found for sounds/music in Ruby. I've put a recording something I made up on SoundCloud here: https://soundcloud.com/xavriley/auto-dubstep-sonicpi with the Ruby code I used here: https://gist.github.com/xavriley/71b255775829b486249b I'll be publishing more when I get the chance. 
You are on the right track with gets.chomp but you need to change the string that you get from gets.chomp to an integer with to_i like posixpascal said. def whileLoopFunc() puts "Please enter the first number: " i = gets.chomp().to_i i = 1 + i puts "Please enter the second number " x = gets.chomp().to_i puts "We will now print all the numbers in between #{i-1} and #{x}" while i &lt; x puts i i += 1 end end whileLoopFunc() What if a user puts in a number where i &gt; x (for examples i = 5 and x = 1)? As of right now the program returns nil but you would still want it to return all the numbers in between. You should think about how you would handle that and maybe expand the method.
Perhaps this [repo](https://github.com/visionmedia/google-search) is of some service?
Maybe check out https://github.com/google/google-api-ruby-client
"Lines starting with four spaces are treated like code" as per the formatting help when typing up a reply.
Honestly, I'm quite on the edge with Windows. The only thing that is keeping me on it is League of Legends. I'll check back with you if I decide to install a Linux distro and try it out.
There is #instance_variable_get and you can do something like this pry(main)&gt; class Hello pry(main)* def initialize pry(main)* @a, @a2 = "a1", "a2" pry(main)* end pry(main)* pry(main)* def get(n) pry(main)* instance_variable_get "@a#{n}" pry(main)* end pry(main)* end =&gt; :get pry(main)&gt; Hello.new.get 2 =&gt; "a2" 
From [Google's TOS](http://www.google.com/intl/en/policies/terms/): &gt; Don’t misuse our Services. For example, don’t interfere with our Services or try to access them using a method other than the interface and the instructions that we provide. Be careful with scrapers... you can get your Google account terminated.
Can I ask why? This reads like a huge smell. 
You could create the menu options as an array and simply loop through them. 
I think that's as good as it get's in just HAML. If you're using it in something like rails you could do: %li= link_to "link text", "http://google.com" 
Learning/exploring what I can do with ruby. But in this instance I have several variables to check and their results determine which instance variable I will use. I would prefer to reduce how many repetitive if/else statements I have to write. I'm sure there's probably an easier way to do it, but it would involve rewriting a lot of my code so eh.
Another thing to do might be case statement, something like: card = case @a2milk when :fresh "Drink" when :closed "Open container" when :sour "Throw out" else "Buy carton of milk" end If you haven't already, I'd suggest reading about functional programming concepts in ruby.
This is a good point. I was wondering how I would go about this. I know while loops aren't used a lot - I'm just trying to get in the problem solving mindset. could that branch be done within the while loop or do I need to use something like if elsif? 
Thank you !!!!
Thanks for your assistance - Question about this. I typed up the example you gave and then ran it. I entered in the elements : apples Oranges Pears Carrots It prints the string with the number of items in the array but it doesn't return the names of the elements. It just returns "0"s I'm obviously missing a concept here... 
Just answered my own question sorry. It's converting the input to int!
Would this be a feasible approach? for i in 1..maxVar instance_variable_get "@var#{method(i)}" instance_variable_set (:"@var#{method(i)}", i) end Noting that method(i) returns a number. I'm just attempting to set a group of variables that are not in an array to certain numbers in a quick format.
Could I use an if statement so if the user enters strings or ints it will list either?
Honestly, it's under consideration. I'm more or less between Python with NumPy, R, and Ruby. R is probably the right answer for getting there most simply, however Python would probably be a better addition to my toolbox (and the actual programming part of this project should be simple enough that learning Python shouldn't be much of a setback..). And Ruby is what I know.
&gt; %nav.mainNav &gt; %ul &gt; %li= link_to 'SAMPLE', '#' &gt; %li &gt; = link_to 'DROPDOWN', '#' &gt; %ul &gt; %li= link_to 'Users', '#' &gt; %li= link_to 'Staff', '#' &gt; %li= link_to 'Managers', '#' &gt; %li= link_to 'Delivery', '#' %nav.mainNav %ul %li= link_to 'SAMPLE', '#' %li = link_to 'DROPDOWN', '#' %ul w%/Users Staff Managers Delivery/.each do |label| %li= link_to label, '#' 
I'm always looking for good Ruby devs that are within commute distance to Santa Cruz. 
&gt;Yet out here, in the tech capital of the US, I've realized two things: 1) Nobody uses Ruby here (Silicon Valley, not San Francisco). 2) There is a huge problem with the negative image surrounding people from bootcamps. You might just not what people want in Silicon Valley specifically. Have you considered applying to start-ups outside of Silicon Valley, in the surrounding Bay Area region? (I apologize if you already have, your wording just implies that you've been applying to SV-only companies.) You might consider going to a Hackerspace/Makerspace in the Bay Area region and networking that way while improving your skills on your own time. It's what I did, and having a makerspace on my resume (for "community involvement") is what got me my job. Granted, I don't live in the US, but maker culture is huge right now, and it'll definitely be a large plus. You should check out this website for makerspace opportunities: http://ba.chgrp.org/
Are you willing to do some freelance work? Do you have some github projects to show as a portfolio?
Thanks! At first I was limiting myself to SV, but started applying in San Fran as well because they are more startup and Ruby focused, however it would be 1.5-2 hr commute from where I am. But now I'm not concerning myself too much with commute and just applying to different places. I have been attending meetups to network, but they are usually only monthly. I'll definitely check out the Hackerspace stuff!
Are you looking at entry level positions or more senior positions? I'm a ruby/rails Dev in the area and haven't had trouble. Also, have you looked at consulting opportunities as well as straight software? 
Don't forget about ruby 1.9+ hash syntax! key: "value" Personally I find it a lot nicer to read.
just curious but can you give a few examples of consulting opportunities related to Ruby?
it sounds like your entire portfolio is one project that "kinda looks like crap." do you see how that could be a red flag to recruiters who, as you said, may already be biased against bootcampers?
Why not just fix this in the affected controller instead of applying the overhead system-wide? 
Thoughtworks, Pivotal Labs, Thoughtbot, etc. Almost all of them have significant Ruby on Rails consultancies.
Thanks! I was looking for that on google, but all kept pointing me to `:key =&gt; "value"` and I got frustrated and just went with it. 
Is "`= link_to 'SAMPLE, '#'`" notation more preferred than "`%a`" when creating links?
Correct me if I'm wrong, but + and %20 are both valid ways of encoding a blank space according to the URI specification. Your "fix" for this seems like a monstrous hack. 
/home/furiouslymasticating/Templates/gosu_dodger/enemy.rb:8:in `initialize': Unknown error (RuntimeError) line 8 in enemy.rb needs to be changed from './data/gfx/enemyship.png' to './data/gfx/enemyShip.png' good job on your first game!
jQuery? This isn't /r/shittyprogramming
I suggested something similar for someone who had an external system passing data in "action" parameter, which Rails overrides. http://stackoverflow.com/a/23791022/681520
This could go even further: ["Users", "Staff", "Managers", "Delivery"].each { |i| %li= link_to i, '#' } 
`1.upto(maxVar).each{ |i| instance_variable_set("@var#{m(i)}", i) }` Note that I used `each` instead of `for`, didn't use `:""`, and used `m()` instead of the builtin `method()`. Also, you should probably use an Array instead. p.s. How the hell do you get multiline code blocks?
What os are you in? open irb irb(main):001:0&gt; require 'libnotify' irb(main):002:0&gt; Libnotify.show(:body =&gt; "hello", :summary =&gt; "world", :timeout =&gt; 2.5) See what happens 
&gt; Sounds like a very easy jQuery solution. In rails, you could create a form and create a router to perform some action. this is an native os app (s)he is making, jquery is the opposite of what s/he will need 
Thank you very much! I'm still trying to get the hang of all this stuff in ruby. Kinda just teaching myself/looking at other people's stuff on the internet. As for the p.s. , I'm running RES, and I have a little button that says Code in my text editing box. I never played with the settings on it, so it should be standard. 
Please, for the love of everything, ruby != rails. I love rails, but ruby is SO much more than "short name for Ruby on Rails".
Well, as link_to is a rails helper, it may not be available if you use e.g. sinatra... If you don't link to rails routes, IMO "%a" is better / more "portable" - if a bit more verbouse; however with rails routes you should always use link_to.
I felt compelled to clean this code: module Math extend self def mean array array.inject(0.0, :+) / array.size end def sd array sqrt array.inject(0.0){ |sum, n| sum + (n - mean(array)) ** 2 } / array.size.pred end end p Math.mean(1..5), Math.sd(1..5) # Mean and standard deviation for numbers 1 to 5 # =&gt; 3.0 # =&gt; 1.5811388300841898 Do you normally write code that way? Almost looks like code golf; nondescript variables, no spaces around operators, 8 unnecessary semicolons (I counted!). It genuinely irks me.
yes you are basically right. But Rails does not seem to handle it correctly. I did not have the time to digg deeper. Regarding your statement, that it is a monstrous hack - I don't think so because it is a middleware and Rack is lightning fast. But I did not compare it to changing it in the application directly. I would love to see some compared performance numbers if you have some. Thank you.
I did not do that because it will arise different problems. What if there are more places affected? What if you have to change the way the URL is changed? Things like this should always be placed in a central way. You could use before_filter in the application_controller but that's not sexy :)
Hey, you like one-liner too! (I check your posts) The semicolons are necessary to maintain all on one line. I know I could make the functions more compact, but I was sleepy. You were right about starting the accumulators with 0.0, to force float, and the use of :+ on mean. I learn ruby on the old days of 1.8.X, so I'm not used to newer idiomatics, yet. On production code, I prefer a less terse approach. Just look the verbosity on [vector class on statsample](https://github.com/clbustos/statsample/blob/master/lib/statsample/vector.rb). 
The one liner actually *was* for code golf :P You really don't need the semicolons, try it without: def mean(x) (x.inject(0) {|ac,v| ac+v})/x.length end def var(x) (x.inject(0) {|ac,v| ac+(v-mean(x))**2})/(x.length-1) end def sd(x) Math.sqrt(var(x)) end Your codebase there looks strange to me, there are examples of inconsistent whitespace *everywhere*, mixed tabs and spaces and other inconsistencies - it'd drive me nuts! lol What's the reasoning behind using `m=mean`? Isn't it just another variable to garbage collect? You should just use the method name if you want a less terse and more verbose style.
Sure. Just change: gets.chomp.to_i to gets.chomp 
So if I'm reading [the code](https://github.com/baweaver/pry-session/blob/master/lib/pry-session.rb) right, you're basically saving the history to a file on save, and the rerunning all the history commands on load? I'm not sure what `_pry_.input` is for. Thanks for the work!
So these are basically service objects (whose value I am happy to attest to), but I like the syntax. Looks awesome!
and if you have links for them, you could loop through a hash, right? {"users" =&gt; "http://users.com", "Staff" =&gt; "staff.haml",}.each do |x, y| %li %a{href: "#{y}"} x
&gt; The example above allows us to create a contact using the following call: So would you do this from a controller or from a model?
The pry input takes anything that responds to read line, like a file. Once it reaches EOF, it pops it and goes back to stdin. 
I use mutations at the Day Job. I agree it's a pretty nice library - it has some quirks but does give us a place to put business logic that's outside the models and outside the controllers (especially important because we have a main Rails app then a smaller Sinatra app providing an API - locating all the business logic in mutations keeps in centralized)
You can scrape google, you just need proxies if you want to scale it. Also, spoof your user-agent to match a browser instead of the standard mechanize user-agent or they'll ban you immediately. Try not to make more than a request per minute per IP address. You can push it faster but your risk of getting IP banned increases. Also, randomize the sleep time to try and break free from patterns. Finally, don't feel bad about scraping Google, even if it violates their terms of service. They are the world's largest scraper themselves.
We do this from our controllers, the mutation will call the needed models.
We don't use them as service objects, but as DCI implementation (http://dci-in-ruby.info/). We still have separate service objects in our projects. An extra advantage is that we can use the same mutations in our Grape API to share the same business logic. We extract the required and optional blocks from the mutations and map them to the grape variant. This way we can automatically generate our API documentation. 
If you like mutations you should consider [ActiveInteraction](https://github.com/orgsync/active_interaction) (full disclosure: I'm one of the maintainers). It's based on mutations but it embraces Rails (really ActiveModel) so it will work with forms, you can use Rails validations, etc. Depending on how you use mutations it may or may not be a better fit.
At a first glance ActiveInteraction looks great, but I'm wondering how the different validation mechanism are handled. We like the idea of having two separate validation mechanisms: 1. Mutations checks if the call complies with the interface. In a web application this rarely happens, unless the frontend contains a bug and sends wrong information. When using an API, interface checking gives API developers great feedback when the interface requirements are not met. 2. ActiveRecord checks if the provided data is valid, this can happen in both the web environment as with an API call. Mutations can return an invalid ActiveRecord instance with errors, which can be handled by Rails to provide a nice form with errors.
You accidentally the link. https://hakiri.io/blog/ruby-security-tools-and-resources
ActiveInteraction sort of bundles those together. It's for a good reason though. Instead of returning an ActiveModel instance from a mutation and using that in a form, you can use the interaction itself. Consider an interaction that requires a string name (the interface) to be present (the validation). class ExampleInteraction &lt; ActiveInteraction::Base string :name validates :name, presence: true def execute; end end If you try to call this without a string, you'll get back an error. ExampleInteraction.run(name: true).errors.messages[:name] # =&gt; ["is not a valid string"] And if you try to call this with a blank string, you'll get another error. ExampleInteraction.run(name: '').errors.messages[:name] # =&gt; ["can't be blank"] In both cases you can use the outcome (an ActiveInteraction object) as a form object. Check out [the readme](https://github.com/orgsync/active_interaction/blob/2cbec8e3792ac1c4d9a56bffc73c8e5c54eb7f3a/README.md#what-do-i-get) for more. [Full disclosure: I'm also an ActiveInteraction maintainer.]
I learned a lot. Thank you.
You win the semicolon thing. For var(), I store the mean value, to evade calculate x.length times. OMG, you're really OCD for code ;) About spaces, I used like two or three different editors for the development of all the library, so is natural the occurrence of some inconsistencies. A couple of other developers changed things, so the problem worsened with that. While the test suite runs without problem, I don't think much about it. I know there are a couple of libraries for automatic formating, but always break things ;) About the storing of mean, is historic cruft. At the beginning of the development, there isn't memoizing of variables, so I need the m=mean trick. Later, I added the memoizing stuff, but I don't delete that unnecessary step. Anyway, I will be very glad to find people that helps my on that kind of stuff. Anybody just want to add the next-brilliant-and-shiny new statistical method, so the boring stuff is left to me.
Looks good but the name is really confusing since there is such as thing as "mutation testing" with libraries like Mutant.
&gt; For var(), I store the mean value, to evade calculate x.length times. Ah I completely glossed over that it was in a loop, my bad, and yea it makes sense you have inconsistencies as it's open source. I see the `RuboCop` gem used in some projects to alleviate this, it can run alongside tests as opposed to gems that automatically fix indents like [rbeautify](https://github.com/erniebrodeur/ruby-beautify). Edit: RuboCop also has an `--auto-correct` flag, might be worth trying that out too.
So every single thing you want to do is it's own class? That doesn't make sense to me at all. Why not use or write a more generic parameter validation gem. 
Fair enough. I have taken note of this suggestion at https://github.com/phusion/passenger/issues/1211
Yes, every action in our application is contained within a mutation. This makes sense for us, based on the complexity of our application and the kind of business logic we are dealing with. MoneyBird is an online accounting platform, the actions in our application are complex and have often side effects. With mutations we can describe the action and side effects in a clear and precise way, minimising errors in the implementation. A generic parameter validation gem does not solve the problem of defining the interface to our business logic. Rails strong parameters is a nice way to validate parameters, but it does not define a rigid contract. Let alone the benefits you get from data coercion with the filters in mutations. If this approach suites your needs depends entirely on the kind of application you are maintaining. For us the approach makes sense.
Here is what I envision.... class Foo include CheckParams def some_action(*args) check_params(args) do a,b,c,d,e = args required e, default: 5 integer e, between: [1,10] string b, matches: /blah/ end more code here end def some_other_action(*args) .... end end Somehow organizing your code this way makes more sense to me. 
Personally, if I ever feel that there's a need to write a comment of any sort, including big ol' header sort of comments like that, it's a code smell. Instead of putting a band-aid on it, I should refactor it to be smaller. No file should be so big that it needs comments like that, nor any code so confusing it needs a comment. This might not always be realizable in practice, but it's what I keep to as much as possible. If I have 5 validations all next to each other, why do I need a header comment? I just group them all together with a line break before and after.
Assuming your `CheckParams` module is like [Virtus](https://github.com/solnic/virtus), this is only cosmetically different that using command objects with Mutations. Instead of having separate classes for each action (like `CreateAccount`), you'd have a single class with methods for each action (like `AccountCommander.create`). There's no real downside to having a bunch of small classes managing your business logic. And there are a couple upsides: They all conform to the same interface (like `Mutation.run(hash)`); and they're all shorter and easier to reason about.
We have considered creating one large class with many actions instead of creating a module with many classes that have one action. Because you never know when an action becomes long and requires extra methods for clean code, we decided to go with the latter approach. It makes testing mutations also easier, we have one spec for each mutation describing all behaviour of the mutation.
this isn't so much a rails way issue as an internal coding standard issue.
What do you mean by 'semi-startup'? Just curious.
IMO, the Ruby'ists and the Ruby community killed the language. The style guides are horrible, the use of DSL's over design patterns, and a complete lack of SOLID principles makes most of the Ruby code out there a nightmare. Oh, and don't forget about gem dependency hell. Ruby is a language not unlike any other, so you could ignore all the pretentious rubyists, or abandon the language completely. I recommend the latter because of the performance and maintenance issues you'll encounter later in life. I feel much better now after ranting - and can address your actual question. IMO, beyond a small 2 liner comment at the class and method level, blocks of comments do not belong in a file. It sounds like the file is so large that perhaps it is doing too much? Fall back to SOLID, refactor the file into several (well named) files and the comment blocks become unnecessary.
cool! love the video about jazz_hands
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Lobotomy**](https://en.wikipedia.org/wiki/Lobotomy): [](#sfw) --- &gt;__Lobotomy__ ([Greek](https://en.wikipedia.org/wiki/Greek_language): λοβός *lobos* "[lobe](https://en.wikipedia.org/wiki/Frontal_lobe) (of [brain](https://en.wikipedia.org/wiki/Human_brain))"; τομή *tomē* "cut, slice") is a [neurosurgical](https://en.wikipedia.org/wiki/Neurosurgical) procedure, a form of [psychosurgery](https://en.wikipedia.org/wiki/Psychosurgery), also known as a __leukotomy__ or __leucotomy__ (from the Greek λευκός *leukos* "clear, white" and *tome*). It consists of cutting or scraping away most of the connections to and from the [prefrontal cortex](https://en.wikipedia.org/wiki/Prefrontal_cortex), the anterior part of the [frontal lobes](https://en.wikipedia.org/wiki/Frontal_lobe) of the brain. While the procedure, initially termed a leucotomy, has been controversial since its inception in 1935, it was a mainstream procedure for more than two decades, prescribed for psychiatric (and occasionally other) conditions – this despite general recognition of frequent and serious side-effects. &gt;==== &gt;[**Image**](https://i.imgur.com/py1p4eA.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Turning_the_Mind_Inside_Out_Saturday_Evening_Post_24_May_1941_a_detail_1.jpg) --- ^Interesting: [^Lobotomy ^Software](https://en.wikipedia.org/wiki/Lobotomy_Software) ^| [^Teenage ^Lobotomy](https://en.wikipedia.org/wiki/Teenage_Lobotomy) ^| [^Subconscious ^Lobotomy](https://en.wikipedia.org/wiki/Subconscious_Lobotomy) ^| [^Howard ^Dully](https://en.wikipedia.org/wiki/Howard_Dully) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ci6oznz) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ci6oznz)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
thx! more content coming!
Definitely concentrate on Scala first, it's much more dynamic than Java and will be less of dramatic difference. If you're not familiar with the more functional parts of Ruby, lambas, currying, enumerable map and reduce etc then take a moment to learn those in a familiar setting as those concepts will be useful later. Don't bother with an IDE as they take time to set up and take you further from your comfort zone. Coding Scala in Vim is absolutely fine, I wouldn't say the same for Java.
Here let me inspire you: http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html Honestly I find that it is partially a mentality thing, if you've never programmed in something like Ruby and you ascribe to all the Java non-sense, then it is pretty miserable. The transition won't be too bad IMHO but I prefer to question all the Java insanity. I'm not a fan of endless containers, configuration via XML, long class names and complex class patterns, so I dispense with these things, which makes me look like I am crazy to the regular Java programmer .. I don't like spring, etc. I tend to question anything java related with utmost suspicion as to its utility. I often think of Java as playing with G.I. Joe characters when I was a kid, the fun part was about building silly little bases and setting things up - but you never play war. Java makes you feel productive because to do any damned thing you feel like you need 50 classes. But in the end all your doing is spending time getting things setup, not actually solving problems. So don't be afraid to approach this stuff differently and question the non-sense, lest you'll end up with a AbstractSingletonProxyBeanFactoryProvider class when all you needed was something simple. 
That's really insightful. I've always seen Java as a gateway to Scala, but the fact that Scala shares more characteristics with Ruby than Ruby shares with Java is important intel. I'm thinking it may be best to tackle some of my past projects but in Scala, or to find ways to connect the dots between Ruby codebases and Scala. It's a transition that Twitter managed to pull off, so there is a precedent there.
Well, it seems that jumping straight to Scala would eliminate some of the issues you raise with Java and would ease the transition since it does share some traits as a language with Ruby.