Ah, I don't use this for cases like that. You're right of course. Perhaps I misunderstood the author's point. I use this pattern for testing, for example, saving a timestamp to a database, where the persisted timestamp has a different precision than your local one. 
Basically, because it kept the example short. In real life, you'd probably have a customer somewhere in the middle, associated with both a credit card and a cart. The customer would then use the credit card to pay for the cart of items (either directly or through some sort of Checkout service object, depending on how complicated things got). I try to make my examples real-world-ish, but here I missed the mark.
This might help: http://stackoverflow.com/questions/1268289/how-to-get-rid-of-non-ascii-characters-in-ruby
&gt; The Well-Grounded Rubyist An upvote for "The Well-Grounded Rubyist". And I'd add to that list "Eloquent Ruby"
Interesting! The majority of my Ruby programming has been on 1.8... I had no idea we did string encoding now! Cool! So my guess is that Pathname2 simply hasn't been updated to handle string encoding? For now, I've put the code behind a filename cleaner, but it'd be great to be able to handle these filenames more gracefully (and really stick it to the C# guys here at work), so I guess I will play around with it in my test environment.
FWIW if you're just looking to escape Java, Scala works great on Android, with much better interop.
The best way I can describe it is that _why takes you in an awesome journey through Ruby while making you laugh your pants off. When I read it, I was thinking "What is this, I'm not learning anything at all". However, after a few pages I was already writing Ruby (and in the community accepted way)
I'm not at all saying this is going to work, but have you tried changing the console code page? If not try `chcp 65001`
It would be, except that the programming katas you have to do to join don't work for me. With the one to finish the Person class, when run I get: NameError: undefined local variable or method `message' for Test:Class
I get NameError: undefined local variable or method `message' for Test:Class on the second question, I don't think that's an error on my part.
Jesus Effing Christ, give it a break already.
shame the starting demo's broke for some people. I have been using codewars for months and it's pretty neat. Sometimes the people who write the tests (they are just users really) do make mistakes though - but you can discuss this on the message board for the kata and have it fixed usually.
I haven't. That might be interesting to try.
You can do the first two problems in Javascript and it'll unlock the whole thing, if the Ruby ones aren't working.
For the people getting an error on the second ruby question, you have to call the instance variable @name in the second method (instead of name)
Where do you see the camel casing? You sure you're not looking at the JS or CoffeeScript version?
Check out Eloquent Ruby
Submission Timed out every single time. Looks like a neat website if it worked.
In case someone still have questions or wants to see benchmarks - http://homeonrails.com/2014/04/ruby-speed-quiz-explained/
Read that as corewars, was incredibly disappointed when it wasn't :-( (I have no idea what that's got to do with ruby, but still.)
If you're already using bootstrap: https://github.com/smalot/bootstrap-datetimepicker
Just worked fine for me. 
quite a few of these things are available in ActiveSupport i do enjoy the hash functions though :)
If you're using Bootstrap and need a date/time picker: https://github.com/TrevorS/bootstrap3-datetimepicker-rails
Aww man not using bootstrap atm. Anything else? 
Ah. I see. After you signed up. Yeah the kata are created by other users so maybe.
This will dramatically increase WTF's per hour when someone not familar with this lib is reading the code.
This right here: &gt; As rule of thumb, avoid mutations after an object is being initialized. Can be a difficult way to structure your application, but man does it make things easier. Threaded code often puts you in this weird situation where you *undo* performance optimizations and end up decreasing overall wall clock time. Plus it's really, really difficult to reason about overlapping operations, so it's best to avoid them until something forces you.
https://github.com/markrebec/inkjet is another alternative with a few additional formatting helpers (indentation, dim, etc.) and a dead simple usage syntax. It's lacking a CLI, though, as that wasn't a requirement when I built it, and if I remember correctly I only supported the main palette. Great job with tco! Love that it will find the closest match to your requested RGB for you. Edit: Hopefully that didn't come off as slimy and self-promoty! tco is fantastic, and it just reminded me of my brief excursion into colored shell output :)
How does this compare to the term-ansicolor gem, as far as colors available via telnet? Can you push more than just the ansi colors?
Im using pikaday: https://github.com/dbushell/Pikaday
I'm in the same boat as you. I've been hoping for something like the new date pickers that are in Android 4.4, which work really well, but have yet to see anything. Yes, they would work well for browsers too. https://github.com/amsul/shadow-ui looks like it has potential
Welcome to refinements.
you can discuss this on the website's forum!!
I've even thought about and missed a generalized map method that takes two blocks, one of which is a key transformation block, and the other is a value transformation block, which runs the key transformation before or after the value transformation. c = { :hello =&gt; "hola", :world =&gt; "mundo" } c.map_keys_first -&gt; (key, value) { "#{key}#{value}".to_sym }, -&gt; (key, value) { value.to_s * 2 } =&gt; { :hellohola =&gt; "holahola", :worldmundo =&gt; "mundomundo" } and reverse the order of operations in the `map_values_first` transformation.
to get help with your Katas
 c.each_with_object Hash.new do |(key, value), new_hsh| new_hsh["#{key}#{value}".to_sym] = value.to_s * 2 end
"how Rails utilized in Rails" typo? 
This is exactly where you should start: https://learn.thoughtbot.com/products/25-ios-on-rails-beta
Yes! I'd love to give you my email address, so that you can send me your stuff instead of reading it on your site! And you even make sure to only send me bite sized stuff each day! Best user experience ever!!!
+1. Refinements have some valid use cases, particularly when building a framework; they're great at cleaning up the guts of a class that manipulates a lot of primitives, without polluting the objects that'll be used by the application code. I can see them being an alternative to `#extend` for DCI as well. But seriously, don't litter your code with syntactic sugar stored in refinements. Whatever it took to talk you in to monkeypatching before, the same criterion applies to refinements.
&gt; c.each_with_object Hash.new do |(key, value), new_hsh| new_hsh["#{key}#{value}".to_sym] = value.to_s * 2 end Thanks :) does that return the new_hsh at the end? 
Yes :)
I haven't tested it with telnet, so I'm not too sure, sorry :-(. But based on a very brief review of the term-ansicolor gem, I think both of them produce the same escape sequences, so if you had any problems with term-ansicolor and telnet, you'd probably have the same problems with tco too.
Thank you for your kind words :-). No, not at all! It's good to have multiple options. And inkjet has some nice things on top that tco doesn't have. In fact, I was more focused on making the terminal app. The library is sort-of a by-product.
You can easily use Rails to do exactly what you want: http://railscasts.com/episodes/348-the-rails-api-gem?view=asciicast You're looking to built an API that responds to http requests and responds with JSON. Watch that railscast and you should be basically ready to get started. Cheers!
I'd say no you don't need the degree, experience and capability counts for a lot. If you're that close though, why not just finish it?
Nope. Helpful answer, I know. 
simple answer - I am burned out on school. long answer - I love to work my ass off, but I have to know I'm working towards something. Sittinging and working 10 hours on a C++ assignment to prove some abstract inheritance concept seems like a waste of time, especially if the other option is working on a real-world Ruby/Rails app. 
what did you do between getting that degree and getting your first full-time job as a web developer? (related to CS, of course). 
That degree seems ironically relevant... especially if you're a freelancer.
Probably not necessary, but it might help. When applying for a job, having a CS degree helps offset not having a strong portfolio of work, but a strong portfolio is more valuable than a degree. IMO if you have 3 years of school left that is a difficult choice, but if you only have 1 year left I'd suggest that its worth finishing, perhaps after taking a break for a quarter or semester. 
You just started getting gigs by publishing your projects?
hehe, I am.
No, my own projects act as proof that I am a web developer. I got my first gigs through friends/relationships I made along the way.
As someone who hires software engineers, I personally look at education as additional experience rather than satisfying a prerequisite. To get an understanding of what's going through the mind of the person you're interviewing with, you should read this: http://www.joelonsoftware.com/articles/GuerrillaInterviewing3.html
Enjoyed that article - I hope my resume SCREAMS SMART... GETS SHIT DONE by the time I'm done with this summer.
Okay thanks. I'm just starting out freelancing and I need to find clients somehow.
hehe
Do you need one? No. I am a web developer out of San Francisco and have been for 5 years. However, you will always have to live with the stigma. Frankly, I would finish school and then I would become a developer and love your 20s. You can do it, and you'll love it, but realistically you'll want your degree in 2 years.
hahaha...I'm going to be 30 in 2 years (too much loving my 20's got me into this position). I am worried about that stigma, for sure. I just wonder how much it'll affect job-prospects, especially considering that I have a masters, albeit in an unrelated field.
Get a few projects and you should be okay. I had 35 interviews before I finally got to my company. It's scary out there, man. But I love my job and who I work with. I know places hiring too so I can help there once I can see and vouch for your work. 
&gt; but you can discuss this on the message board for the kata and have it fixed usually. Not if you can't make it through the starting demos...
&gt; you can discuss this on the website's forum!! Not if you can't make it through the starting demos to sign up.
The Ruby problems are not working. There is an error in the test class written for the second one to make it output @name in the string.
Thanks for the info. I haven't had any issues with term-ansicolor. The reason I asked, was because your gem offers more colors. I will have to give it a shot and find out. Thanks!
Unless you want to work on ERP systems or science related apps you don't need a degree. The most employable coders I know either don't have more than an associate's or regret wasting the time on a bachelor's degree. In fact I would probably hold having an education Master's against you in an interview... Focus on code and get involved in the local dev community.
If you have twelve credit hours remaining you should suck it up and get the paper. Not because the degree is valuable, but because there are some elements of comp sci that are extremely difficult to teach yourself. Good examples would be a solid understanding of algorithms and cryptography. Having the basic degree may, in the future, allow you to explore higher education opportunities in those areas when your interests take you there. Career fields that use/improve these skills tend to require the relevant degree.
You don't need a CS degree to get pretty much any web dev job, but it can't hurt you to have one. Do be ready to give a good answer as to why you quit, more than being burned out. Even so, 12 hours is a light semester. If I were you I'd suck it up and finish somehow. You could do it part time if you want. You're just so damn close.
The short: A degrees greatest value is the prestige associated with it, and your abilities you developed along with it in learning multiple new things efficiently and effectively. Oh and also the College Career Fairs -- can't beat them for networking, especially if you know absolutely no one professionally. My brother got his master's from Georgetown, and while there are many schools like Georgetown that have rockin teachers and excellent challenging curriculum, he told me the reason he went there was simply for the networking power by itself. You would be surprised at some of these top private institutions how many CEO's or children of CEO's/CTOs/COOs/Managers you meet. All invaluable people to have in your network for future opportunities. Extra story if you care to read: There are things I have seen from my school experience translate directly to the workforce -- specifically the feeling of a deadline. My senior year, I constantly had something due for a project (I took the most software-engineering focused track I could, for me it was called "computing systems" Colleges have these. Check out Cal-Berklely's CSC-169 -- it's SaaS and Cloud Computing using Ruby on Rails and Heroku -- my school actually used that as a model), So if you work somewhere that has an iterative development style, you'll feel at home. Also, experience in my software engineering courses actually translated directly, and specifically the SaaS one got me a job at a local start-up, because I became a teaching assistant for that class, and I could officially put "Ruby on Rails" on a resume. Fast foward a year later, a company that was traditionally a EE Java shop decides to try a higher level language (ruby) and gives me a call (they were always at my college career fairs) Anyways, could I have gotten that startup job without going to college and just picking up rails books? Yeah, I am almost positive I could. That being said, my network is what it is because of college, and I feel probably 10 times more secure about my future employ-ability. What if the job market changes and web developers are an easy to find commodity? Well I got that computer science degree, I can brush up on some networking topics, go be a networking engineer or something, who knows? Maybe quantum computuers invalidates everything we know about software development today and we all need to go back to school? Those with degrees already have a fast lane. Anyways, you get the point -- the future is very uncertain, having a degree helps deal with that. Not saying you can't, but again you should be doing everything you can while you are young to secure your future. hi five if you really read all of this, you're awesome! 
Thanks, I fixed it!
i have no formal education and i make low six figures
You don't have to. As I stated on the subscription form I will only send you ruby/rails related articles updates but if you are not interested in those than you should just simply close the form :). But thanks for your opinion!
You have more school in than I do, so I'm not going to lecture; but 12 credit hours? That's one more full-time semester, or a year of part-time work to be done with **a whole other degree**. My undergrad degree was something near 128 credit hours; quitting 12 hours short (eg., 90% done) would seem crazy to me.
If you don't mind my asking, where did you learn about the more hardcore CS concepts, data structures, algorithms, etc?
Learn by your self is not a problem. Is keeping the interest constant. Without a degree or with one of you don't learn new things or exercise it's useless 
There's no stigma. I was making 85k at age 20. No degree but I aced all the problems on the whiteboard and computer. That's what mattered.
Like 500k?
Use Goliath, if you have an eventmachine driver for your database. Goliath has a http server built in, so you do not need anything else, for your json API. 
'gem install instagram'? Probably a copy-paste error. Other than that: interesting.
Does saying **"I crave GOOOOOOOOOLD!!"** at the interview, work?
Nice gem! I would advice on separating configuration and syncing. Btw, have you seen homesick gem? I use it to keep my dotfiles in sync. 
Yeah, right.
This. I think it's kind of mad to quit so close to finishing. 
More like something about requiring more minerals.
This varies from person to person, some prefer it, some need it, others don't. I personally have no formal degree in anything other than shaving yaks. I studied photography for 6 months but bailed due to numerous reasons. So far I regret nothing.
What counts in the world of work is not what you have been taught but by what you do. Enthusiasm, continual self learning and development, passion and a real interest in some bit of CS or Ruby will get you there. In my line of work if a candidate had 3 degrees but no evidence of participation in any tech community, no personal website, no open source programming experience or no real demonstration of enthusiasm, then I will not look favourably on that candidate compared to someone who has no degree, but some of the other stuff.
I just want to back you up because every other comment is tangential to what you are saying. At my work, you had to have a (as in: any) degree. That stopped a couple years ago. Now you have to have a degree in something computer related. That includes information science, library science, computer science, electrical engineering, physics, etc.
I was faced with the same dilemma. You will find a job with 7/8 of a degree. With only one semester left, I would definitely go ahead and finish your degree unless you absolutely can't stand it. There are jobs that aren't available to you without it and you'll be passed over for jobs all the time in favor of someone with your experience level and a degree. Can you have a successful career without one? Definitely. That path might be a little shorter/easier if you complete your degree. I'll also say that I'm ultimately glad I finished. I have found a lit of what seemed not with knowing at the time pretty useful in the course of my career. I'm a better engineer because of it.
Degree is not so important. Honestly, if you know how to write a for loop you're actually above 20% of the people recruiters refer to us. A healthy interest in algorithms and continually learning doesn't hurt though.
I researched and bought recommended books. I read them and learned. Over the years I applied the information and slowly it became internalized. 
I took a two year break and worked, and went back to finish my last year of schooling. I was in a similar situation, albeit having more than 12 credit hours - I couldn't leave an unfinished task being so close to the end. I don't regret finishing, I think it would have loomed over me for a long time to have spent so much time, energy and money trying to earn a degree I was so close to getting. 12 credit hours is nothing. Finish. It'll look better to employers than "Eh, I gave up and moved on to other things". That being said, I understand burnout as I've experienced it myself. Take a break for a while, see where your ideas take you, but make yourself go back and finish eventually. 
no
Way to go.
I believe that anyone is capable of doing the same. All it takes is time and determination.
Just because you didn't / don't notice the stigma where you are doesn't mean there isn't one - there certainly still is.
I'm gonna throw my two cents in here. A lot of people here are saying "no" you do not need a degree. Technically they are right. 99% of web dev jobs wont require you to know a lot of what's covered when earning a CS degree. Having said that, there are a lot of web devs out there and jobs can be competitive. Not having a degree can be a hindrance. I know this because I don't have a degree and it has been a problem for me. Fortunately I have sorted it out so I know it can be done but it's not a simple as "write great code and someone will hire you." PM me if you'd like to know more about my personal details.
Ha, I just hit this issue again last night. I don't use heredocs in ruby all that often, but I do use them in bash regularly. In bash, the stripping is automatic, so this is something that trips me up every time I do use them. It seems, based on my google searches last night, that people have been complaining about it as far back as 2006. It'd be nice if core would change the implementation so you didn't have to require active_support or add an ugly gsub method.
Yeah it would be awesome if it just natively stripped out leading whitespace. But that's probably not going to happen given how long it's been this way. The method could potentially get moved to core, though, if it's deemed useful enough. I think there are a number of methods that started in ActiveSupport and were included in Ruby 1.9 natively.
Sure, there is precedence to consider. One way it could be added would be to add another ending modifier; say '+' or '=' to play off of '-'. That should make everyone happy. When looking into heredocs last night, I learned something else that was interesting. You can modify your heredoc to be a single quoted string by encapsulating the indentifier (ex &lt;&lt;- 'HEREDOC'). Or, you can send it to Kernel#` with backticks (ex: &lt;&lt;- `HEREDOC`). Pretty cool stuff, however I don't have much use for them. http://www.ruby-doc.org/core-2.1.1/doc/syntax/literals_rdoc.html#label-Here+Documents
You might compare this to 'homesick' https://github.com/technicalpickles/homesick
Puma puma puma!
i use rcm from thoughtbot https://github.com/thoughtbot/rcm it's very simple
Not in the moment. Is that an issue?
Depends on where you want to live. In Phoenix, I survived many years without a degree, but I grew up in technology and have a strong command of Unix and did php for a long time. In the Bay Area, however, where it's fiercely more competitive and demanding, the 24-year-old kid interviewing you is going to use the same qualifiers to filter you out that they used in academia. They're going to ask you what algorithms you've worked with even tho it rarely comes up with a lot of jobs. I have had to try all sorts of nonsense with binary trees and various sorting algorithms on a whiteboard even tho they KNOW you'll never need any of it as a rails programmer. The interviewers for these sorts of positions mostly did Java in college and they think like Java programmers with Java paradigms like linked lists. Other things you would learn in college, like efficiency in algorithm design and Big O notation do come up and are very useful. Even at my job today, academic papers come through all the time and we have weekly reading nights.
In the sense that I'm not going to sign up for a mailing list in order to see your content, yes.
I feel sorry about that. You can read the rest of the posts on my blog though without signing up on the mailing list: http://www.rubytutorial.io/
sababa!
stupid question but, you did take out the dollar signs when you typed that out right?
This guide seems like its for configuring an already existing ST2 installation. I suggest going to http://www.sublimetext.com/2 and installing it first
you really don't see anything to do with Ruby? hint: you can solve the puzzles in Ruby
First, as a rule *NIX commands will report nothing if they succeed, and an error if they do not. So the fact that nothing came back on the terminal means the command was executed, it just might not have done what you wanted. Second, you should be inputting exactly the following, hitting "Enter" after each line: cd /tmp git clone https://github.com/mhartl/rails_tutorial_sublime_text.git cp -r rails_tutorial_sublime_text/* ~/LibraryApplication\ Support/Sublime\ Text\ 2/Packages/User/ In what you wrote above, aside from the "$" that you shouldn't be typing, you appeared to have an extra "\" between the arguments to cp. For these commands to work, of course, you must have already installed Sublime Text 2, and git.
wow really not bad, i will play with it too, but the interface of codewars is more fun. When i will achieve mastery in codewars i will switch to exercism. THANK YOU FOR SHARING!!
Yes, lol. The first thing I get it just a typical usage: cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source_file target_file cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source_file ... target_directory in terminal. So I write the following instead cp -R rails_tutorial_sublime_text/* ../Library/Application\ Support/Sublime\ Text\ 2/Packages/User/ but that doesn't work either. I'm not terminal line expert, but is that not the way to do it? I'm currently in my /usr/temp directory. Aka /johndoe/tmp. I want these files copied into /johndoe/library/application\ support my file to be copied is in /johndoe/tmp I'm in /tmp already, we for there using the first command of the 3. Essentially what I'm doing is cp -r rails_tutorial_sublime_text/* ../Library/ But it doesn't take. Any ideas?
I installed ST2 first, but I suppose the directory is not where this expects it to be. Hmm. I'm pretty much a MAC noon. When I go into Applications, how can I check where ST2 is installed? 
I noticed that too, and took out the extra \. I still get the "usage" explanation in terminal afterwards. I also tried replacing the ~ with .. to no avail either.
So, I installed Sublime and there is no Application Support/Sublime Text 2 directory. Do you have that directory? What happens when you: ls /Library/Application\ Support/ is it listed? I dont use sublime, so I wont be much help
Oops, assuming you're on a new-ish machine use "cp -R" not "cp -r".
Tried that one too. After looking at the next step in the guide, it appears my issue is that application support/sublime text 2 does not exist and it should. The next step is also expecting that directory to exist and yet it does not. I have no idea how to get it there properly.
Yeah, same issue. The directory doesn't exist, and the entire setup guide is based on the premise that it does. It must be created somewhere though. I'm a mac noob. How can I find out where the Sublime Text 2/Packages/User directory is?
ha, I found it try: cp -R rails_tutorial_sublime_text/* ~/Library/Application\ Support/Sublime\ Text\ 2/Packages/User/ The '~' stand for home. You were using '..' which is previous dir. 
In the menu... Sublime Text 2 -&gt; Preferences -&gt; Browse Packages
I'm a non-CS graduate, actually a Chem. Engg. dropout, which sucks. Just got my degree in a non-CS major. I've gone through 2 interviews, they were semi-favorable (I don't want to assume lol). They checked my Github. Asked me to code a Rails app on a time limit. Asked me what I thought about Rails and its strengths and weaknesses. Nothing about my degree. Basically how to get better? What Sohailk said. For me it was 8-12 hours a day (my internship) for the past 6 months. When I was tired of coding I read books. When I was tired of reading I listened to Giant Robots and Ruby Rogues. The mistake I had was to not to reach out to other people whenever I had a place where I was stuck. My suggestion is, just ask someone for help whenever you've been stuck on somewhere for a while (I set a 30 minute time limit before I make the rounds on StackOverflow/chat). Find a Ruby friend so you have someone to talk to and you have mindshare. Also, "mechanics", in my case I sped up by memorizing some of the common patterns that a Rails developer does. For example I always forget if rails generate model needs a plural or a singular noun. (It's singular). Falling in love with the editor (I shifted from Netbeans (yuck) -&gt; Sublime -&gt; Vim) that I'm using. Watching how pros work via their screencasts. [Check this article out](https://medium.com/how-i-learned-ruby-rails/e08c94e2a51e).
My university actually offers a full stack web dev course, with Rails, EmberJS, Angular, Coffeescript, etc. For the most part you're right, though.
Wow, well this is extremely weird. So when I do that, it's in Library/Application\ Support/Sublime\ Text\ 2/ However, when I try to navigate there from Terminal... it doesn't exist. How can that be? Even ls -a doesn't show it, but I can see it in Finder. :/ I dont' get it. 
In that case your path is wrong again, you are looking for: ~/Library/Application\ Support/Sublime\ Text\ 2/Packages/User/ If *that* folder isn't there, then something went wrong with your installation of Sublime Text 2.
Found it. It turns out it was just MAX hiding things on me, and I had to turn off the hide setting in terminal. Not only that but I had to relaunch terminal and finder. Even an ls -a wasn't working until I changed the setting. defaults write com.apple.Finder AppleShowAllFiles YES (there was another one like this for terminal)
but seriously - tough love is good. After reading these responses, I'm going to stick around and finish. I just hate it. I hate that I have to get another piece of paper to show that I can do the work, when earning that paper is actually slowing down my learning process. If I didn't already have 2 damn worthless degrees and a fucking masters (big mistake, whatever), I wouldn't feel like the CS degree was so worthless. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Core War**](http://en.wikipedia.org/wiki/Core%20War): [](#sfw) --- &gt; &gt;___Core War___ is a [programming game](http://en.wikipedia.org/wiki/Programming_game) created by D. G. Jones and [A. K. Dewdney](http://en.wikipedia.org/wiki/A._K._Dewdney) in which two or more battle programs (called "warriors") compete for control of a [virtual computer](http://en.wikipedia.org/wiki/Virtual_machine). These battle programs are written in an abstract [assembly language](http://en.wikipedia.org/wiki/Assembly_language) called *Redcode*. &gt;At the beginning of a game, each battle program is loaded into memory at a random location, after which each program executes one instruction in turn. The object of the game is to cause the processes of opposing programs to terminate (which happens if they execute an invalid instruction), leaving the victorious program in sole possession of the machine. &gt;==== &gt;[**Image**](http://i.imgur.com/C3Ne6Yc.png) [^(i)](http://commons.wikimedia.org/wiki/File:Core_War_PMars_Screenshot.png) --- ^Interesting: [^Kamen ^Rider ^× ^Kamen ^Rider ^OOO ^&amp; ^W ^Featuring ^Skull: ^Movie ^War ^Core](http://en.wikipedia.org/wiki/Kamen_Rider_%C3%97_Kamen_Rider_OOO_%26_W_Featuring_Skull:_Movie_War_Core) ^| [^Programming ^game](http://en.wikipedia.org/wiki/Programming_game) ^| [^Victor ^A. ^Vyssotsky](http://en.wikipedia.org/wiki/Victor_A._Vyssotsky) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cgjeomp) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cgjeomp)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
skimmed the article, looks interesting. I like his insistence on books - one reason to stay in school has been the Inter Library Loan - Rails 3 Way, Elegant Ruby...all for free!
Shh, you're lowering recruiting standards! :)
Puma is not going to solve the garbage collection issue. Ruby's garbage collector is stop-the-world. When the GC runs, all threads are paused. Puma also does not support out-of-band garbage collection like Unicorn and Phusion Passenger do. It's a bit hard in Puma's case because anything it does out-of-band can affect other concurrently running threads. On the other hand, Phusion Passenger *does* provide out-of-band garbage collection, even for multithreaded apps, in its Enterprise edition. It does this by managing the threads in an intelligent way, waiting until all threads finish their requests, spawn another process if necessary to take over the traffic, and *then* runs the GC on the original process. Even in the open source edition, Phusion Passenger's out-of-band garbage collector avoids starvation situations, which Unicorn could suffer from. In Unicorn it's possible that all processes happen to be running out-of-band GC at the same time. Phusion Passenger actively avoids this situation by ensuring that only one process at a time is running the out-of-band GC. There is also work on the way to make out-of-band garbage collection in Phusion Passenger better by integrating into Aman Gupta's garbage collection work. See https://news.ycombinator.com/item?id=7488578
I use Chris Pine's book to teach newbies in my job, all of whom have zero programming experience. It's a great book, and it teaches good habits (not to mention the Ruby way) right from the get-go. It's a great place to start. Once you've completed everything up to blocks and procs, I'd give this site a shot: https://rubymonk.com/ It's quite thorough, and if you've got a grasp of the basics, you'll get it quickly. Don't be afraid to Google and bookmark all of the ruby doc! Here are two reference sites that are invaluable: 1. [Omniref](http://www.omniref.com/) -- quicksearch for all standard Ruby documentation. Unbelievably useful. 1. [Rubular](http://rubular.com/) -- test regular expressions, it's... awesome. And if you have any questions, post them over at /r/askruby! Good luck!
Okay so you're approaching this in exactly the right way. I was a c# programmer for years and decided to try and learn rails before I'd done any ruby - big mistake. That said, ruby is one of the most inviting and natural feeling languages to code in so it's a great place to start. Picking up the basics of ruby is actually not too tough - your average rails book will typically contain at least a chapter on "basic ruby" to act as either a refresher or an introduction to the basic syntax. Some of the concepts such as OO programming (classes and such) are more general programming concepts and you might find that many ruby books will assume knowledge of that. In reality these skills are of the "easy to learn, lifetime to master" type ilk and the best way to learn those is is practice and patience. Anyway on to your question: I started with this book: http://peterc.org/beginningruby/ Then moved on to this book: http://designpatternsinruby.com/ The first book was really good but you only really need the first half of it. The latter half I found really interesting but it's largely a walk through some of the features of teh ruby standard library along with one or two gems. The second book was incredible and is very useful for learning not only ruby but the principles of coding. The other advice I'd give you is just to fire up irb and mess around. It won't take you long to get the hang of. Also don't forget there is a wealth of information online as well as tools to help you practice such as the excellent CodeWars: http://www.codewars.com/about Good luck!
Can I ask what some of the specific frustrations you're experiencing with Chris Pine's book are? Maybe you just need a few pointers to help you get unstuck rather than a new path. One of the blessings and curses of Ruby is the "there's more than one way to do things" mentality. It leads to lots of cool experimentation and breakthroughs, but can be overwhelming to beginners. The Ruby community is almost always happy to help in my experience!
I don't put leading whitespace in a heredoc unless it is needed so I don't have to strip it back out.
There's also a String#undent method in Homebrew that I use in projects https://github.com/Homebrew/homebrew/blob/master/Library/Homebrew/extend/string.rb#L2
Do you have a Computer Science background? If not, then you might find this [book](http://www.amazon.com/Computer-Science-Programming-Basics-Ruby/dp/1449355978/ref=sr_1_1?ie=UTF8&amp;qid=1396570187&amp;sr=8-1&amp;keywords=ruby+computer+science) useful
How about [tryruby.org](http://tryruby.org)?
Books and videos are great, but nothing beats running your questions by another human, or pairing with another ruby developer to learn IMHO e.g http://www.pairprogramwith.me/
Ruby Koans
Dude, I feel you 100%. It is seriously fucking aggravating and you hit the nail on the head: earning a paper to show you can do the work is detracting from you actually learning how to do the work. But it's a billboard that people can glance at instead of having to pore through your fine print. You can do it, crush it!
What do you do when you get stuck though, especially in algos? Do you ask people IRL?
I started learning ruby and rails recently and here are some of my recommendations not currently mentioned: For ruby check out: * codeacademy - this is a pretty linear and rote approach, but it will help familiarize yourself with basic programming constructs (classes, methods, objects, etc). * rubywarrior. This is a game that requires using programming/ruby language. Best to do once you have learned about methods and loops. * codewars.com is another cool tool. This is a great problem oriented way to learn. It presents you with various challenges to attempt - solutions are easily available for reference. This one is better after learning some basic ruby. For rails there are two tutorials that might interest you: * Kehoe. It's something that could be done in a weekend, or over a week (I'd budget 10-20 hours depending on your pace, or more depending on how deep you go into extra reading). This one is $20 though. * [Hartl](http://ruby.railstutorial.org/ruby-on-rails-tutorial-book). You can do this one for free and it goes pretty in depth, very thorough and also covers test driven development if that's your thing. (Sorry for not linking everything, most will be the top results in google). Another thing to consider is that you really don't need to learn ruby then rails strictly in that order. In fact, you might find it helpul and interesting to study both at the same time. It can give a lot of context for what you learn in ruby, and give you a sense of accomplishment by creating stuff in rails. Last thing I will mention about learning rails is that one of the biggest immediate hurdles is getting your environment set up (getting rails and ruby installed). What processor are you running?
Wow. I totally didn't of that. Thanks.
Oh, I didn't realize you were serious. I guess it depends on which computer you care about, the one in your head or the one on your desk. I'd rather the one on my desk work infinitesimally harder so the one in my head doesn't have to. But if you enjoy and find it easy to write and read unindented heredocs than by all means, go nuts.
Since you want to move to rails and web dev, just follow this: http://www.theodinproject.com/courses?ref=home It will teach you html/css, javscript, ruby and rails.
Non programmer, safe to assume not comp sci I think
It does not make the issue less pressing. Using threads does not provide you with a workaround for the problem described in the article. The problem solved by threads is "increasing I/O concurrency* without increasing memory consumption too much". That is a very different problem from the one described in the article, namely "the garbage collector causes pauses and spikey memory usage, and large strings stick around for too long". Those problems are orthogonal from each other, and solving one problem does not make the other problem become smaller. [ * ] = Note that I explicitly state "I/O concurrency", instead of the more general "concurrency". As we all know, MRI has a global interpreter lock so you can't run normal code in parallel. However, MRI unlocks the lock while performing I/O, so multiple threads *can* perform I/O in parallel, just not CPU computation.
A lovely one for us, probably having to recompile ruby...
You should learn some data structure and algorithm theory, you should really get to grips with OOP theory, and as an employer I'm going to probably test you on design patterns. You don't need a degree to get those things, but if you have a degree I know you probably have them. If you don't, I'm going to push you on them. You can learn the lot to undergraduate level with a few weeks intensive study. But the two most important things I look for on hiring somebody are experience on commercial projects and github activity on open source. One of those being really impressive can outweigh a complete lack of the other. Good luck.
If enough people find it useful, a gem could be created to do that. I don't like the fact that it extends String with a method that has a very narrow application. It probably even looks weird if used outside of the context of a heredoc: `42.to_s.strip_heredoc` is nonsense. It would probably be better to have a generic function for removing indentation that takes a string and returns a modified copy, and it could live in a specialized gem. Ruby doesn't quite support a clean modular programming style, so a good practice would be to provide the function with a proper namespace. For example, if the gem is called "indenter", the implementation could be used as `Indenter.strip(str)`. The names are of course made up just now. It's very likely that more appropriate names can be suggested.
It seems like it's just a floating point issue. &gt; t.iso8601(8) =&gt; "2013-11-02T21:27:16.42399999-04:00" BigDecimal is my normal go-to when I need precision or when I'm working with money. It's probably overkill here, but it's another option: &gt; Time.mktime(2013, 11, 2, 21, 27, BigDecimal.new('16.424')).iso8601(3) =&gt; "2013-11-02T21:27:16.424-04:00" I'd probably just round it.
I've gotten a lot of help from [here](https://pine.fm/LearnToProgram/?Chapter=00). Check it out. The author writes in a very simplistic way so everything is easy to understand and the examples are thoroughly gone over. 
Thanks, I think I'm going to use the thoughtbot book. Do you know if the book assumes no prior knowledge to any of this stuff? 
+1 for hartl. The tutorial goes over some basic abilities of rails, then into the ruby language, and then into building a twitter clone from the ground up. A great way to learn and actually see something come to life
Anybody know how to get libyaml 0.1.6 on OS X? I can only find references to 0.1.5.
That's kinda kick-ass.
Sure, I manage an information architecture group in IBM (as part of an acquisition). We use ruby to create a large number of automation tools, and we're working with rails to deploy content and content tools. 
I usually search here for what I need: http://jsdb.io
My copywriters have a basic understanding of all tags that have to do with "copy style" related elements (h1, h2, p, a). Before I ever got the job here they were including them in their copy docs to help give devs a good roadmap for page structure based solely on copy. I don't want to train anyone I just wanted to change one small portion of the already existing scheme(which was just moving the tag to the same line as copy it is associated with so i can do a line_each block.) By changing one item of the system they used I am not "disrupting" what they do very well already, which is write great copy and keep the copy doc neat and organized the way they know how, not have to worry about closing tags or proper markup or if they are writing HTML properly. When I thought about how I would explain a UL or an OL, hell even an IMG tag to a copywriter I could already see the darkness I would have to dive into. Also I am not requiring them to close the tag, just to provide it at the beginning of the copy. For things like bolding portions of text or adding inline text links that I still handle the old fashioned way by using the visual instructions from the .docx. The .docx is included because that is how I receive my copy from my writers and I include it to help others understand the flow of how I use this tool. The readme does give instructions to indeed change the .doc to a .txt so that Ruby can read the file naturally. I feel like i can skip the whole convert to .txt portion of this tool by using the WIN32OLE library that comes standard with RUBY but that means wherever I run the tool I must be on a windows comp not the hardest problem to solve but just too much extra stuff. Always looking for ideas please help and thank you for your comment. 
I used the official documentation and the template described in this post: http://stackoverflow.com/a/5030173.
Sinatra is so simple that you can pretty much just read the official documentation.
&gt; When should I use a Set in Ruby? When I want *collection.include?(element)* in *O(1)* and not *O(n)*
Not just 'in ruby' either, this is basically just the definition of a set
It would help if you provided a link to it.
I wrote a blogpost on Multi Language blogs &amp; static websites, any feedback is greatly appreciated!
Thank you for reading this! I reposted here: http://www.reddit.com/r/ruby/comments/22824k/multi_language_blogs_or_static_websites/ And deleted this post.
Another gotcha not mentioned, is Set actually uses Hash under the hood, where every element is used as a key. Thus every element in your Set will be frozen. If later you wish to modify the entries, you will have to dup them.
The classic set implementation uses a hash table to back it which allows for O(1) key checking
I highly recommend building a few simple apps. You will struggle, google, read the docs and you'll get it. Nothing ever has taught me better than doing and struggling and figuring things out. So what do you want to build? Start super simple. 
I did a whole series of Sinatra videos for MetaCasts.tv, so I would recommend those. http://www.metacasts.tv/?keywords=Sinatra
I'm afraid the command line will be mostly unavoidable. I suggest you get comfortable using that first. You will see it makes a lot of sense. For installing, have a look at rvm or rbenv. The sidebar here links to rvm (https://rvm.io/)
After the tutorial on the official site, this helped as a next step. Four parts that all help conquer a nice little musicbox. http://code.tutsplus.com/tutorials/singing-with-sinatra--net-18965
Yup ;) 
That course is worth its weight in gold.. times 10.. then with diamonds sprinkled on top. 
Everyone gets burned out on school. Everyone. Fight through it, because your job will burn you out many times too.
Hey man, I learned Ruby via Sinatra too. Basically what you want to do is to iterate on what you are learning. First, set up a Git repository to keep track of the changes and you can put your code on Github, and you can ask people to rate your code. Then, code the iterations of the site. In my case, I rewrote a PHP app that I did. Iterations were: - render static pages - have some semblance of routing - add basic cutesy CSS - add a database of one table (used DataMapper for this part) - add a connecting table to the first table - add more CSS via Twitter Bootstrap/bourbon.io - add sessions for log in/log out - add javascript/jquery for cutesy stuff - add ajax - add reports via Prawn
Ruby clearly doesn't use a classic hash table because it maintains ordering in 1.9+.
Hash Table + array would be my guess or a stable hashing alg. 
Why does this have anything to do with Ruby?
You can do that without a(n order of magnitude) performance impact, it just costs extra memory.
I am struggling to see the advantage that this provides over coffeescript, syntactically or otherwise.
just for reference... https://github.com/ruby/ruby/blob/trunk/lib/set.rb#L205
To be perfectly honest, I think JS was hastily constructed in order to perform its specific role - I'm not entirely sure if what we're using it for now is what it was originally used for. That being said, it follows that we may be defining the core of the language as something else than what it was originally. Changing the core of the language while still maintaining a close relationship with the codebase is difficult. When creating an abstraction language, it has to be decided whether or not the target language would require runtime libraries for the compiled code to work - I believe Opal, a project designed to compile ruby to javascript, has this. It also has to be decided if code written within the abstraction language will interface easily with code in the target language. My decisions in this lead to liquidscript having the property of seeming to 'cover up' javascript's failures. To be perfectly honest, that is the only way to make liquidscript run without runtime libraries, and to make it easily interface the tsrget language.
Yes. https://github.com/rubysl/rubysl-set/blob/2.0/lib/rubysl/set/set.rb#L68 
Actually it's [hash table + doubly linked list](http://www.igvita.com/2009/02/04/ruby-19-internals-ordered-hash/).
O(log N) doesn't tell you anything about how fast it is, just how the fastness scales as N approaches infinity. It's perfectly possible for O(log N) to be faster than O(1) in practice, especially if you factor in worst case behaviours.
I'd ditch anything heroku related in the start. Just gem install rails and learn it locally with eg rails casts. Gui wise : git has a gui and ruby mine might help for that too however learning the command line way is the "right way". Note don't miss out on pry if u learning ruby too.
Look at gems like [tr8n](https://github.com/berk/tr8n). 
Can't really recommend anything better than http://ruby.railstutorial.org/ruby-on-rails-tutorial-book
Not if you have done proper maintenance on your hash table and resized it way before it was getting full. Yes, resize is not free, but it doesn't happen on lookup. 
 @money = @money.to_i this code looks ridiculous, isn't it? :( but i need to safely check whether the format is correct or not... via begin rescue above this code
I've successfully used [Transifex](https://www.transifex.com). When the app updates, upload the YAML file. Translators then work in a web environment, and you can export the resulting YAML when they're done. I was able to use it for free as an open-source project, but commercial projects require [a bit more cash](https://www.transifex.com/plans/).
www.localeapp.com Pretty great, free up to 500 "words"
MRI certainly doesn't do anything magic to offset the cost of hash resizes on insert, but that's not the O(n) I was thinking of. Hash tables degrade to linked lists when key hashes all map to the same bucket, and this can be a [target for denial of service attacks](http://static.usenix.org/event/sec03/tech/full_papers/home/staff/alex/export/twycross/crosby/crosby_html/) if you're not careful to randomise your hash functions. Demo: class Foo; def hash() 1 end; end 50_000.times.inject({}) {|h| h[Foo.new] = 1;h } This takes 90 seconds to run on my relatively beefy home server.
I would suggest putting checks to separate methods. If you can't initialize instance in case of bad argument, only then you should check the argument in initializer. What I would do: - Keep the integer check in initializer. Raise error if value is not integer. You can't use the class anyway without correct money format, so there is no reason to fail without error. Or keep `try` in if you want it the other way. - Store value in instance variable only if it is integer. - Make method `in_range?` which checks if value (now validated so you don't have to worry about that) is in correct range and returns true and false. It would look like this: class MoneyStorage attr_accessor :value def initialize money @value = Integer money end def in_range? @value &gt; 100000 and @value &lt; 3000000 end end This allows you to reuse the class for other purposes, yet keeps all the functionality you need. You can use it then like this: [6] pry(main)&gt; money = MoneyStorage.new("foo") ArgumentError: invalid value for Integer(): "foo" from (pry):8:in `Integer' [7] pry(main)&gt; money = MoneyStorage.new("123") =&gt; #&lt;MoneyStorage:0x007ffd22fabcf8 @value=123&gt; [8] pry(main)&gt; money.value =&gt; 123 [9] pry(main)&gt; money.in_range? =&gt; false [10] pry(main)&gt; money.value = 350000 =&gt; 350000 [11] pry(main)&gt; money.in_range? =&gt; true [12] pry(main)&gt;
So should @money only be integers? no fixnums? Anyways, I'd do it like [this](https://gist.github.com/anonymous/9993472#comment-1206096) 
You can use [i18n-active_record](https://github.com/svenfuchs/i18n-active_record) to create your own frontend (in addition to the other solutions listed above).
What semicolons? Edit: If I may even point out, the scanner doesn't even recognize a semicolon as a proper token, and will error before even making it to the parser.
My take on it: https://gist.github.com/anonymous/9996702 Money should not be an integer (float isn't great either but it's a step in the right direction). If you pass a non numeric, it will raise out on it's own and the caller should be expected to handle that. You can check if it's valid easily, and you can add some messages/raises to the private methods if you'd like. Depends on the contract you want
Integer is a much better representation of money than float for most applications (unless you are dealing with small fractions of cents). Floats should only be used for approximations of real numbers. Anything where you expect to have only small denominators (in this case 1/100) should use integer as the underlying storage.
This code is not ridiculous at all, and is fairly idiomatic. Better would be: def initialize(money) @money = money.to_i end In ruby, less emphasis is placed on type checking. Type coercion is usually preferable. Consider: @accounts = [] CSV.read(file, :headers =&gt; true) do |account_id, balance| # balance is a string # but MoneyStorage doesn't care as long as it can be converted @accounts[account_id] = MoneyStorage.new(balance) end 
https://github.com/medcat/liquid-site Fixed, thank you.
&gt; https://github.com/medcat/liquid-site lol dude, what's up with that readme! :)
In ruby 1.9+ hashes maintain ordering based on insertion order, http://www.igvita.com/2009/02/04/ruby-19-internals-ordered-hash/
I don't think your example is a good one for type coercion. &gt; # but MoneyStorage doesn't care as long as it can be converted `"garbage"` can actually *not* be converted to a natural number. Ruby just happens to arbitrarily return `0` from `"garbage".to_i`. But you never want to import garbage, so raising an `ArgumentError` is the correct way to handle this case. Even more so when dealing with money. I hope no one in the real world uses `String#to_i` in this case.
I'm kinda confused over all this 'javascript syntax sugar' languages. Basically I think that if there is such thing as Dart (https://www.dartlang.org) (types, oop, cool modules and stuff out of the box), there is no need for this or any other newcomers languages in "let's make another JS syntax sugar" hype train.
First, [see this comment](http://www.reddit.com/r/ruby/comments/228xj7/liquidscript_a_new_language_for_the_web/cgklrp9). Secondly, from my understanding of Dart, there is a heavy runtime library that dart requires - something that I'm not entirely comfortable with, especially considering the movement towards compressing everything and small javascript files. If Dart was supported, as a strong language, by every browser, without a runtime library, then I'd say "go use it" - but Dart, I'm pretty sure, compiles to javascript, requires a runtime library, and does some freaky stuff that I wasn't comfortable with putting in Liquidscript. To be perfectly honest, the tool that is used is up to the developer - the "JS syntax sugar" hype train isn't really a hype train. I created Liquidscript because I wanted a tool that I was comfortable working with. I am also planning on allowing Liquidscript become another language entirely separate from Javascript (i.e., not compile to Javascript), but that's still something I'd have to decide if I want to do or not.
I actually don't use CS since the only part of coding that really bums me out is debugging, which is harder in coffee. But, I'm thinking I might give this a whirl.
2.1Ghz hexcore Westmere Xeon - it's relatively beefy next to most home servers ;) Oddly it takes 280 seconds with Ruby 2.1 built from FreeBSD ports as opposed to RVM, kind of weird given 2.0 is fine. &gt; I was curious how bad the penalty for such a stupid hash function is, so I removed it Even ostensibly sensible hash functions can exhibit similar behaviour in face of an attacker who can predict them - note `ruby -e 'p 1.hash'` changes every time you run it nowadays. &gt; 0.25s when not overriding hash. And O(n) isn't even that bad as far as worst-cases can get. I expect everyone who's written a quicksort has seen it shoot off to O(n^2) at some point, despite it usually being one of the fastest approaches.
thanks...
good point... i will consider this too
what is the difference between integers and fixnums? there is no such fixnums in java or C# :p
I never had any issues debugging CS, it's just JS. Also, with sourcesmaps you can debug better.
I would say: get skilled with Javascript anyway, if you are looking for a way not to write it..
I discovered Opal a month ago. After six hours of "fucking around", I transitioned our front-end from CoffeeScript to Opal, and haven't regretted a minute of it. Opal isn't worth it if you're just connecting a few effects on a page. The gains are apparent when with larger client-side codebases. If you've got 2000+ lines of CoffeeScript or Javascript, and just aren't feeling it, Opal is worth looking into. If you're registering a few onload handlers, don't bother. CoffeeScript solves the "bad syntax" problem of Javascript, but Ruby's object model is just stronger. `method_missing`, `instance_exec`, modules, etc. I was actually surprised by *how much* worked in Opal. If your front-end code is significant enough for you to miss these, as a Rubyist, Opal's got em. You will run into bugs and unimplemented areas. I've been [contributing fixes to Opal as I go](https://github.com/opal/opal/issues/created_by/mieko), and even with days (total) I've spent fixing Opal instead of working around limitations by modifying my code, it's definitely been a win. The core developers are smart, the compiler is written in Ruby, and I had submitted significant pull requests in a day. They're test-oriented, and shortening the list of failing rubyspecs is a priority. A Ruby to Javascript compiler is, by nature, a large task, and the core team is small. If you've got a good grip on Ruby, Javascript, and compilers, it's a really fun project to hack on.
This is dead-on, particularly at the level of maturity Opal is at now. Opal can bring significant gains, but there's no replacement for having a real understanding of Javascript. I think this is even *more* true when using a cross-compiler.
For learning Ruby with people critiquing your code, I'd like to recommend this site: http://exercism.io/ I think you'll enjoy it quite a bit.
Evaluating it in a couple of projects now; we love what we see so far. We've been burnt very badly by CoffeeScript over the past couple of years; "It's Just JavaScript" — except when it isn't. Now that there are multiple implementations with different sets of issues, it's even more "fun". Opal is JavaScript written as a decently large subset of *Ruby*; we're far more productive in it than in CS (or raw JS). The one advantage both implementations of CoffeeScript have over Opal is that the underlying JavaScript does tend to be much easier to relate to your original code. If your JS skills aren't up to snuff, neither Opal nor CS is going to save you. If you *do* have both Ruby and JS skills, however, you'll probably wonder why it took you so long to get into Opal.
Aaah, you're right, it will redefine it. Momentary lapse, the public method would need to be called something else. You're also seem to be right about it not supporting private methods (I tried something similar to your code), which makes it something that I would hesitate to use. As for the reason of using private accessors/readers/writers: You get to provide a minimal public interface of the class (by making them private), while still internally providing a way to read/manipulate the instance variables while not evaluating them directly.
I've had issues. It may be just JS, but there's a big difference between looking at expanded form javascript that *resembles* the coffeescript you wrote, and debugging your coffeescript. There is a tangible cognitive overhead to debugging javascript that you originally wrote in coffeescript.
Private attr_readers are useful to abstract away the instance variable, which you might be grateful for if you a) want to expose it later, and/or b) leave space to drop in more logic than a simple ivar lookup. I do come across code where the *only* instance variable references are in the constructor, and everything else goes through attr_* methods. I quite like the style, to be honest, but I don't stick to it rigidly.
I used CS on a couple of small projects and you have two files to debug instead of one.
For everyone saying 'make your own in_range method', use cover? with a range. examples: (1..10).cover?(1) # =&gt; true (1..10).cover?(9.5) # =&gt; true (1..10).cover?(11) # =&gt; false
Acceptable is rather subjective. Personally, I've never seen ruby code that does this, and I don't see an obvious gain doing this in a simple comparison. If you were using lazy enumerations, then I could easily see an argument for this.
The concept of Infinity seems to only exist for BigDecimal objects. So, e.g.: irb(main):001:0&gt; 1/0 ZeroDivisionError: divided by 0 from (irb):1:in `/' from (irb):1 from /usr/local/bin/irb:11:in `&lt;main&gt;' That alone makes me wary of using infinite ranges outside of situations where I have a very good mathematical reason to do so. If you *are* using them in a mathy context where you don't mind being locked into BigDecimals, though, then go nuts.
Why this is preferable to using greater-than? 
In theory, if infinite ranges were supported, you could do this with activerecord: User.where(created_at: (-inf..1.day.ago)).all To grab all users created before yesterday. This would let you *encode* greater than/less than clauses as a `Range`.
`1/0.0`
You need to know about coffeescript source maps for chrome. https://github.com/markbates/coffee-rails-source-maps
Use `Float::INFINITY`, not `1.0/0.0`
Just to add to this, I use them as part of extract method refactors too. It's great that you can (often) pull out a local variable into a method without altering the rest of the method.
Not an incorrect solution, but exceptions should be used for exceptional conditions - mostly errors of some kind. For flow control, ruby offers [catch/throw]( http://www.ruby-doc.org/core-2.1.1/Kernel.html#method-i-catch) for just such cases; it doesn't introduce a complex/expensive backtrace, and additonally shows this is expected behaviour. Edit: I've seen often that examples for exceptions are handling invalid user input. This, I believe, originates from languages which do not differentiate the 2 cases (don't have the catch/throw concept, only exceptions), but especially in ruby exceptions should be only used to recover from "system" errors.
I don't want to sound like a complete jerk, but I mostly hear that from people who haven't spent a lot of time with it. I mean, how much harder is it? You can still use a debugger in a browser and figure out pretty much where your stuff is breaking. I would like to hear more concrete examples of it being more difficult to work with/debug. If you are still stymied on such things, feel free and pm me for a screen hero or tmux pairing sometime. 
Very cool project, but I already get uncomfortable with how much of JS is hidden by CS implementation, so I don't think I'd use this in a project soon.
&gt; I mostly hear that from people who haven't spent a lot of time with it That's fair since I haven't. But I've also never really seen the point. Especially since it makes the part of coding that I enjoy (writing logic) only slightly easier. And it makes the part of coding I hate (the debugging) a bit harder. The cost benefit of getting used to it doesn't really add up. But that's just my opinion. A lot of people like it. It's great that there are so many tools out there for devs that people can find their niches.
Fantastic! Thanks for this. 
That's my style and I preach it to the high heavens any chance I get. It's much more refactor friendly when things are already referencing methods instead of instance variables. Instance variables, even inside of your own instance, are implementation details of state.
Side note: You generally don't want Range#include? -- you want Range#cover? #include? checks each value; #cover just does x &gt;= start and x &lt;= end. Range is special-cased for numeric values so it doesn't matter in this case, but it does with other types, e.g. r = 'a'..'zzzzzzzzzz' r.cover? 'ttttttt' #=&gt; true r.include? 'ttttttt' #=&gt; wait...wait...wait...wait..go to bed...wait... 
Absolutely correct, good point! :)
Read [this](http://brandonhays.com/blog/2014/04/05/letter-to-an-aspiring-developer/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+FluxCapacitor+%28The+Daily+Flux%29)
Hi LaserWolfTurbo72, You can always ask questions on http://forum.thoughtbot.com for any of thoughtbot's books you buy. We use https://github.com/thoughtbot/laptop to set up our laptops for Ruby development. I'm the maintainer of the Mac OS X version. Open a GitHub issue if you have any problems. Cheers, Dan
[This](http://stackoverflow.com/questions/18556955/heroku-config-secret-key-base-error) might help.
You don't want to use [`File.write(token_file, token)`](https://devcenter.heroku.com/articles/read-only-filesystem) on Heroku. Anything configuration related should go to ENV and be set up through `heroku config:set VAR=&lt;value&gt;`. Then you read it from ENV in ruby `secret = ENV.fetch('secret')`. This way you don't have sensitive information in your source control and you can easily change them from environment to environment. Also here is answer to your question on [StackOverflow](http://stackoverflow.com/questions/18556955/heroku-config-secret-key-base-error) If you end up using many ENV variables, I recommend using [dotenv](https://github.com/bkeepers/dotenv) gem to keep them somewhere nice. It allows you to use .env file (which should be in your `.gitignore`) to specify ENV variables easily and automatically loads them from the file in development or test environment.
Good suggestions. I'd also worry about the fact that if you got this code to work, each dyno would have its own secret token, which are used to decrypt session data. If I authenticate or set some session-specific settings, I could get routed through another dyno on the next request and lose my entire session. It wouldn't be fun to be logged out randomly all the time.
A response to the recently submitted article [Ruby Garbage Collection: Still Not Ready for Production](http://www.reddit.com/r/ruby/comments/21lsno/ruby_garbage_collection_still_not_ready_for/).
*2.1.2 :p But a good article with lots of information, more like this please. 
Nah, the article says 2.1 is ready for production... Unless you hit that particular bug, which is unlikely, and either way fixed in 2.1.2.
I hardly knew any of these movies :(
" Front-End development with Ruby" If you are talking about web then "Front-end" is usually HTML / Javascript (Unless you are talking about opal.rb but I doubt that) If not web then you need to be a bit more specific. Post more details if you want to get a decent response.
Generally speaking the Ruby community accepts that a predicate method may return a truthy or falsey value rather than hard `true` or `false`. I'm not sure it's fair to refer to this as a pitfall.
Done, hope that's enough..
I"m assuming an escape?
lookup backslash escape sequences
Yay for progress. Bit disingenuous the tone it takes in the beginning, the referenced blog did indeed find a particularly disastrous bug in 2.1.1 (not sure how often you'd hit it but it mentioned unicorns growing to swap which could presumably be very bad for many people) but it's a comment on that post that gives the incorrect explanation. Good on the author for fixing the problem though.
I don't see how just breaking up the parsing elements into smaller functions means it's "more functional". The only problem was with the `puts` statements. A complete parse method is still just as pure functional: # no side effects, always returns the same output for the same input def parse_timesheet(lines) return lines.map do |line| parsed_line = line.split(",").map(&amp;:strip).tap { |arr| arr[0] = arr[0].split.first }.flatten last, employee_id, office = parsed_line # very readable output end end
Well, while they didn't say it straight out, I think the author was pissed that the guy who wrote Ruby Garbage Collection: Still Not Ready for Production didn't file a bug and just assumed it was a underlying issue in the algorithm. That explains the tone. Hence the bolded please when the author says to file a bug near the end.
I like this approach I use it for string interp with quotes. Might help with your table name. %Q[@variable = '#{x[2]}',] =&gt; " @variable = '2' " @variable is just part of a string I want to print out and the string interpolation must have quotes around it to signify a string. more reading: http://www.dzone.com/snippets/how-display-string-double
What OS are you on? Best bet with ruby is to use rbenv or rvm to manage it. rbenv seems to be the more popular new kid on the block.
I'm on Windows 8. The mess of errors started to appear shortly after I tried to install the dev kit, so I think it has something to do with that.
Use Bundler instead of installing gems using the `gem` command. example: In your Gemfile, you list the gems the app needs. You then `cd` into the app's main directory in the command prompt and run `bundle`. Bundler handles all the mess of installing/updating gems and checking for version compatibility.
Can you be a little bit more explicit about what I need to do? Where exactly do I need to be when I run the bundle command? I'm really convinced my problems have to do with the dev kit at the moment :/
**UPDATE** So I did [this](http://imgur.com/Q1eNlGI), but it only confirms there's something wrong with the devkit. I know I downloaded the right one... maybe it has something to do with the download location. I probably extracted it to my downloads folder like a noob, but I looked for c:/ruby/devkit and didn't see the devkit folder anywhere...
I would strongly suggest installing a VM and running Ubuntu on your windows machine to do ruby development. Ruby web apps run on unix based web servers, and you will save yourself a lot of headaches by developing in an environment that is the same as your app's target environment. Ubuntu or OS X are ideal for developing that kind of software, just as you would want a windows machine if you are writing windows apps. That being said, you should use [bundler](http://bundler.io) to manage the installs of your ruby gems. The fact that it's asking for the uglier gem means that a rails app isn't installed, try running the [$ rails new](http://guides.rubyonrails.org/command_line.html#rails-new) command to build a new rails app. Then you would typically manage the gem installs for that rails app in the gemfile install the gems listed in the gemfile with the bundle command. Hope this helps.
In step 1, I do not have those batch files in c:/ruby200/bin. Everything appears to work up until step 5, where `$gem install json --platform=ruby` gives what appears to be the same error as trying to install uglifier
Thanks for the reply. I think if I went with Ubuntu I'd want to install it on a microSD card and be able to boot from there. I hear 13.04 has nice touch-screen capabilities, which would be nice for my Surface Pro. Do you happen to know how to install Ubuntu on a microSD card so I can boot from there without having to partition my hard drive?
Try a system restart? If you followed the instructions I'm not sure why you're getting the same error.
I am usually against these "yet another blog post on how to do something that has been explained many times before" style posts. However in this case, the author goes into much more detail and has a wider scope than what I have seen in the past so it is worth a read.
Ah. Can't help you there. You should really use a Linux system for developing. Much more suitable.
So you more than doubled the lines of code and still didn't end up with a functional program. 
celluloid, parallel, sucker_punch, peach, various wrappers around akka etc. 
&gt; Popular gems are usually more popular for a reason. And it’ll be much easier to get help if everyone else on the internet is using the same gem. I think it's important to think about what makes a gem popular. In my opinion, some factors include how many different problems it solves (if it covers more use cases, more people will use it), how many contributors it has (the contributors will recommend it), and popularity itself. As popularity is a widespread criteria for selecting a library, once a gem becomes a bit popular then nothing stops it from gaining more and more users. The popularity tendencies are very hard to revert. I think all of those factors I mentioned have no correlation to the quality of the library. If you look at very popular projects, the quality of the code is very poor and there are always 20 or 30 reported bugs. Even if there are lots of users and lots of contributors, big libraries are hard to maintain and hard to use. I see more questions asked about Rails than about any other tool, and it's not because it lacks documentation or community. The activity reported by Ruby Toolbox doesn't reflect the quality of the library either. There are many reasons why a tool would not need any updates, and I agree with you that if the author doesn't care, it's not a good sign in itself, but it's better to find out why there are not updates. There are many feature complete tools that we use everyday, like ls, cp, cat, etc. I would suggest using some other criteria for selecting a library. For example, I would look for tools that do one thing and do it well, and libraries that make good use of resources (use less memory and less CPU, for example).
I have some experience with Celluloid &amp; Akka so I can comment about those. Both are actor model implementations have a different use case than Workers. Workers is a simplified wrapper around threads since in many cases I don't want to use actors. I did implement the Tribe gem (actor model built on top of the Workers gem). One of the main differences between Celluloid and Tribe is the relationship between the actors and threads. Unless things have changed, I believe each Celluloid actor uses a dedicated thread (plus one thread per fiber on JRuby?). Tribe lets you decide if you want to use a dedicated thread per actor, a shared thread pool, or multiple thread pools. In some apps I need in the hundreds of thousands of actors so a 1:1 relationship between actors and threads is a problem. I haven't used Peach or various JRuby wrappers around Akka. In general, I try to avoid being Jruby specific in my apps. Also, I haven't used sucker_punch so I'll have to check that one out. It looks similar to Workers and roughly looks like it was started a year ago also. I don't recall seeing it when I started Workers. Another reason I felt compelled to write this is that I find these sorts of open source projects to be a lot of fun :-) I hope this answers your question. If not, feel free to email me and we can chat further. I'd like to hear more about your experience with the gems you mentioned and what kinds of projects you use them for.
Certainly more readable.
Regarding the likeliness of the bug: we found it via a bug observed in production while doing mundane stuff, so it isn't astronomically unlikely that others might hit it, too. Basically, if you ever make "big" strings in a Rails action, you're susceptible.
This may be a really stupid point/question, but.. you do know to omit app/project specific info from your exception messages when searching, right? You will **always** have the most luck when googling the most generic version of the exception. Start by removing any project-specific variable or method names from the text of the exception. If you still get nothing back, try stripping the line number and filename, and if you're still not having any luck, try **just** the name and the most relevant/generic part of the message. Granted you're still very likely to eventually run into something that no one else has, or at least something that no one else has bothered to ask about or post a solution for, and for that this is a fantastic idea. Like I said, this is a great idea, and I don't mean to downplay it at all, but let's be honest... we engineers like to make a way bigger deal out of debugging than it really is. Sure, it's super annoying, and once in a while you'll run into something that proves to be a major pain in the ass, but f you have a knack for it and know how to follow the stack traces and breadcrumbs in the code you'll rarely run into something where you're flat-out stuck and have no course of action (a patch/fix, submitting a ticket to the offending project, downgrading/upgrading to a stable version, etc.). Edit: spelling
I don't know if they were "pissed", but it's not like we made a conscious choice to do one over the other. We found something interesting in the GC algorithm and we wrote a blog post about it. It turned out to be a bug and not a "feature", but for the susceptible user, does it really matter? The takeaway here is that there's a rather serious bug in the GC algorithm for the 2.1 Ruby interpreters, and that everyone needs to upgrade when the next release comes out. I'd say that's important news.
1. Not `&lt;something&gt;.env` just `.env`. You can have .env.&lt;environment&gt; if you need. ie. `.env.test` 2. I usually keep them out of source control. That is the point of having them. dotenv gem should only be active in development and test environments so there is no reason to push them to production. 3. Yes. Here is sample of one of my files: RAILS_SECRET_KEY_BASE="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" 4. Again example: App::Application.config.secret_key_base = ENV.fetch('RAILS_SECRET_KEY_BASE') { raise "You must specify RAILS_SECRET_KEY_BASE environment variable! Generate one with `rake secret`." } 5. Yes You need to add dotenv-rails gem to your gemfile. See https://github.com/bkeepers/dotenv. Specially section for rails.
It's definitely not a stupid question. This isn't supposed to be searching for app/project specific exceptions -- we're trying to make it easier to find the places in code where error messages actually get raised, instead of just people talking about them in forums or blogs or whatever. Google does a surprisingly bad job of indexing these. If you've got the line number where an exception is raised, you're obviously capable of finding that code yourself. If all you have is a generic exception message, you're in trouble no matter what. But if you have some obscure but specific message, it's usually pretty hard to find relevant code via regular search engines.
Ooh, this looks nice. I have some experience using Celluloid, and found that it was much _more_ than I needed -- which meant it had added complexity, added edge case issues, additional possible bugs, additional possible backwards compat issues accross versions and associated maintenance costs in my own code, etc. I was actually considering going back to using straight Threads myself, but not happy about the things that are kind of tricky to get right with straight Threads. This actually looks like it adds just exactly enough on top of Threads to give me what I actually need for my fairly simple use cases. I look forward to trying it out. Of course, the risk with these things is it will turn out I do need more functionality after all -- or it will turn out that the developers/maintainers/other people need it, or that it's harder than it was thought to get even the basic functionality right, and this project will thus gradually creep toward Celluloid anyway, but always a couple years less mature. 
Been there, done it all on my own. 1-2 how to articles + some gem reverse engineering dissection was all that was needed.
I tried hard to build Workers in layers for exactly the reasons you described. Long story short, I am hopeful that one of these layers will meet your needs. Feel free to email me if you have questions or if you find that your specific use case isn't met by Workers. One thing I can promise is that Workers will not turn into an actor model implementation since I want to keep it lightweight. I built a gem called [Tribe](https://github.com/chadrem/tribe) on top of the Workers gem that implements event driven actors. So long story short, there is no reason to add complexity to the Workers gem since it already exist in a separate project.
I tried installing Virtual Box with the Ubuntu 13.10 .iso file on a microSD card, but it ran *extremely* slow. It seems like my only option is dual boot at this point, and I wanted to avoid that if possible. 
Did you try devoting more resourced to the virtual box? If you set the box to use most of your pcs resources while it's running it should go smoother. 
Why not just use rubocop rather than waiting until the changes have been committed? Surely you want to catch it beforehand.
I know it's pretty popular, but that doesn't mean it's good in my opinion. 
This kicks ass
Thanks. I seem to still be getting the same error. Any idea why? Here is what I did.. 1) In my Gemfile, I added gem 'dotenv-rails', :groups =&gt; [:development, :test] 2) In config/initializers/secret_token.rb, I added... require 'dotenv' . . . MyApp::Application.config.secret_key_base = ENV.fetch('SECRET_KEY_BASE') { raise "You must specify SECRET_KEY_BASE environment variable! Generate one with rake secret." } 3) I created a new file .env in my root directory. In that directory I have... SECRET_KEY_BASE="jhas8f7gjsnsd98u..." 4) In my .gitignore I have added... .env 5) I committed everything, pushed it, pushed it to heroku git add . git commit -m "Added dotenv Gem and the secret key base" git push 6) Finally, I pushed it to Heroku, set the key, and opened my herokuapp URL... git push heroku heroku config:set SECRET_KEY_BASE=jhas8f7gjsnsd98u... #I tried this step with and without quotes heroku open In the end I still see the same error. I must set config.secret_key_base in my apps config. Any ideas? Am I getting some syntax wrong? Do I need to set SECRET_TOKEN on heroku instead of the SECRET_KEY_BASE I've used everywhere? Thanks for any help you can give.
Just in case you forget to run rubocop? If you want a public record of your style history a la coveralls and travis-ci? Not everyone has it as part of their pre-commit hook, and this is a free service for public repos. Why not both? 
I've just integrated Rubocop into my testing rake task. Travis.ci handles it just fine.
What if hound is wrong? For instance, what if I like to omit parenthesis on my method definitions? Not saying this is a problem with hound, it seems like a good tool, but I can imagine being less than enthused to find out the team I just joined uses it aggressively.
This seems like the kind of tool that gets teams excited to impose style guidelines in the first place. On second thought, I think *that* is more concerning.
You can configure it however you like
Because messy broken commits?
Are you sure, the secret_roken.rb file is being run? I don't like this type of debugging and I don't encourage it usually, but you could put something like `puts 'Loading secret'` just above the "MyApp::Application.con....". Then when you push the app to heroku, check logs to see if that line is there. Also you don't need to `require 'dotenv'`. It is required automatically in environments it should be required in.
Directly relating to this: This should happen before you commit (as a client-side checker or smth), or as messages output as a git hook. Somewhat relating to this: I really don't give a flying gazebo about most of the style guide things. Yes, some code violating a lot of it at once will look messy and should be given a quick pass, but honestly, does it matter if I single or double quote strings? What about using method parentheses on a line where a single function call is made? And honestly, unless the line is 250 chars long, my editor can handle it. So can my terminal for diffs. 80 is an unneeded restriction. So whilst I guess this might have value locally, code that I write and commit would probably continuously violate this, yet still be just as readable as code that doesn't. And it'd still work, and I'd feel less frustrated at the 'commit -&gt; check -&gt; it works, but your LINES ARE A LITTLE LONG -&gt; change -&gt; commit -&gt; NOW YOU DONT NEED BRACKETS' (etc). Style guides, so long as the code *works* and doesn't make me want to stab you with a fork, are annoying.
It just annoys me that there are so many gems for the same purpose. All that work goes into a duplication of effort and in the end instead of having one awesome, fast, rock solid, well tested, memory efficient, proven in the field, well documented, suitable for edge cases gem we get a dozen shallow implementations half of which get abandoned in six months. There is a fascination with novelty in the ruby community. Everybody wants to re-invent everything every year. It annoys me. BTW you can use thread pools in celluloid. 
Such is life with free software built in ones spare time. You have the freedom to push your agenda by donating your hours or money to the projects you most care about and I hope you do. I'd certainly love to have more commercial grade Ruby software given to me for free. One question, can you point me at an example demonstrating Celluloid creating say 200k - 1 mil actors that are all backed by a small group of OS threads instead of 1 OS thread per actor? I haven't read/seen such an example and I'd really like to benchmark it. I don't believe Celluloid pools can be used for this, but I could be wrong.
&gt;Such is life with free software built in ones spare time. You have the freedom to push your agenda by donating your hours or money to the projects you most care about and I hope you do. I'd certainly love to have more commercial grade Ruby software given to me for free. I am not saying that you should be forced to do something you don't want to do I am saying I am annoyed that you choose to start a new project instead of spending your time making an existing project better. &gt;One question, can you point me at an example demonstrating Celluloid creating say 200k - 1 mil actors that are all backed by a small group of OS threads instead of 1 OS thread per actor? I can't but maybe they can, you should ask them. Let's presume they can't either though. Why not work on celluloid so that it can? Surely whatever techniques you used could be applied to celluloid right? Furthermore Celluloid has some functionality your code lack right? So the people using Celluloid miss out on the awesome threading code you have and people using your code miss out on the awesome whatever celluloid has. This is my point. If you had helped them we'd have a better celluloid. Instead now we have two gems. Some people will use celluloid and some people will use your gem and both of them will end up missing out on something or another. 
style checking, hmm probably not something I want to actively enforce. Now Code Climate complexity checks etc, hell yes.
this: http://redd.it/21lo40 most rubyists will deny that fact... however.... it's still a fact :)
huh new to ruby, has all the facts.
I meant: irb(main):001:0&gt; require 'rubygems'; require 'ruby-filemagic'; "somestring".mime ... but I assume the result would be the same (missing fm method). By briefly looking at the code this seems justified and I'd say that the gem is just broken and I'm a little surprised that anyone managed to use it.
There is another truth that isn't easy to swallow for most of the ruby community but is the main reason ruby is popular now. Rails. Up until rails started getting big, ruby was just another scripting language in a sea of many hobby scripting languages. It didn't exactly have any strong advantages over any others. It writes really elegant code but it was still slow. I wouldn't say it was unpopular either. Before rails came along gems were being written at a good rate and acceptance was pretty high. It just didn't become a hyped language until much later. The where people doing graphics with it before that like _why the lucky stiff with [Shoes](https://github.com/shoes/shoes) and loads of people using it for system scripts and small web servers (like sinatra but I cant remember the framework name).
You can't possibly be this retarded.
&gt; require 'rubygems'; require 'ruby-filemagic'; "somestring".mime Pretty much the same require 'rubygems'; require 'ruby-filemagic'; "somestring".mime LoadError: no such file to load -- ruby-filemagic from /usr/local/lib/site_ruby/1.8/rubygems/core_ext/kernel_require.rb:55:in `gem_original_require' from /usr/local/lib/site_ruby/1.8/rubygems/core_ext/kernel_require.rb:55:in `require' from (irb):2 from /usr/local/lib/site_ruby/1.8/rubygems/defaults.rb:111 &gt; By briefly looking at the code this seems justified and I'd say that the gem is just broken and I'm a little surprised that anyone managed to use it. Seem a bit odd that it's *broken* as I know of others using `schleuder` with the same install version the required programs and gems to be working.
Perl started in 1987, so it had a head start and was pretty dominant in the Unix scripting world for the next 20 years. And then there was also PHP, not much used for scripting, but it dominated the web world for a long while and still does. It simply took a while for Python and Ruby to catch up and not just be a better languages in theory, but an overall better solution in practice. Also Ruby started in Japan and it can take quite a while for something to make it past the cultural and language barrier. Looking at Google Trends is interesting. Perl has been going down for the last decade. Same with PHP, but it's still bigger then all the other combined. Meanwhile Ruby and Python have not changed all that much in popularity, but Python moved above Perl around ~2007, Ruby matched Perl in 2011. 
1. Most languages take a long time to get popular. Even for the languages which eventually make it big, it's an exponential process... which means a lot of long, slow development with only a relative handful of users, followed by an increasingly speedy rise once they hit a tipping-point. 2. In 1995 the web wasn't even a fraction as big as it is now, and as such most people simply *didn't hear* about new languages, platforms, libraries or programming paradigms. If you don't remember it then it's hard to imagine what life was like before programming blogs, before online documentation, before aggregators like reddit or hackernews, when the best way of learning about new programming ideas was Usenet, and internet access was the preserve almost exclusively of hardcore geeks and research institutions/corporations. 3. Most languages need a specific kick to get popular. C first got popular because it was the language Unix was written in, and therefore that people wrote Unix programs *in*. Javascript first got popular because it was the scripting language of the web. Ruby had nothing similar until Rails came along, and - at least initially - it really rode to mainstream fame and mass-recognition [on Rails' coat-tails](http://www.tiobe.com/index.php/content/paperinfo/tpci/Ruby.html).
You are right. The code is ok. I tested it on my machine and it seems to work ok: 1.9.3-p545 :001 &gt; require 'filemagic'; require 'filemagic/ext'; "string".mime =&gt; "text/plain; charset=us-ascii" 
I don't think that's much of an issue. That being said, I speak/read/write Japanese daily. If a large section of your developers (developers developing Ruby) are Japanese, it makes sense. It's somewhat acceptable for both Americans with US English and Commonwealth folks with English, so what's wrong with Japanese? Don't support another age of colonialism.
Yeah, rails made ruby grow up a little bit--as rails projects started getting deployed in increasingly high-user-based sites (twitter being a canonical example), the developer community uncovered performance issues, and more important, the lack of release discipline of the underlying language. It has taken some time for the ruby language to deal with this, but I believe it has largely been successful. Release discipline has improved. Not all of the community has understood this---witness the complaints when some features destined for ruby 2.0 where excised because it was determined they were incompletely defined. That was good discipline. All in all, I'm happy with ruby and rails. I was a fairly early rails supporter and that's how I came to the language. 
I would say part of the reason is because it was developed in Japan. Not saying that Japanese developers are bad, but the reality is that the language barrier kept it out of the limelight for a while. 
He's a veteran php programmer so probably stupid. I'm also a veteran php programmer and I was really stupid for not leaving php years ago.
grey@x60:~/ruby$ ruby heartbleed.rb -p 80 reddit.com SENDING HELLO heartbleed.rb:47:in `recvmsg': Invalid argument - recvmsg(2) (Errno::EINVAL) from heartbleed.rb:47:in `block in &lt;main&gt;' from heartbleed.rb:44:in `open' from heartbleed.rb:44:in `&lt;main&gt;' 
(Normally SSL listens on port 443.) I'm not seeing this problem. What version of Ruby are you using? $ ruby -v ruby 1.9.3p0 (2011-10-30 revision 33570) [x86_64-linux]
What you will find as you progress through CS as a major is that fundamentals don't often come up in app development. You're going to want to learn to be efficient with an expressive language. Fundamentals aren't so important in common day-to-day work.
 grey@x60:~/ruby$ ruby -v ruby 2.1.1p76 (2014-02-24 revision 45161) [i686-linux] 
Troll, of course. It's a brand new account.
What the solution to the problem was.... [StackOverflow](http://stackoverflow.com/questions/22947724/jruby-warbler-not-creating-usable-executable-jars/) What I had to do was use the command, git add . and this allowed me to add the changes and new files in the gem. Because of how Bundler creates the .gemspec, I had to issue that before Warbler could include it. Then I also had to add in the runtime_dependency for each gem that was used in the gem I was creating. Once that was done, Warbler added those to the JAR, and I was able to run the program without having to have JRuby on the system. I hope that this helps out someone trying to create a JAR using JRuby and Warbler. 
What does expressive mean, and would meteor be considered more expressive than rails? 
A launguage's expressiveness determines how powerful the linguistic features of the language can be. For example, being able to declare a foreach by doing &gt; for( member : struct ) rather than just incrementing indices like so: &gt; for( int i = 0; i &lt; struct.size(); i++ ) is much more expressive. Languages that give you syntax for power are expressive. Some languages, like C, do not offer much in the way of expressiveness, but make up for it in speed and device support. My area is in embedded systems, so I don't get a chance to work much with expressive languages, but from what I've seen of meteor, it seems very nice. I can't advise you on whether to choose it over rails, though. The only advice I can give is to try both and see what floats your boat/business.
Thanks, makes sense. And I have been learning both! Mainly Rails, though, because it seems a much better prospect for finding a webdev job. 
I think the emergence of Rails just ties into the idea that an ecosystem takes time to grow around a language. It's a snowball effect.
There's a lot of competition among programming languages. Once you start creating libraries in one, it can be hard to reuse said libraries in another one. Programmers are picky then. First there was Linux. Then there was Ruby. Then there was the first Pickaxe Ruby book. Then there was Rails. Then there was the Mac that Rails developers used. Programming for the web is one of the most complicated things programmers have had to do. Rails has provided a framework for that building on the dynamic features of the Ruby language. Newer languages than Ruby still haven't been at the same level of flexibility of the dynamic features of Ruby. Only JavaScript is at that level. And we know that some programmers have a hard time taking JavaScript seriously enough. But now Node.JS is a success despite the bullying JavaScript programmers suffer. *wink* :-)
I'm not personally a fan of Rails, but yeah, you can't ignore it's contribution to Ruby. I think Sinatra fits the Ruby philosophy better. (Lightweight, elegant, and no magic "convention over configuration.")
Well, on the one hand, the trend is that web apps are getting more client-heavy, so simply more JavaScript is written. On the other hand, there's a rise of popularity for node.js - you may say it is for JS what Rails is/was for Ruby. But both of those are also a synergy - a lot of developers can easily transition from exclusively frontend to frontend and backend development. And it does make some sense to use the same language for server and client. However node.js is (also like rails - or anything) not a silver bullet; part of this is just hype.
I think Web developers have a skewed view of the world -- not everything revolves around websites. In bioinformatics (my field) people use scripting languages to automate computes on DNA sequence data. When I started in the early 1990s, this was entirely in Perl (and still largely is) People in the field are now slowly moving to Ruby and Python (Although I was an early Ruby bioinformatics user since about 2001), but things like rails are pretty much irrelevant to this -- people just want a nicer scripting language than perl (Although perl 6 wouldn't be bad if it ever was finished; probably its chances have passed by now).
Pretty much entirely because of node.js -- with it Javascript isn't just something interpreted by web browsers but something that can be run server side ala rails or even just as a !# command line script like any other scripting language. It even has a package manager similar to gem.
yeah, rails is top-heavy in ways that I think it shouldn't be yet limited in places where I think it should be more flexible. There's a fine line between "convention over configuration" and "my way or the highway". 
1. Competition (Java, PHP, and Perl were already more popular) 2. No killer use case, like Rails (build any web app, very quickly) 3. Language barrier, though Mats released ruby docs in English in 1998 I think... [edit- 2000 was when Dave Thomas book on Ruby was published, that kind of cleared away the language barrier, so that's a five year headstart for English documented languages). 4. Entrenched adoption. (unpopular opinion, Java devs who spent their whole college life learning Java, just couldn't or didn't/don't want to learn ruby, I have run into this a lot in the last 6 years.)
[Here's](http://blog.jayfields.com/2008/03/ruby-inject.html) a good article on #inject :)
If you find cases where any production-ready Ruby impl is faster than JRuby, you should file a bug. It usually means JRuby's doing something wrong.
There shouldn't be a need to rewrite your entire backend if you simply switch databases. But since you're using ~~Rails~~ ActiveRecord, you probably need to. Well, before I start flaming Rails again, here's the way how I would go about switching databases in a structured way: a) I would wrap your entire database access into a class (read: repository pattern). Something along the lines of: class SQLDatabase def fetch_friends_of_friends_of(user) User.where # ... however this query looks like end def create(record) record.save end end Make sure to go through this layer for every database access in your system (read: replace `User.all` with `DATABASE.fetch_users` in your controllers). b) Write tests for this database layer (this can be done while working on a)) which make claims about the behavior of the outer boundary, e.g. database.create User.new(name: 'chris') expect(database.fetch_users.size).to eq 1 expect(database.fetch_users.first.name).to eq 'chris' c) Build another class called `Neo4jDatabase` and use the exact same tests to drive its implementation. You can use rspec's shared examples in order to avoid duplication. Don't know about minitest. Personally I would stay away from ORMs which try to mimic ActiveRecord's behavior because the mismatch between graph databases and OOP is even bigger than the mismatch between relational databases and OOP. So I'd use whatever gem is available to query neo4j directly: def fetch_friends_of_friends_for(user) Neo4j.query("START n=node(0) RETURN n") end d.1) Now it gets tricky. Since your domain model is so tightly coupled to the database (it inherits from ActiveRecord), there's no easy way to reuse it without breaking a bunch of tests. I would just remove the subclassing and get rid of all ActiveRecord specific methods (e.g. `has_many`). You probably still want to use the same type coercion and default values ActiveRecord provides. Check out `virtus` in this case. d.2) Switch your database somewhere in `application.rb`: DATABASE = Neo4jDatabase.new e) Enjoy your life with a rails application which is decoupled from the database. There are several features which I extremely like about this extra layer: * The interface of your database layer combined with your tests tell you **exactly** what your database needs to be capable of (e.g. get me a list of friends of friends). This makes choosing the proper database and optimizing your queries easier. * It will also make adding persistence related caching a breeze. Just add another class which acts as a proxy to your actual database object and use redis whenever you feel the need to do so. * You can speed up your tests by replacing your application with an in-memory database (which passes all the tests from the database test mentioned in b) of course) during tests.
Wow. Thank you. This is really helpful. Do you know of any example Rails repositories doing something like this(with any NOSQL database)? If not, how would I go about searching for an open-source repository like this? (Because I learn well from examples). Also a little off topic because I'm curious- "before I start flaming Rails again" -what would you prefer using as far as languages/frameworks go?
[Here](https://gist.github.com/anonymous/153c09aad1cbe10ba24d#file-redis_database-rb)'s a repository example for a simple todo application using redis. Internally it's a mess and I'll clean it up someday (I promise!). I don't know about any open source repositories, though. I got most of the ideas from [this blog post](http://hawkins.io/2014/01/pesistence_with_repository_and_query_patterns/) and played around with the interface/different ways to test it until I arrived at that design. Well, rails is a great *web* framework (CSRF protection, powerful router, ...), but not so much a great application framework. This becomes obvious once you try to switch between databases or change authorization gems. This stuff is all over the place. From all web frameworks I like sinatra the most, but still use rails from time to time. Especially if I need to get stuff done fast.
I think the two sayings are the exact same thing just with different connotations. Rails isn't meant to be the best framework for everything web. It's meant to be the best framework for most things web while still having enough flexibility to do almost all things web. Most things web need fast releases, MVPs and robust, well tested code. Most things web don't need infinite scalability with the fastest most eloquent code being applied in every area of the application.
Thank you for the links. I better get started on reading because this sounds like it could be a very time consuming change!
Disastrous GC *regressions* aren't show stoppers. This is why people don't automatically upgrade their core libraries on major releases.
I use faker and watir-webdriver at work for database entry. Works well with cheapo contest entries and Web game automation too if you're into that stuff.
I'm an web automation QA guy, so I spend most of my time with Cucumber, RSpec and Webdriver. I recently started exploring Page Object (Cheezy) and Like quite a bit of it.
Testing: 1. `minitest`: rails ships with minitest 4, minitest 5 is very nice. 1. `minitest-reporters`: for green dots 1. `webmock`: best way I've found to test calling external services Debugging: 1. `pry`: as you mentioned 1. `pry-byebug`: a debugger for pry 1. `pry-stack_explorer`: for moving up and down the stack That's about all I add to stock rails when I get a project started. `jbuilder` and `erb` are just fine for view templates.
If you're willing to ditch joins in the switch to nosql, surely you should be willing to ditch them with SQL. Denormalize. 
"I wouldn't say it wasn't unpopular either" I wouldn't say that you don't dislike not writing in an ass-forwards way
Ahhh, missed the "denormalize" part of your comment. In the name of performance I still believe a graph database is the way to go about this. See: http://java.dzone.com/articles/mysql-vs-neo4j-large-scale
&gt; Denormalize. How would you suggest replacing the join between `users` and `comments` with denormalization? Putting `user_name`, `user_email`, ... into `comments`? That sounds like an extremely bad idea. The raw data which drives your application should be as normalized as possible. Otherwise you'll be in for a pain if requirements change. You can of course put other layers on top of that raw data to help performance. Database views and ElasticSearch comes to mind.
Exactly! Write an ORM for your ORM and flame ActiveRecord because you think it does it wrong, when what you're really doing is switching from a relational model to a non-relational model. Apples != Oranges.
I think if you only have two and three step relations then it doesn't absolutely necessitate making the jump to neo4j. Anyway to truly get the advantage of neo4j you're going to need to write cypher or gremlin queries. Not just use the Rails wrapper gems. I'd suggest using the method Enumerable\_any suggested to abstract your data layer away from the application layer and running as far as you can with that method and getting used to it and its trade-offs. Yes you end up with more extensible apps, but the tradeoff for me is that you have more boilerplate. All the good stuff that you love about Rails is exactly because of the tight coupling that MVC introduces. It's a hell of a lot easier to write an app where you put your database reading objects directly into the view. And write all your domain/application logic directly in your controllers or persistence layer. It's just that these things don't scale up (in terms of legibility and clarity of intent) to large applications. Then when/if you _do_ need to use neo4j it's a relatively painless change that doesn't necessitate a complete re-write with sweeping changes across the app. Speaking from experience, I'd also advise to not use JRuby for a direct connection to the database, because the slow startup time absolutely kills productivity when doing TDD. Rather neography for sending queries over the wire instead. I can understand though, if it's a pet project and you want to learn about neo4j that you still want to make the jump. It's absolutely up to you. I'd just caution you that making the move because you think it will make life easier/better/faster _might_ be a bad judgement. I think you'll also have a significantly marketable skill even if you do only introduce bounds, interactors, presenters, form-backing-objects, decorators etc to a Rails app, and learn about the tradeoffs of these levels of abstraction. If you then go on to find that neo4j is going to speed it up. Then having a real world app with measurable performance characteristics that you can then easily improve by introducing neo4j and making an apples for apples comparison, all because you had a really well de-coupled amazing architecture is going to make for a much better series of blog-posts, interview material, and chats with developers than a completely unqualified "Yeah neo4j is cool, I'm using it in my personal project and it's just tons better than ActiveRecord"
+1 for better_errors and binding_of_caller; really makes dealing with an MVC web framework a lot easier.
Well, it's "correct", just with a bit of unneeded syntax. To make it even 'easier to see', just avoid the funky `inject(0)` syntax altogether, since you don't really need it: (a..b).map { |i| i**3 }.inject(:+) # or `sum` if using rails
chef+vagrant for development is sweet 
Use begin/rescue to catch timeout error and restart monitoring
These days I have all my sites/apps hosted on Heroku, Linode, and Digital Ocean and I find time/costs quickly add up when redis crashes on linode when I'm on vacation or postgres randomly shuts down on digital ocean at 3AM on a Fri night. The beauty of Heroku is that in 1 click you can tie in Papertrail and New Relic to monitor and alert you before an issue becomes and issue and just dial up service as needed. While Heroku may be far from the cheapest I don't think it is fair say they have "pathetic resource limitations for the money". One of the biggest selling points for a PaaS like Heroku is the hassle-free setup and maintenance they offer and (at least to me) that is hands down worth the extra cost. 
If you think you're going to flip-flop between Neo4j and an AR-supported backend, then follow Enumerable_any's advice and write an abstraction layer. If you think you've landed on the winning backend with Neo4j then just go for a straight rewrite. Part of my original comment was rebuking Enumerable_any's implication that AR is implicitly wrong. 
You said "from experience". Have done Rails/Neo before? And a big reason I would change to Neo is because I would also be doing a lot of table joins in Postgres. Speaking of Neography, I found this neat little gem that would help: https://github.com/elado/neoid. If I use this and Neography, what else would I really have to change?
I think (since I'm fully done with my PG backend), I'll keep this repository intact, try my hand at Neo using a clone of my current repository, and if it doesn't work out, no big deal.
Sounds like a good plan. So why do you think an RDBMS is wrong for you?
&gt; Newer languages than Ruby still haven't been at the same level of flexibility of the dynamic features of Ruby. Only JavaScript is at that level. what does this even mean? absolutely nothing. 
&gt; Write an ORM for your ORM I wouldn't call it an ORM. It's actually just a proxy which uses an ORM under the hood. &gt; flame ActiveRecord because you think it does it wrong I don't think I implied ActiveRecord is doing it wrong. ActiveRecord is a damn fine ORM! Going the rails way and littering your code base with ActiveRecord specific calls (`where`, `save`, ...) is *doing it wrong*. &gt; when what you're really doing is switching from a relational model to a non-relational model. Apples != Oranges. I don't get this part. non-relational != relational, sure. But what has this to do with complaints about ActiveRecord?
I would add: 1. [shoulda-matchers](https://github.com/thoughtbot/shoulda-matchers) for rspec, by Thoughtbot. 2. [Kaminari](https://github.com/amatsuda/kaminari) for pagination.
Interesting, those are usually reasons for using an RDBMS instead of NOSQL. Please do post updates of your experience, I'm interested in learning of accounts of how/why NOSQL benefits a project vs not.
Yep, I'm building my own startup on it, and previously was at another successful one which used it as the core of the business. In building the current one, I've gone from a Rails app with no database, to using PStore, to ActiveRecord, to now introducing neo4j. It might seem like a ridiculous amount of churn, but it's been relatively painless to swap out the back-end stores by using boundary objects. From first glance at Neoid looks like it toes that line of productivity vs coupled-ness that Rails does. I'd guess it would be plain sailing and faster development at first, but potentially more pain later. In terms of "What else would I really have to change?" it's a good question to ask. Another question to continually ask, is "What's the cost of doing this now, vs doing this later?" It all depends upon your application, the number of developers, and average skillsets etc. I'd still urge you to introduce boundary objects, because it's less expensive in terms of time and complexity to do it now, than it would be later. However, if for you, it's all about, proving the hypotheses that "this app would be much faster/performant/cleaner etc if it used neo4j" then I'd say maybe just give neoid a spin. I've no idea what your app is either, but there's always a chance that you build speculative features that don't introduce actual value because they don't happen to solve the problem that actually exists. Let's say you're assuming this is some massive social network application, that will need tons of friends-of joins, and so when it goes viral you can absolutely scale by just doing traversals in neo instead. You build a flapping bird side-game that everyone loves, and plays all the time. All your development effort shifts towards developing the flapping bird side game because you found you can make a ton of money on it. But nobody cares about re-connecting with friends or sharing scores with friends. All your architecture is now amazingly efficient at dealing with social networks, but you have 14 relationships in your database between 4m users. You also have a ton of code dealing with nodes and relationships and friends of friends, that hardly ever gets touched, but does increase cognitive load when trying to work out how to update a user's score in the game. This is all obviously a total imaginary scenario, but the point to illustrate is that if you always delay decisions until the last possible moment then you wouldn't waste money on developing features that are never used. That goes for architectural decisions/refactors and backend data-stores. If you build an MVP and use tracer-bullet approaches then you can avoid wasting loads of time on building stuff that is never used. It's always disappointing to give up on a cool idea. But it's much more disappointing to spend months building a cool idea, that you admittedly have to pull out and just delete the code for. When all the time you could have been building a different cool idea that people actually use.
The [EDIT] site_prism gem may be of interest to you as another page object gem possibility
I haven't looked in a while but I recall OpenShift (by RedHat) being a pretty compelling and possibly more affordable alternative to heroku. AppFog also looks like it's worth a look. I'm just using Digital Ocean currently, $5 a month to do whatever I want is pretty compelling.
webmock is pretty darn nifty. My only complaint is that, as an rspec user, the I'd prefer if webmock used expect syntax instead of should syntax. Minor detail, really.
I have indeed thought of using polyglot persistence. The big issue is that there is far, far more data that Neo can handle better than PG in my case. And if I'm going to go to all of the trouble to adapt AR, I might as well just stick with Neo completely to keep the complexity down. You say you've done this? How did you wrap AR? What did you use to learn how to do this?
Good job providing links, also +1 for Kaminari, that's my favorite go-to paginator.
I guess my main issue is with this: &gt; I don't think I implied ActiveRecord is doing it wrong. ActiveRecord is a damn fine ORM! Going the rails way and littering your code base with ActiveRecord specific calls (where, save, ...) is doing it wrong. When you're writing a Rails app, which (by default) is built around ActiveRecord, then "the Rails way" of using ActiveRecord calls everywhere is not littering or the wrong way, it *is* the Rails way. If it's hard to do it another way, it's because it is *not* the Rails way. The fact that AR does not currently have an adapter for Neo4j could be either that it doesn't fit with Rails well (not likely), or that a robust and stable adapter has not yet been written (more likely). 
For model testing, shoulda-matchers is great for simplifying association and validation tests. For integration testing, previously mentioned faker is awesome, and works even awesome-er with factory-girl. Capybara and launchy are two more great tools for integration testing. +1 for pry, binding_of_caller and better_errors, super helpful for debugging
Thank you for your insight. Truthfully, I'd love for that scenario to happen (that you described), but I think it will be the opposite. Which sucks for me because I've already fully completed the SQL based backend. So essentially, I'd just be cloning my current repository and adapting that, while still keeping the original intact. I have a little bit of time to burn since my front end guy is just getting started, and I'm basically just providing myself busywork on my current app. And yes, I'm worried about the scalability as well. So I feel like I can kill two birds with one stone and try to adapt a clone of my current repository. What did you use to adapt Neo and AR? Just Neography? How did you call relations in AR? You can't use the has_many, belongs_to, etc, right? Also, how do you deal with polymorphic relationships in this situation? I have quite a few of those too.
As far as avoiding complex joins goes, I believe I could do that using multiple queries. But is that more effective than the seemingly "silver-bullet" approach of searching graph relations? And on top of that, what would I do about multi-step relations with lots of complex relational data? Neo looks better in that effort as well. Then there's scalability of all of this related data (which there will be a lot of). If there is a way to solve all three of these using SQL, how would I do that effectively? (aside from the aforementioned denormalization technique)
Oh, okay. I'll take a look. Thank you for the link.
I've been trying to help a non-programmer friend learn Ruby. Ruby is so powerful and popular that people want to dive right in. Programmers can pick up Ruby easy even if they don't code in it elegantly or idiomatically right away. Beginners like my friend struggle with computer science basics. You're right that books like Eloquent and Well-Grounded are too advanced. I don't know how thoroughly the beginners Ruby books and materials teach the foundations of programming. I do know that Wesley Chun's "Core Python" does. I recommended to my friend that she grind through that book doing all the exercises. Picking up Ruby should be easier after that. To a beginner, Ruby and Python are close enough. It's understanding and drilling the basics that's most important. Do any of the starter Ruby books have a ton of exercises?
&gt; As far as avoiding complex joins goes, I believe I could do that using multiple queries. If all else is equal (things that should be indexed are in fact indexed, the search optimizer is behaving itself rather than bugged, etc.), a join can be as efficient as getting the same result with multiple queries, sometimes more efficient. So right off the bat I'm somewhat concerned that you say this, along with my earlier concern about you saying that the way to avoid joins is to switch to nosql -- these statements don't appear to be factual. Now it may be true that you do actually have a good reason to switch, but all I have to go on is what you actually say. It is well known that it is a deep art to optimize database schemas and database queries, and so on, and sometimes things don't turn out as you would at first expect -- but switching databases tends to be a large effort, and it would be a shame to put in that effort for spurious reasons. I'm not a total SQL/RDBMS diehard; I think there's a place in the world for graph and tree databases, and for databases that don't offer ACID guarantees. But there is also a lot of misinformation and nonfactual hype for non-RDBMS solutions, and there are plenty of tales of woe from people who used the wrong solution for their particular needs. It's also possible that neo4j is ideal for your needs, and you just made some misleading statements along the way. Hard to say. I think that Enumerable_any's earlier suggestion of a wrapper isolating the details of database access is very sensible as long as you are considering the possibility of any switch, and on top of that, if it were me I would really lean into finding ways of optimizing the existing queries. It is quite rare for people to run out of optimization options; they usually give up relatively early in the game. Again, it's a big subject.
The fact is that without Rails, ruby would not be a known language at all, and the development would not be at the rate it is today. That said i always see this as an issue/problem with ruby. Its too much rails, and its also why i have gone with python, as its more general and have no one killer app. 
Thank you for the input. Luckily my PG backend is already completed and tested to the nth degree. I'll apply some of the concepts of what you said to it and see what happens, but I also currently have a little bit of downtime between now and launch date for my app because my front end dev is just getting started. Obviously it's not all downtime as I'll be helping him a little bit. I'll probably still create a second version using Neo and I'll test them against each other when it's completed. I'm sorry if I sounded ignorant in any of my arguments, but it seems like a risk that's worth a shot. Also Neo is one of the fewer NOSQL db's that is ACID compliant =)
I've tried a hybrid model, with some data in the graph and some in AR, but keeping it in sync is more effort in my case than moving everything across to neo. The only thing I've left in AR is users for devise. Then users in the graph and AR store a reference to each others respective ids. I might also see what I can get out of neoid. I might be able to fit it into my system of having a boundary object, then not needing to manually maintain ids across both data stores. As for polymorphic relationships, they don't really relate to a graph. E.g. acts as taggable or commentable or whatever are effectively replicating ordinary graph relationships. It's a join table that any multiple tables can join to, which is the same thing as a relationship really. Any node can join to any node, with any number of attributes on the relationship. I'd do commenting or tagging by just having a (u:User)-[:COMMENTS_ON(body: "Great post")]-&gt;[b:BlogPost]
ACID compliant is good. I hope the exercise is interesting.
For me it's a holy trinity Cucumber, Rspec and Capybara. I also use Guard for watching changes in file. And for template language I like to use Slim.
Aside from those that are mentioned already, here are a few of my must-haves. 1. [Gon](https://github.com/gazay/gon) - Easily send data to your js files from your controllers. 2. [Letter Opener](https://github.com/ryanb/letter_opener) - Easily test emails. Emails are opened directly on your browser. 3. [Sidekiq](http://sidekiq.org/) - Background jobs! 4. [SimpleCov](https://github.com/colszowka/simplecov) - See your code coverage! Really helpful when writing tests.
Beginner at programming here... I've seen a bunch of things out there about deployment solutions...what are they, why do I need one, and is it something a beginner can easily pick up or are there easier ways for a beginner to get things done?
Sure. I'm also pretty free for the next two or three months working on my own project which uses neo4j, so happy to chat about it. Would be nice to bounce ideas around anyway, and it was good to hear about neoid from you. I can comment on your repo too if you're interested.
Development: nitrous.io Deployment: heroku Nitrous can deploy straight into heroku, no messing about moving stuff manually
Check out taza.
Yeah, sure. That sounds great! PM me your GitHub username, as I like to use private repositories. As soon as I create the Neo clone repository, I'll invite you. I just sent Andreas Ronge, who seems to be a leading expert on Rails/Neo an email about using his wrapper gem as well. (https://github.com/andreasronge). Thanks for your time! I've learned a lot just from all of those comments!
I usually use monit on DO/Linode, and have never had a problem with services going down and staying down. Took me 10 minutes to setup.
My best tool is probably Rubymine. I love Emacs and Vim, but with Rubymine (and a decent test suite) it's actually easy to refactor Ruby code.
It might be worth checking out [Cloud 66](http://www.cloud66.com), which helps you deploy and manage your Ruby apps on any cloud or your own servers. We support DigitalOcean, Linode, AWS etc, and you get full SSH access to the servers. This model has some pretty good [price savings when compared with PaaS/DIY](http://blog.cloud66.com/cost-of-setting-up-and-running-a-rails-app/). Disclaimer: I work for Cloud 66.
In 99% of cases Monit should take care of bringing services like that back up for you, my default rails chef config &lt;https://github.com/TalkingQuickly/rails-server-template&gt; includes automatically setting up Monit for all servers installed (postgres, redis etc) and [this post](&lt;http://www.talkingquickly.co.uk/2013/09/using-chef-to-provision-a-rails-and-postgres-server/&gt;) has instructions for using it.
I'd just like to interject for a moment. What you're referring to as MVC, is in fact, Model2 architecture, or as I've recently taken to calling it, classic MVC. Source: [Rails is not MVC](http://andrzejonsoftware.blogspot.com/2011/09/rails-is-not-mvc.html)
For me: * Testing: [RSpec](https://www.relishapp.com/rspec) and [Webmock](https://github.com/bblimke/webmock) (without [VCR](https://www.relishapp.com/vcr/vcr/docs)) * HTTP: [Faraday](https://github.com/lostisland/faraday), [Faraday-middleware](https://github.com/lostisland/faraday_middleware) and [Faraday-conductivity](https://github.com/yourkarma/faraday-conductivity) * pry, pry-rails, better_errors and binding_of_caller (obviously) * for dealing with amazon: [AWS-SDK](http://rubydoc.info/gems/aws-sdk/frames) (so no fog for me) * [lograge](https://github.com/roidrage/lograge) Edit: * [Virtus](https://github.com/solnic/virtus) makes making models easy has some pretty awesome features too. I prefer this over ActiveModel.
The compiler says: "I don't know what percentage is" The exercise says: "percentage should be a parameter of the method add_interest!" so what you forgot is to add the parameter to the signature of the method add_interest like this: def add_interest!(percentage)
You're missing a parameter declaration for the add_interest! method.
One big one, one small one: [RailsAdmin](https://github.com/sferik/rails_admin) - An automatically generated administrative dashboard for your Rails app. [PP](http://ruby-doc.org/stdlib-2.0.0/libdoc/pp/rdoc/PP.html) - Not a gem but an underused library. Pretty print objects (very helpful in console). 
Still does nothing http://imgur.com/vNACyX2
I've done it now, cheers
you also added the variable percentage at the method call, but it's not defined in this context. The first variant reading account.add_interest!(10) was correct. This calls the method add_interest! with the value 10 for the parameter percentage.
&gt; The compiler says: "I don't know what percentage is" It actually says "I want zero arguments, but you gave me one". The `undefined local variable` error is from a different version of his code.
* [Cuba - web toolkit](https://github.com/soveran/cuba) * [Ohm - Redis ORM](https://github.com/soveran/ohm) * [Cutest - Testing framework](https://github.com/djanowski/cutest) * [Clap - CLI arguments parsing made easy](https://github.com/soveran/clap)
Weird.. I just tested this the other day. At work, we're using rspec on a project and `expect(my_webmock).to have_been_requested` seems to work fine for us.
Huh. I'll have to go back and try it again! If it does work, then I'll modify my statement and say that I have no complaints about webmock. :P
I love [rails footnotes](https://github.com/josevalim/rails-footnotes) for debugging. It puts a footer at every page in your dev environment, and shows which controllers were called, which views have been rendered, what db queries were made and where in the code those db queries come from. It has been super useful in cutting back on db calls and reducing load time due to db lookups. There have been times when I was making a ton of extra calls because I thought I was including everything properly in the Object.find() call (yes, still on Rails 2.3) but i wasnt. So doing object.children kept making new db calls, instead of 'children' being loaded once by the controller. 
Thanks for the feedback. I'm going to update that wording regarding JRuby since it's slightly misleading. The long story short is... it depends if your workload is IO or CPU bound. For CPU bound apps... JRuby (or Rubinius) will give you the most performance with multiple cores because they are both designed for it. MRI has a global lock on the interpreter (GIL) so you really can't keep more than one CPU core busy at a time. For IO bound apps... You will still get a lot of benefit from the Workers gem even on MRI. For example, say you are building a web crawler and you want to perform 1000 simultaneous HTTP requests. In this case, you can use a Workers TaskGroup, add each request as a separate task, and then wait for them all to complete. You will see huge performance gains (even on MRI) because the threads will spend a substantial amount of time waiting on IO. I hope this helps. Feel free to contact me if you have any questions.
At my startup we have an internal active-model compliant ORM we're getting ready to use with OrientDB, which is another (open source, not just community edition) graph DB, using a gem called Pacer (https://github.com/pangloss/pacer) which relies on tinkerpop and the blueprint standard not orient specifically for the most part. We're planning to open source it, not sure on timeline but if anyone is in helping/getting access we have had outside collaborators before we open source things in the past, could happen again. We may be waiting on a new release of Orient to fix one or two issues, but Orient's cool because it has a lot of great non-graph document features and some SQL query support too, IIRC.
oci8
Looking at the docs right now. It seems like you are doing the right thing. What happens when you do this? db.exec("your query") { |row| puts row.join(',') } 
You mean site_prism? That's what I use. I've worked with it and Page Object quite a bit and vastly prefer site_prism.
That worked! Thank you! Just really confused why the original one didn't work. Thanks again!
[MiniProfiler](https://github.com/MiniProfiler/rack-mini-profiler) is pretty handy when you need to diagnose poor-performing pages in your web apps.
TIL.
fixed it. sorry new to reddit posting haha
 while(true) do begin b = Watir::Webdriver.new :ff #b.dothings #**timeout rescue Exception =&gt; e begin b.close rescue Exception =&gt; e puts "already closed" end b = Watir::Browser.new :ff end end edit: I literally just copy-pasted your source and mine came out fine. Weird.
&gt; So, now we can fully understand how it works: ActiveRecord actually stores in the database the integer corresponding to the enum label position inside the array that we provided to the `enum` macro. Well, there goes a good old bad idea. A data structure, that holds no meaning without a supporting application, gets elevated to a feature. I've spit poison working with some php mashups, that obfuscated data in this way, now Rails will allow for very same obfuscation with no effort at all. If you need a dictionary, use a table. If you're lazy, use TEXT. If you're ready [for that homicidal maniac of a developer, that you're going to create, to come after you](http://c2.com/cgi/wiki?CodeForTheMaintainer), feel free to use integer with no meaning of its own.
Anyone having performance issues with those on Ruby 2.1? Super slow for me on Rails 3.2 app after upgrading to 2.1
Some books are targeted towards programmers with experience in other languages whom want to learn ruby. For learning programming, typically you want a book that walks you through the basics. Doing simple output with numbers and strings. Doing basic arithmetic, getting into loops, and conditions. From there one can learn about things like methods, classes. Start writing basic small programs. I started learning ruby well after I learned the basics of programming, so I can't recommend books from a beginner's perspective, but i do know of this one: http://ruby.learncodethehardway.org/book/. Further more, what "proper" programs are you trying to write? Can you post something you're trying to learn at the moment that you're having trouble with? Perhaps we can help you correct some of the issues.
Random advice for beginner-intermediate programmers: Start small and begin with individual code challenges - there are lots of these online, e.g. codewars.com Read other people's code to understand other methods and syntax (also available at codewars.com). Occasionally go back and read your own old code. As your code grows in size, isolate your components so that you can be certain each component does what you expect it to do. This is a good method in general that professional developers use too.
Sometimes the simplest ones are the best: The [andand gem](https://github.com/raganwald/andand/). Ever find yourself doing this pattern a lot? if foo &amp;&amp; foo.bar something end The andand gem lets you make that a little simpler: if foo.andand.bar something end And, of course, it can be chained indefinitely: foo.andand.bar.andand.whatever.andand.thing Although if you're reaching that deep into `foo`, it might be a red flag. It's especially nice if `foo` is a statement with a little heft behind it: if Order.find(123) &amp;&amp; Order.find(123).customer &amp;&amp; Order.find(123).customer.is_something? Of course, you could clean this up by breaking out `order = Order.find(123)`. Better still, though, you could use: if Order.find(123).andand.customer.andand.is_something?
what book are you using?
Re performance: I can count on 0 hands the number of times I've been performance bound on rails code such that `andand` would slow anything down. Re clarity: I think `.andand` is incredibly clear. You have to learn what it does once, and then it's quite obvious from there on out. Personally, I think it's *more* readable, but that's pretty subjective. Re adding more code: just the one- `gem andand`. If it's code I didn't write and don't have to maintain, it doesn't add any complexity cost unless it breaks. This gem is simple enough and stable enough that I don't consider that a problem. 
I recommend these three sites to anyone trying to learn ruby (no specific order): http://rubykoans.com/ https://rubymonk.com/ http://www.codewars.com Have fun and good luck!
The app would be broken for _you_, but for anyone else?
The best way to move forward is to get help. Post the code you're using, and the error you're getting and we'll be able to tell you what's gone wrong and why.
I recommend Learn Ruby the Hard Way too. It's a great way of getting things to stick in your head.
The performance penalty comes from the sum of little details like this one. Rails is slow and uses a lot of memory because it has lots of little code fragments like andand. Regarding clarity, I agree that if you master how to use it and you implement it in all your projects it will end up looking familiar, but I think there's extra cognitive load because there are more cases to cover. This is one mentioned in the README as a gotcha: `x.andand.length &gt; 3`. Instead, for that case, they recommend this version: `x.andand.length.andand &gt; 3`. There's mental juggling going on. About the extra code, I will explain my point of view. I think it's easier if we exaggerate a bit. Imagine you start a project and you use Rails and RSpec. Even before you write your first line, you have added 165,000 lines of code. You can justify that because those tools have proved useful for you, and you accept the memory it uses and the performance you get. But if somebody improves those tools to the point that you get the same functionality with 1/10 the lines of code, 1/10 the memory usage and 10x the speed, you will welcome the change. On the other hand, if somebody doubles the lines of code, the memory usage, makes it twice as slow, and it still has the same features, some people may complain. In all cases (Rails, Slim-Rails and Fat-Rails), it's code that you didn't write and you don't have to maintain, but you are nevertheless affected by the design decisions somebody else made. With big tools, the bloat arrives in tiny waves and that's why nobody complains too much. With little tools it's also hard to notice the extra code, but consider that `a &amp;&amp; a.size` uses a hundred lines of code less than `a.andand.size`. I think a hundred lines of code for that little functionality is too much.
I work in a primarily Windows AD shop although I deploy on Linux servers. [AdAuth](https://github.com/Arcath/Adauth) is a godsend for Active Directory authentication integration. I also use [Bunny](https://github.com/ruby-amqp/bunny) for RabbitMQ integration and [Wicked-PDF](https://github.com/mileszs/wicked_pdf) for generating PDFs from custom views. Apparently I'm a bit odd since I saw none of these in the rest of the comments...
The "exploit" bit of this is that the invalid characters would get persisted in the db and rendered (and thus raise an exception) for *all* visitors. Have an index page that displays post titles? Submit an invalid byte sequence as a post title and that index page will start returning a 500 error on all subsequent requests. We actually had a user who was sending the same message to a bunch of their friends on our website. It had an invalid byte sequence on it and as a result, none of these users could view their inboxes. And that wasn't even intentional.
I took that and made it a 1-liner: File.stat(`ldd #{$:.map{|d|Dir[File.join d,"openssl.so"]}.flatten.compact.first}`.split("\n").detect{|e|e.match /libcrypto/}.split[2]).ctime&lt;Time.new(2014,4,7)?"Vulnerable!":"Not Vulnerable"
The `attr_reader` method call will create instance methods in this case. So, when you call x and y on the `to_coords` method, you're actually calling these methods. The best way to understand this is that reader methods don't require a message receiver; some people would add `self.x`, but it isn't required.
Bugger, yes that is what I meant. NSA news on the brain...
Enum is so basic I'm surprised it wasn't already supported
I recently started a new job doing Ruby on Rails for the first time, although I've got plenty of experience with other frameworks. I've been going through books like mad. I found the Rails specific ones to be of minimal use. They're hand wavy. They give you a one liner and tell you it works, but not why. The Ruby specific ones have been better. So far the best of them has been Eloquent Ruby. It doesn't just give examples, but it gives you the real world motivation behind the examples. Programming Ruby gave out more code, but the examples were so contrived I was scratching my head trying to figure out why they were doing what they were doing.
Thanks for the tip!
Thanks for the links! I hope I'm not the only one with these problems and other people could benefit from the resources you posted.
Thanks guys, I just bought that book!
Only losers give up.
I'm happy to hear that I'm not the only one scratching my head. I'm sorry you're having trouble. You can do it! I hope this helps you: https://onemonthrails.com/
If you're just learning ruby you don't need to worry about efficiency just yet. Learning something like vim will benefit you in the long run, but I don't think it should be the main focus or much of a concern for a beginner. Focus on core programming concepts and getting good with the language first and building something useful.
Not the app. It freezes the browser whenever an error occurs and it is shown.
Thank you
[slop](https://github.com/leejarvis/slop) is infinitely more concise -- when we switched from using optionparser to slop in [pry](http://pryrepl.org) our LOC went down by about 20%
Understood! Thanks for the help.
When I'm testing something in irb or rails c, I usually create a test.rb file and will write my code in there. I can then call load 'test.rb' to run the code. Much faster than retyping in console and can get an overview of my code in an editor.
I found [trollop](http://trollop.rubyforge.org/) to be much nicer personally.
The article says ruby is statically linked against openssl, so you can't check with ldd. However I can't reproduce this on Linux?
https://github.com/docopt/docopt.rb I'd recommend taking a look at docopt if you've never looked at it. 
Heard great things about Cloud 66. I'll check it out when I get chance. Thanks.
&gt; we’ve extended our distributed ruby compiler to parse every exception case, with it’s message, file and line number its*
The issue that has steered me away from `andand` over the years is that nine times out of 10, the presence of a `nil` in your call chain is an edge case. In your example, you are using `andand` to guard against both order #123 not existing, and it not having a customer bound to it. In the first case, I'd prefer to just fail fast. Exceptional cases deserve exceptions being thrown. In the second case, you've got an object in an invariant state. Rails apps whose business logic has to reach into domain models and inspect their state are generally a lost cause; if you can't guarantee that persisted objects are valid, then you can't build an application on top of your domain models. Of course, this is just one schlub's opinion, but if you have to guard against `nil` pervasively in your app to prevent `NoMethodError` on `NilClass` to be thrown, then you're playing a game of whack-a-mole that you *will* lose, in my experience.
spammiest e-book i've ever read, ridiculous. 
I'd say you obviously have to have a pretty full understanding of Ruby and Rails, but you'd also have to have a pretty strong familiarity with the entire application stack, and then I'd expect the following qualities: - Strong attention to detail: know what to document in your issues tracker, know what kinds of things need to be examined before code is released, etc - Know when to deviate from the RoR MVC model (i.e., when to bring in support classes) - Have good software design skills - Be really, really comfortable writing tests - Know how to write with others
If you're just trying to develop locally you don't need to install a web server. Rails ships with a web server that's fine for development.
You could expand the idea of relying on hash lookups and have a key named "help". Then constructing custom help text is easy. Also, OptionParser can output help text automatically with a list of options. Call doesn't have to lookup an inline proc, just anything that responds to call. There are gems that do all of this for you, but I think this is neat. It's building your own and still keeping it so simple. It's not the only way, nor is it more "right", but I can see it working for some.
Is this in ActiveModel as well?
master ruby :)
Add database design to that. 
Ha. There is such a huge demand for RoR programmers that many companies are happy to hire complete newbies.
Thanks all, for taking your time to provide so much good information.
I think the idea that you'll ever get job security from a specific language or framework is dangerous. RoR is big now but who knows what the future will bring. Job security is kind of an older generation thing but if you want continued employability make sure you never stop learning and being open to new ideas. 
Thanks themaincop...
Write more code. That's pretty much it.
I think it's fun to try and think of it as a fun little problem or quiz: instead of calling it finished with the first solution you can come up with, think of how succinct you can make it, how short you can make the solution before you're satisfied with it. Part of the great fun of working with Ruby is that there are a myriad of ways you can use and abuse shorthands and quality-of-life methods to come up with very short solutions to common problems. I found it particularly useful when I was first learning to just go to the class documentations and try to find the perfect method for whatever I was trying to accomplish. For example, you're working with an Array? Check out the [Array docs](http://www.ruby-doc.org/core-2.1.1/Array.html) and look around for methods that can help you accomplish what you're doing. Also, remember that if something sounds like it should exist, it probably already does. Maybe it's not implemented in the Ruby standard lib, but you can bet your bottom dollar that [Active Support](http://guides.rubyonrails.org/active_support_core_extensions.html) has it. All of this being said, there's also a lot of value in knowing that just because you can write something as a one-liner, sometimes you shouldn't. Try to always value readability. Sometimes it's just better to have 3 lines that are very easy to read, than one that looks like your cat was walking on the keyboard, especially for future devs who might be working on your code (or even future you).
Where at? I am right next to Austin and search online for Rails developer hardly has any results. Job postings that do come up usually looking for Sr. Rails developer.
Don't worry about minimizing line count. I feel a much more important factor is removing complexity. Less code is in general more complex than more code. Are your four line solutions dealing with extra complexity compared to the one line solutions? Do they have more state? Are they simply just not quite as compact?
Expanding on /u/nerdshark's idea: To learn how to play a musical instrument, you'd practice every day. To learn Ruby, [write some code every day](http://ejohn.org/blog/write-code-every-day/) — even if you can spend only 10 or 15 minutes on it. Yeah, so maybe 10 or 15 minutes a day isn't the quickest way to learn. So what? You're spending _some_ time on it. That's better than _no_ time on it. To get better at a musical instrument, you'd listen to a lot of music too. Reading good Ruby code fills your mind with good examples. These books are helping me: * David Black's [The Well-Grounded Rubyist](http://www.manning.com/black3/) is the best Ruby intro I've found out of literally 15 or 20 that I looked at. (Yeah, I'm one of _those_ guys.) Get the second edition in progress at Manning.com rather than the first edition at Amazon. Buying the 2nd edition while it's being written gets you a free epub/Mobi/PDF of the 1st edition. * Russ Olsen's [Eloquent Ruby](http://www.mypearsonstore.com/bookstore/eloquent-ruby-9780321584106?xid=PSED) might be even better for you because you've already mastered the basics. It teaches patterns of thinking in Ruby. * Bigger and better Ruby programs are built with objects. Sandi Metz's [Practical Object-Oriented Design in Ruby](http://www.mypearsonstore.com/bookstore/practical-object-oriented-design-in-ruby-an-agile-primer-9780321721334?xid=PSED) seems to be the best OO design book for Ruby. Be patient with yourself. Give yourself a year to learn object-oriented thinking. You're changing your way of thinking. That takes time and persistence. But you can master it. Just keep at it. 
this: https://projecteuler.net/ will force you to look up methods on arrays/strings. this will help form your mindset
Why is this better than `&amp;&amp;`? :)
It's just light-weight syntax for passing a single anonymous function to a method. Even though Ruby already has fairly light-weight syntax for anonymous functions (i.e `lambda { }` and `proc {}`) it was thought the case of passing exactly one anonymous function was common enough to be special cased: i.e `collection.map { |v| v * 2 }` versus `collection.map lambda { |v| v * 2 }` Another interesting feature is that blocks are passed outside the argument list, this can make them look like you're defining new control structures: `File.open("hello.txt") { |f| puts f.read }` Ruby actually has a `loop` construct, which is just a method taking a block, but it looks like a control structure built into the language: `loop { puts "infinite loop!" }` 
This, a thousand times. But mastering all those things will only help you later on with _insert language or framework_ development. Learn good OO and application design principles, and try to keep up with the changing technology. As no one want't to be a senior VB6 developer these days, because the technology is deprecated. But i know some senior VB6 devs who can handle almost any technology and requirement, just because they have experience building real applications, for real, sometimes very demanding, clients.
Apart from [typoglycemia's advice](http://www.reddit.com/r/ruby/comments/22wkbz/how_to_get_used_to_ruby/cgr4e5m), I'd also recommend checking out http://exercism.io/. You get to solve problems and have others comment on how your code could be improved.
Yeah, it really means that blocks are the only real closures in Ruby, everything else, `define_method`, `lambda`, `proc` and friends are just methods that take a block (ok, with the possible exception of `-&gt;`)
Read the documentation of [Array](http://ruby-doc.org/core-2.1.1/Array.html) class and [Enumerable](http://ruby-doc.org/core-2.1.1/Enumerable.html) module.
Thanks for the pointing me to right resources.
i had not heard of loop do before. for other curious folks: http://stackoverflow.com/questions/16813199/when-and-why-use-loop-do-construct-in-ruby
Exactly my thought. For e.g. in one of the exercise of RubyMonk, I iterated through and array and then saved values in an empty array, finally calling on required method on new array. Eventually when I saw the solution, it used map and was simple and elegant.
Since others have given lots of answer already. I would like to answer it in less of what it actually is and more about what you can think of it as. *What is it?* It's a "block of code". In Java, when `if` condition is true then it execute a "block of code". In Java, you define method that contains a "block of code". *Why do you need to use it?* Why do you need a block of code in Java? So that you can execute them. Ruby makes "block of code" first class value, so that you can pass it around. You can also define a function that takes a "block of code", so that you are not limited to only language's built-in structure. Imagine if Ruby does not have `unless` keyword. You can implement is easy as. def unless(cond) if (!cond) yield end end And then you can use it like this: unless(x &lt; 0) { puts "X is positive" } Imagine `using` keyword in C#. You can implement it in Ruby like this: def using(obj) try yield obj ensure obj.dispose if obj.respond_to?(:dispose) end end Then you can use it like this. using(Resource.new) {| r| # r is automatically dispose after this. } Look at how close this is to C#'s `using` keyword syntax. But you don't have to wait for core Ruby language developer to release new language version. Defining your own language construct allow your code to be more concise. And you don't always have to wait for language developer to add new construct.
Man, all the answers here would really confuse an average 5 year old. Let's try: When you are writing computer code, you generally ask the computer what to do by giving it instructions in order. If you ask it to do the same things in the same order a lot, it is helpful to give that set of instructions a name -- this is called making a function. Some functions are exactly the same every time but some can vary a little using what are called arguments. So, for example, rather than saying "print the string" you can say "print the string, with the string being 'hello world'" The Ruby programming language gives you another option too. On top of the common kind of arguments where you give one or more values, every time you ask the computer to execute a function, you can also give it another set of instructions called a block. If it wasn't expecting these instructions with the function call, it won't do anything with them, but if it was expecting them, this lets you give special instructions for what the computer should do this time, at a certain point in the middle of the function's saved instructions. A common example is calling the 'each' function on a collection of values: by giving a block you can have it do anything you specify with the first element of the collection and then move on and do the same thing with each other element of the collection in turn. This sort of case is so common, that functions which expect a block are often called 'iterators' (sometimes even when they only deal with one thing :/). 
Do you have other people at work that write ruby as well (with more experience)? I would continue to write code like you have been, and then have your peers review your code. You and your peers will learn from each other.
Cycling.
Yup the original questions were splattered around. Basically the gist is "what do you guys do on a daily basis" but we thought of having like "guide questions" (which turned out weird I guess). Flexible means 40 hours? Can you work 4 days 10 hours then 3 days rest?
ABC. Always Be Coding. Seriously. Write code for everything. Even one-off tasks, things that you'll never do again. Figure out a way to do it with Ruby, and remember it.
OCaml, eh? I keep seeing this name show up in the Haskell world, both as a "predecessor", and a stepping stone. It looks interesting. Could you share your motives and experiences, briefly?
I'm barely taking my first steps in OCaml (and in functional programming really) so take my opinions with a grain of salt. :) When I was learning to code, procedural and OOP like most people learn it felt like there was a set of rules I had to learn so I could make stuff work, learning OCaml feels much more natural: everything is really just mathematical functions that behave in a way you would expect, this is maybe more related to it being functional than the merits of the language itself. I can't shake the feeling that immutable variables, no-side-effects functions and lazy evaluation are the way to go though, they take a huge problem (global state) out of the equation and just allow the compiler to apply all kinds of crazy mathematical optimisations. Language-wise I just love it's pattern matching, fantastic and robust. Look it up, take your time playing with it. Even if you end up not using it I'm sure it will give something valuable. 
babinho, what books, blogs, or video training are good resources to learn "Design principles"? Thanks
Marry me.
A lot of looking at the computer screen with a blank stare. Serioisly. A lot. Not sure why arrival time is relevant but technically 9-6; however, it quite often varies. Most of my research is highly dependant on the project. For ex. I just finished building an app with automatic email and SMS reminders which took a good bit of research in choosing an SMS service as well as running the background processes. (Twilio + clockwork + redis by the way) The number of commits varies too much to even give a daily average. According to github, 300-500 commits per month. I work for a company but billing depends on how the payment is setup. Some projects are billable hourly and some are fixed. Either way the cost is paid for by the client. Hope that helps
Aww man I don't know how to ride a bike. :(
I think you have to read a lot of different books to get things, but for me, [Destroy All Software](https://www.destroyallsoftware.com/screencasts) is really good. You have to pay for it but you'll get your money's worth in terms of productivity gains. [Clean Code](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) had a big effect on my code after. Check out Uncle Bob's [talk here](https://www.youtube.com/watch?v=WpkDN78P884). Google all of Sandi Metz's talks but [this one](http://www.confreaks.com/videos/240-goruco2009-solid-object-oriented-design) is my favorite. She also wrote Practical Object Oriented Design in Ruby, awesome. You still have to code though! I think you'll figure out patterns just by coding and asking around.
Same way you learn to ride a bike. Keep falling off and keep getting back on. Installing [pry](http://pryrepl.org/) can make it a lot easier to learn, as its a very friendly REPL. Look for ways you can use ruby in your daily computer tasks. Need to rename a big folder full of images sequentially? Piece of cake. But do it in ruby anyway, and learn to appreciate blocks and `FileUtils` Hell, find some small project you want and write a script or even gem for it
Hey Guys! I'll tell you first hand that I was "just interested in web development" and I still consider it that. I just receive a paycheck for it now. This is still first and foremost, my hobby. Now with those words said I'll dive into your questions: 1. So I actually work from home but we have standup at 9:36 in the morning via google hangouts. If you're not familiar with what standup is, here's some info: http://en.wikipedia.org/wiki/Stand-up_meeting As for hours in my week? Honestly they fluctuate. I'm fortunate enough to work for a company that cares about results over 8 hours a day. I struggle working more than 6 hours a day now. For myself, I have to be careful not burning myself out because then the next few days will not be productive. Side projects are almost always spur of the moment. I almost never finish them. But!! That's ok, experience is experience. Finishing something doesn't require experience. 2. This is a difficult one. I wouldn't say there's a strict percentage, but I do stare at my screen just thinking about how to solve a problem a lot of the time. There are many different ways to approach solving problems though. Reading an article may help, but what about when you encounter a problem that isn't common? This is when that kinda breaks down and sometimes you just need to program something that sorta does what you want, then modify that til it does exactly what you want. That path will reveal and teach you a lot of things that reading an article would have never touched on. Articles = Best Path. Experimentation = Slow path, but many rewards other than a solution. 3. Low LOC and High amount of Features is probably a good metric of efficacy. A lot of commits is sometimes misleading. I have a lot of commits that refactor code. It's not a feature and it could possibly add lines of code so these metrics are difficult to substantiate. Your best measurement is "Do people like using what I made?" 4. Yes. Clients are billed for research. It's important to understand that research likely ends in making great software that will last longer and be more effective. Although It is worth noting that this is hard to display as valuable to clients. Reading documentation is a requirement for our job. Otherwise thinking is widdershins.
I may be a little atypical, since I work at a startup in SF. Nonetheless: 1. We start at 10am. Really, you get in whenever, but we have a morning standup, so 10am is the latest you can get in. So, realistically, we all show up around 9:55am. People start trickling out between 5:30 and 7. We're all shooting for about 40 hours a week. I put anywhere from 1 to 15 hours a week on side projects, depending on how motivated I am that week. 2. At work, my time is probably broken down something like this: 1. 50% hands-on-keyboard coding/debugging/otherwise interfacing only with the code 2. 15% reading reddit or hackernews 3. 5% meetings 4. 25% interfacing with other developers (code reviews, architecture debates over chat, in-person discussions, etc) 5. 5% snacking, ping-pong, bathroom, general loafing In terms of research, I occasionally do some at work if it's related to what I'm doing (eg, learning an api I need to integrate). Most things I label as "research", though, I do at home on my own time: trying out new frameworks, learning new languages, etc. 3. I go through a project every couple of weeks, I guess, but that's not a super useful way to measure anything, since you have no idea how big our projects are. I'll bet I average 50 lines of code a day, if I had to guess. Maybe less, if you count the days where I refactor and remove a bunch of code. :) This is very spiky, though: some days when everything lines up I write 200-500 lines. Other times I all day tracking a bug down to a 1-line change. 4. I work at a product-based company, so we don't bill anyone for anything. :) However, when I've dabbled in freelancing, I do generally bill for the time I spend reading the docs on a new gem. It's usually a pretty negligible amount of time, though. I'm not sure how I'd handle it if I needed to spend a few days getting up to speed on a new tool for a client.
It's less a "what should I use here", but more a "WTF is this thing not doing what it's supposed to do!?". Sometimes you simply have to chose between the devil and the deep blue sea when it comes to interaction with "business" or "enterprise"-ish APIs… Or if you need to upgrade one of your core infrastructure components (Rails 2.3→3.0 (basically rewrite your app from scratch), 3.0→3.1 (Asset pipeline), Ruby 1.8.7→1.9+ (String encoding)). Or some of your other dependencies (jQuery 1.4→1.10 (where dir `$.browser` go?)). Sure, a good test coverage will help a lot, but it becomes another kind of PITA if you're facing a migration from Test::Unit + fixtures to RSpec + factories :-)
Ruby was created in Japan that's why lol
There is no such thing as job security. The best thing to do is keep up with new tech.
It is an example where resource is polymorphic to the animal and category model. 
I am sorry, I don't understand. I am trying to figure out what someone normally uses the columns resource_id and resource_type for
Pick one language. Stick with that. Then play. Follow a tutorial to build something, anything. Don't try to be clever or original with what you build, follow the recipe until it beeps or bloops or whatever. Then break it. Try to figure out how you broke it and then fix it. Go to a local free tech conf or user-group. It doesn't matter if their focus is not on the language/tools you've chosen. Just go and don't feel like you have to prove you're original and clever there either. The clever and original can come later... Much later. :) maybe try to find a mentor, but not too soon. Make something first. Since you're choosing Ruby then listen to Ruby5 and Ruby Rogues podcasts. Do the Try Ruby and Rails for Zombies on codeschool.com. Try to build a blog in Rails (it'll suck, that's a good thing). Don't try to learn Vim (yet). Follow people on Twitter who tweet about Ruby. Don't listen too closely but take the pulse of the community. That should keep you busy.
http://guides.rubyonrails.org/association_basics.html#polymorphic-associations
Watch http://railscasts.com/episodes/154-polymorphic-association
thank you!
What does this have to do with Ruby/Rails? Post this on the r/programming subreddit
Please do also take a look at https://github.com/papers-we-love/papers-we-love
I typically arrive at work around 8:30 or 9 depending on the day and how slow going it is. Sometimes I'm out of there by 3, others 9pm. There isn't much of a "typical schedule". I personally never read books exactly, the internet is typically a far better resource. I typically like to spend about 5-10% of my time keeping up on tech news and the ruby/rails community just to make sure I'm aware of any new security flaws but also to look at nice patterns/anti patterns that I can incorporate into my workflow. LOC/commits/features are complete folly to measure on a daily basis. For instance this past week I spent researching an existing codebase that we're being put in charge of a 100% redesign. Trudging through the existing code and figuring out what logic we'd use or not use, spending lots of time on the whiteboard, and then planning the next few iterations was at least 50 hours of my workweek. Some weeks I'll push 100s of lines in a single day... it just all depends on the current demands of the products. Research time, ramp time, and bug fixes are never billed. If you don't know how to do something, the client isn't paying for you to figure out how. Now, that being said... I typically never bill my clients hourly. I make an estimate based on how long I expect the product to take, add a multiple to factor in QA and unknowns, and then quantify my time spent so that I can more accurately quote the next time. If you're flying blind or doing fixed pricing, you'll either be left looking like an idiot or left eating your shorts because you underestimated the requirements. 
Thanks danimoth2
In addition to the info here, if you plan to stick with ruby I would highly recommend reading [Metaprogramming Ruby](http://www.amazon.com/Metaprogramming-Ruby-Program-Like-Pros/dp/1934356476). It's a pretty easy and entertaining read and really digs into ruby's object model and things like blocks, and how they differ from more traditional OO languages.
Do you actually need to 'click' each link or could you simply visit the the URL of each link and test it for the CSS? @page.search('.someCSSclassSharedByLinks').each do |link| link_uri = link.url new_page = Mechanize.new.get(link_uri) #some test for the css in new_page end
Standup at 7:30am, remote. I work in a decent-sized codebase, perhaps 35KLOC. I spend most of my time reading code and googling things - perhaps as much as 80%. Probably 10% of the time figuring out how to write good unit / functional tests for new functionality, which can be surprisingly non-obvious... 10% developing functionality. Note that this is very different in an existing vs greenfield codebase - in the latter you might do a lot more new-feature-development. 0% reading books, as I consider this non-billable for a professional developer except in rare cases (if I need to find an answer that I can find quicker in a book than via google, fine... but work hours are not the time to be reading "introduction to rails" or something in my opinion) In terms of LOC/commits/features per day - this is entirely irrelevant, although not at all a stupid question for you to ask. It underscores one of the most difficult aspects of professional development, which is that it is very, very hard to quantify and/or estimate value vs LOC vs time. A feature, or a bug fix, might be 1LOC, but it might take a brilliant programmer a week to write that line. Similarly, often the best code is the LEAST LOC and not the most. Simplicity, DRY code, reusability and conciseness are absolutely vital in professional development. Features are a tiny bit better maybe, because they correlate to business value, but a "feature" can be so tiny or so enormous - at a technical level, for technical reasons - that it is almost always useless to try and treat them all as comparable. Unsatisfying, I know. It's also the source of much chagrin between developers and managers. Estimating, evaluating, judging code and developers is finicky and difficult, especially if you aren't a developer. Sometimes you can tell how good a developer is just by discussing the code, even if they haven't committed anything yet - you can tell how much work they've done by their level of understanding. I'm not sure what the right solution to this source of confusion is, but as a developer you should not care one iota about LOC/commits/features. It's apples to purple to proper nouns: completely orthogonal to *value*.
At least for myself, I try to be in standup every day. It makes a difference to your peers. If I work 4x10s I will take the 5th day off, but generally attend standup. Especially when you're new to a) development, b) a codebase, or c) a team, this is a great way to establish credibility and a good rapport with your peers. Note: I may have expressed this poorly... I do NOT endorse attending standup on your sick days, vacation, etc. That time is yours. But if you're doing 4x10s and some of your team is doing 5x9s, being in standup for the last day (or whatever analogous circumstance you find yourself in) is a professional thing to do.
Reddit. On a serious note, I manage a small startup (team of 6). We're on the e-commerce &amp; outsourcing space. I get up at 6am, arrive at the gym by 7am. Get to work by 10am then usually end my day at 7pm. During the hours between 10am - 7pm, I have a little to-do list inside my head on the things that I need to do. 40% of my time I dedicate to coding (add new code, write tests, rinse and repeat). Coding is also usually the thing I do first thing when I arrive in the office. The rest of my time is divided to meetings if there are, talking to my team about the things THEY need to do and answering work emails. From 7pm until the time I get sleepy, I dedicate to reading and research. So basically, I do my research and reading outside office hours. As for research and reading that directly affects the project that I'm currently working on, of course I bill this to our clients. :) I don't use LOC or commits as a metric for productivity. Instead, what we have are tasks that we set for ourselves every time we start a new sprint (2 weeks for us). For me, this is a more relevant metric to track. I have to admit that I still check commit graphs just to see what people are working on.
binstubs, man. binstubs
join a user group, meet up. ask around. the problem might be the lack of ruby jobs in your area, so you might have to find an alternative. you can also join a mailing list for the local group as they usually have emails recruiting. you'll also want to do stuff of github to get your reputation up.
It removes or replaces invalid bytes in a string and then returns the string. 
The method cleans a given string from invalid byte sequence in UTF-8
Thanks! What I mainly meant, though, is that it could be useful to add the explanation the project's readme.md. Then again, perhaps it's correct to assume that anyone who stumbles upon that project is already familiar with the method.
RubyMotion is a good example of something not web related. There are also other Ruby implementations that can be used to build all kinds of applications. With IronRuby you can build almost everything that can be built with C#, and using JRuby - everything that can be built with Java. I have seen Ruby being used for hardware programming as well.
Awesome answer. I'm still trying to figure out the correct balance between reading and coding. Read too much and you won't get stuff done, code too much and you might write something that has already been implemented before.
Thanks for answering. +1 to the point you make on the charging customers for time spent researching. I was very apprehensive about this at first but the reasoning makes sense. I guess as long as you bang out the needed feature by the specified time, then billing the time while researching is okay.
&gt; As you can see, the tool detected that we had a Ruby app, fetched the corresponding Ruby version (2.0.0), and then installed all the required gems does this actually build&amp;&amp;package Ruby into that .deb? no more dealing with rvm, rbenv or ruby-build?
Hey, I tried running it but the first line to return the path to openssl.so returns nil
I'm a developer at [PromptWorks](http://promptworks.com), currently working on a Ruby/Rails app for a large client, but we try to not keep people on a specific client/project for more than 3 months straight. 1) We work M-F 10-5. Most people arrive earlier than 10 to eat breakfast, drink coffee, and talk. Our standup is at 10, and is typically about 15 minutes for a team of 8-10 people, which admittedly is still too long. 2) We go to google for research whenever the need arises. It really depends on what we're stuck on. As for books, I never read books at work. I read programming books in my free time occasionally, whenever I'm obsessing about a topic. Currently I'm switching between SICP and Learn You a Haskell. 3) LOC/day really depends on the feature and the existing codebase. I'd like to deliver features with as little code as possible. Sometimes we can over-engineer a solution, when a little more thought would yield a simple architecture. 4) Yes, we bill clients for our time. I don't know the specifics, but we prefer to bill weekly. One important thing to note is that we pair full-time and practice TDD. At the beginning of every week, we figure out who is pairing with who. All development and most research is done together. I think this alleviates some of the concerns you brought up in 1, 3, and 4. Every pair has at least 1 senior dev, and working together all day prevents us from cruising Reddit or working on some side project. The team and our clients trust us to be working on the next most important thing at any given time, so we don't concern ourselves with LOC/commits/features/hours per day. The only metric that really matters is what gets finished each sprint, which we're pretty happy with. We also have retrospectives at the end of each sprint to talk about what worked, what didn't, and how he can improve for the next sprint.
Yes, it embeds the ruby version and all the required gems!
Site will not load for me. 
[Announced speakers](http://steelcityruby.org/#speakers): Charles Nutter (JRuby), Jessica Kerr (Git Training), Laurent Sansonetti (RubyMotion/MacRuby), Bryan Helmkamp (Code Climate).
Very cool! Does this work with passenger? Perhaps change one word in the title "...effortlessly create a debian.." I had to think twice.. "why would I have debian packages in my rails app that I need to get out?" /derp on me
It could work with passenger, but it's not the recommended way. If you wanted to do so, you would need to select /opt/your-app/bin/ruby as your ruby binary in your apache configuration, and also set there the environment variables required by your app.
what do you mean by 'enable aliasing on images' ?
Will this run on a standard heroku stack? The wiki says it will run on OpenShift and CloudFoundry. https://github.com/cantino/huginn/wiki
You mean, `$:.map{|d| Dir[File.join d, "openssl.so"]}.flatten.compact.first` ? Do you have it installed? what about `puts OpenSSL::OPENSSL_VERSION` ?
Its how I learned. If your good at it and passionate you could know 5 languages and make 85k a year when your 20. And yes my first site did get hacked.
Good question, especially after the heartbleed episode. It will use the system dependencies for everything, except libyaml and libffi, which are statically compiled with the ruby version (and will be updated if there is a security issue).
You are exactly right. I dont actually need to click each link, just visit the URL. Ill be implementing your suggestions here soon and see what I can come up with. thanks!
There is an unbelievable amount of opportunity. How could you say there isn't? Everyone brings unique skills &amp; backgrounds to the table that are valuable to a team. Said OPs should understand that landing their first (good) software development job is a long process that takes determination, but they should not be discouraged from continuing. Anyone that values number of years of experience over demonstrated skills &amp; potential is an employer to avoid.
I believe Psych will link against the system's libyaml, if it can detect it.
Pkgr could create a Passenger-Nginx config file and let Passenger take care of spawning and managing the processes. That would save a lot of code too. And as an added benefit, the user can select which Passenger version to use, or use Passenger Enterprise if s/he so wishes.
You're* obviously not "good" if your site got hacked. Do bridge engineers claim they are good when their early projects collapse? Software Engineers as a whole do not take enough pride in their work, and this sub seems to not be interested in helping to change that.
Apparently, I've chosen the wrong career as I work 8 - 5 with no ping pong.
That's a good use case, thanks. I'll definitely investigate more in this direction.
Hey, everyone has different priorities. You probably have more time in the evening to pursue your interests, for example. I get pingpong, but I'm also expected to step up if something big breaks over the weekend. I get as much vacation as I want, within reason, but I also have a pager duty shift every 4 weeks or so. I get high pay, but higher rent (SF). I get the opportunity to work on everything in the company, including anything that looks interesting, but I *have* to work on everything in the company, including some technical drudgery. Most career paths have tradeoffs. I wrote a [blog post](http://kevinkuchta.com/_site/2013/07/why-startups/) a while back on why I prefer startups. I should write one about all the bad things with startups someday, if only to point out that I'm aware of the costs. :)
When I first fucking started. I was in high school and just learned server side code. I apologize the first site you ever made was fucking amazing I'm sure. I didn't make my first website when I got my 2nd real programming job. (The 85k one)
I do tech support/sysadmin work so I still have to do on-call work. I only get "vacations" in between contract jobs as nobody hires full-time around here. So I haven't had a paid vacation since `11.
Railscasts has a couple of great tutorials about creating and securing APIs that can provide JSON responses or whatever. I'd recommend taking a look at those. Dated slightly by now, but i still found them helpful. On phone so i can't find links, pm me if you can't find them via google and I'll dig them up for you. There's also been some articles about Rails service oriented architecture designs that may be useful to you, but I've never done a Rails SoA before, so I'll let someone else weigh in on that. Once again, googling turns that up pretty quick.
Do you think you should have been working for a company when you were 3 months in? That is what this topic is about. 
No. That's when you start making shitty freelance websites for people you know.
Awesome thanks I will check those out. Do you also know of anything that take a very beginner approach to modelling. I have 15 years experience now, and I feel like I could create my entire data model in SQL in a day. But Ruby syntax is still very foreign to me, and I feel like it would take 10-20x as long right now trying to do so in Rails. I feel like if I can get go through a couple easy example, a few tables with relationships, create the Active Records, and learn the syntax... I'll have a much greater understanding and domain knowledge to follow along with the RailsCasts and the iOS on Rails book.
I second the railscasts recommendation. For SOA i'd recommend [Service Oriented Design with Ruby and Rails](http://www.amazon.com/Service-Oriented-Design-Addison-Wesley-Professional-Series/dp/0321659368). Covers a lot of ground in that regard.
You need more than just models to create api's though.. Controllers and serializers for instance. Code school has a pretty good course on creating api's with rails I think 
Checkout [Destroy All Software](https://www.destroyallsoftware.com/screencasts).
Time is a loose factor as far as determining skill. I've mentored bright kids who have surpassed seasoned developers in a matter of months. What they will most likely lack is the politics to make their voice heard/matter to others that may view them as a threat.
This isn't specific to keyword arguments. It holds true for all arguments in Ruby. def default(thing = 10) puts thing.class end &gt; default # Fixnum &gt; default(nil) # NilClass
Thanks! We were going to write up another article about securing your machines with the newest openssl against Heart Bleed, but we assumed there were enough articles in the wild that we didn't think another one was required. Look for new articles! We should be blogging regularly!
What happens when you update the PKG. Will it automatically restart the web daemon? Will it respect changes you made after install (config files etc)
Thanks, this is awesome! Exactly what I need. Should have known. I also go around looking for iOS tutorials on this or that, and it always end up being Apple has the best stuff. The base documentation is always the best things. Thanks again!
Since you already know SQL, then you should take a look at http://guides.rubyonrails.org/migrations.html . This will teach you how to do in ruby what you already know how to do in SQL (namely the create table statements). After that, the associations are extremely important, and understanding how they map to SQL too. i.e.: the differences between using has_and_belongs_to_many , vs using belongs_to and has_many with a join model. (has_and_belongs_to_many masks the join table complexity, but you should be aware that it still exists) My advice, since you already know SQL, is that you should have your SQLPro or whatever SQL client you fancy on the ready while you're trying out the migrations and testing creating stuff via the rails console, so you can see what's happening in the database.
[FPM](https://github.com/jordansissel/fpm) and [PRM](https://github.com/dnbert/prm) do most of this work for you, easier I think.
I had to learn via trial by fire at work. The koas are a nice diversion.
Yeah, this isn't even for work myself, at least not yet. Not a programmer by trade, but just something I decided to pick up again on my own after not touching programming since a couple courses I took in school some years ago.
I think you need better experience in building an all rounded project? If so consider this: https://tutsplus.com/course/build-a-ruby-product-for-the-long-run/
I'm a software engineer. We use Ruby at work to generate a bunch of repetitive c code.
Everything in most people's experience feeds into a bias of "youth == good" and "inexperience == opportunity". The upshot of that isn't that we *as a craft* are continually learning, which would be good, but rather that *we as a random agglomeration of interchangeable individuals* are *each* always learning. What this leads to is an increased imbalance of power between developers and employers, who find it in their short-term interests to juice this cycle as much as they can. It's not sustainable, though, as anyone who lived through the sudden glut of "C/C++" developers in the early 2000s or the *ginormous* glut of PHP "talent" more recently can attest. And it discourages companies from investing in capabilities; it's cheaper and much lower-risk to hire one genuine master developer than a dozen "self-organising" apprentices. Software, like any craft, requires several years of applied experience before one begins to achieve mastery. Sure, there are raging talents who make a couple of million dollars before they graduate high school. Someone wins the lottery almost every week, too; that doesn't make buying 100 tickets a week a sound investment strategy. Yet that's what companies are doing with the current focus on *cheap über alles*. Being cheap is often the most expensive thing an employer can do to himself.
ok and you want to **alias** images? (i.e make them look crappier?)
I'm not sure such OPs are lapped up. Can you provide examples? If somebody wants to get into this market, there is plenty of opportunity. Nobody is going to get a decent job after 6 months of dabbling, but they might get something that will give them the 18+ months of experience to start getting a little better, and that might lead to a job that gives them the 3-5 years they need to get good. Not everybody needs a degree to know how to code, and for the right role and the right candidate I'd have no problem taking on somebody that junior.
It will respect the changes you've made to the configuration, if that configuration was set using environment variables, or config files stored in `/etc/appname/`. Daemons are not automatically restarted, you need to trigger it yourself with `service appname restart`.
Because not everyone wants to / can use docker (think how you would deliver a project to a client), and it comes with additional complexity. Package managers are ubiquitous. You can see this blog article for additional context: http://blog.packager.io/post/81988994454/why-i-made-pkgr-io-digressions-on-software-packaging
PRM is basically the same thing as deb-s3 (rpm support is broken), only more complex. And FPM is good at abstracting packaging differences between deb, rpm, dmg, etc., but it does not tell you how to build a package for a non-trivial piece of software.
What happens if you are developing on one platform and deploying to another?
It should just work, if you build your packages on a similar machine to the one you're deploying to. You can try the hosted version (https://packager.io) if you don't have build machines available.
RVM by default sets itself up in your home directory. All Rubies, gems, and everything will be in `~/.rvm`. You can separate gems into different "gemsets" per application if you want.
Let me briefly explain some things. So, rvm keeps your ruby version. [Bundler](http://bundler.io/) keeps your gems for your projects via Gemfiles. For each project, you would have a Gemfile with a list of gems that you use. You can then do a bundle install and bundler will install the gems listed in the Gemfile. Now, lets see if I can answer your questions. &gt; From my understanding, RVM is supposed to be like virtualenv and Gems is supposed to be like Pip? Arg, Ive never used those tools, so I cant give you an answer. &gt;Am I supposed to load a new, self-contained RVM for each new project? No, rvm just has your rubies. Its a kinda like a ruby repo. &gt;Do I have to install RubyGems to each RVM like how I install Pip to each new virtualenv? No, you would use bundler to manage your gems. &gt;Second, is it recommended that I don't install gems like Sass to my local environment? Ive never heard anyone say that you shouldn't install gems system wide. Maybe some else has an opinion about this. &gt; Is there a way for me to change where these packages are installed/symlinked? Pip, Homebrew, and NPM all install to /usr/local/bin/ and it's first on my $PATH before /usr/bin/. I wanted to move Ruby gems here for consistency (and reserve /usr/bin/ for system files only). I would let bundler worry about keeping consistency. 
Would there be any reason not to use it for hosting a small personal site?
Yes - anyone would be able to arbitrarily write to and delete from the folder in which you run the server.
Woops.
What stinks is that the patched Ubuntu libyaml didn't actually change the libyaml version - so the patched one still returns 4.
Have you tried [exercism](http://exercism.io/)? I just finished the first exercise and I thought it was good.
I agree with you. I was only making a statement on the behavior and that it's not limited to keyword arguments.
This article doesn't seem to hold up to thoughtbot's usual high standards. Here's why: * In his **Refactoring** step he's drastically changing behavior without writing a test first. Neither TDD nor refactoring work that way. * `File.write` is an implementation detail and stubbing it makes the test very brittle. The next guy decides to use `File.open` and `File#write` and the test suddenly breaks even though the behavior didn't change. Avdi Grimm talks about the last problem and how to solve it in his (free) [The End of Mocking](http://www.rubytapas.com/episodes/52-The-End-of-Mocking) screencast. He's even using an example which is extremely close to the one from the blog post.
Other benefits besides clean validations (I use telephone numbers as an example): * You give other telephone number related methods (country, prefix, ...) a place to live. * Semantics. A string is semantically meaningless. * You can protect yourself from mutation. A string in Ruby isn't immutable which makes it easy to introduce bugs. (Imagine some view related code which tries to format the telephone number string in a certain way, but ends up using `gsub!`.) I don't think there are any real drawbacks. Of course you need to write `TelephoneNumber.from(user_provided_string)` somewhere, but I see this more as a benefit (clean code) and don't care about these 50 characters. Speaking of (AR) implementation: ~~You could provide your own getter and setters ([SO post](http://stackoverflow.com/questions/10464793/what-is-the-right-way-to-override-a-setter-method-in-ruby-on-rails)). This should be straightforward, just make sure to never leak the string representation to the outside world.~~ Use [`composed_of`](http://api.rubyonrails.org/classes/ActiveRecord/Aggregations/ClassMethods.html) (credits go to materialdesigner). BTW. these "small objects" are also called value objects. /edit: Check out `virtus` which provides a much nicer way to write custom coerce methods than ActiveRecord.
With your focus on Rails here, you might have better luck in /r/rails.
Thanks for the tip!
Well that simplified the entirety of the question. Thanks!
Np :) definitely make good use of distinct value objects whenever possible. 
This is where testing gets muddy. On the one hand I don't want to write a test that checks if File is able to write to a file. File is not mine and I don't need to test it. On the other hand, if you mock too much out of it you risk smoothing over your own errors, like in that screencast where his test fails to note that the file was opened in the wrong mode. I think Avdi's conclusion at the end is the way to go: write an adapter class for interfacing with outside APIs and then use integration tests rather than unit tests to make sure that adapter class is doing what you expect it to do. That being said I don't think this necessarily takes away from the beginner-level advice that thoughtbot is pushing in their article, but it would've been good to use a different example.
Ruby Koans Codewars
This subreddit might as well be called /r/rails.
Its still in development, but includes a lot of standard date scopes that can be mixed into any ActiveRecord model.
Take a look at https://github.com/papers-we-love/papers-we-love
Anyone have any idea? Can't find any documentation as to what is going on.
Looks nice, but unfortunate that it depends on squeel and thus AR &lt; 4. Any reason you went that route instead of using ARel?
Saw someone else mentioned codewars too so checked that out and did a couple exercises, thanks. I'll look into Ruby Koans too.
Where do you see that squeel requires AR &lt; 4? The ruby gems page just says &gt;= 3. https://rubygems.org/gems/squeel
Ack, you know what, I think I misread the gemspec over at https://github.com/activerecord-hackery/squeel the last time I looked at it. It seems like you're correct about that! That said, the gem's dead and it looks like not much progress was made on AR 4.0 compatibility - have you tested it out with AR 4 by chance?
Not yet. Haven't really had a chance to play with Rails 4 yet. Later this year I'll get a chance though.
I'll give it a shot in a few, and if I find some time to hack at it I'll shoot you a PR that uses ARel finders instead of Squeel. This is definitely something I could make use of in my codebase to clean scopes up! Thanks for open sourcing it!
thanks! With the way I built the specs, you shouldn't need new specs. 
For some reason I knew you'd be in here.
I know the guy who does: **grep -r "if"** to replace **all** the ifs with a file with a class. Doesn't care about how many times he would run this line of code or even if maybe it's dead at all -- juts *add moar files! add moar classes! just because you can!* P.S.: if you do the same, please, find another job and never turn on computer again.
The down sides are increased memory usage, slower execution, and unwieldy garbage collection.
This is poor example for beginners. It's trying to force two purposes into one method. A better example IMHO would show a string reverse method, then a string write method, then a method that calls both. The #tap is unnecessary especially for beginners. Better to use a temp variable. The file_name is coming out of nowhere. It's hardcoded into the method without any explanation as to why. Better to make the filename a param. 
So you mean the downside is that you're executing Ruby?
Rule of thumb: if you're writing methods to do funky stuff with attributes of your object then you may want to consider composed_of in Rails. If you smell the need for normalisation then don't try and be clever: just split it out and normalise it properly.
Contracts are not "a method for enforcing" type safety. They are a form of tests, specifically "Built-in" Tests. A Type is a complex thing... but in most languages it describes the attributes and behavior of a thing. In Ruby the type of an object is defined by its behavior during execution =&gt; Duck Typing. You can see Types as very simple built-in tests that are executed by the compiler/interpreter. A Contract is a test that is being run every time the code is executed. By being built directly into the code, it is much easier there to check for pre- and post-conditions of a method and being able to leave the object in a valid state after the method execution is over. You don't need to write explicit test cases where you need to setup test data, execute the code and so on. Contracts are just the simplest form of a unit test where you can put much more logic than into a Type definition. In my opinion Contracts are exactly in the spirit of ruby because they are test that live directly with the code, are easy to read and flexible. And through the dynamic nature of ruby it happens quite a lot that a nil Object pops up through your code and causes somewhere else an exception. Contracts can help a lot to catch this and other types of errors early. If you use them as simple type checks you're doing it wrong. Use them for behavior checks, pre- and post-conditions of a method. I highly recommend reading the chapter "Assertions" from Robert Binders "Testing Object-oriented Systems" if you want to know more about the power of built-in tests. 
would be fantastic if you make it an engine rather than a stand alone app
This is my favorite tutorial because it is the hard way, and made me learn good habits of commenting code, and then taking other people's code, and commenting it to understand what is going on. [Learn Ruby The Hard Way](http://ruby.learncodethehardway.org/book/)
Thanks for the feedback. I'll add those shortly. Right now its just a library that was extracted from an existing codebase so it has some of the weird artifacts from 5 year old code.
created an issue for it: https://github.com/descentintomael/include_date_scopes/issues/3
Updated to 0.9.1 and removed Squeel
When you say "NOT read-only" do you mean literally make it so that it cannot be read? Or make it "read-write" Edit: Also... do you want this permission to be given to the owner or to others or what?
Just declaring the directory task doesn't mean it will be invoked. You have to set the directory task as a dependency of some other task task :default =&gt; 'test/example/foo' directory 'test/example/foo'
Very cool. Code is pretty clean. I left a git issue for something small I thought could be improved.
You should master learning frameworks, master learning new languages quickly, master thinking about problems in a way that in translatable to any framework, then translate to the framework you are currently using. To master job security you have to master retraining yourself.
You're looking for this: [File#writable?](http://ruby-doc.org/core-1.9.3/File.html#method-c-writable-3F) Simple usage: `File.writable?('/etc/passwd') #=&gt; false` PS join us over in /r/askruby!
I also wrote a pure-ruby backport/polyfill at: https://github.com/jrochkind/scrub_rb It's pure ruby with no need to compile native code, so works fine in a jruby deploy and anywhere you don't want to or can't compile native code. My pure-ruby implementation is about an order of magnitude slower than the native code (and I'd guess slower than some possible Java implementations for jruby), but I don't generally use String#scrub in 'inner loop' type places I care about squeezing maximum performance out. Also, my pure ruby implementation isn't _entirely_ identical in output to ruby 2.1 scrub, known differences mentioned in README, they aren't ones that matter to me -- it has been tested on ruby 2.1 scrub test cases, with failures noted. 
Glad to help =)
That is not in any way equivalent to checking read-only file attribute. Even if it can fit the bill in most apparent use cases.
Awesome. Thank you for that. I saw some other examples, but they were placing a file inside of the directory. I suppose that's how that usually works though.Thank you again for that answer. 
While technically true that it isn't actually equivalent, I think it's functionally equivalent for Windows. In fact, it doesn't even check to see if the file's in use by another process (which will cause most file ops to fail). Can you tell me a case where it's not accurate?
Lovely :-)
Any case at all. Read-only attribute is not equal to having a write access, while having similar effects. If you're filtering out (or in) read-only files before performing a batch operation with elevated or switched privileges, you can't rely on `#writable?`. And it's a decent idea to not ask for permission elevation without really good cause. On the other hand, if you rely on `#writable?` before removing a file, you're as screwed, as on Linux you won't be able to delete a read-only file even if you have write permission or are a superuser. You'll get an EPERM exception. `#writable?` checks for ability to write to a file, using `eaccess` C call. It is not equivalent to checking a read-only attribute, even if it suffices for most cases, by a virtue of being a better solution to initial problem.
We're talking about Windows. Can you give me a situation where it wouldn't work in Windows? There *may* be some UAC-controlled situation I'm not thinking of, but I can't really imagine it... `File#writable?`, as far as I can tell, returns exactly the read-only attribute value in Windows.
coderbyte.com A lot of interesting problems once you get past the beginner stuff. Highly recommended. 
You rock!
Thanks! It was actually way easier than I thought. Only took about 5 min to implement.
`File#writable?` returns [effective user's ability to write to file](https://github.com/ruby/ruby/blob/1aa54bebaf274bc08e72f9ad3854c7ad592c344a/file.c#L1505). No guesses involved. It means, that if you don't have access to a file, it will return false, even if read-only attribute is not set. Windows has powerful file system access control, which is not limited to basic attributes.
I understand that. But in Windows, if the user's permissions only allow read access, any properties will show the "Read Only" property as flagged. The only way that it could be a problem is if the files being touched are set to be acted upon by another user at a later time -- which would require a separate session, except in UAC scenarios. Thus, as I said, it is *functionally* equivalent. 
The only time I run into this issue is when I use system ruby instead of an Ruby version manager like Rbenv or RVM. Xcode 5.1 and clang did some funny stuff Ruby and Python that come by default on Mavericks. I help out on the Boxen project located on GitHub and people who have been setting new machines lately have been getting this issue all over the place.
&gt; But in Windows, if the user's permissions only allow read access, any properties will show the "Read Only" property as flagged. This is [blatantly false](http://technet.microsoft.com/en-us/library/cc938434.aspx). You can verify falsity of it by checking file attributes and access permissions for almost any file in `%systemroot%\system32`.
Indeed. If you're placing stuff in a folder, chances are you want a directory task, to make sure the destination actually exists.
In this particular example: def total_price products.sum(&amp;:price) end Does that execute a sql sum, or does it fetch all the products and then sum them all? I would think that this would be substantially faster (note the upper case P): def total_price Products.where(price_list_id: id).sum(:price) end But maybe products.sum is already smart enough to do that? The "solution" given in the article will definitely walk through all the objects and add them up in ruby: def total_price(items) items.map(&amp;:price).inject(:+) end So yeah, the tests are way faster, because there isn't a database involved. Ruby is really fast at adding two numbers together! But now production is hosed, because it has to fetch every item from the database and add it up in Ruby.
The need to *test* `File` is a function of being *coupled* to `File.` Being coupled to `File` isn't bad, because `File` hardly ever changes. Unix filesystems have been around for decades. The reason that mocking individual `File` methods was a bad idea, as /r/Enumerable_any mentioned, is that `File` offers you many ways to skin the cat. The stubbing is brittle because it enforces *how* the object interacts with the filesystem. Stubs that do this need to be fired. [fakefs](https://github.com/defunkt/fakefs) is the right tool for this job. It stubs the filesystem *underneath* `File`, `Dir`, `Pathname`, etc. Essentially, I want to get two things out of TDD: 1. Working code that came into existence as a *consequence* of making tests pass. 2. Unit tests that operate *above* the test object, and only manipulate the environment *underneath* the test object. The first criteria ensures that I can safely introduce changes to the object I've built. The second criteria ensures that it's easy to do so. If your TDD process isn't achieving both of these in equal measure, then you're essentially waving goodbye to your ability to refactor your code down the road.
Oh okay. I've never used a version manager before, only system ruby. Which one of the two you mentioned would you recommend? Are they a pain to set up?
check this out http://www.brpreiss.com/books/opus8/
That is awesome. Thanks for sharing!
yup yup!
I like Rbenv it's less invasive. Make sure you download the Rbenv-gem-rehash plugin. Sorry for the lack links I'm on my phone. It's all on GitHub.
Thank you so much!
The code certainly could be better, but realize that just using pop() wouldn't teach the reader anything about how stacks work. That would be like teaching sorting by calling sort(). The point of a data structures/algorithm book is to teach you how these things can be implemented, not just tell you the built-in commands for them (even if in practice you would use the builtins.)
I found this guy's repo. He seems to be updating it like once a week: https://github.com/yangtheman/ruby-algorithms
GSC 2008 project - ruby data structure and algorithms - https://github.com/kanwei/algorithms
Except now you're also more decoupled from an ORM implementation API detail
TBH, I don't think ruby is a good language of choice for those topics. Of course it is good and important to know and understand the concepts, but the point of ruby is to take a high-level approach to everything. Sorting is sort(), end of story. The implementation detail of which algorithm is used underneath is not, and should not be, of your concern when writig ruby code. It is something worth thinking about in languages where performance is (almost) primary concern - that's why it is usually taught in/alnogside c/c++. And any code dealing with those is definitely NOT going to be idiomatic ruby - as idiomatic ruby is to use the already implemented solutions. Finally, implementing algorithms and data structures on your own without manual memory management kinda beats the purpose IMO. Note: I suppose you're talking about algorithms and data structures in CS class sense - basically whatever you program is an algorithm, but in this context it refers to topics covered by the mentioned book.
This isn't dedicated to algorithms, but I think of it in the same category. It's one of the few patterns books not in Java: http://www.amazon.com/Design-Patterns-Ruby-Russ-Olsen/dp/0321490452
I'm a big fan of Rbenv too. Set it up with homebrew and install ruby-build to install new rubies. I vaguely remember having to make sure the Xcode command line tools were installed, but it was otherwise pretty straight forward. 
That is not more important than performance. PriceList is already coupled to ORM because it extends ActiveRecord::Base. That's the perfect place to put an "implementation API detail" like an SQL query. It is already hidden behind a total_price method, which is how the rest of the app accesses the information. Some day if the app is ported to some other data store, then this method -- just like any other method in any class dependent on ActiveRecord::Base -- would have to change. The more I think about it, the original post is really a horrible change. Developers should never sacrifice production quality just to make the tests run faster. The motivation for this change was that the tests were running slow; if this was already slow with a limited amount of data in the test database, what would it be like for a real user who was buying 20 things at once? 
I often wonder the same thing. I love the intent of the project, but the last time I tried to use it, it was too slow when deployed to an android phone. Also the package was pretty big when the ruby interpreter needed to be included. Things very well may have changed. I will start playing with it again if I see a ruboto app that works well on android.
Are you making a blog? You don't need Rails to use Jekyll; all you need is a web server that can serve static files and you're good to go.
I would like to combine both, example.com is something in Rails, and blog.example.com as Jekyll.
(UK dev) 1. Whenever. I generally turn up between 9 and 9.30, and leave between 4.30 and 5.30. The important thing is that the work gets done and I'm not falling behind -- and I'm the one that decides that. It's a professionalism thing. 37.5 hours per week is my contract. Side projects -- between 0 and 10 hours per week, depending on my mood. 2. I've never, ever been good at reading books for learning. I learn by doing. I spend maybe 30-45mins/day reading hacker news/proggit (r/ruby, r/programming, r/webdev) to stay up to date on what's out there. I spend about 2/3rds the remainder coding (so, 3 or 4 hours) and the other couple of hours working with the client to define features, doing feature discussion/other non-programming tasks with the team. 3. From -2000 LOC to whatever. There's no real metrics. Generally I aim for one 'story (that's a 'thing' -- feature or bug or investigation etc)' to be completed every 2 days or so. If a story takes any longer than that it should have been split down into sub-tasks. "What are you supposed to finish" tends to be monitored on a weekly or bi-weekly basis -- you commit to finishing X amount of work in the next week or two, and then if you don't meet it, you think about why. Did you underestimate? Were there things standing in your way of getting them done? 4. If it's required or even related to the task in any way, yes, i bill. If their feature requirement requires me to use an external API, hell yes I'll bill for the time taken to read for it. But I don't generally itemise at that level -- "37.5*hourly_rate this week please." is as far as I normally go.
Gotcha. Well, they are two different things, and it's probably best to treat them as distinct projects. Jekyll is a ruby script that reads primarily text files in markdown format and turns them into HTML files. The idea is that you can write posts in a text editor without having to do all the HTML yourself. The Jekyll installation instructions are here: http://jekyllrb.com/docs/installation/ As for Rails, it is a framework that you build web applications on top of. The Rails documentation is very good. I'd start here: http://guides.rubyonrails.org/getting_started.html There are also other options for hosting your Rails applications if you don't want to hassle with setting up a VPS yourself, such as Heroku.
Thanks for the help, also to the guy that said you need a degree you do not.. most jobs i have seen are not requiring it.. thats a thing of the past.. thanks guys!
Jekyll is not a runtime but generates files right? You could simply SCP/FTP the files to the server.
Digital Ocean for hosting plus Cloud66 for deployment is what in currently using for my latest Rails project. It's a match made in heaven. Cloud66 gives you the ease of deployment like Heroku, but you still own the VPS so you can get in there and hack around to get Jekyll working alongside your Rails app, so long as you don't interfere with that Cloud66 is doing to your box.
It took me about 4 good days of slowly knocking the wall down with my head when I decided to do what you're doing now. There was no book then though. You'll get it. Just power through. 
use rsync for best results
I'll check Cloud66. Not sure if I can afford the pricing yet. So basically Digital Ocean + Cloud66 = Heroku? I'm going to probably start with DO first then add Cloud66 once I have more income. It's more of for practice actually, since our startup is on Heroku and I think we will move out of there at some point.
Yup possible but I'll look for something more automated. I used to do the FTP thing back when I was in PHP, which was cool at first, but I think I want something more automated now with scripts, without being as costly as Heroku.
Oh yeah that's about the time frame the developers I talked too took as well (days). Did you do it alone? (I think for this type of thing you have to do it alone since I will be Googling a lot anyway.) Was there any specific blog post or gotcha that you have? From what I've seen I shouldn't confuse Capistrano 2 stuff with Capistrano 3.
Honestly when I watched that video a few months ago I didn't understand anything, I hope I will get it better now.
Yeah, for a business the cost is a no-brainer for us. Gotta spend money to make money, and the time and headaches it saves us is worth it. Cloud66 actually compares themselves directly to Heroku here: http://help.cloud66.com/your-account/pricing.html
I made a quick write-up about hosting and deploying a static Jekyll site [here](http://obedespina.com/blog/2014/03/29/create-deploy-host-with-jekyll/), so it may be helpful to get your blog up running quickly. DigitalOcean has a droplet with nginx/Unicorn/Rails already installed and configured; I've used it a couple times and it was much easier, though I recommend you go through all the nginx and Unicorn config files just to get a feel for how it all works together. If you're interested in further automation, you can look into [Chef](https://learnchef.opscode.com/). With Chef, you can run a script to configure your whole stack to get your app and deployment working; something like [this](https://github.com/acidlabs/chef-rails).
You're on the right track, but you're going to need a fair bit more than just Jekyll and Rails. You'll to know how to configure vhosts in Apache/lighttpd, or some other web server stack as well.
Are you comfortable with Linux? If not, your first stop is learning a bit more about that. Otherwise, grab yourself a $5/month instance from DigitalOcean and start playing. They have some good guides for getting started as well! i.e https://www.digitalocean.com/community/articles/how-to-install-rails-and-nginx-with-passenger-on-ubuntu
Seems like you're doing two different things, but expecting them to do the same thing. On the Ubuntu VM, you're installing the code via 'gem install'. But in your dev environment, you're cloning it from github with 'git clone'. Maybe there's content present on the github repo that is not included with the regular gem?
newbie mistake, I was not accounting for the possibility that the gem install files and github project files might differ at all, but that is probably the case 
We use chef, and it is a real time-saver, although the learning curve is a bit steep. You might look at [Ansible](http://www.ansible.com), as it is easier to get started with. Keep in mind that you will still need to know the minutiae of provisioning before automating it. 
I built a small Sinatra web app and instead of using a database just stored a "setting" in a file using: File.open("/path/to/file/setting", 'w+') {|f| f.write("on")} Read using: File.open("/path/to/file/setting", 'a+').read.strip Remember if you store this in /tmp/ that on reboots it'll go away. 
As long as you have a filesystem available, you can also use a similar pattern to store the bit in the filename, the file contents, or even the permission bits (on a filesystem that supports them).
Ruby has a built in standard library for doing this: PStore. A good thing about this is that is transactional. http://ruby-doc.org/stdlib-1.9.2/libdoc/pstore/rdoc/PStore.html http://robm.me.uk/ruby/2014/01/25/pstore.html (Essentially it Marshals a Hash object to disk)
This is very cool, and I never knew about it. Thanks!
It's probably a bit of an overkill for OP's issue, but it's probably better than the dozen or so usual roll you own approaches.
Hey author of Reliably Deploying Rails Applications here, great end to my Saturday coming on and seeing someone mentioning the book, thanks! If you run into any issues/ problem, feel free to shoot me a message :)
Awesome. I will, thanks Ben :)
Lots to L-o-L about here : 1. Guy idolizes Gary Bernhardt - the biggest crybaby and fraud in the Ruby community. 2. Guy programmes all the time even until 4am yet hasn't got a single OSS project on his github with more than 13 stars. I won't take your advice TYVM
1. Can you elaborate on that? I've generally been impressed with Gary Bernhardt. What in particular has he done that makes you feel otherwise? 2. OSS isn't the only measure of talent. I know plenty of programmers who are talented and for one reason or another don't contribute much to OSS. Ad hominem attacks aren't particularly effective for advancing discussions. If there are parts of his post that you disagree with it would be much more valuable to point out specifics. Were there parts of the post that you didn't like or didn't seem to be useful?
1. Read his twitter, he's an endless whinger and complainer, never actually submits PRs to fix problems but just complains. When he does write code (which is RARE, he typically produces 'screencasts' in lieu of actual programming) he comes up with laughable things like [this](https://github.com/garybernhardt/cls). The guy is an idiot, he's just a showman. Also read his interaction with charliesome (a Ruby core member) in [this twitter thread](https://twitter.com/charliesome/status/324751145451012096). Gary is a condescending douche. 2. OK.
I'd use JSON, just in case I need this state in an app in another language.
the *class &lt;&lt; self* line? if yes, then it's this. You can have ClassMethods and InstanceMethods. This method is just to define ClassMethods in a very readable format. That said, the following three codes are equivalent. --- **Defining class methods with SELF** class Myclass def self.first_class_method # do something with the class end def foo #do something to the instance end end --- **Defining class methods with the class name** class Myclass def Myclass.first_class_method # do something with the class end def foo #do something to the instance end end --- **Defining class methods with &lt;&lt; self** class Myclass class &lt;&lt; self def first_class_method # do something with the class end end def foo #do something to the instance end end --- The first and third methods are prefered. Using the class name inside the definition makes it difficult to rename a class in a text editor as you'll have multiple renaming points which will most likely cause a bug if you forget to rename one. EDIT: fixing some oops!
Here is the bug you are saying about: https://bugs.ruby-lang.org/issues/9624 It was just a typo, that is already fixed and is waiting to be pushed into some Mac OS update system. All you need is to add two spaces into rbconfig.rb: http://stackoverflow.com/a/22583048/322020 curl https://gist.githubusercontent.com/Paulche/9713531/raw/1e57fbb440d36ca5607d1739cc6151f373b234b6/gistfile1.txt | sudo patch /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/universal-darwin13/rbconfig.rb
You already have some very good solutions but here's another: [DATA](https://shifteleven.com/articles/2009/02/09/useless-ruby-tricks-data-and-__end__/)
This is a really poor article. It boils down to: &gt;I have enjoyed programming for a really long time. I'm really good at it. Here's how you can be really good at it! &gt;But first, here are my heroes and inspirations. I'm not going to actually give you any of the useful information I learned from them; you'll just have to take my word that researching them on your own is worth your time. &gt;Now, here's what you actually came to read: &gt;Use functional programming, not state. What's the difference, you ask? Fuck you. &gt;Use enumeration. Nevermind that this is one of the most basic parts of Ruby, and that I am absolutely not the first person telling you this... &gt;Use value objects. Again, I'm not going to actually give you any information about these that will be useful unless you already know all about them. &gt;Don't use ifs! They're hard to test. What should you use? Fuck you, I'm busy, I'll write about that later. &gt;Be explicit. (*he at least gave a code sample with this, so I can't give him too much shit over it*) &gt;Use lazy loading. (*Again, this tidbit could actually be useful for beginners, but I wish he had gone into more depth on its meaning.*) This *could* have been a good article if he actually expanded more, but at this sparse level of detail it feels dirty. Frankly, I there is so little in terms of content here that the title just feels like clickbait. Color me disappointed.
Cheers, appreciate it!
Something like what Java has, I assume.
&gt;&gt;strtotime: Why would I want specifically English support in a core library? &gt;Because it's what you might need in a web app Being a webapp excuses you from properly localising your shit? I had no idea.
The most popular languages, like Java and C++ and Perl, have, in some sense, too many libraries rather than too few, in the sense that there are so many that it can be hard to find the good ones. Few (or no) people are aware of the full extent of what is available just in C++ Boost or in Perl CPAN, let alone the totality of libraries available somewhere on the web. By that measure, Ruby, too, has more Ruby Gems than most people are ever even aware of, although fewer than those more popular languages. The question would seem to be about *particular* libraries/functionality that are missing, not simply the total count; I was rather disappointed that the OP never replied to mention any, since it is believable that there is a reasonable list.
I was wondering about this and checked for Norway. 3 or 4 job listings... Doesn't seem to be such a big thing here. Not that I mind tho, it's fun to work with
&gt;I watch 2-3 videos A DAY on programming, many of the times I have already &gt;seen it several times, and I instead play it in the background and listen while &gt;I code. What do you mean by this? Does that mean that you follow the code in the screencast or something else? I'm asking this because I find it very difficult to multitask while watching programming screencasts, so I usually just focus on the actual screencast and pause here and there to check out the examples in the REPL. I also play some segments a couple of times until I get a better understanding of what the author is trying to express. 
Friggin awesome! I'm going to have to check this out.
Unapologetically OSX? But you run it on Travis-CI which uses Linux images right? So shouldn't it be OSX and Linux? (Or am I missing something)
Scrape HTML or buy your way into being a partner
Are you scraping netflix or somewhere else like rotten tomatoes? I know they have links to netflix on their movie pages as well.
The article needs some work. The first paragraphs, for example, belong on an "about me" page. The rest of the article, the list of concepts, could be useful to keep in mind when coding, but lacks explanations and an overall theme. Some paragraphs don't have any apparent connection with the title at all. Lazy enumerators make my code easier to change? I'd love an explanation there! "Programming concepts I use in my Ruby code" would be a more fitting title I feel. I hope you will rewrite this article to be more focused and more useful.
second example also shows YAML::Store, which does not use Marshal :)
Thank you for explicating what I knew intuitively as I read this manifesto. This isn't progress, nor is it good Ruby. It is, as you say, an attempt at shoehorning Ruby into a functional programming mold. Why not just use a functional language and be done with it? Ruby isn't meant for this. It's like trying to 4-wheel-drive with a Prius.
&gt; an attempt at shoehorning Ruby into a functional programming mold. this is absolutely what this is, in an attempt to turn each object into a named lambda of its own. except: module GoogleProfileHtmlDownloader extend self def download(url) scrape(url) end private def scrape(url) html = crawler.get(url, followlocation: true).body return rescrape(url) if has_moved?(url) html end end is just a cheap way to get around your own "rules"; that scrape method should be inlined.
Don't? They obviously don't want people querying them, so don't do it.
dropdown menu on the front-page itself, or dropdown menu in some hypothetical admin panel? also, for location-aware information, you need a way to tag the content by geo-coordinates, as well as use the browser perhaps to ask for the person's current lat/lng, or geo-code based on ip address from the request. [This](http://robots.thoughtbot.com/new-ebook-geocoding-on-rails-your-map-to-geocoding) is probably a good place as any to start.
Bah watever, so sick of this cloying bullshit.
путин - хуйло!
No disrespect to mr. tenderlove, but I kind of wish conferences would invite fresh faces to speak.
Thanks for your reviews! I am a relatively newbie and found some of the rules to be strongly opinionated. Will try to message the author to join the discussion.
it would be great!
+1 for RSpec - it's really intuitive
If you're looking for practical use of ruby you can try [open source rails](http://www.opensourcerails.com/) website.
Start wit MiniTest and then move to RSpec if you don't like it for some reason.
Thank you for your response. Through the research and your responses, it seems like ruby is a good language to learn. I do not plan to become a master of programming but it is definitely something that will expand my horizons. Thank you again.
Have you considered browsing the projects listed on: http://issuetriage.herokuapp.com/#ruby780777362602580265 ?
there is an interesting discussion on the topic here: https://gist.github.com/glv/9794089
! Is not the same as (). ! Is just a ruby way to say "hey, something is gonna change in this method. () is a way to call a parameterless method, which according to the ruby style guide, you should avoid if you're calling or defining a parameterless method. Having said that, for things like this check out the ruby style guide (Google for it).
&gt; In fact `Set#include?` will always take the same amount of time, regardless of how many elements it contains, whereas `Array#include?` takes longer the more elements in the array. What? No. `Set#include?` takes `O(log n)` time, where `Array#include?` takes `O(n)` time. Still proportional to the input, but exponentially faster for growing `n`. EDIT: You can downvote all you want, but you still won't get `O(1)` lookup for a Ruby Set or Hash, no matter how hard you try. The only circumstance in which that is possible, is if you choose a perfect hash function for your input, which is not generally the case, especially not "regardless of how many elements it contains".
Thanks, this is actually pretty useful.
Sounds like you want to grab the [Pickaxe book](http://www.amazon.com/Programming-Ruby-1-9-2-0-Programmers/dp/1937785491/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1398174973&amp;sr=1-1&amp;keywords=pickaxe+book). It's a tome, but it'll take you through the Ruby way of doing things. [The Ruby Way](http://www.amazon.com/The-Ruby-Way-Second-Edition/dp/0672328844) is great and easily accessible, but I don't believe it's been updated for Ruby 2.0. Lastly, you can always skim through the [Ruby docs](http://rubydoc.info/stdlib/core/frames). Edit: You should also check out [POODR](http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330). Great way of learning how to refactor!
this is kind of a silly book, but it's about ruby. and pretty entertaining honestly. [Why's Poingniant Guide to Ruby](http://www.rubyinside.com/media/poignant-guide.pdf) EDIT: i hadn't read this in a long time so i was skimming it, but seriously if you can get past how out there the book is, its honestly a pretty legit way to learn ruby. EDIT AGAIN SHIT: also [Eloquent Ruby](http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional-Series/dp/0321584104/ref=pd_sim_b_3?ie=UTF8&amp;refRID=0CNPBXH182K43CXK56CF)
Thanks. I thought it meant "change me don't not my clone". I'm guessing this just shouldn't be done.
Thanks I've seen references made to the Why's Guide book. You just sealed the deal for me. 
so I totally misunderstood that convention. thanks for the clarification. are there more resources that outline these ruby specific conventions? 
Wow, this book sure is "out there". It's a great resource. Thanks.
It's just a character in the method name. Ruby doesn't know or care about its meaning. Convention tells that when you see a method that has a "bang version", it *should* mean that the bang-less version is pure, while the bang version is impure. It's still up to the author, though, and you should *always* make sure by reading the API docs.
Ruby's syntax is actually a little bit different than other mainstream languages in certain parts. It's inspired in Perl, so you might find it a little bit weird if you come from Java or Python (my case). Here are some tips to get used to the language. Take a time to read part of the docs. I recommend taking a look at the Enumerable module, as it's one of the most useful. http://www.ruby-doc.org/core-2.1.1/Enumerable.html Also, if you are not sure of what a certain sign does in Ruby (for example, do you know what $ and &amp; stand for?), Google will make it hard for you to search these symbols. In this case I recommend using http://symbolhound.com . It's a symbol sensitive search engine. Perfect for search about those weird operators in a lot of programming languages. Last, try to do some real work with the language and use Google when you have a question, such as how to convert the Hash to json, or how to have the unique elements of an array. Here are some suggested topics worth researching about: - the difference between blocks, procs and lambdas - convert a symbol to a block - optional hash argument in methods - how to write a gem - rspec syntax - why not to use the 'and' and 'or' keywords (prefer &amp;&amp; and ||) 
What a great list of suggestions. You should definitely be someone's mentor. Thanks.
i think it's a blast! kind of amazing that you can learn ruby from what is essentially a coffee table art book? It's certainly got to at least be a contender for most interesting programming manual ever.
There are lots of style guides out there, just google a bit. However, [Matz](http://en.wikipedia.org/wiki/Yukihiro_Matsumoto) himself [has an opinion on bang methods](http://www.wobblini.net/bang.txt). In essence, he says that *method!* is meaningless unless *method* (no bang) is also defined. All the "bang" version of the method means is that it's a less-safe version of the non-bang version. 
[Give Learn X in Y Minutes' ruby guide](http://learnxinyminutes.com/docs/ruby/) a read. It's a quick primer to ruby specifics for people who are already programmers. (Full disclosure: I wrote the original version of that document)
I've seen people do all sorts of things they shouldn't do, and every coding convention you can think up has been broken ... sometimes even in widely distributed code. Horrible, terrible things that would make your eyes bleed. In many cases, the code even works!!! But in this case [/u/strelecxy](http://www.reddit.com/user/strelecxy)'s opinion [is shared by Matz himself](http://www.wobblini.net/bang.txt). 
Also in Rails it generally means I throw an exception instead of returning nil
Definitely worth a read. It's getting a bit dated now, but much of the meat is still relevant. ...and there's bacon.
"This is a hybrid of Array's intuitive inter-operation facilities and Hash's fast lookup." - http://ruby-doc.org/stdlib-2.1.1/libdoc/set/rdoc/Set.html Hash lookup is constant time, right? Run in 2.1.1: require 'benchmark' require 'set' A = Set.new((1..1_000).to_a) B = Set.new((1..10_000_000).to_a) Benchmark.bmbm do |bm| bm.report('1K') { A.include?(500) } bm.report('10M') { B.include?(5_000_000) } end Rehearsal --------------------------------------- 1K 0.000000 0.000000 0.000000 ( 0.000012) 10M 0.000000 0.000000 0.000000 ( 0.000007) ------------------------------ total: 0.000000sec user system total real 1K 0.000000 0.000000 0.000000 ( 0.000009) 10M 0.000000 0.000000 0.000000 ( 0.000007)
&gt; Where can I learn the ruby way of things? for ex: I think ruby does str.reverse! rather than str = str.reverse() You want [Eloquent Ruby](http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional-Series/dp/0321584104). It's a book about writing *idiomatic* Ruby, which is what you're asking about. The Pickaxe book and POODR are both excellent books that you also want, but Eloquent Ruby is probably the best book for what you're specifically asking about.
`O(1) Set#include` since it just uses an internal Hash representation of the dataset. &gt; http://ruby-doc.org/stdlib-2.1.1/libdoc/set/rdoc/Set.html # File set.rb, line 80 def initialize(enum = nil, &amp;block) # :yields: o @hash ||= Hash.new enum.nil? and return if block do_with_enum(enum) { |o| add(block[o]) } else merge(enum) end end # File set.rb, line 204 def include?(o) @hash.include?(o) end 
Thanks for the the emphasis on "idiomatic" ruby. I don't yet know the lingos and that phrase alone results in a plethora of pages, tutorials etc.
That's a cool website. Thanks for the share and the time it probably took to write the ruby version.
Yes, throwing an exception generally means "more destructive".
Whatever. Pick one and start. Throw a dice if you cannot decide. You should not delay starting with TDD for this - both options are good. By the way: http://articles.coreyhaines.com/posts/dont-always-need-a-testing-framework/
That was kind of my point :) But thanks for pointing out the slightly misleading heading, I've updated it now so hopefully things should be clearer.
These always show me something I can't believe I've missed until now. How did I miss `warn` all these years? If I had a nickel for every time I've typed `STDERR.puts` in a CGI script ....
Just a quick note, the '!' is not available to every method, it's the name of the method, that generally does what you state. However, the '!' really means, this method is destructive and could be dangerous to use. It's fine to use these methods, just make sure you know what they do. On a similar note, when a method returns a boolean, it is Ruby convention to add a '?' at the end of the method. For example def hungry?(person) if person.hungry return true else return false end end
MiniTest supplanted Test::Unit when Ruby 1.9 was released and was largely an "under the hood" change. The comparison is between unit test style assertions vs. spec-style assertions.
Nice :-)
You can try this website: http://www.codetriage.com It sends you issues via email from projects you watch.
Hash still cannot do lookup in `O(1)`, which is physically impossible. Your benchmark is pointless here?
It is literally impossible to do a precise inclusion check faster than `O(log n)`. You can lower the constants with a hash function in front of it (at the expense of memory usage), but you're still going to have to account for an n-proportional collision list, which is probably a balanced tree structure of some sort. The only way to achieve `O(1)` lookup is with a well-defined input range, a perfect hash function, and something like a bloom filter.
Hash maps are generally viewed as O(1) for the average case. See: https://en.wikipedia.org/wiki/Hash_table My benchmark was intended to demonstrate the speed of a lookup between a smaller 1K entry set and 10M entry set. Both returned in approximately the same time. If it followed O(log n) you'd expect some increase in the significantly larger set, right?
I always liked cookbooks to learn language specific idioms, although it looks like the Ruby Cookbook is from 2006, so I don't know if it is out of date by now.
I have no idea what you are talking about. All Ruby objects are hashable and `Hash` has amortised O(1) lookup. Are you confusing Hashtable lookup and Binary search? Genuinely curious as to your thought process here. Incidentally, [this is the hashing function that Ruby uses.](http://en.wikipedia.org/wiki/MurmurHash)
O() can refer to either worst case complexity or amortized average complexity, the latter interpretation is being used in the article.
MurmurHash is a great hashing algorithm, but *it's not a perfect hash function for all inputs*. You will not achieve O(1) hashtable lookup unless you have a perfect hash function. Collisions will occur, and are proportional to n. A hash table is organised as a list of buckets. The hash function determines which bucket an object goes into. If your hash function is perfect (which is possible if and only if you know the exact possible inputs), your load factor is equal to 1, you can get O(1). If your hash function isn't perfect, collisions will occur, and multiple objects will have to go into each bucket. Each bucket is likely organised as a balanced tree, because that is generally a good idea. That bucket then has O(log n/k) lookup time. For any arbitrary Set only doing lookups, k will be a constant, hence O(log n). Having a load factor close to 1 improves lookup performance, but at the expense of memory, so most implementations go for a load factor higher than that when dynamically rehashing.
Avoiding global namespace pollution is just one of the benefits of not using global variables, anyway, fair enough. :)
Just to clarify are you referring to O(1) in the average case, worst case, or both?
I'm obviously biased but, for me, when I'm starting out with something new I wind up asking a bunch of why/how questions. I want to be able to understand what I'm doing and how it works and that most often comes, again, **for me**, by peeling the onion back and looking at the layers until I'm satisfied. With minitest you can peel back the onion as far down as you want and you won't spend more than about an hour doing it. If you want to know how the assertions work, read `lib/minitest/assertions.rb`. It is only ~700 loc (incl doco). If you're satisfied at that level of onion, stop there and go write some tests. If you're more curious, look deeper and see how it runs stuff. Between minitest.rb and minitest/test.rb (ie, _all_ of the mechanics) there's only ~1000 lines. If you want to write spec-style tests and want to know how they're different, `lib/minitest/spec.rb` is &lt;300loc. I don't think this is quite as feasible with rspec. There are 130 _files_ across the codebase and they weigh in at a hefty 19.4 kloc. Yeah, you can do it, but you can't hold that all in your head and you won't have the same level of understanding you would doing this with minitest.
It's not Ruby. It's **Rails**Club.
https://github.com/m0wfo/cups
Thats exactly why I am also biased to MiniTest, its so light weight and small. I hope to understand a fair amount of it. But RSpec's popularity kind of freaks me out. I am unsure whether, I will be able to collaborate with someone with it. I mean if I am working with another programmer on a project, most likely choice for TDD will be RSpec. So was thinking, would it hurt at this point. Also another reason is that almost all tutorials/walk through seems to be written in RSpec. 
Do you really want anti aliased mario? Pixel art is meant to be pixelated.
Checkout http://issuehub.io/. They've got a good interface for picking off issues.
A year ago I would have said RSpec without any hesitation. Now, MiniTest::Spec gives you ~90% of the expressiveness of RSpec with ~10% of the "magic". For TDD, use MiniTest::Unit, but please learn BDD and MiniTest::Spec (which will give you a leg up on RSpec if you decide to cover all your bases later).
True, the current version is also a significant factor in making a judgement. Most of the talks/tutorials/comments seem to be comparing the old MiniTest. It seems now its really good.
The ! Symbol just means that the object will be modified directly. So if your string, string ="foo" string.reverse! Would directly make string = "oof"... If you just said string.reverse then it would reverse the contents of string without actually modifying it. You would have to do otherString = string.reverse. This would make otherString = "oof" and string would still be "foo". 
Codeschool. Rails for zombies. Hands down the fastest and most practical way to learn
Im getting a Oops! This event could not be found.
There is not going to be a standard answer... Anywhere from none to a lot. I use a little JS on almost every app, however how much varies considerably. Everything from a few minor dom transformations, to some more serious rails SJR all the way up to apps that are merely a rails API with full javascript frontend.
I'm absolutely with you on the worst case being something like O(log n) or O(n) depending on the hash function being used. I'm no expert in this but my understanding was that while not perfect, good hash functions can approximate perfection (i.e. O(n)) for the average case by creating a good distribution and redistributing if needed based on additional inserts. It think this is where people are disagreeing with your original statement.
Would just loading active support work? require 'active_support/core_ext/numeric/time' require 'active_support/core_ext/date/calculations' rand(1..1825).days.ago
1. Come out of your semicolonness 2. Learn to "code in ruby" (different from java, php, python). Ruby has many things unique like blocks. 3. Get a copy of Agile Web Development with Rails 4 4. Next step Programming Ruby &amp; Meta Programming ruby 5. RubyInside blog is always helpful May I recommend Lynda Rails 4 essential training (Paid) and Rails 4 tutorial by Michael Hartl(free) Rubycasts when implementing particular functionality, stackoverflow, rails guides and APIs **Disclaimer** - I am no pro **Edit** - Browse through other posts, use search feature on sidebar.... search for "learn" plenty of things to explorer For interactive tutorials Rubymonk (covers meta programming)
I am going to try this out but you need to do this x_var + y_var instead of '#{x_var}' + '#{y_var}' There are a couple problems - single quote strings are immutable so string interpolation "#{}" will not work - You are "casting" your variables to string by putting them into a string Also did you take a picture of your screen?
 x_var = gets.chomp.to_f y_var = gets.chomp.to_f if op == "+" puts x_var + y_var elsif op == "*" puts x_var * y_var elsif op == "/" puts x_var / y_var ... 
Here is a working version of your program https://gist.github.com/tanema/99fe3570869d3e193f0e
require 'date'; [*DateTime.new(2009, 5, 23)..DateTime.now].sample
 &gt;&gt; 5.times { p Time.at(Random.rand((Time.now - (60*60*24*365*5)).to_f..Time.now.to_f)) } 2013-04-23 06:22:04 +0000 2012-12-09 04:56:15 +0000 2009-06-30 21:37:36 +0000 2012-11-04 16:32:40 +0000 2012-03-22 12:48:18 +0000 =&gt; 5
&gt; just ruby &gt;&gt; Would just loading active support work? No.
 &gt;&gt; Time.at(rand((Time.now - (60*60*24*365*5))..Time.now)) =&gt; 2012-11-08 13:45:31 +0000
&gt; To manipulate the DOM are you using plain javascript, JQuery or AnguylarJS? I know all three of those approaches fairly well, work with the web long enough and you will too. Pretty much every modern website is going to have some form of DOM manipulation (greying out something, dismissing alert boxes, whatever). If you're new you can certainly get by with just jQuery as a path of least resistance, but eventually you'll have a larger site and you'll create what's known as 'jQuery Spaghetti' and then you'll turn to an alternative to using the jQuery hammer for everything. &gt; What do you mean by working on the API side? I'd say your average Rails site has controllers that create instance variables that are consumed by HTML views and the controller then returns that HTML to the client (a web browser) in the response. The site I work on has corresponding native apps that do not render HTML they are clients that utilize JSON responses, so while the controller does a lot of the same "data connecting", I never have to actually write HTML or JS for this type of work (instead I use JBuilder templates much like you'd use ERBs). 
Minor quibble: The hash function itself should always be O(1). The worst case times are based on collision resolution. The times vary because the collision list can be implemented in various ways.
Thanks evilduck. Then first is important to learn Javascript first and then learn Ruby and Ruby on Rails or can I learn them simultaneously?
try going to http://www.theodinproject.com/studygroups and choosing the ruby tab
I just updated the link, not sure what happened there, but you can also check the Odin link too to access the course we will be following. 
I noticed you didn't use the If then structure. any reason you should or shouldn't do that?
Great thanks, I've posted there.
In general a case statement is faster in most languages (ruby included) and is generally a better fit for flow control when comparing the value of a single variable. Also I am lazy and a case statement is less typing by a bit which is why I also use `p` instead of `puts` or `print`.
just go for it.
Cool data! Is there any anecdotal evidence of when and how these vulnerabilities have been exploited?
do it the ruby way, send it ... require "colorize" $stdout.print "simple calculator\n\n".yellow $stdout.print "operators are:\n".green $stdout.print "\t+".blue $stdout.print " -".blue $stdout.print " x".blue $stdout.print " /".blue $stdout.print " ^\n\n".blue $stdout.print "x = ".green x = gets.chomp.to_i $stdout.print "y = ".green y = gets.chomp.to_i $stdout.print "op = ".green op = gets.chomp.to_sym op = :* if op == :x op = :** if op == :^ result = x.send(op,y) $stdout.print "result = #{result}\n\n".green 
If you have no programming experience whatsoever, I would not try to sit down and seriously learn both at the same time; while there are some commonalities between both languages, there are countless important differences as well and it might be fairly confusing keeping that straight conceptually. Further, fully understanding Javascript is not a critical step in the process of creating a web site (in the simplest form). A lot of times a simple site will just need a few lines of custom jQuery written and the bulk of the work will be on the Rails backend or the bulk of your fancy front-end will be enabled through something like Bootstrap's JS libraries. Since you can't very well write a Rails-based website with Javascript, I would say learn Ruby *and* Rails[1] first, then learn JS as needed. Or choose a NodeJS based backend server instead so you only need one language to start with. [1] Don't neglect learning Ruby as a language independent of its use in Rails. Rails is often described as doing "too much magic", mostly by people who have never seriously tried to learn Ruby.
I'm new to ruby, how common is it to send messages as opposed to calling methods. I understand in this case it's awesome since what OP is getting from the user is the same as the function name, but in practice which is more common?
I don't know, but I use it often in context of dynamic programming
I first started with Ruby the Hard Way (http://ruby.learncodethehardway.org/book/index.html). You can pretty much skip/skim the first 9 or 10 Chapters if you're not a total beginner with programming. Overall, getting into methods/classes/data types was what really got my head around Ruby. I started this as a total noob before heading to Dev Bootcamp in San Francisco.
jump in with both feet and keep an open mind. if something does not make sense, don't worry you will understand later. to get familiar with ruby try https://projecteuler.net/ to get started with webdevelopment look at http://sinatrarb.com . it is easier to understand. pick up a small project. make something. solve one problem at a time. use google. also try rails tl;dr do not pay for courses
There's a gem for this. It's called [lonely_coder](https://github.com/trek/lonely_coder).
Thanks evilduck for all this good information..I will follow your advise..
The sessions are really weak. I guess I'm not sure what I was expecting, but this isn't it. I have talked to a few other people that are also disappointed. Lots of people walking out of talks.
I've been disappointed talks-wise about RailsConf since 2010, and despite that I don't like to miss a single one (like this one T_T) because hanging out with people that does the same as me, and having the possibility to meet new people and speaking in person with people that knows a bunch a lot than me is AWE-SOME, so, if you are in Chicago and you aren't enjoying the talks, ditch them, just go and say hello to the first people you see and spent some minutes talking to them, rinse and repeat... and yeah, RailsConf sucks.
great.. I'm going to give it a try
Nokogiri. It's a pain to install but worth it if you can.
I'd love to use it, but I just can't seem to get it correctly installed on my Windows x64 Ruby 2.0 installation.
Considered vagrant? Might make life easier for you.
I use it very infrequently, though I do think it is awesome. I've just not gotten used to using it for development. Anyways, I'd like the users of my library to be able to run it natively on Windows x64 without any issues.
I've not gone to any sessions except for the DHH keynote as I'm only here to do interviews but so far my experience has been overwhelmingly positive. The vendor area is a lot of fun (surprisingly) and the talent in the room has been very inspiring. DHH, not surprisingly was an excellent source of discussion and debate. If you did catch his keynote (or the fallout thereafter) you might enjoy this [interview that was immediately after his keynote too](http://www.ugtastic.com/david-heinemeier-hansson/). 
After two days I haven't really been impress with any talks I have attended.
Lol you sound like a douche
Nokogiri is very easy to install on Windows. The devs already made all the work and bundled everything inside the gem. What's exactly your issue?
Something something something hire us QA is expensive. I'm a senior developer in test at a large company. We run close to 3000 tests in an hour. QA is expensive if you don't hire the right people to set it up. If you hire someone that can set up automation correctly, your productivity goes through the roof.
Use the rubyinstaller.org build with the devkit. It should install. Also, for most uses, the x86 ruby build should work just fine on windows x64.
Awesome tips! I've added them to my todo list. thanks
Creating a self post and merely saying that something sucks is not very productive or mature, is it? I don't go to conferences to be awed or even learn that much. Sure, I expect that at least some of the talks are interesting enough to not walk out on, but the most important thing about conferences to me is seeing what is out there and meeting the rest of the community. If you don't like the talks, try striking up a conversation with someone new. Meet people. That's what conferences are for. *The people there*. Great conference talks can always be found online at any time from the comfort of your own home.
I advise [Ox](https://github.com/ohler55/ox)
You might wanna look into Nitrous.IO. When I had to teach the rails club at my uni, nitrous was a life saver. Instead of spending 3 meetings troubleshooting people's shit, just point them at pre-built templates and go from there
I'm actually currently working on a pure Ruby XML/HTML parser (https://github.com/yorickpeterse/oga) due to various problems we've had with Nokogiri (https://github.com/yorickpeterse/oga#why-another-htmlxml-parser). It's a long way from being finished but you might want to keep an eye on it. In terms of what's currently out there, there are basically 3 options: 1. Nokogiri 2. Ox 3. REXML Nokogiri is the most commonly used but requires C. More importantly it also compiles libxml2 on every Gem install unless you disable this manually. Ox is an ok alternative but you can not parse HTML with it unless you use the SAX API. REXML is garbage. It's slow, can't handle encodings very well and the APIs are not always straightforward.
Right now, I need to get some feedback.. but I'll need a hand with riak 2.0 in the near future 
So basically that was a big advertisement for "Rainforest" or whatever, which sounds like they've packaged the Mechanical Turk API for "automated" testing. The flaw in this idea is that you would somehow want your half-baked app out in a public facing server so that MTurk users could help you test it. Ummm... at my company that's a non-starter. Our apps are basically private apps, and we would never want someone on the internet to see them before we released, and even when we do eventually release, we only want a small group of around 10,000 people to ever see them.
Xmlsimple is simple
Rainforest actually supports other kinds of testers (other than mturk), though this isn't default, but is possible for companies want control over who sees their app and does the testing. If you need that, you should reach out.
Why not just get a VPS? Edit: I haz grammar
He's just using RMagick to load images. Would you prefer he write the code to parse multiple popular image formats?
Nah, bitmaps to make it easier only.
Thanks bignothing. Then in reality you do not use plain javascript but JQuery and a MVC JS framework? Thanks
There's nothing wrong with using a library that implements a specific and difficult algorithm, such as loading PNG files. In fact, this is *the right thing to do*™. If it were a trivial problem that he used a rare, unpopular library for, I can see how that might be a problem. For example, it would be a poor choice if he used a file writing library to save the ASCII file instead of Ruby's `File.write()`.
I know this it the right way to do that, but after the title I expected ruby algorithm not library. :%s/Ruby/RMagick/g
I admit, his algorithm is pretty simplistic. The interesting thing here should be the algorithm for converting a 2D array of image data into a 2D array of letters, not the algorithm for reading an image from disk.
Conferences like this aren't generally designing their programs for folks who have been doing ruby or rails for a long time. It's a fun place to congregate with like minded people from around the world, but if you are a more seasoned rails programmer you will inevitably feel disappointed if you expect mind blowing talks.
Trust me, your liver thanks you for staying home :)
cool. I followed the repo.
would this generate lots of Datetime ? i think it's not optimal
I love digitalocean, being able to destory and create droplets in seconds is brilliant.
a mature software component system that includes dependency management (rubygems)
It's up for me http://www.downforeveryoneorjustme.com/rubyinstaller.org If you're still having problems, you could report it to the Google Group http://groups.google.com/group/rubyinstaller
It's a very expressive language, so you often find your self solving a problem in many different ways. Also, rails is amazing for creating something fast. A lot of companies use Ruby on Rails for prototyping, so they show a client what their final product will look like.
I'm a lowly devops guy, not a full developer, but I find that a shell script will get to a point where it's time to flip it over to a ruby script. Often when I am getting web api data. Anything with structured data, really.
Ruby is really good at a few things on top of just being easy to read and write: Ruby's biggest strength to me is in its use of blocks, particularly in conjunction with enumerators. Ruby is also great for metaprogramming, though that's more on the advanced side.
This is often quite overlooked, it really hits you when you use another language like Python.
Seconded, faffing around with shared hosting is just not worth the pain. DIY TIL DIE
There are some ruby/rails projects on https://www.codemontage.com/ 
If you want something to "just work" I'd highly recommend Heroku. They give you 1 free Ruby process (called a Dyno) to get started and only charge you if you need to add more. You're probably used to shared hosting environments, which isn't really appropriate for modern Ruby apps. If you want some help getting setup just PM me and I can Skype/Hangout with you to walk you through the process or answer any questions you may have. Best of luck!
Everyone's pointing to a VPS. So am I... I'm partial to https://chunkhost.com/ myself. Originally started with SliceHost, but since they merged with RackSpace, I've been happy with ChunkHost.
Thanks
What do you think about the common statement that ruby's blocks are poor substitutes for real functional style anonymous functions?
How so? :)
What makes them poor substitutes? 
Boycotts? Ruby has all the equipment to do true functional programming. It's certainly not geared toward functional programming the way other languages are, so it won't be the best tool for many jobs. It's still very nice to have the ability to dip into that functionality as needed, and I've had success using it in a few real world situations. It's surprisingly pleasant.
Calling out to other programs is easy, putting variables in your calls is easy, getting input/arguments/ENV variables is easy, heck, you can even write scripts in other languages in your ruby programs and then use ruby to get the other language to execute them.
Nothing wrong with it. Python dependency management is more Unix than ruby which is fine by me.
I have limited experience, but they have pip, easy_install, and isn't there another package installer. So they don't have consensus like gems. I found it confusing, but they do have package installers now. Plus there are no Gemfiles or bundler. Maybe things are improved and I didn't know how to do things, but I found the Ruby experience much easier.
I don't quite have a full enough understanding to argue either way really. I was hoping you could enlighten me a little :)
Isn't this easier with perl though?
Sorry, predictive text. It was supposed to say blocks.
It's got a very clean syntax that lends itself to easy code iteration and development. It doesn't force you into a box, like python or other opinionated languages do, so you can truly make it yours. For me it's because it is consistent, in that everything, absolutely everything, is an object, and a lot of the ways of processing these objects just seems intuitive to me, where other languages approaches to similar problems seem contrived and artificial. That's just my opinion Ruby is also very very good at string manipulation, a trait it inherited from its ancestors. This allows the easy creation of languages such as SASS and SLIM. Throw in the ease of meta programming, and you add the ability to make powerful, verbose DSLs that dramatically extend the flexibility the language
Ruby is an excellent general purpose language. It excelles at readability and has top notch tools for making web apps, web services, and server side network apps. Its actually easy to enumerate the things Ruby is NOT good for. It's not good for situations where you need to have top tier performance (C,C++,OpenCL rule here, runner ups goes to Java,C#,Go, and Rust), high levels of IO concurrency (Go, node.js, and erlang rule here), and precise memory control (C,C++,Rust, and Objective-C win here), embedded scripting (Lua and Javascript wins here) Ruby's biggest rival is Python since their strengths and weaknesses line up almost 1 to 1, so choice is a matter of taste. Languages that can do nothing that Ruby can't do better would be Perl and PHP
https://pine.fm/LearnToProgram/?Chapter=00 Pretty decent introduction that I think people who are looking for a post about learning ruby could appreciate. Just going to sit this here.
Several thousand DataTime and a millisecond later.
I don't know perl, so I can't really speak to how they compare. What I've read (and it jives with my experience) is that ruby takes the good bits of perl (good shell integration, language support of regexes etc.) and adds a bunch of good bits from other languages (better module system, better object orientation, blocks, etc.). 
virtual box
If performance is an issue, then it's a very fair criticism. You can't do the same optimizations on Ruby that you could on Clojure or Haskell. If it's not, then I think a functional style with blocks is quite nice. I do a lot of my data post-processing for my Master's Thesis like that.
That one is with chicago vps. You have to look for a coupon code to get that price though.
I think its really easy to memoize algoriths. You just pass a block to a Hash on initialization. If there's a miss on the Hash, the block is executed and the readily stored in the hash.
I do wish that there was some kind of Monad type thing for enumerators though. Getting a nil back in the middle of an enumerator chain really harshes my mellow.
Ruby excels at not getting in my way.
As stated above, you can pack a lot of functionality into one Ruby statement. One example is this line of code I wrote recently. url = 'http://www.weatherstuff.com/api/plug_in_da_query_here' data = Nokogiri.HTML(open(url)).text.split("\n").map {|row| row.split(',').to_a} Ruby lets you chain together lots of functions that come pre made in the large standard library. Here I am using a Rubygem called Nokogiri and another called Open-Uri . Then I call a few std lib functions like split and map. Think about how many lines of code it would take to connect to a webpage in Java and then start reading data into an array. The Ruby version is a single line and it reads like an english statement.
OP should have taken screenshots of the Parley thread/messages so we can form our own opinions on what happened. You also have to remember that Ruby Rogues Parley is not an open forum (like /r/ruby), but a [paid for](http://rubyrogues.com/parley) [closed forum](http://parley.rubyrogues.com/login) (like a private HN). People (like yourself) signup for Parley because the likes of DHH, steveklabnik, garybernhardt, tenderlove, and other past Ruby Rogues guests are on there. If you rock the boat too much, users might start canceling their subscriptions, ergo you got banned.
Very cool. I was thinking about making a large scale websocket application. Rack::Websocket looks interesting. Is there any downside to using thin as the server?
.compact the array first? Or an I misunderstanding?
Yeah, I like blocks. Just interested in what people are saying :)
I once heard ruby described as 'perl designed by some Japanese hackers who has never used perl. I'm not a perl user either. I'd be interested in how they compare.
I see, makes sense. So would you pass a block to reduce to handle the nil values, rather than using `:+`? That's probably what I would do.
Virtualenvwrapper in python is pretty cool, and also used for package management. I found it to be one of the coolest things in python. Also pip does a very good jon at maintaining packages, their dependencies etc
You could always use to_i or to_f which converts nil to 0 arr.map { |e| can_return_nil(e).to_i }.reduce(&amp;:+)
Rubymine works perfectly on a windows box - I use it at home. The problem is that Ruby is still not 100% at home on windows, and it takes a lot of work to get it running well. If you use a JRuby runtime on windows rather than a 100% pure ruby, you should have no issues with it at all.
The ban, unless I am very much mistaken, had nothing to do with what you were saying.
Remote SDK makes for a feasible windows env with rubymine
I made this gem because I didn't particularly like how singleton-based the heroku 'scrolls' was and I also felt like I could make something significantly smaller. This is not a drop in replacement for scrolls, you'll need something like `logger` to actually print to things. I didn't feel like it was a good idea to write a logger inside of the gem like scrolls.
Thanks for the suggestion. I still prefer linux due to it having a better terminal, but it could be helpful for some of the .NET to rails api work I have to frequently test.
Yeah I don't think he's a dick at all. My limited interactions with DHH have been pretty pleasant actually. The problem I have with LoD and SOLID purists is they wind up doing a shit ton of work to appease the Loose Coupling gods and wind up with a ton of objects that are actually really closely related, never need to be swapped out, and aren't totally DRY for fear of making one object dependent on another. I'm not saying LoD and SOLID are bad. I think they are great when you're designing public classes and things that are meant to be reused and swapped out. Those that blindly follow any design principals like that wind up using them as a crutch because of their inability to see the bigger picture. If you want to TDD then do it if it helps. If you want to write tests later then do that too. Just make sure you have some fucking tests.
The classic Editor vs. IDE question can elicit some quite strong opinions from lots of folks :-) I think in the end you should use which ever environment makes you more comfortable this will probably get you up and running quicker. Often I find that people feel that using an IDE when starting out in a new language / application framework is useful. Over the years I have personally gone back and forth several times, but in the recent past have been mostly in the plain editor camp. Personally, I am a SublimeText 3 user for all of my development (except when I need to use Xcode).
If you're already using WebStorm, have you considered picking up IDEA instead of RubyMine? JetBrains may even let you upgrade your WebStorm license to IDEA, which should cost the same as buying RubyMine - they're pretty cool folks in my experience, doesn't hurt to ask. You get all of the JetBrains IDEs as plugins instead of having to use different programs for each. I use IDEA for Ruby, Python, and Scala and love it!
I've been writing some scripts using the Thor CLI framework. I love it.
Mostly those screenshots would include the following from OP: "My code can beat up your code", "you guys can suck it", "DHH is an idiot", "I get paid good money for my work so I don't care what you think of me", and other things like that. These are the comments that got flagged, not anything vaguely resembling insightful comments. Sprinkled into the mix was much of the same commentary on TDD found in the OP's blog post, but without any examples, relatable experiences, honest questions, or really anything else representing a genuine attempt at conversation. If anything, it only served to create an example of what DHH complained about in his blog post. It's worth noting that outside of this noise were dozens of great posts from other people, which covered both extremes of the topic as well as everything in between. OP was banned not for his views (because many others had similar views, and expressed them without issues), but because he was extremely confrontational, and very light on signal in his posts while being extremely noisy.
Add a "permalink" attribute to your models. Here's how it'll work for Region: class Region &lt; ActiveRecord::Base def to_param permalink end end class RegionController &lt; ApplicationController protected def load_region @region = Region.where(permalink: params[:id]).first! end end class TripsController &lt; ApplicationController protected def load_region @region = Region.where(permalink: params[:region_id]).first! end end There's a handful of ways you can auto-generate the permalink attribute: [Rails Toolbox](https://www.ruby-toolbox.com/categories/rails_permalinks___slugs) 
emacs with evil mode is great for beginners who want to get up and running quickly
after a good night and 1 hour morning refactoring ?
I recommend FriendlyId. It's got some concessions for permalinking.
Refactorings are always best done with a hangover.
~~Wheres the wrapper?~~ ~~Because I think you're full of shit:~~ ~~https://pay.reddit.com/domain/netflixroulette.net/~~ ~~Because, you've said that the website is made with a JS wrapper, a Python wrapper &amp; a ruby wrapper and yet there is no open source wrapper.~~ EDIT: Look for reply by OP.
I'm sorry I put the wrong link in this post http://netflixroulette.net/api/ very bottom. http://i.imgur.com/BpVcMqP.png
Ahh! Got it. There's no link to the api page on the index hence I couldn't see it. Anyway, nicely done! I actually really like the site.
When everything is so reusable that no one understand what anything does.
meta meta meta meta programming is the new hotness, get onboard
BGundlach, check this link, What should I learn along with Ruby on Rails? http://stackoverflow.com/questions/9756314/what-should-i-learn-along-with-ruby-on-rails 
People are doing ruby development on windows?
"bundle update" is painful?
So, you reinvented `bundle outdated`?
Nope but what this gem does is much different. Bundle update will take your Gemfile and then update every single gem to the latest version. This alters your installation and could be very dangerous unless you have very aggressive pessimistic operator locking in place. Gemshine just compares what you have in your Gemfile to the latest version of each gem according to rubygems.org and displays both versions side by side in an ascii table so you can see what the difference is. It does not do the actual update since that would be really gem specific. The use case is so that you can quickly see how out of date your gems are or when a gem might have released a new version without having to search for 80 different gems on rubygems.org manually.
Add an empty `puts` at the end of your script.
Don't forget the Vimplugin for Rubymine and you're good to go.
It's a silly thing to say, blocks are a syntactical optimization for passing a single anonymous function to a method. Ruby still has normal anonymous functions that you can create with the `-&gt; {}` syntax.
disable media hint
well I try that, but the Timeout::Error is never raised, heroku always raise the error outside the application.
Heroku's system doesn't raise errors back to your Rails app, so this won't catch all of them. It only will work if 1) your timeout is set lower than Heroku's and 2) the request hits your app and it's your app that is slow to respond, not the infrastructure. It may be that all your dynos are busy for the whole timeout period so the request never hits your app at all, the request is just sat queuing then gets cancelled, this means your app is never involved. You'll need to check NewRelic for the time spent "request queuing" for that.
&gt; request My time is lower than 30 seconds, and the reason that I want to catch those errors is because I want to show a pretty screen for the user and send an alert to my errbit app
Well, DRY _can_ stand for do repeat yourself.
Hah! Touché.
&gt; But imagine if these actions were all ten lines long or more, and there were ten or twenty more actions. Now see, *that* is the problem that needs fixing. Your controllers are a mess at that point, and making them less DRY is not the solution.
Totally, that’s a whole separate problem. I’m a huge fan of breaking up controllers into smaller ones, and extracting out form or service objects for large actions. But even with that, I still find extracting common action logic into callbacks to not be much of a win.
I still cannot replicate using this technique, here the repo https://github.com/3zcurdia/timeout-example
secret.yml + .gitignore. Prior to that, I had an application.yml file with figaro. Same thing, .gitignore.
This article is drivel. If a controller has gotten so fat that it's a chore to follow the logic... It's time for a refactor. Those long actions are taking on too much responsibility, and the logic needs to be moved off into the models and/or service objects. You need to reexamine your callback structure and see if it can be normalized some... Maybe even moved up into ApplicationController. DRY code is almost always a maintainability win. When something changes it is so nice to make that change in one place, rather that hunt though the project for the code pattern and change it everywhere... 
params[:id] should suffice if you are on the show action.
Testing. Unit testing the model for outcomes is much easier than testing a lot of logic in a controller. It depends on the complexity the view needs in my opinion.
This is a prime example.
I agree that trying to trace the flow of code through all those before_filters is more trouble than it's worth, but I have a different solution. Here is a pattern I learned from a co-worker a while back and is now my preferred way to handle this problem (simplified for this example). def show raise Some403Error unless user.visible_to?(current_user) #... end def edit raise Some403Error unless user.editable_by?(current_user) #... end private def user @user ||= User.find(params[:id]) end helper_method :user You have an accessor for the @user instance variable like a normal class would, and you let it be "lazily" loaded by whatever line calls it first. It's more understandable than the before_filter because you can just trace what that method (`user` in this case) refers to like any other method, rather than be confused how an instance variable got set by something seemingly out-of-band like the before_filter. Also, you don't even have to have a controller method if you don't need to do anything with the var in the controller. the `helper_method` line exposes that `user` method to the views, so you can just use the "local" method `user` in your views and again, it's lazily loaded so you never have to care who calls it first. You're just calling a regular object-oriented accessor. Finally, if your `raise Some403Error` is all the same for every method, you can move that kind of stuff to the `user` method as well. That way you have a DRY, central place to check permissions, visibility, etc., and you often don't even need to have a single line of code in the `show` or `edit` controller methods... the first caller of the `user` accessor is the view, and the user is loaded lazily.
Absolutely. If my controller basically consists of a few service object calls, I can do easy stubs and simplify my test logic. Assuming of course that my service objects and models are also well tested. I don't need to test them again in the controller. I only need to test their interactions with expected outputs and error conditions. 
For sure. I use this pattern occasionally as well, although typically the way I’ll do it is the methods will only return data, without setting any instance variables. Then I’ll use the return values of the methods to set the instance variables in each action. That way there’s no mystery or difficulty in figuring out what instance variables are being passed to the view.
I would make a wrapper client and place it in my lib directory. Then, the mock the external calls, you just set up the expectations on your client. 
Does anyone actually do things the wrong way discussed in this article? I can't imagine anyone thinking that the use of the described before_filters was better than adding the same, single line to some of the methods. 
That's a lambda, it's not a true function.
&gt; poor substitutes for real functional style **anonymous functions** You said "anonymous functions", can you explain why a lambda isn't an anonymous function?
They're not the same thing, there are subtle differences in how they work. Also, why are there so many ways of making them in ruby, and why do they all have subtle behavioural differences? Why did we need the new stab syntax, and why does it behave differently from the keyword lambda syntax? It's all a bit messy.
I've used the three major contesters for writing tests: RSpec, MiniTest::Spec and MiniTest::Unit. In my experience, RSpec is easier to start with for sure. At some point in time you might want to use something simpler in design like MiniTest. If you do, ::Spec is the obvious transition. Once you realize the power of using classes and modules in your tests, you'll want to try and switch to ::Unit. Still, it's a matter of personal taste. You should focus in learning the software design techniques rather than focusing on choosing one tool, they all do the same: they test your code.
Dude, you **really** need to stop writing these self-aggrandizing blog posts. They're actually pretty fucking embarrassing and make you sound like a douche.
Wait, can you explain the subtle differences in how they work? Because I think, scratch that -- i know - you're absolutely wrong. In fact even [wikipedia](http://en.wikipedia.org/wiki/Anonymous_function) says you're wrong "In computer programming, an anonymous function (also function constant, function literal, or lambda function)"
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Anonymous function**](https://en.wikipedia.org/wiki/Anonymous%20function): [](#sfw) --- &gt;In [computer programming](https://en.wikipedia.org/wiki/Computer_programming), an __anonymous function__ (also __function constant__, __function literal__, or __lambda function__) is a [function](https://en.wikipedia.org/wiki/Function_(computer_science\)) defined, and possibly called, without being [bound](https://en.wikipedia.org/wiki/Name_binding) to an [identifier](https://en.wikipedia.org/wiki/Identifier). Anonymous functions are convenient to pass as an argument to a [higher-order function](https://en.wikipedia.org/wiki/Higher-order_function) and are ubiquitous in languages with [first-class functions](https://en.wikipedia.org/wiki/First-class_function) such as [Haskell](https://en.wikipedia.org/wiki/Haskell_(programming_language\)). Anonymous functions are a form of [nested function](https://en.wikipedia.org/wiki/Nested_function), in that they allow access to variables in the scope of the containing function ([non-local variables](https://en.wikipedia.org/wiki/Non-local_variable)). Unlike named nested functions, they cannot be [recursive](https://en.wikipedia.org/wiki/Recursion_(computer_science\)) without the assistance of a [fixpoint operator](https://en.wikipedia.org/wiki/Fixpoint_operator) (also known as an *anonymous fixpoint* or *anonymous recursion*). &gt; --- ^Interesting: [^First-class ^function](https://en.wikipedia.org/wiki/First-class_function) ^| [^Lambda ^calculus](https://en.wikipedia.org/wiki/Lambda_calculus) ^| [^Scala ^\(programming ^language)](https://en.wikipedia.org/wiki/Scala_\(programming_language\)) ^| [^PHP](https://en.wikipedia.org/wiki/PHP) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch2gt9q) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch2gt9q)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Whether or not Ruby has many differenet kinds of anonymous functions is totally irrelevant to the thing you stated which was that lambdas are not anonymous functions. I don't care, and this argument was not about, the various kinds of anonymous functions. 
I meant that they are literally not methods without a name. See here: http://bpaste.net/show/ntDxVVvwdG2QxNMdrrCl/
That's nothing to do with anything! Did you even read the definition of anonymous function on the wikipedia page or ANYWHERE else? You're just pulling definitions out of your ass at this point. Ruby's lambdas will meet any criteria for 'anonymous function'. Stop talking at this point, please.
You don't want an attr_accessor for selected_race here, if the purpose is to store it in the session. attr_acccessor is a convenience method to autodefine both a setter and a getter for the instance variable, so attr_accessor :foo is the same as def foo @foo end and def foo=(value) @foo = value end You may want to do def selected_race=(value) session[:selected_race] = value end and def selected_race session[:selected_race] end But be careful with = methods used inside an object, as if you try to access them implicitly on self, without a self.selected_race=(value) you'll create a local variable shadowing the method, and that can be confusing to understand/debug the resulting errors. 
If the pattern is applied consistently, there is no mystery, and you only do the database hit once whenever you need a User object. 
Yeah, lots of people. As a freelancer I get to see a _lot_ of codebases—of all varieties—and a huge percentage of them used controller callbacks like this.
I haven't seen any downsides so far, but i haven't used it in production. If you liked this one, checkout the same application using Faye: https://github.com/DamirSvrtan/mini-chatter-faye
That's not what you said, you said ruby's lambdas were not anonymous functions, you were wrong.
Now you're telling me what my meaning was. Do you see why that is foolish?
VCR for mocking external calls. As /u/Velium said, encapsulate the service and throw into lib/. I also tend to encapsulate third-party wrappers. That gives me a consistent API should I switch out the third-party wrapper later.
Terminator + Tmux = (C)onsole (U)topia.
Gotta throw Linode out there, though it's hard to compete with DigitalOcean at $5/month.
I'm starting to wonder if this person is just trying to make a name for themselves by being loud and brash. Certainly a good chunk of the ruby community now knows the name, for better or worse. But otherwise, I suggest if OP really wants to be a teacher and community leader, they really need to focus on attitude and presentation. You'll note in any community you find very few leaders who are highly opinionated, inflexible and condescending as that is a very ineffective way to spread ideas and win fans.
You can also find some fine examples of OP's attitude here on reddit. [This one](http://www.reddit.com/r/ruby/comments/21qnif/tdding_pat_shaughnessys_ask_dont_tell_prefer_the/) is a fine example.
You need to manually upload the file via FTP or some other form of file transfer. Do it once and be done with it. How often do you change your secrets? For deploying with Capistrano for example, you just make sure the secrets.yml is symlinked to each deployment. (deploy.rb) `set :linked_files, %w{ public/.htaccess config/secrets.yml } # Secrets`
That solution might work if you have static hosts, but I am using ec2 and dynamically scaling my application based on load. I have no idea what hosts will be running my app, and I also have no guarantee that any host running my app will continue to run my app. 
There are no best practices in programming. That said, I use [webmock](https://github.com/bblimke/webmock). I have tried VCR in the past. It's decent software, but too much, in my opinion. Webmock is just painful enough that you'll want to build an adapter (or gateway) object that encapsulates the external service. You then mock the adapter in your code and life is good.
I was about to post a blog article about this very topic. Too often I see people putting sensitive keys in their repos, thinking that it's secure. Our current solution is using Environment Variables. In our application.rb, we load environment variables, and use that throughout our project. We have a script that builds a production machine from scratch, then we mount an encrypted luks filesystem. This ensure that even if someone were to physically steal our machine, when the machine powered off, the filesystem unmounts and all the intruder is left with is an encrypted filesystem. Never put anything in your git repo that you don't want to share. This problem was the purpose environment variables were created.
For the love of god, STOP SPAMMING this subreddit with blog posts about how awesome you are. Everyone is sick of it. Nearly all your posts get buried, and for good reason. You're a blow-hard and aside from your own blog posts saying how great you are there is exactly zero evidence to back it up. Shutup.
Might [this help?](http://stackoverflow.com/questions/13980842/how-should-secret-files-be-pushed-to-an-ec2-ruby-on-rails-application-using-amaz) Or [this?](https://github.com/dmytro/aws_deploy/blob/master/CONFIGURATION.md) I know next to nothing about this but at a cursory glance it seems to be helpful.
+1 for #10, -1 for #11. Sitting in front of a computer for long periods of time is very unhealthy. You're better off picking a completely different hobby. Healthy body, healthy brain and all that crap.
We are using environment variables as well, works like a charme. All .env* files are in gitignore and in our deployment the files are rsynced during setup to the server
Agreed. You can also enjoy video games though. "DON'T PLAY VIDEO GAMES!" is not helpful or useful advice. The way you stated it makes much more logical sense, and I would still down-vote #10.
awesome. thanks. I dont know why I was so intent on having an instance var there, when the session handles the job just fine.
&gt; I'm not sure what advantage that function holds over just using the session hash directly. Encapsulation. You might want to change the way you store the currently selected race (e.g. use a different key, store it in a database, ...). And in these cases you don't want to go look for `session[:selected_race]` in your entire code base.
I wasn't that IAM credentials were automatically deployed to EC2 hosts. That is immensely helpful. Thanks. 
Yeah, nothing wrong with playing video games. I was more focusing on the "MASTER" part of his title. If that's really the goal, skipping video games seems reasonable. 
Put them all in a .env file. https://github.com/bkeepers/dotenv could help you load them into ENV hash at boot time. Example: In a .env file in Rails.root, DISABLE_ANALYTICS_CACHE = 1 and in your code, if ENV['DISABLE_ANALYTICS_CACHE'] == '1'
Are you saying that terminator and tmux can run within windows and allow me to have all my colorful logging information, and fancy rails output? Because that might be cool. What is the benefit of tmux exactly? I use it on my nitrous boxes to maintain a session, but won't my desktop session end when I shut my laptop down and take it to work?
This is what I do: def show @user = fetch_user raise Some403Error unless user.visible_to?(current_user) #... end def edit @user = fetch_user raise Some403Error unless user.editable_by?(current_user) #... end private def fetch_user User.find params[:id] end So simple. So obvious. Can't go wrong. Would I write a PORO like this? No. And, actually, I probably wouldn't even extract `fetch_user` unless it had some shared eager loading or something. I've painted this bike shed about 45 million colors in the last 6 years. The rails way ends up being the most obvious/least painful.
thank you -- that makes altogether too much sense.
Thanks, just to clarify do you have 1 class or 2? When you say "mock the external calls", do you `.should_receive` a sample of what the data from the external API should look like?
Hi, thanks for the answer :) I put up some of xhe code that I'm using. When you say third-party wrapper, is it the same with my `GithubConneciton` class? Do you have some sample code for guidance?
Hi, do you also mock the response you should be getting from the external API?
Generally, I don't pass the response back to the calling code. This means my object that hits the web will extract out the primitive values that "matter." So I'll mock the response, and test that my adapter object extracts out the important primitives.
would take a picture of the page but for some reason I can't get my rails server to start? thought it was just *rails s* or *rails server* 
Most likely @posts isn't defined or is something that doesn't have an each method. More info would be helpful. 
If it's your own class, no need to wrap it twice. But say you were using a pdf generator like Prawn. I wouldn't use Prawn directly in my application, but instead have a Pdf::Generator module that defers to Prawn. Then if I switch out that gem later for another one, I only have to worry about the internal API I created.
+1 this. I'm guessing the @posts instance variable hasn't been defined. Undefined instance vars evaluate as nil, and NilClass doesn't know what to do with .each OP, can we see the posts controller, the routes.rb, and the path you're accessing that raises this exception? Edit: *you're
http://imgur.com/YIFNDz1 heres where I have the "posts controller" or at least I think I do. 
http://imgur.com/YIFNDz1