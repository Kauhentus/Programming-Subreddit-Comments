I apologize for the confusing examples. I am sure you understand that when one is confused it is often difficult to puzzle through what question one even wants to ask! You did a very good job of answering, for which I am grateful. I pulled the examples from code I had just run, one was 166 and the other was 178. They are random numbers from 128 to 255. The random sequence can end in a 1. In fact, it will half the time. For the purposes of the loop, it should work for all character sequences that represent the numbers 128 and up. 100000000 to 11111111 if we limit the data string to eight entries for convenience. But this could be a number like 100101000101010001010110101111101010110101 ... So... data = ["1", "0", "0", "0", "0", "0", "0", "0"] result = [8] data = ["1", "1", "1", "1", "1", "1", "1", "1"] result = [1,1,1,1,1,1,1,1] is what I am looking for, and everything in between. Here are some hopefully illustrative inputs and the outputs I am looking for in the [input] yields [output] format: ["1"] =&gt; [1] ["1", "0"] =&gt; [2] ["1", "1"] =&gt; [1, 1] ["1", "0", "0"] =&gt; [3] ["1", "0", "1"] =&gt; [2, 1] ["1", "1", "0"] =&gt; [1, 2] ["1", "1", "1"] =&gt; [1,1,1] ["1", "0", "0", "0"] =&gt; [4] What I am really looking for, I now realize, is a way to go from long binary numbers to the output. Their doesn't have to be an intermediary string step if it's not necessary. I just can't imagine it not being necessary. [1001010110100000101] =&gt; [3,2,2,1,2,6,2,1] or even in decimal: [306437] =&gt; [3,2,2,1,2,6,2,1] or something like: rand(1..4294967295) =&gt; some sequence of base 10 integers that add up to 32. That's the ultimate input/output.
Can you link to an official statement that says callcc is deprecated? afaik they're not, they've just been moved out of core to stdlib.
I believe this made me call it deprecated: https://github.com/ruby/ruby/blob/trunk/ext/continuation/continuation.c#L10
Is there a big ruby community in Belgium?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Void safety**](https://en.wikipedia.org/wiki/Void%20safety): [](#sfw) --- &gt; &gt;__Void safety__ is a guarantee within an [object-oriented programming language](https://en.wikipedia.org/wiki/Object-oriented_language) that no [object references](https://en.wikipedia.org/wiki/Reference_(computer_science\)) will have [*null* or *void*](https://en.wikipedia.org/wiki/Null_pointer) values. &gt;In [object-oriented languages](https://en.wikipedia.org/wiki/Object-oriented_language), access to objects is achieved through [references](https://en.wikipedia.org/wiki/Reference_(computer_science\)) (or, equivalently, [pointers](https://en.wikipedia.org/wiki/Pointer_(computer_programming\))). A typical call is of the form: &gt;where *f* denotes an operation and *x* denotes a reference to some object. At execution time, however, a reference can be *void* (or *null*). In such cases, the call above will be a __void call__, leading to a run-time [exception](https://en.wikipedia.org/wiki/Exception_handling), often resulting in [abnormal termination](https://en.wikipedia.org/wiki/Crash_(computing\)) of the program. &gt; --- ^Interesting: [^Eiffel ^\(programming ^language)](https://en.wikipedia.org/wiki/Eiffel_\(programming_language\)) ^| [^Overdriven ^fluorescent ^light](https://en.wikipedia.org/wiki/Overdriven_fluorescent_light) ^| [^Anthony ^Walters ^\(American ^football)](https://en.wikipedia.org/wiki/Anthony_Walters_\(American_football\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+crfduvn) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+crfduvn)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I really like this pattern, thanks for sharing!
Thank you so much! There are parts of me that think in BASIC, C++, Assembly... none of them very well, so seeing a variety of solutions is so very helpful. Thank you for the explicit step-by-step code and good commenting.
Using an ivar on class methods of a module means that this code isn't thread safe. Putting a `call` class method and using the `Bottles` module as a singleton object is problematic (in much of the same way). Consider either dropping the singleton pattern (and really, _always_ consider dropping the singleton pattern) or making this stateless.
Yeah, I'm not sure either. I would probably add `to_a` and call it a day. btw. `all` doesn't trigger a query in ActiveRecord 4 anymore, it returns a relation. It's basically the identity function on relations.
We are "around" but afaik the community is very fragmented. Not at all like the fairly large PHP community (especially in Ghent). At Arrrrcamp I'd say about 4 out of 10 attendees are Belgian. Due to the tradition of quality international speakers (Aaron Patterson, Ben Orenstein, Zach Holman, Jim Weirich, Jehuda Katz, Corey Haines, Avdi Grimm, etc...) the conference attracts a lot of attendees willing to travel.
First mistake is that you want to put newline: $ ruby -e "require 'pp' pp [1,2]" -e:1: syntax error, unexpected tIDENTIFIER, expecting end-of-input require 'pp' pp [1,2] ^ You need the `;` character: $ ruby -e "require 'pp'; pp [1,2]" [1, 2] And also look at this: $ ruby --help | grep "\-r" -rlibrary require the library before executing your script $ ruby -rpp -e "pp [1,2]" [1, 2] 
/u/nakilon's advice is sound, but `xargs rm -rf &lt; dir-list.txt` is the "right tool for the job" in this scenario.
I am always *stunned* by how many lines of code can be condensed in ruby. I have not only dispensed with all the traditional looping, I have rid myself of the statements to buildup the original random number. The final statement is: ("%32b"%rand(2**31..2**32-1)).scan(/10*/).map(&amp;:size) `("%32b"%rand(2**31..2**32-1))` is the initial object. This, as near as I can tell is a random integer from 2,147,483,648 to 4,294,967,295 expressed as a 32 digit long binary number in string form. I believe that is every number that can be expressed in binary as a "1" followed by 31 ones or zeroes. `scan(/10*/)` scans the string looking for every instance of a 1 followed by zero or more zeroes and outputs them to an array, if I am not mistaken. Oh, regular expressions, is there anything you can't do? `map(&amp;:size)` takes each element in the array sends it to a block and outputs an array of the results of the block. In this case the block is in &amp;: form, something I've never seen before, and it applies the size function to each block. length also works. And I used `map{|x| x.size}` and it does the same thing. And that's it... all this ridiculous code condensed into one statement... and to think, in a year I will look at it and have *no idea what it does or what I was thinking.* Still, it looks cool to me now.
I edited the answer, though I'm skeptical. 
I was able to cut out all the unnecessary looping. I had only made the original string into an array because I was assuming that I would have to use `data.each {|x| do something}`. So when I saw that you used join to turn a string I had turned into an array back into a string, I was thrilled. I do a lot of dumb things because I can't think of any other way to do them (or that's how it worked on my Commodore 64). My final code: ("%32b"%rand(2**31..2**32-1)).scan(/10*/).map(&amp;:size) This replaced about twenty lines with indexes and aggregators and breaks and bleah... ugliness!
So what makes this better than Nokogiri? A more painless install? Does that have performance/correctness ramifications?
Can I know the joke? EDIT: I didn't get it heh.
Reread the docs on `recvfrom`: http://ruby-doc.org/stdlib-1.9.3/libdoc/socket/rdoc/Socket.html#method-i-recvfrom
The dev links to another post of his: &gt; Nokogiri on the other hand is quite fast, but in turn is not thread-safe and in certain places has a bit of an odd API. Nokogiri also vendors its own copy of libxml which greatly increases install sizes and times. Most important of all, Nokogiri simply doesn’t work on Rubinius. &gt; So what exactly is the problem with Nokogiri and Rubinius? Well, on MRI and Rubinius Nokogiri will use a C extension. This extension in turn uses libxml. Due to MRI having a GIL everything might appear to be working as expected, however on Rubinius all hell breaks loose. To be exact, at certain points in time bogus data (e.g. null pointers) are sent to the garbage collector, this in turn crashes Rubinius. Both I and Brian Shirai (brixen) have spent quite some time trying to figure out what the heck is going on, without any success so far. The exact details of all this can be found in the following Nokogiri issue: https://github.com/sparklemotion/nokogiri/issues/1047. &gt; This particular problem is thus severe that some of the production applications I’ve tested (that use Nokogiri heavily) consistently crash around 30 seconds into the process’ lifetime. As a result it’s impossible for me to run these applications on Rubinius. If a process were to crash once every few days I might be able to live with it while searching for a solution, every 30 seconds however is just not an option. So if I'm using MRI...I wonder if it is worth it to try to use oga over nokogiri for xml parsing?
This whole NullObject thing needs to stop. Most of the examples given on this topic aren't even remotely 'Null' objects, they are objects with very real meaning and very real behavior, i.e. the common `AnonymousUser` example. An `AnonymousUser` is in no way shape or form a `NullObject`, it's a very real very useful model, it's only connection to `nil` is that the ORM returns `nil` for 'user not found', that's it. The rest of the argument for this primarily comes from working in languages where 'null' is significantly different from any other value. It's not in ruby, `nil` is an object, just like every other object. `NoMethodError: undefined method 'what' for nil:NilClass` is no more a code smell than `NoMethodError: undefined method 'what' for &lt;insert any object here&gt;`. Your working in a duck typed language, errors like this are going to happen, what object doesn't have the needed method isn't important, you have the same problem to solve whether that class is `NilClass` or `MySuperDuperFactoryBuilderPatternClassOfWonder`.
Just finished taking a look at it, the day after deprecating Nokogiri in our project (in favour of [Ox](https://github.com/ohler55/ox)). I can't say I'm regretting my decision yesterday, at least for our use cases. That is *not* intended as a knock against Oga or /u/yorickpeterse; congratulations for shipping are more in order. In Ox, a node is a node is a node; traversal and querying of individual nodes (or chains thereof) could hardly be simpler. Since all of the HTML markup we deal with is generated (albeit from human-entered Markdown), dealing with funky malformations is less of an issue for us. I had a simple kick-the-tires POC translated from Nokogiri to Ox in five minutes without a single WTF moment; Oga wants me to think of it as "a better Nokogiri" (how?), keeping Nokogiri's convention of "all children of nodes are in collections, even if there is only one child". I wind up writing almost exactly the same ceremonious boilerplate to get simple-to-moderate parsing done in either Nokogiri or Oga. If you're a Nokogiri shop who's had it with the Whac-A-Mole every time you do something silly like upgrade your dev team's OS, or just the disregard Nokogiri celebrates for standard Gem development/build practices, then Oga may well be worth your time to take a good look at. The beauty of having multiple tools, each capable of performing similar tasks in different ways, is that we can finally choose the tool that's best for the job *in our current circumstances*. If Oga accomplishes nothing more than pushing the Nokogiri team to clean up the cruft in different corners of their ecosystem, it will have performed a *huge* service to the community (and to Nokogiri). I look forward to seeing people do more with Oga than that.
I... think... that should be `"1%031b" % rand(2**31-1)` as I don't want the resultant binary string to exceed 32 digits (on the off chance that rand happens to generate 2,147,438,648). 
If you want to work through it yourself, do something with that "ex" variable. If that `rescue` block does get initiated, would you know? *Also, an example of your input file would help.
You're right, I will do something with the rescue block and see where that leads me. Here's an example of the input file for you though: 1.1.1.1 500 2.2.2.2 23 3.3.3.3 95
Thanks. I did not realize my example was so stupidly bad code :) thanks. I hope my new example is better. The main thing about Object#as is if you want to chain a function that is not a member of the chained value itself. For instance like this: def my_reverse(arr) (arr + arr).reverse end [1,2,3].as {|x| my_reverse x }.tap {|y| puts y }
http://ruby-doc.org/stdlib-1.9.3/libdoc/socket/rdoc/Socket.html#method-i-recvfrom `recvfrom` takes 1 or 2 arguments and returns an Array with 2 elements. You're passing it 5 arguments and you're not doing anything with the returned value. You're also setting `resp`, `from` and `port` after calling `recvfrom`, so even if the variables were set by your `#recvfrom` line they'd be overwritten by the next 3 lines. Also, you call `File.open` everytime you call `packets` in that loop. You can save all the responses and write the file at the end. Format/indent your code and you'll notice you don't `end` your `File.open` section. `while` requires an end statement, so you're running the `printf`statement in that same `File.open` block. Also, use `puts` instead of `printf` there as you probably do want a newline character at the end. Don't check the IP every time you shovel it into the array. That statement is awkward to read and you can just call `uniq!` at the end when you're done.
I came up with this. It at least sends data to the right port, I couldn't get a response back to it to really test it fully. https://gist.github.com/anonymous/e078669e8d790f22736a *Revised: https://gist.github.com/anonymous/6de2308f57f78ccc6f17 **I just noticed the @min_size should be @minimum_response_size. Might still be other errors but it might be good for something. 
More fixes: https://gist.github.com/anonymous/bc16f359d30141db6c8b Looks like you have no route to that IP address. Probably related to your network configuration. The second error seems to indicate that you already have a socket bound to port 1337. Make sure no other programs are running and listening on 1337. I guess you're doing something with NTP. The script works for me and gives me an output file with similar format to your input file.
It's not really meant to be a better Nokogiri, but instead a viable alternative. For just parsing XML using Ox will result in the best performance, but it can't parse HTML. In case of Oga a node _can_ be in a collection but this isn't a requirement. For example, the following is perfectly valid: element = Oga::XML::Element.new(:name =&gt; 'p') element.inner_text = 'hello' element.to_xml # =&gt; "&lt;p&gt;hello&lt;/p&gt;"
The "migrating from Nokogiri" link gets a 403. 
Is stars.png in the same directory as your script?
When I was a kid, I could never figure out how the map at the mall knew where I was. Like, are they tracking me? Can't be, it's just a sticker. I was not a smart child.
codeschool good 
Awesome! Paste the pull request link so we can all +1 it!
Yes it's in the same folder as my script. Or do you mean something else?
Sorry, that wasn't the best question. Does it work if you specify the location of the image using an absolute path?
Holy crap it does. So does that mean the files are in the wrong directory?
Oh ok awesome! Thanks for your help man! Really appreciate it. 
You're right. I *knew* there had to be a way to do it without using Ruby, but I'm still learning bash commands too. Thanks!
I use Windows 7 64bit. I tried out your code, and it worked without a problem. I can't seem to figure out why my code doesn't work, because it's doing almost the exact same thing as yours.
http://www.reddit.com/r/voltframework/comments/36ta5u/building_a_realtime_chat_app_with_ruby_volt_in_10/crgvoy5
Isn't most of the io done in Ruby async?
I try and help develop an event driven framework in ruby called pakyow and all the smart core devs swear by celluloid. In their opinion event machine is dead.
MRI is designed for concurrency but not parallelism because of the GIL. Other implementations (Rubinius and JRuby) do support parallelism.
Yeah, I think most people are moving to celluloid as well.
Ruby uses blocking semantics. Node.js uses non-blocking semantics. In my experience things which change the chosen semantic of a language are a bad idea. Avoid EventMachine and em-synchrony. Take a look at nio4r and kgio for two different I/O libraries for Ruby.
Very informative on what a websocket server does behind the scenes.
Wasn't expecting this kind of post to be from Pusher
 You're using sending ```#each``` on your array (@csv_contents), this will give you each element of the array, not the index. See http://ruby-doc.org/core-2.2.2/Array.html . Look for ways of getting the index ( with our without the element ) or better yet don't even bother with the index. 
 @csv_contents.each do |row| yield CsvRow.new(row) end 
You have a typo on your class name. You defined 'CvsRow' (line 40) but it should be 'CsvRow'.
Nopers
He is 4 days in and you suggested yield? Bold move Cotton. 
His code has method_missing and all sorts of crazy stuff for a begginer. This yield replaces a explicit block call.
Use rvm only if you don't mind being in shit. It overrides `cd` with own bash script and is intensively used by Rails coders only because they are mostly PHP coders in the past, so they don't mind being in shit.
What are the non-shit alternatives?
Rbenv
*I eat shit for a few years and it never tasted bad for me.* I didn't eat shit for years, so I can't tell you more about its taste, than you already know.
What continues to amaze if not shock me, and has done for about a year now, is the variety, vitality and urgency with which additions or alternatives to The Rails Way stack are being released, discussed, explored and put into production. I'm perfectly willing to believe that there will be more Rails-Way apps in production in a year's time than now; I'd be *shocked* if the increase in production Ruby apps *making differently-architected use of select Rails components* isn't far, *far* greater — and that those teams have a far greater supply of what most Rails-Way devs are by now convinced is mythological: *free time*.
Spot on. Rails is a framework for implementing apps that are as close to Basecamp (ideally Bascamp, circa 2006) as legally permissible. Your pain level will decrease *dramatically* the more closely you approach that "ideal". I'm *all for* extracting frameworks from working code. However, common sense and sound practice should both tell you that extracting "general purpose" frameworks from a *single* app is pretty pointless.
Yup. I think, OP, that you need to read up on the difference between a class association and inheritance. Inheritance is where one class *is* another class while association is where one class *has* another class. In your case you're trying to do both. You've inherited from Array (so Board *is* an Array), but you've also stored an array in the board property (so board also *has* an array). If you want to use inheritance, as you've been doing, then use concat as explained above. This adds several elements to itself, since board *is* an array. However if your board ends up having multiple fields that aren't related to the array (e.g. A second array, maybe an array of entities), then use association and keep your code how it is except that you stop inheriting Board from Array. 
This is not good advice. Distributions have security patches, while rvm has ??? Install ruby using apt-get, and install gems for your project locally using: bundler --install --path vendor/bundle
Others have really already filled you in on what you should actually do in this situation, but you've actually touched on some really interesting features of Ruby that I feel are worth at least putting out into the world. This is some pretty advanced-level stuff, so feel free to ignore this entire comment if it just muddies the picture for you. /u/yes_or_gnome said that &gt; you don't want to subclass Array. Even if you think that you do, you don't This is true. You never want to inherit from Ruby core classes. The reason for this is because of the low-level implementation of Ruby's core classes. Basically, several of the methods of `Array` are written so that they return `Array` instances, *not* instances of *whatever class they were called from.* So if you have your `GameBoard` instance (with `GameBoard` inheriting from `Array`) and you call `#reverse` on it, it'll return an `Array` instance, *not* a `GameBoard` instance. You don't want this behavior. So if you want to write a class that extends a Ruby core class, we choose to delegate to it, not inherit from it. Secondly, nobody has quite explained how `print` works, which is worth knowing. When you call `print` or `puts` on an arbitrary object, what you *actually see printed* is the result of the `#to_s` method called on that object. So if you were to do something like have `BoardGame` delegate to an `Array` instance (as you should), but still wanted to be able to do: &gt; print BoardGame.new # [1, 2, 3] You could do this: class BoardGame attr_reader :board def initialize @board = [1, 2, 3] end def to_s @board.to_s end end And now you'd get the behavior you want. On the whole, you probably don't want to do this, frankly. It could cloud your image of what class you're working with and stuff, but it's totally doable. Thirdly and lastly, it's already been mentioned that `#initialize` doesn't return the last expression in its definition, which is different from every other method in Ruby. This is, I think, an important thing to clear up for a Rubyist's long-term understanding. `#initialize` is not a magic method, it is not evaluated differently from all other Ruby methods. The reason `#initialize` appears to return a different value is because *you didn't directly call it.* `#initialize` happens when you call `.new`. `.new` is a class method that every class has. `.new` *actually* creates an empty instance of your class (using the `.allocate` method), then calls `#initialize` on that object, and *then returns the object*. If you were to define `.new` on your class, it would look like this: class BoardGame attr_reader :board def self.new new_instance = self.allocate new_instance.initialize return new_instance end def initialize @board = [1, 2, 3] end end (Nota bene: the definition of `.new` doesn't *actually* look like this, because `.new` is *actually* defined as an *instance* method of the `Class` class, and all classes are instances of `Class.` This is confusing until you wrap your head around it [and let's not talk about eigenclasses], but actually extremely elegant and, imo, the reason Ruby fucking rocks) As you can see, when you call `BoardGame.new` you're not getting the expected result of a `[1, 2, 3]` because `BoardGame.new` returns the `BoardGame` instance, not the return value of `#initialize`. This will get important down the road, because there are design patterns that rely on taking finer control of the instantiation process, and you'll want to be able to employ different kinds of techniques to accomplish those goals. So yeah. Keep Rubyin'. Keep asking questions. Learn it all, and generate beautiful code. We're counting on you. EDIT: Forgot to assign the array to the instance variable in the `.new` example. I do this shit live all the time. Ugh software
Most likely the poster doesn't need an object. but is using one for the purposes of learning ruby objects.
OP, I started groking composition and inheritance when reading [Russ Olsen's Design Patterns in Ruby](http://www.amazon.com/Design-Patterns-Ruby-Russ-Olsen/dp/0321490452). It's in the first chapter which is free to preview on Amazon.
In Ruby 1.8 -&gt; 1.9: * Strings switched from byte lists to character lists with encodings. This has large implications for string handling. * Hashes now accept the new `{foo: "bar"}` syntax rather than just hashrockets. * The VM was rewritten to use YARV, improving performance * Fibers 1.9 -&gt; 2.0 * Keyword arguments. `def foo(bar, baz: "default_baz")` * Refinements. These are still pretty half-baked, ignore them. * `Array#to_h` * Lazy enumerators * Better GC 2.0 -&gt; 2.1 * Required kwargs * Better method cache * Generational GC * Nonblocking IO no longer raises exceptions 2.1 -&gt; 2.2 * Incremental GC * Symbols can be GC'd More info: * http://slideshow.rubyforge.org/ruby19.html#1 * http://globaldev.co.uk/2013/03/ruby-2-0-0-in-detail/ * http://globaldev.co.uk/2014/05/ruby-2-1-in-detail/ * https://www.ruby-lang.org/en/news/2014/12/25/ruby-2-2-0-released/ 
Breaking changes: 1. iconv removal 2. New hash syntax 3. switch
Chruby
People like you is another reason that Ruby rocks.
Well gee. I'm just a guy who appreciates elegant object models.
I recommend using rbenv. Here is a great tutorial on how to set up ruby using rbenv. It does also go into detail about setting up rails, git, and databases. It also gives you instructions on how to get ruby via RVM, etc.. but I would stick with rbenv! Let me know if that helps! Here is the link: https://gorails.com/setup/ubuntu/15.04 Easy as pie! 
Friend, that is literally the best answer I've ever received, regardless of question. It is literally self-encompassing. If you were a woman I'd kiss you; If I had money I'd gild you. As it stands, all I can say thank you very kindly. 
Yep, I brought it up because we had chatted about it in the past and given the news of the CLR on Linux and OS X I thought he might have taken a peek at the project. The IronRuby project was how I got into Ruby and my first shot at podcasting when I created the Iron Languages podcast with Will Green (hot gazpacho) several years ago.
And thank you for watching as well! Have you watched any of the older episodes by chance? The latest video is an entirely new look and format. :)
It's not about what is offered, rather what is applied in reality. Distributions have an entire infrastructure around automated notification and installation of security updates. rvm/rbenv not so much.
For anyone reading this, `tr` does not duplicate the functionality of `gsub` or `sub` for that matter. http://stackoverflow.com/questions/26749065/what-is-the-difference-between-tr-and-gsub
I don't think there is a way to do this [1]. If you already know Ruby, learning PHP should be pretty easy. [1] You could write a PHP -&gt; Ruby compiler and test against the generated Ruby code. /s
This is kind of a bad article. They just kind of summarized the information in the slides without the benefit of the speaker's expertise on the subject and probably-added spoken information. Do yourself a favor and just read the [slides](https://speakerdeck.com/sferik/writing-fast-ruby) that the article was culled from - they're much better information. That said, if you're going to talk about performance quirks of a VM, you *need to clarify which VM you're using*. Ruby MRI 1.9 and 2.2 have wildly different performance characteristics for some operations, and JRuby is completely different from MRI flavored VMs. Additionally, citing numbers like "4.5x faster" without providing the benchmark is pretty bad form. With that said, here's an attempt to explain the bits the article gets wrong. It's likely written against Ruby MRI 2.0 or 2.1. * The majority of the examples are "do fewer iterations", which is kind of duh. Doing less work is faster than doing more work. These could be summed up in a single bullet point with examples, and an explanation of *why* they're faster. * `Hash#merge!` isn't faster because it's "in a tighter scope", it's faster because it doesn't do the extra duplication work that `#merge` does. The implementation of `#merge` is literally: return rb_hash_update(rb_obj_dup(hash1), hash2); `rb_hash_update` is `#merge!`. And advocating for merge! as a "faster merge" is irresponsible because it has destructive side-effects. * X vs anything with a block - The block forms will *always* be slower, because block creation involves creation of a block binding, and will have to drop the interpreter out of native code into interpreted code. If you are writing performance-sensitive code, avoid blocks where you can, but don't eschew them if it leads to really, really ugly code. Remember, one of the goals is beauty, not just performance. * tr vs gsub. The article states "You can always replace gsub with tr", which is just *wrong*. You can sometimes replace gsub with tr, if you're just straight replacing characters, but if you actually need regexes (which is what gsub is for!) then tr isn't going to cut it. * "Parallel assignment works by allocating the array but it makes code harder to read" - this was so close, and yet so far away. Parallel assignment is slower in MRI than serial assignment because it uses Ruby's destructuring assignment feature, where it allocates an array [1, 2], then destructures it into the multiple left-hand variables `[a, b]`. The extra array allocation kills performance here. Unnecessary allocation/iteration is the culprit, not some quirky arcana of the parser. * "Using throw/catch for control flow is useful to jump around the code when compared to using exceptions, making it five times faster." - wat. throw/catch is faster because it isn't an exception handler - for example, it doesn't build stack traces. It's basically "go to a point higher up the stack". And if you're using exceptions for flow control, you should probably feel bad about that, anyhow.
A majority of the PHP application was outsourced to overseas contractors and we all know what a bitch it is to refactor legacy php code, so I hope that's not the case with the ruby code base (if it is I'm on my way out lol) Thanks for responding - I was hoping that was not the case, I don't really want to give them a reason to keep me around the PHP team longer than necessary. I don't know if "bait and switch" is a common thing in the industry or how other companies go about it, it's my first full-time gig, but this just seems the process they bring new dev's along on here. I definitely feel slightly cheated and misled - but I couldn't have predicted the other team members around me leaving abruptly like this
&gt; you absolutely must use a ruby version handling system. On a server? Why? Are you really running multiple apps with multiple Ruby versions on a single box? &gt; I use rbenv rbenv is horrible to use on a server due to ruby-build not supporting binary packages. Having every server spend 15 minutes of CPU time building Ruby every minor version change sucks. 
Wtf is the "source code level"
oh. me on a cell phone isn't the best at all times. I had it in my head that we were talking about local environment. On a server.. it's not as much a must, but I'd still recommend a version handler. Most deployment procedures (capistrano for example) will allow you to automatically check and upgrade ruby on the server if you change project ruby. This is easier than manually keeping servers up to date. I do agree that it's a shame that ruby-build insists on building from source. Frankly I've found no solution I'm really happy with for deploying with ruby, and I'm leaning more and more towards container based structures where ruby version management becomes easier to manage.
I found it was helpful to get my bearings when I first started but I'd really have to go back and re-evaluate it now that I know what I'm doing to some extent.
Excellent summary. I wanted to post something similar myself, but you did all the hard work for me :) &gt; if you using exceptions for flow control, you should probably feel bad about that, anyhow If you're using throw-catch for flow control (which are basically just `goto`s), then you should *probably* feel bad about that, too! 
Aside from that is there another course or a better way to learn? 
Thank you. The older videos were a learning experience :) so don't judge them too harshly as most of the problems I address in the current crop going forward. I plan to eventually reprocess the older videos someday.
I think the IronRuby project still exists in some form.
dtto, exactly what came to mind still got surprised by peoples overconfidence, stand before a crowd and speak about something not knowing much about :(
Unit tests are, essentially, testing individuals functions in code. This usually means invoking function calls, passing in mocked objects, and asserting expected output. You can't invoke PHP functions and pass in PHP objects to those functions from Ruby.
It's ok for a starting point/introduction. The Odin Project has a decent Ruby section where you'll cover some core CS and internet protocol concepts as well.
CodeAcademy is a really good typing exercise that will get you off the ground when you're first learning. It's good because you can learn the syntax and not worry about stuff like "Why the hell is Ruby not installing?". Setting up Git, Sublime, RVM, learning the command line and all that other stuff can be a huge distraction when you're starting out and interactive tutorials get around that by letting you postpone that stuff for later. That's can be a double edged sword, though. I've heard some sites are trying to get around this by using online IDEs like Cloud9, but honestly, you just need to tough it out and learn how to code in the real world with common tools / workflows. **TL;DR:** Use it for no more than 10-15 hours, then move on to learning modern development workflows. Appreciate it for what it is, but know when its time to get rid of the training wheels.
What's the point of this comment other than nit-picking?
*The course itself is fine for learning the basics. After you go through that find something more advanced. *Everyone learns differently, I teach Ruby to total beginner. Some people love that course and some hate it. I also highly recommend learn to program by chris pine. 
I thought "Practical Object Oriented Design in Ruby" was pretty good. ( Practical Object-Oriented Design in Ruby: An Agile Primer (Addison-Wesley Professional Ruby Series) https://www.amazon.com/dp/0321721330/ref=cm_sw_r_awd_oLvyvb063M999) It'll only get you through a leg of your flight though. :/
Beyond the admitted nitpicking, I figured I'd clear up the domain name for the confused. Maybe you find the site through google or a bookmark; maybe you type it in to the address bar. Don't know. Sorry if you find the pedantry offensive. Don't take it personally. 
Eloquent Ruby, far and away my favorite ruby book
I don't think that's what's meant by "fast Ruby" at all, here or in general.
He's just correcting you, be polite.
Programming is details. Programming is precision. Programming is nit-picking. You might not realize this now, but as you start coding, you will find that even the smallest change in syntax can throw the interpreter off. What kent_dorfman was trying to do was both point out the correct name of the domain, and also noting that such precision is part of the practise of programming, and you might as well get used to it.
The key to learning ruby or any other programming language, for that matter, is getting started, and practising by writing code everyday till it becomes a habit. One of the best resource to both get started and coding everyday is [Zed Shaw's Learn Ruby the hard way](http://learnrubythehardway.org/book/). It's short - each chapter takes about 10-15 minutes of your time. It's hands-on - you see a little code, and the author will encourage you to type it in on your machine and run it to see what it does. It's absolutely "not the hard way" - surprisingly, the book is the exact opposite of what the title implies. I suspect that this is Zed's tongue in cheek manner of showing beginners that writing code is the only way to learn coding.
This should never be done... And it's pretty cool. Nicely written too.
Compared to their HTML/CSS and JavaScript courses, it is poorly structured. Makes you guess a bit more than one should. I do recommend you use it to learn, but you should also check out: Learn Ruby The Hard Way http://www.learnrubythehardway.com/book After those two, real books that cost money will become invaluable. Also, if you do become proficient and use a Mac I highly recommend you get Dash. Offline access to almost every doc for almost every language. Pretty awesome!
Hey I agree that codecademy is rushing their Ruby based lessons. Rails is not that difficult, the website is just not very good at teaching you. I recommend you use this! https://www.railstutorial.org/book Solid everything. 10/10 would bang my head against a wall again.
I'd say the best way to become a shitty programmer is to discourage yourself from experimenting with code, thereby discouraging you from gaining an understanding of how programming languages work. If you don't know how the language works then you can not formulate workable plans perfectly suited to problems and you are, by your own definition, a shitty programmer. I may not be OP and I've been doing this less than a year, but, I'm not going to just read your asshole post without saying something. I'm getting back to second and third year computer science stuff now. I suggest you move over to /r/learnprogramming where that kind of anti-newbie asshattery is welcome.
...I don't get it 0_0
[Here's](http://ltltracking.herokuapp.com/) my complete web-app. I used Sinatra. Thanks for the help!
Which fragment is particularly hard to understand for you? Once you evaluate it step by step, it's pretty simple. The numbers are cherry-picked prime numbers so that further transformations of the result of their multiplication yields `hello, world`. `to_s(16)` transforms the result of the multiplications to its hexadecimal form. `scan` splits the string into an array of strings of size 2. Then the `hex` method is applied to each string in that array. `hex` "treats leading characters from str as a string of hexadecimal digits (with an optional sign and an optional 0x) and returns the corresponding number". The resulting numbers correspond to ASCII char codes, to which they're converted. Then `join` concatenates the elements of that array into a string.
Exactly! Love the data manipulation Ruby has.
Ha ha, Python is a cool language. . . if only the Ruby and Python people came together. . . we might just be able to stop the Javascript onslaught. :) /Long time Python user, been using Ruby for the past 6 months, love both
This sort of trickery started back in the 80s with C and was expanded on in the 90s with Perl, known as JAPHs (Just Another Perl Hacker). Some of them are ridiculous. http://www.cpan.org/misc/japh
Just chop off the time part of now and insert your own start and end times
Believe me, this kind of "trickology"^1 started way way back. It wouldn't surprise me if it is intrinsically linked to computers. (Now that I am thinking about it, this might be an interesting paper, linking trickology to Turing completeness. Although there already is [a link between Turing and van der Poel](http://cacm.acm.org/blogs/blog-cacm/167012-turings-1936-paper-and-the-first-dutch-computers/fulltext)) 1. Poel, W.L. van der (1961) 'Micro-programming and Trickology' in * Digitale Informations-wandler* 
I would assume it's coming from this line: `request_uri = request_line.split(" ")[1]` but it's hard to tell because the code you've posted is obliviously not the real code as it has a number of syntax errors and the line numbers don't add up. Assuming my guess is right, `request_uri` will be `nil` when `socket.gets` returns `nil`. I would check for `socket.gets` returning `nil` and inspect the socket in that situation. Just a guess but what you could be seeing is a network error / timeout with the client sending data after the connection. You may try a guard clause to see if the socket is still connected: `socket.gets unless socket.closed?` or something along those lines depending on how you want to handle the issue.
Can someone explain to me why the numbers are expanded out like that? What's the significance?
I suspect you're correct. And that article is a fantastic read, thanks.
Perhaps a client connects to the socket but closes the connection without transmitting anything. I assume an EOF within the socket.gets within the loop would result in nil getting assigned to request_line. In general, you're doing no error checking at all. The rule of network programming is to be liberal in what you accept. Your program will fail horribly if anything is not as you expected. That's the opposite of what you're supposed to do. Why don't you use webrick and let someone else do all the hard work for you?
Javascript isn't going anywhere for a while.
Have you considered starting out by making sample quizzes on some other, more generic app (e.g. Sporcle) to get real feedback on your quiz/question style? Other than that, it's a very vague idea at this point but sounds good to me! 
Thanks, I may well do that.
Ruby has actually made me use Python's functional constructs more. With Ruby, blocks are everywhere and they're very similar to closures or rather they're a form of closure. Also, Ruby pushes map/reduce processing even more than Python. In general, I'd say that Python is more sane and has better general purpose libraries while Ruby is more fun and seems to have many more libraries overall but many of them are half-baked. It's really easy to create a gem, much easier than creating a Python module IMO. Ruby has a little more Perl in it than Python in that it makes many quick-and-dirty operations easy. They're both great languages though.
It's just some way to factor 32309054545040288110865443940, I'm guessing. Take the hexadecimal version of hello world, coerce it into a base-10 number (above), then just factor it up.
I suggest using docker and pulling down a ruby environment. That way you can experiment with no consequence.
&gt; For anything asynchronous that doesn't need to touch the shell, sure Javascript is a perfectly good choice, if not the best. The asynchronous Python framework Twisted has been around forever, years before node. Ruby has EventMachine. Java has Netty and there are plenty of others. The node crowd would like to have you believe that node.js is the be all, end all of asynchronous frameworks when that's hardly the case. Agreed, people are weird. On the one hand, I understand the desire to have one language to rule them all, because the opposite is a nightmare - when your team/platform uses 20 different languages/toolsets. But there is a happy medium and I think it's perfectly fine to use several different tools. The OTHER thing and I always come back to this - Javascript was more or less forced upon everyone because it was (well except for VBScript for a while in IE) the only scripting language you could use in a browser. No matter how you slice it (Coffeescript, GWT, Pyjamas, whatever) you're dealing with Javascript or something that compiles to Javascript in the browser. Dart never had a chance without buy in from Microsoft, Apple and the Firefox folks. Now just think about that for a second. . . imagine if you had no choice on the backend? Imagine if every web app had to use say, Ruby on Rails. Imagine how pissed off everyone would be if they had no choice on the backend! Yet, that is the reality for frontend web programming and THAT is my major problem with Javascript, I have to use it for front end code. . . that sucks! And by extension, when I see the proliferation of Javascript everywhere else, it pisses me off because we have a situation where a language has been forced down our throats because you can't avoid it on the front end (unless you're not doing web development but let's face it webdev is pretty freaking popular for obvious reasons) and now, it's being forced down our throats everywhere else. Enough Javascript, Jesus Christ. And all that being said, I don't hate Javascript, I think it's OK.
I totally agree with everything you have said here. I would reemphasize that Docker has really fixed the issue of a non-homogenized coding team (within bounds, as with everything). It is amazing that people don't throw up their hands a bit more over the lack of choice on the browsed end. Yet every time I talk to a node person, I get told that JavaScript can do anything. Yes, any language can do anything, and if you stand by your favorite language to the end, no matter which one, you will be out of a job. Yet the node world seems to really lure people into a strange mindset. I think node and JS are beyond OK, I think they are great, but yeah... JS people seem to be the equivalent of the apple fanboy within development. 
I understand its vague, but was thinking to make some screenshots/mock ups if there was at least 20/30 responses. So far, I have got only 7. Perhaps, I will wait a week more and see if some more will be interested.
if you change STDERR.puts request_line to STDERR.puts request_line.inspect you should be able to get a better idea of what socket.gets is feeding you. 
This is where you puts a gist.github.com link or something. The reddit pasting makes things a lot harder.
That's a good suggestion, thank you, I will use github next to link the code next time.
use RubyMotion
best thing is RMQ tweet @GantLaborde for more info or InfiniteRed. They're always helping people get setup.
Hm, so I tried what you suggested and this is what was coming out of the socket. "GET / HTTP/1.1\r\n" "GET /favicon.ico HTTP/1.1\r\n" "GET / HTTP/1.1\r\n" "GET / HTTP/1.1\r\n" "GET / HTTP/1.1\r\n" "GET / HTTP/1.1\r\n" "GET / HTTP/1.1\r\n" "GET / HTTP/1.1\r\n" "GET /index.html HTTP/1.1\r\n" "GET /index.html HTTP/1.1\r\n" nil HTTPServer.rb:23:in `requested_file': undefined method `split' for nil:NilClass (NoMethodError) So the issue does in fact seem to be socket.gets returning and crashing the program. How would you suggest fixing this issue? 
I wanted to learn by making the HTTP server myself, I think it doesn't do anyone any good to not do something just because it's difficult.
Check out https://github.com/michaeldv/unbelievable -- it let's you write Ruby code in plain language ;-)
That's an interesting link, thanks! However, and that's what makes Reform different to Lotus validations and ROM, etc. is that validations in a form can be business logic, too, and that has to be programmed in Ruby, a schema doesn't help but could provide boilerplate code. Anyway, reading that stuff you could easily generate a "basic" form from a hyper-schema. Cool idea, thanks!
I think the you'll get a lot more response *after* you've made a mock-up! At the moment, the idea is about as vague as saying "I might make a ruby screen cast. Is this a good idea?" - people would give you much more feedback if you actually posted the first video. 
&gt; You could write a PHP -&gt; Ruby compiler Sounds trivial! This is clearly the best option ;) 
Take Lagniappegirl's advice and go with RubyMotion, it's easy to setup and works pretty well. I've played with Ruboto and I have to say it sucks. I couldn't even get a simple Hello World app working after several attempts.
&gt; 32309054545040288110865443940 /u/vin_edgar is right. https://www.wolframalpha.com/input/?i=prime+factors+of+32309054545040288110865443940
The first one, because DRY. In general: It doesn't really matter. If you feel strongly about keeping a consistent code base (style wise), use a tool like [rubocop](https://github.com/bbatsov/rubocop). btw. you should use two spaces, not four for indentation.
Haha thank you. That's me trying to carry over Python subconsciously. And yeah because of DRY the second felt weird to me but I thought...maybe that's how they do it in Ruby.
The first one. But I think it would be easier to read as `unless current_ip == new_ip`.
Like this: [= square [lambda [x] [* x x] ] ] [puts [.to_s.blue [square.call 2]]] [def [argumented x=2] [puts x] ] [argumented]
Thor gives you a structure for documenting the app, but you still have to supply the information. This article is partially about what you need to keep in mind when providing that information, so that your documention is useful to the reader. 
I'm assuming he means if you end up implementing additional functions besides sending an email. Otherwise you'd potentially end up with a giant if statement that would logically make more sense in a separate method. 
At my last workplace, the lead dev preferred to use 'unless' only for inline statements. IE: if !(foo) # do X end versus foo() unless bar 
I agree with this preference. Maybe I'm just dumb, but even as a native speaker it always takes me a little bit longer to mentally parse "unless" statements. Something something double negative.
Well, good syntax highlighting can compensate for that - either approach is reasonable as long as it's applied consistently. We don't enforce style on either, since I feel that different styles are clearer with different predicates.
Who says you have to? Using thor, or another command line framework, you can still wind up with good or bad documentation, depending on if you pay attention to the places thor gets it's bits for documentation, and making sure appropriate ones are filled out appropriately, and how they end up looking in the help screen thor generates. For instance, the neglected thor `banner` class method and `banner` option (two different things). 
From my ***personal experience*** I think more than the web framework itself the principles they carry matter more. - For eg; Rails, Django, Express or whatever the principle here is MVC. - Ruby or Python, principles are OOP (Object Oriented Programming) or Functional Programming. ***Principles*** like forms, templates, route, migrations, unit tests, CRUD operations etc are something every web dev should be familiar with. If you are comfortable explaining these to anyone at anytime, you will easily crack the interview. ***Most Interviewers*** look for people who can solve a problem or at least come up with an approach. "In Depth stuff" matters less unless you are interviewing for Google or Facebook. ***"3-5 years" is just a filter***. Even if it says 5+ years go ahead an apply. Just be a normal, likable human being in the interview who can solve problems or come up with approaches. Also apply for at least 3-4 interviews to get a hang of it. Keep at least a week's time gap between all the interviews. Me and my friend did the last part. ***After 2-3 interviews we became really good at cracking interviews*** but we didnt take any offers coz by that time we were "too good" :P
"if this class changes a lot" - I was referring to churn... or how often you make changes to the code in the class. Basically if the class is simple or seldom changes then your four line solution works great...
I'm just starting out with Ruby too and I find that reading books help a bit to understand programming. I'm currently reading "Learn to Program" by Chris Pine and "Eloquent Ruby."
You could actually combine the two, by using unless. unless current_ip == new_ip send_email(new_ip) current_ip = new_ip end Although a guard clause is looked upon more favorably (only if you're somewhere it could be called, like a function) return unless current_ip == new_ip send_email(new_ip) current_ip = new_ip
I always think about coders as artists: we create things from scratch with the help of our creativity.
Jesus christ.
Looks interesting. But are there any advantages in comparison to other state machine implementations? (e.g. AASM) Thanks.
Ruby (core) will automatically account for leap seconds, by delegating the calculation to the underlying operating system. [Link](http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/57104).
Very basic. Plus, didn't Heroku change their pricing lately? I'd love to see a very in depth tutorial about how to do some dynamic stuff. Also, iFrames in HTML, I've never seen anyone do it yet in haml, or erb. 
Eloquent Ruby is a very great book. Read it :)
Oh, guess I haven't hit that yet. LOL, thanks for the heads up!
I think Code academy is good for syntax but I LOVE and highly recommend exercism.io to actually practice writing code and learning testing syntax 
Nice! Any plans to support other db types (sqlite, mysql) through command line options?
so good! 
Nice write up, your gist and repo links don't seem to work though. Is the repo private? Did you replace the gist?
Confirmed. Sublime Text (especially version 3) is awesome.
My 3 cents in free form text: I would not use it. Coding is a skill learned by practice, not unlike riding a bicycle. I could take multiple surveys on how to ride a bicycle properly and still not be able to ride. Only coding experience trains me to think in code and this has little to do with memorizing correct answers. I find exercise-oriented resources like rubymonk, ruby-kickstart, codewars and exercism very useful and worth some of my limited and precious screen time. Again, this is my opinion but may be try for other programmers who prefer training to memorizing. 
that line of code does read the whole file into memory. Look into using IO.foreach. it will stream each line and not keep the whole file in memory. 
If you want to do this to learn something about Ruby, then fine. But if you actually need to do this, you don't get faster than just executing grep. Consider doing that if you can: http://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html 
And Google...
Thanks for that. I'll look into IO.foreach. I keep reading that File is a subclass of IO, but no real mention of either reading a file pointer, or the whole file into memory. 
I use try in some cases, for instance, if I need some field from a first row in a where clause I use try to check there were no errors `Product.where(:some_clause).first.try(:price)`, not sure if there's something better than that.
But now the the return type can't be assumed so you have to have "if" logic mucking things up.
depends if the engine compiles views and doesn't reload scripts, too. complex frameworks go through a lot of scripts, even more so if you have a thousand dependencies and libraries, all adding a small amount to the processing time, this is best visualized (albeit not a web framework) in [Atom's timecop](http://i.imgur.com/jW6jYcv.png) tl;dr the reason probably is that there are a lot of dependencies being loaded that are badly written
Dynamic languages can't be optimized to the extent that static languages can. A program written in a dynamic language can modify itself as it runs, so the strategies that are used to optimize the bytecode/machine code are less efficient.
With the caveat that if the patten you're looking for happens to contain the record separator, you're gonna have a bad time.
Performance is not everything grasshopper. You need to know when optimization is important and when it is not. There is no *better* framework or language. Each is suited for a particular use. When I need to write a utility that has to work blazing fast then you can be damn sure I will fire up vim and tear into some C code. However, not everything I write needs to be *that* fast. Even with years of experience it still takes me longer to write C code than Ruby or Python. Also, if you **want** to write a webapp or API in C then be my guest.
What has *some* diagram common with reality ? In practice I've experienced several Struts and JBoss deployments running slower then comparable Rails - by measuring handled requests per second and general response times. Does it mean Java-based web frameworks are less performant ? JVM or mature C/C++ compilers produce usually faster code then known Ruby and Python implementations. However just in area of serving a web content the differences are dwindling, because total performance depends on many other factors then the programming language itself. There are many big sites like Github (written mostly in Ruby) which I find fast enough with regard to their high traffic.
You are right! BTW the Rails part is based on http://guides.rubyonrails.org/active_support_core_extensions.html
I often use it for displaying data in a one liner when associations might be nil, like if you have customer accounts that haven't made purchases at all, and you're displaying a list of customers and purchases = customer.most_recent_purchase.try(:purchase_amount) || 'N/A'
Perhaps, but Clojure is slower than Java. /u/digger250 said that dynamic languages generally can't be optimized as much as static languages, not that all dynamic languages are equally slow.
I generally agree. This usually means that you are not sure what type of object you have (for example as return value from some other method). Unfortunately, this was accepted (or even encouraged) in Ruby community for many years and you can have it from some external library or something. Writing a proxy can be too expensive sometimes, so you have try for simple cases.
Parent post isn't quite correct. Static languages can also modify themselves at runtime. The static/dynamic distinction has more to do with the ability to predict the type of a thing without having to run the program. Clojure runs on the JVM, which has seen 20+ years of intense research into how to make the fastest possible VM. Ruby and Python have started down that path (YARV and the new semi-generational collector for Ruby, Pypy for Python), but have a lot of catching up to do. Also, Ruby and Python have stated their intention to remain compatible with existing extensions written in C, and that unfortunately limits the extent to which they can improve. Also, while Clojure is dynamic, it is able to do a decent amount of type prediction, and where it is not it must fall-back on the Java reflection APIs which slow things down considerably (hence the recommendation to turn on "warn-on-reflection").
I wouldn't say that Rails autoloading is awesome. While convenient, it totally hides dependencies from you. Moreover, it's so magic that there's [an entire chapter about its gotchas](http://guides.rubyonrails.org/autoloading_and_reloading_constants.html#common-gotchas). Here's a post on [Bundler.require](http://myronmars.to/n/dev-blog/2012/12/5-reasons-to-avoid-bundler-require), put point 2 and 3 can be also used against autoloading.
Heh... Interesting... Character encodings are weird!
 ?a.upto(?z){|o|$&gt;&lt;&lt;o} Could someone explain this? I get the part in the block, but I haven't seen the ?a notation or passing a block to upto
You can do local variable assignment in conditions like this: ```a = 42 and p a```
A bit of googling found me this, https://stackoverflow.com/questions/1345843/what-does-the-question-mark-operator-mean-in-ruby for the question mark - it gives the ASCII value. The upto block does exactly what you'd expect - it runs once for each number in the range (?a, ?z).
I wonder why you're getting downvoted, as it's an actually reasonable stance.
huh, thanks!
Use this: http://ruby-doc.org/core-2.2.2/
Cool - thanks for the info
This one seems to be the most popular answer here. Its on my to-do list to get and read. 
I just found an even shorter way of doing this one example! :D ?a.upto(?z){|o|$&gt;&lt;&lt;o} # 21 chars $&gt;&lt;&lt;(?a..?z).to_a*'' # 20 chars
This was news to me.
I wouldn't be at all surprised if those benchmarks you're referring to are simple "hello world" apps or some trivial cacheable DB operation. You need to factor in what your likely bottleneck is going to be (calls to the DB in many cases). Take a look at a more realistic comparison and you'd probably find that the execution times are no more than double (if that) which is a range that many are comfortable with given the positives. Olympic sprinters can run WAY faster than I can, but make us both carry 50kg backpacks and we're probably going to be moving around the same speed.
If anyone is looking for the correct path of the broken link: This change is just part of the evolving conventions in gem development. RSpec, for example, has had its executable in exe since 2011. It just contains an incorrect capital letter: https://github.com/rspec/rspec-core/blob/v2.7.0/rspec-core.gemspec#L19
The link doesn't work for you? 
10 Tricks to Make Your Code Less Readable to the Next Developer 
Oh, duh, I didn't click the link the article. Thank you for the updated link!
Thanks for this. I've been struggling with the same. 
 .join Is much more readable, though.
Riiight... Whoops
IMO pretty wordy for a basic programming concept. For those having trouble with this sort of thing: The key takeaway is **the difference between (returning) a value vs a reference**. Learning to use pointers in C/C++ will _really_ drive this concept home.
We got deep into Jekyll for our sites. It brought joy back to our jobs after years of shitty CMSs that only we developers would end up adding content to.
If you like video, you might like this: https://www.youtube.com/watch?v=OvUIFKxmpko - it's only part 1 of 3, but it's old enough now I might upload the other two parts next actually! :)
published a preliminary version under an old gem name that I haven't updated in a while: https://rubygems.org/gems/meta_instance https://github.com/NullVoxPopuli/meta-instance
Dear god, it's perl... The heavens help us...
https://rvm.io/
or ruby-build or ruby-install
What are you actually trying to do? Find all employee's who's first name's are greater than 10000? That doesn't seem right. So what's up with `@salary = Employee.first_name`, what are you trying to accomplish with that? You also have a random `]` in there that will give you a syntax error. If you have experience programming but not with ruby, I would suggest spending a day or two just learning ruby-without-rails, so you understand syntax and such. If you are trying to find the number of employee's whose salary is greater than or equal to 10000, this would do it: Employee.where('salary &gt;= 10000').count
Not any different then doing a source install in terms of maintaining environments and consistency between servers.
It's a great approach for test boxes. But compiling ruby everytime I stand up a dev/qa/prod box it's extremely annoying. All of a sudden I have an extra 20+minutes on my chef run and I *might* not end up with the same build of ruby in the end? not a great plan. And I really do mean might, I get that with rvm I will probably get the same version of ruby installed. But what about next year? 5 years from now? 10? there is just no guarentee that I can create the same environment with that solution indefinitely like I can with an rpm.
fyi.. [support for ruby 1.9.3 ended Feb 23, 2015](https://www.ruby-lang.org/en/news/2014/01/10/ruby-1-9-3-will-end-on-2015/)
There’s a typo: &gt; &lt;footer&gt; &gt; Copyright &lt;%= Time.now.year &gt; &lt;br /&gt; &gt; &lt;/footer&gt; &gt; &gt; Note the use of `&lt;%= something %&gt;` here. In the code block, you wrote `&gt;` instead of `%&gt;`.
`compact` is more idiomatically expressed as `reject(&amp;:nil?)`. Your desire to implement `#uniq` on lazy sequences is a bit misguided: what is the `StopIteration` condition for, say, `[1].cycle`?
&gt; `reject(&amp;:nil?)` ... `#uniq` Thanks! I updated my post and the code. That's a very interesting point about the `#cycle` enumerators. Maybe the solution would be an option to `#uniq` with a number of repetitions allowed before `StopIteration` is raised. It'd be a programmer-beware kind of thing; in the way one always codes to avoid infinite loops. The use case here is parsing large CSV files with hundreds of thousands of rows on inexpensive VM's. And the reason why the files are so large is that they are the de-nomormalized databases of decades of government data crammed into single CSV files. E.g. every restaurant's name and other info is repeated hundreds of times — on every row for every health violation. My `map_csv` looks like this: def map_csv(&amp;row_handler) CSV.new(File.open(table_file, encoding: 'utf-8'), headers: true) .lazy .map { |row| row_handler.call(row) } end 
I liked rubymonk.com
After looking into this a bit, I've come up with the following implementation: class Enumerator def uniq cache = Set.new Lazy.new(self) do |yielder, value| yielder &lt;&lt; value if cache.add?(value) end end end [1, 2, 3].cycle.uniq.take(3).force # =&gt; [1, 2, 3]
Fascinating. Thanks so much. This has been really interesting.
I'm not sure I understand your problem, but it sounds suspiciously like you're trying to reinvent the Hash, poorly.
Middleman is great. I use it to build the site hosted on my [Raspberry Pi](http://pi.tafkas.net)
[Here's the input](https://data.cityofnewyork.us/Health/DOHMH-New-York-City-Restaurant-Inspection-Results/xx67-kt59). And [here's the output](http://www.rubydoc.info/gems/eaternet/0.3.17/Eaternet/Agencies/Nyc). So the issue is, what's the best way to implement it so that: * the whole file isn't slurped into RAM, * you can play with the data right away after instantiating the client class, * the code is clean and refactored: there'll be many different cities' data coming soon, all being parsed to the same output enumerations. And so [this is the current implementation](https://github.com/eaternet/adapters-ruby/blob/master/lib/eaternet/agencies/nyc.rb). It's pretty slim.
This talk does a *superb* job of organising and presenting a bunch of ideas that have been rolling around in the back of my head for decades, and I suspect many others' as well. Definitely worth 45 minutes of your time for anyone reading this. It also helped me to understand why the last nearly four years of daily Ruby has made me gloriously happy with my *work* and deeply dissatisfied with my *job* — applying hermeneutic tools and philosophy to an intractably formalist, oh-no-we're-not-hierarchical product, in a company based in a Ponzi scheme of a country where hierarchy is a matter of enforced societal identity, and innovation (or anything else) outside clearly-understood but never-specified "OB markers" is strictly forbidden.
Well, first off, why not parse the data with `CSV.foreach`, rather than trying to fake it by making the read `lazy`? I guess I don't understand why you want to do that. Every restaurant has a CAMIS number that uniquely identifies it. You could create a `Restaurant` class, that contains a number of `Violation` objects. For each line in the CSV, instantiate a new `Violation`, look up the `Restaurant` in the `restaurants` hash by CAMIS number attached to the violation, and add it to the resultant object. Something like this: @restaurants = {} CSV.foreach("path/to/file.csv") do |row| rest = restaurants[row["CAMIS"]] ||= Restaurant.new unless rest.name # The restaurant hasn't been seen before insert_code_to_initialize_restaurant_here end rest.add_violation(Violation.new( code: row["Violation Code"], description: row["Violation Description"]) ) end In the end you'd have a hash keyed on CAMIS number, each of which returns a single `Restaurant`, which contains zero or more `Violation`s. (Note that I don't have much experience with the CSV library, so the exact usage may be off in the code example above.) As someone who has been there and has tried to reinvent Hash poorly as well, I promise you that you can't do it. Hash in Ruby is very, very fast, and scales very, very well, and it does exactly what you want it to do by ensuring that each restaurant is only instantiated one time.
Yes, that makes sense, except I ruled out that kind of solution because there's not enough RAM to fit the entire dataset. This is optimized for _space_, not time. It's slower than it could be, and that's fine because it's meant to run as batch processes on something like Heroku. Also note that your code parses the entire file before passing control back to the user. So while it's faster, it'll feel slower when used in an interactive development style. If you adapt your code for that, it starts to get closer to mine. But a second design point is that the "output" should be in the form of, * List of restaurants, * List of violations, etc. I don't need to attach the violations to the restaurant! This is because the output is a Ruby-ized version of this standard, made by [Yelp and the cities of NYC and San Francisco](http://www.yelp.com/healthscores). This code translates weird crap in whatever format it's in, into cleanly defined lists of objects. This repo will be adapters for many city/agencies; grabbing the source data in whatever form it's in, and then offering it in the form of a handful of [`Enumeration`s as I've specified here](http://www.rubydoc.info/gems/eaternet/0.3.17/Eaternet/Lives_1_0/Adapter).
Oh and btw, I just realised... Even though your version definitely looks cooler, you can in fact just do: p [*?a..?z]*'' # 14 chars Edit: Or if you're using **ruby version 1.8.7** then this will not work, since `?a` returns the ascii code, not the character. However, instead you can do: $&gt;&lt;&lt;[*'a'..'z'] # 15 chars ...Since back then, printing an array would simply display as its elements.
Well, it sounds like what you really want here is a database. Why not just use SQLite or something? Edit: Not sure if it answers your question about `uniq` or not, but the fastest way to determine “Have I seen this thing before?” is still probably looking it up in a Hash. Just use the thing as a key and set the value to `true` every time you find something that's not already in the hash. I'm still not sure what it is you're trying to actually do and why, though.
&gt; Also note that your code parses the entire file before passing control back to the user. Are you sure? AFAIK `foreach` reads the file line by line and passes the control for each line to the block. I can't find it in the docs, but there's an article claiming the same thing: http://www.sitepoint.com/guide-ruby-csv-library-part/
For all those people who use Ruby, but secretly wish they could program in something cool, like Java.
Ah man, tell me about it. Our CMS is supposed to be for normal users to take a shit in, but they seem incapable of even trying to log in to the damn thing. It doesn't take a genius to post a fucking JPEG file to the web with this so that they can use it in some marketing email. Damn them.
Nice use of a lightweight static site maker on a lightweight piece of hardware!!
I have a few questions: * What is the compiler error. Are you sure it's even related to ruby? * Have you tried the ruby200 SCL? * Why do you need oniguruma? Isn't that what ruby's built-in regex engine is based on?
That's a very different question from "What is the best way to get a ruby 1.9.3 environment setup on RedHat?" I still maintain that RVM is the best way to get an environment set up. Once you have your environment the way you like it, I'd recommend something like Docker or Capistrano to keep everything in line. At a minimum, just provide your own binaries to RVM.
With such [beautiful, idiomatic examples](http://infraruby.com/examples/wiktionary) to be inspired by, who *wouldn't* want to invest the time/effort in using this tool?!
So, what is InfraRuby? It looks like someone just doesn't want to say JRuby. What would this get me over just regular ruby stuff? 
Did you actually click the link and read it?! &gt; When compared to JRuby, InfraRuby has faster startup (~0 seconds vs ~5 seconds, depending on your hardware) and faster runtime (~5x, depending on your code), and also lower memory usage (~3x, depending on your code). &gt; The InfraRuby compiler is implemented in the InfraRuby language and uses JRuby to bootstrap: the compiler source is compiled to bytecode using the compiler itself under JRuby. For comparison, the compiler source is compiled again using the compiled compiler. &gt; This chart shows, for each runtime, the time to compile the compiler source to bytecode: &gt; http://infraruby.com/asset/7CC1BFA68B178D61.png (And obviously, the one key feature that this has but ruby intentionally avoids: type checking.) However, you'll also end up working with closed-source software, a very restricted library, a tiny online community and ugly unidiomatic code. So, you know, swings and roundabouts...
&gt; with service.call returning either a Failure or Success instance (see Either in Haskell or Result in Rust). &gt; I like this idea - I think that we can learn a lot from functional languages. Sandi Metz talked about similar approach during her [2015 railsconf presentation](https://www.youtube.com/watch?v=9lv2lBq6x4A).
Thanks, that certainly helps. I'm basically trying to do something like this: &lt;lvl1 attr = 'x'&gt; &lt;lvl2&gt; &lt;lvl3 n = 'unique_value'&gt; Basically I'm searching for that unique value (which is easy enough) and then pulling out the value of x in the level above it (what I'm struggling with)
&gt; The differences to current 2.1 and 2.2 branches are negligible, nothing a newbie should care about. I wouldn't say negligible, but definitely nothing to concern a newbie. The quality of the Pickaxe Book is so high that it's still a great way to learn the language.
Yep, `foreach` works like you describe; I wasn't very clear. I mean _literally_, with my code, I can do this, and it returns the prompt back immediately: pry&gt; bb = nyc.businesses # =&gt; Enumerator::Lazy ...I can then take a look at a data item, which also returns immediately: pry&gt; bb.next This makes it possible to write unit tests which use data in these huge files. But in your solution, it will parse the entire csv file before returning, which is exactly what I wanted to avoid, because it does take a while. (Unless I'm missing something?) Also, note that _inspections_ need to be de-duplicated as well... 
If you are familiar with python, then you'll be happy to have keyword arguments in 2.x. The other changes will only make sense for someone that's already an experienced ruby developer. http://globaldev.co.uk/2013/03/ruby-2-0-0-in-detail/ 2.1 and 2.2 were, from memory, mostly performance improvements.
stack trace: https://friendpaste.com/qXGF3BxP9bJdZiyZVVBX5 I don't think it's ruby version problem particularly. I think it's a ruby environment setup issue. ruby193-ruby-rubydevel is installed so it should have the neccessary headers, but it still seems to be missing something. I think it's a disconnect between the makefile from the gem install and how this ruby environment is setup by RedHat.
it's okay.. i'm installing ruby 1.9.2 on a server right now.. 8)
OOoo, that might be the solution I'm looking for. Thanks! Man RedHat is a pain in the ass.
pick axe? Is that the Pragmatic programmers book?
Yes. Some of the differences between 1.9 and 2.2 are: - Source code is always UTF-8 - You can have symbol keys in your hashes with `{ key: :value }` instead of `{ :key =&gt; :value }` The rest you'll get as you read on.
The [colorize](https://github.com/fazibear/colorize) gem seems to be what you're looking for
Why would someone downvote a valid question.. I'll find you!!
Yep. It's a great resource. It was how I got my start way back when. Can't recommend it enough. 
If you didn't want to use a gem, you could create your own methods. def colorize(text, color_code); "\e[#{color_code}m#{text}\e[0m"; end def red(text); colorize(text, 31); end def green(text); colorize(text, 32); end def blue(text); colorize(text, 36); end You can then call puts blue('The pen is royal blue')
That example uses JRuby's syntax for Java integration. Not all InfraRuby code looks like that! EDIT: Also, you would still need that Java integration code (`Java::android.app.Activity` etc.) if you were using JRuby instead. It has nothing to do with InfraRuby specifically. And you know that. 
The current pickaxe book even includes those two points. It includes info for both 1.9 and 2.0
Do you know what it would do if you are in a terminal that doesn't support colors, or are piping it to a text-file?
I have a blog post, where I explore the idea of passing callbacks as arguments http://codingwithaxe.com/callbacks-and-ruby/ I will definitely explore Rust's and Haskell's approaches to this problem. Thank you very much :)
I think there might be a different abstraction that would fit your purposes better than a form object, but it is definitely hard to reason without seeing actual code :) As with everything in programming: "It depends"
Is the explicit `return` required for Java integration?
No.
Are the hard tabs required? What about the excessive use of local variables? 
I don't know
Try [GDBM](http://ruby-doc.org/stdlib-2.2.2/libdoc/gdbm/rdoc/GDBM.html). Note that you may need to install `libgdbm3` if your distro doesn't include it already. It's not the fastest thing on the planet but it's a key-value on disk database and is included in the ruby stdlib. It allows multiple readers so you can startup the batch process to build the DB in the background and immediately look at the data as it's built.
The standard library's `Set` is just a (very nice) [wrapper around `Hash`](https://github.com/rubysl/rubysl-set/blob/922ff85d02aec21541324ca947bf6b0aa78ec130/lib/rubysl/set/set.rb#L185), for what that's worth, but you're right that the implementation could use (marginally) less space by directly invoking `#hash` on the values. That said, even [Haskell's `nub` function](http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-OldList.html#nub) is O(n²), 
`Hash` stores values as references: foo = "" bar = {foo: foo} foo &lt;&lt; "foo" bar # =&gt; {:foo=&gt;"foo"} That no copies are made means that the increased storage requirements are, as I said, marginal.
If it where truly lazy, all other references would leave scope each iteration of the lazy pipeline and the object being referenced would be GC'd, maintaining a reference to each object as it passes through the pipeline means the memory usage for the entire pipeline will grow at O(n). 
I disagree with the author. I've had times where I've used inject that returns a different type versus the initial value. May not be the best example but I've done something like this to nest parsed keys. def nester(arr, value) arr.inject(value) { |v, k| { k =&gt; v } } end Given value = 1 with arr = [2,3,4] This would output a nested hash: { 4 =&gt; { 3 =&gt; { 2 =&gt; 1}}} 
That's a cool idea. Yes, some kind of key-value store which is on disk. 
who the hell makes a CMS designed to take a shit in
I believe it detects if it is outputting to a TTY and disables colours if not. Look at the readme and code, it isnt big.
You'd be surprised. It's the usual story though. For making normal templated pages, uploading things, etc... it's supposed to be pretty straightforward for normal users. But they still think it's some sort of technical magic or something. For doing actual development work, it's a goddamned pain in the arse; it's faster to hand-code HTML than it trying to do the infinite loop of point-click-edit-submit-fuck!-gotopoint...
 class String def red "\e[#{31}m#{self}\e[0m" end end puts "foobar".red Excuse the formatting. On an iPad. 
The question isn't about whether the good performance matters or not, it's about why do Rails and Django have such bad performance?
I think we've already explored callback hell in the programming world. If you really want to take this approach (and I don't like it), at least return a promise. 
If you really need to have static typing or you need the speed of C, have a look at crystal lang!
This is eloquent (y) Thanks a lot :)
Do you have build-essentials installed?
still pretty new to Ruby, so I'm not sure about this, but why wouldn't you use a map to do something like that since you're iterating over each element and changing them in place?
But I'm not really changing anything in place. Map wouldn't work since map would return a new array with each element "mapped" to whatever is returned by the block. Look at how many elements are in the array. If you were to use map, it would end up with an array of 4 elements, however my example outputs, at least on the very first level of the hash, a hash with a single key value pair. 
Lol it's a dutch job. Expect it to pay next to nothing. Salaries for dutch programmers are embarrassing..
Okay, thanks for explaining.
10 Tricks to Keep In Mind While Trying To Read That Other Guy's Code
&gt; COTS application In that case, contact the vendor for support.. it's more expensive but likely a lot more useful than r/ruby. What are the supported platforms in the vendor's documentation? Does it include RHEL? Which RHEL versions? (4,5,6,7 are all in support at the moment).
Ruby's keyword argument behaviour differs significantly from Python's (in a good way :P).
I would be very wary of using ``try`` in your code. Instead, seek to return sane defaults for not found objects. A collection that's not found would be an empty array instead of nil for instance. Really, just avoid nil in general as it makes little hacks like that seem necessary.
Yep, you're 100% correct. I forgot your original question by the time I got to this comment on the bottom. Haha. Sorry about that :-)
Glad you got it working. I'm not sure if I like that the board is accepting input from the players, however. I'd make a third class called "game" or something to that effect that would serve as an integration point between the players and the game board, personally.
Edited to include source code
I've gone twice in a row and it's a great conference. Although, disclaimer, some friends of mine have been involved with organizing it in the past, and/or are visible members in the DC Ruby community, soo there's that. (hi guys!) $300 isn't bad for a conference, at all. There are some conferences - Steel City Ruby and Nickel City Ruby - that were $99, but factor in hotels in Pittsburgh and Buffalo respectively. (For sense of scope, RailsConf and RubyConf are close to $1,000, I thought) The DC/NoVA/maybe Maryland??? area is awesome for Ruby meet ups, which is actually what I'd suggest looking into, at a beginner level: one in DC itself, Arlington Ruby and NoVA Ruby. There may be more: my knowledge is a couple three years outdated by now. Arlington Ruby occasionally has what it calls Retrocession: essentially one day conferences. Never been, but I suspect it's fun.
I am a brand new Rubyist, aspiring web developer, and blogger at the Ring.pop blog. I am studying seven days a week to learn RoR. I post detailed study logs every Saturday. I'm averaging 20+ hours a week of dedicated study time! I started this 1,000 hour challenge to keep myself motivated and to inspire other beginners. I have no background in programming.
I would say in general that looking to consulting companies that mostly work in webapp applications for more serious engineering knowledge isn't a great idea. Keep in mind that most of what these companies do is churn out low-medium complexity mostly CRUD apps. Thoughtbot especially, has done a great job optimizing this process and do a wonderful job helping the community via blogs, OSS, etc. But, I wouldn't look to them to learn much about building more complex or general purpose code. Here are some things that I would recommend doing: 1. Learn a new programming language, preferably one that isn't at all like Ruby. Go, Java, Scala, Clojure, C, Haskell, etc. Most importantly try to learn them in an idiomatic fashion, i.e. don't try to write Ruby in Scala. Each language has it's own standard patterns many of which are much different than Ruby's patterns. This alone will expose you to many more design patterns and if you dive into the 'why' you'll certainly gain knowledge. 2. Learn devops tooling. e.g. Build your own mini-heroku starting from bare boxes. This actually isn't terribly difficult anymore and you'll learn a lot about systems along the way, particularly if what your used to is `git push heroku master`. Along the way you'll pickup a lot of knowledge, linux command line tooling, configuration management (Chef, Ansible, Salt, etc), deployment models, etc. All of this knowledge is very useful and feeds back into your coding, i.e. how do I build this app in such a way that it's configuration can be easily managed? How do I log effectively? How do I monitor? (statsd, etc). 3. Dive into higher level language agnostic topics, overall system architecture, distributed systems fundamentals, etc. Microservices, caching, consensus algorithms, etc, etc.
&gt; The mini-heroku sounds most interesting though. If you don't have much systems background you can break this into chunks: 1. Build a Chef recipe (chef uses Ruby for it's recipes so it will be familiar) that can take a Rails app hosted on github and deploy it on an EC2 micro instance starting from a base Ubuntu image. This one takes maybe 100 lines of Ruby to do but will introduce you to a lot of the configuration and systems basics. 2. Figure out how to deploy your app with Capistrano to this node. 3. Build a docker image as part of your code's build (on travis-ci for instance) and deploy that image to a node. 4. Integrate it all, use a Chef recipe to build a docker base box, automate the docker image deployment, etc. Many ways to do this and several OS projects that do most of it already. 
It's a realtime framework that let's you write Ruby on the frontend and backend (isomorphic Ruby). Check out the [homepage](http://voltframework.com/) or [this tutorial](http://datamelon.io/blog/2015/building-a-chat-app-in-volt.html)
Resolved this one by moving my posts to source/blog folder. My `config.rb` I had following set up as - blog.prefix = "blog" Hence, it was looking into blog folder for articles. Moving them resolved my issue.
I think you completely missed the point i was making. Read between the lines. The examples on your website are horribly ugly. They go completely against any ruby style guide. No one is going to look at those and think "InfraRuby looks great!" 
Some of my favourites are: * https://robots.thoughtbot.com/how-we-test-rails-applications * https://robots.thoughtbot.com/using-polymorphism-to-make-a-better-activity-feed-in-rails * https://robots.thoughtbot.com/if-you-gaze-into-nil-nil-gazes-also-into-you It's not free, but their Ruby Science ebook also has a ton of good stuff: https://gumroad.com/l/ruby-science And there's also [Upcase](https://upcase.com) which I would highly recommend. 
It never stops surprise me, how much (waste) content can be generated around a trivial issue. Like from one ancient Greek fable, where after long and strong rumbling and earthquakes, mountain delivered a tiny mouse. There has to be some kind of inefficiency characteristic to teachers. Like a proverb *"Who is good at something, he does it. Who is mediocre at the same thing, he writes books about it. And who does not even understand it, he teaches it …"* ;) 
http://stackoverflow.com/a/6741614
If you've read the link you've posted, it suggests add it to a `Gemfile` of your project and then run `bundle install`. Or alternatively install either system-wide with `gem install google-api-client` or to your profile/home-dir with `gem install --user-install google-api-client` and update your executables search PATH appropriately.
You have to add it to dashing's Gemfile. After you add it to there, run `bundle install`. The 'Dependencies' section you linked tells you this: https://gist.github.com/mtowers/5986576#dependencies
yeah this is where I mis-read. Thank you very much, now kind of working!
"Blog has been removed"
While another has kindly answered your question.... Never do this, use a Hash instead.
http://i.imgur.com/1kdDpjx.jpg
That's just the way I tried to explain what I need:)
Wat.
Hi, I am also new to ruby. I started learning it last week. I did have some (very little) programming knowledge prior to starting ruby, so conditionals, loops and functions (methods) weren't completely new to me. But, OOP is new to me. I was inspired by your tic-tac-toe program, so I made one of my own. This is my first real program in ruby. Till now I have only been doing small exercises and drills, and I felt really good after I completed this. Its *amazing* how much you gain in confidence after doing a larger project like this! I feel like I have **finally** understood OOP and all the elements of ruby, as everything naturally came together. There is still room for improvement, and I plan to do it soon. For example, print_board is not very pretty, and it may make sense to separate out the 3 classes into 3 source files (maybe even introduce a 4th class), AI could be a nice addition, and of course refactoring and more code-styling... But, at this point, the program works (hopefully no bugs!), and OOP has been implemented in a satisfactory way, so I feel it is good enough to post here. I have [posted it to github](https://github.com/arjuntemurnikar/Tic-Tac-Toe/blob/master/tic_tac_toe.rb). Any comments and suggestions for improvement are most appreciated! And thank you OP for the inspiration! Hopefully, my implementation gives you some inspiration too. In that case, nice trading inspirations with you, kind stranger! :)
Wow. Interesting! I hadn't read your comment, but I thought exactly the same way. I am new to ruby. See my post [below](http://www.reddit.com/r/ruby/comments/37snkx/hi_two_weeks_ago_i_vented_about_my_inability_to/crqygev). I implemented something along those lines -- a mediator, called "Referee". The players tell their move, and the referee validates the move before making it. At no point is the board state modified by either. The Board class modifies the board. The referee controls the game and the players only play. I guess I have really understood the OOP philosophy. This is *exciting*!
I have to agree that this should rarely be done. However, I have found instances when developing iOS applications that the dynamic instance variables have come in handy. 
Don't do this. This is the wrong answer. The correct answer, as posted above, is to use a hash. If you want it to be an instance variable, then that's fine - but it should still just be a hash. `instance_variable_set` should be treated as a more advanced tool, normally in the context of metaprogramming. I doubt you'll be needing to use it any time soon, and you should always think twice before reaching for it! 
If he was using Pry he could have just done `? Child.&lt;` and `$ Child.&lt;` and been done with it :) [3] pry(main)&gt; class Child [3] pry(main)* end =&gt; nil [4] pry(main)&gt; $ Child.&lt; From: object.c (C Method): Owner: Module Visibility: public Number of lines: 6 static VALUE rb_mod_lt(VALUE mod, VALUE arg) { if (mod == arg) return Qfalse; return rb_class_inherited_p(mod, arg); } [5] pry(main)&gt; ? Child.&lt; From: object.c (C Method): Owner: Module Visibility: public Signature: &lt;(arg1) Number of lines: 4 Returns true if mod is a subclass of other. Returns nil if there's no relationship between the two. (Think of the relationship in terms of the class definition: "class A&lt;B" implies "A&lt;B"). 
Well for now I have to assign 4 variables for each element in array which makes me to copy 4*50=200 lines of code. I felt like I can make a loop there..
I actually need to assign 4 variables for each element in an array, that's why I thought about the loop. While hash helps only with a pair...Do you know a way to assign as much as I need?
Can you speak with a code please? I tried to explain my question in a code, so please be kind:)
I scrape a web-site using queries(which are elements of an array). I get four outputs from a page and store those in four variables. That's how I end up with four variables for each element of an array.
A loop is the right idea, but you shouldn't use it to create new variables. I think what you're looking for is an array of arrays, or array of hashes. Like this: words = gets.chomp.split(" ") values = [] for each i in array values &lt;&lt; [valOne, valTwo, valThree, valFour] end Or, more idiomatically: words = gets.chomp.split values = words.map do |i| [valOne, valTwo, valThree, valFour] end Both of which will give you something that looks like this: [ [x, x, x, x], [x, x, x, x], [x, x, x, x] ] Where the four 'x' are the four variables that you would be assigning to, for each element in the original array. If you want the four variables to be 'named', use an array of hashes instead of an array of arrays.
All right, this is something interesting. I'll have to try that) (will let you know if it worked)
Nice! I'm liking the logic separation from the players and board. Like I suggested to op, you can try making a simple AI, and eventually start thinking about how to implement an unbeatable AI (hint, look up nodes) Happy coding! 
Nice. I was actually just looking for something to do this.
Check out this guide, if you are interested [how to install rails on ubuntu](https://www.atlantic.net/community/howto/installing-rails-in-ubuntu/) Do not use apt-get. Use rvm 
I played around with `proc` and got somewhere because a proc's return will return from the enclosing method: class Formatter INITIALISMS = %w(nyc pdx lv) def capitalize(s) # Define custom case handlers handle_initialisms = proc { |s| return s.upcase if INITIALISMS.include?(s) } # Run handlers for special cases handle_initialisms.call(s) # Fall back to standard #capitalize s.capitalize end end formatter = Formatter.new %w(nyc pdx nashville).each { |word| puts formatter.capitalize(word) } # =&gt; NYC PDX Nashville 
Yeah, all of the assertions provided would pass if the *upcase* method were used instead of *capitalize*. As far as I can tell, that's what OP is going for.
.? Pretty much none of the tests would pass. In minitest, expected result is on the _left_. Sorry. I realize it's confusing. I'm trying to properly titleize and therefore capitalize these strings. I receive them as all uppercase. I should really switch to rspec.
Ah, I think I see what you're trying to do. You're giving it a word that's fully uppercased and you want to return a word that's capitalized in the correct places. Well, now I know why you didn't use upcase. :-)
I get stuck ALOT when I write non-CRUD apps. I always end up abandoning projects because I stall for a long period. Moral takes a fat hit and I stop feeling productive. Any advice to muster through this phase? 
0x0dea, that's awesome, your explanation makes perfect sense too. Thank you for the feedback!
Which is usually what you'd want in this case, or else you'd get some odd errors that might not be so obvious when trying to debug.
Not disagreeing with you at all here. Just thought it makes more sense for the game to crash for a beginner, versus explaining why invalid inputs seem to (almost) always print the "low" statement and/or explain rescue clauses.
Your `capitalize` method is trying to do way too much... Make it at least one class, with more methods. Test each method in isolation, if it helps. THEN test the overall `translate`method (or whatever you call it - but don't just call it capitalize!) Also, it looks to me like you should be splitting your input string on spaces and slashes, and translating each word separately. 
Sure, I use Nokogiri here
This is a very common and well documented problem. Have you googled it?
Right. If there are use-cases for a subset of functions in a module, then they should be in their own module which should then be included by the parent module. 
Yeah but it's weird, in Ruby 2.0+ you can bind a module's methods to any object, [see here](https://gist.github.com/banister/34c7d9e7eb3e925a40e7). Whether you *should* do it on the other hand is a different matter, but it's now at least possible 
&gt; You linked directly to one example http://infraruby.com/examples/tic-tac-toe http://infraruby.com/examples/wiktionary http://infraruby.com/examples/benchmark http://infraruby.com/examples/framework Your examples are **all** ugly. They all break ruby style guidelines for multiple reasons. But hey, don't take my word for it -- run your code through any [static code analyser](https://github.com/bbatsov/rubocop) and see for yourself how the ruby community judges it. Or, let me put this another way: You keep saying "not all InfraRuby code is bad"... Well okay then, show me some good code!
I recently found my first legitimate (I thought) use of undef keyword in ruby for this basic idea in debt_ceiling, in my [Audit](https://github.com/bglusman/debt_ceiling/blob/master/lib/debt_ceiling/audit.rb) class... It's a little silly, but I had 3 or 4 classes all defining 2 methods, and one defining only one of those two methods... so I put both methods in a module, and undef'd the one unused method in Audit (:+). Could build a little tool to make this easier, undef things not on a whitelist or on a blacklist via `except: []` or `only: []` list of methods ala Rails, but it's not that common a practice so probably overkill unless you're doing it in a bunch of different places.
What about Metaprogramming Ruby?
Don't use windows for ruby. If you want to remain on windows for your daily OS just code inside of a virtualbox running ubuntu, linux mint, or something similar.
1. Yes 2. Linux or MacOS, I prefered Linux. 3. VirtualBox with Linux is enough for developing ruby on Windows. 4. Every person has its own favourite. I prefered Vim or Sublime. 5. http://railscasts.com/ is ok if you plan use Rails.
Windows will always be an issue. It's officially supported in a very limited sense. There will always be libraries that require C extensions that just aren't available/implemented on Windows. A good document to read would be from the Python doc site: https://docs.python.org/2/extending/windows.html And here is a nokogiri issue involved with adding Windows support: https://github.com/sparklemotion/nokogiri/issues/864 However, with that being said, there is really nothing stopping you if your use case for the language isn't inhibited by your operating system choice. I am doubtful that the release of Windows 10 will impact Ruby 2.X operability but it can happen so be ready for it. As far as tools, just use Sublime or RubyMine. Personally, I don't use Windows so I'm more accustomed to a Linux/Unix based toolchain (vim, tmux, etc). And, if all fails, use VirtualBox or dual boot into Linux. Learning the Linux operating system would make you a better technologist, in my opinion.
Hello, Honestly, don't if you have any other option. Good ones include setting up a dual boot (having two OS on a single machine). Can't speak for windows 10, but works like a charm with the previous versions (7 and 8). Second option is to setup a virtual machine on your windows box. A bit slower, a bit easier on the setup also. Now, if you have no other choices, I did setup a Rails environment on a Windows 8 machine two weeks ago, and it did work. Expect some problems around javascript runtime (install node), some gems (Postgres was a bit difficult), but nothing impossible with patience and a significant amount of googling. The main problem is that if you stumble on a system related problem, expect to be alone (ie, people on Reddit or StackOverflow will be on Mac on Linux). Regarding the "best" IDE, that's a trick question (ie, everyone has his preferences). Both Sublime Text (paying, free trial) and Atom (open source) work well on Windows. I've a preference for the former, but that's personal. Those are mostly "editors", but good one. As far as I know, RubyMine works on Windows and is considered a very good IDE for Ruby (never tried it personnaly).
Nice list but it's incomplete without [POODR](http://www.poodr.com/)!
Practical object oriented design in Ruby - Metz
Yes.
Even when using a mac I target my software for Linux in a virtual machine. Unless you're writing software that specifically is meant to run on OS X, there's no point to it. Assuming you're writing web applications, your deployment target will almost always be a linux system. It's exceedingly rare to find someone who actually uses OS X as a production server environment.
I do this. I've found that Xubuntu in VMware works so well in fullscreen mode that you forget it's a VM. I suggest avoiding Virtualbox, it's buggy and a lot slower.
Just ordered #3. If this is a marketing scheme, nice work! 
1. Not initially and not with pure ruby, but you will very likely run into problems. Aside from that, it's a point of technical debt. 2. I like VirtualBox. Have somebody create the base image with mostly everything installed. You can choose to use the VM as nothing more than a terminal to run code. You can use Windows for your editor, browser, etc. 3. If you are going to try and stick with pure windows, you need your editor and ruby installed. Instead of powershell, I would suggest using something like https://www.cygwin.com/ 4. For windows: Notepad++ is well used for a good reason. Sublime has gained quite a following. You can also just use gvim. 5. I am a fan of https://rubymonk.com/ for language familiarization.
Nice list. I've read about half of them and am currently jumping around the well grounded rubyist. As someone else mentioned POODR should definitely be on that last aswell.
I would suggest not avoiding VirtualBox, it's not really buggy and it's definitely not noticeably slow, though it might have more system overhead. Make sure you have unused resources to allocate to the virtual machine. I've been working out of VMWare Fusion/VirtualBox for several years now, and I actively maintain a handful of headless VBox instances for my LAN. (Router, DNSx2, File Server, Development Machine). I usually like to run Windows in VMWare and Linux in VBox, but either or usually will get the job done. It just comes down to guest tools and setup.
This is the best advice. Even when I'm using OSX or Linux as my main OS, I still spin up VMs with Vagrant to isolate my dev environments between projects and match production as closely as possible.
did you by chance install the guest additions for the VM? I too had similar issues with windows (I run linux on metal). After installing the software I no longer had issues.
Clojure is a dynamic language, but it runs on the JVM, so it's not as dynamic under the hood. You lose speed from the clojure runtime, but the JVM is still pretty fast. http://clojure.org/compilation
In about halfway through it and I'm very satisfied. I find it too be just detailed enough without getting too lost in the weeds
Would it be okay to have Vagrant installed on Windows, then code in Windows but save the files so Ubuntu could run them? 
Yes - that's exactly how it works (ideally, at least)
https://my.vmware.com/web/vmware/free#desktop_end_user_computing/vmware_player/7_0 This is a free version for personal use.
Okay, well that's exactly what I'll do in that case. Seems like best of both worlds to me. I get to stay in the OS I like but have the tools from the OS I need. Perfect. 
...and don't forget to enable 3D for ubuntu virtual machines. 
We started with MRI on windows, mostly without issue. You will probably need a devkit installed as well, for gems with native C-code extensions. We switched to JRuby because we have a large population of Java coders who wanted to contribute JAR's to interface into their products. The migration process was pretty painless, occasional jockeying with the gems in the Gemfile. We use bundler exclusively for dependency management. Only real thing that I miss is a genuine "fork" implementation - so a lot of the methods in the Process stdlib aren't available to me. This similiarly impacts tools like spork and guard - they work to a degree, but often need restarting because they lose the plot. I guess I should answer your questions directly too * not sure - I imagine MRI will build fine, might have to wait for all the kinks in the devkit o be ironed out. * We use Win7 Enterprise, a 64-bit OS. No issues to speak of. * nothing special - we use the tortoise SCM tools (hg, svn and git clients). We tend not touse powershell, but we have a few specialty jobs that do, nothing involving ruby. * I like sublime, most of the team use rubymine. I started with netbeans but it tended to implode too much * railscasts.com - nothing windows-specific afaik
I think that's the issue I have running Ubuntu in Hyper-V. There's no 3D options and the UI is incredibly lagging unfortunately. 
Sounds awesome. Will definitely do that. 
I've done this before and recommend it.
A lot of people are suggesting virtual environments. I would say it's worth it and not that hard to partition your hard drive and just set up Ubuntu for developing. For awhile I developed on ubuntu and handled business related matters (excel mostly) on Windows. I now have Mac which is worse for excel but better for developing.
Might want to reconsider that stance. VirtualBox is an excellent product. If you've never used Vagrant and VirtualBox for a build environment you really owe it to yourself to try. There is a reason it's the virtualization platform of choice right now.
Tldr; second module overrides the first because the interpreter works linearly. 
Why use this vs declaring namespace in Rakefile?
4 out of 10 sounds about right, give or take. The optional question on our registration page last year says 25%, but less than 1/6 answered that so it's most definitely skewed. Ghent is a lovely place, arguably as nice or better than Bruges (slightly less tourist-y). It's one of our biggest assets :-)
EDIT: Before I let you read what I really think, let me first state that anybody can write platform-specific Ruby code on another platform using Vagrant to create a virtual operating system, so for that reason things aren't catastrophically bad. I've come to this forum looking for Windows advice before, and nobody ever has anything nice to say. I was called a "troll" for implying that it shouldn't make a damn bit of difference if you use Mac or Windows. I came to Ruby specifically because it was said to be platform independent, after I had been screwed over by corporations that control platforms that my professional skillset has depended on. Ruby doesn't care what platform you use, but our culture does. For that reason, there are many Gems that don't work on Windows. On my current Ruby project, I've been using Windows for the last year, and I'm able to code everything that I think I can. Although, I just learned that you can't use Ruby to convert .less to .css on Windows, but you can on Mac, because of a requirement for the V8 library. From my perspective, I have been using Windows for 20 years, and I'm not going to make a hundred changes to my daily routine, from changing my start menu to an Apple menu, to changing every mechanism I use in the Control Panel, and have a completely different selection of apps, and buy more expensive hardware that's slightly slower, and downsize my monitor from a 30" to Apple's biggest 27" size..... TO PARSE A CSS FILE. So I invented my own CSS metalanguage in about 25 lines of code, and it's proprietary but it actually suits our needs much better anyway. That's how I solve problems, so I'm allowed to stray from the culture. But if you work for a company that already started using the "less" Gem, you're screwed. 
Good points. I use a Mac most of the time now but have used Windows extensively in the past and the hate towards it is way over the top. Especially now, it's a pretty good OS. The issues tend to be down to extensions that simply haven't been built for Windows but that isn't a problem with the OS itself.
It's easier to share and maintain the rake task. If you have, let's say, 10 projects that need your task and you have to fix a little bug, its easier to change the version on each gemfile and hit bundle instead of making the change in all projects. 
Haha, I found the opposite. Subjectively, I find Python docs easier to read, but that's probably because I have a much stronger understanding of Python already than I do Ruby. I reccomend you try both, I think they're both decent. Python clicked for me, Ruby didn't. Try one for a bit, try the other, you'll have a preference.
There's a *little* bit more to it than that, but it's still not very complicated... module Wolf def speak puts "Auuu!" super end end module Dog def speak puts "Woof!" super end end module Fox def mystery_speak puts "Ring-Ding-Ding-Ding-Ringerdingerding!" end end class Mutant include Fox include Dog include Wolf end Mutant.new.speak # =&gt; Auuu! Woof! NoMethodError: super: no superclass method `speak' for #&lt;Mutant:0x000000021b9cf0&gt; The ruby interpreter keeps looking up the object's ancestor chain, for the first class that responds to the given method.
That's a fantastic offer. If it's legit, I hope someone takes you up on it. 
Oh my I would definitely be very interested. I've been coding for about 1 year and my first app ever has about 600 users now (maybe 100 MAUs). I worked on it with my friend who is as (in)experienced as me. Since it was our first app, we had no idea what the hell we were doing and we're in the process of refactoring the code now. Would love to walk through it with an experienced pro!
That sounds pretty interesting :) Where abouts are you based? Send me an email over at ********** What stack did you use to create this app? Edit: Am mainly a lurker and didn't realise email replies posted here :p
Hey! I am brand spanking new to the world of coding, and would love some direction on how to get started. I live in the states so our timelines will be a bit off, but I'd be open to communicating via Skype, email, hangouts, whatever works!
Rails stack. Postgres. Deployed to heroku. Based in nyc. Will email shortly! Thanks#
Thanks, looks like I missed that during editing. It's alright now.
Thanks!
It's fixed now.
I am a guy who just want to become web developer in near future. Already finished some RoR courses like [Coursera](https://www.coursera.org/course/webapplications), did some Codecademy and one of RoR Udemy's courses. I am actually looking forward to improve my basic skills. I know about Hart'l tutorial and read few chapters of his book. About my programming experience. I've got some C++ lessons in University and i was always connected somehow with "making things" and "get shit done". I was able to do some programms in programing languages I didn't know. I think I am good with getting what i want from Google/Stackoverflow. I am just looking forward what to do next. I want to know what I need to learn more so I can think about getting internship or junior position job.
amadman114, I'm in awe of its proposal and altruism. Congratulations !
I recommend Metaprogramming Ruby (it's a book from the sidebar). After reading he question the first thing I thought about was the diagram from said book. The author goes into much more detail about how Ruby works and about other situations like this.
Still have more self study to do before I'll need mentorship badly, but I'd very much appreciate if you let me add you on skype or chat via email. If you don't mind I'll send an email to the address above just to connect with you.
You could have used a Linux virtual machine.
Yeah, Vagrant shares a folder with your host, so you can open it in your normal text editor.
&gt; Vagrant makes it easy to blow away environments you no longer need and build new ones with great provisioning systems It also makes it nice because you can put the config files in your repo and anyone who works on your project has the same environment.
Didn't think so many people would be interested! I've set up a Slack domain. Please PM me your email and I'll invite you to the domain
Didn't think so many people would be interested! I've set up a Slack domain. Please PM me your email and I'll invite you to the domain
If the offer still is available I am interested. I work as an IT/business manager at a small firm in Sweden and I´ve coded our own business system in RoR. I´ve had to learn everything from scratch and would appriciate some guiding in how to write better, more consistent and robust code. I guess testing is what I fear most.
Testing is the way forward! Send me your email and I'll invite you to our slack :)
 @events ||= Event.where("occurs_on BETWEEN ....... This one line of code pretty much sums up the whole 7 minute episode. Given that this is *by far* the most important point to take away, I would have spent more than a few seconds focusing on it.
If this were my website, I'd design it much more graphically... Just some ideas, in case you want to tinker with it (and learn some more ruby in the process!) * Add some top-level progress graphs, e.g. using [gruff](https://github.com/topfunky/gruff). * Present each day's progress in a big calender, with details displayed when you hover over each day, rather than a long chain of bullet points. * Each day's progress could then be stored as a simple bit of JSON. If you wanted, you could later re-design the website with ease, since the whole thing is just data-driven. For example: . { date: '2015-06-02', ruby: {hours: 1, details: ['Ruby loops', 'Multiplication exercise']}, rails: {hours: 2, details: ['Redesigned this website! :)'] } } (Note: I realise you might want to make the JSON more complicated than this, which is fine - it's just a very basic sketch!) Want to add a "weekly summary" section? Generate it with code! Want to add a "books referenced" summary? Again, it's all data-driven from the input JSON! Want to add an easy way to add a day's work, rather than manually typing out JSON? Write an input form! Adding such features to your website would be a great way to show your improved skills, and would help you easily re-design the whole thing in the future.
&gt; https://www.rubycasts.io/ruby-internship Aren't you that creepy guy who's always spamming the world about how awesome he is @ Ruby and calling everyone stupid?
I'm definitely interested, and I'm at the point where I need someone who knows what's the good thing to do. I recently published my first gem, asked for advice and got tons of feedback, I wish I could have more. I'm looking into Rails now, slowly building a project :) I'd be glad to join the Slack !
Those are all great ideas, I appreciate your input. I think you're right. Improving upon the blog would be a good project as I progress. I'll implement some of your ideas in the near future! I don't even know what JSON data is to be honest. I'll add that of things to study.
what's the app if you don't mind me asking? I'm a total newb Ruby/RoR person and am always interested at looking at successful apps/sites for an idea I'm working on.
I'd take ya up on it but feel bad wasting people's valuable time. I'd be cool to someday set up a google hangout of programming and people just writing code and shooting the bull. Shout out questions, learn new shit, etc...
Understand completely! Best wishes on your endeavor. I'll check out the new app you're building. Thanks.
Thanks! These are some good ideas that I'll think about. Sounds a little like [this exercism.io submission I wrote for the Bob problem](http://exercism.io/submissions/5300287d84cb4ea1903a3b65e6617a01). It's Python, but could easily be Ruby: from re import compile responses = [ {'matcher': lambda w: w.isupper(), 'response': 'Whoa, chill out!'}, {'matcher': compile('\?$').search, 'response': 'Sure.'}, {'matcher': compile('^$').search, 'response': 'Fine. Be that way!'}, {'matcher': compile('.').search, 'response': 'Whatever.'} ] def hey(what): for reply in responses: if reply['matcher'](what.strip()): return reply['response'] Some kind of a list of matcher+strategy objects. And for the capitalize/titleize problem, a notion of _atomic_ transformations on the whole token vs. higher level transformations (irish, compound) which split the token and create new recursive calls.
The simplest way to think about it is this: - Create an array of all the letters. - Rotate the array n times. - Transcribe the string based on the rotated array. If you take a look at the Ruby documentation for [Arrays](http://ruby-doc.org/core-2.2.0/Array.html) and [Strings](http://ruby-doc.org/core-2.2.0/String.html) you will find a couple of really helpful methods that will make the solution very simple. I've included hints on which methods to look for in my solution description.
It shouldn't make a damn bit of difference, that's delusional. Windows and Linux/Unix are entirely different OSes with different conventions. If I am developing for an app that I know will be deployed on a Linux server, I really don't see any benefit for making it work cross-platform; especially if I want to make use of the countless awesome Unix features. The operating system you use is a massive choice in your computing habits, so you have to recognize this decision has consequences in what you can, and cannot do.
Correct
Simplest is probably something like: class CaesarCipher def initialize(shift, alphabet = ('a'..'z').to_a.join + ('A'..'Z').to_a.join) @alphabet = alphabet @cipher = alphabet.chars.rotate(shift).join end def encrypt(text) text.tr(@alphabet, @cipher) end def decrypt(text) text.tr(@cipher, @alphabet) end end If you don't want to use `tr` then you can consider how you would implement `tr`. If starting from the above example class, consider the result of `@alphabet.chars.zip(@cipher.chars).to_h`. 
You're doing great. I encourage you to revisit this code as you learn new concepts and rewrite it to make it more elegant or efficient. A few examples of things I think could be improved: 1. Use an iterator like `each` to map across the array and print out all words being used over a certain number of times. 2. Use a filter method like `select` to find all words being used more than a certain number of times. 3. Use string interpolation rather than concatenation: `"You have " + item_count + " items."` is typically written as `"You have #{item_count} items."` 4. As you get more advanced in your knowledge of Ruby, use regular expressions to isolate parts of text you're interested in. Don't worry, all of this stuff will start to become clear as you learn more and more. But for someone with your level of experience in both Ruby and programming, this is fantastic progress.
Firstly, I'd like to thank you for taking the time to read over my code. Your first two suggestions really opened my eyes. The third suggestion made me smack my forehead lol. As for number four, I will have to look into regular expressions to gain a better idea of what you mean. I forced myself to get into the habit of commenting on my code heavily so that 1. I can go back and reference it to use again. 2. So others can give me good advice like you just did. Thanks again, I will keep all of this in mind, and I will revise this code as well. 
A couple of very simple improvements that I would make: Your code: text.delete! "." text.delete! "-" text.delete! "_" #this section takes care of removing any symbols that may text.delete! "," # be included in the text such as periods, exclamation points, text.delete! "!" # quotation marks, parentheses, etc using the delete method. text.delete! "?" text.delete! "(" text.delete! ")" text.delete! "/" text.delete! "'" text.delete! '"' words = text.split(" ") Better code: words = text.scan(/\w+/) Your code: if (f3*10) / (f2*5) &lt;= 20 &amp;&amp; safeWords.include?(f1) == false Better code: if f3 / f2 &lt;= 10 &amp;&amp; !safeWords.include?(f1) (Also, use better variable names than f1, f2 and f3!!) Also, to clear up a bit of confusion, you say in the comments: The "!" operator automatically reassigns the value to it's original variable This is not quite right. For example, `reverse` and `reverse!` are **different methods**. (In ruby, method names often end in a "!" or a "?".) These "Bang methods" simply mean: Warning - this method does *something 'dangerous'* - which usually means they change the original object, rather than creating a new one. [More info here](http://dablog.rubypal.com/2007/8/15/bang-methods-or-danger-will-rubyist). So for example, similarly, you could have done `f1.downcase!`, rather than `f1 = f1.downcase`. There are various other ways you could improve this, but I don't want to overwhelm you with comments - overall, it's a pretty good bit of code for a newbie!
If you are looking for feedback, here is some. - I would read your safewords from file. Something like `File.open('safewords').read.split("\n")` and you get your array from file where safewords are one per line. - You can replace those delete statements with one gsub like this `text.gsub!(/[\.\-_,!\?\(\)\/'"]/, '')`. This finds each of those characters and replaces it with nothing, effectively removing the character. - Why do you capitalize keys in your frequency hash? - If you are going to reverse the result of sort, you can use `.sort_by { |x, y| -y }` (notice the `-`) - You can assign items from array with one line like this `f1, f2 = frequencies[0]`. This will put `frequencies[0][0]` to `f1` and `frequencies[0][1]` to `f2`. - `f1 = f1.downcase` this would not be necessary if you would not capitalize ;) - The `if` at the end could use an `else` with some message like "All right!" or something, just so I know it did something. - You can use `!safeWords.include?(f1)` instead of `safeWords.include?(f1) == false`. Now for something more "higher level". As ruby is objective language first and foremost, you could put this into an class. Basic classes are really simple to write. Something like this: class WordOveruser attr_accessor :safewords attr_reader :text attr_reader :word_count def initialize(text) @text = text @safewords = [] end def frequencies words = text.chomp.downcase.gsub(/[\.\-_,!\?\(\)\/'"]/, '').split(' ') @word_count = words.count frequencies = Hash.new(0) words.each { |x| frequencies[x] += 1 } frequencies.sort_by { |x, y| -y } end def overused_word f1, f2 = frequencies[0] f3 = word_count if ((f3*10) / (f2*5) &lt;= 20) and !safewords.include?(f1) [f1, f2] else nil end end end Then you would use it like this overuser = WordOveruser.new(text) overuser.safewords = File.open('safewords').read.split("\n") result = overuser.overused_word if result puts "You used the word '" + result[0].to_s + "' " + result[1].to_s + " times. Consider using a thesaurus." else puts "All right" end --- If you were not looking for feedback, please ignore :)
&gt; You can replace those delete statements with one gsub like this text.gsub!(/[\.\-_,!\?\(\)\/'"]/, '') Ewww... No no no, that's ugly code! I still have several issues with your "fixed" version of the code!
:) I have a few issues with it too. I like your `.scan(/\w+/)` approach much better. 
&gt; I would read your safewords from file. Beautiful idea. Did not think of that. &gt; text.gsub!(/[\.\-_,!\?\(\)\/'"]/, '') Thank you for introducing me to gsub. &gt; Why do you capitalize keys in your frequency hash? I completely meant to remove that. &gt; If you are going to reverse the result of sort, you can use .sort_by { |x, y| -y } (notice the -) I remember reading that method. Does it make a difference which method you use? &gt;f1, f2 = frequencies[0] Stuff like this is why I love Ruby. There's an easier way to do EVERYTHING &gt; The if at the end could use an else with some message like "All right!" or something, just so I know it did something. That would have helped me a lot during debugging lol. 
&gt; Could you explain to me what this does exactly? The example in [the ruby documentation for String#scan](http://ruby-doc.org/core-2.2.2/String.html#method-i-scan) demonstrates pretty much exactly the same problem :) `/\w+/` is a [regular expression](http://ruby-doc.org/core-2.2.2/Regexp.html). `\w` means "word character" (a-z, A-Z, 0-9, "_"), and `+` means "one or more". So in other words, using `text.scan(/\w+/)` like I did above will simply ignore all other characters in the `text` - i.e. you don't need to bother deleting each punctuation symbol manually - and return an array of words. Clever, eh! &gt; feel free to overwhelm me with comments Okay, here's a couple more to keep you busy: 1\. Read a [ruby style guide](https://github.com/styleguide/ruby). There are several online, but they are mostly in agreement with one another. Your code is not *badly* styled, but a couple of points worth mentioning are: * Use `SCREAMING_SNAKE_CASE` for constants (e.g. `SAFE_WORDS`, not `safeWords`. This is ruby, not javascript!) * Prefer string interpolation instead of string concatenation (e.g. `"You used the word '#{f1}' #{f2} times. Consider using a thesaurus."`) 2\. Your coding style - like most beginners - is procedural, not object oriented. It would have been much easier to read (without the need for so many comments everywhere) if you'd broken this down into a class with helper methods. I could write my own version to show you what I mean, but it looks like half of the internet are already jumping on this thread to have a go :P
&gt; I remember reading that method. Does it make a difference which method you use? Well, you don't need to call `reverse` if you sort it backwards in the first place. So one less method call.
I am moving over to Melbourne later this year from London, currently learning web development (rails atm) with a view to a career transition from an AV project manager to full time developer when I get there. Would be great if we could have a chat about the scene in Melbourne? 
How could I forget ;-)
Just to add to tomthecool's answer, a great site for testing the regex and creating new ones is rubular: http://rubular.com/
Comments are totally fine for learning. In practice rubyist avoid comments because the code is suppose to be readable. One of my focuses when refactoring is to be able to hand my code to a novice or someone who does not specialize in Ruby and have them read my code and understand it. There are a lot of conventions we use that you will pick up over time. Good job.
As a Dutchie I felt a sense of pride when I opened up "country-avg-male-height.json". Anyway, I don't see myself using this right now but nice collection regardless.
props to you. I am often refactoring code to make it read like a book rather than some cryptic mess of poo
Ruby is one of the few languages specifically designed for us developers. We might as well propagate the madness! 
I'll echo what others have said - i think you're doing great for only having three months of learning experience... but when i saw that list of 'safe words' my first thought was that you must have a very exciting sex life 
This is probably a bit off for you, but I've recently fallen in love with the [seeing is believing](https://github.com/JoshCheek/seeing_is_believing) gem. Basically it will annotate a ruby file with the result of each line as comments. When you add integration with your editor of choice, you basically can re-evaluate at a keystroke. It's like an IRB session with friendlier editing.
You should really check out the gem [Treat](https://github.com/louismullie/treat) for natural language processing. It will save you from having to reinvent the wheel in some aspects. 
"Do You Read, Folks? Here are 10 Books You Should! #3 is instant get!"
Yes. Yes indeed.
Heh... didn't know that. Yeah that makes this much more simple :P
There isn't really a default way to store data in Ruby. The most convenient one, if you keep your data simple, is probably YAML, since it's easy as `require 'yaml'` and `IO.write(filename, object.to_yaml)` for pretty much any object. I would suggest CSV if you are planning to feed this data to other programs in other languages (it's easier to find - or make - a CSV parser than a YAML one), but if you aren't, just go with YAML.
I think this one is pretty simple. It generates a map of the original characters to the rotated ones. def caesar_cipher(string, shift = 1) alphabet = Array('a'..'z') encrypter = Hash[alphabet.zip(alphabet.rotate(shift))] string.chars.map { |c| encrypter.fetch(c, " ") } end p caesar_cipher("testing").join 
 $ irb irb(main):001:0&gt; Array(0..2).permutation(2).to_a =&gt; [[0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1]]
I really like the idea, to write missing language features in Ruby. Pattern matching is something I miss in Ruby, and I'm definitely going to try this library in my own projects. It can get a little messy through due to the -&gt; proc syntax.
&gt; Really hacky but it worked (on 2.2.2)! This comment compelled me to hunt down [this monstrosity](https://gist.github.com/andkerosine/3356675) to check whether whatever the hell it's doing still works.
That works for the example, but comprehensions make it easier to write nested loop things like: compr(-&gt;{ "#{fname} #{lname}" }, fname: %w( Alice Bob Eve ), lname: %w( Washington Lincoln )) #=&gt; ["Alice Washington", "Alice Lincoln", "Bob Washington", "Bob Lincoln", "Eve Washington", "Eve Lincoln"] or if you need mathy set stuff like: def grid_points_within_circle(radius, x_offset = 0, y_offset = 0) compr(-&gt; { [x,y] }, x: -radius..radius, y: -radius..radius) { (x - x_offset)**2 + (y - y_offset) &lt; radius**2 } end It doesn't make it possible, just easier in my opinion. 
Now _that_'s impressive.
That's succinct enough to be usable for the common cases. I like it.
 $ irb irb(main):001:0&gt; %w[Alice Bob Eve].product(%w[Washington Lincoln]).map { |fname, lname| "#{fname} #{lname}" } =&gt; ["Alice Washington", "Alice Lincoln", "Bob Washington", "Bob Lincoln", "Eve Washington", "Eve Lincoln"] $ irb irb(main):001:0&gt; def grid_points_within_circle(radius, x_offset = 0, y_offset = 0) irb(main):002:1&gt; points = Array -radius..radius irb(main):003:1&gt; points.product(points).select { |x, y| (x - x_offset)**2 + (y - y_offset) &lt; radius**2 } irb(main):004:1&gt; end =&gt; :grid_points_within_circle irb(main):005:0&gt; grid_points_within_circle(1, 2, 3) =&gt; [[0, -1], [1, -1], [1, 0], [1, 1]]
You can't use Ruby in Xcode, especially if you're looking to make a Mac app. The closest thing that you can get to is RubyMotion (http://www.rubymotion.com/), which lets you write iOS/OS X apps in a ruby-like syntax.
This wrapper gets pretty close: class Proc def for(params, &amp;predicate) compr(self, params, &amp;predicate) end end -&gt;{ [x,y] }.for(x: 0..2, y: 0..2) { x != y } vs [(x,y) for x in xrange(3) for y in xrange(3) if x != y] The problem is I have to put the `[x,y]` and `x != y` parts in Procs to prevent NameErrors.
Does YML support more then just Hash table formation? (nesting?) I need a Admin user to have username and password for example. The times before I used YAML was only things like:
I kind of refactored it even further, in a sort of Sandi Metz moment. I think I made it worse, but what the hell https://gist.github.com/revdan/5a5100d009210a2de9ef Comments welcome :)
Python would be interesting too. with PyObjC I can use Xcode? Is it hard to understand as a coding beginner?
If you're just starting but you absolutely must use cocoa, I'd give it a try. Disclaimer: I still love you rubyists :)
yeah, that's what i'm talking about with this forum. I don't know when these massive consequences are going to rein in on me. I'm about midway through my career, so they better hurry.
I'm the guy who runs Practicing Ruby, and although it may sound strange, I think we're probably very much in agreement here! I personally hate the fact that educational resources are commercialized, especially when they take the form of "read my blog to sign up for my newsletter to then get endless offers for products and services" Practicing Ruby is meant to be an answer to that, in that 100% of our materials are released under a free documentation license (CC BY-SA), and are made freely available with virtually no branding or nagging to the entire world via practicingruby.com, and in raw source form via https://github.com/elm-city-craftworks/practicing-ruby-manuscripts 100% of the materials are funded by reader support, which is necessary, because the articles take anywhere from 50-100 hours to produce on average, and there are around 100 of them. So the total work to build the archives we have is roughly equivalent to two years of full time writing work. What I'm asking for here, is for a small group of community members to contribute funds so that I can pay authors a small stipend for their work (I'm also giving them five full days of my own time for collaboration and editing), so that they feel treated with respect, and to remove the temptation to do the articles for the main goal of selling something else (it's actually disallowed by our publishing guidelines to self-promote beyond simply listing the projects you're involved in). With the small amount of funding we collect, we're able to produce materials that get read by tens of thousands of readers with NO COMMERCIAL INFLUENCE on the content whatsoever. If you take a look at one of our articles, you'll find they're literally in as close to a plain whitepaper format as you can get: https://practicingruby.com/articles/gentle-intro-to-actor-based-concurrency?u=dc2ab0f9bb -- There's no clutter in sidebars asking you to buy a book, to buy consulting services, to join a mailing list to get "one weird trick" in your inbox, etc. All of this is a result of the fact that we actually ask for money from time to time. It makes it possible to do professional work WITHOUT selling some other product or service, which means our content is totally reader focused, and not in any way "content marketing". You may still feel as if you'd never want to see this sort of thing on Reddit (or anywhere), and honestly I kind of wish that were the case too. But so far, this is the best way I've to sustainably produce works for the public good. EDIT: Fix broken link.
If your using the `bson_ext` gem you should be safe from this, the C extension replaces the vulnerable code. But still check your apps, I didn't check all combos of `bson` and `bson_ext` to completely verify.
I do interviews with people who are doing cool stuff in tech community and while I'm not really in a position to put much in the way of funding in I can offer an interview and expedited publishing. Since the timing is of the essence for your campaign, I could interview you as soon as tomorrow to publish within 24 hours of the interview to help promote your project. Quick feedback on the KS intro video. Lead in with the topic really quick and then get to the point of what the call for funds is for. I had to skip forward to see that it's not for you but to fund honorariums for further contributors. I'm mike[at]ugtastic.com and https://www.twitter.com/ugtastic :)
RubyCocoa is still around. As of Yosemite it's no longer bundled with the OS X SDK, but it should still work if you install it.
Have you reached out to the Ruby5 or RubyRogues folks?
Where's the attempt to submit a patch to fix the problem before disclosing?
https://github.com/thoughtbot/factory_girl
Good news! I added pipelining, arguments to workflows, and parameterized jobs. You can now do what you wanted :) I would love feedback on this from you or others using this! 
Interesting approach. When I read the title, I first thought this was going to be an automated solution that would create pull requests to keep you up-to-date with the latest minor Rails release, e.g. 4.2.1 to 4.2.2.
This is much clearer to me. I find comprehensions quite unreadable.
Actually I don't like VCR, I fixed dozens of broken specs because beginners misuse it, and cassettes keep recording over old ones and destroying fixtures. Pure webmock is way better because you have full control over how your fixtures look. I have yet to see VCR used properly. 
The combined [ternjs features](https://github.com/marijnh/tern_for_vim) are all available either built-in or as plugins in vim: &gt; omni-complete This feature is built-in: " enable ruby omnicomplete let g:rubycomplete_buffer_loading = 1 let g:rubycomplete_classes_in_global = 1 &gt; TernDef: Jump to the definition of the thing under the cursor. Use [starscope](https://github.com/eapache/starscope) combined with vim's built-in cscope support: `Ctrl-]`. See `:help cscope` &gt; TernDoc: Look up the documentation of something. Install [ri.vim](https://github.com/danchoi/ri.vim), then use vim's standard `K` documentation key when your cursor is on a class or method. &gt; TernType: Find the type of the thing under the cursor. Not sure what this achieves in a dynamic, duck-typing language.. &gt; TernRefs: Show all references to the variable or property under the cursor. Use the built-in cscope support: :cs find s &lt;method or class&gt; It's easier to use the recommended keybindings: `Ctrl-_ s` when cursor is on the word. See `:help cscope` &gt; TernRename: Rename the variable under the cursor. Use [EasyGrep](https://github.com/vim-scripts/EasyGrep): `&lt;Leader&gt;vr` 
We had a pretty much identical vulnerability in Rails last year. https://github.com/rails/rails/commit/27a0c137d00e774bf22050d4cfd952e9ab4362ac
FWIW, this wasn't speculation on my part. I've taught a *lot* of novice Ruby programmers, and I think I get the "please explain blocks, I just don't understand them!" question more than any other. That said, I agree with you that they are relatively simple to explain, which hopefully I've demonstrated in the article.
My favorite resource is [RubyWeekly](http://rubyweekly.com/) and to a lesser extent, [RubyFlow](http://rubyflow.com). Also, you may find [AwesomeRuby](http://awesome-ruby.com/) useful.
https://ruby5.codeschool.com I actually prefer the mailing list to the podcast.
Yes!
you can write a small script to read the csv file into a var using File.open then use the function used in this post (http://technicalpickles.com/posts/parsing-csv-with-ruby/) to easily input each field to the database assuming you have headers for each column. 
You can always examine new solution to see if it fits your demands in code style and overall quality and fork to make it better. Or at least to draw some ideas from those solutions. Making yourself a better programmer is crucial, but don't forget, that community has pretty many worthy developers that produce in parallel many gems that one cannot reach at the same time solely.
Definitely - there doesn't need to be a relationship between the source and the output columns. The output columns could be completely new, example: source EnumerableSource, [ { index: 1 }, { index: 2 }, { index: 3 } ] transform do |row| row[:new_field] = row.delete(:index) * 100 row end You'd get { new_field: 100 } etc as rows in the output. Let me know if this properly answers your question, or if you need an example on a specific use case you'd have! EDIT: the EnumerableSource example comes from [the Kiba test suite](https://github.com/thbar/kiba/blob/master/test/support/test_enumerable_source.rb)
Yeah I have seen Shoes before. But the screenshot at the starting page already didn't appeal to me. :(
If it's a Rails app then use the Rails models to create the data, so you can take advantage of validations, associations, etc.
Many hosters are flexible and will work with you to reduce the bill if you politely claim a bug in your system caused abnormal usage. If your previous 3 months were 1TB and then this month is 30TB, it's easy to prove this month was abnormal.
...like what? Anyway, it supports full object hierarchies. It can even handle cycles and references.
Huh? The only thing passed to the background job is a number and string (id and provider type).
Sequel + Factory Girl or Faker would be able to do this all in a few lines of code.
My first thought was that they should really have had something warning them when processes are having to be killed for being over the memory limit. That was covered by the blog post, but seems to be the "best" way to catch something like this to me.
Yep! Which is what I was counting on. The problem is that if you `kill -9` a DJ, it won't mark it as an attempt, or that it errored out, so it'll run it again as though it were attempt #1.
Curious whether you've evaluated Patreon? It seems well suited to your work.
Please be joking
Seriously.
&gt; run your code through [RuboCop] and see for yourself how the ruby community judges it. No, "RuboCop" != "the ruby community". RuboCop is just a tool to enforce some guidelines. And it is *configurable*! Here is the configuration for indentation with tabs: Style/Tab: Enabled: false Style/IndentationWidth: Width: 1 Here is the configuration for redundant `return` keywords: Style/RedundantReturn: Enabled: false And here is the configuration for Java integration syntax: Style/ColonMethodCall: Enabled: false Style/MethodName: Enabled: false After that, there are other trivialities like this: Prefer single-quoted strings when you don't need string interpolation or special symbols. Fortunately that guideline can also go unenforced: Style/StringLiterals: Enabled: false &gt; You keep saying "not all InfraRuby code is bad" I said not all InfraRuby code looks like the Android API. Your opinion of the Android API is not relevant to InfraRuby. 
We already collect subscriptions on Practicing Ruby's website, using Stripe directly. The current revenue supports about 1.5 days of paid work per week for me on Practicing Ruby, albeit at a pretty barebones level of compensation. To make it a full time job, I'd need to be able to double the rate I'm paying myself now, and fund four days a week. That would take quite a few more subscribers, but in the realm of 2-4x the current number of supporters, not 20x!
Haha, whops, yeah it's completely a joke. Sarcasm on the internet is a tough one.
Yep, joke. :)
It's nifty and keystroke-saving, but I would recommend against using this for anything serious. Square brackets almost always mean we're dealing with a `Hash`, `Array`, or some other kind of `Enumerable`. Using `String#[]` breaks that convention, leading to confusing code. Additionally, many devs just don't know about it. The author of this article didn't even know about it before today.
You probably know this (by now), but you should only very sparingly use `kill -9`. There's hundreds of things that can go wrong when sending SIGKILL. 
Wow. That's really great to hear that it's moving in the right direction. I haven't heard from you but my offer to produce an conduct an interview and post it with haste still stands. I've got a couple hundred interviews on UGtastic (transitioning to WHOIS Tech Community) and am about to publish my interview with Anita Sengupta from GOTO Chicago 2015 (interviews pending with Chad Fowler, Corey Haines, Trisha Gee, and 15 others). They're free interviews with people doing cool stuff in the community, Practicing Ruby is pretty cool...
I'm definitely going to take you up on this offer. Right now, one of my essays is sitting on the front page of HN, and the Kickstarter was mentioned in Ruby Weekly today, so we're getting a healthy flow of traffic and new pledges coming in. Maybe some time next week would work best, because that'll be a way for me to try to keep the momentum going. If you haven't seen the HN thread yet, there is a lot of "behind the scenes" information about Practicing Ruby that I've left in the comments there, and the essay itself is worth reading to understand my perspective on things. https://news.ycombinator.com/item?id=9661284
Sure thing! The monitor side will differ per host I think, so that's a tough one to give a clear cut solution for. The server side could be tasked with broadcasting when things go wrong more often though, which would help in situations like this. If a process is killed, announce it in the company chat, or send out an email for example. # ActiveRecord This is a Rails app, but with some custom class (some people call them "plain old ruby objects" ) which might be making it seem more difficult than it really is. Here's a quick disection: class VideoFile &lt; ActiveRecord::Base after_create :queue_cache_video, if: :should_cache_video? end This part is pretty general Ruby on Rails. There's a "video_files" table in our database, where we store each and every video on the site, so there's a row in that table for each video we have. The `after_create` part is a Rails specific thing that effectively says: "After you create a new VideoFile object and save it to the database, check to see if the `should_cache_video?` returns `true`. If it does, then run the `queue_cache_video` method." Explaining this made me realize the `should_cache_video?` method wasn't in the shown code, so I just updated the blog post to remove that to make it a bit clearer. Thanks for the heads up there. # Delayed Job def queue_cache_video ['s3', 'rackspace'].each do |cache_provider| Delayed::Job.enqueue UploadVideo.new(id, cache_provider) end end This code, which will run after a new video is created, will loop over 2 constants (in our actual site, these are defined in a config file). Next it will use [Delayed Job](https://github.com/collectiveidea/delayed_job) to create 2 new jobs. Now, this part is a bit tricky. If you've never used Delayed Jobs, or secondary processes, it's a bit of a big topic on it's own. Think of it like this: If a user was visiting the site, and it caused the creation of a video file, should we ask that user to wait until we've uploaded the file to S3 and to rackspace before rendering the page? Probably not. Instead we return something to the user real fast, then a separate process, that's where the download takes place. All this code will do is add a new row to a table in our database named "delayed_jobs". By itself, nothing else will happen. The key is that you need to have that process running. Usually you'll probably be starting your rails server using `rails server` and keeping that up in a console that creates a rails process that will look for web requests on a port, and return html. What we also need to do is run `bin/delayed_job start`, which will start another process that's not a web server. Similar to `rails console`, it'll have access to your database, but doesn't actually serve anything. This process will check that `delayed_jobs` table every few seconds for new jobs, and when it finds one it'll run it. # Running the Delayed Job What Delayed Job will do is look at this class: class UploadVideo &lt; Struct.new(:video_file_id, :provider) def perform VideoFile.find(video_file_id).save_as(provider) end end And effectively do a `UploadVideo.new(1, 's3').perform`. All of that happens behinds the scenes in the separate Delayed Job process. This just looks up the `VideoFile` using regular old ActiveRecord, then calls the custom `save_as` method passing in the 's3' parameter. def save_as(provider) p = Provider.find_by(account: provider) video.video_files.find_or_initialize_by({..}).tap do |video_file| p.service.save_as(self, video_file) end end This method is a bit masked, because some parts aren't shown, which is probably where some of the confusion lies. We have a separate `Provider` which is looked up by "s3". This provider has a class method we created named `service` which will initialize a new `Provider::FogProvider` class. This `service` method could initialize different classes depending on where we're saving our files to. Next, we call `save_as` on the `Provider::FogProvider` object, passing in the `VideoFile` instance, pass in the original video_file (which in our case has a provider of Viddler) and the newly initialized video_file (which has a provider of s3). That's a plain old ruby object that uses the [Fog](https://github.com/fog/fog) gem to do its heavy lifting. That class uses another gem, [Typhoeus](https://github.com/typhoeus/typhoeus) to do it's file transfers. # Tl;dr This code uses Ruby on Rails, plain old Ruby objects, [Delayed Job](https://github.com/collectiveidea/delayed_job), [Fog](https://github.com/fog/fog) and [Typhoeus](https://github.com/typhoeus/typhoeus). Some of the code that holds things together is omitted with the intention of making it more simple, but that's up for debate. :) Hope it helps!
You should probably close that temp file while you are at it.
[PStore](http://ruby-doc.org/stdlib-1.9.2/libdoc/pstore/rdoc/PStore.html) is another option. You could also use what's already mentioned: YAML, JSON, [MessagePack](http://msgpack.org), Marshal, etc. Ultimately it depends upon your requirements.
I'm surprised Pluralsight doesn't host all of your content, seems like it would be one less thing to worry about then.
So it's the root of the issue here that it stored the file in memory instead of streaming it into a temporary file? Did you find a solution to do that to keep the jobs lightweight?
I'd add three more recommendations to the article: - Don't rely on tracking failures. Your script can and will be killed forcefully one day. Track attempts and successes, and make sure to raise alerts when things don't go as planned. Failures are numerous and surprising, success is predefined. - When dealing with simple data streams, keep what you need for the minimum required time. Your input size should not be your memory requirement, your algorithm should decide on that. Input size may wary unpredictably, your algorithm is yours. - Code defensively, paranoidly even. Not because people are malicious hackers, but because they are rightfully ignorant of your tool's limitations. They will break it by simply using it in their best interest. Regardless of their competence.
It tends to make perfect sense to me. Strings might not implement the Enumerable module but they are iterable (each_char). Regardless, I don't think that matters too much. To me, the [] operator is a matching operator. When you think about it, that's precisely what it does. In an array, say you called arr[0], you are matching the first item in an array. In a hash, you are using the [] to invoke a deterministic hash function to obtain an object ID to retrieve that value. You are matching some input to get some output. You know what's great at matching as well? regex!
Quick answer: you can do that today in Kiba, by writing a denormalizing source (which will, for each source row, iterate over one field splitted value, then yield one row for each value). Another possibility is to use a transform for that, which is not doable yet but will soon be implemented ([see issue](https://github.com/thbar/kiba/issues/4)). My next post will answer your question in full-depth, so you may want to subscribe to the [newsletter](http://thibautbarrere.com). 
Takeaway Bullet Number Four then becomes * Identify, question, and validate as thoroughly as practical all assumptions made about tool-provided safety nets. The amount of ingenuity expended creating tools is exceeded only by the amount required to see all the holes in the safety nets you build for your customers. And thanks for the wonderful write-up. We should all be thinking &gt; There but for the grace of `$DEITY` go I, and my business.
Thanks for the clues! :) I tried to think about it without looking at other people's answers, and if I follow ur 3 points, I understood it as: - Create an array of all the letters: alphabet = Array('a'..'z') - Rotate the array n times (here I rotate it once over to the right): shifted_alphabet = arr.map { |a| a+1 } - Transcribe the string based on the rotated array. string.chars.map {|a| shifted_alphabet.fetch(a, " ") } so all together it would look like this : def cipher(string) alphabet = Array('a'..'z') shifted_alphabet = alphabet.map { |a| a+1 } string.chars.map {|a| shifted_alphabet.fetch(a, " ") } end p cipher("ifmmp") but it returns an error "no implicit conversion of Fixnum into String (TypeError)" :/ what's missing in my thought process ? or is it a syntax thing? 
Dickey's Fifth Law: &gt; Nobody ever went broke underestimating the foresight of the maintenance development team. ...and the Sixth: &gt; Even fewer have gone broke by underestimating their ability to see what their customers would do to and with their code. H. L. Mencken was an optimistic, trusting soul.
I'm surprised this isn't getting more upvotes, especially the third point. I'm surprised there was no monitoring service like monit that keeps a close eye on resources. My bitcoin node has monit and I used cpulimit to make sure bitcoind doesn't eat all my cpu (it also does a nice job of throttling the bandwidth as a side effect).
My company does. I haven't had any major issues with it... Why?
I like this solution a lot! It's short and sweet :) I have a bit of a dumb n00b question though ...U.U : I often get a bit confused by how abstract things are, and the |c| (or whatever other letter people put in there) always throws me off. I understand that it's a variable, but what is it actually doing? Also I was wondering why you needed to both rotate + shift the encryptor because if I understand correctly, rotate creates a new array by rotating the original array, which is what we want for the cipher, but shift just drops the first element and makes the array shorter. So why is shift needed at all actually?
Other people's answers gave it away, but if you haven't looked at them yet you should spend a little more time looking at the core methods for arrays and strings in the documentation. Keywords to look for are **rotate** and **tr**anscribe. In general it is a good idea to become comfortable with as many of the core methods as you can. They will make your programming life much easier. As far as your current code, there's a problem with the creation of your shifted_alphabet. In the block the variable 'a' represents a string and you are attempting to add the number 1 to it. This is where your TypeError is coming from. 
Hey, I made something like that not long time ago. It's very simple and propably not very well designed - but It's my first time and it works: https://github.com/ZyzioZiom/promoplatform-padrino/blob/master/models/activity.rb method is import_csv It supports first row as headers and creates hash with headers and values for each line of CSV file. 
Thanks for the link @schneems, I'll look into it further!
Yep! Monit is what killed the DJ when it got too big, then started a new one. Unfortunately it wasn't alerting of that it was doing this.
hehe good catch. It's actually in an `ensure` block within the `save_as` method, but I cut it out of the code in the post. Trying to make this code slim while still providing enough context has proven more difficult than expected.
Yeah, it was as simple as changing this: request.on_complete do |response| tempfile.write response.body end To this: request.on_body do |chunk| tempfile.write chunk end The first will load the entire file into memory when you run `response.body`, but the 2nd will only increase the memory by the chunk, then the memory will go down, then go up when the next chunk is loaded. Basically, never read the entire file into memory at once.
I'd like to add an offset to the seconds field. For instance, if the original timestamp is `[00:02:00]`, I'd like to be able to input `09:30:07` to output `[09:32:07]`.
 h, m, s = 9, 30, 7 $_.gsub!(/(\d\d):(\d\d):(\d\d)/) do t = (h + $1.to_i) * 3600 + (m + $2.to_i) * 60 + s + $3.to_i '%02d:%02d:%02d' % [t / 3600, *(t % 3600).divmod(60)] end
It's not ruby, it's activesupport, a 3rd party gem.
Perfect! Thank you so much!
Seems like a cool survey. You have my data now. I'm interested in seeing the results!
Thanks! Looking forward to sharing them! Not looking forward to tabulating all of the qualitative data though ha..
If you're interested in writing Ruby code for the client-side (aka the browser) or even Node.js, you should check out [Opalist](http://www.opalist.co).
How many entries do you have so far? How many are you anticipating? Who / What are you doing the study for?
+1 For sequel. Awesome library, and Jeremy is an awesome maintainer.
I think the examples would be clearer if they used implicit return where possible. This use of this unconventional style in conjunction with the introduction of a void return type makes one wonder if an InfraRuby void method requires the return statement to avoid a type error. I realize that it does not only because of your comment, and because I went to the Try page to experiment before taking the time to write this comment. Same with parenthesis on empty argument lists: one wonders if the typechecker makes them necessary somehow. I realize that they are not necessary only because I took time to experiment. IMHO, updating the examples to use indentation of 2 spaces with soft tabs will make them more effective. Unusual indentation is much more noticeable than other kinds of unusual style.
Of course, but we don't want to lose any of the details through automation. Those who have been sharing stories of their depression deserve to have their comments read and understood :) 
Oh nice! Good on you guys! One of those stories will be mine (past or mostly past).
Wow, yeah we didn't even considering sleeping patterns or trouble. Great point
I wrote the blog post. Just wanted to mention that this doesn't completely reproduce tenderlove's demos, as he tweeted out: https://twitter.com/tenderlove/status/607080102355017729 This code doesn't allow you to repeatedly pipe the output back into `dilute.rb`, which is how he did the demo. One way to do that would be to actually print the output, but make it invisible using the terminal color sequence `"\e[7m"`, but this isn't concealing the character on my terminal (iTerm2). Anybody know why it doesn't work? Or is there a better approach to this?
You completely missed my point so either I did a bad job at explaining things or you just don't understand. Adding "convenient methods" makes people use them all over the place where quite often specific concern can be isolated and solved in just one place in a consistent fashion. Why do you use `pluck`? Because something is not in a form that specific components of your application require. So, what do you do? You use pluck, and maybe map too, and maybe something else as well. How far can you go with this? Sometimes far enough, sometimes not far at all and you start mixing all kinds of approaches to get stuff transformed/mapped/coerced/whatever. What's the result? Complexity. To put it in different words - you MISS encapsulation, you don't THINK about encapsulation, because you have those convenient methods available, but they are limited, they will not solve all your problems. Also using arguments like yours leads to discussions about "when it is OK to monkey-patch" or "is this a good monkey-patch or a bad monkey-patch". There are just a very few legitimate cases where monkey-patching is OK. It is way too easy to abuse this that's why I'm so against it.
I don't think I understand because the end result hasn't been complexity for me. Unless you have a good example, we're not going to get very far arguing about it because any tool you use can be misused. &gt; It is way too easy to abuse this that's why I'm so against it. Shunning a tool just because it has sharp edges is a poor way to look at it in my opinion. It's like trying to chop vegetables with a hammer because the knife is sharp and might cut you. You have to understand your tools including their limitations.
&gt; Monkey-patching is not a sharp tool. It's a big hammer that smashes your fingers... It can be both. In examples such as yours, where your class method clashed with ActiveSupport's `Object#try`, I agree that ActiveSupport can (occasionally) screw up your code through monkey patches. (Although in this case, since `try` is such a well-known ActiveSupport method, you should really have foreseen any potential issues!) However, ActiveSupport 's monkey patches can also be incredibly useful when writing elegant Rails code. For example, `Object#present?`, `Object#in?`, `String#pluralize`, `String#underscore`, `String#constantize`, `Numeric#megabytes`, `Array#in_groups_of`, `Hash#with_indifferent_access`, ..... are all extremely useful, when used sensibly. Adding such expressive features to ruby projects is simply not possible without monkey patching.
I think the critic is falling "flat" because Rails was founded on the ideals of using meta-programming to create a web-framework. Monkey-patching is still a part of meta-programming. In other languages they have to resort to type annotations and reflection to get some of that stuff done. But I think that meta-programming can be a difficult issue because it can make reusing your code in a different context more difficult. Rails has taught Ruby many new idioms. Exactly because they could change Ruby to try new ideas more generally. Also the core Ruby developers showed great fortitude by following along when possible. I think being able to change, modify, core language features is an important part of scripting languages. Languages that restrict features so that they provide more safety can also restrict creativity. When one restricts creativity, one is more likely to fall into a proprietary trap when your libraries end up stuck in a dead-end somewhere. :-)
Thanks to this approach we don't have a good(*) standalone inflection library or a unit conversion library etc. I don't even know what to say about HWIA as for me it's just a great example of the mess that Rails brings with it. Can you actually imagine that I forgot AS defines `Object#try`? Is it an acceptable thing to **not** be aware of the fact that some library does something that may affect my code? I think it is. It should be. It shouldn't be a standard that something can screw up my code. What you see as "elegant" I see as problematic. `Object#try` doesn't solve anything btw. It's just a poor-mans-monkey-patch that is used rather than introducing a proper NullObject pattern in your code base. Just like `Enumerable#pluck` doesn't solve anything. \* or it exists but nobody uses it because it's not popular and it's not How We Do Things
How am I supposed to know when somebody required AS? Am I supposed to run my library tests against all-the-things-that-come-with-monkey-patches? Try to imagine the total effect of this when you consider thousands of people trying to build their libraries. Ruby is not Rails. Ruby is Ruby. I made a list of monkey-patches (not a complete one!) that messed up my code in the post, those things caused bugs that were discovered later when somebody started using my code in an app that has AS. Here's a good one: `ActiveSupport::Concern` redefining `included` and changing its semantics. Man, seriously, this is messed up. It caused bugs in Virtus which relies on `included` a lot and it really had no idea that suddenly `included` can accept a block IF ACTIVE SUPPORT WAS USED. Not to mention people expected me to change my code so that it can work with ActiveSupport. My only concern should be to make my libraries work with Ruby. I should not care about ActiveSupport. This is not a healthy ecosystem. This is the damage I'm talking about. People who just use Rails and/or don't spend a lot of time working on Ruby libraries probably don't get it. It's fine but at least try to understand because it's important.
im not sure how to resolve this 
Not true. Strings in Ruby can be defined in a number of ways. Single-quote, double-quote, heredocs, and `%[]` and its variants come immediately to mind, and all can be used as part of an if-statement for better or for worse. Looks like an issue with the Ruby Sublime Text plugin.
[no it isn't](https://stackoverflow.com/questions/1836467/is-there-a-performance-gain-in-using-single-quotes-vs-double-quotes-in-ruby)
Try to benchmark it, the performance difference is negligible. However, I prefer single-quotes when no interpolation is needed.
This looks a lot like a Python error. Let me do some tests... http://hastebin.com/tacalirabu.txt There it is - you're somehow making Sublime run Python instead of Ruby for this file. Make sure your build system is set properly (Tools -&gt; Build System)
does anyone know how I can run programs taking input from users in sublime? Do i have to use Respl? also im trying to use the .chomp method but it doesn't seem to know where that is at? what all am I missing in order to test and learn ruby in sublime?
Looks like DejaVu Sans Mono to me, only the 0 is dotted in that and the screenshot shows a diagonal bar. That's the closest I could find! edit: It is Menlo See here for a visual comparison of the two: http://41.media.tumblr.com/wiTflIDkmoqr6fyl6m2nhK2Oo1_500.png
yeah that's the theme. so it's the default font, looks like retine -&gt; meslo/monaco. ty
Completely delete the line and retype it?
I really dislike Python's error reporting. "invalid syntax" never helps resolving the issue. Even the raw token stuff PHP prints at least gives you something to search for.
Review: The book contains no explaination of any of the patterns other than a single rather uninformative line for each. eg: &gt; Iterator helps you to iterate through a complex object using an interator(sic) method. The code examples are not examples of good code and are probably best used as a starting point for refactoring practice. I do like the consistency of the examples, using a generic D&amp;D type game as the basis for the code examples. But if you're looking for a resource with good explainations of design patterns check out: https://sourcemaking.com/design_patterns or the book "Design Patterns in Ruby" http://designpatternsinruby.com/ if you particularly need Ruby examples. Edit: Fixed typo &amp; added something I liked about the book.
&gt; How am I supposed to know when somebody required AS? Am I supposed to run my library tests against all-the-things-that-come-with-monkey-patches? Try to imagine the total effect of this when you consider thousands of people trying to build their libraries. To be fair that's partly Ruby's fault - you can't expect every library author to play by the rules. Ruby has the most insane module system I've ever used. Everything you `require` can modify the global namespace and `require`s aren't even local to the current file `a.rb`, but changes to the namespace can also be experienced by every other file requiring `a.rb`.
For example, Refinements were spurred by Rails' interest in monkey-patching. Also other methods that were at first monkey-patched ended up being incorporated into Ruby proper. But I don't recall the names. Rails is an old project nowadays, and some of these changes took place several years ago. Some of those changes were just "fixing" core Ruby methods that may have later incorporated the changes. But last I recall anything about this it was around 5 years ago. Long time.
I appreciate the core argument. Let me address some things. AS is on lockdown. This is the first patch i've seen that's been accepted in a REALLY long time. Why was it accepted? Rails and Rack have has interfaces to a large number of things, would it be better if they were wrapped up in objects? Yes and no. Some objects like Rack::Request make sense as they've got certain actions associated with them, the class not only holds data it holds logic. Hashes hold no logic, they hold data, they're really good at it in fact. They're quite fast and very flexible. Do you want Rails to spend a bunch of time on each request coercing data into a different data structure you might never use? It's all a tradeoff. I agree proper encapsulation, separation of concerns, etc. is generally good. I don't agree with your conclusions or sensationalist title. It pains me when people in Ruby go to great lengths to tear down Rails. It's a very integral part of Ruby and won't be going anywhere. I wouldn't mind so much if maybe you were more active and vocal in evangelizing your views of Ruby in directly with Rails. That patch came in as a public PR, easy to comment on. It's easy to criticize someone else's project, it's harder yet more helpful to get involved with that project. Two of the biggest draws to Ruby for me are the insane flexibility of the language and how nice and cooperative the community were compared to other languages. Let's not lose both of those in one stroke of a pen. 
IIRC, pluck and map aren't equivalent. On active record query scopes, using pluck will return an array of just the column value without instantiating an intermediate array of expensive active record objects. Monkey patching is unfortunate, but that's what you get when you rely on message passing and object orientation. 
If there were no benefits, Ruby wouldn't success in the world of programming, where Python already existed. For example, molecular biology is a lot about parsing custom CSV/TSV/etc. data -- Ruby suits text parsing much better, than Python text parsing stdlib, that needs two times more code, magic, and isn't even PCRE.
&gt; If there were no benefits, Ruby wouldn't success in the world of programming. "no benefits" was meant to be in comparison with the language the scientists are already familiar with. It wasn't meant as an absolute statement. Thanks for pointing out the weaknesses of Python you came across. 
I spend roughly 10-12 hours daily working with ruby. Typically 4-6 hours are spent on OSS. Why would you think I'd have any more energy to get involved in a project where people fundamentally disagree with what I value a lot? What do you expect me to do? Refactor rails to not depend on AS? When its creator thinks it's the best part of Rails? It is a battle I am not going to fight because it's lost already. Even if I had the time and energy to help with a web framework it wouldn't be rails anyway because it's too big and there's too much legacy to deal with. Regarding the title - it is what I think, it is how I feel. Call it however you like, I'm not looking for any sensantions. Ruby is 100% of my professional life and a huge part of my personal life. I deeply care about its future and evolution and making me feel bad that I don't participate in rails development is not fair. 
&gt; How am I supposed to know when somebody required AS? Am I supposed to run my library tests against all-the-things-that-come-with-monkey-patches? It's not just Rails though, core Ruby ships with similar types of things and has for a long time: https://twitter.com/tomdale/status/457282269342744576 The only way to guarantee things won't blow up in your face at runtime is to switch to a statically typed language. Otherwise, yeah, with dynamically typed languages you are forced to anticipate every execution path possible and write tests to trace them. Which as you've discovered you can't do, because you can't anticipate everything your users will have loaded and what that code will do. So basically you need a compiler that does static type checking and makes some of these assurances for you.
[**@tomdale**](https://twitter.com/tomdale/) &gt; [2014-04-18 22:19 UTC](https://twitter.com/tomdale/status/457282269342744576) &gt; Ruby: where requiring a module that ships with the stdlib changes how integer division works everywhere. [[Attached pic]](http://pbs.twimg.com/media/BliXzRrCQAAWeIs.jpg) [[Imgur rehost]](http://i.imgur.com/FvCnDzh.jpg) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
if you're just going to reassign it with a gets, then it doesn't matter what it's initially set to. you could use anything. since it's later getting set to a string, I'd probably set it to empty string, '', but variables in ruby don't need their types declared in advance. you could use 0, 3.0, anything you wanted.
Yeah I think the underscores look very readable and I tried null earlier and say that it wasn't working. Thanks for letting me know what nil is that's very helpful of you.
Sorry but she was right. Python is huge in scientific programming for many reasons. Excellent libraries(scipy, pandas), precompiled dependencies (wheels), ipython (notebooks), managed environments for non-devs (conda, etc). I've worked with Ruby and R devs that switched to Python for computer vision and statistical modeling.
This used to be the case but the past few years people have started to just use double quotes for everything. Less to change if you decide to do string interpolation. There's no performance hit for using double so you might as well.
I don't think I understand either, because it appears to me that the author doesn't identify any specific problems, and doesn't offer any specific solutions either. All I see is vague OO dogma. As you mentioned, where is the example code to demonstrate all these opinions? I doubt we'll ever see it, because I have an inkling it would get ripped apart in the comments. I'm critical of the design of Rails too, but I can't find any takeaways in this.
See https://github.com/rubygems/rubygems/pull/1188
&gt; You didn't even bother commenting on the PR and mention that you disagree with it, you went straight to ranting on a blog. On that whole thread, there's one :-1:, you could still add your voice, it wouldn't have gone un-noticed Of course I didn't even though it did cross my mind. In fact that was my first thought "OK I'm gonna comment on that". I'm gonna be honest - I didn't comment on the PR because I knew it makes no sense. It's not about that PR. This was just a trigger for me. Commenting on it wouldn't change anything. Nobody would revert the commit and even if it was reverted it's still just one little monkey-patch. The mindset and opinions would remain the same. &gt; I'm frustrated by this trend of bashing on Rails or &lt;library&gt; with no attempt to mitigate the problems that are being bashed You can't mitigate monkey-patching. Which is also a point I'm trying to make. My solution to this problem is to stop doing that. That's why it would be irrational to jump into any discussions within the rails core because AS is *the foundation* of Rails. As I said this battle is already lost. &gt; Criticizing a framework I spend time trying to make better without participating in seems equally not fair, that's why I wrote the comment. It's how I feel. People attack my work, the work of others who spend 10-12+ hours a day trying to make the (Ruby) world a better place to get torn down with casual observations. Not a hint of trying to participate. It's deeply frustrating, though I'm more frustrated by the trend then by this particular post. We're doing the best we can with what we have. All the time that goes into Rails could be spent on building a better ecosystem. This is what I believe in now. I'm doing my part here that's why I allow myself to criticize things in public. I am against monkey-patching, I am against ActiveSupport and the general mindset behind Rails. I've learned my lessons and I don't want to repeat the same mistakes again. Please let me know how I could participate in a way that would be helpful for Rails and I will do that. Just keep in mind that my opinions are pretty much the opposite of what Rails is doing :) &gt; Again this sentiment is more about the overall trend then your specific post. Many newbies to Ruby will think that the only actionable way to make Rails better, is to make blog posts that make it to the front page of Reddit screaming "STAHP!!!!!" While it feels good (..) FWIW I don't feel good at all. I didn't write it to feel good. I wrote it mostly because I often *mention* that I don't like monkey-patches and never properly explain why. So I wrote it down as a blog post, slightly angry blog post because I'm annoyed that this even needs any discussion. &gt; What I wish I could get across is that we want you to help (at least I do). That's great to know, it means a lot to me really. For example I had a couple of chats with Sean Griffin about ActiveRecord and what could be done to improve it in a way that other libraries could benefit too. More specifically what to do with ARel, how to approach sql generation etc. This is what I'm interested in as you probably know. I also expressed great interest in helping with ActiveModel improvements for Rails 5. How to restructure helpers so that they make less assumptions about certain objects. I'm sure I could provide a lot of feedback regarding many different APIs of Rails. Question is - how would that fit within the rails mindset :) Is Rails ready to become one of the many ruby gems and play nice with others? Would the core team be happy to reuse external libraries as a new foundation of various Rails components? This is the kind of stuff I'm talking about. &gt; I don't want Rails to kill Ruby I also want Ruby to succeed in the longer term and continue to evolve. Rails needs to become a good citizen in this ecosystem first. It's not the case right now. &gt;&gt; I deeply care about [Ruby's] future and evolution &gt; Me too, maybe we can work together to make it a good one? I'm sure we can.
why isn't there someone out there that has set this up to work like this in sublime like when i hit run it opens in terminal? sounds like such a pain in the ass to open the terminal every time i've made a change and want to run a program i have to do that..
Strongly recommend a good, simple text editor. Vim is a common choice.
Thanks for the input, is anything lost by using a text editor? Edit: is vim only for Unix? I'm running Windows. 
Just a heads up - you typo'd "brakeman" with "bracketman" :)
I asked for an example in one of the above threads and he complexity ignores it even going as far to say that using `.map` and friends just ends with complexity. He doesn't elaborate on it and just rants on and on. Personally I think that `Enumerable` is the correct place for it. We'd get a lot further with the discussion if the author offered solutions to the problems instead of just complaining that there are problems.
Thanks guys, I have downloaded sublime and am fiddling with it now. Is there any resource out there that explains how one uses a text editor together with ruby? Like how ruby interacts with sublime and how compilation and output from the program works.
The only reason I mentioned Flask and Django was to preempt any remarks about python's web frameworks. You went the other way.
I started with RubyMine and find it invaluable but it could get a little overwhelming at first.
I asked a few very experienced ruby devs this exact thing. The answer was, I've never felt the need to implement a linked list in Ruby. Matz included a lot of methods in the Array class that have similar functionality as those commonly associated with linked lists. Otherwise, feel free to create your own using struct or a class. This is a good journey into functional programming with building a linked_list in Ruby: http://zvkemp.github.io/blog/2014/12/15/introduction-to-functional-programming-in-ruby-linked-lists/ Excellent read!
Thanks, fixed
You're right - I should have clarified: Arrays can be used as objects that functionally *behave like* linked lists. (`Array#pop`, etc.) But, they are *not* implemented as linked lists under the hood - so you won't get the performance benefits etc. since each element of the array doesn't know its next/previous element in the list.
Thanks! It's pretty simple how the gem works, at a basic level, but painfully complicated to get right for *all possible syntax* :P
I love this program, great way to show how a mathematical edge always wins out. I ran it with a 100,000 starting balance, wagering $1 at a time. It takes a while but eventually the balance goes to 0. 
- I wrote transproc - a gem which does data mapping and follows principles that I believe are better than monkey-patching Enumerable - I explained how it works in a separate blog post a couple of weeks ago - I linked to that post - I built a pretty advanced data mapping library called ROM with pluggable mapping backends where transproc is used as a decoupled engine which is such a nice proof how isolated libraries can easily be reused I "just rant on and on"? I "just complain"? I didn't put much emphasis on my personal work in the blog post because promoting my work wasn't the reason why I wrote it. I wanted to explain my point of view on monkey patching and explain it on a higher level. I understand it could be too abstract for some people. I will come up with concrete examples when I have the time to do so. 
What I do is (OS X) press cmd+shift+p to open a Sublime input dialog. Then I type "install" to search for the "install packages" command. This opens another dialog and I type "ruby" to search for related packages. These sorts of tools are useful: - Linters - Syntax highlighters - Style checkers You might also check into a tool called Rubocop. It provides a lot of important validation against best practice Ruby.
&gt; Understand what your dependencies are dependent of (within reason)? Here's a snippet that might help you in the future with that: `cat Gemfile.lock | grep active support.` It is not a good idea for library code to look at what else an app includes. Libraries should be self-contained. &gt; No, Rails is realistically the only one that's a given. The idea that Rails is this special snowflake library is supported by a large portion of the community. This is exactly what /u/solnic is trying to address. Just because so many people *do* treat Rails different from other libraries/frameworks doesn't mean they *should*. &gt; Without ActiveSupport Rails wouldn't be Rails and the "elegance" would be lost. This is not a bad thing. Rails' "elegance" is just shortsighted hacks on top of other shortsighted hacks. &gt; &gt; This is not a healthy ecosystem. &gt; Seems pretty thriving to me. Have you ever had to maintain Rails apps written by someone who did everything "the Rails way"? Over the past 10 years, I've made a lot of money cleaning up after these people. &gt; The opposite is also true. Most people wouldn't want to use Infector.new(string).pluralize (or whatever interface you have in mind) over string.pluralize. That's because most Rails developers don't understand the tradeoff between the two. They optimize for the amount of typing it takes to make something work without regard for its future maintainability. Rails leads people to believe everything should be doable while hitting as few keys as possible. Just because people don't want do use something doesn't mean it isn't a better long-term choice. I'm also not saying that monkeypatching is universally horrible. It can be a great way to get a feature shipped quickly so that people can start using it, but since library and framework code has a *lot* of dependents, I would advise against using it as a long-term solution — and never as something your users depend on. I see it as nothing more than a stopgap and it should be replaced with code that solves the problem in a better way. Apps live under a different set of rules because you (or the organization you're working for) own everything that depends on the app code. You're free to change it whenever you need to, so you can monkeypatch at will and accept the responsibility that comes with it because you can remove both the monkeypatch and the code that relies on it in a single commit and you're back to code that doesn't modify the runtime.
&gt; Where is the right place to add a 'pluck' method that operates on instances of Enumerable if Enumerable is the wrong place? You're assuming that there *is* a right place for it. `Enumerable#pluck`, as written in the PR, makes assumptions about the contents of the `Enumerable`. It applies only to Enumerables which contain only objects responding to the `[]` message and take a single argument. One `nil` or other non-Hash argument and you've got a `NoMethodError`. There is no reason that all Enumerables should support this. A Hash includes `Enumerable`, but can't use this for anything useful. Since `Hash#each` iterates over an array of 2-element arrays, all you can use `Enumerable#pluck` for is to reimplement `keys` and `values`: 2.2.1 :014 &gt; {a: 1, b: 2}.pluck(0) =&gt; [:a, :b] 2.2.1 :015 &gt; {a: 1, b: 2}.pluck(1) =&gt; [1, 2] This isn't any different from the `sum` method, which I'll admit is pretty convenient when you're dealing with an Enumerable containing only numbers, but goes against the way the rest of `Enumerable` is implemented. 
How does that compare to Sinatra? http://www.sinatrarb.com/ 
on my 5th try, I got 100 spins AKA I didn't win once. On my 6th try, this happened: irb(main):430:0* puts "Number of spins #{spin_times}" Number of spins 14377819 =&gt; nil irb(main):431:0&gt; puts "Number of wins #{wins}" Number of wins 388587 =&gt; nil irb(main):432:0&gt; puts "Number of losses #{losses}" Number of losses 13989232 =&gt; nil 
https://github.com/pivotal/pivotal_ide_prefs Pivotal Labs are a bunch of badasses. I had the pleasure of working with them on a recent contract. Ho-lee-shit they know their stuff. Exclusively they use rubymine, and taught me a ton about it. The link is to their IDE preferences file, which is now my defacto setup. I used to use sublime mainly, and still do for certain tasks, but professional developing is enhanced by a full IDE. I have a coworker who loves his VIM plugins, but there just isn't anything like the full debugging power of rubymine. There are things that try to give you all the tools, but it's just not the same... 
&gt; Matz included a lot of methods in the Array class that have similar functionality as those commonly associated with linked lists. The need for a linked list isn't defined by the operations it has available, of course you can implement the same operations in a linked list, array or any other linear connected data structure. The need for a linked list is defined by the performance characteristics of the operations
rben is a typo... should say rbenv
Here's my list. See the :quality section. https://github.com/sixarm/sixarm_ruby_gemfile group :test, :quality do gem 'brakeman' # Detects security vulnerabilities in Rails apps via static analysis. gem 'bullet' # Detects database N+1 queries, unused eager loading, and counter cache needs. gem 'cane' # Code quality threshold checking as part of your build. gem 'churn' # Detects code that changes often for us to review, refactor, retest. gem 'coveralls', require: false # Web service to track code coverage over time. gem 'debt_ceiling' # Scores a technical debt metric and manages debt reduction. gem 'flay' # Analyzes code for structural similarities to find areas for refactoring. gem 'flog' # Scores an ABC complexity metric: Assignments, Branches, Calls. gem 'heckle' # Perturbs our tests to ensure they are working correctly. gem 'laser' # LASER: Lexically- and Semantically-Enriched Ruby bug detector. #gem 'metrical' # Executes MetricFu separate from your project's dependencies. [requires newer metric_fu] gem 'metric_fu' # Meta-analytics that runs churn, reek, roodi, etc. and graphs results. gem 'reek' # Detects code smells like coupling, clumping, large areas, short names. gem 'roodi' # Ruby Object Oriented Design Inferometer: parses code to warn on design issues. #gem 'rails_best_practices' # parse codes in vendor, spec, test and features directories. [Retired; less-maintained] gem 'rubocop' # Ruby static code analyzer, based on the community Ruby style guide. gem 'rubycritic' # Reporter that wraps gems such as Reek, Flay and Flog. gem 'sandi_meter' # Static analysis tool for checking Ruby code for Sandi Metz' rules. gem 'simplecov', require: false # Code coverage analyzer for Ruby 1.9+ gem 'simplecov-html', require: false # HTML output formatter for SimpleCov. #gem 'simplecov-rcov-text', require: false # Text output formatter for SimpleCov. [Outdated] gem 'sourcify' # Workarounds before ruby-core has Proc#to_source &amp; friends. end 
I agree. My point was that it's a missing data structure in Ruby while some other languages have this built in. I hypothesize that the reason many Ruby dev's don't bother implementing linked lists is because they can gain a large degree of the benefit by either using array methods or possibly extending the array class. And yes, if you are working with a lot of data and need something more performant, building a linked list structure from a class or struct is entirely reasonable. But ruby's array's get a special form of optimization with array's of over 16 items that's going to work pretty well for most people. If you or anyone you know has seen the need to use a linked list data structure in Ruby, in a real world project, I'd be interested in know more about it. So far I've only seen it examined as an academic exercize within Ruby. 
Yes. Your answer definitely helped me a lot. Do RubyMine respect our .vimrc settings though? If it does then nothing can be more awesome. It's like having the best of both the worlds.
Never knew about strascope and ri.vim they sound good. This is great. Can you share the link of your .vimrc file ? I think I can learn a lot from it. Currently I'm trying take inspirations from https://github.com/joedicastro/dotfiles/tree/master/vim and it's simply unbelievable. Thanks for your help. 
site.port could be a string - either add .to_i or put the 80 in quotes.
you don't need to compile ruby.
I think it's quite obvious i *was* talking about the supported operations, and not the performance. Arrays are not linked lists. I know. But (as i said from the beginning) for *simple use cases* - where I optimum performance is not an issue - you can use arrays in place of an actual linked list. 
&gt; or possibly extending the array class Without getting too off topic here... No experienced ruby dev would ever do this. You should `include enumerable` in your class, NOT inherit from `Array`. (but yes, apart from that, you're right!) &gt; If you or anyone you know has seen the need to use a linked list data structure in Ruby, in a real world project, I'd be interested in know more about it. See my post. I've used linked lists a few times. 
Nice list! Good to see, that someone else made the same decisions. 
In Liquid it's both. {{ if site.port == 4000 }} INTEGER {{ endif }} {{ if site.port == '4000' }} STRING {{ endif }} will output both INTEGER and STRING.
Since Jekyll compiles to static files, this code only runs when it first gets compiled. My guess is that it does not set the port variable correctly when compiling so you don't get the disqus block there. Does it hurt to have Disqus in development? I would just leave out the logic and let Disqus try to work on localhost even though you won't see actual comments.
I'm only sure that on my development machine it's NOT running on port 80, since I use the default that `jekyll serve` provides and that happens to be 4000. However, since it's running on Github, I cannot be sure of anything, you are right. I coded this assuming that on the Github server, `site.port` will return 80 since the webserver is accessed using that port by default. Do you know of any other way to deduce whether the blog is running on local/production environment? I know I can set some value in `_config.yml` but it's too much of a bother to change every time.
Honestly, that is a great question. I do not believe it will respect .vimrc because this is a Vim emulator, not actually Vim. From the blog post (http://blog.jetbrains.com/ruby/2009/08/rubymine-for-vim-addicts/): This plugin provides nearly complete vi/vim/gvim emulation while editing files in RubyMine. The following functionality is supported: * Motion keys * Deletion/Changing * Insert mode commands * Marks * Registers * VIM undo/redo * Visual mode commands * Some Ex commands * Some :set options * Full VIM regular expressions for search and search/replace * Macros * Diagraphs * Command line history * Search history * Jumplists * VIM help So unfortunately I am going to have to guess that this is not going to be full fledged Vim support, simply a way to support vim within the RM environment. That means that it will depend on your usecase as to whether or not that is a real solution. 
You could have a env: production in your `_config.yml` and then create a `_dev_config.yml` with env: development Then you can start Jekyll with $ jekyll serve -w --config _config.yml,_dev_config.yml The `_dev_config.yml` will then override items from the `_config.yml`-file. 
You're right about `pluck` in ActivveRecord. It's much faster because it doesn't instantiate objects. But you miss the problem behind it. It only exists because people seem to be afraid of going deeper into AR. They want to have an immediate call for everything. Consider an example: you need first 10 user names sorted alphabetically. Rails Way: User.order(:name).limit(10).pluck(:name) Now, this looks nice but it also is confusing. It doesn't return a "primitive" value (e.g. like `count` returns a Numerical). It returns an array of values and those values can be of an arbitrary complexity (guess what will be returned for a serialized column?). But note that those values are not a `Relation` or a model instances that are returned by many other AR methods. Also there's a functionality duplication. The same thing can be achieved with what AR already provides. And it's [documented](http://api.rubyonrails.org/classes/ActiveRecord/Result.html). For example: ActiveRecord::Base.connection.exec_query('SELECT name FROM users ORDER name LIMIT 10').rows.flatten You can put in the query generated by `pluck` and you will get exactly the same result. And I'm pretty sure that this one faster, too, because it doesn't go through Arel as you already have the query. So here you go, a little convenience method for people who do not care to learn their tools properly or even to read the docs. Now, back to `Enumerable#pluck`. It _is_ a special case of `map`. And it only exists because AR wants `Relation` instances behave as arrays. But instead of doing that it makes arrays (and incidentally all other `Enumerable` implementations) to behave like `Relation`. --- People may laugh on recruiters calling Rails a programming language but to a certain degree it is. Coding Rails at times is so different to coding Ruby that one may start wondering if it starts being its own flavour of Ruby. If you take stdlib as a part of language then messing with it is definitely a way of forking a language. 
I've found it easier to use jekyll.environment to see if you are running in production or in development. See http://david.elbe.me/jekyll/2015/06/08/jekyll-different-settings-production-github-and-development.html for usage example.
A text based editor is sufficient. Lots of people like one with syntax highlighting though, and other 'advanced' features. SublimeText is popular (and starts to approach an IDE if you get into all it's features). Some people like the old-school vim (which also has many sophisticated features); I think it's got a pretty big learning curve though and am not a fan. The main thing though is I agree Windows is going to cause you problems. OSX or Linux/Unix, setting up a VM on Windows is a popular solution when you've got Windows. But it's possible you can do simple stuff on Windows without problems. You can start on Windows if you want -- but the first time you run into something where you're having trouble because it's Windows, know this will be the first of many, and at that point I'd switch to something other than Windows rather than sink time into fighting with ruby on Windows. 
&gt; Like how ruby interacts with sublime and how compilation and output from the program works. At the most basic level, it does not. And you don't really need it to. You edit your code in the text editor; you run your code from the command line. There are fancy ways to get SublimeText (or vim, or TextMate) to actually run your ruby code and display output inside the editor. Been programming ruby nearly 10 years, I've never used these ways. But some people like them. Also, ruby doesn't compile, there is no compilation, it is interpreted. (For the pedants, perhaps it compiles to bytecode internally depending on the ruby platform you are using, but from the developers perspective, there is no compilation step). 
Really great guess though. I like what you did!!! &lt;3&lt;3 I should probably write a blog post about it, but I like reading people's guesses. Also maybe it's a good puzzle for people to try out. If I blogged how I did it, maybe people wouldn't try for themselves (and that would make me sad).
As long as the module has been required, you should be able to do: X.read(email) any where you want. No need to wrap it in another method. I did this in irb: 2.1.3 :006 &gt; module X 2.1.3 :007?&gt; def self.hello 2.1.3 :008?&gt; puts "hello" 2.1.3 :009?&gt; end 2.1.3 :010?&gt; end =&gt; :hello 2.1.3 :011 &gt; X.hello hello 
I'm a Python developer, but I've often heard Sinatra equated to Flask, which I personally love for microservices. Hopefully my hearsay is slightly helpful :)
Sinatra for your API, Sidekiq for processing the data manipulation. I wish I got to do fun shit like this again. 
You can use `extend self` in X and convert the class methods to instance methods: module X extend self def read ... end end class A include X end X.read A.new.read
[Sinatra](http://www.sinatrarb.com/) or [Padrino](http://www.padrinorb.com/).
Thread safe code's a given, but I'm not aware of there being a JRuby requirement on Sidekiq? Performance is supposed to be better, buts it's certainly churning through the queues happily on my MRI containers. I actually moved away from Resque as the memory performance was shockingly poor in comparison to what I'm getting from Sidekiq, and that means I can run more threads so queue processing speeds overall increased too. I've not really kept up with Resque since then, has it made much progress in the last year or so? 
I think with `scan` and `match` you should explicitly state that you want to match multi line string, since `UTF-8` is immediately followed by `\n`.
&gt;This is different because tap will always return the hash, while your suggestion still modifies the hash in the same way, but you cannot chain on it. It's just semantics... and given the experience of the author, he probably wrote it while thinking about something else :). Actually, I think I see what he was actually getting at after a bit of thought, messing around in Pry and a little sleep. The presentation sidetracked me into thinking it was just meant to fix an existing database when it's really leading up to fixing JSON stringifying loaded hash keys. Definitely makes more sense to compose some lambdas together to create a data transformation function in that case. Modifying base objects is completely unnecessary for that problem. The Transproc stuff is pretty cool, really builds on what I read about in The Ruby Programming Language when it showed examples of using a functional programming DSL to combine lambdas in various ways for different types of problems. If the author fixes up the presentation a bit then it ought to be some very interesting stuff, might even teach a few people that approach so they don't feel compelled to just modify core objects all the time. I do think library writers *should* come to some sort of standard practices agreement, since it can only make their products more reliable and interoperable. Duck punching works great if your own project is the only one affected by it and everyone working on the code is cool with it. Easy to see it getting out of hand when everyone's doing it at the top and middle for every little piece of extra functionality.
Great book on this under development at Pragmatic Publishers: https://pragprog.com/book/msgpkids/learn-game-programming-with-ruby Covers exactly this.. made a nice little space shooter within one evening...
Thanks. Maybe I will look into flask as well. 
There is also grape,it might be better than sinatra if the Api becomes more complex.
No space after the `#!`. It's just #!/usr/bin/env ruby
Awesome reply, thanks &lt;3 I appreciate your efforts and your thoughtfulness here. I want to comment on a few things, but overall, thank you! &gt; Would the core team be happy to reuse external libraries as a new foundation of various Rails components? Historically there's a huge problem in doing this. Theres a few issues that come up. One of the biggest fears is that the maintainer will disappear and Rails Core will have to maintain &lt;library&gt;. Beyond this there's some cases like sprockets where, well...sprockets. It's still being maintained but Rails ends up being essentially dragged along as new features are introduced and old features are deprecated and dropped. This libraries' surface area was HUGE, and the resulting integration wasn't great (IMHO). For this negative example, there's a positive example: loofah. https://github.com/flavorjones/loofah got picked up as __the__ rails html sanitizer. I think this was a good choice. The goals and scope are well defined and there's been a history of support there. Even if the maintainers disappeared, it hopefully wouldn't be too bad to fork and maintain. So, maybe? The best case for replacing internal tools with external libraries is if we can decrease core team workload in a stable, sane, way. The libraries would need to be a drop-in replacement for &lt;feature x&gt; otherwise there would be upgrade woes. &gt; nobody would revert the commit and even if it was reverted it's still just one little monkey-patch. The mindset and opinions would remain the same. I see this like voting. Even if you vote for a candidate that didn't win, there's still a record that they got one more vote than if you didn't. Sometimes it's much easier to curb opinions than others in OSS. If you have a compelling reason or use case, we (at least I) want to hear about it. For example if a PR would cause an error or problem with another popular library then I would certainly want to know before we merged it in. We're not intentionally malicious, sometimes we have to pick between the worst of two evils, but more info always makes this easier. &gt; I'm sure I could provide a lot of feedback regarding many different APIs of Rails. I agree. I also think that some of what we need is trials and experiments. People have asked for better route helpers, but I've not seen a good API example that makes me say "That's the one!". It gets even harder when you have to consider backwards compatibility and performance. One of the hardest parts (yet strangely satisfying for me) is working with (or around) the hard limits already in place in Rails. In the past I've weasled my way into parts of the project i've been interested in by adding better exceptions http://www.schneems.com/post/31460949407/raise-hell-better-programming-through-error-messages/ and recently performance patches. Even with "contributor" push access, I don't get free reign. I have to fight for all of my ideas and PRs just like anyone else. In the process i've been able to get experience with how the org works and see when and where I can pick battles. It's not an easy or short process, but for me it's paid off. It's hard to start off with wide sweeping changes which is probably what you're interested in. If you're mostly interested in Active Model, there's a few open issues and a TON of open PRs https://github.com/rails/rails/pulls?q=is%3Aopen+is%3Apr+label%3Aactivemodel either fixing issues, or simply commenting your opinions on any API changes could be helpful. Anywhoo, thanks again. 
you should post to /r/tinycode
i need it to open in the OS terminal rather than build in the sublime window. it won't take user input as nicely in the built in one which is why im currently navigating to the directory and using ruby filename.rb i just thought perhaps they would have a way to automate that as it seems pretty easy.
so do i save that as a .sh or something?
I could be wrong... But if @rules will always have the things you need for total, you could just do something like.... def total sum = @rules.keys.sum do |key| (@rules[key] * @counts[key]) end sum - discount end or even this might work def total sum = @rules.sum do |key, item_count| (item_count * @counts[key]) end sum - discount end
Honest question, what would this be used for? It makes perfect sense, I just don't know where this would apply.(beginner here)
Another vote here for Sinatra, providing you really don't need much in the way of middleware. I went through a fairly long phase where I was using primarily Sinatra modular apps, but by the time I'd added back things like Warden for authentication and a few other middleware pieces, it was almost easier to go with a thin version of Rails. But if you're just doing basic Slack integration with something else and it's in a trusted environment that doesn't need much modding, Sinatra all the way. 
Will test this when I get back home.
It works both ways, with or without space.
I'm pretty sure that you have a SQL injection vulnerability [here](https://github.com/otamm/Glasses/blob/master/lib/glasses.rb#L60-L63). Passing user input (`key`) into `where()` unsanitized is going to land you in trouble in a hurry. Also, `LIKE %...%` is going to result in a full table scan, which is bad news for anything beyond a trivial amount of data. Is there a reason you wouldn't just use Elasticsearch? Edit: You also have injection vulnerabilities [here](https://github.com/otamm/Glasses/blob/master/lib/glasses.rb#L211-L213) and [here](https://github.com/otamm/Glasses/blob/master/lib/glasses.rb#L232) and [here](https://github.com/otamm/Glasses/blob/master/lib/glasses.rb#L254-L256) and [here](https://github.com/otamm/Glasses/blob/master/lib/glasses.rb#L278-L280).
a free book explaining all basics math for game (an for more) http://natureofcode.com/book/
This won't work, though, if I need to apply the method to a specific class each time I instantiate, right?
This is a configuration for vim so it is a line in the file: `~/.vimrc` which is where you put all of your vim configuration. Once you've edited your vimrc, you restart vim and then when you type "\r" vim will map that to ":!%p&lt;Enter&gt;" which is the following vim command: : &lt;-- puts vim into command mode ! &lt;-- tells vim to execute the following command %p &lt;-- outputs the full path of the current file &lt;Enter&gt; &lt;-- hits the enter key vim is cool but you probably don't want to learn a new editor (especially vim which is a bitch to learn) just to execute the current file you're working on. But, I do think it's worthwhile to use vim as an editor because, in order to do stuff like this, you need to compose Unix primitive commands. So, using vim is a gateway to really learning Unix. I'm writing a script right now to translate our codebase from RequireJS to ES6 Modules. The heart of the migration is 6 sed commands that transform the syntax from RequireJS --&gt; ES6. The only reason I had a clue on how to get working with sed is because vim uses the same commands so I'd basically learned it over the years just by using vim.
minimizing dependency on Rails actually makes me a lot less nervous checking it out. i've _always_ liked Cells approach, but was nervous that dependency on Rails and hooking it in in just the right way made it fragile across Rails upgrades. I see several other architectural improvements too. Congrats to Cells to sticking with it, and learning from actual implementation practice to keep improving the architecture. It's looking pretty sweet. I'm hoping it's finally at a point to start catching on -- letting us start writing better encapsulated code in our web apps, with or without Rails -- and maybe, just maybe, even a gradual way out of Rails. 
Refactoring is changing the organization of the code without changing its behavior - so once you've written a bunch of code, the idea is to spend some time restructuring it to be more clear
Well, just in case... Ruby 2.1.5 in Pry require 'benchmark' n = 1_000_000_000 Benchmark.bm do |x| x.report { for i in 1..n do; a = 'string'; a = nil; end } x.report { for i in 1..n do; a = "string"; a = nil; end } x.report { for i in 1..n do; a = 'string'; a = nil; end } x.report { for i in 1..n do; a = "string"; a = nil; end } end user system total real 127.905000 0.015000 127.920000 (128.090326) 127.765000 0.032000 127.797000 (128.075326) 128.108000 0.015000 128.123000 (128.443346) 127.796000 0.016000 127.812000 (127.995319) Benchmark.bm do |x| x.report { n.times {a = 'string'; a = nil} } x.report { n.times {a = "string"; a = nil} } x.report { n.times {a = 'string'; a = nil} } x.report { n.times {a = "string"; a = nil} } end user system total real 117.313000 0.016000 117.329000 (117.560724) 117.531000 0.031000 117.562000 (117.873742) 117.281000 0.015000 117.296000 (117.406716) 117.329000 0.078000 117.407000 (117.546723) Benchmark.bm do |x| x.report { 1.upto(n) {a = 'string'; a = nil} } x.report { 1.upto(n) {a = "string"; a = nil} } x.report { 1.upto(n) {a = 'string'; a = nil} } x.report { 1.upto(n) {a = "string"; a = nil} } end user system total real 116.315000 0.078000 116.393000 (116.814681) 116.548000 0.063000 116.611000 (116.789680) 116.439000 0.015000 116.454000 (116.570668) 116.642000 0.016000 116.658000 (116.932688) string = "string" Benchmark.bm do |x| x.report { 1.upto(n) {a = 'string'; a = nil} } x.report { 1.upto(n) {a = "#{string}"; a = nil} } x.report { 1.upto(n) {a = 'string'; a = nil} } x.report { 1.upto(n) {a = "#{string}"; a = nil} } end user system total real 116.486000 0.078000 116.564000 (116.760678) 128.374000 0.062000 128.436000 (128.764365) 116.829000 0.047000 116.876000 (117.080697) 129.012000 0.031000 129.043000 (129.309396) Seems like the difference is pretty much negligible unless you're using string interpolation. Unsurprising that it only affects the time when you're using those features. What did surprise me is that double quotes are faster than single in for loops.
The kata prompt asks that the rules be passed in because "the pricing changes frequently". I take that to mean the best thing to do would be: def initialize(rules) @rules = rules.dup @counts = Hash.new(0) end To allow new instances to adhere to any new rules whilst not keeping a reference to an external object that can affect its output.
It may be helpful to realize there are really only a few things that begin a block, which gets ended with end: * `class Something` (class defintion) * `def something` (method definition) * `if something` (or unless) * `something do` (note the **do**; calling something with a block) That's pretty much it, end goes with one of those. There might be 2 or three infrequent other cases. If you haven't spent much time with ruby, you might want to spend a day or two with a reference or tutorial learning the language, before diving into some code that may or may not be written clearly. C# is so readable to you because you're used to it, ruby will get easier when you get used to it. Also, is the code not indented properly? Also, yes, there's probably a way to make SublimeText do that, google for recommended ruby plugins, you definitely at least want syntax highlighting. 
Thanks a lot! That worked like a charm.
Use a proper process supervision framework, such as djb's daemontools or derivatives (runit, s6, etc), and implement resource monitoring for your application with statsd/graphite, metrics, etc). I wrote more about [process supervision awhile ago](http://jtimberman.housepub.org/blog/2012/12/29/process-supervision-solved-problem/). I also gave a talk about making applications [more operable](https://speakerdeck.com/jtimberman/you-should-be-on-call-too-mwrc) at MWRC in 2013 that may be helpful (video is on ConFreaks, but much faster to browse through the slides). Cheers
enumerable methods run on an empty collection return nil. a quick and easy fix is to add `|| 0` at the end of the line. (google ruby logical operators if this is confusing)
well, if the prices change during checkout, is it harmful that the current customer is affected?
&gt; Is there a reason you wouldn't just use Elasticsearch? Or [ransack](https://github.com/activerecord-hackery/ransackransack). I think this gem should be treated as a good learning exercise/experimentation, but for any serious production application there are already plenty of better tools for the job.
I can't believe I nailed the explanation on my first try. Thank you!
Try [BracketHighlighter](https://github.com/facelessuser/BracketHighlighter) for Sublime. I use it all the time and it helps a lot. Its language-agnostic AFAIK.
You're spot on!
I believe Padrino is basically Sinatra + authorization/admin-views and those other stuff that basically gives you thin Rails.
You have an example of replacing a simple scope with a simple SQL statement. I can write SQL,I would still prefer to do it in activerecord. Plus you can re use your composable scopes.
Python doesn't have a function to add EAX to EBX. Enough to be useless in computation.
thanks for your response, i thought about commenting my end blocks but that doesn't help much unless everyone who's working on the project does it as well. It'll probably be easier for me to read once i know the language better.
&gt; enumerable methods run on an empty collection return nil No. `select`, `map`, `reject` all return empty arrays/enumerables.
Yeah, if you feel the need to comment your end blocks, usually it means you should break up your code into smaller methods or more classes. 
Typed arrays are a huge deal. So much computation requires array optimizations which can be done when you can use simple arithmetic to gain access to array elements in memory. Since Ruby arrays are not of a fixed type you have no idea how to quickly access elements. Ruby arrays now are just big collections. To do array computations it would need some other data structures.
Not sure why you got downvoted, I think this is the best solution in the thread by far and actually does was the prompt asked for, passes in pricing rules for each checkout, safely isolates them and allows full flexibility in rule definition. A nitpick, and several solutions in the thread have these problems, not just this one: def total @item_counts.map do |item, count| pricing_rule = @pricing_rules[item] # (2) price = pricing_rule.call(count) end.inject(:+) || 0 end - `inject(0, :+)` is a much better way to get zero out for an empty count hash. - There is no need for the `map`, i.e. no need to walk the list twice: `@item_counts.reduce(0) { |sum, (item, count)| sum + @pricing_rules[item].call(count) }` - Separate issue: `RULES.default = lambda { 0 }` probably wants to be `RULES.default = lambda { fail 'Call your manager' }` lest we give away a bunch of free stuff :)
&gt; However, you should rarely be writing code more than 2-3 layers deep in blocks. When you're defining nested modules, sometimes there's a reason to do: module Foo module Bar module Baz # ... end end end instead of: module Foo::Bar::Baz # ... end 
I'm not saying that's not posible, but it can get messy really quick. I guess I should be more specific...
&gt; when you have a zillion end tags one after another If you have a zillion end tags in a row your problem is most likely the overall structure of the code. You shouldn't need to nest that deeply and especially in ruby your methods/blocks should not be very long in general. 
Wow, that's a cool solution! :)
Whoops! That must have gotten edited out while I was proof reading / moving code around. Thank you for letting me know. I just edited back in. To answer your question, you read data like this: require 'pstore' store = PStore.new('my_file.pstore') store.transaction { store[:value1] = "Saved on disk." } my_var = store.transaction { store[:value1] } # =&gt; "Saved on disk." 
What's the performance like with Structs vs regular Classes? 
Hey cheald thank you for the attention! In the first case, there's no a SQL injection vulnerability. Take a look at the first example: http://www.bccriskadvisory.com/rails-sql-injection-gotchas/ The '.where()' method used here is being used in a way equivalent to passing a hash of a single key and single value, which is protected agains SQL injections by default. The other 3 cases are indeed vulnerable, I haven't posted them on the README.md because I'll only talk about them on the gem's wiki, advising that they should only be used when the parameters are being sanitized elsewhere. Actually, maybe I'll just deprecate them. Thanks for the advise about the 'LIKE %...%.
Well, my way to minimize the bad performance effects of using 'LIKE' is by prioritizing other search params, like ids, bools and ranges. However, in a case where an user only inputs a string in a search form, only 'LIKE' will be used. Each param would search through a single column only.
You are incorrect - values are escaped, but the key is not. Your usage is demonstrably vulnerable: 2.2.2 &gt; value = "3" 2.2.2 &gt; key = "1=1); drop table users; (select * from users where id" 2.2.2 &gt; puts User.where("#{key} = ?", value).to_sql SELECT "users".* FROM "users" WHERE (1=1); drop table users; (select * from users where id = '3') You're interpolating user data into strings which are presumed to be sanitized. It is an unreasonable expectation to expect users to perform their own sanitization; one of the big draws of AR is that it will perform sanitization for you. You should probably do something like checking key values against the table metadata provided by the model to ensure that only valid keys can be used.
Using o-structs is extremely slow, don't do it in production code. Please add this warning to your post please
&gt; Exhibit A: https://twitter.com/maccaw/status/576437511729221632 Except the Padrino developers [responded to and worked around](https://github.com/padrino/padrino-framework/issues/1867) the API breakage in Rack. Padrino is a nice middle ground, where it provides the structure and rigging you'd expect from a framework, but leaves the rest up to you. Almost anytime someone complains about Ruby, it is almost _always_ concerning a Rails API or Rails-ism. It would follow, if you removed Rails from the equation, you'd resolve many of those complaints.
Uhm, don't know details about this change but if something as fundamental as error handling was completely broken and no tests could catch that then seems like there are some serious flaws in the test suite. Or maybe not the test suite but the CI setup, they should be testing against all stable releases of rack that they support. I mean after all those two libs are quite fundamental pieces of the ruby ecosystem.
Thanks!
You're right. I forgot the most important part *facepalm* I am looking for people to contribute yes, but I am mainly looking for code reviews and advice. The only reason I emphasize the reviews and advice, is because I myself am a bit of noob to programming, and am looking for opportunities. I'm creating this series along the way to help others as well because I do not want to receive help without giving help in return however I am able to. 
Cool post! We’re using the following code in probably all of our production applications, to get the speed of `Struct` and the flexibility of passing keywords arguments à la `OpenStruct`. class ClosedStruct &lt; Struct def initialize(*args) args = [{}] unless args.any? args.first.each_pair do |key, value| # Make sure we only set values to defined arguments if members.map(&amp;:intern).include?(key.to_sym) send :"#{key}=", value else raise ArgumentError, "#{self.class.name} doesn’t support the `#{key}` keyword, only #{members.join(', ')}" end end end end This makes it possible to do this: class Person &lt; ClosedStruct.new(:first_name, :last_name) end Person.new(first_name: 'Foo', last_name: 'Bar') # =&gt; #&lt;struct Person first_name="Foo" last_name="Bar"&gt; Person.new(first_name: 'Foo') # =&gt; #&lt;struct Person first_name="Foo" last_name=nil&gt; Person.new(first_name: 'Foo', something_weird: 'Yup') # =&gt; ArgumentError # Person doesn’t support the `something_weird` keyword, only first_name, last_name"
&gt; . If you're not willing to write code in a style like most other Rubyists, they're going to be less likely to want to work with you. It's not that I'm not willing to, it's that I really don't know how. The reason I knew other Ruby programmers would cringe at the horror, is because I've done a fair share of reading, and I've noticed Rubyists are really picky about their styling. My point was that right now I'm just happy that I got everything to work properly. Now it's time for me to polish it up and turn it into a much more readable code. 
The best way is to read other people's code on see how they handle a particular problem. You can also google "ruby design patterns" to get started thinking about structure. You can also checkout rubocop which will warn you about stylistic "errors" in your code. *I would start by refactoring that large "function" into some small Ruby methods.
Structs are implemented in c so the performance is great. Openstructs are implemented in ruby and make use of method missing so they are much slower.
Thank you for this. This is something that all newbs should be introduced to when starting off with Ruby. 
What does the ```intern``` method do? The documentation is not very clear :( 
Bookmarked! This is a goldmine. I've used quite a few of these libraries, namely phony and sinatra. 
how are you looking for code reviews? Do you want us to review your code here on reddit? Or with issues on the GitHub?
https://github.com/microrb/microrb.com/issues/2
&gt;it's just more readable for me mostly due to formatting i suppose but also i can select a bracket in visual studios and it highlights its partnering bracket for me Rubymine highlights the beginning code of your ends too. It also autoformats. 
`Treasure` is a *class*, while `Treasure.new(:pie, 5)` creates an *instance* of that class. The *class method* `Treasure.points` doesn't exist, but the *instance method* `Treasure.new(:pie, 5).points` does. The following example would work, because your `TreasureTrove.random` returns an instance of `Treasure`: treasure = TreasureTrove.random puts "#{treasure.name}, #{treasure.points}" 
Good explanation. I'd nitpick and say it's clearer to say "a lambda is an anonymous function", not "an object with a value that is...". But yeah, a lambda is a way to keep a block of logic in a variable or pass it in a parameter. They are used to make your code more generic or abstract, when you need to parameterize a block of logic. ActiveRecord scopes are a pretty decent example. 
&gt; Good explanation. I'd nitpick and say it's clearer to say "a lambda is an anonymous function", not "an object with a value that is...". Yeah, I guess that's fair. I think it's actually both, and I was trying to communicate that in Ruby, lambdas are also Ruby objects. Thanks for the reply and clarifications. 
Sure. But EVERYTHING in ruby is an object, right? Or at least everything that can be assigned to a variable or passed as an argument is. Is `12` an 'object with a value that is an integer'? Is `"string"` an "object with a value that is a string"? I'm not sure "an object with a value that is..." makes sense in ruby, what is an "object's value" exactly? It makes me think there's going to be an `object.value` that is something. I don't think there's any notion of an object generically having a "value" in ruby. 
_over_simplifies? Um. 
No, I think the object explanation was great. "Anonymous function" doesn't make much sense to beginners/less experienced.
You need to use the full namespace: Treasuretrove::PRIZE.size. You're outside the scope of the Treasuretrove module.
You can take it a step further (as Giles Bowkett does) and alias the word lambda to the uppercase letter L It does wonders for obfuscating code :)
You don't need regex if there are only 3 columns which is why I asked for input. I see your other comments though so I understand why you need the regex now. &gt;Why do you use IO.foreach instead of f.each_line? Is there any difference? http://stackoverflow.com/a/1728941/1394698 Some of the other posters have good solutions.
The scope method should work fine taking either a proc or a lambda -- for most purposes they are basically interchangeable, they have a few differences in behavior, around argument checking, and how a 'return' behaves inside a proc/lambda definition. lambdas are basically the standard default when you don't have a reason to choose a block, made even more so by newer ruby's special concise syntax for creating them with `-&gt;`. I personally find it best to think of a "block" as nothing more than a special syntax for passing procs into methods, rather than a different thing. Ruby supports special syntax for passing exactly one proc into a method, using the `do` or `{}` constructs on the end of a method call. It does this because this is such a common use case, and ruby wants to make it readable. So methods can be written to take a "block" using this special block syntax. But under the hood, it's semantically the same thing as a block. (Yeah, yeah, some people will suggest that in MRI, there are certain performance optimizations for blocks that are never turned into full-on procs in a variable. This is an implementation detail for performance purposes, you don't need to think about it, it does not effect semantics). 
&gt; File.open 'output.txt', 'w:UTF-8' do |file| &gt; File.foreach 'input.txt', encoding: 'UTF-8' do |line| By default it's CP850, and changing it to UTF-8 produces the following error "gsub!': invalid byte sequence in UTF-8 (ArgumentError)". EDIT: Hey! I actually got it to work, but I had to re-save the file as UTF-8 from Sublime Text. Thank you very much!
I love and recommend elixir, especially to rubyists but I agree this blog spam is pretty annoying.
I've been practicing Ruby for about a month now. This framework looks like it'd fit the website I'm trying to make. However when I try the tutorial for the todo app my website only shows a blank page when it should be showing the input box. Navigating to /todos works but still shows up blank. Might just be that I'm a complete noon but is the tutorial documentation no longer working?
 case coffee_choice when 1 then total_cost += small_coffee_cost when 2 then total_cost += medium_coffee_cost when 3 then total_cost += large_coffee_cost else puts "you didn't enter the right number to order a coffee please try again." end although, personally, I'd refactor that to def symbolize_choice(choice) case choice when 1 then :small when 2 then :medium when 3 then :large end end coffee_cost = {:small =&gt; 1, :medium =&gt; 2, :large =&gt; 3} if coffee_choice.between?(1,3) total_cost += coffee_cost[symbolize_choice(coffee_choice)] else puts "you didn't enter the right number to order a coffee please try again." end 
Is the = nil not redundant when outside the loop?
thank you for the refactored version.
Thank you. I'm getting to that now. There are a few things I will need to learn about before I can use the bundler. I've yet to work with gems. 
It was a little out of date. [Check out this one I wrote more recently](http://datamelon.io/blog/2015/building-a-chat-app-in-volt.html). Drop me a line if you need more help or think I could do a better job in future episodes. Hope that helps!
Blocks *are not* objects. They have to be wrapped in a Proc to become objects.
Blocks are not objects, but [Methods *are*](http://ruby-doc.org/core-2.2.0/Method.html).
You never HAVE to user lambdas (in my experience). But once you get a little more comfortable with them you start to see use cases every now and again. It's a trivial example but here's a little one: #ApplicationController def find_my_stuff(&amp;block) raise "find_my_stuff requires a block" unless block_given? params.each do |key, val| if model_name = key.match(/(\w+)_id/) model_name = model_name[1] raise "Unpermitted class" unless raise_check(model_name) return yield( make_class(model_name), val ) end end end #FooController @foo = find_my_stuff { |model, val| model.friendly.find(val) } ... @foos = find_my_stuff { |model, val| model.find(val) }.foos #BarController @bar = find_my_stuff { |model, val| model.find(val) } ... It's mostly just a way to make your code more reusable. It will also help if you need to instantiate. Here's a slightly more relevant example from an Obj C tutorial I'm doing (I'm just going to translate them to Ruby for everyone): @game_board = [ Tile.new("A safe harbor", UIImage.imageNamed("PirateFriendlyDock.jpg"), -&gt;(character, obj) { character.healAll; character.getItems(obj) }), Tile.new("Yo, you bout to fight an octopus, son", UIImage.imageNamed("PirateOctopusAttack.jpg"), -&gt;(character, obj) {character.takeDamage:200; character.expUpWithDmg:2; } ), ... #different Tile with different actions (blocks) per tile ] Without procs getting that per tile behavior would be much more difficult. As a point of contrast the tutorial I am using just used an `if/else` method. Which would have been quicker here, but more constraining for more complex situations)
Are you trying to run RoR or Ruby code? I just asked a senior about Watir and testing Ruby. She asked me "In a browser?" and gave me an eyebrow raise. 
Thanks for spotting it, fixed!
If you have such a high number of attributes you should probably try refactor some away, for example with [Introduce Parameter Object](http://www.refactoring.com/catalog/introduceParameterObject.html).
There is a small thing to be aware of with this approach: If you're always injecting dependencies during tests, then you only ever rely on the default when in production, so you're not testing that execution path. Overall it's a minor risk, and you can mitigate it with integration tests. PS - It's probably a bad idea to name your method [`send`](http://ruby-doc.org/core-2.2.2/Object.html#method-i-send) :p
Yeah, as I point out, I have at least one test that touches all the callable objects with integration test. With the dependency injection, it is quite simple to test out different execution paths without having to touch code that requires expensive operations. Thanks for pointing out the `send` :)
have any good tutorials/screencasts?
We are very confused as to what you are asking. Watir opens up an actual browser window and does automates things in it. It is usually used for integration testing. What are you trying to accomplish here?
&gt; In Sublime Text 2, so not in a browser. Made my day.
blocks are not objects in the same way that while loops are not objects. They're structures, but they can also be passed as values. In this way you can see it as lamdas and procs being the objectification of a block. Blocks are objects, just anonymous ones.
&gt; If you use dependency injection as a default get-go tool, you might get intimidated by the fact that you need to construct dependencies each time you want to call a given class. You shouldn't need to construct the object every time you use it. Do it once at app startup: MyApp.new(SomeService.new(RealTwitterGateway.new)) This directly leads to the next thing I wanted to point out: User input doesn't belong in the constructor, otherwise you'll never be able to separate usage and construction of the object (and you could just replace your object with a global method). So, it should be `service.call(input)`.
So we call them structures, not objects. I'm not sure what you mean by "they can also be passed as values" in this context.
Ah, gotcha. Sorry, been coding all day, brain's a little fuzzy. :)
&gt; This directly leads to the next thing I wanted to point out: User input doesn't belong in the constructor, otherwise you'll never be able to separate usage and construction of the object (and you could just replace your object with a global method). So, it should be service.call(input). 100% agree.
Your data isn't there, it's loaded via AJAX. This [JSON](http://mlb.mlb.com/gdcross/components/game/mlb/year_2015/month_06/day_11/master_scoreboard.json) looks to be the source.
 def hi yield end not passed as a value (I meant parameter, but the value is still passed and converted) def hi &amp;block block.call end passed It's an object and not just a structure because it contains values and a scope. In the same way we call a Proc and Lambda an object, so is a block. Look up "rb_block_t" in the Ruby source code.
The data is in JSON format, xpath and Nokogiri only works for XML, or html.
Rails let's you execute sql if you really, really want/need to. But 99% of the time, I'd say, you're going to be find just working with the model and letting activerecord (the class that your models inherit from) do the heavy lifting for you. So if your goal is to learn SQL (Which I'm of the opinion you should. It's fun and you should know what's going on under the hood), doing it through RoR is not going to give you the experience you're looking for. I think you want to be as close to the database as you can when you're trying to learn sql, and doing it through a framework like rails just seems to be asking for problems to get introduced that are completely unrelated to sql. That's just my opinion, though.
Yeah i've just found a series of sql tutorials using mySQL so i'll give it a go. I figure like you've stated, learning how it's working behind the scene will most likely be beneficial and I'll be able to use it later on I'm sure.
Hi, your question makes sense to me, and I'm not sure why all the confusion. Yes, any given watir script drives a browser. And you'd like to see some example scripts. If I had some in mind, I would post them, but it's been too long. Good luck!
If I recall my own experience, I managed my first N+1 problem in rails about 5 hours into building my own website. If you want to learn rails you should always understand what a query in the log means and be able to figure out what it does and especially what the problem is when a join breaks for instance. I second that installing a database is a good choice. Though when someone asks me at work I recommend to build their rails project with postgresql and when some migrations have run and data is loaded, I tell them to connect manually via psql console and try to figure out how to access the data yourself without rails. That makes it easier for them as they know how tables should be connected through models.
You can switch to vim which provides better autocompletion for ruby. With Plugins like YouCompleteMe it gets even better for vim. Moreover you can use community ruby / ruby on rails snippets for better autocompletion. If you want a full blown IDE then you can opt for RubyMine but it's not so popular to use it in community. 
If you want to know what SQL is about, install SQLite3, and use the plain Ruby library for it. Make a toy app, read a tutorial, etc.
Hi Alixious, autocomplete for a dynamically typed language will never be close to that provided by a statically typed language because everything can change at runtime. If you must have it, rubymine is pretty good but there are also other ways of working which could give you a better experience for free. Have you ever used to immediate window in Visual Studio? Ruby has a much more powerful version with a gem called pry. I will often do a lot of development directly in that window. To use it first do a gem install pry. Then something like this; require 'pry' i = 20 binding.pry # this will jump into pry like a breakpoint when you are in pry, you can type i.methods&lt;enter&gt; or i.&lt;tab&gt;&lt;tab&gt; to see the methods on that object etc. There is heaps more to this little gem - i highly recommend you check it out.
So what can you do to scrape json info?
Can you expand on your benchmark? I'm afraid I don't understand the code you tested. What I said revolves around the difference between doing this: def foo(&amp;block) block.call end And this: def foo yield end I can't remember how significant the difference was. It might have been very small, but I read a performance benchmark that showed yield was faster.
Hi there, I thought I would chime in to reply. This is definitely not spam. The reason for publishing this on reddit is we found it to be a good vehicle to raise awareness to more people that might be interested in personal training. We are a serious educational platform and we want to embrace the community better. We thought Reddit might be a good opportunity to share our potential. You can check my authenticity by checking my information on Tuts+ and my personal website: http://tutsplus.com/authors/jose-mota and http://josemota.net.
I like the form letter response. Gave me a good chuckle. :)
I've been there man. I used to scrape data from nfl.com in an attempt to win my football pool :) You should definitely be using something else. In particular, you should be using [KimonoLabs](https://www.kimonolabs.com/). They're a really cool startup that makes web scraping a breeze. I've used it to scrape The Pirate Bay, Rotten Tomatoes, etc. SUPER easy. Let me know if you need any help or have any questions.
The JSON class in the ruby standard library. Just `require 'json' ` and `JSON.parse(...)`.
Thanks for the explanation. Definitely helped clear up how the loop is counting each word in the array. 
Thank you for taking the time to answer. Helped to clear up what I was being hung up on. Thanks for confirming what I thought was the case for the sort_by method.
This is an older article I wrote, but thought I'd share it here just in case it helps anyone. I'm sure there are cleaner ways of doing this, and I'd love to hear them as well, so please share :)
Hi Rick, I've been reading your tutorials (and everything else on Volt) and I have a similar issue. This isn't a complaint - I appreciate the effort of yourself, Ryan and others - but Volt isn't quite there for newcomers. I'm a seasoned developer but have limited experience with Ruby and have found Volt a bit of a challenge as I'm not sure what is a Volt issue and what's down to my lack of Ruby knowledge. I'm sure it'll come good but it seems a bit of a moving target at the moment. I think pushing users to Stackoverflow is a good move, you guys are always helpful but popping into Gitter every time I hit a problem isn't very productive. I'm hoping post 1.0 the ecosystem will grow and we'll see more tutorials and demos. Thanks :-)
You did the right thing by using `each`. Ruby is a mature language and mature languages always have "bad parts", `for...in` is considered one of them because `each` is always more appropriate. However, many `each` blocks can be simplified by using other methods, many of which are in `Enumerable`. Check out `Enumerable#count`, `#group_by`, and `#reduce`.
it's only a Proc after it's passed to the method, where it's converted to a Proc with the &amp; symbol.
It looks like RuboCop uses [overcommit](https://github.com/brigade/overcommit) for managing the Git hook integration (or the RuboCop guys also wrote overcommit ...). Awesome idea, but since it is a static code analyzer, wouldn't RuboCop scan the whole project vs. just the files that are staged for commit?
I'm not familiar with overcommit, but yes, this approach would scan the whole project, so it assumes your code is RuboCop compliant to begin with.
I think you are missing my point. It's an anonymous object until it's converted to a Proc. It has both state, and behavior. It just doesn't have an external interface to call methods on until it's converted into a Proc.
Just define a regular expression in `FORBIDDEN` and modify the `grep` parameters with an `-E` option. For example: ... FORBIDDEN='debug_backtrace|console.log|debugger' .... GREP_COLOR='4;5;37;41' xargs grep --color --with-filename -n -E $FORBIDDEN &amp;&amp; \ .... This _should_ work ...
You can also use `egrep` instead of `grep -E` ... I know that's a *tiny* time saver, but every keystroke helps ;)
thanks for the recommendation.
Thank you!
Notice, you don't have an intermediate `frequencies` to be created. `Enumerable` defines the method `group_by` to classify items in array: words = %w(double double toil and trouble) words.group_by { |word| word } # =&gt; { "double" =&gt; ["double", "double"], "toil" =&gt; ["toil"], "and" =&gt; ["and"], "trouble" =&gt; ["trouble"] } Then you could apply `count` to values words.group_by { |word| word }.map { |k, v| [k, v.count] } # =&gt; [["double", 2], ["toil", 1], ["and", 1], ["trouble", 1]] Sort them by last values words.group_by { |word| word }.map { |k, v| [k, v.count] }.sort_by(&amp;:last) # =&gt; [["toil", 1], ["and", 1], ["trouble", 1], ["double", 2]] And hashify at the very end words.group_by { |word| word }.map { |k, v| [k, v.count] }.sort_by(&amp;:last).to_h # =&gt; {"toil"=&gt;1, "and"=&gt;1, "trouble"=&gt;1, "double"=&gt;2} The whole point is that with various `Enumerable` methods you can operate in more idiomatic "Ruby way".
The choice of debugger isn't really the point; it's more about ensuring unwanted artefacts aren't committed to Git.
Windows has a lot of SSL issues when it comes to ruby/bundler. Some people have success with [this guide](https://gist.github.com/luislavena/f064211759ee0f806c88). Good luck!
Hashes already duplicate their keys: key = "hello" # "hello" ht = {key =&gt; "world"} # {"hello"=&gt;"world"} key.upcase! # "HELLO" ht # {"hello"=&gt;"world"} That's why it never really caused any problems in Ruby 1.8 before the `Symbol`mania started. For better backwards compatibility, I'd suggest interpreting `:foo` as syntax for `"foo".freeze`, but that's probably not even necessary except to enable a few optimizations here and there. There were frequent discussions about adding syntax for frozen `String` literal like `"foo"f` or `%f{foo}` as basically something halfway between `String` and new `Symbol` - none of that got anywhere so far.
I think its the same link i tried. Do you happen to know any other way? thanks
Nope, sorry. I gave up on Ruby on Windows a long time ago.
If you freeze your strings as the article prescribes, you will see that the object_id is the same each time.
that's fine but it isn't the proper solution. attr_writer 'something'.freeze is ugly as sin edit: and not as performant. You guys are monsters ;) 
If all string are immutable then you wouldn't have to freeze it.
You are cute. try again
I wasn't commenting about that point. What's with the constant [context-changing when someone tries to discuss a particular point with you](http://www.reddit.com/r/ruby/comments/39gyb7/ruby_3_should_merge_strings_and_symbols/cs3eqpf?context=1)?
ok... I'm having trouble following you. here are my points: 1. String#freeze is an ugly solution 2. String#freeze creates a larger object in memory than a Symbol. edit: clearly explains position; gets downvoted
Neither I nor the author ever said one approach would be more performant than the other. `ObjectSpace.memsize_of(:hello)` returns 0. What is more likely: that Symbols take no memory, or that this API doesn't do what you think it does?
I don't know about you, but this is what I get: 2.1.2 :001 &gt; require 'objspace' =&gt; true 2.1.2 :002 &gt; p ObjectSpace.memsize_of('hello') 0 =&gt; 0 2.1.2 :003 &gt; p ObjectSpace.memsize_of(:hello) 0 =&gt; 0 2.1.2 :004 &gt; p ObjectSpace.memsize_of('hello'.freeze) **edit** - indeed: 2.2.0 :001 &gt; require 'objspace' =&gt; true 2.2.0 :002 &gt; ObjectSpace.memsize_of('hello') =&gt; 40 2.2.0 :003 &gt; ObjectSpace.memsize_of(:hello) =&gt; 0 2.2.0 :004 &gt; ObjectSpace.memsize_of('hello'.freeze) =&gt; 40
Right... but the reason they made symbols is for performance. Do you get it now? and as far as your api comment, you may be right but I don't see any other api's for this and in addition to that you are more than welcome to inspect the object in pry and see what instance methods are carried around. I'm not making this up. I promise edit: down voted for pointing out that performance is important to core ruby maintainers. who would have though? 
my ruby version is 2.2 
I think it's better to write new comments rather than editing existing ones. Let others experience the journey with us.
Noted.
Oh, and instance methods aren't copied into every instance. They are a part of the class or module on which they are defined. If you meant instance variables, pry doesn't seem to list any for Strings or Symbols.
Probably yes, I just don't want to claim that since I haven't looked at post-symbol-GC ruby C extensions API much. Ruby already has special handling for: * mutable Strings * frozen Strings * dynamic symbols (used only in ruby code, can be gc) * static symbols (used in c code, cannot be gc) and piles hacks to make that backwards compatible on both ruby and C side. It would really benefit from cleaning up this mess, and turning symbols into frozen strings is probably the easiest way to go.
&gt; I'm only barely competent in C, but I'm pretty sure this shows that every Ruby Symbol object contains a Ruby String object, which is what gets returned when you use Symbol#to_s Every Ruby dynamic Symbol. Ruby ended up with 4 implementations of basically strings (mutable String, frozen String, dynamic Symbol, static Symbol). [Anyway, `Symbol#to_s` returns a fresh `String` every time](https://github.com/ruby/ruby/blob/trunk/string.c#L8794): VALUE rb_sym_to_s(VALUE sym) { ID id = SYM2ID(sym); return str_new3(rb_cString, rb_id2str(id)); } 
The reason you're getting down-voted is that you won't accept that you're wrong. See: https://news.ycombinator.com/item?id=9197412 &gt; Symbols and frozen strings offer identical performance
It's not that you're doing it wrong, it's that you're doing it right, but right is a bit magical and concise when you're starting out. If you really get what's going on then great! If not, don't beat yourself up over it. Block syntax is weird looking, and there's a ton of magic going on in sort_by - it's basically running a fairly complex, optimized tag &amp; sort under the hood, and the block syntax for hashes take two arguments (|key, val|) where almost all other enumerable blocks take just the val, etc. It DOES make sense eventually, and blocks and their handling are one of the best parts of Ruby (IMHO), so keep banging away and it will quickly become second nature. Good luck!
There's a global table, you still get new object on `#to_s`. I'm not sure if string contents itself are allocated by copy-on-write or copied immediately (Object headers are allocated each time).
TIL. Thanks for the info!
My intention wasn't originally to bring up the performance impact or semantics of string/symbol conversion, only to demonstrate that Symbol isn't a more compact way of storing data than String for individual instances. I showed `rb_sym2str` because it gave a clue about the Ruby type of `fstr`. I think that the current behavior of `Symbol#to_s` makes sense ... I wouldn't like it if such a basic method made the Symbol mutable (`#unfreeze` would be horrifying). And because mutable Strings are the default, that's what we expect `whatever#to_s` to return.
The benchmark i posted in my comment says otherwise. Not to mention, you don't benchmark with Time
not all tooling is so kind, unfortunately
Best typo ever in the article: I know status quo bias will make many people dislike this idea, but let's reverse this - if it was already working like I describe, would any sane person suggest introducing Symbol type? Of course now. Hrm..
This is the best response. I'm with you.
&gt; And you've just proven my point... No, it shows that indentation with tabs is *optional* according to a tool *you* chose! &gt; You need to disable loads of checks against best practices [...] Do you agree with all of the guidelines enforced by RuboCop? How about this one? Prefer single-quoted strings when you don't need string interpolation or special symbols. Is that a best practice? Or do you think that's *optional*? &gt; You are trying to write java, not ruby. Using Java libraries will involve Java integration syntax. What did you expect? 
This is part of the reason I use git add -p
Yes, good point but I feel like now that we have Symbols, their distinctly different look (from strings) makes them more attractive as hash keys. When I see a Symbol, I know that it can't be modified and it just sort of "looks right" now. I'm relatively new to Ruby and must admit that I thought Symbols were a bit odd at first.
This blew my mind the most: In 2014, bootcamps across North America graduated roughly 6,700 students. This year, that number is expected to more than double to 16,000. To compare, there were approximately 48,000 undergraduate computer science graduates from accredited US universities in 2014. **Wow..** Not that many people get a CS degree it seems. Crazy factoid right there!
Can someone mention the difference between using pry, and using the pair of gems: binding_of_caller &amp; better_errors - I Personally use the latter and just drop -fail where I want to break and play around. Are they essentially the same debugging tools?
Not sure why you got modded down. I took this as an ironic statement. Maybe everyone is getting a bit tetchy about the anti-Rails vitriol coming left, right and centre at present.
Hahah. OK, so here's what I'm trying to do. I want to have a landing page that gives you 2 options. You pick one option, you get brought to an ordering my product page. You pick the other, you get brought to a page that allows you tell me more info about what you're looking for. I'm selling homemade honey/bees btw.
&gt; Hashes already duplicate their keys This is actually just a *special case* that occurs when using strings as keys.
What's the point? Honestly. I hate symbols and the way they work in Ruby. Why? Because sometimes you get hashes with strings as keys and sometimes with symbols. It's annoying as hell. Even parsing JSON by default gives you a hash with string keys (unless you provide some options but there are problems with that too). I'm so sick of this I almost always just load up HashWithIndifferentAccess, as shitty as it is, I just don't wanna deal with this crap.
Sorry to hear that Matthew. If you decide to pick up Volt again and get stuck, shoot me a private message here on Reddit or on the Blog. I am always looking for new post ideas. Chances are, if it is confusing for you, it's confusing for others also. Thanks for the feedback!
It is worth having a decent understanding. Being able to look at the queries active record produces and see whether they need to be improved etc. Understanding how the different joins work helps.
Estimating that sort of thing can be difficult. Often I feel like predicting how long even basic development tasks should take is tough to get right all the time. It's better not to focus on the time it takes you to learn - just jump in. If you need resources, the sidebar has some good ones to start.
I'm trying codecademy right now. If I complete the Ruby course, do you think I'd be able to build this type of website after?
Of course. You have string-&gt;symbol in LISP (i.e. Scheme) and list_to_atom/1 binary_to_atom/1 in Erlang.
Yep. 30 seconds on google found me [this post](http://stackoverflow.com/a/1265405/1954610) which explains why the two different libraries exist. If you really want a "tl;dr" of these articles, then: Always use `Time`, unless you're trying to do something very unusual that's not supported by the API. (Such as pre-Gregorian Calendar Reform dates, like this article discusses!)
No, not really. You'll have to learn a basic web framework like rails or sinatra after that, which would also require learning a bit about databases. And a layout framework like bootstrap. Are you planning on implementing the ordering page or is that already something online? If you wanted to make an ordering site, then you'll have to learn about security to protect credit cards. And some payment system. At this point, why not just use something like Shopify.com? I would say all this effort would be more worth it if you plan on keep writing code as a parallel hobby for the foreseeable future. Otherwise it would be like me saying I want to manage bees and produce honey because I have a website that could really use a product to sell.
I haven't really experimented with the binding_of_caller &amp; better_errors debugging idea, but one thing I really like about pry is being able to `ls my_object` to show its variables *and methods, including which class/module defines them!!* For example: [1] pry(main)&gt; ls ["example"] Enumerable#methods: all? each_slice flat_map max_by none? slice_when chunk each_with_index grep member? one? sort_by collect_concat each_with_object group_by min partition to_set detect entries inject min_by reduce each_cons find lazy minmax slice_after each_entry find_all max minmax_by slice_before Array#methods: &amp; concat hash reject slice * count include? reject! slice! + cycle index repeated_combination sort - delete insert repeated_permutation sort! &lt;&lt; delete_at inspect replace sort_by! &lt;=&gt; delete_if join reverse take == drop keep_if reverse! take_while [] drop_while last reverse_each to_a []= each length rindex to_ary any? each_index map rotate to_h assoc empty? map! rotate! to_s at eql? pack sample transpose bsearch fetch permutation select uniq clear fill pop select! uniq! collect find_index pretty_print shelljoin unshift collect! first pretty_print_cycle shift values_at combination flatten product shuffle zip compact flatten! push shuffle! | compact! frozen? rassoc size .... This can be very useful when dealing with your own (custom) classes that have a confusing list of ancestors.
I think one thing that few people have mentioned since switching to 12 factor apps is how potentially dangerous it is to leave sensitive keys in your envvars. While to be usable e.g. API keys have to be somewhere in your ruby process, when you leave it in an envvar, any processes your ruby process spawns will also get those envvars - and as we saw with shellshock, that can be a Bad Thing. My suggestion is to have initializers that pull the vars out of env and then delete them from env, like so: API_KEY = ENV.delete('API_KEY') Then you just refer to API_KEY (now a constant in your ruby process) in your code and any subsequently spawned child processes won't have access to the API key.
&gt; I'd suggest interpreting :foo as syntax for "foo".freeze They are only semantically similar enough to not cause major problems on MRI 2.1+, your assuming that freezing a string interns the object, there are no semantics about the freeze operation that guarantees this, it was an internal optimization added in MRI 2.1. At the very least you also need to introduce a `to_proc` implementation in String or you will break almost all Ruby projects. It's pretty easy to parse symbols and replace them with `"&lt;&gt;".freeze`, try it and see how many things you break across various interpreters, I'm betting there are a lot more issues than you think there are. 
Who knows. It depends on how many hours you spend at it, and how quickly you take to it. And whether you end up just copy and pasting things without knowing what you're doing (much quicker! But you don't know what you're doing). Anywhere from a couple months to a couple years to never? 
Sounds like Ruby would be overkill/not the best tool for the job. Shopify and Big Commerce would be much easier to implement an e commerce solution for. You could set up a basic site with zero coding knowledge in minutes, and then tweak it with basic css/html. Or hire someone off odesk for $5 an hour to take care of the fiddly bits. If you're just passionate about learning and are using this as a learn-by-doing exercise, check out Codecademy and Learn Ruby on Rails by Daniel Kehoe (I'm doing Michael Hartl's book, but this sounds better suited to you). You can probably get really something basic up in a month or two and then keep adding features to it forever. But again, using Ruby for an e-commerce site sounds like using a pneumatic drill to get a nail into a plank of wood...
I think you are making a mistake in confusing Ruby's symbol as a language feature from the internal symbol table, they really aren't the same thing at all, I disagree that Ruby's Symbol language feature is exposing the internal symbol table in any useful way, or that removing the feature would be 'hiding' something. But sure, features that provide more opportunity for errors and bugs than they provide value on the whole, should be considered for removal, of course. Features that take a lot of work/attention/extra code to use without error should be considered for removal, of course. (Or at least considered if in retrospect they should not have been added, to guide future languages; removal is hard because nobody wants to destroy backwards compat; in this case the OP argues that it maybe could be done without too much trouble -- maybe, I dunno). Discussing ruby on reddit has become a pit of despair and nonsense, I'm afraid. Nothing makes me fear for the future of ruby more than discussing it on reddit. I should probably stop reading reddit. **update 10am EDT** So yes, I was surprised to see that you are right in that **IN MRI** symbols and the internal symbol table are related. Which you can see with this interesting bit of code: xxxx_fronk = "something" Symbol.all_symbols.collect {|x| x.to_s}.find_all {|i| i.start_with? "xxxx"} #=&gt; ["xxxx_fronk"] However, in JRuby they are not. That same code produces `[]`, your local variable name does not show up in `Symbol.all_symbols` in JRuby. I think it would be difficult to find even a single example of this divergence in JRuby causing a bug or problem for anyone ever. Because I also think it would be difficult to find even a single example of someone making use of the fact that `Symbol.all_symbols` includes every symbol name from the actual MRI internal symbol table. Because it's simply not a very useful feature, there's nothing much you can do with it. I think this `Symbol.all_symbols`, in MRI, including actual internal symbol table names -- is pretty much the only thing that evidences the fact that `:symbol` literals are kept in the actual internal runtime symbol table. It's just not a particularly useful thing, it doesn't matter. I still don't know if I'd argue for actually removing symbols as in the OP, because I think the backwards compatibility issues are likely to be more than the OP predicts, and I value backwards compat pretty highly. (Please let's us never have to go through something like 1.8=&gt;1.9 again). But my experience with ruby over nearly 10 years leads me to think that symbols, while initially they seemed a neat feature to me, are in fact way more trouble than they are worth and in retrospect it would have been better if they had not been done like that. If you really need access to the internal symbol table, there are better ways to implement that, and the current implementation doesn't really give you much useful access anyway. 
The second link has a very good, concise explanation what is going on with gc'able symbols. It explains that symbols stayed the way they where and they introduced new symbols (mortal symbols) to compensate for people misusing symbols (&lt;-my opinion). And yes, you're right, the frozen string optimization kind of mimics the interning of a string. Symbols are the way Ruby identifies things. Matz decided it would be a good idea to let programmers use that mechanism, too. With the frozen string optimization, we can mimic a pretty good, separate implementation of that.
Ruby (well, MRI) uses internal IDs for that which it doesn't expose except to C extensions. Symbols and Strings are both converted to and from those IDs by metaprogramming API. It wouldn't really change anything here, and performance would be generally comparable. Erlang doesn't even gave strings, it just has linked lists of ASCII codes, so using symbols there makes more sense. (or it could get real strings, like what Elixir does, but that's another story)
I would have a strong preference for #2 for two reasons. Firstly, I hate semantic indentation. Secondly, I hate languages that resemble English, because it makes it harder to remember the language because English has so many synonyms and the synonym part of my brain activates automatically. I have this problem with SQL all the time. "WITH" or "USING"? "SORT BY", "ORDER BY", "LIST BY", ..?
You might want to look at [Qt Designer](http://doc.qt.io/qt-5/qtdesigner-manual.html), there are Ruby bindings to Qt. Your app would then be portable too.
&gt; If you don't need it, just don't use it. Symbols are needed for keyword arguments and many APIs. JSON makes string-keyed hashes mandatory. You can't just pick one and ignore the other without excluding yourself from the use of many technologies.
&gt; Discussing ruby on reddit has become a pit of despair and nonsense, I'm afraid. Ouch, I'm glad you didn't respond to one of my posts this way! Do you really think this discussion is that bad? I feel that I've learned a lot since it started.
USA has about 9 times Canada's population. If you take those 6.7k graduated students, then USA has around 7 times more graduates than Canada but if you consider the expected 16k students for 2015 it ends up being only 3 times more. They are not so bad IMHO. [source](https://www.google.com.uy/publicdata/explore?ds=d5bncppjof8f9_&amp;ctype=l&amp;strail=false&amp;bcs=d&amp;nselm=h&amp;met_y=sp_pop_totl&amp;scale_y=lin&amp;ind_y=false&amp;rdim=region&amp;idim=country:CAN:USA&amp;ifdim=region&amp;hl=en&amp;ind=false&amp;icfg&amp;iconSize=0.5)
&gt; I think both of these changes mean that frozen strings already treated just the same as symbols in terms of internment, in ruby 2.2. Both are 'uniqued' (one object in memory for identical value), and both are GC'd too. Am I wrong? There doesn't appear to be a "global frozen string" table. [1] pry(main)&gt; x = "x" =&gt; "x" [2] pry(main)&gt; x.dup.freeze.object_id =&gt; 70198057259660 [3] pry(main)&gt; x.dup.freeze.object_id =&gt; 70198061716140 [4] pry(main)&gt; x.to_sym.object_id =&gt; 711388 [5] pry(main)&gt; x.to_sym.object_id =&gt; 711388 [6] pry(main)&gt; RUBY_VERSION =&gt; "2.2.2" 
Hm, do you think the implementation of shared objects for frozen strings in 2.1 is buggy? Or someone not showing up in object_id? Ah, it kind of looks like it only works for string _literals_? How odd. irb(main):011:0&gt; x = "foo" =&gt; "foo" irb(main):012:0&gt; x = "foo".freeze =&gt; "foo" irb(main):013:0&gt; y = "foo".freeze =&gt; "foo" irb(main):014:0&gt; x.object_id == y.object_id =&gt; true irb(main):016:0&gt; z = x.dup.freeze =&gt; "foo" irb(main):017:0&gt; z.object_id == x.object_id =&gt; false irb(main):018:0&gt; z = x.clone =&gt; "foo" irb(main):020:0&gt; z.object_id == x.object_id =&gt; false irb(main):021:0&gt; z.frozen? =&gt; true
&gt; Usefulness of access to all symbols (similar to ObjectSpace module for accessing every object) has nothing to do with the original question. Of course it does! If there are no uses for the exposed list of all symbols, then why would it matter if it goes away? And if the original question is "Would we be better off without symbols", of course it's relevant if they have a feature frozen strings do not that you need, or not. Missing access to a list of symbols is only a limitation, as you say, if there is some use for that list. I can't think of one and have never seen one. You do not need that list for any metaprogramming or reflection that I have ever seen. The fact that JRuby Symbol.all_symbols does not actually include internal symbols has never, as far as we know, stopped anyone from doing any metaprogramming in JRuby. It's not a limitation if it does not limit you from doing anything you'd want to do. I think JRuby generally considers any divergence from MRI a bug, so I'm sure the difference would be considered a bug -- but it's probably not one that has hardly ever, caused a problem for anyone, because it's not a useful feature. 
My example shows that frozen strings don't always occupy the same memory location when they have the same content. The [deduplication of frozen string literals](https://bugs.ruby-lang.org/issues/8992) is a special case which is accomplished through a compiler trick. The only reason I can think of right now to expose a global frozen string table would be to clarify its nature in the interest of this discussion. :) Edit: Starting writing this comment before jrochkind edited the original comment.
&gt; performance would be generally comparable Before the frozen string optimization, the performance differences were quite significant (Source claims 2x). After the frozen string optimization, the difference is smaller, but symbols are still quite a bit faster. [Source](http://www.sitepoint.com/unraveling-string-key-performance-ruby-2-2/) &gt; Erlang doesn't even gave strings, it just has linked lists of ASCII codes, so using symbols there makes more sense. Erlang has enough syntactic sugar (e.g., string literals) to fool people into thinking strings are a first-class citizen. I don't think this has any motivation in it for using atoms (aka symbols). There are a lot of real reasons erlang needs atoms, though. For example, atoms are used to tag datastructures for easy pattern matching. You could do exactly the same thing with strings by simply putting quotes around the atoms. Performance, though, would take a huge hit because you just changed a simple integer comparison to a O(n) string comparison. Of course, you could start optimizing and tweaking the string implementation to match that performance, but frankly, atoms are a much more elegant and straightforward solution.
Read the .gemspec file and look at the line for spec.files. You'll probably notice it uses git to parse the set of files in your project and adds those to your built gem. spec.files = `git ls-files -z`.split("\x0")
If a frozen string table were available, why couldn't that be used to look up identifiers instead?
No problem :) it's one of those seemingly unintuitive things that is just experience 
Yeah. I've programmed in Ruby for years now (not rails, custom projects) and I just recently realized that I should move all my libraries into proper gems so I can properly manage them and maybe release some as open source on github.
About gems being tied to Git: You don't have to use Git for file discovery. That's just for convenience. You can pass an array of files, but you have to manually update this list whenever you create a new file. You can use something like `Dir['lib/**/*.rb', 'bin/*', 'test/**/*.{rb,yml,json}', './**/*.{md,rdoc}']` so you don't have to use Git.
`Array.any?` doesn't exist, it's `Enumerable#any?` being talked about. 
Nice. I independently setup exactly this yesterday at work to start building some middleware software. post '/' do binding.pry end is an awesome way to see what a server is sending you.
Can you post your code to a pastebin, e.g., gist.github.com? You have a hash with keys `:pile_1`, `:pile_2`, and `:pile_3`. These keys are identical but for a numeric component, the keys are consecutive in that component (`1`, `2`, `3`), and the set of keys doesn't change. These facts together suggest to me that you should use an array instead of a hash.
I posted the code here: https://gist.github.com/anonymous/028fc0c3bfe1a8465e92 The reason I used a hash is because I wanted to see the game printed to me after each mode. Array was hard to read when printed. Any other ideas for aesthetic reasons? Thank you for the help!
Thanks! I'll try out the suggestion. The code definitely kept feeling more and more complicated.
Check out [wombat](https://github.com/felipecsl/wombat)
It doesn't look bad its just not something a Rubyist would write. You're just starting out so I wouldn't really worry about it, especially if your new to programming. The thing is, you've written a procedural program here. It literally runs from top to bottom. As a beginner I don't think it's such a crime to begin learning Ruby this way, the most important thing is starting to think about how to solve problems and mastering control flow, which procedural programming is really good at demonstrating. However you might want to try breaking your code up into at least a couple methods even if you don't approach it from an object oriented mentality, it will help make things more readable. Usually Rubyists prefer to deal with objects. One of the great things about programming in an object oriented way is that you can encapsulate logic and state. I know as a beginner it's difficult to wrap your head around. But think about how difficult changing something in your game would be, it would cause a ripple effect across your entire app. So is your code horrible? No, its just not something you would ever write, its a great learning tool though. Now isn't the time to be worrying about such things, apart from stylistic conventions, just try to grasp as many concepts and don't be afraid to experiment. I'll just mention that you should make things such as goal a constant. To give you an idea of how a Rubyist would approach this I threw a little something together. Just a quick write up from seeing that gif on wiki. https://gist.github.com/anonymous/b8164ede560b973cc02e
Because you need frozen strings to be garbage collected but you can't do that to the place where you store identifiers. Therefore you must differentiate between those. There's a great presentation by Narihiro Nakamura [here](http://de.slideshare.net/authorNari/symbol-gc) about gc'able symbols and why "immortal symbols" are still needed.
Erlang strings are first-class citizens according to the common definition in PL theory.
OpenStruct, AFAICT, has one and only one good use case: defining `struct`-like objects where the fields to be added are dynamic and not reliably known in advance, and where adding "all possible" fields (and leaving their values as `nil`) is undesirable. I know there has to be a better way to dynamically construct "value objects" that have a varying subset of possible key/value pairs; if anyone knows of any such, I'd be grateful.
You can't call a type that literally doesn't exist "first-class citizen".
but you've got enough base knowledge to be efficient with it for most things? From my understanding there is a easy part to sql that is the most needed go to stuff then there is some very fancy stuff you can do if you really dig deep and invest time into learning it thouroughly.
To be explicit, I'm not advocating skipping learning sql. You really should learn it, regardless of what choices in frontend and backend framework you choose.
Yeah exactly, there are people who specialise in it. I know enough to get by.
The term "first-class citizen" is not about types, but about abstractions (see, for example, Abelson and Sussman, SICP Section 1.3.4). The string implementation in Erlang is perfectly in sync with that definition. Strings are a sequence of characters or codepoints. Many programming languages use existing collection classes to realize that. C, for example, which uses a simple array of characters to realize strings. Also without any "tagging" at all (which is absolutely insane, to quote you). C strings are, btw, not first-class citizens because you can't pass them as arguments or return them from functions without losing information. 
Thanks for all the responses. I will try it out this weekend and let you guys know if I need more help. 
People want HashWithIndifferentAccess, but they want it to be fast, concise, and clean rather than slow, bulky, and dirty.
But why is there even a need for such a strange thing? I'm not a Rails guy and I really appreciate your effort in explaining that to me.
You have a few options. 1. Gitignore the tests specific to your environment 2. Have a config yaml file that has the list of servers. Exclude the config file from the VC so that contributors can run tests as well. +1 for proxmox
It's a source of seemingly-meaningless inconsistency that comes up in interop situations, of which Ruby&lt;=&gt;Web is one, but definitely not the only one. For example, JSON serializes symbols to strings, but after a round-trip, all your symbol-keyed hashes have become string-keyed hashes. If you're using Resque or Sidekiq, you have to write your client and worker with this in mind because everything is serialized to JSON in the queue. If you have a job that just calls some slow method which accepts keyword arguments, you can create the keyword argument hash in the client and put it on the queue there, but then the worker has to convert the keywords back into symbols. On the other hand, if you're using YAML, symbols can be preserved (using the leading `:`) and you don't have to worry so much, but that YAML is then "Ruby-flavored" and looks strange in other languages.
* Mocks
Mocks and or setting the test server in an environment variable along with an extended flag setting in the config. If the flag exists and the env var is set use that env var as the host to run your tests on. This could be documented and useful for other users.
First a general tip: Don't invalidate for what you don't want, validate for what you do want. In other words when looking at external input, look for it to be formed like the expected structure, rather than trying to clean out all the possible invalid structures. Of course, that can still go wrong. It sounds like your talking about external requests, those you generally want to mock out in some way, the [VCR gem](https://github.com/vcr/vcr) is a good example of something that can help you with this. You may have to hunt a bit more for something similar if your not working with HTTP requests. If recording real requests as VCR does isn't enough, then you may want to consider 'fuzzing' in your test suite. The general idea is to exercise your code with a lot of semi-randomized inputs. I don't have a specific gem to recommend as I've not does this in Ruby but it does appear there are several out there, google 'fuzzing' and read up. 
You're right, worked perfectly! I'm surprised that there's not really anything in the Ruby community or elsewhere on the web linking to that page... also wow that took a long time to generate. Anyway, thanks!
PermGen is been removed in Java 8...
Your first option is mocks, if you want to do unit and/or functional tests. Another option is to do these calls once, check manually that all the results are OK, then store the results in a file or database and then do sanity checks on those values. Then if you want, you can combine the two approaches: use fixtures to instantiate expected results, then use mocks for simulated results to feed to your unit and/or functional tests. 
Why would you install ngrok via npm? It's a Go package. I would just install it with your distros package manager.
This. At least 1k times. Using constructor exclusively for injecting collaborators and/or some configuration + `call` that accepts input is a wonderful pattern.
im finding ruby harder to learn than c# because i'm able to visualize more of the backend stuff a bit better. I've looked at a little bit of python ruby which are both interpreted languages and believe they seem to be about equal because they abstract a lot away from the programmer, for example explicitly typecasting variables. It may be a burden for some people to say int var or string var but to me it is just a lot more clear of what is what.
There was no irony. Television did not kill newspapers. Similarly, I don't think that Elixir/Phoenix will kill Ruby/Rails, though I think there's going to be a shift. There's plenty of room for both to be vibrant communities, I don't think it's an exclusive situation. Hell, every now and again I take a look at what goes on in Java land, and they're still doing some pretty spiffy things.
Thanks. My thoughts exactly.
Yep
It doesn't seem that everyone agrees with you. Also note OP's comment "I am new to Ruby", so text files would be a simple approach.
Rubocop. I use it with Atom and it analyzes code as you type.
Assuming you're on a Mac: * Rubymine &gt; Preferences * Do a search for 'console' * Click *console font* on the left hand side * **Important**: Save your own scheme. They wont let you change the font on a default scheme. * After that, you can go to town choosing font and font size.
Jedi offers semantic completion though, while this solution does not. I have been planning on building a semantic Ruby completion engine for vim eventually, just needs some time.
I just use Emmet with Atom, enough auto completion for me, usually. And an erb-thing.
Thanks for this. I'll make sure to update the post when I have the time
The OP already mentioned [neocomplete](https://github.com/Shougo/neocomplete.vim) and [youcompleteme](https://github.com/Valloric/YouCompleteMe). What problem do you hope to solve that these tools do not?
Looksee lets you examine unfamiliar classes, and methods. https://github.com/oggy/looksee
No problemo
You can always write programs to solve problems on https://projecteuler.net
https://github.com/Valloric/YouCompleteMe/blob/master/README.md#semantic-completion-for-other-languages Please elaborate. It was an honest question - I'd actually be interested to know what these existing tools are missing. 
I didn't know a line of ruby before I started my first Ruby on Rails project. I would recommend that you take a Ruby on Rails course, pick a web app you'd like to build and then build it.
With the prevalence of incredible DSL's and frameworks/libraries that comes with Ruby, I'd honestly recommend just trying to build something real with the knowledge you have of syntax. A good first project I pair with on for people newer to Ruby is building a simple sinatra API that scrapes reddit or some other popular site using Mechanize, and then set up a jQuery (or Opal if you want to keep it all Ruby) frontend that hits this API. Example that I did with my BIL recently is [here](https://github.com/ybur-yug/nerd_apis) 
IMO a cleaner way to write the final rspec example is: describe Pizza, type: :model do describe "#expired?" do subject { build(:pizza, end_date: end_date) } context 'with a future expiration date' do let(:end_date) { 2.days.from_now } it { is_expected.to_not be_expired } end context 'with today as the end date' do let(:end_date) { 0.days.from_now } it { is_expected.to_not be_expired } end context 'with today as the expiration date' do let(:end_date) { 2.days.ago } it { is_expected.to be_expired } end end end Another tip: you probably want to be using `Timecop` to freeze the time in this spec, otherwise you could see random failures when the day changes during a test run. 
This is a great one
Gotcha. Should I just save myself the hassle and go Mac?
Huh. I'm actually interested in design a Ruby on Rails web app, and since this is one of my first projects, I'm probably going to make a basic website. You think Linux is the way to go?
Ruby can be fine on Windows. 1. Install [cmder](http://gooseberrycreative.com/cmder/) to get a decent terminal emulator. 3. For basic development, get [the Ruby installer](http://rubyinstaller.org/downloads/) and install it on your Windows side. This gives you access to basic stuff, and you can do a lot here. 2. Install [virtualbox](https://www.virtualbox.org/wiki/Downloads) and [vagrant](http://vagrantup.com), which make it really easy to spin up different development environments as you need them. I've set up a quick Vagrant box suitable for Rails development [here](https://github.com/parsonsmatt/rails-box) 4. Once you've got the Vagrantbox setup, you can use cmder to interact with it over SSH to run commands like `rails new` or `bundle install` etc. while editing the code in the shared vagrant folder with your editor of choice in Windows. It's a nice setup.
Yup. All the major Rails-friendly hosting providers are pretty much linux-based. Another commenter said the differences between mac and linux are minimal... but all it takes is 1 difference to prevent an app from functioning correctly. In my experience, there are quite a number of ruby gems that behave differently on a mac than on linux. Like I said, you should mimic your production environment 100% on your development machine so that no surprises pop up when you're trying to deploy or when your app behaves strangely in production.
The biggest thing is just to mirror production, and that's what you have tools like Virtualbox, Vagrant, and Docker for. Past that there's a rather heavy concentration of Mac users in Rails.
There's no need for Timecop, Rails now has this built-in: http://api.rubyonrails.org/classes/ActiveSupport/Testing/TimeHelpers.html#method-i-travel
Sounds like you're just double clicking the file in Explorer? Open up a real command prompt and run the script you want manually in that window, e.g. by typing "ruby myscript.rb" in the correct directory. The command prompt won't close by itself if it's opened manually like this.
If you do development using Docker, it's _way_ easier in Linux. On OSX, you have to run a Linux VM through boot2docker and then stuff like host mounted volumes are a pain in the ass. Yeah, they work, but you can't fix file permissions or anything (so if you want to keep Postgres data on your host, well, you can't because you can't set the permissions to be owned by the postgres user) and it's slow due to the files being made accessible through vboxfs. Edit: And I disagree about OS X being easier to set up for development. You have to install brew and stuff and installing a local database like Postgres isn't exactly straightforward (and uninstalling it if you need). On linux, there's no additional package manager to install or anything. There's a lot fewer hoops to jump through to get a good dev environment set up in Linux and Ubuntu is a piece of cake to install. Oh, and an issue I've personally run in to developing on OS X is that the different Ruby versions and stuff I've used add a lot of clutter in /usr/local. Well, the Yosemite upgrade took over 4 hours to complete because of this. A lot of what goes in to setting up a dev environment in OSX is not really supported and upgrading to a new OSX release can be a major headache with things breaking all over the place. I've never really run in to similar headaches in Ubuntu. Now, I'm not saying OS X is a bad OS to develop on. It's my favorite despite the issues I've run in to and inconveniences with Docker, but some things really are easier in Linux. 
Hear, hear! This was similar to my very first Rails dev environment. It was strictly a Windows shop, so I had to hid the fact that I was coding in a Linux VM with a quick close of the Window if management walked past. Ah, happy days.
Download [Oracle VM Virtualbox](https://www.virtualbox.org/wiki/Downloads) for free and use its _Guest Additions_. This is critical. With the _Guest Additions_, you can do stuff like share folders and copy and paste between Windows and your VM. It makes Linux development on Windows pleasant.
Most Rails programmers, I think, want to interoperate with JavaScript, which is enough reason to use JSON. My collaborators use these and many other languages, and most of them don't have a Symbol type, so they wouldn't want or know how to use it if JSON had it. The second problem is that a parser for a data format that can represent non-GC'able data is a DDoS vector. The sender doesn't even have to be malicious to trigger the memory leak, just unaware of the behavior of the receiving system. It turns out that it's possible to have Ruby's JSON [parse all Hash keys as Symbols instead of Strings](http://ruby-doc.org/stdlib-2.2.2/libdoc/json/rdoc/JSON.html#method-i-parse) (`symbolize_names`), but it's not advised for the above reason. 2.2 fixes the leak, and Rails 5 requires Ruby 2.2, so maybe this approach will start gaining traction when Rails 5 comes out. I might be able to start using it in Sidekiq right away. dRuby is a tool that I've admired for a long time but never used. I couldn't use it everywhere because so much collaborating software is untrustworthy or implemented in other languages, but I should look for a place for it.
You can't learn larger-scale design on Project Euler but it is absolutely a great way to gain familiarity with the syntax, semantics, and builtins/standard library of a language. And you might learn some cool math along the way, too. I highly recommend it as a tool for learning any programming language, ruby included.
I haven't had any problems deploying on Linux after developing on a Mac, and the tools on OS X are great. The only thing I will complain about is that whenever Apple upgrades OS X, it downgrades/alters the unix packages that some of my gems need. So its my development environment that suffers the most.
Ruby's fine on Windows. You'll hear horror stories but I learnt on Windows before I'd even used a Mac and didn't have any problems. You only hit issues if you start using third party libraries that use C and need to be compiled. Use the RubyInstaller for Windows found at rubyinstaller.org and you're good to go.
It even looks much more readable by using `expect(x).not_to be_something` or in your example `it { is_expected.not_to be_expired }` 
&gt; TextMate. Anything else is just fluff. :) Sublime Text is objectively better than TextMate in some aspects, like the breadth of the plugiin ecosystem. &gt; But seriously, there aren't any tools (that I know of) that are available on Linux but not OS X Docker? A system-wide package manager? &gt; and having access to more web browsers Safari is barely an excuse for a web browser. &gt; (and on the platform that more end users are likely to use) Irrelevant if you're not developing desktop software. &gt; I just don't see that there's a huge advantage to developing on Linux as opposed to OS X I didn't ask you if OS X was good, I asked you why you said OS X was *better*. &gt; and indeed, a substantial portion of Rails developers do in fact use OS X I'm sure a substantial portion of them use Linux too. Unless you have the number it isn't a meaningful argument. &gt; One of the nice things about Ruby is that insulates you from the metal below. You do have to set up Ruby itself. For example, compiling the Postgres client gem in way easier on Linux than on OS X. `apt-get install build-essential libpq-dev` vs. installing Homebrew, possibly compiling a bunch of packages if there are no binary versions available, messing with the include paths to get RVM or whatever else to find the headers, and later the dynamic libraries, etc. OS X may be Unix, but it doesn't really follow the "everything has it's own place, you'll always find in there" for libraries and code, and Homebrew is not at all a first class citizen. Specially when you find out that every major upgrade will take hours due to copying /usr/local around for no reason. &gt; But Ruby code written on OS X should run just fine on Linux and vice-versa. Given that OS X is a lot easier to set up and use than Linux, Have you used Linux in the last 5 years? Because you can get an Ubuntu flash drive, try to install it in whatever computer you find in front of you, and it will just work in 90% or more of them. Giving you a complete desktop environment, with actual best in class programs in some areas instead of useless Apple versions like Safari, with no hardware tax to pay. &gt; being on the same platform doesn't seem like a compelling reason to develop on Linux as opposed to OS X. Code can and does break while going from OS X to Linux due to Ruby extensions, and some times platform differences if you attempt to use system executables or libraries without being careful. If you have any system you are responsible for you cannot do a production deployment while just testing on OS X. It will absolutely break, and would be irresponsible. &gt; Besides, what distribution of Linux? Any of major 5 (Ubuntu and derivatives, Debian, Fedora, Arch, OpenSUSE) will do. And you can pick based on your preferences instead of loving or hating the Apple UI with no options. And it's a piece of cake to test with whatever version you're running on a server with containers (Docker or LXC), with little processing overhead. &gt; What version? Is it that hard to pick whatever the default is on the download page? It will probably work right in 99% of the cases. I really don't buy those arguments that assume the programmer is devoid of brain cells for even most basic tasks like picking a version. &gt; What if you're hosting on FreeBSD? The chances of that are ridiculously small unless you are the one setting up the infrastructure yourself with BSD. At which point going to a download page and picking a distro version should not phase you. &gt; The truth is, using OS X is really good enough. So your conclusion is just "good enough"? Not "better", as you said previously? 
I compiled a set of resources for learning Ruby, Rails and web development here, hope it helps you: www.developingandrails.com/2015/01/crash-course-on-modern-web-development.html
It's mentioned in the documentation: https://www.jetbrains.com/ruby/help/configuring-colors-and-fonts.html
I actually disagree with cemc. We use vagrant at work for more or less simple installation of dependencies. But really the linux angle of things hasn't really helped us prevent problems at deploy time. Rarely does it help catch an nginx or unicorn issue. Honestly, i think you'd be fine developing on a mac with webrick. I do recommend using the same database software though. Postgres on both for example.
I used to do Rails devving on my windows machine. Basically it worked fine, but there are (or were) a lot of edge cases, especially with tooling. Things like the fact that processes are heavier on Windows slowing down startup and testing noticeably. Also you will struggle to get help with this sort of issue. Now I use a mac book pro, and a Debian VM on the desktop. It's a good combination, and I think there is almost no difference in the configuration at this point. I also do some light windows development in Windows, but not the full stack rails stuff. Ymmv 
I faced the same problem than you and my solution is a windows host + linux(s) VM. 
I'd say yes. Especially if you don't have a mac yet seeing as you can install linux on practically any computer without issue. You could also use Vagrant to set up a quick VM/dev environment, and at that point it doesn't really matter what OS you're running.
I didn't know about monster.vim thanks for that. Do you use resense in vim ? Is it good ?
thanks for looksee. Seems interesting.
…and then you want to go and Photoshop a quick design element and end up using The GIMP and wanting to slit your wrists. You will just spend more time setting up your system to make it mostly usable with Linux than you would with OS X. But if you want to do things the hard way (and I've been using Linux for 20 years off and on and administrated my own FreeBSD server for 15, so I'm no stranger to doing things the hard way) then feel free. Sooner or later, I've come to be just absolutely frustrated with every Linux setup I've used.
Ruby may not be the right choice for the job. Goliath/EventMachine on Rubinius or JRuby are what you'll want for higher throughput on Ruby, and they're not as well supported as Rails/Sinatra. For most of your other questions, read Practical Object Oriented Design in Ruby by Sandi Metz. It's a fantastic introductory book on designing OO software.
2 There's http://jsonapi.org/ 6 Agree. Consider service objects is when your controller method is becoming long (= probably doing too much business logic and not typical controller stuff such as rendering, redirecting, session, etc) and/or dealing with more than one model object. Don't overthink it, you can always extract it from fat controllers/models as you go along. 7 Try http://swagger.io/
1. I recently finished a similar project. We created a rails application that served as the web application and mounted a grape app as the api. I really liked Grape's declarative nature and that I was able to reuse the validation logic from ActiveModel. I would definitely use it again. However, there was certainly some caveats that you should weigh. Grape isn't 1.0 and there are are some problems because of it. I ended up writing some patches to get it working the way I expected and the documentation is lacking. Although I think the API is fairly locked down and there isn't a lot of breaking changes, that's still a concern. I personally would recommend using a standard rails controller since the ecosystem is vast, developers are plentiful and the documentation is great. Sinatra can be a great alternative but there might be some security best practices that I'm not aware of. 2. Heroku publishes a set of best practices they follow on creating HTTP JSON APIs. I found it valuable to reference: https://github.com/interagent/http-api-design. I think they used Padrino (a framework built ontop of Sinatra). 3. Use Rack::Test. Test authentication, status codes and responses. 4. I don't personally feel that way. Some people opt for hypermedia apis but it isn't as widespread. 5. I doubt it. 6. Service objects are a useful abstraction but if you don't feel comfortable using them, write the application first and then refactor out the domain logic later. You might be over optimizing off the bat. 7. Not sure, sorry.
I recently come to Ruby (for webdev with rails) from C++/Qt, so bear with me. Eitherway, I wrote a HTTP server in C++, and I test it usually by doing 1. Have a manually written data packet in a string or something inside the test 2. Call the method which takes such data and processes it. 3. Get the result data, and compare it to another manually written data packet Ok, now you're on the other end in terms of the protocol, I mean, you're a client. I'd actually not do it much differently .. maybe with a twist (I'll use the ARP gem as example): You must be using sockets to communicate with the router. We want to emulate the router in the simplest fashion. The simplest solution that comes to my mind is: Mock the socket or some similar functionality. This should be as deep down as possible, so if you can, mocking the socket itself might be a good shot. If not possible, consider adding an abstraction layer for this. Now we need to simulate the client-server concept of a socket. This is not TCP, but you're the client, sending stuff to the 'server' (the router in your case), which responds to you. Ok, so, you usually send a packet, and get a reply. For more complex operations, you may send another packet afterwards, and get another response. Now we need to simulate this flow. This up there sounds like a flat structure, you send stuff and get something back, so an array should suffice. I'd have an array, with each element being a hash - Let's call this hash 'RequestReply'. (This could also be a class). This 'RequestReply' has two key-value pairs: First *request* and second *response*. So, in your mock, whenever your lib sends a request packet, take the first element in this array, remove the first element of the array, see if the expected request matches the lib's request, and if so, send the response back through the mock. If something unexpected happens, the test fails. Note that both, *request* and *reply* should be manually written by you. Don't use code to compute those. The point is to make sure that you **know** what's expected and is then sent back. I hope this helped?
&gt; I hope this helped? Yeah, probably it did. So let me put it this way. The object in my code doing the communication is SNMP::Manager. Basically, I could build a mock object that responds to same methods (walk, get, etc.) and my tests would use that object instead of the real SNMP::manager. At least the theory is simple :) Checking response/reply pairs is yet the easy part. IRL I also want to create situations in tests where lower layers like SNMP raise exceptions (for example, due to a wrong IP address given to it) and see that my top level code handles those correctly. Simulating exceptions for every possible situation is a slippery road. But again, I'm learning... :) **EDIT:** Oh and yeah, that would not be "as deep as possible", I see now why you talk about mocking the UDP socket. 
You always should try to go as deep as possible to the point where you're sure that the layers under what you mocked-away function properly. So, if you e.g. already have tests for the lower-layer, then it'd be perfectly fine to mock these out in higher-layer tests. The issue if you don't do this is not only that you can't really test things like raised exceptions from those parts. The real issue is that you're not testing certain parts. I'm pretty sure that SNMP has a RFC, which you used to code your gem. You now have two possible approaches. Approach one: You go through the RFC, look hard for corner-cases ("MAY", "COULD", ...), and write tests for all cases including those corner-cases. This approach also works with 'Test Driven Development'. I don't think that TDD is the holy grail that the Internet tries to make it look like, so another approach: Approach two: Go through your code. Try to write a test for each and every branch (if clauses, etc.). This results in that every line of your gem is ran at least once. I lied, because here comes approach number three: A mixture of both. That's what I mostly do. This works well enough to have tests which cover the specification (Which is highly important!) and thus gets you the good part of TDD so to speak, while having to do with your code. How to do get it right is pure experience though. And one more thing: Google for "test suites" for the protocol your code implements. They're not ultra rare, but sadly also not really common. Such test suite does **not** remove the need to write your own tests, but they enhance the quality of your tests by quite a large margin if they're good. And that for doing not much on your end.
Great introduction and has me excited to use the language.
Wait, you are proposing his test kit jump over external dependencies like SNMP::Manager to mock lower level? That seems like crazy talk -- fragile (you don't control those gems), silly (you just care that those gems i/o the expected i/o based on your usage -- either your trust them and their tests or not), ... Why not just mock at his apps level for testing his app and also add in non mocked (but configurable) real world test for his lab for end to end that is also usable (with configuration) for other users of his gem? 
 require "open-uri" def downloadFile(path, url) begin open(path, "wb+") do |file| file &lt;&lt; open(url).read end return true rescue return false end end downloadFile("./images", "my_link") Doesn't seem to work, could you give an example?
omfg it works! I LOVE YOU &lt;3
I think you're using bash-it plugins for chruby, z and fasd. The first issue is that you don't have chruby installed so the chruby plugin can't find it. Either disable the chruby plugin or install chruby. The second issue is you need to disable either the z or fasd plugin since they're not compatible. https://github.com/Bash-it/bash-it
Try http://www.reddit.com/r/elixir
... SNMP::manager is from the 10 year old snmp gem. Either way I believe it is generally considered bad form to jump into other gems space and mock out from under them. 
Check your inbox, but the Stable Marriage problem is what you're looking for. [Wikipedia Entry](https://en.wikipedia.org/wiki/Stable_marriage_problem) 
Pretty and all, but I don't see much of a difference between that and creating a new MetaRuby Subreddit. Or why the creator did it in the first place... it's an honest question, I would like to understand :/
Warning: material can cause denial, anger, bargaining, depression, acceptance, or all of the above. Viewer discretion is advised.
&gt; Either way I believe it is generally considered bad form to jump into other gems space and mock out from under them. Please re-read the first paragraph: &gt; You always should try to go as deep as possible **to the point where you're sure that the layers under what you mocked-away function properly.** So, if you [...] **have tests for the lower-layer, then it'd be perfectly fine to mock these out in higher-layer tests.** I could've been clearer that I meant to 'stop' at the boundary where code is well-tested.
Sinatra runs very well on JRuby. No compatibility issues in 3+ years of running it on our payments API.
Yup, that's fine. It's a normal thing to have in databases: If one Model has a list of children, each of the children will have a reference back to the parent. In database terms: Host has a 1:n relationship with Guest, and Guest has a 1:1 with Host.
The good thing about BB is that he's opinionated. The bad thing about BB is that he's opinionated. I used to respect him as a Ruby thought leader. I think what he says is good for junior devs everywhere. Currently I just respect his work in the emacs community. Being opinionated over there is basically like pissing against the wind.
 puts "Hello, Kiev!" puts "Hello, Kiev!" puts "Hello, Kiev!" vs for i in 1..3 puts "Hello, Kiev!" end vs 3.times { puts "Hello, Kiev!" } vs 3.times do puts "Hello, Kiev!" end vs 3.times do puts 'Hello, Kiev!' end And then it cuts off, but here's a few more: 3.times { puts "Hello, Kiev!" } print "Hello, Kiev!\n"*3 a = -&gt;(n, a) {n&lt;=3 ? (puts("Hello, Kiev!") || a[n+1,a]) : () }; a[1, a] 1) What is his complaint? That a puts statement can succeed a puts statement? 2) He already complained about the for loop syntax. If anything, this is as close to a valid use you can have (other than i being 3 by the end in the outer scope). 3) What is his complaint here? That we can use curly braces to denote a block? 3, 4, 5) Here is the real complaint. These minor changes are all valid Ruby. But I think this is a good thing about Ruby, not a bad thing. Except, each of these (save 3 and 4) are doing different things. They can go in different directions. The first is least flexible. The second gives you the starting point of 1, which doesn't appear in any other implementation except my silly recursive lambda. 4 and 5 differ in whether something will be interpolated. 4 and 6 represent idiomatic Ruby, and they're both perfectly refactorable to achieve some other goal. The beauty of Ruby (to me) is how malleable it is. It makes it a breeze to refactor.
&gt; * MRI is slow. &gt; * There is a lack of collaboration between different core library developers - such as JRuby, Rubinius, MRI, and opinions from the ruby community. &gt; * There is no clear vision for how the language will progress; deprecations and new features are not discussed well, and there is a lack of constructive dialogue. &gt; * for loops are pointless, and the subtle syntax change is slightly confusing &gt; * BEGIN and END blocks are also pointless/bad ideas, and should be removed. (Also, we already have Kernel#at_exit). &gt; * flip-flopsonly have one use, and should be abstracted into a module/something, rather than having special syntax for it. (These may be removed in v3.0) &gt; * Block comments (=begin ... =end) should be removed &gt; * Single character literals (?a) are (since v2.0) pointless, and should be removed &gt; * Core library aliases (e.g. collect == map, inject == reduce, ...) are unnecessarily confusing &gt; * autoload sucks, and will be removed in ruby v3 &gt; * Sets are not part of the core library, which is disappointing &gt; * defined? returns a string, not a boolean &gt; * Kernel#% is a confusing method name; we should use Kernel#format instead &gt; * Ruby documentation has lots of important bits missing &gt; * Much of ruby standard library has poor APIs/is unmaintained, e.g. net/http Agree 100% with the points above, but I think he got it wrong on the points below. &gt; * Proc objects have no arity checks and non-local returns, making them error-prone. Only lambdas should be in the language. I would assume procs exist because everything is an object. Being able to instantiate a proc is a good thing. One of the most annoying things about python is that slice syntax cannot be used to instantiate an object. &gt; * The single-quoted strings vs double-quoted strings argument is a waste of time. Stop talking about it. &gt; * Some literal syntax, such as %q{...} vs %Q{...} are unnecessary and should be removed. We should just have one way of defining such things. There is a very good reason for the differentiation between single and double quoted strings: interpolation and escaping! `''` is the equivalent to python's `r''`. Ruby's syntax here is far superior - in fact it's one of my favourite language features. &gt; * or, and, not are not flow control operators (contrary to popular belief), have strange precedence, and are fairly pointless - these should be removed. Agree that `and` and `or` should have differing precedence, but I think that these operators are very useful for writing control flow code in a readable way. &gt; * Mutable strings are very weird (virtually no other language does this) ... but there *are* immutable strings: they're called symbols! Mutable strings are often handy. &gt; * Class variables have very weird behaviour when used with inheritance; just use class instance variables instead I don't understand this argument. They are used for very different things, and both are useful. &gt; * Poor naming choices, such as Kernel#puts rather than Kernel#put_line, and include rather than includes `puts` is very standard. e.g. in C. &gt; * Perl variable names ($~, $&amp;, ...) should be removed &gt; * Perl style Regexp interactions are not what you'd expect from an OOP language. Variables like $~ and $1, are bad; Regexp.last_match[0] is better, but we should really only deal with the MatchData object These are useful for command-line Ruby scripting usage. &gt; * The new "idiomatic" hash syntax ({key: 'value'}) is confusing It covers an extremely common use case: interned strings as keys to a Hash. How is it confusing, when it helps people avoid using string keys? &gt; * The ruby source code (written in C) is difficult for ruby developers to understand. This is not a good argument to use something else. &gt; * Rails is overly dominating the community. It is dominant, but I don't think that is inherently bad. We just need *more* "killer apps" like Rails! &gt; * There have been few notable features added to ruby since version 1.9 I disagree. Keywords, refinements and even performance is a feature! &gt; * In general, there are far too many ways of solving the same problem. (e.g. "Print this string 3 times") &gt; * Re-assignable constants are a terrible idea, why does ruby do this?! Re-assigning a constant *does* still warn, but it lets you do it anyway. I think this flexibility is one of Ruby's great strengths! 
Hi Elfenars, I posted our backstory here http://metaruby.com/t/welcome-to-metaruby/21 With regards to your specific question, I think a number of things. The most obvious is probably personality and culture. Reddit has its own... and so does every other forum (or other similar platform) out there. MetaRuby aims to be a friendly forum for grown up discussion - sometimes a little cheeky, sometimes serious. It's the community at MR that will define it, though hopefully our ethos will help shape that into something that we all want to be a part of. Hope that helps :) 
Thanks for posting. I am the developer of this app. I will be happy to answer any questions and appreciate any feedback.
My gem doesn't show up when searching for the keywords service now, service-now or ServiceNow (https://rubygems.org/gems/rs_service_now/versions/0.0.3) Sometimes your page displays "No results found" but then updates with some results. Also the "No results found" page has a stray S after the message.
Stray 'S' is now fixed, thanks for pointing it out. It fetches the results as you type so if there are no results for the initial keyword it says "No results found" and then shows the results if available as you change the keyword by adding/removing letters/words. It looks like your gem is fairly new so it is not included when I last synced from Rubygems.org. It will be included after the next sync. I intend to automate the sync to be a weekly/bi-weekly process. 
it's not that new, but thought I'd point it out. Thanks.
Do you have any statistics on the performance of this versus a google search for "ruby gem #{keyword}"?
Good lord. The man was right.
take a look at the [concurrent-ruby](https://github.com/ruby-concurrency/concurrent-ruby) project. they're making a master list of concurrency libraries for Ruby and its shaping up quite nicely. at the very least, it can help Rubyists get a feel for different concurrency paradigms if we choose to shift over to another lang.
it would be great if you could sort it by most recently pushed gem. I don't need to see top hits that were last contributed to 4 years ago. 
Good suggestion! I will add 'days since last updated' to be one of the ranking signal.
Ahh, more of the same old "perl stuff is scary" nonsense. Maybe "and" and "or" are too dangerous, but %Q{} is really valuable and Perl magic variables for regexps keep simple things simple. 
Excellent, thanks for the response.
Brilliant responses. Thanks for your time. Specifically the best practices guide from Heroku and warning about Grape was really helpful. By any chance, do you know whether Sequel plays nice with Grape?
Great many pointers to research! Thanks! I think your answer is tending to make me lean toward Rails API, though Grape looks nice. Remarks about caching during authentication is noted, any chance you came across any patterns/resources you may want to recommend? Polling: I am unsure about the value of providing changed data. Do you mean the advantage in being able to reduce size of payload? Do you think it needs to weighed in if each request is fairly lightweight? JSON expressions: Thanks for this, I wanted some proper pointers for testing as this will be my first real big project where I will be using these skills. JSONAPI specification: I skimmed through it; one subtle aspect about its annoying me! camel casing every key! Its quite sad, but do you know any solution for converting a snake case hash into a camel case JSON?
Its now version 1.0; seems pretty stable, right?
Have been looking to read POODR for long; may be I will before starting the project. Thanks for the pointers, will be seeing the RubyConf talk on Goliath.
Having it run on JRuby increased its capability significantly? Is there any downsides in switching to JRuby?
Sure, will read! Thanks :)
This seems to greatly work! Thank you! Basically what I was trying to do was clean up a file cause it is output from an API filled with a ton of junk x 1000. What would actually be a real goal for me is to make it look through each line, and if somewhere in that line it says "MEOW" then I want it to go back and search the last 20 lines before it for a line that says "PUPPY" and then paste the rest of that line into a new file. And so forth for the rest of the file. Any way you can modify the above code for that? Seems like a tiny bit of work but I have reddit credits and can gift you more reddit gold for that.
&gt; flip-flops I'd tend to think I've been deeper into Ruby and MRI than most and I have never even heard of this 'feature' before. It's...interesting...I guess. Is it really a problem? I've written and read 100k's of lines of Ruby at this point and I've never seen it.
Yup, thx. 
&gt; I've never seen it. One more reason to remove them! If no one uses them nobody will miss them and removing unnecessary things means removing unnecessary complexity.
I use that form all the time. It is simply the shortest form that allows using both ' and ". There are some ways to abuse it though, that I wish didn't exist: \&gt;\&gt; % This is a one line string [another empty line. Dunno how to escape those] =&gt; "This is a one line string \&gt;\&gt;
Yes, I am looking to authenticate users via oauth2 (Facebook &amp; LinkedIn); will checkout the doorkeeper gem. Thanks :)
Wow, I get it now and learning a lot here. Looks beautiful!!
Let me see, perhaps I need a more detailed research.
No, but you might be prematurely optimizing the stack. I would stick with Postgres, Sinatra/Grape/Rails API, Sequel (Or ActiveRecord), and maybe Redis. You can use Postgres's full text search. If it's too slow, try caching or changing the index type first. Docker is cool but I don't know if you need reproducible builds quite yet.
Damn silly 10-years noobs, go open Dictionary and find the word Microframework. Fucking degrading industry of coding produces those ones who think, that HTTP-servers == Programming.
here! http://pastebin.com/0Hp4LNT7 thank you!
Shallow, opinionated, unfounded and deeper context lacking talk. Rather political and entertaining then technical and constructive. Bozhidar's ego inadequate big to what he did really created and can show off. Waste of time watching the video, if you'd ask me. Not denying current referential Ruby implementation and stdlib miss serious parallel and asynchronous programming support, but the situation is similar at comparable CPython, PHP or Perl. Matz and the Ruby core team seem to do the right job despite occasional whining here and there. The Ruby is continuously improving and evolving (see Py2 → Py3 transition debacle), still keeps significant share at web development solutions and lot of available paid jobs. There is nothing him or anybody else would prevent improve code of his favorite implementation and issue pull requests. After being proven, he can even speak more into further development. This would however require some greater skills and balls most are unfortunately missing. Only plain blaming remains to them …
yes, that was my mistake :/, they are in the original file
I've updated it to explain what I'm doing. 
So you say /r/ruby is a fun-club of retardness and using words meaning of which you don't know? I thought it is about Ruby.
You are right, that wikipedia says microframework == http shit. But the fact, that this word got this meaning is ridiculous according to https://en.wikipedia.org/?title=Micro https://en.wikipedia.org/wiki/Software_framework You are wrong, that people should be let do whatever makes them happy. Especially when you say it is somehow related to that they aren't children. Because it is totally childish if one starts posting cats and Minecrafts videos to /r/Ruby just because it makes him happy.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Software framework**](https://en.wikipedia.org/wiki/Software%20framework): [](#sfw) --- &gt;In [computer programming](https://en.wikipedia.org/wiki/Computer_programming), a __software framework__ is an [abstraction](https://en.wikipedia.org/wiki/Abstraction_(computer_science\)) in which software providing generic functionality can be selectively changed by additional user-written code, thus providing application-specific software. A software framework is a universal, reusable software environment that provides particular functionality as part of a larger [software platform](https://en.wikipedia.org/wiki/Software_platform) to facilitate development of [software applications](https://en.wikipedia.org/wiki/Software_application), products and solutions. Software frameworks may include support programs, compilers, code libraries, tool sets, and [application programming interfaces (APIs)](https://en.wikipedia.org/wiki/Application_programming_interface) that bring together all the different [components](https://en.wikipedia.org/wiki/Software_component) to enable development of a project or solution. &gt; --- ^Relevant: [^Apache ^Gora](https://en.wikipedia.org/wiki/Apache_Gora) ^| [^AVFoundation](https://en.wikipedia.org/wiki/AVFoundation) ^| [^Application ^framework](https://en.wikipedia.org/wiki/Application_framework) ^| [^Computing ^platform](https://en.wikipedia.org/wiki/Computing_platform) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cs93bjk) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cs93bjk)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](/r/autowikibot/wiki/index) ^| [^Mods](/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Call ^Me](/r/autowikibot/comments/1ux484/ask_wikibot/)
Edited the code and I now have this: http://pastebin.com/FkkUQL4v But it still leaves the "number:" in the url for some reason.
I think you should be able to use [.split](http://ruby-doc.org/core-2.1.0/String.html#method-i-split) for this. Example: "1: mouse".split.last If you still want to use gsub then what you need is a [regular expression](https://en.wikipedia.org/wiki/Regular_expression). Example: "1: mouse".gsub(/\d+: /, '') 
nevermind! All fixed!!! Thanks again!!
VERY USEFUL. Thanks!!!!!
&gt; Mock the socket or some similar functionality. This should be as deep down as possible, so if you can, mocking the socket itself might be a good shot. If not possible, consider adding an abstraction layer for this. .... &gt; Now we need to simulate the client-server concept of a socket. This is not TCP, but you're the client, sending stuff to the 'server' (the router in your case), which responds to you. Ok, so, you usually send a packet, and get a reply. For more complex operations, you may send another packet afterwards, and get another response. Now we need to simulate this flow. This up there sounds like a flat structure, you send stuff and get something back, so an array should suffice. I'd have an array, with each element being a hash - Let's call this hash 'RequestReply'. (This could also be a class). This 'RequestReply' has two key-value pairs: First request and second response. So, in your mock, whenever your lib sends a request packet, take the first element in this array, remove the first element of the array, see if the expected request matches the lib's request, and if so, send the response back through the mock. &gt;If something unexpected happens, the test fails. &gt;Note that both, request and reply should be manually written by you. Don't use code to compute those. The point is to make sure that you know what's expected and is then sent back. &gt;I hope this helped? ... &gt;You always should try to go as deep as possible to the point where you're sure that the layers under what you mocked-away function properly. So, if you e.g. already have tests for the lower-layer, then it'd be perfectly fine to mock these out in higher-layer tests. &gt;The issue if you don't do this is not only that you can't really test things like raised exceptions from those parts. The real issue is that you're not testing certain parts. &gt;I'm pretty sure that SNMP has a RFC, which you used to code your gem. You now have two possible approaches. &gt;Approach one: You go through the RFC, look hard for corner-cases ("MAY", "COULD", ...), and write tests for all cases including those corner-cases. This approach also works with 'Test Driven Development'. I don't think that TDD is the holy grail that the Internet tries to make it look like, so another approach: &gt;Approach two: Go through your code. Try to write a test for each and every branch (if clauses, etc.). This results in that every line of your gem is ran at least once. &gt;I lied, because here comes approach number three: A mixture of both. That's what I mostly do. This works well enough to have tests which cover the specification (Which is highly important!) and thus gets you the good part of TDD so to speak, while having to do with your code. How to do get it right is pure experience though. &gt;And one more thing: Google for "test suites" for the protocol your code implements. They're not ultra rare, but sadly also not really common. Such test suite does not remove the need to write your own tests, but they enhance the quality of your tests by quite a large margin if they're good. And that for doing not much on your end. Where the OP links two gems he wrote which if you look at them he requires the long released and unowned by him snmp gem. 
I don't know what's cooler, street fighter in ruby, or git-wayback-machine. In any case, there's a lot of cool in this video.
You don't use Mechanize to save the images. If you have the URL, you can save them directly. Open the image; read it; write that data to a file opened for binary writing, like so: require 'open-uri' File.open('shades_goat.jpg', 'wb') do |f| f.print open('http://i.imgur.com/19qN2YZ.jpg').read end
See the comment above, he meant removing %{} since %{} and %Q{} are the same.
https://code.google.com/p/selenium/issues/detail?id=8596
Indeed. And if it does not use blocks and instance_eval, what does it use instead that is so much better? I like blocks. I don't want to miss them. Granted, eval is evil. The article does not provide answers and even worse it does not hype me to bother getting the answers myself :/
Guys, guys, come down, I'd say you both have made your point and I have gained from the argument, because I've had opportunity to think it all through. Anyway, looking at the same mentioned snmp gem source, you see how UDPSocket has been wrapped into UDPTransport class. I think this is what I need to do first - wrap the `SNMP::Manager` into my own class, let's call it `SNMPTransport` and then have two versions of that class - one for testing, one for actual work. The only thing is that the methods in the testing `SNMPTransport` (`walk` and `get` in my case) have to return rather complex SNMP::Response and whatnot objects, not just strings etc. **EDIT:** Oh wait! The disassembly of those SNMP::Response things should be put into the wrapper class too so that my `Arpdb::Arp` class would not have to know anything about those objects. `SNMPTransport#walk` should return an array of rows and `SNMPTransport#get` should return just String. **EDIT EDIT:** And to be even more cool, the `SNMPTransport` could be "dependency-injected" into the `Arpdb::Arp` so that no additional work is needed for substitution.
Awesome! Great to see people using Ruby outside of the web. How was your experience with Gosu?
It uses blocks where it makes sense, not overuses them :) Blocks is an awesome part of Ruby.
So unless I'm creating websites I don't need Rails?
By making config a module, you are executing potentially untrusted code every time you load a config file. This is why we have config file formats like YAML.
Either OSX or a Linux distro.
To confuse those who can't even I suppose.
I had this as my code browser.find_element_by_xpath("//*[@id='dashboard_posts_editing']/div[9]/div[2]/div/ul/li[2]/span") 
From this post you get an idea about the exact XPath expression. For the exact method you should explore the Ruby Selenium docs.
&gt; I could've been clearer that I meant to 'stop' at the boundary where code is well-tested. Completely skipping clarifying comments of me. I'm done with this. Cya.
[RubyMonk](https://rubymonk.com/) and [The Odin Project](http://www.theodinproject.com/)
What did you use to build the front-end?
Twitter Bootstrap.
Yeah... I've tried that but it's not working.
Hello, FYI: I’ve updated the Awesome Ruby Events list that collects Ruby events (meetups, conferences, camps, etc.) from around the world. New entries include: Ruby Vietnam, RubyDay Italy, ROSSConf Berlin, RubyConf Colombia and many more. Anything missing? Contributions welcome. Cheers.
The talk is divided into two parts - past and future, the future starts at https://youtu.be/bqWBB8-iEac?t=1463
In which data structure would you want to store the lines ? This example stores it in an array u_words = [] File.open("temp.txt").each_line do |line| u_words &lt;&lt; line.strip if line.strip.include? "_u" end puts u_words this .strip removes the newline character "\n"
When my Sinatra app got too complex.
[example yaml](http://www.yaml.org/start.html)
Yeah I think people that blindly trust yaml tend to forget it has pretty powerful serialization in ruby -- its not simple stupid data.
ruby -&gt; the programming language rails (ruby on rails) -&gt; a framework on top of ruby to build websites did you see the answer?
That's not the correct syntax for a method definition. The error tells you where the problem is (line 3). To define a method without arguments you simply do this: def copy_unique_lines # method body end If you want to have arguments you can do it like this: def copy_unique_lines(argument1, argument2) # method body end Notice how the argument names are not strings. If you want to define default values for your method arguments you can do it like this. def copy_unique_lines(argument1 = 0, argument2 = 0) # method body end 
I think they might be new in ruby 2.2.
Thank you!!
I find it funny that you get rails working on a windows pc and have trouble getting it going on a mac. Usually it's the other way around :D
Haha I heard the same! I also posted this thread earlier which convinced me to get a Macbook Pro: http://www.reddit.com/r/ruby/comments/39vgew/coding_w_ruby_on_windows/ But I'm just so used to Windows that the folder management, and smaller details feels easier for me..
Don't worry, you will get used to it. RoR runs much faster on OSX/linux
I am doing this off memory, on my phone, so bear with me. First, install Homebrew: http://brew.sh, then enter: brew install rbenv ruby-build rbenv install 2.2.2 rbenv global 2.2.2 gem install rails rbenv rehash rails new mynewapp Hope that helps!
This. Homebrew is a must. rbenv is a must. If you have a repo already, skip the rails install, and gem install bundler instead.
You can use virtual environments like koding or nitrous. They include most of the stuff you need to get started developing in ruby and on rails
Also: brew install rbenv-gem-rehash rbenv-binstubs
&gt; rbenv or rvm is a must. FTFY.
Thanks, it makes sense. I think the decision for using Elastic search and Redis can be deferred. But I think going with Docker from the beginning is better right? I could confidently deploy once I am a bit into the development without much incompatibility issues. 
&gt; http://pastebin.com/aRsdxZvK when I replace it with begin I get an output error saying copy_unique_lines is then an undefined variable though :/