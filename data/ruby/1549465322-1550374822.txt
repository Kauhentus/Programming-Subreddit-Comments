Hmm... no idea. I flew to Docker after my dev env crapped out (weird combo move of Mojave install and brew upgrade). When I got back to coding on the host OS all the rubies were borked like this. The gem installs were also out of whack, everything with binaries complaining about needing to be re-installed pristine, but I'm such a noodle I just grep'd the error messages `bundle install` generated just to grab the 'gem pristine [gem name] --version [gem version]` part of the error message. I was tired... :) But, like I said, may have just been a coincidence. Any case, glad you're up and running again. 
Ditto! :-)
Weird. Yeah, I've had some strangeness with mojave, brew, rvm, etc all playing nicely. If I didn't need ruby to use rubymine, I might move to a docker type thing.
Indeed, much like Rails one of the great things about Ruby is that it is 'boring' at this point. In many ways the same could be said of Python but as mentioned elsewhere on the thread there are more users from outside the usual dev audience with Python and more people who are taking it up as an intro language.
Yeah I agree the userbase might be different. After all csharp also has a low pop compared to something like elixir. Only java,python,javascript do not surprise me as they are huge.
Well, honestly. I'm at work most hours and not actively browsing reddit. Being gainfully employed as a software engineer working on Ruby does tend to mean I don't spend as much time on the reddits. Also, I'd say much of the marketing hype tends to scare people away these days despite the vibrant and thriving market of Ruby engineers, internet hype will do as internet hype does.
nice to be part of the employed gang!
Does pry work? Understandable to use irb if you're in production or on a server, but pry is so vastly better than irb there's no reason not to use it. Give it a shot! It's life changing.
I didn't read all the responses, but, this is indeed the reason I'm not frequently active here.
Docker is OK, once you get it up and running, but attaching to it so you can drop into pry or whatever when debugging can be a hassle. It's also a bit resource heavy on Mac. The upside is obviously being able to pull up (and throw away) complete environments without trashing the host OS. I'm still unsure if it's ideal, and have gone back to developing on the host OS directly (now rbenv, brew, etc are all behaving) for day-to-day coding and using Docker for personal projects. Still trying to figure out where I want to go. Apparently you can remotely debug Ruby apps in Docker using RubyMine. Not sure if this is any use: https://bzzt.io/posts/running-the-rails-debugger-in-a-docker-container-using-rubymine
Silently winning
Ruby feels like it sits better with programmers with more skill. They know how to find what they are looking for. Python is more often used as a beginner language, which explains why it has more users.
Not everyone besides yourself is an idiot HardLuckLabs. I am not talking about the addons from ActiveSupport. The Ruby standard library is mostly convenience methods. Take a look at any change log from Ruby 2.0 and on. They're full of simple convenience methods.
Blocks and yields are exactly the way that loop functionality works. This is not abusing them. It's using the tools properly. Again, you're trying to insult me. It is pretty clear I understand blocks and how to program in Ruby. I don't care how old you are or how long you've been writing a language. These are crutches used to demean other programmers who were born after you. I think you'll also appreciate that both Java and Ruby look and work radically different than in 1997 and 2004 respectively.
Writing ruby code
so which is it, now - changes since 2.0 or the entirety of the stdlib that's full of convenience methods? 
Same here
Busy making money?
The way guys like you contribute to our craft is by forcing others to rewrite your code in a different language. Keep up the good work, Sir. 
The Silent Majority Stand With Matsumoto
Can also confirm: Have been building a large production backend for almost the past year.
Where do you see the # of currently online users in a sub?
Eloquent Ruby, latest edition. &amp;#x200B; As for Rails specific, most helpful for me was reading the Rails documentation, using Rails for a project I had in mind, and reading source code of large open source Rails applications like Redmine, Gitlab, [RubyGems.org](https://RubyGems.org), and Spree.
Interesting analysis.. The fact is that Reddit is just a place where we can talk, not only somewhere to "lost" time... So basically IMHO it should not be incompatible to be even when working.. Maybe, there's less to say about ruby...
Python is now the defacto learning language. So, you'll always have newbs asking questions about it. Once you know Python, learning Ruby will be easy so you'll have fewer questions.
In that sub page on the right side (near the subscription buttons...). There are the numbers of subscribed users and the current online users..
Nope... Because you're right here counting in the online users count... Basically it's not incompatible..
How about FaaStRuby? üòú
&gt;Eloquent Ruby There is only one edition of that book and it is 8 years old. Is this book still relevant after 8 years?
It can run any Ruby. If there‚Äôs demand for JRuby, I should be able to just turn that on. 
Lol) Elixir has 12k subscribers and 5 to 10 live projects in production))
What about it?
Got late =(
The Well-Grounded Rubyist is my go-to.
[POODR](https://www.poodr.com/) is great once you know the language well enough and are moving onto higher level program design.
Agreed and, specific to Rails, I'd say that "The Rails 5 Way" gives a pretty good overview of Rails.
I am looking into the old edition of this book and found it interesting. The new edition of this book gonna come soon. Might buy the new edition. 
All of the pragmatic Ruby books are great... I'm working on the refactoring one now.
[The Rails Tutorial](https://www.railstutorial.org/book) This is the holy bible for everyone getting started in Rails development - it might be a bit below your knowledge level, but the chapter Rails Flavored Ruby is a great way to learn the parts of Ruby you'll need to jump-start Rails dev. It's free and online so it doesn't hurt to have it in your back pocket!
i've been eagerly awaiting some tutorials on ruby and lambda (i've already written several python lambdas). thanks for posting!
My favorite programming book! Sandi is brilliant. I've read it through twice... probably due for another go
Happy to hear. You‚Äôre welcome. Hope they are helpful. üëç
i would say probably not worth it unless you're just checking it out from the library. Although a lot will probably hold true, TBH ruby moves too fast to use an 8 year old book reliably. 
Leverage your local library if possible. It shouldn't be too much of a culture shock TBH. Most likely shocks will come in dynamic typing and the need to write specs/tests to do something that would be a type declaration in Java. Tests are not the end all be all but are much more necessary in ruby than most languages. Basically tests equate to code confidence. Other notable mentions are: \- in ruby everything is an Object, even Nil, false, true. \- ruby has implicit returns, last thing evaluated gets returned, this is how I recognize most java devs that converted to ruby \- a ton of enterprisey rails development is re: devops deploy stuff, so you may already be ahead of the game if you know some of these \- learn the difference between when you're interacting with an ActiveRecord query (lazy loaded database relation) and when you drop to a plain old ruby objects
\+100 on anything Sandi writes/declares. IMO one of the most sane ruby developers out there. You can learn a lot from her. 
Have the first edition sitting next to me as we speak, great little (*cough* 240pg *cough*) read
Yesss Sandi Metz is my Oprah
It's not a book, but [RubyTapas](https://www.rubytapas.com/) is 100% worth the subscription. Even at just one ep/week, the archive is huge so there's no lack of content.
&gt; ruby has implicit returns, last thing evaluated gets returned, this is how I recognize most java devs that converted to ruby Yap, learned that thing a few days ago. thanks for the suggestions. I am fairly a quick learner. I did some small python scripting work before for my personal stuff, so dynamic typing is not a big shock. Just need to get used to it. Any IDE suggestion for personal work in Ruby? I heard RubyMine is really good but it's not free. 
It's cool! The contents are interesting and read well. I am looking forward to the completion of the book.
Hey /u/toungueroo! Awesome work on the framework! I've been working on a proof of concept that uses Jets to orchestrate some scheduled marketing features on my company's application and I have a couple of high-level questions: 1. Is there a way to directly configure an application/stack's **VPC** (not **vpc_config** which includes a security group and subnet ID settings)? 2. I'll need to create some functions that will need to be called when a message is received on a FIFO SQS queue - any suggestions on how to implement this as a Jets::Job or should I look elsewhere? Thanks!
Something to discuss! :)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/ruby] [Good book for experienced developer, please?](https://www.reddit.com/r/ruby/comments/anw34m/good_book_for_experienced_developer_please/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
&gt;RE: Awesome work on the framework! I've been working on a proof of concept that uses Jets to orchestrate some scheduled marketing features on my company's application Awesome üéâ &gt;RE: 1. Is there a way to directly configure an application/stack's **VPC** (not **vpc\_config** which includes a security group and subnet ID settings)? Unsure if there's a way to configure only the VPC itself because the Lambda function needs to know the subnet to use. So believe with Lambda you must configure a vpc\_config with the subnet\_ids at a minimum. With Jets, you can configure the vpc\_config application-wide though in the config/application.rb. So this setting will apply to all the Lambda functions. Something like this: Jets.application.configure do config.function.vpc_config = { security_group_ids: [ ... ], subnet_ids: [ ... ] } end Docs: [http://rubyonjets.com/docs/function-properties/](http://rubyonjets.com/docs/function-properties/) &gt;RE: 2. I'll need to create some functions that will need to be called when a message is received on a FIFO SQS queue - any suggestions on how to implement this as a Jets::Job or should I look elsewhere? Thanks! Sure. SQS events are not yet supported. You can probably do achieve it with an [Associated Resource Extension](http://rubyonjets.com/docs/associated-resources-extensions/) but will be some work. Will add support for SQS events. Unsure when. Definitely, want it though. In terms of looking elsewhere, been suggesting folks with questions go to [https://community.rubyonjets.com/](https://community.rubyonjets.com/) to hopefully help others find them in the same place.
I liked the http://poignant.guide/book/
Maybe Russ Olsen's [Design Patterns in Ruby](http://designpatternsinruby.com/)? I assume coming from a Java world you're familiar with GoF patterns. Olsen's book might help map concepts you're familiar with over to their equivalent Ruby. The book won't help with Rails as such, but it does step you through a lot of the idioms present in Ruby applications. 
I like RubyMine, but I liked sublime, Textmate 2 and atom as well.
what is the difference between this one and POODR?
&gt; - ruby has implicit returns, last thing evaluated gets returned, this is how I recognize most java devs that converted to ruby I always do the returns as well, but just for clarity. I did learn Java @ the university though. Is it considered cleaner to remove the return?
Will disagree a bit. The thing that Eloquent Ruby does is tell you how to write good, idiomatic Ruby. That (in my opinion) is the most important lesson for any experienced programmer
Will disagree a bit. The thing that Eloquent Ruby does is tell you how to write good, idiomatic Ruby. That (in my opinion) is the most important lesson for any experienced programmer
Thanks man!
POODR is more about coding in the small: how to design well-crafted classes, messages as the cornerstone to interface/class interaction design. Olsen's book is more about larger granularity architectural models. It also has a section outlining the basic building blocks in Ruby. An interesting takeaway from Olsen is how we don't need or use a lot of the GoF patterns, as some of the original are workarounds in C++/Java that we just don't have to worry about in Ruby. But I digress. Sandi Metz's POODR book is great BTW. These two books are what I recommend to anyone with a coding background coming to Ruby. When you've gone a bit further you may want to check out more of Sandi Metz's work. Her (99 Bottles of OOP)[https://www.sandimetz.com/99bottles] is an excellent treatise on refactoring in Ruby. And welcome to the Ruby community. I'm currently working with an ex-Java coder who swears he can never go home again. :)
Slightly offtopic: Do you know Crystal? (https://crystal-lang.org) - Fast as C, slick as Ruby
I think it's probably fine, there are some new things since 2.1, but the vast majority of what it teaches you will still be good code. 
When the question is, "which Ruby book should I read while strung out on psychedelics?" :) Ah... I miss _why.
2.1 is still plenty recent enough.
It's fine.
Great, all-around, well organized Ruby resource. I find the patterns section super valuable. 
Downvoting for language and for not providing any sources in support of your statements.
I've never really found an IDE brings enough to ruby to justify the overhead/complexity. A coworker uses rubymine and I've heard good things about it too. I just use sublime text but have tried atom and Visual Studio Code, they all use the same keybindings and have similar plugins though the main difference being VSC and Atom are built on Electron.js and ST is C#. 
Do you also do cross platform GUI stuff? If so, what's your Ruby toolset?
I've seen there's a new ML library for Ruby which is built on TensorFlow foundation. Can't recall the name ATM, sorry. Anyway it looked like a very ambitious project. I advise to look for it and check it out. 
You beat me to it. The book is enjoyable to read and explains Ruby so so well. You will appreciate some of the content as a Java developer with the way he labels ideas. Seriously, I could not recommend this book enough.
It honestly surprises me to no end, on how mailing lists are still a thing. Old-forms of communication never die.
Again... Not sure why people place Python as the easier language to learn compared to Ruby..... My old man(ish) attitude looks a Python code and thinks: "yuck".
Not true, if Ruby interpreter itself keeps improving. Also, I'd be curious to see how would mruby perform on wasm... 
yes and no... Yes: do modularize your code respectively if you have redundant methods, actions, ect.. No: Don't over complicate your code base. A problem I see constantly in the Elixir's communities, is how they over complicate code-location and modularization practices.
I find ruby is too often associated with rails, where as python not so much with Django, rails is the hard part, whereas Django isn‚Äôt so bad.
You would probably want to set up an active record relation, you can do it a bunch of ways (like a join table that contains relationship type ids and two people ids) or if you want to really stick with just one table you can maybe do a foreign key on the person object to be another person object like class Person &lt; ActiveRecord belongs_to :mother, class_name: "Person", foreign_key: :mother_id end Check out https://guides.rubyonrails.org/association_basics.html#self-joins
I still consult the Pickaxe for 1.9 without issues, but I think earlier than 1.9 would cause problems. 
Try "metaprogramming ruby"... There are many great books about ruby.. I was also a former embedded developer and Ruby gave me a aha-moment to be honest.. Despite I practiced also Java, the OO-ness of ruby is just amazing.. Any books that will teach you idiomatic ruby and also metaprogramming will be gooa
Michael Hartl's book is the best one. Try this out [https://www.railstutorial.org/book](https://www.railstutorial.org/book)
This isn‚Äôt a book recommendation, but I‚Äôve worked with a lot of java devs who were picking up ruby for the first time and a very common stumbling block is the shift from IDE based development to repl/console based development. Ask a team member to walk you through their console tool and learn it. It‚Äôs how you will do things like, ‚Äúwhat methods can I call on this object right now‚Äù, or ‚Äúwhere is the source for this method‚Äù, etc. 
seriously thorough, free, good stuff here: https://launchschool.com/books
Hey there, I'm looking to do something similar in my game, would it be all right if I contacted you about it?
Agreed. I've been working with Ruby at my day jobs and beyond since 2008. I never got around to reading Eloquent Ruby, even though I picked it up around 2012. Recently went through it, picked up at least a couple of pieces of information and the way that Russ frames some of these concepts is truly fantastic, even with the experience that I have.
Extracting a function to another file is refactoring 101 and can improve readability of very large files, but ultimately you're just redistributing the junk. Eventually it becomes hard to find. See also: service objects &amp; concerns. I'd definitely advise everyone to read the Sandi Metz mentioned at the end, which will lead you to a more sophisticated view of how behaviour arises from the composition of objects. 
One way to model is to have a Person model which just stores individuals and this model will has_many :relations. The Relations model will be basically a join table for Person with itself but will also store the relationship_type as a column. The restrictions on parents can be modelled as validations.
your json looks fine: `JSON.pretty_generate(@user)` ```=&gt; { "test": { "test@gmail.com": "password123", "tasks": { "First": "Create your first task!", "added": "Fresh task" } } }``` for writing to a file i typically do this: `File.open('Storage.json', 'w') { |file| file.write(json) }`
If I do it for multiple objects (just call the function 2-3 times) there is a JSON formatting error :( I‚Äôm going to see what trying it your way does
you'll want to build one hash and generate json once
Awh man. Because I‚Äôm stuck to this online IDE I just wanted to use JSON for a little DB to create accounts and CRUD a task list for 1-10 separate accounts 
There's a lot of functionality that sentence.. could you break your need down a little more specifically? 
I just want to store my Ruby Hashes to a text file, and be able to read/edit them later on. I figured JSON would be the best way.
Your data structure is a binary tree mixed with a bit of graph theory. I don't want to distract you from your learning journey however I think it's important to at least let you know so you can come back to researching it later... Though you can fudge it into a relational the problem is not really a suited being solved via a classic RDMS. A graph db like Neo4j would work much better for modelling this data and if it was in a professional setting I would expect you to choose a graph db or at least to explore it's merits against your RDMS. 
yeah I loved "metaprogramming ruby" that was a good book. :)
You can store multiple hashes an an array and write that out, or append additional elements at any time. Would that work?
Hmm..personally. I‚Äôm not sure. Very new. I‚Äôll definitely look at using arrays tomorrow. 
This is really helpful, thank you! I think I‚Äôm going to do the join table as it seems to be a standard in genealogy software.
I think this is exactly what I‚Äôm going to do. Thank you so much!
I‚Äôve never even heard of a graph database...I‚Äôll add it to the research list. Thank you!
Of course! Though replies will be a bit slow, as I don't receive reddit notifications on my phone.
Awesome, thanks guys! Excited to start learning
I just avoid classes altogether :-)
Where Junk is the byproduct of apps that use a couple of hashes as their data model from birth, generally constructed around the author‚Äôs fetish for a new language feature. If building a car was the goal, you‚Äôll often find objects for the windshield, doors, and the wheels and then a sprawling nested hash for the engine with a god class or module to make it all work. 
 Go has gained a lot of popularity for the same appeal, but the thing is that you still need a good set of Structs from which to start hanging functions from in the code. 
&gt;ore my Ruby Hashes to a text file, and be able to read/edit them later on. I figured JSON would be the best way. Be aware that Ruby has a built in serialization tool called Marshal. In your example here, it's as simple as calling Marshal.dump(@user) See more [https://ruby-doc.org/core-2.6.1/Marshal.html](https://ruby-doc.org/core-2.6.1/Marshal.html) This works well for saving data in a a simple Key Value (KV) store like LevelDB. For sure - install Ruby on your local machine. It'll be a lot easier than trying to learn over a website.. 
It's in no way a waste of time - I've got the 3rd edition pre-ordered, but the 2nd edition is open on my desk as I type this.
I‚Äôll definitely have to check it out. Thanks. The reason I use this website is because I use it on my corporate computer while I‚Äôm at work. Lots of down time. When I get home I work on more rails sided stuff.
can you install Chrome? I used to do a fair amount of dev work on a chromebook. You can use a \*nix style shell in a browser tab! Setup a free instance on AWS or another cloud provider, then ssh on over to your machine. [https://chrome.google.com/webstore/detail/secure-shell-extension/iodihamcpbpeioajjeobimgagajmlibd](https://chrome.google.com/webstore/detail/secure-shell-extension/iodihamcpbpeioajjeobimgagajmlibd) &amp;#x200B;
The Corps Is Mother, the Corps Is Father.
You need to reinstall the Ruby version you are using rvm reinstall 2.3.0
Are you trying to test uploading a file?
Yeah. I need to attach a file, and the site uses the default browser `open file box to select the file
working. 
There should be a file input on the page. Try making it visible and then try something like this. driver = webdriver.Firefox() element = driver.find_element_by_id("fileUpload") element.send_keys("C:\myfile.txt")
I'll give that a try after a bit of food, cheers!
‚ÄúObject Oriented Design in Ruby‚Äù is fantastic, highly recommended.
As I understand it, it turns out, there's basically no reliable way to interact with the actual open file dialog in an automated fashion. But if you are using capybara, what it _does_ give you is a convenience method to assign a file to a HTML `&lt;input type="file"&gt;` object directly (which does not necessarily use the actual open file dialog under the hood, it sort of skips it to get to the same outcome). https://www.rubydoc.info/github/jnicklas/capybara/Capybara%2FNode%2FActions:attach_file
Visual Studio Code [with some extensions](https://www.reddit.com/r/rails/comments/8u0dow/visual_studio_code_setups/e1bl9md/)
 Thanks very much! I'll definitely give this a look
No luck sadly. Still 404 :(
Why is this better than standard.rb?
I wouldn't say it's better - I'd say it's different. &amp;#x200B; prettier-ruby is a layer on top of prettier, which has the philosophy that it doesn't matter what your original style is, we're just going to parse the AST and print it out in a consistent way. This eliminates the need for intervention, and generally has a faster development cycle. &amp;#x200B; standardrb is a layer on top of rubocop, which has the philosophy of pointing out where you're violating styling rules, and then allowing you to fix them or automatically fixing them. This allows finer control, and can be easier to integrate with an existing test suite.
So someone have spent over 9 months working on this project, but scrolling through the Github page I have no idea what it is, what it does and what I can use it for.
Thanks.
i wish i find time.
Thanks! Great job! Have to confess that prettier are one of those things i miss from Js dev lifecycle. Its so relieving to no worry about code style anymore. I have been using Rufo and I will definitely give a shot on Prettier-Ruby
Thanks for the feedback! I'd be happy to clarify. This is the exactly the kind of information I'm looking to get from this initial rollout so thanks.
Mail filters and thunderbird - still going strong for me after all these years. SSD‚Äôs cured most perf issues with big mailboxes. 
Cool, I'm gonna try this out today. I was just searching for something like this not too long ago. After coming back to ruby from javascript/typescript I've been missing prettier alot. \`rubocop -a\` is just too slow for an on save hook.
I am going to take a look at this and discuss it with my team. A lot of typescript fans so maybe...
I think you should add a few examples of transformed code. A few simple things, and maybe some ghastly ActiveRecord query chains to show how it handles complexity. Since it's a plugin for prettier, but also an alternative to Rubocop, you're going to get a mix of visitors who know what prettier is, and those who have no clue at all.
We already use prettier for js and css, but not standard.rb. Would be nice if this could work together with standard.rb like prettier with eslint. I understand it's an early release, but I am all for putting this type of linter in projects and end all discussion and overhead about it.
Thanks for the link! looks like a good stuff.
right now I am using VS Code with the terminal. Thanks for the extension link
It largely does - the test suite within \`prettier-ruby\` shells out to rubocop to ensure it's valid for those rules. I'd be surprised if there were many discrepancies.
That's a great point! I've added it to the README ([https://github.com/kddeisz/prettier-ruby](https://github.com/kddeisz/prettier-ruby)).
Unfortunately you will have to dig a bit into archives to find the actual examples. The bastards are deleting a lot of very valid arguments. You can dislike the language all you want, but people are completely pissed off at these assholes and moving away.
Also, I'm not convinced you really are interested. People who say things like "sources in support of your statements" usually are shills that are just baiting. I have screenshots of them and could put together a very interesting article, but I don't know if people really are interested.
Do you guys not use IDEs?
No.
Nope! 
&gt; The problem was we weren‚Äôt particularly interested in paying hundreds of dollars a month for someone to host a configuration file for us, or spinning up and maintaining an entire server to answer yes/no questions, or tying our entire data model to the feature flagging system. None of the solutions we evaluated met our criteria: free, easy, non-intrusive. Maybe we‚Äôre picky. What criteria does Rollout fail on? I'm failing to see the advantages of eight ball over it. 
Rollout needs Redis. So in our case given we are in AWS, we'd need an elasticache redis cluster (which, granted is managed) which is not free. Hosting a JSON file in Cloudfront is pennies (quite literally)
Am I alone in disliking formatters like this? Gofmt works because there aren't many options in Go. JS formatters work because JS is anarchy. Formatters seems kind of antithetical to Ruby IMO. 
That's certainly reasonable if you aren't already using Redis.
not at a computer right now, but doesn‚Äôt the example in the readme violate rubocop? in particular, the use of semicolons to allow multiple commands on a single line. 
Nope.
Formatters are just a logical step after linters, which are just a logical step after a style guide, which are just a logical step when you code with other people. Genuine question, where do you draw the line as to what's "antithetical to Ruby"?
I'm a React developer working on a Rails team. I know exactly what Prettier is and I have it firing on my JS files every time I save. But strictly Ruby developers might have never heard of it, because they don't know the JS ecosystem that well. That might be the sticking point for a lot of potential adopters. Your readme assumes a reader knows what Prettier is. I'm really excited about trying this out on some Ruby code tomorrow, though. Great work!
Yep, and if you haven't yet, I would highly recommend some time learning SQL and "relational database" separate from Rails. ActiveRecord is basically a convenience layer on top of SQL and an rdbms, and understanding that, and the basic concepts in rdbms, are invaluable in understanding what you're doing in ActiveRecord, and being able to choose the right ActiveRecord tool for the job. 
I don't see this progression as being logical at all. 1) mostly because I don't think Ruby code should be run through a "linter" in the first place. Between the abundance of TDD tools and the REPL console, you just don't need it. 2) One of the primary missions in Ruby is that there are multiple ways to achieve the same end result. Linters, like code formatters, are inherently biased to the person's tastes who wrote them. &amp;#x200B;
Nice. How many redis clients do you use? Is it per env? or multiple per envs?
I'd never heard of this tool, either, so I looked it up in NPM. My work on front-end is limited to vue on desktop and kotlin on mobile. These kinds of scripts aren't really used outside of JS. fwiw. 
MAN, what a terrible title on this Reddit post. 3x performance improvement from MRI and no more patching are HUGE deals. You're doing great work! Maybe we can resurrect Ruby in the eyes of the world at large thanks to your efforts.
Why is this better than rubocop?
Vim ftw! 
1) TDD does not solve arguments over style. Here's a test with 5 ways of solving it. There are many more. def test_sum_of_array test_array = [1, 2, 3, 4, 5] assert_equal(sum_of(test_array), 15) end def sum_of array array.sum end def sum_of array array.inject(&amp;:+) end def sum_of array array.reduce { |sum, n| sum + n } end def sum_of array sum = 0 array.length.times do |i| sum += array[i] end return sum end def sum_of a s = 0;for n in a;s+=n;end;s end The test passes every time. And you dare to call JavaScript anarchy. 2) "But obviously the first one is best. That's just common sense." Sure, I agree. But it doesn't matter what we think. Which one does our senior dev prefer? Is he really going to let you away with the 5th one in a code review? Or is he going to configure Rubocop to shout at you if you try to commit single letter variables and for loops and many expressions on one line? Mine's gonna go with Rubocop every time. Life is too short. By the way, I write better Ruby code _because_ of Rubocop, and _because_ of the Airbnb style guide, and it's definitely not the same Ruby that I learned from books years ago. And I write fantastic JavaScript _because_ of ESLint and _because_ of Prettier. And now I'm the guy on the team who gets to decide what ESLint rules we enforce.
See answer above w/r/t to standardrb.
üëè
That's... really not accurate. These kinds of scripts are used all over the place for various functions.
&gt;TDD does not solve arguments over style And now I'm the guy on the team who gets to decide what ESLint rules we enforce. So this whole thing is just a vanity exercise dictated by personal taste. 
We are using this gem in production at [machinio.com](https://machinio.com). It has a nice set of features that we didn't find in any other Solr Ruby libraries: 1. It abstracts the solr query syntax from a developer and provides a simple API 2. test coverage is pretty good :) 3. No dependencies except for Faraday (and zk if you're running Solrb with Zookeeper). 
Eh, no. This whole thing is me being a Good Guy for new members of the team. And making life easier for other reviewers and maintainers when they have to look at my code. Or being kind to myself, 6 months from now. See it doesn't matter whether I prefer .sum or .reduce or a for loop. The Ruby interpreter doesn't give two shits about my opinion. What matters way more is consistency. And consistency requires that someone makes a decision. Hence, a style guide. It doesn't matter who that person is, or even what the decision is. It only matters that the decision, once made, is enforced whenever appropriate. Hence, linters.
They kind of are, they just aren't scripts. An IDE would impose a style guide and would fix up your code as you write. I've written for Android before and Android Studio (IntelliJ in disguise) does this really well. It just doesn't use an external script to do it.
I use VIM and compilers, mostly LLVM. This world you live in seems like a lot of bikeshedding. Sorry. 
No it's ok. You haven't said anything here that would give me any respect for your opinion. If giving a fuck about code style is bikeshedding, then I'm glad we're not on the same team.
Probably unpopular opinion here, but I genuinely think prettier is a deeply wrong idea that is killing the art of writing clean code. Code is written by humans and ment to be read by humans. Unlike a minified js code or compiled code, formatting here matters here and greatly helps having readable code. I am very often disappointed by some decisions prettier takes for me, making the code much less clean. I feel most of the time it just wraps everything for the sacred objective of not reaching the line length. I believe linters, style checkers and more advanced tools like rubocop (with some handy autocorrect) are the way to go to ensure we have common rules across the team and consistent style, along with reducing the friction of opinionated preferences. Code reviews also helps sharing coding and styling preferences. In my modest opinion, coding is an art and making it clean and readable is part of the beauty of it. No tool would ever make this better than a human. This argument I hear all the time of ‚Äúnot having to care about styling‚Äù feels to me like a lack of passion to our work and laziness. Coding is hard, making code maintainable in the long term is harder, and we should care about people that will read our code. I understand you put a lot of work and effort on this, I respect this, but I have to say I deeply hope that this prettier trend does not broadly reach the ruby community like it did for javascript.
lol - sorry pal, I'm a CTO. I don't need to respect your style. I need you to move the fucking needle, and all this bullshit you're talking about is a ginormous waste of fucking time. You waste: a) Your time, b) Your team's time c) My time d) The Company's time Here's the news flash: we've been down this road with styleguides and whatever else in Java land some 20 years ago. It didn't end well. People took up Ruby precisely because of dickbags like you trying to tell others how to write code. Get fucked. Either your shit meets requirements or it doesn't. It will be rewritten in 3-5 quarters, anyway, and probably in a different language. Maybe you got awards for showing up to class on-time in school and were used to a plate full of cookies or some shit when you got home. I personally don't give a rats ass. Everything you've told me here is fucking bullshit. So forget style. Forget linting. Forget your shitty JS'isms. You're going to sit down with the customer service team and you're going to personally review every last fucking ticket that's been sent in the last 6 months, and you're going to correlate common issues to conversion drops in a set of cohorts that will be in your email box in about 30 fucking seconds. Now get the fuck out of my office. &amp;#x200B;
&gt; I'm a CTO &gt; ginormous &gt; Here's the news flash: &gt; I personally don't give a rats ass. &gt; Now get the fuck out of my office. This is pathetic. Like when some teenage kid goes all keyboard warrior. And none of this limp-dick posturing has helped you to make anything approaching a point. You're just a prick who doesn't know how to engage with people.
I don't get paid to "engage with people". I get paid to turn tech into profits. And everything in this thread is full of shit, including your asinine, back patting, self-gratifying claims about "being the guy" who gets to set style. Who gives a shit. Do some real fucking work already. &amp;#x200B;
Can you explain more about what the [configuration](https://github.com/machinio/solrb#single-core-configuration) stuff does? Is that sending commands to Solr... as soon as `Solr.configure` is encountered? To dynamically define the schema in solr? Is it idempotent, or are you expected to run it only once, or what? 
Your examples are not the same, they have different performance characteristics. 
http://wiki.c2.com/?PrematureOptimization
I've worked at a bunch of SaaS companies that use it for background jobs and I've basically been working in that area alone for the past 5 years
So your strategy is to smoosh your way into monitoring? Are you so bereft of good reasons to use your platform that you're scared to compare yourself to NewRelic or Skylight? Please explain yourself. 
not at all
you could also just write code so its readable, just saying...
Yea, ok. So we just write shit code all the time then our ruby-prof traces result in no obvious areas of performance improvement since it's all shit. Good idea. Perhaps you should actually understand the context in which that statement was made and consider that before applying it universally. 
Hey man if your job dictates that you shave milliseconds off of every for loop don't let me stand in your way. But if it matters that much, maybe Ruby isn't the language for you. Rapid performance is absolutely not one of the language's design goals.
haven't done my homework here, but, just curious, why does one choose solr over elasticsearch?
Hey man, if your job dictates that you write bad code just to get it out the door when anyone with a smidge of understanding could write faster code in the same time, don't let it upset you. Also don't be surprised when you have a hard time finding a job in Ruby. 
Little late to the party. Any copies left?
...I do have a job in Ruby. I write programs for the web. HTTP is a great big bottleneck I can't do anything about. The speed of my for loops doesn't matter a fuck.
I'm sorry man, but if you think HTTP is the bottleneck in your apps, you haven't a fucking clue what you are talking about. I would recommend you write the same thing in a few other languages then get back to me on this. 
I tried to rewrite one of my apps in another language: 10 PRINT "YOU'RE AN ASSHOLE" 20 GOTO 10 Thanks for your feedback!
Yea, that really supports your argument well...
Was it not performant enough for you?
At this point I just assume your trolling but for the benefit of others reading this: No HTTP 'overhead' isn't why your Ruby based web app is slow, it's because Ruby is not particularly performant itself and because users of Ruby have a tendency to write code in a way that either may look good or may abide some other interest without much regard for performance.
I'm somewhat eagerly awaiting Ruby having a JIT because this type of shit is going to explode and 99% is going to be very angry people whom don't have a clue what they are talking about. 
Do you have coworkers? Are all of your coworkers equally skilled? Linters are a good first line of defense against several categories of errors.
&gt; Ruby is not particularly performant itself So back when I said: &gt; Rapid performance is absolutely not one of [Ruby]'s design goals ...I was right all along? Trolling aside, here's what I'm talking about: &gt; ping google.com 64 bytes from 216.58.204.14: icmp_seq=13 ttl=56 time=24.175 ms 64 bytes from 216.58.204.14: icmp_seq=14 ttl=56 time=19.664 ms 64 bytes from 216.58.204.14: icmp_seq=15 ttl=56 time=23.026 ms 64 bytes from 216.58.204.14: icmp_seq=16 ttl=56 time=683.678 ms 64 bytes from 216.58.204.14: icmp_seq=17 ttl=56 time=1881.153 ms 64 bytes from 216.58.204.14: icmp_seq=18 ttl=56 time=894.051 ms 64 bytes from 216.58.204.14: icmp_seq=19 ttl=56 time=19.435 ms 64 bytes from 216.58.204.14: icmp_seq=20 ttl=56 time=20.175 ms 64 bytes from 216.58.204.14: icmp_seq=21 ttl=56 time=22.564 ms I'm pretty sure I've never written a for loop that sometimes takes almost 2 seconds to complete, sometimes under 20 ms. I'm pretty sure there's nothing wrong with Google's code either. I'm predominantly a front end developer. Not the kind that knows CSS really well, but the kind that sweats over bundle sizes and input latency and times to first meaningful render and I honestly don't give a shit about the speed of a Ruby for loop. It is utterly meaningless in my world; there is so much more that needs to be made faster before I'd notice the milliseconds that could be shaved off by using a for loop instead of `.each`. 
I'm incredibly confused. Your 'evidence' that backend loop time doesn't matter is google.com ping times? Wut? &gt; I'm predominantly a front end developer. Not the kind that knows CSS really well, but the kind that sweats over bundle sizes and input latency and times to first meaningful render and I honestly don't give a shit about the speed of a Ruby for loop. It is utterly meaningless in my world; This is really what I've been saying to you, you actually have no idea what you are talking about, you don't work on the backend, you have no idea what backend response time actually means (your ping backend response times for google are _very_ close to zero because they don't write shit code for stuff like this). I honestly don't get what you're trying to say here, it seems like because google's response to an ICMP packet is fast that the response time of an app server doesn't matter? Is that it? 
&gt; If you want to dive in and do more of the sleuthing yourself üïµÔ∏è, since Ruby 2.1 we have ObjectSpace, built right into the core library. This basically can measure what the module name suggests: look at the space an object takes up, hence ‚ÄúObjectSpace‚Äù. That's probably not where the name 'ObjectSpace' comes from. I think it's more likely that 'object space' is another name for the object graph. It's from Smalltalk terminology. This module lets you reflect on the object graph.
You think memory usage is going to go up with a JIT? That's probably what will actually happen I agree, but possibly with a good JIT it could actually reduce memory use through compressed pointers and scalar replacement.
So first off, I have to defer to your knowledge knowing whom you are. But I've never experienced your counter point. I would tend to think one of the more advanced JIT runtimes is the JVM and I don't think there is much question that it uses a _lot_ of memory for start up. I've also been playing with truffleruby rc12 in a rails app with PG and while the performance is quite nice after JIT startup time and throwing a bunch of RAM at it, the memory usage is a notable increase. My general guess is that the situation will be much as it is for the JVM today, the memory usage for 'small work' will suck and for high throughput production work it will be acceptable in contrast to the performance gain. Also under these workloads there may be a notable decrease in peak memory usage due to the things you've mentioned. However, there absolutely will be a user backlash due to the ram usage and even slow startup time changes. I don't think this is avoidable. I think the best path forward (which I think you are already on in some ways) is that developers use MRI for local dev and deploy on truffleruby. 
Yeah I was pointing out a hypothetical, not suggesting we'll see this in practice. A JIT for MRI could reduce memory used by individual objects, but in practice it is unlikely to amortise the additional cost of the JIT data structures.
When working in a project where 10 oppinionated developers have, each one, their own personal style that is better than the style of the other 9, an automatic code formatter comes like a blessing.
Conceptually in that context I was referring more to the user expectations than the concrete realities. My original comment certainly was somewhat in jest but I do think that is the unfortunate reality any JIT for Ruby will face. Ruby has, at least in some circles, bean known for it's relatively modest memory usage in light usage (Heroku built an entire business model on this) but as soon as a JIT is introduced, be it through MRI or TruffleRuby, this is going to increase (again for light usage). For heavy usage, sure it could improve things, but those users aren't loud and angry, the light users are loud and angry. 
Wow cool, I did not know ObjectSpace has all these extra methods!
Bullshit. That‚Äôs 6‚Äì8 people without enough work to do. Debates I‚Äôve had to mediate generally come down to broader technology choices: kv vs nosql, CI stacks, GitHub vs gitlab (and runners), enforcing iso27001 security standards, kubernetes vs manual docker configs, and eliminating rest for grpc. A team arguing about style is a company losing money. Come review time, you don‚Äôt want to be that guy. 
Do you work as part of a team where multiple people contribute to a shared codebase? Does every person write code in a stylistically different way (trailing vs leading dots, single vs double quotes, etc). Some people are bothered by the inconsistency. 
awesome, ty for sharing
This is the shittiest thread I've read in a long time, ugh.
I am not sure if you are refuting my point or not. But you should calm down a bit. Why are you so stressed?
yup! it is in my experience. I'm like in the complete opposite boat from you, well at least somewhat. trained a good amount in Ruby and have to learn Java now. 
dynamically typed language to a statically typed language! interesting. 
The question is: why are you not? Why is there no fire under your ass hotter than a code style formatter? Is that all your career sums up to - pretty code? I‚Äôm irritated because I can‚Äôt believe so many people are getting paid to literally burn money. Nobody on my teams argue about style. Protobuf interfaces maybe, style, no. The rest of the time is triaging prod issues or shipping features. 
Nothing like code formatting to bring out the trolls. There are some truly awful posts on here. 
up front I'm still learning and had to look up the difference between the two. cool!
Most rubyist use simpler editors. VS Code is more then enough for most standard rails projects.
Ugh
We should get this on the prettier site, and maybe in the org
Most people‚Äôs apps are slow because of the database. Source: I work for Heroku and specifically look at performanc of customer apps. Google me. Then after databases they‚Äôre slow because they‚Äôve never looked at perf at all. Usually this has to do with using a library and creating a ton of objects. In Ruby memory allocation dwarfs time spent actively on the CPU. While you‚Äôre right that some of those methods are faster, without profiling and understanding the overall workload you don‚Äôt know if you‚Äôre optimizing the bottleneck/hotspot or if you‚Äôre working on an insignificant chunk. Think of big O notation, we only care about the largest order usually. If you always write ALL your code to be the fastest possible then you‚Äôre burning another precious commodity: your own development hours. Your productivity is not free, or cheap even. Readability is a value as well. I do encourage people to care about performance. But I also encourage them to be not go overboard. If you‚Äôre in security you build a threat model and work off of that. If you have to write the FASTEST RUBY AT ALL TIMES. Then you must be shipping nothing but C-extension code. 
I‚Äôd argue it doesn‚Äôt even work in Go. Any tool like this is bound to put uniformity of the code as it‚Äôs main value, and while uniformity can help readability, they‚Äôre just not the same thing. Might as well just focus on writing and peer reviewing readable code. 
I agree completely. Formatting code is just like choosing abstractions, picking variable names, etc. All these little choices convey meaning to the next developer to read the code, and used skillfully can make their task simpler. Code formatters by definition care more about code looking consistently the same than code being the best it can be in different situations, they unavoidably round code quality downwards.
Calling "Queues" thread-safe by nature is a bit silly. The Ruby implementation of `Queue` is thread-safe... but this certainly isn't applicable to all queues in general.
This is fantastic. I've been lamenting rubocop's inferiority to prettier ever since I used it in node, and have wondered why it wasn't ported to ruby. This is the only sane solution and this will approach will, imo, eventually become as standard as syntax highlighting. Thanks for making this.
&gt; Most people‚Äôs apps are slow because of the database. Source: I work for Heroku and specifically look at performanc of customer apps. Google me. I know who you are but I think it's important that you understand your bias in a statement like that. I've worked for multiple companies that have moved off from heroku specifically because your CPU performance is fucking awful. Your company has an inherent bias toward companies that _do not_ have CPU bound issues because when they do, they just leave. So I don't for a minute doubt what you are saying, I imagine the vast majority of _your customers_ are database bound, but where you're lacking here is extrapolating that to the entire community. 
This sounds like a time-share scam. 
Would you please tweak the readme to show the exact command-line steps needed to install prettier? I don't know what "add prettier-plugin-ruby to your package.json dependencies" means, nor what to type to "install using either npm install or yarn install". Other questions for this ruby n00b include in what directory to be when installing, if it makes a difference. Many thanks; I'm looking forward to playing with it.
I use an IDE but my organization (Airbnb) does not force everyone to use the same editor. People use RubyMine, Sublime, VS Code, Atom, Vim, Emacs, maybe others. So it's easier to achieve consistent styling if the formatter is an external tool that can be plugged into any editor.
Good point! I rephrased the text using your wording, with your permission.
I agree. Some Rubyists aren't used to node package terminology.
Bravo. A few years ago when I heard developers at my company complaining that the large majority of comments on their pull requests were about style instead of content, I began to understand the value of having an automated tool like Rubocop that enforces consistency. It lets the humans focus on content during code reviews. Now that prettier exists for JavaScript I've seen that it saves even more time. You can just write your code, save it, and let the tool reformat it for you in your editor. Happy to see this coming to Ruby. I just tested it on a few Ruby files. I liked most of the defaults I saw. One change I'd like to see: default to putting a `,` at the end of the last line in a multiline hash or array. At Airbnb we use this convention so diffs only show the lines that actually had a meaningful change. 
Weird. I use Scout APM on a few projects &amp; really like it but this seems desperate. 
Awesome! You can use whatever words you want!
What about people who don't ski?
Electronic ignition killed the art of adjusting the choke on an automobile. Some 'arts' are destined to die.
&gt;I wouldn't say it's better - I'd say it's different. &gt; &gt;prettier-ruby is a layer on top of prettier, which has the philosophy that it doesn't matter what your original style is, we're just going to parse the AST and print it out in a consistent way. This eliminates the need for intervention, and generally has a faster development cycle. &gt; &gt;standardrb is a layer on top of rubocop, which has the philosophy of pointing out where you're violating styling rules, and then allowing you to fix them or automatically fixing them. This allows finer control, and can be easier to integrate with an existing test suite. &amp;#x200B;
In their defence: 1. I have heard Scout is actually quite good. 2. Most people don't make decisions based on merits of facts, but mostly on whether they like the party/person and/or whether they trust it. As much as we developers like to think of ourselves as rational, for a large part we really aren't. When you chose your favorite framework, did you do your research on 7-8 different frameworks and carefully compared all pros and cons, or did you just go with the one that some friend or some trusted party recommended? Building relationships is key, and that is what Scout is (rightfully) doing. Of course, building relationships doesn't work if the product really sucks. But Scout doesn't suck. And being better doesn't mean you will be chosen. 
I'm curious to get your thoughts on my perspective because I'm in the process of introducing a style guide (rubocop) at work at the moment and much of the push back has been along the lines of what you said (though you've said you like rubocop). &amp;#x200B; To me, consistency is almost, but not quite, a goal in itself. I like to think I have put passion and effort into my work, but questioning (at one end) whether it's important that this line is indented by 5 spaces or (at the other) whether someone realizes that the code is going to execute not in the most obvious way (perhaps different order of operations than intended, either mathematically or parenthetically) over and over on PRs feels like death by a thousand cuts. &amp;#x200B; I want to provide meaningful feedback on the substance of the code I am looking at, not the style with which it is written. I don't see rubocop much differently than prettier in that some arbitrary style is chosen as the one true style and then any style conversation is moot. I can focus on whether there are two ideas in your class that should be broken apart rather than whether or not the parentheses on the line are meaningful. &amp;#x200B; I hope that I can't be accused of a lack of passion or laziness but again, I'd love to hear your thoughts!
Somewhere around my 15th language; now using Ruby within rspec for the day job, trying to find just the right 'Ruby for programmers' path to really grok it. A pleasure finding this community.
Agreed, they're just too close to it and can't recall when it was new to them. I've been coding for &gt;35 years but have no idea how to install following those instructions :-) I'm hoping someone gets it, fixes the README, and pings me so I can join the party.
Glad to know it's being used by others as well!
Good article, but it needs to explain things a lot more because a lot of this stuff is well hidden from most devs like myself.
JRuby memory usage with JIT was lower for a large production I ran compared to using CRuby and a large number of processes.
Raise the price definitely. $3 doesn‚Äôt look serious. 
You‚Äôre welcome!
It‚Äôs literally just me, there‚Äôs not a big team doing this. I‚Äôm very happy to update the README and will do so this morning.
Perhaps something here might spark an interest? [https://www.quora.com/What-are-beginner-Ruby-projects](https://www.quora.com/What-are-beginner-Ruby-projects)
If you have a sysadmin background, writing big chef or puppet libs is a fun way to practice multiple skills at once. Otherwise, pick a lean web framework like Sinatra/Grape/Roda and write microservices. You can use that as an excuse for learning another API or protocol you're interested in. It sounds obvious, but for me at least, it's a lot easier to think of projects if I have a problem I already want to solve, or some other thing I want to learn. Pick something you're already interested in that isn't the language itself and use Ruby as the tool to build it.
Why is having more alternatives a bad thing?
&gt; Probably unpopular opinion here, but I genuinely think &gt; prettier is a wrong idea that is killing the art of writing &gt; clean code. You can say this about many additions to ruby in the last 3 &gt; years too. And I may agree with many other comments. But it is not always a black-white view. Take this: https://github.com/ruby/ruby/commit/91fc0a91037c08d56a43e852318982c9035e1c99 The old code was: f.close if f &amp;&amp; !f.closed? The new code is: f&amp;.close I do not like the &amp;, but we can also hardly claim that the first line is so much prettier than the second one, right? Both are quite ugly to me. The second variant has one huge advantage, though - while ugly, it is also much shorter. (I still don't use &amp;. myself since I can not stand it; it is especially ugly in combinations like this: t1&amp;.kill&amp;.join but when we critisize shit like this, we also have to keep in mind the alternative, which can be shitty too. If it were up to me I'd only keep pretty code in ruby, which would also mean less flexibility for people to use syntax wise in SOME areas - @@foo would also instantly get removed; global variables can not be removed since they are sometimes indeed without trivial alternatives, but I don't like them either). &gt; I believe linters, style checkers and more advanced tools &gt; like rubocop (with some handy autocorrect) are the way &gt; to go to ensure we have common rules across the team &gt; and consistent style Don't get me wrong - the autocorrect feature of rubocop is my favourite one. But rubocop also has TOTALLY arbitrary and rubbish "community rules". I wouldn't let the defaults onto any of my projects. It is a partially moot point since rubocop can be tweaked, but you refer to "consistent style" - so WHO defines that? Rubocop? You? The boss? You yourself wrote before that you believe in "the art of writing beautiful code". Well, I write pretty ruby code all the time. I don't need any arbitrary tool to lecture me which style is beautiful and which one is not. &gt; In my modest opinion, coding is an art and making it clean &gt; and readable is part of the beauty of it. No tool would ever &gt; make this better than a human. This is the part I agree with. Still, rubocop works NOT solely as a "prettifier" - the autocorrect part is actually cool. I can take old ruby code, and updated it to a more sane, modern variant. I actually think we would need auto-changers everywhere, including a ruby-to-crystal variant. Or, if crystal deviates too much, to have a second ruby-language, as part of ruby, managed and designed by matz, which has the goal of being as fast as a compiled language, at the slight extra cost of having ugly shit such as type system - ugly, but faster. Like crystal. But managed in one project rather than disparate projects (it's not good to dilute developers into 10000 sub-languages). &gt; This argument I hear all the time of ‚Äúnot having to care about &gt; styling‚Äù feels to me like a lack of passion to our work and laziness. I agree only partially. Some coding is JUST STUPID GRUNT WORK, especially fixing bugs. I don't see why we have to go through that at all. The creative parts are ok. &gt; I understand you put a lot of work and effort on this, I respect this, &gt; but I have to say I really hope that this prettier trend does not &gt; broadly reach the ruby community like it did for javascript. If rubocop exists then I don't get why prettier or other altnernatives should not exist. Where is the problem? People can decide what to use and what not to use. I honestly do not see any problem here. 
I didn't say that üòè
&gt; Formatting code is just like choosing abstractions, picking &gt; variable names, etc. All these little choices convey meaning to &gt; the next developer to read the code, and used skillfully can make their task simpler. There are trade offs. Consider this: def foo(i) pp Dir["#{i}*] end The code is quite simple to understand. You can also use a longer variable name. The question IN THIS SIMPLE context, is - is it worth to use a longer variable name? To me no. I don't recommend using single letters for when code becomes more complicated, but for simple tasks I fail to see why we should use long variable names only because they are "prettier" to read. And that comes from someone (me) who loves long method names when it makes sense. 
&gt; To me, consistency is almost, but not quite, a goal in itself. I like to think &gt; I have put passion and effort into my work, but questioning (at one end) &gt; whether it's important that this line is indented by 5 spaces or (at the &gt; other) whether someone realizes that the code is going to execute not &gt; in the most obvious way (perhaps different order of operations than &gt; intended, either mathematically or parenthetically) over and over on &gt; PRs feels like death by a thousand cuts. Many rules in rubocop make little sense. But I still think that consistency is a worthy goal to be had. Whatever you do, be consistent about it at all times. And what is even more important - DOCUMENT THE CODE YOU WRITE. Every single person who thinks that the code is self-explanatory is just a lazy bum. And there are so many people who are lazy. I am lazy too. I hate writing documentation but I force myself to not forget doing so, as shit as it is. The alternative is undocumented code AND I HATE undocumented code - even much more so when code is documented but the comments are wrong. That is still better than zero documentation code.
New to reddit? Welcome!
&gt; Gofmt works because there aren't many options in Go. Depends. If it is voluntary then I have no qualms. I think gofmt is mandatory though right? I hate mandatory formatters. Then again I also think that Go is an overrated language created by an evil and greedy corporation. Too many people are sheep and use whatever random language they can get their paws on (and "land a job" that way, which is admittedly a major driver in people learning languages).
I would not call a style guide to be a logical step when you code with other people. While I understand that a consistent style guide is useful, there have been projects that were successful without having had a need to use a style guide.
Your two points are not correct. 2) refers to "more than one way to do it". That is a philosophy and that includes also having alternatives that you can choose to use - or not use. So I welcome alternatives to rubocop. Note that not all "multiple ways" achieve the same end result. Some are shorter; prettier; or do something different. The goal is not to have 1000 ways purely for the sake of having 1000 ways, but to find alternatives IF someone wants to. Ruby is multi-paradigm after all. As for (1), I don't see the connection. People can use a linter but decide not to need or use a REPL, so your statement that because we have a (or more) REPL(s), we should not need a prettifier, does not make a lot of sense. People can just decide on their own what to use. I don't use rubocop or the prettier myself but it's good that alternatives exist. (I do use rubocop a LITTLE bit for when I have to auto-update very old ruby code written by others; I do so primarily so that I have to spend less time manually updating that old code to what I consider better modern ruby code.)
That page can be quickly improved really. I feel this is such a minor thing to want to complain about.
Thanks for the free ebook! I'm a total beginner and I'll take a look.
I've updated the README with some more clear instructions. Let me know if it doesn't answer all of your questions.
You are the number #1 complainer/whiner on this subreddit. I don't think presenting a project is a minor thing either when its on Reddit or when it is on Github.
awesome. I love this - where I've done training and need to do more - for some free, foundational material: https://launchschool.com/books
Same here. Having it as options with a simple keybinding in an editor so you can mark a region and say "do your worst with this" is great to deal with poorly formatted code, but so many opinionated decisions of code formatters tends to make code harder to read, not easier, and so I would not ever want to systematically apply it to my code on an ongoing basis. A typical examples I've run into would for example be more complex manual alignment that is particularly "designed" to line up parts of expressions that are the same to make differences stand out, that often gets ruined by formatting tools. 
Depends. What is the *purpose* of abstracting the above into a method? The use of "pp" suggests that perhaps the content is currently just a placeholder for more functionality to be added later. But what? To me the key is that names communicate intent. It doesn't matter if the names are short when the intent is clear. In this example the intent is not clear. You can fix that with a better argument name, but also with a better method name. The problem is that we're doing two things with names: We're communicating about the implementation, and we're communicating about the interface. In this case the implementation is obvious, but the motivation for the interface is not. 
Picking ‚Äòi‚Äô as a variable name *does* convey meaning though, in this case it‚Äôs ‚Äúthis is a one-time usage variable that serves a trivial purpose, don‚Äôt worry too much about it‚Äù, it‚Äôs a perfectly valid choice. A code formatter stifles the developer‚Äôs propensity to think about code formatting, that‚Äôs the whole point, I argue that code formatting it‚Äôs too important to not think about. 
Consistency is important to ensure code is readable for everyone. If a tool that seeks to enforce consistency decreases readability on average for your code-base because it ruins careful formatting by those who do care deeply about it, then you're enforcing consistency for the wrong reasons. For some teams it's essential to apply a formatter, because one or more of the team members can't write well formatted code if their lives depend on it, much less to avoid the ire of co-workers. For others it's a time sink that harms the productivity of your best developers and causes conflicts. And many alternatives in between. My advice would be to turn off most options to start with, and then sit down with those on your team that objects, and agree small batches of options to try. Enable just a few at a time, see how it works, and iterate. 
The ugliness of Go code is a large part of the reason why I don't do Go. The ability to write very clean code is part of what keeps me using Ruby. People systematically under-estimate how important it is that code reads well. 
&gt; Most ruby devs use multimonitor with editor on one, browser on another, and terminal on the third. I knew I was missing screenspace! 
Ironically, the only person left in our team that uses ruby really is me - and I use it to mock and/or prototype various components before the team takes it and reimplements in c++, go, or sometimes python. Mostly we're a Go shop on the backend, and the gofmt tool is used primarily to standardize tabs and spaces before check-in. That's it. Team sizes are small - 2 to 3 people - with a dozen or so micro-service'y projects going on at any given time. Because of that, code review is often done on the fly and a lot of design issues are settled between the people writing the code. I very rarely intervene. Like this thread, the squeaky wheels are usually the front-end teams. There's an eternal war going on between react / angular devs, and the UX folk who are just trying to cajole them into meeting milestones. Because of this I've begun hiring native devs for iOS and Android to eliminate staff dependencies on front-end web teams. I'm decidedly not a sheep. The purpose of a business is to make money, not argue about tool stacks. I find with Go that there's a lot less arguments (as designed) at the cost of developer interest. I think standardizing around middleware is more important than language. For that reason, we've been looking at porting some of the gRPC code to msgpack over zeromq. Hands down, a couple of good Django or RoR devs can do more work than a react team. Farming out a re-skin of the design is a lot more cost effective, too. send over the PDFs, get back HTML and CSS -&gt; web team. It's the best way to keep the peace with the argumentative fools like the ones in this thread and prod mgmt / ux. fwiw. 
Maybe they would have been _more_ successful with a style guide. Who can say?
This seems a bit contrarian for the sake of being contrarian. Ruby's philosophy has everything to do with supporting multiple code paths to solve the same problem, and precious little about linters or code fashionistas. Rubocop is a decent tool, but it's something I expect people to run as a sanity check before submitting a merge request, not the source of big debates over code style. 
The latter, it's just a piece of code that is used to make queries later (translate field names, find appropriate core to query etc).
Do you have a link to the web version?
Solr is mostly used in Java companies, in our case it is a historical reason
Yes, its http://i-love-ruby.gitlab.io/
Actually, I make money from running a Ruby on Rails company. So its okay. When people read it, they will understand about it.
Could you clarify what you mean here? This is part one of several on this subject, so more is coming. 
the op blog is quite interesting https://mindaslab.github.io/
Clear concepts and fun to read book
Unless you get solid word of mouth, people, myself included, will see the price and pass on over it because we assume it's some cobbled together blog posts of no real value.
well YMMV. I did work for one company that forced windows, which at the time was literal hell for a ruby dev... you had to have VMs to do anything. On top of that they forced an aspect ratio on their deploy images that was their lowest common monitor to support Internet Explorer which IIRC was 1080x720 at the time. You had no admin control either. Needless to say, I didn't stay there long.
Interesting. I wonder why you allow for invalid enums though. As in \`[State.new](https://State.new) :a, 4\`
I use Scout APM on a few Rails apps. Its much better at getting down to specific methods DB transactions that are slow. You can sync your github &amp; it will tell you what lines have a n+1 queries. I prefer their interface to NR's. Its cleaner &amp; simpler. Scout can do error reporting &amp; alerts but I haven't tried it.
I use array/hash based enums, the advantage is that you can use all array/hash methods like include?, key?, ... class SimpleArrayEnum &lt; Array def initialize(*arr) super arr.map(&amp;:to_s) each do |value| define_singleton_method(value) { value } end freeze end end State = SimpleArrayEnum.new(:draft, :sent) State.draft # =&gt; "draft" State.foo # =&gt; NoMethodError class SimpleHashEnum &lt; Hash def initialize(hash = {}) super() merge!(hash) each do |key, value| define_singleton_method(key) { value } end freeze end end Color = SimpleHashEnum.new(red: "R", green: "G", blue: "B") Color.red # =&gt; "R" Color.foo # =&gt; NoMethodError
It looks like you've copied [Manning's](https://www.manning.com/) cover style. You might want to change that to avoid legal action.
Lol
Good point. It still early for the enum class. The error checking (for invalid keys in new) is still missing.
&gt; I've worked for multiple companies that have moved off from heroku specifically because your CPU performance is fucking awful We don't provide the CPUs. Heroku runs on top of AWS. &gt; your company has an inherent bias toward companies that do not have CPU bound issues because when they do. Also all my performance patches to Rails and other libraries are benchmarked on my MBP with dedicated multiple cores and gigabytes of RAM. It's not just Ruby "on Heroku" it's Ruby. Writing to memory is just about guaranteed to be slower than executing instructions on a processor, the exception being if your caching something extremely expensive, but that's the minority case. &gt; So I don't for a minute doubt what you are saying Thanks! &gt; I imagine the vast majority of your customers are database bound, but where you're lacking here is extrapolating that to the entire community. Which is kinda why I mentioned where my experience comes from. If you're speaking from a place of scientific computing with Ruby where every while loop needs to be tuned, then yeah...that's a different perspective. I get that "not all developers" share a similar experience, but a helluva lot of them do. 
Sorry the link is currently hidden (by github) I sent in a support request to get it back. Here's the code (for your reference): ``` ################################## ## auto-create/builds enum class. ## ## Example: ## State = Enum.new( :fundraising, :expired_refund, :successful) ## auto-creates/builds: ## ## class Enum ## def initialize( key, value ) ## @key = key ## @value = value ## end ## end ## ## class State &lt; Enum ## ## FUNDRAISING = new(:fundraising, 0) ## EXPIRED_REFUND = new(:expired_refund, 1) ## SUCCESSFUL = new(:successful, 2) ## ## def self.fundraising() FUNDRAISING; end ## def self.expired_refund() EXPIRED_REFUND; end ## def self.successful() SUCCESSFUL; end ## ## def fundraising?() self == FUNDRAISING; end ## def expired_refund?() self == EXPIRED_REFUND; end ## def successful?() self == SUCCESSFUL; end ## end ## ## pp state = State.fundraising #=&gt; #&lt;State @key=:fundraising, @value=0&gt; ## pp state.fundraising? #=&gt; true ## pp state.expired_refund? #=&gt; false ## pp state.successful? #=&gt; false ## pp state = State.expired_refund #=&gt; #&lt;State @key=:expired_refund, @value=1&gt; ## pp state.fundraising? #=&gt; false ## pp state.expired_refund? #=&gt; true ## pp state.successful? #=&gt; false ## base class for enum class Enum ## return a new Enum read-only class def initialize( key, value ) @key = key @value = value end ################### ## meta-programming "macro" - build class (on the fly) def self.build_class( *keys ) klass = Class.new( Enum ) ## add self.new too - note: call/forward to "old" orginal self.new of Event (base) class klass.define_singleton_method( :new ) do |*args| old_new( *args ) end keys.each_with_index do |key,index| klass.class_eval( &lt;&lt;RUBY ) #{key.upcase} = new( :#{key}, #{index} ) def #{key}? self == #{key.upcase} end def self.#{key} #{key.upcase} end RUBY end klass end class &lt;&lt; self alias_method :old_new, :new # note: store "old" orginal version of new alias_method :new, :build_class # replace original version with create end end # class Enum ```
@Proudclad Added support for SQS Events: [http://rubyonjets.com/docs/events-sqs/](http://rubyonjets.com/docs/events-sqs/) Though with FIFO SQS queues, you have to currently poll as AWS does not yet support Lambda Triggers with FIFO queues.
Oh nice!! Yeah I saw that FIFO wasnt supported and downgraded to a regular queue. Thanks!
Not sure if you're just messing around with ruby to learn but it looks like you're trying to build a Finite State Machine. You may want to checkout the [statesman gem](https://github.com/gocardless/statesman) as it'll give you a few more options. 
thanks for not saying, 'go do your homework!'
If only Ruby had its own IDLE in the package!
Rails code is so strange ...
&gt; But I've never experienced your counter point. Actually matz said the counter point - one constraint, and also in regards to mruby, was to be able to use ruby on small, constraint, embedded systems. Partially due to Heroku; but more generally also because (m)ruby SHOULD be used on small systems. That's an area where lua is used a lot and where one could use ruby too. Matz does not invest that time into mruby for nothing. &gt; I've also been playing with truffleruby rc12 in a rails app Big fat java stack AND rails? And you have memory problems? Who would have known ... &gt; My general guess is that the situation will be much as it is for the &gt; JVM today, the memory usage for 'small work' will suck Firstly, the jit can be disabled so there is that. But more importantly, what you claim here runs against what matz and others said, so sorry dude but ... no. I'll take what matz said during presentations over what you assume the future to be.
I don't think you can estimate the people using ruby based on reddit subs. As for where people went, well. A lot of this has to do with work. Say you were 22 years old in 2005 or so, just starting with ruby. Now in 2019 you are ... LET'S CALCULATE THIS BEAST ... well, 36 years old. Many people may have kids at that point; or usually tend to have high-paid jobs (well for the most part), possibly be some CTO or even CEO, whatever - it just changed compared to 22. Young people are usually a lot cooler than middle-aged folks. The fun died down a lot - some moved into other languages such as Go (!) and so forth. They are in general rarely doing any cool stuff anymore either - and if they THINK they still do, they often totally overestimate what they do these days. This happens in general by the way; look at this trend: https://trends.google.com/trends/explore?date=today%205-y&amp;q=Ruby%20-%20Programming%20language,Perl%20-%20Programming%20language,PHP%20-%20Programming%20language,Python%20-%20Programming%20language,JavaScript%20-%20Programming%20language PHP, ruby, javascript, perl all are in decline (at the least concerning what the google charts measure); only python gained grounds or stayed the same.
You are a very unfun gang. You are not doing any of the really cool stuff. Work keeps you from doing awesome things. You just highlight what you are fancy-doing in the working-slave business (I understand that money is important).
Yikes, at least make it a horizontal colorfield!
Ruby is not boring. Rails, and web-stuff, is however had insanely boring. I can not understand how people can tolerate this boring thing in general (I refer more to web-related stuff, WOW that is a ghetto, much bigger than zedshaw ever claimed rails alone to be).
That depends on the area where you are. I am pretty sure that ruby is still a lot more popular in japan than python is.
But what about it!!!
Actually I re-read your statement here twice - and after some thinking, I fully agree with you, so deserving an upvote.
Mailing lists SUCK in general. I never managed to handle them. I know how people can use them effectively but I just don't have a workflow that is compatible with this.
See - I'd never use such a combination.
Can't be! Can't take you that long to write ruby code.
I don't think you need "more skill" per se. Ruby is, however had, a LOT more fun than python is. I always found this strange how restrictive python is compared to ruby, yet python claims to be based on monty python (though in reality we all know it is based on an animal). Python can be quite complex though. Generators? Lambda? Decorators? Walrus-fatso operator?
It's pretty yucky but it is usually quite simple. I think python code as such is acceptable. Worse than ruby but better than perl. I could see myself using python (I actually do), but there is no way I would use perl. Of course I prefer ruby so ...
Only some people do. I used ruby before rails, never got into rails, never regretted that either and use ruby for all web-related tasks nonetheless. I literally use ruby for everything. The only drawback to concede to would be that ruby is significantly slower than the master language (aka C).
&gt; Maybe, there's less to say about ruby... Not sure - could also be because most people DO NOT HAVE INTERESTING PROJECTS. I have quite a few projects but ... I am not sure any of them are really interesting to people. They are somewhat boring even if I use a few of them daily ... Generating hype that is actually based on something GOOD and USEFUL at the same time, is a bit difficult. You sort of need not only an interesting project to begin with but also some marketing skills (which I don't have; but I also lack an interest in wanting to be a marketing guru either, it just does not fit to how my brain operates - when you spend too much time with biology, you tend to think vastly different to e. g. economics-centric people).
Just bought it! Best of luck!
Write something that crawls a web page as HTML or JSON and uses that info to do something interesting, e.g. leverage the darksky api so render some basic weather information. 
What do you mean by referring to Zed Shaw (learn ruby the hard way author)
yield\_self proper doesn't support additional arguments.
I think this method is part of `Kernel`, not `Object`.
Cool. Noted. Will finesse this. Thank you.
Yep, you are correct. Cheers.
Then why charge at all? I love Ruby too!
As newbie to ruby coming from java experience, it would be great to see how to debug in ruby. I have seen prybug has option but it‚Äôs hard to believe that‚Äôs only good option out there.
That same support article says Heroku websocket functionality. It‚Äôs worked for me, tuning multiple web dynos without having to consider any of this.
This is great news
From my experience, WebSockets are not affected by this limit. I‚Äôve seen an app with 4 dynos and a dozen of thousands of simultaneous connections.
Interesting. Are you sure about this? My source is this Stack Overflow thread: "[Websocket concurrent connections limit on Heroku](https://stackoverflow.com/questions/25118381/websocket-concurrent-connections-limit-on-heroku)" &gt;"There are no limitations on the free dyno tier in terms of resources. In terms of concurrent connections there is a **theoretical limit of 50 connections per Heroku router instance** but we don't currently publicise the number of router instances running at any one time. In general, for the EU region you can expect to have around 1500 connections available at any given time." --staff reply to me. Later he clarified, this limit is for all dyno types. even paid ones. Thanks for your thoughts.
Why would you want to make a delegated method private anyway? If you're sending a message to a public method of an instance or a class from another class I'd expect it to be public I wouldn't call a private method from the outside. Delegated methods should be public imo
Thanks for sharing. Was this on AnyCable or using the default ActionCable server?
Yeah. I‚Äôm definitely talking about schools/boot camps in the us. 
It‚Äôs a bit of a throwback to old internet days when people just wrote their blogs before social media. 
Thank you. Installed and tried to run it: [error] No parser could be inferred for file: ruby/my.rb
Well do you want to check it out and give some feedback? :)
Yup the cover was inspired by manning. But manning themselves have copied their art work from out of copyright publication.
Yes http://i-love-ruby.gitlab.io/
Amazon has no zero price option, so kept it minimum. Actually I want my book to spread to people who are on Amazon Kindle unlimited. For them its just $9.99 I think and they can read what ever they want in a month.
Thank you.
https://tenderlovemaking.com/2016/02/05/i-am-a-puts-debuggerer.html
you already have a post about this. 
For a command line tool like Thor, I‚Äôd make sure to keep my actual application code in its own class(es) and use Thor as the interface to those. Then I could do the same thing with some other cli gem or even just with the built in OptionParser. This way you are only using the gem to call your code and not to define the code. This won‚Äôt work with all gems. Sometimes you have to accept that to change gems means significant refactoring. 
I think running Rubocop through the code in the book would really increase the readability of this book.
Just ordered your book on Amazon. Thanks a lot for your work!
A quick point of order. This post received a report for being spam, I suspect because a similar post already went up just yesterday. However, I've approved this post solely because it seems this extra post has sprung from being a little overenthusiastic, and there are so few books released about Ruby these days that I think any that *are* could do with a little help. Please don't take this as carte blanche to keep posting about the book every day, of course, in which case such posts may need to be moderated.
Sorry the README is in flux right now because we‚Äôre republishing it under the prettier namespace. As a temporary fix you can add ‚Äîparser=ruby to the line and it‚Äôll work
Ok thanks, will try to have a look at the frameworks you mentioned. &amp;#x200B; Also following a Ruby on Rails course on pluralsight, probably just still don't know how to chain everything together. &amp;#x200B; Should I focus on back-end for Ruby or treat it as a general programming language?
I'm probably the worlds worst "rubyist" because I've used it for 8 or 9 years and never touched rails. I literally couldn't tell you anything about it. If you like maintaining huge monolithic apps and having skills that appeal to startups-turned-enterprises, by all means learn it.. but it isn't a requirement. But speaking generally here, the starting point for learning any framework should be learning the language. So yeah, learn ruby's core library before diving into rails.
Interesting idea, on the React project I'm working on I'm getting data from 2 APIs and almost the entire website is built on top of it (basically a lot of info on hospitals that I iterate through all to generate a webpage with all of them). &amp;#x200B; But I can't think on how to translate it to Ruby. 
Thanks, I had a look and yep a lot of them are "problem solving", but they give an overall good knowledge and challenge your brain into lateral thinking. &amp;#x200B;
Is it good to assume that Ruby is used only as a back-end language?
just scan the book a little bit. take it with a grain of salt if you want feedback - you need some english proofreading - you tend to just have some short simple phrases and not explain why some things happen - you use geany. the hole internet speak about vscode, sublime, emacs, vim, rubymine - yiu have some pics from windowsxp :) - you are using 2.4.0 as version, you should try to update this to the latest version - string_1, and string_2 are not proper variables that you want to teach for a newbie in programming :) - you tend to repeat a lot :) - you skip explain blocks and start using them under loop section :) - under Array array section you have some spelling mistakes, you tell your readers about appending strings and integers but you never explain this previously :) - explain about set theory and then just doing and use &amp; or | in a very short sentences will not help a novice. - you should explain methods not functions, when you are teaching about classes. - wrong indentation - using set/get is not ruby way. - starting the inheritance chapter like this: `We evolved from monkeys. Chimps look like us`. I will change this to more simple and more general programming concepts :) - you confuse override with refinements in ruby :) - Polymorphism is totally wrong. Sorry. I guess I will stop here scanning your book. Is a great effort, but you need to think about: - who is your target - explain the language not the STD - explain concepts not show how ruby works - work more on ruby way of doing things best! 
you can you pry, or debugger, or byebug
This. When writing Thor CLI applications I make sure to let my gem have a CLI class that defines all the actions. Thor is just there to parse input and execute my codebase.
Oh okay. Actually amazon approved my print edition, and when it was done I posted to the group.
Please send feedback, it matters a lot.
Thanks, will do.
Yup, but this one is for the print edition.
Thanks a lot man. I need critics like you to improve. I don't think I can correct all in the next iteration, but I will try my best.
I use [dry-containers](https://github.com/dry-rb/dry-container) to manage dependency injection and create wrappers as an abstraction layer for the gems I use.I 
Technically speaking, Thor stopping development is not a problem, as the gem is still out there for you to depend on, you could even fork it and republish it yourself if you so chose to do so. The more common issue is breaking API changes that you have to adapt to. The question you have to ask yourself is architecting your app in such a way as to completely isolate your dependencies is even worth it. If you spend twice the time building a feature to make it easy to adapt to a completely different library, and never do, this investment is wasted. To be clear, I have had to replace gems before that were extremely difficult to replace, but it was almost always because they didn‚Äôt ‚Äústay in their sandbox‚Äù or did a bunch of global patches to activerecord that ended up being used all over the application. But rather and spend a bunch of time trying to abstract them away I just tend to be a little more choosy on which gems I use. If they are too greedy with the api they expose I use something else, or I just implement it myself
4 dynos for AnyCable; with Action Cable they used ~20 dynos for the same amount of clients 
I think that's a good point, e.g. indentation is inconsistent in [this](https://i-love-ruby.gitlab.io/#_functions_in_class) chapter. But overall a very nice book, congratulations on releasing it!!
Thanks for highlighting the statesman gem. The (new) Enum class gets used in the [Universum runtime for Small, Smart, Secure, Safe, Solid &amp; Sound (S6) Ruby](https://github.com/s6ruby/universum). The universum world computer (runtime) is itself a (big) state machine (like ethereum) :-). Here's a usage example: ############################## # Crowd Funder Contract State = Enum.new( :fundraising, :expired_refund, :successful ) Contribution = Struct.new( :amount, :contributor ) FundingReceived = Event.new( :address, :amount, :current_total ) WinnerPaid = Event.new( :winner_address ) def initialize( time_in_hours_for_fundraising, campaign_url, fund_recipient, minimum_to_raise ) @creator = msg.sender @fund_recipient = fund_recipient # note: creator may be different than recipient @campaign_url = campaign_url @minimum_to_raise = minimum_to_raise # required to tip, else everyone gets refund @raise_by = block.timestamp + (time_in_hours_for_fundraising * 1.hour ) @state = State.fundraising @total_raised = 0 @complete_at = 0 @contributions = Array.of( Contribution ) end def pay_out assert @state.successful? @fund_recipient.transfer( this.balance ) log WinnerPaid.new( @fund_recipient ) end def check_if_funding_complete_or_expired if @total_raised &gt; @minimum_to_raise @state = State.successful pay_out() elsif block.timestamp &gt; @raise_by # note: backers can now collect refunds by calling refund(id) @state = State.expired_refund @complete_at = block.timestamp end end def contribute assert @state.fundraising? @contributions.push( Contribution.new( msg.value, msg.sender )) @total_raised += msg.value log FundingReceived.new( msg.sender, msg.value, @total_raised ) check_if_funding_complete_or_expired() @contributions.size - 1 # return (contribution) id end def refund( id ) assert @state.expired_refund? assert @contributions.size &gt; id &amp;&amp; id &gt;= 0 &amp;&amp; @contributions[id].amount != 0 amount_to_refund = @contributions[id].amount @contributions[id].amount = 0 @contributions[id].contributor.transfer( amount_to_refund ) true end def kill assert msg.sender == @creator # wait 24 weeks after final contract state before allowing contract destruction assert (state.expired_refund? || state.successful?) &amp;&amp; @complete_at + 24.weeks &lt; block.timestamp # note: creator gets all money that hasn't be claimed selfdestruct( msg.sender ) end
Thor is open source software. If its development ever stopped, nothing about your working application would ever have to change, the gem wouldn't *go away*.
I mean, it‚Äôs fine. The example cited is complete garbage though. Git is managing the files, not ruby. Ruby is just analyzing the git repo
as I understood GitHub was rewritten in Go (mostly)
Yeah the "write a web crawler" project is usually when I find out the bad parts of a new language. We use a bit of React at work, there is definitely nothing wrong with adding it on top of rails, as the react-rails gem is pretty awesome but it might be unnecessary if you're already running on React IMO. We generally we use Rails as the back end "data store" for the json data, so the routes your react app would call to get the data. This may not apply to your app though. [A JSON only rails application](https://guides.rubyonrails.org/api_app.html) will be decently fast as the view layer gets skipped. But it allows you to push things like authentication into the Rails application and just fetch local routes which avoids cross domain requests as your Rails app can handle the site to site stuff in the background. Basically all of the client side stuff you can't/shouldn't do, you now can push into the server side rails application and just fetch what you need via JSON routes. For your purposes I wonder if you could leverage something like the [Ruby Object Mapper](https://rom-rb.org/4.0/learn/) or the [dry ruby gems] (https://dry-rb.org/) to compose objects
meh, I wouldn't make that claim. I wouldn't think there's anything about ruby that makes it better at managing files than python. 
source?
Ruby is a great language for a lot of reasons and it has a lot of gems for handling files and processing them. Ruby is quite capable of doing these things and doing them well. Is it "the champion" of doing this? Objectively, no. Ruby is slow, and I mean very very slow. Look up some benchmarks of pure ruby csv parsers vs C cvs parsers. The times will not even be close. Subjectively, however, maybe. If it's easy for you to read/write the code and it's fast enough for your purposes, then sure, it can be your champion The examples you gave don't really show any of ruby's strengths for handling files. The websites (or parts of the websites) themselves may have been programmed using ruby, but all of the core file handling stuff is handled by git which is written mostly in C. That being said, ruby is a great language with elegant syntax and loads of gems. Its meta programming is extremely powerful. I had a Java and PHP background before I started working with ruby and I'll never go back. Development in PHP is an order of magnitude slower for me. Ruby is an absolute pleasure to work with. As for "should you use it?" You should probably stick with what your team knows, especially if this is a large project that you'll be responsible for maintaining. Depending on the scope of what you're doing though, it could be a good thing to try ruby out; it's an opportunity to expand your knowledge and become a better programmer. P.S. it's = it is, its = belonging to it. üòâ
there is no better or worse. most decent programming languages have a standard library that basically hooks into whatever the underlying os provides. the way you work with files may differ slightly but underneath it‚Äôs the same shit. now, if you look at the way the code flows, looks and feels, ruby is like poetry and python is like communist poetry. 
https://www.reddit.com/r/programming/comments/aobww7/a_lot_of_github_infrastructure_is_in_go_now/
It was mostly in Ruby/Rails. This is literally news from last couple of days. Not sure to what extent go is used.
No, but there was a tweet this week that the actions framework is in go
This is a very incorrect statement.
Sure, but the GitHub website is still on Ruby on Rails. [Here's why they did some stuff in go](https://twitter.com/p_reynolds/status/1093856251593805825): &gt; Not much, no. App tier is still Rails. And CPU time (especially of in-house software) isn‚Äôt the dominant part of our hosting costs. This is more about programmer effectiveness in the niches Go serves well.
PS: Thanks to Matz (the ruby founder) for highlighting sruby! See &lt;https://twitter.com/yukihiro_matz/status/1092631315252310016&gt;.
hmm. so we rewritten parts of it because our developers heard about this shiny new thing and all of a sudden it‚Äôs ‚Äúall go‚Äù. cool story bro
cool
Switch Games written in Ruby?! How can I get started?
Well Amir said April :-). summoning /u/amirrajan 
That could boost the platform
I‚Äôll reveal it in April :-)
I was very interested in RubyMotion, but it seemed at the time that you needed to buy a very expensive license just to try it out, I wasn't going to pay it by myself, and I wasn't going to ask my employer if they would pay for me goofing around with some software.
It's probably more fair to argue that you don't personally see a _need_ to solve the problem that the OP has presented. I would disagree with that argument, though. For instance, have you ever had to encounter an app that's got zero-day security vulnerabilities that nobody can do anything about because the app is stuck in Rails 2/Ruby 1.8.x and would require a herculean effort to upgrade? Because I have, multiple times, and in each case I could point directly at abandoned dependencies as the cause.
it is so funny, if you put it that way
I'm so hyped for a good GUI library for ruby T_T
By Switch, is he talking about the Nintendo?
There‚Äôs a starter license available for you to mess around with. 
Yes that is what it seems to be.
Noted. 
I always think that Ruby is a few improvements away from getting back in with the cool kids. Python has had a surge lately due to AI, but Ruby (IMO) is far nicer to write code with. 
OT: As a Ruby professional running multiple large production projects, all profitable and a couple pretty large, I really don't get the "Ruby is dead" vibe. Ruby ain't going anywhere. That said, RubyMotion is GREAT, I have had a license since the inception of the project based just on how cool it is. 
Not to hijack this post, but what 2D game would you love to build? Replying will help me do a gap analysis. 
‚ù§Ô∏è
It's moved into "mature" language territory, which means "the cool kids" think it's dead. In reality ruby is fine. 
&gt; $ /node_modules/.bin/prettier --write --plugin=prettier-plugin-ruby ‚Äîparser=ruby ruby/my.rb &gt; -bash: /node_modules/.bin/prettier: No such file or directory &gt; % Nope. That didn't work. Let me know when you're "done" with the README and I'll give it a shot. I'd also happily help tweak the formatting; it's something I do at work... Thanks for trying to make it all good. Much appreciated.
Feel free to hijack this post. People generally do not think about RM and It would be nice if they started. To me personally i am interested in all sorts of 2d,2.5d tower defense games.
played the game Rampart?
Nope I did not. Also ever heard of Istrolid ?
I haven‚Äôt, but I‚Äôll definitely check it out!
I know this isn't what you're asking, but have you considered just interfacing with GSheets directly? They provide a [client library](https://developers.google.com/sheets/api/quickstart/ruby) and everything.
I don't at all mess around with non-free software, but this is a very interesting development.
Good that it will be partially open source, but it won't have any effect on a "renaissance". The ruby renaissance will have to come from within ruby itself, primarily. We know it is possible - python did so. Ruby will have to cover several key areas: - Improve documentation everywhere. - Focus on making every day tasks simpler and easier to solve. - Focus on making every day tasks more efficient to handle. I don't want to keep on using hardcoded paths via require alone - I want to be able to use a more sophisticated way to require file/files as is, and easily change them at a later time too, without having to micro-manage every .rb file (avoiding circular dependency warning etc..) - Ruby will have to focus more on the www in general, too. The www is just about the single most important thing. Rails is just making the rest of ruby too lazy. The www should be a first-class citizen. That is the only part PHP got right (and you can see how javascript is nowadays used more widely than PHP). - mruby should be the basis of MRI ruby. Keep everything super-modular. One base to rule them all. - Did I already mention more documentation? - There should also be a ruby variant that can be compiled, a bit like crystal, but in ruby. The syntax may not have to be the same as the main ruby "scripting" language, but it would solve a lot of any speed problems that may still remain. Lots of more things can be said but I think the title is just too brash. A renaissance is also very unlikely to happen over night - you will need more baby steps. Also, the rubygems ecosystem should improve a LOT. It's ok, but not mega-awesome. The ruby tool box functionality should be integrated into rubygems.org. (rubygems.org is quite ok but we could need more integration). Anyway I think that may be for another thread - the "renaissance" term just triggered that response.
I doubt you can attribute python's rise in popularity with AI. Here, locally, there were lots of courses in python but none of them had to do with AI. Python simply is a "default" choice for when people need a simple but clean programming language. The biggest problem is that barely anyone knows ruby; and if they know ruby, they think it is rails. This is also an area where ruby has to become more ... hmm ... known. And then used, too, of course. There may be a slight language barrier too - too much japanese-centric communication makes it hard for a language to become more "global". It's also a bit difficult to compete with python after it has a lead. You don't "just" have to be better, you actually have to be a LOT better than python - and while I think ruby is better than python (I can explain why), from a language designer's point of view, the thing is ... you sort of need to be overwhelmingly good, rather than just "a bit better", to make huge strides and a dent. People love to keep on using what they know. There are lots of people in academia who still use perl, largely because they are too slow, old and lazy to learn anything new (and also because they can get things done in perl, too).
I don't think "ruby is dead". If you look at the google trends, PHP lost significantly more than ruby in %, perl is at a dead man's stage, and even javascript has a hard time growing. Only python is either growing or holding its ground. People LOVE hype. It interests them more than anything else since that may not be as interesting to them. People want to stare at whatever is awesome and so they follow the hype to the next hype to the next hype to the ...
Thanks! I'm open to other solutions, as long as the output of the web scraper is quickly available in excel or gsheets. I didn't know that it existed. I'll definitely take a look and figure this out!
To me I never had a real use for any IDE to begin with. I am still not sure why people need one when they write ruby. I actually use KDE konsole+terminal+editor as an IDE of some sorts; ruby is handling tons of stuff on my computer system. I use it to compile everything from source, too. It literally is my way to interface with the computer and the www etc... I'd wish ruby would be like C though in regards to being able to have a complete and fast operating system. UNIX/Linux is great (I refer to non-systemd *nix, not the red-hat infected crap) but ruby is simply better.
that‚Äôs the story of go :)
Ruby-gtk works quite ok-ish.
This is the old DOS game right? Where people had a short time to build some walls then the opponent started to whack away on it?
No worries, best of luck with the book, and congratulations!
I think the question is odd. GitHub and gitlab use primarily ruby on rails, yes? For the UI part. Yes, that is also ruby of course, but rails is not like ruby and vice versa. So when the coworker says that ruby is good at managing files, he refers to a stack of code, in rails, yes? In theory you could do this in any other language, can't you? If we compare ruby and python, then I think ruby's design is far superior. File.readlines() or File.open() {} is a LOT more logical in my opinion than python's variant. In general ruby goes a container OOP like approach whereas python is quite strange ... python is like an OOP language that has been designed starting from functions as a first-class citizen. I guess you can even find that in the history and python's origin. The OOP model is simply a different one from ruby. As for Node - JavaScript is not worthy to call it a real programming language, just like PHP. JavaScript was just a trolling attempt by its creator, and because there was no simple language back then that would allow for ... well ... manipulate data from the client side.
Ha. Allright, I was kinda on the fence but (especially considering the free license) I'm sold.
&gt; Objectively, no. Ruby is slow, and I mean very very slow. That is not really "objectively" since you compare DIFFERENT TRADE OFFS HERE. Yes, C will be super fast, but is there a cost involved? Of course. People tend to have to write more code and think harder when writing in C. There is a reason why "scripting" languages became popular - perl, lua, ruby, python, javascript. &gt; I had a Java and PHP background before I started &gt; working with ruby and I'll never go back. Yeah. Going back to inferior languages is hard. I contemplated using other languages than ruby but the problem is - after using ruby, you begin to realize how much most other languages SUCK. This is actually the biggest shortcoming from the old biggies. Take a look at C++. It added some "auto" thingies where you have to define less; and they made iterating over collections simpler too. They literally re-used ideas coming from the "scripting" languages here. C++ on its own would have never evolved that way. There is so much inertia and awfulness in applied programming - I am surprised people love being paid corporate hacker drones. I find that utterly awful to waste my time away in java (or any such rubbish languages).
But they use many different languages, so I don't get your assumption based on a reddit comment based on a twitter tweet. I think for a real evaluation we would have to know which languages are used and the amount of code in use at that corporation, too.
But it is actually true. There is no real technical reason why they use Go other than WANTING to use it. They are just on the hype train, until they get bored again. And they literally use lots of different languages.
Yes!!! It‚Äôs like Tetris meets castle building 
I am not sure why you are replying to me with this? Are you replying to the wrong comment? RubyMotion is not an IDE, it is a set of tools and a framework to compile from Ruby to a native binary that works on iOS, OSX and Android devices, you can use whichever editor you want, IDE or not.
Hand to heart I really do care about fellow devs and helping them succeed. That‚Äôs number one over money for me. 
To clarify: RubyMotion is a compiler that converts Ruby into LLVM IR, which can then be sent through the rest of the LLVM‚Äôs compiler infrastructure to create bitcode targeting all supported chipset architectures. 
Only runs on OSX for now üôÉ But yes, you need a Mac to compile. 
There is a play-through here (for anyone wondering) and those DOS graphics are so pretty! https://www.youtube.com/watch?v=EfrhOwM7kf0
In general the simpler your data structure, the easier it will be to display it on the commandline. If for some reason you can not or do not want to simplify the data structure, I would recommend building up the data structure that you wish to use for display. This may be the case in your example already, so we can try to skip to the next point. But it would perhaps be simpler if you use a Hash rather than the "job" Array. Hashes are sorted in ruby since some time, so .each_pair could be used as-is and it will already be properly sorted if you did that prior to calling .each_pair. I often just populate a hash with what I want to have. You can easily store any data structure in yaml too and re-use that, too. If you have it as an array let's use pseudo code - if you have the Hash: hash.each_pair {|key, value| # and then well, puts value[:title] # or whatever the name is I usually use "pp key; pp value" to see what is what, then I change it to the respective keys. It's really that simple. I even use classes for that; the report method is usually the one that will display data onto the commandline.
I didn't notice the starter license when I researched it, I think it was more than 5 years ago. My daily rate is more than 200 USD, but thanks for being so reasonable and forthcoming.
Everything you‚Äôve mentioned is accurate. Which is why - personally and specifically with Ruby on Switch - I‚Äôm putting Ruby‚Äôs renaissance in the hands of the most passionate people out there: kids. Joy first. Wonder and awe first. Happiness first. This is the aesthetic of Ruby that matters. Python et al can have the current Enterprise TM world. My goal is to arm the _next_ generation of devs with Ruby tipped weapons.
Exactly ok-ish but still does the job for small UIs, RubyMotion though! I liked more the way things are done and wanna dig more in it, and in the mobile apps too.
I ended up doing the stupid way and parsed ARGV directly. I hate optionparser but the alternatives are not great since it adds one more dependency. Parsing ARGV yourself is a bit stupid BUT that way I don't have to worry about any external code much at all; the best thing is that I can treat input, such as ARGV, through classes that will respond to user input. I'd do it the stupid old way and e. g. if someone is passing something like --use-this-as-directory-for-extracting-archives=/opt I'd just let that call the corresponding setter-method. And the class then handles it just regularly like any other situation (e. g. called internally only too). The bottom line is - you actually don't need any of these commandline-parsers really. For standalone .rb files they can be nice, but for larger projects I found that I don't need them. Even writing code that scans over ARGV for "--" values is not that long to write in ruby; and in larger projects you often can abstract this into some .rb file anyway. But it's also ok to use a commandline-tool if you need some special code in it.
Btw last release of thor was November 2018: https://rubygems.org/gems/thor/ Are you absolutely sure it is dead? How do you know there are no different gem maintainers?
You may want to look at table print: [http://tableprintgem.com/](http://tableprintgem.com/)
&gt; The yield_self method didn't make much sense to me until aliased to then It still does not make a lot of sense to me. BUT "then" is a better name than yield_self. I think in general, the shorter a method name can be, the better, normally - at the least when you look at alternatives such as yield_self. I have admittely gotten a bit old so I am not so easily up for any recent change in ruby myself ... then again I also don't feel that all changes in the last 3 years were that awesome; and several others on reddit also said something similar. My hope is just that the good changes will still outweigh the bad ones (I have no qualms with changes that are not good or bad; they are just neutral and I am neutral. I am only concerned about bad changes; and yes, that is of course subjective since different people may feel differently about any given change).
‚ÄúDonald Trump is an Idiot‚Äù. I like her/him already!
SNES style JRPG
Final Fantasy 6/3 a good bar? Are were you thinking Soulblazer/Illusion of Gaia/Terranigma?
What‚Äôs the best book for ruby noobs in your opinion?
FF6. So many good times
Done and done. I loved that game so much too. Makes me nostalgic just thinking about it. 
Yeah, my point was that you can't objectively say that ruby is the champion of processing files, but you could subjectively say that if it's better for you. I definitely see what you're saying, but I don't think it's fair to call java and c++ "inferior" or "rubbish". They serve a different role than ruby and they are the superior tools for some tasks while ruby is better for others. In the end, the important thing is that what you make works and is maintainable. I would personally never go back to those other languages, but there's nothing wrong with others enjoying them.
&gt;I don‚Äôt at all mess around with non-free software This fundamentalist stance is horribly unproductive rhetoric imho. Not saying that you‚Äôre one of these people but... 99% of people that take this stance have never contributed non-trivially to open source. For example (contextual to this subreddit): if you‚Äôve never cloned Ruby and compiled it from source, you are just as ‚Äúbad‚Äù as people who build proprietary systems. Worse even, not only do ‚Äúyou‚Äù (in the general sense) refuse to pay for proprietary libraries, but also don‚Äôt ‚Äúpay‚Äù for open source ones either. Just my unsolicited two cents. And again, this is a criticism of the comment with a large dose of assumptions. I‚Äôm not trying to directly attack you. 
I am a fundamentalist but, unproductive? Maybe for rich tech company owners but I'm productive as heck. I don't know what you're referring to.
If you want to load lines into an array, you can use `File.readlines`.
Thanks, how did I miss this lol. 
Counter argument: Machine Learning and Data Analysis make up 2 of the top 3 uses for Python by professional developers. https://www.jetbrains.com/research/python-developers-survey-2018/ But you are right, Python being entrenched in the data science space is pretty much just an accident of history. Ruby surged on the need to deal with a specific set of problems around web development (via Rails) and then went on to make its mark in the system management space (via Puppet and Chef). Python grabbed AI (via TensorFlow) while we weren't looking. I'm reasonably confident I'll still be coding in Ruby in five years time, even if Ruby never has its own TensorFlow-eqivalent - because there'll always be interesting problems to solve and Ruby is still such a beautiful language. Maybe I'll end up like those old Perl coders - slow, lazy and old. Doesn't sound _too_ bad :)
The best and most fun resource I found is https://github.com/JoshCheek/ruby-kickstart Clone the repo, Set up the tests and start solving the puzzles. You end up learning Ruby by using it, while solving CS puzzles with increasing complexity. The exercises are fun and addictive and will help you level up on important CS concepts while seamlessly learning the language. 
Sorry ‚Äúunproductive‚Äù as in: stating you‚Äôre a proponent of free software and won‚Äôt use proprietary software, leads to unproductive discourse.
I want to like rubymotion, because ruby was the first language I actually enjoyed using, and I‚Äôm now getting into iOS development. However, I know swift now, and it‚Äôs a good language. What incentive do I have to give up Xcode? I don‚Äôt see the value add.
Interesting... so this is at the initial RFC stage, for the general concept? _I.e._ no code _per se_?
Sweet!
100% agreed :)
Anyone with experience writing mobile apps in both React Native and Ruby Motion? I'm curious to know how they stack up. 
I think it's the secondary effects of AI, and other academic uses. Researchers use Python, and they work in universities, so the universities end up teaching Python. Students eventually graduate from the universities, and enter the job market, leading to Python's current popularity.
:)
I know this sub thread is replying to the first half of the thought, keep in mind the other half of the context following the comma. There is an opportunity to re-focus the discourse in a productive direction by getting curious about the original posters thoughts on the interesting aspects of the development.
I basically want a subset of Phaser.js with a more-sane design.
Does it work on Ubuntu?
Android development using the same language would be the primary differentiator In the specific case
Metriodvania 
What‚Äôs your favorite one?
A subset of the runtime will yes. 
Wow I love that. At least once a year I google ‚Äúruby enumerate group and count‚Äù and get the exact solution that OP mentions
Galaga. Or Joust. #whynotboth 
Totally a fair statement (especially with regards to trying to understand why a specific stance is taken instead of lashing out as I did). The fundamentalism is just a personal pet peeve of mine, specifically because past conversations I‚Äôve had led to intrinsically selfish motives (ie ‚ÄúI want stuff for free and want others to bare the burden of the cost‚Äù). Maintainers are burning out from poor contribution ratios and poor compensation models. The solution definitely isn‚Äôt to keep parroting the current free software rhetoric.
Noted. 
Sanity is a top priority of man. I feel like all game engines these days are operating in an ‚Äúold school‚Äù OOP/C++ local maximum. I‚Äôm definitely not making these same mistakes... hopefully 
Is ja rule involved at all ha ha ha just kidding i hope it turns out well for the folks who go have a good one
If you aren't already, try to get in the habit of checking ruby's docs for stuff like this. There's a really readable version up at [ruby-doc.org](https://ruby-doc.org). Click on 'core' up at the top and then scroll down and find the class you want documentation on. Also, when you're looking at the documentation of a class, it's always a good idea to take a look at its parent class's docs as well (convieniently located on the left sidebar).
Yeah, we'd been pushing for it for a while and it finally landed. What's funny is if you watch my RubyConf talk, you'll notice in the section where I show that function I make a mistake and call it "count by" instead of "tally by", as Matz had just rejected the other name a few weeks prior to that. Amusing Ruby trivia of the day I suppose.
Diablo style Action RPG
Super Metroid for the SNES
SimEarth
/r/pyxel/ might give you some inspiration. it's written in python and for the terminal, but lots of great examples.
What was your favorite diablo class?
Oooooo! I forgot about that game 
I'm happy this feature will exist. Thanks for sharing it. Unfortunately, I found this article confusing or unclear in several respects. * It spends most of its leading text describing backstory and people involved in this feature (which may or may not be interesting to people who don't follow the inside baseball of Ruby). * It refers to "our fun little annual tradition," but it's unclear who the antecedent of "our" is (the Ruby maintainers, I assume, of whom the writer of the article is presumably one) or what this tradition is (presumably a yearly release cadence, based on the 2.6 release reference). I can assume from this that `Enumerable#tally` is slated for release (with Ruby 2.7) *next* December, nearly a year away, but that's not explicit. * There's a section called "The Code," but this is yet more backstory because it links to the patch to add the feature and the author's comment on the issue tracker discussion about it. None of this is especially helpful in understanding what the feature is unless you just really like reading C or following lengthy discussions. * In the "Vanilla Ruby Equivalent" section, we finally reach the all important question, "What does this method do?" Sounds like we're finally going to learn what this is, after an introduction and two sections of backstory. Unfortunately, there's no actual explanation here. It's just Ruby code. * After that block of code, there is an offhand reference to the fact that it uses an "identity function" by default. (Unsure if Ruby programmers are accustomed to that term.) * Finally, some examples. Reasonable. * The "Why Use It?" section doesn't actually say why you'd use it. It instead just supplies another chunk of code and says `Enumerable#tally` does the equivalent. I don't know if the author will read this comment, but here are my notes. * *Briefly* contextualize the Ruby 2.7 release process (e.g., Ruby tends to release in such-and-such a timeframe, 2.7 is next, and it typically includes improvements such as Enumerable#tally.) * Describe `Enumerable#tally` right away. Extricate the three salient details which matter: what it *does*, what problem it *solves*, and *how* it solves it. * Use words to approach each explanation, supplemented with code examples if necessary. For example, for what it does, say that it builds a hash. The keys are the values of the enumerable (possibly after those values have been passed through a function), and the values of the hash are how many times each enumerable value occurs. For what problem it solves, propose situations in which a histogram of values might be useful. Further motivate it by showing what code it can supplant (as the author did in the "Why Use It?" section). For the how, maybe dive into the C code, perhaps translating it to a Ruby equivalent directly. * Having described some of the background‚Äîthe motivation, perhaps the implementation‚Äîthat may naturally lead into the background of how this feature came about: all the nitty-gritty so that people can feel engaged with the story without the distraction of skimming for the feature. Thanks for reading.
Good resource. Thanks :thumbsup:.
they are all my favorite
Awesome, thanks for sharing!
Sorry I am unable to understand. You saying that if I ask a car, you will provide the engine?
You can‚Äôt build iOS, Mac apps on a Linux machine.
depends a lot of your knowledge. 
Myst style adventure
Would Thimbleweed Park fit in that‚Äôs space?
I think the simplest thing is just to well... code simply. Abstracting interfaces to well-established gems seems a great way to overly complicate your application. Yes, by all means use dependency injection when you need it. And architect your code so that you don't end up with "everything connected to everything". But IMHO, wrapping too much of your code in adapters and the like can be a classic case of premature optimisation. It's like the case when people try to write portable SQL, against the day they want to move to a different RDBMS - and then never do. The best defence against the problems associated with re-architecting is to have a solid test harness - so you can rip things out and replace them knowing you haven't broken anything.
Author == Op, for reference. Rearranged some things, will reply more formally tomorrow.
This was the sentence I was waiting for the whole time! Finally I can give RM a try! Will I be able to create Linux/Windows Desktops apps as well?
It is perfectly acceptable for him to ask others for pointers here. And people are fine to not answer it either. See janko-m for giving a good answer.
&gt;It is perfectly acceptable for him to ask others for pointers here. Of course it is. I wasn't trying to discourage it either... I was only providing another way to find the answer (possibly even more quickly) if the OP gets stuck on something like this in the future.
It sounds that it's exactly what I'm looking for! Thanks spiffistan! &amp;#x200B;
Thanks!
It's working code. See &lt;https://github.com/s6ruby/programming-cryptocontracts&gt; for contract samples or &lt;https://github.com/s6ruby/universum-contracts&gt; that you can run today (on your very own computer) with ruby :-).
You‚Äôre missing the period at the beginning of ./node_modules.
Also you should check out the README as it‚Äôs been updated many times now.
Cool... will check it out. Thanks.
Ruby isn't dead, but Ruby isn't growing, relative to total programming languages market. 
This should have been in a long time ago. Bikeshedding is stupid.
Neither is C++. And if it has to "grow" like the cancer that is JS, I'd rather have stagnation. 
&gt; I'd be able to redirect the terminal output to a new file and copy the new file's data onto a google sheet. Printing table borders will complicate this. 
&gt; I'd like to display on the terminal, a column for title_1 and a column for title_2 While you don't get borders without some extra work (I'd recommend gem here) for formatting what you print [use `printf`](https://ruby-doc.org/core-2.6.1/Kernel.html#method-i-sprintf) (note that `sprintf` accepts the same args): FORMAT = "%-10s%-10s%15s\n" printf FORMAT, *job[0].keys job.each { |j| printf FORMAT, *j.values } But this may present problems when we look at your next requirement. &gt; I'd be able to redirect the terminal output to a new file and copy the new file's data onto a google sheet. If the ultimate destination is a spreadsheet, you should use [Ruby's CSV library](https://ruby-doc.org/stdlib-2.6.1/libdoc/csv/rdoc/index.html) with tabs as the column separator: require "csv" job = [{:title=&gt;"title_1", :company=&gt;"company_1", :publication_date=&gt;"date_1"}, {:title=&gt;"title_2", :company=&gt;"company_2", :publication_date=&gt;"date_2"}] puts job[0].keys.to_csv(:col_sep =&gt; "\t") job.each do |j| puts j.values.to_csv(:col_sep =&gt; "\t") end Of course output will not always be aligned but if you want to paste into a spreadsheet... 
But it does [have a `:seperator` option](https://github.com/arches/table_print#column-options). 
&gt; If that number is less than $199.99, I‚Äôll give you a discount code for a full year Indie License covering the difference yeey I would save $13 :) I would like to ask some details on the lincensing though. 1) Started license runs only on android 8.1? So if my phone runs on older androids (even 8.0) I'm out of luck on that one? 2) What happens when my indie license runs out? Can I still use latest version which was out when the license expired? Or I just can't use it at all? Will already existing app continue to work?
Yep! Hopefully I‚Äôll have some good news for you in April. 
Thank you so much sshaw\_ for your reply!!! It worked for me! I was finally able to put the data into a csv!
Thank you!
Therefore, Manning have created a derivative work, which they are entitled to, and may well have, copyright. You may use the same copied (out of copyright) material, but you may not be entitled to use it in a similar manner. Great work publishing this book and thank you for releasing it. I'm sure I'll be referencing it frequently.
hello. for non rails friends here :) let's imagine I use: - roda as web - postgres - redis - sequel - and falcon as webserver will falcon make my web app faster and better? u/ioquatix 
You'd probably be better off doing this on the Ruby side, but I'm not familiar enough to help... If you want to do it with pure SQL and some docker-compose configuration: If you create a directory in your project with sql or shell scripts you'd like to run during initialization of the postgres database, and mount it into the container as `/docker-entrypoint-initdb.d`, it will run them in order when it comes online. For example, you can create `sql/01-create.sql` in your project, with create statements, etc. Then, add a volume to your compose file: `- ./sql:/docker-entrypoint-initdb.d`
`join` is not an integer method. 
you want `twod_arr.join`
&gt; Focus on making every day tasks more efficient to handle. I don't want to keep on using hardcoded paths via require alone - I want to be able to use a more sophisticated way to require file/files as is, and easily change them at a later time too, without having to micro-manage every .rb file (avoiding circular dependency warning etc..) any news here from the core devs?
I think u/amirrajan that if you manage to do some noise here, and open source rubymotion, and ask for help and feedback, it will be big change for ruby. I'm upset that ruby core devs never pick llvm for jit, as I'm guessing you are using this for you backend :)
Thanks, but now all its printing is &gt;222222222 
because youre changing each element of `twod_arr` to the value of `i+=1`
How could I avoid doing that? Sorry, I'm really new to ruby and unfamiliar with most concepts. Also, the array should be 9 rows long, but right now all it seems like is that its just printing a single row. 
&gt;I'm upset that ruby core devs never pick llvm for jit There are pros and cons for this. LLVM moves quickly and their straight C api is "best effort". &gt; if you manage to do some noise here, and open source rubymotion, and ask for help and feedback Probably beating a dead horse by now given my other comments. But RubyMotion will be open sourced _sustainably_. Ruby (and by extension RubyMotion) has to compete with languages/platforms provided by corporations such as Microsoft, Apple, Amazon, Google, Facebook, et al. These companies have literally billions of dollars to invest in their languages. Ruby doesn't. The only means I see of combating this would be to bolster the _core_ ruby team significantly. Right now the core ruby team can sit on a stage in an auditorium. We need to fill the _entire_ metaphorical conference hall with core language devs/compiler engineers. If not that, then we need to make sure they have an equal amount of money to compete with these larger organizations. Till some means of getting to this point is reached, I'll be really conservative in what parts of the compiler will be free and which parts will not. TLDR: The current approach to OSS is broken and controlled by very large corps. I don't want to contribute to this status quo, and I'm working towards finding a better way.
That is when C++ already has a large enough market share to be self sustaining with lots of interest from diverse parties to keep it going. And it is not lacking in resources, comparatively speaking. Not the same could be said about Ruby. 
since you want to return `y`, put `y` after `i+=1` this might get you closer: ``` sz = 9 arr=Array.new((sz*2)+1,"-"){Array.new((sz*2)+1,"-")} twod_arr = arr.each_with_index.map {|y,i| if i.odd? == true r=1 y.map! {|x| r.odd? == true ? "+": x } end y } ```
&gt; any news here from the core devs? To stay consistent with my "sustainable" open source theme. Get your hands dirty and fix it, this includes /u/shevy-ruby. I'm here to help you along. The core ruby team is already burdened enough and are definitely handling more high priority things (most of whom also have a full-time job). So seriously everyone. Clone the repo. Get it compiling. Fix a problem. Send a PR.
Thanks so much man!
Use [Array#transpose](http://ruby-doc.org/core-2.6.1/Array.html#method-i-transpose) job = [{:title=&gt;"title_1", :company=&gt;"company_1", :publication_date=&gt;"date_1"}, {:title=&gt;"title_2", :company=&gt;"company_2", :publication_date=&gt;"date_2"}] puts job.map(&amp;:values).transpose.map { |row| "[%10s] [%10s]" % row } The output is like this: [ title_1] [ title_2] [ company_1] [ company_2] [ date_1] [ date_2]
1. Starter license only targets latest. That's the limitation. 2. You will no longer get updates to RubyMotion, but can still compile with whichever license you were paid up through.
Thanks, I'll try this method to,
- roda as web: no concurrency concerns? - postgres: async-postgres - redis: async-redis - sequel: depends on underlying database - shrine: might need more significant work - sidekiq: shouldn't be too much of a problem - and falcon as webserver: yes
Sorry, was a bit late when I saw this first. 1. Backstory - Fair. In this case I happened to write the article just after finding out that aforementioned backstory actually panned into something real, and led with that. Rearranged to put a short version up front. 2. Release Cycle - Fair, bit too insider-y. It's a joke that a lot of the bloggers about tend to actively watch for releases to write about, and February is pretty early to start. It heats up a lot towards the actual release (December) which is when you see a ton of posts on the subject. Granted with how early this one is it may well come out in a 2.6.2, but I couldn't know that one for sure. Cleaned that section up and made it more explicit on the release schedule. 3. The Code - Granted, though it's a fairly short section. Moved it down and renamed to "Source Code" to make it clearer. 4. Vanilla Ruby - I wonder how much I should write on that specifically, as the article would get a lot longer from it. That said, that may well ring hollow considering the backstory bits. I'd written another piece which covers the implementation in a lot more detail, and will consider writing that into the article. 5. Identity Function - Bad habits, clarified the nature of an identity function. 6. Late Examples - Moved towards the top, with an added 10 second "Short Version" 7. Why Use - It looks like I wrote this article more targeted towards intermediate Rubyists, and because of that I'd used examples of areas where they'd likely do the same thing and how the function is useful. I'd failed to consider writing precisely \_why\_ you want to count things in the first place. Will have to think on more examples for that section. Replies on Notes: 1. Release Cycle - Clarified, as mentioned above 2. Describe 1. What it does - Added 2. What it solves - Need to think on good examples for this that aren't too contrived 3. How it solves - Mentioned in #4 above, will consider how best to write that in 3. Story - Moved towards the bottom I think the main takeaway on this one is that I should be more careful to put content first, and watch the assumed knowledge more. Thanks for the reply!
Thanks for the reply, sounds good, will probably check it out after the April announcement :) Last time I've checked it it was iOS only, now it looks much more interesting to me.
We are on ruby `2.6.1` right now :)
Interesting, didn't know you could do that, will give it a go thanks.
[Here ya go](https://pastebin.com/mCnm5MsJ). There's really not a lot that's different. Python doesn't like `'\e'`, but other than that it's pretty close to a copy/paste job.
I like it
I need to stop day drinking
Yeah, I'm pretty sure he means 2.6 instead of 2.7 - unless I'm completely missing something.
I would hard-avoid the AMS-JSON gem. It's current maintenance policies are a mess (for example, the development shutdown on its master branch)! They even suggest alternatives themselves; I would go with Netflix's offering. 
I've been using AMS for so long that i forgot about the existence of alternatives xD. Thank you for your suggestion I'll definitely give fast\_jsonapi a try and update it here too.
 ./node_modules/.bin/prettier --write --plugin=@prettier/plugin-ruby ruby/my.rb ruby/my.rb [error] ruby/my.rb: Error: /Users/michael.sattler/git-repos/how-to/node_modules/prettier-plugin-ruby/src/ripper.rb:13:in `initialize': Unsupported ruby version (RuntimeError) [error] from /Users/michael.sattler/git-repos/how-to/node_modules/prettier-plugin-ruby/src/ripper.rb:224:in `new' [error] from /Users/michael.sattler/git-repos/how-to/node_modules/prettier-plugin-ruby/src/ripper.rb:224:in `&lt;main&gt;' [error] [error] at Object.module.exports [as parse] (/Users/michael.sattler/git-repos/how-to/node_modules/prettier-plugin-ruby/src/parse.js:9:11) [error] at Object.parse$2 [as parse] (/Users/michael.sattler/git-repos/how-to/node_modules/prettier/bin-prettier.js:10641:19) [error] at coreFormat (/Users/michael.sattler/git-repos/how-to/node_modules/prettier/bin-prettier.js:13858:23) [error] at format (/Users/michael.sattler/git-repos/how-to/node_modules/prettier/bin-prettier.js:14117:73) [error] at formatWithCursor (/Users/michael.sattler/git-repos/how-to/node_modules/prettier/bin-prettier.js:14133:12) [error] at Object.formatWithCursor (/Users/michael.sattler/git-repos/how-to/node_modules/prettier/bin-prettier.js:42401:15) [error] at format$1 (/Users/michael.sattler/git-repos/how-to/node_modules/prettier/bin-prettier.js:43770:21) [error] at /Users/michael.sattler/git-repos/how-to/node_modules/prettier/bin-prettier.js:43965:16 [error] at /Users/michael.sattler/git-repos/how-to/node_modules/prettier/bin-prettier.js:43905:14 [error] at Array.forEach (&lt;anonymous&gt;)
We're about to see Ruby be able to compete with and/or overtake Python in the ML space via Truffle. Speed is really kicking up and the 3x speed increase of C extensions over MRI is EXCITING (not to mention no patches): https://aardvark179.github.io/blog/capi.html/
How so? Would not the interest from Japanese companies and usage there alone be enough to keep Ruby going indefinitely from a fiscal standpoint? The good news is that very smart developers seem to realize the value of Ruby over other languages, including python.
RubyMotion has a bitter-sweet taste for me. I paid for it for years before it came under new ownership. I really have always wanted to use it, but we only used it on a couple of projects and couldn't sustain the cost. 
offer stands if you want to take advantage of it: https://www.reddit.com/r/ruby/comments/aovm41/a_renaissance_for_ruby_rubymotion_will_be/eg3y4v8
I also wanted to comment on that style of game. Metroid, Castlevania, Ninja Gaiden. All of these represent so so so so many hours. This month with Xbox gold is this new found gem: [Bloodstained Curse of the Moon](https://www.microsoft.com/en-us/p/bloodstained-curse-of-the-moon/btg951rgx7qd). It's a straight up Castlevania iii'ish clone created last year by the Konami guys who made the originals. I've been so happy playing this game. 
With sidekiq and talli, you need both redis and memcache. Redis can also work as a cache server. Why using/maintenaning both?
`require 'pg'` ?
You're absolutely right but its always good to have another option. Those who use sidekiq can use redis and those who do not use sidekiq and are looking for easier caching solutions, both Redis and Dalli are available üòä
did that
It's tremendous of you to take on all those notes and revisions. It was entirely optional. I think I was just crabby from reading so much documentation that didn't really make sense to me. It's likely that had I followed you or read more by you, this would've made a lot more sense, but I hadn't. It was just a drive-by on my part, and it might've seemed unfair as a result. So thanks for going above and beyond and not reacting badly to my harsh tone.
Github's actual ssh+git backend is (or used to be) implemented in [mostly erlang](https://github.blog/2009-10-20-how-we-made-github-fast/) as far as I know; their ruby background jobs use bert-rpc to communicate with it. The common mantra is that ruby is a massively convenient language, great for rapid prototyping. Historically been popular with startups or small teams that need to get an MVP off the ground quickly. It's not without its share of tradeoffs, however. Your friend technically isn't wrong saying that ruby is an easy language to work with files in... but I doubt ruby would be anyone's first choice for building an app that needed to exclusively manage files and handle requests at github's scale, unless the requirements were "we need it built in a week, and you will be the only person responsible for maintaining it, but we have gobs of money to throw at horizontally scaling it".
Qo is working towards 1.0.0, and I've gotten most of the public API down now. I'm posting this as I'd love to get some thoughts from the community on this before I set it all in stone. Likely I'll be finishing off some documentation changes to try and make it easier to follow, debating on a wiki or what to use, so ideas on that side are appreciated as well!
Oh I'd be lying if I said I can't be equally cranky, hence waiting until the next morning to reply and think on it. It did force me to do some self-reflection, which is a good thing. Documentation is extremely important, so any advice I can get on improving is appreciated :) So on that note, thanks for taking the time to review! I'll keep that all in mind for next time, and certainly wouldn't mind someone keeping me honest every now and then
Thank you!
i was with you until the "As for Node" part. i am not that very well versed in the Node architecture, but i can say anything built on C++ would be better in file managing than PHP or python(that is the whole reason why i included Node in my main question).
Overriding `Class#===` seems like a hack to me. Especially since `SomeAPIAccountExpired === SomeAPIAccountExpired.new` will return `false` with the provided implementation. I would prefer an explicit conversion of error types: ``` rescue SomeAPI::Error =&gt; e case translate_error(e) when SomeAPIAccountExpired ... else raise e end ```
post your code; minimal reproduction case; like this there probably isn't enough information
I doubt we will see Truffle in production for in 5 years.
I would not say that Ruby lacks backing per se. It does have it but it's not a directed continuous stream of devs and money. The problem with Ruby is / was the chicken egg scenario that happened. There are not that many companies with a huge commitment to Ruby. There are some but they can only do so much. &gt;Ruby (and by extension RubyMotion) has to compete with languages/platforms provided by corporations such as Microsoft, Apple, Amazon, Google, Facebook, et al. These companies have literally billions of dollars to invest in their languages. Ruby doesn't. The only means I see of combating this would be to bolster the core ruby team significantly. Right now the core ruby team can sit on a stage in an auditorium. We need to fill the entire metaphorical conference hall with core language devs/compiler engineers. Core/compiler engineers are not very common and it is more of an exception to find them employed outside of very big tech companies. That's almost a given considering the complexity and commitment one need to be one. I am not surprised that outside of FAANG and alike there are only so many compiler engineers. And the truth is /u/amirrajan that most of people are just not capable of fixing issues with compiler or even understand what the compiler is doing. There are other things that people can help with (and people generally do) and that's the ecosystem. I know most of these things are low hanging fruits but they need to be done so compiler devs dont need to do everything. &gt;The current approach to OSS is broken and controlled by very large corps. I don't want to contribute to this status quo, and I'm working towards finding a better way. Yes and no...the current approach to OSS is broken but OSS is not meant to be a free buffet. Corps do OSS to their competitive advantage not because they are a charity. We have already reached the point that you cant make that much money by selling building blocks (tools, compilers, programming languages). It is the same what happened to Docker. Everybody but Docker Inc made money out of Docker. I think by popularizing RM and providing backing services you can earn much more than just by selling RMs licenses.
I totally agree with the "selfish motives" it's also because OSS is broken due to the nature of software but BIG BUT. There are already existing tools for free that I could use and I still bought app called CodeKIT. I would do the same if CodeKIT would be just a frontend for all those oss tools. It's similar to the editor I use. I would probably never fix/submit a PR because I have no time to "care". But I occasionally fix things / implement stuff for packages that I use and care about and I bet majority of people are like that. Oh and there's still the cost/risk assessment on my part...I would nowdays probably not buy a mac only APP. I have been unhappy with Apple's hardware recently and It would be too unwise to put all my eggs in one basket. Sort of why I switched from using TextMate. I liked using it was probably the best editor I ever used but I abandoned it in favor of Emacs just because it's a mac only app. 
I read the pickaxe back then and purchasing it was worth it (the initial one; I got the hardcopy). Lateron I bought the second one and while it was still good, it was not as good as it used to be, because I knew most of the content already. But anyway, if a new pickaxe comes out, I can recommend getting it once. It is not absolutely necessary but it helped me. The by far most important thing is to keep on writing code, though. You will simply learn a lot more that way than purely from reading theory or theoretical parts. I think if you have a difficult time finding something to write, you should first look at what interests you the most; or what you need the most, right at this moment, and go from there. For example, whenever I wanted to do something or needed something, I put stuff into local TODO files, which kept on growing. From there I can then go and start to do smaller things, and write code for them. I give you a random example here what I needed in the last 2 hours. I needed a method that obtains all entries, via an Array, from a remote URL. I then would feed that Array into a 'wget' system call to batch-download remote entries (I know I could use recursive wget, but I like being able to delegate all these things onto ruby). This is not rocket science, it is just boring, simple tasks, but I needed it as a new base component for code that I will write later in this week. That is just one example, I am sure you can find more. Just focus on what is the most interesting to you; or what you need right now or in the next days, and go from there. Extend every day a little bit; don't forget to add documentation. Also, once it is of an acceptable size, I recommend to put it into a gem too - you will learn more that way when you package your code for re-distribution. &gt; I'm also learning JS and React from scratch and it's &gt; easier for me to put the knowledge to work immediately, &gt; eg. building a website entirely in JS and then do it again &gt; but in React. Yes, I remember that was my impression too when I moved from perl to PHP - I could sort of test web-related things more easily in PHP than in perl. I moved to ruby since ruby is about 100000000x better than both perl and PHP and never looked back again (and still do everything web-related in ruby). I think you really just have to pick something that you want to do or like to use and go from there. Just anything really - ask yourself what you need right now, and go from there. You'll keep on adding more things that you need over time anyway and then questions like the above will be answered "on their own" almost automatically.
&gt; &gt; &gt; Should I focus on back-end for Ruby or treat it as a &gt; general programming language? This depends on your needs. I needed a general purpose language and I picked ruby after an old interview from matz that he did in e. g. 2003. https://www.artima.com/intv/ruby.html So I used ruby before rails. I don't use rails; I don't depend on rails. I'd find it very sad and boring if people would only have an interest in ruby because of rails. I actually recommend people to NOT even come to ruby if it is purely due to rails. My experience was that people who do so won't stick with ruby, and this is unfortunate for everyone involved. Only use ruby if you have a need for a general purpose language that is elegant. But be aware that ruby is really awesome - it will be very hard to move to another language afterwards since most other languages really, just objectively, SUCK. One exception is when you need more speed, then you may have no choice to use a faster language; most people won't need this though. And the faster languages will suck a LOT more than ruby. Ruby is for humans.
That's actually similar to my use case, although I built that web-shop example via rails. And it worked too. Then rails got bigger and bigger - and more boring. I actually think that this is not even rails fault alone; the whole www stack is pretty much a HUGE cluster-fudge. Zedshaw said that rails is a ghetto (well, it's a fair comment if you look at speed + complexity), but this can be applied TO THE WHOLE WWW STACK really. &gt; I can feel the incoming downvotes I don't think there will be many downvotes. There aren't THAT many rails people really; I'd say about 50% 50% or so. People totally over-inflate how important rails is. I get that, but lots of people use ruby because of ruby, not because of rails. &gt; But speaking generally here, the starting point for learning &gt; any framework should be learning the language. Agreed. I also feel it is not worth the time investment by other people if people only jump on the bandwagon due to rails hype alone. They are not real ruby-hackers really (most of them, not all of course; tenderlove is using rails, regular ruby AND writes C code too, but let's be honest - most people are not like that).
A Dwarf Fortress like game would be nice
As it says in the README, you need to be running at least Ruby 2.5.
There are various ORMs (Object-Relational Mappers) out there. Those wrap DBMS, so you can change between e.g. postgresql and sqlite with less effort. To list a few: \- [sequel](https://github.com/jeremyevans/sequel) provides a good, [short Example](https://github.com/jeremyevans/sequel#a-short-example) provides a good example for sqlite3. You benefit from a fast setup. \- [activerecord](https://github.com/rails/rails/tree/master/activerecord) is the Rails default ORM. I would use ActiveRecord if and only if i have a plain DB setup. Adapting to an existing database can be hard. \- [rom-rb](https://rom-rb.org/) is another ORM i can list. However, i didn't work with it, because sequel did match for most cases. \- Of course you could also simply use the plain [sqlite3-ruby](https://github.com/sparklemotion/sqlite3-ruby) gem without an ORM. &amp;#x200B; My personal perference is the sequel ORM. I didn't test it but quite sure that all these gems work fine with ruby 2.6. &amp;#x200B;
I realize this is a late reply to to clarify I don't mean boring in a bad way. I mean it in the sense that Ruby is a mature, stable, and well established language. It's not the sexy new flavor of the month. People no longer choose Ruby because it's cool, the choose it because it works.
I've been following Qo's development for a while and I'll be honest - this library looks really cool, and the source code is probably something I'd learn a lot of new Ruby tricks from, but I probably wouldn't find myself reaching to use it, mostly due to the friction of pattern matching not being supported by the language itself. Possibly a related impression, but reading through the documentation, it looks like you've gone to extraordinary lengths to make it flexible and usable in many different contexts, whether that's constructing a matcher itself, `case ... when` syntax. That said, perhaps it's a bit too much detail? I find myself swamped trying to comprehend when or where I would use this gem. Perhaps having a recipe book would be helpful here. It's definitely cool, though. I'm wondering if this would help clean up rescuing from errors. Let's say a gem has some vague error classes that are only differentiable through the error message. Could I use Qo's pattern matching to match the error class and predicate matching to match the error message? Do you personally use this gem anywhere that has paid off significantly?
So something that loads up and kills you immediately? Consider it done! :-P
&gt;I still bought app called CodeKIT I think that statement (for lack of a better term) "absolves" you. I try to do this myself. Every time I adopt a gem into my enterprise, I donate to them monetarily in some way. Ever time I use brew to spin up a new machine (every time I install any new piece of OSS software on a machine), I see if there is a means to donate to maintainers (since I don't have time to donate). If every gainfully employed software dev did this, I think we'd be in a much better place. &gt;Emacs Emacs is wonderful! Umm... that's really all I wanted to say. Emacs is so awesome. Can we talk about Emacs some more?
I've seen a few approaches to 'hiding' the browser commands like this, I've ultimately ended up removing all of them from code bases I've worked on. It's simply easier to read, understand and modify a simple 5 line sequence of steps than it is to track down cutely named helpers across 5 different files. The other thing I commonly see happen (and this may be intentional for some but it's kinda crazy) is people will use the helpers judiciously without thinking about what they do. So you have something like a `create_and_sign_in_user` helper which ends up getting used in almost every spec in the test suite but it's actually going through the entire in browser sign up process each time. Do the same thing for a few model setups and your test suite gets _really_ slow. 
&gt;There are not that many companies with a huge commitment to Ruby. I think we'd be in a much better place if companies simply contributed some monetary amount that represented their commitment. A good litmus test would be to go on a job search website and look for ruby jobs, then for each company that comes up, see which ones sponsor ruby monetarily (something more than zero). I feel that the results of this litmus test wouldn't be great. &gt;are just not capable of fixing issues with compiler or even understand what the compiler is doing Exactly this. So two options spring up. Option 1 is invest the time to learn it. Option 2 is give money to those people that can and have directly impacted your career trajectory. Most gainfully employed developers do neither. Specifically with RubyMotion (and that it's in the compiler arena), when the fundamentalist oss people say they won't use it cause it's closed source, I'm presented with the same chicken and egg problem. The person probably can't contribute to the source, those that can are busy making sure the their own worlds don't catch on fire, and at the end of the day, I'm still "alone" dealing with the hard problems (and now for "free"). In essence, not sustainable. &gt; think by popularizing RM and providing backing services you can earn much more than just by selling RMs licenses It's not about the money (at least not this specific conversation). It's more about "the (gainfully employed) masses" giving support to what they use. I think we'd be in such a great place if that litmus test I mentioned passed with flying colors. PS: I appreciate the conversations. And you are awesome &lt;3
&gt;I think that statement (for lack of a better term) "absolves" you. I try to do this myself. Every time I adopt a gem into my enterprise, I donate to them monetarily in some way. Ever time I use brew to spin up a new machine (every time I install any new piece of OSS software on a machine), I see if there is a means to donate to maintainers (since I don't have time to donate). If every gainfully employed software dev did this, I think we'd be in a much better place. Uhh I wish but I am not sure I can justify spending that money. You are right that these people deserve money or other form of compensation but I am not sure how realistic this is. Especially if you are not a rich developer from the US of A. &gt;Emacs is wonderful! Umm... that's really all I wanted to say. Emacs is so awesome. Can we talk about Emacs some more? I like Emacs but maintenance and extending it is becoming a pain for me. I want to adopt things quickly..you know just try them out and I found out it's rather cumbersome with Emacs especially if you are not an elisp hacker or do not have a deeper understanding of emacs (which I do not). 
&gt;Uhh I wish but I am not sure I can justify spending that money. And that's totally fine. I'd _never_ ask someone to give money that can't afford to give. But perhaps asking their employers to give that money. &gt;Emacs especially Best functions to get familiar with: - `M-x describe-function` - `M-x describe-key` - `M-x apropos` You'll be extending emacs in no time with those under your belt.
I have to say I started using emacs when I saw the emacsrocks videos. I know about the keys just never bothered to properly learn elisp :-/. Guess it's time to start or switch.
Understandable. If Page Objects (or something similar) are introduced before the pain that Page Objects alleviate is present, then the Page Objects are just going to add unhelpful overhead.
I'm running sqlite3 (via the aforementioned Sequel) on 2.6.1. Works very well.
&gt;I think we'd be in a much better place if companies simply contributed some monetary amount that represented their commitment. A good litmus test would be to go on a job search website and look for ruby jobs, then for each company that comes up, see which ones sponsor ruby monetarily (something more than zero). I feel that the results of this litmus test wouldn't be great. Absolutely. It's a shame what happened with many open source projects that are backbones of many multi billion $ companies and nobody cares. &gt;Specifically with RubyMotion (and that it's in the compiler arena), when the fundamentalist oss people say they won't use it cause it's closed source, I'm presented with the same chicken and egg problem. The person probably can't contribute to the source, those that can are busy making sure the their own worlds don't catch on fire, and at the end of the day, I'm still "alone" dealing with the hard problems (and now for "free"). In essence, not sustainable. To me this is more of a business problem especially in IT where sometimes decisions and technologies used do not really make sense. The world is full of corporate or startup drones that simply do not care about anything but money and success and wont bother contributing in any way. However I believe this is similar to shit meat that people consume because it's relatively cheap and they can. We are not gonna change the world by wishing for people to eat quality but expensive meat. That's just not possible. You will attract some people that care but in the long run not much will change. &gt;It's not about the money (at least not this specific conversation). It's more about "the (gainfully employed) masses" giving support to what they use. I think we'd be in such a great place if that litmus test I mentioned passed with flying colors. I am not in the business of making mobile apps and have very little to no use for them but ironically I always ask ruby people why they did not use RM or why they used RN or this or that. Somewhat I believe that promoting RM is important heck you can even tell that people are interested from the number of upvotes this thread received. I just hope RM re-gainst momentum and you get a lot of that burden off your shoulder with a bigger community. You are awesome for keeping RM alive and being always there for people. 
I think a description of the pain would be helpful to understand that. I don't think the given example shows any pain at all. The only wonky thing in there is `find("#schedule_availability_block_recurrence_rule_1").set(true) # Monday` but this wasn't really fixed in the updated version and if the checkbox is labeled properly, and you're on a reasonably resent version of Capybara then you should be able to replace this with `check 'Monday'`. 
I appreciate so much that the core team adds new APIs with such a consistent level of rubyness. and I would define "rubyness" to be along the lines of `yes! if happyness_with_new_api &gt;= happyness_with_old_api` or i see a new API's usage and be like 'oh yeah that is so very ruby'
!FUN!
That‚Äôs just the classic tradeoff of abstraction. If you don‚Äôt abstract, you have a lot surface area that you may need to change at once, which makes change harder. If you do abstract, the abstraction itself could be clunky and hide what‚Äôs really going on. Programming is hard.
&gt; That‚Äôs just the classic tradeoff of abstraction. If you don‚Äôt abstract, you have a lot surface area that you may need to change at once, which makes change harder. I don't think that is generally applicable here. There are plenty of tools in rspec to avoid duplicating code, before blocks, let blocks, in-spec file helper functions, etc. You also don't _usually_ fill out the same form in multiple spec files so you usually don't have the problem of spread out code duplication. There may be some cases where it's useful to create a helper to avoid duplication and I'm not advocating against that. As an example it's common to have a 'standard' search form structure or a 'standard' way to handle async select boxes (select2). Writing helpers to work with these is a good idea. I am, however, advocating against moving all browser interaction into 'page objects' or 'helpers' as, in my experience, it only makes the tests harder to work with. 
Fair points.
Yep. I've had the pain, I thought this was a useful post. I think this is one of the main conceptual issues in creating good architecture. Like someone else said below, a "class tradeoff of abstraction." The pain is: The way you fill out this form _changed_, because the DOM/JS in the browser changed (because of a UX or implementation change, could be either), and now you have to find half a dozen or more places to fix by copy-and-pasting the code for the new way to fill out the form in the browser. But if you just go adding 'page objects' all over the place where it _might_ happen, you will undoubtedly be complicating your code. So much difficult to deal with code has been created by "cargo culting" patterns/abstractions. You've got to use em all with judgement. 
While I think this is worth discussing and I'm glad you brought it up, and the OP arguably could have had more language about abstraction tradeoffs here and in general -- the OP certainly did not advocate for putting "all browser interaction into 'page objects' or 'helpers'". It in fact specifically says: &gt; I find that Page Objects only start to become valuable beyond a certain threshold of complexity. I tend to see how far I can get with a test before I consider bringing a Page Object into the picture. I think that's actually just right. I'd say, if some people are getting the idea from the article that it's advising **all** browser interaction be extracted, then the article should be more clear... but that's actually fairly clear. 
I wrote a library that introspects the Thor framework to generate autocomplete scripts for your Thor CLI. I was sick of handwriting and editing these scripts, so I wanted to automate it in some way. This allows you to generate the scripts after Thor has been loaded, so you can create your own subcommand to call, or you can print them after Thor is loaded or save them to a file etc. Feedback is welcome. 
The documentation is on my top list of things to fix, as I'd be inclined to agree, it is a bit dense. As far as practical usage of Qo, I actually use it at work and in other personal projects for debugging among other things: * [TraceSpy](https://github.com/baweaver/trace_spy) was built on top of it to make it easier to get at TracePoint APIs, and has been exceptionally useful on more than one occasion. * Using it as a way to simplify creation of RuboCop autocorrectors and NodePattern matches * Experimenting with REST apis, and http requests in general * [Railway Oriented Programming](https://fsharpforfunandprofit.com/rop/) type techniques * Higher-order or monadic types, like [Dry Monads](https://dry-rb.org/gems/dry-monads/) * [Elixir-like](https://elixir-lang.org/getting-started/pattern-matching.html#pattern-matching-1) result matches, like [Dry Matcher](https://dry-rb.org/gems/dry-matcher/) * [Scala-like case class](https://docs.scala-lang.org/tour/pattern-matching.html) pattern matching using preconditions and destructuring A lot of it is it's just not quite a familiar idiom to Rubyists (yet), and comes more from languages like Scala, Haskell, Elixir, and other functional ones. Now do note that pattern matching is coming to Ruby, Matz confirmed as much this year at RubyConf, it's just a matter of them [deciding on the syntax at this point](https://bugs.ruby-lang.org/issues/14912). Insofar as errors, you certainly could. Qo can match against strings through pulling values out of an error.
No. Thank you! :) 
Page object is a cancer. Do User object instead. Source: am programmer. I could tell you that the source is that I'm working around this shit since 2013 but it would be irrelevant because stupidity of Page object became obvious to me in minutes after I've read about it the first time 6 years ago.
I don't know about this example. When I see your `@availability_block_form.fill` I would assume I can just add another key=&gt;value when altering the actual form and it would actually do something, which it doesn't. So no matter what I want to change about the test, I have to change it in two places. And unless there is a lot of repetition which there really shouldn't be in acceptance tests it would make way more sense to me to give the fill method a model/fixture otherwise I don't really see the point here.
I have always fantasized about building a game in the vein of Chocobo's Mysterious Dungeon, or even a more classical rogue-like. Other game ideas I have fall more in line with what's classically considered simulation gaming, maybe simulation coupled with some of how certain japanese visual novels work where you're training or building a character through your choices.
I‚Äôve added Chocobo‚Äôs Mysterious Dungeon to my list. üéâ
Well I'm not that great at cli's but there is two ways I would have done this: 1/ make it into a rake task. But I don't think this is gonna fix your issue for the long command. 2/ make it into a gem using Thor gem to make it into a cli. Actually, to fix the long command, export bundler's path into your PATH env var. And put your script inside a `.script` folder for example and export it's path to your env PATH. For me I have always a `.script` inside my PATH variable where I put my scripts.
If you used rvm, I would say check out wrappers. I'm not sure chruby has that though as I know it started as a project that didn't like the way rvm did things. Generally environment variables, such as BUNDLE\_GEMFILE, would be moved into the executing user's shell scripts. Although you could leverage the dotenv gem too and put them in a flat file in the executing directory and load that file. Usual practice on a script is to ensure that you're in the correct working directory which would eliminate a lot of the explicit pathing requirements. You could also run it as a ruby executable (see ruby shebang) and have the script handle the bundler loads similar to how rails does it. You could also gemify it (perhaps via bundler) and then all you'd have to do is specify the ENV parameters and load it in an irb context. 
Or just put the script somewhere in your path and make it executable.
so are we? how about you give an experience report?
I prefer BBQ style of page objects. https://github.com/drugpl/bbq I call them experience objects and tend to wrap a session in an object instead of a page.
What I'm missing is the problem that 'page objects' are supposed to solve. To hit on the two points you brought up: &gt; It could, though, also mention that one main sign for page objects is where you are going to use them in more than one place, if you're only using it in one place, maybe not. If you're using it 'more than one place' it's unclear to me that it is actually a page object. i.e. what is the scenario where you are filling in the same form on the same page from multiple specs? The only thing I can think of is having something like a sidebar that is present on multiple pages but somehow the current page impacts it in such a way that you need to test it on every page that has it. But this would mean that you need a reusable helper of some sort, not a 'page object' since it's not really related to a single page. &gt; Although I think avoiding 100-line example blocks is not a bad idea, additionally, even if only in one place. If you have a 100 lines worth of capybara browser commands in a single spec than I'd argue the test is doing _way_ too much or it's doing something very repetitive that could be done with some setup + a loop. In other words a 100 line spec is a symptom of a different problem and just stuffing those lines some place else isn't solving the issue.
&gt; The pain is: The way you fill out this form changed, because the DOM/JS in the browser changed (because of a UX or implementation change, could be either), and now you have to find half a dozen or more places to fix by copy-and-pasting the code for the new way to fill out the form in the browser. I guess this is the part I'm not understanding. Why aren't all the specs for any given form in a single `describe` block with shared setup code in a `before` block or a simple helper method inline? 
The obvious way to fix the former issue, is to use keyword arguments. 
I took a look at the survey but I'm confused as to what you mean by 'Build Failure', I could interpret that in a number of different ways: * Someone broke a test * A test is failing only on CI (or intermittently failing) * The build itself failed (e.g Travis decided to change the version of a system lib installed in the test environment) * Probably some other reasons I'm not thinking about right now My answers to the survey are going to vary wildly based on which type of build failure we're talking about. 
Hi, thanks for participating! &gt;I took a look at the survey but I'm confused as to what you mean by 'Build Failure', I could interpret that in a number of different ways: Generally, a build failure can be caused by several reasons, e.g., compilation error, failed test, missing dependency. So a build failure is the consequence of any bad integration of new changes to a codebase. &gt;My answers to the survey are going to vary wildly based on which type of build failure we're talking about. That's exactly the goal of the "scenario" questions.
How‚Äôs performance?
If you're looking to pick an array element at random, use `Array#sample`. 
Speaking of regaining momentum... I have an online school for RubyMotion development (https://rubymotion.school), and I also re-started a weekly newsletter, curating RubyMotion news (https://rubymotionweekly.com). I'm doing this because I believe in RubyMotion, and I want to make sure the community has the resources needed to succeed.
I'm not going to embarrass this person by mentioning their name, but in a recent conversation with such a person: "I honestly miss the RubyMotion community -- React Native has been good for {me}, but the technology is so fragmented compared to RubyMotion. It's slowly getting better, but I'll always have a soft spot for RM."
From [the docs](https://docs.ruby-lang.org/en/2.6.0/Object.html#method-i-3D-3D-3D): &gt;`obj === other ‚Üí true or false` &gt; Case Equality ‚Äì For class Object, effectively the same as calling #==, but typically overridden by descendants to provide meaningful semantics in case statements. Providing a choice of `rescue` options here is effectively a case statement. I think Pawe≈Ç's use of `===` here is perfectly valid.
 mkdir -p ~/usr/lib/ruby mkdir -p ~/usr/bin gem install -i ~/usr/lib/ruby/ dependency1 dependency2 ... export GEM_HOME=~/usr/lib/ruby/ mv your_script.rb ~/usr/bin chmod 755 ~/usr/bin/your_script.rb
This wouldn't affect the object to which the messages are being delegated. We're still delegating to public methods, but the delegating class isn't exposing those methods.
I‚Äôm reaching the same conclusion after years of building and maintaining fancy page object frameworks. Keeping page classes as shallow as possible is much easier to reason with, debug, and teach others how to use. Trying to explain why you‚Äôve obfuscated behaviors down and across many ‚Äúhelper‚Äù or ‚Äúpartial‚Äù files is more trouble than it‚Äôs worth. Another point I liked in your comment is methods that encompass huge flows. When you‚Äôre using it across 100s of tests, it‚Äôs time to reconsider why logging in each time is a requirement for every test case.
Ah that makes sense, thank you
Ahaha, kids, I made such comment on purpose. To show you how stupid you are, because the next time on similar topic I'll comment "page object is a cancer, source: working with it since 2013" and you'll upvote. But that would be not the real source, because page object is indeed stupid and you have to be a programmer to realise it, not just work in the field for years. The experience is irrelevant here. If something is stupid it's stupid no matter of time. But you are too stupid to understand it, ahah.
Thanks for your answer, but what about the dependencys from bundler and running the exact ruby versions? How would i declare that my script should run with this specific gemset? (set in gemfile.lock)
i thought about making it a gem, but this is a kind of short script that will get tinkered around a lot I think. Thanks for your input, I'll think about it :)
thank you for the script. I was probably a bit confused about my gemfile and the use of bundler. As I might have different versions of gems I was thinking about making sure the scripts run in the context of that specific gemflie.lock. 
thank you for your input. Gave me some things to look up!
It is _valid_, but it's harder to understand/change (the rule how to convert error messages is scattered across classes) and `SomeAPIAccountExpired === SomeAPIAccountExpired.new == false` [1] is very surprising and can lead to bugs later when using `case`. [1] This can be fixed of course.
If he's running on his own system under his own user he already has a set Ruby version and all the dependencies installed. Who's is the environment said he was running in. All the rest is just needless work. If he said he was trying to make it portable, or was trying to learn the bundle system. Then that would Warrenton all the extra steps. k.I.S.
Are you using Rails? If so, you can use Rails‚Äô enum. Google it.
Yes, thanks.
"I'm so pissed I'll use Rinda, buwahaha, that'll show them!" &amp;#x200B;
You could override the \`initialize\` method. ``` def initialize(params = {}) puts "something is created" super end ``` I wouldn't recommend this.
Last month we did a major dry-view release, and last _week_ I got to share a talk about it! This is a big release in a couple of ways: (1) it really fleshes out all the features, and now the system feels complete, and (2) this may be one of the last releases before we hit 1.0. So any testing and feedback at this point would be most welcome! Thanks!
You could override the `inspect` method to show something else: ``` class User attr_reader :first_name, :last_name def initialize(first_name, last_name) @first_name, @last_name = first_name, last_name end def inspect "#{first_name} #{last_name}" end end user = User.new("Luke", "Skywalker") =&gt; Luke Skywalker ```
The Console outputs object details because it immediately runs the `#inspect` method on the instance. You can however modify both the constructor function and the debugging method. For example: ``` class User attr_reader :firstname, :lastname, :fullname def initialize(first_name, last_name) @firstname = first_name @lastname = last_name @fullname = "#{firstname} #{lastname}" puts "#{@fullname} has been created" end def inspect "#&lt;#{self.class} fullname=#{@fullname.inspect}&gt;" end end ``` Now if you create the object in the console, you'll get: ``` user = User.new('Luke', 'Skywalker') Luke Skywalker has been created =&gt; #&lt;User fullname="Luke Skywalker"&gt; ``` Notice that the class has three symbols next to an `attr_reader`?, Well, that is a macro that allows you to *retrieve* object's attributes: ``` user = User.new('Luke', 'Skywalker') Luke Skywalker has been created =&gt; #&lt;User fullname="Luke Skywalker"&gt; user.firstname =&gt; "Luke" user.lastname =&gt; "Skywalker" ```
thanks for the reply ```ruby user = User.new something is created # =&gt; #&lt;User:0x00007feba7160270&gt; ``` can I completely hide object information `#&lt;User:0x00007feba7160270&gt;`
If you just don't want the console to spit out a bunch of garbage you can always do: `user = User.new('Luke', 'Skywalker'); nil` `# =&gt; nil` I think you need to explain the WHY of your question better though.
that was exactly what I was looking for. thank you. 
One solution might be to create a `Color` model. This can have attributes such as `name` and `hex_value` - for easy styling of your checkboxes or other front end components. Then, set up a [`has_many :through` relationship](https://guides.rubyonrails.org/association_basics.html#the-has-many-through-association). class Product &lt; ApplicationRecord has_many :product_colors has_many :colors, through: :product_colors end class ProductColor &lt; ApplicationRecord belongs_to :product belongs_to :color end class Color &lt; ApplicationRecord has_many :product_colors has_many :products, through: :product_colors end
I've looked at the docs for it a few times since about 1.9.3 and, you're right; they do a *horrible* job of evangelising or even explaining it. The [Wikipedia article stub](https://en.wikipedia.org/wiki/Rinda_(Ruby_programming_language)) does a *slightly* better job of explaining it, saying that &gt; *Rinda* is a software library for creating modular and distributed co-operating services in Ruby using the [tuple space](https://en.wikipedia.org/wiki/Tuple_space) or [Linda](https://en.wikipedia.org/wiki/Linda_(coordination_language)) distributed computing paradigm. &gt; &gt; Based on a source code initially released to the Ruby community by Masatoshi SEKI in 2000,[1] Rinda was later absorbed into Ruby's core [distributed Ruby (DRb)](https://en.wikipedia.org/wiki/Distributed_Ruby) module. Rinda has been distributed as part of the core Ruby library since Ruby 1.8. and giving three short usage examples. DRb in general has been woefully under-utilised since the rise of Web development as a major, if not primary, Ruby use case. A guy I used to work with insists that DRb is "a hack that lets you implement a poor-man's RPC without a real RPC framework". I think that gives short shrift to DRb, but a Ruby-language [GitHub search](https://github.com/search?l=Ruby&amp;q=Rinda%3A%3ATupleSpaceProxy.new&amp;type=Code) for `Rinda::TupleSpaceProxy.new` yields only 2,806 results as I write this. In contrast, a [search for `has_one`](https://github.com/search?l=Ruby&amp;q=has_one&amp;type=Code) returns 406,195 results and [one for `require 'net/http'`](https://github.com/search?l=Ruby&amp;q=require+%27net%2Fhttp%27&amp;type=Code) returns 643,815 results.
Hey guys! Just wrote about how arrays work in Ruby (how it's stored in memory) and how it can seemingly take on infinite size. Would appreciate any feedback!
If you must use bundler then run `bundle binstubs` and move the generated files to a location that can be executed. `binstubs` generates a wrapper that will load your script in the context of the bundle. 
Enum is more suited for set of values that rarely ever change. Adding/removing available values require source code change. &amp;#x200B; Unless you are really sure these eight colors are all that will ever be, it's better to use ActiveRecord \`has\_many\`.
I don‚Äôt think you can. That‚Äôs the return value from creating the object. Who or what are you trying to hide it from? 
I was going through the Rails code on Github. Then I saw this... ```ruby x = 1.year # =&gt; 1.year x.class # =&gt; ActiveSupport::Duration ``` I wonder how they did it. 
What do you mean how they did it? ActiveSupport from Rails monkey patches to provide additional methods on Fixnums (or was it Integer) so you can do stuffs like 1.month, 1.day etc. These are not custom printed values like you're suggesting
It is kind of cool and fun, I have used it for toy projects. We tried to use it for a more real project and very quickly ended up moving to a "real" message broker as it really didn't seem production quality for communicating over many systems. It also didn't have any good failure mode stories... It is pretty cool and fun to play with for little projects though. 
I'd be interested in hearing other thoughts on DRb if anyone has them. I never took it as production-ready but I've also never dug into the details myself The only thing I can remember revolved around security concerns around the protocol. Then again, I feel like in the age of VPC's I've seen a lot worse things and have wondered if there's still a place for DRb somewhere
Not sure how you're doing migrations, but with Rails and MySQL I run Rails in one container and MySQL in the other. I use docker-compose to orchestrate the two containers along with scripts (you could use Rake, but I've found scripts work better for me) The documentation for Postgres on Dockerhub should be enough for you to create the database and the root user. You could create an initial SQL script if you want (as per the other comment) - I prefer to drive everything from Ruby via my schema.rb and seeds.rb files I don't know if Postgres has this problem, but MySQL starts the container before the server can accept requests so I need to add a step which polls MySQL until it responds to a "heartbeat" query (e.g. `show databases;`) You can use DatabaseCleaner to manage data between tests
There is actually a book about Drb if you are interested, but it‚Äôs quite old. 
Very nice!
I'm wondering how different is this from what `Rails`/`ActiveSupport` does. It looks much simpler and I can see how it would help in a project that does not use `AS`. But it does not do `3.minutes.ago` like `AS` does. That's very useful.
Monkey patching. It's how Rails does everything basically. The monkey patched the year method into FixNum, which returns an ActiveSupport::Duration object.
Good point. ActiveSupport wraps the time unit in a Duration class, see &lt;https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/numeric/time.rb&gt; to make it work with all kind of date/time classes and formats. The Simple Time Unit Class always assumes the time is an integer number in seconds (that is, epoch time). If you need ago it is the difference of Time.now and self (e.g. 3.minute). The code: def ago Time.now.to_i - self end 
Cool. Do you got a blog post on service objects?
I seem to recall that Eric Hodel has used it for some things. We did [show it off at RubyConf](https://www.youtube.com/watch?v=IlGD8lAUMoA) back in 2013.
Great, I never think it could help me. Thank you
It _is_ returning an instance (not an instance variable). You have an object of class `User` in your variable. How do you print out an object of class `User` on the screen? Well by default, the way you see. If you want it to be printed out on the screen differently you can implement an `inspect` method. This will effect pretty much nothing except how it's printed out on screen. `User.new` always returns an object/instance of the `User` class, regardless, and that's what's in your variable. 
This is... very interesting. I didn't know you could do this! That said, this might belong over in /r/rails. Consider cross posting there too!
Have you tried end_with?(*args) ?
Nice one!
I haven't (yet). &amp;#x200B; I just tried now, doesn't seem to help me much. But, again, major noob here. I've tried it in the each\_line and get an error. Week 2 of this class is going swimmingly!
I‚Äôm still learning too so don‚Äôt feel bad. If you‚Äôre reading from a file i would structure it more like: File.each_line(‚Äòfile.txt‚Äô) do |line| if line.end_with(char) return char end end Idk of you‚Äôre pushing the results to an array or what but hope that helps.
So we've taken a string of text from an online resource (just a class thing. He already gave us that line of code since she changes it every semester). The text was converted into a string for use in the script. Well call the string strx. We're pretty much going through strx and messing with it to understand how different methods affect strings. upcase, downcase, etc. The string is a multiline string with weird spaces, characters, and ends with a specific character. I need to print (puts) the string back with that specific character removed in the lines that end with that specific character. I'm wondering if I need to separate the lines in strx to find it? I can't tell if str#chomp('char') is only removing the character from the END of the entire string. 
All the love to Evil Martians!! Love your work!!
\`each\_line\` includes the newline, where present, and that's messing up your \`chomp\` call. &amp;#x200B; \&gt; "hello\\nhello\\nhello".each\_line{|line| p line } "hello\\n" "hello\\n" "hello" &amp;#x200B; I know it looks stupid, but consider \`line.chomp.chomp('char')\` to clear an (optional) newline and (optional) terminal char.
Not bad! I have two comments, both around tests. 1. Do you test your generators? I never went for it because I didn‚Äôt see an obvious path. 2. Do you generate tests? For me this is the most useful part of the generator. I have one that produces a bunch of files that want to be registered in various places. Adding them online seemed too complex so I generate a test that fails until the code is registered. The test fails out of the box and instructs you how to fix it. 
This one? https://pragprog.com/book/sidruby/the-druby-book Yeah, out of print unfortunately. I have a hardcopy of "Distributed Programming with Ruby", by Mark Yates, somewhere around - that looks like it's out of print as well. From memory it cover Drb as well as other concurrency models, but I'm not sure where I've put it. It always struck me as odd. Here we have a feature of the language - or of StdLib in any case - that's been around for years, but it just doesn't seem to get used. Maybe it's more popular in Japan, or in certain industries. Dunno. 
Okay, I think I'm starting to clear some of the fog. I made an example here, I'm trying to remove the white space character and the X on the string. x = "This is a string. \nThis is another stringX" for x.each_line do |line| puts line.chomp.chomp("\sX") end But now I'm running into the error: syntax error, unexpected '\\n', expecting &amp;. or :: or '\[' or '.'
You might enjoy Qo-like matchers for this: https://gist.github.com/baweaver/81398632d1230f32727a2858b61c8b56 Destructuring will be available in the next release, which should give this interface.
This is great! I've been looking for another unnecessary layer of abstraction to add to my applications!
Two things here. First, get rid of the `for`, it's in the wrong context. (you could use `for line in x.each_line` but honestly the `for` construct just isn't idiomatic ruby) Second, chomp just wants a single string, and since none of your lines end with ` X` that chomp isn't doing anything. Either chain more chomps (`chomp("X").chomp("\s")`) or move up to `gsub(/[ X]$/,'')` as the next biggest hammer in the toolbox.
Yes. It's daytime TV, over here in the UK; the equivalent of Judge Judy. /s
That's what I thought. Simple enough.
Interesting! Compare to [ransack](https://github.com/activerecord-hackery/ransack)? I think it's addressing some of the same issues, but rubanok is at a different level of abstraction, and I think I like it better. I find the "plane"/"planish" terminology confusing though. Could there be a better name for the `planish` method? I might just call it `rubanok_fetch` or `rubanok_scope` or something. 
I'm late but I wanted to point out that the data structure shouldn't be modelled as a binary tree. There can be cycles in genealogical relationships.
Sorry for the late reply. First, thanks for the help. Much appreciated. Second, looks like the double chomps work for my example, but not the specific assignment I'm working with. Aaaargh. Back to the drawing board for me. RIP
What are you expecting to see?
This comment is Mockery without constructive criticism. Take a look at r/jrochkind for a good example of criticism that also encourages OP to keep contributing to the community.
sorry, should have said that. i was hoping to see the tasks i had assigned, like 'study Ruby', 'make breakfast' i'm (obviously) following prompts and was told that's what i should see, not the #&lt;Task :0000000000&gt; stuff
If you want to see the description, you have to specify it. Right now it‚Äôs printing out the task objects. 
of course, ok thank you. i know i'm pushing my luck with stupid questions, but how would i have to specify it to see 'make breakfast' or whatever? puts 'you have added make breakfast to the todo list' ? or is there another way?
Ruby doesn't know how to convert your `Task` objects intro strings to print. It cannot simply assume you want the `description` of tasks to be the final string ‚Äî what if you wanted something else, or wanted extra formatting? So you might want to tell Ruby how you wanted to convert Tasks to strings by adding a `to_s` method to your Task class: ``` class Task # your earlier code goes here def to_s description end end ``` Now, when your run `puts Task.new('Say Hello World')`, the `puts` method will first first call the `to_s` method of the object to get a string to print to standard output (your terminal screen). There are likely more idiomatic ways of accomplishing this in Ruby (e.g., make a decorator class) but I've tried suggesting the simplest way that fits with your current approach.
You should give these tutorials a shot: https://www.learnrubyonline.org
You've received a nice solution and it's probably what you should go with. But there are always multiple ways to do stuff and since you are a beginner it might be helpful seeing those other ways.: def show all_tasks.map { |task| task.description} end You can read up on [Array#map](https://docs.ruby-lang.org/en/2.4.0/Array.html#method-i-map) but basically the way it works is it iterates over the block in the curly brackets once for each element in the array and returns a new array filled with results from the block. Now inside that array you got all your tasks and to get the description of the task you would need to write task.description So this code returns a new array filled with the descriptions of the tasks in it.
So, after the introduction, I was expecting an overview of the net libraries, but in the end, it was just net-http, of which a lot has already been written about. 
Thanks :) I don't have it, at least not yet..Maybe I'll do one in the future, but there are already a lot of great articles on that topic!
Glad you liked it :) , thanks!
Thanks for the comment, I did cross post it! Regarding the flag..I believe you are right, I did overcomplicate it a bit..I am still kind of new to the ruby and rails world, but what you said seems more intuitive :) 
Unfortunately I did not write tests for this. It is something on my todo for the future, but right now I wanted just to get it out :) I am also not generating tests, but I hear what you're saying. Thanks a lot for your comments!
Good question. I haven't measured it as the test suite is small and would fail without isolation measures. I'll try to make some experiments and report back.
this is a super narrow definition of controller IMO :)
A particular way to summarize my work hehe.. Anyway, Thank you for your feedback. :-)
This is a really nice, elegant solution. Writing your own to_s is going to be useful for a lot of objects, but if you've just got a list of things in an Array, Array#map is an easy way to get that in a form that already has strings.
Really? Thanks! I'm just learning ruby myself and thought that to_s was the better solution and mine was more complicated. 
I used michael hartl's free online course. Can recommend. 
``` def show all_taks.map(&amp;:description) end ``` Is a little tighter.
While I agree that using `fetch` with a default value is clearer (and has slightly different semantics than the alternative, in cases where you have a defined hash key whose value is nil -- you probably do want the fetch semantics)... lang = new_hash[:language] ? new_hash[:language] : "Ruby" Is crazy, the right way to do that if you for some reason don't want to use fetch (say you want the semantics where nil gets replaced by your default value even if defined) is: lang = new_hash[:language] || "Ruby" 
The end result using data_migrations has exactly the same dangers of falling out of date as the first example, no? It seems to be almost exactly the same; it still looks and acts like a migration; the only difference `data_migrations` brought is a separate directory it lives in and a separate table keeping track of whether it was applied. There might be reasons to want this, but danger of migration falling out of date doesn't seem to be one of them -- whatever tools you have to keep that from happening apply equally to the initial example, no? (I do like putting the logic in a separate, tested, class, in either case). Ah, I guess one thing `data_migrations` gem gets you is you don't _have_ to run your data migrations when running `rake db:migrate`, they are in a separate command? I... guess that's good?
I recommend https://learnxinyminutes.com/docs/ruby/. 
[Eloquent Ruby](https://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104) was one that really helped me out.
I saw few more really good books, but wasn't sure if they were up to date. What are your experiences? Any significant difference between Ruby 2.0 and 2.6 for example?
Well, that book is really good at, "the Ruby way of thinking," which hasn't changed too much between versions. For everything else, there's RubyDoc.
&gt; The next time you need to set up a development environment, you create your database, you run your migrations, and you get a failure in your console: Rails does not know what Post is: Why would you run all your migrations when setting up a dev environment? `rake db:setup` will call `rake db:schema:load` or `rake db:structure:load` depending on which you are using, and `rake db:reset` does the same after dropping the database. There is no good reason I can think of to re-run all migrations from scratch. &gt; To make sure that your data migrations don't fall out of date, you can set up your build to run rake db:schema:load:with_data before your test suite. That seems dangerous, your data migrations could end up inserting data into your test DB that shouldn't be there. That said - I do recommend sticking to SQL for data changes in migrations which may mostly alleviate this issue but the primary reason for it is performance, usually you can write SQL that will be much faster than working through AR. Your `update_all` example would be ok but for more advanced updates I've often see Ruby loops over models that could have easily been written in SQL and would be many times faster.
Thanks for reading! I wrote that article and I'm happy to get feedback. :) \&gt; The end result using data\_migrations has exactly the same dangers of falling out of date as the first example, no? Yes, it has the same dangers. That is why I recommend using \`rake db:schema:load:with\_data\` before running your test suite in CI. It doesn't run all the database migrations, it uses \`db:schema:load\` and then it runs the data migrations. That means that you will get a failure right away, even before running the entire test suite. \&gt; Ah, I guess one thing \`data\_migrations\` gem gets you is you don't *have* to run your data migrations when running \`rake db:migrate\` they are in a separate command? I think one of the best things about \`data\_migrations\` is that you don't have to write that data migration code (DRY) and it provides useful rake tasks. When deploying, your release phase could look like this: \`rake db:migrate data:migrate\` When testing, you could quickly set up your test env like this: \`rake db:schema:load:with\_data\`
Yeah I will give it a shot, since I liked Russ Olsen's "Getting Clojure" so much, that I believe this could be as helpful as that was for Clojure. What I am keeping and eye on is this third edition: [https://www.manning.com/books/the-well-grounded-rubyist-third-edition](https://www.manning.com/books/the-well-grounded-rubyist-third-edition)
\&gt; Why would you run all your migrations when setting up a dev environment? I was trying to write an example to describe the problem. You are right: When inheriting a project, you would start with \`rake db:setup\`. To be honest I don't usually run that rake task, I usually run \`rake db:create db:migrate\` and I expect it to work. A more real example would be this one: You stop working on project A, another team takes over, you go back to project A after a few months, you run \`rake db:migrate\` because you already have a dev database for it, and then you get "Rails does not know what Post". \&gt; That seems dangerous, your data migrations could end up inserting data into your test DB that shouldn't be there. I think inserting data with your data migrations is a bad idea. When I talk about data migrations I'm talking about changing existing records in your database. If you are going to insert data, I would recommend that you put it in \`db/seeds.rb\` and use something like \`find\_or\_create\_by\` for inserting data. \&gt; I do recommend sticking to SQL for data changes in migrations which may mostly alleviate this issue That is a great alternative. 
&gt; Do you test your generators? I never went for it because I didn‚Äôt see an obvious path. You can look at all the built in generator tests as an example: https://github.com/rails/rails/tree/master/railties/test/generators
Not really! While taking everyone's opinion. I have been continuously coding on Atom. And later on as majority suggested VSCode over atom, I tried it and it convinced me to switch. Now I'm coding on VSCode pretty comfortably. :D
These are trending? I‚Äôm surprised. Many of these are very old. R.g., Redmine was around when I started using Rails in 2007. 
Is postgres running? 
I have gem used for installing it for my project. I didn't install it manually on PC. And even when I tried to install it, the installer was giving me runtime error.
Yeah, you need to install it locally. That's what the app is looking for: your local instance of the DB
JSON web services aren't "services" in the sense of the term "microservices." An HTTP API that you use to retrieve and update data isn't a service, it's just a database that happens to communicate over HTTP instead of, say, SQL.
&gt;Thimbleweed Park related, both are adventure, Thimbleweed looks like a multiple character driven story, Myst is a solo adventure where the player is the only character.
Thanks for the feedback! &gt; Compare to ransack? _(Never used it, but will try to answer)\ I think, the main difference is that Ransack forces you to use a specific params naming and the actual _transformations_ are _hidden_ and kinda out of your control. And it's focused on HTML forms mostly (AFAICS from the docs). &gt; I find the "plane"/"planish" terminology confusing though. Could there be a better name for the planish method? I was looking for a concise and **unique** naming. You can use your own with a few lines of code in your `ApplicationController`: ```ruby class ApplicationController &lt; ActionController::Smth # add `planish` alias alias transform_scope planish # override the `implicit_plane_class` method def implicit_plane_class "#{controller_path.classify.pluralize}Scoper".safe_constantize end end ``` Anyway, the naming is discussable. Feel free to propose your suggestions on GitHub. &gt; And "planish" isn't a word [It is]([https://en.wiktionary.org/wiki/planish](https://en.wiktionary.org/wiki/planish)) &gt; In your examples that do eg CourseSession.all.search("xyz"), where does that search method come from? I assume there is a scope or class method called `search`. No assumptions on the implementations. Added a comment to the post.
cool cool. Names I'd propose would maybe involve something around "query", but do you see this being used not just for queries? In that case, maybe something around 'map' or 'transform'. 
&gt; I think one of the best things about `data_migrate` is that you don't have to write that data migration code (DRY) and it provides useful rake tasks. Don't you write the exact same code in your data_migrate example as you did in your first example using an ordinary migration? First example: class ChangeDefaultState &lt; ActiveRecord::Migration[5.1] def up Post.where(state: "Draft").update_all(state: "TODO") end def down raise ActiveRecord::IrreversibleMigration end end Final example with data_migrate: class ChangeDefaultStateForPosts &lt; ActiveRecord::Migration[5.1] def up Post.where(state: "Draft").update_all(state: "TODO") end def down Post.where(state: "TODO").update_all(state: "Draft") end end Same thing, no? Does not seem like data_migrate kept you from running any code compared to initial example? 
Can you say how you assemble this list, what counts as "trending" determined how?
I think I saw it in the old pickaxe first. The strange thing is ... I never used it or seem to have had a need for using it. It's weird.
Pretty much the best book for OOP and ruby: Google ANYTHING from santy metz P.S. check out the Odin project , ruby and ruby in rails section it is open source and well organized https://www.theodinproject.com/courses?ref=homenav
Yeah... there are probably many other solutions in the same space with better performance/security/_etc_ - that's why it's so strange to still see it in StdLib. I can only guess that people in the core team have a use for it, but there other weird things in StdLib that probably never get used by most folk (REXML, RSS, and so forth). Curious accidents of history?
Second variant is also shorter. In this case shorter is better too. Ternary always causes my brain to have to look more carefully. I don't like that.
&gt; # old way upcase_address = person.address &amp;&amp; person.address.upcase &gt; # using the safe navigation operator upcase_address = person.address&amp;.upcase &gt; Using the safe navigation operator lets you escape the nil &gt; exception without making your code look bad. What safe navigation did was shorten code. However had, I think the syntax looks utter shit. The first variant also is ugly, admittedly. But, boy, &amp;. is just horrible. Once is already bad but look at this please: t1&amp;.kill&amp;.join That is pretty? That is ruby-going-perl-1.0. file = File.open('devtechnica.txt', 'r') content = file.readlines content_repeat = file.tap(&amp;:rewind).readlines &gt; Typically, the rewind method when called on a file IO will &gt; return the buffer offset after resetting it, which is always 0. &gt; this will break the chain and will not let us chain the &gt; readlines method to it. By using the rewind method inside &gt; a tap method block, which returns the object on which it &gt; is called, we are able to chain the readlines method as well. While I myself do not think that .tap was necessary, I am not completely opposed to the functionality that it offers. I just think that the people who were suggesting it weren't real ruby hackers (*cough* the functional crowd *cough). But let's ignore this for the moment - WHO in his sane mind would want to write the above code that is almost twice as long, compared to a simple .readlines ??? I mean, seriously? In the time you write it I could watch some Star Trek movie half. &gt; 2. Converting a String into Boolean ‚Äì Rails Only &gt; Converting a string value to a Boolean value can be quite tricky It's not "tricky", it is simple. However had, I actually have had a need to do so myself, in particular when I had strings such as "true" or "false", but also "yes" and "no". So I am not entirely against that use case. Problem is finding a good name for it. Anyone wants to suggest it to ruby core? I think the name is the biggest problem. &gt; ActiveRecord::Type::Boolean.new.cast("true") Yup - that is a HORRIBLE name. The rails people are really terrible at naming things. I mean ... a "cast" WHAT THE HELL who came up with that name? But again, it is indeed not a trivial to find a name for it. I came up with something along the lines of truth, but that name is also not ideal. Can't suggest that to ruby core, I don't think it would be accepted.
Just don't solve the halting problem ;)
Do you believe it ought to be @ioquatix? Considering reviving it.
Step 1 is great! There's only one method invocation yields and runs a second method that accepts no arguments. This is perfect testable code! I don't like step 2 very much. To assert that the correct method is being run inside the loop the Worker tests need to know implementation details of DoUsefulWork::call. In this instance, some reasonable amount of time to be sure DoUsefulWork::call won't raise an exception. The amount of time could change over the lifetime of the project so this test will more-quickly become brittle. The correct setup needed for DoUsefulWork::call to not-raise may change over time as well, and that setup is presumably duplicated in the DoUsefulWork tests. Finally, Timeout::timeout can leave your code in a weird place if you're not extra, extra careful. What we really want to test here is that: * A method invokes its block argument * A particular method is invoked inside that block A better option would be to use mocks. The nice thing about mocks is you can change the behavior of the methods you're mocking. This is acceptable because a test for method A shouldn't need to depend on the behavior of any other method. One test can mock Kernel#loop and ensure that some block is passed. Another test can mock DoUsefulWork::call to ensure it is invoked, but instead of having the mock return some value or no value (due to the looping), it throws a special value like `:doing_useful_work` that is caught in the test. (Raising a special exception would also work here, but is less obvious because it won't stick out like `catch`/`throw`.) Using mocks and stubs instead of a 1ms timeout also makes the test run faster, as `catch`/`throw` and a mock will take far less than 1ms to run.
I liked 'RoR for Autodidacts' - was a different approach you may like that uses lots of examples if you like to skim code - check the reviews before buying to see if it fits what you're looking for... 
Corey is great! Jason is great! Good podcast is good!
Hey! Thanks for the feedback! Can you share it on Github [https://github.com/anycable/anycable/issues/68](https://github.com/anycable/anycable/issues/68)? 
Hey, Palkan asked before to comment on the issue so I did :)
Trending ruby repos https://github.com/trending/ruby realtime.
heavens\_door is new for me :D
Regarding the safe navigation operator, while I would agree the syntax isn‚Äôt great, it‚Äôs actually pretty great and cleans up a lot of redundant code. The first couple times I came across it, it made me go WTF? But, it‚Äôs actually a fairly common construct across several languages, however the majority use `foo?.bar` rather than `foo&amp;.bar` which is at least slightly clearer, but not possible in Ruby because the question mark is a valid/commonly used character in method names. [I‚Äôd recommend giving the proposal for adding it to JS as it includes a discussion of the use cases and links to other languages implementations.](https://github.com/tc39/proposal-optional-chaining/blob/master/README.md) I like it because it‚Äôs more-or-less equivalent to using a Maybe monads in a functional language as it lets you stop processing when the value isn‚Äôt there without having to put conditional checks everywhere, allowing you to handle the nil value at the end if necessary. Regarding the AR Boolean class, I don‚Äôt see anything wrong with the naming, as what it‚Äôs doing is taking a value (likely a string that represents some true/false value (‚Äútrue‚Äù, ‚Äút‚Äù, ‚ÄúTrue‚Äù, ‚ÄúTRUE‚Äù, ‚ÄúT‚Äù, ‚Äúyes‚Äù, ‚ÄúYES‚Äù, ‚Äúy‚Äù, ‚ÄúY‚Äù, ‚Äú1‚Äù, \x01, ‚ÄúOn‚Äù, ‚ÄúON‚Äù, ‚Äú#t‚Äù, and so on ad infinitum...) and [typecasting](https://en.m.wikipedia.org/wiki/Type_conversion) it to a Boolean, so I don‚Äôt see anything wrong with the method name. The only thing that bugs me is having to initialize an object to call cast when I can‚Äôt see any reason it wasn‚Äôt implemented as a class/module method, I can‚Äôt imagine why it would need an internal state to do what I‚Äôm guessing is a regex match or hash lookup.
**Type conversion** In computer science, type conversion, type casting, type coercion, and type juggling are different ways of changing an expression from one data type to another. An example would be the conversion of an integer value into a floating point value or its textual representation as a string, and vice versa. Type conversions can take advantage of certain features of type hierarchies or data representations. Two important aspects of a type conversion are whether it happens implicitly (automatically) or explicitly, and whether the underlying data representation is converted from one representation into another, or a given representation is merely reinterpreted as the representation of another data type. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Desktop link: https://en.wikipedia.org/wiki/Type_conversion *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^238312
Hey, just a little heads-up... Actually Ruby already has its own Tensor Flow equivalent: [https://github.com/jedld/tensor\_stream](https://github.com/jedld/tensor_stream) "Tensor Stream: A ground-up and standalone reimplementation of TensorFlow for ruby. Comes with a pure ruby and OpenCL opcode evaluator"
Supercool.. thank you
For the same reason the word `Love` means something different to every person, and in every moment. Defining `Actor` is up there with the choice of a programming language itself, because it can be approached infinitely different ways. As /u/ioquatix confirmed, `Celluloid` is for all intents and purposes dead right now, but the real thing about that library wasn't the code itself, it was an embracing of this idea of being a Domain Specific Language, like Rails for HTTP, for concurrency, asynchrony, parallelism, and distributed instances of those three, based on the `Actor` and `Reactor` models, in a certain style which was intended primarily to be consistent with the spirit of `Ruby` itself, which is "a joy" to write in, as its brand promise. Compared with other implementations of the `Actor` model, or those various modes listed of multi-machine / multi-core / multi-thread / multi-fiber software design, `Celluloid` alone lived up to that challenge, then trailed off in implementation, further solidifying the original statement I began with. `Rubinius` also attempted to do this, but like you said, on the language level, because it is a "Language Platform" not just a specific individual interpreter of `Ruby` code. It's also there, or probably primarily there, to create other languages, starting from the minimum of what `Ruby` has to offer in terms of syntax beauty and ease.
I think overriding to_s is overkill for this specific situation, although it's probably the better one for more complex objects. In this case, your solution does everything that's needed, in a more minimalist way.
I've said it before and I'll say it again, `?? "?" == "??" ? !!?? : !!!??`.
If you didn't like `&amp;.` then you are going to hate https://bugs.ruby-lang.org/issues/12125 then. 
It's fine though because in Ruby 2.7 you will be able to write `boolify = ActiveRecord::Type::Boolean.new.:cast` and then `boolify["true"]`.
 class AnimalsModel &lt; ApplicationRecord self.abstract_class = true connects_to database: { writing: :animals_primary, reading: :animals_replica } end class Dog &lt; AnimalsModel # connected to both the animals_primary db for writing and the animals_replica for reading end Am I the only one who thinks this is more alien code than ruby? &gt; Rails 6 is going to be special. Big thanks to @github for supporting &gt; this work and being a core pillar of the Rails community Someone catering to Microsoft. Isn't that cute? It's of course a success story for the most part - rails is based on ruby, github is based (in parts) on rails, Microsoft assimilates github to have more control over the whole ecosystem. I find it still hugely greedy by Microsoft to have done so though. &gt; I'm really excited to see parts of GitHub's app pushed upstream. See - that is my biggest problem with rails. It's not very ... exciting. Despite statements of the contrary. It's not necessarily the fault of rails alone, mind you. The whole web stack is pretty ... hmmm. Strange? Boring? I also never had this problem with ruby. While there are a lot of additions I consider unnecessary or ugly in the last ~3 years, ruby in itself is still absolutely awesome. And fun. But ... rails? Hmmmm. &gt; which open up these possibilities User.connected_to(database: { writing: "postgres://foo" }) do User.create!(name: "Gannon") end config = { "adapter" =&gt; "sqlite3", "database" =&gt; "db/readonly.sqlite3" } User.connected_to(database: { reading: config }) do User.count end What a terrible clusterfudge. Seriously. &gt; Add Relation#prick as short-hand for single-value plucks Ok ok I admit I misread there ... but this is more amusing than the rest of this medium-hosted blog. Did I already mention how terrible medium is? &gt; A while back, DHH have started YouTube series called On &gt; Writing Software Well which later became part of the &gt; Getting Better YouTube page Now - say all what you want about zedshaw ... I did so myself back then when he equated the rails community with the ruby community (I use ruby but not rails), but ... the stuff he writes is still a LOT more fun to read than fancy-pants youtube series about boring code. Or boring niches. By the way, not all about the www is necessarily boring. I like web-scraping for example, mostly because it helps reduce manual work (I had to download all lectures from a university that was using, annoyingly so, javascript-populated entries for their lectures ...) def create_or_find_by(attributes, &amp;block) transaction(requires_new: true) { create(attributes, &amp;block) } rescue ActiveRecord::RecordNotUnique find_by!(attributes) end Awful. I am glad I don't have to maintain such a code base. I also hate most methods with a "!". Standalone variants are ok such as: some_string.strip! But it is still quite ugly. What I hate the most is optparse doing something like: end.parse!(ARGV) You'll find some examples for that style. I hate that thing. Plus - people who directly use ARGV, rather than a parameter in a method ... they probably don't know why using ARGV directly is not a good idea either. &gt; Rails can now thwart attacks that attempt to copy signed/encrypted &gt; value of a cookie and use it as the value of another cookie. I consider cookies in general to be sniff-attacks from upstream. Something is fundamentally wrong with the way the web currently works. def create # do stuff follow_redirect!(params: { user: params[:user_id] }) end The ugliness is perpetuated. How can people use that??? &gt; Aaron Patterson is on an ever-long performance optimization &gt; quest and his latest addition is allocations. Now that is a good thing; he also helped make ruby in general faster in some areas, so we need more Aarons in ruby in general. Just not when he bricks his phone... require 'prometheus/client' prometheus = Prometheus::Client.registry $email_job_retries = prometheus.counter(:http_requests, 'A counter of Email jobs that were retried') ActiveSupport::Notifications.subscribe "enqueue_retry.active_job" do |name, start, finish, id, payload| $email_job_retries.increment({ job: payload[:job] }) end Noob alert - uses $. Well ... Guess that's your typical rails user - people who don't know ruby. What a terribly convoluted API too. Don't get me wrong - it is good that you can be super-terse; but it is bad when you don't have a SIMPLE alternative anymore. retry_on Errno::ECONNREFUSED, SocketError, Timeout::Error, attempts: 5 This is a general problem in ruby - network failures or failures in general. It's too verbose and cumbersome. You can of course rescue Exception and afterwards cater to more fine-tuning but it is still way too verbose in my opinion. I guess the biggest problem in ruby is not rails in itself - it's actually good that rails exists. But what is bad is that there aren't that many (real) alternatives; and not a focus by the core team to make the focus on www a first class citizen, which I think is a mistake. Even the lousy spaghetti language PHP showed why the www is the single most important aspect for "modern" programming language (or javascript rising and recently also managing to dethrone PHP finally). sinatra/padrino are nice but does not quite feel anywhere near close to where rails is. Something is amiss here.
The thing about testing and refactoring that I‚Äôve been thinking about a lot recently, is that often I want to redesign vs. refactor. Everyone mentions how TDD enables refactoring, but a lot of times it‚Äôs the design of the code that‚Äôs not holding up, not the internal implementation. I wonder how often other people run into this, or is pure refactoring always good enough? Obviously tests need to depend on some kind of implementation (you need an API to call) so what happens when that API needs to evolve? In TDD by example (the book by Kent Beck), in this case he will just modify the test to start the redesign. Is there anything better we can do here?
how would you fix these "ugly" syntaxes?
Looks like it's new to everyone! Also, looks super useful. Surprised it hasn't been pinged in here yet. Thanks for the tip.
Paranoia is depricated
Lots of rambling, (questionable) opinions and nothing constructive. What's your point?
The biggest thing for me here is parallel testing. This should definitely cut down CI or pre-commit hook time.
Thanks buddy!
[https://thumbs.gfycat.com/UntriedVerifiableBedbug-size\_restricted.gif](https://thumbs.gfycat.com/UntriedVerifiableBedbug-size_restricted.gif)
Hmm, the way I think about it, if I want to redesign, refactoring is the thing that enables me to get there.
&gt;I guess the idea is simply that it's useful to separate your data migrations in separate rake tasks than your schema migrations? Yes, I think that is the main advantage of using \`data\_migrate\` instead of the Rails db migrations. \&gt; I think one of the best things about \`data\_migrate\` is that you don't have to write that data migration code (DRY) When I talk about "that migration code" I'm talking about the code I wrote for the data migration rake tasks in the second pattern. I still think that there is value in writing a spec for data migrations. You are going to be running them in production, so you should write a test to show that you've considered a couple scenarios. The example is pretty simple, but data migrations could become even more complicated.
That‚Äôs a great point. Still, redesigns can have an effect on the tests, and that‚Äôs what I‚Äôm trying to figure out how to minimize recently. And I think the answer there is designing the test suite with the same rigor that production code is designed.
&gt;\&gt;The ActionCable javascript package has been converted from CoffeeScript to ES2015, and we now publish the source code in the npm distribution Why only this bit gets converted to ES 2015, and not many other bits of CoffeeScript. Also why 2015 and not ES2016? &amp;#x200B; Anyone knows? &amp;#x200B;
Wasn't this already possible with [parallel_tests](https://github.com/grosser/parallel_tests)?
You don‚Äôt need Rails for this and yes it would be overkill. You‚Äôre probably looking for something like the capybara gem to drive a headless browser combined with your choice of testing framework. I like rspec but you may prefer testunit or minispec.
I would assume browser compatibility, and the library itself is pretty small anyway.
Anecdotally, every team that I've seen adopt parallel testing experienced fairly severe problems with their test suite... mainly, nondeterministic results (both false positives AND false negatives).
I think those teams aren‚Äôt isolating tests properly then right?
It‚Äôs definitely browser compatibility. Rails can‚Äôt drop IE10&amp;11 I guess they could include something like Babel but that‚Äôs another layer of complexity. 
I think he‚Äôs trying to tell us he‚Äôs insufferable 
I think lots of that conversion will happen when the project drops Sprockets and sets up a webpacker backed asset compilation system.
if the test passes who cares........ 
In my experience, flaky tests are caused by the code itself being poorly isolated (for instance, pervasive global variable access), and when the code _has_ proper isolation, test suites don't take long enough to be worth running in parallel.
I've felt compelled to downvote basically every comment I've seen from this user.
&gt; I guess they could include something like Babel but that‚Äôs another layer of complexity. Rails 6 ships with webpacker by default which has babel setup by default.
&gt; Also why 2015 and not ES2016? It's not like there is much difference, just `Array#includes` and the `**` operator as I recall. 
Rails 6 uses webpacker for JS by default but sprockets is likely to stick around for awhile for CSS/images. 
I've seen you on a lot of posts writing really long complaints or getting into really arcane arguments about the way that ruby at its core is structured, I can't help but wonder why you do this.
Thanks for the clarification!
Yep, this. RSpec + Capybara + Ruby (no Rails) will do the job nicely.
have a look at http://watir.com/
Looking forward to ActionText. [There is a workaround to set Action Text up with Rails 5.2.](https://littlelines.com/blog/2018/11/30/how-to-make-actiontext-work-with-rails-5)
The Active Storage JavaScript files are already written in ES2016. Are there some other files that are still in CoffeeScript?
Huh. Sometimes there's a need to differentiate between "value not set" vs "0". Not sure where I'd need Hash.zero?
Nice and concise summary -- thanks!
&gt; `case` statement can have all kinds of different values, and they‚Äôre treated in all kinds of different ways Nope. Exactly one way -- `#===` (case equality) operator (which your text only mentions in "you can use a class or module, which will be compared using the `===` operator"). It is not "weird", but pretty consistent and well-documented feature, allowing all kinds of quasi-pattern-matching (with custom types, too). It could surprise less experienced Rubyists sometimes, but I feel a bit uneasy about representing frequently used core language features as "weird". Most of the other examples are indeed esoteric, though :) (Well, `%`-literals are not, as for me.) 
Since you're discovering those, you might like `fit` and `fdescribe`/`fcontext` as well! https://relishapp.com/rspec/rspec-core/v/3-8/docs/filtering/filter-run-when-matching
Good point. The safestruct is not for "general" programming it was "extracted" from sruby that offers strong safety and security guarantees for your code (on the blockchain). You need Hash.zero (in the real world) for a nested Hash (Mapping). Example: allowances = Mapping.of( Address =&gt; Mapping.of( Address =&gt; Money). Cheers. Prost. Stay safe.
You are so right! I've updated the post to strip that part out. I thought it had to do with \`===\` but when I tried it it didn't work. Looked over my notes and realized I was calling \`===\` on the wrong thing!
not all heroes wear capes
Seconded.
fwiw, BEGIN/END blocks are also used in awk.
&gt;The ActionCable javascript package There are legacy projects still using asset pipeline or new apps where people don't want to use Webpacker. I really like Webpack but I'm not a fan of \_Webpacker\_. I install \_webpacker\_ for asset paths but remove it's Webpack package b/c I don't like having a gem installing build &amp; JS modules.
Thank you for that post! I am curious why you actually listed the `numbers`. It actually works the same way in python. I haven't seen a language where `0x00` wouldn't work. When looking at c the octal `0` prefix is the way to go, when declaring octal numbers. ``` 1 #include &lt;stdio.h&gt; 2 3 int main() { 4 int h = 0x10; 5 //int b = 0b20; 6 int o = 010; 7 printf("%d\n", h); 8 printf("%d\n", o); 9 } ``` However, it is nice for everyone who didn't knew that. At this point let me say that you can also define big numbers separated with an underscore: `1_000_000 == 1000000`.
It would be helpful if you provided some example code, particularly the Selenium setup but my guess is that your issue is due to not setting up headless chrome correctly since there are some hoops to jump through to get that working, just google 'headless chrome file download' for plenty of examples. If you have specific questions after that, I can probably help as I used file downloading in headless chrome in several projects. 
We spent a fair bit of time on making our test suite reliable and created guidelines for the devs to keep it that way. Mostly global variables, elasticsearch, mongo, or accessing random data from db and depending on the order when it is unnecessary were the culprits.
[https://github.com/SherOnDale/ocbc-rpa-ruby](https://github.com/SherOnDale/ocbc-rpa-ruby) ive searched about downloading on headless chrome with selenium. nothing helped :(
class User &lt; ActiveRecord::Base self.implicit\_order\_column = "created\_at" end &amp;#x200B; Finally. &amp;#x200B;
&gt; There are legacy projects still using asset pipeline or new apps where people don't want to use Webpacker. I'm not sure what you are trying to say here, the ActionCable JS is now written in ES2015 so if your concern is old browser support something _has_ to transpile it to ES5 which is little different than the previous situation of compiling coffeescript to ES5. &gt; I really like Webpack but I'm not a fan of Webpacker. I install webpacker for asset paths but remove it's Webpack package b/c I don't like having a gem installing build &amp; JS modules. I have no idea what you are saying here, you use webpacker without webpack? What does even mean?
ES2015 has wider support than ES6. I install Webpack with yarn or npm &amp; remove the one the Webpacker installs. Mastadon does something similar: https://github.com/tootsuite/mastodon. 
Those are my thoughts on serverless future and adoption, and how I solved the cold start problem on FaaStRuby. What do you guys think?
ES2015 _IS_ ES6.....
Thanks! It's a very good point, I did not realize that \`loop\` is a regular method. I've updated the article :)
The stuff commented out for headless chrome downloads looks right. However you're passing a relative path, `tmp` to Chrome. I don't know where this would save the downloads but I doubt it would be relative to your source directory. Try setting it to an absolute path, something like `File.join(File.dirname(__FILE__), 'tmp')` to point it to a `tmp` directory next to app.rb.
It's a strong indicator of not having properly isolated tests.
Fuck me. I'm an idiot. I actually thought es6 = es2016.
&gt; Why only this bit gets converted to ES 2015, and not many other bits of CoffeeScript. What other bits of CoffeeScript? AFAIK ActionCable was the last remaining CoffeeScript in the Rails source and also AFAIK CoffeeScript is no longer included in Rails 6, even generator support was removed. 
Tests just exercise code. When devs say that a test exercises some chunk of code "in isolation," what devs mean is that the test is able to exercise the code without having to exercise adjacent dependencies. In other words, the extent to which a test is "isolated" is nothing more or less than the extent to which the test _subject_ is isolated from other code. I've never heard of anybody writing a poorly isolated tests for a well isolated object.
I did too, friend. 
Some of these aren't all that weird and are present in many other languages: Conditional in switch statement: Scala, Kotin via `when`, etc. For loops: It's weird to see them used in Ruby, but they function pretty much like a Python for loop (including variable escape) Bin/hex/oct literals: Almost all languages support this. Interpolation: Also present in many languages and many with the same optional brackets e.g. Scala, Kotlin, Perl, Php, etc Void: This is true in some form of most languages where 'everything is an expression'. e.g. () == Unit in Scala. 
&gt; The safestruct scripts are dedicated to the public domain. Is there public domain in europe? I've always thought that it is mostly construct of common law. If it's so, I guess EU based projects can't use it?
I'd say it was less thoughts, more advert.
yea they decided to switch to yearly releases of ES exactly one year off from making the last digit of the year match to revision number: ES5 = ES5, it existed prior to the yearly naming convention, but it would be ES2009 if you backported the current naming ES6 = ES2015 ES7 = ES2016 ES8 = ES2017 ES9 = ES2018 
Well sorry if it came out that way - that was not the intention at all. There's nothing for sale there. At least not for now. I want everybody to use the platform though, so I can learn from your guys and make it better!
No, it downloaded the file where I wanted it to be in headed mode. But nothing happened in headless mode
Of course there's a public domain in europe. Who do you think owns the air you're breathing in Austria?
Much like default scopes, I wonder if this sql magic is a bad idea.
Yeah I think it depends on how its implemented. I tend to use UUID (or similar) for primary ids on all of my projects for some time. It does not feel great having to place implicit ordering scopes or gasp deal with the default scope pain to use those to maintain proper ordering against a created\_at or some other sequential side effect column. If it is just default scope injection by another name I am all with you. 
lol you're getting mad about 5 year old rails idioms and blaming msft... whats up, you ok?
Because I am persistent, I learned how to run gdb and ran my minimum reproducible program in it. This was the result: Thread 1 received signal SIGSEGV, Segmentation fault. 0x00000000680dd4b0 in rb_vm_bugreport () from C:\Ruby25-x64\msys64\mingw64\bin\x64-msvcrt-ruby250.dll Based on this, I'm thinking that the VM is encountering an issue when it attempts to start, and when it attempts to tell me why, the `rb_vm_bugreport()` function produces a segfault. At least now I have more information to run with.
Probably, the advantage (or the reason) of having parallel tests in Rails now is that those problems have been solved. 
&gt;Have you ever kissed a girl?
it doesn't work for me when I try to autocomplete to\_json, for instance: require 'json' a = \[\] a.to\_json maybe it doesn't support monkey patching , please can someone else confirm the same issue 
huh, this is awesome as well ! [https://i.ytimg.com/vi/HsgqEFbt8mA/hqdefault.jpg](https://i.ytimg.com/vi/HsgqEFbt8mA/hqdefault.jpg)
I've had no luck so far and went back to griddler. At least the SES/SNS adapter seems to not work at all, while the griddler adapter has solutions for all the quirks.
Intriguing. Cold starts are a big problem. Could be nice for an organization to group a bunch of functions with minor traffic who don‚Äôt want them all in one application.
I don't yet read all the article... (I paused at the beginning when I read about some tries in optimizing their ruby code before switching..) And I wonder why they didn't think about native extensions? If it was just a matter of some (isolated) heavy computation, native extensions would be a good fit...
You should keep reading the article :)
Of course..
Ewww - why would you want to do this?
&gt; The owner of this website (deliveroo.engineering) has banned the country or region your IP address is in (BR) from accessing this website :/
flip-flops are about to be removed though. (irb): warning: flip-flop is deprecated
Same for Colombia... :-/
I wish they would show some benchmarks around which parts of the Ruby code were so slow.
Good lord OP, why even write an article like this? **Everyone** knows Ruby is not a fast language and doesn't scale particularly well. This is not news. Furthermore, nobody chooses Ruby (or Rails) because it is fast or scales well. Rust is faster than Ruby. Who exactly is surprised? There are countless articles about "We switched from Ruby to Go/Rust/Clojure/Elm/Elixr/Scala" and its the same story every single time. &gt;Our project was successful: moving from Ruby to Rust was a success that dramatically sped up our dipatch process &amp;#x200B; Let's say it one more time with feeling - *Nobody chooses Ruby because it is fast*. Period. Switching from Ruby to a different language for performance reason is not news nor is it worthy of writing an article about.
Great write up (small typo in paragraph 3 of the Background section s/increase/increae/) Amazing performance gains, and love the incremental approach to moving stuff out of Ruby into Rust. 
(To be clear, I didn‚Äôt write this, just posted it)
Stop messing with my scrollbar.
Enjoyed the talk!
What are the advantages to webpack outside of webpacker? Or the disadvantages to webpack inside webpacker if that‚Äôs more to the point. 
Thanks for the reply. It‚Äôs interesting to hear of other places where they are used. I mostly wanted to show them to people that might not be aware but it sounds like you‚Äôre all set.
Username relevante 
Good lord OP, why even write a comment like this? It's an interesting and informative article discussing practical real-world experience of bridging Ruby and Rust, covering multiple available options and giving useful examples. Your comment meanwhile is a worthless rant that seems anchored in juvenile defensiveness over one's favourite toy. Yeah, Ruby's slow. Sometimes it becomes a problem, and it's nice having guidance on how you might mitigate that.
There's literally a *Why Rust* section of the article. Perhaps you'd like to respond to that instead of mindlessly ranting. Again.
Modernising the installed base, in any large ecosystem based on technology undergoing significant change, is *hard*. The demonstrable quality and superiority of the newer system is irrelevant; you're pushing up against social/political constraints rather than purely technical ones. In incompletely walled gardens (as Rails has clearly been, at least post 3.2), it's even harder; you don't control the outside bits that people bring in to solve problems with now-legacy apps, and you never bothered to define proper interfaces because you were afraid that might hamper your ability to glue random bits onto the side of the megalith. They had the opportunity to clean up their architecture (some would say, to *initiate* architecture) in 4.0 and again in 5.0, but...social/political constraints.
&gt; that seems anchored in juvenile defensiveness over one's favourite toy I'm defending the language by saying it is slow? Interesting angle &gt; Yeah, Ruby's slow. Sometimes it becomes a problem, and it's nice having guidance on how you might mitigate that. Guidance like the 100+ articles that already talk about it? Saying "zomg Ruby is slow" was cool and hip 5 years ago but it's a long dead horse at this point.
Your are missing the point of the article.
Are you even replying to the right comment?
&gt; I'm defending the language by saying it is slow? Interesting angle I mean, you're literally whinging about there being too many articles about it. Doth protest too much and all that. &gt; Guidance like the 100+ articles that already talk about it? 100+ articles of similar detail on bridging Ruby and Rust? Feel free to suggest a few. That would be quite a bit more constructive. &gt; Saying "zomg Ruby is slow" was cool and hip 5 years ago but it's a long dead horse at this point. See, there's that defensiveness again. Boiling down a fairly detailed technical article to a dumb attack on how Ruby performs.
[I mirrored the article](https://hur.st/mirror/deliveroo.engineering/2019/02/14/moving-from-ruby-to-rust.html) if that helps.
I wish they could have at least tried JRuby or TruffleRuby First.
For non-UK people who are maybe less familiar with this company, I think it's worth noting that Deliveroo has been engaged in a bitter struggle against workers attempting to unionize for a couple of years now. There was a walkout strike in Manchester just today to protest delivery workers making under minimum wage. I'm sure their engineering team has interesting things to say but I'm wary of giving them the traffic.
&gt; See, there's that defensiveness again. Alright, ya got me üôÑ 
Why not to use `:pending` tag? Seems to be more explicit.
Made me go through several levels of captchas and selecting buses and motorcycles just to show me an article !!!
it's easier to just write \`x\` in front of the word. Specially if you are under editor like Vim (where you navigate with keyboard, and never use mouse) all you do is press \`\^ix\` + \`esc\` and boom you have \`xdescribe\` . So you can do this edit + trigger your tests under 1 second 
Webpacker gem is more plug n‚Äô play. But if you want or need more granular control over your frontend build the you‚Äôd want to separate the version of webpack that gets installed by the gem. My reasons to spit Webpack away were a bit edge case. I needed certain version of CSSnano for one project with multiple style sheets. In another I needed a certain version of Penthouse that depends on a certain version of headless chrome. 
Could crystal be a good alternative here? Given it's syntactically so similar to Ruby and has performance of a compiled language.
I agree that it‚Äôs faster. But it‚Äôs not as obvious. Other people who may not be very familiar with RSpec can struggle to understand this. In my opinion it‚Äôs the same as using abbreviations. You can technically create variables with one character, but that‚Äôs almost never a good idea.
Still hasn‚Äôt hit v1.0 ‚Äî most places won‚Äôt touch it.
If the poster is [https://twitter.com/steveklabnik](https://twitter.com/steveklabnik) then yes, we get it. You rock and you have moved on from Ruby and now doing cool shit with Rust.
GitHub uses RoR with success. They use Golang for performance sensitive stuff.
It's a little more complicated than that. The High Court ruled their riders are self employed. That's what makes it legal for them to earn below minimum wage. It's a wider issue with the rise of a self-employment style of work force. Like Uber drivers. On the flip side the riders are allowed perks that a normal employee does not, such as being able to have someone else carry out their work. Personally I really don't like it.
Uninteresting article honestly. 
Thanks man, I couldn't read it too.
The article is not accessible, but if you scroll down, some one has mirrored it.
&gt; Everyone knows Ruby is not a fast language and doesn't scale particularly well The Ruby apps at my work scale just fine, and we handle between 25k-40k RPM. The biggest bottlenecks are our RDS instances.
Might be worth trying [https://ghostinspector.com/](https://ghostinspector.com/)
First, what the hell is ruby 2.5.4? Second, this works for me #include &lt;ruby.h&gt; int main(int argc, char ** argv) { RUBY_INIT_STACK; ruby_init(); static char * args[] = { "", "-e", "" }; ruby_options(3, args); rb_require("socket"); rb_eval_string("p IO.instance_methods. include?(:read_nonblock)"); rb_eval_string("p IO.private_instance_methods.include?(:__read_nonblock)"); return 0; } As you can see + $ gcc tset.c -I /usr/include/ruby-2.6.0/x86_64-linux -I /usr/include/ruby-2.6.0 -lruby + $ ./a.out true true it seems to work fine.
I read this article as: * we had the performance problem for some parts of our Ruby infrastructure (that you probably could have met too) * we decided to solve it this way (by rewriting **part** of the infrastructure in Rust) * here are our practical experience of doing it this way if you want to try it. It doesn't look like Ruby-criticizing article for me, or Rust fanboy article, or "Ruby suckzzzz Rust rulezzzz" article. Just retelling of some interesting, practical **and related to Ruby** experience with large production codebase. 
Thanks! Relation#pick is handy: &gt;If you need to select a column from an ActiveRecord::Relation you can use pluck which will trigger the following query: &gt; &gt;SELECT \`articles\`.\`title\` FROM \`articles\` &gt; &gt;But if you want the first value you‚Äôll need to add a .limit(1) , that‚Äôs what pick is doing for you: &gt; &gt;SELECT \`articles\`.\`title\` FROM \`articles\` LIMIT 1 &amp;#x200B;
Disagree profoundly. Ten years in Ruby (and 20 in web dev) has taught me that controllers are to supply HTTP endpoints, validate incoming parameters, and perform assignment of exposures and/or redirections upon return from the business logic. Clean Architecture will save your project, if you let it.
&gt; `Array#extract!` Because mutability is the king and [#partition](https://ruby-doc.org/core-2.6.1/Enumerable.html#method-i-partition) is too hard :(
I had compiled [Ruby Reference](https://rubyreferences.github.io/rubyref/) from the official language docs, trying to make it easily readable and navigatable. Maybe this helps (at least as a secondary source).
Sorry; my bad. Don't know how that happened.
oh yes, of course fully agree if I was about to commit a pending test to \`master\` I would use \`:pending\` tag. But I rarely commit pending tests to master. I usually just mark some tests pending just for myself e.g. end of the day run of tests, marking tests I know are not finished or to work on other parts of application &amp;#x200B; When I'm 100 sure the feature is ready and ready for code review I rarely have any pending test left. &amp;#x200B; so yes use \`:pending\` for commiting TODO pending tests within the team (if needed) but use \`xdescribe\` \`xcontext\` \`xit\` as development productivity tool for single developer before finalizing Pull Request :) 
It is, and I still love ruby. This is an article about two of my favorite technologies working together! Ruby and Rust via a native extension is one of the oldest production uses of Rust. It‚Äôs nice to se this still happening at other places today.
How do you run integration / feature tests quickly? The slow part is starting up the headless browser between feature suites. And sometimes you're having that test make async calls, wait, etc.
"Use sparingly"
You are being defencive by saying the post shouldn‚Äôt be posted in the first place. The article is clearly how they replaced slow parts with Rust.
If you set the configuration as described in the docs there: RSpec.configure do |c| c.filter_run_when_matching :focus end Then you can just run `rspec` and your filtered examples will get picked up.
I'm running the beta in a side project currently, and I never knew how much I wanted #pick.
so, they moved a computation-heavy part of their platform to a compiled non-gc'ed multi-threadable platform. Seems fair. Would be nice to also know if they have the same workforce ratio for maintaining the new system, other than that. 
&gt; First, what the hell is ruby 2.5.4? An excellent question! I believe I downloaded that from the GitHub repository, specifically the ruby\_2\_5 branch. I didn't want to use 2.6 because it was super-new, not realizing that I was still jumping the gun with my 2.5 source. Whoops! &gt; Second, this works for me Yeah, straight-up Ruby like that works fine for me too. I felt like I was so close when I got my command-line app to load and run Ruby code (and it's super-easy to do, too), but adding in the Windows subsystem makes it segfault. Even running your example code segfaults when I tell the linker to use the Windows subsystem. &gt; And for the rb\_vm\_bugreport(), that prints to the console. I don't know enough about windows to know what happens when GUI application tries to print into the console when none is attached. But could be maybe related? That's what I'm thinking too. I think the call to `ruby_init()` fails for some reason, and when `rb_vm_bugreport()` tries to tell me why it failed, it can't "find" a console and segfaults because of it. Might be time to go spelunking into some C code... *cries in script kiddie* &gt; And finally, for embedding [http://mruby.org/](http://mruby.org/) is probably worth exploring. mruby is something I've toyed around with, and it's definitely an option. My only concern is that it's basically still Ruby 1.9.x at its heart, and I've started to use some Ruby 2.x features in my code. Now, I know there was a release recently that added a good chunk of the Ruby 2.x features in it, but it still makes me feel weird. I do still want to get the MRI working in a Windows GUI app, because now it's a challenge to surmount, but for practical use mruby is definitely on the table. Thank you for taking the time to respond! I really appreciate the help.
I appreciate this article. Thanks! In particular, I found the breakdown of approaches for how to connect Rust and Ruby to be very helpful. I've got quite a few libraries I've written in Ruby that I've come to depend on, and now that their interfaces are stable, I'd like to also consider offering native extensions (or even rust crates!). Now, I am a rank beginner with Rust, but it seems like an excellent companion to Ruby. Ruby's principal strength is expressiveness, and its principal drawbacks are performance and an inability to get compiled down to binaries (which doesn't matter much in the world of web development, but is a big deal for most other types of programs). Rust seems to address both quite nicely. For anyone who has put a significant investment in Ruby, Rust seems like a great choice for when you slam up against Ruby's limitations.
To me, that's part of the distinction between _refactoring_ and _redesign_; refactoring shouldn't affect your tests (you *are* only testing your classes' public API, right?), whereas a redesign *will* break unit tests. It'll *usually* break integration/feature tests too, so you break them first: as incrementally as practical, change your tests to work with your new design, watch them break on your old one, then iterate closer to a green bar again. I find that I rarely have the redesign fully thought through when I start reworking the tests, but that rework process helps me understand and evolve what I really want to do. Remember: Git branches are cheap, so don't be stingy about experimenting, but *do* watch out for aimless flail. I've been doing TDD/BDD/DDD/WTFDD for well over a decade now, and it's unusual for me to go a fortnight without learning something new about how to match my technique, process, and tools to what I'm trying to accomplish.
I think that might have to do with the JIT, I expect it to get stable in future releases, but who knows, I'm not really a Ruby core dev *shrugs*
For simple scripting I usually disable rubygems, it speeds it up a little bit (if you don't mind sticking to the standard library). There are also rubyopt and did_you_mean but I don't think they make a significant difference. $ time ruby -e '' --disable=gems real 0m0.047s user 0m0.022s sys 0m0.020s $ time ruby -e '' real 0m0.124s user 0m0.091s sys 0m0.026s 
 '2.4.5/bin/ruby -e ''' ran 1.03 ¬± 0.19 times faster than '2.3.8/bin/ruby -e ''' 1.09 ¬± 0.14 times faster than '2.5.3/bin/ruby -e ''' 1.42 ¬± 0.19 times faster than '2.6.1/bin/ruby -e ''' You can improve it a lot by disabling Rubygems: '2.6.1/bin/ruby --disable=gems -e ''' ran 8.81 ¬± 1.28 times faster than '2.6.1/bin/ruby -e ''' 2.6.1 is still the slowest of the lot: '2.4.5/bin/ruby --disable=gems -e ''' ran 1.01 ¬± 0.13 times faster than '2.5.3/bin/ruby --disable=gems -e ''' 1.06 ¬± 0.13 times faster than '2.3.8/bin/ruby --disable=gems -e ''' 1.49 ¬± 0.20 times faster than '2.6.1/bin/ruby --disable=gems -e ''' But it's ~11ms vs 16ms instead of 100ms vs 140ms.
I really wonder why they didn't call it \`select!\` though. 
Unless I'm misunderstanding you, you aren't talking about the gem, you are talking about the npm package, `@rails/webpacker`. The source of which lives here: https://github.com/rails/webpacker/tree/master/package It's a pretty thin wrapper on top of webpack that just provides environment based configuration and some default rules. If you wanted to use a specific version of webpack, you can just set that version in `resolutions` within `package.json` and get both the exact version of webpack you need and keep the environment based configuration integration. 
Yeah, note that as implied by the exclamation mark at the end, `extract!` is mutating. The text in OP was a bit confusing on this: "which works like reject! but instead of returning an array of the non-rejected values, you get" -- not just "returning", it mutates the receiver! `extract!` does not seem to actually be new? Documented as existing since at least Rails 4.1? https://www.rubydoc.info/docs/rails/4.1.7/Hash:extract! it is mentioned in the Change notes for Rails 6 though. Looks like previous `extract!` only took key arguments, new one takes a block too? The Changelog is indeed confusing! While `partition` is one non-mutating choice, it has somewhat different and less convenient semantics for many common use cases. The non-mutating method that matches the semantics of Rails extract!-with-block except for being non-mutating, is #select in Rails stdlib. https://ruby-doc.org/core-2.5.1/Hash.html#method-i-select And um, `select!` already exists (https://ruby-doc.org/core-2.5.1/Hash.html#method-i-select-21), but is documented to have _really confusing_ semantics. Maybe what you really want is [keep_if](https://ruby-doc.org/core-2.5.1/Hash.html#method-i-keep_if), which doesn't have a bang but is mutating, and _maybe_ actually has exactly equivalent semantics to new Rails `extract!`-with-block? This is indeed awfully confusing. 
I think you can use 'take' method which does something similar. Gives first value only.
Make sure to look into the memory errors in SmallVec
&gt; --disable TIL! Thank you (and /u/Freeky). I do stick to the standard library most of the times. This makes a significant difference in that case! 
Here's another interesting one, which I _think_ means no longer seeing that weird `utf8=‚úì` in your params! https://github.com/rails/rails/pull/32125
&gt; I think that might have to do with the JIT None of these versions have the JIT enabled by default.
JIT would affect the startup time somewhat I would guess, I thought 2.6.x was already enabled by default, but I might be mistaken. Of course, you could always disable it with a flag :p Anyways, maybe it's not even the JIT.
Right, I'm pretty sure it's nothing to do with the JIT (I work on Ruby JITs and follow the MRI JIT closely.)
Mmmmm... *everything* is an object...
As far as I understand it, in Austria there is no equivalent to "public domain" as it is in the USA. Once you create a work, you are its author ("Urheber" in German) - you can never waive this fact, you can only waive all your rights of the work. Contrast this with "public domain" of the USA where you even waive your authorship. Also see [https://de.wikipedia.org/wiki/Gemeinfreiheit#Abgrenzung\_zu\_verwandten\_Konzepten](https://de.wikipedia.org/wiki/Gemeinfreiheit#Abgrenzung_zu_verwandten_Konzepten) (in German).
Yeah, start-up time is pretty bad compared to other languages. I get |ruby 2.6.0 (`ruby -e ""`)|60ms| |:-|:-| |perl 5.26.2 (`perl -e ""`)|2ms| |python 3.6.7 (`python3 -c ""`)|13ms| &amp;#x200B; This is the reason the `hexapdf` binary (part of the HexaPDF library for processing PDF files) has a `batch` command because when working on many small PDFs the start-up overhead dominates the processing time (the difference for a test case was 14 seconds compared to 150 seconds).
Just nearly every programming language is "multi-paradigm" if you push hard enough. Ruby is one of the most unambiguously OO languages in use today, and describing it as otherwise seems rather silly.
https://github.com/amatsuda/heavens_door "Capybara test scenario recorder for Rails"
Sort of. I'd include that the specific behaviour is not always that everything is an object in EVERY regard of the definition. Best example is: x = 5; def x.hi; puts "hi"; end TypeError (can't define singleton) I mean it's not as if people get tripped up over this because it is a very very very small detail - but I think it should be pointed out whenever it is stated that "everything is an object". It should be more along the lines "just about everything in ruby is an object but it may not show full object-specific behaviour in every aspect". It's longer but ... would be more accurate.
I agree with your first sentence. I never fully understood why there is this distinction between "functional" and OOP - to me the whole distinction is hugely artificial and arbitrary. I disagree with your second comment, though. Ruby is OOP in its core design, yes - but it actually has always been multi-paradigm. You only have to look when matz added certain other parts of it in the past; procs; lambdas; and so forth. While I use ruby as an OOP language, there are others who write code differently. It would be wrong to state that ruby is ONLY an OOP language. OOP is at its core and, in my opinion, the basic core of ruby - but ruby IS multi-paradigm. It follows partially from "there is more than one way/path to go about doing something".
Very strange. I noticed the opposite behaviour - my ruby scripts get faster and faster. The official benchmarks show this too, so I am not sure how well your data can be trusted. Ruby has however had gotten somewhat bigger I assume; rubygems possibly, e. g. bundler integration. I think we can only get a realistic comparison if we know all details.
How peculiar. You should report this to the official bug tracker. Matz may look at getting the core team to improve on that.
The biggest difference between (pure) functional and non-functional languages is the lack of mutable state. Ruby has mutable state; while you can use it in a functional style, its support of mutable state disqualifies it from consideration as a functional language, in the paradigm sense. Real functional languages like Lisp, Haskell, Elm, or Erlang are defined by their immutability of state and idempotence of their functions - neither of which Ruby guarantees. You can make the case that Ruby can be used procedurally - but that's just because procedural and OO languages are both imperative. You can write Ruby in a functional style, but the imposition of that style is by the programmer, not the language. You can't write Ruby without using and being subject to the design of the object model, though.
Take returns an array instead of an ActiveRecord relation. 
That isn't a good counterexample of "everything is an object" - it just demonstrates that Ruby has a rule that won't let you extend instances of singleton objects (specifically, Fixnum, Integer, and Symbol) to keep yourself from shooting yourself in the foot, but they're still objects, and you can still extend the Integer and Symbol classes! AFAIK, the only cases of "not an object" in Ruby are methods and blocks (you don't instantiate either to use them), and they'll be bound to Method and Proc instances respectively in any case you _do_ want to use them, so the distinction is essentially not useful.
`strace -c ruby -e '' --disable-gems` On my system, it looks like what's causing the slowdown is that it is lstat'ing the ruby-2.6.1/lib directory.
&gt;The Ruby apps at my work scale just fine Well that's another issue entirely. Ruby, the language, isn't *slow.* The performance issues have with it are because of architectural decisions that would likely effect other languages in similar ways. &gt;The biggest bottlenecks are our RDS instances. The data access layer is pretty much always the bottleneck. We had the same problem with RDS with C#. Our entire DAL was single-threaded and blocking. It was a disaster. &amp;#x200B;
That's probably the most pragmatic way of doing it. Puppet, for example, decided to rewrite their *entire* framework (the backend parts) in Clojure. It's taken them years and they still aren't finished with it. It's faster, sure, but at what cost?
I'd work with Enumerable tbh, something like, `enum = page.elements enum.each do puts 'found element' end ` But I have very little experience with selenium
Rubygems have fundamental design flaw. It allows people to install multiple versions of gems which is useless since everybody are using rbenv or rvm anyway. But it slows down loading of all ruby programs by order of magnitude. Especially with loads of gems installed. 
Thanks! I know how to do that with Watir and Capybara, but if I use this maybe I need to rewrite all the code hahahah
My general advice would be, try to avoid loop do end and while and for.... Ruby has iterators of all kinds for iterating over collections
Yep, but in this case I can't avoid unfortunately. I need to click ok until find the object.
Good luck then I guess :D
&gt; since everybody are using rbenv or rvm anyway. Nope, definitely not. Since bundler was invented some years ago, nobody I know uses "rvm" style environment managing. Which I am glad not to have to, I found it a mess. 
Thanks!
&gt; I thought 2.6.x was already enabled by default, but I might be mistaken. Yeah, you are. Why not google it yourself if you're not sure instead of putting incorrect info on reddit and making someone else do the work of verifying? https://www.ruby-lang.org/en/news/2018/12/25/ruby-2-6-0-released/
&gt; AFAIK, the only cases of "not an object" in Ruby are methods and blocks How are methods (instances of the class Method) not objects?
Yes. You can loop `while` something or `until` something and `break` if something else. HTH
Wut? So it only counts if thrift or protobuf is the transport?
An HTTP API can certainly have a service behind it. All the Amazon services we use work this way. But there's a difference between using an HTTP endpoint to send a message to a service, and using an HTTP endpoints to persist data.
What you probably want is something like this, or use capybara since it does this kinda crap for you: wait = Selenium::WebDriver::Wait.new(timeout: 15) # how long to wait button = wait.until do ele = browser.find_element(:xpath, "//span[@class='rwInnerSpan' and text()='OK']") ele if ele.displayed? end 
So you have a problem with REST and prefer RPC based API? That's all I'm getting here...
I wish they would put the snowman back. 
That's all you're getting because that's all you're seeing. And that's because you're making assumptions. I never even hinted that I have a problem with databases over HTTP. I've used several databases with HTTP APIs, there are definitive advantages. Almost categorically, however, I'd argue that a monolith with a single relational database is preferable to any "service architecture" where services can query other services for data. There's a reason that approach is more commonly called "distributed monolith." All the entanglement of monoliths combined with the hardest problems that distributed systems can offer. If I want a method call, I'd rather use a normal method call than RPC. Queues aren't RPC.
Bundler doesnt do anything with different ruby versions. It's totally orthogonal to rbenv/rvm. And to counter your anecdote I dont know anybody who does ruby development without rbenv unless they are using docker for everything
But different ruby versions is totally orthogonal to different versions of rubygems installed. I was assuming you meant using rvm "gemsets" to control what versions of gems are available in a given context, and then only installing one version of every gem in a given "gemset". Something like that was what we used to have to do to manage dependencies before bundler. Now it's just fine to have more than one version of a gem installed, `bundle exec` will make sure a given project always gets exactly the same gem dependencies activated, reproducibly. I guess we know different people, cause you know nobody that doens't use rvm (gemsets?), and I know nobody that does use rvm gemsets. But clearly "everyone" doesn't use them. If you don't use rvm _gemsets_ (and arguably even if you do), whether you use rvm, rbenv, or chruby, or none of those, for ruby version switching, it is not useless to have multiple versions of a gem installed in the current ruby system. 
&gt; EDIT: Had no idea how many folks sub here just to shit on Ruby Just... what are you even *referring to*?! This is why I accuse you of being overly defensive - you're treating a pretty decent article about *writing Ruby extensions* like it's some sort of worthless diss on the language. And when people point out the article is informative and useful you tack on *this* nonsense like they're Ruby-hating gits for *daring* to question your interpretation. I've been using Ruby as my daily go-to language for about *20 years* now. If anyone here is shitting on anything here, it's *you*, on exactly the sort of content I find useful and interesting in my day to day life as a Ruby programmer. Kindly stop.
In general Ruby has had a massive problem with excessive stat-ing or openat() as part of `require` "forever". It's become a much bigger deal with bundler, because bundler in particular has lead to an explosion in pollution of $LOAD_PATH, and the time spent checking paths grows exponentially with the number of gems. I've had apps in the past where large number of gems means that ugly hacks like saving $LOAD_PATH, and explicitly adding only a given gem's directory to the path, requiring the gem and restoring $LOAD_PATH cut number of stat's on startup from more than 100k (yes, really) to &lt;10k. And that was the quick and dirty solution; we could have spent time making it much more precise, but that alone cut the startup time by *minutes* on the system (pre-SSDs...) it was running on. What's really needed is to deprecate putting directories in $LOAD_PATH, in particular. More use of require_relative helps to an extent. E.g. in most cases you really want to ensure you load files from a given gem anyway, not randomly scan ever gem installed both on the system and mentioned in your gemfile for a file that happens to match the require'd name. But really what you'd often want is to specifically require from "the system", a given gem's base path, or the current projects base path, and exclude everything else from consideration. E.g. consider the two options below. The first results in 4x as many system calls to load "foo". But that on a machine with barely any system-level gems installed, and without any Gemfile. Every gem you add would pollute $LOAD_PATH and increase the number of system calls for *every* require: ``` $LOAD_PATH &lt;&lt; File.dirname(__FILE__) require 'foo' ``` vs. ``` require_relative 'foo' ``` But using require_relative everywhere is not a proper solution. 
RVM/RBENV are solutions to containerizing projects to make them more easily deployable. Ever deployed a Rails 2 app on Ruby 1.8.2? Yeah, you're in for dev hell. It's not a solution for eliminating gems not in your project. Sometimes I need to install something outside of my Gemfile. Sometimes I need a quick script and it needs a library, or I'm working on a git project. Or how about Foreman - it's silly to set it up in your Gemfile if you're not deploying with it - a gem install does well enough. And if that upgrade to Nokogiri breaks your app, you'll be sitting around for 3 more minutes waiting to downgrade the thing if you remove the old version. That's only some reasons that come to mind - there are plenty of reasons to install gems outside of a Gemfile. Additionally, if you *are* running something with a Gemfile, it targets the explicit gem you're using (if you specify versions in your Gemfile, which you should, and if you don't, you should) - it doesn't matter if you have 17 versions of pry installed. That's not where slowdowns occur. If it was, having more than one version of a gem installed would outright crash your app due to naming collisions, but bundler doesn't allow that to happen (at least not through that software).
I have to disagree. I use RVM locally and RBENV on every production machine I use. It's so much easier to upgrade rbenv and install a version of ruby when upgrading, rather than trying to install it from scratch. And gemsets are glorious when you have literally dozens of projects you're working on simultaneously. If you've got one project and only working on one ruby version ever, then, sure, there's no need. But, hell, up until a year ago, I was managing an app that was on Ruby 1.8.6. Now I have two on 2.5, one on 2.3, a few older projects on 2.2... that juggling just doesn't work with system ruby.
No matter if people are using rvm or similar tools or not, the design flaw is there. Rubygems is slow. I have done reseaarch and a talk about it in 2014. About 27:00 here. https://youtu.be/xecVyZNGFps The problem lies in rubygems and bundler with rvm like tools only makes the problem worse as you install more and more files into your lib folder. The thing is rubygems must be fixed, not bundler or rvm. 
The more files you install using rvm the more directories ruby needs to walk. See my explanation in https://youtu.be/xecVyZNGFps at 27:00. There is not an easy way out of this unfortunately. I did my research and we wrote bundler_ext gem which makes things a little better by disabling bundler. You have to manage dependencies manually. We use RPMs. But the problem is still there. 
Try [cypress.io](https://cypress.io) for end to end testing. Simple and sweet!
What would be the world without lawyers hairsplitting the word "is" or in this case "public domain" :-). Yes, the Creative Commons Zero (CC0) holds in Austria, see https://www.creativecommons.at/cc0-lizenz-oesterreich (in German). Of course, if you ask three different lawyers you will get three different opinions (depending on who pays for the study). 
You can do it like this `if ["this","that"].include? prediction` or like this `if prediction == "this" || prediction == "that"`
Hey thank you so much! I just tried it and it works :)
This exact waiting behavior is a core functionality of Capybara, it will wait automatically if you call e.g. `find(:xpath, "//span[@class='rwInnerSpan' and text()='OK']")` `puts "Element find"` &amp;#x200B; See [https://www.rubydoc.info/github/teamcapybara/capybara#asynchronous-javascript-ajax-and-friends](https://www.rubydoc.info/github/teamcapybara/capybara#asynchronous-javascript-ajax-and-friends) &amp;#x200B;
Oops, I misread your post and thought you were already using Capybara. Well, the recommendation is still valid.
Thanks!
By default the capybara waits 5 seconds to find the element.
Browser tests are not part of my development workflow, except for when I'm working with a web-based GUI that can only be tested by a web browser. For backend services, which don't typically offer web GUIs that would require a browser to test, I follow the maxim: "sufficiently advanced test automation is indistinguishable from monitoring."
To help understand why, it may be useful to consider how the computer thinks about your instructions. A lot of the things you type into a program are called _expressions._ An expression is really **anything that has a value**‚Äîin other words, anything you can assign to a variable. Bear in mind that values must be of a certain "type" `'yes'` is an expression whose value is itself (the String "yes"), `1 + 1` is an expression whose value is the Integer 2, and `true &amp;&amp; false` is an expression whose value is the Boolean false. In an `if` statement, all the computer cares about is the **value of the expression after `if`**. `if (true)` causes the code below it to run; `if (false)` causes the `else` clause to run. In your original code, `if prediction == ["Rams" || "LA"]` doesn't mean what you're trying to say, because the expression `prediction == ["Rams" || "LA"]` will always have the value false: `prediction` is a string that the user enters, and `["Rams" || "LA"] is an array. A string is never equal to an array, so the whole thing is always false. You had another expression in your `elsif` branch, `prediction == "Patriots || New England || Brady"`. This _can_ be true, but only if the user enters the whole string verbatim (_i.e.,_ "Patriots || New England || Brady"). Since you put the `||` inside quotation marks, they don't have their special meaning of "or", and are just normal characters in a string. The key is to give `if` or `elsif` an expression that has a true value when you want and a false value when you don't. Per /u/Tomarse's suggestions, `["this", "that"].include?(prediction)` and `prediction == "this" || prediction == "that"` are both expressions that are true when you want them to be. They're a little more complicated than the expressions we've talked about so far. If you don't understand why they work, I highly recommend you take some time to think about it (and read the Ruby Array documentation on the `#include?` method) until you understand it well enough to explain it to someone else. 
I tried everything on windows. didn't work! I installed ubuntu and right after installing ruby, rails, rvm, node, I created a new rails project. everything worked absolutely fine. but when I started server, I kept getting connection pool error on both sqlite3 and postgresql.
Search this reddit a bit more, this question or very similar were asked before
As an addendum to /u/ryanlue, you may want to try using `case`: case prediction when 'Rams', 'LA' # code code code when 'Patriots', 'New England', 'Brady' # code code code else # code code code end Ruby's `case` is very powerful and can do a lot of cool stuff, if you know what you're doing. For situations like the one you're working on, it may end up being more readable than a bunch of array `include?`s or expressions chained together with `||`. &amp;nbsp; Additionally, I noticed that you're using `capitalize!` on the string you get from the user. Most "bang" methods (i.e. methods that end in an exclamation point (!)) modify the object "in-place"; meaning that you can call it on an already set variable without assigning it to a new variable. However, these methods _also_ usually return `nil` if no changes are made. So, if the user were to input "Hello", calling `capitalize!` on it would return `nil` because the string is already in the correct form, whereas `capitalize` would do what you wanted. &gt; "Hello".capitalize # =&gt; "Hello" &gt; "Hello".capitalize! # =&gt; nil &amp;nbsp; Lastly, I notice that one of your options is "New England", which can never occur. `capitalize` downcases the rest of the string after the first letter, so you could end up with "New england" but never "New England". It would probably be better to `downcase` the what you get from the user and work with all lower case strings instead.
Google would also be a great resource here.
Not sure if I‚Äôm wording this correctly. I‚Äôd like to just learn the basics so when I‚Äôm listening to him talk about it, I can maybe understand a bit. 
Decent article, but the part about Emails is wrong. What if I buy a [.computer](https://icannwiki.org/.computer) domain name? Your regex wouldn't let me use it
Hi! I think it's super cool that you want to learn more about this so you can bond with your husband. I'd probably start with the intro to ruby from the official website: https://www.ruby-lang.org/en/documentation/quickstart/ From there, you could try and find a book that meshes with you. Or you could try and learn by doing. Whichever suits your personality more. Personally, I learned by doing so I can't really recommend a book, but I know that the "learn x the hard way" books are popular, and I know that there's a ruby one. But I couldn't tell you how good it is. 
He‚Äôs so passionate about it I just want to know what the heck he‚Äôs talking about. He was a developer for something. I think its called Waitr but he calls it water. I‚Äôll try checking out that link. I don‚Äôt know much about programming so hopefully I can figure it out. It seems super complicated. 
That's problably watir - http://watir.com/
I don't have much useful to add but you seem like an awesome wife! I'm sure your husband will really appreciate it.
I think Learn Enough Ruby to be Dangerous is an enjoyable resource. It gets bonus points in your case because it has a chapter dedicated to testing. Good luck with your programming adventure.
I work with animals and he 100% listens to everything I tell him and understands it. I just want to understand what he talks about. 
That‚Äôs it! 
This warms the cockles of my heart.
It‚Äôs super intimidating, I must admit. My dad was a programmer and worked off a ‚Äúgreen screen‚Äù hooked to I think an AS400. I may not have the passion my husband has for it but I‚Äôd love to learn. It‚Äôs exciting just hearing him talk about it. 
You probably don't need to learn about ruby specifically (at least not at first), and just need to learn about software development in general. Unless he talks about the language rather than what he is using the language for.
I tried code academy but it felt to ‚Äúgame like‚Äù. I didn‚Äôt like it. I may have learned a bit but it felt cheesy. Does that make sense? Like the hooked on phonics of programming. 
I bet he'd enjoy introducing you. I am passionate about Ruby, use the language on a daily basis, and did spend time to explain to my girlfriend why I like this language specifically, with examples. It was a very fun experience as it challenged me to explain "programming", "programming language", to show different examples of languages, etc. in order to give her context. I had to show her the world I spend time in and her being able to understand me on that level was very gratifying. I recommend you ask him to explain, and ask all the questions to come to mind as you try to understand his world. See it as talking to a kid about his favorite videogame -- it would not be the same if you went on to learn about it yourself. The juice is in his welcoming you into his world. If you choose to have this conversation, I'd love it if you shared how it went. 
a little out of date, buts its less boring than a traditional tutorial: [https://poignant.guide/book/chapter-1.html](https://poignant.guide/book/chapter-1.html) This is how i got into ruby.
Chris Pine's [Learn to Program](https://pragprog.com/book/ltp2/learn-to-program) is a great book to get you started on learning the basics of programming, and it's presented in Ruby. A lot of the other Ruby books assume a basic understanding of things like flow control, functions, etc, whereas this one really takes a very basic approach and assumes you have no prior experience coming in.
I‚Äôve tried to talk to him about it but I think because I don‚Äôt know the basics, it‚Äôs overwhelming. It‚Äôs like he tries to talk about it in simple terms for a minute but gets so excited he might as well be speaking a foreign language. 
Basics is what I need! I‚Äôll check this out as well. Thank you!
Not to be sexist (and not presuming your gender) because I didn't name this group but I found some of their training quite accessible. [http://railsgirls.com/](http://railsgirls.com/)
Udemy.com does video series' about everything to do with development. They're a lot more serious than CodeAcademy and very matter-of-fact. They're paid courses, but when they have sales on (which is virtually every other day), they're only about ¬£10 and as much as 40 hours of quality lectures. Colt Steele does a famous one that thousands of people got started with, I think it's just called 'The Web Developer Bootcamp'. They also have series' for Ruby, Ruby on Rails and advanced Ruby. Good luck! : )
I have no problem paying to learn. (I think if people are willing to teach things that have taken them years to learn, they damn well should get paid for it) I‚Äôll check this out! Thank you! 
Oh, I see. OK, here are a few aspects which I enjoy about Ruby. 1. Its creator, this cool, always positive and seemingly never-aging Japanese guy Matz was learning programming and all the languages felt klutzy and difficult. There was too much to type and too much to do just to make the computer happy. *So he decided to make a language that makes programmers happy.* What an idea! Of course, it is one thing to think that you can create a language like that and a completely another thing to do it, because, who the hell knows what makes programmers happy?! But, he did it, just like that (well, over many years). So even the very existence of the language itself is a testimony of humanity and creativity and delight. 2. It is simple! "5.times do X"... well, I don't have to mansplain what this does, do I? It is structured to read like plain English (by a Japanese guy!) and in many cases this simple matching how our brains work removes a lot of tension, and makes our programming thoughts... just... flow. Like, "do this stuff *unless* ..." 3. It doesn't make us type stuff we don't have to. I can type "calculate_car_loan(car_price, months, interest)" or "calculate_car_loan car_price, months, interes". This is just one example, things lie this add up. 4. When programming Ruby you are in God mode! If it was a computer game, you the player would be able to change physics, and alter the rules of the world. Matz trusts you to do this. Of course, with great power comes great responsibility, and so, by definition, Matz just made you more responsible! 5. It can be very terse and powerful. You can do a lot in one line. That can be dangerously satisfying. 6. All of the above can result in serious nerdom. Look at [this guy](http://reference.jumpingmonkey.org/programming_languages/ruby/ruby-one-liners.html) and def show your BF [this one](https://www.youtube.com/watch?v=aBgnlBoIkVM). 7. Because of the nature of the language, many smart and cool people gravitate to it. Think of the climber community -- supportive, nerdy, generous, smart and cool, with appreciation of the good things in life. Wouldn't *you* want to mingle with people like this? So, this is just a start. Maybe bring some of these topics with him. Maybe some of the people in this thread could add more of what they like, about the language, with simple examples?
Seriously though, the "sale" prices of ¬£10-15 are the actual prices. The "standard prices" of hundreds and up are not expected to be paid, so don't go dropping ¬£199 on something you can get for a tenth of that the next day. They have sales constantly, I bought a series on sale for ¬£12.50 just last night when it was ¬£99.99 the day before. They'll have a sale on again within 3 days, guaranteed. 
I second this for your purposes, it‚Äôs an extremely thorough basics guide with small exercises after each chapter to reinforce the learning. Enjoy listening to your husband wax poetic!
Check out the Odin project.
&gt; I don‚Äôt know much about programming so hopefully I &gt; can figure it out. It seems super complicated. Ruby is quite simple/easy on the mind if you keep it simple. There is nothing as complicated as in C, where you have to juggle pointers or have a compile step. In my opinion, though, the only real way to understand ruby is to write code that does something. If you are of a somewhat young age (techie-generation) then picking up programming even casually should be really simple. You don't have to go to learn everything either - just pick on something that interests you and where you think you can get more things done by letting the computer do it (which is actually what I use ruby for mostly, really - ruby is the ultimate glue language for literally any task I can feed to the computer into doing for me). I don't know watir well. I would not assume that everyone is fascinated by it, though. Watir could be very boring, but ruby can be a LOT of fun (if you can avoid doing boring things; many people who make a living being programmers have to do a lot of boring stuff - look at the javascript folks).
It's a very good book. A bit outdated but still great. I wondered about updating it and putting the updated variant onto rubygems - but I am so lazy and slow. :( I did lots of totally random other things ... like in the last few days, I was playing around with KDE konsole. Did you folks know that you can style the konsole tabs, via a .css file? I did not know! And now I am playing around with putting custom icons onto the konsole tab... from ruby scripts. And then unicode/emoji - that will be a lot of fun. Is also probably a bit a waste of time but ... it looks cute!
I am a biologist/molecular biologist "by trade" (and then dabbled into bioinformatics ... unfortunately bioinformatics is so heavily infested with maths ...). I use ruby because it is hugely consistent, linear, elegant and concise (once you understand it; initially it may be a bit difficult if you never programmed before; I was using perl and php before, so ruby easily beats both).
&gt; Matz trusts you to do this. Of course, with great power comes &gt; great responsibility, and so, by definition, Matz just made &gt; you more responsible! It's less about whether matz trusts anyone or not - that is not relevant. It's the philosophy of ruby. More than one way to do it - and ruby in many ways does not care which style you go about, e. g. if you use OOP-centric style, if you add or don't add (), if you go functional and so forth. It's very different to python where the parser will scream at people if they forget () or don't indent properly. The ruby parser is more sophisticated/flexible. It's a very different philosophy from many other programming languages. 
Wow. You‚Äôre amazing.
These annoy me a lot. I noticed a local ad but only girls were allowed to go there. That really made me angry. If I were to host a ruby conference or workshop, I simply wouldn't care about gender to begin with. That thought would not even cross my mind at all. I also don't buy into the "girls are so easily discouraged" because I know plenty who can program without a problem. This gender-centric thinking really makes people dumber in general.
Good!
Then I'd say your use case is not really typical for Rails. Rails has an api mode, but is primarily designed for full stack development. That's why parallel testing is important. A single browser test can take as long as hundreds of unit tests.
Are you my husband? He speaks of ruby like it‚Äôs a smooth melody. You sound a lot like him. 
Watir is great. I've used it in a bunch of projects. It solves a bunch of really difficult problems. Tell him some random nerds on the internet like his work.
&gt; Then I'd say your use case is not really typical for Rails I agree. But that doesn't mean I don't use Rails, it just means that the way that I get my Rails apps to work correctly and reliably doesn't require me to write and maintain all that many tests that exercise the entire system. &gt; Rails has an api mode, but is primarily designed for full stack development. That's why parallel testing is important. A single browser test can take as long as hundreds of unit tests. I've used Rails plenty. I've drank my fill of the browser test kool-aid. Outside-in development with heavy browser testing is not a sustainable approach -- it may work fine in the short term (6-12 months), but over the course of a decade, it inevitably puts a heavy strain on productivity. Let me put it another way: if your tests cannot validate that your software works _without_ a web browser then your software is inextricably _coupled_ to its GUI. Which means you (not you personally, the proverbial "you") basically took MVC and completely threw it away.
&gt; hooked on phonics of programming An excellent description.
Yep. A partner that wants to learn something thats a bit complex like programming only because YOU like it is - put a ring on it worthy.
I‚Äôd be lying if I said I didn‚Äôt tear up a little
 &gt;These annoy me a lot. &gt; &gt;I noticed a local ad but only girls were allowed to go there. That really made me angry. then you are too easy to be angry. the shortage of women in tech is areal thing and if they want to get together and discuss the issues without males around thats their business. &amp;#x200B; &gt; I also don't buy into the "girls are so easily discouraged" because I know plenty who can program without a problem. This gender-centric thinking really makes people dumber in general. I've never seen anyone there claim "girls are easily discouraged" or dumber. You are quite possibly attaching your own biases to this. If you haven't noticed boys are kinda different and not only anatomy (women are better in most areas areas that matter IMO) . I'v e taught and I don't ar about any PC argument. There are some analogies that are more affective with a mom than a dad. Doesn't make ANY of them dumber - just different. Unisex people can all fly off to another planet where women and men are both less interesting and they can go extinct. 
If you're using Ruby with Selenium you should almost always be using Capybara. There's very little reason not to. With that you want to try something like: `while page.has_css?('.rwInnerSpan')` ` # do whatever` `end`
That‚Äôs cool 
This is what you want your wife/SO to write to Reddit. She's the unicorn. 
Well, if he talks like a husband and sounds like a husband...
I‚Äôm no unicorn. I promise. He gets mad at me because I won‚Äôt let him play my vanilla Skyrim. We have are faults/arguments. 
We are married. 
I intended that as a complement. :) Enjoy. You're very lucky to have each other! 
I've volunteered at rails bridge and other female based events in the past when I was a high school programming teacher... The social environment at those types of events can be extremely beneficial to people's learning (not just females) where they feel more relaxed and their attention is not divided from certain social factors.
I always recommend rubymonk.com and also the poignant guide can be interesting if you like comics. These are the two primary ways I got into Ruby. Problem is both are a bit dated and the first may be down sometimes as the maintainer can't support it full time I think. 
Sorry. One of the key concepts in ruby is a technique called 'Duck Typing.' That's where the saying comes from..."If it walks like a duck and talks like a duck, we consider it a duck' This is a pretty poor joke for a non-rubyist.
I think my husband has talked about this before! Will look this up as well! Thank you so much! 
\&gt; then your software is inextricably *coupled* to its GUI. &amp;#x200B; Well, yes, that's the nature of a web application. I can test that the api works. I can test that the ui works with Jest. But I cannot know with a high degree of confidence that the backend and frontend are working as intended together without a browser test. And without feature tests, it's also easier to have frontend and backend get out of sync.
My husband makes a duck comment but it‚Äôs a bit different. He says if you have a problem, all it takes it saying it out loud to fix it. Essentially, you could talk to a rubber duck, as soon as you say it out loud, you understand your own problem.
That's Rubber Duck Debugging
&gt; But I cannot know with a high degree of confidence that the backend and frontend are working as intended together without a browser test. Is that because to do so is impossible?
Can you give examples of some of the things you'd like understand? I wonder if they aren't more cultural or higher level than what you're asking about. Or put another way, learning to program might not teach you what you think you want to learn. 
Oh Look it is TenderLove's wife
I should warn you that (from personal experience) once you understand programming he may casually attempt to use you as the duck. 
He does. Thats why I want to learn. 
You should also choose a text editor now and make sure he respects your choice. It's 2019, we can be married to someone with a different religion. 
I appreciate your reply. I don‚Äôt think I‚Äôd like to be apart of a ‚Äúgirls only‚Äù group. I reckon I don‚Äôt think I‚Äôd learn any differently from men so I don‚Äôt really get it. 
I am an absolute newb when it comes to programming. I‚Äôd like to not only learn general programming basics, but maybe lean that knowledge on the ruby side of things. Does that make sense? I‚Äôm almost positive I sound like an idiot right now. 
The fact you wouldn't consider gender is a problem, not a virtue - it means you're blind to the suppression of minority groups in tech, which (wearing my manager's hat) has consistently and systematically undermined my access to the talent pool. This isn't "gender-centric thinking", it's enlightened self-interest. As usual, being "angry" solves no problems at all, and to me it says more about you than it does about the employment friction. 
To reply to this again. My dad was an amazing programmer. But he only wanted to teach my brothers. I‚Äôve always wanted to learn. I tried for a few months when I was in my late 20‚Äôs to learn from my day but he died in 2012 so I didn‚Äôt get the chance to really pick his brain about it. Sometimes I feel like I‚Äôd be closer to him and my husband because they are so much alike. Not only is it their job, it‚Äôs their passion and hobby. I just kinda want to dig into and understand this passion, ya know? 
Yeah, I completely get that. And it makes a ton of sense. What I'm curious about is what is something you don't understand? Maybe "All of it!" is your first reaction, but this isn't all that helpful. Most people learned to program by solving a problem. A simple problem such as, "I wonder if the computer can do this math problem for me easier than me doing it my self." &amp;#x200B; And so, what is your simple problem? Can you think of anything your husband has said recently that you didn't understand and you'd like to? 
While this is fantastic. You're in for a world of hurt. Give us some things he says for context. I assume hes not handing you algorithms or white boarding. So he must talk about stuff. If you can give us key words we can probably point you at what they are. 
This makes me want to get a rubber duck for my desk 
Sign up for app academy open, they focus on ruby and rails
Watir is awesome! Kudos to your husband üèÜ 
*infested* Made my day...
Use Learn to Program. https://pine.fm/LearnToProgram/
Hi, as many other people said, it's great to invest some time just for the sake to share more thoughts with your husband.. Imho, you don't really need to know that much about Ruby, I mean the heavy parts about OO (object oriented programming) and metaprogramming (ability for the program to adapt itself to some situation which is easy to implement in Ruby).. But more about the problem that this Ruby gem (the plugin you're husband is involved into) is actually solving, ie. automatic testing... For example the fact that more and more websites use dynamic content rendered in JavaScript (to put simply, it's a way to have, let's say a more visually appealing website with some animation and a cooler User Interface) that brought the need to test them in the context of a browser by a human... But it can be really cumbersome, it would be great to have some automation tool that do this for us... Wait.. Watir.. This gem is here for that! In short you may want to read some stuff about *system tests* _(in rails -the main ruby web framework-)_ or end-to-end tests...
Yup. That's also a fairly popular method to clarify tthings in your own head by talking it out loud.
[Frank](https://imgur.com/a/YzFWkCm) has one to spare. You have to promise belly rubs for it though.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/wS3nlub.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20egmxxup) 
Yeah but the rubyists in the room got it.. And it was funny. :)
I don‚Äôt think I can edit my post so I‚Äôll put this here. I‚Äôve been reading and watching this community for quite some time and was a bit intimidated at the thought of posting. I‚Äôve seen a few arguments along the way here, so, me having no idea about ruby, I was expecting a bit of backlash. You guys were not only informative but y‚Äôall were kind and appreciative of my wanting to learn. Seriously, you guys are the absolute best and I appreciate all the advice and kind words. You guys are so full of knowledge and seem so willing to spread it. Thank you all for being so amazing. I‚Äôm taking all the advice and will report back with hopefully a passionate understanding and willingness to learn Ruby. Again, you guys are awesome! 
I gave you a link to their training material because as a guy I found it personally accessible - not to join the group or because its girls only (their online content isn't). However lol...it seems like quite a few people are triggered just by the name as if its something inferior which shows sexism can come from either gender.
The link is informative so thank you. It might be a bit sexist because it‚Äôs slanted towards girls. Sexism goes both ways. But I get it, I‚Äôd love for more girls to get into the field. I appreciate your reply. Again, thank you! 