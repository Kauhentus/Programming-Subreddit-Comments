I believe you are looking for "10 Things You Didn't Know Ruby Could Do" by JEGII: [https://confreaks.tv/videos/aloharuby2012-ten-things-you-didn-t-know-ruby-could-do](https://confreaks.tv/videos/aloharuby2012-ten-things-you-didn-t-know-ruby-could-do) &amp;#x200B; (There is also a Rails version: [https://confreaks.tv/videos/railsconf2012-ten-things-you-didn-t-know-rails-could-do](https://confreaks.tv/videos/railsconf2012-ten-things-you-didn-t-know-rails-could-do))
I did a few quick tests and it looks like there is a pretty large penalty for jit on fast sidekiq tasks (or tasks that are currently optimized to call compiled gem related code) and "ok" increases on pure ruby CPU intensive sidekiq tasks. It certainly feels like heavy IO/memory/object mutation related code is a weak spot of the current round of JIT code. Net for a few of my codebases was a loss re sidekiq. huge tank on rails apps.
That's the one! Thank you! The switch he did in the title threw me for a loop.
That is it, thanks :)
&gt; I fould this statement wrong and naive. Of course they are relevant and it has nothing to do with duck typing. Be kinder. We don't need to make every Internet forum toxic.
I've managed to get a working pg Layer. Doing some additional testing and then I'll share it.
SOLID is mostly rubish. SRP - Decent guideline but the worst code I've ever worked on followed this rule religiously. Wading through 25 5 line classes is _not_ easier to understand than a single 100 line method. Particularly since most of these classes end up with meaninglessly abstract names. Open/closed principle - A great way to ensure your codebase only grows in size and eventually becomes unusable. Liskov substitution principle - I'm OK with this one, caveat being you almost never be using inheritance anyway. Interface segregation principle - Doesn't really apply to Ruby and in languages where it does apply actually implementing this results in a massive sea of interfaces no one wants to untangle. Similar to the Open/closed principle this is a great way to ensure your codebase will bloat over time and become impossible to work with. Dependency inversion principle - This one varies, there are dozens of way to interpret this, some are good (allow setting a Logger), some are fucking awful (IoC containers). 
You really have to twist the definition of interface segregation to apply it to Ruby. In your example you have created a single general purpose interface for two use cases which is really against the entire point. 
I'd love to get into opal but I am a slow learner and need LOTS of examples. I actually learn the most from examples, e. g. tweaking what others wrote, and then AS I do so, read up on documentation - this is how I learned ruby-gtk many years ago. And that, surprisingly enough, actually worked for me very well (and still does; I still use ruby-gtk). There does not seem to be a lot of tutorials of ruby + opal though. :( I'd love to use a system, including interactive javascript, just from a pure ruby solution really - even if it were only locally.
Yeah. I think TruffleRuby is not alone in this case - the rails team should really actively try to help standardize for other projects to pass things here. JIT has similar problems - rails is just such a huge beast.
Yeah - reminds me of people wanting to have crystal run on windows natively. No real progress is being made ... :)
Awww man. That's disappointing. Thanks for taking the time to investigate!
I know you've already found the video you wanted but it reminded me of a popular video I did back in 2012 called [Ruby Trick Shots: 24 Ruby Language Tips and Tricks](https://www.youtube.com/watch?v=gIEMKOI_Y-4) which you might also enjoy :-)
They have other drawbacks though. JRuby requires java for example. Rubinius I think is not 100% on-spec parity with MRI right now.
You are a king! I just found your twitter account and it says "Author of the AWS Lambda Ruby runtime". So you are one of the men I have to thank. 
&gt; But don't expect to see it in puma How come?
Steal logic from ActiveSupport and shove it in a class that represents the working week: require 'date' class WorkWeek attr_reader :start_day DAYS_INTO_WEEK = { monday: 0, tuesday: 1, wednesday: 2, thursday: 3, friday: 4, saturday: 5, sunday: 6 } def initialize(start_day) @start_day = start_day end def beginning_for(date) date - days_to_week_start(date) end private def days_to_week_start(date) start_day_number = DAYS_INTO_WEEK[start_day] current_day_number = date.wday != 0 ? date.wday - 1 : 6 (current_day_number - start_day_number) % 7 end end week = WorkWeek.new(:wednesday) week.beginning_for(Date.today).to_s #=&gt; "2018-12-05" 
 payweek = now - (now.wday - 3) % 7
OP is looking for the date of the start of the working week in which a specific date (`now`) falls. payweek_start_date = now - (now.wday - 3) % 7 
Seeing your full code would help. 
I added all files. Thank you!
Looks great - i'm about to put something live with this right now, will let you know how it goes!
Stack Overflow would contain tons of examples of communication between users in a programming context. Alternatively, there are many free and open Slack communities out there surrounding programming/software engineering communities. 
dies it have to be in the work place and verbal? Programmers communicate heavily in open forums and communities like on reddit and stackoverflow, etc. Could you analyze such written public discourse? You might even find nice differences between different language communities. 
I didn't even think about using Slack. Thanks for the suggestion! I've heard it's popular among programmers, but I haven't really used it. I could probably compare the language used in Stackoverflow to the used in Slack.
[https://bugs.ruby-lang.org/projects/ruby-trunk/issues](https://bugs.ruby-lang.org/projects/ruby-trunk/issues) &amp;#x200B; Pick some of the topic that interest you, may be moving to C99 compiler, JIT, or some others, there are lots of conversation there that could be useful for your analysis. 
Hey, thanks for the help!
Due to the fundamental way a request is handled inside puma, which maps well to HTTP/1 but is very hard to refactor at this point. Puma is hardly the only application server suffering from this design, and you can also see it in some HTTP client implementations: socket = request. That's it.
Now it’s really Christmas!
GitHub issues / PRs for big projects might also be of use. 
If multicore is important, consider writing it in a different language (C, Go, etc) but invoking it from a background worker like sidekiq. the creator of sidekiq has also created Faktory, which will allow you to write the worker client in Go. You would trigger the task by asking Sidekiq/Faktory to enqueue the task description. 
I'm not sure if Crystal version Sidekiq help? https://github.com/mperham/sidekiq.cr
You can use Ruby as a backend API for most of the major JS frameworks. Angular, React, and Vue all can work with Ruby as a backend. For a framework that was built along side Rails, checkout Stimulus.js
If you are going to use Ruby on Rails as back-end API, then I'd recommend EmberJS as front-end framework. It is relatively small compared to React or Vue, but has a very open community. It was built with the same MVC concepts and code conventions as Rails and does so much of the heavy lifting for you.
In our project we are thinking about doing a migration to AWS but we don't have experience as much as in Heroku. I was wondering, where does the pricing change that makes AWS a better choice in those terms compared to Heroku? &amp;#x200B; Right now we have an ecosystem of 20 applications on Heroku. Some on the enterprise space, and we find out that the logging and dyno usage are making our monthly bill a pain in the ass.
I've used ember with rails before. Worked great! Jsonapi-rb for all my serializers made communicating with ember super easy. 
Forgive me if I'm wrong, but is this scratch for graphql?
Incidentally, the example of the Stimulus site is this very feature. [https://stimulusjs.org/handbook/building-something-real](https://stimulusjs.org/handbook/building-something-real)
Yea Prometheus is a monitoring/trend-analysis solution written in Go.
I'm not sure if you're asking for integration or just something that fits the design patterns. You've got recommendations for the latter already but I feel obliged to mention that you should probably consider splitting the responsibilities (managing data/rendering information) completely, such as through a GraphQL API and separate repos/servers. At that point, any framework is the same, and I'd recommend the more popular ones if you're starting with JS frameworks now (but not Angular).
Avoid Ember.js at all cost, use React or Angular instead, Ember has terribly old code, that Ember.Object is years behind time. PS: I was a Ember dev
Tell me lies, tell me sweet little lies lol
Rails + UJS helpers. 
What do you mean?
You can use es classes with ember. And typescript... And async await, and concurrency tasks.... Ember had some rough edges 4-5 years ago.. but it's way better now
So I'm still working on formalizing the tutorial, but you've basically got it right in your edit. You need to have the .so files somewhere that the LD\_LIBRARY\_PATH recognizes, and build the 'pg' gem with the appropriate settings. &amp;#x200B; Layers are a great way to do this. You can put the necessary libs into the 'lib' directory of your layer, and build on top of those. I expect you'll also start to see layers being shared for common cases like this over time, in multiple languages.
It still suck to use .get everywhere.
agree, but you don't use get anymore. everything is native es5 getters. ``` @computed get myProperty() { return "something computed" } @computed get otherProperty() { return this.myProperty; } ```
I actually try to not use JS frameworks unless I need to. It make sense for a lot of applications but there is an added level of complexity, and first render size. I generally use something akin to [EvilMartians Modern Frontend in Rails](https://evilmartians.com/chronicles/evil-front-part-1) and just use server side rendering, and webpack for my frontend. That being said, when I do need to use a framework I will usually reach for Vue for a small to mid sized project and react for a larger one.
Uhu this is a improvement lol, but I still thinks is way more simplier and a lot time I only use React with Mobx, in my opinion Ember follows convention over configuration in a point which is toxic, Rails managed to do it better, what about testing with Ember it still suck like old times?
Hey, Newb here, so please be gentle with my feedback! Haha. Could you possibly use the .replace method on the word string to replace the unguessed letters with _’s. Then call a new variable to store the players progress? 
Make has many relations with pagination and you will see, Ember-data really is a piece of garbage.
I could definitely try that, thank you for your suggestion! 
&gt; but I still thinks is way more simplier to use React and a lot time I only use React with Mobx That is a very small sliver of the functionality you need to build web apps. I've been using React at work for over 2 and a half years, and any react projects results in building your own framework -- which can result in mixed expectations when bringing on new people to a project. :-\ &gt; Ember follows convention over configuration in a point which is toxic, how so? &gt; what about testing with Ember it still suck like old times? Testing ember is a dream. Until BigTest.JS, no other frontend testing suite came close to what ember offers. For example, here are some tests from my app, https://emberclear.io See this file if you want colors: https://github.com/NullVoxPopuli/emberclear/blob/master/packages/frontend/src/ui/routes/login/acceptance-test.ts#L49 ``` module('Acceptance | Login', function(hooks) { setupApplicationTest(hooks); clearLocalStorage(hooks); setupRelayConnectionMocks(hooks); trackAsyncDataRequests(hooks); module('is logged in', function(hooks) { setupCurrentUser(hooks); module('visits /login', function(hooks) { hooks.beforeEach(async function() { await visit('/login'); }); test('redirects', function(assert) { assert.equal(currentURL(), '/'); }); }); }); module('is not logged in and visits /login', function(hooks) { hooks.beforeEach(async function() { await visit('/login'); }); test('is not redirected', function(assert) { assert.equal(currentURL(), '/login'); }); module('both name and mnemonic are filled in', function(hooks) { module('with valid values', function(hooks) { hooks.beforeEach(async function() { const mnemonic = await mnemonicFromNaClBoxPrivateKey(samplePrivateKey); await loginForm.typeName('NullVoxPopuli'); await loginForm.typeMnemonic(mnemonic); await loginForm.submit(); }); test('redirects to chat', function(assert) { assert.equal(currentURL(), '/chat'); }); test('sets the "me" identity', function(assert) { const store = getService&lt;DS.Store&gt;('store'); const known = store.peekAll('identity'); assert.equal(known.length, 1); assert.equal(known.firstObject.id, 'me'); }); }); }); }); }); ```
ember data is not ember. while it's the default data management library, it's not required. And it is *really* hard to make a data library as flexible as ember-data -- and even with it's shortcomings, they are known, and being worked on. You can use fetch in your routes, like here: https://github.com/NullVoxPopuli/react-vs-ember/blob/master/IndyTechTalks/presentation/src/ui/routes/starwars/route.ts or GraphQL with https://github.com/bgentry/ember-apollo-client With the number of react and angular apps I've written the adapter/serializer pattern that ember-data provides is MUCH underappreciated. Normalizing API data is so valuable for having any sense of sanity -- especially when you don't control the API, and can't achieve consistency as a result of that lack of control. 
as a consequence of not using js frameworks, page load times will be super fast! (&lt; 0.5s even!)
Kind of. You can visualize your own schema or connect blocks and export code. 
 [~] irb irb(main):001:0&gt; @rand_arr = %w(G O O D N E I G H B O R S) =&gt; ["G", "O", "O", "D", "N", "E", "I", "G", "H", "B", "O", "R", "S"] irb(main):002:0&gt; @guess = %w(N O E) =&gt; ["N", "O", "E"] irb(main):003:0&gt; @rand_arr.map { |letter| @guess.include?(letter) ? letter : "_" }.join(' ') =&gt; "_ O O _ N E _ _ _ _ O _ _"
You can for any of them, since it doesn’t matter in any way to the front end app how the backend is implemented.
wow, this helped a bunch. Thank you so much! 
more people need to understand this. Tribalism is so obnoxious to deal with. You _can_ solve all the same problems regardless of tech choice.
I’ve lost track of the number of times I’ve thought, “wow, this gem does exactly what I need and behaves exactly the way I wanted it to” and then realized it was an ankane gem. Dude’s work is excellent.
Slides for the talk: https://speakerdeck.com/shioyama/building-generic-software Code presented in the talk: https://github.com/shioyama/translates Mobility: https://github.com/shioyama/mobility
Thanks for sharing those guides. They look very interesting!!!
That is true, but library and tooling support is going to vary in quality depending on the combination you choose. For example, you can basically plug-and-play Ember with the Rails JSONAPI gem. Configuring Ember to use GraphQL or developing both halves of MyCustomApiSpec is generally going to be a steeper hill to climb which may hinder starting the project.
The first problem is you should be using @phrase_arr[@index] = ... instead of @phrase_arr[@index2] = ... on lines 30 &amp; 32 because `@index2` is the index for @guess which explains why the output would always have 3 (or the number of characters in `@guess`) underscores in the front. Fixing this only reveals a further problem – if we take your example of `@rand_arr = %W(G O O D N E I G H B O R)` and `@guess = %w(N O E)` then the first time through the `while @index2 &lt; @guess.size` loop, `@phrase_arr` will look like _ _ _ _ N _ _ _ _ _ _ _ _ because everything that isn't `N` gets replaced with `_` After the second loop, @phrase\_arr will look like _ _ _ _ _ _ _ _ _ _ _ _ _ because everything that isn't `O` gets replaced with `_` ... and I think you can guess what happens next. The solution is to do the replacement check once per letter, one way to do this is by using the [include?](http://ruby-doc.org/core-2.5.3/Array.html#method-i-include-3F) method on `Array` def display @phrase_arr = @rand_arr @index = 0 while @index &lt; @rand_arr.size @phrase_arr[@index] = '_' unless @guess.include?(@rand_arr[@index]) @index += 1 end puts @phrase_arr.join(' ') end &amp;#x200B; A further improvement would be to use `map` to replace the un-rubyish `while` loop def display @phrase_arr = @rand_arr.map do |letter| @guess.include?(letter) ? letter : '_' end puts @phrase_arr.join(' ') end &amp;#x200B; Ultimately, the best solution is probably to use [Regular Expressions](https://ruby-doc.org/core-2.5.3/Regexp.html) to do a replacement with `gsub` class Hangman def initialize(file_name, guess) @phrases = load_phrases(file_name) @guess = guess end def display puts @phrases.sample.gsub(unguessed_letters, '_').chars.join(' ') end private def unguessed_letters /[^ #{@guess.join}]/ end def load_phrases(file_name) File.readlines(file_name).map { |line| line.chomp.upcase } end end guess = ['A', 'B', 'C', 'D'] hangman = Hangman.new('Phrases for Final Fall.txt', guess) hangman.display &amp;#x200B;
Some pretty unstructured, taste-based suggestions: * React * Redux * OpenAPI &gt;= 3.0 * TypeScript if you're into that. Not Flow.js. * Don't make JS asset compilation part of your Ruby build/test pipeline. (I would even keep them in separate repositories.) * Whichever ORM you use, don't let your Record/Model classes turn into giant "god objects". E.g. the "User" data you need for your "my widgets" page is going to be different from what you need for your "contact support" page. Don't try and force them into the same model. * User "delete" actions should almost never delete a record. A lot of features come naturally if you use a disabled/archived action instead. (But make sure there's GDPR-compatible "hard delete" option as well.) * Don't expose sequential database Ids in your API. Examples that do things like `get /users/2 =&gt; UserTable.where(id: raw_user_input)` should come with huge warning labels. 
Why not Angular? 
Just to add on to /u/eighdah14 's comment, there are other open chat programs commonly used in open source you can look at as well: gitter, telegram, to a lesser extent, discord, etc. As well the more old school IRC or mailing lists. There is likely also some analysis out there already you may be able to lean on, e.g. this is one analysis based on the linux kernel mailing list: http://www.opensym.org/os2016/proceedings-files/p101-schneider.pdf. I have no idea how rigorous it, just the first example I came across. 
good solution! just a little golf to make answer storage better: ans = "GOODNEIGHBOR" # thinking like Answer.find(rand(Answer.count)).first ans.split(//).map{...} Better to create plain strings and store those, I figure. :)
Just keep in mind that the people who discuss there are not necessarily 1:1 representative. For example, I am also a "hobby" programmer so naturally my area of expertise is completely different than say, nobu (though you can also study the use of english words by japanese developers, which is interesting too). I would pick different sites and then analyse the data you get from there. Direct communication via email is not always easy for everyone; for example, I can never handle any real traffic on my email accounts. It always becomes too much to work through it even when the emails would be important. (I am one of those who always preferred e. g. webforum such as phpbb; can't stand discourse though).
&gt; I understand that asking "can you give me some of your private communication" is quite a big ask, but all identifying or private information in the texts would be omitted Yeah, that's quite a big ask... I mean, I *could* theoretically give you a giant archive of several months (/years?) of discussions between developers in e.g. the #developer channel from my company's slack (~40 developers, plus many semi-technical staff). But there's bound to at least be a tonne load of company-confidential stuff in there, so I couldn't possibly do that unfortunately (unless you asked my manager, and signed an NDA, etc). As others have said though, there's plenty of *online* discussion you could use as a reference. For example, perhaps look at the *comments sections* in StackOverflow, or ServerFault, or SuperUser, or AskUbuntu. Perhaps look in software-related subreddits. Perhaps look in Github issues. Perhaps find some public Trello/Jira boards. Perhaps look in Discourse, or a *public* software-related Slack workspace. I suspect there's already vastly more data freely available on the internet than you'd know what to do with, without needing to additionally dig into potentially sensitive private communications (which adds an additional challenge around accessing and redacting the data).
Side note: It's been interesting to see this comment get both a large number of upvotes and downvotes yet no discussion. Personally I think there is a lot of group think around concepts like SOLID that are driving people to not approach them critically.
Yes. But it only does an input box and text area. I want to copy a whole chunk of html code.
Also look at comments on issues in popular github projects. Some of them will just be long lists of comments where people chip in random comments without much back-and-forth conversation, but look enough and you'll find good examples of in-depth, person-to-person technical discussion between developers.
Ah, thanks for the explanation. It made a whole lot more sense in my head haha. I don't have a lot of experience with Ruby, so this was really appreciated and I'll definitely learn from it :)
When I played with ember it uses Qunit aguess anyway it was a mess to make test, sum almost all my opnions in this article https://medium.com/@vlascik/honest-look-at-ember-in-the-middle-of-2018-a0dc2787e506
There are female Rubyists.
I'm still using erb + jQuery serving millions of users. I did React , but gave up upgrading it. Too much time wasted upgrading react and fixing bugs. Things changing so fast in JS. But i prefer stability.
Not a big fan of React, so I'd recommend Vue if you need something big and complicated. Otherwise, I'm really digging Stimulus and feel it's an excellent compliment to Rails.
&gt; Get your skills indorsed on blockchain by our various validation methods What does that even mean? The site explains nothing.
If your main language is ruby, you might try asking on the Ruby for Good Slack channel. They do a lot of volunteer open-source non-profit projects, so if you find a willing group you'd be able to follow both their Slack conversations and their Github repo's issues and discussions. I think you can just request to join their slack channel at [this webpage](https://rubyforgood.herokuapp.com/).
Well it's mostly personal opinion mixed with a bit of evidence that Angular is a) disk and memory heavy, b) does not compensate in speed and c) is hated by a lot more people than just me, which leads to d) stable user growth as opposed to the ever rising Vue and React growth. Lastly forcing us to use TS is kind of heavy on beginners too.
It still uses qunit. They just have better abstractions now :) I've read that article, and while I agree with some of it, I disagree with a lot. I'm a single developer and love ember. Also, I'm personally working on helping improve ember, because, I want the default to be the things I love about ember.
Ruby framework: If you are an experienced developer, then I highly recommend \[dry-web-roda\]([https://github.com/dry-rb/dry-web-roda](https://github.com/dry-rb/dry-web-roda)) which comes with awesome \[dry-rb\]([https://dry-rb.org/](https://dry-rb.org/)) + \[rom-rb\]([https://rom-rb.org/](https://rom-rb.org/)) + \[roda\]([http://roda.jeremyevans.net/](http://roda.jeremyevans.net/)) stack. For newcomers I would recommend using Rails API. JS framework: I recommend Ember. Several reasons: 1. Ember has a data library called \`ember-data\` which makes API calls super easy and it's quite powerful. I don't think any other JS frontend ecosystem has such a library. 2. Ember has a huge \[catalogue\]([https://www.emberobserver.com/](https://www.emberobserver.com/)) of addons developed by the community. 3. Ember's Glimmer is the fastest and the most advanced rendering library among JS framework. 4. Ember follows convention of configuration which makes development super fast so that you can focus on developing features.
Your `return` statement is returning from the entire method call on the first iteration, breaking out of your `while` loop.
It’s because ‘return’ causes it to exit the method, breaking the loop at the first letter of the word. 
This ^, change the return statement to puts instead if i just wanna print each letter for now
If you want it to print one letter per line, try changing ‘return word[i]’ to ‘puts word[i]’, but also do some reading about return statements in Ruby. 
“return &lt;VAR&gt;” doesnt mean “give this one back and carry on”, you’re telling ruby “this functions job is done completely, give this &lt;VAR&gt; back and run other functions”. Try making an array in function, push each vowel to the array, and then return the array. Basically, tally everything up, then return the one result.
- add a new action X, which returns only the changed rows, serialiazed as a json. - add 'render :js' to your index action. - add a new file 'index.js.erb' - in index.js.erb file, add in ajax, a function that asynchronous calls action X and rewrites(calls inputHtml js function) the corresponding rows in your index table. 
One word: AJAX
It's an acronym 
Search for either AJAX or ActionCable. AJAX will use the polling strategy, it will fire a request every X seconds even if the DB has not been changed. ActionCable is more complex to set up, but it mantains an active websocket between client and server, and you can update your table only when the DB is changed. To be honest, by your question you look like a beginner, so I would definitely go with AJAX which is much simpler to set up and use.
All the other responses are correct, but what you are looking for is specifically this: https://signalvnoise.com/posts/3697-server-generated-javascript-responses
But that's point you know I would love to use jest or other tool, but it seems locked by the ember cli, on Rails you have more freedom, that what I like, but you know its my opinion in the end. About folder structural which is a great thing for ember cli but I just think my own is simplier even when I got other structures, React is so simple that you understand quite easily. PS: I was a single dev using Ember too
No. It is exactly the point. In the secon use case, the client is forced to use interface it does not need - pass a parameter that is not needed. ISP guides us that it's better to create dedicated interface (method) in this case. I found this article helpful in understanding it: http://rubyblog.pro/2017/07/solid-interface-segregation-principle
Six words 
I am hoping we see some major rework on Action Cable in Rails 6, I really wish we could use WebSocket for almost everything. 
The goal was to reduce coupling but now the controller is trying to rescue a CannotEditError error it does not know of. It is perfectly fine to have multiple methods rather than raising error to crash an application, then rescue it elsewhere. A form object could execute save method, return true false, then have a attribute readers for the object and error messages.
ActionCable will allow your server to push messages out to your views on demand. It’s quite easy to use. If you have any questions feel free to reach out, I have implemented it on a production live project so know a bit about it.. 
I consider it to be a colloquial word. 
Two different questions, with two different approaches. &gt; I would like one of the columns to be updated dynamically every few seconds, This can be achieved pretty easily with some JS, an AJAX call, and some helper code to place content from the AJAX call in the table. &gt; whenever the value is changed in the database (by another user). This is a bit tougher as it requires websockets. Basically, every time a relevant change is made in the database, attached clients can react and update accordingly.
Oh I see. Thank you guys very, very, very much for the explanation!! I know that's some hideous unformatted code, appreciate your time putting up with me :) &amp;#x200B; This is a huge help.
Thank you!!!
This is kind of a nitpick/technicality but they can use long-polling with Ajax to get something close to push behaviour. However Ruby is typically not strong on this front (unless you seek out a non-blocking async server framework, which is not the norm). If anyone wants to know more about this sort of server read up on the c10k problem.
really good talk, thanks for posting
Also exceptions as control flow is an antipattern
Who does permission check like this? If your model relations are simple then instead of `Task.find(params[:id])` I'd do `current_user.tasks.find(params[:id])` (assuming user has many tasks). If user is trying to access task that does not belong to him/her then RecordNotFound exception will take care of the rest. If model relations are a little more complex, involving some form of access control lists then it's probably time to find a library which does that for you outside of the action code.
It's fine for me
I highly recommend moving to Linux for Ruby development. I ran into a lot of little issues when doing it on Windows. It’s just a lot more tedious and it’s meant for Unix.
If you're going to stay on Windows install WSL and use ruby through that. 
WSL baby
What in particular can you not do with Action Cable? Just curious
Everything on Windows is hell. Use Ubuntu.
Its quite easy to use Ruby on windows these days. I'd take Linux or macOS over it anytime but setting up a ruby dev environment with the Ubuntu on windows crap was a breeze last time I tried it. 
I last used Windows environment with Ruby around a year ago and still faced little tedious issues. It’s a lot better than it once was, you’re right.
Because Windows is hell
I can totally imagine situations where this is useful. However I can also imagine some major "WTF" moments for a new developer trying to figure out what my test suite is doing. Any advice for using this cleanly?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [A Ruby on Lambda example using the Serverless framework](https://www.reddit.com/r/RubyLang/comments/a4pzqd/a_ruby_on_lambda_example_using_the_serverless/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Thank you! I decided to learn AC as it seems more efficient use of resources. 
Thank you everyone for all the comments. I really appreciate. Will report back when success. 
Thanks, glad you enjoyed it!
WSL all the way, that or a VM. But yes, Ruby on Windows is hell.
It sounds like time for you to shine by creating a lot of tutorials based on opal and ruby-gtk. People like me would really appreciate it :D
I got to ask Matz about this at RubyConf, in one of the Birds of a Feather tables! His answer basically boils down to the fact that Windows does things excessively different from *nix-based systems. Permissions, system calls, etc are all different and so while they do try to accommodate Windows, it’s not perfect and I got the impression it wasn’t a pressing issue. He went into more detail but it’s been a month now and most of the convo was about mruby, so I can’t remember much of the specifics. I do think there is an opportunity for devs to help make Ruby on Windows better but it would be a constant battle with each release. To be honest, with how Windows 10 has been treating me I might just switch to Linux full-time myself. 
I'd stick with the original controller... 
Try jruby.
I have heard that ruby on Windows isn't _that_ bad, or as bad as it used to be. But I don't use Windows myself, so can't say. I'm not sure if anyone else in this thread actually uses Windows? So that is one thing that will make it harder, that most tutorials and explanations you find are probably not going to be for Windows. Are you actually having trouble, or you're asking if you should stop before you even start? Give it a try, see if it gives you trouble?
Hi! From reliable and cheap proxies I can advise this site [https://buy.fineproxy.org/eng](https://buy.fineproxy.org/eng). There are private and shared proxies available. Proxies are pretty fast and give maximum anonymity.
Have not tried it yet; am also not sure if I actually need it (I write ruby code way too "oldschool" so really just case/when having regex options, which become the commandline options) - but the idea behind executable mocks is nice.
That sounds more like a problem of complexity if the test suite hinders a new developer from writing ruby code that works.
Ruby works perfectly fine on windows, either the one-click installer or WSL. You should provide more context if you are genuinely looking for help. Windows isn't lending itself to a hacker-generation as much as Linux is; even MacOS is better in this context since it is mostly based on *BSD.
&gt; I got the impression it wasn’t a pressing issue. This is only partially true. Most ruby dev hackers use Linux or MacOS*, but if you look at the ruby issue tracker then you can see changes rejected if they work on only one system e. g. linux bu not on other systems. Nobody likes windows really but lots of people use it, so ruby has to work on windows too. And ruby actually DOES work on windows. It's not great if you compare it to linux but you can use ruby on windows very well, even without WSL. I know that because I test my ruby scripts on windows every once in a while too and they work - even ruby-gtk (!).
Why is it "hell"? It works.
No, you are perfectly correct - ruby on windows works fine. Note that the one who started this thread has not given ANYTHING specific.
Great remark indeed choonggg. I'm planning on writing a second part to this blog post where the service object will be refactored using dry-transactions therefore addressing the issue you are pointing out (https://dry-rb.org/gems/dry-transaction/).
Thank you!
Thank you! I actually extracted ExecutableMock from this project [https://github.com/christophemaximin/performa](https://github.com/christophemaximin/performa) You can see it used here: [https://github.com/christophemaximin/performa/blob/master/spec/exe/performa\_spec.rb](https://github.com/christophemaximin/performa/blob/master/spec/exe/performa_spec.rb) Whether it is used cleanly or not is up to you :)
&gt; But that's point you know I would love to use jest or other too Mocha is another popular option. QUnit is just the default. FWIW, I find it annoying that Jest mocks everything by default. Makes doing any high level testing a big pain. &gt; About folder structural which is a great thing for ember cli but I just think my own is simplier even when I got other structures, Have you seen: https://dev.to/nullvoxpopuli/a-general-and-flexible-file-structure-that-works-for-all-projects-in-any-ecosystem-1lp9 ? Implemented here: https://github.com/NullVoxPopuli/emberclear/tree/master/packages/frontend/src &gt; React is so simple that you understand quite easily. right, but it also doesn't do as much. For the things that react has done *really* well, Ember has stolen. Like, DDAU, for example, and `&lt;AngleBracketComponents /&gt;`, etc
Ruby great work on Windows only if you have W10 and use WSL mode. Without WSL many gems doesn’t work correctly 
 Model.image.attach(io: File.open("/path/to/file.jpg"), filename: "pic.jpg", content_type: "image/jpg") Is this your typical use-case, attaching images from the local filesystem? 
No :). My own use case is the first example of attach.
 Model.image.attach(io: File.open("/path/to/file.jpg"), filename: ...) This is missing a `File#close` (or does `attach` close the file automatically?).
You know this from experience?
Haha, I know this. Unless you use the Rails installer, which kind of magically works, you won't be able to install C-extension gems. And if you need a non-Rails C-extension gem, it will suck. Ruby on Windows works for small scripts, but it's brittle for big applications. I mean, you can make it work if you REALLY want to use Windows, or you can just use UNIX and it "just works". Most gem developers don't use Windows so you actually have very little support for tested Windows gems. Although you could argue the most common gems are tested, still, it feels out of place, like taking a fish from the ocean and dropping it in a river. You have to adjust everything to make it work. It's not like it can't be done, but why? Do you use Ruby on Windows? Have you used it to build applications in a work/team environment? 
It does. It's not about how to program with files, only Active Storage API.
many years worth of IRC log of #ruby https://freenode.irclog.whitequark.org/ruby
🤦🏼‍♂️
FYI when asking for code help in the future Reddit has formatting for code. &gt; Lines starting with four spaces are treated like code puts "Hello World!"
Take a look at Opal for a true isomorphic option - specifically look at the Frameworks section here: http://opalrb.com/libraries/ There's been some chatter about this by Rails core members and it [can be used with Rails](https://github.com/opal/opal-rails). The Opal core devs are open to suggestions to make it easier to use with Rails as well if anyone wants to chat with them and find that the entry bar is too high. I also think https://www.pakyow.org/ is interesting.
A bunch of my builds failed. I was wondering why this wasn't a larger issue -- I realized it is only an issue if you had a gemspec/gemfile explicit dependency (including indirectly) on the `logger` gem. Since logger is a part of stdlib, you don't really need this. I'm not sure why you would have it. I think it was confusing, and maybe shouldn't have even been a separate gem ever, which is maybe what nahi was trying to deal with by yanking it? But my project dependend on a gem which itself has `logger` listed in it's gemspec for whatever reason. Which triggered all my builds and deploys failing after nahi yanked logger 1.2.8, which had been the most recent logger released to rubygems for 7 years. :shrug:
If you look at the code in the controller especially the line you already highlighted you'll notice it tries to look up the product with product\_id. However it has no way of knowing what that product\_id is since you don't sent it with the request. The post in stack overflow is trying to explain how to go at it including it in the request. 
That makes sense, thanks for sharing!
I wonder if there's a popular tutorial or SO answer or blogpost code listing out there that recommends putting it in the Gemfile.
&lt;3
If it had never been released as a seperate gem, that would simply have failed. My interpretation of what happened is that nahi realized it never _should_ have been released as a separate gem. Since it was, some indirect dependency (dependency of a dependency of a gem you actually listed in your gemfile, maybe) could result in your project using the rubygems-released version of `logger`, which had minor differences from the stdlib one (which was also probably not intentional), which _probably_ wouldn't matter to your code, but if they did, I can only imagine the confusing debugging nightmare, when you probably didn't even realize there _were_ alternate versions of `logger` you could have been using. My _guess_ is that nahi was trying to correct this by yanking `logger`. Although he only yanked a particular version, 1.2.7 was still there (which maybe matched what was in stdlib already anyway). But after 7 years, it's _too late_, yanking a 7-year-old version that many software in production may be depending on does not actually help make anything less confusing or disruptive. 
Hey, jrochkind, just a quick heads-up: **seperate** is actually spelled **separate**. You can remember it by **-par- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
Yeah, if it's in a `.gemspec` people can be somewhat forgiven for not checking, but it's still kind of kooky. In over 10 years of ruby and rails I've never seen anything like this portrayed as standard.
I think it was probably just a mistake that logger was released as a gem to rubygems at all?
Check out this proof of concept - the syntax feels pretty concise like Elixir's: https://github.com/LendingHome/pipe_operator
How do you feel about this alternative syntax? https://github.com/LendingHome/pipe_operator
What "hell" exactly are you experiencing? With such a vague question, we can't really give good answers...
Have they fixed file sharing yet or is it still a PITA?
as far as that goes, yeah, bad name collision. could be a blog post on that about best practices :)
At first blush, I don't like it. Seems too concice... but thinking about it... I want to try it on something non-trivial, I could see how this could cleanup a few projects. It's actually really cool what you're doing. I liked the "Why?" Section because I was getting ready to post literally that as I was reading through the README:) Also, just an FYI (and I hope you don't take this as a nitpick) &gt; To be inversed The past participle of "invert" is inverted. "inverse" is an adjective which is a different part of speech.
I’ve been wishing ruby had elixir-style pipes for a while now and this looks pretty neat. Has it been used in a production environment yet, or is this purely a proof-of-concept?
Thanks for the feedback! Agreed it's pretty concise but the syntax definitely grew on me. Just a heads up that this proof of concept has only been tested in isolation with RSpec and Ruby 2.5.3. In theory it only requires "prepend" (so ruby 2+) but I haven't actually tried using older versions of Ruby. Fixed the [inverted](https://github.com/LendingHome/pipe_operator/commit/a2566b9f162b9efdb3365aff9189ef01f19388d3) issue as well, thanks again!
Purely proof-of-concept - only tested in isolation with RSpec and Ruby 2.5.3. Discussing it in https://bugs.ruby-lang.org/issues/13581#note-58 to see if they're open to further exploring this type of syntax though!
2 years of on-and-off study and tinkering. &amp;#x200B; Best advice I can give is read the Rails Guides, they have a ton of information there that will help explain the entire framework. After you feel like you understand your newly found powers. Try to build something, don't do it before.
Agreed. Ruby is a breeze. Rails takes more time to wrap your head around. Took me months. The best way to learn rails is to watch multiple training videos. Eventually the basic MBC will click and all will make sense. Then you can dig deeper and start learning about the additional features rails has represented by folders and files in your project, such as tests, background jobs, etc. Don’t give up. 
It's a ton to wrap your head around if you're not already familiar with the concept of MVC web apps. I initially tried it out, hit a wall, then "downgraded" to Sinatra which was much simpler and more straightforward. After I got more comfortable about what models, controllers and views were for and how they interact, going back to Rails was much more manageable.
Totally understand it's PoC. :)
I couldn’t figure it out on my own. Once I got a rails job and had an existing code base full of examples it got pretty easy. It does a lot for you under the hood which can be hard to reason about. 
Cool project, but this seems very close to [Object#yield\_self](https://ruby-doc.org/core-2.5.3/Object.html#method-i-yield_self). Not exactly, but pretty darn close. Part of what makes Ruby great is the simplicity. I think adding more complex syntax is the wrong way to go. This syntax seems a little too tricky and opaque for new Rubyists to get a handle on quickly. Since it's a method, but looks like an operator, it could be very confusing to newcomers to the language, especially since pipes are already use in the syntax for blocks. Your example of: "https://api.github.com/repos/ruby/ruby".| do URI.parse Net::HTTP.get JSON.parse.fetch("stargazers_count") yield_self { |n| "Ruby has #{n} stars" } Kernel.puts end makes this clear. The `".|` would look really confusing if the block took a param, like `"foo".| do |e|` for example.
I like `pipe` a lot. IMO it's short and descriptive enough for newcomers: "https://api.github.com/repos/ruby/ruby".pipe do URI.parse Net::HTTP.get JSON.parse.fetch("stargazers_count") yield_self { |n| "Ruby has #{n} stars" } Kernel.puts end I don't like `.|`. It's a bit too awkward for me. But I think in this case the author is just using `|` as a placeholder for potential syntactic sugar.
&gt; Part of what makes Ruby great is the simplicity. Ruby is expressive, not simple. From https://www.ruby-lang.org/en/about/: &gt; He [matz] has often said that he is “trying to make Ruby natural, not simple,” in a way that mirrors life. &gt; Building on this, he adds: &gt; Ruby is simple in appearance, but is very complex inside, just like our human body1.
Rails is at least 100x bigger than Ruby, it takes a long time. I used it part-time for 2 years, but didn't feel like I was confident until I'd been using it a year or two full-time, 40hrs a week. 
I know it sucks!! :/
I think that quote is referring to the complexity you can express simply with straightforward syntax. The "simple in appearance" would seem to refer to syntax. Anyway, we could argue semantics on this for a while :) I think that `.|` isn't very expressive. 
I'm trying to get it resurrected but not having much luck so far ☹️
I think this is a cool concept. I like `pipe`, but `|` concerns me because it changes behavior already present in the standard library: [Set Union](https://ruby-doc.org/core-2.2.3/Array.html#method-i-7C). I understand that this is a proof of concept, but it seems to be a slightly dangerous one. I'm interested in seeing how this evolves! (Side note, I love your [zero_downtime_migrations](https://github.com/LendingHome/zero_downtime_migrations) gem!)
Anyone using this in production/work? I'd love to hear some use cases.
I dunno cause it works for me, but are you sure the output is from the code you are showing? Theres a typo of "anotehr" in the output and not in the code shown.
&gt; Since it's a method, but looks like an operator Doesn't that describe every operator in Ruby? 
I don’t know what was wrong with Atom I restarted the application and now it works. Thank you!
Your problem isn't stimulus specific, it's just javascript. `select` only exists on input elements, you're trying to select a div (unclear what that even means). If you are trying to get the html inside that div, then you'll need to pull it out with `innerText`, create a hidden input element, set it's connect to the innerText of the div then select that. A basic helper to copy any string to the clipboard would look like this: function copyToClipboard (str) { const el = document.createElement('textarea'); el.value = str; el.setAttribute('readonly', ''); el.style.position = 'absolute'; el.style.left = '-9999px'; document.body.appendChild(el); el.select(); document.execCommand('copy'); document.body.removeChild(el); };
Exactly right! The actual method is `__pipe__` which is aliased as `pipe` for convenience (like `send` for `__send__`) and `|` for syntactic sugar! The `.` in `.|` is required because this does not compile unfortunately: url | do URI.parse Net::HTTP.get JSON.parse end Agreed that `pipe` is definitely clearer - but for those cases when we want to express the same concept more concisely - we have `|` available as well (which has been known as a "pipe" for [decades](https://en.wikipedia.org/wiki/Pipeline_%28Unix%29))! It feels similar to the other shorthands we've added over the years e.g. map(&amp;:something) # vs map { |o| o.something } object&amp;.something # vs object &amp;&amp; object.something -&gt; { example } # vs lambda { example } object.(example) # vs object.call(example) Personally I don't think I'd ever use `|` in block form like the example you posted - I'd really only be using it for inlining things for conciseness e.g. `map(&amp;Math.|.sqrt.to_i.to_s)`. For all other cases I prefer the more explicit `pipe do ... end` form for clarity. Thanks for your feedback!
**Pipeline (Unix)** In Unix-like computer operating systems, a pipeline is a sequence of processes chained together by their standard streams, so that the output of each process (stdout) feeds directly as input (stdin) to the next one. The concept of pipelines was championed by Douglas McIlroy at Unix's ancestral home of Bell Labs, during the development of Unix, shaping its toolbox philosophy. It is named by analogy to a physical pipeline. A key feature of these pipelines is their "hiding of internals" (Ritchie &amp; Thompson, 1974). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I'm a fan of porting idioms from other languages into ruby, and this looks really quite well done. Nice to see folks are still pushing the boundaries of ruby here and there.
Websockets can get pretty confusing to debug when things don't go as planned. Definitely consider taking up u/3vol's offer if needed. &amp;#x200B; \-- &amp;#x200B; Thank you u/3vol for being a bro. 👍
Great point! One of the Ruby core developers brought that up as well in https://bugs.ruby-lang.org/issues/13581#note-60. My thinking was that the `|` method only really needs to behave like a "pipe" for two cases: 1) the pipe | operator is called with NO arguments [9, 64].map(&amp;Math.|.sqrt) 2) the pipe | operator is called with ONLY a block url.| do URI.parse Net::HTTP.get JSON.parse end Searching through the Ruby source revealed [10 existing | method definitions](https://gist.github.com/shuber/b4d0a10c272d36f6b482ffd491e4cfba) - ALL OF THEM expecting an argument e.g. 123 | 4 #=&gt; 127 Checking for the presence of that argument seems like something we could build logic around and there's really not that many existing `|` definitions! What do you think?
Updated README to use `pipe` instead of `|` when `do ... end` blocks are used. I think the `|` shorthand should only be used when inlining things for conciseness. Thanks again!
Somewhat related - this is another proof of concept demonstrating [ES6 style object destructuring](https://github.com/lendinghome/destruct) in Ruby. This same type of concept could be used to port Elixir style pattern matching as well e.g. data = { name: "John Smith", age: 35, prefs: { lang: "en", tz: "UTC", } } User = Pattern { name age prefs[lang] } user = User =~ data user.name user.age user.lang [data].map(&amp;User) case object when Pattern { some attrs[:nested][real][deep, fields] } Pattern!.some Pattern!.real Pattern!.deep Pattern!.fields Pattern!.nested #=&gt; NoMethodError end
Thank you! I've experimented with porting other things in/out of Ruby over the years if you're interested in more of that kind of stuff! * [ES6 style object destructuring in Ruby](https://github.com/lendinghome/destruct) * [Abstract classes in Ruby](https://github.com/shuber/abstract_class) * [Implementable interfaces in Ruby](https://github.com/shuber/interface) * [Variable objects for class and instance variables in Ruby](https://github.com/shuber/variables) * [A port of Ruby 2.0 to native PHP 5.4+](https://github.com/shuber/phuby) Note that I don't recommend using any of those for anything ever :P
Thanks for the feedback! Agreed I would not recommend using `.| do ... end` and would suggest using the more clear and explicit `.pipe do ... end` instead for those cases. I'd really only use the `|` form when inlining for conciseness e.g. [9, 64].map(&amp;Math.|.sqrt.to_i.to_s) I've updated the README to use `pipe` instead whenever `do ... end` is specified to make things clearer. Thanks again!
Yea it's kind of like a hybrid of `yield_self` and `instance_exec` with some shorthand for clarity and conciseness! Like I mentioned in your other comment I agree that `| do ... end` looks strange and would prefer using `pipe do ... end` instead for those cases. It's a pretty terse syntax but I like that it doesn't introduce new operators for this kind of stuff - the recent Ruby tickets introduce `&lt;&lt;`, `&gt;&gt;`, and `.:` but the pipe `|` operator has been around for decades!
Yea agreed it's just another method like everything else!
Just a couple: https://h2o.examp1e.net/configure/mruby_directives.html http://ngx.mruby.org/
shopify used it for their "shopify scripts", not sure if they still do https://github.com/Shopify/ess https://github.com/Shopify/mruby-engine
I find this example strange : ``` # left to right url.pipe { URI.parse | Net::HTTP.get | JSON.parse } # or top to bottom for clarity url.pipe do URI.parse Net::HTTP.get JSON.parse end ``` Why would the `|` disappear in the verbose version ? I'd rather see both version show a pipe symbol between what is piped : ``` # left to right url.pipe { | URI.parse | Net::HTTP.get | JSON.parse } # or top to bottom for clarity url.pipe do | URI.parse | Net::HTTP.get | JSON.parse end ``` 
AnyCable has added embedded mruby engine recently: https://docs.anycable.io/#/go_instrumentation?id=custom-loggers-with-mruby (it’s still experimental though has been used in production). More mruby-based features to come: https://github.com/anycable/anycable-go/pull/43 . We use ngx_mruby in some projects. And my personal everyday CLI tool https://github.com/palkan/acli )
Thanks.
Ofc you're welcome not to like it. I'm just saying it feels very much in line with the spirit of ruby. The idea of point free "pipelines" in general are pretty standard in other functional langs like haskell and elixir, and even the `|` character itself is familiar from unix and variants of it are common. I also think if by "expressive" you mean that the ability to express algorithms concisely the code in question is clearly more expressive than standard ruby. If you have experience with other functional languages, it will look quite familiar as well. You are free to argue that you don't want to make ruby more haskell-like (which is essentially what's happening here), I just don't think arguing that it's less simple or less expressive is a cogent way to do so.
Thank you so much.
I wonder if h20 will get ruby 2.0 for its 2.3 release.
It does, but from the perspective of someone learning Ruby, it's not always clear when you need a dot, when you need braces, or when you need brackets. So, someone coming from another language may assume it is an (non-method) operator that acts different in the language. I think this risks further complicated the learning process for new learners.
I do like .\`pipe do ... end\`, fwiw. 
?
They're actually *always* optional! These two statements are equivalent: url.pipe { URI.parse | Net::HTTP.get | JSON.parse } and url.pipe { URI.parse; Net::HTTP.get; JSON.parse } You could technically use `|` in between expressions in the multi-line block version as well but that feels kind of like using the `self.` prefix when you don't need to - just unnecessary visual noise. For the inline versions we use `|` instead of `;` to separate expressions in README examples since `|` is more common for this type of behavior. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [mruby 2.0.0 released (x-post \/r\/ruby)](https://www.reddit.com/r/RubyLang/comments/a57abs/mruby_200_released_xpost_rruby/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Good point! Ruby is a very flexible language and there are many ways to express the same idea e.g. dots vs no dots, braces vs no braces, method aliases, shorthand operations e.g. `map(&amp;:something)`, etc. While pipelining is certainly not a new concept I can agree that it feels like more of an advanced feature that could take extra time to cover when ramping up new Rubyists!
I'd just keep `;` then. Why add this synonym when `|` already means so many other things in ruby ? Comparable syntax to my shell scripts seems like a low benefit when I already see this character as `or` &amp; `|going to define some block arguments|`.
It's just for syntactic sugar! Within the context of `pipe` we own the definition of `|` (which has been known as a pipe for [decades](https://en.wikipedia.org/wiki/Pipeline_%28Unix%29)) so we don't really need to worry about conflicts. I definitely support your preference of `;` over `|` if that makes things clearer for you!
**Pipeline (Unix)** In Unix-like computer operating systems, a pipeline is a sequence of processes chained together by their standard streams, so that the output of each process (stdout) feeds directly as input (stdin) to the next one. The concept of pipelines was championed by Douglas McIlroy at Unix's ancestral home of Bell Labs, during the development of Unix, shaping its toolbox philosophy. It is named by analogy to a physical pipeline. A key feature of these pipelines is their "hiding of internals" (Ritchie &amp; Thompson, 1974). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Awesome. Looking forward to your tutorial.
What is the benefit of switching to this? Is there any downside?
Upside: Designed to be easy to embed. You can make it *really* small by excluding parts of the standard library you don't need. Downside: Lots of things are missing. I think threads would be the big one (there is a thread extension, but when I tested it, I ran into tons of problems) 
&gt; but I don't know what to do when I am on my own What are you working on when you're on your own? A particular project with particular goals, or just trying things out? I think a particular project with particular goals will give you focus, and provide a clearer answer for such things like "when to make a controller", because it'll be when you need to implement something that a controller is required for, which you can figure out when trying to figure out "how do I implement this thing?"
Learn by doing. Find a problem you want to solve, work on it, ask questions when you are stuck. Be sure to avoid [XY questions](http://xyproblem.info/). 
Codecademy's Ruby path, then Rails path
This is what I do. That's why I'm here and in other places asking questions :x
check out www.launchschool.com, if you can take that program, you can learn it very well - at the junior level, but very good. it starts in the backend too. it sounds especially good for you since you don't feel there is a strong foundation. in LS, you dont move forward in the curriculum _until_ you demonstrate the understanding and mastery. don't let that scare you though, if you put in the work, expect results. feel free to join their Slack community and ask questions. There is a free prep course. If you are not afraid to put in work and really want to learn, and its suitable for your schedule and stage and life, its excellent. 
Thanks, I'll check it out.
yup $200 a month, if you can do it full-time, its fantastic. 
I think codewars is a good place to start. You can work on solutions to easier problems to learn the basics of the syntax, data types, and the methods available to use. It’ll force you to practice googling questions and knowing what question to ask
I'll check it.
It didn’t click for me until I read POODR. 
Poodr, care to give me the full form?
Odin project is pretty good
Practical Object Oriented Design in Ruby written by Sandi Metz.
I agree. You learn a language by speaking, reading and writing. Same with programming. It’s learned through practice. 
Get involved in Open Source ( F/OSS ) projects on GitHub.com and contribute to projects there. Other coders will often mentor you, and you'd be solving real problems right away. 
If doesn’t get much more Googleable than POODR. Try it. 
Yes, this is a couple years ish old. I found it worth a review. :)
Maybe taking a couple or more Udemy Courses would help? Especially if they're all different teachers, bcz not everybody approaches students the same way.
I'll try.
Also of a better note is that sometime this very month of December, "Manning" the publisher of David A. Black's "The Well Grounded Rubyist" is putting out (or maybe already has) the 3rd Edition of his Book. I have the 2nd Ed. and its great, but is now outdated. But on Amazon, it got something like 4.5 Stars or better from tons of folks who left glowing reviews as "Verified Purchasers."
That 2nd Edition was only for Ruby 2.1 .
While it hasn't been updated to the new version yet, http://zynaddsubfx.sf.net uses mruby to have a scriptable &amp; embeddable UI.
There are uses cases where a chat bot is a perfect fit. For instance, at a client, I built a chat bot that allowed marketing people to pull updated locales and deploy them to production. They call the command when they're happy with the updated copy and can push updates without having access to Heroku, GitHub or anything else.
Hint: try entering "_" as your guess and see what happens :) Answer: &gt;!You're checking the guessed character against the masked "_ _ _ _" display value instead of the actual phrase!&lt;
`@pts + @phrase_arr.count(@guess[-1])` -- This does not reassign the variable. You need to use `+=` here, instead of `+`. `x += 1` is shorthand for: `x = x + 1`. By writing `x + 1`, this does not change the value of `x`.
Also, you could simplify that whole method to: `@pts += @phrase_arr.count(@guess[-1]) unless @guess[-1] == ' '` I haven't read through the rest of the code in detail by the way; so I'm only really commenting on that one method in isolation.
ahhh thank you thank you so much, I should have thought to do that before haha. 
Good catch, though that's not what happens - the current points are passed into the method on each iteration
No problem. Tom also makes a good point that you should probably be assigning the points to the `@pts`variable on each turn (you'd need a separate variable for each player)
Oh right, yeah. I just skim-read it as I said... Didn't realise that instance variables are being assigned all over the place, within each method, for no real reason :/
What rules are you talking about?
alright, gotcha. I'm pretty new to all of this so thanks for the insight :)
You mention you want to learn to code - is it safe to assume that Ruby is your first programming language? I absolutely love programming in Ruby, but I've come to understand that Ruby is not a great language to learn the fundamentals of programming. It's syntactic sugar, reflective nature, dynamic typing, and optional syntaxes are often what makes it appealing to programmers who want to write expressive code, but these are the same things that make it pretty hard for beginners to understand what's going on and increase their understanding of programming concepts. I think this is why you feel that the courses you took didn't teach you the rules and if those courses were teaching Rails along with Ruby which I've seen a lot of courses do, I can imagine the amount of frustration with trying to learn the programming concepts while balancing what parts are pure Ruby and what heavy lifting Rails is doing for you. I'm not saying you can't learn programming with Ruby first, but you're going to have a much better time learning programming first with something like Python where there's only 2 ways to do a loop and one way to do an if statement whereas the sky is the limit on how your want to write your Ruby prose. Plus, Python is quite popular so this side quest won't derail your career. Even a static-typed language like Java will help you much better learn the core concepts because it has stricter syntax (semicolons after each line, parenthesis for function arguments, data types, brackets). It's really hard to understand what's happening if everything is optional. The basics of programming are mostly the same in any language, but learning those in a more structured language will make your journey much easier. Plus, languages like Python and Java are used by academia and thus there are a lot of great resources out there that make learning them easier. Ruby isn't going anywhere anyways, so you can come back any time!
OP says he wants to learn to code... and you're recommending learning by contributing to Open Source projects? lol Sure, a great way to level up when you want to learn best practices from others and learn collaboration skills, but certainly not a task for someone learning "how to use the rules of coding".
https://www.codingame.com I like that in addition to codewars. You essentially automate "playing a game" (you'll have to check it out) and it takes you through the fundamentals gradually ramping up difficulty.
You'd be surprised. I've seen numerous people go through the F/OSS ranks starting with mostly just eagerness at the start, and now hold gainful employment or own businesses built on coding prowess. 
I had some background in programming before I started ruby, so take my recommendation with a grain of salt. I stand behind [Ruby Koans](http://rubykoans.com/). It was a good lesson on both fundamental ruby language and has been the most interactive way to learn ruby imo.
Thanks, I'll check it out.
I didn't mention it. But recently I came back to the idea I had earlier in life, namely to make a game. And I still have program which I've worked on. And engine in which I will work on is based on ruby(RGSS3). So that is the reason why I want to program in ruby. It can be helpful in writing scripts and making this game a better product. And I know learning python alongside with ruby would be a great thing to do because as I found out lately python have similar approach for programming. And I can then translate learned concepts along. But libraries can't be brought from one language to other I think. 
We used chat bots extensively at my last gig. Scaling, migrations, deploys, rollout flags, and just about every task you could imagine was possible via slack bots. Was kind of nice but also potentially overkill as each piece was something new to manage 
There's a lot of **suggestions** in this thread already, so instead, let me reframe the problem a bit. You say in your post, &gt; I want to learn to code. and then in a comment, &gt; But recently I came back to the idea I had earlier in life, namely to make a game. And I still have program which I've worked on. And engine in which I will work on is based on ruby(RGSS3). So that is the reason why I want to program in ruby. Note that /u/menge101 mentioned, "Be sure to avoid [XY questions](http://xyproblem.info/)." This is a perfect example of an XY question: it's common for beginners to confuse "coding" with general practice of software development, and it seems you're asking about one when you really need to know about the other. That is, knowing a programming language is only one part of the universe of competencies required to build software. Besides learning a language's syntax and mechanics, you'll have to learn how it interacts with the system you're running it on—dependency management, version management, and even just how to interact with the language in the console. You'll have to learn the paradigms that shaped its design (_e.g.,_ object-oriented programming). You'll have to learn a version control system, a testing framework, and all the language-independent concepts related to your problem domain. You'll also have to learn to un-stick yourself when you get stuck—not just asking questions or searching for previously asked questions on StackOverflow, but actually reading through documentation: You need to break a problem down and think "Okay, step 1 is I need to check if this array has any duplicate values in it... how do I do that?" and then you need to spend 15 minutes combing through the [official Array docs](https://ruby-doc.org/core-2.5.3/Array.html) to see if any of Ruby's built-in methods can help solve your problem, or if it needs to be broken down further. (Why is this better than searching for an answer on StackOverflow? Because you'll find out about a dozen new things along the way that you didn't know Ruby could do, and you'll have them in your back pocket for the next time you come across a problem totally unrelated to this one. It'll also get you accustomed to reading technical documentation, which is really critical—you need documentation to use _anything,_ and a lot of it is really badly written.) So my advice is that you'll have to readjust how long you think it's going to take to get this game built: * Stage 1: Learn the very basics of Ruby—loops, conditionals, methods, blocks, and basic data structures (arrays/hashes). It seems you're past this stage already. * Stage 2: Learn to work in the UNIX command line / `irb` enough that you can do programming exercises without the help of a browser. Start learning/using a real text editor if you don't have one already (SublimeText is the modern favorite because it can be very powerful, but doesn't require a lot of learning up-front. If you have a week or so to burn just getting competent at a text editor, emacs/vim are very rewarding IMO.) * Stage 3: Use what you've learned to solve various programming challenges online (like at hackerrank). When you get stuck, use a combination of Q/A and documentation. * Stage 4: Learn OOP. as /u/eRetArDeD suggests, _POODR_ is the Rubyist's OOP bible. * Stage 5: Pick a _small_ weekend project (not the RPG you've been dreaming of building since forever) and use the concepts you've learned so far to build it. (You will probably also learn a bit about [libraries](https://ryanlue.com/posts/2017-03-02-what-is-a-library) at this point.) For instance, I built a script that I use to import and rename photos from my digital camera to my hard drive. * Stage 6: Learn git. Try another weekend project (or, if you're feeling ambitious, writing your own library) to give yourself practice with it. For any single thing you learn at any stage of the process, you'll get the very basics in a week or so (full-time), but it will probably take a month of practice to feel like comfortable with it, and you'll need to continue picking up useful tidbits in the background for probably most of your career. Once you've got all these things down comfortably, then you'll probably be in good shape to start building your RPG.
One thing I somehow haven't seen mentioned yet is using a REPL to get a grasp on some of the things you're struggling with. Having an interactive window into the language that allows you to evaluate code, actually see real return data and get instant feedback is a really useful learning tool -- especially if you're a visual learner or learn through doing. Ruby ships with a great basic REPL called `irb`, but there's an even friendlier and more powerful one called [pry](https://pryrepl.org/) that you can install through rubygems. Even though the screencast on their website looks little dated at this point; it's all still valid today. So give that a watch and start playing around for yourself.
so i've done quite a bit of Ruby - junior level of course - in data structures and OOP and other areas, with a focus on programming concepts and problem solving. Do you mean to say Python is easier to learn than Ruby? I'm just asking, because if so, perhaps this is good news to me if I go on to learn that. I'm just trying to complete my programming curriculum that utilizes Ruby, but in a bit of a bump because of a pretty crazy schedule and life demands, but am hoping to clear that up. Perhaps I can move on to Python at some point which is good to know and of course can attract on the job side of things. Java, I haven't done
Didn't `Hashie::Mash` come out of Chef and isn't there some tangential relationship with `Hashie::Mash#deep_merge` or something...? We're talking almost a decade at this point, so some of the details are a bit fuzzy... Anyway, this was a really good review! I love and hate Hashie::Mash.
I've been using Python recently and I completely understand why it's now the language of choice of bootcamps and universities to teach people how to code. The limited amount of ways you can do things in Python makes writing and reading code much more straight forward. But while I wholeheartedly recommend Python for people learning programming, I think Ruby is great for junior-level developers because you can start learning different patterns and the more elegant, clever means of solving problems which Ruby is known for being really good at ("Programmer's Happiness"). I think when you are in the process of learning more basic concepts like variables, control statements, functions, classes, data structures, algorithms...etc, Python is better suited for that. But when you want a language where you want flexibility to design your solution in order to learn and solve more complex problems, Ruby is great for that next stage. In fact, learning and knowing how to balance writing readable Ruby and writing performant Ruby and learning the tradeoffs is one of the core things that separates junior Ruby developers from senior Ruby developers because it's very easy to write what seems like clean code that is very inefficient.
cool, thanks, so having done almost a year in ruby - not all of it full-time - perhaps i'd find picking up python easier if I try later on. I don't want to focus my time resources on that right now but it's good to know, if that is the case.
That's great that you have project that'll motivate to you to keep learning! Working on various side projects in my own past definitely motivated me to keep building and improving and learning and I wouldn't be where I am today without those. The only thing I'll say is to step back once in a while and re-evaluate your goals. I think there was a point long time back where I believed myself to be proficient at programming because I was able to implement various features in Rails apps, but in reality, I had just gotten familiar with searching for gems, following online tutorials, and knowing how to google errors. Stepping back, I realized that while I was making progress in building various side-projects, my main goal was to become a better programmer and that required more in-depth knowledge and experience with Ruby itself and better understanding what was going on under the hood at the operating system level and overall, that required a different strategy in how I was learning. Regardless, best of luck on your project!
A couple of years ago I was in the same situation. Around the time I was searching for a solution to a problem I was having at work that required coding, I lucked upon a free course that paved the way for me to build a full-fledged application to fix my record-keeping issues. [The Upskill course](https://upskillcourses.com/p/essential-web-developer-course) was very easy to follow and gave me exactly the skillset I needed.
&gt; irb eno Thanks for very extensive look on the matter. I just came back to learning programming. And I notice some things that knowledge of programming could make faster. Today I wasn't thinking about making this game, but after a response from /u/CogitoErgoCode I thought that it could be a better motivator for browsing through help provided by you and many others. That's why I will try to make use of every advice I got here.
&gt;Open Source ( F/OSS ) projects on GitHub.com Where I can find them?
&gt;Step back once in a while and re-evaluate your goals. This is good advice. I fell often on this. When you do one thing that leads to another you forget the reason that led you here. &amp;#x200B;
&gt; Didn't Hashie::Mash come out of Chef Not that I'm aware of. There is `Chef::Mash` within Chef but that is actually a copy of the `HashWithIndifferentAccess` code from Rails, no idea why they called it a Mash. AFAIK deep_merge is unrelated. 
Personally, I wouldn't touch hashie with a 10 foot pole. The most common use case is dot access, and nowadays `Hash#dig` solves that issue better than hashie ever did. When I want to actually use object, use something like dry-initializer to quickly define an object and evolve it from there.
A lot of the times I've found uses of `Hashie::Mash` are in the form of ``` Hashie::Mash.new(JSON.parse('{"x": 2, "y": {"inner": 3}}')) ``` which can be easily replaced with: ``` JSON.parse('{"x": 2, "y": {"inner": 3}}', object_class: OpenStruct) ``` which IMO seems less dangerous since `OpenStruct` to my knowledge has less features than `Hashie::Mash`. But in the end, PORO seems safest. But I can also understand that wrapping JSON with POROs isn't always easy when the payload changes all the time and one has to anticipate extra fields etc. I remembered this article from a while back that talked about this stuff: https://www.schneems.com/2014/12/15/hashie-considered-harmful.html 
&gt; dry-initializer Thanks for the pointer to that, hadn't seen that gem before. Seems interesting.
I would personally recommend **rubymonk**([https://rubymonk.com/](https://rubymonk.com/)). It covers almost all the topics from basic to metaprogramming. 
Article basically says startup time is going to make running a standard Ruby app inside Lambda expensive--makes sense, startup is expensive because the assumption at development time is startup happens once and you're good. Under the hood it's a little more complicated than 1:1 startup:execution, but the point is still good: Don't try to port a service where startup is expensive to an environment where you don't have control over startup.
If you want ruby on lambda, check out the framework my friend launched: http://rubyonjets.com/
Interesting. I'll check it later.
This was very entertaining, thank you for sharing. It seems that Hashie::Mash tried to support too many things at once: * hash behaviour by subclassing Hash * hash with indifferent access * dynamic getters and setters for hash values * dynamic boolean methods for checking key presence * dynamic bang methods for initializing keys * deep merging It's no wonder these features were often clashing with each other. But if we put Hashie::Mash aside, it's nice that the Hashie project provides many useful mixins for Hash operations. Though I would prefer if they were also available as functions, as I don't like creating Hash subclasses.
Rip your bank acct
Check out [The Odin Project](https://www.theodinproject.com). Nice learn by doing curriculum that's free and opensource. You can actually help contribute the the courses. You do a ton of projects and push everything to Github and onto the actual live solution pages, so you get a lot of experience with no only Ruby but the related tech as well. There's a great community on Discord and Discourse as well. **Disclaimer: I'm a former student turned mod**
nice ! I'm adding it to [https://www.serverless-ruby.org/](https://www.serverless-ruby.org/) today
&lt;3 beautiful 
hmm why ? you can implement authentication / authorization many ways with this solution
Nice．I'll look there when I'll be free.
I mean running ruby in lambda lol
Oh that :) . &amp;#x200B; From the AWS Lambda now Supported languages (Ruby, Python, Go, Java Javascript ) the language that makes the most sense for the use case is Python. Second best is Ruby, and after that Go JS and Java. &amp;#x200B; Now why is that ? AWS Lambda (like I describe in the article) uses flow: 1 spin up lambda &amp; load code, 2 execute code, 3 die . You have problems with cold starts with languages like Java (, you cannot apply much of a use of the event advantages of JavaScript, Go is awesome but you cannot apply concurrency benefits of Go. &amp;#x200B; So in most scenarios the best choice for AWS Lambda is dynamic scripting language like Python or Ruby. Don't have much of a disadvantage of cold start, they are scripting lang = ideal for Lambda, execution don't need compile, and like I said concurrency is not needed as the AWS Lamda is concurrency of it's own right :) &amp;#x200B; Yes there are somecases where Java, Go, JS will kick ass on AWS Lambda over Python and Ruby but that's the point of AWS lambda (and microservices) =&gt; in those cases use whatever tool makes the more sense :) &amp;#x200B; But in 97% of the cases Python and Ruby are the best choice as you are not designing long running scripts where would other languages shine (in fact you are trying to split large Lambdas into smaller Lambda functions when this case happen ) &amp;#x200B; We had this discussion before in /r/ruby : [https://www.reddit.com/r/ruby/comments/835rjj/we\_demand\_faas\_providers\_to\_support\_ruby/](https://www.reddit.com/r/ruby/comments/835rjj/we_demand_faas_providers_to_support_ruby/) &amp;#x200B; &amp;#x200B; So in most cases your bank account is far better of with Ruby :) 
It's bonkers, but this is the kind of stuff I really enjoy Ruby for. 
TIL \^ 
Use byebug (or similar) to slow it down and see what's going on inside the process. It was helpful for me to understand when the page was routing and the controller was getting called, etc... &amp;#x200B; It's also helpful to see full rails example sites and understand where your code should live.
I would like to see a real world example of a ruby app using SOLID principles. Maybe if somebody from a SOLID camp is up to a challenge to implement 'realworld' Conduit (medium clone). 
Recap of the problems of running a Rack app on Lambda and adding a few of my own: 1) Startup time could be bad, generally Lambdas "sleep" and have a spin off time when you call them that you might not have control over. Obviously this could be terrible for a web app. 2) The way you write routes will completely change, you have to use AWS Gateway and not Rails routes. For me this alone is a deal breaker. 3) The whole version control and deployment thing is quite chaotic, does AWS have a mechanism to version control and deploy Lambdas that I am not aware of? Last time I used Lambda I just edited the code in the AWS interface, not version control and no nothing. 4)Your dev env will probably be very different from your production env! might lead to all kinds of messy bugs Am I missing something? To me it just doesn't sound that attractive. points (1) and (2) in my eyes are a deal breaker, point (3) can be solved, just not sure who and how much it will cost you. &amp;#x200B;
Thanks for this insightful response! I think that given the currently implementation of the standard lib, the | method would work for the two cases you present above. That being said, I’d be weary of standard lib changes, but that’s always a risk, yea? :) Please forgive this next question, as I’m fairly ignorant about the topic, but... what would it take to enable a different syntax altogether, such as “|&gt;”? Custom C code? I’d probably feel best about something without conflicts in standard lib if plausible!
My experience has led me to think when I find myself reaching for one of those mixins -- I should probably find another way instead. What seems simple ends up just not worth it. All of those mixins are basically conveniences to make operations on a Hash more like operations on a custom-fit object. The convenient syntactic sugar isn't worth the troubles they can cause, including from ambiguous semantics. If I really want an open-to-any-key thing with key-as-method access, there's OpenStruct. But really, I've come to prefer just doing the extra work to define and maintain ordinary ruby classes with actual method definitions whitelisted for what might be necessary, where possible. It's extra work up front, for more reliable and predictable code for lifetime of project. 
The value prop is "area under the curve". Serverless is about not paying for provisioned capacity that you don't need. If you can predict capacity, or require little enough that paying for excess isn't worth the overhead, you're probably better off with Fargate on ECS, though you will have scaling points that are less reactive than Lambda.
As for deployment, the serverless application model is a superset of CloudFormation, and the CI/CD pipeline can all be automated with CodeDeploy and associated services, or integrated with your own.
could you please share a screenshot of the output from Rspec?
points 1 and 2 - with all due respect but I have the feeling you didn't read the article as I'm pretty much answering this. Or if you feel I didn't answer this with enough detail pls let me know. &amp;#x200B; point 3 AWS has a custom product for managing infrastructure provisioning and deployments (Cloudformation) or new tool specialized on serverless management SAM [https://docs.aws.amazon.com/lambda/latest/dg/serverless\_app.html](https://docs.aws.amazon.com/lambda/latest/dg/serverless_app.html). All you need to do is define teplate like this [https://github.com/aws-samples/serverless-sinatra-sample/blob/master/template.yaml](https://github.com/aws-samples/serverless-sinatra-sample/blob/master/template.yaml) and lunch 2 commands for deployment . Or there are other ways (like Serverless framework ) to mange this problem. Point is this is different world than Rails. There is quite the need for understanding several AWS products and tools to be able to use this solution. &amp;#x200B; 4 Well not really. In this case you want to have your Development enviroment on AWS Lambda as well ... Maybe test enviroment can be on local computer but other enviroments should be as close to Prod as possible = &gt; i would create development enviroment using AWS API Gatway and Devel stage lamda functions &amp;#x200B; So I honestly think there is a level of misunderstanding of what this technology is designed for. May I recommend one of my talks [https://skillsmatter.com/skillscasts/11594-lrug-march](https://skillsmatter.com/skillscasts/11594-lrug-march) where I try to explain Serverles-microservices and monolith philosophies. My English is not that good but I feel this is the best resource out there to describe what I mean by the differences &amp;#x200B; &amp;#x200B;
you need to expect {your_code}.to raise_error SomeError
Vagrant? Is it 2014? Didn't HashieCorp kill it off a few years ago?
I would not recommend using Vagrant at this point in time - it’s extremely heavy and gets worse as time goes on. Additionally it tends to promote stuffing everything into the same VM - you can build it to do otherwise but in my experience I’ve only seen it abused, as this tends to be labor and resource intensive. I would strongly suggest using docker-compose. It’s fairly intuitive and can convert to more complex setups in the future (such as Kubernetes) and promotes the “one service per container” philosophy. It’s lighter and there’s a lot more support for it these days as well.
No they didn't. If anything they released new version. I am happy Vagrant user myself:).
I still recommend Vagrant, but I also recommend it with libvirt/KVM and NFS otherwise it can be too slow.
I'd say that vagrant is alright if you don't work on to many projects, but the size overhead of keeping full Linux distros really starts to bite after a while. I used it for a few years and it helped but I feel docker is lighter and solves the same problems for me.
It's not exactly a "collision"... the thing released to rubygems _is_ the same thing (if not exactly the same version) as the thing in stdlib. There are other cases where this is done intentionally, to let people use a version beyond what's currently in an MRI release, or a version different than what was in the MRI release. An example is `json`, in [stdlib](http://ruby-doc.org/stdlib-2.5.3/libdoc/json/rdoc/JSON.html) and [rubygems](https://rubygems.org/gems/json/). It's confusing, and causes problems for release management, even when done intentionally. But I don't know the alternative, the whole ruby dependency system just wasn't designed to account for this intention. But in this case, I _think_ it wasn't done intentionally, and seemed to add no value. 
Sure. I usually had only 2 concurrent Vagrant projects...so...:) The nice thing about Vagrant is that it's full VM. That's bad in a use-case where you can use a container however amazing when you need a full VM.
Deploying a Rails app on AWS Lambda is support by Jets Mega Mode. It's covered here: * [https://blog.boltops.com/2018/11/03/jets-mega-mode-run-rails-on-aws-lambda](https://blog.boltops.com/2018/11/03/jets-mega-mode-run-rails-on-aws-lambda) * [http://rubyonjets.com/docs/rails-support/](http://rubyonjets.com/docs/rails-support/)
Happy to say that Jets is now on the official AWS Ruby runtime. Article talks a little bit about AWS Lambda Custom Runtimes and Lambda Layers. Also covers a small bugfix to the official AWS Ruby runtime. 🎉
Sure, I actually fixed my initial issues, so I just threw in an uninitialized variable to cause an error. I'm not sure what you want to see this for, I'm not looking for help debugging my rspec, I was looking for a way to stop exception swallowing. Randomized with seed 63172 /Users/nate/.rvm/gems/ruby-2.5.1/gems/site_prism-3.0/lib/site_prism/page.rb:34: warning: instance variable @page not initialized RSpec::Core::MultipleExceptionError: undefined local variable or method `glom' for # &lt;Capabilities:0x00007f8ad798ba20&gt; undefined local variable or method `glom' for #&lt;Capabilities:0x00007f8ad68e3ba0&gt; undefined local variable or method `glom' for #&lt;Capabilities:0x00007f8ad692d868&gt; Thats the full text of what is printed to the screen, lacking a stack trace and a line number.
Yeah, i thought there ought to be, but i can't find documentation of it.
I've updated the article I hope it makes more sense now and cover it all 
I asked because my test show the full stacktrace, so wanted to compare and that I had it set, but didn't remember 😅 &amp;#x200B; you can pass `--backtrace` to the rspec command or you can set this in the spec\_helper.rb file `config.full_backtrace = true`
I'd like to see more evidence for his assertions, particularly that serializers are inflexible. Bypassing the controller and creating something model-like that isn't a model seems... odd. 
Via configuration: # spec/spec_helper.rb or similar config.full_backtrace = false # or true? Via command line: rspec spec/some/thing_spec.rb --backtrace 
hmmm... It's been so long I honestly don't remember now...
I suffer from the slow file mounts on OSX. Both docker and vagrant. I’ll have to look into this. I run Ubuntu desktop at home and it is amazingly faster than OSX when running mounted files in a vm/container 
@equivalent8 We added it to the site already :) [https://github.com/equivalent/we\_demand\_serverless\_ruby/pull/13](https://github.com/equivalent/we_demand_serverless_ruby/pull/13) 
FWIW, Jets also supports running Rack apps like Sinatra on AWS Lambda. It also supports running Rails apps. The command is: [http://rubyonjets.com/reference/jets-import-rails/](http://rubyonjets.com/reference/jets-import-rails/) The startup times is a consideration and one of the reasons Jets loads the rack app within the Lambda Execution context. So generally the app is already loaded in memory reused between requests. For cold starts, there's prewarming: [http://rubyonjets.com/docs/prewarming/](http://rubyonjets.com/docs/prewarming/)
On hey Tung!
Thanks buddy for mentioning Jets! We should catch up again when you have time! 🎉
oh right, sorry about that. I have too much work piled up didn't check that :) I'll be restructuring the website completely to be more a guide book to various approaches [https://github.com/equivalent/we\_demand\_serverless\_ruby/issues/17](https://github.com/equivalent/we_demand_serverless_ruby/issues/17) so if it's ok I'll contact you in the future just to hear your thoughts 
Yes of course. Anytime 👍
Yes. Of course. Anytime. 👍
Serious question, when do you need a full vm? I love docker compose because my dev environment reflects deployed envs (one service per container with some shared networking) and only really ever have issues when trying to run something like spark via docker compose (even then it works with a bit of tweaking)
Looks great!
Definitely a good point! There's been others that share those same concerns around `|` conflicts! Really the `|` is optional and can be disabled by default and enabled via `alias | __pipe__` if they're comfortable with the shorthand. I've updated the README examples to favor `pipe` over `|` for clarity. Yea unfortunately `def |&gt;` doesn't compile so it'd either need to be in core Ruby or _possibly_ in runtime Ruby via some concept like https://github.com/jicksta/superators. Or use some other "operator" that we can `def` without Ruby complaining about syntax errors.
When using Docker on macOS you can change your mount consistency setting. [https://docs.docker.com/docker-for-mac/osxfs-caching/](https://docs.docker.com/docker-for-mac/osxfs-caching/)
I've had terrible apps that were hard to setup and had great apps that didn't need any further assistance to setup. I understand what this solves however it always felt to me that booting up Vagrant, Ansible, Docker, you name it, is just making it actually harder and not solving the main problem that your real messy environment was. Don't get me wrong, dev-prod parity is something I'm always up for, but it always felt like a far away dream that will never happen. You'll always get something different and we must live with it. 
When you want a different kernel, when you need to test containers or virtualization (can you test VMs in containers? No). It's the only way to install everything the same as is on production. For just running Rails in development you might not need it though ;).
About ruby programming: I'm always happy to read more about ruby gems / libraries with some (real world) examples. Why not a little series one gem at a time. What 3rd party (or your own) gems do you use in passenger? How do you handle the command line processing? How do you handle parsing of HTTP headers? and so on. Cheers. Prost. 
Instead of `def main_supported` `if (/cygwin|mswin|mingw|bccwin|wince|emx/ =~ RUBY_PLATFORM) == nil` `return true` `else` `return false` `end` `end` you could do: `def main_supported` `(/cygwin|mswin|mingw|bccwin|wince|emx/ =~ RUBY_PLATFORM).nil?` `end` which is a bit neater :)
thanks will push this in the next commit
- I would like to build a professional profile like yours, how should I start? - Engineering: what and/or how decisions were made around important projects you have built? Tips, decision making - security for web apps - design patterns: what have you used and why one over another - how to manage/plan a project as a PM or Team lead or technical lead - How to allocate time for work/personal/open source projects? - how do you find balance between work and life time? 😀
Those instructions don't look right. For one thing, if you need a certain version of bundler, the commands in the instructions should probably include that version. Those instructions, I _think_, are installing bundler from whatever is currently at the HEAD of it's git repo (which may not even be released at all), which I wouldn't want to do _ever_, and currently is probably the new bundler 2.0. When I google, I find this, which looks sensible to me: https://stackoverflow.com/a/39959819/307106 So I'd try this: before_install: - gem install -v 1.17.2 bundler --no-rdoc --no-ri * Your Gemfile requirement actually says any 1.x bundler that is at least 1.17. 1.17.2 is the latest 1.x. * I don't _think_ the next step in the SO answer should be required, the `bundle _1.17.2_ install`, travis ordinary routines should go ahead and do a bundle install with the bundler you just installed, as it will be the latest one now. The next step might be necessary if you wanted to run with an older bundler than travis had by default. * Most of my projects don't actually specify bundler in the Gemfile at all. I'm not sure if most people do, or if it's a good idea. But you could just not do that, and you would not be alone. 
+1 for profiling memory in Ruby and Rails
&gt; Most of my projects don't actually specify bundler in the Gemfile at all. I'm not sure if most people do, or if it's a good idea. But you could just not do that, and you would not be alone. I didn't know that, when I created the gem bundler was already added to the spec as a dependency but thanks for telling me this. Will keep it in mind for future projects.
Quite funny, we had to do something quite similar some months ago: [https://drivy.engineering/use-sidekiq-middleware/](https://drivy.engineering/use-sidekiq-middleware/) 
Here is a list of things I'd like to learn from you: - how did you find your business partner(if any), what was his responsibility in the making of phusion, how did came up with the business model, and how did you funded it at the beginning. - what are the nginx buttlenecks , overall architecture as you see it. - same for passenger - future plans for passenger - how to build things that scale well( like passenger) - when did you discover the value of phusion. I guess I'd like to know your story from day 1 at phusion.. 
Thanks for your interest in Phusion! I will think about your suggestions. With regards to the story from day 1, I already have a couple of articles about that: * [https://blog.phusion.nl/2018/06/18/happy-birthday-phusion/](https://blog.phusion.nl/2018/06/18/happy-birthday-phusion/) * [https://blog.phusion.nl/2016/10/04/bootstrapped-profitable-and-proud/](https://blog.phusion.nl/2016/10/04/bootstrapped-profitable-and-proud/)
I always struggle with understanding how to craft and organize applications outside of an opinionated framework. For example, how to manage your database with Sequel in terms of configuration and code loading. Here's a recent comment I made detailing my lament: https://www.reddit.com/r/ruby/comments/9zck2o/web_scraping_webcast_video_will_blow_your_mind/ea9hnn4/ I'd really love to see more people writing about creating somewhat complex applications from ground zero without Rails. I imagine there's a lot of people who are fluent with Ruby, but are not fluent in application design in Ruby (without an opinionated framework to guide you). I find there's a big jump between feeling fluent in Ruby as a language, knowing all sorts of best practices about design patterns etc., and _actually implementing and organizing it all on your own_.
HTTP/2 and why the heck it's taking so long to come to ruby/rails!
Interesting, that may be something they added to whatever generated your gem skeleton (bundler itself?), because they thought everyone should do it even though many weren't. Perhaps I should be doing it, I don't know! 
While I can't advice which is better, I can add to the list: Kemal if you want to consider Crystal with type system http://kemalcr.com https://github.com/veelenga/awesome-crystal/blob/master/README.md
Roda is my choice.
Micro-framework choices all come down to preferences. At that level it tends to be about which ones get out of your way in the most appealing manner. I tend to favor Sinatra since it makes the request entry point really obvious by merging controller and routing concerns.
One service per container might be considered an anti-pattern in some cases. I would not use docker(-compose) as it adds too much friction. 
Your dev env does not reflect a deployed envs in any way. It's a simulation and cant be considered as the one true blueprint.
I suspect you are using it wrong. Vagrant != Docker. You use Vagrant to have a controlled underlying platform for your containers.
I wish for more blogs where people faced perf issues and needed an extension to augment ruby.
What exactly do you mean by friction? Most Rails apps will start with two containers: - Rails app - Database Additionally, it really depends on how you subdivide "service". I agree that a swarm of micro-services in the beginning is probably not the correct first step, but splitting up your application and database is.
Hi I'm author of [https://blog.eq8.eu/article/](https://blog.eq8.eu/article/) for what is worth I just to want to give you one suggestion from my experience with tech blogs: My moto is "They don't have to be pretty or grammatically correct" the biggest value is about Spreading the helpful message so my recommendation: focus more on that. &amp;#x200B; Reason why I have this opinion is that I've seen smart people that had something interesting to say started a blog on medium.com and they spent 80% of time polishing english, polishing phrazing and styling and only 20% of time on the message that they wanted to say. Yes there will be some grammar nazis pointing out mistakes or telling you that they would write it better but seriously F-it. 95% of people don't care and they just want to learn something not criticize. &amp;#x200B; I rather focuse my blogging time on paying attention to the feedback of comments on technical side and opinions of developers "where was I wrong or why " rather than " the format is not pretty" &amp;#x200B; So if you plan your blog to help others and to spread ideas. it's far more valuable to release the blog not perfect otherwise you will get discouraged maintaining it and realistically you would release 1/5 of the articles you would like to . If the blogging is about building public image image (which I'm not against to) then ignore what I just said here and I would recommend to mirror the blog articles to Medium.com as it have enormous exposure in contrast to whatever custom blogging solution you introduce 
Hey 👋. I wrote about this (kinda) https://schneems.com/2017/05/30/writers-write/. The key (for me) was to set a schedule to post a new blog post per week. Once you get into the swing of things then new ideas come much easier. 
Are you building an API? Read this: https://medium.com/@terry.raimondo/why-i-chose-rails-api-over-grape-414422e0711b I've built a few Sinatra apps too and felt the same pains, I'm always missing something that's built into Rails. 
I've been using sinatra for years now and it has never failed me.
Totally forgot about Today. Might be a good choice.
1) No, ruby is not dying. It is just not the hipster language anymore. 2) Focus on learning pure Ruby before ever touching Rails. 3) Well, as a Rubyist - yes, I think it is worth learning. I would also continue to focus on JS. 4) I highly recommend anything by Sandi Metz. For fundamentals, I can say enough good things about the Pragmatic Studio courses. https://pragmaticstudio.com/
&gt;What exactly do you mean by friction? Unnecessary setup for little to no benefit while ignoring the reality of the tools you are using. Why do you need a docker for a monolithic app in any way unless your entire team is on linux ? Vagrant allows you to have an absolute control of your environment and is cross platform. The reality of added complexity at your dev stage will hit you sooner than you realize. You in no way need a container for a database. Period.
&gt;the simplicity Lol, Ruby has the simplicity of an auto parts shop with 20 nice things on the shelves ... but a back door to a junk yard with 5,000 old wrecks sitting around waiting to be moved out. Yeah, I like Ruby, but just sayin'
\&gt; **Why Ruby on Windows is hell?** Windows is hell. So it stands to reason... Srsly, not really kidding. Windows is a different place with a different culture.
As a developer working with Ruby for more than 6 years, I dare to say that it is worth it.
I actually evaluated Amber from Crystal. However it still feels a bit immature for production yet. Every minor version is backwards incompatible and I'm simply afraid to use it for non-internal projects yet. But I'm a huge supporter of Crystal in the long run.
I understand the difference between them, but my point is that vagrant is inherently wasteful. I really enjoyed it for a time.
I am building an API, yes. However, I'm rejecting Rails API on early stage for a reason. Rails API is still Rails, but without views and assets. And as such, it is good at what Rails is good at: CRUD services. My requirements are not for a CRUD. Could not be further from CRUD probably. Rails just won't be a good fit. I also disagree with a few points of this article. I'm not using ActiveRecord, so it's no pain for me that it does not integrate well with Grape. Sequel or ROM migration are very easy to add and give me the same power. Author can set up Rails API in a day? No problem, I can do it in Grape too. And while I don't like Grape, I don't see Rails API as any better.
Roda is my choice. Natural improvement over Sinatra, it's from Jeremy Evans, so you know it's going to be rock solid. Surprised it's not listed.
I hate to be this person, but can we just put this domain on the blacklist? the articles are always so garbage.
+1 Roda
Ruby is good, but as a Java developer, I can tell you... It's a bit of a spin of using a dynamic typed language. Especially ruby because there are so many magic methods. I don't think ruby is dying, the community is too large for that.... I'm learning "crystal" though which is a stronger typed version of ruby, I wonder if it will catch on.
Well as I said you misunderstood the problems Vagrant solves.
What problems am I misunderstanding? Apart from that I have too much hard drive space available to me? 
Nice list! I did not knew about [https://github.com/rack-app/rack-app](https://github.com/rack-app/rack-app). My favourite picoframework is still [https://www.rubydoc.info/gems/rack/Rack/Builder](https://www.rubydoc.info/gems/rack/Rack/Builder) And for something completely different try [https://github.com/webmachine/webmachine-ruby](https://github.com/webmachine/webmachine-ruby)
10x! 
Looks good! The only thing I would suggest is making this if-then block into a ternary: https://github.com/palash25/log-symbols/blob/master/lib/symbols.rb#L32-L36 @SYMBOL = main_supported ? MAIN_SYMBOLS : FALLBACK_SYMBOLS 
Just be aware that there is a very real danger of starting to get frustrated with all other programming languages after prolonged exposure to ruby. Unfortunately there is currently no known cure for that condition.
&gt; Am I delusional? Yeah. Probably. Ruby is not a complicated language. To be productive with Rails you don't need to know how its internals work. Nobody would expect you to know how ActiveRecord works under the hood. Everybody would expect you know how to use finder methods though. I think you just had bad interviews.
&gt;Ruby is not a complicated language. You glossed over the whole point of my rant. Ruby is easy to pick up but hard to master. Hence: **In the market there is an ocean of people who don't "truly" know Ruby (a lot of these people are bootcamp grads but it applies to CS grads as well) and a small group of expert Ruby people who started back when it picked up and know Ruby at a deep level and nobody else in between.** &gt;To be productive with Rails you don't need to know how its internals work. What about working on an existing application that is a pretty large codebase: AKA every actual production app out there. &gt;I think you just had bad interviews. I have had more than a dozen interviews ranging from small startups to mid size companies asking about Libraries. Keep in mind that it is Library questions in combination with coding questions on how to do things the "ruby" way. Can you name some companies that don't ask about libraries? It is conceivable that they were all bad interviews but there were clear patterns in the kinds of questions they were asking which leads me to believe that it is not just a fluke. 
btw. I still have examples from KRUG presentation: [https://github.com/pawelpacana/krug-webmachine-examples](https://github.com/pawelpacana/krug-webmachine-examples) [https://speakerdeck.com/pawelpacana/webmachine-ruby](https://speakerdeck.com/pawelpacana/webmachine-ruby) &amp;#x200B;
Great write up! I had similar ideas when Ruby support was announced for lambda, and did a Slack bot myself. They don't make it very clear in the documentation, but there is a simpler way to deploy your code (I don't totally understand this SAM stuff). The aws cli has a 'lambda' command that lets you upload a zip of your project from the command line -- I just made a Rake task for this: desc "Upload project files to AWS Lambda" task :upload do `aws lambda --region #{REGION} update-function-code --function-name #{FUNCTION_NAME} --zip-file fileb://index.zip` end desc "Deploy project to AWS Lambda, with all prerequisite actions" task deploy: [:clean, :bundle, :generate_version, :zip, :upload] 
I believe your issue is actually language agnostic... I think the problem with most courses and people taking them is that they think its a learn once and never study again affair. In my opinion and experience, in this field you never stop learning and getting better. I don't see how learning Python made such a difference for you, unless you are the type of person that wants to know the exact definition of good code, as defined by some rando on some gospel book or readme file. In my experience, in ruby there are a ton of ways of resolving a problem. Some might be more performant than others, but most of the times doesn't matter as readability is many times preferred over achieving ultimate optimal performance (which is an absurd obsession nowadays in my opi ion). There are some stuff to avoid like n+1 queries on rails and better looping strategies, but you pick up on that fairly fast and its well documented everywhere. If you believe you didn't get a job because you created three methods instead of chaining a map, select, reduce kind of thing, id find it hard to believe or you dodged an environment that might not be good for you. As long as you resolved the problem requested and you are not applying for a position obviously not fit for you like lead/señor dev... Heck, what you say about chaining methods sounds like a bad practice in some ruby shops. It really depends on the style decided... Anyways its good you found your way! Some reading/books that might help you with your specific frustrations (which seem to be more related to rails) are the rails guides (yep official docs are amazing), "the rails way" and or "agile web development with rails." Any of those three should in my opinion leave you in a good position for a jr position. Obviously having a side project app will do wonders as well.
What does it have to do with Ruby/Rails? Isn't this true literally for any other language and framework? If I were to hire you to work on my PHP/Laravel app I'd expect you to know PHP and Laravel. Don't think all companies require an expert, sometimes you just need somebody capable of doing CRUD all day. Really depends on the company needs. I don't even know what "ruby way" means. Writing simple and readable code?
/s There is saying in Ruby world: "Matz is nice and so we are nice", and so is Ruby itself (Ruby on Rails is not so nice because of DHH tho). It seems you are just not nice enough to get that high level. ¯\\\_(ツ)\_/¯ &amp;#x200B; Now, had similar experience back in the 2010s. I dropped out from university (tech, but not CS-related), there were a lot of graduates to fill out positions of PHP/Java/.NET devs, so I haven't got a change there. And then I found out about that new shiny language – Ruby. I read few books, did some coding to learn and for fun. I quite liked it because it's simple, yet deep and powerful, it combines OOP with functional paradigms, and there is almost often an elegant solution to every problem. Then I learned about RoR and spend some time doing pet-projects, learning JS, CSS, HTML. &amp;#x200B; The main point though is that I didn't just learned syntax and few basic things and went to build next Facebook/Twitter/Youtube killer. I tried to understand basics/foundations of the language, and how to make things right/better: how to use OOP, functional programming, unit test, version control, how make code readable/maintainable. So... after year or two a friend of mine referenced me to his colleagues, I got an interview and got my first job, although I was screwing up a lot (like, question: "how do you do \_that\_ in Ruby?", answer: "ah! there is a method for that in standard library, I always forgetting it's name, but I definitely use it, just need to look up it in docs."). &amp;#x200B; Now back to you questions. 1. Is there a gap between experienced devs and beginners? Yes, but does it impossible to overcome? No. You just need to be willing to learn and get better at what you do, not just "delivering results daily". 2. Are all learning courses are bad? Can't tell for sure, but there were a lot of good resources back in the day, even free ones (thanks, Ryan Bates!) and a can assume that number is even greater now. I think "Programming Ruby" and "Agile Web-Development with Rails" are still must-reads for new Ruby/Rails devs, and Pragmatic Programmers' continuing to publish great books about new languages and technologies. But you must understand that you can't become pro in 30 days doing a course or two, right? 3. Yes, you are probably better off to get on hype-train for some new shiny language/framework like Elixir/Go/NodeJS/whatnot before it gained a pull of experienced developers. Cheers and best luck! &amp;#x200B; P.S. Sorry for any grammar mistakes and typos, it's quite late and english is not my native language (spell checker, you're my only hope!)
I have several counter-points, that are not **completely** against what you are saying, but probably can add something: 1. I believe that no "course" or "bootcamp" is enough to become hireable (and if your Python experience says against it, it _could_ be because Python's job marked is MUCH wider than Ruby's, sadly, and growing fast) 2. The situation "everybody wants seniors" (or at least sane middles) is real in Ruby land, in my feeling; and yes, it is not fair from some point of view. The reasons are hard to analyze, but one of them is probably the downwards tendencies on Ruby usage, so those who still do it, is either "old mature codebase you need to understand quickly", or "small startup of people who think they know exactly what they do (and that's why they choose Ruby), and want one or two more of the same -- knowing immediately what they do" 3. But no, as far as I can tell, "hireability" is not about deep kun-fu of method chaining and metaprogramming with telepathy -- it is about _experience_. I don't mean "CV experience" (I worked here and there), but the understanding of things, which is coming from really _reading and writing software_, not from books and bootcamps. That's, _maybe_ what they are asking, "have you heard about this and that library? how do you write this?" === "have you actually layed a hand on some problems, tried to choose libraries that solve the, or solve them yourself, and find yourself in more problems, and how did you get out of there" and so on. 4. There is only one way to get experience -- well, by getting it. Yes, in an ideal world, it would be some paid internship immediately after bootcamp, but, well... here we are (though, here in Ukraine even paid Ruby internships still exist, that's because life is relatively cheap and our job market is still high on outsourcing). But that's doesn't mean you can't get any if you really want. Keyword is OSS. Or just "your own pet-projects", not necessary published, but a lot of coding, a lot of "why this and that works or doesn't, and how others solve those". I don't know how you've spent those "two years", but if you aren't desperate already, and still hope for some advancement in Ruby -- that's the way. 5. And no, not all Rubyists that have some paid work are gray-haired dinosaurs with 15+ years of experience (though I am, but I still see a lot of newbs becoming mids and moving further, not only here in Ukraine where ... see "life is cheap"... but also on international conferences and communities) 6. Though, yes, the job market is shrinking. Something like that.
The reason why the above is a bit better is primarily because you can eliminate if/else branching, and simply work on the outcome of .nil? applied there.
I did not downvote or upvote you; the solution by EvilInky is better because we can get away with all branching, be it if/else or ternary.
I started with another language so it was easier for me to know where to start. I can, however had, recommend a few things: - Focus on what interests you personally, no matter what that is. When you have clear use cases what you want or need to do, the rest follows. - Even if you are just learning, try to aim for something that is of medium complexity. My first project was an IRC bot in ruby but any other task may fit here. If you use Linux, try to write some ruby scripts that do something on the commandline. - Also note down a TODO list over several days, no matter what it is. Then you have LOTS of things to pick from, what to do. :) - Last but not least if you REALLY don't know what to do, pick something from perl or python and see if you can find some gem for this. If not, consider writing a gem. I recommend this step very early, no matter how "crappy" your code is, you will learn a LOT if you update your gem just about every day or second day initially. It helps you get a structure to your projects. Try to pick a project here that is not too simple but not too difficult; the best would be a project that is somewhat simple but can accept more and more code over time. That is what I did with my multimedia project where I just keep on adding functionality (while trying to document it, too); it grows little by little.
This is true! To be honest, I didn't even read their suggestion because the formatting looked weird to me, so that's my own fault. 
Do you not understand that there is a difference between 2 years of Ruby and 10 years of a certain language? This is normal and understood in the Java, Angular and Python world. Apparently not in Ruby. 
(side note) Funny how they are (almost) all the same, mostly Sinatra-alike, with some stylistic differences of "how you define a tree" (though, I am **really** suspicious about dynamic dispatching Cuba/Roda fashion). What's left is Rails/Hanami/Camping class + method style. Python and Rust, which I have an eye on, have so much more different approaches :(
`Gem.win_platform?`?
For fallback symbols I'd use `i` for info and `!` for warning. `¡` is (half of) exclamation mark in Spanish so when I see it I think `!`, which is not info. 
Roda is my go to.
I hate the term serverless, it's worse than 'the cloud'. Why not just call it what it is - a ruby slackbot using aws lambda?
Was surprised to see someone already typed out my *exact* answer. I totally agree with all points. 
Which is why I don't touch new languages I write/help other people improve gems instead :P
1. Nope. I’m seeing a lot more enterprise adoption, but for specific applications. My org uses ruby for internal tools. 2. It depends on your learning style. I learn by doing, so I build a few code along apps to learn the style and then just build some stuff for fun. It really depends on how you learn. 3. Ruby is really powerful, but also pretty user friendly. If you know oop and how to program in general, you should be fine. 4. The well grounded rubyist and stuff by Sandi Metz.
Do you have a real point or are you just looking for people to validate your feelings of why you failed to gain traction with ruby. I’m glad you’re doing well now with python, but I don’t know what you’re trying to accomplish with this thread. 
&gt;but I don’t know what you’re trying to accomplish with this thread. I am trying to gain some insight into the points I have made and glean other peoples experiences in regards to this topic. One data point I'd like to add is that I spoke to a hiring manager of a mid-size rails shop and he has informed me that indeed he is having trouble finding very experienced Ruby + Rails developers (he is looking for 2-3 years of experience) and when I pressed him further, he mentioned some of the same topics I did(In particular ActiveSupport). Now obviously that is just one anecdote but thats why I am looking for insight! If you are just looking to get triggered and not actually provide any insight, then please just move on. 
&gt;I don't see how learning Python made such a difference for you, unless you are the type of person that wants to know the exact definition of good code, as defined by some rando on some gospel book or readme file. HA! That made me laugh because I could relate to this so much from my early year late night sessions. In reality, I studied CS and worked on many Java and C++ side projects since I have been in High School. Maybe Python just clicked better. When I graduated, I got pigeon holed into QA engineering. After quitting my job for those two years I finally got back on track. Ruby was a constant struggle just to internalize deeper concepts but as I dug deeper I could not find the best resources for more complex Ruby and Rails topics. There is an endless amount of documentation for Beginner\early-stage Intermediate Ruby though. &gt;If you believe you didn't get a job because you created three methods instead of chaining a map, select, reduce kind of thing, id find it hard to believe or you dodged an environment that might not be good for you. I would agree with you except I kept having it crop up again and again. I am in the NYC area and all I have available here using Rails are startups and midsized business. I really don't know what to tell you but I appreciate your insight! &gt;and you are not applying for a position obviously not fit for you like lead/señor dev... Since it appears that you are more insightful, can you give your thoughts on what makes a senior Ruby Dev? Not just a senior dev but a senior **Ruby** Dev? &gt;Anyways its good you found your way! Yes I had worked with Angular 1 a long time ago and did not really enjoy it. I told myself that I would not bother with Angular 2+ after they did the redesign. I just happened to land in to the job with some basic Angular 2+ skills and I ended up really enjoying it. Angular 2+ Python are pretty nice technologies and the success in getting stuff build is leading itself to more success. That was another major problem with Ruby and Rails, sure you can get simple stuff up quickly...hell you even have this scaffolding ability (with Rails)! But intermediate to complex, it felt like crossing the desert. &gt;Any of those three should in my opinion leave you in a good position for a jr position. Forget Jr. experience, I could hammer my head again for a year or less and write out jr level ruby code no problem. I am not a beginner programmer. What I NEED is a clear pathway to transition from jr to intermediate and then to senior. Given the very poor reaction that people have had to this post and the lack of documentation, I feel that this info is not well known. This was a major pain point those two years. I wonder if this is why Ruby salaries are so damn high? True deep level Ruby knowledge is like a moat that only a few have. Why don't you help out: What are good books to transition from Jr to intermediate and then intermediate to Sr Ruby experience? Are there even good books or is it all just hands on knowledge? 
&gt; Focus on learning pure Ruby before ever touching Rails. People often say this, but I think it is helpful to add this tiny extra bit: "because all of the underlying magic you see in Rails is not magic at all. It's just clever Ruby." This is obviously implied, but when you recognize this fact, you can understand anything at all in Rails. It's just a GitHub repo away. If you do not, you are held hostage by it's "magic", which, while potent, is a source of frustration. Largely from people who accept it as simply magic. Good luck op, and welcome to Ruby. Some of the .net guys at my work are currently into Ruby, and are enchanted.
Just in time when we finished and made bugfixes for our own implementation :-/
That's true. I've been thinking about creating an API framework that would be marriage of Grape (good parts) and Hanami, i.e. class per endpoint. This it pretty much how we use Grape right now.
Not really a fan of how you are taking the feedback but I get it, its frustrating, you are upset and I think you should. On that note I believe a lot of what zverok_kha mentioned is accurate in terms of experience... "They" want someone with years of experience on random gem/api/etc. But again I feel this is language agnostic. With regards to jr/int/exp... I don't think you transition from one "skill level" to another by only reading books, I think a lot of it comes from applying what you know or have experience doing, managing and tutoring others, designing and architecting, knowing when to scale and or optimize (and where to start) and stuff like that… To be honest I imagine thats on any programming language. I feel this is a question that lingers on all programming subreddits and forums... Heck, id say most professions probably are affected by the same problem right now, no one wants to train people and at the same time they expect ludicrous experience. Anyways back on topic, books that I have personally found value on that go beyond the basics, for Rails (as that seems to be your main interest): "rails antipatterns", "rails 5 test prescriptions", "ruby science". For ruby, i personally liked and got value out of "ruby performance optimization", "design patterns in ruby" and "confident ruby". Avdi Grimm author of the last book also has "Ruby tapas", which is a series of short videos that I feel is a good dive into the deeper side of ruby. Besides this, you should look at open source projects apps and gems. The uk gov has excellent rails apps with varying degrees of complexity you can learn a ton from. Im interested to learn from you if in Python there is some magical course or book that would produce better prepared developers, as if there is such thing, it could be an excellent influence/base to do something similar for Ruby... Where you say there is such lack of material. Maybe I got it wrong but you seem to be fixated on finding some 10 step plan, with cartoons and fancy colors to become a señor dev. I have seen such abominations for JavaScript, but I doubt anyone takes them serious... Anyways as far as I know, no such thing exists for Ruby or for Rails. Hope this helps!
Unfortunately I messed up the formatting - all the indentation disappeared :(
Learn by solving codewars puzzles
Oddly, `initialize` is mis-spelt as `intialize` in the same snippet in the original post, but not in the above quote. &amp;#x200B; ( When I first started with Ruby, I spent at least on hour debugging an issue to find that I'd spelt `initialize` as `initialise` )
Oh wow I didn't notice that as well. I didn't copy paste that's it's correct in the quote :)
Yeah, I wish this was there for Rails 5.
I am not sure. Perhaps one can re-bind UnboundMethod but I never had a need to have to do so. It would strike me as too abstract to deliberately ignore these ways. Of course you can also define a method that just calls methods in e. g. toplevel-defined .rb files, such as: def foo Foobar.bar There is also module forwardable, where delegation becomes possible. I also did not have the need to use it - oddly enough, I do things in a very stupid and simple way, by just defining what I need somewhere, and then simply loading/adding that code to my projects.
Because AWS lambda isn't the only provider of that service? 'Serverless' is fine. Of course it still runs on a server, but it's abstracted away. It's a concise term with an accurate, understandable meaning. That's what words are got-- they make conveying complex ideas simpler.
&gt; Is ruby dying like the hacker news "prophets" are saying? Ruby has been "dying" for about 10 years now, according to certain authors on the internet. Whilst it's not as "trendy" as it once was, it's far from dying. It's still in active development, and there are many companies that use the language as a core part of their tech stack. The language is not going away any time soon. &gt; Whats the best way to learn ruby? aka what did you all do to learn it? In my opinion, start with the basic syntax and focus on writing code "the ruby way". If you just try to write e.g. "JavaScript in ruby" (lots of `for` loops, and a bunch of methods in the global namespace), or "Java in ruby" (excessive use of inheritance, and a reluctance to use duck-typing), etc .... Then you won't learn to appreciate what the language was really designed for. &gt; In your opinions, is it worth investing time to learn ruby or should I just focus on js/node/java etc and fly by the seat of my pants (and google-fu) if i somehow land this job? If you want a job in ruby, then yes you should learn it. But *in general*, I don't think the choice of language/framework is particularly important in your career. Development principles are very transposable, and learning a second language is much easier than learning the first one. Just pick one, and stick with it for a while. &gt; What books are recommended? (if any) the well grounded rubyist looks to be popular. Plus it has a new version coming out in Feb. This question gets asked *all the time*. Personally, [POODR](https://www.poodr.com/) is my favourite ruby book I've read, but there are many more. I'm sure you can find comprehensive book reviews online.
I suppose ‘accurate, understandable meaning’ is also a subjective term then. Imagine if we called things with dairy in them ‘dairyless’. Just because the terms have been given meaning and are used doesn’t immediately make them good terms. 
Thanks!
99% of scenarios will just be a standard `def &lt;method_name&gt;` in the class definition, or the methods gets added via inclusion/inheritance. There is also a lesser-used `Module#prepend`, which places the module *before* the class in its ancestor chain - i.e. this is like "injecting the new definition before the previous one". As for "all of the other ways", I'm not sure I can provide a comprehensive list... There are loads of meta-programming tools in the ruby language, meaning you can cause all sorts of crazy behaviour if you so choose. The most common "other" way is via `define_method`. But classes can also be re-opened, and methods can injected, via tools like `class_eval` and `instance_eval`. And then at the extreme, you have things like `method_missing`, `method_added`, or even [`TracePoint`](https://ruby-doc.org/core/TracePoint.html) to "spy" on any method invocations (and inject arbitrary behaviour). --- In general, the only way to get a *comprehensive* list of all methods available to a specific object, at a specific point in runtime, is: my_object.singleton_class.methods However, as I said originally, this is usually unnecessary. Methods are almost always defined via regular `def ...`s in the class definition. Or if you're using a complex framework such as rails, which does make heavy use of meta-programming, then you're better off just reading the documentation/google than trying to deconstruct exactly how everything fits together from first principles.
You were using vagrant for isolation hence you found out docker works better. But docker/vagrant dont solve the same problems. They are 2 different technologies overlapping in some aspects yet they are used differently.
Thank you for the wonderful, well thought out reply. I'll look into this POODR! Thanks again.
mruby is used by create smart contract on CKB-VM
cheers
It is for Rails 5.2 if you are brave enough
Sounds like this will replace the need for https://github.com/thoughtbot/griddler
How many frameworks will they introduce before addressing: bloated ActiveRecord, incredibly obsolete view layer, the lack of form objects &amp; service layer (everyone does it differently), grouping by features?
\+1
I've used Rack::App in production and it is great. I've got to say Roda is really nice too.
I saw the same thing in Portland in the last few years, dozens of juniors pumped out every 6 months. The Ruby meetup was full of juniors looking for jobs, maybe one or two companies hiring. Supply and demand is real. If you have the exact same skills as everyone else, you will be a replaceable commodity. Glad you found a path forward.
This is great. I wonder how easy it is to extend. Here's why: My application makes use of both email and SMS notifications. Sending emails through ActionMailer is very rich, but we've had to build all of the templates/jobs/queues/etc separately for SMS (Twilio API call). It's not a big deal, but it is a source of complexity-from-inconsistency. I've had the dream to hack together a custom ActionMailer delivery service that sends through SMS so that I could author and send emails and SMS messages using the same ActionMailer pattern. ...ActionMailbox makes me curious whether I could extend it so that we could process inbound SMS messages the same way that inbound email are processed. Very cool.
I use MRuby for building embeddable graphical user interfaces through [mruby-zest](http://log.fundamental-code.com/2018/06/16/mruby-zest.html).
is not mandatory to have service object as `ActiveService, ActiveForm.` All the `Active*` should be disable by default and you need to enable and should a pluuggble system where should be easy to remove for example `ActiveRecord` with `Sequel ORM`
As someone who is a newbie and hasn't used this, what role would it fill with something like a MailChimp API integration? Full replacement? Supporting plumbing?
&gt; ...ActionMailbox makes me curious whether I could extend it so that we could process inbound SMS messages the same way that inbound email are processed. Very cool. I have a use-case for this. What would you want the API to look like?
&gt; Ruby’s JIT compiler does JIT compilation in a unique way, which prints C code to a disk and spawns common C compiler process to generate native code. Is this as crazy as it sounds? I know next to nothing about compilers, but jeez, transpiling to C, printing it to disk, spawning compiler processes? "Unique" isn't the first word that comes to mind. All of these steps are rather time-consuming. What ever happened to Topaz and getting a known-good(ish) JIT with minimal effort?
All that and no mention of Zawinsky's Law.
Did you compare Rack::App to Sinatra? If yes, could you share what you find better?
&gt; ...for example, there are ways you can solve a problem by "chain linking" a bunch of Ruby methods together. Normally, an inexperienced person would just do it the Java/C++/Python way by writing out a method that solves the same problem step by step. This will alert true Ruby people that know there are easier ways to solve the problem. I've worked with Ruby for some time and cringe when I see "chain-linking" or any code that's "too smart." One-liner solutions could be a fun way to impress possibly good for one-line competitions but the beauty of Ruby (for me) comes with the language's ability to balance readability and power. Here's a talk which brilliantly addresses readability and clarity. https://www.youtube.com/watch?v=DC-pQPq0acs
"bloated ActiveRecord" : They are working hard on improving activerecord performance, check this PR for example: [https://github.com/rails/rails/pull/33312](https://github.com/rails/rails/pull/33312) . But yes, it will stay a "Super object" with lots of methods, I guess there are pros and cons to that. At least count on memory and performance getting increasingly better.
Add me to the chorus in praise of [Roda](https://roda.jeremyevans.net/). We have several Roda apps in (internal) production, including what started as a POC microservices platform (~20 services) with home-baked service discovery and so on. Getting that up was what convinced people that we could, in fact, be Rails-free and make stuff work. We used Roda and tons of what [dry-rb](https://dry-rb.org/) had on offer at the time (~2 years ago), and that's still an entirely viable (and maintainable) option today. For nearly a year, though, we've been putting far more time and effort into [Hanami](https://hanamirb.org/), which gives us more/better structure and a vibrant community to interact with.
They're captive to actual/perceived installed base; one "lesson" they appear to have "learned" at about the 3.2/4.0 migration was that they "should" only add features, never remove or significantly rework them. If you want modern architecture, look elsewhere. [Hanami](https://hanamirb.org/) is a thing, and so are several other frameworks out there. 7-8 years ago Rails _was_ what SMEs used Ruby for; 4-5 years ago, they were the elephant in the room; now, more shops see things differently. Good luck, Mr Phelps.
Hanami is fine for personal projects, but there's simply no way to convince majority of dev teams to use it in the projects, and for a good reason (ecosystem).
Not exactly a JS framework... but you're up for a big surprise here... :) [https://easydatawarehousing.github.io/ferro/introduction/](https://easydatawarehousing.github.io/ferro/introduction/)
&gt; What would you want the API to look like? Sorry, I'm not sure what you mean. I'm wondering whether the external API for ActionMailbox can be the same whether it's processing email or SMS. I'm excited because I won't have to think about what I want the API to look like, I'll get whatever ActionMailbox's API is (and I'm generally satisfied with Rails core). As it is, my current implementation is a controller action that captures and verifies a webhook payload, creates an `InboundSms` model, and enqueues it on a background job that then does further processing on it (e.g. figures out whether it should create or append to a Zendesk thread). Which seems very similar to my reading of the ActionMailbox architecture. If everything could be hidden away as configuration leaving just "process the payload in a background job", that'd be nice.
Couple of issues: 1. If it’s creating Json, it’s better to call it a representer than presenter (both patterns are essentially decorators). 2. Why is a re/presenter making SQL calls?!? That should be in a query object or something. 3. If it’s job is to decorate an object as json, it should have an explicit to_json method 4. Why does an invoker have to know to call this object’s props method? The word Prop is already in the class name. In conclusion, this violates single responsibility principle: it both accesses the database and also formats data. It is also confusingly constructed. 
&gt;https://github.com/thoughtbot/griddler Hopefully Action Mailbox will be much more polished than ActiveStorage when it releases.
Awesome breakdown.
Also available to try on Heroku https://devcenter.heroku.com/changelog-items/1539
On the offchance the OP is trying to determine where a particular method is coming from, the `Method#source_location` is a godsend. c.f. User.new.method(:id).source_location #=&gt; ["/u/in0pinatus/.rbenv/versions/2.5.3/gemsets/railsapp/gems/activerecord-5.2.2/lib/active_record/attribute_methods/primary_key.rb", 18]
“As of Ruby 2.6.0-rc2, we achieved 1.7x faster performance than Ruby 2.5 on CPU-intensive non-trivial benchmark workload called Optcarrot https://gist.github.com/k0kubun/d7f54d96f8e501bbbc78b927640f4208. We’re going to improve the performance on memory-intensive workload like Rails application as well.” Yessssss keep going, guys!
1. No, rather the concept of languages dying, is dying. The trend is that web browsers, and computers in general, are becoming ever more virtualized. The result is the choice of language will less and less be dictated by the platform that it is running on. The only reason JS became more popular than Ruby is simply because Ruby wasn't natively supported by web browsers, not because JS is objectively a better language. I believe Ruby will make a comeback once WebAssembly has matured and you can manipulate the DOM directly with Ruby. In future there will be space for all major languages in the industry. The choice of language choice will depend on how productive it is at achieving a particular *task*, and not which *platform* it is going to run. Ruby is superior to most languages at certain things such as rapid prototyping, so there will always be a space for it.
&gt;ruby-lang.org/en/new... I hope to be proven wrong, but it is looking more and more like Ruby has always been performant enough, but Rails was written in a way that is hard for VM to optimise.
"Linked Lists" in Ruby is a massive troll. It's certainly possible to take a C or Java implementation and literally translate it into Ruby. But it would be stupid and non-idiomatic, because a Ruby array gives you everything you're aiming for. Want to delete the third item? You can do it. Want to pop the start? There's a function for it. These are exactly the reasons people give for needing a linked list. Really I think the answer that would most impress me is "a Linked List is largely what's behind the scenes in Ruby's array type, so we don't need to reinvent the wheel". That said, that stupid literal translation has shown up in job interview before..
It’s not just that rails is hard for the VM to optimise, it’s also not written from the ground up with performance in mind so it’s slow because it’s just badly designed in that regard.
1. Ruby dying is something I've been hearing since I first started using it. I don't think its gonna go away any soon. 2. I learnt it from a book. I forgot the name but it was something along the lines of Learning Ruby Novice to Ninja or something. Its been a while. 3. I'm biased here. Yes, learn Ruby. Its not very hard to learn it. You should be up and running in a week or two. 
that has always been the case, rails was built with the (valid) assumption that the bottleneck is the db, and the framework was "fast enough". There is a lot of framework overhead and not a lot of attention to performance. See, the techempower benchmarks, for example. Many ruby setups have much better performance than rails. https://www.techempower.com/benchmarks/ 
&gt;Just be aware that there is a very real danger of starting to get frustrated with all other programming languages after prolonged exposure to ruby. Oh the pain. I remember learning Golang after using ruby for 5 years. 
Thanks! 
endless range 😍
I use [dry-web-roda](https://github.com/dry-rb/dry-web-roda).
Ecosystem is larger than you'd think, since anything you can use in any non-Rails project (Sinatra, Roda, dry-*, you name it) can just drop in to a Clean Architecture project like Hanami. And the savings in testing and maintenance time will make believers out of anyone who stops drinking the Flavr-Aid long enough to actually try a pilot project. Rails != Ruby. And that's a damn good thing for both.
&gt; There is a lot of framework overhead and not a lot of attention to performance. Sorry but that's not true. I work alongside Rails core developers at a big Ruby shop and I can tell you performance is a top concerns. Rails is a framework with high level abstractions, of course it's never going to be as performant as bare bone "frameworks" on micro benchmarks, that's just a given, it's really comparing apple to oranges. Case in point in the benchmark you link. You see sinatra being much faster than Rails, makes perfect sense since it doesn't bother with stuff like CSRF protection etc. There's a lot of overhead in Rails that's just not useful in that context. But now if you look at the bottom of the list you see that padrino, which is simply sinatra with lots of batteries included to be somewhat of a Rails competitor, is twice slower than Rails. Rails simply makes a tradeoff between raw performance, and development speed / ease, that makes it look bad in benchmark sure, but focusing on that is silly.
haha, so see coming from Ruby you are not a fan! perhaps that's why its not really something emphasized in my ruby backend work. Yes, Ruby has all kinds of nice Array methods - I find it fun. I guess I'll just have to familiarize myself due to other languages - this was a Java job interview but I was demonstrating basic exercises with data structures and OOP and stuff, it was pretty simple otherwise. The guy interviewing me didn't know Ruby so I would demonstrate my code.
(Please don't read the below as an offense/attack, just as a hopefully useful feedback.) Neither your article nor README answer the very first question: "you should be using it _what exactly for_?" I understand you've put a lot of work into it, but sometimes the amount of work put into something clouds author's view on it: they seem to view the thing they've built as "obviously useful", and therefore fail to explain _how_/_when_ exactly is it useful?.. Let me show how I am trying to make sense of it: * I am starting to read your [README](https://github.com/BurdetteLamar/markdown_helper); * "What is markdown helper?" starts with: "Class `MarkdownHelper` supports..." but hm, what, do I need some "class `MarkdownHelper`"? When? Why? Not sure... * OK, "How it works" is, in fact, more like "what is it": "preprocessor that reads a markdown document (template) and writes another markdown document" -- well, that I probably can relate... Or not, still not sure, what's intended usage? (Though, mentioned above feature of TOC, is, at least, definitely useful for my README's, I typically have an ugly rake-task to generate them; let's see how I'll make use of it!) * Next section: "File inclusion": "This markdown helper enables file inclusion in GitHub markdown." -- OK, I can understand when it could (probably) be used, for creating large documents from several other, so, OK, what should I do if at some point I'll need it?.. No answer, just a lot of sections with plain text "you can do this or do that, oh, here is use cases for those" (well, thanks, I can imagine what are the use cases for text inclusion!) Even the line "(Actually, this README file itself is built using file inclusion.)" not helps: I still not sure how your tool helped with that, can you show what was the sources and how you've processed them?.. * Finally: "Usage" section with CLI description... Which doesn't help either, it explains in great details that one file will be the template, and another will be the result (ugh, I probably could've guessed it) and that both probably will be `.md` (oh thanks at this point I was totally not sure your markdown helper works with markdown files...) * ...and only after that, we go to the inclusion directives, which (alongside the name of CLI tool) was the only thing that matters for the user... * ...well, second thing that matters (for me, even -- the first) is "how to generate TOC with this tool", but at this point the README jumps again into the weird mode of "let me explain you the use cases for TOC, please follow that link to another file of 20 paragraphs, which doesn't answer my only question clearly: I just want TOC, what should I do???" (The same problem -- "say a lot of things, and explain nothing" -- could be found in the current article you link, in fact.) I'd say, that if you really care for people to use your software, you could probably restructure your readme the way, that it answers two main questions in, like, the first paragraph. The two main questions are: 1. What it does and how is it useful? 2. OK, if I need what described in (1), what should I do? The tool's goal is **simple** and **useful**, it totally doesn't require a whole folder of files with "different use cases" explanations if they don't make clear "what and how" immediately! Something like this (properly rephrased) probably would be 99% enough: &gt; Markdown helper is a processor of markdown templates into documents. Currently, it supports the following tags: &gt; &gt; * TOC generation with `@[:page_toc](## TOC title)` tag, which gathers all the headers in the document and renders in the pretty list with links; &gt; * File inclusion with `[format](path/to/file.ext)` tag, see `[below]` for supported formats description. &gt; &gt; Usage from CLI: `markdown_helper [options] input_file output_file` &gt; &gt; Usage from code: `...` &gt; &gt; Additional features (adding comments, diagnostics)... &gt; &gt; Example of usage: see this README source `[there]`, it woks this way (explanation). 
FWIW k0kubun said at Rubyconf that the two largest cases of JIT being slow are when there are too few methods and the JIT can never compact, and when there are too many methods. For Rails, the issue is not how the code is written, just that there is a lot of code. For now anyway. http://confreaks.tv/videos/rubyconf2018-the-secret-power-of-ruby-2-6-jit &gt; it’s also not written from the ground up with performance in mind so it’s slow because it’s just badly designed in that regard. I somewhat disagree. It's fairly difficult to find things to optimize. My best patch to date got me 10% perf improvement, though likely no one would have ever written the same code that I did from scratch. While there are some design decisions I wish I could walk back that would help make other perf optimizations, they're not as common as you might think. Ruby optimization strategies also change as the VM changes. What is "fast" today might not have been fast when the code was first written. For 90% of Rail applications out there, their code is what's making it "slow". FWIW I do appreciate your work and know that you write extremely performant code. I agree that Rails could be better from a perf perspective, but it's not as though the devs are ignoring performance completely. 
I see that there is a bit of disappointment for the lack of JIT improvements when running rails, but do we have numbers on other types of real-world use cases, besides rails and optcarrot? IMO it'll take years for JIT to optimize the mess of rails, and that's ok, I mean, JRuby has been JIT-ing rails since 1999 and it is hardly perceived as a game-changer. 
Data structures is a question that is not geared towards a language. So saying questioning about linked lists when he put data structures on his resume is certainly it a troll. Data structures are an engineering concept not a language one and are totally valid to ask. 
I didn't mean to imply the rails core team doesn't care, as you said, it's generally a trade off. It's just that performance has never been the selling point for Rails. 
This is a fairly common pattern but I think the implementation here is lacking. I'd write it something like this: class FormObject def self.attributes_registry @attributes_registry ||= [] end def self.attribute(attribute_name) attributes_registry &lt;&lt; attribute_name _generated_attribute_methods.define_method(attribute_name) do instance_variable_get("@#{attribute_name}") end _generated_attribute_methods.define_method("#{attribute_name}=") do |value| instance_variable_set("@#{attribute_name}", value) end end private_class_method def self._generated_attribute_methods unless const_defined?(:GeneratedAttributeMethods, false) include const_set(:GeneratedAttributeMethods, Module.new) end const_get(:GeneratedAttributeMethods) end end Which has two primary advantages: 1) It only creates a single Module per class instead of a module per attribute. This can have a real performance impact if you're making extensive use of something like this. 2) It gives the module a name so your `ancestors` / stack traces aren't filled with the gibberish of anonymous modules. 
The thing is that rails is colossal. I can't think of any other software based on ruby that is that huge.
(a) this is needed ... how many times? (b) the syntax is appealing to you? To me the biggest change is JIT. I don't know how and when to use it though - documentation is one area where ruby really really has to improve in the long run
We don't have that much aside from benchmarks, not even extensive documentation ... it's all work towards ruby 3.0 to be honest. 2.6.0 is important of course, lots of smaller changes/improvements, but 2.6.0 is more a "let's test the initial parts for the jit" release too.
Well that is a useful change. Ideally rubygems.org itself could show that too. I understand that this would mean that the Ruby Toolbox becomes less useful, but personally I think that all this information should be available on the official rubygems site as-is, simply for convenience of the end user.
Yeah that was very poorly handled. Normally deprecation warnings should be given. It also is at odds with matz wanting to not cause disruption. It does also show that the ecosystem is a bit fragile, not only in regards to ruby but downstream for users too since they may react very slowly when changes happen. Personally I was not affected since I do not use logger or need it (never understood why I need it; if I need logging support, ruby itself does it for me, well without logger). I think the situation is more complicated though with bundler being merged into ruby, and all of ruby stdlib being gemified. Who will have a higher priority? In this context, while I agree with you that the situation was handled poorly, stdlib should be more important than gems with the same name. It's strange that it does only affect one version and not another one - the rubygems.org team could push back 1.2.8 and lock it. AT THE SAME TIME, though, I think this shows that the whole rubygems ecosystem is limited. One name is to be assumed the same, which I hate. I suggested years ago to allow multiple same names even by different authors. For example, I have a gem called "configuration" but I can not publish it because another gem already exists. The namespace is "module Configuration" and there is no way I will change that name BECAUSE IT MAKES SENSE. But if I add this as dependency in .gemspec, people were to use that other gem, which means that projects that I use would break. This is something that has to be resolved in general one day, possibly allowing author-ownership (optionally), so that we can specifiy which author or authors to use as well.
Well, it becomes more prevalent after ruby's stdlib has been gemified. It is a problem of using the same names - you have a conflict then and have to resolve it IF you have gems like that. Not just in regards to logger but take any other gem that is part by default ruby releases.
&gt; , the whole ruby dependency system just wasn't designed to account &gt; for this intention. Yes, this is a problem I agree with you here. It will take a while before this is resolved one way or another. It's getting a bit more complicated now with bundler being integrated. There are also two instances of e. g. using openssl, one in bundler, one in rubgems (I think openssl is now a gem too). It's all a bit messy as-is. :\
Please delete this PesterBot from reddit - it steals my time and other people's time.
Hey SpamBooBCMB please do not defend the spam that you do with your useless bot. Nobody needs it; nobody wants it and I don't understand why the reddit team spams us human people with such useless bots in the first place. It wastes our time. ALL these bots are spam bots. And no, this is not equal to rescuing kittens - spamming is NOT like rescuing kittens. Reddit was not built by bots for bots. Have a nice day!
This is not a good idea because the syntax of ruby is quite different from elixir, whereas elixir is literally built around | (or whatever they used ... |&gt; or something like that).
"author-ownership" is still just a textual namespace in the end. I don't see how it would help. You are welcome to release your gem as "shevegen-configuration" now if you like. 
The problem is that matz never said that ruby is NOT simple as such. It just isn't one of the primary or major design goals. We can argue which goals are the more important ones but matz has not said that a design goal is to make ruby complex. Ruby tries to solve things and follows a more-than-one-way path in many cases, so it is not necessarily the simplest language per se. The problem with | is that it would be bolted on top of ruby at this point whereas in elixir it was there from the get-go.
It is also horrible. The | simply does not work at this point for ruby. It's not that the character is bad, but the rest of ruby does not fit in with it a lot. When you have a method call such as: .|. you know something is wrong. And this is why not everyone should be designing programming language. Syntax is very difficult to "get right". Look at C-family languages, they all copy/paste from C really.
&gt; map(&amp;:something) Newbies already struggle a lot with &amp;: It took me quite a while to understand &amp;block too. Ruby is not necessarily the simplest language on earth, syntax-wise. It's not necessarily very complex either. There is a reason why people are scared of the ruby parser.
The core of ruby is super-simple and super-consistent. That does not mean that all of ruby is super-simple.
I don't like the .|. either but I don't like your example either. I feel people are trying too hard to integrate | and they fail, both with .|| but also as a method-block like in your example. I even think that sinatra-style is a fail in design, which makes most of the www-stuff feel ... strange (rails uses that too) ... :\
Yup, the benefit seems fairly small at this point in time. I think people coming from elixir love the |, understandable since elixir was built around pipe operations from the get go. It's harder to integrate it into ruby in a "natural" way.
One area where that comparison fails is that, e. g. on *nix style pipes, we don't have a method operation such as .|. (aside from it looking awkward... typing this here almost looks like a penis and something associated with it).
I think shopify does - at the least they report strange code that breaks mruby.
I'd prefer that RubyGems.org keeps presenting only the objective data.
What have you tried? It looks like a Rails app, so after installing the gems with \`bundle install\` I'd give \`rails server\` a shot.
Thanks.
It's a rails app. You'll need to do at least these things: 1. Install a mysql2 database. 2. Configure config/database.yml properly for your database. 3. Install bundler 4. Run bundle from the repo root directory 5. Run 'bundle exec rake db:create' 6. Run 'bundle exec rake db:migrate' 7. Try to run 'bundle exec rails s' 8. Debug / install other missing dependencies / seed data in the database as necessary? 9. Visit http://localhost:3000 in your web browser of choice
Thank you.
Sounds to me like a bit of an [XY problem](https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem). Can you tell us more about what you're doing?
I’ll try :) What I have: A script that makes a series of http requests to a server using calls out to curl. In addition the server has an endpoint that opens up a websocket. Once opened it sends messages down the socket. What I want: To be able to open the socket and listen for data. The data is in the form of json objects. This should happen outside the main script but the main script needs to be able to read any data that came. 
Good call, my primary purpose was to demonstrate the idea without optimisation, but indeed, for production code, it would be definitely useful to avoid having tons of anonymous modules. Thanks for sharing.
&gt; Run 'bundle exec rake db:create' &gt; Run 'bundle exec rake db:migrate' `bundle exec rake db:setup` or `rake db:create &amp;&amp; rake db:schema:load`. `migrate` should not be used for provisioning a new database. 
Here is how you can do it with `async`: ``` require 'async' require 'async/queue' require 'async/websocket' require 'async/http/internet' Async.run do |task| internet = Async::HTTP::Internet.new messages = Async::Queue.new task.async do |subtask| endpoint = Async::HTTP::URLEndpoint.parse("ws://demos.kaazing.com/echo") endpoint.connect do |socket| connection = Async::WebSocket::Client.new(socket, endpoint.url.to_s) connection.send_message({"query" =&gt; "kittens"}) while message = connection.next_message messages.enqueue message end end end task.async do |subtask| while message = messages.dequeue response = internet.get("https://www.google.com/search?q=#{message["query"]}") puts response.read end end ensure internet.close end ```
This is an article written by you about your own gem .It's an advertisement, and you should be more transparent about it.
Awesome I’ll try this out 
&gt; def exists?(path) &gt; path.is_a?(String) or raise ArgumentError That's very bad Ruby, and it flies in the face of duck-typing. Ruby code should not make assertions about the *type* of variables.
I don't think I asserted anywhere that devs are ignoring performance (that would be kind of insulting, no?). Rails simply wasn't designed with performance as the priority. Because of that, it's stuck with lots of design choices that as you say, are hard to optimise. My experience has been that it's very hard to retrofit good performance onto an existing system where performance has not been a top priority, because efficiency actually underpins the design of the interfaces. You can certainly make inefficient designs perform better, but once it's part of a public interface, by definition it's very tricky to refactor them into something fundamentally more efficient.
As a Ruby core dev who worked on the Windows build, this is basically it. The other problems are: - It costs money and a lot of time to have Windows for development. - The development experience is frustrating at best and horribly broken at worst, when considering cross-platform open source C software. - The Windows kernel seems to deliberately go out of it's way to make UNIX software hard to port. - Expecting all developers to have a working Windows development environment is simply unreasonable.
OK, so you need a little how-to on using threads and then how to communicate stuff back to the other thread? Probably just stick this somewhere to get you started: Thread.new do while true do my_websocket_listening_thing.listen # do something to tell parent thread a thing somehow end end I don't have much thread communication experience. You do have shared object access in that \`Thread.new\` context, so you could call something directly in there. Another option that I know of is that you could hook into your event loop (if that's what the main process uses) or use signal processing to interrupt the process and go straight to a user defined block of code. I'm not sure if you can resume the original code execution even if you trap it, though. Maybe that's something to look into. Another option is to have this run as a separate process which is slightly different, although it may end up being simpler to maintain in the long run compared to threading. A lot of this depends on what your use case can tolerate.
Yes, `bin/setup` looks like it will work great here. I haven't verified that the migrations and the schema.rb have equivalent results; hopefully /u/meagar has.
[removed]
Seems merged now: https://github.com/ruby/ruby/blob/trunk/proc.c#L3066
https://github.com/ruby/ruby/blob/trunk/proc.c#L3066 "Where is your god now" :)
Homebrew? Metasploit?
neat. 
Tried to use mruby for sound processing within VST pugin. [https://github.com/fazibear/mrubyvst](https://github.com/fazibear/mrubyvst)
Thanks for your feedback! When the old site went down in mid-2017 I decided to, after a few years of the site growing stale, bring up a discussion about the general future of the Toolbox: [https://github.com/rubytoolbox/rubytoolbox/issues/1](https://github.com/rubytoolbox/rubytoolbox/issues/1) In there it was [also discussed whether Ruby Toolbox should be folded in as part of rubygems](https://github.com/rubytoolbox/rubytoolbox/issues/1#issuecomment-309104635), to which I was absolutely open. [David Radcliffe from the Rubygems team stated](https://github.com/rubytoolbox/rubytoolbox/issues/1#issuecomment-309128895) that [Rubygems.org](https://Rubygems.org) should be focused on hosting libraries, and bringing in a bunch of features that the Ruby Toolbox takes care of would put the main priority on maintainability and reliability at risk. I still agree with this, [rubygems.org](https://rubygems.org) should be a very robust place to host libraries, so the ruby toolbox remained it's own site.
Serverless more or less denotes paying for only what you use and not being bothered with idle infrastructure: [https://www.youtube.com/watch?v=ljoNnmUkv\_o](https://www.youtube.com/watch?v=ljoNnmUkv_o)
I don't really have to verify that migrations and schema.rb contain equivalent results; if the author hasn't committed their changes to schema.rb, then their app won't work.
Thanks, meagar. "Transparency" moved to top.
Would be nice if you incorporate it into the article or state why you don't. It's a very strong statement you put in that article without defending it, it makes it come across as it should be obvious.
I don't think he meant it to be an attack, I think he's stating this as a straightforward fact of computer science.
`annotate`, the gem that's useful once
Cool application. Too bad the MRuby VM isn't optimized for numerics, nor is it trivial to avoid GC in a RT context.
Post covers how to upload images or any file with Jets and Carrierwave in this tutorial guide. The full source code and a live demo is also provided in the post. * Live demo link: https://upload.demo.rubyonjets.com * GitHub Source Code: https://github.com/tongueroo/jets-example-upload
Once? You can have it update on db:migrate. I’m not sure what you mean, otherwise.
Also keep in mind that 2.6 has non-jit improvements as well. I'm seeing reports of ~6% faster rails apps. You can make things faster without jit, but with JIT it should be easier (since your perf optimizations don't have to be truly universal, due to the ability to deoptimize). 
I agree with you there.
You can open the websocket connection in a separate [thread](https://ruby-doc.org/core-2.5.3/Thread.html) and use a [Queue](https://ruby-doc.org/core-2.5.3/Queue.html) to pass any messages back to the main thread. Please take a look at the linked docs. The examples included there should be enough for you to do what you want.
If rather keep schema.rb open in a 2nd window so I can see this without scrolling to the top. I remove this from every project I see it on and nobody misses it. Complete comment vomit at the top of your files. Do not recommend. 
Not to mention the diff noise.
I'm making a joke but it's not really a joke. When I've worked with it, this gem has been useful to me until I know the codebase, then it's just cruft. As u/jhirn said, it's "comment vomit at the top of your files."
It's not about intent, it's about impact. His statement is toxic, even if he didn't mean it to be. https://blogs.scientificamerican.com/psysociety/e2809cbut-i-didne28099t-mean-ite2809d-why-ite28099s-so-hard-to-prioritize-impacts-over-intents/
500 over here.
| It's not about intent, it's about impact. While I do understand the point of this, I don't think it quite works here. I think "I found this statement wrong and naive." is very far from toxic. It's quite an objective statement really. As we grow as humans we naturally go trough many phases of being naive and plain wrong about concepts. That's not something negative, that's natural progression. Denying those mistakes and experiences is denying the fact that we are beings that need to learn trough our mistakes. We will never be perfect. Finding a flaw should be seen as an opportunity to improve. I think fixing this backwards perception of faults is much more valuable and achievable. So I argue that there has to be no emotional impact in reading something declared as "wrong and naive". I don't think you need to be thick skinned for this one, it is a basic level of taking in criticism. He even prefaces it with "I found..." stating that it is his opinion and experience and implying it is subjective. Having said that though, teaching resources are used by others to learn. They set the standard for what we can expect from the oncoming generation of programmers. I would argue that teaching irresponsibly should have repercussions.
tldr: not very
If I'm reading this right: &amp;#x200B; Give a 3rd party, Russia-based cloud SaaS a backdoor into your Rails app... what could go wrong?
I've found this useful on legacy projects, but the best thing is to add yard/Rdoc comments to models with actual documentation of why/what.
Dont understand the hate, it’s great when you dive in a new project
Agreed! Like Matz said "Ruby is simple in appearance, but is very complex inside, just like our human body"!
Only the sexiest languages like Ruby have the dick `.|.` operator! J/k I agree that it looks strange and I have removed such examples from the README. If people actually want that for conciseness then they are free to alias it themselves: ``` Module.alias_method(:|, :__pipe__) ``` I do think the block form of `pipe` looks fine with `|` operators to separate expressions though. I feel like the method name makes it pretty clear what that `|` operator is supposed to be doing: ``` url.pipe { URI.parse | Net::HTTP.get | JSON.parse } ```
Ruby is a careful balance of functional programming with imperative programming! https://www.ruby-lang.org/en/about/ Since this pipelining functionality is scoped to `pipe { ... }` blocks I think this integrates pretty well - just use it when you need to, or don't use it at all if you don't want to!
Right, elixir uses `|&gt;`. I don't use elixir myself - I just used it as an example in the title since the syntax is pretty similar to Ruby and I thought it'd help people understand what it's doing. Certainly an interesting idea that was fun to prototype! Thanks for your time and feedback, very much appreciated!
Agreed with the `.|.` lol! I still feel like the block form of `pipe { ... }` is much clearer about what it's doing. Plus it's just another Ruby DSL block like all the other ones we've seen/created over the years.
Can you please elaborate on what it is that you don't like about the method-block style? It's scoped to `pipe { ... }`, technically operator-less, and just a simple list of expressions!
Disagree with the hate. It's very useful unless you have a photographic memory or like to bounce around tabs/windows/tools to check the schema definition. It's especially useful if you work on multiple projects. Those that really dislike the comment verbosity may find ModelProbe more palatable? [https://github.com/hopsoft/model\_probe](https://github.com/hopsoft/model_probe)
I find it very confusing that `[1] &lt;&lt; 2 #=&gt; [1,2]` and `'one' &lt;&lt; 'two' #=&gt; 'onetwo'` but this new composition tool operates opposite to that. Specifically, I looked at the example given in the source, and was certain there was an error until I remembered "Oh, right, `&gt;&gt;`." It's just a very surprising thing. ``` * f = proc {|x| x * x } * g = proc {|x| x + x } * p (f &lt;&lt; g).call(2) #=&gt; 16 # ???? Not 8 ???? Oh, right. Not 8. Yikes. ```
I really need this to be honest! One thing about Django that I miss is that whenever I need to check any attribute for a model I just go to the models.py file, in Ruby I have console open most of the time to check the attributes
Here are a couple trivial examples of use: https://gist.github.com/havenwood/e381c87c90c54b7ccfe13ca53719797a
Why not use the schema.rb file? 
It's only "not very" fast for Rails. But the JIT gains for smaller apps are super encouraging. Ruby core team has stated that gains for larger apps like Rails are their next priority. I think we'll start seeing some impressive gains landing for Rails in 2019.
I believe the merged version, unlike @nobu's initial patch, doesn't automatically converts "everything that responds to `call`", it just takes procs (even "something responding to `to_proc`", which will be much saner, is not supported -- guessing from code; I haven't tried it myself)
The merged version also works with anything that implements #call too.
Ugh, missed the `compose` implementation, sorry.
[ ] You read and understood the article.
&gt; t really looks like Ruby 2.6 and 2.5 are the same speed. From what I remember from optcarrot, there was a difference in speed - but I can not find it right now, neither via google. Gotta use better bookmarks for that stuff ... :\ :/
Jumping on the hate train with this. You know what would be really actually useful? Types.
That's not true. Apps can function just fine without schema.rb. It's purely an aid to development.
How are you finding Crystal?
Not only a new project. If you work with other people, maybe someone changed the model since last time you touched it. 
There are a lot of languages out there that use types. Why stick with Ruby. 
You don't even need (static) types. Just explicitly listing the attributes in the class would help a lot. ActiveRecord's implicit attributes are only helpful for the first few weeks of development.
If yiu have an instance of the model you can enumerate thr properties with a built in AR method. I do like this though, if I squint, it looks like types.
Not exactly what I expected, i think it tried too hard to keep the syntax light... What's annoying be is that I haven't seen many changes to method signatures to make them more declarative... But we shall see.
&gt; but this new composition tool operates opposite to that. Does it? `f &lt;&lt; g` is `-&gt; (x) { f[g[x]] }` or `f . g`. If you squint a little you can map it to your Array and String examples: The order stays the same. `&lt;&lt;` is also called "backwards" composition and `&gt;&gt;` is called "forward" composition. The direction of the arrows reflect that (at least in most of the world's languages which flow from left to right). They could've chosen other operators, but they made the correct choice given `&lt;&lt;` and `&gt;&gt;`.
Gratuitous syntax sugar that should not be part of core. 👎👎👎👎👎
Why?..
We should realize at this point that we are not getting a significantly faster Ruby anytime soon. The closest we got is the GraalVM but I doubt it will be usable anytime soon with production applications. I would gladly sacrifice some of Ruby/Crystal's features for performance. Make some things optional or mandatory to help the compiler and enforce stuff. 
I think its because we are more often consuming JSON over CSV so anything related to JSON gets more eyeballs.
I think there are many people that would appreciate some optional typing. There some discussions to have something like that in Ruby 3.0.
Well, that was fun to read.
Stripe is working on [a type system for Ruby](https://thestrangeloop.com/2018/gradual-typing-of-ruby-at-scale.html). They haven't released it yet but promised to make it open source.
This is a welcome patch and was if you're honest enough inspired by what you call "a series of rants",see &lt;https://github.com/csvreader/docs&gt;. It is stall a patch (because as the article series lays out its unfixable) and many other errors for a modern csv library remain. Just a simplistic test case try the ruby quiz challenge #1 &lt;https://github.com/planetruby/quiz/tree/master/001&gt;. Here's the test.csv datafile for your convenience: ``` class RubyQuizTest &lt; MiniTest::Test def test_parse # level 1 records = [["A", "B", "C", "D"], ["a", "b", "c", "d"], ["e", "f", "g", "h"], [" i ", " j ", " k ", " l "], ["", "", "", ""], ["", "", "", ""]] assert_equal records, parse( &lt;&lt;TXT ) A,B,C,"D" # plain values a,b,c,d # spaces before and after e ,f , g,h # quoted: with spaces before and after " i ", " j " , " k "," l " # empty values ,,, # empty quoted values "","","","" # 3 empty lines # EOF on next line TXT end # method test_parse end # class RubyQuizTest ``` 
&gt; it uses StringScanner FYI: For the new alternative modern CSV reader library I have put together some "low level" input benchmarks, see &lt;https://github.com/csvreader/benchmarks/tree/master/io&gt;. And StringScanner is the clear winner over all ruby (parsing) code because - of course - it's a c-extension :-).
It's a tradeoff alright. There's pros and cons for both approaches. Testability for example ...frameworks like Spring jump through hoops to make the code testable (the whole depedency injection throughout the framework), in dynamic types this isn't needed. Ruby code is easily mocked and stubbed. As a result of this and other things there is much less bloat in Rails or Ruby in general. Proponents of Spring might say that depedency injection is THE WAY to write good code regardless of language, just as a design pattern. I never thought it leads to more readable or maintainable code.
IMO, the most powerful tool for program comprehension in a dynamic language such as Ruby is a REPL. If you're not already familiar with it, check out [PRY](https://github.com/pry/pry). &gt; No more getting lost in the web, looking for method definitions, only to realize that it's dynamically defined with metaprogramming With a REPL you do not have to wonder where that method is or what it does, [you can just ask your running system](https://github.com/pry/pry/wiki/Source-browsing#view-method-and-class-source-code-with-show-source)! You're just one `binding.pry` (or `binding.irb` if you don't want to use `pry`) away from the truth.
Yea definitely a big part of my workflow
To be honest, DI makes a lot of sense in strongly-typed languages. In Ruby, all you'd need is an object that responds to certain methods, which is easy enough. Compared to Java where you need the types to typecheck, you'd need to subclass, implement or something far worse. DI at least hide this ugly stuff from you. I think that metaprogramming and modules also alleviate the need for DI in Ruby. 
I definitely wouldn't mind optional type annotations or something, if it could bring some real gains. Mostly though, I'm satisfied with Ruby's speed and I'm happy with the performance gains that each point release has brought us. I mean, I'd love more speed too (duh!) but realistically, as a Rails developer, Ruby's execution speed is not the bottleneck for anything I do. Rails may be one of the slowest frameworks out there... but on the other hand, it's still fast enough to serve up *thousands of requests per second* on a single server instance and that's good enough for many many many use cases. 
Yes, I use this every day. It's amazing how you can hook into the application state so easily. It even works on "view" templates (I'm talking Rails). Made me ask myself, wouldn't it be great if `binding` could be used with some editor plugin to offer LSP-like suggestions without huge performance hit? Might be a noob question.
I'm actually working on something very similar as part of my Master's project, but instead of going with pry, we collect some samples by instrumenting the running system and then expose it with a language server. A language client in an IDE could then work with actual runtime types and other sample data from previous runs. Let's see how this goes. The problem with `binding` is that it's only useful at a very specific point in the execution (e.g some statement in some method that you want to stop at for debugging purposes). It could still be interesting to enhance a static analysis tool, such as [solargraph](https://github.com/castwide/solargraph) with some of pry's runtime info.
I don't think you're reading that PR description correctly. The benchmark shows that these changes perform slightly worse or the same on the given benchmarks.
Glad to hear that you enjoy ruby :) I miss types whenever I come back to some project older than 1 or 2 weeks. I love writing stuff in ruby but I literally hate maintaining it. Is it `foo.bar` or `foo[:bar]` or `foo['bar']`? What are the required methods when I want to replace some dependency? What are possible options in the hash passed in the constructor? (lovely question especially when constructor only does `@opts = opts`) When the project is fresh, you have all the answers in your head and it is easy. But after a week or a month, it is a horror. Btw. you are not right that typed language cannot alert you of runtime errors. Strong typing system can prevent some or even most runtime errors, e.g. unexisting method, passing a string instead of a number, access hash with invalid type of key or even calling a method on a null/nil. You probably meant that only tests can prevent logical error, but even in this situation, strong types help you a lot.
I had never heard of the XY problem before this link. It's definitely something I've experienced before (on both sides, heh)
I find a lot of programmers who learned to code in strongly typed languages are initially upset by ruby in a kind of visceral way. But over time, once they start to embrace the syntactic sugar as a means of clarity and expressiveness, they fall in love with it.
Java makes testing a much bigger pain than it needs to be. Good luck mocking out something that some library author decided needed to be final. Need to fuck around with time in your Java tests? Hope you injected a clock interface. Need to fuck around with randomness in your Java tests? Hope you injected an RNG class. Need to do either in Ruby? It's 3 pm 2012 and dice always roll sixes, why not? Having done a lot of Java and a lot of Android, testing in Java isn't as bad as it could be (Dagger makes DI bearable) and the static type system sometimes makes refactoring good, but I was impressed when I came back to Ruby how far RubyMine has come along and how few tools I miss. I kinda wish Java had a "test only" mode where you were allowed to override constants and mess with finals and do all sorts of "yes Java I know what I'm doing" which was denied in prod mode. (Likewise I wish Ruby had a prod mode that let you lock down certain features with flags so you know no gem has redefined system methods.)
Hmm, I was going to say the same thing about `binding`, but thinking about it, `pry` can do useful things with even if you're just at a top-level "binding", going into a specified class and listing methods etc. There's probably some way to use `pry` usefully with editor integration. 
Oh, I think DI is still useful in ruby sometimes (probably less times), but we can do what I _think_ counts as "DI" with plain old ruby sometimes. Many classes end up letting you specify a `logger` for instance. Dynamic typing means anything that has the API of a "logger" (basically `logger.warn` etc) is one, there's no need to specify interfaces (there's a con to this too of course). But it can still be helpful to be able to tell a class or object what logger to use. 
Hm. ``` # before change ... include row_sep 6.526 (±15.3%) i/s - 33.000 in 5.130936s ... # after change ... include row_sep 7.360 (± 0.0%) i/s - 37.000 in 5.032146s ``` Ah, I see, the numbers are different for other types of benchmarks. Sorry for misinterpreting.
Those differences are statistically insignificant, as well.
Awesome news
Indeed. I just (with sleepy morning eyes) have read it like "after the change all cases are _slightly_ faster".
You can mock over `final` classes, or mock `new Date()` pretty easily in Java actually. PowerMock, JMockit, and several others support it. The issue isn't that the language doesn't allow it. The issue is that most java users truly believe that adding vast amounts of complexity to their code which is only used in test is actually the proper thing to do. They don't see it as a nasty hack to allow testing, they see it as _good code_. 
The null object pattern is really nice for this and I agree that the amount of #try and &amp;. I've seen in code bases is a band-aid.
you can try it out! https://sorbet.run/
Ruby is by far my favorite language - although if you're approaching this as a sysadmin, you might consider python just because it's more universally installed.
Having a problem to solve or a project in mind is always a great way to get up to speed -- if you're a server admin, Ruby (and Rake, ruby's version of make) are great for automating repetitive tasks.
I'm also a Cherwell developer at work and would like to eventually get into writing APIs. With that being said, what direction would you go?
My best approach for learning is to try and do something. When it doesn't work, I google why it doesn't work. I try solutions that I find online until one works. I make a note of that solution and then I move on to the next problem. You can get as fancy or as simple as you want but most learning in software development is based on that process.
Thanks for your insight, I understand the context better now. I was thinking of this more similar to the `yield_self` stuff, where you are chaining methods together. 
I would still not consider python, ruby offers much nicer syntax and reads much nicer when making sysadmin-like scripts
Ruby is great, it's made to be fun to write. It reads nicely and you can do pretty much anything with it. Youtube videos are great if your attention span is short.
Ruby is a great first language. Just make sure not to jump into Rails before you've mastered Ruby. There is a lot of 'magic' Rails (meaning a lot of things that automatically are done for you under the hood), so it's a really bad intro for a beginner who's aiming to learn basic programming concepts. &gt; what are some good ways to learn code? &gt; &gt; will get bored outta my skull if I try to sit down and read a 600 page book. Pick a pet project and work on it. That's how I learned (at least before I went to school and got a degree). I started out writing purely procedural code because that was all I knew. Spent a lot of time Googling stuff about basic sting manipulation. Learned what 'characters' and 'indices' were. Then I ran into a road block and Googled a bit and found out about 'classes.' Seemed useful, so I started adding classes to my code. Googled more. Learned about malloc, free, and arrays. Then polymorphism, then generics, then data structures, then algorithms.
When I was starting with Ruby/Rails, I had a couple of webapps in mind that I wanted to develop; one was for tracking vehicle maintenance, and another was for news-gathering teams to do photo sharing. Both were fairly specific to my situation, but the latter one turned out to be useful enough that I launched it as a subscription service.
Strongly second getting far into Ruby/coding before working with Rails. An upvote was not enough to convey how many ruby devs I’ve met who really just used the rails magic and knew little about coding without it. 
Seconded about python being more universal as a sysadmin. Either way you go, as a fellow visual learner I'd recommend following along with video tutorials building projects from scratch. For picking up Ruby on Rails, I ended up following the 'building AirBnB' tutorial on [https://code4startup.com/](https://code4startup.com/)
I was a sysadmin for five years, until I left and got a programming job which I've been in for six where I mostly write in Ruby. &gt; will get bored outta my skull if I try to sit down and read a 600 page book. Yup don't do that. &gt; Is Ruby a good language to start my coding adventure It is for programming for programming's sake. Like if you want a non-your normal day to do project, Ruby is great for that. I made a Sodoku solver as my first non couple lines of code project, fun but not useful. &gt; should I be looking elsewhere? Yes I think you should. Do you work in Windows and do much in powershell? It's a pretty powerful language and a good way to start picking up fundamentals while actually performing work duties. For example, and this was kind of a bigger project than intended at the time: I wrote a script in powershell to query one database that held HR information for employees. If it found someone who left it'd check their active directory account and ensure it was disabled. If it found someone who JUST started and HR hadn't informed us yet it'd create their account anyways. That saved me a few hours a week dealing with crap. That's the kind of project you ought to start on IMO. People will say Python and they're not wrong, it has more uses. The key thing though is that a lot of programming involves the same CONCEPTS and it's the little stuff that changes. No clue if it's still relevant but I read [Seven Languages in Seven Weeks](https://www.amazon.com/Seven-Languages-Weeks-Programming-Programmers/dp/193435659X) which was a fun intro to programming that gets you to try a bunch of different languages. It's actually what got me started with Ruby.
This is why I take a look at https://crystal-lang.org/ . IMO The perfect language but too young yet...
Most of the time a ! bang method means it is going to modify whatever you are calling it on whereas the non-bang method is going to *return* the new value. Generally speaking you want to avoid writing code that modifies things in-place (the bang version) unless you are being very intentional. ```ruby irb(main):001:0&gt; x = [3, 2, 1] =&gt; [3, 2, 1] irb(main):002:0&gt; y = x.sort =&gt; [1, 2, 3] irb(main):003:0&gt; y =&gt; [1, 2, 3] irb(main):004:0&gt; x =&gt; [3, 2, 1] irb(main):005:0&gt; x.sort! =&gt; [1, 2, 3] irb(main):006:0&gt; x =&gt; [1, 2, 3] ```
Do this. It should make the difference clear to you. x = [1, 2, 3] y = x.map(&amp;:to_s) puts x puts y y = x.map!(&amp;:to_s) puts x puts y The bang methods (methods that end with `!`) transform the array _in place_ - that is to say, they actually alter the array. The non-bang methods don't alter the array, and instead create a _new_ array that is transformed. 
Beat me to it!
I've been using Ruby for a long while now and am working a new job using golang. I'm finding unit testing to be the largest pain point so far. Very much enjoying the benefits of compile-time type checking, but oh man it'd be nice to be able to mock something easily... It's either DI or relying on integration tests. :/ Ultimately it just means I need to get used to different design patterns. 
This is great! I used to do check exactly these properties (# of issues, regularity of commits etc.) manually to determine if a project is alive+healthy. Having the badges in place is helpful.
So, the `!` doesn't have any special meaning to ruby -- it's just part of the method name. Techncially, `rotate!` and `rotate` are just two different methods. There are certain conventions for what an alternate method with a `!` means. But they aren't really always followed. Some people think `!` means "mutate the receiver." But according to Matz, `!` is just intended to mean "dangerous alternative". Of course, mutating the receiver could be considered "dangerous". But in the end, you just have to look up the method definitions and see, in any given case. `!` can be a mnemonic device to help you remember the difference, but it just depends on how the methods were implemented. [rotate](https://ruby-doc.org/core-2.2.0/Array.html#method-i-rotate): Returns a new array by rotating self so that the element at count is the first element of the new array. [rotate!](https://ruby-doc.org/core-2.2.0/Array.html#method-i-rotate-21): Rotates self in place so that the element at count comes first, and returns self. So in this case, yes, `rotate!` changes the array you call it on ("rotates self in place"), while `rotate` leaves the original array alone but returns a new array that's a transformation of the original ("Returns a new array"). Does that make sense?
&gt; The cores of Ruby functional style are: &gt; * blocks/procs &gt; * chainability &gt; &gt; In general, we say that a goal of "functional" program is to represent the computation as a chain of the transformation of values; those transformations should not change values (immutability), should be idempotent and pure (except for the input/output, preferably clearly separated), right? What do you think of this proof of concept that takes this "functional-style DSL" a bit further? [https://github.com/LendingHome/pipe\_operator#-pipe\_operator](https://github.com/LendingHome/pipe_operator#-pipe_operator) It's an interesting hybrid of both functional and imperative programming which still feels pretty Ruby-ish since it's just another DSL block and methods are still chainable. ``` url.pipe { URI.parse; Net::HTTP.get; JSON.parse } ``` ``` url.pipe do URI.parse Net::HTTP.get JSON.parse.fetch("posts") select { |post| post["published"] } JSON.pretty_generate(allow_nan: false) end ``` ``` [9, 64].map(&amp;Math.pipe.sqrt.to_i.to_s) #=&gt; ["3", "8"] ```
 Though I'm confused why leet code wouldn't accept my first solution if it's calling on that method for the solution. It's not really clear how there testing the solution so I'll just chalk it up to a TIL opportunity. Thanks that clears it up.
Yeah, this makes sense and that's a great article on it.
I'm not sure if I consider replacing the classloader and editing the byte code in place "easy" but I imagine if the user experience is simple enough, it would seem that way. I didn't have access to these tools in big corp programming, unfortunately, precisely because they did what's said above. &gt; The issue is that most java users truly believe that adding vast amounts of complexity to their code which is only used in test is actually the proper thing to do. They don't see it as a nasty hack to allow testing, they see it as good code. I would be very interested to see how much of DI gets used because it improves application architecture, versus how much actually improves the codebase. There are times where I've found the use of a DI framework to bind a source of system objects kind of useful, but in Ruby I just end up using the object-as-its-own-factory pattern and it also just works.
Learn by doing. Instead of starting your own project you can solve small puzzles on Codewars, Codingame or Hackerranks. I am a fan of codewars, so check it out.
Ruby is a great language as it provides the Rails framework, which is geared directly for making websites using MVC principles. Rails also gives you a lot of helper methods for accessing and presenting data. &amp;#x200B;
On the other hand, when there's something that needs to be changed in the `RSSFeedEpisodeTestFactory`, or especially if there's a bug in it -- it makes a lot harder to deal with. I've seen it go wrong in both directions. Which honestly leaves me unsure of what to do when writing tests. But I've definitely encountered tests where so much of the setup was extracted to "somewhere else", that is hard to tell when a failure is a test setup failure rather than code failure, hard to figure out how to fix it when so, or hard to figure out how to change the test when what has to be tested changes. 
They were probably testing the original array, so while both statements return the same value they’re just looking at the original to see if it was modified. Map without the ! creates a new array, while map! alters the original
Probably the wrong subreddit to say this but I've gone the other way. Ruby was everything I wanted after years of writing Object Oriented Perl. I jumped on it around in the very early 2000s while most shops web shops were still using mod_perl but over the years it feels like there has been a community trend towards what I'd describe as "conf' celebrity golf". Those super DRY, _why's camping framework level meta-programming DSL monstrosities that look great on a demo slide at the cost of quality of life things like being extensible and predictable. Rails was the king of this mentality though to their credit they've slowly tried to back away from the really bad stuff over the years starting with the Wycats era releases. I still love Ruby but like most scripting languages I think they truly shine gluing together APIs into prototypes and data munging. 
But there are few sources that are trying to make ruby more attractive to sysadmins, like [http://rubyforadmins.com/](http://rubyforadmins.com/) and also I think I had some hardcovered book about it. 
Jason: you know what? Just fuck off. Your spamming it's annoying, and your posts show that your as dumb as bread crumbs.
I think for my sysadmining, I've found shell scripting to be the most universal by far. Also significantly more painful than either Python or Ruby.
I actually have a really hard time with language learning books. Whenever I pick up an o'Riley book I fall into the pattern of: 1. Alright I understand the syntactic structure and why its built this way. Interesting. 2. God this is sooo slow and redundant/I don't need to have the concept of an integer explained. Ok, I'm just going to skim a head. 3. What the hell is a monad, and how the hell did it get here from a paragraph about string concatenation? [Exercism](https://exercism.io) is my got to for learning a new language. Its basically just a social TDD problem set. Once you submit a solution you can see how others solved the same problem, make and receive comments, or revise your solution. There is also now a tutoring system for it as well. There are no lessons, but there are some recommended reading for each language. Also its all free. &amp;#x200B; When I was learning Ruby, I also enjoyed [https://rubymonk.com](https://rubymonk.com/). &amp;#x200B; &amp;#x200B;
Just search github - especially the pull reuests, bugs, comments etc
&gt; Why?.. Is wrapping `f.call(g.call(n))` with `f'(n)` manually such a common and burdensome operation that it requires a new methods to do it? Where is all this functional composition done at in Ruby now, can you show me? &gt; TBH, I believe you misused "syntax sugar" term. I don't think so but prove me wrong. 
I'm sure people will disagree with me, but I would probably say Ruby is responsible for modern testing, particularly unit testing, being halfway decent. Libraries like jUnit, QTP, and such have been around for decades, but are always miserable tools to use. Compared to them, MiniTest and Rspec are like black magic. Since the introduction of both ruby test packages, and early TDD evangelism by ruby developers, testing has moved from a dirty word to a thing you have to do. Look at many JS test frameworks, or ExUnit (in Elixir). Many of them can trace their ancestry to "RSpec, but in Javascript" or "MiniTest, but in Elixir".
Remember all those times you said Ruby's CSV library was unfixable? I do. LOL
This was a huge undertaking by [Hiroshi-san](https://twitter.com/hsbt/) to get this out the door and deserves a ton of praise for his work. 
I honestly think it needs a little more... I know it wants to be like ruby but strong typed... But it's not declarative enough to make it easily readable for human eyes imo. Also I'd love some sort of a mandatory exception statement in the method signature.
Actually a lot of sys admins use Ruby as a replacement of Perl. Python is widely used but you should consider both and pick the one you feel the most enjoyable.
I think that's a huge reward of working with a different stack, you gain perspective. I've been so much into Ruby the last 6 years I barely remember what it's like writing in a static language. I really want my next stack (either as a hobby or a new job) to be static. Not because I think java leads to better code than Ruby, but because I think developers should gain perspective.
&gt; What do you think of this proof of concept that takes this "functional-style DSL" a bit further? I think it is a nice personal exercise that has nothing to do with idiomatic Ruby.
OK, thanks, I got your points. Don't agree with either of them, but I don't think it is a situation where one of us can make the other change his mind. Am I right to understand that from your point of view NO more features (new methods, classes, operators etc.) should be added to Ruby ever, and all further development should be done in direction "leave the language alone, just make it (faster, more concurrency-friendly, what else?)" Or do you still assume there could be new useful language features? What could they be? Is there any feature (classes/modules/methods, not something like JIT) from [this year's release](https://github.com/ruby/ruby/blob/trunk/NEWS) that doesn't match your definition of "syntax sugar"?
&gt;PRY I remember when PRY was first introduced, that was 2011! This got me thinking, will we one day see PRY replaces IRB as default?
I think you raise a good point. If I were to find my factory growing complex at all, that would be a red flag to me and I'd maybe start considering a different approach.
It still is. To quote from below: This is a welcome patch and was if you're honest enough inspired by what you call "a series of rants", see &lt;https://github.com/csvreader/docs&gt;. Note, however, it is still a patch (because as the article series lays out it's unfixable) and many other errors / updates for a modern csv library remain. Just as a simplistic test case try the ruby quiz challenge #1 &lt;https://github.com/planetruby/quiz/tree/master/001&gt;.
It's an excellent first language because it's designed to be "programmer friendly", so readable, everytime someone asks me about programming language I show an example of ruby and one of C# and they always choose ruby. About learning, I read a book and I already had experience with C# so I just started to "translate" my C# projects to ruby. As a sysadmin you might want to look [Chef](https://www.chef.io/chef/) for automation on your servers.
This is the answer to [Seems standard CSV library is not "broken, broken, broken" anymore](https://old.reddit.com/r/ruby/comments/a797b5/seems_standard_csv_library_is_not_broken_broken/). This is a welcome patch and was if you're honest enough inspired by what you call "a series of rants", see &lt;https://github.com/csvreader/docs&gt;. Note, however, it is still a patch (because as the article series lays out it's unfixable) and many other errors / updates for a modern csv library remain. Just as a simplistic test case try the ruby quiz challenge #1 &lt;https://github.com/planetruby/quiz/tree/master/001&gt;. 
&gt; seems one guy just fixed Let's celebrate Kazuma Furuhashi (a.k.k 284km). Thank you. Thank you. Keep it up.
Gems is something I just used and thought it came with ruby. Is this version of gems something you could/would install yourself independent of ruby or it will be bundled with a future release?
They’re installed together but you can update separately: `gem update --system `
Basecamp (creators of Rails) is using it in production :) 
Right, shell scripting is the ultimate in universal. I mentioned python as it's probably on 95% of systems you'll see, compared to maybe a third that have a useful, modern-ish ruby. So I feel like it strikes a good balance.
I think it also depends on how much control you have over the systems in question, and what OS you primarily work on. If you're working in an environment where ruby is available on your systems, or easily installed, great! Do you some ruby. But if you're running a more "enterprise" linux distro, or even some other unix, where getting a modern ruby going is an ordeal, I'm not sure it's such a great idea. Not long ago I had to admin some systems that only had system packages for ruby 1.8 (in the days of ruby 2.4). Even as a rubyist it was infuriating to work on them, because a lot of gems have *something* in their dep tree that requires ruby 2.2 or better, so nothing "just worked" like it does on normal, modern ruby. In that kind of an environment, python was definitely an easier target.
Good question though -- will ruby 2.6.0 come with rubygems 3.0.0? Not sure, ruby 2.6.0 already has an RC1 out, so unless it does... Ah, it does! If I install ruby 2.6.0-rc1, and run `gem -v`, I get `3.0.0.beta3`. So there you go, looks like ruby 2.6.0 will come with rubygems 3.0.0. (Me, I wouldn't have called ruby 2.6.0.rc1 an _rc_ if it's using rubygems 3.0.0.beta3 and the final will use 3.0.0 period, unless 3.0.0 will match beta3 exactly, any _intended_ changes before final release don't make it an "rc" to me. But I've noticed "RC" doesn't mean what I think often in ruby community...)
Gems that are installed by Ruby is in gem form exactly to allow you to update them separately from Ruby. 
I think I actually am comfortable with _factories_ (where the outcome is simply a single object, with no other side effects) that get somewhat complex. Although I often use factory_bot rather than rolling my own. As much for "you know where to go to find the factory and how it will work, once you know how factory bot works", as for actual convenience that factory bot adds. Where I've seen it get into trouble is setup with other side effects and mocks. "It should be easy to tell what the test is actually doing" applies to _setup_ code too, and I think an addendum is "just by looking at the test, not by looking through multiple files". Personally, I have for instance, come to abhore using rspec's fancy `subject` features. They sometimes seem to make things concise and make it _easier_ to see what the test is testing _when you are writing them_. But whenever I came to tests written by someone else, like 99% of the time them doing fancy things to make the tests _concise_ made it hard for me to figure out what the tests were doing. And of course usually when I come to tests written by someone else is when there are _failing_ tests, or I need to add _more similar tests_, and both things get harder when I can't figure out what the setup is actually doing. But I definitely don't feel like I have a lot of answers, I don't feel very expert at writing readable and maintainable-over-the-long-haul tests. 
I would love to here more about getting into low-level performance and optimization. Once things get into C extension territory it gets questionable as to whether we're going to find an answer. I'd love to have a better grasp of OS-level debugging
neat, thanks!
I agree with you that the requirements of the problem were poorly specified, it wasn't entirely clear to me they were asking you to mutate the array, rather than return a new array, with the directions "Given an array, rotate the array." But yeah, for the purposes of learning, that was the difference here. Mutate the original array, or return a new array with that transformation?
Best of both typing worlds: the amazingly flexible gem [contracts](http://egonschiele.github.io/contracts.ruby/).
Make it an Enumerator and you can lazily grab the first x numbers in the sequence, grab only odd ones, etc... 
So, you should know that this is terrible code. A couple magical things: `qaHash = Hash.new {|h,k| h[k]=[]}` This means to create a new hash with nothing in it, with a default block. That default block means that when you try to use a key that's not defined yet, it'll initialize the key as an empty array. ``` items = projects.map{ |p| qaHash[p['qa']] &lt;&lt; update_builds(p) } ``` This is probably not what the original author actually wanted but here's what it says: For each project in projects, convert it to a hash which includes whatever was in the qaHash before, plus a new key called whatever the value of `p['qa']` is, with the value of whatever update_builds(p) returns, which is a different hash. A side effect of this code is that the qaHash gets populated as you might expect, and also an `items` is an array of hashes an increasing number of values in it, like: ``` [ { "p_qa_value_1": { repo: ... } }, { "p_qa_value_1": { repo: ... }, "p_qa_value_2": {repo: ... } }, { "p_qa_value_1": { repo: ... }, "p_qa_value_2": {repo: ... }, "p_qa_value_3": {repo: ... }, }, ... ] ``` I'm guessing that's not what they meant, but that it doesn't matter because they aren't actually using the `items` array for anything, and instead are just using the final `qaHash`. This code can be written in a much clearer way, that would also require a lot less memory overhead. 
This line `qaHash = Hash.new {|h,k| h[k]=[]}` creates a new Hash, the block `{|h,k| h[k]=[]}` is called when you access a key that is not found on the Hash, every key has a default value, in this case an empty array `[]`. qaHash = Hash.new {|h,k| h[k]=[]} p qaHash # prints {} qaHash[1] # try to access any property p qaHash # prints {1=&gt;[]} the best way to learn what a piece of code does is to see in action, i recommend taking a look at [https://github.com/pry/pry](https://github.com/pry/pry) and [https://github.com/deivid-rodriguez/byebug](https://github.com/deivid-rodriguez/byebug), both of those allows you pause a ruby program at any point and check the variables
update\_builds is also a terrible name for that function. It in no way describes what it does, unless he only posted part of that code.
Others have given you a rundown. I just wanted to suggest reading up on the [enumerable module](https://blog.codeship.com/the-enumerable-module/). It's one of the great things about Ruby and a common stumbling block for new devs.
thanks!
thank you. i'm still confused, but i guess it's a little clearer
thank you, i'll check it out
Totally agree!
Feel free to ask questions, I'll answer them!
thanks! am reading a lot about ruby. when i feel like i can ask a decent question, i will ask it ;)
I always forget to check this on ruby docs when I'm so used to going from the array to hash sections.
&gt; Am I right to understand that from your point of view NO more features (new methods, classes, operators etc.) should be added to Ruby ever, and all further development should be done in direction "leave the language alone... No, just things that seem to be toy features. So in this case I asked &gt; Is wrapping f.call(g.call(n)) with f'(n) manually such a common and burdensome operation that it requires a new method to do it? Where is all this functional composition done at in Ruby now, can you show me? This would justify such a feature (to me :)) &gt; Is there any feature (classes/modules/methods, not something like JIT) from this year's release I will look and get back to you. &gt; ... that doesn't match your definition of "syntax sugar"? I don't think this is _my_ definition. This is _the_ definition. From https://en.wikipedia.org/wiki/Syntactic_sugar: &gt; ... is syntax within a programming language that is designed to make things easier to read or to express. 
Good detail on current state of JIT. Thanks for posting it. I am excited about JIT and was hoping for some real impact in 2.6. Even if that isn't happening, I feel getting it in 2.6 will go a long way in making 2.7 significantly faster as more people use it. 
I've not used RPG Maker before, so I can't comment on the logic, but right away you have a syntax error. "Soul.png" is being interpreted as "run the png method on the Soul class". Your line should actually look something like: Bitmap.new('Soul.png') # note the quotes that indicate this is a string Have you ever used any other programming languages? I'd suggest looking into a free online course such as Codecademy to get started learning the basics.
It sounds as though some code simply plays better with JIT than other, so it is possible that the task of improving Rails JIT performance is the responsibility of the Rails community and not the Ruby core team? Can Rails be refactored to see more benefits? Are there coding habits that we can start to learn to improve the ability of code to take advantage of JIT?
Not knowing RPG Maker is probably fine, The script should be very far from most built in mechanics. The quotes helped, though I had to move the sprite from a folder that sorts the new images. (Pretty sure I can add a file directory to use folders) &amp;#x200B; Codecademy was the first source I went to. It was going fine, until it wanted me to use code that I haven't seen before.
&gt; Or do you still assume there could be new useful language features? &gt; What could they be? Yes, though nothing comes to mind. &gt; Is there any feature (classes/modules/methods, not something like JIT) from this year's release Not a complete list, but: * constant names may start with a non-ASCII capital letter * Dir#each_child * New Time features * Random.bytes * URI::File Other, older things that come to mind: * Enumerator::Lazy * Hash#dig 
&gt; is possible that the task of improving Rails JIT performance is the responsibility of the Rails community The author says that he doesn’t want people to have to write code differently for JIT to make it faster. In a talk he gave at RubyConf he mentioned one of the major challenges with Rails was the sheer number of methods. When there are lots of methods this current implementation does not optimize as well. &gt; Are there coding habits that we can start to learn to improve the ability of code to take advantage of JIT? The behavior of JIT is likely to change in the coming years. If you optimize for this implementation it might be slower in the next implementation. AFAIK there is only one main way to play with the overall performance and that is by changing the number of methods that JIT will attempt to optimize. Though again that could change with the next implementation. 
Just goes to make you realize how important the work with Truffle is. /u/chrisgseaton
TL;DR: Good news for people that play NES games with Ruby, not so good news for people running Rails or Sidekiq.
&gt; items = projects.map{ |p| qaHash[p['qa']] &lt;&lt; update_builds(p) } This doesn't create any copies of `qaHash`. `items` will be an array of the default arrays that are values of qaHash. This is confusing code, but it's not especially inefficient because aside from the hashes created by update_builds, the only thing that is created is an array with references to arrays. Those arrays are necessary for the output so it's really not that bad. `qaHash` is what is known as a closure, so it always refers to the same local variable in the context where the block was defined.
I see, looking to use this in rails 6. Thanks for doing this :)
And what about people who are programming?
Can someone explain (or link) why they choose to optimize through c code and not through the intermediate formats (eg llvm’s typed assembler)?
&gt; So in this case I asked: &gt;&gt; Is wrapping `f.call(g.call(n))` with `f'(n)` manually such a common and burdensome operation that it requires a new method to do it? Where is all this functional composition done at in Ruby now, can you show me? I have a LOT of problems with this question, so I decided to treat it as rhetorical ¯\\\_(ツ)_/¯ But if you are insisting... First, from my perspective, "wrapping `f.call(g.call(n))` with `f'(n)`" is NOT what's it about; the feature is about treating callables more like a value object, which could be important a) for DSLs and b) for developing _new_ idioms and approaches. # DSL example, some imaginary router: get '/foo', &amp;parse_params &gt;&gt; BusinessOperation &gt;&gt; render_result # New idioms and approaches: Faraday.get('http://example.com/something.json') .then(&amp;JSON.method(:parse) &gt;&gt; self.method(:sanitize)) .fetch('items') .map(&amp;GoodsRepository.method(:load) &gt;&gt; self.method(:ensure_access!)) (Let's pretend that everybody who are planning to comment it with disgusted "but this is ugly and unreadable!!!1111" already did that, OK?) I am NOT saying that the examples shown are necessarily "better", but for my eye it is "another approach" definitely, not just "wrapping" something. Next, "Where is all this functional composition done at in Ruby now, can you show me?" -- from my perspective, is EXACTLY against your own point :) We generally don't do the functional composition in Ruby **currently**, but probably we will, given the proper tools/syntax/idioms? For me, an important thing to think about new features is "how they will allow new approaches to code", not "how they will allow doing micro-rewrites of existing code without actually changing anything" (and THAT would be a "syntax sugar"). For me, a language is a tool of thought, and I treat new features from the point of "whether they'll allow me to think in a different way". &gt; ... is syntax within a programming language that is designed to make things easier to read or to express. That's very selective quoting. If we say that "anything that makes things easier to read or express" = "syntax sugar", than the whole Ruby language falls into this category. Syntax sugar is syntactic elements which are just "shortening" or "beautifying" of existing constructs, without producing any new semantics or derivative constructs. Examples of syntax sugar in Ruby: * `obj.call(...)` =&gt; `obj.(...)` -- it is absolutely not necessary, just "pretty" (for some of us, Rubocop's authors hate it); * `{:foo =&gt; 'bar'}` =&gt; `{foo: 'bar'}` -- the same, it is still the same "symbol =&gt; value" hash, just less symbols to type; * optional parenthises around method calls and hashes in arguments Basically, anything that is "just the same language items in the same order, just less typing". I believe that the composition of callable objects is _semantically new concept_, not "just less typing" one.
I don't have a link right now, but the core team decided that basing the work on LLVM or alternative can be a huge maintenance burden for them in the long run and so prefer their own smaller implementation of JIT.
truffle will happen in years from now. Plus you never know when oracle will kill it. 
You surely can change a few things in Rails to improve the JIT gains, but it's way beyond that. By definition JITs are good at optimizing CPU heavy hotspots, e.g. a handful of methods that are called at lot and don't wait on IOs. Compiling a method is costly, so it's an upfront cost that only pays off after it's been called a lot afterwards. Emulators like VMs are mostly one huge CPU only hotspot in a loop so it's normal that they gain a lot from JITs, web frameworks generally don't have such hotspots, and spend a lot of time on IOs.
It's sad .But nobody cares about sudoku.
Hey, I understand why you are writing those (to show to your clients and persuade them in something), but why do you post it here? We are definitely not the target audience, for us, it is pretty obvious that all of your statements either trivial (and unrelated to Ruby/RoR), or untrue. So, what's the point? Just to have more visits on your counter?..
you wont get people to go to your site by posting useless crap in various subreddits. just saying
Content marketing at its worst.
Thanks for the advice dear.We are giving what ever information we are having and giving our link to know more knowledge. 
My only gripe is that we all depend on chromium now. It makes me a sad panda. :(
I already suggested to make him president on the ruby issue tracker! (I don't care in which country specifically really, even though Japan may be a logical choice.)
3.0.0 will be part of ruby 2.6 - that is the whole point of increasing the version to 3.0.0 really; bundler will also be part of the "official" ruby (the one you can download from the official homepage). Integrating bundler was one major reason for many changes to rubygems in the last some ... 2 years or so.
Yes, 2.6.0 will have rubygems 3.0.0; 99.9% likeliness. I think there may be one or two problems still but xmas is in 4 days, so - still time for last minute fixes (I am not so much referring to rubygems as such, but bundler).
No - that was not really a TL;DR. You omitted a lot of important information in your TL;DR.
Yes, unfortunately some code will lend itself better to JIT than other code. As for your other questions - there is a lot of documentation and explanation missing when it comes to JIT. I suggested to add more documentation on the official ruby tracker some time ago but I think Takashi has more than enough to do with the code-side of things, so documentation and explanation may lag behind ... :( Documentation is an area where ruby really ought to become better. It is such a great language but the documentation, while not totally terrible, is mediocre at best in general. &gt; Are there coding habits that we can start to learn to improve the ability of code &gt; to take advantage of JIT? I asked just about the same thing in the issue I created at the official bug tracker. :) I guess all we can do right now is to be patient ... information will trickle down sooner or later, most likely by blogs (who seem to write better documentation than the official homepage does ... :P )
&gt; The author says that he doesn’t want people to have to write code &gt; differently for JIT to make it faster. Well that is also matz' philosophy - but the problem is that matz also said that some code parts can be optimized better than others, and if people care about speed, sooner or later they WILL want to make changes when they need more speed. Plus, the whole ruby 3 goes under the 3x3 speed improvement, so these are orthogonal design goals that you have here. The best compromise would be to add high quality information in one place, with information that also makes people possible to decide for which projects JIT may be useful and for which it may not be so useful. I can already see what I will do - I will actually not use JIT for some time, since I have no idea how it all fits together and works or whether it may lead to bugs, breaks or projects that would perform more slowly. With better documentation this could be avoided perhaps, but I am a bit less enthusiastic about the JIT as is - but the real aim is ruby 3.0 so we all have to be patient anyway.
There were several reasons; matz gave a presentation. One was that they are not sure what may happen to LLVM in the long run. If people think this may be unlikely to change, yes, perhaps but ... see github being assimilated by Microsoft, thus changing github to a MS platform. Downstream projects have no influence on that and similar changes, to some extent, can always happen with just about any project. The ruby core team wants to try and keep things managable from the ruby point of view, thus trying to not depend on outside projects too much if this can be avoided.
I needed this very much! Thankyou for posting it ʘ‿ʘ
I’m not exactly sure what MS and github have to do with anything here, but thanks for your POV :) Anyway, at least both llvm and gcc use intermediate formats. I think also MSs compiler. I’ll try lookup Matz’s presentation on it.
 👍 Glad it would be of some help.
Cool. &gt; I think there may be one or two problems still but xmas is in 4 days, so - still time for last minute fixes "RC" _really_ doesn't mean to the ruby maintainers what it means to me! 
I don't find postings like that helpful at all. I think posting "whatever information" vs "useful information" is part of the problem.
silly clickbait article with no useful information.
I feel guilty for my compatriots :( Most of recent clickbaity corporate "tech blogs" are Ukrainian outsource/outstaff companies, probably some "mail list for marketologists" recently suggested this way of promotion. ¯\\\_(ツ)_/¯
What's the difference between this and Kimurai? Apparently by the same author . 
Kimurai is a scraping framework, Rubium just a simple gem which allowing to automate Chromium browser directly without Selenium (like Puppeteer). I have plans to add Rubium engine to Kimurai (see existing engines https://github.com/vifreefly/kimuraframework#available-engines). 
/u/indenturedsmile is probably correct in regards to what the issue is. I'd also just take a second to mention if your goal is learning Ruby, RPGMaker isn't the best spot to do it. I mean, it's great and all and gives you something you're interested in, awesome. However, RPGMaker's Ruby Version if I remember right is closer to 1.9.3 which is fairly out of date. There's going to be some occasions where something that looks like it should work in Ruby, doesn't apply to the version of Ruby being used in RPGMaker VXA.
Because the intermediate format for LLVM or GCC were not meant to be used this way, and it is not a stable format. Which means every new version of LLVM Ruby night have to rewrite some part of it.
What was the other MJIT that **someone** is working on ? &amp;#x200B; Vladimir Makarov, the original author of MJIT, said he is working on a new JIT ( along with many other things ) that doesn't requires GCC or LLVM. Simply because many are not comfortable with having GCC or LLVM in production environment. ( [https://www.youtube.com/watch?v=emhYoI\_RiOA](https://www.youtube.com/watch?v=emhYoI_RiOA) ) &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
I wonder if it works even if your content is bad. It might! 
That is not exactly true. Especially llvm put a lot of effort defining the intermediate representation. A whole bunch of front ends (including rust and ghc) compile to the intermediate representation. [0] [0] - https://en.wikipedia.org/wiki/LLVM#Intermediate_representation
&gt; and if people care about speed, sooner or later they WILL want to make changes when they need more speed For sure, I guess what i'm saying is...don't do that yet. If you're going to optimize something right now, optimize for performance in general with JIT off. Usually this involves reducing allocations, or simplifying logic. In general if code is fast to begin with, then in theory it should also be fast in JIT. As the implementation firms up then we can start considering what patterns are faster. &gt; With better documentation this could be avoided perhaps, but I am a bit less enthusiastic about the JIT as is The way i'm thinking about JIT is the way I thought about generational GC. Generational GC was added in Ruby 2.1 and while it worked...there were bugs and edge cases. It wasn't really in 2.2 that it was really bullet proof. Then incremental garbage collection was added and while that was better there were still some bugs etc. I would say that all the GC changes were really solid by Ruby 2.3. I think JIT is like that. It's a working implementation, but it could be better. It's exciting because this is the groundwork, this is what needs to happen before we can start to see any big perf improvements that we're hoping for. While I admit, this isn't as exciting as getting a thing that works out of the box and is magical...writing a working JIT that can run on any codebase without a SEGV is an enormous challenge. Ruby also has different requirements from other languages. For example Java (and JRuby) both optimize the crap out of their code and run really fast once things are warmed up. But the first time you execute your code it is very slow. One of the main blockers for a JIT in ruby is that since it's used not just as a web programming language but also for scripting, we care more about the one off code execution time than other languages with a JIT. We also care a lot about memory. The MJIT proposal is the first and only proposal to satisfy most of the needs for most of the developers, and in it's own way...just having a JIT implementation be allowed to ship with Ruby is a huge achievement. 
You might want to note that this uses GraphQL Ruby's DSL syntax, which is eventually going to be deprecated: http://graphql-ruby.org/schema/class_based_api.html
What's wrong with depending on chromium? Isn't it open source &amp; therefore reproducible?
Is there a way to pass an environment var like that in Windows?
as far as I'm aware it works exactly the same in Windows
i love this, thanks
The problem in this specific example is that when the last character of s1 ('c') is reached, then s2.include?('c') will be truthy. It shouldn't be counted though, as s2 contains only one 'c' that has been matched with the first 'c' in "aabcc" already. That is where the second part comes in. It replaces the first occurrence of 'c' in s2 with an empty string (i.e. removes the first 'c' from s2) as soon as the first 'c' in s1 is reached. After that, s2.includes?('c') will be falsy and the second c will no longer be counted.
Wow, this is beautiful
&gt; By definition JITs are good at optimizing CPU heavy hotspots, e.g. a handful of methods that are called at lot and don't wait on IOs. Compiling a method is costly, so it's an upfront cost that only pays off after it's been called a lot afterwards. Why can't I just prematurely compile my whole codebase so that I don't have to rely on the JIT to guess which hotspots it is going to meet and which ones to leave alone?
Haven’t heard about headless mode. Chrome without chrome! Lol
Without much more context all I can really link you is these gems which I've used in the past with good success: [https://piotrmurach.github.io/tty/](https://piotrmurach.github.io/tty/)
Sorry I'll add some detail, there's not much though and thanks for the link
Thor is the canonical gem for making CLI apps in Ruby
To add on this, once you have it written you can add a ruby shebang, make it executable, and move it somewhere into your PATH sans .rb file extension (that’s what the shebang is for).
I’m actually working on a great blog post on this topic and will link back when live. I’m writing about creating a ruby app, that is exposed via some CLI, and tested as well. Probably overkill for your problem, but it’s a great overview and the solution has performed well in a live environment for several years now. Happy to chat with you briefly before then if desired, as it might help guide my writing as well. Shoot me a message if interested!
You might like this book: https://pragprog.com/book/dccar2/build-awesome-command-line-applications-in-ruby-2 This book and https://pragprog.com/book/rmtpruby/text-processing-with-ruby will set you up really sweet for building tools in Ruby! One thing I've really enjoyed about Ruby is that you can just create a file like `slack_notify`, add the `#!/usr/bin/env ruby` shebang, and either put or symlink it on your PATH, and it feels like a native bin tool. It's very friendly and convenient! This is the simplest possible example, and from here you have things like `optparse` in the std lib, and gems like `thor`, `methadone`, `gli`, etc open up Eve more opportunities. Ruby is really great for this!!!
My man!
Remove .RB from the end, move it go /bin. Put #!/path/to/ruby in the top of the script. Now relogin. The script will be found in your path, so it will just work like a normal coomand.
Itd still wait for input after I run the program name as a command though, I want to be able to give params and args all on one line
The only way to understand something like this is to get out a pad and go through it like the computer would.
Yes, you are right. Updated the post to make it more clear. Adding the usage of the class based API in a follow-up post.
What you want is optparse ;) with the above of course
Depends on what do you need. Do you need some kind of terminal gui? Than perhaps you need a binding to ncurses. Do you need interactivity? If the only thing you want to do is parse arguments and act accordingly then I suggest to start with OptionParser from standard library (no dependencies you don't need). It's really simple, example from my gem: [https://github.com/strzibny/invoice\_printer/blob/master/bin/invoice\_printer](https://github.com/strzibny/invoice_printer/blob/master/bin/invoice_printer)
Not all of what they said is great advice. Instead of putting that script in /bin put it in /usr/local/bin or better yet ~/bin (make sure to add that to your shell’s PATH though). You don’t have to be root to do that. Also, you don’t need to log out to see a new command in your PATH. If you modify PATH in your shell’s config file then load that file, e.g. `source ~/.bashrc`. Or just modify your shell’s PATH with `export PATH=$HOME/bin:$PATH`.
https://github.com/ioquatix/samovar can be useful for complex command line apps with sub-commands and other functionality.
Because you can't compile the code without executing it a few times first. Some simple code: def add(a, b) a + b end You compiler wouldn't know what to do because it doesn't know what `a` and `b` are. Are they strings ? integer ? floats ? Whereas the JIT will see that this method was called 10 times in a row with ints, and will assume it's always that, and compile that method this way.
Really?
Features List on top of my head. &amp;#x200B; Webpacker, using WebPack as default ( I am still hoping Webpack becomes good enough as default so we no longer needs Sprockets ) Action Mailbox and Action Text, ( Hopefully some improve with Active Storage as well ) Unconfirmed - Parallel Testing and DB. 
Some suggestions: 1) The goal for coders in every language should be "Readable" code. With that in mind, ruby code can be very clean and readable and it can be written in such a way that it's very similar to python code. 2) I suspect that you probably jumped straight away into a framework like Ruby on Rails without spending much time on learning ruby as a language. Correct me if i am wrong in this regard though. Check out the following books 1) Eloquent Ruby (Russ Olsen) 2) The Ruby Way (Hal Fulton) 3) The Ruby Programming Language (Matz and Flanaghan i think) 4) Also check out the source code for the ruby standard library. You are sure to pick up a lot of good habits from reading it. 5) Every language has it's share of idioms and ways of doing specific things but it's even more important to do things in the most readable way possible, preferably by following industry coding standards for that language. 6) Also, while it's good to have a good idea for what different pieces of rails does, it's more important that you know how to use them and put together whole applications even if they are nothing but gloridied CRUD Apps in the beginning. Good luck.
I like short, concise, succinct one liners when they clearly express what's happening. I think here it is overdone exactly at the part that confused you for two reasons: - I don't expect .count to mutate anything. If you want a solution that mutates s2 do something else not .count. - I don't expect commonCharacterCount() to mutate s2. dup s2 so the original is preserved or at least put a bang on it along with a comment that the method is optimised at the expense of calling it alters your data
Pros: Oo language Excellent documentation Rapid prototyping/ Development RoR=MVC framework Easy language to start with Cool community ( extremely friendly) Cons: Not that hot anymore Ruby generally except for web apps is not too notch (mainly comparing with python) Generally regarded as a slow language 
Biggest pro for me is I like it and find it easy to work in.
&gt; Generally regarded as a slow language Except there is (generally) no huge difference speed-wise between Python and Ruby performance wise at this point. Sometimes I feel like people forget that a lot of languages are under active development, and that just because Python was significantly faster than Ruby at one point doesn't mean it is necessarily still the case (or that it will continue to be the case!). Not talking about you, just airing my own rant.
I was intrigued so checked out TechEmpower benchmarks and, sure enough, Python and Ruby are head-to-head. The only reason I'd jump over to Python is due to activity around research and data science.. since I don't have those interests, Ruby it is! Having said that, looks like there was meant to be a full stop after "comparing with python". I think they were saying generally in comparison to all other languages available. Which is an indisputable point.
&gt; Having said that, looks like there was meant to be a full stop after "comparing with python". Good point, can't disagree there!
Pro.. it's genuinely a pleasure to program with. You can use strong OO concepts, FP, write/use descriptive DSLs, huge ecosystem (mostly web focused), the community upholds the philosophy of developer happiness which generally shows in usability of a lot of tools and general attitude. Popular enough to find work and to find developers. Con.. (as mentioned) slow and a little memory hungry (though this doesn't matter for most cases). Lack of static type checking. Pigeonholed into a 'web' language. Loss of steam. I've worked with Ruby for about 7 years. I picked up Go and Elixir over the last 12 months. With Phoenix (Elixir's answer to Rails), I'm not sure why I would use Ruby/Rails. This isn't a dig at Ruby, but rather Rails, as Phoenix is an infinitely better designed framework. That loss of steam + increased, compelling competition as time goes on is not a good sign.
By good enough, I think you mean easy enough. I understand the advantages, and somewhat understand why people go ga-ga over it, but sprockets for small to medium sized projects "just work" and is so much easier to use.
There's also a bit of history. Matz is a big free software fan and really likes GNU stuff. GCC is already a known entity. Plus it doesn't hurt that Vladimir Makarov (who proposed MJIT architecture) is a full time developer on GCC. From his Kaigi talk https://vmakarov.fedorapeople.org/VMakarov-RubyKaigi2017.pdf he has 20 years of experience with GCC. If they run into compiler issues, they'll have lots of experience. 
I highly recommend using docker for your backend dependencies (postgres, mysql, redis, elasticsearch, cassandra, etc) instead of install them to your system with homebrew. It's very easy to do and ensures your developing / testing against the the correct versions and makes it very easy to have different versions / data for different apps you're working on. I also recommend trying out prezto if you're an oh-my-zsh user - same cool toys with much better performance. 
&gt; Basecamp 3 is already running rails/master in production Holy crap. I guess it’s good enough for me then. 
Parallel testing please.
The notable part is "failed to build native extension". That means its trying to compile C code. You probably need to follow the instructions here: https://github.com/rbenv/ruby-build/wiki 
Hey everyone, earlier this year some blog posts I wrote on deploying Rails apps using Kubernetes on Google Kubernetes Engine (GKE) got posted here and did pretty well. At least it was upvoted pretty highly, although there weren't many comments. I originally wanted to update those blog posts both because several parts had changed, and to simplify things where I could. I then realized that blog posts might not be the best format for this however - I had gotten some private emails where people had gotten tripped up on wording and some asides I had taken. And writing out detailed instructions and taking screenshots can take more time than just recording video. So I decided to still do the updates, but instead use a screencast format, and split things up into logical sections to make it a real course. I hope this is something Ruby devs find value from. I'm open to feedback! Thanks.
Ruby is also incredibly popular for embedded, not just web. 
Can you refer me to some frameworks regarding embed?
You probably have good reasons for using RSpec. But I did want to grab this opportunity to give another shout out to minitest. It rocks. Is small. Simple. Easy to debug. Comes with rails by default. And is nearly always magnitudes faster than other testframeworks. I've not seen any good reason for using Rspec in the last five years.
Hey everyone, earlier this year some blog posts I wrote on deploying Rails apps using Google Kubernetes Engine (GKE) got posted here on [/r/ruby](https://www.reddit.com/r/ruby) and did pretty well. At least it was upvoted pretty highly, although there weren't many comments. I originally wanted to update those blog posts because GKE, Kubernetes, and other things have changed in the meantime. I then realized that blog posts might not be the best format for this however - I had gotten some private emails where people had gotten tripped up on wording and some detours I had taken. Not to mention writing out detailed instructions and taking screenshots can take more time than just recording video. So I decided instead of updating the blog posts I would record screencasts, and split things up into logical sections to make it a real course. Some things I updated or improved from the blog posts previously posted: * No prerequisites - don't need to bring your own domain name any more * Cloud CDN can be enabled with a new BackendConfig Kubernetes resource and Service annotation * GKE has private networking now so we don't need Cloud SQL Proxy any more, which added unnecessary complexity * I figured out why cert-manager was bugging out getting certs for some people; I reported to the cert-manager repo but we know what to work around in the screencast * Took out the nginx sidecar container w/ Brotli - added unnecessary complexity I hope this is something Ruby devs find value from. If there's any interest I'd like to record at least two more episodes teaching Terraform and Helm. I'm very open to feedback! Thanks.
I am working in a mid sized project and if you have a frontend with React or another kind of progressive web framework it becomes a pain in the ass to manage the dependencies without screwing up. I know that there is stuff such as rails-assets.org but honestly webpacker is pretty much in a good state to have anyone a decent configured webpack environment.
Whoops, just found it. Use the .escape method with the client which should be enough to prevent SQL Injection as outlined in the github page. I also found this which it a far more complete document for all capabilities in Mysql2: https://www.rubydoc.info/gems/mysql2/Mysql2/Client 
the syntax is what does it for me.
I was just looking for something like this today! 
What would you like to know? 
Rspec is descriptive, and is designed to be specification for the objects you build. Written correctly, specs are the documentation you leave for the next maintainer. MiniTest is designed to test, which is not the same thing. Especially for applications, specs are my preference. And spec marchers are especially useful for understanding intent and tracking down failures. For example, “test” pseudocode: `Assert message_list.count is equal to 12` Fails with “Expected 12, got 13” While “Spec” pseudocode: `Expect message_list to have 12 messages` Fails with “Expected to have 12 messages, but there are 13. Here are the 13 messages: ...” Poorly-written project specs abound, and are not superior to MiniTest tests. But well-written specs are worth a lot more than MiniTest tests. 
&gt;&gt; Is wrapping f.call(g.call(n)) with f'(n) manually such a common and burdensome operation that it requires a new method to do it? Where is all this functional.. &gt;&gt; composition... &gt; I have a LOT of problems with this question, so I decided to treat it as rhetorical ¯\_(ツ)_/¯ But if you are insisting... This is not rhetoric. It's one (of several) way one can determine the need for a feature. &gt; the feature is about treating callables more like a value object, which could be important a) for DSLs and b) for developing new idioms and approaches. &gt; DSL example, some imaginary router: .. &gt; New idioms and approaches... RE: The ugly and unreadable comment. Yes, true. As I said: starts to tread into Perl 's TMTOWTDI. &gt; Where is all this functional composition done at in Ruby now, can you show me? -- from my perspective, is EXACTLY against your own point :) Not quite. &gt; We generally don't do the functional composition in Ruby currently, but probably we will, given the proper tools/syntax/idioms? So they've added a feature that is not needed but they're _hoping_ someone will use. Ha. I do not want to work with this product manager. &gt;&gt; ... is syntax within a programming language that is designed to make things easier to read or to express. &gt; That's very selective quoting. If we say that "anything that makes things easier to read or express" = "syntax sugar", &gt; than the whole Ruby language falls into this category. Negative. This is syntax _within the programming language_, not, as you're trying to argue: _the programming language's syntax_. Ruby sends messages to receivers. This is done via `.`, e.g., `"foo".concat("bar")`, `[].append(1)`, etc... But, there is _syntax within Ruby_ that sends the message to the receiver **without** the `.`: `&lt;&lt;`, `&gt;&gt;`, `+`, etc... This is operator overloading which, is syntax sugar. &gt; Syntax sugar is syntactic elements which are just "shortening" or "beautifying" of existing constructs, Yes, like `&lt;&lt;` for function composition. 
All you need is [OptionParser](https://ruby-doc.org/stdlib-2.5.3/libdoc/optparse/rdoc/OptionParser.html), it comes with Ruby. 
Minutest has a similar ability, called BDD Style, though.
Sorry, I am giving up. There are so many inconsistencies in our dictionaries and definitions that it would require a significant amount of time and effort just to synchronize them, and only _then_ we could've gone back to the initial topic. ¯\\\_(ツ)_/¯
You may want to use [prepared statements](https://github.com/brianmario/mysql2#usage) (`#prepare` and `#execute` methods) which prevents query parameters from being parsed as SQL. You may also want to look into [Sequel](https://github.com/jeremyevans/sequel#a-short-example) which also supports the mysql2 gem under the hood.
Oh wow this is cool, thank you
Did not realize Vladimir Makarov is a full time GCC dev. That's cool. Thanks for mentioning it. 
The same story from their side (to know it happened exactly like presented here).
&gt; Optimize object allocations which we've not invested so much in JIT so far I think that optimizing object allocations will make Ruby faster in general. If you benchmark your code to see where you can avoid allocations you will most probably gain some performance. In Ruby itself this is already addressed for some classes (Array, Hash) with the upcoming release due to the transient heap feature (see https://bugs.ruby-lang.org/issues/14858) but one notable omission in this regard is the String class. If short-lived allocations of small strings are made faster, many libraries that do parsing or serializing will benefit.
https://github.com/mruby/mruby/
I'm more than a little suspicious of the benchmarks given that there are additional operations in the deep benchmark (i.e. the dir_path should be precalculated), although given the differences between read and write suggest there's more going on there.
I'd guess it's mostly the OS doing permission checking: you might access `dir_path/01/`, but that does not necessitate access to `dir_path/01/02`. It would be nice to see a benchmark with different numbers of sub-trees to confirm that. A directory split makes mostly sense when you need to shard your data across multiple mount points (either network filesystems and/or physical volumes (e.g. `dir_path/01` to `7f` from server A, and `80` to `ff` from `/dev/sdg1`). See also this SO thread: [What are functional differences between tree-like/hierarchical and flat file systems?](https://unix.stackexchange.com/a/157627/55712)
Awesome job man! Definitely something you can be proud of. 
Thanks!
Thank you so much for your work!
Really interesting , will check it out thnx ;)
I don't get the SPA fascination, why are trying to avoid page reload?
Good question. Well, in some cases when you lots of info on the page and you don’t want to disrupt the UX with a page reload it would be nice to have it.
Take a look at Array#&amp; [http://ruby-doc.org/core-2.5.3/Array.html#method-i-26](http://ruby-doc.org/core-2.5.3/Array.html#method-i-26) &amp;#x200B;
THANK YOU for your cheers ! Merry Xmas ! :-)
&gt;doing permission checking Interesting point. I wonder if we can disable that. Other commenters mentioned that flush can be an issue and the size of the file are too small to measure correctly performance.
FYI: [Spoiler] Frank J. Cameron has posted a first solution / code-snippet @ &lt;https://rubytalk.org/t/re-ruby-quiz-challenge-9-tally-up-calculate-the-standings-table-for-the-english-premier-league-2018-19-season-and-the-winner-is-liverpool-manchester-city/74884&gt;. 
Did you know? The next EuRuKo 2019 in Rotterdam, the Netherlands will be on a boat. An not just any boat. We're talking former cruise ship 'ss Rotterdam' &lt;https://twitter.com/euruko/status/1070288835916034048&gt;.
Have you tried Turbolinks?
VueJS and jsorm with either webpacker in app or spa on another server
Good job mehdi.
Although I myself do not use or need rails, I find it nonetheless good that the rails team is still going strong.
I find that comment interesting because ... I think all testing-frameworks in ruby are pretty ugly and awful; rspec is a bit nicer to read indeed but it is still ugly. I am not a big fan of sentence-driven testing. :P
I guess you will get very biased results here. I'll give some comments and start with the cons: - Speed. Compared to C there is no comparison. Ruby is a snail. Ruby is doing fine when pitted against python and perl but if you need speed, C is king. C++ may be acceptable too. - Documentation. The documentation is ok, a bit better than mediocre but far away from VERY GOOD. - Amount of users. There are plenty of people using ruby but there are significantly more people using python. This is something that factors in. For example, when there are bindings to C/C++ toolkits and such, often you see a python version but not a ruby version. So python has more momentum and leverage right now. I am not entirely sure why ... it may have to do with documentation and the fact that ruby is both more fun and more complex than python (taken as a whole). Anyway, to the pros. My number one reason is: - Ruby is very, very easy on the brain. Literally stuff such as: container.each {|item| That's almost plain english. You iterate over every item in the container object there. Python's for loop never felt as straightforward (ruby also has for, but I rarely use for). - Ruby can be adapted to how you think. Open classes etc... ad-hoc method/code additions or removal. You adapt ruby to your needs, not the other way. - Ruby is a LOT of fun. Literally I used perl, php and python before (or rather I picked up python years after I started with ruby). I still use python too. Ruby is by far the most fun. Perl and PHP are too awful to use; python is strange in some ways. Explicit self passing between methods in a class SUCKS. Python has a strange OOP definition that it is using. - Blocks are great in ruby as are collections/enumerable. There is a reason why ruby has been used for prototyping so much - it really is working "pseudocode".
Dude? Excellent documentation? You didn't write this when you were drunk? &gt; Ruby generally except for web apps is not too &gt; notch (mainly comparing with python) Funny that you claim this because I have been using ruby before rails emerged, and still use ruby just fine for commandline stuff (not all is commandline-only; I use web-components and GUI bindings too, but it is the commandline where I usually start with ANYTHING). &gt; Generally regarded as a slow language This is true IN GENERAL for the "scripting" languages. However had, I fail to see the huge difference between perl, php, python and ruby here. They sit in a similar boat. Plus, the path to ruby 3.0 leads to more and more speed improvements anyway.
&gt; The only reason I'd jump over to Python is due to activity around research &gt; and data science Speed is not a decisive difference here but there are more people using python - no way to deny this. This then leads to lots of more code written in python. People who know e. g. C++ and then write bindings, will often do so in python simply because the learned it already. So when you are in such a state, it makes indeed little sense to switch to ruby even though ruby is better - python is "sufficiently useful" to not have to switch. An example for this is the relion toolkit: https://github.com/3dem/relion/tree/master/src It's CPP and when it comes to add-ons, these are in python predominantly (and some shell scripts such as https://github.com/3dem/relion/blob/master/scripts/star_loopheader ) And that is one example for many similar projects. Bindings to frameworks is an area where ruby really should do a lot better. There are no bindings for qt5/kde5 for example. :( There are bindings to gtk+gnome but this is 90% a one-man job (japanese hero-hacker). We really lack C/C++ gurus who use ruby rather than python. I have no idea how to better this situation ... :\
Think of this as sort of competing with lua, then you get a better picture for mruby. Personally I'd love for mruby and MRI to merge one day. I myself use MRI only; mruby is mostly for C/C++ hackers only .... :(
Agreed! It is a good reason. I find it very easy on my brain. In PHP I have to think too much. In Ruby I can shut down, listen to strange music and let my toes do all the coding (well, almost ... still my fingers but I am sure I could do it with my toes and eyes closed).
I found it hard to upvote or downvote your comment so I left it as-is. Some comments I disagree with a bit or a bit more. &gt; Pigeonholed into a 'web' language. Partially true. But some people used ruby way before rails and are not using rails. Like me. And I use ruby for all web-related stuff too - it replaced PHP here. I think the biggest problem is indeed that people see rails but not ruby. Rails is sort of too big here - it overshadows the rest of ruby too much. There are other big projects in ruby though; puppet for example. &gt; Loss of steam. Well ... this depends. If you look at the charts, perl lost momentum, PHP lost momentum - lately even python (!) lost momentum. Even Javascript struggles to overtake PHP but I am sure in 2019 javascript will have put PHP down finally (below javascript that is). When you look at languages such as Go, while it is awful, and the syntax is quite ugly, Go is still comparatively easy and faster than ruby python etc... - I know quite a few people who went to embrace Google as their new master and use Go, largely because C/C++ but also Java are too complex/verbose. And these people often write a lot more Go code than they do write code in e. g. ruby or python. So loss of steam is not only limited to ruby alone, even though I can not disagree with your comment. &gt; With Phoenix (Elixir's answer to Rails), I'm not sure why I would &gt; use Ruby/Rails over it aside from if I was looking for developers. Because Ruby is still better than Elixir. Elixir makes erlang acceptable. The concepts are quite cool - I am a sucker for massively distributed objects doing stuff; that fits to biology too and what Alan Kay said. But Ruby versus Elixir - sorry. Elixir is acceptable, but Ruby beats Elixir with its eyes closed. &gt; That loss of steam + increased, compelling competition as time goes on &gt; is not a good sign. Eh - I have seen the rails hype too. People jump ship all the time unless the language gives them value they do not get elsewhere. &gt; but as developers replace Rails, they'll replace Ruby if nothing &gt; else is keeping them around. These people did not have a genuine interest in ruby prior to that so can we really count them as real ruby folks?
I don't know the answer, but isn't about Mocha rather than minitest?
This is a really a Mocha question rather than minitest. I believe it should be possible by passing a block to `with`: https://www.rubydoc.info/github/floehopper/mocha/Mocha%2FExpectation:with
It also assumes you already know all the file names. I've switched from flat to deep when `ls` started taking ages, and I'm not switching back.
&gt; People who know e. g. C++ and then write bindings, will often do so in python simply because the learned it already. So when you are in such a state, it makes indeed little sense to switch to ruby even though ruby is better - python is "sufficiently useful" to not have to switch. Yep, great point. It really does depend which side of the equation you start on. In terms of lack of C/C++ gurus, I agree. Ruby is written in C, though, so they are still around. It's also about where the community generally gravitates. I wouldn't even think of using Ruby for anything GUI related.
&gt; I think the biggest problem is indeed that people see rails but not ruby. Rails is sort of too big here - it overshadows the rest of ruby too much. That's what I mean. Over time it has perhaps started as Ruby, but it has later been pigeonholed into web. I'd still say that is the case, though I couldn't say if it's changing since the hype died down on Rails. So you're right, I'm talking about loss of steam in terms of Rails. &gt; Because Ruby is still better than Elixir. First, we'll have to absolutely agree to disagree here. Elixir is built on top of Erlang/OTP and runs on the BEAM platform. The fact it ships with a whole platform for distributed services which has been going for 30 years already has Ruby beat by a long-shot. Add to that great concurrency controls out the box, fault-tolerance, hot-code reload, in-memory store, remote debugging consoles, optional type-checking through annotations (not great, but.. Dialyzer), pattern matching, piping, fully immutable data structures. It is highly fault-tolerant and doesn't chew up nearly as much memory as Ruby, is considerably faster on concurrent workloads. This all comes baked into the language and platform. It's like comparing Ruby to Java on the JVM. There is no competition. Personal preference means nothing here -- it is a different level of language. I've used Ruby for the last 6 years and have spent 12 months building a non-trivial Elixir cluster (not Phoenix). Ruby is well and truly outclassed in this situation. The only thing I miss is OO (though am coming round to process-based architecture) and the many great gems available in Ruby (still plenty of activity in Elixir). &gt; These people did not have a genuine interest in ruby prior to that so can we really count them as real ruby folks? It's a good point. I got into Ruby due to Rails. Now I have a faster, more robust framework I can use and I have Go for fast, small, simple micro-services and CLIs, I don't really have space for Ruby. But Ruby is the first language I genuinely enjoyed. I'd say Elixir is the second. Go.. not so much. There is a big difference I think due to expressiveness. I'd love to find something for Ruby to do for me now, but I honestly can't see why. That doesn't mean I'm not a real Ruby folk. I'm not married to any language or framework. I still do part-time work in Ruby.
Airtable
[removed]
Do you even need to use that gem any more? I thought you could use webpacker to hook everything up a bit more easily.
Yes. But you still have to write tons of code for React to work. Right?
Ah, I misunderstood your question. That looks to be about the normal amount of code in the tutorial.
Yes I meant easy enough. Webpack is just way too much config and messing around. ( Or may be I am just not good at it yet ) I got stuck in the mentality of having less dependancy. Since there is overlap in Webpack and Sprockets. 
But then you don't need a full SPA either. Especially for a form.. You can simply use rails properly and add the remote: true option to your form to submit it in ajax. And even for things which are not forms, you can easily spice it up with some js. But going full SPA has a lot of pain points too.
Thanks
Can try turbograph too, which allows partial DOM replacement. 
Neat structure. It makes me a bit cringy when people call their own work elegant, right in the title. Why did you go with unicode symbols? They will be a pain, and require whacky runtime conversion if this is to be used with most Extertal systems (like a db). For printing I might be OK with it, for arguments not a huge fan. 
Very clean and idiomatic. Thanks for sharing.
I wrote [something very similar](https://github.com/bakineggs/poker) many years back. It's cool to see how similar our solutions ended up being! :) &amp;#x200B; The difference between [Podos::PokerHand#card\_counts\_by\_rank](https://github.com/oguzbilgic/podos/blob/master/lib/podos/poker_hand.rb#L65) and [Poker::Hand#matched\_cards](https://github.com/bakineggs/poker/blob/master/lib/poker/hand.rb#L134) is a great example of the power little changes like Enumerable#group\_by can have (it was introduced in 1.8.7 and I was still worried about compatibility with 1.8.6).
Now you could write Crystal similar to what you could write in Ruby and at the speed of Go and C in some case.
If Rubyist were to adopt Crystal for performant and more type safe coding, it could have a better option than Golang.
I’m curious what your thought about Crystal language?
Interesting, the mentioned of qt5, I know Crystal has one https://github.com/Papierkorb/qt5.cr
I've seen Crystal before, it does look promising. However, I couldn't use it for a non-trivial project simply because it would be difficult to find developers as compared to Ruby or Go or even Elixir.
Ruby, PHP, Python etc. are just instruments for solving business goals. Here in Russia the popularity of ruby is low, it's hard to find a job as ruby developer, that's why a year ago I had to jump back from ruby to PHP. It's a big con. Ruby syntax is concise and beautiful. It's a pro.
Rosetta Code has a similar task with a Ruby example, (amongst other languages): http://rosettacode.org/wiki/Poker_hand_analyser 
Perhaps I missed something, but in the `two_pair?` implementation, you sort the array of `[2, 2, 1]`. Why not just compare to `[1, 2, 2]` is there a particular reason you need to sort that list?
Rails + UJS. 
Without breaking any rules in regards to privacy. Basic plan got removed, people got an email 40 days prior or so I believe of these changes they could contact us to find a solution e.g. scale down and possibly upgrade instances to maintain the same price or less. If you didn't contact us in that period you'd more than likely be moved to standard, in which you're more and than free to contact us to do th same to save money or keep the prices the same we're usually very understandable. Some people opt out of emails so they would of missed the changes so we also had a website alert on the side. Personally 40 days was enough time for my personal projects on there to be down scaled.
Now I’m inspired to do some refactors on some code of my own.
that doesn't care about multiplicity. 
Going full SPA is a horrendous amount of work! I've never found a way around that. Your options are: 1) let Rails be Rails and make a classic multi-page app, 2) try Turbolinks, 3) deal with the amount of work involved in making your front end an entire separate app.
That’s how devs pickup Crystal skill on the job if they are doing Ruby or Rails stuff.
if you know Ruby you can easily pick up Python and the other way. Python is like Communist Ruby (that may actually be a good thing in some contexts).
I spent time jumping between Python and Ruby earlier in my career. I wasn’t doing any big data, mostly web applications. I found I liked rails and Ruby’s syntax more than Python’s syntax. Just a personal preference. I liked that for every “do” there was an “end” and that I didn’t have to add self as the first argument for objects. Like it was mentioned above, if you know one the other is fairly easy to pick up. To make a decision you might also want to think about what you want to use the language for. Building web apps? Big data? AI or Machine Learning? These will have a larger impact on what tools and libraries each language has to offer. My biased opinion, learn Ruby :)
Lol. Good point. I'll just stick to Ruby. 
I have experience with both languages as an engineer in large corporations and it depends what you want to focus on. Ruby language and tooling is superior for everything web related. It's also a language of choice for many startups. Ruby's community is smaller but average Ruby engineer is further in his career (more skilled). Python excels in science and is more popular overall. If you worry about your skills not being portable then don't. As @TextileWasp mentioned it's really to switch between these languages. You can't go wrong choosing either, but if you ask me Ruby is more enjoyable to work with. Especially if you don't have to work with a badly written Rails app.
I like the idea of web development more. AI is definitely fascinating but I feel web dev is more attainable and what I find more interesting because the web has been such an influence on my life. It definitely comforts me knowing how easy it is to switch from comments here. Thanks!
I didn't realize it would be that easy to switch. I heard it was easy but I wasn't sure what "easy" meant. Thank you for your wisdom. I'm gonna code with my bud and stick with Ruby for the time being.
You’re asking on r/ruby. Prediction: gonna find a lot of Ruby fans :) 
ruby like python are no more than tools, focus on what you want to build not the spades.
It depends, programming isn't for everyone, contrary to what every media might try to spin it. Just like not everyone is good at maths. &amp;#x200B; And those who aren't gifted, programming languages actually matters a lot. For many, programming is hard, but there seems to be a a higher chance or probability that Ruby "clicked" for them. For professional programmers, they might think every languages is similar and have their pros and cons. But for beginner, the languages that really makes them productive and click matters a lot more. &amp;#x200B; So you really should try both, see which ones fits better for you. Once you get used to programming in general, moving to another language isn't actually that hard. 
The more languages you learn the easier it becomes to pickup new ones. You can never lose by learning another language whether it be Ruby or PHP.
Learn Ruby. Learn C++. Learn Golang. Learn ML or Common Lisp or something. Never doubt this: It is *always* valuable to learn a new programming language.
Lawful Good VS Chaotic Good
This is barely about Ruby or Rails.
&gt; A few years ago I completed Learn Ruby the Hard Way. Not a good idea to learn ruby from a guy who left it years ago and does not write idiomatic ruby. As for language switching I assume you have to evaluate both python and ruby. I did so myself many years ago and decided to go with ruby (but I also use python though less so than ruby). What made me use ruby was this ancient interview: https://www.artima.com/intv/ruby.html It's still valid today IMO and is the main difference between ruby and python.
&gt; Python is like Communist Ruby This is a problem because in theory communism would work for everyone; in practice it was always a few elite in charge establishing a dictatorship. Ruby really is not like this AT ALL so the comparison fails. Ruby is more like poetry and art combined in a practical way.
&gt; that I didn’t have to add self as the first argument for objects This always bothers me in python too - the fact that python is too dumb to know where self is and that I have to tell it about self. Python has a VERY strange way to do OOP.
Learn everything right? Because we have an infinite amount of time...
I guess he may be interested in the ARGUMENTS given.
That's such a non-statement. Any language is a "tool" but not every language is equal to the other one.
I disagree with your statement that only the elite can program.
It's not dumb, it's a design choice. Ever worked on a giant Rails app that autoimports a bunch of libraries? Then in some class somewhere method `foo` gets called and you have no idea where it comes from.
Ruby is not dead, Rails is not dead and your friend is an idiot https://blog.eq8.eu/article/is-rails-still-relevant-in-2018.html
Thanks for the reply.
You know what... It really depends. If you want to learn programming I'd suggest learning with ruby as it has some very useful inbuilt methods, this helps you to focus on the logic of your problem. But honestly as a language ... There are a lot of people using it still but I think those numbers are dwindling. But it doesn't matter so much about learning a programming LANGUAGE because for the most part it's just syntax. Learn the basic ideas of programming, such as loops, conditional statements, data types, errors, functional programming, object oriented programming... using ruby to do this is more than ok... then later on focus on learning specific languages. Infact given that the ruby community is one of the friendliest communities out there ruby is often the best choice of language to learn in. I started learning with JavaScript and ruby, and if I could start over again... I'd learn to program using java, c# or any strong typed language, as it's helped me immensely in understanding why (especially with dynamic typed languages) code design can be super important. Happy to chat more if you want to DM me.
Learning a new language becomes easier the more languages you know. I aim to learn a new language every other year or so. However, learning an ecosystem is not as easy. What packages are popular for what purpose? How do those packages work together? What build, deployment and monitoring tools are useful? Etc.
Stick with Ruby for now. Guy at work gave you a lazy answer. You’ll learn two types of things: - Programming fundamentals - How to use Ruby Popularity in scripting languages comes and goes. Python maybe be popular now, but in five years it will be something else. Ruby might even make a comeback, who knows. The fundamentals you learn from your friend (data types, logical statements, etc) you can use anywhere. I’m not a developer, I’m in IT doing more admin work. But I spent a couple years learning Ruby on the side. When I finally needed to do more Python, it was trivial to get up and running. 
As awkward as it is but I use ruby directly to handle things - including parsing commandline ARGV on my own. There is of course a reason why thor etc... are popular - getoptlong and optparse are so horrible. I hate both. The documentation is awful; and why is optparse called that way but you then use it via Optionparser? These little things make me mad; so I use ruby directly. It's a little bit more work to scan for entries in ARGV, admittedly, but the plus side is that I do not have to depend on any other random commandline parser thingy. I was contemplating writing my own but to be honest, what I usually do is write a menu() interface and throw everything at that, and inside handle things via a massive case/when menu acting on // regex options given. So I don't really need any fancy commandline parser anyway. Note that I set everything that is important and persistent via setter-methods anyway, so the "type" checking done by commandline tools I don't need either - my methods already make sure that all values are sane (or will be rejected, via notifications to the user).
No, you only pass in ARGV to this - skat_in_the_hat is right. I put executables under bin/ of my gems and inside these ruby files that don't have the .rb end I do things such as: Foo::Bar.new(ARGV) And class Bar handles this in the lib/ subdirectory. &gt; I want to be able to give params and args all on one line What is the difference between params and args from your point of view? ;)
&gt; Not all of what they said is great advice. Instead &gt; of putting that script in /bin Well, you can extend the above comment by stating that things should be installed via a gem. 
Ack ... ncurses. Do people really use this? I mean, really?
Careful - it may kill your sanity. There is a reason why things such as thor etc.. were created. optparse being so lousy is one reason as to why. :)
Good!
ping -&lt;parameter&gt; &lt;argument&gt;
Very good body of work, Mehdi. If you have not covered it already, one interesting topic would be the nuances of *setter methods* in Ruby,
It's like asking what car you should learn to drive in. Sure some cars are easier or nicer to drive than others, and each model has its own idiosyncrasies, but at the beginning the driving bit is more important. Learn data structures, common design patterns, and principles of object oriented programming. 
sloboda-studio :P that is a nice name
A good mentor is the best thing for learning. Really the best. I personally know both Ruby and Python, and find Python far more useful and prefer it nowadays. That being said, I am glad I know both and ruby will always be special to me. If you have a great mentor who can help you with ruby, go for it. Ignore your coworkers and bite their hand off.
I write python at work and ruby for everything else, including some stuff at work that nobody else will be asked to maintain -- dev-env one-offs, load tests, etc. All my personal projects are ruby. We are a Python shop so everybody here goes out of their way to shit on ruby, because, I guess folks knowing how to code with other languages is a threat to their rice bowls. But I love it. It is totally worth learning, especially if you know an expert who will make the learning curve less steep for you.
the communism part was a tongue in cheek remark. it was meant as: python is a bit less flexible (whitespaces anyone?) i have to agree with you that Ruby is like poetry. Not only that, but the syntax actually unlocks creative ways of solving things you didn’t even knew were possible
Language doesn't matter that much, but because you have a friend that can mentor you, I'd say that is a great reason to start with Ruby.
I don't understand what you're asking. I think you can learn ruby or python, if that's what you're asking. 
Your "if I could start over again" is interesting to me. I started out learning C/C++ and it almost drove me off programming for good. Hated the syntax, the seeming over-complexity to do simple things. It all felt like such a dreary chore. Years later I was forced to do some JS (actually UnityScript) in a more interesting context and realized that coding might not be so bad after all. When I found Ruby, I kinda fell in love with using it and writing software in general. I've always wondered how my life's trajectory would have changed if my foundations _weren't_ in a formal, statically typed environment. I'm a full-time software developer now, but I think I would have probably ended up in this career much earlier.
I think you might have misinterpreted what they said. It's not that only the elite can program, but some people are more cut out for it than others. Concepts just fall into place, the logic and reason behind it is more intuitive to them, the syntax and grammar isn't as confounding. What language they work with doesn't matter as much. Some people have to work harder at it, but still end up just as competent and skilled. Other people may take a lifetime of instruction and never really end up having it make sense to them. The biggest group is the one in the middle. For them, the language used can make a world of difference in how quickly they understand concepts, improve their skills, or whether they engage with programming at all. Each person is different and the only way to know which language works best for you is to try them out. Ruby and Python are both hugely productive languages and I definitely encourage anyone to try them. If you're getting back into development in general, though, choosing the one that creates the least amount of mental friction is probably going to be the best way forward. 
Use prepared statements instead, if possible. You can't SQL-inject a prepared statement. 
Yeah, my first thought was "Why!? Why!? Why!?" when I saw the unicode symbols. PITA for those of us who don't normally work with Unicode. My second thought was "well, maybe he had a backup, like 9C for 9 of Clubs", so I read the source. Nope: Unicode or GTFO.
Thank you, prepared statements feels like a much better approach than escaping characters. For my use case it looks like mysql2 is all I need, but what is the selling point for you for Sequel?
thank you very much for the cheers ! I'll try to release more articles in 2019 ! Merry Xmas !
Thank you very much ! Indeed, I covered this topic in this article: https://itnext.io/a-matter-of-attributes-668bdd29ad29 Merry Xmas !
Ruby will always be my day-to-day scripting language, the first language I turn to when I've got an idea for something. I never tire of coding with it. OTOH, a lot of fabulous software has been built with python. I'd definitely learn both.
I think we can hash it out and find array to help them out.
Good programmers don't limit themselves to one language.
I just love knowing what errors the methods will throw, what they return etc.... It's much easier I think to adhere to good programming practices when you're forced to lol.
Porque no los dos?
Not at all. That’s written in es5 and es6/7/8 really cleans up a lot of that. As far as getting react to work in rails. It’s no more code than writing a partial and adding the webpack flag on project creation. Just like with any project though the more complex things you’d like your project to do the more code you are going to have to write. I write a ton of react/redux and a ton of rails. I’d prefer to write all my front end in react on every rails project, but depending on the project it just can’t be justified all the time. React is just a tool and you have to decide if it’s the right tool for the job
A Christmas miracle :)
u/ioquatix what is the status with fibers improvments?
Yes it was merged. Details in the link above.
fantastic!!! I've read this for a while now: https://bugs.ruby-lang.org/issues/14739 u/ioquatix what are the next plans to improve the performance? :) I think fibers are and should become more ```in the news``` for rubiest
Thanks! It was a lot of effort and even for me quite a challenge to write assembler for several different architectures. Testing was hard too. I used a raspberry pi to test arm32 and arm64 for example. The next area for performance is better stack allocation/pooling. It’s low hanging fruit but required a consistent interface for coroutine which we didn’t have up until now.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [Ruby 2.6.0 Released - thank you everyone who worked hard for this release! (x-post \/r\/ruby)](https://www.reddit.com/r/RubyLang/comments/a9dw7g/ruby_260_released_thank_you_everyone_who_worked/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Except ... his bud has a Merc and is offering free driving lessons while some oddball from work is suggesting he learn to drive in a BMW without suggesting where a BMW or an instructor might be sourced.
Having a close personal friend available to bounce ideas off and steer you in the right direction is priceless. Given 2 tasks with otherwise identical complexity and learning curves, completing one with an experienced mentor will be an order of magnitude more enjoyable and successful than attempting the other alone, not to mention the added benefit of increasing the bond with your friend. 
I think you're right. Guy at work is so vehement about it I had to ask an unbiased group. Thanks. I think you hit the nail on the head. 
According to `ruby-audit` this version is vulnerable on arrival: ``` Name: ruby Version: 2.6.0.0 Advisory: CVE-2018-16395 Criticality: Unknown URL: https://www.ruby-lang.org/en/news/2018/10/17/openssl-x509-name-equality-check-does-not-work-correctly-cve-2018-16395/ Title: Incorrect equality check in OpenSSL::X509::Name Solution: upgrade to ~&gt; 2.3.8, ~&gt; 2.4.5, ~&gt; 2.5.2 Name: ruby Version: 2.6.0.0 Advisory: CVE-2018-16396 Criticality: Unknown URL: https://www.ruby-lang.org/en/news/2018/10/17/not-propagated-taint-flag-in-some-formats-of-pack-cve-2018-16396/ Title: Tainted flags not always propogated in Array#pack and String#unpack Solution: upgrade to ~&gt; 2.3.8, ~&gt; 2.4.5, ~&gt; 2.5.2 Vulnerabilities found! ```
**Pros:** 1. The biggest pro for me is Ruby's extreme strength for scripting. It is my favorite language for writing scripts. I will take it over Python, Perl, or Bash any day. 2. High degree of flexibility makes implementing any design pattern a breeze. **Cons:** 1. The lack of static type checking in my Rails monolith makes me insane. Tests are good, we need them. I need types now too.
This is why you should use bundler.
Try it on Heroku https://devcenter.heroku.com/changelog-items/1542
Have you reported it on the mailinglist?
No. Which mailinglist?
It seems like someone have already reported your findings here: https://github.com/rubysec/ruby-advisory-db/pull/374
Not mentioned is a performance improvement to `Dir.glob` that will significantly speed up Rails template lookup, especially notable in dev with many partials. https://bugs.ruby-lang.org/issues/13167 https://github.com/rails/rails/issues/20752
OK. Thanks!
Do you have patreon account ?
Markaby for the win.
I think you misunderstood my comment. I was not referring to `attr_writer` and `attr_accessor` but the fact that methods with a trailing equals sign can only take a single argument except for `[]=` In other words, calling `def foo=(alpha, beta)` will throw an error but calling `def []=(alpha, beta)` will not...
&gt;❤❤❤ Yay!
Cool. Though wouldn't it be much cleaner if blocks were evaluated in the context of a Tubby::Renderer instance instead of passing the instance into the block?
thank you for working on this!
From the experience with `markaby` (which does it the way you suggest), it is a hard trade-off. As markup-in-Ruby are best when used to create some small pieces of HTML inside normal Ruby classes (think decorators), you'll fall in all kind of nasty problems when evaling in another context. Imagine this: class UserDecorator def friendly_name [decorated_object.first, decorated_object.second].join(' ') end def badge build { span friendly_name # oops, there's no #friendly_name in current scope... # or, for example, I want to debug... friends.each do |friend| p friend # oops, I've meant Kernel#p, not &lt;p&gt; end } end end So, I believe now `t.&lt;tag&gt;` is a reasonable compromise.
Hm, That seems fair. I have no experience with markaby and potential inconveniences that it has with `instance_exec`. One thing I find useful though is to use `method_missing` and delegate messages to the calling scope. Like: ``` class Foo def initialize(&amp;block) @context = eval 'self', block.binding @block = block end def call instance_exec(&amp;@block) end private attr_reader :context def method_missing(method, *args, &amp;block) return super unless context.respond_to? method define_singleton_method(method) do |*a, &amp;b| context.public_send method, *a, &amp;b end public_send(method, *args, &amp;block) end def respond_to_missing?(method, include_private = false) return true if context.respond_to? method super end end ```
ok, thank you for the precision.
Did a search for this, but what is good about the JIT compiler? I’m not exactly sure what makes it useful or unique, but it’s at the top of the page and seems important. 
That's a good question. The JIT compiler has required quite a bit of internal restructuring to improve both non-JIT and JIT code paths. Ruby is highly dynamic, so it's hard to get the compiler to inline operations. I think this refactoring has been a useful exercise in order to appreciate what is required to get really good performance from a dynamic language like Ruby. I'm honestly not sure if the direction of the JIT compiler is going to yield good performance. When you look at how advanced some JIT compilers are (e.g. Node), you realise it's a lot of effort to get to native performance in general code. The approach used by Ruby is quite basic, but it also minimises the changes required within Ruby, which isn't a bad trade-off. JIT compilers balance the time required to compile the code vs the performance improvement of the compiled code. Based on what I can see happening, I think the assumption is that we can spend a long time to compile much more efficient code, with a minimal impact to the running system. The majority of Ruby code that would benefit from JIT compilation is things like long running web applications, so the potential pay off is quite big if it actually yields an improvement. I think the biggest issue will actually relate to Ruby itself: we already have a lot of native extensions. Therefore, JIT compiling the glue code might not make a significant improvement in performance. Additionally, I think it's a reasonable assumption that IO is one of the dominating factors in performance of web applications (e.g. client, database and filesystem). In the end, the dominating performance overheads might be elsewhere, the JIT compiler might make Ruby 10x faster, but it can't change fundamental designs relating to IO or CPU contention.
I do now! I'm also experimenting with Tidelift. https://www.patreon.com/ioquatix Let me know what you think I'm new to this.
Thank you for your thoughtful response! Helps to put everything in context more.
Anyone having issues with controller specs for Rails 4.2.10 and Ruby 2.6.0? &amp;#x200B; I test one of my gems against multiple versions of Ruby and Rails and the combination of Rails 4.2.10 and Ruby 2.6.0 is giving me a "Thread error: Already initialized" when running controller specs (error can be seen here: [https://travis-ci.org/vinistock/sail/jobs/472205140](https://travis-ci.org/vinistock/sail/jobs/472205140)).
You may be able to find some ideas on how to accomplish this from the cable_ready gem. I use this gem for all server triggered DOM mutations. https://github.com/hopsoft/cable_ready/blob/master/README.md
May I suggest a few lower levels? I don’t the possibility of any individual dishing out $600 per month, but a $5 and even a $2 - $3 level makes it much easier for folks to pull the trigger and support your work. Sure it’s not much but it adds up. Thanks for your work!
Okay, I added a $5 tier. Lower amounts incur higher proportional costs (due to flat rate transaction fees). So, a $2-$3 level might not make so much sense?
I only suggested the super low level because I’ve seen many successful patreon accounts offer them as a “throw me a few dollars, it’s less than a cup of coffee” level. Easy for people to pull the trigger which means cash dollars in your pocket. 😎
Okay that make sense, I added it.
Thanks friend. 
First allow me to say that the video starts with advertisement. This automatically qualifies it as utter trash. If you feel that you have nothing important to say, go run an advertisement. That way people can instantly know that the rest is not worth watching. I actually did not watch the rest of it so I don't know any of the "arguments". The link here also has absolutely NOTHING other than a video. I think this should be forbidden. There is no substance from the original poster, so why waste time if the original poster was too lazy to write anything?
Nice explanation of the new feature and future directions.
I don't mind &lt;&lt; so much but, boy, &gt;&gt; is ugly as fuck. One day we may have to go back to 2014 or so and reject lots of additions that shouldn't have made it into ruby. Then again, as long as one does not have to use it, these changes are not soooo terrible. I can avoid them and use what is good. Not all changes made were bad by the way. But this one - boy. UGLY. &gt; First, both JSONApiClient and XMLApiClient are tightly coupled to &gt; their parent and provide little functionality besides the functionality &gt; they inherited — meaning that any change to the parent class would &gt; probably break the classes inheriting from it. Inheritance is less flexible than composition; however had, if you write code where you break subclasses then you must be doing something wrong to begin with. I've never had that problem. &gt; Second,JSONApiClient and XMLApiClient are too specialized. &gt; Inheritance is all about specialization, but having too specialized &gt; classes can cause headaches Not really. &gt; they are hard to extend (when requirements change) Nope - trivial to change, JUST LIKE ANY OTHER RUBY CODE TOO. &gt; introduce unnecessary complexities (for a human, it’s hard &gt; to remember many different kinds of objects and what they do). Well - more code IS making things more complex. But if you have to think in terms of classes then you are already doing it wrong. You start by both the data structure and needs of the project at hand; then you design the APIs you wish to use. The rest comes on its own. &gt; We took an existing class/service/object/function and combined it &gt; with another to get more specialized behavior. This is the basic &gt; idea behind function composition. So HOW is this any different from subclassing/composition? WHY is it called "function" composition? These words don't even have much meaning on its own in ruby. &gt; The map method is of limited usefulness on it’s own. But when we &gt; combine it with a block (another function) it can transform whole &gt; datasets. Since when is a block a function??? &gt; In mathematical terms, f(x) &gt;&gt; g(x) is the same as g(f(x)) . So now ruby goes full-scale haskell? &gt; Note, if you want Elixir style pipelines that return a result &gt; check out yield_self or the new alias for it then . I still do not understand why people want to slap elixir onto ruby when the syntax is different. yield_self was a clumsy name; then is a better name even though it is quite non-descript. &gt; On the other hand, Proc#&lt;&lt; is more in-line with Haskell &gt; style composition AHA! Random Monad folks - now I know who lobbied for that change. Well ... if that were to make haskell folks use ruby ... but somehow I doubt it. Haskell folks love Haskell. &gt; Or, in mathematical terms, f(x) &lt;&lt; g(x) is the same as f(g(x)) . So, lost me there bro. I don't even want to have to decipher the single letters there nor the order of evaluation. That's even looking like lisp - we need more parens! &gt; Both &lt;&lt; and &gt;&gt; are basically the same, which one to use &gt; is only subject to your preference. Please - use &lt;&lt;. &gt; Function composition is very useful in languages that don’t &gt; have the concept of classes and inheritance Didn't he just say before that it is useful in ruby? But ruby has classes and inheritance so now I am confused.... fetch = self.method(:URI) \ &gt;&gt; Net::HTTP.method(:get) \ &gt;&gt; JSON.method(:parse) \ &gt;&gt; -&gt; response { response.dig('bpi', 'EUR', 'rate') || '0' } \ &gt;&gt; -&gt; value { value.gsub(',', '') } \ &gt;&gt; self.method(:Float) This is a wonderful example why this shit shouldn't be added - and why people who suggest this should not be using ruby. I am only glad that I don't have to write undecipherable mess such as the above. Even elixir looks better than this. What convoluted utter garbage - tell me that this is proper, useful design? You even have any idea what is going on in this code? Seriously? &gt; Since we do have inheritance in Ruby this kind of composition is less useful. He admits this - good. That code is completely fake. &gt; Yet it gives us the ability to create utility functions on-the-fly What the hell is a "utility function"? And "on the fly" man ... we already could add/remove methods as-is at any moment in time in ruby. So I don't see what was gained? Other than the possibility to use different syntax of course. Worse syntax - what a "gain" ... &gt; In my opinion, this is a big step forward for the language. It's a step backward. Because it is not necessary, ugly and absolutely useless. &gt; As its implemented now, composition sticks out like a sore thumb. &gt; The ecosystem needs to grow to accommodate for this feature. What does he even want to say? &gt; Constantly calling #method on a class/module is confusing and distracting Just use .send Or, even better - properly design your code where the code itself tells the right story. That is what C is doing too - the linux kernel literally tells a story as well. It does not have the same elegance as properly written ruby (aka not ruby written by ||&gt;&gt;-&gt; clowns who confuse ruby with a certain other language that uses such strange characters), but still. &gt; a short hand operator for this purpose would be welcome (I would &gt; propose &amp;[Json].parse). Yep, the ugly shit keeps on coming from certain people. In fairness, he is not the only one suggesting this. &gt; The map, reduce and other enumerator methods are hard to compose &gt; since they are implemented on an instance of an object — an Enum module exposing them would be nice. .map is trivial to use. .reduce is not so commonly needed. I don't get the "hard to compose" claim. I don't even know from which rock these clowns emerge. Are they actually REALLY using ruby? Because what they propose is so totally at odds with how you used ruby a few years ago ... you can see this on the ruby bug tracker too. I don't get it.
Ironically I find tests take away a huge advantage of ruby. I am not referring to all tests, mind you, but if you have to write more tests to ensure your ruby code works, then IMO you must be doing something wrong (I don't mean you specifically, I mean in general).
Ah ... written by judofyr. I remember that name - good ruby hacker. As for Tubby - it looks ok so far. I have not yet used it, only looked at the example. Will test it in the coming days. While the API isn't what I had in mind, it has some interesting ideas - as trivial as it sounds but I haven't thought of a .to_html method before. That actually makes quite some sense.
I had the same though. I can not answer that - perhaps judofyr had some specific reason.
This is a fantastic clarification, thank you!
&gt; t.&lt;tag&gt; is a reasonable compromise. Problem is that it adds syntax-overhead. 
I found method_missing in general to be difficult to deal with; the other part of your question is still valid IMO, e. g. why the "t." part is kept in the API.
Unfortunately, the direct answer is: It currently brings no added value to application developers. (Please correct me, someone, if I'm wrong.)
Unfortunately, the direct answer is: Nothing. It currently brings no added value to application developers. It hasn't delivered any benefits yet. The performance work was ditched because it wouldn't fit into the arbitrary Christmas deadline. (Please correct me, someone, if I'm wrong.)
So currently, the JIT's only effect is to hurt performance when used, is that correct?
Each language excels in its domain. ¯\\_(ツ)_/¯ 
So basically, very small little random tweaks, and a JIT which hurts performance under Rails. Does Ruby have a public development roadmap yet, or is this just what to expect?
"All my children are beautiful in their own way." :-P Sorry, that's a cop-out! Some languages can really suck, and that's ok.
Okay fine, python is fantastic for scientific computing. ruby is fantastic for web dev (and not much else). fight me :p
&gt; It rocks. Is small. Simple. I'll take this opportunity to give a shout-out to RSpec: All the RSpec users have already heard this Minispec rah-rah stuff. But honestly, it's not really honest. For anyone deciding between the two: * Minitest is a **library**, RSpec is an **application**: RSpec has a great command line interface and help text. Minitest's CLI is rake, which is difficult to use, overly wordy, and gives overly verbose output. * Minitest has a plethora of plugins and add-ins to give it the full features of something like RSpec. But when you use those (like most do), you've now got an application which is the size of RSpec but worse: it's much more complex because it's a big ball of wax, plus various plugins are in varying states of decay and disuse. I can go on. &gt; I've not seen any good reason for using Rspec in the last five years. Ditto, but for Minitest. No reason to use it. :-) And tired of the FUD.
Misleading title? Better to say **Tubby: Markup Tags in Ruby** When I first saw this in the list, I'd hoped it was a non-Rails-specific analogue to [`mbleigh/acts-as-taggable-on`](https://github.com/mbleigh/acts-as-taggable-on) or [`pat/gutentag`](https://github.com/pat/gutentag). (The latter is the most promising such tool I've yet found that isn't inextricably bound to ActiveRecord; I expect to start seriously poking at it in the next week or two). Our desire to not reinvent more wheels than we already have (e.g., see the newly-released [`jdickey/crypt_ident`](https://github.com/jdickey/crypt_ident) authentication Gem) is not nearly as strong as the imperative to *not* re-enter a use relationship with Rails. Suggestions welcome.
But nowhere near as well documented.
I can certainly understand where you are coming from. But remember, almost everyone who works on Ruby does it because they love it. &gt; very small little random tweaks Given how many hours I worked on improving coroutines for 2.6, this statement comes across as pretty harsh and uninformed. It's true that as lower hanging fruit is picked, it gets harder and harder to improve performance. Honestly, the caliber of developers working on Ruby performance is really incredible. It's not easy to change the interpreter, and it's easy to break a lot of software if we are not careful. &gt; a zero-day security flaw My understanding is there was a bug in the software reporting the CVEs, there aren't actually any known CVEs in 2.6.0 - feel free to correct me if I'm wrong. &gt; a JIT which hurts performance under Rails The JIT isn't my area, but it's an experimental feature which we can now test. Unless we gather such information, we can't make forward progress. It's a particularly difficult area. I think everyone wish there was a simpler way to gain significant performance, but it's unfortunately not that easy. &gt; My wish for Ruby that'll never happen: semantic versioning and honesty about whether it is or not. Please feel free to get involved here https://bugs.ruby-lang.org/issues/15456 
What testing-framework in any language _do_ you find nice to read? RSpec is the best I've seen (comparing to Python, Haskell, Elixir, Swift, Objective C)
In some cases it's an improvement, in other cases it's a disadvantage. Hopefully as the relevant developers gain more insight into the performance characteristics, more areas will be improved and less areas disadvantaged :)
(I think Python's chunky syntax is holding scientific computing back. But its low barrier to entry and good documentationg has encouraged use.) Ruby's weak typing does make it good for web dev. But I'm looking forward to the new crop of strongly typed web frameworks in Crystal and Swift. 
The comparison is between ruby and python though... not python and whatever :D
Thanks for the thoughtful and honest reply. &gt; almost everyone who works on Ruby does it because they love it. This goes for most of the popular programming languages. We can still be honest, avoid boosterism, and be publically accountable. There's a ton I love about Ruby, but I haven't gotten involved in the past because: * I saw core devs publically announcing, incorrectly, that Ruby is semantically versioned. * Matz is great, and Ruby is his project. Core development meetings and notes were carried on by an insular group of Japanese coders, and all notes were in Japanese. &gt;&gt; My wish for Ruby that'll never happen: semantic versioning and honesty about whether it is or not. &gt; Please feel free to get involved here https://bugs.ruby-lang.org/issues/15456 Matz really like the arbitrary Christmas numbering system and core Ruby devs defend it falsely as semantic. There is also no Python PEP-like transparency culture. It's cool, it's their game, they can do what they like, but this isn't a system looking for open participation.
Hey, tracychavez, just a quick heads-up: **publically** is actually spelled **publicly**. You can remember it by **ends with –cly**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
hEy, TrAcYcHaVeZ, jUsT A QuIcK HeAdS-Up: **PuBlIcAlLy** iS AcTuAlLy sPeLlEd **pUbLiClY**. yOu cAn rEmEmBeR It bY **EnDs wItH –cLy**. HaVe a nIcE DaY! ^^^^ThE ^^^^PaReNt ^^^^cOmMeNtEr ^^^^cAn ^^^^rEpLy ^^^^wItH ^^^^'dElEtE' ^^^^tO ^^^^DeLeTe ^^^^tHiS ^^^^CoMmEnT.
`method_missing` would never be enough to solve the problem. What about my `p` example (which is very real), or any other short name that HTML claims for itself? What about instance variables?.. def badge build { span @user.name } # Whoops, @user is not here end In fact, solving this kind of problems with `method_missing` is "pretending something behaves how it actually not", just making things more confusing. Generally speaking, there are two kinds of usages for "nested blocks"-style builder DSL: * when it is typically top-level (think RSpec or Sinatra) -- in this case, `instance_eval` is reasonable and desirable * when it could be called from some method of some class -- in this case, by the reasons given, it is better to not mess with the execution context.
You know, this last phrase is related to the rest of my comment. It is kinda logically following from it.
For me, the key parts of semantic versioning are: - Bump major version if breaking backwards compatibility. - Bump minor version if adding new features. - Bump patch version if releasing bug fix or performance improvements. All the above are advisory to a certain extent. Because you need to define "breaking backwards compatibility". e.g. If you have a public method but no one uses it, is it okay to remove it? We should try to avoid bumping major version too often because practically speaking it's hard for users to keep up. That doesn't mean you can't bump versions whenever you want. Of course, you can just arbitrarily bump version on Christmas. Sometimes it's good to have goals like that. That being said, it's clear to me Ruby needs to have a consistent mechanism for versioning across the entire system. I think most gems use semantic versioning, but as you say, it's not clear how many of the core developers respect such an idea. I think PEP is a good idea to a certain extent. The best we have right now is the Ruby bug tracker. It's the spiritual equivalent.
Or alternatively, combine both will be Crystal for speed and less memory consumption, suitable for both scientific and web development. We don’t fight, we love
Ruby is a great beginner language, I picked it up quickly after only coding in Java for about 6 months. If you want to do websites I would recommend the Sinatra library as it is simpler. 
I half expected the API to be restful but it seems like everything is done via GET? And most response codes are 403. I guess I really enjoy finding the appropriate http status code for every outcome when writing an API so I found the design behind the choice for these status codes and only GETs a bit off putting. Cool idea though.
Ruby is a very big and complicated language; /r/python is what I recommend as an introductory language since it's simpler.
No, Ruby on Rails is not a good choice to learn first. It’s too complicated. But ruby is a great first programming language! I recommend the book Learn to a Program by Chris Pine. I’ve taught several of my own kids to program—one now makes a living as a programmer and two are computer science students right now. 
Ruby is decent; it was the first programming language I learned. Problem with it is that the syntax is unlike most other popular languages today.. No curly braces, \`def\` and \`end\` instead. It was a bit jarring to go from Ruby to C#. *Rails* on the other hand is a web framework *for* Ruby and I would absolutely not recommend it to a beginner. Learn the language and the standard libs first, then start poking around at frameworks. If you want to get your feet wet with web stuff and you *really* want to use Ruby (not a bad choice, tbh), check out [Middleman](https://middlemanapp.com/). Its a static-site generator built with Ruby and you can go as deep into the Ruby side of things as you want.
You are right, this is one little aspect of it that is lacking, but this can easily be corrected :)
Thank you for the kind comment
I'd say yes and no. Yes because it is both good options for a beginner and a professional so he isn't learning some "toy" tech but diving straight into real world development. The con is that ruby is way magical and they may miss what's going under that fancy syntax. He may also find difficult to know what is backend and front end. So maybe a better option could be starting with some front end JS HTML and CSS and then add backend. I find front end easier for the beginner because of the instant feedback and that most errors are evident.
I love RoR but having it as the first experience could be really tough, mainly because: - enough magic happens that they’ll be lost when things don’t work, and debugging what happens in the framework will be a crazy ride - when looking for help, for any given issue they’ll find 50 different ways of doing it, and it still won’t work after picking one or two randomnly because of how their project is built. I know in this day and age it feels crazy, but if the first goal is to have “dynamic” page, I would recommand first using JS in the browser and/or building Node JS components as needed. Or let’s be crazy, use embedded PHP first, and move on to Sinatra or RoR when they understand the super basic stuff (variables, loops, making and calling functions, printing stuff and including modules)
Yes, yes it is. It's super easy and the skill gained is transferable to real life. Only catch is Rails suck at Windows (so Linux or Mac)
Part 1 / 2 \&gt; I don't mind &lt;&lt; so much but, boy, &gt;&gt; is ugly as fuck.One day we may have to go back to 2014 or so and reject lots of additions that shouldn't have made it into ruby. Then again, as long as one does not have to use it, these changes are not soooo terrible. I can avoid them and use what is good. Not all changes made were bad by the way. But this one - boy. UGLY. I don't mind all the additions. In my opinion it's better to have too many different features than too few, and I wouldn't like to force somebody to thinking the way I do (in terms of writing code) as we are all different - more people, more ideas, more progress. &amp;#x200B; E.g. I find both quite readable, but think that using both at the same time is confusing. Though, anecdotally, I can say that people are split on which one is better. People that worked with Haskell found \`&lt;&lt;\` to be better, and people that worked with Elixir found \`&gt;&gt;\` better. Different people, different tastes. \&gt; Inheritance is less flexible than composition; however had, if you write code where you break subclasses then you must be doing something wrong to begin with. \&gt; I've never had that problem. \&gt; &gt;Second,JSONApiClient and XMLApiClient are too specialized. Inheritance is all about specialization, but having too specialized classes can cause headaches \&gt; Not really. \&gt; they are hard to extend (when requirements change) \&gt; Nope - trivial to change, JUST LIKE ANY OTHER RUBY CODE TOO. I thought that the example pointed this out quite well. Say you change the output of \`ApiClient#get\` as all subclasses of it basically do \`def get; JSON.parse(super); end\` all of them would break. I'm not saying that composition solves this problem, but it points out a problem in this class hierarchy - \`ApiClient\` is so basic that it's likely to change more often than it's subclasses. In other words the \`ApiClient\` - \`JSONApiClient\` inheritance abstraction is arguably a bad decision. As I pointed out, dependency injection would, in my opinion, be a better solution. \&gt; Well - more code IS making things more complex. But if you have to think in terms of classes then you are already doing it wrong. You start by both the data structure and needs of the project at hand; then you design the APIs you wish to use. The rest comes on its own. I agree with that. But I think you are missing the point. I tried to point out creating too many abstractions through inheritance to solve problems is, in the end, confusing. You end up with a lot of objects that are all so highly specialized that it becomes hard to conclude which one to use in which situation. What you described is the general idea of software design. I tried to point out that moving to an extream is bad. \&gt; So HOW is this any different from subclassing/composition? WHY is it called "function" composition? These words don't even have much meaning on its own in ruby. &amp;#x200B; It isn't, that's what I point out in the continuation of the article. The functionality that \`&gt;&gt;\` and \`&lt;&lt;\` provide is called function composition, While Ruby does not have "functions" it does have procs and lambdas, which are fore all intensive purposes "functions" - they provide computation and aren't defined on an object. I think I linked to the definition in the article. I make the distinction because in CS there are many different kinds of composition, so I didn't want to confuse people. \&gt; Since when is a block a function??? &amp;#x200B; This is explained in the previous paragraph of this comment. \&gt; So now ruby goes full-scale haskell? \&gt; I still do not understand why people want to slap elixir onto ruby when the syntax is different. yield\_self was a clumsy name; then is a better name even though it is quite non-descript. &amp;#x200B; I wouldn't say that. Ruby is borrowing what's good from other languages. In my opinion that's a good way to improve the language - by copying over what has been proven to be good in other languages. \&gt; Random Monad folks - now I know who lobbied for that change. Well ... if that were to make haskell folks use ruby ... but somehow I doubt it. Haskell folks love Haskell. I don't know where this came from or where this is going, but I won't go into this straw man argument. \&gt; So, lost me there bro. I don't even want to have to decipher the single letters there nor the order of evaluation. That's even looking like lisp - we need more parens! &amp;#x200B; That's just pseudo-mathematical notation for coposition that we learned in 5th grade. No need to make a tantrum. \&gt; Please - use &lt;&lt;. I'll use what I want :) I don't think that one is objectively better than the other, so use which one you see fit. If you want to use exclusively \`&lt;&lt;\` then more power to you. \&gt; Didn't he just say before that it is useful in ruby? But ruby has classes and inheritance so now I am confused.... &amp;#x200B; It's explained in the continuation of the paragraph you quoted.
\&gt; This is a wonderful example why this shit shouldn't be added - and why people who suggest this should not be using ruby. I am only glad that I don't have to write undecipherable mess such as the above. Even elixir looks better than this. What convoluted utter garbage - tell me that this is proper, useful design? You even have any idea what is going on in this code? Seriously? &amp;#x200B; The quoted code is a contrived example of what is possible, or how it is possible co compose functions. Regarding the "looks worse than Elixir" part, yes it does, that's the conclusion, things need to improve for this feature to shine. The above example is of limited usefulness in any real-world scenario, but the same principle is quite useful in my opinion. \&gt; What the hell is a "utility function"? And "on the fly" man ... we already could add/remove methods as-is at any moment in time in ruby. So I don't see what was gained? Other than the possibility to use different syntax of course. Worse syntax - what a "gain" ... An "utility function" is a function that provides some kind of utility, e.g. "I need to strip the whitespaces, capitalize the first word and lowercase all others, and capitalize the last letter, for a bigger part of my code", or "a function that converts all hash keys from strings to symbols" - it's not directly useful but it serves a purpose. &amp;#x200B; I found Elixir ugly in the beginning, but over time I grew a liking to the pipeline syntax as it made more sense and provided "composability" (in the broadest sense of the term - that's why it's in quotations). We did have way to define methods on-the-fly (I think that you ment to say function/proc instead of method), but it was clumsy when you wanted to combine two together - not clumsy as much as laborious without any real benefit of the labor. \&gt; It's a step backward. Because it is not necessary, ugly and absolutely useless. It's a quality of life improvement, it's ugly to you (this is your subjective interpretation), and it's as much usefule as the old way of doing it. \&gt; What does he even want to say? &amp;#x200B; This is explained in the continuation of the paragraph you quoted. \&gt; Just use .send &amp;#x200B; How does this lesser the confusion? Can you provide an example / explanation? &amp;#x200B; \&gt; Or, even better - properly design your code where the code itself tells the right story. That is what C is doing too - the linux kernel literally tells a story as well. It does not have the same elegance as properly written ruby (aka not ruby written by ||&gt;&gt;-&gt; clowns who confuse ruby with a certain other language that uses such strange characters), but still. &amp;#x200B; As addressed in the beginning of this comment, you are missing the point. Not only that buy throughout your article you have switch topics and created many straw man that serve no purpose nor do they go against my claim. It's getting increasingly laborious to address them. But here you have switched again, ignoring everything the article pointed out and made the same claim twice. \&gt; I don't get the "hard to compose" claim. I don't even know from which rock these clowns emerge. Are they actually REALLY using ruby? Because what they propose is so totally at odds with how you used ruby a few years ago ... you can see this on the ruby bug tracker too. I don't get it. &amp;#x200B; Well, \`\[1,2,3\].map { .. }\` can't really be composed with anything. And I can't pass an argument to \`map\` over which a block should be applied. Say you want to pass an array to map over with \`-&gt; x { x \* 2 }\`. That's not really possible without some kind of utility like I wrote and linked to in the article.
Ruby lost because we forgot that with every year we have more data and users to process. We foolishly chose dev happiness thinking that Ruby wont be affected by the biggest force in the market...demand. The market demans faster language and the market demans language capable of doing much more than what Ruby offers. There are fragments of those in the ruby community but not a single dictator capable of improving them to a point they are able to compete with other langs. Too bad it was good while it lasted.
I've actually tried this approach earlier (see [this test file in a branch in Mab](https://github.com/camping/mab/blob/wip/test/test_mab_component.rb)) and it turns out that cleanness of avoiding `t.` is not worth it. Here are some things that "just work" in Tubby: - You don't need to inherit or include/extend anything to use it. This means you'll never have a conflict in method names or instance variables. - There is no magic forwarding `method_missing` or "automatically copy instance variables inside a dummy object". `self` is exactly the same at the inside as on the outside of the block. There's no surprises (like `t.p` vs `Kernel#p`). - Very clear API: You create a new template with `Tubby.new`; this template you can pass around like a regular Ruby object. This opens up for some interesting patterns in the way you do layouts or composition. I'm planning on writing an article that shows the various ways you can use Tubby. The README doesn't quite capture how you end up building an application in Tubby.
Hell yes. Ruby quickly evolving and Ruby on Rails too. Rails is also a great frameworks supported by big companies. Sure, there is a lot of magic behind Rails but I think you'll discover during all your career with this framework. Also, the community teach you best practices like: - clean code - Don't Repeat Yourself (DRY) - Test driven Development (TDD) So my advice (for what is worth) is go learn Ruby!
I'm not sure where I picked up the idea of `#to_html`, but now I wish everyone used it. I actually often end up doing `HTMLSafe = Struct.new(:to_html)` and now I can do `HTMLSafe["foo"]` to quickly mark strings as HTML safe. Such a simple API which is safe-by-default and easy for other libraries to opt-in to.
This is not connected to the comment you made here, so others can freely ignore it. I saw your comments on other posts, come across as childish and closed-minded. That's why some redditors have decided to ignore your opinion or not talk to you altogether. In your comment you made several tantrums that serve no purpose but dramatic effect - they don't argue the validity of my claims, nor do they show a contrary claim that has any substance or proof attached to it. You also like to use straw men arguments - arguments that go of on a tangent that prove something else is correct and then you try to extrapolate that therefore the other claim you made is also right. This is a logical fallacy. E.G. Because Haskell people like Haskell, that doesn't mean that Ruby can't have FP features, or that FP features in Ruby are inherently bad. You propagate your opinion as the only right solution. While this may objectively be the case in some situations, your claim is worthless without argument so try to back your claims up - the burden of proof is on the one making the claim. This why you come across as childish and close-minded. Lastly, cursing and swearing doesn't give validity to your claim, if anything it subtracts from it. When you curse, swear and call names you come across as unable to produce an argument that goes in support of your claim or against my claim and therefore you resort to calling me names, to discredit me as a person - not my argument. This is called an "ad hominem" argument and is also a logical fallacy. E.G. Just because I'm a "shithead" doesn't mean that what I sad is wrong.
No - it's bloody terrible. Ruby is a wonderful language for an experienced dev, but there are a number of drawbacks as a first language: * **Non-C-like syntax means fewer "transferable skills" to other languages**: Learn C and you have a leg up on every other language with similar syntax. Learn ruby and you only know ruby. That's not a problem for a second or subsequent language, but a beginner needs all the encouragement they can get try diversify beyond their first language and avoid becoming a monoglot. * **Comparatively cryptic/seemingly-ambiguous syntax**: the idiomatic lack of parentheses around method calls, implied hashes, message-passing OOP rather than not traditional function-calling, etc. It's a wonderfully expressive language for a master, but beginners need simple, clear, unambiguous tools that minimise reliance on human tokenisation of code, operator precedence, etc. * **Emphasis on metaprogramming**: Idiomatic ruby isn't so much concerned with solving a problem as with defining a DSL that then allows you to solve *all* problems of that type elegantly and quickly, and then using it to solve your particular problem. Ok so I'm exaggerating slightly there, but compare a well-written idiomatic ruby program to an idiomatic Java one and it's like comparing an all-you-can-eat buffet to a microwave ready-meal. That abstraction and indirection comes with a price, however, and that price is difficulty of comprehension for newbies. Even if you learn ruby as a first language (instead of something more common like python/javascript/java), **for the love of god** do not attempt to learn Rails at the same time. Rails is a collection of different DSLs written *in* ruby, with huge quantities of deeply impenetrable magic going on all over the place, so trying to learn half a dozen domain-specific languages *at the same time* as learning ruby itself is a recipe for confusion, frustration and giving up in disgust. When you're ready to learn ruby learn ruby, and then once you have a handle on it learn Rails.
Hah, I honestly didn't think about the multiple meanings of tags when I wrote the title. Tagging is a very ORM-dependent problem though. I'm not quite sure how useful it would be to have tagging library that isn't coupled to an ORM? Personally I often end up re-implementing it for my exact use case. There's so many different choices (are your tag names just a string, or is it a reference to a `tag` table; can different models be tagged, or is it only one?; what types of queries do you want run?).
Where do you host ruby website projects like this? I always used Heroku for Rails and Sinatra hobby stuff, but its actually expensive if you want to run a small site without downtime. 
Cool. I think that you and @zverok_hka are probably right about the awkwardness/problems that may occur when you start messing with `method_missing`. I personally like code that looks pretty (that's why I love ruby), but if you are writing an open source library then it's better to make thinks as robust as possible. Great work and thanks for sharing!
no because I think learning programming means learning about: - control flow - program stack - data structures - algorithms rails typically hides most of those things behind very high level concepts. Also rails is useful once one understands a lot of extra stuff related to web app development, also not related to programming. ie relational databases, CSS, http protocol etc. You can follow some tutorial and create a functioning website. I guarantee you won't know why or how it works or what those things were are you had to copy to different places from the tutorial. I would recommend something that's a slim library or tool and learning about it is not overwhelming and allows one to concentrate on programming concepts rather than the library. I have not used it but first thing that comes to mind is https://www.libgosu.org/. Otherwise Ruby is a great language. After learning about 20 something languages in many different paradigms I like Ruby the most. I don't believe in "first language" or beginner language thing. Ruby is complex, but worth learning, as it's concise, elegant, very expressive.
Middleman, like all static site generators, output the website as static files (html, css, js, etc). Middleman takes your erb, sass, and coffeescript files and effectively "compiles" them into html, css, and js. So you would host it via a web server such as nginx. Well, you can host it from S3 if you wanted to. Generally speaking, a _website_ doesn't have need for a "backend" such as Rails or Sinatra unless you are interacting with data. If all you want to do is create and host a personal website or something comparatively simple, use a static site generator like Middleman. 
Ah right. Ok thanks!
Most of us here are Rubyists, so you'll probably get a "yes" from us ;) Personally I think [Ruby](https://www.ruby-lang.org/en/) is a great language, that said the framework [Ruby on Rails](https://rubyonrails.org/) shouldn't be your starting point as it brings in a lot of advanced concepts which increase the learning curve. A better starting points would be [Sonic Pi](https://sonic-pi.net/), which lets you write music with Ruby.
It’s great choice. I was thinking about giving 1vs1 online lessons. If you are interested please ping me. I would like to put myself in a teacher shoes so I believe that it would be beneficial for both sides. A while ago I saw a video of guy who did an live-cast “how to build start-up with Rails in 1 day”. his plan was really ambitious. I noticed that he knew what he need to use, but he struggled with asking google in a right way to get an answer. I think it comes with experience, so having an mentor would be really beneficial. Good luck!
Have you considered Python?
In my opinion all languages are good languages to know because it's still diving in somewhere and learning the fundamentals etc. However, Rails has a lot of helpers and does a lot in the background for you which can stitch you up if you want to move over to other languages. It also means if something goes wrong finding what that is can be harder because of all the bits and bobs it does for you in the background. I worked for a company for a little while that develops with Rails and I didn't really enjoy developing in Rails. But find what works for you, do what you think will suit you and your style and like I said, no language is a bad language. Some people just work better with others. 
Python has been at the forefront for quite some time. But I can say that, in 2018, the gap has narrowed, mostly due to a new (even if not there yet) JIT and Amazon lambda support, while python hasn't caught new ground and people still complain about 2 to 3 migrations. 
Dumb post, it’s not a popularity contest. Do what you enjoy.
How much do you think strict semantic versioning will actually improve anything about day to day development with ruby? I can't figure out why that would matter.
Ruby as a language? Yes. Ruby on Rails as a full stack thing for a novice to take on, probably not. I teach computer science to k-12 students, volunteer two days a week in a high school com sci class, and run a nonprofit on the subject. I think Ruby is a great first language for learning computer science topics. Rails is a great framework for developing web applications, but developing web apps means: - understanding html - understanding css - understanding the fundamentals of databases - understanding the request/response cycle of the nature of the web. And a whole lot more. Rails glosses over all of that, gluing it together in a way that is convenient for someone who knows all of that and wants to work at a higher level, but creates more mystery than it solves by hiding it all from a beginner. If you gloss over all that as a beginner, your only exposure to learning it is when something is going wrong... which is the worse possible time to do so. 
Great stuff! I'm curious, I seem to recall a proposal to tie IO operations into fibers. The idea, as I understood it, was that fibers could be suspended by ruby whenever they commence a blocking IO operation. I don't know if I understood that feature proposal correctly, but if my memory is accurate, this would bring a lot of new utility to fibers. Presently, it's hard to justify cooperative multitasking (fibers) because it's too easy to introduce a blocking IO call that ends up blocking every single fiber within a given thread. Does any of this ring a bell? (It's possible I'm just off my rocker here)
As much as I love ruby, this is the correct answer. I don’t understand why you’re being downvoted.
What do you think gives python a lower barrier to entry than ruby? Not disputing it, just trying to figure it out. 
python isn't really any faster than ruby. I agree that python has become much more popular than ruby. I'm not totally sure why, I don't think it's because of any inherent strength of python. 
It's r/ruby and I'm arguing (in some aspects) against ruby. It's not *that* surprising that fanboys with an unnuanced vie of the language would take offence at that. ;-) Hammers are great for banging in nails and poor for screwing in screws, but if you post in r/hammers advising people against banging in screws with them, some hammer fanboys are always going to get bent out of shape.
Now that's interesting.
Yes
I tend to agree with a lot of what's said here. &gt; The con is that ruby is way magical and they may miss what's going under that fancy syntax. This is a rather serious con. I've been programming Ruby and Rails for well over 10 years and find this as confounding and challenging as day one. Not to muddy the water too much in this conversation, but I find this so continually confounding and a source of bugs that I'm working towards jumping ship to something like Elixir. It's as expressive and much easier to understand the behaviour of a system (so far in my limited experience).
You're asking the ruby subreddit, so everyone is going to say yes. Personally I love ruby (especially for scripting) but I'm not a huge fan of rails (it hides a lot and is very opinionated). Ruby is a language known for its dynamism and flexibility, which I'd argue aren't features you can appreciate or use well without some experience. For a first language (i.e assuming _no_ experience), I'd opt for something boring and declarative like Java or C#.
Where did you infer that from my post in the first place ? Afaik python was always much more popular than ruby and that gap became wider with Ruby not having a corporate backing. Python had universities, Google and others and it managed to grow ecosystem much more than Ruby. Ruby beyond Rails/SysOps did not grow as much as Python. What is funny Ruby did not even have a chance during the python2/3 split because of lack of vision. 
RubyOnRails is magic and has a lot of fancy syntax. Ruby does not. I would recommend they learn ruby with sinatra and then move to rails personally. OP was asking for a programming tool as opposed to a frontend tool. I use Sinatra/Ruby everyday, but do zero front end work and never touch rails.
We can definitely trust a code boot camp to produce an objective comparison between two programming languages, right?
I think, unix shell and C should be the first, then any fancy language you wish.
Want a user key ? :)
I would recommend something like Lua because it has fewer concepts and you could immediately work on something interesting like a mod for a game.
I agree completely. Rails is fantastic, but any web framework is not a good way to introduce beginners to programming. Also, the lack of parentheses and proliferation of colons confused me immensely when I was first learning Rails (without learning Ruby first) as an experienced programmer in 2008 or so. This kind of DSL was pretty hard to parse: ``` # Ruby 1.8 foo :bar, :baz =&gt; "baz" { |fee| fee.fi } ``` 
There is a blog post here which discusses the various issues: https://www.codeotaku.com/journal/2018-06/asynchronous-ruby/index You are probably thinking of https://bugs.ruby-lang.org/issues/13618
¿Porque no los dos?
I think yes. With Rails easy to build the first application real quick, when you see the result you have the motivation to explore language further. That thought from my experience.
Thanks for the response! &gt; Blocking is inevitable, it just depends on what level you will implement non-blocking behaviour. IO is a big source of latency and easy to use event reactor to mitigate. The OS provides primitives which make it easy to schedule and the latency is big enough that it's a net win. I'm not sure I follow. The problem I'm referring to is when there are multiple fibers running in the same thread, and one of those fibers fails to yield, causing the entire reactor loop and every process running atop it to hang. Blocking IO is merely a common cause for a fiber failing to yield (or at least, failing to yield in a timely manner). A fiber could also sit in an infinite loop and cause the same problem -- in the end, this is just the inherent weakness of cooperative multitasking we're dealing with. Anyways, it seems like fibers would be a lot more useful if ruby's IO layer could yield fibers whenever they are about to kick off a blocking IO operation. I'm curious what OS primitives you're describing. My days of hacking kernels, writing assembler, and looking up system calls in man pages are way behind me, so I'm suspicious that I've missed an important development in systems programming :)
&gt; The problem I'm referring to is when there are multiple fibers running in the same thread, and one of those fibers fails to yield, causing the entire reactor loop and every process running atop it to hang. Right, so, you are not wrong. I just tend to take a more holistic view of how this all fits together. Let's take your specific example. An infinite loop. Actually, infinite loops should have a yield operation at the end (and this can actually be entirely automatic by the VM). So, this should either be a non-issue or a bug. If you have a loop which can go forever, in `async`, you need to add this manually: https://github.com/socketry/async-http/blob/9f4a312ebf7eb4cda950bd01e0b6290b1e998c8c/lib/async/http/protocol/http1/server.rb#L63-L64 If, on the other hand, you have a loop which DOES terminate, you are simply making a latency/throughput tradeoff. You can decide if you yield every iteration, every 10 iterations, etc. Eventually the loop will terminate and other tasks will be allowed to execute. I tend to look at this kind of blocking behaviour as being similar (but on a different scale) to network IO, disk IO, memory IO, instruction decode, etc. Each level requires different trade-offs and has different performance characteristics. &gt; I'm curious what OS primitives you're describing. The typical one is [select](https://linux.die.net/man/2/select). The `select` system call takes a list of file descriptors and waits for an even to occur for up to a specified timeout (or indefinitely). `epoll` and `kqueue` are more advanced versions which allow you to create an OS data structure which you add and remove descriptors from. This avoids sending several thousand (or million) descriptors to the kernel for every syscall, which as you can imagine, doesn't scale very well. 
When I was learning to code, my friend gave me the best advice on picking a programming language, "Pick one and get really good at it. The choice doesn't matter - but the dedication does." I picked Ruby because I thought it was elegant and weird. I'm still really glad I did.
You might want to look at [Hyperstack](https://hyperstack.org/) if you are interested in ruby + react.
Because of stuff like this: https://github.com/ruby/bigdecimal/issues/114
This thing's driven me up a wall in the past, found a way to fix it, and perfectly happy to hear there's a much easier way to work around this.
I don't think you need the brackets... Without immediately knowing anything else about your code, that seems like an understandable concise line of code.