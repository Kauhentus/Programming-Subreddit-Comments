Friends Sharing this with you team will be great
Thanks for the great example. I second your last paragraph, I've seen it happen in small companies where a few of my friends work: the programmer used metaprogramming for simple use cases where there absolutely no need, so they fucked up the rest of the team (and the company). I have used too dynamic function calls, using method_missing etc. but never beyond this. I am trying to understand If this is a pattern that will help me solve problems and not create new ones. I guess that you are using the example you posted in something like an API for the clients? Because in other cases, couldn't `define_singleton_method name` be transformed to a single method with the `name` as an argument? 
So why didn't they use `def find_by(:id, 12345)` instead of creating new methods for each call and causing system bloat? What If I want to call 10 times `find_by_name`? Will I create 10 methods instead of 1 ?
One example that comes to mind is database drivers - you might load SQLite in dev but Postgres in prod
Why not use def filter(ft) if ft == :short arr.select(&amp;:short_filter) elsif ft == :long arr.select(&amp;:long_filter) end end Only issue I see is when filters amount is big e.g. 20 or 30 of them. But still in this case it can be simplified without having to use metaprogramming.
thanks for the links, I am checking them out.
What is the difference?
 Fooinstance.active? =&gt; true Vs Fooinstance.state == Foo::active =&gt; true 
It is shorter (less code) and arguably easier to read (more semantic / declaritive, that is, telling you what and not how). I'm not the original author so just a guess (or my humble opinion/understanding).
No? They’re not creating the methods on *call*, they’re creating them on class load. You can’t have multiple columns in a table all called name, so you’ll only ever create the one `find_by_name` function. I believe they also used `method_missing` to do the right thing with functions on call like `find_by_name_and_age` etc. Internally these probably *did* call a function like `find` with ages for column names, how to join, how to sort and order, limits etc. But the developers thought that a function where a lot of that was in the function name would be easier to read and use. Then they went with their newer format, which I’ve completely forgotten the name of...
An example I've done recently involves a reporting application in Rails. Depending on the report, it will accept certain parameters that needs to be cast into a particular type (eg. Date), and if params are missing defaults may need to be defined. Using metaprogramming, the parameter-related methods were condensed into one-line declarations backed by the .param and .cast methods in the base class, which looked something like this: class SomethingReport &lt; BaseReport param :start_date, :date, default: -&gt;{1.week.ago.to_date} param :end_date, :date, default: -&gt;{Date.today} # rest of the class end Without metaprogramming, the class would be much less readable: class SomethingReport &lt; BaseReport def start_date=(date_str) @start_date = (self.class.cast(date_str, into: :date) rescue nil) end def start_date @start_date || 1.week.ago end def end_date=(date_str) @end_date = (self.class.cast(date_str, into: :date) rescue nil) end def start_date @end_date || Date.today end end
In addition ot /u/ScootsMcGootz's excellent reply: When you use `bundle install --without production`, bundler will create a `.bundle/config` file where it will note down your local bundling preferences. Thus, make sure to put this filename in `.gitignore` before pushing your project to production; otherwise, your production setup will ignore those gems too.
What's wrong with ``` find . -wholename '*/.git/config' -exec sh -c 'cat .gitconfig &gt;&gt; "$1"' -- {} \; ``` ?
I’m sure this was fun to build, but why wouldn’t I just use global git config?
Its true that a lot of times you can accomplish the same thing by being more direct. The example being discussed right here is called "macros". There's a lot of different type of meta programming you see in the wild. [Here's a list](https://gist.github.com/Integralist/a29212a8eb10bc8154b7) that tries to classify them. Keep in mind that performance is not always the ultimate goal. If that is all that matters to you at all costs, Ruby is not a good fit. Ruby's primary tenant is to delight the programmer. Thus, it is common to sacrifice a sliver of performance for a pound of ease and delight. As mentioned in another comment, it's common to use meta programming in libraries because it has potential to make your library much more accessible. It's not just a matter of "I'm making it so entry level programmers can use this", it's also often to save an incredible amount of time and reduce errors. Often times the logic sitting behind metaprogramming is very detailed and error prone, and certainly not something I want to be thinking about and rewriting when I have a business problem to solve. It makes fewer lines of code that I write, and thus, likely, fewer potential bugs related to that code. And relative to the difference in performance, it's almost certain that I wouldn't notice the difference anyway. Of course, it can get out of hand, but so can anything.
&gt; 20 or 30 of them Exactly. I wrote you a very simplified example, with the only difference being a select block. My point was that when you have lots of these, and they follow a pattern like I described, it's useful. But my example is trivially easy on purpose so you can see the pattern, without having to enumerate the kinds of options where metaprogramming is useful.
Wrong sub buddy.
Something like a monitoring service (New Relic, Rollbar, etc) you wouldn’t need to load in dev or test environments. That’s the most common one I’ve seen.
In a hub directory that contains multiple git projects
Kind of irrelevant comment I'm about to make. AirBnB is one of the best designed, worst implemented sites ever. It's so damn slow. I would love to know exactly where their failure is in terms of performance. Namely is it application layer or is it persistence layer. From using the site, I find it really hard to tell.
Yeah I can agree with that. It's pretty much an abstractions issue: if you have metaprogrammatic code commingled with other code in a single entity, you almost by definition are operating at multiple levels of abstraction in the entity. So you should extract one or the other and encapsulate better, and at that point you've just tacitly pulled out a library.
&gt; something like an API for the clients Yeah, exactly. This pattern allows me to define a clean, simple, and semantically-distinct API. &gt; couldn't `define_singleton_method name` be transformed to a single method with the `name` as an argument? You wouldn't even need to do it that way. If I wanted to achieve the some functionality without metaprogramming I could have just done: class ResourceResolver def self.all_resources -&gt; (opts, args, context) { ... resolution logic ... } end end and I would have achieved the exact same functionality. But I find this to be a lot less clear in the `ResourceResolver`--in particular, it's not clear why in the hell I've wrapped the logic in the lambda (that's enforced by the GraphQL library I'm using), and it creates a goofy coupling between the resolver and it structure I don't like. Plus it still allows for anti-patterns. So the metaprogramming both decouples resolution logic from the GraphQL API layer, and helps enforce stronger code in other places.
I'm speaking at this one over some fun subjects around === and pattern matching for ~30m this Tuesday. The slides will be posted to that group a bit later once I clean them up and flesh out the speaker notes to act as a psuedo-tutorial.
Control + Z works.
I think you're looking for the interactive shell, or the read evaluate print loop (repl), which is irb rather than ruby. If you're trying to run a ruby script, then it's ruby &lt;filename&gt; Hopefully this helps...? 
Recently we had to remove N+1 queries from our (relatively small) app, it took us a non-trivial amount of time to track everything down. (They're not as easy to spot as they are in these examples, `AcitveModelSerializer` for instance is a huge offender in generating N+1 queries.) So naturally ROM.rb is something I've been wanting to try out for a while now ;) Thanks for posting the video, for $10 that ebook is an insta-buy.
Looking beyond the database-backed models (without saying it's not an issue), do you not think that the mixing of so many concerns into a single object is an issue? Personally, I find it hard to maintain when following the conventional "Rails way", with conditional validations and attributes that only make sense in a specific context (think email/password confirmations in a registration form), following these patterns in my code has made it a lot easier to reason about and maintain down the line, and, as mentioned, easier to test. Regarding testing, I guess what you stub depends on where you consider the boundaries to be, or what you consider to be a "unit", for example, I wouldn't stub in a controller test unless it's an external service over HTTP or the likes (as you mentioned), but following the practice of not merging without a successful build is just painful in a monolith when you let the majority or all of your tests hit the database.
Yes, the e-book is a bargain, if you do end up trying the rom-rb or dry-rb stuff out, you should check out the Gitter channels, a great place to get help when starting out I've found. https://gitter.im/rom-rb/chat https://gitter.im/dry-rb/chat
Having worked on applications that didn't have trivial business logic I arrived at the completely opposite conclusion: hitting the database in unit tests has huge performance impacts. It can lead to a test suite taking 10, 20, 60 etc. minutes, during which I cannot do anything. Unit tests are meant to be fast and they're meant to be run constantly.
Actually, they probably ARE created on call, via method_missing, but once they are created, the method is no longer missing! As a result, only the methods needed are actually created. It creates a syntactic suger. That said, I think Rails made that syntax deprecated in favor of `def find_by(:id, 12345)` 
That's just another case where test factories create huge performance impacts.
Have you properly installed Ruby on your computer? Also, for a local environment, I suggest getting Ubuntu or looking at ways to run Ruby on a virtual machine. Although Windows has become much more Ruby-friendly as of late, I think you'll have a better experience with a different setup.
Interesting video. I agree with a lot of this, particularly the ease of accidentally causing N+1 queries and database-calling code spilling into places where it shouldn't be. I don't think that the directory structure of a Rails app not having changed in a long time really counts as a serious issue, though. There are often arguments for evolving and changing such things but I appreciate the stability of knowing where things will be in any rails application. If we look at the JS community, things are constantly evolving, and in the real sense of the word "evolve" - it's messy, there are tonnes of competing approaches which get a lot of attention only to die when the next attractive landing page appears, the same solutions appear over and over, along with the same mistakes. AR is not perfect and it certainly makes it easy to make mistakes. However, it (together with Rails) is a mature platform and there's value in that, I think. 
Yeah, thanks for the advice. I may do that. But for now I am eyeing (like most people) ROR development, and I am thinking on Windows, so I will analyze the feasibility of playing with Ruby on Windows. But it is definitely a possibility.
Check out the bullet gem to make those queries easier to spot. [Skylight.io](https://www.skylight.io/r/epquZ6XLsICs) is great too, as well as newrelic.
Yup, FactoryGirl with build_stubbed is a time and lifesaver. 
Yeah. A lot of unit tests don't need to have model data inserted in the database. But there's no way around for intergration tests. Million of db insertions will bloat testing time.
I'm not sure if it's a bug or not, in my experience it just looks for the most common patterns (and we already avoided those). We had a lot of code in serializers/async workers that had N+1s.
Ruby is not Rails. Rails is not ruby. Anyway, it's up to the developer to do that i guess.
Rails is built in Ruby so..
Uncle Bob gave a fairly similar talk a few years ago at Ruby Midwest, for anyone looking for more info/ideas. https://www.youtube.com/watch?v=WpkDN78P884
Mostly disagree with the speaker. - ActiveRecord is NOT an anti-pattern. It's A pattern. In some cases it's good, in some worse. It's your job to decide when and how use it - You can't build an application without knowledge of SQL and DBs. N+1 is a nasty problem but solving it isn't difficult at all. Spend one evening to study preload methods (preload, eager_load, includes) and their differences. If you don't want to learn SQL and don't like to look at server's log and can't remember to preload associations - install `bullet gem` and follow the instructions - "AR violates SRP". When it's time use Service/Query/Form/Policy objects. Premature optimization is the root of all evil - "Throwing everything in one place is sensible way according to Rails". No, it isn't. Watch https://www.youtube.com/channel/UCUkM9uMpWatT7gVWShgtKFw/videos - "Active Record ties your application to your database". It doesn't. It's just a first brick in your application. It's up to you how you'll build it - The same directory structure between Rails 1.2 and 5.2 is a bad thing? Here I have to much word to say but even don't know where to start - "def create - 50 lines of code" - oook. Sure it's fault of AR I didn't really get about what the video is. rom-rb and dry-rb gems are good tools and if you want to start using them then it's much easier and faster to read their documentation.
Windows computers are inherently cheaper than macs. Some people have familiarity with Windows, but a Linux install may be more than what they’re comfortable with. When I first started in Ruby, this would have been a great starting point as I couldn’t afford an Apple computer and relied on specific Windows applications. Dual booting is feasible, but a hassle. VMs/Vagrant/Docker are definitely an alternative as well as C9, but nothing wrong with knowing all of the options. I am impressed on how smooth it works verses a few years ago.
Am I not able to use parent? 
You can (see edit) but by convention you would not.
Sorted, thank you for your help! 
the single responsibility principle applies to all of the above. sorry for the confusion, there seems to be a disconnect
&gt; AR is not perfect and it certainly makes it easy to make mistakes. However, it (together with Rails) is a mature platform and there's value in that, I think. Many people are saying that Rails is "mature", but I have to admit that I'm not sure exactly that means. If Active Record really hasn't evolved much, as this video claims, then I feel like all we're left with is "it's been around for a long time", and that isn't very reassuring. Paperclip has been around for a really long time, and it just got deprecated. The reason why I think it's important to talk about whether Rails has evolved is because there are many alternatives to Rails components/gems that I find much more advanced and "evolved" than their Rails counterparts. For example, I find that Sequel has matured much better than Active Record; this is shown by the fact that the other two "ORMs", rom-sql and Hanami::Model, are both built on top of Sequel and not Active Record. To go back to the N+1 queries, why does Active Record still allow us to make them? Nobody ever wants to make N+1 queries, but yet they still sneak in, even though most people are well aware of eager loading. As the videos says, the reason is most likely backwards compatibility. I think rom-sql really made a step forward here by making it impossible to make N+1 queries implicitly. Obviously, that's just one of the steps forward it made, another big step is the separation of concerns.
&gt; ActiveRecord is NOT an anti-pattern. It's A pattern. In some cases it's good, in some worse. It's your job to decide when and how to use it I think the video tries to argue that Active Record pattern is "good" only for simpler scenarios, and that it falls short when complexity increases. The problem with "deciding when and how to use it" is that you usually don't know that Active Record won't be a good fit until you start hitting walls, at which point your application is already too far off to be able to go ahead and completely replace Active Record with something else. In this case your only option is to start hacking around Active Record limitations. The advantage of using something like rom-rb is that it will work well in both simple and complex scenarios. &gt; You can't build an application without knowledge of SQL and DBs. What Ryan meant was that your Rails controllers and service objects shouldn't need to know the details about making queries. These details should instead be encapsulated into repository/relation objects. That makes it easier to separate reading/writing to the database from the rest of the business logic. &gt; N+1 is a nasty problem but solving it isn't difficult at all. Spend one evening to study preload methods (preload, eager_load, includes) and their differences. If you don't want to learn SQL and don't like to look at server's log and can't remember to preload associations - install bullet gem and follow the instructions It's impossible to ensure you're not making any N+1 queries, even with the Bullet gem. The best way to solve this is by having your ORM not allow them in the first place, which is what rom-rb does. &gt; "AR violates SRP". When it's time just use Service/Query/Form/Policy objects. Premature optimization is the root of all evil Wouldn't it be easier to maintain SQL queries if we *knew* that *all queries* are defined in Query objects? In other words, that it's not possible to define queries outside of Query objects? I think we can safely assume that query logic will grow in any application, so it's better to create a place for them in the very beginning. With Active Record it's more difficult, because it simply doesn't have that abstraction, so you have to either find 3rd-party gems or [implement your own](https://twin.github.io/finder-objects/). rom-sql, on the other hand, comes with that abstraction built in. &gt; "Active Record ties your application to your database". It doesn't. It's just a first brick in your application. It's up to you how you'll build it I think it's far better to have abstractions that were designed to help you with complexity readily available, rather than starting with a blank slate and having to find your own way.
Bro, we haven't ever talked to each other, but I love ya. Your work on `Paint` gem is amazing, and this blog of yours is really out of this world. As an admirer, here goes some feedback from someone that came from Graphic Design and studies typography more than he should: You gotta make your text less thin. Love the way you worked this asymetric layout and characters per column is great. Now the thinness of the letters hurts me a little. Else than that, thanks for sharing your deep knowledge as always!
If you doing graphs, you better off with something that does it on the front-end from json data you feed it. Something like https://www.chartjs.org 
also [`StringScanner`](https://ruby-doc.org/stdlib/libdoc/strscan/rdoc/StringScanner.html)
If you're practicing, then just use what Ruby Cookbook tells you to use. What I described is 95% Javascript and maybe 5% Ruby. 
To add. I'm a full time Ruby developer now. I've been coding Ruby for about 12 years, and when I started I was on a windows machine. It's what I had. It's what most people in the world still have. When I got serious into development I realized that a mac would be a better fit but if it weren't for good people who put out windows content I wouldn't be here today. Fun fact: I went through several "Ruby on Rails" books and the first one to work was "Rails for Idiots" it used a windows machine and eclipse as the IDE. 
&gt; I think the video tries to argue that Active Record pattern is "good" only for simpler scenarios, and that it falls short when complexity increases. ActiveRecord is good when your data model is good. The vast majority of Rails apps I've seen turn into messes were apps that were poorly modeled at the data layer forcing the programer to try to fix those problems in code. &gt; What Ryan meant was that your Rails controllers and service objects shouldn't need to know the details about making queries. These details should instead be encapsulated into repository/relation objects. That makes it easier to separate reading/writing to the database from the rest of the business logic. The 'Rails way' is that the queries are structured in the model classes, the only aspect of querying that should live in a controller are performance optimization (eager loading, selecting only needed values, etc). The only except I run into with this approach are search forms, the query assembly for these I abstract to a separate objects. &gt; It's impossible to ensure you're not making any N+1 queries, even with the Bullet gem. The best way to solve this is by having your ORM not allow them in the first place, which is what rom-rb does. rom-rb doesn't prevent N+1 queries in any more cases than bullet does. It's still possible to iterate objects in rom-rb and load associations. &gt; Wouldn't it be easier to maintain SQL queries if we knew that all queries are defined in Query objects? In other words, that it's not possible to define queries outside of Query objects? Not in my experience. I'd rather have the queries in the model classes. I want the data, validations, behavior and query logic in as confined a space as possible, not spread out over 15 files in various directories. In your model classes are getting too large, you have a data modeling and missing abstraction problem, not a code organization problem. &gt; I think it's far better to have abstractions that were designed to help you with complexity readily available, rather than starting with a blank slate and having to find your own way. As this relates to your application being tied to it's database. It _should_ be tied to it's database, the concept that a datastore is an abstractable concept is unrealistic at best and one of the stupidest ideas in computer science at worst. At the end of the day the way your application is structured and in many cases how it is architected is going to be tied to the capabilities of your datastore. e.g. The way I have to write code when I know I have PG and transactional guarantees is much different than how I have to structure code to have the reliability I need when working with cassandra. 
Perhaps https://github.com/minimagick/minimagick - it calls out to the command line tool rather than embedding a library.
It's an implementation detail that adds \~300 footgun methods to your class. And given that this is Ruby, you can't prevent consumers of your class \(or juniors/devs on deadline…\) from using those methods in ways you didn't intend.
AFAIK VIPS is the new hotness in image libraries. https://github.com/jcupitt/ruby-vips MiniMagick is the thing to use if you are stuck on ImageMagick.
Thanks, that is what I am using. Just wondering if there is a better one. Will gruff use minimagick or do you know of a good chart/graph gem.
Thanks
image_processing is a nice wrapper gem with libvips and minimagick support.
Unless you have foreign keys, complex relations, and objects acting on relations. Suddenly AR needs to make a DB call and you can’t stub it without effectively throwing AR away. Database consistency matters.
&gt; ActiveRecord is good when your data model is good. The vast majority of Rails apps I've seen turn into messes were apps that were poorly modeled at the data layer forcing the programer to try to fix those problems in code. I don't agree that you'll start experiencing pains with Active Record only if you're doing something wrong. For example, in a previous job we were dealing with PostgreSQL tables that had up to 15 million rows. Now, when you have to do a migration like change the column type, you need to iterate over all records to make the necessary updates. Instantiating model instances (`ActiveRecord::Base`) would add a big overhead to that, so we had to make model-less queries which instantiate Ruby hashes instead. If we were using Active Record, we would have to say goodbye to the query API and use raw SQL for everything. Luckily, we were using Sequel, which made it trivial because it supports model-less queries with the identical query API as when you go through models. Since rom-rb is built upon Sequel, it has the same advantage (though it already instantiates light structs to begin with). &gt; The 'Rails way' is that the queries are structured in the model classes, the only aspect of querying that should live in a controller are performance optimization (eager loading, selecting only needed values, etc). The only except I run into with this approach are search forms, the query assembly for these I abstract to a separate objects. I agree, so this means you never see queries being built in controllers and service objects? I find that, when there is nothing to enforce this rule, query logic inevitably start leaking to place where it shouldn't. &gt; rom-rb doesn't prevent N+1 queries in any more cases than bullet does. It's still possible to iterate objects in rom-rb and load associations. Yes, that's why I said "implicitly". It's of course possible to make N+1 queries if you really want to, but then you know that you're doing it, because you see that you're calling the repository object in a loop. Moreover, doing it this way makes it much harder than eager loading these associations, so you'll feel like you're doing something wrong, which is great because you *are* doing something wrong. In Active Record the code for fetching associations will look exactly the same when you're eager loading and when you're not, the only difference is if there is an `includes` somewhere before. So it's not possible just by looking at code to know whether you're not making an N+1 query, because you could have always forgotten to eager load something. And it seems that Bullet can miss a lot of cases, according to [another comment](https://www.reddit.com/r/ruby/comments/8hly49/exploding_rails_ryan_bigg_video/dylbd21/) from this thread. &gt; I'd rather have the queries in the model classes. I want the data, validations, behavior and query logic in as confined a space as possible, not spread out over 15 files in various directories. In your model classes are getting too large, you have a data modeling and missing abstraction problem, not a code organization problem. Let's for a moment forget that we're used to seeing certain things in certain places in Rails. Why is it useful to have scopes defined in the model? Aren't scopes just macros at the end of the day? When I'm reading the model code, query macros don't increase my understanding of what the model does at all, so I would rather have them live somewhere else (e.g. query objects, which in rom-rb are called "relation" objects). &gt; At the end of the day the way your application is structured and in many cases how it is architected is going to be tied to the capabilities of your datastore. e.g. The way I have to write code when I know I have PG and transactional guarantees is much different than how I have to structure code to have the reliability I need when working with cassandra. Yes, I definitely agree, I don't think it's possible to completely abstract your business logic from your database, you do still have to rely on some features such as transactions. But I think that abstracting as much of it away possible leads to better design and easier stubbing in tests. It also makes it much easier to use more than one datastore when you have to. For example, in my previous job we had classic relation data that fit into a PG, and we also had time-series data which needs to be stored in something like Cassandara (considering that we were receiving 500 million new "records" each day). If we had used rom-rb, adding another datastore would be much easier, because rom-rb abstracts datastores (rom-sql is just one adapter).
There's ruby qt bindings. Check it [https://github.com/ryanmelt/qtbindings](https://github.com/ryanmelt/qtbindings)
Ugh. This comes across as simply bad OO. Once you're writing imperative transaction scripts you may as well throw away Ruby and go back to writing perl CGIs. The elephant in the room is that this approach gives you [anemic domain objects](https://martinfowler.com/bliki/AnemicDomainModel.html) and pushes all your domain logic into transaction scripts that people unwittingly call "service objects" (fun fact: they're *not* a service layer in either the Fowler or the Evans sense). Basically you're not writing OO code anymore and it's a classic case of [OOP: You’re Doing It Completely Wrong](https://vimeo.com/91672848) because the behaviour no longer arises from a composition of domain objects. If I wanted to write code like that, I wouldn't use Ruby. Don't even get me started on the Ruby:Enterprise Edition that is dry-rb. &gt; "ActiveRecord violates SRP". It doesn't. This is a tired refrain that misconstrues the SRP in terms of things like method counts, rather than seeing it as an OO domain design principle. Bottom line, you can write SRP compliant AR models. &gt; "ActiveRecord ties together callbacks, dirty tracking, validations in the one bloody class" It doesn't. An awful lot of them are actually implemented in separate classes and objects. Simple example: even the model's attributes are actually delegated elsewhere, to an `ActiveRecord::AttributeSet` that does things like dirty tracking. Similarly, validations are implemented by separate classes and objects. Ryan is complaining about the *interface* exposed for activating these features, because that is indeed exposed in one class (`ActiveRecord::Base`) but they're actually a fairly well separated bunch of concerns. In truth, under the bonnet ActiveRecord is more than halfway to being a data mapper pattern. 
hanami's ORM is a layer on ROM, it's not "other two ORMs". 
Sure, but you should strive for code that doesn't violate the law of demeter. If you have code that has stuff like `categories.articles.users.pluck(:name)` etc. then you don't have any chance of stubbing that easily. If you however inject your dependencies wherever possible (and/or use TDD) then you shouldn't have any problems with stubbing.
What about the file system? 
If we all were using something like beanstalkd as a queue-server, we would get stuff like this for free because it is built into the server part to remember a job if a worker dies.
It has gotten a lot better. I had initially submitted a bug report a few years back with the lack of support for symbolic links in the subsystem due to NTFS not supporting the sym links. Even though parts of the subsystem are using a VFS, the mounted VolFs and DrvFS (/root, /home, /mnt/c, /mnt/whatever) are passed through to the NT Kernel, NTFS in WSL does now support the sym links and overall a lot more stable. &gt; While NT supports symbolic links, we could not rely on this support because symbolic links created by WSL may point to paths like /proc which have no meaning in Windows. Additionally, NT requires administrator privileges to create symbolic links. So, another solution had to be found. &gt; Unlike VolFs, we could not rely on EAs to indicate a file is a symbolic link in DrvFs. Instead, WSL uses a new type of reparse point to represent symbolic links. As a result, these links will work only inside WSL and cannot be resolved by other Windows components such as File Explorer or cmd.exe. Note that since ReFS lacks support for reparse points, it also doesn’t support symbolic links in WSL. NTFS however now has full symbolic link support in WSL. This is a pretty good read on the File system in WSL https://blogs.msdn.microsoft.com/wsl/2016/06/15/wsl-file-system-support/
Because we like using Ruby too. And it's hardly torture.
Because we like using Ruby too. And it's hardly torture.
Ruby is a very syntactically sweet language that many find a pleasure to code in. It's easy to read, fun to write. This is largely due to Ruby's high level of abstraction, which requires a lot of magic under the hood. Because it's abstraction level, it's relatively slow compared to even other scripting language such as Node. This lack of performance does not make it ideal for making any graphical or CPU intensive games. What kind of games are you looking to make?
Some 2d games and probably some fake 3d, I heard a story from a python user saying that he stopped making his game after python slowed down because his game was too big for python to handle, is there any benchmark on how much faster c/c++ comparing to Ruby?
I have the following in my `Gemfiles` for apps that get deployed to heroku, maybe it helps somebody: ``` ruby File.read('.ruby-version')[5, 5].strip ``` Heroku prints/printed (?) a warning if you did not declare the Ruby version in the `Gemfile`.
For Ruby 3 isn’t the 3x claim based on the speed of Ruby 2? The current version is already faster than 2 and I don’t think they’ve ever claimed 3 would be 3x faster than 2.5, especially since that goal was set a while back before current speed improvements were made. 
Faktory provides all of the beanstalkd functionality, including the same reliability, with a nicer Web UI. It's free and OSS. https://github.com/contribsys/faktory http://contribsys.com/faktory/
do people use beanstalkd as ActiveJob infrastructure, are there existing options for that?
This is a great article describing this feature, but I would never design architecture around super fetch (really because I wouldn't design architecture around assuming Redis/any job queue is actually persistent). The right way to do this is to build idempotency into your jobs using statuses persisted to disk (ie: DB). You should *ALWAYS* be able to kill your entire job processing system (especially the queue) and not lose work. You should not need to depend on features of the job processing system in order to do this. 
I do not think it exists.
&gt; As this relates to your application being tied to it's database. It should be tied to it's database, the concept that a datastore is an abstractable concept is unrealistic at best and one of the stupidest ideas in computer science at worst. This seems unsubstantiated. I write entities that aren't tied to the database all the time. It's great. Database styles, of which relational databases is just a member, vary greatly in their substitutability. The kinds I work with are easily separated from core "model" logic. &gt; The way I have to write code when I know I have PG and transactional guarantees is much different than how I have to structure code to have the reliability I need when working with cassandra. The realization of the incompatibility of implementations across database styles is important, but the most significant takeaway is that consistency boundaries are part of your application, not your database. Determining what data changes together (and what doesn't) is a big part of your architecture. All abstractions leak, but leaks are the exception, not the norm.
Same. `ruby File.read('.ruby-version').chomp` 
its*
Looks like it at least theoretically does, I don't know if it gets much use or how well it works. http://api.rubyonrails.org/v5.2/classes/ActiveJob/QueueAdapters/BackburnerAdapter.html
Thanks!
Even better.
RPG Maker ( is either written in Ruby or allows you to create some types of games using Ruby). I haven't personally seen it so I can't say if it's any good. http://www.rpgmakerweb.com/ On the other hand, though it's not a lua / ruby type would be javascript with some webgl libraries like three.js, bablyon, etc.
I always use a .ruby-version file, but have encountered numerous downsides and annoyances with putting it in the Gemfile. You have to do it if you are on Heroku, but otherwise ick. Some common scenarios: * You are developing a Gem that is intended to pass its tests in multiple ruby version. * You install a ruby security update and forget to update your Gemfile.
You could try Crystal. It has a very similar syntax to Ruby (in fact inspired by) and it compiles down via LLVM. https://crystal-lang.org
Agreed. 
Thanks
&gt; is Ruby good for game development? Not really. It is possible, but difficult. There is no platform (PC/Mac/Android/iOS) that you can reliably distribute a whole app to, without a very complicated and buggy build process. JRuby is probably your best bet. If you don't care about distributing the game, and you are happy with 2D, the [gosu gem](https://www.libgosu.org/) is very good. &gt; are there any updated benchmark that I can see? Benchmarks comparing what to what? &gt; How about the language's performance? Is it at least faster than python ? It's roughly the same as Python.
I did try pdf.stroke do but still got an error.
Doesn’t seem like you’re requiring the gem in your script. 
Hey, thanks for the praise! I'll look into the typo issue! Btw: Coltrane looks fantastic!
Thanks for the hint!
Does it work if you add this at the top of the script? require 'bip_mnemonic'
The `enable :sessions` will `use Rack::Session::Cookie` under the hood, so you only need one of these two. Using `enable :session` is preferred, because then Sinatra knows that you're using sessions and it can use that to configure things like the `Rack::Protection` middleware ([code](https://github.com/sinatra/sinatra/blob/5149dc9e0b0e281231b91223c6a414c905ad3a96/lib/sinatra/base.rb#L1691)). I think the equivalent of use Rack::Session::Cookie, { ... } would be set(:sessions, { ... })
This guy bashes
Just what I was looking for, a compiled language that is simple to write and read, but also powerful, thx alot
&gt; And if you were to execute this little script, it would do exactly what you would expect. Nothing wrong here. I did not expect this piece of code: # foo.rb class Foo @@class_var = 'Hello!' def self.read_it puts @@class_var end end To print anything.
While an object is indeed an instance of its eigenclass, [the #class method skips it](https://github.com/ruby/ruby/blob/a6108df9485ec81de6255208f8a931de9f7adb57/object.c#L245).
&gt; how does Rails work with or leverage the Rack code? It seems that Rails uses its own `ActionDispatch::Session::CookieStore` middleware instead of `Rack::Session::Cookie`, but that middleware is a descendant from the `Rack::Session::Abstract::Persisted` class, just like `Rack::Session::Cookie`. So it seems that even though Rails decided to use their own cookie middleware, they still reused Rack's base class for sessions. &gt; Can you mount a Rack app in a Rails process and have it reuse the session? Since `ActionDispatch::Session::CookieStore` is a middleware, and middlewares are applied to anything in the "Rack stack", mounted Rack applications should have sessions available. And it shouldn't matter whether `ActionDispatch::Session::CookieStore` or `Rack::Session::Cookie` is used, because the "session" base class provides the same interface through `env["rack.session"]`, so the Rack application shouldn't have to have any special Rails integration.
&gt;require 'bip\_mnemonic' Thank you. This helped a litte bit, but now I get a new error message: 2: from /var/lib/gems/2.5.0/gems/bip\_mnemonic\-0.0.2/lib/bip\_mnemonic.rb:25:in \`to\_entropy' 1: from /var/lib/gems/2.5.0/gems/bip\_mnemonic\-0.0.2/lib/bip\_mnemonic.rb:25:in \`map' /var/lib/gems/2.5.0/gems/bip\_mnemonic\-0.0.2/lib/bip\_mnemonic.rb:27:in \`block in to\_entropy': Word not found in words list \(IndexError\) Any ideas?
As far as I understand, it's just that the `class` method will skip over the eigenclass, while method lookup doesn't. I don't understand your issue with modules; it's just a class, and when you use `module Name something end` all it does is something like `Name = Module.new do something end`. The functions you'll use inside that block will be methods of the module object, but they aren't touched by method lookup of an object whose class includes a module, it's different.
My bad :) Fixed it. Thanks for pointing it out.
# implicit block Prawn::Document.generate("implicit.pdf") do text "Hello World" stroke_axis stroke do rectangle [100, 300], 100, 200 end end
&gt;happy to help
:\)
I still don't understand why this happens. Why is there 4 printings ?
Because he appends the new code to the old, leaving in place the previous call to `Foo.read_it`.
He should print the whole code, because it's confusing.
One problem with the Rails way to avoid running n+1 queries is that it's relatively easy to see in the logs when you missed preloading an association, but it's difficult to see when you forgot to remove a preloaded association when it's no longer used.
Thanks for the suggestion, I've added a comment to help with that.
I think that the issue is how you are breaking down the correction, which is making it hard to understand. There are two separate methods used here `array[]` and `rand()`. As the docs mention 'rand' takes a single argument to represent the max value, and, if an integer is used, will return a value equal or greater than 0, but less than the argument passed in. So if we pass in 3, `rand(3)` we could only get back 0, 1 or 2. These should correspond with our array indexes. `array[int]`returns the value of the index we pass in, so in the example you provided, this would be the result of `rand(3)`. Therefore, the example will access an array element randomly at position 0, 1 or 2.
Does `enable :sessions` also use `Rack::Protection`, too? A slight divergence, but does this also enable `Rack::Flash`? What does [sinatra\-flash](https://github.com/SFEley/sinatra-flash) offer over [Rack::Flash](https://github.com/nakajima/rack-flash)?
Thank you very much, you made me undestand ! It's much more simple than what I thought it was.
&gt; Does `enable :sessions` also use `Rack::Protection`, too? No, it only affects which parameters are sent to `Rack::Protection`. The `:protection` setting affects whether `Rack::Protection` is added, and it's set to `true` by default. &gt; A slight divergence, but does this also enable `Rack::Flash`? What does sinatra-flash offer over `Rack::Flash`? You can easily check that by searching for `Rack::Flash` in `sinatra/base.rb`, the vast majority of Sinatra's source code is in that file ;). No, it doesn't, you can see that it doesn't even add `rack-flash` as the dependency. I have no knowledge of either Rack::Flash or sinatra-flash, so I don't know how do they compare.
He forgot to actually call `Foo.read_it`, so the class was just defined, but the code was never run, hence no output to stdout.
Now if I just had a time machine and could take this back ten years to when I was trying to get Ruby running on Windows that would be great. I managed but certain things were a pain. Mainly native gems that didn’t want to compile the first time. Really nice to see things have changed. Ruby is a great language and the more people who can jump into it without having to fiddle too much to get it working the better. 
Any easy way to add the jemalloc compile flags to rvm ? (i use capistrano-sidekiq )
Simple: don't use them.
I appreciate the replies but they are so ephemeral here. Any chance you plan to blog or document this stuff in a more permanent manner?
&gt; I don't understand your issue with modules; it's just a class A `module` is not a `class`, however a `class` is a `module`.
Couldn't use "sample"? https://ruby-doc.org/core-2.2.0/Array.html 
&gt; everything in Ruby is an object Err, no? `while` is not an object. Comments are not an object. Blocks and methods are not an object (though they can be described and represented by an object). Whitespace is not an object. A splat is not an object (or an operator, or a method, for that matter). Hash-rocket? Ditto. Who the heck came up with this "everything is an object" thing? Every _value_ is an object is closer to the truth (but not actually true either - `Symbol` and `Fixnum` are "immediate values", almost indistinguishable from objects, but not quite objects).
I meant in the abstract sense, but you're right, and that could be confusing when there's an actual `Class` object.
The only current downside is it is still single-threaded. It has Go-like concurrency in the form of fibers but there is no parallelism between them. This will be fixed in v1.0, due out this year. Supposedly, like Go, it will automatically schedule the fibers across all possible CPUs automatically so it should not be breaking upgrade.
How about a Client class? Example: client = MyGem::V2::Client.new client.achievements #=&gt; return instance of Achievements That would also let you share an Achievements class between the versions, if the data they return is the same. Another idea would be to abstract the API version away (if you can get away with it). If you look at the [source for Octokit 1.0.0](https://github.com/octokit/octokit.rb/tree/v1.0.0) you can see how they supported multiple versions while they were in transition. However, I can see why you wouldn't want to do that if you want to lean on the API docs. 
Yeah, I'd really just like to specify a *minimum* version. That way I can easily test every new version, but it won't boot if I actually have too old of a Ruby installed.
&gt; But in context, he is alright, no? Kind of. I mean, I know what he wants to say. It's just that this gets repeated a lot, and it's a bit of a pet peeve of mine.
A client class sounds like a great idea - I didn't even think of this, even though I've used a couple of API-related gems in the past. I'll toy around with this and see how it works out. Thank you!
what error do you get? If you get an error doing something that is in the Prawn docs, I'd file an issue on prawn. 
There is a lot more that could be said about them than this. Yes, in general I don't use them. I have never found them to do what I want or expect. Unfortunately class instance variables have their own gotchas. For example, sometimes you DO want inheritance. Class instance variables are not inherited: class Base @class_var = "Base" class &lt;&lt; self attr_accessor :class_var end end class SubClass &lt; Base end puts Base.class_var.inspect # "Base" puts SubClass.class_var.inspect # nil What if you are coding a module, that writes some configuration to a class instance variable? Oops, sub-classes will lose that configuration! This makes coding macros a royal pain sometimes.
Hmm, I could have sworn I'd seen class ivars inherited in some circumstances, and went to try to demonstrate that with an example... but now I can't! So maybe I was wrong? All this stuff is one of the remaining confusing parts of ruby to me. 
Yes but it was blocked for this exercise :'(
Ahhh! I thinked he missed syntax or anything else.
I think knowing how to manipulate data is very valuable for any company. This includes reading, manipulating and moving data from and to a variety of sources. Knowledge about using a database natively without the help of Ruby's abstraction libraries goes a long way: it helps you make better informed choices in terms of "the right tool for the job" in terms of "this is best performed by letting the DB handle these parts of my problem" or constructing efficent queries. Every business has data, and thus skills to manipulate data is valuable for every business. 
I've never seen that use case in practice. Do you know of any libraries that use it "in the wild"?
yes hopefully we will be getting into SQL and more in the backend in the near future, thats the first half of the curriculum. Hope to be employable - and good, considering the rigorous nature of the program - by end of or near end of backend portion. ty!
Use what pattern? Class-state that should be inherited by sub-classes? Sure, plenty. Rails is one, and uses it's own `class_attribute` solution for it. https://github.com/rails/rails/search?utf8=%E2%9C%93&amp;q=class_attribute
Thanks, I actually didn't know about that!
Also, "my post is confusing because of missing editor."
As some others stated, the main use case is ActiveRecord extensions and macros, but I did not know about `class_attribute`. So, for example, one might make a module called `StringNormalization` that could be used like so: class MyRecord &lt; ActiveRecord::Base include StringNormalization normalizes_string :first_name, strip: true normalizes_string :last_name, strip: true, upcase: true end For just a weird pointless example. The `normalizes_string` macro is actually adding a configuration to a class variable, which ideally should be inheritable, but override-able by sub-classes.
There are plenty of valid reasons for them, configurable class traits for example.
&gt; That is a really pedantic argument, I'll freely admit that it is. &gt; it's pretty obvious no one is talking about syntax when saying 'everything in Ruby is an object'. I actually had someone ask (IIRC) why `while` isn't an object and why hash-rocket isn't a method. It is a no-brainer when you're already familiar with Ruby, but depending on your public, it might not be so obvious what "everything" refers to. &gt; The only vaguely questionable one is blocks / lambdas but you can only interact with them as objects (Proc) so it also doesn't really matter. Not true. You also interact with them as what they are - blocks: 100.times.inject(0) { |a, x| a + x } 100.times.inject(0, &amp;lambda { |a, x| a + x }) &gt; That is an implementation detail of MRI, not a language feature. i.e. as far as I know the spec doesn't not explicitly disallow creation of a singleton class for `Fixnum`, `Symbol`, `Float`, etc. That is correct... ish. It is often said to be an implementation detail - but I have a hard time calling something "just an implementation detail" when it has consequences on your code. And furthermore, for all intents and purposes, MRI *is* the spec (with the failure of RubySpec project, and with ISO spec being stuck in draft stage, and in end-of-lifed 1.8.7 version of Ruby, too). JRuby follows suit and treat those classes as special; I can't test on other implementations at this moment.
I guess I don't understand what you mean by "the use case" or "that use case" here. What do you mean?
yep, they totally end up doing exactly what most would assume -- inherited, ability to override. Th only gotcha is that if you _mutate_ the thing in a subclass, that effects superclass (and all other subclasses sharing it too). You have to change it to override in a sub-class by actually doing an assignment `WhateverClass.my_property = whatever`. So I consider it best to only use immutable values there, override in a sub-class by changing it to a new value, possibly with a non-mutating `merge` on the original, etc. `class_attribute` adds other crazy stuff too, like convenience instance methods to access the class property -- and then the ability to override it on a single _instance_ if you want too! Which is actually useful sometimes. But you can turn that all off with `instance_accessor: false`. 
And code like this will generate nice N+1 queries when an active record object is actually injected class ShoppingCartCalculator def initialize(cart) @cart = cart end def total_discount @cart.cart_items.collect(&amp;:discount).inject(:+) end end 
&gt; As far as I understand, it's just that the class method will skip over the eigenclass, while method lookup doesn't. How can #class skip over the eigenclass without something pointing to the proper class? Also, wouldn't it just make more sense for #class to use the same mechanism as the method lookup? Regarding the method lookup itself, take this example: class Dog; def bark; end; end fido = Dog.new The method lookup for `fido.bark` would look something like: 1. does fido have a singleton class? no 2. does the superclass of fido point to an Iclass that was from an extend? no. 3. does the superclass of fido point to an Iclass that was from a prepend? no. 4. does fido point to a class? yes, class `Dog`. does `Dog` have a bark instance method? yes. stop method lookup Now, I'm confused about the method lookup would look for `fido.bark` after we have opened a fido singleton class via `def fido.wag_tail; end`. Given the incomplete info I have, the method lookup should look like this: 1. does fido have a singleton class? yes. does singleton class have a bark instance method? no. start all over again, using `fido singleton class` this time. 2. does the superclass of `fido singleton class`point to an Iclass that was from an extend? no. 3. does the superclass of `fido singleton class`point to an Iclass that was from a prepend? no. 4. does `fido singleton class`point to a class? yes, class `Class`. does `Class` have a bark instance method? no. 5. things have gone haywire because of the self referential bs of `Class` This doesn't even get to my question about having the class of`module Bark` and `Bark IClass` pointing at `Bark singleton class`, but let's leave that aside for now.
This is all well and good, but what to mock and what not to mock is actually a really hard problem. I found that I missed issues frequently when I ran with mocks and not the real objects and database records. The tests were fast, but they didn't prove anything meaningful about the whole system working as it should.
I feel like using instance variables within `before` blocks is a bad idea. Using `let!` seems far cleaner.
I agree with the general sentiment of that article. Perhaps I still find that for simple cases, where creating helper/factory methods are either overkill or completely unnecessary, a one-line `let` is fine. I'd rather use a small bit from RSpec's DSL than use an instance variable.
Just like this title says, the solution is to use class instance variables instead. 
The second assertion here is of very little value, as the only thing it checks is whether we called the client with correct argument list.
A finite valid `while` can be evaluated to an object. I'd be curious to know if there are valid ruby statements or expressions that don't evaluate to objects.
Yest, this helped. Thank you.
&gt; Not true. You also interact with them as what they are - blocks You can jump through whatever syntax hoops you want to, but the method receives a Proc. There is no such thing as a block at runtime, it’s just syntax sugar.
Nice article but this is cringey af: "I help SaaS companies increase market share faster by improving their delivery velocity" in other words -- you're a programmer who writes OK code. Right? The bizspeak buzzwords are meaningless.
I have mixed feelings too. I like instance variables because I clearly understand them.
Sidekiq uses class attributes to store job options per worker class, where the options may also inherit. https://github.com/mperham/sidekiq/blob/master/lib/sidekiq/worker.rb#L30
It is difficult and I also often don't know the best way to design tests. However, at the moment I usually try to think in terms like this: Are the individual pieces of my system separate enough that they can change independently? E.g. does the way we bill customer have anything to do with how we ship items? Probably not - so there is value to testing these two things in isolation. In general, I find mockist testing to be useful when we're dealing with a system of equally important, independent, decoupled components each of which can change without affecting the others. Conversely, sometimes you just cannot split up something into independent components effectively. Complex algorithms and multi-step processes tend to fall into this category (if you're inverting a matrix, there's really no point in "mocking" e.g. row addition). In such a case I prefer to write my tests like layers of an onion with no mocking. It's not always clear-cut but I find this to be a good guideline. Think about whether you could explain what the test does to another person in less technical terms: If you can say "we want to check that whatever is input by the user is passed to our input sanitizer and only sanitized input is stored in the DB", then I'd say go on with mocking. However, if you'd have to say "we have to check that the result from the AbstractGatewayFactory is passed into the BeanPropertyConfigurator", then maybe that's not where you should use mocks. I disagree that only integration tests are meaningful, I'd rather say that only tests that test intended behaviour in some sort of way rather than accidental implementation detail are valuable. Of course, if your app is just a glorified CRUD app, there might not be a lot of internal behaviour that justifies complex testing. But your app might also be an online Ruby REPL or banking application and there's lots of behaviour that can be tested there without going through the UI.
Let is shit. 
 Non-lazy let! is an alternative, but it's not worth the trouble. What? A single character difference is "not worth the trouble" over a `before` block?
Operating system? Looks like it can’t find OpenSSL. Is OpenSSL installed?
Have you tried the solutions from [googling the error](https://www.google.com/search?client=safari&amp;rls=en&amp;q=Could+not+open+library+%27libssl.so%27:+libssl.so:+cannot+open+shared+object+file:+No+such+file+or+directory&amp;ie=UTF-8&amp;oe=UTF-8 )? Here are a couple of hits: https://askubuntu.com/questions/339364/libssl-so-10-cannot-open-shared-object-file-no-such-file-or-directory https://www.linuxquestions.org/questions/centos-111/libssl-so-1-0-0-cannot-open-shared-object-file-no-such-file-or-directory-4175589481/
What does `ls /usr/lib/libssl*` say? [This line](https://github.com/GemHQ/money-tree/blob/8314a73c56cdab6be552dc3bfb645b18fa037f7b/lib/openssl_extensions.rb#L9) is trying to load libssl and is failing.
I think that is they hadn't extracted the logic to class methods it would have been better. Setting up a class method to validate instance state seems wrong. If it is intended to be reused, put it in a validation module.
I don't know if I'd call using class methods in instance methods *dependency injection* really. Maybe if they were their own class as a Validator or something. 
I disagree a bit about class methods. The benefit of them is that they make you functions stateless and trivial to move around and test. This has been my go to tecnique for years (make it private, inject the state, make it static, pull it out into a new module) This piece of code was obviously not bad from the get-go though and I would agree here that it wasn’t necessary
Virutally every Ruby testing framework is based on metaprogramming these days. I’ve used it myself quite a bit for working on very generic bits of code where I want to generate code. In production systems I only tend to use it when the code I have is generating functions based on static data (and I prefer the static config for conciseness; e.g. CRUD APIs via config) or in tests when I want to generate a lot of similar test cases
I'm not sure if I got the point. Maybe I'm too tied with the example. The only refactor I can see here is: @cart.cart_items.sum :discount What I didn't see? 
^The linked tweet was tweeted by [@keystonelemur](https://twitter.com/keystonelemur) on May 09, 2018 04:36:35 UTC (1 Retweets | 1 Favorites) ------------------------------------------------- Slides are now uploaded from my talk at [@fogcityruby ](https://twitter.com/fogcityruby ) tonight on === and pattern matching. Normal: [https://www.slideshare.net/BrandonWeaver7/fog-city-ruby-triple-equals-black-magic](https://www.slideshare.net/BrandonWeaver7/fog-city-ruby-triple-equals-black-magic) With Speaker Notes (tutorial): [https://www.slideshare.net/BrandonWeaver7/fog-city-ruby-triple-equals-black-magic-with-speaker-notes](https://www.slideshare.net/BrandonWeaver7/fog-city-ruby-triple-equals-black-magic-with-speaker-notes) As always, feel free to ping me with questions! ------------------------------------------------- ^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •
This covers my slides from the night as well as a lot of further reading, though everyone might enjoy. Ah, and as a bonus, I've managed to get full pattern matching down to 1.5 to 3x slower than vanilla at worst case, depending on what type of arguments it gets. Don't worry, I'll be back on my mad gem hackery game within the week, and there are more fun announcements to come after I finish a few contracts.
I was referring to this: &gt; What if you are coding a module that writes some configuration to a class instance variable when included? I wanted to see how that would be used and it's practicality. I'm having a hard time picturing it.
This is what I refactored to before reading the body of the article. Any comments appreciated. require 'date' class CreditCard def initialize(number, expiration_date, brand) @number = number @expiration_date = expiration_date @brand = brand end def valid? current? &amp;&amp; number_valid? end private def current? month, year = @expiration_date.split('/').map(&amp;:to_i) Date.today &lt; Date.new(year + 2000, month) end def number_valid? number_length == (amex ? 15 : 16) end def number_length @number.gsub(/\s+/, '').length end def amex @brand == 'American Express' end end 
Looks better that the article, not pick would be to name the method `amex?`
 require "pp" get '/auth/:name/callback' do request.env["omniauth.auth"].pretty_inspect end
I’m all for stateless functions - I’m saying, what do those functions have to do with that particular class? Pretty much 100% of the time I see class methods made in this exact same way - as helper methods that get put on the class that’s currently being worked on because well... no one thought if there was any better place. This is why some people criticize OOP and call it “class-based programming” - a mindless programmer only thinks about classes because that’s where the code lives. Classes are just a means to create objects, and if the method isn’t changing object state or reading object state, it could probably be written as a method outside of the class. Leaving the object to have less responsibility.
Thanks. I did have it named `amex?` originally, but I find the double question marks ugly when used with the ternary operator - `amex? ? 15 : 16` Maybe ternary operators are just ugly and a case statement would suit on this occassion? def number_valid? case @brand when 'American Express' number_length == 15 else number_length == 16 end end
The speed problem can be resolved by running tests in parallel. E.g. Semaphore has a feature that does that automatically: https://semaphoreci.com/docs/about-boosters.html
In ActiveRecord: https://github.com/rails/rails/blob/15ef55efb591e5379486ccf53dd3e13f416564f6/activerecord/lib/active_record/readonly_attributes.rb https://github.com/rails/rails/blob/cfb1e4dfd8813d3d5c75a15a750b3c53eebdea65/activejob/lib/active_job/queue_name.rb In the thing I'm working on atm: https://github.com/jrochkind/attr_json/blob/6659572b1a5132b4aff7e017f4b36e0f87d6585b/lib/attr_json/record.rb In both cases done with Rails `class_attribute` for reasons explained above. 
I actually agree. To be fair, I did say at the end of the post that I wasn't yet 100% happy with the code and that there were more things I would like to do. Your comment and others inspired me to go back and clean up the code further. I added the new code at the bottom of the post, which I'll also include here. ``` require 'date' class CreditCard NUMBER_LENGTH = 16 NUMBER_LENGTH_AMEX = 15 def initialize(number, expiration_date, brand) @number = number @expiration_date = expiration_date @brand = brand end def valid? number_is_right_length? &amp;&amp; !expired? end def expired? DateTime.now.to_date &gt; Date.new(*expiration_year_and_month) end def expiration_year_and_month month, year = @expiration_date.split('/').map(&amp;:to_i) [year + 2000, month] end def number_is_right_length? stripped_number.length == correct_card_length end def correct_card_length if @brand == 'American Express' NUMBER_LENGTH_AMEX else NUMBER_LENGTH end end def stripped_number @number.gsub(/\s+/, '') end end ```
I agree. I decided later that the class methods were a bad idea. I changed them back.
What might have been better if I were going in this direction is to have a `Number` class and an `ExpirationDate` class, each with injectable values. That feels premature at this point though.
I would also suggest calling it `amex?` as that's idiomatic to Ruby, even if it does make ternaries look weird. I would also recommend putting the "magic numbers" of 15 and 16 into constants so it's abundantly clear what they mean. In this particular case it's not too hard to figure it out but I think it's a good practice in general to assign numbers to constants so nobody looks at a number and asks, "What's the significance of 9.7?"
Imo, inline if statements should be used in the place of ternary operators. It's a few extra characters but reads much cleaner. `if @brand == 'American Express' then 15 else 16 end`
Yeah, reading server logs is definitely the way to go for optimisation.
ah yes, the course on re-inventing the wheel.
The benefits appears to be highly when applied to processes using threads. I think you could expect decent results if you use Puma, but probably less-so if you're still using Unicorn. Sidekiq is the part of system most heavily multi-threaded.
Yea I don’t think they were the end of the world. It’s fun to go deep into thinking about where the best place for logic is - there’s many options.
The N+1 happens at collect(:discount).inject(:+) problem. The issue to me is the usage of collect and inject, in this scenario. The refactor of *this example* I expected to be: #Without ShoppingCartCalculator class ShoppingCart ... def total_discount cart_items.sum(:discount) end end #If ShoppingCart is huge, and you'd like to make is easier to read module ShoppingCartCalculator ... def total_discount cart_items.sum(:discount) end end class ShoppingCart include ShoppingCartCalculator ... end * Why do I prefer Without ShoppingCartCalculator? 1. total_discount method is a business logic using ShoppingCart state. 1. CartItem is a weak Entity compared to ShoppingCart * Do I prefer Without ShoppingCartCalculator, even with a HUGE ShoppingCart class? No. I totally fine to split huge class definitions on modules. * What about all of assumptions in this class about the structure of the cart object, it's relations, the fact that everything is loaded into memory etc? Since ShoppingCartCalculator is a reading improvement, not a better model, I understand it can assume be part of ShoppingCart definition. Just written in another file.
https://github.com/thoughtbot/scenic
The problem with this solution is a `SELECT` query with `UNION` which will run every time when you will request a subset of your posts. And it will store the full collection of posts in memory while applying conditions you of your subquery. And it's no way to build an index for a view. So even it is possible to use View with Rails, it is not optimal for your query performance... Am I right? 
I think it's not that bad actually. Extract Method is a core refactor. Now I'd suggest making a value object `CreditCard` and a separate object `CreditCardValidator`, the validator can be a class or a module. The thing with refactoring is that it's very important to know when to stop, especially in big projects. Every step helps. Having logic isolated in a small method is much better than having a huge method. Sometimes though, big methods which don't interact with other objects (think leaf in a tree structure) can be left messy as long as you don't have to change them. That's what Sandi Metz call an _Omega Mess_, don't really like that word though :p
Yes it is. For example check the following link out: https://content.pivotal.io/blog/using-database-views-for-performance-wins-in-rails
It looks like SOAP with JSON to me.
Yes, I'm going to try and eradicate magic numbers in the future. Such a simple refactor to improve understanding of the logic. Thanks for the article, it seems to have generated some good discussion.
[removed]
From what I understand Basecamp already has a license and it was already installed on their systems.
I just added a few of these to my app tonight because RuboCop said too. I’ve read about them and think I understand but I don’t think they made any difference in my app. It worked before and it works now so I dunno. 
Each Ruby object has, besides class it is instantiated from, also its "phantom" singleton class. So the true inheritance tree looks like *object &lt; object's singleton &lt; object'sclass &lt; 1st ancestor class singleton &lt; 1st ancestor class &lt; 2nd ancestor class singleton &lt; 2nd ancestor class* etc. In other words, `Object#class` does not return direct singleton class. Like `Module#ancestors` omit all objects singletons. For that purpose, there is a dedicated `Object#singleton_class` method. 
Yea, that view will perform terribly on all database I know of. The more comical concern is that there is nothing in that view that tells you the type of each row in it and since it's a union of multiple tables, `id` is not unique (absent some custom id generation scheme). So even if you could use this to provide a list of posts to a user, you can't really do much of anything else with it.
Yep. My question was that if the object model looks like [this]( https://www.devalot.com/assets/articles/2008/09/ruby-singleton/singleton-array.jpg), then doesn't that mean that foobar has to go through several steps during the method lookup just to retrieve its instance methods from array?
...which is kind of an ironic thing to complain about on a website that aggregates links
Yeah, I'm a horrible person etc. In a world that has CooperPress, Libhunt's so-called newsletters are simply terrible.
Maybe a noteworthy addition or something for part 3: When calling `super` it's a different thing to use `super()` or just `super` but afaik it's the only edge case in that regard.
Note: The manuscript source includes many single-file ruby script samples, see &lt;https://github.com/yukimotopress/programming-blockchains-step-by-step/tree/master/manuscript&gt;. Happy mining and blockchaining with ruby.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [yukimotopress/programming-blockchains-step-by-step/.../**manuscript** (master → e6765a0)](https://github.com/yukimotopress/programming-blockchains-step-by-step/tree/e6765a0b6ca2bcf915d0d1a02b9b65430a21fbc3/manuscript) ---- 
It has officially ended with the release of 2.2.10 https://www.ruby-lang.org/en/news/2018/03/28/ruby-2-2-10-released/
Thanks!
The last word you were looking for is awesome...not great
Iteration is faster over arrays. Random lookups are usually faster on hashes. Measuring it proves this: $ seq 1000000 | sort -R &gt; input.txt $ head input.txt 768673 428501 834853 361329 621286 165599 772359 101041 827053 597053 $ ruby -rbenchmark -e 'h={}; ARGF.each {|s| h[s] = s.to_i}; puts Benchmark.measure{ h.each_value {|i| }}' input.txt 0.210000 0.000000 0.210000 ( 0.217624) $ ruby -rbenchmark -e 'a=ARGF.readlines.map(&amp;:to_i); puts Benchmark.measure{ a.each {|i| }}' input.txt 0.030000 0.000000 0.030000 ( 0.025642) 
I think what OP means is wahy `hash[key]` is faster than `array.select { |i| i == key }.first`? If that's the case, it's because of the way the data structure is organized. If that's the case, [check out tree data structure](https://en.wikipedia.org/wiki/Search_tree). There are several ways to implement a hash though.
Yeah, completely right and really thank for your feedback.
"aren't really all that great" -- fair enough. "simply terrible" -- toxic, not nice. Word choice matters.
Do you mind posting a version of this class written in Go that you consider to be good? I don't see anything wrong with this version in Ruby, but I am definitely interested to see what someone else would consider being really good in another language I am not familiar with.
in your example .select iterates through the entire array as well... Array's :[] and Hash's :[] are ~= though. The (semi) equivalent hash function to the `.select` would be: `hash.select{|k,v| k == key}.first[-1]`
Yes, what I meant to say is that fetching a record from an array, is `O(n)` while fetching it from a hash is `O(log(n))` 
With Honeypot leading companies will send you interview requests. 
If that does not help, the admin then takes a look at the views and adds fragment caching. 
Coordinated Universal Time is the “standard” world time. 
Not exactly sure what you mean by 'fetching a record' but going to assume you mean access by index. In that case Arrays entry fetching should be O(1) and Hash fetching should be O(n) [1]. [1] http://bigocheatsheet.com/
Very cool!
Isn't indexing into both an array and a hash O(1)?
Let's be clear with semantics: Big-O notation is the absolute WORST case (EVEN if it only happens .00001% of the time). Big-Θ is the average case (it IS relevant how frequently cases happen). For hashes accessing is generally considered Θ(1), but unfortunately the worst case is O(n)... Consider a standard hash table if all n entries were to receive the same hash value from the hashing function. The algorithm would be forced to go through the entire key list of n entries in the hash bucket to find the match. Now obviously this isn't GENERALLY true since hopefully the hashing function is more random with MANY buckets (in reality the theta is closer to Θ(n/b) where b is the number of buckets in the hash but in general b &gt;&gt; n).
Big-O means that the function is bounded *above* by another function; that is, it will be *no worse* than that function. Big-Ω means it is bounded *below* by that function, meaning it is *no better* than that function. Big-Θ means it is bounded both *above* and *below* by that function. All of these can be used in the context of best-, average-, and worst-case. Indexing into a hash is O(1) in the *average* case. It can be O(n) in the *worst case*, but that would only happen if all objects hashed to the same bucket.
I misunderstood the question I think... I was talking about full-scan search vs search trees :P
Thank you for sharing this. Excited to give it a try :) 
Just give me a newsletter that doesn't get 75% or more of its content from Reddit. 
It's not a search tree, it's a [hash table](https://en.wikipedia.org/wiki/Hash_table) hence the name `Hash`. As the others mentioned, (after growing when a certain number of collisions occur) access is ideally O(1) and not O(log n).
No, as the others mentioned, in a hash table, you use buckets to resolve conflicts, not search trees - which led to the comment about the O(n) being the worst case. However, MRI Ruby (since [2.4](https://github.com/ruby/ruby/blob/ruby_2_4/st.c)) uses [Open Addressing](https://en.wikipedia.org/wiki/Hash_table#Open_addressing) rather than the usual [Separate Chaining](https://en.wikipedia.org/wiki/Hash_table#Separate_chaining). Long story short, this uses a single growing array for the buckets (bins) and probing rather than chained arrays/linked lists; for most cases the former is faster than the old approach. [Here's an article about it from the developer who wrote it](https://developers.redhat.com/blog/2017/02/27/towards-faster-ruby-hash-tables/). 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ruby/ruby/.../**st.c** (ruby_2_4 → 753aa75)](https://github.com/ruby/ruby/blob/753aa75319282297c41a02d9932b5d88ba575112/st.c) ---- 
I see. I guess this makes sense for Ruby. I guess trees are better for databases and stuff.
I think about it like this: Why is a librarian able to find a book faster in a massive library than I can on my small bookshelf? Because the books are deterministically indexed at a library but my bookshelf is just a random assortment of books. Same idea with hash tables: the items in the hash table can be located deterministically using an objects `#hash` identifier. From there it's a matter of accessing an index in an array. There's a bit more to it (i.e. looking through buckets once the index is found), but that's the basic idea.
See [Best of Practicing Ruby](http://yukimotopress.github.io/practicing) at the [Yuki &amp; Moto Press Bookshelf](http://yukimotopress.github.io).
Thanks for the clarification.
Practical Object-Oriented Design in Ruby (POODR) https://www.poodr.com 
Ok, apparently you decide what’s ok and not. If you feel sad about the fact that I call a parameter an argument in my article.. there is more important things in life. 🙃🙂 Have a nice day
Thanks, I do have that one but I kind need something with more code examples. I also have 99 bottles.
Is 99 bottles any good?
The Rails 5 Way https://leanpub.com/tr5w
I liked it. It was more my level.
I remember DHH saying that N+1 queries is a feature and that it might be useful when you do Russian doll caching. But i agree usually you don't want it. There are gems that notify u when u do N+1 queries, like Bullet, so I don't think it's a big issue. 
Remember he has a book to sell so a problem has to be created. 
99 Bottles is one of my favorite books, along with Refactoring, Ruby Edition. 
I really like Sandi Metz but I just can't recommend this book. It seems to be the only Ruby book that junior Ruby devs care to know about, but it's very long winded, and it's not even a long read. I recommend highly Eloquent Ruby by Russ Olsen to take you to the next level. Also checkout Tom Stuart's books, he's a fantastic developer. 
No. For example, if you index both tables by created_at, the PG query planner will push the condition down and use both indexes. Very close to as efficient as using a single table. You can also get a similar result using PG table inheritance.
&gt; Yea, that view will perform terribly on all database I know of. Are you sure? Given indexes on the underlying table, PG will happily push down the conditions, and if you swap the UNION for a UNION ALL, you've basically got functionally the same situation as inheritance/partitioning.
However PG doesn't push down `LIMIT` or `ORDER BY` so you'll still end up building huge result sets in the memory.
The irony here is that most of the alternative solutions that address the “problems” inherent with Rails are hosted on Github, which is a very large &amp; complex Rails application (Same is true of Gitlab). Demonstrating empirical evidence that some companies &amp; teams have figured out how to find success at scale in spite of the challenges that trip others up.
Came here to recommend the same, phenomenal book.
&gt; wouldn't it just make more sense for #class to use the same mechanism as the method lookup No. The utility of the `#class` method is to tell us the class from which this object was instantiated. It is not to return the first class in the method lookup list, because that is by definition *always* going to be the eigenclass of the object, which is therefore neither useful not particularly interesting.
Yeah, I agree that these AR limitations typically won't make a difference between the business succeeding or not. But it does mean they have to make hacks around these limitations, which is never ideal.
I didn't know the video host was protecting the streaming in some countries. Where are you trying to stream from? I ll see if I can put it on YouTube then
Nice.
policy objects are so simple that i prefer to roll my own. that said, there appear to be [wrappers for pundit](https://github.com/smartinm/sinatra-pundit/blob/master/README.md) to integrate it into Sinatra.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [smartinm/sinatra-pundit/.../**README.md** (master → f988d1b)](https://github.com/smartinm/sinatra-pundit/blob/f988d1becaddc23e34dd4ec5940386433671dd68/README.md) ---- 
Hi, great article. How do you test "functionally" when it comes to interacting with the database?
I would categorize database or external resource interaction as a form of IO, and try and keep that as far to the edges of my application as possible. Ryan Bigg had some interesting ideas on this in his Exploding Rails talk / book using ROM. That said, this helps primarily with Unit level tests, eventually you're going to want some form of Integration or Acceptance level testing as well to cover how it all fits together.
The secret is that you don’t entirely need to forego it to get some of these benefits.
Good write-up! I thought this would be a very different post, but it's still OO, except done right. I think a lot of the bad rap OO gets is not inherent of OO itself, but a weakness which can be avoided by adhering to a few rules. Just because a language lets you get away with a lot, doesn't mean you should do it.
I don't think Pundit is Rails specific at all. It integrates with Rails easily, but all the code is pretty straight forward.
Admittedly I'm counting the seconds before some of my more Haskell oriented friends jump me for it ;)
Sometimes I just start writing and writing and writing and.... This one is around some of the ideas that combined closures and OO techniques to make libraries like Qo and Xf among others. In the same vein as the previous article, we have more than one paradigm to use in Ruby so it'd be a shame not to give it a good run!
pundit is hardly rails\-focused. 
I second this one and there is actually an updated version of this book named Metaprogramming Ruby 2
Writey writey writey. Had a lot to try and put on paper, so breaking it up into more than a few articles. This one veers deeper into the FP abyss, and in some ways goes counter to how you'd normally program in Ruby. That said, explicit flow control in data pipelines has saved my tail on multiple occasions.
It is absolutely fair game to get a hold of.
Do that more than a few times, and you begin to realize this gets cumbersome.
&gt;&gt;&gt;Release with a deprecation notice. This will be identical to the bugfix release, only it spams your logs with a deprecation notice. This is a separate release so that you can upgrade to it at your leisure. It'd be good to have a deprecation notice on the Github page indicating this is coming, simply so new people finding the project don't invest in setting up with something that won't be around much longer? Not all read Reddit.
https://github.com/thoughtbot/paperclip/pull/2599#issuecomment-388448271
I think I’m quoted in it. Or at least I was asked for a quote for it. Author is a really good speaker as well.
The end of an era. 
A bit sad but maybe not unexpected.
Anyway, thanks so much for the great work done around Paperclip. All my projects still depend on it.
Conflating IO with method logic can become difficult to test and refactor over time. Methods should be agnostic to how they get data, as long as it's in a format they can properly respond to. The idea is to abstract knowledge of state out as far as it can reasonably go, leaving your private API free of concerns about it. `gets` is a blocking method, and one I would almost exclusively avoid unless you're using it at the outer bounds of your application for some type of interactive CLI. If it becomes unwieldy, your application is likely doing too much and needs to be broken down into smaller parts.
Injecting an object for IO is exactly what part of the post mentioned. The entire point is to avoid directly calling it inline and getting stuck to a single implementation. The point is to keep blocking / IO actions separate. Dependency injection is one way of doing that. Propagating data down and performing actions up is another way. What's practical depends largely on the circumstance. Really, the entire point of the article is to be pragmatic about it and use what you can when you can to have cleaner interfaces which can be more flexible depending on what they're acting on.
Chrome will start marking in the URL bar that an HTTP website is unsafe, but won't cause an interstitial. So probably not what you're talking about. I figure the error you're seeing is because their certificate has expired. (Specifically on Feb 10th, a few months ago.) It's a Let's Encrypt certificate, so they need to re-run their scripts (certbot maybe) and renew the certificate. They don't have a complete suburl redirect set up. Only the index page redirects incoming HTTP traffic to the HTTPS website, which is why the URL /u/ASIC_SP posted works. The reason you only see a basic HTML page is because they include various images, CSS and Javascript over HTTP even when serving an HTTPS request. This is huge no-no in web security - [Mixed Content](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content) is something to avoid as you break the integrity promises of TLS. So modern browsers will refuse to load that content over HTTP, causing you to see only the basic HTML render.
This is giving me an unexpected feel. RIP
what about ruby-devscoop: http://ruby.devscoop.fr/
Out of interest, what is your background in functional programming? No offense, but i often notice these exact blog posts and gems coming from someone who has just been learning haskell for 2 weeks and suddenly feels enlightened - rather than an actual gnarled, highly experienced FP practitioner ... ;)
Thank you for the great write up. Very cool to see someone using Dokku in the wild and your guide will make it very easy for me to make some changes on my own setup. I wonder if storing for a month rather than two weeks would be better. For anything with decent traffic you should know about problems pretty quick but on a lower traffic site you might not. I’m probably just being overly cautious however. 
I am not a lawyer. Post is just a summary of what I did for my apps until now, after digging through the net for info. About the retention period I think it all goes down to whether you will be able to justify a retention period in case of a potential control.
Every time I put my heart out there, I have to back out the changes when the library dies a year later :( 
merged
I use default GA config. I think that an option I mention in the article is about obfuscating IPs they collect anyway. Correct me if I'm wrong
Personally, ActiveStorage isn't doing it for me, isn't making it easy enough to customize in the ways I need. But paperclip hadn't really been getting the maintenance it needed. Sadly like many thoughtbot open source projects, which start out looking very good and well-designed, and end up not getting the ongoing maintenance I need. It's open source, nobody owes us anything, but I've become cautious about thoughtbot dependencies. My interest these days is in [shrine](https://shrinerb.com/). 
I have found that leaving the configuration object "open" to any arbitrary keys seems convenient and is certainly easy to write -- but ends up being a mess later. With typos in config keys not failing fast, and no obvious single place to look at in the code for the list of legitimate recognized keys, it just leads to confusion and frustration, in anything that is going to last a while. I guess in some ways it's analagous to static vs dynamic typing. Although i still love ruby and feel no need for static typing in general, in this case I've been trying to move to configuration objects with a 'closed' list of acceptable keys (and sometimes even validity checking on set). (Also trying to avoid `hashie`, which I used to find convenient for configuration objects). The extra work up front pays off down the line. 
What if anything did you do to comply to the GDPR’s version of the cookie law? I’ve been curious how others have been handling that since the open source projects seem to all be focused on the older cookie law.
I am not yet sure how to solve it. As for now I have banners informing that I use cookies and I mention them in my terms. Any tips on that ?
All of them, definitely. Rails should swallow entire Ruby infrastructure and everything anybody written useful in Ruby ASAP.
Well, they do have ActiveStorage which is a decent solution for file uploading. I think having a built in authentication/authorization solution would make sense since these are two very common things that get built into nearly every application I build.
First I've heard of shrine. Thanks for that. If you haven't already, [carrierwave](https://github.com/carrierwaveuploader/carrierwave) would be another one to try.
I’m not sure either haha. The law gets very confusing. Best I can figure is it now requires explicit consent for any cookies not deemed “strictly necessary”. Analytics cookies can be automatically loaded if they contain no PII, but considering most do by default, something has to be done there. Login and session cookies (specific for Rails) would seemingly be considered personal info and would have to be disable until explicit consent is given. [Cookiebot](https://www.cookiebot.com) has a service for this but their pricing really sucks for larger sites. But their examples are good for what seemingly has to be done. Scouring through /r/gdpr may be of some help too. But generally speaking there seems to be a lot of conflicting information out there regarding cookies.
Devise/some form of auth/auth gem.
Not sure why downvoted. But that said, you can use ip for the general geo stuff, it's just collecting specific ips into GA that would trigger this. Source: We had to tell a client to go to Google to see what Google could do about undoing the delete bc they did it unannounced and told the client it was due to the IPs being stored in GA (PII). 
You don't have to do anything unless you are offering the gem for download.
I don't think the conclusion of the article is sound. If a job performs a query internally to determine if the job should be run, then it becomes impossible to actuate the job without meeting the preconditions evaluated by the query. For instance, to test the job in this post, you'd have to generate a user that wants notifications. This is a step backwards in terms of design: i.e. I want to actuate something I'm testing, but in order to do that, I have to set up an unrelated constellation of objects. The job should therefore _not_ be concerned with determining whether it should run. In fact, we simply should not enqueue jobs that aren't supposed to run. On the other hand, all jobs must be idempotent. Therefore, they have to *at least* query to determine if they've already completed their task. That's a different concept than whether the job should be performed, though. So I would expect there to be some logic for each job that causes it to ignore the job if the work has already been done. This kind of query in a job is unavoidable. The only code that belongs on a job is code that is _of_ the job. Determining whether a job should be enqueued or not is logic that belongs in whatever controls the issuance of the job.
I thought I didn't think there were any, but you convinced me here. I'm not actually super happy with devise, so I'm not too worried about a Rails version being worse. I'd love to have something built in that Just Works. 
[https://tldrlegal.com/license/mit\-license](https://tldrlegal.com/license/mit-license) is a good site for understanding licenses a bit better. From what I understand, you only need to include the license in any copy of the software or substantial portions. In the case of ruby it is generally included in the gems you use—if you change/fork code in a gem the license still remains for that gem and it's changes. In the case of JavaScript, I believe you just have to include the license at the top of the source file for that JavaScript code or package. I am unsure of what is required when you minify. The license, in respect to a general "ruby app", only really comes into effect when you give/sell/publish the software to someone else. The execution of the software\(s\) doesn't seem to require you to display a license to the public in any way; just in the source code—which may or may not be seen by anyone other then you or your organisation. This is my understanding anyway...
&gt; The code enqueuing the job doesn’t need to care whether the work of the job needs to be done or not. It aids comprehension to keep the logic about when to do something near to the code that actually does the thing. This will make the code easier to understand when you come back to it later. I feel the opposite. The logic has to live somewhere, and the controller is the module with the brains. Moving the logic out of the controller into the job just makes the job more complicated. The job then has more than one responsibility - I think it’s better to keep them simple and focus on the task that they’re doing. The same applies to everything honestly. Is it better to have functions that handle all kinds of error checking, or to have a layer above the function call that sanitizes inputs and passes sane data? One of my favorite philosophies is “Guard the hinterlands, not the border,” a quote from Confident Ruby. It means that in order to have clear, confident code, you have to have well defined layers and responsibilities. Every function in the entire application can’t do error checking - it will weigh your code down and add a tax onto every line that you want to write. Someone up the chain has to sanitize inputs so that you can focus on expressing logic in its simplest form. Practically, it means pushing the “ugly” logic of error / edge case handling to factories that create appropriate objects, for example Null Objects for handling error cases. Down the chain, the logic can genetically operate on any object its passed. It’s a real game changer when you adhere to this. 
(not the author) I don't think the idempotency issue is that different actually. Because of idempotency, jobs already often need to pay attention to state -- does it make that much of a difference if it's state the job itself effects, or not? (And in this case, we don't have a definition of `user.wants_notifications?`, so it _could_ be state the job effects, although the name of the method doesn't really suggest it, agreed). If you need to check that condition every time before running the job, but the job can be launched in more than one place, then we seem to have three alternatives I can think of: 1. Every place that launches the job needs to check the condition itself. Un-DRY in an undesirable way, it's easy to forget to check it, it's easy for the logic to get out of sync and not all be checking the same/right thing. 2. Job itself checks. 3. We create a NEW class the `SendNotificationJobRunner`, and all it does is check the condition and then (conditionally) launch the job. Every call site calls the `SendNotificationJobRunner` instead of actually calling ``SendNotificationJob` directly. So at least the conditional logic is DRY... but I don't see any real advantage to this added non-conventional architectural complexity. If you need to sometimes run the job without the condition -- provide some parameter to the job that by default runs the condition, by can be given an arg to not run it. Granted, the ActiveJob API doesn't make this easy. I actually don't think the ActiveJob API is quite right, in general. So what I often do, I go even further with your suggestion "The only code that belongs on a job is code that is of the job", I take it further and try to put _nothing_ in the actual job but calling out to another object that does the real work. Because I do not like the ActiveJob API, I find it inconvenient for parameterized args like I'm suggesting here, and inconvenient for testing. So I do something like this. class SendNotificationJob &lt; ApplicationJob def perform(user, message) SendNotification.new.execute end end class SendNotification attr_reader :check_precondition? def initialize(check_precondition: true) @check_precondition = check_precondition end def execute if !check_precondition? || wants_notifications? do_stuff end end end The SendNotificationJob doesn't really even _need_ any testing. The SendNotification class is a PORO that can be constructed with an API that makes sense, and is easy to test however you like. And, if you want/need it, it's easy enough to give it a flag that determines whether it checks the precondition or not. If you didn't realize you needed this flag at first but later add it -- also no problem for existing call sites, both cause we can easily add it as an optional keyword arg in the constructor, and because existing callsites are probably calling the SendNotificationJob anyway, not a SendNotification object directly. So, uh, I guess I came up with a fourth option. This is what I would actually do. 
Thank you, this is a good point!
Good post. I'll take issue with one thing, but agree with the rest: &gt; Every place that launches the job needs to check the condition itself. Un-DRY in an undesirable way, it's easy to forget to check it, it's easy for the logic to get out of sync and not all be checking the same/right thing. This really depends on the purpose of the background job. Most likely it's for a single use case, and the job is not actually going to be used in multiple places. If it's somehow justifiably intended for multiple use cases, then I'd write a command object that enqueues the job, encapsulating the logic that determines if the job is necessary to perform. I'd then take a dependency on that command object wherever I need to cause the job to be enqueued. I strongly agree with keeping the background job class minimal. Whatever it _does_ behind the scenes should be something I can exercise directly in e.g. a rails console. The background job subclass is just an integration (or "mesh point") with the job library. Logic doesn't really belong there, either.
F
I
Ah, great suggestion! Thanks. That also reminds me of WebMock which I could also add to the list.
What are the best alternatives to paperclip?
N
&gt; then I'd write a command object that enqueues the job, encapsulating the logic that determines if the job is necessary to perform. I'd then take a dependency on that command object wherever I need to cause the job to be enqueued. Exactly how I'd handle it.
Odd that they decided to shutter project down instead of handing it over to somebody else. I'm sure there are and will be tons of apps that will be using Paperclip until the sun burns out. But I guess nobody made an offer...
Good stuff! I really want an APM designed for evented systems that allows visualization of message processing flows. Ideally, it'd be event store agnostic, but I suspect that'd be a tall order.
I would think it would come packaged with the gem when you include it. Have you checked your source files?
Goodbye
Yep We actually have used both over paperclip for some good time now.
This is a collaborative effort between Iodine and Agoo development. The PR to extend the Rack SPEC has become a hot topic.
Methods are stored in the method table. It is a hash table, but it's not a `Hash`, nor any other Ruby data structure. `#method` is the way of reading individual entries out of the table. Singleton method `bar` on class `Foo` would have inspect text like `#&lt;Method: Foo.bar&gt;`.
When using the `method` method, class methods have a dot &amp; instance methods have a pound. Like so... irb(main):001:0&gt; String.method(:new) =&gt; #&lt;Method: String.new&gt; irb(main):002:0&gt; String.new.method(:to_s) =&gt; #&lt;Method: String#to_s&gt; Also, for many methods, you can look up the location for original source w/ the `source_location` method. In a shell, you'll see this... irb(main):004:0&gt; class Foo ; def bar ; end ; end =&gt; :bar irb(main):005:0&gt; Foo.new.method(:bar).source_location =&gt; ["(irb)", 4] For classes written in Ruby and stored in a file, you'll see this... irb(main):008:0&gt; Set.new.method(:replace) =&gt; #&lt;Method: Set#replace&gt; irb(main):009:0&gt; Set.new.method(:replace).source_location =&gt;["/Users/pope4president/.rbenv/versions/2.5.1/lib/ruby/2.5.0/set.rb", 187] And for some native methods, I think the ones implemented in C, you you'll just get nil... irb(main):010:0&gt; String.new.method(:to_s).source_location =&gt; nil
&gt; Methods are stored in the method table. It is a hash table, but it's not a Hash, nor any other Ruby data structure. #method is the way of reading individual entries out of the table. Ya, methods are stored in something called the `m_tbl` on a class, right? I was really just wondering about which class the `bound_method` Method object retrieves the `bar` method from? Neither `foo_1` nor `Foo` are ancestors of `bound_method`, so it doesn't seem like it can inherit the `bar` method. &gt; Singleton method bar on class Foo would have inspect text like #&lt;Method: Foo.bar&gt;. #&lt;Class:0x12341234&gt; means the class was not assigned to a constant. The inspect text for the singleton class for SomeClass would be #&lt;Class:SomeClass&gt; So you're saying there's 3 separate reasons that `#&lt;&gt;` is returned? E.g: 1. `#&lt;Method: Foo.bar&gt;` if it's an instance method on a singleton class 2. `#&lt;Class:SomeClass&gt;`if it's a singleton class 3. `#&lt;Class:0x12341234&gt;` if a class was instantiated without being assigned a constant The only common trend among these 3 things that I can discern is that none of them are accessible via a constant or variable. Is that correct?
You are defining `baz`on line 4, and `source_location` reports the origin as line 4. `bound_method ` is just a variable that is assigned to foo1.method(:bar), and `bar` is defined on line 1. It's not, and never was, an instance of `Foo`. Add `p bound_method.class` and you'll see it's an instance of `Method`.
`Method#source_location`, `Method#call`, etc, don't use the inheritance chain, they get their data directly from Ruby's internal data structures when the `Method` is instantiated and cache them for its lifetime. For example, we could continue adding code after your example and have something like class Foo; def bar; 1; end; end bound2 = foo1.method(:bar) bound2.call #=&gt; 1 bound_method.call #=&gt; nil using the previous definition of the method even though there's no longer a way for `foo1` to use/access it.
I actually think that is *not* the job of Rails. Rails is a kitchen sink, and it should just be a much better kitchen sink then the current offer. I am not arguing for kitchen sinks or Rails though. I think Hanami is what we should be advocating for, sustainable and maintainable Ruby Apps in the long time. But i think Ruby needs both, and possibly even more in other fields to survive. 
That is really cool, I hadn't heard of Crystal. I've been spending a lot of time in C++ and to the static typing actually catches a ton of Errors at compile time. For some quick little projects I don't want to deal with it and that is what I've been using Ruby for. But for anything large I want the extra checks to ensure I don't add bugs further on in the project's life cycle. This seems to provide a good middle ground where most of the complexity of C plus plus isn't required, but a performance and reliability boost his desire. Being so new it's not going to nearly to set of libraries that Ruby has though.
For research related to Ruby, there is http://rubybib.org. If Ruby isn't the *topic* of your research, you're just using it *for* research, then academia doesn't work like that - people generally won't care what language you have used and so there won't be a place for researchers using Ruby - it's your research that people are interested in, not the tools unless they're a research result in themselves.
Sure, but why aren't Ruby then chosen as often as say Python for doing research with? Is it really just because there isn't a NumPy for Ruby?
That's a big part of it. There just aren't as many science libs for Ruby. The other big catch is momentum. Research tends to build on previous work. Python has been the scripting language of choice for some time. 
You’re 100% correct - I updated the quote.
That would be gold!
Numpy and pandas make python easier for data scientists to rip through data and get the results they need. It would be a slightly more manual process in ruby, which the majority of that audience isn’t interested in doing. That’s why most use R anyway 
Most of the Research relates to Data, that is before Big Data or machine learning was a thing. And there isn't enough momentum in Ruby to push those things. Heck if it wasn't Rails Ruby may not have been a languages outside Japan. 
MIT-style license, nothing stopping anyone from forking it if they wish. 
thank you, this is a nice comparison. I'm new to all of this, so it's a process! 
Python integrates with R much better than Ruby That's why
&gt; *However, because I want to convince people to try out Crystal...* Yet another ~~rubyist-click-bait~~ poorly named article with the sole purpose of hijacking rubyist to Crystal...
This. Just add it by default in the Gemfile.
Partly because Ruby originated in the developer world, and Python originated in the academic world. Hence why Python has NumPy and Ruby lags behind in scientific features. 
&gt; bound_method is just a variable that is assigned the value of foo1.method(:bar), and bar is defined on line 1. It's not, and never was, an instance of Foo I was speaking hypothetically about how this wouldn't make sense, and it's not really my question. From the start, I've been fishing for info about where `bar` resides inside of the object model, not where it was defined. Again, I'm talking about `bar` in relationship to the `Method` object which `bound_method` is pointing to, not `bar` in relationship to `Foo` or `foo1`. I was speculating about how `bound_method` can't inherit `bar`.
&gt; The ancestors of a module are all the modules that it inherits from, in order. I've been using #ancestors on classes. I did find it pretty peculiar that the ruby documentation for #ancestors talked about modules, though. &gt; Inheritance is a relationship between modules. I was under the impression that inheritance involved using method lookup to get find methods on superclasses?
This is great news! It was always cumbersome to have to `rescue ArgumentError` when doing strict string conversion to integer. Things will get much cleaner and apparently faster too. But more than that, I think this is very important because it's creating a standard about what is Ruby's convention for distinguishing between exception-raising and non-exception-raising methods. Rails ended up borrowing the bang to make this distinction (as in `find_by` and `find_by!`), but that is not quite the same semantics as the standard library's destructive vs non-destructive distinction and generated some confusion about naming methods with bang or not. But now we will have a standard to follow and I think it will make things clearer in the long run. It would be good if Rails also changed its methods to this new form in the future. I just don't know what would be the best form since many of them already accept an options hash as argument (and maybe one of your table's columns is named "exception", who knows?), but it would be nice for consistency.
What’s this editor? 
It's emacs
I'm guessing at least the live coding synth stuff this is done with Sonic Pi: http://sonic-pi.net/
Yep. https://github.com/repl-electric/adventures-in-algorhythm 
In addition to the answer from /u/chrisgseaton, using mutexes also allows your code to work when using another ruby such as jruby or rubinius.
Yes SonicPi \(though my own custom fork [https://github.com/josephwilk/nicos\-ip](https://github.com/josephwilk/nicos-ip)\) and Emacs is also speaking directly to synths and Unity using OSC. The full stack of tools is: Emacs, Elisp, Ruby, SonicPi, SuperCollider, Ableton Live &amp; Unity3D.
I would suggest using `rvm`.
Either use \`rvm\` as suggested by /u/ioquatix, or something else like \`rbenv\`. For \`rbenv\` you can run \`rbenv install 2.5.1\` and then do \`rbenv global 2.5.1\` to use that version globally throughout the system. I believe \`rbenv\` is also available on Homebrew \(though I'm not 100&amp;#37; sure where I installed it from!\)
I also suggest using [RVM](https://rvm.io/), but other than that it just sounds like you need to fix your PATH. Homebrew probably installed Ruby 2.5.1 in /usr/local/bin. Try typing: $ /usr/local/bin/ruby -v If that returns 2.5.1, there you have it. But you should use RVM.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://rvm.io/) - Previous text "RVM" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
&gt;/usr/local/bin/ruby \-v Nailed it \- that is returning 2.5.1 What should the path be / where should ruby live?
You can always link the ruby you installed with homebrew using `brew link ruby` (you might need to throw in an `--force`, I'm not sure if brew just lets you override the system ruby) Although I agree with people, that if you are doing this more often, you should use rbenv or rvm. But if you just have this one project, just link the brew ruby and you are fine.
Thanks this got it. I had some garbage in my bash files. After cleaning that up, 2.5.1 is now returned. Thanks again!
Cool. It occurs to me now that changing your PATH might affect other things that may be installed in both `/usr/local/bin` and another path in your PATH variable, so just be aware of that.
Open Sound Control https://en.wikipedia.org/wiki/Open_Sound_Control.
[removed]
I personally prefer [rbenv](https://github.com/rbenv/rbenv) but rvm is great too. One other plus for those that work in multiple languages, there is also [pyenv](https://github.com/pyenv/pyenv) and [goenv](https://github.com/syndbg/goenv) using almost exact command patterns.
and don't forget esvm for those needing elastic search versioning.
A personally prefer Chruby 
Like others have said, use `rbenv` or `rvm`. I personally use `rbenv`, but either will do.
Oh! Thanks for sharing. It's brilliant. I really enjoyed it. 
It would be nicer yet to use mandatory keyword arguments. They've been around since 2.0, so all modern Rubies support them!
CRuby can still work concurrently for IO-bound tasks. Many Ruby standard library methods and C libraries will release the GIL when doing external processing (DB access, file access). From https://www.jstorimer.com/pages/more-about-mri-and-the-gil: "But don't forget the caveat! In MRI, when one thread is blocking on IO, MRI switches to another thread and lets it run in parallel. So in a multi-threaded system where you have a lot blocking IO, MRI will perform similarly to JRuby when it comes to concurrency."
They would be nicer in the sense that they communicate requirements better but they also introduce the need for you to keep them in sync with the arguments to the 3rd party method. I'm still on the fence about which one is better.
Your link has the colon embedded in it.
I was trying to use the colon grammatically, as a context for the subsequent quote. Fixed.
Ah, and Programming Rust. I'll probably start with that and Domain Modeling Made Functional, which I picked up because I realized it was written by the Railway Oriented Programming guy ( https://fsharpforfunandprofit.com/rop/ ). Turns out it's quite a good book so far. Rust was more for doing some tighter optimizations to pattern matching. Stealing some ideas from Spark and Scala on that note to try and make it parallelizeable for serializeable entities, so that should be fun.
Yeah, of course, and I fixed it in my address book so I could read the article but thought I'd pass it on in case others were feeling lazy.
\[Sandi Metz FTW!\]\([https://www.sandimetz.com/products#product\-poodr](https://www.sandimetz.com/products#product-poodr)\) I recommend both books Read through open source code. I've learned a lot from the RSpec library.
ah, thanks!
Another chruby fan here. chruby to change rubys, ruby-install to install it.
Learn the principles of OOP separately as far as Im concerned - pretty simple (Lynda.com free week and you should be good) 
Wow, proof that /r/ruby is retarded. They suggest rvm over rbenv.
Wow, nice proof that /r/ruby is retarded. They suggest rvm over rbenv.
You can't depend on the GIL to prevent race conditions in programs which use threads and which call code which releases the GIL. You can absolutely see race conditions in such a program, for example, which uses threads and accesses a database. This means that two threads which set fields on an object can cause unpredictable behavior.
&gt; You can't depend on the GIL to prevent race conditions in programs which use threads and which call code which releases the GIL. Yes you can, if the GIL is being used correctly. If there are bugs in the program, such as using the Ruby API outside of the GIL, then yeah that's broken. That's like any other programming bug like writing to free'd memory - it could do anything. I don't think that's a reasonable criticism. &gt; You can absolutely see race conditions in such a program Well obviously - you can see race conditions in a Ruby program that does not release the GIL. This doesn't have anything to do with the GIL in particular. &gt; This means that two threads which set fields on an object can cause unpredictable behavior. Only in a program with bugs.
Wanna know where that `super()` call leads to? You can use `super_method` https://www.schneems.com/2015/01/14/debugging-super-methods-ruby-22.html
To check if a method can call super, one can use `defined?`. E.g., `defined? super`.
Read "Practical object - oriented design" by Sandi Metz. That book helped me a lot. 
ty
ty yes, someone else recommended that book
Simon Allardice does a great principles of OOP - there's no code but the general ideas - some limited examples use JS but it's more about classes, abstraction, polymorphisms, inheritance, etc...
If in the US, most libraries offer access to Lynda if you have a library card. That’s pretty awesome given how much great content is on Lynda. You can’t beat free. :)
I'll be the third. It's mandatory reading for everyone on my team. 
sweet, cool ty
wow ty
also [nodenv](https://github.com/nodenv/nodenv)
IdentityCache [does not depend on Rails](https://rubygems.org/gems/identity_cache). There's [SecondLevelCache](https://github.com/hooopo/second_level_cache). I though I saw a fork of [Record Cache](https://github.com/orslumen/record-cache) somewhere that supports ActiveRecord 4.2 (linked version only supports up to 4.1). See what [Awesome Ruby](http://awesome-ruby.com/) has to say on this topic. 
oh haha, nice. cool, thanks for the demonstration!
This was a completely useless example. But this is what people refer to when they talk about "monkey patching". This can be useful (for example) for working around a bug in a gem or framework (like Rails), but must be used with caution. Ruby is extremely powerful, and a great language for expressive programming. Just be aware that things like this exist when you're in those "WTF????" moments tracking down some obscure bug.
A `Method` is an object. Where is a `Proc` in the object model? Do not confuse names with the things they name. `Method`s point to method implementations, not method names. Redefining `Foo#bar` doesn't mean that the previous implementation has to be purged from existence, just that it doesn't answer for that name any more.
It is, and Homebrew is the [recommended installation method](https://github.com/rbenv/rbenv#homebrew-on-macos) for Macs. You can tell if you have `rbenv` installed through Homebrew by running the command `brew info rbenv`. If so, it'll say something like " Poured from bottle on 2017-07-03 at 18:53:21" on the line immediately below the *Homebrew keg* URL. If not, that line will instead say "Not installed".
Wow, nice proof that /r/ruby is experienced. FTFY, arrogant twit.
I can humbly recommend you this article I wrote about OOP in Ruby. It starts with the basics (object, class, instantiation, messages, class vs instance methods, etc). Part 2 will continue the basics with public/protected/private, polymorphism, inheritance, the concept of abstract classes, etc. https://medium.com/@mariano.giagante/an-object-oriented-programming-primer-e33142ecaf93
Ya, I realized I had the wrong idea when I remembered that you have to use `Proc#call` and `Method#call`. Putting it another way: class Bird; def fly; "flap flap"; end; end pelican = Bird.new method_object = pelican.method(:fly) method_object.call # Bird#fly isn't being called here, but Method#call is. Therefore, there's no method lookup for the #fly method. I guess my questions now are: 1. what does a "method implementation" look like inside of a `Method` object? e.g., is if I were to implement my own version of the `Method` class, what would it look like? 2. what would a user defined version of `Method#call`look like internally?
I'm also a huge fan of Sandi Metz. Here's a [playlist](https://www.youtube.com/playlist?list=PLgyFUrQT3Nk1U757wmi5I3zFJAxJoLBnF) of some of her talks that I put together https://www.youtube.com/playlist?list=PLgyFUrQT3Nk1U757wmi5I3zFJAxJoLBnF
Only if your experience is that you never used anything else than rvm and that you don't know why it sucks. Lol, kid, don't speak to those who are smarter than you.
Yay I always wanted to replace my IDE with a browser!
interesting, ty!
cool ty! 
ah, do not know what this means, but interesting. still quite new
The code in the OP still needs to be kept in sync with the arguments to the third party method. def self.person(**args) ThirdParty::Person.new(args[:first_name], args[:last_name], args[:age]) end
Noticed that Trestle was left off the list of Admin gems. I haven’t used it yet but it looks pretty nice. It’s relatively new and is actively developed.
wow, truly destructive right there, haha. wow
Why not find the problem in kaminari and fix it? It ought not to be creating all those objects. 
[All replies must be minion themed](https://i.imgur.com/gmbYm3o.jpg)
I'm not 100% sure, but some time ago SciTE used a non-fixed width font by default a while ago (maybe still does?), and it may look weird if you are not into proportional fonts.
I think most Ruby implementors agree that timeout is pretty bad. Timeouts are raised in blocking code by interrupting the call by basically whatever means possible, and it can be very abrupt and unhelpful to the other end, can close file handles so nothing can be communicated when handling the timeout, and they also do some things I believe like create a new thread per timeout. Rubinius re-implemented them using at least a single thread instead of one per timeout. I hope to do something better in TruffleRuby.
Citation please. @ddnexus has no [PRs](https://github.com/kaminari/kaminari/pulls/ddnexus) or [issues](https://github.com/kaminari/kaminari/issues/created_by/ddnexus) made.
Good point, but at the same time, we have to always account for the possibility of the _other_ end of a socket aborting the connection "abruptly and unhelpfully," as you say. Communicating with file descriptors comes with a host of failure scenarios that our programs ought to be prepared to cope with. If we build our systems with that failure in mind, we can deal with any such error in a straightforward manner (retrying). I agree that `Thread#kill` is a pretty heavy hammer, and that users of timeout should understand that's what's going on behind the scenes. I just don't know that we should declare Timeout to be categorically a Bad Thing (TM). I certainly don't think connection pools should be presented as a reason why Timeout has a flaw.
I was surprised by this when I first heard about it. I see a lot of people who use `Rack::Timeout`, for instance. [The warning about using `Timeout` in general](https://github.com/heroku/rack-timeout#timing-out-inherently-unsafe) is burried 10 headings down in the README.
I think the difference is that a timeout should be useful information you can act on. If someone keeps timing out in the same way, then you don't want to just keep retrying. The C API has a function that lets you install a handler to run when a thread is unblocked. Maybe if we could do something similar in Ruby itself you could say unblock the file handle, and also send a timeout message, and then close it.
Very true. Actually, I realize I was being very vague in my comment. When I referred to retrying, it wasn't really about timeouts in particular, just that we always have to be prepared to cope with networking errors (such as the _other_ end of a socket being a blocking IO call in ruby that was interrupted by a timeout).
Forth comment on: https://github.com/kaminari/kaminari/pull/785
Check this issue and feel free to review your judgment: https://github.com/kaminari/kaminari/pull/785
&gt; Communicating with file descriptors comes with a host of failure scenarios that our programs ought to be prepared to cope with. I'm not sure I understand how is this related to `Timeout`. What causes your code to raise an exception isn't communication with file descriptors, it's the fact that the `Timeout` library calls `Thread#kill` on the thread that's executing the block given to `Timeout.timeout`. &gt; I just don't know that we should declare Timeout to be categorically a Bad Thing (TM). I certainly don't think connection pools should be presented as a reason why Timeout has a flaw. I think the connection pool example was just an illustration. The reason why the `Timeout` library is bad is because the only way to ensure the cleanup code will be executed is to use `Thread.handle_interrupt`. To see how it works, I'll paste the example from the documentation: th = Thread.new do Thread.handle_interrupt(RuntimeError =&gt; :never) { begin # You can write resource allocation code safely. Thread.handle_interrupt(RuntimeError =&gt; :immediate) { # ... } ensure # You can write resource deallocation code safely. end } end Thread.pass # ... th.raise "stop" I think it would be terrible to have to do this, `begin...rescue...end` blocks are already enough. Since 99% of libraries we're using don't use `Thread.handle_interrupt`, I think there is no point considering this. I see this and Mike Perham's post as a reminder to people that they should use `Timeout.timeout` only if absolutely necessary, and to make them aware of the potential consequences. I think it's easy to think that HTTP.timeout(:global, connect: 1, write: 1, read: 1).get("http://example.com") is pretty-much the same as Timeout.timeout(3) { HTTP.get("http://examplee.com") }
Haha, oh wow. So there's a PR that has nothing to do with performance. Just a thing that renders a placeholder. Got rejected because it bloats the gem and can be easily worked around by 0.001% of users that actually need it. @ddnexus goes on on a rant and then makes his own gem because "it's easy". Brilliant. Converting all my projects to Pagy immediately. 
I've never used it either, but looks cool! Definitely something worth considering when I have some spare time. [Thanks](https://media.giphy.com/media/oobNzX5ICcRZC/giphy.gif) for the tip.
[Great idea, but this one is creepy](https://media.giphy.com/media/lKZEeXJGhU1d6/giphy.gif)
&gt; I'm not sure I understand how is this related to Timeout. What causes your code to raise an exception isn't communication with file descriptors, it's the fact that the Timeout library calls Thread#kill on the thread that's executing the block given to Timeout.timeout. I think it's to do with file descriptors because to kill a thread that is blocked on IO (which will usually be the case with something that's timed out) you need to do something quite brutal to get it out of that system call and to handle the Ruby kill exception. That can leave the socket closed for example.
&gt; I'm not sure I understand how is this related to Timeout. What causes your code to raise an exception isn't communication with file descriptors, it's the fact that the Timeout library calls Thread#kill on the thread that's executing the block given to Timeout.timeout. Yep, I am aware. What I was referring to is the effect that the thread being killed has on the world outside the process. When a thread owns a resource like a file descriptor, and the thread is killed, the runtime environment (ruby + the operating system) have to ensure that resource is freed. When threads are making use of a resource that is scoped _outside_ the thread boundary, it's a different story. That's why I'm suggesting that we can't just look at this as Timeout being bad. It's the _combination_ of Timeout and sharing resources globally across threads that leads to problems. &gt; I see this and Mike Perham's post as a reminder to people that they should use Timeout.timeout only if absolutely necessary, and to make them aware of the potential consequences. That part I entirely agree with. Whenever our IO operation avails us the ability to set a timeout directly, there's _no_ reason to use Timeout. However, in the case of a generalized HTTP server request timeout, I don't know that there's any way to accomplish this without terminating threads.
Yep, exactly. And the reality of computers is that the world outside our ruby process is already, in fact, a brutal one, and we can't entirely isolate our programs from it anyways. We _should_ be friendly as we can in our handling of file descriptors, closing them if we're in the process of being terminated, etc. That's why I entirely agree that we ought to prefer timeouts for individual IO operations. But we _also_ should presume that our processes can be brutally kicked, punched, and ultimately terminated at any time. This means that our threads should own their own resources and not share them.
oh, I missed that. That's annoying! Is there a PR or Issue to look at? I filed a similar issue on kaminari back in 2011 (https://github.com/kaminari/kaminari/issues/137), and a colleague sent a PR to kaminari to fix it also back in 2011. (https://github.com/kaminari/kaminari/pull/154) I wonder what's up with kaminari maintenance. Personally, I'd rather even _fork_ kaminari and improve it than start or switch to a completely new thing. 
&gt; EVERYTHING in Ruby is an object, Methods in Ruby aren't objects.
Uh, yeah, if there was a PR to fix the performance problem, that's not it. If the OP author found the source of the so-many-objects, it would be useful to share, in case someone else actually does want to fix it. 
Are you sure? pry(main)&gt; class Foo pry(main)* def self.foo_method; end pry(main)* end =&gt; :foo_method pry(main)&gt; fm = Foo.method(:foo_method) =&gt; #&lt;Method: Foo.foo_method&gt; pry(main)&gt; fm.class =&gt; Method 
That was a nice highlight, and thanks for the shout-out! I would just like to comment on a few things. &gt; It’s a built-in way to deal with uploads without extra dependencies like Paperclip, Carrierwave or Shrine. &gt; &gt; [ ... ] &gt; &gt; Since ActiveStorage has been merged into Rails, all the features described above are built-in and don’t require any extra dependencies and so less maintenance needs to be scheduled Well, Active Storage is technically also an "extra dependency", the difference is just that it ships with Rails. That has some pros, such as that it will always be up-to-date with latest Rails releases (though Shrine, Refile and Dragonfly will as well, because the don't depend on Rails, except for the small Active Record extension). But, it also has some cons, such as being tied to the Rails' release cycle; e.g. the ImageProcessing feature you mentioned will only be available starting from Rails 6.0, which I'm guessing will be about a year from now. &gt; Most popular gems like Shrine, Paperclip, etc. don’t provide ready-to-use tables and require a migration to add a few fields where you want to store your file information. Even if you feel free to do what you want and you’re not stuck to the ActiveStorage way, from my experience you’ll certainly recreate a polymorphic Asset model. Yes, Active Storage's Attachment/Blob polymorphic design is very compelling, I'm thinking of writing a similar extension for Shrine. &gt; As we seen above, ActiveStorage attaches and detaches files outside ActiveRecord transactions. You need to do it by yourself when you need to, independently from a save, whereas common gems store your files using ActiveRecord callbacks directly from your params. In my opinion, ActiveStorage provides a better way to handle file attachments by separating two concepts: attributes which go in the database and files which depend on your storage. That's a good point, I also think that it's better when attaching is explicit. In Shrine this led to some unexpected gotchas, such as people relying on certain model attributes being present during attachment, but they weren't because the attachment was assigned before some attributes (the user chooses the order of attributes via strong parameters). It might seem more convenient at first, but I think it's less flexible. ------------ Btw, there is one thing I noticed when reading Active Storage regarding variants that I found far from ideal. This is what happens when visiting a variant URL: 1. Rails routes the request to `RepresentationsController#show` 2. controller retrieves the Blob record from the database 3. controller checks whether the variant has been generated (which for external services means a HEAD request) 4. controller redirects to the direct (expiring) URL of the processed variant I think that is a lot of overhead for displaying each individual thumbnail (1 database call + 1 HEAD request + 1 redirect). It would be nice if these requests were cacheable, but I think that the response being a redirect and the `Location` being an expiring URL could complicate things.
[https://github.com/asdf\-vm/asdf](https://github.com/asdf-vm/asdf) takes a little getting used to, but now I use for just about everything.
Another admin gem I've been meaning to try is called [Wallaby](https://github.com/reinteractive/wallaby). It was presented at a meetup I went to, seems like a flexible admin console solution, although I've not really had a chance to use it yet.
My favourite programming book, ruby or otherwise. You can't go wrong :D
If it were the method itself, then `Foo.method(:foo_method).object_id == Foo.method(:foo_method).object_id` would be true, but it's not. This is because methods aren't objects. A Method object represents a method, including a closure over the original object, but it isn't the method itself, and it isn't allocated unless you specifically ask for it. It's a lot like Procs vs blocks. Blocks are not objects; if you need an OO wrapper for a block, you instantiate a Proc object by passing a block to a Proc constructor, e.g. with either `Proc.new` or `-&gt;`. Sometimes Ruby just does it for you, e.g. when dereferencing a explicit &amp;block parameter. The Proc represents a block, and has a reference to the block, but it isn't the block. 
nice!
&gt; You can't really tell. No, you can definitely tell, because like I said, `Foo.method(:foo_method).object_id != Foo.method(:foo_method).object_id`. The method is not the Method object. &gt;is that Method object the method itself? Or is it a wrapper around the method? The latter. &gt; Or is it a converted version of the original method? Nope. &gt; I can work with a method just as if it were an Object. No, you can ask the Method object to do things on your behalf. You don't get to mess up the method itself. The only thing you can directly with methods is declare them. Everything else is by proxy. 
I don't like all these "new feature to hide an error!"
 you as a developer and also for your users, who will be delighted with a fantastic app!
 One of the most interesting is Hot Module Reloading, supported out-of-the-box in Webpacker.
I also wrote about why this is bad with a suggestion on how we could change the API to allow for a safer timeout. https://www.schneems.com/2017/02/21/the-oldest-bug-in-ruby-why-racktimeout-might-hose-your-server/ As Seaton mentioned already the problem is that the timeout can fire when cleaning up anything, not just when checking connections back into thread pools. 
Informational!
This is a sub for Ruby the programming language. We do love our gems, but you might want to try a different sub. 
This is spam.
Keep commenting -- it increases the Engagement and drags more people here.
That's true, but the arguments to the `person()` method do not.
&gt; With keyword arguments, I can choose any order I want at the callsite, but if the name of the arguments change, I have a different kind of update to make to every callsite. Yeah, maybe. If the names change, but the position &amp; logic doesn't... your factory still works. Otherwise, the 3rd party is breaking the contract in which case it's more complex refactoring anyways. 
Coooooooooool!
I’ve talked to a few people about it and it gets knocked for using a DSL while Administrate doesn’t. Some people just want plain Ruby. I’m undecided on that. Right now having a DSL doesn’t bother me. Maybe I’m just not advanced enough yet. 
It's more like in SciTE the output is not lined out very well. The rows and columns are not "clean", like not all numbers are directly underneath each other. I can't solve it with formatting and it's nice and clean in irb. But thanks anyway!
By 'forced' path do you mean less options? If so I'm not sure that it's a benefit.
You're welcome, I'm glad you found it useful :)
[It seems a little better, but I'm not there yet.](https://imgur.com/a/65EXmnb) To be clear: I just enabled the 'use monospaced font'. Haven't tried adding anything yet.
Ah, okay, thanks
^(my pleasure) ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
Link to the [RailsConf 2018 playlist](https://www.youtube.com/watch?v=zKyv-IGvgGE&amp;list=PLE7tQUdRKcyak-yFKj5IN3tDYOh5omMrH) instead of just Confreaks’ newest videos.
Warning: the sound quality is terrible
Thanks, good catch :)
I know, I was joking.
Hey thanks. It is more than likely going to be on the database side. The project could be described somewhat as a dynamic game with an enormous amount of live / simultaneous interaction going on. Logistically we haven't gone down the road too far yet, but trying to figure out the most efficient way to get data in realtime from user-to-user as well as storing it in the system (so I'm envisioning a kind of p2p + server sync going on in order to provide some redundancy and fast updating per quadrant / zone). It's also extremely graphically very heavy, but I don't suspect that will be a bottleneck since we won't be storing the asset data in the database (and yes, probably using Cloudfront for that).
The proposal for new method is [discussed](https://bugs.ruby-lang.org/issues/14423) in Ruby tracker. As asked by Ruby maintainers, I've also released the functionality as a (very small) gem, for everybody to experiment. Demo of functionality: # Most idiomatic "infinite sequence" possible: p 1.enumerate(&amp;:succ).take(5) # =&gt; [1, 2, 3, 4, 5] # Easy Fibonacci p [0, 1].enumerate { |f0, f1| [f1, f0 + f1] }.take(10).map(&amp;:first) #=&gt; [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # Find next Tuesday require 'date' Date.today.enumerate(&amp;:succ).detect { |d| d.wday == 2 } # =&gt; #&lt;Date: 2018-05-22 ((2458261j,0s,0n),+0s,2299161j)&gt;
It's more akin to a game with a tremendous amount of interaction and realtime graphical events going on. I don't necessarily mean less options, but rather being forced to think through options and function before pulling them into the app - being forced to choose correct or "best" existing libraries (or implementing our own if they don't fit the spec well enough).
Ah okay. You should look into using Memcached. You can store the real-time data in cache and serve it via API or Websockets. You can use a background worker to persist to the database. This will take all the pressure off your db and into your memcached server.
Functionality seems useful, but I don't like the name, this is more analogous to `reduce` / `inject`. 
What you want is fixed-width font for error window in SciTE. The config I pasted before might let you achieve that. I'm not 100% sure.
What does that issue have to do with performance and memory consumption issues? Am I missing it?
I have Ubuntu installed on a 128GB SSD and recently I noticed my disk space is almost gone, so I decided to create this script to help me (and others) delete unwanted stuff from RVM.
`enumerate` is basically a synonym for `each`. It will be really confusing for users. `enumerate` doesn't indicate anything close to the fact that there is a recusion, that it is infinite or that you build up more values from what you have. This feature is basically the opposite of `reduce` / `inject`. Too bad ruby doesn't have the alias `fold`, because `unfold` would have been a good choice. Names i find much better: * `build_up`: shorter * `recurse_with * `and_recursively` : I like that it's clear that the initial object is part of the values returned. 
Great post
Not to mention that approach is dangerous for many companies and sites. Be prepared to have future issues with legitimate requests getting blocked, especially if you're B2B. Rack::Attack comes with the self-hosted version of Gitlab, and I first became familiar with it when it started blocking requests from within our internal office network. Since everyone connects through the same external IP, it decided to block requests during a deploy. Spent a couple of hours figuring that one out :(
Seems good and useful to me. I'd vote "in" :)
Take a look at the Pagy codebase and prepare for eye bleeding. def pagy_link_proc(pagy, lx=''.freeze) # "lx" means "link extra" p_prev, p_next, p_lx = pagy.prev, pagy.next, pagy.vars[:link_extra] a, b = %(&lt;a href="#{pagy_url_for(MARKER)}"#{p_lx ? %( #{p_lx}) : ''.freeze}#{lx.empty? ? lx : %( #{lx})}).split(MARKER) -&gt; (n, text=n, x=''.freeze) { "#{a}#{n}#{b}#{ if n == p_prev ; ' rel="prev"'.freeze elsif n == p_next ; ' rel="next"'.freeze else ''.freeze end }#{x.empty? ? x : %( #{x})}&gt;#{text}&lt;/a&gt;" } end 
I would say it isn't terrible but rather it's just quite silent. I have to listen on Max if I am in a noisy environment.
&gt; If the OP author found the source of the so-many-objects, it would be useful to share, in case someone else actually does want to fix it. The hard part, to me, is finding it. [MemoryProfiler](https://github.com/samsaffron/memory_profiler) has never let me down so far.
I agree. I might call it `sequence`, since you call it on a value in order to get a sequence.
I find that to be a crude, ugly, and unnecessary bolt-on and I'm really disappointed to see it in core Ruby. The objections to simply catching exceptions were and I'm not joking, "it's noisy with -d" and "it's slower than it could be" in the context of YAML/JSON parsers. What a crock of shit. 
I'm a fan, now to find a particularly mischievous way to use it as one does.
Oh noes! Broke IPAddr I think: [17] pry(main)&gt; ips = IPAddr.new('10.0.0.0/31').enumerate(&amp;:succ) =&gt; #&lt;Enumerator: ...&gt; [18] pry(main)&gt; ips.first(5) =&gt; [#&lt;IPAddr: IPv4:10.0.0.0/255.255.255.254&gt;, #&lt;IPAddr: IPv4:10.0.0.1/255.255.255.254&gt;, #&lt;IPAddr: IPv4:10.0.0.2/255.255.255.254&gt;, #&lt;IPAddr: IPv4:10.0.0.3/255.255.255.254&gt;, #&lt;IPAddr: IPv4:10.0.0.4/255.255.255.254&gt;] Mf lets you do some fun things with this: [20] pry(main)&gt; 2.enumerate(&amp;Mf &lt;&lt; 1).first(5) =&gt; [2, 4, 8, 16, 32] [21] pry(main)&gt; 1.enumerate(&amp;Mf * 5).first(5) =&gt; [1, 5, 25, 125, 625] [22] pry(main)&gt; [[[[1]]]].enumerate(&amp;Mf[0]).first(10) =&gt; [[[[[1]]]], [[[1]]], [[1]], [1], 1, 1, 1, 1, 1, 1] In general though, I would definitely agree on using this for tree-like structures. The fun question is what happens when it out of bounds?
It also doesn't help that in some other languages, `enumerate` is a synonym for `with_index`. I'd like to also throw the name `iterate` into the mix, to match the Haskell function http://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#v:iterate
How about "unfold"?
I added the [reasoning](https://github.com/zverok/object_enumerate#upd-naming) about the name to readme. Repeating it here: * Core method names should be short and mnemonic, not long and descriptive. (Otherwise, we'd have `yield_each` instead of `each`, `yield_each_and_collect` instead of `map`, `parallel_each` instead of `zip` and don't even get me started on `reduce`). It is if you can't guess what core method _exactly_ does _just_ from the name, more important to have it easily remembered and associative. * Code constructs using the name should be spellable in your head. I pronounce it "1: enumerate succeeding numbers", "last result: enumerate all next" and so on. Judge yourself. * Concept is present in other languages and frequently named `iterate` (for example, Clojure and Scala). As we call our iterators `Enumerator`, it is logical to call the method `enumerate`. * Once you got it, the name is hard to confuse with anything (the only other slightly similar name in core is `#to_enum`, but it is typically used in a very far context). The only other reasonable option I can think about is `deduce`, as an antonym for `reduce` which makes the opposite thing. Elixir follows this way, calling the methods `fold` (for our `reduce`) and `unfold` (for method proposed).
I'd say `deduce`, then. (`unfold` is used in languages which use `fold` for `reduce`, those two methods are more or less opposite.)
Seems nice! How does it compare to identity_cache? It looks like it's less bound to AR and allows a bit more flexibility, but with less pure AR power (has_many, embedding). 
[Volt](https://github.com/voltrb/volt) sounds like the thing you're looking for, it uses Opal. However, I'm not clear on its current maintenance status.
Very nice!
Assuming they are also using Cloudflare I don't think this is the only approach they are using.
Pakyow or Clearwater?
&gt; In Rails 5.2, select_{value,values,rows} methods have been removed completely That seems rather misleadingly inaccurate. :/ "*broke* query caching" too, for that matter.
Last commit on GitHub was over 2 years ago.
Have you checked out [hyperloop](http://ruby-hyperloop.org/) ?
Thanks for the detailed response. I like it, will try it! Good job on the high test coverage.
And good job on updating the README with a response to my question.
Numpy and Pandas are two of the 'big players' that make Python a data science favorite. Ruby does have equivalents \(and they're actively maintained\): [Daru](https://github.com/SciRuby/daru):Pandas ~~NArray~~[Numo::NArray](https://github.com/ruby-numo/numo-narray):NumPy
I did this too :) https://ssl-check.herokuapp.com/
Have you done the benchmarks with a real app to determine which one is faster? Roda and sequel both need a bunch of plugins to be useful. Do your own tests. All the benchmarks out there only test routing.
&gt; simply &gt; cache There are only two hard things in Computer Science: cache invalidation and naming things. -- Phil Karlton
Wow, this makes Perl look readable in comparison.
I think it's a bid odd to have a (keyword) argument that drastically changes the behaviour/API of a method. For cases where this is necessary I think separate methods would be a better fit.
Yes, but most of the people doing "web stuff" are just making simple sites, deploying once in a while, things where you set something and try not to think about it. At least this was my case when I wrote it. Obviously CI is the best place to put it but I think if your organisation is sophisticated enough to use a CI, they'll have monitoring already set up in a sophisticated way and ideally automated.
I'm glad you like it :\). If you have feature requests or bug reports, feel free to submit an issue to the repository.
Just using Net::HTTP, e.g. def ssl_cert begin uri = URI.parse(self.url) http = Net::HTTP.new(uri.host, uri.port) http.use_ssl = true http.ssl_version = :TLSv1 http.verify_mode = OpenSSL::SSL::VERIFY_NONE http.open_timeout = 10 http.read_timeout = 10 http.ssl_timeout = 10 http.start do |h| @cert = h.peer_cert end @cert rescue SocketError, SystemCallError raise UrlError.new "Bad URL? #{$!.message}" rescue Net::OpenTimeout raise UrlError.new "Timed out. Is the site up?" rescue OpenSSL::SSL::SSLError if $!.message =~ /sslv3.+tlsv1 alert/i raise UrlError.new "We're trying to validate your certificate using TLSv1. It looks like your server doesn't accept it: [#{$!.message}]" end end end 
Is Hyperloop super tied to Rails? Any chance it can be used free of Rails?
I haven't done any actual benchmarks with Roda. TBH I don't think there would be a significant difference when you add all the Rack middlewares that you need. I think it's always the other things that will be the bottleneck and that you would need to scale (database calls mostly). Since Rails encourages Active Record and Roda encourages Sequel, there is an obvious win for the latter because I do think that Sequel's performance plays a significant role in scaling. Jeremy's [Sequel-ActiveRecord benchmark](https://github.com/jeremyevans/simple_orm_benchmark) compares a variety of examples. In the end I think you should choose what you like more. I didn't agree with many of Rails' decisions and wanted to be more on control, so Roda and Sequel were very appealing to me because they still have all the features I need but they're opt-in. And very often they're more advanced than their Rails' counterparts, and also faster. Ultimately the fact that I didn't like Rails' complexity played the biggest role in making the switch.
I had success with a project last year by going through the Rails tutorial and just changing the models for what I needed. It got me close enough to start modifying it in other ways, and I also just skipped parts I didn’t need. You might try that approach. 
Thanks for the advice. I didn't want to get too much in the details but what gems would you recommend for oAuth2 or OpenID authentication?
I had a small project once, where PDF generation was needed. The print stylesheet for ActiveAdmin was deemed sufficient, so I instructed the users to simply print certain views to a PDF file. Anyway, there are multiple ways to achieve this from the server side too.
I built something similar to this for my workplace for our potential new clients to apply for services with our company. It's a pretty basic form input -&gt; database and I also added an approval process where administrators can change a status field for the applications. I wrote it using Sinatra, rather than full blown rails, but it was good.
Devise, mentioned above, has support for setting it up with OAuth via Omniauth.
No unfortunately :( but I would be happy to help review your code if you need suggestions. It's basically two models, user and submission. Users can have many submissions. Because the forms would most likely need additional form fields at some point in time, instead of adding each field as a model attributes I have one 'data' field that is serialized JSON. The benefit of that is that if they add or remove fields to the submission model it's much less work to update displays and controllers. Some might argue that that's not a best practice in this case but it works for me. I also added a few PDF views using prawn so that they can export copies of the submissions.
I want to add a thing: despite common misconceptions, one does not need devise in every project. Only use it if you want users to be able to create acounts and log in and verify accounts and stuff like that. I recommended it because devise helps you in doing that and your description sounded like you might want to do this. But general advise - don't use gems just for using them but only when you need them.
Need to write a gem that detects unnecessary gems, then uninstalls itself. 
I was trying out Heroku, OpenShift (bit cheaper but not as DO). I am on Digital Ocean VPS now, because DO has nice &amp; easy interface and fair price. I only have a small bash script to set it up -- it's faster than any Docker-based solution, easy to understand (no ops frameworks, &lt;100 LOC), SELinux configuration, letsencrypt and git-push deploy in-place. If you are interested I wrote something about the setup. Setting up git push code deploy to remote server: http://nts.strzibny.name/git-push-code-deploy-to-remote-server/ Trusted SSL certificates with Let’s Encrypt and NGINX: http://nts.strzibny.name/trusted-ssl-certs-lets-encrypt-nginx/ Allowing Nginx to use a Puma/Unicorn UNIX socket with SELinux: http://nts.strzibny.name/allowing-nginx-to-use-a-pumaunicorn-unix-socket-with-selinux/ Hope it helps.
Thanks for sharing your setup info and links. Is there some place you have also wrote about your bash script as well which you use to configure server? I would love to check it out. 
Nice idea! But how do you detect that you require gems that you don't really need because you could easily implement the features in need yourself? Unused gems, sure (but I'd guess there really is a gem that detects them), but not needed != not used...
Just curious as to why? 
Take a good hard look at https://www.hatchbox.io from Chris Oliver. 
Most of my projects have an update.sh that git pulls from production branch, runs an optional migration, then restarts the server. It can be made very simple.
What’s wrong with Capistrano? It takes about half an hour to setup deploy stuff to fit your needs.
Capistrano is great. Been using it for years. I’d definitely use it for deployments to DO. 
Not yet, I want to find time to make it more general so that it can be used for another project, but right now it's not.
Rubocop would have a seizure parsing this.
Depending on the size of it and how much the rails app depends on Sidekiq, I've used Capistrano for a metal app, Capistrano and Docker-Compose (bitch to set up), and lately I tried Mina for a very small app. Currently all three options are used 'in production' on my DO-like server (the Dutch "TransIP"). I must say that I really like the complete containerisation of my Docker-compose projects. Once you're set up it is awesome and painless, but it takes a while to fully understand
I'm a fan of AWS Beanstalk for spinning up simple environments. It's really quick and easy to manage. You also get the added benefit of easily autoscaling. Once you get everything set up within your application, you can simple run `eb deploy` to deploy. Depending on the branch, it can deploy to different environments. For small projects, you can stay within the free tier range for a year.
I moved off AWS to Digital Ocean for the same reasons. If you want to get fancy they have a fully supported Ruby SDK called \[dropletkit\]\([https://github.com/digitalocean/droplet\_kit](https://github.com/digitalocean/droplet_kit)\) or as many have suggested Capistrano works very well.
My team has moved to the docker/kubernetes way of doing things. It makes it really easy to manage all of our small apps and larger apps, and the on-demand scaling we get is unrivaled (say goodbye to unicorn workers). There is a learning curve, and you’ll probably need a devops team to handle the kubernetes side, but being able to configure and deploy an app reliably without having to worry about the differences between prod and dev is awesome. 
Been using Capistrano for years on both EC2 and DigitalOcean. No complaints. 
Not sure why you downvoted. Dokku is great. 
Probably because OP said he tried dokku and found it slow and unreliable. 
Capistrano. 
Ah I'm an idiot. I totally glossed over that before.
I use Clever Cloud, a service similar to Heroku but with predictable costs and made by a very nice time. The best support I had until now.
It’s amazing. One click ssl, sidekiq, and elasticsearch. And it now supports Puma too.
We use the slim server, and let the cluster scale the number of servers as needed
Capistrano is great, Indeed. How do you handle initial server setup? Like installing Ruby, Nginx, Postgresql etc. 
I like to use http://hyper.sh personally. 
about the "can confirm" stuff: The chart is wrong, because it says "consider themselves superior" when it should in fact say "*are* superior". 
How are you deploying docker-compose? Can you give a basic overview? 
 😁 
Thanks.. As I thought, it could be done with much less code.. However I have a little question.. I thought that having loops with explicit controls \(I mean controlling manually the index, the iterator etc.\) are something that do not happen often in ruby.. Am I heard wrong? Or does this case just an edge case where the while is the best option?
Well, the absurdity of the task probably requires code to be non-idiomatic (because after 2-3 refactorings toward idiomaticity you may suddenly find it to go back to "normal" program). But I'd say something along the lines of: TARGET_ARRAY = "Hello World".chars CHAR_RANGE = 32..126 SLEEP_TIME = 0.005 def find_char(target) found = rand(CHAR_RANGE).chr print found while found != target found = rand(CHAR_RANGE).chr print "\b#{found}" sleep(SLEEP_TIME) end found end TARGET_ARRAY.map { |c| find_char(c) }.join 
[removed]
IPv6?
do you manually setup your server initially or do you have a automated way of doing it? 
I just follow this guide - https://gorails.com/deploy/ubuntu/18.04#capistrano
I really wish Hanami 2.0 will come out sooner. It is built on top of Roda, Sequel and Dry-RB. 
I’d try to stick with Heroku as long as possible. The operational overhead of other solutions just isn’t worth it for personal projects up to medium-sized user bases. Also check out Netlify for static sites/single-page apps.
I don't think that `loop`+`break` by any means more idiomatic than `while` -- it is still "old non-enumerator cycle", but even with the condition of breaking hidden inside the cycle. Thinking of how to break down the search for the character into idiomatic Ruby, I remember about my recent `Object#enumerate` [proposal](https://github.com/zverok/object_enumerate): def find_char(target) rand(CHAR_RANGE).chr .enumerate { rand(CHAR_RANGE).chr } .detect { |ch| print ch sleep(SLEEP_TIME) print "\b" ch == target } .tap { |ch| print ch } end PS: I don't think that "wrapping in class" does something for idiomaticity: because, if it would be real task discussed, it probably would be part of some larger algo inside class/module, so we are just discussing how the particular cycle should be presented idiomatically, not how it should be wrapped into class/module/gem/Rails engine :) PPS: Also, yours doesn't work properly :) (too many `\b`, deletes everything).
What’s the release schedule look like for 2.0 plus are there dev branches I’m missing? Or is it all just still chatter and ideas at this point?
This is a known pattern called a [Fluent Interface](https://en.wikipedia.org/wiki/Fluent_interface)
Though there is still Engine Yard
capistrano would be the most "standard" long-used solution. 
Thank you for the added info/clarification! (I think "broke _query caching_" is accurate, it broke the query caching feature. But a more complete explanation of what's going on is more important than arguing about the phrase used to describe it. :) )
[I think we all know where this should *really* go](http://termbin.com/2i03).
Love this solution. Looks the most ruby like. Though not necessarily the most readable. A small wrapping object to me _is_ idiomatic. Classes are small and easy to make and I like how it adds clean abstraction and service layer. But we're all just talking about style here. And yes, I've got a bug in there. 😬
Looks like we've been invaded by an executioner from the [Kingdom of Nouns](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html). Not everything in Ruby has to be OO. It has great scripting features too.
Jesus Christ, dude, you should warn people that your link produces a loud croaking mess. I was actually wearing my headphones and it kinda hurt.
actually will add a general volume control
People seemed to generally like [Object#enumerate](https://www.reddit.com/r/ruby/comments/8ke1k4/objectenumerate_ruby_core_proposal_demo_also/) idea, but felt uneasy about the name or synopsys. At the same time, I've thought about some examples in favor of `Enumerator#generate`, especially cycles with no initial value (thanks [joke thread](https://www.reddit.com/r/ruby/comments/8kypsr/ruby_equivalent_of_this_program/) for today's inspiration). So, here is another take to discuss. Examples akin to previous proposal: # Infinite sequence p Enumerator.generate(1, &amp;:succ).take(5) # =&gt; [1, 2, 3, 4, 5] # Find next Tuesday require 'date' p Enumerator.generate(Date.today, &amp;:succ).detect { |d| d.wday == 2 } # =&gt; #&lt;Date: 2018-05-22 ((2458261j,0s,0n),+0s,2299161j)&gt; Examples with no initial value: # Random search target = 7 p Enumerator.generate { rand(10) }.take_while { |i| i != target }.to_a # =&gt; [0, 6, 3, 5,....] # External while condition require 'strscan' scanner = StringScanner.new('7+38/6') p Enumerator.generate { scanner.scan(%r{\d+|[-+*/]}) }.take_while { !scanner.eos? }.to_a # =&gt; ["7", "+", "38", "/"] WDYT? Also, `Enumerator#generate` probably less confusing naming, and less radical proposal, after all (no `Object` bloating).
done, thanks for the feedback
That's awesome. I've always referred to it as "that clever thing AR Associations do" and have studied it from there. I feel cool when I find ways to leverage this style in my own interfaces. It's funny to me that the Ruby example is so mundane. Though, perhaps unique. 
It's a nice idea. It seems like a better place to put it, but it doesn't preclude an explicit allowance, e.g. `require 'object/enumerate`, to enable such function for `Object` which would be a thin wrapper to invoke your proposed method.
Bar.increment_counter changes @foo_count from 100 to 101. 
&gt; Why do you think the methods should be defined on self? Just trying to find the logic behind what class methods get defined on. &gt; A method defined in an instance method is defined itself on the instance method Afaik, plain old object instances don't have methods defined on them, only class objects do. For example: class DefSpecNested def create_instance_method def an_instance_method;self;end an_instance_method end end DefSpecNested.new.create_instance_method DefSpecNested.instance_methods(false) #=&gt; [:create_instance_method, :an_instance_method]
&gt; Afaik, plain old object instances don't have methods defined on them, only class objects do. Yeah, I know, but why do you think that's relevant? I don't think it contradicts what I said or what the specs say. I did write 'defined itself *on* the instance method' but I mean 'defined itself *as an* the instance method'.
Sorry, I didn't catch the explanation then. I know a bit more than the average ruby user about the object model, but experience wise, I'm actually still learning ruby.
I.e. if you want it to be `100` _after_ incrementing, set `@foo_count = 99`.
If I can pester you some more, that rule doesn't seem to hold true here since a singleton method gets defined: class TestThree class &lt;&lt; self p self #=&gt; #&lt;Class:TestThree&gt; def method_one # this gets defined on #&lt;Class:TestThree&gt; as expected p self #=&gt; TestThree def method_two; end # this unexpectedly gets defined on #&lt;Class:TestThree&gt; even though self is TestThree end end end
Ah it's the lexical captured class then - the declaration context. It must be defined in the declaration context of the declaring method. I was wrong about it being defined on the same class as the declaring method - it's defined in the same declaration context class as the declaring method. That must be why the ISO spec talks about the current class or module.
&gt; Ah it's the lexical captured class then - the declaration context. It must be defined in the declaration context of the declaring method. This concept seems to encapsulate what's happening here. There's something called the [default definee](https://stackoverflow.com/questions/39453741/ruby-what-class-gets-a-method-when-there-is-no-explicit-receiver), but this doesn't go into specifics about when default definee gets changed (it probably changes between class SomeClass;end).
There is indeed. But their pricing structure is hostile to small organisations and bootstrapped startups. Their "solo" plan can't be used for HA and doesn't support anything smaller than a t2.medium. I run a bootstrapped startup that has relatively low absolute traffic, but one that needs very high availability for the traffic that it does get. So we run 3 x t2.small. EngineYard's pricing would x10 my hosting bill. I only recommend them to big companies or well-funded startups.
I like it a lot. 👍
Congratulations on getting your first app out there. It's looking pretty slick! I'm sure u/excid3 will be delighted to hear that his videos inspired you. I also find his tutorials to be very clear, concise and helpful for all sorts of solutions. I've registered with your site because finding good healthy recipes is something I'm genuinely interested in. A couple of observations from my first experience: * The search box appears to be broken. I have zero experience with these js frontend wizardry things, but the generated `&lt;form&gt;` element doesn't appear to have an `action` attribute. Is this normal? * It would be nice if the image for each recipe was also a link to the recipe. I think this is your intention, but at the moment there is just an isolated `&lt;a&gt;` within a bunch of nested `&lt;divs&gt;`. Two of those `&lt;divs&gt;` set the recipe image as the `background-image` with inline css. The `&lt;a&gt;` appears to be a placeholder so I guess you're working on this already. Anyway, I'm looking forward to trying some of these recipes, adding some of my own and watching your app evolve as I eat.
Looks really nice. Heroku has free SSL integration now, which would be advisable to add.
I am delighted indeed! It couldn't make me happier to see people make cool things and know that I was able to help a little bit. These recipes are making me hungry. Love the design for it too! Search box is broken for me too. An action isn't required if you're handling the form submit with Javascript since the action would be defined in the AJAX request. One suggestion I would make is consider replacing the idea of "favoriting" with something that fits the product a bit better. To me, I would want to say "I want to try this" to add it to a list of dishes that I would pull up to buy ingredients for next time I'm at the store. Then after I've made that dish, I could say "I liked it" or "I disliked it". That way as a user I have a much more intuitive way of interacting with your site. And you could send out weekly emails with a grocery list for those dishes, and follow up a few days later asking me to rate them. Email strategy is a crucial part of building a good product. I should probably talk about that more on GoRails.
His app is deployed with Heroku which is as simple as doing a git push to Heroku. Nothing fancy there. If you want to see how it's all done on your own server, I wrote a tutorial here that's worth walking through if you want to wrap your head around all the odds and ends. https://gorails.com/deploy/ubuntu/18.04 That's roughly the same process I use for Rails hosting in Hatchbox.io, but with a lot more things handled for you and automated. It's really important to manually deploy apps to your own servers to wrap your head around it all, but after that you can waste a lot of time so automation to the rescue.
good catch on the misspelling :) I know exactly what you mean, sometimes it gets hard to finish your projects especially when running into roadblocks. With recipepoodle I found myself excited to use even when I was building it on my local machine and I was the only user. It was the first time I was building a something that was specifically for me. It made it easier for me to track the calories of recipes I was already making. I can't wait to see what your building! The last 20% always seems to take the largest amount of time, but make sure to post it on this subreddit when you're done so we can all check it out :) as far as learning about the deployment, I went through videos and followed step by step. Heroku makes it really easy to get set up. specifically here is a good resource for Heroku deployments with rails [https://www.youtube.com/watch?v=5kVtmnZNC8w]. Definitely feel free to message me when you get to that step and I'll be more than happy to help.
Welcome to the site :) I will continue to be improving the functionality and adding new features. One of the first things I want to tackle is being able to group recipes and have your own "recipe books". - The form actions are submitted through angular in the controller which then makes a post to the API. I didn't find it necessary to have the action attribute when doing this. But I am also quite new to the front end so I may be following bad practice? - I have very little html/css experience, so I leaned pretty heavily on using this framework that I purchased (https://www.creative-tim.com/product/material-kit-pro). It made it a lot easier for someone like me to get up and running but it meant I also had to follow the confines of the css framework. If you go through the html and it looks like I have no idea what I'm doing... it's because I have no idea what I'm doing. With that said making the image, a link shouldn't be hard to figure out. Thanks for joining and signing up. If you have any ideas or comments please feel free to message me anytime. 
agreed, ssl is one of the first things on my list as an improvement. 
I know about Hanami web framework, thanks for pointing out Hanami CLI. It probably needs a name change/better name. I bet most people would just assume it's for Hanami commands, like Rails commands.
Those kind of optional things still can wreak havoc on dependencies. When it's just _your_ code you have to worry about, even 'monkey patching' is just fine. It's when it starts conflicting with dependencies. I don't like the modules in stdlib that can be require'd, to change the behavior of other classes in stdlib app-wide. You might as well just put them there all the time since all code has got to be written as if they could show up at any time. 
\`stdlib\` already does this quite a bit, e.g. \`time\`, \`date\`, \`fiber\` are ones I know of the top of my head. I'm not sure what the motivation is for such an approach, perhaps to minimise the chance of backwards compatibility issues?
Very nice list. Wow, so many option parsing libraries. I'm going to suggest my own gem here: [MarkdownUsage](https://github.com/sshaw/markdown_usage). It can be very handy, especially if you have usage in your README. 
yep, it does. not a fan. 
Ui looking fresh!
I haven't tried this, but [ruby-packer](https://github.com/pmq20/ruby-packer) seems promising.
Check out: https://github.com/phusion/traveling-ruby it's not super up to date but should still work fine.
What did you not like about Rails? It has a huge curve for newbies--I hated it in the beginning but got over it. 
Amazing work! I really find the design and the idea quite whimsical. However, you might want to fix the following bugs/inconvenience-causing-elements : - The sidebar should automatically hide/un-collapse once I select one of the links. - The recipe name is not completely visible at the top on the single recipe page. - When I select one of the mini cards (categories), there can be an autoscolling added so that it's more evident that the contents of the page have changed after the AJAX response. 
sequel + roda. 
Seconding this. Roda is extremely versatile AND has nearly no overhead. Would recommend. Roda is what express.js should be, but isn't. Sequel is also a good (and fast) ORM.
It's not that I don't like it, I think it's good but it makes you go the way it wants. You need to do things the Rails way and not just using Ruby and then making the choices yourself, I don't see as much freedom as I see with Sinatra, for example. Let's say you want to go for Clean Architecture, there is no "easy" way to do it on Rails as you really need to go with how they do stuff!
But as I said to the guy above, it doesn't allow as much freedom as other options! That's my biggest caveat.
What does that freedom buy you versus what it costs you?
That's really not true. I've been working with Rails for nearly a decade now. If you look in my controllers, models, serializers, etc... There is *very* little code in them, mostly just calls to POROs. If used properly, Rails can just be the glue between your data later and the client. Let Rails deal with what it's good at, and build out your business logic in POROs. When done properly, you could really extract your logic and drop it into another framework with minimal fuss if you had to. This makes it an absolute *breeze* to do Rails upgrades. On my smaller projects, I just initialize a new Rails project and then drag over my /spec, /app, /lib, /db dirs and the things I need from /config and my Gemfile. In the end Rails is also just "plain Ruby". Sure, they've extended the native objects some, but it's easy enough to learn what and where. What people call "Rails magic" is mostly people not understanding how the advanced features of the language work. Sinatra had it's place, great for standing up a quick web interface for a Utility or lighting website. But, as soon as you are doing a project of any complexity, you'll soon be looking for gems and such to provide what Rails has "out of the box". Couple that with the large and mature community of gems to do what Rails doesn't already provide, and you have a powerful tool that's hard to beat.
You say 'freedom', I say 'technical debt that is going to become technical bankruptcy'
Well if it's a critical project that needs collaboration between a lot of parties I guess that it would be too costly, but in this case, building a little side project I don't think that the cost would be really high. I would have to think things twice or thrice before doing stuff? For sure, but I could also think outside the box. But I see your point, I just don't think there is just one right choice and the other are wrong ones!
hmm, couple new ones in there I'll have to check out. 
There's nothing wrong with Sinatra for small projects that have a few endpoints. With bigger stuff, you begin to appreciate Rails' convention instead of spending all the time configuring things. 
This is a great optimization. Block parameters can be so useful in making clean code. 
So Heroku is PaaS whereas DigitalOcean is a VPS provider. You won't transition to DigitalOcean and have the same experience you do with Heroku. For me personally and professionally, I've found AWS EC2 (ubuntu) + Nginx/Passenger + Capistrano + AWS RDS to be my favorite. Heroku is great...it's just that it gets too expensive too fast. Spend the (relatively) short amount of time to learn AWS basics and it will pay off.
The difference between class variable (@@var) and class instance variable(@var) is that the value of class variable is shared across all the instances and inheriting classes. So when you update the value of class variable anywhere it will be reflected for all of the classes. But that's not the case with class instance variable. The values you have assigned in the super class will be inherited but each subclass will have its own copy. So in the screen shot you have shared the value was 0 for the first class and the value was changed to 100 for the second class. Then the increment value method was called once for each of the class. So the output is correct indeed. 
Roda is awesome, I with I could set it up with rom-sql easily but the rom setup is quite intimidating
Honestly? Python and Java (the horror!) frameworks for web apps; Ruby is a text-munging language for me, not something to build large applications in. But I've always agreed more with python's philosophy than ruby's.
Looks good! I'm still fairly new to the Ruby game myself, but I'm learning more and more everyday as we use Ruby at my job. Rails, however, I'm not so proficient at, but I am starting to dabble in it a little. Regarding your project, man, that is one sleek website! Very eye\-catching, but not too much going on in one screen view, so that's good. Just a suggestion: the spotlight and the "what's on your plate today?" are more than likely going to be missed a lot of the time being towards the bottom of the site, so you may think about alternative placement of those. I certainly would not have known it was there had I not scrolled down because of my screen size. Also, I'm not sure if it was just me, but loading into your website the first time around, it took quite a while \(maybe about 15\-30 seconds, thereabouts\). But now it seems to be loading fairly quickly, so maybe it's cached? And the "Seasonal" and "Seafood" links do not work at the moment. Seriously though, this website looks great! Good job on your first project!
"Clean Architecture easy way" in Rails: use [ActionController::Metal](http://api.rubyonrails.org/classes/ActionController/Metal.html), do literally anything you want with plain old Ruby code and directly populate the response body. Rails gives you no less freedom than Sinatra \(for example\), it only makes more default decisions for you. It has more opinions and conventions, but does not prevent you from doing things any other way.
Flask, and I really miss Rails.
&gt;it only makes more default decisions for you. There's a cost when you deviate from those decisions though, right? They're not free. For a non\-trivial application: \*\*Staying "on the Rails" and sticking with Rails' default decisions:\*\* Probably a \~10x speedup over cobbling things together yourself in bare\-metal Rack application. \*\*Going "off the Rails" and against those default decisions:\*\* Probably a \~2\-5x penalty vs. staying "on the Rails" If you have more than a few places where you're going against those defaults, the friction can outweigh the speedups pretty quickly. Though, I don't think too many apps would fit that description.
I really like rails and appreciates all that you get for free. However I'm also amazed by the simplicity of Sinatra and I'm also into REST APIs (as in hypermedia). This has lead me to start building a framework on top of Sinatra and Sequel. Check it out on https://github.com/sammyhenningsson/shaf
Can't argue science.
At this point, it seems easier to divorce where methods get defined from `self`. I read this and it was pretty eye opening: http://blog.yugui.jp/entry/846
So glad i stumbled on this! My dumb ass was looking for a book yo learn ruby! Dodged that bullet! 
I know it's dumb, but whenever I hear someone say Ruby is dying, it makes me kind of sad. I shouldn't be thinking of any programming language like it's something special to me, but Ruby is the one language I enjoy coding more than any other, so I guess it has kind of carved out it's own little USB slot in my heart 
did you click on the play button?
I know it’s a joke, but yeah, Ruby’s dying. It’s a useful, productive language just like Perl was, so it’s not going to die completely any time soon, but barring improvements — the type system, performance, deployment/dependency management, concurrency, killer libraries, _something_ — it’s gonna be hard to justify new development in Ruby for teams not already tied to it. 
Ruby is still under active development. Ruby has a mature ecosystem of libraries, use cases, etc and continues to grow. Millions of people already know Ruby. It’s pretty easy to justify new development in Ruby for teams - I just did. 
just look at him go
I think didn't get the point of this site.
The thing is, terrible to maintain code can be (and often is) written with any framework/platform. I have nothing against people trying new things, but be careful of "grass is always greener". Personally, I don't _love_ Rails like I do ruby, but it's still what I choose to use. 
What is dead may never die, but rises harder and stronger.
And how much is each of those a speed-up/slow-down compared to Sinatra, where you got to cobble it all together yourself? 
The crest of the Gemjoy.lock family. 
The argument was about the future, not today. Of course there are very good reasons to use ruby today.
google 'is ruby dead?' ...all the "experts" in tech say yes. This site backs up their claims with #science
Delphi is dying
[As used by the California State Auditor](http://code.jeremyevans.net/presentations/isleofruby2018/index.html#1).
That's sort of right man, but think of it this way: there has to be some semblance of structure because the human brain can only juggle so many new things at once. This is why frameworks work for teams of 2 or more people, because there is the convention that exists which people are familiar with. For personal projects, feel free to dabble in trying out different coding styles/frameworks. It's good for learning and gaining deep knowledge in a language or how frameworks are built etc. But for commercial projects, I'd go with Rails. You can very much deviate from the Rails way in some parts of the app anyway (some service object framework like trailblazer, light-service, dry-rb libs, etc) 
I've been using rails for 8 years and love it. I recently try Go to build an API. Although Go is really fast and easy to learn I missed some rails features. For example CORS and authentication. You have to implement them from scratch and there is when you realize the time saving when using Rails. I think that every framework or language has their pros and cons and also depends of the project. I always recommend rails for a startups and Go for scalability.
What’s happening here is you have two different instance variable. Unfortunately I’m on mobile but I’ll try the best I can. So when you call Foo.increment_count it increments @foo_count within the Foo class. When you do Bar.increment_count you are initializing a different instance variable from the Foo classes instance variable. This instance variable for class bar is set to 100. So when Bar.increment_count is called, 100 will have 1 added to it because it inherits the increment_count method from Foo which specifies to add 1 to the instance variable @foo_count. And that’s why you get 101.
Well, that and reading Perl code makes your eyes bleed.
Gems I use in my project are completely dead and non working these days. Makes me sad
Care to share examples? I've hit some of this lately, but most of them were horrible ideas to begin with (like, monkeying with the internals of minitest) or dealing with something you'd try to get away from (quickbooks) and it's no surprise the maintainer has moved on. Don't be afraid to submit PRs and offer to help maintain. Somebody has to do it!
Gruff is one. Cant remember some of the other. Considering rewriting the whole project in a more stable language anyway. ;(
That makes sense!
Unless it's intentionally bad code \(which I hope it's not\) then it's fine. I'd rather read Ruby code, but it still is better than Python. :D
Holy crap, I didn't see this ! Thanks, I should have paid more attention.
Might as well be latin at this point
I got an ssl error.
Gruff? Wow that's old. Everybody moved on rendering of graphs to the front-end JS libraries years ago. It just makes more sense too. Some gems slowly die off because devs generally find better alternatives. Sometimes those alternatives are not ruby.
My app is offline/console no browser, cant use online javascript stuff. =\ I'd switch in a second if there was a to way to generate the graphs without internet. I hate gruff/rmagick/imagagicka.
Up voting for some good points. But, as a ruby dev who is transition to python, I feel like a lot of the same arguments apply to python. Most python performance blogs boil down to "Avoid the GIL by moving heavy lifting to C libraries." Pip is about as good as rubygems. Virtualenv is about like RVM. Yeah python interpreters are more common, but with linux distro vendors shipping old versions, you wind up having to manage an updated installation anyway. Both languages have JVM based interpreters available. So why is ruby "dying" and python is fine? Fuck if I know. My best guess is the center of gravity in certain problem domains happen to be in that direction. IE [network effect](https://en.wikipedia.org/wiki/Network_effect). If I want a strongly typed system with a fast interpreter, honestly, I'd consider c# first.
Hmm. There must be some way to work around that. Maybe SVG graph generator of some sorts. There must be some alternative. Also there's always an option of forking and getting stuff working again. Supporting OSS is a thankless job though.
Yeah lots of work. I just haven't seen anything ruby graph wise except for gruff.
That custom framework your colleagues did seems like a source of pain in the long run. Specially, after your colleage leaves the company. Also, when doing things the "rails way", onboarding new developers is extremely easy, because there's a lot of shared knowledge. If one day your company needs to hire a senior, this developer will probably not be happy to work in a code that contains so much unnecessary complexity. 
Python got a lot of adoption by scientists, statisticians and, more importantly, data science - with AI being a hot topic I guess so will python. A few months ago I was at a ruby meetup, one of the **speakers** said "I even allowed one of my teams to start a new project in ruby", if that's not indicative of a decline, I don't know what is. 
Well the author is one of the founders so I don’t think he is leaving anytime soon, but anyways I really enjoy the framework. It’s just the way they decided to go, 5 years running strong, I think it makes stuff really easy to follow. But I get your point!
yea I'm just hoping the "ruby is dead" joke doesn't last as long...
&gt; Sometimes those alternatives are not ruby Oh, you've seen dry-rb too. 
they don't give those .science domains to just anyone.
This only had two up-votes? WTF. And of those was mine.
So dying as in no longer cool and hip, or dying as in not used by many companies to make money?
Ruby has been dying for at least a decade. Don't worry.
Website is dead for sure. 
OK, as a thought experiment let's say Ruby is dying. What language would you move to next that is fun and powerful? Give me your suggestion.
Pretty sure it's gonna become a "controversial" post. 
Not OP but I assume he's not a masochist.
Without context that quote seems rather meaningless. Did they use ruby for other projects? Or was "even" implying "even though it wasn't Python, our standard go to language"?
Create a new array/hash - "seen" - to tack what's been displayed recently. Every time you get a joke back, check if it's already in the array/exists as a hash key. If it is, repeat the selection process. If it's not, remove the oldest joke from "seen" so it'll appear again. Or something like that.
have you used https://www.chartkick.com ? ive used it in a couple of projects and its been great.
Go /s
I've been writing code since the 80's, and professionally since the 90's. I've written BASIC, FORTRAN, C, C++, VB, ASP, C#, VB.NET, PHP, Perl, Java, JavaScript, Magic, Python, Ruby.... and probably a few I've forgotten or not bothered to list. Except for the first two, I've used them all in my professional career to one degree or another. The only one that makes me cry when I have to try and debug someone else's code is Perl. ... It's only a little better if it's an old Perl script I wrote long enough ago to forget the details. I swear, it's a write-only language.
Without an additional guard clause this could still produce a repeated joke, when shuffle A ends in joke X and shuffle B starts with joke X. 
Google golang
If Ruby died completely... I'd give Julia a chance, but would probably end up going back to Python.
Block is a often used feature (especially in gems) Having optimization for it is great :)
You should also checkout [http://shoesrb.com](http://shoesrb.com). If you are a member of Ruby Tapas, there is an episode of using Shoes to build distributable desktop apps: Episode #521: Distributable Desktop Apps \([https://www.rubytapas.com/2018/04/02/ruby\-gui\-toolkit\-jason\-clark/](https://www.rubytapas.com/2018/04/02/ruby-gui-toolkit-jason-clark/)\)
object pascal?
It’s JavaScript based. I don’t use ruby on the web or a browser. I have a command line app that generate PDFs. 
Filters out almost everything related to Go, since most users don't call it that.
I got so angry when I read “go” I missed the “/s” and downvoted you for a second. I took it back. Sorry.
I understand what you're saying, but to me the "penalty" you describe is looking at it backwards. It's only a penalty when you compare it to fully utilizing all the defaults and conventions. It's not a penalty compared to starting with the common alternatives, which give you hardly any of those significantly beneficial conventions in the first place, or may be more dead set on their conventions (several front-end frameworks spring to mind).
Maturity should mean the opposite.
You could use something like array.each_slice((array.size+1)/2).map(&amp;:shuffle).flatten 
I say what I said, having replaced 100% of the non Ruby scripts with ... Ruby scripts over. So I saw maybe ~70k LoC of Perl. We even had two major "customer" facing applications that were written in it around ~1997 and again ~2001. Those two applications were butter smooth to convert to Ruby, with a significant amount of code "updates" simply being API rather than syntactic. I actually ended up writing a script that updated API calls to save a lot of the manual repeated effort. Part of the reason we did that is that we had over 50 different scripting and programming languages so we wanted to consolidate since it makes support and hiring much easier. In the end, we use C++ and Ruby (and some Java and C# due to vendor BS.) Now later on when it came to automating a lot of our sysadmin and deployment tasks, that's where I found the write-once type shite-code. I wish I could say it was strictly all perl, but there were shell scripts, rexx scripts, python scripts and ruby scripts all write so poorly there was no way to tell the sysadmin/whoever wrote them if they still worked for us. Everything is nice and automated now, so it's just an incredible hump to be over and never have to read any of that garbage code ever again. :D Least till we do the next M&amp;A activity ...
Hysteria, self fulfilling prophecy, etc. It's not in a rapid decline, until everyone believes that it is, then everyone freaks out about ruby suddenly being esoteric, etc.
definitely do it as a hash and just check to see if the key exists
Python 
You can't, but you can have the cronjob pass a command line argument to it to tell it cronjob mode. 
Happy hacking!
Abandonment is something that honestly we should expect to happen eventually to external library dependency we take on as a dependency, IMO.
Ruby was the first language I started coding in 7 years ago. My very first post on reddit was on this subreddit seeking advice on my (very first) program written in Ruby. I'll never forget the first comment I got: "The code is shit." and then a plethora of resources to get better. I like to think I've gotten better at programming in the past few years, but whenever I'm feeling like hot shit and need a dose to get me back to the ground, I'll always recall that comment: "The code is shit." and I keep trying to improve. Thank you Ruby. And thank you amazing people on this subreddit. I hope Ruby never dies. 
I don't think Python is fun or powerful. I have been looking at rust.
/s really, seems that some people like go. 
crystal seems interesting, also elixir.
I guess it’s okay but to me: ruby == poetry and go == vogon poetry While it may still be poetry we’re not even in the same league
Maybe it's because Why's Poignant Guide was my first exposure to Ruby, maybe it's because Matz is such a sweetheart, but Ruby is the only language that I actually get emotional about. It's just so dang beautiful and fun to code.
It's been "dead" and on a rapid decline since like 8 years ago when all the hypebeasts moved to Node. I didn't know there was a new decline.
First of all, good work building something to help others. I would second using [Shoes](http://shoesrb.com/) or possibly seeing if you can run and package your app with JRuby. Unfortunately, you have made things very difficult for yourself by using SDL directly. It's an awkward dependency on any platform. I don't know how hard it would be to port your work to something like Shoes, but it will make distribution a bit easier.
Crystal
Perl's scoping rules are excellent. Sigils, list/scalar context, and the various magic/shell\-ish variables are just things you need to memorize. But in the hands of a competent developer, it ought to be about as straightforward as Python/Ruby/etc. Part of the problem, IMO, is that most "perl devs" haven't seen things like Function::Parameters or Moo\(se\). They half\-learned the languages ages ago, stopped improving, and leaned on the "but it's Perl" excuse whenever someone complained about their code.
The second, though closer to "even though it is normally a bad choice" 
I almost think this should be removed as spam. I get the tongue\-in\-cheek sarcasm of pointing out how ridiculous "ruby is dead/dying/a ghetto" assertions are \(we're still waiting for COBOL/Fortran/Perl to die...\), but it's not executed very well and reads more like a troll post, imo. Might I suggest studying the fine literary work on \[McSweeneys\]\([https://www.mcsweeneys.net/](https://www.mcsweeneys.net/)\)? That said, it did generate some insightful discussion here.
well OK but that's hardly a sign of a dying community. 
Python is surprisingly good at handling things such as massive arrays. It's the reason why I switched to it in the first place: was making a massive roguelike, with literally millions of items and thousands of characters that the game needed to track. The other languages that I tried before Python had trouble coping with that amount of data. As for Rust, I don't find it much fun to program in, but would definitely call it 'powerful'.
If only everyone called it that. But searching for golang excluded a lot of newbie questions, which was exactly the kind of content that I was looking for when trying to learn the language. At least it's not as hard to search for as R...
Totally
https://i.imgflip.com/2atwm1.jpg
Yea python is certainly not fun, making libs (eggs) is painful.
Not nodejs that's fer damn sure
Lol @ mongo dB
Hey, joelbluminator, just a quick heads-up: **curiousity** is actually spelled **curiosity**. You can remember it by **-os- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
In python though it's easier to deal with metaclasses. In ruby for example you can't inherit from `Class`, while in python you can extend `type`.
Yes, this is the old name. Borland had some trouble with registered name from Apple, then changed the language Object Pascal to Delphi.
server-side MVC web development is dead. And nodejs/python/golang is good enough to output JSONs.
Why would you want to inherit from Class? What would you hope to achieve by that which you can't achieve by extension or inclusion? E.g. consider that this works: ``` 1│ module MyExtension◂ 2│ def bar◂ 3│ puts "Bar"◂ 4│ end◂ 5│ end◂ 6│ 7│ module MyClass◂ 8│ def new◂ 9│ puts "MyClass new"◂ 10│ ob = super◂ 11│ ob.extend MyExtension◂ 12│ ob◂ 13│ end◂ 14│ end◂ 15│ 16│ class Foo◂ 17│ extend MyClass◂ 18│ end◂ 19│ 20│ foo = Foo.new◂ 21│ 22│ foo.bar◂ ``` 
Is it? I've seen no hint of a decline other than in hype. I've had more requests for Ruby skills year after year and no indication of it slowing down. I've worked on greenfield project after greenfield project with Ruby, so it's certainly still regularly chosen for new projects. 
In fact there's 200+ forks of Gruff, several of which have had recent commits. It seems the problem there is "only" engaging the original owner, which certainly can be hard enough. 
Companies that use it to make money are moving away from it as they mature. Ruby doesn't lend itself to building things that last a long time. It is fantastic to get a business off the ground super fast, and has great applicability to certain problem domains, but runs into issues with complexity, changeability and performance unless developers have a lot of discipline. The bigger a ruby codebase gets, the worse these effects become. Of course this is just my experience as a ruby developer in a company with a lot of ruby and a lot of brilliant engineers, so please take it with a grain of salt - there are always going to be new pools of ruby activity and exciting things happening, and certainly rewarding jobs. Just be sure to stay aware of the industry as a whole. Being a polyglot over your career is probably the best way to stay engaged and relevant.
Yes, I have been looking at Haskell for when I finish with Ruby. I still have a ways to go with Ruby though.
Btw there has been first class uploading with Shrine for a while now. That’s been the main paperclip replacement recently 
What other web frameworks / libraries did you try besides Rails? Because my experience is exactly the opposite, I found that libraries in the generic Ruby ecosystem are much more advanced than their Rails counterparts. Roda allows for more precise routing than Rails' router. Sequel is much better designed, faster, and solves a wider array of problems compared to ActiveRecord. Rodauth is better designed and more advanced than Devise. Forme is a more flexible form builder than Rails' built-in one or SimpleForm. Dry-validation is more featureful and precise compared to ActiveModel validations. The list goes on.
Doubling down here. Crystal is super fun and extremely quick when compiled/runtime
Ruby isn't dead, but it is definitely not growing.
&gt; Sinatra has it's place, great for standing up a quick web interface for a Utility or light-weight website. Sinatra can power heavy applications just as well. I worked at [Clearbit.com](https://clearbit.com) for a while, which has their sufficiently complex set of microservices written on Sinatra. Heroku also started using Sinatra when they started breaking up their Rails monolith ([video](https://www.youtube.com/watch?v=lA8KhC9fFYY)).
That’s a great point. OP would need to do something else to solve for that. I have some thoughts, but I’m not sure they’re any simpler than simply maintaining an array of used jokes. In a relatively small set, approaches other than picking a random joke and picking a new one if it’s within one of the last 10 jokes might be slightly more performant, since the likelihood of randomly selecting a recently used joke increases. 
Could also use a Set. Easier to reason about since the hash would have no values, and it should offer equivalent performance since sets use hashes internally. 
&gt; There's nothing wrong with Sinatra for small projects that have a few endpoints. Sinatra and similar Ruby web frameworks work great for larger applications as well, see my [previous comment](https://www.reddit.com/r/ruby/comments/8l8um5/rails_rejectors_what_are_you_using_currently/dzfw9t3/). &gt; With bigger stuff, you begin to appreciate Rails' convention instead of spending all the time configuring things. I thought that Rails' conventions help you more when you're starting out, and less when you're growing a codebase. I found that many decisions that Rails makes don't work well for me in the long term, so I would rather pay the price of having to make more decisions early on so that later I can maintain the app more easily.
Go to r/golang
Here's a sneak peek of /r/golang using the [top posts](https://np.reddit.com/r/golang/top/?sort=top&amp;t=year) of the year! \#1: [It came to them with a message](https://pbs.twimg.com/media/DEjApdzXcAAlhH7.jpg) | [73 comments](https://np.reddit.com/r/golang/comments/6na5sy/it_came_to_them_with_a_message/) \#2: [Go 2, please don't make it happen](https://i.redd.it/7t1p88ct13ez.jpg) | [287 comments](https://np.reddit.com/r/golang/comments/6rxfjo/go_2_please_dont_make_it_happen/) \#3: [The struggles of a C programmer switching to Go](https://i.redd.it/2ckqvxbhib0z.jpg) | [18 comments](https://np.reddit.com/r/golang/comments/6dwm8t/the_struggles_of_a_c_programmer_switching_to_go/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
Um, javascript ?
&gt; Is there any way I could tell it not to pull the same joke until !joke has been invoked 10 times again? a) Keep an array of the ids of the last 10 ids that have been presented (treat it like a queue, push and pop if length &gt;= 10), after sampling check the list, if it's already on the list, throw it away and try another (and then add it to the list). b) sample 10 ids at once, keep them in memory, present them in order (again treat like a queue with `pop`) on ever `!joke` request, when it's empty, fill it with new 10 new ones. 
Okay, so do the same thing but with N=11, now if it repeats between batches you still didn't get a repeat in 10. Easiest way to solve it. :)
I recently got a job doing Ruby \(start next month\) \- I ran through these exercises to get up to speed: [https://rubymonk.com/](https://rubymonk.com/)
I went to a coding boot camp to learn ruby but I used treehouse as another resource and found it to be helpful, I tried codeacademy but didn’t like it as much. I would sign up for the free trials and see what videos and lessons work better for you and then sign up for that one...best of luck on your journey, ruby is awesome 
I want to put in a word of caution about the cost and performance implications of using a gem like this. It looks like it adds a database table and upserts the stats on each request. If you’ve got lots of write capacity to spare, it’s probably not a problem until the site starts to grow. At scale (for some value of “scale” depending on your budget), you’ll definitely be sad about how much you’re paying to write every time you read. I’d strongly recommend using a service for this and just caching the result locally for a small period. If you’re not on board with the GA API, I’ve used Gauges with good success. I’ve even used a free-for-low-usage apm service like Instrumental for things like this, depending on what I want to track. 
Ah, my mistake. I haven't done work on my Rails project in a while, bit out of the loop.
I like Learn To Program by Chris Pine.
Normally, I recommend these [Ruby books](https://programmingzen.com/ruby-books/). Pick one that suits your current experience as a programmer and with Ruby. I would couple it with a [coding exercise](https://programmingzen.com/15-sites-for-programming-exercises/) site to practice your skills.
No prob, I figured that was the case. I think a lot of people don't know about it cause once you set up Paperclip, you don't really pay attention to replacements for it.
Eloquent Ruby: I highly recommend this book for someone new to Ruby but with some prior experience with programming. This book turned me into a Ruby pro over a weekend. http://eloquentruby.com/
I recently compiled an official docs (and some other stuff) into book-looking reference for Ruby and its standard library: https://rubyreferences.github.io/rubyref/
I "get it", but I don't "get" why its funny. To be honest, I'm finding that, like Sergeant Murtaugh, I'm too old for this shit. This shit being typical internet things. I've got a wife ,kids, and I'm 15\+ years into a career. Seeing how people waste their free\-time almost makes me want to make them babysit for a week. Then reassess how you spend your time on this sort of ephemeral bullshit.
100% agree
I don't know why I would use a gem with docs in broken English where there is https://github.com/ankane/ahoy and tons of third-party services and probably on-premises solutions to this problem.
I strongly recommended [The Well Grounded Rubyist](https://www.amazon.com/Well-Grounded-Rubyist-David-Black/dp/1617291692/ref=sr_1_1?ie=UTF8&amp;qid=1527101031&amp;sr=8-1&amp;keywords=the+well+grounded+rubyist) This gives you a great foundation, it's extremely well written and a nice reference to go back to. I also recommend [Practical Object Oriented Design in Ruby](https://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1527101127&amp;sr=1-1&amp;keywords=practical+object+oriented+design+in+ruby) This book is just amazing. If you're new to object oriented programming, and even if you have a bit of experience, this is going to improve your skills dramatically. Good luck!
Unrelated but it makes me really happy to see a post like this. Mostly because every other day there is a post about Ruby being dead and whatnot. 
Plus one for ruby koans. Exercism is a great site for practicing small coding challenges after you finish the koans.
+1 for well grounded ruby
Thanks for the response! I'm still fairly new to Ruby, so could you possibly give an example of how I might do this? I was thinking something along the lines of: require 'discordrb' bot = Discordrb::Bot.new token: 'TOKEN_HERE', client_id: CLIENT_ID_HERE jokes = ["joke1", "joke2", "etc"] seen = Hash.new bot.message(with_text: '!joke') do |event| event.respond jokes.sample.merge!(seen) unless seen.has_value?(jokes.sample) end bot.run I'll have to test this when I get to my computer, but do you think this would work?
Exactly what beginners like me need! Thanks!
The number of times I have just `zgrep 'Started GET "/pages/about"' production.log.* | wc` ... do things that don't scale, they said. It'll be fine, they said. 
In my opinion, those websites are not an optimal use of your time. I think their ideas and efforts have a positive influence on people learning / experiencing prog. languages... but at the end of the day you're going to be laying out instructions for the computer you're on to follow, codeacademy is you laying out instructions for a website's computer to follow.. it's just not the same and not as realistic in my opinion as what you'll experience coding on the job.
Consider applying to a bootcamp like App Academy (it doesn't matter if you want to go). They make you take tests in order to be accepted and give you material to study. It's a pretty easy way to learn the basics. 
Probably not... I'm guessing each call to jokes.sample returns a different joke each time? In that case, call it once, save it in a var, then check if the var is a hash key.
I have plenty of bias :D When I joined Reddit in 2008, I'd for the first time had a chance to use Ruby commercially in my previous job, from 2005 on. I'm sure plenty of hype has died down, and it's possible fewer companies are trying it out for smaller things, but I'm seeing bigger and bigger teams use Ruby, and these days when I talk to people who want to do new projects it's either Ruby or JS they want. But increasing when they want JS on the frontend they may use Node to build their frontend bundles but serve up API's with Ruby. When I first used Ruby, we used PHP on the frontend and Ruby on the backend because finding enough Ruby developers to use it on a frontend was too risky a proposition... So from my perspective, I've seen PHP "die", yet I also know plenty of large shops deploying greenfield projects on PHP. I saw Perl "die" before that, but that too is still being used (the last Perl project I was vaguely involved with was a billing system where the backend was Perl (...) and the frontend PHP...). And all the way through the Rails hype cycle I've seen Ruby filter into more and more devops tools, and more and more backend development, and the backend/frontend distinction becoming blurrier and blurrier with Node being squeeze and slowly becoming a build tool. I have no idea what absolute usage is - I'd expect Ruby usage is still lower than C/C++ because of the sheer amount of legacy crap and "enterprise" systems. Probably still lower than Java because of Android, and lower than Objective-C because of iOS. And there are certainly other niches where Ruby is not well represented, like numerical computing and large scale data processing. But I work for a VC now, and did consulting before that. In neither positions do I generally come across many people using anything but Ruby for new projects. It's biased as hell towards tech firms doing web stuff, so it doesn't tell us anything about the overall health, but it's not biased because of my interest in it - nobody applying to the VC firm I work for know the tech team here prefers Ruby. Despite the bias, what I can say is that it's nowhere near "dying". Maybe there's a decline in some sectors. Maybe there's an overall decline. But usage is definitively healthy elsewhere, and growing many places. It's not "dying", it's maturing. Maybe it won't surpass the heights of the worst Rails hype, but frankly the Rails hype was entirely detached from everything I liked about Ruby - to me it'd be nice if Rails decline, because it'd mean people will be less likely to make projects depend on Rails (e.g. Elasticsearch tools like Chewy support Sequel tolerably well, but it's a second citizen to ActiveRecord because of Rails, and that's fairly typical). Of course maturity can turn into decay, but I see now evidence of that. 
Ah okay, thanks for the help!
&gt; Companies that use it to make money are moving away from it as they mature Are they? That's the opposite of what I've seen everywhere I work. I've seen a few notable examples of people scapegoating Ruby for their own engineering failures (Twitter being a key early/old example, where they used every bad pattern in the book, and then blamed it on Ruby, and hailed their success in exorcising Rails when the most important thing they did was firing the idiot who built a centralised monolith instead of applying best practices for federated messaging). But mostly I've seen Ruby extend into a whole lot of areas where most people aren't aware it's used, like devops, where a lot of people aren't aware they use systems that rely on Ruby. &gt; Ruby doesn't lend itself to building things that last a long time. Ruby hasn't existed long enough for us to know that. COBOL didn't "lend itself to building things that last a long time" either, expect turned out it did. Same for Fortran. Or C. But I have Ruby code that's a decade old that is more solid than ever, because Ruby is so malleable that you can build tools around it that makes the logic clearer and the code so much shorter that even if the code should get messy a cleanup effort is easy in comparison. The ability to instrument code in ways that few other languages (except equally dynamic ones like Smalltalk or Self) can do, for example, makes a world of difference. Whole research projects used to spring up around doing things like aspect-oriented development in more static languages, that doesn't need a name in Ruby because it's so trivial (re-open a class, replace method with wrappers; or extend an individual object). I remember being confused when I first started with Ruby because the GoF Design Patterns book was practically a holy text at the time, and yet when I started looking at how to implement them, they mostly evaporated into nothing - turns out most of the design pattern effort ought to have been renamed "primitive static language workarounds for stuff that's intuitive in Smalltalk inspired languages". I agree it's good to be a polyglot, but of the two dozen or so languages I've worked with, Ruby and JS are the only ones I expect to still be using a decade from now (if I'd been doing mobile I might add Java to that, but there to JS and Ruby are more viable than ever for Android at least), and of those JS is so hated that we're getting Webassembly so people can suffer it less. And we've only started scraping the surface of what can be done to improve on Ruby (both in terms of making it better/faster, and in terms of inventing something better based on lessons from Ruby - no Crystal is not it). I don't doubt that you're seeing what you're seeing, but you could have said the same thing about C in the 80's or C++ in the 90's, or Java in the late 90's - they all suffered teething problems that made people sneer at them and turn back to their old tools, or to shiny new ones and insist they didn't "lend themselves to building things that last a long time". If anything, we should probably hope that's actually true, because so far our history shows that the languages that have lingered on the longest in commercial use so far are mostly the ones that were good enough to gain traction but bad enough to be impossible to replace once you were invested... I'd prefer we see a language that takes the same leap over Ruby as Ruby did over Smalltalk in terms of taking the most powerful bits and actually making them friendlier to use. 
I'm not sure if I created the current\_joke variable correctly, but would something like this be considered good practice? require 'discordrb' bot = Discordrb::Bot.new token: 'TOKEN_HERE', client_id: CLIENT_ID_HERE jokes = ["joke1", "joke2", "etc"] seen = Hash.new current_joke = bot.message(with_text: '!joke') do |event| jokes.sample.add(current_joke) event.respond current_joke.merge!(seen) unless current_joke.key == seen.has_key?(current_joke) end bot.run
I'd grab one or two good courses on udemy for practical training and a good book for reference.
cool, if you need help you can DM me here or ping me on [gitter chat](https://gitter.im/learnbyexample/scripting_course) where I mentor students...
To be fair I used to believe in the "magic" of rails, and I think it's down to developers who quite simply just don't understand Rails enough. It's easy to think that it's all magic when you aren't yet knowledgable enough in Rails to understand what's actually going on. 
Can I PM you to ask some questions about the job market? I have been putting in around 20 hours a week on theOdinProject and am really enjoying Ruby ATM but I still have concerns about the job market and am interested in anecdotal responses. 
Are you attempting to assign the block to current_joke? Or initialize current_joke as an empty var? 
I'm using Learning Ruby First, which is free by the way, and I am quite liking it. Full of great insights. Also it uses version 2.4.0, which is pretty recent.
I was trying to create an empty variable, and assign the sampled joke to the variable
I hadn’t heard of Ahoy before, but that sounds like a solid, scalable strategy. Redis is super fast and resilient, plus you can always change 100 to 200/300/400 if you want to dial back your writes to the main db. 
Contrary to what people are saying, Ruby is not totally dying, at all. There are countless companies still investing in Ruby \(and yes, even Rails\), and Crystal is very, very promising. Benchmarks are incredible, and syntax is nearly compatible with Ruby. In reality, it's like Ruby continues on through Crystal, even while Ruby is still alive and well.
Working on a XRP blockchain analyzer in ruby: http://wipple.devnull.network/ Ruby coder for life. They will have to PRY it from my dead hands before I stop coding in it!
So I learned when rails 3 had just come out - many of the online examples were made obselete so that made things harder. My rough path was: 1. Saw a video about ROR, wanted in 2. Installed ruby, played around 3. Tried to read this book: https://www.apress.com/gp/book/9781590597361 4. Gave up because all of the examples were out of date and nothing worked. I also felt I needed a grounding in ruby first. At this point I should point out that I'd come from a c# background and was not used to things "going out of date". I was not learning web dev, I was learning rails. 5. Read this book https://www.apress.com/gp/book/9781484212790 6. Read the rails official docs 7. With all this context, re-read the book from step 3, now able to transpose the examples so they work. 8. Read this book https://www.amazon.com/Design-Patterns-Ruby-Addison-Wesley-Professional/dp/0321490452 By the time we get to steps 5-8 I am also regularly watching http://railscasts.com, doing kata on codewars and had started working on a web application that I will eventually deploy. I went on to have a 5 year rails carer before moving to node.js a few years ago.
[https://blog.usejournal.com/rails\-is\-magical\-maybe\-youre\-scared\-168c0d5c2795](https://blog.usejournal.com/rails-is-magical-maybe-youre-scared-168c0d5c2795)sorry for promoting my own material but it's just to show you how much I agree with this point :\)
Ryan Davis (minitest etc) needs your help!
fire away...
Simple executive overview
Looking at the import line itself, it is quite readable. My issue is the hypocrisy of the Python community regarding the [TOOWTDI principle](https://wiki.python.org/moin/TOOWTDI) and the fact that unless you force yourself to pick one of those rather consistently you'll wake up three days later and have no clue how you should be calling a function you imported (was it `os.path.join`? `path.join`? `join`? or did I alias it as `path_join`?). It also bothers me that `import foo` and `from foo import bar` have completely different order of words, and it's a pain in the butt to change one to the other if you decide you should.
"Oh freddled grunt\-buggly ... " Far too sophisticated to compare with Go.
Girl in red looks a bit plain, IMHO, just like Go.
Decorators are an abomination.
Exactly. With so many new developments in the pipeline for Ruby the obsession with Ruby's demise is hard to fathom. Graal VM is already offering serious performance enhancements for Ruby.
voGOn
Ruby's focus is too narrow \- web development and Rails. Whilst Rails is an excellent, mature technology, web development has moved on to async/concurrency where Ruby is weak so Rails adoption is losing\-out to Node.js. Golang and Python have also intruded into some of the space occupied by Ruby dev ops \(Chef and Puppet\) as has Docker. Basically Ruby occupies an outdated model \- OOP MVC and recipe\-style dev ops.
[Indeed.co.uk](https://Indeed.co.uk) is all you need. Search for Ruby in the job title and you'll see Python:Ruby is now 4:1 in London and Node:Rails is 3:1. Ruby is a bit more popular in the USA but the decline is obvious. There are currently 25&amp;#37; more Django jobs than Rails in London and Ruby recently fell below 100 for the first time. 2 years ago there were regularly 180 Rails jobs by title. Now it's around 85.
The first one is an array of ["a,", "e,", "i,", "o,", "u,"], just dont use commas with %w. The last one comes out a an array of ["a,e,i,o,u"] which doesnt include a "u".
Ah! Thanks.
I ran into the same problem today and I blogged about it. My case is a bit different from yours: I'm running on GitLab CI with the Docker executor. So my cause may be different from yours, but maybe this information will prove useful to you some day, or to others reading this thread. [Running Chrome Headless, Selenium and Capybara inside GitLab CI and Docker](https://blog.phusion.nl/2018/05/24/using-chrome-headless-selenium-and-capybara-inside-gitlab-runner-and-docker/)
But it doesn’t quite run Rails yet. I am hoping this will be solved soon. 
USA/Portland. My company doesn't use it but I go out of my way to use it when I can ! It's a great scripting language to help with office tasks
That guy seriously should be working for some SF company making 250K a year while spending 2/5 days a week working on open-source. Reminds me of that OpenSSL dev that pretty much single-handily maintained piece of software entire world is using for [chicken feed](http://veridicalsystems.com/blog/of-money-responsibility-and-pride/index.html). 99.9% of tech companies do not fund or contribute anything back to open-source as it's an expense they don't need.
Repost: https://www.reddit.com/r/ruby/comments/8k379i/paginating_ruby_on_rails_applications_with_pagy/
Oops, sorry!
Shameless advertising incoming: I couldn't get warm with Nagios, etc. so I created a little monitoring tool for Ruby and it also includes [an SSL expiration check](https://github.com/2called-chaos/watchmonkey_cli/blob/master/lib/watchmonkey_cli/checkers/ssl_expiration.rb). It just checks stuff though, there is no notification system in there as I'm the only one responsible for fixing things anyway.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [2called-chaos/watchmonkey_cli/.../**ssl_expiration.rb** (master → 9f9fe77)](https://github.com/2called-chaos/watchmonkey_cli/blob/9f9fe77fe09756bb420261892735a5d1c64948d8/lib/watchmonkey_cli/checkers/ssl_expiration.rb) ---- 
I hit the same original issue \(ruby managed by rbenv, cannot install gems from bundler or gem\). Maybe the problem is with IPv6. In my case it is my company's broken IPv6. Ruby will first try to use IPv6 addresses which will timeout \(2 minutes for each at my case\) and then it will try IPv4. I switched off IPv6 on my machine for our internal network. `$ host` [`rubygems.org`](https://rubygems.org) [`rubygems.org`](https://rubygems.org) `has address` [`151.101.194.2`](https://151.101.194.2) [`rubygems.org`](https://rubygems.org) `has address` [`151.101.2.2`](https://151.101.2.2) [`rubygems.org`](https://rubygems.org) `has address` [`151.101.130.2`](https://151.101.130.2) [`rubygems.org`](https://rubygems.org) `has address` [`151.101.66.2`](https://151.101.66.2) [`rubygems.org`](https://rubygems.org) `has IPv6 address 2a04:4e42::514` [`rubygems.org`](https://rubygems.org) `has IPv6 address 2a04:4e42:400::514` [`rubygems.org`](https://rubygems.org) `has IPv6 address 2a04:4e42:200::514` [`rubygems.org`](https://rubygems.org) `has IPv6 address 2a04:4e42:600::514` [`rubygems.org`](https://rubygems.org) `mail is handled by 10` [`mxb.mailgun.org`](https://mxb.mailgun.org)`.` [`rubygems.org`](https://rubygems.org) `mail is handled by 10` [`mxa.mailgun.org`](https://mxa.mailgun.org)`.` `curl` [`rubygems.org`](https://rubygems.org) `--verbose -4` works, `curl` [`rubygems.org`](https://rubygems.org) `--verbose -6` does not. `$ wget` [`rubygems.org`](https://rubygems.org) `--verbose` `--2018-05-24 17:51:29--` [`http://rubygems.org/`](http://rubygems.org/) `Resolving` [`rubygems.org`](https://rubygems.org) `(`[`rubygems.org`](https://rubygems.org)`)... 2a04:4e42:600::514, 2a04:4e42::514, 2a04:4e42:400::514, ...` `Connecting to` [`rubygems.org`](https://rubygems.org) `(`[`rubygems.org`](https://rubygems.org)`)|2a04:4e42:600::514|:80... failed: Connection timed out.` `Connecting to` [`rubygems.org`](https://rubygems.org) `(`[`rubygems.org`](https://rubygems.org)`)|2a04:4e42::514|:80... failed: Connection timed out.` `Connecting to` [`rubygems.org`](https://rubygems.org) `(`[`rubygems.org`](https://rubygems.org)`)|2a04:4e42:400::514|:80... failed: Connection timed out.` `Connecting to` [`rubygems.org`](https://rubygems.org) `(`[`rubygems.org`](https://rubygems.org)`)|2a04:4e42:200::514|:80... failed: Connection timed out.` `Connecting to` [`rubygems.org`](https://rubygems.org) `(`[`rubygems.org`](https://rubygems.org)`)|151.101.194.2|:80... connected.` `HTTP request sent, awaiting response... 301 Moved Permanently` ...
No xvfb.
Yes looking at that meme I always find the girlfriend more attractive but maybe she's a bit... Slow..
How do you know what it checked was correct if there is no notification?
I think if he wanted to work for such a company he would. Not everybody's dreaming of that.
What that code does is assign the result of the block to current_joke. An empty var would be: current_joke = nil But honestly, that type of mistake suggests you're still struggling with the language basics. You should consider studying up on ruby's lexical &amp; semantic rules before going further.
Were you able to get something going? Let me know. I'm trying to tread the same path as you.
The whole world doesn't revolve around money for everyone
I use it with Platypus which is a GUI wrapper of sorts for scripts. I do get Mac notifications via osascript, similar to what you have done.
This is pretty cool \(as someone watching and buying into XRP\). What kind of real use cases have you made with it? I was looking to build a node.js client to stream real time data. 
Just outside Moscow. There a significant community here for Ruby. I use it at work and for fun. Won't be changing any time soon. I get great enjoyment out of writing Ruby and it always makes sense. Looking forward to 2.6 :)
tell me where to find this job, i'm into it. 
never heard of JRuby \- what is is?
Ruby interpreter that run on the JVM
It’s not terrible if you need to use java libraries, the interoperability between java objects and “ruby” objects is pretty seamless.
Hanami with rom-sql
ok
^The linked tweet was tweeted by [@keystonelemur](https://twitter.com/keystonelemur) on May 25, 2018 04:26:18 UTC (0 Retweets | 6 Favorites) ------------------------------------------------- Going to try for a Ruby tip every day for a bit, see how long I can keep going :D ------------------------------------------------- ^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •
Two tips out already, decided to make this a thing: * https://twitter.com/keystonelemur/status/999487689459027969 * https://twitter.com/keystonelemur/status/999868563409199104 Using this to keep a small outlet of Ruby fun while I'm working on some more epically sized projects. Let's just say there's about to be a lot of fun announcements, articles, and other material over the next few months.
I've gone this rabbit hole and want to warn others about the issues I experienced with Clojure. *WARNING:* This is a mini-rant on Clojure. **First, the good parts.** - Clojure is a dialect of Lisp, meaning it doesn't differentiate data and control flow - e.g. A function is just a list (array). This helps you / teaches you to think about your program in a different manner. I once read a quote from someone in The Cathedral and the Bazaar that was along the lines of "Show me your algorithms, I may not know what is happening. Show me your data structure and I'll figure it out". - Portability. Clojure is intended to be a "guest" language in a virtual machine. The idea is that a Clojure program written on the standard JVM implementation can, in theory, run in any other implementation e.g. on Cloerl (Erlang) or CLJS (JavaScript). - The macro system. Wich will be familiar to you if you've used Elixir macros in the past. It's a step up from C/C++ macros, but a step down from Rust's. The macro system enables you to do metaprogramming, which saves time and can quickly solve repetitive tasks which are common for languages with strict immutability. - Lein (task runner) is nice. **The bad parts.** - I'll tackle portability first since I hinted at the problem in the exposition. There are multiple dialects of Clojure (Clojure, Cloerl, CLJS), meaning that it's not really portable. E.g. I can't take a CLJS program and run it as if it was Clojure. The standard library is lacking, it's not even close to Elixir's (Elixir is a "guest" on Erlang's VM named BEAM). From the top of my head, date-time parsing is missing - I had to resort to Java in Clojure and to Erlang in Cloerl to do the parsing and then convert the data back to Clojure. This also means that there is no central dependency manager and that most dependencies aren't interchangeable between dialects. - You have to learn two languages. The first is Clojure, the second is the one of the host's VM. If you use Clojure, you will be writing in both Java and in Clojure to accomplish some tasks. Similarly to Elixir (which is also bad in this regard), you can't just write a module / class in the host's language, but you have to use a meta-syntax to bridge the gap. In Clojure is the dot syntax, in Elixir it's calling functions on atoms. - The macro system is dependant on JVM and the standard implementation. This is a "for the time being" issue. At the moment, if you want to use any other Clojure implementation you have to depend on the JVM one to expand macros. Which defeats the portability point. - Data and Control flow being one and the same can get really confusing. I've inherited Clojure projects that only the person who wrote them could read. This is not a remark on the language as much as on the person. But data and control flow being one-and-the-same made things worse, as I often time spent hours trying to figure out what was happening only to find out that a list that I thought to be a function was actually a list containing two functions. And other shenanigans like that. This is not a remark on the language, but I want to put it here none the less. Why is the person writing the documentation for Clojure obsessed with the word "functional" I think it appears a million times. Clojure planted a seed of hate towards guest programming languages in me. And made me see flaws in other languages, namely Elixir. I wouldn't recommend it as a mature language for the time being, but if you like to tinker with things and like Lisp I would highly recommend it for a toy project. **NOTE:** If you use Clojure only to hide Java's ugly head then most of the bad parts (the first three) aren't valid points for you. And actually isn't half bad as a replacement.
It still doesn't implement UDP correctly :\( [https://github.com/jruby/jruby/blob/98abdb4fa8373f08e186b24be97e55ace91e885e/core/src/main/java/org/jruby/ext/socket/RubyBasicSocket.java#L471\-L474](https://github.com/jruby/jruby/blob/98abdb4fa8373f08e186b24be97e55ace91e885e/core/src/main/java/org/jruby/ext/socket/RubyBasicSocket.java#L471-L474)
Can you disclose where in Asia ?
Just landed in Vietnam, but I was in Japan since March. Going back to Japan in a month. Girlfriend's uncle died in Japan and they need to take care of some legal matters as what to do with his mentally disabled son. I'm here for support but because I'm on a tourist visa, I couldn't stay past the 90 days. 
Technically the threading model itself is pretty much the same (both use native threads). The actual difference is that MRI have a global lock that prevent parallelism. One of the MRI maintainers is currently workings on a new API to allow parallelism: http://www.atdot.net/~ko1/activities/2016_rubykaigi.pdf
Do you know why that is?
&gt; technically starting 1 day before summer Is there some technical date for the start of the seasons?
I work on an alternate implementation of Ruby on the JVM and we use native POSIX calls instead to try to work around this.
Yes, I wish JRuby would do this. What implementation are you working on?
TruffleRuby https://github.com/oracle/truffleruby
Awesome. Is it possible to test using travis/rvm?
The problem with guilds is that they are poorly defined and will be tricky to support in different implementations.
I was there for the first day \(unfortunately couldn't make it to the second\). Really nice atmosphere, fun people and good talks. Hope it happens again soon in the Netherlands :\)
What is RPA?
If the task is as simple as you describe, and if both tools (sensors and ticket system) are in the browser, it should be easy to just use something like [mechanize](https://github.com/sparklemotion/mechanize) browser automation library, and the script should be small and readable (like "open this URL, check this button by that CSS selector, then open that URL, enter this data, submit form", almost literally)
Originally posted this on the Rails subreddit and got some great responses, just wanted to see if anyone else had any input.
Yo looking forward to this
I tried to get it to work today. I also failed with various errors.
Huh, will TruffleRuby let ruby code interact with Java code the way JRuby does? I knew about TruffleRuby and knew it was on the JVM, but I never though to consider Java integration on it. 
one would hope that would change before release, although MRI doesn't have a great track record there. 
We have our own Java interop system, and we also try to implement JRuby’s but it’s lower priority. You can for example use something like SWT from Ruby pretty effortlesssly.
Can I find docs on your current Java interop system somewhere? JRuby's is pretty seamless, using Java objects just as if they were ruby objects (and translating Java 'primitives' too), is yours like that?
Yes that's the idea. But the further idea is that it's the same for a Java object, or a JavaScript object, or a Python object, or an R object, etc. https://github.com/oracle/truffleruby/blob/master/doc/user/polyglot.md
It's Robotic Process Automation. It's the ideia to take a very, very repetitive process and automatize it, using "robots". 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [oracle/truffleruby/.../**polyglot.md** (master → b2d83aa)](https://github.com/oracle/truffleruby/blob/b2d83aa61f9430f99c00f46951f9fa37d43b5188/doc/user/polyglot.md) ---- 
I'm admittedly not a big conference person, nor much of a pairing/social coder (other than contributing to OSS where I can)... but this is an fun, inspiring little story! Congrats to the organizers and attendees for such a successful event.
Yes there are technical dates for the change of seasons. This site provides detailed informations if you are curious. https://www.almanac.com/content/first-day-seasons The short answer is that it's based on the position of the sun compared to the equator. (When its right above it, and when it's at the biggest angle from it) The reasons the date can change each year is given if you click on one of the SPRING EQUINOX / SUMMER SOLSTICE / FALL EQUINOX / WINTER SOLSTICE links.
 A bit confusing for a newb like me, since this is clearly mentionting “rails” as though it’s part of Ruby whereas it’s made from ruby (a framework which explicitly differentiates Unit and Integration tests)
I'd love to know what makes it confusing for you.
Never heard of AnyFixture. Definitely going to roll this one into some apps. 
You enjoyed it so why not? Just started learning myself
Even if it’s “dying”, being familiar and knowing at least the fundamentals of ruby or rails would still be useful in transitioning existing companies to different or newer frameworks. &amp; I definitely agree with /u/skroleeel, as long as you enjoy it keep at it!
Despite all the Ruby being dead and "it's not the cool kid in town anymore" kind of post I just keep learning Ruby because it's really fun and you can really jump to another languages after you get a good grasp of what programming is all about anyway. Really hope we shouldn't care about what people think about our technology stack or anything, and being gullible about that. When we were a kid I don't think you care much as long as you had fun doing something.
ruby is great and if its ease of use keeps you coming back it doesnt really matter. It can prob do anythging you want :\)
Awesome! I do enjoy it a lot, was just worried about spending a lot of times on something that may be obsolete by the time I get a good grip on it. But you're right, I should just go for it!
Thanks, and very true. I'm gonna go for it!
I do agree. I just didn't want to spend all my time focusing on learning it if it ended up not being used anymore. But I'm gonna go for it and keep learning :)
Thanks. Yes, I've seen some great work done with ruby. I can't wait to be able to do my own project with it.
&gt; but currently, there are no known reliable ways to detect if the browser has finished loading the page Unless I'm misunderstanding your problem, the issue isn't with the brower loading the page, it's with your react code not setting up listeners quickly enough. There are certainly ways to wait for the browser to load your page, e.g. wait on readState == 'complete'. Usually with SPA frameworks you can find some root element or data-attribute to wait on, or worst case can use a lifecycle hook to set a global and wait on that. 
Ruby is still in the top ten web development languages. If you're purely learning languages for getting jobs, Java and C# are better choices. But learning Ruby is not a bad choice--check out job listings and Ruby meet ups in your town if you're concerned. 
I just tried working with it. I think I have it setup correctly. I’m at that point with testing where I kinda know what I’m doing. I made a fixtures file, pull that in via rails helper, then include the context. Seems to work. 
Chef uses ruby, unless chef takes a dive or people decide DeVops or CI/CD with chef is not worth it, then ruby is dead. Moral of the story ruby isn't going away any time soon, learn that shit. 
Ruby isn't dying...Javascript developers want you to believe that because Ruby is a mature ecosystem while Javascript is a messy morass of ever changing, and fighting communities. 
There is *a lot* of places already using Ruby, so even if it was *dying* then those applications will still have to be maintained by someone—and they aren't disappearing anytime soon.
Well, I started learning Ruby a few months ago and I'm an old guy who knows C, C\+\+, C#, Java and Python. Ruby is the most fun out of all of them. There's just something about the design of it that clicks. Plus the ecosystem is awesome. To me it's like a better Python :\-\)
If you like Ruby but want something cutting edge, check out Crystal.
Yeah I suppose so (looking at RubyKaigi). It's their own proud programming language after all ;)
Just that this is the ruby subreddit, but the article is talking about Rails, which, sure, is one of the most popular frameworks, but is still a framework that should be known to really get a sense of some references, imho. I mean, ruby can be used for great many other stuff than with rails which the might not separate out those types of testing. But don’t get me wrong, good article as an overview, no doubt.
Actually knowing the difference helps you even outside of Rails. You could have those types of tests even if you use Sinatra for example or your custom built framework. These concepts are not specific to Rails (even though they are very popular in the Rails community).
My first tool was ruby and I spent so much time getting lost in it because it’s just so much fun. Now I can pick up pretty much any other tool in a few hours. 10/10 I highly recommend ruby. Plus the gems make it magical. 
yes it's a nice language. It doesn't have the development toolkits like Java or C#, the universality of Javascript, or the academic bluster of Python, but it's a respectable language in its own right.
Ruby is marvelous. I've been programming for 25 years and learned a new language for practically every one of those years. Ruby is the language I keep coming back to. Learn it, you won't be sorry. 
My company is hiring for Rails devs as well as pretty much every company that does any Ruby in Prague (where I am now). It's very clear from any dev meetup. Yes it's small numbers than Java, JS and PHP. But it was kind of always like this even when Ruby was talked more on the internet. Even Oracle puts a lot of effort in research for TruffleRuby these days. From purely Ruby perspective this is the best and most exciting time to do Ruby for me. And one thing I would like to mention is our community which I really like (think Matz or Aaron Patterson).
Taichung, Taiwan.
 a = (1..10).to_a #=&gt; Array b = a.collect #=&gt; Enumerator The enumerator `b` keeps a reference to array `a` inside. Calling `each` on `b` effectively calls `a.collect` with the same block, and returns the same thing. Enumerators are "make me an object with an `each` method that does what this method would do if given a block"
Most Enumerable methods will return an Enumerator if you don't pass them a block. That allows you to build your own Enumerator that will start executing once you call a "terminal method", such as `#each`, `#first`, `#take` etc. The `#each` method will on most Ruby objects also return an `Enumerator` if you don't give it a block. And if you do give `#each` a block, it will return the array consisting of yielded elements of the collection. In the Enumerator block `self` doesn't change, it is whatever it was outside of the block. In the StackOverflow post the Enumerator object is created inside an instance method of a class, so `self` will point to the instance of the class, regardless of whether it's outside or inside the `Enumerator.new` block.
Creating an enumerator using `Range#collect` (or `Array#collect`) can be thought of as a two part operation. The call to `collect` constructs the enumerator, which requires both a range to enumerate over, and a block to iterate with. You could pass a block immediately like so: range.collect { |x| x } And you would get the same array returned. However, you can also omit the block, which constructs the enumerator but does not evaluate it—it just sort of “leaves it hanging”. You now have a `collect` Enumerator, which when evaluated happens to return an array. That's the first part. Now look at the documentation for [`Enumerator#each`](https://ruby-doc.org/core-2.5.0/Enumerator.html#method-i-each): “Iterates over the block according to how this Enumerator was constructed.” So basically, calling `each` on the enumerator constructed earlier completes the second part, which evaluates the enumerator using the block. So you've split what could have been done in a single operation into two separate parts, the construction using `collect` and the evaluation using `each`. A yielder does exactly what it says: It yields values to the block provided to it. Whenever you pass a value to the yielder using the `&lt;&lt;` method, it simply takes that value and yields it to the block it was constructed with. In this case, it is basically being asked for the next value by the enumerator. So the yielder in this case acts as sort of an “exit point” for the infinite Fibonacci loop. Once the next value in the series has been passed to the yielder, the enumerator no longer cares about further results of the loop, and doesn't return to run it again until the next value is needed, whereupon the block picks up running where it left off. I don't know if I've really made this clear, especially the part about how yielders work, but honestly it's more important to understand how enumerators work in practice rather than how they function internally. While immensely useful, they're a bit tricky to wrap your head around, and I'd say that once you are comfortable with using them, it will be much easier to understand how they actually work.
It is definitely still used. I can't comment on the job market. 
Unfortunately, not all of our JS is handled by React. Some components are handled by Bootstrap and it does not provide any hooks. Yet thanks for the idea, seems like a reasonable option for a lot of use cases.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/github] [Gem markdown\_helper Updated](https://www.reddit.com/r/github/comments/8merop/gem_markdown_helper_updated/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Interesting! Thanks for your input. I decided to go with it and learn Ruby :\)
Thanks. I am learning Java at the moment in school, and though it's okay, I'm not that much into it honestly. I like Python a lot, and the little I did with Ruby got me excited about it right away! After reading everybody's answers, I decided it to keep going with Ruby :\)
Thank you! I am gonna go with it :\) I got "Learn Ruby the Hard Way" and I am excited to begin!
Thank you. I'm with you, I did not do much with Ruby yet, but everything I did do was so much fun!
Remember that programming languages aren't tattoos. That is to say you can change your mind at any time. 
I will! Thanks for the suggestion.
Thanks! I am ready to dive in!
I'm gonna learn that shit for sure!
Ah, that's a nice little rule of thumb to keep in mind. Do you know of any articles that break down how the Enumerator class looks internally using ruby to explain it? I think that would help me understand the other Enumerator combinations.
I think all languages have detractors and a lot of people hate on both Ruby and Rails. To me it’s all about using whichever tool you prefer. It’s no different than Apple vs Android, Chevy vs Ford, or whatever. Ruby is actively developed and after all of these years it continues to get better. A focus right now is on speed. Ruby 3 has the goal of being 3x faster than Ruby 2 and we’ve seen a noticeable difference already. Ruby 2.5 is much faster than Ruby 2. I don’t know that it actually needs to be faster although faster is always great. Shopify runs Rails and handles more than 80,000 requests per second. That’s not comparable to Facebook or Twitter but it’s damn fast and proves that Rails and of course Ruby are fast enough to not pose problems. If you do need more speed there’s Crystal which is in a lot of ways a compiled version of Ruby. It’s not actually Ruby but there’s a lot of similarities so it’s easy for a Rubyist to jump into. But again, it just comes down to developer happiness. That’s why Ruby was created and for a lot of people it’s a joy to work with. I’ve worked with PHP since around 2000 and I’ve at no point thought this is a cool language or anything like that. It never wowed me. It was just a tool I used that often felt pretty clunky. Ruby by comparison wows me fairly often. But that’s just me. I’ve become a diehard fan of Ruby. 
What kind of program is it? Have you seen repl.it? repl.it lets you run programs in a whole bunch of languages in the browser, including ruby. https://repl.it/languages/ruby
Generally speaking, Ruby code can't run in a web browser, only javascript can. If you want to interact with your ruby program through a browser you'll need to set up a web app(ie website). I use Ruby on Rails, but I've heard Sinatra is good too. If you decide to go the rails route, my coworkers recommend this tutorial https://www.railstutorial.org/book It's free to read online 
[`bundle gem`](https://bundler.io/v1.16/man/bundle-gem.1.html) with [`.gitconfig` `user` section](https://github.com/sshaw/dotfiles/blob/b3614bd8824848e568c85af30d6a02b0542da2e0/gitconfig#L1) to supply gemspec with name and email and for Rails [`.railsrc`](https://github.com/sshaw/dotfiles/blob/master/railsrc) with a [Rails template](https://github.com/sshaw/dotfiles/blob/b3614bd8824848e568c85af30d6a02b0542da2e0/rails-template.rb) (not tested with Rails 5 😉). I also [alias `git`](https://github.com/sshaw/dotfiles/blob/b3614bd8824848e568c85af30d6a02b0542da2e0/bashrc#L36) to [the `hub` command](https://github.com/github/hub) to create the GitHub project and setup the remote. The one things I would like (or at least that I can remember) is being able to specify a README template. I've tried [hoe](https://github.com/seattlerb/hoe) somewhat recently, but ran into some issues and/or confusion. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [sshaw/dotfiles/.../**railsrc** (master → b3614bd)](https://github.com/sshaw/dotfiles/blob/b3614bd8824848e568c85af30d6a02b0542da2e0/railsrc) ---- 
Great to see a comprehensive tool to track these sorts types of issues down 👍👽. Can't wait to try it! &gt; That's it! Just replace let! with let_it_be Ugh `let!` &gt; If you modify objects generated within a let_it_be block in your examples, you maybe have to re-initiate them. We have a built-in support for that: let_it_be(:user, reload: true) { create(:user) } 😱 FTW, stick with instance variables!
Opal is a „Ruby in the browser” - https://github.com/opal/opal
You can start from very low level emulation like http://asmjs.org and work out your way to run Ruby in your browser.
&gt; The enumerator b keeps a reference to array a inside. That is not what happens, the range is never turned into an array in that code. Calling `each` on the Enumerator returned by `collect` intern calls `Range#each` which just walks the sequence. As an example, you can call `(1..1_000_000_000_000_000_000_000).collect.take(5)` without running out of memory on your computer.
`Range#each` has a special implementation that only works for certain types in order to be efficient. It only functions for Fixnum / Symbol / String natively and custom objects that implement a `succ` method. For example, `Time` does not support iteration: now = Time.now later = Time.now + 1_000 (now..later).each =&gt; TypeError: can't iterate from Time But `Date` does: (Date.current..Date.tomorrow).each =&gt; #&lt;Enumerator: ...&gt; What `Range#each` does is call `succ` (successor) of the last value generated and `succ` needs to return the next value (successor). `each` just returns the receiver. The reason for this is to allow `Range` to represent large sequences without actually creating them in memory, e.g. you can write this: `(1..1_000_000_000_000_000_000_000).collect.take(5)` without allocating a massive array of integers.
&gt; A yielder does exactly what it says: It yields values to the block provided to it. I'm not sure I understand. In this example, I see the `y` yielder, but I don't see what it's yielding to: fib = Enumerator.new do |y| a = b = 1 loop do y &lt;&lt; a a, b = b, a + b end end p fib.take(10) # =&gt; [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
That is true, I forgot a `to_a` in my example.
This may help you understand what goes on under the hood: http://patshaughnessy.net/2013/4/3/ruby-2-0-works-hard-so-you-can-be-lazy
What does your ruby script do, exactly? How best to get your ruby code to "run in a web browser" depends on what it does. Does it take user input? Then there's a variety of solutions. No user input? Then more info is needed to provide you a possible solution, including the possibility that ruby is *not* the answer...
Yep, had that link in the op. There's a lot of unexplained things in that post, among which is whether Enumerator::Yielder#yield is the same as `def test; yield; end; test { p "hi" }`. Also, the idea of calling yield on an object is very strange and he doesn't give an explanation for how that actually works, just what the end result is. range = 1..10 enum = Enumerator.new do |y| y.yield 1 y.yield 2 end enum.collect { |x| x*x }
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ruby/ruby/.../**yield_spec.rb** (trunk → 96e6eb3)](https://github.com/ruby/ruby/blob/96e6eb380dc097ba0d47a589a7158e5b1a3c1cae/spec/ruby/core/enumerator/yielder/yield_spec.rb) ---- 
Other people have provided some good hints, buy I'll try to clarify the overall difference between code in a web browser and code in a terminal. # Code in a terminal What happens when I enter `ruby my_script.rb` into a terminal? First, the terminal looks at the word "ruby" and decides what to do with it. When I installed ruby, one the most important things it did was make the "ruby" command visible to my terminal. It also made sure I had permission to run this program, which will be important later. My terminal knows what "ruby" is, so it starts up that program and passes it one argument: "my_script.rb". Ruby now has control of what to do next. When it receives a ".rb" file as an argument, it reads the contents and decides what actions to perform. If the script has syntax errors, Ruby will display an error message and then exit. If the script says to read a file called "secret_stuff.txt", Ruby will try to do that. It's possible you don't have permission to read that file, in which case Ruby will encounter an error and exit. But if that's a file you created, you probably do have permission and Ruby will go ahead and read its contents. Why am I talking about permissions? Well, let's look at web pages. # Reading a web page First, it's worth noting that a "web page" is different from a "web browser". Right now, I'm using Chrome as my browser. I installed Chrome the same way I installed Ruby, which means I gave it permission to run on my computer and modify (some of) my files. I did this because I trust Chrome to only do safe, reasonable things with my files. I'm using Chrome to view a web *page* that it downloaded from reddit.com. When I asked for this page, Chrome read through a file from reddit.com and decided what to do with the information there. This is similar to how Ruby read through "my_script.rb" in order to decide what to do, except that Ruby expects ".rb" files while Chrome expects ".html" files. So, as part of the answer to your question, you may want to [learn more about HTML](https://developer.mozilla.org/en-US/docs/Web/HTML). However, a lot of HTML is just used to load [JavaScript](https://developer.mozilla.org/en-US/docs/Web/javascript) files. # Code in a web page JavaScript is a programming language that was (famously) created in 10 days in 1995. It solves one problem well: user interaction with a web page. Without JS, web pages would just be static text that links to other pages. To get a sense of how big a difference this makes, compare Wikipedia (which could be written with no JS) to Google Docs (which could not). But JavaScript is not Ruby, so why bring it up? Well, because JS is the only programming language that can run in a web browser. When Chrome loads reddit.com, it looks for any ".js" code contained in that page and runs that code within the context of that page. This is very similar to how my terminal runs `ruby my_script.rb` in the context of my file system, except Chrome does a lot of work to make sure reddit.com *does not* have access to my file system. Code in a web page runs in a contained environment so that DefinitelyNotAVirus.com can't read "secret_stuff.txt" even if the program Chrome would be able to. This behavior is a good thing, but supporting it means that JS can't do everything that Ruby can do. As a result, the question "How do I run Ruby in a web page?" actually has a few different answers. # I just want to distrubute my program If I just want other programmers to be able to use my Ruby code, I can distribute the actual source. I might email someone a .zip, but [Ruby Gems](https://guides.rubygems.org/) is the ultimate way I would do this. # My program can be made with JavaScript As someone who already knows JS, there are a lot of programs I would be happy to write in JS from the beginning. JavaScript kind of sucks to learn, though, especially compared to Ruby. Also, JS in a web page is not good for reading a lot of files or doing some long-running computation, if that's the purpose of the program. Finally, even if the program is written in JS, there is still a question of how the end-user gets ahold of it. For that, I need some kind of Web Server anyway. # Time to run a Web Server Other commentors have suggested (Ruby on) [Rails](http://guides.rubyonrails.org/getting_started.html) and [Sinatra](http://sinatrarb.com/intro.html), both of which are well-supported Web Frameworks. But what do they actually do? Well, a lot of things. When I submit a comment to reddit.com, I'm sending a file over the internet to Reddit's servers. The server does the work of saving my comment on some other computer, then constructs a new file that it sends back over the internet. My web browser reads that file to update my view of what happened. A web framework helps with a lot of those steps. The code you connect to a web framework doesn't actually run in a web browser. The framework includes a Web Server which handles the tricky business of [sending information over the internet](https://developer.mozilla.org/en-US/docs/Web/HTTP). A web framework also helps you read the file I sent over the internet, and format the content of the file I send back. Right now, your program probably doesn't output HTML. A web framework lets you create HTML without you having to learn every detail of how that should work. But remember: the code is not running in the user's web browser. There has to be [some other computer](https://i.imgur.com/p7I2hsJ.png) that does the work. Instead of learning [NGINX](https://nginx.org/en/docs/) and keeping my gaming PC running a web server 24/7, I would probably let something like [Heroku](https://devcenter.heroku.com/articles/getting-started-with-ruby#introduction) host my app. # Woof, that's a long answer I hope this is helpful! 
&gt; `Enumerator::Yielder#yield` is just a method So is it accurate to say there's two different yields: a `yield` keyword and a `Enumerator::Yielder#yield` method? &gt; What it does is forward the argument passed to it along to the next block in the enumerable chain. Where's the next block in this chain, though? fib = Enumerator.new do |y| a = b = 1 loop do y &lt;&lt; a a, b = b, a + b end end p fib.take(10)
&gt; So is it accurate to say there's two different yields: a yield keyword and a Enumerator::Yielder#yield method? Yes, they are not directly related. They conceptually achieve the same goal, just that the language level `yield` works at the direct block level while `Enumerator::Yielder#yield` passes it up the enumerable chain. &gt; Where's the next block in this chain, though? In that case it's hidden inside the implementation of `Enumerable#take` which basically just calls the block n times. 
A physics calculator that takes the properties of atoms into consideration. Instead of typing the chemical element I want to be able to click with the mouse you know
&gt; Where's the next block in this chain, though? &gt; &gt; In that case it's hidden inside the implementation of Enumerable#take which basically just calls the block n times. Thanks, this answers part of the enumerator mystery. I made a user defined `take`, but it's not being passed the value of `a`. module Enumerable def my_take(n) arr = [] n.times do |n| arr &lt;&lt; n end arr end end fib = Enumerator.new do |y| a = b = 1 loop do y &lt;&lt; a a, b = b, a + b end end p fib.my_take(10) &gt; There is also nothing mystical about Enumerator::Yielder#yield, it is written in C in MRI for performance reasons but they same thing could be written in pure Ruby. Yield altogether seems pretty mysterious. Would you happen to have an example of it written in ruby?
&gt; Yield altogether seems pretty mysterious. Would you happen to have an example of it written in ruby? It probably looks something like this: class Enumerator::Yielder def initialize(&amp;block) self.block = block end def yield(*args) block.call args end end
Sounds to me, if you just want to get your program into the browser, Opal is going to be your best bet, probably the easiest to get up and going. Someone here made a music education type of program using Ruby and Opal. Follow the links for some screen shots. https://www.reddit.com/r/ruby/comments/7tncey/any_ruby_musicians_and_enthusiasts_out_there/ https://www.reddit.com/r/ruby/comments/84zk67/are_music_enthusiasts_still_there_some_coltrane/
To answer your question: the `Hash#select` method returns a `Hash`, which is why you're able to get the keys off it the return value. The `Enumerable#collect` method returns an `Array` of the _same size_, where each element is transformed by a block. The `collect` method is an alias for `map`, if that makes it any clearer. Since the expression `k if v &lt;= 1` evaluates to `nil` when `v &gt; 1`, you will get `nil` values in the result. In other words, the `collect` method is not used to filter out elements. ----- The interesting thing is that `Enumerable#select`, which returns an array, is overridden by `Hash#select`, which returns a hash. This means that `Hash` does _not_ conform to the `Enumerable` interface/duck type. It seems like a really terrible idea to me, and I was not aware of it until just now. Personally I would consider this a bug, but it appears to be intentional.
you could do something like: ``` counts = {} dups.reject{|v| counts[v], k = true, counts[v]; k} ```
Keep in mind this is assuming numbers aren't sorted... If they're sorted correctly (like your example) it's much more efficient to not save a hash table of every element!
For education purposes I recommend checking class https://ruby-doc.org/stdlib-2.5.1/libdoc/set/rdoc/Set.html which is often forgotten.
This also works: dupes = dupes &amp; dupes
Another approach is to use `group_by` of the `Array` class. dupes = [1, 1, 1, 2, 3, 4, 5] dupes.group_by{|n| n}.keys
I don't believe there is one. But the definition of `dig` is very simple ``` def dig(idx, *more) result = self.at(idx) if result.nil? || more.empty? result else raise TypeError, "#{result.class} does not have #dig method" unless result.respond_to?(:dig) result.dig(*more) end end ``` So we could modify that to be our own `dig_set` method easily ``` def dig_set(idx, *more, value) result = self.at(idx) if result.nil? || more.empty? self[idx] = value else raise TypeError, "#{result.class} does not have #dig_set method" unless result.respond_to?(:dig_set) result.dig_set(*more, value) end end ```
a[:1][:2] = 4
 $ irb irb(main):001:0&gt; a = {} =&gt; {} irb(main):002:0&gt; a[1][2][3] = 4 Traceback (most recent call last): 2: from g:/WS/progs/Ruby25-x64/bin/irb.cmd:19:in `&lt;main&gt;' 1: from (irb):2 NoMethodError (undefined method `[]' for nil:NilClass)
But you don't need for `dig`, that's the whole point of that function. I'm looking for something like that but for settings (instead of getting). Think `mkdir -p` for hashes. There really isn't function for this?
\`The symbol \`:§\` is not valid
Not that I know of.
Oh yeah, I'd forgotten about that annoying wrinkle. Exactly why we should avoid using numbers as keys.
You can construct a hash that has this behaviour by default, by using the optional block argument to Hash.new: [1] pry(main)&gt; hsh = Hash.new { |hash, key| hash[key] = Hash.new(&amp;hash.default_proc) } =&gt; {} [2] pry(main)&gt; hsh[1][2] = 3 =&gt; 3 [3] pry(main)&gt; hsh =&gt; {1=&gt;{2=&gt;3}} [4] pry(main)&gt; hsh[2][4][6][8] = 10 =&gt; 10 [5] pry(main)&gt; hsh =&gt; {1=&gt;{2=&gt;3}, 2=&gt;{4=&gt;{6=&gt;{8=&gt;10}}}} 
Using numbers as keys in hashes is absolutely fine.
I don't think there is one, but now that you mention it it might be useful. One thing is that #dig can go through arrays or hashes, whatever is there, while a construction equivalent would have to assume hashes I guess. Unless there's something fancy you can do with [jsonpath](https://github.com/joshbuddy/jsonpath) but I don't see an obvious way to do this. You could try writing your own implementation of what you want, as an interesting exersize. 
You can use a _number_ as a key just fine. I'm not sure why you'd want to use a _symbol_ for a number. `:"1" != 1`. But I haven't had much cause to use numbers as keys either, so I'm not sure about use cases. Using either is certainly fine, if it actually makes sense. 
Can you do it? Sure, but you can't go straight from an integer or float to a key. You need to turn it into a string then use that as the key. You can't just plug and play as it were. 
Really? Because I've tried using numbers as a key before and I had to do the same workaround. a[:1] tosses back an error in my experience.
 [1] pry(main)&gt; hash = {} =&gt; {} [2] pry(main)&gt; hash[1] = 2 =&gt; 2 [3] pry(main)&gt; hash[3.14] = 'pi' =&gt; "pi" [4] pry(main)&gt; hash =&gt; {1=&gt;2, 3.14=&gt;"pi"} 
Thanks
That is because `:1` is a ruby syntax error. If you want to use a number as a key, you do it like this: a[1] = "whatever" That is a number as a key. If you want to use a _symbol_ representing a number as a key (I am not sure why you'd want to do this, but you can), you do it like this: a[:"1"] = "foo" `:` is the operator for a _symbol literal_, it is not an operator for a 'hash key' or something. You don't need to use it for keys to hashes. If you use it, you are trying to use a _symbol_ for a key, not a number. 
For dig it can stop reading whenever the key you've specified doesn't exist. For the function you want it would need to know which type the missing structure has. A hypothetical `a.dig_assign([1, 2, 3], 4)`could result in `a == { 1 =&gt; { 2 =&gt; { 3 =&gt; 4 } } }`, or it could result in `a == { 1 =&gt; [nil, nil, [nil, nil, nil, 4]] }` and while that last option looks weird I'd personally expect the hypothetical `dig_assign` to work with arrays (same thing `dig` does), and if it does work with arrays I don't see why it would create hashes when a numeric key is used.
That's because `:1` is a syntax error, but that doesn't mean you can't use `1` as a key. `:"1"` doesn't create a key, it creates a symbol, the key of a `Hash` doesn't need to be a symbol, it can be anything.
I think it totally depends on your professional goals and what kind of company you want to work for (or start your own business). That being said, IMHO what's amazing about Ruby is that it was created 25 years ago and yet it feels very modern. It's an incredible feat of design. It's probably fast enough for 98% use cases you could ever think of and getting faster each year. Companies like Github, Shopify, AirBnB and Basecamp are deeply invested in it, as well as too many other companies to count. 
You may be thinking of javascript, which has this limitation. Ruby allows anything that responds to the `hash` method to serve as a key in a Hash as-is. The only things that do not respond to `hash` are objects descending from `BasicObject` or those that have been manually manipulated to remove the builtin `hash` method.
From my experience for stuff like this selenium by itself is usually good enough. After all, we are using it to pull stuff from sharepoint (and that is huge dynamic mess made by microsoft). So give it a shot.
See https://bugs.ruby-lang.org/issues/11747
i watched thenewboston’s tutorials on youtube (still haven’t finished them yet) and just made things. making things is the best thing to do to learn a language i think 
yes, our dear language doesn't run in the browser. Best to learn basic HTML/CSS/JS and make an API for your Ruby methods.
It’s nice to know that Ruby’s GC significantly improved since github started using OOBGC. But I seriously doubt anyone except them was using this technique anyways. 
It was shipped in standard in Unicorn, lots of people were using it, us (Shopify) included. It was an interesting tradeoff between throughput and response time.
Is Shopify still using OOBGC now? I thought Puma is the standard now, what benefits do we have for staying with Unicorn? It seems Puma wins on throughput, latency, performance, and memory resources.
Passenger supports doing it too. https://www.phusionpassenger.com/library/indepth/ruby/out_of_band_work.html I'm not sure how many people were using it. But that several app servers implemented it shows it was believed to be the thing to do for a while. The passenger docs note, in accordance with the OP, "Since Ruby version 2.2, out-of-band garbage collection is no longer needed." I' not sure for how long it's said that. 
I know how rubyconferences.org work (and contribute [sometimes](https://github.com/ruby-conferences/ruby-conferences.github.io/pulls?q=is%3Apr+is%3Aclosed+author%3Azverok)) :) What I've tried to say that the linked article just takes all-except-2 conferences from that site everybody knows, and I am not sure what value the linked article has.
Thank you for your detailed writeup! Shouldn't the corrupt memory issues be fixable? After looking into the issues surrounding `Thread#raise` and `timeout` it looks like it's mainly the libraries which are unsafe, because they haven't been designed with asynchronous exceptions in mind. Is there something inherently unfixable when using `Thread#raise`?
In theory yes, I suppose you could. But in practice it's close to impossible because the exception could be raised absolutely anywhere. For example, imagine some connection object (the code is a bit silly, but that pattern is common): class Connection def transaction @in_transaction = true yield ensure cleanup @in_transaction = false end end If the asynchronous exception is raised inside the `ensure` during the call to `cleanup`, well that instance ends up in an invalid state which will be very hard to recover. So you could try to flush lots of the global state (connection pools &amp; such), but ultimately just killing the process is simpler, faster, safer.
Ahh, got it. I misread. Thanks for the clarification.
&gt; the code is a bit silly, but that pattern is common That basically sums up all the examples I saw. They were either not thread-safe (in the basic sense, without async exceptions) or triggered N &gt; 1 side-effects outside of the Ruby process where a power outage would've had the same outcome. http://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/ was probably the only post which might point to a real issue and after digging into redis' and connection_pool's issues I found [this statement](https://github.com/mperham/connection_pool/pull/75#issuecomment-91595203): &gt; In thinking about this more, it seems like it is up to each connection to ensure its own safety in the face of Timeout, just as mysql2 did. Perhaps a fix to the redis gem is in order. So, it _seems_ to be fixable, but apparently not at connection_pool's level. &gt; ultimately just killing the process is simpler, faster, safer. True and as long as we don't have to use puma we'd rather not risk switching either.
&gt; They were either not thread-safe It's not really about thread safety. Imagine this `Connection` object. You check it out of a `ConnectionPool` and use it only in your thread. It's thread safe. The point I made is that if you can't rely on `ensure`, then you can't cleanup state when an exception rewind the stack. So in this case it might be put back on the pool in a corrupted state. &gt; a power outage would've had the same outcome. A power outage would simply "terminate" the process. If the `ensure` wasn't executed but the process exited immediately that would be fine. The problem is that the `ensure` isn't executed but the process continues. &gt; just as mysql2 did With all due respect to mperham, `mysql2` is far from handling timeouts &amp; such perfectly. We have production error reports due to corrupted state in Mysql connection several times a day. 
This sounds like a few people don't know some of the latest tricks. Although, it's definitely up for debate as to whether this really qualifies as Ruby running in the web browser. I certainly thought it was neat. [http://www.blacktm.com/blog/ruby\-on\-webassembly](http://www.blacktm.com/blog/ruby-on-webassembly) [https://github.com/blacktm/ruby\-wasm](https://github.com/blacktm/ruby-wasm) [http://www.ruby2d.com/](http://www.ruby2d.com/) YMMV, but, this sort of does a bit of what you're talking about, you might still need to adjust what you're doing to make it work entirely.
Unpleasant downside of that approach: you can't pass a block to methods that are wrapped by `Dry::Monads::Do`, unless that block is intended to deal with being called with `Result` containers every step. If you had anything else you wanted to do with a block argument, forget it. I think of dry-rb as an experimental new language that is temporarily using Ruby as a starting point. It's got ideas from Haskell, it's got ideas from Java IOC containers. At some point it's surely gonna have to fork the base language to fix these impedence mismatches. 
You can simply use the fact, hash values are just references, so a.dig(1) # {2 =&gt; 3} a.dig(1)[2] = 4 a # {1 =&gt; {2 =&gt; 4}} 
Those sed commands are hideous
If including `Do.for(:call)` affects all method calls, does that mean any helper methods we wish to include in our transaction also become monadic?
thanks for this. I was really missing this feature in Ruby.
Imagine if he didn't use GNU sed... 
The second part of the first code blurb is incorrect: toast = nil # Both lines below raise NoMethodError toast.try!(:push, '🥑') toast&amp;.push('🥑') `toast&amp;.push('🥑')` will not raise anything. It will just return `nil` and do nothing else. [13] pry(main)&gt; toast = nil =&gt; nil [14] pry(main)&gt; toast&amp;.push('🥑') =&gt; nil 
`.for(:call)` only wraps `#call`, other methods are safe from it. `.for` accepts a list of method names as symbols -- practically, a list of methods you want to affect. So the programmer is in full control of what happens
awesome, thanks
I don't advise it for production also. But for development and test it's pretty nice! Every time I see PG error now I'm happy, cause I don't need to break my eyes trying to understand what the hell happened. 
This looks great, thank you for sharing! Quick question, does this save memory in the Ruby side or the Redis side?
It feels like, at least with no. 4 and 5, you are in dire want of job monitoring. If you can just look at your job execution numbers and timing for the last year in a graph, the whole "when do I schedule it?" question gets a lot less hard. As does "are my jobs taking too long, and if so which?"
I agree in principle, however if you have stricter requirements for your backend and need to build some PKI on service communication, then you need to use a reliable stack. Ruby's openssl might not be the fastest openssl binding on the market, but it's decent enough. Puma ships with their own "minissl" implementation however, which is way more limited, less configurable, and poorly maintained. It seems that it was done for a time when ruby's openssl quality was low, but it hasn't caught up, and a lot of tickets lately have been because of "minissl" \(for instance, you couldn't properly turn off unrecommended SSL/TLS versions, pass options, enable TLSv1.2\(?\)...\). If it's a feature, it better work. FWIW unicorn doesn't ship with any TLS socket support, but that's because you shouldn't be using it in the first place with unicorn. 
Nice work! I made a similar thing, but in a form of a food blog, where I share my favourite recipes and restaurants: http://cuisinehacker.herokuapp.com I did it when I was a junior and wanted more opportunities to learn than my job and books, tutorials... A personal project is indeed a great way to learn because you're working on something that interests you.
It's all about Redis side. Ruby memory is stays intact. 
&gt;Why do I need to encrypt User ID.. This was pretty bad as now some user capable of doing Inspect element can change the user_id This precisely 0 to do with encryption. CBC bitflipping attacks exist specifically because encryption does not provide authentication. Fortunately, although the text never mentions it, the code uses the "and_sign" function, which signs the input.
&gt; It's not really about thread safety. Thread safety seems to be a minimum requirement for async exception safety, though and that's why I dismissed the examples I saw as not relevant and fixable (my comment wasn't direct at your connection pool example). &gt; A power outage would simply "terminate" the process. If the `ensure` wasn't executed but the process exited immediately that would be fine. The problem is that the `ensure` isn't executed but the process continues. Again, I had a specific example in mind: Along the lines of `ensure; fire_rocket; send_warning_to_population(x); end`. Async exceptions are the least of your problems with this code since you can't even guarantee atomicity without them.
I don't known why I always neglect this resource! Thank you for reminding me.
Thank you for the time you've spent on this.
Maybe this is homework and if so you can just ignore this, but don't use primitives like this. Create objects. 
Just pushed a fix for that, thanks!
I'm aware of the differences between `&amp;.` and `try`, but do `&amp;.` and `try!` differ in any way?
Ah, I missed the exclamation point, sorry! I'm not certain! I didn't even know there was a `try!` I gotta admit! 
Yup, when you autoscale it's important to have a minimum and maximum threshold :D
I feel like it's missing the most crucial and likely to miss concept: background jobs should be idempotent.
If you have 10,000 jobs kicked off concurrently, how do you keep those 10,000 jobs from eating up the connection pool connections and blocking each other? My current solution is to dedicate a thread and wrap it with a \`.with\_connection\` but it eliminates the ability to run a much of small jobs concurrently.
You give the worker processes enough connections that all threads can work concurrently without issue. If you have 20 threads, you give the process 20 connections. Doesn't matter how many jobs you have; it'll only process 20 jobs concurrently.
Related, from my horse's mouth: https://github.com/mperham/sidekiq/wiki/Best-Practices
Got it, so I should "chunk" up the loop in chunks that match the number of database connections
But say you have multiple "master" jobs kicked off at this time. Each one is only aware of the max number of connections available. There's still a possibility of connection blocking.
The jobs are all enqueued within Redis. They are not pulled into a Sidekiq process to execute until there is a thread free to run it. That thread has it's own DB connection, if you've sized the connection pool appropriately. There's no possibility of blocking waiting for a connection unless your pool is undersized.
The job system (sidekiq or most anything else) only processes a certain number of jobs concurrently, configurable. Just because you queued up 10K jobs, doesn't mean they are start at once. It depends on how you've configured your 'worker' system, whether via sidekiq or whatever. You do need to pay attention to system resources when configuring the workers. Database connections, as well as RAM and CPU (and if relevant storage space or IO, etc). 
Thanks for the explanation. That makes sense.
https://instrumentalapp.com/ruby-application-monitoring Note I work at this company.
Even after converting pounds to dollars this seems lower than I wouldn’t expected. 
Scoping of constants in Ruby is extremely complicated. I would not attempt to understand it fully unless you an expert. You can find constants lexically (which doesn't mean available in any scope - it means the opposite of that - it means only lexically nested scopes), or through the ancestry of your modules (which is often the same as the lexical environment). https://gist.github.com/kyrylo/6413067
The fastest way to import CSV data is using Postgres' [`COPY` command](https://www.postgresql.org/docs/current/static/sql-copy.html). If you have the CSV file on disk, it should be as simple as ActiveRecord::Base.connection.execute "COPY your_table FROM '/path/to/file.csv' FORMAT CSV" It's nice when you can just tell your database to do something in an optimal way :)
&gt; https://gist.github.com/kyrylo/6413067 thank you, looks complex, i'm beginner so will take it step by step i guess. 
a whitelist of allowed hosts would have been more useful. 
Cool. Then I can ask you: Where do I find the pricing? I tend to ignore services that don't have pricing links on the page, but since I have the opportunity to ask you directly here....
I think the practical explanation is that Python has been popular for much longer and had time to cross into lots of different fields. Ruby wasn't really popularized until Rails came along. 
I have a similar question. I'm a Php and c# developer and in the past few months I'm learning some python and ruby. And I can't the see de Beauty of python, the language is awsome but there are lots of weird cases like the private methods with decorators, the needed of ABC to have something like an interface, the way methods are created, the need of injecting self in every class method, and the packages management and documentation need to improve a lot. Maybe it's because of my background as developer. In other hand ruby have a great syntax, the frameworks looks nicer and the community too. 
It looks like you're in Boston. US developers are very highly paid compared to any other other country. The figures look about right for London salaries.
\&gt; I'm a Php...developer LOL
I wanted a simple configuration solution that wasn't integrated into rails, and was completely invisible to my objects.
Considering Rails is pretty good at being secure by default for other types of vulnerabilities, I find it surprising that open redirects are still so easy to create in Rails. Something like https://github.com/sdsdkkk/safe_redirect really should be built in.
As someone who has written both, I can tell you why I like Python better. &gt; object model is sane, neat and intuitive I would say Python's object model is very much the same as many other languages. You have inheritance. You can mix-in via decorators. &gt; magic methods based duck typing Ruby works in nearly the same way. The difference is that your method names are something like `==` instead of `__eq__`. &gt; descriptors This is a pretty low-level thing that you won't need for most use cases. I haven't needed to mess with descriptors in ten years of Python. Not sure if Ruby even has an analogous feature. &gt; metaclasses They're a thing you can do and they make your code harder to read that it's worth. &gt; imperative std; blocks are an absolute killer-feature This is a matter of taste, mostly. I do like ruby's block syntax _but_ chaining them together loses you a bunch of performance. You have to iterate once over your collection for each method call, e.g. `my_array.reject { |i| i.nil? }.map { |i| i + 1 }.each { |i| ... }` (an oversimplified example, but you get the idea). &gt; no Unicode hell This honestly ain't that bad to deal with if you've worked with it even a little bit. Unicode is one of those things that is fine to ignore until it isn't. Python will save you a _lot_ of headache dealing with it because you'll get the errors up front instead of dealing with garbage data later. &gt; pip literally can't be compared to gems + bundler which can be found in almost all projects There is a pipenv project which has taken off that provides some parity but pip alone ain't great. As for advantages for Python: * The Python autocompletion for vim is lightyears ahead of what's available for Ruby. I'm not sure how things like PyCharm compare to RubyMine. * mypy, while it needs some work yet, is amazing to have on a project. Static type checking to catch simple mistakes is such a massive boon to productivity. * Python helps make code clearer. One thing that comes to mind immediately for me is dealing with imports. In Python, you do something like: import json Now, everything you have imported lives under `json`. `json.loads()` to parse a JSON-formatted string. `json.dumps()` to dump a string, etc. Compare this to Ruby, where you do something like: require 'json' Now where are my JSON-related functions? Fortunately they're in the aptly-named `JSON`, but you actually might need to look that up because it's not clear whether it's `json`, `Json`, or `JSON` unless you are clear on the naming convention for Ruby modules (and oh by the way, 3rd party developers do whatever the fuck they want). Further more, something like `require 'json'` can dump crap literally anywhere in your namespace. It can be in a module or not -- it's up to the developer to not screw it up. Similar deal for calling methods. In Ruby, you don't generate preface a method call with anything. That means that method could come from your class or _any_ of the 3rd party modules you've imported. If you don't know, you have to figure it out (or maybe RubyMine will tell you, if you use that). By contrast with Python, method calls are prefixed with `self` and things from modules have to be brought into global namespace explicitly. You pretty much always know exactly where the code lives. * Python has a focus on one _obvious_ way to do something. That generally means that developers will converge on that one obvious way. Ruby would rather give you a whole bunch of reasonable looking ways to do something and let you choose. While that can be nice, it also means that you have to understand _every possible way to do something_ if you're going to effectively read other peoples' code. Hash syntax is one example. Methods being aliased is another. It's also got an exceptionally rich ecosystem around it. Have a look at the quality of projects like Sphinx, pytest, and requests. They're really damn good. Ruby has some great stuff too, but I've found there is a _lot_ more sprawl with regards to community libraries that are used. Compare https://www.ruby-toolbox.com/categories/http_clients to the aforementioned requests, which is a de-facto standard in Python. Anyhow, my two cents. Hopefully that shed some light on things.
It is an average of advertised wages. I my experience this is probably more representative of entry based pay than say an mid level or expert in the field. Those job postings tend to advertise salary less because it is a wider range and more negotiable. The contract rates seem more realistic. 
 gem-clear () { for i in $(gem list --no-versions) do gem uninstall -aIx "$i" done } Remove all install gems.
Things like Scipy and Numpy. I moved from python \(and Java\) to ruby in 2004, have always enjoyed ruby. \(I am not a Rails or web developer\). I guess it's a personal thing. You'll find things to like or dislike in either language. The very thing one person dislikes in python, someone else will defend. Same for ruby. That said python also has support from google. Also, ruby lacks a GUI or proper bindings to QT and others. Python's pyqt \(I believe\) i doing well. Ever since I left Java, I've never been able to do any GUI work. I don't see any change in the situation in the last 14 years. 
Filled a void as a decent, free, cross-platform beginner's language which was cemented with its readability and multiple applications, especially in the hard sciences and systems administration that don't typically attract programmer types. I lament this for what its worth. Ruby and its ecosystem are superior to Python's. 
Out of curiosity, what kind of non-rails stuff were you working on that motivated you to make this?
yep!
I like ruby as a language much more. But scipy/numpy/pandas/jupyter/etc. Even if there are some piecemeal replacements for some of these tools, there isn't the whole data analysis/data science ecosystem in the ruby world.
There are a bunch of tricks to speeding bulk data loading, but the major two are: 1) If possible, load the data into a table with no indexes on it, then create the indexes afterward. This is _much_ faster than inserting with the indices already defined. 2) If using Postgres, create the table and issue the `COPY` command in the same transaction and use the `FREEZE` option. This isn't as big a deal as #1, but it does speed up loading and speeds up initial data access by pre-setting the visibility flag. NOTE: This does break transaction visibility isolation but that usually doesn't matter for bulk loading. The other thing I can recommend, if it fits your use case, is to use partitioned tables in PG 10. I'm able to load ~200M rows into a partition, setup indexes on it, warm the data and put it into the line of fire in ~4 minutes using this approach (most of this time is index construction and warming). As for the actual data loading, I shell out to `psql` and use it's built in `\\copy` command. This was much faster than piping the data through Ruby in my testing.
As just mentioned by Matz in keynote at RubyKaigi 2018. 
&gt; This is a matter of taste, mostly. I do like ruby's block syntax but chaining them together loses you a bunch of performance. You have to iterate once over your collection for each method call There's [`Enumerable#lazy`](https://ruby-doc.org/core-2.5.1/Enumerable.html#method-i-lazy) which avoids that.
Cool, thanks for answering! I was thinking that yeah the fastest way would be to be as close to Postgres as possible, turns out there was a `COPY` command. I need to research `COPY` but there is also a case where subsequent CSVs would also be uploaded
Thanks for the detailed answer. I still have to scope and think which of the other approaches make sense when it comes to the trade-off of developer time and if we really need it, but those are really good TILs!
Honest question, but what can Python do with list comprehension that Ruby cannot? I always found Ruby's method daisy chaining a lot easier to read.
Cool, I'll check it out, are there any other cool PG features that Rails devs might not know much about? Also, formatted the code, just in case someone else will be reading this: File.open('sample_file.csv','rb') do |f| conn.copy_data('COPY "some_table"(col1, col2) FROM STDIN WITH CSV') do while chunk = f.read(10240) conn.put_copy_data(chunk) # does not need to be row-aligned end end end
Ruby has analogs of scipy and numpy though - sciruby and narray/nmatrix.
Even though I am wondered by the same question I think one of the reasons is that people outside of the web don't really need a better object model. These people are scientists, casual coders and so on. They just need their work to be done in a obvious way. Python provides that. I kinda hate python, though
Thanks for your kind words. If you'll use the API in the future, feel free to ping me if you need help.
You only have to inject self for class methods, but if it’s a static method, don’t use it. Decorators allow you implement DRY by wrapping functions with a single word. Use pyenv for development and pip for package management.
with a different method signature and different behavior. sure. 
Oh, the signature’s different? Never mind then. 
`yield` can be replaced with ordinary method call, it's just using a keyword makes it look nicer in some way. Using exceptions could also be avoided (given we're using `yield`) with `return` but this allows to combine `Do` with database transactions (`return` doesn't trigger rollback but an exception does) so it's a safer default choice. WRT passing blocks to methods it turns out you're likely not to have such problems. And even if you do you can refactor your code to work around this, though I never had to. And yes, `dry-rb` takes ideas from a lot of other places but it's still Ruby.
Python is easier for grad students to make haphazard scripts with
I've been evaluating this for my company. We have a couple of projects and generate the documentation on each push to the server in a job. The results are saved and served like you described with a static index html file that links each documentation. We are **not** commiting the result of the `yardoc` (or whatever you use) command to the repositories and I think it would be wrong because they are automatically created. But this is really not a good solution, for example in Java tooling you could go the next step and merge documentation of multiple projects together. This is harder in Ruby since this functionality does not exist with the documentation tools I reviewed. Most of the times you can generate JSON or something similar instead of HTML and write a tool that would merge them together, but this gets harder the more you want, ie. linking between Projects. 
I feel like slowly earning "the most hated Rubyist" title. Should I hire personal bodyguards already, or should I wait till Ruby 2.6 being released? :philosoraptor:
You've got a ways to go before reaching Zed Shaw levels. But another option would be not pushing for things in stdlib that a bunch of experienced people think is a bad idea, figuring even if you don't understand it there might be something you don't understand and caution is warranted before making stdlib/core changes that are more or less irreversible. 