**Remember that hashes are NOT ORDERED. If you are new to the concept of hashes, this can be kind of difficult to understand. 
I honestly am not very familiar with java. But joesb is right in java it's called a hash table. Hashes have a lot of different names they're also known as associative arrays.
It's not actually an array. It's an entirely separate data structure.
They're more comparable to parallel arrays than 2-dimensional arrays (although they aren't implemented as parallel arrays either). Think of an array as a list, and a hash as a dictionary. Dictionaries are a collection of word =&gt; definition (key =&gt; value) pairs, while lists are just an ordered collection of items.
I was not aware. Thanks! 
It's probably easiest to think of hashes as dictionaries. It is a data structure that associates a key with a value. Very literally, you could create a hash table that associates English words with their definitions. Just as with a real dictionary, looking up a definition for a given word is very efficient in a hash table. 
This may be the most used data structure. You really need to get the theory behind it, this is crucial. https://en.wikipedia.org/wiki/Hashmap
Sweet. Thank you!
Nice read, thanks !
* Indentation in Ruby should be two spaces, not tabs. * I would like to suggest that you take a look at the [Moneta gem](https://github.com/minad/moneta) for all your key-value storage needs. It is such a sweet way of handling storage when you don't need a database. Just a suggestion of course! * Run [Reek](https://github.com/troessner/reek) on it to identify code smells and underlying structure problems. It will drive you mad, but it is very good for improving your code * I took the liberty of adding the project to [Code Climate](https://codeclimate.com/github/redwallhp/steam-vapor). It's free for open source and you can add a nice badge to your github repo to show the quality if you wish * Try adding some tests :)
Use [Tempfile](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/tempfile/rdoc/Tempfile.html) for temporary files. Tempfile handling is surprisingly tough to get right.
Neat. Wasn't too thrilled with extend; it works but the lack of unextend stinks.
At first you can probably just think of it as an array where the indices are strings rather than integers.
not just strings, but arbitrary objects.
&gt;At first OP's having trouble understanding the whole concept. Baby steps.
I'll look into those. (I'm new to Ruby.) Got a source for the spaces? I've never seen anything indicating that Ruby cares about whitespace, and I definitely prefer tabs, as they make more sense typographically.
Ruby does not care about whitespace as you said, but it is an accepted community standard that Ruby code should be indented with 2 spaces. You can throw that out the window if you want to of course, but be prepared for more annoying people like me complaining :)
i'm sure the author knows what this is useful for.. but i can't figure it out...
http://www.youtube.com/watch?v=1OT-FxxYza0
Think of them as dictionaries. You look up the word 'dog' and it refers to something. Well, in the above dictionary, if you look up the word 'dog' it refers to 'fido'. Arrays are kinda like dictionaries where you can only look up numbers. So this can be considered a generalization of arrays. The implementation details can be found in the wikipedia link. But basically, the key is hashed into an array index, rather than being plugged in directly (like in the case of ordinary arrays), hence why it's called a hash.
google for "ruby style guide" and you'll see that pretty much everyone recommends using 2 spaces, and no tabs. That's the defacto style guide for ruby as I understand it, but I couldn't point you to anything official, because I don't think such exists. It's kind of formed out of convention. :)
Their data is frequently pretty bad. Wouldn't recommend relying on it for anything other than maybe as a starting point. Also it's the sort of thing most people find creepy.
Its a script that compares your code to the guidelines which is mentioend here: https://github.com/bbatsov/ruby-style-guide
Fantastic talk, John. Using the push daemon example was a nice touch! While it is perhaps a less commonly performed task, it provides some unique opportunities for examples of smells. In case you haven't seen it, or for anyone else interested, Ben Orenstein also gave a great refactoring talk at the Aloha Ruby Conf last year - http://www.youtube.com/watch?v=DC-pQPq0acs
Content updates yes, design changes not yet. A redesign is further down the road.
This was a fantastic talk. I like how he took it from completely procedural to OOP and almost watched how he solved the issues at hand. Possibly the best way to grow as a developer is to watch how others find solutions.
Creepy is subjective, but yes, their data is often crap. My company uses it for confidence checking.
So from what I understand, you do nearly all your looping using #each instead of for or while? Or did I misunderstand?
I came here to say just this. Both this talk and Ben Orenstein's are two of my favorites. As someone who's beyond simple tutorials, I love learning what makes great code different and better than average code.
Or: 1.9.3-p194 :001 &gt; require 'time' =&gt; true 1.9.3-p194 :002 &gt; DateTime.strptime("2013-05-19 23:11:10", "%Y-%m-%d %H:%M:%S").to_time =&gt; 2013-05-19 16:11:10 -0700 
Oh great another RoR blog tutorial. Just what I was looking for.
In the meanwhile there is not one rails CMS that can hold a candle to dozens of PHP content management systems. I guess everybody is too busy putting together fifteen minute featureless apps and then abandoning them. 
Ruby &gt;1.9 also has the built in Fiddle module, which seems to have the same functionality as ruby-ffi, but it's difficult to find good tutorials for it. Here's a presentation about it: http://www.slideshare.net/tenderlove/hidden-gems-of-ruby-19/111
FFI is definitely the way to go. Makes your life so much easier.
And here's [another presentation](http://verboselogging.com/2013/05/01/ruby-batteries-included) that touches on it. There is a ton of other good stuff in the presentation too!
I looked at it! However. If you need to access underlying C data types of other Ruby objects I haven't found a way to do that in FFI. Also, it only works with dynamic libraries. But, if you just want to access a C library you installed locally, then I can imagine FFI is really awesome!
Another article about Ruby FFI http://rubysource.com/detecting-faces-with-ruby-ffi-in-a-nutshell/
I'm failing to grasp the relevance of complaining about sparse CMS product choices in reply to an educational tutorial being posted.
To be fair he's on part 6 now (and still calling it a '15 minute blog'.) But seriously, it even starts with scaffolding.
Were you looking for code review or something? Not to be harsh but this is just a html parser. Why use this over say going to pandora.com -&gt; my profile -&gt; likes?
If CMS is something you think is a good idea then by all means use a PHP one. Why does the CMS have to be in Rails? Nevermind, I don't have time for the answer, got to get back to my featureless apps.
this is all fine until you need something like stat() or some fancy-pants alloc() derivative which is almost always going to be done with the pre-processor. FFI .. is not pretty when you need to step around the pre-processor.
`stat` is a function in `libc`. As for dealing with macros, could use [XNI](https://github.com/wmeissner/xni#readme) which generates stub C from Ruby classes, which are then binded in via FFI.
Why would you need to access the internals of a Ruby object? That could end up corrupting the Object and crashing the VM.
If you could build your own cms easily then there would be dozens of rails cms programs out there. The fact is that it's really hard and takes a long time. It's also not glamorous I guess.
I think I'm in the "special case" case ;-)
Ok. I'm going to try that out. Last problem left is that I have structs that I don't want to layout in FFI. I just want to use them. They are deeply nested and it would be tedious to create 5-10 different FFI::Struct's only because they are used internally. My "high level" code will never see them. I tried finding something like allocating a MemoryPointer from native datatype size but couldn't find something like it.
Here is how you write a blog if you are not using rails. apt-get install wordpress.
I used to be in the tabs camp, until it became common to host code on places like github. Tabs are rendered so wide it's pretty ugly and ends up harder to read. Take a look at [your steam.rb](https://github.com/redwallhp/steam-vapor/blob/master/lib/vapor/steam.rb). The lines aren't that long but already run off the page because of the tabs.
If you're still having trouble, the talk itself is on youtube - http://www.youtube.com/watch?v=q_qdWuCAkd8
Why? If you need a clean object why not just new up a brand new one?
This recent addition to the Phusion Passenger manual is part of an ongoing process to improve the documentation and general user friendliness of Phusion Passenger. We want to make Phusion Passenger **the best** documented (or just the best) Ruby app server out there. If anybody has more suggestions, please let us know.
Call me old fashioned, but why not call this "entity-extractor" or something dull but self-descriptive. Not a big fan of the cutesy names that bear no relation to function; not likely to remember it if I find myself with a need for it down the road. Having said that, I was processing twitter feeds today and having this kind of output can be handy.
The rvm docs tell you exactly what needs to be done and what happens, what do you mean by 'no clue where it came from'?
i think this article suffers from being overly dramatic and by not acknowledging that DRY is a very commonly talked about principle. Flay is neat, though
There is some confusion here. `@start` is never initialized, but you seem to want to use it You're calling the methods you're trying to match from `when` test expression, you probably want a String there. You're calling the methods you want to call from the `when` body, just call the method directly there. You're assigning to the local `next_action` in different methods, but these are not shared, use an instance variable.
Thank you very much for your input. I have a few questions. Yes. I transferred it incorrectly from my editor. I've fixed the @start initialization. &gt; You're calling the methods you're trying to match from when test expression, you probably want a String there. By "when test expression" do you mean the case statement? If so, yes, I'm trying to pass the result of that case statement to the next_action = method(next_action).call expression. But for some reason, the result of that case statement isn't being passed because the case statement doesn't seem to be catching anything I enter at the prompt. &gt; You're calling the methods you want to call from the when body, just call the method directly there. That seems to break the while loop. My intention is to use that while loop as an infinite runner for the process. It seems like I need *some* sort of evaluator for user input at some point in the process that calls the relevant method. &gt; You're assigning to the local next_action in different methods, but these are not shared, use an instance variable. Once we get into the while loop, doesn't all the action remain in there? Aren't we calling the methods from *within* the while loop? So I don't need to turn next_action into @next_action?
Thanks in advance!
You're implementing a state machine here. I prefer to implement state machines as one class per state since they're easier to test, but this seems, instead, to be part of an exercise. &gt; when beginning `beginning` should probably be `"beginning"` &gt; next_action = beginning This is where you want to call the `beginning`. `beginning` returns a String, the name of the next action, so it is ok. Be sure your other action methods do the same. &gt; […] &gt; next_action = method(next_action).call Remove this line, it is not necessary. You can also fix your problem by removing the case statement. and using just `next_action = method(next_action).call` (be sure to handle the NameError raised when the given action is missing.
&gt; &gt; You're assigning to the local next_action in different methods, but these are not shared, use an instance variable. &gt; Once we get into the while loop, doesn't all the action remain in there? The `next_action` in #play is different from the `next_action` in #beginning. Your action methods should either set an instance variable indicating the next method or return the next method name. &gt; Aren't we calling the methods from within the while loop? Yes, but you're executing two actions for each trip through the loop. Once in a `when` body and once after the `case` expression. &gt; So I don't need to turn next_action into @next_action? You don't, but the assignment in #beginning can lead to confusion. Just return the result.
Cuba is my favorite Ruby (correction, *web*) framework by far. My choice of web stack is Cuba for routing, [Erector](http://erector.rubyforge.org/) for templates, and [Sequel](http://sequel.rubyforge.org/) for database access. All great projects.
Sinatra is not a full featured framework, it's still a toolkit, although a much more complete one. The source for cuba is great though, amazing learning experience. 
Sinatra is a toolkit, a framework makes decisions for you. Sinatra doesn't.
[Definition of framework](http://www.thefreedictionary.com/framework) &gt;A set of assumptions, concepts, values, and practices that constitutes a way of viewing reality. Sinatra makes no assumptions for you, just as Cuba, they are actually really similar except for the fact that Sinatra has more features and Cuba purposely keeps it down. Rails on the other hand **does** make assumption and that's what separate it as a framework from Toolkits like Sinatra, Cuba, Camping, etc. This is no semantics, they aim to be different things.
Did that a few times in the past with Ruby's Spiritual Liege: Perl. Too lazy to bother now...
This is all DSL magic. If you want something without DSL try camping or espresso.
Yikes, is this expected behavior? Code: require 'cuba' Cuba.define do on get do on "hello" do res.write "hello world" end end end run Cuba Requests: GET / # 200, but empty GET /hello # 200, "hello world" GET /hello/world # 200, "hello world" 404, do you speak it?
Hi @judofyr, it is expected because you already matched the GET. If no routes match, you get a 404. In this case, the inner `on` acts as an `if` without an `else`. Here are three ways to accomplish what you want: First version, putting all the conditions together. on get, "hello" do res.write "hello world" end Second version, using the status code explicitly. on get do on "hello" do res.write "hello world" end on default do res.status = 404 end end Third version, mounting another app. on get do run SomeApp end If the routes defined in `SomeApp` don't match the request, that app will halt with a 404, and that will be the value returned from this `on get` block. Here's the code what lets that happen: https://github.com/soveran/cuba/blob/master/lib/cuba.rb#L120-L132 Sometimes I use an `error` helper that sets the status code and also renders an error page: def error(status) res.status = status render(status.to_s) halt(res.finish) end For that helper to work, you need a `render` helper that just writes to `res`. I could be more explicit and illustrative there by writing to `res` directly, but I wanted to show you code copied directly from one of my projects. With that change, the `default` block in the second example would look like this: on default do error(404) end I hope this clarifies a bit how Cuba works, let me know if it's still confusing. 
Hey @myringotomy, I think stating Cuba is DSL magic is a bit exaggerated. The meat of Cuba is the `on` method, and its purpose is very simple: it accepts a variable number of arguments and a block, and executes the block only if all of its arguments return true when passed to `match`. I think `match(...)` is what may make it look magical, because it treats some values as special cases. Check the code to see what I mean: https://github.com/soveran/cuba/blob/master/lib/cuba.rb#L213-L222 That code is what allows the matching of PATH_INFO and the collection of values to be passed to the block. But I still would not call that magical, as it's very well documented and doesn't involve metaprogramming. I'm not familiar with espresso, but I have worked with Camping in the past. It has some DSL aspects when you mount routes, and specially if you use Markaby, and it has some metaprogramming in the dispatcher. We could argue if that's DSL magic or not, but in the end it doesn't matter much because it's probably a matter of taste. In any case, it's great that we can choose from a lot of good tools like Camping, Sinatra, Cuba and others. I just wanted to point out that while DSL magic is abundant in the Ruby ecosystem, it's a bit too much to say Camping and Cuba are DSL magic.
I haven't used either one but this is the first example on the cuba page. require 'cuba' Cuba.define do on root do res.write 'Hello, Cuba!' end end That's a DSL. This is the first example on the espresso page (github). require 'e' # or Bundler.require class App &lt; E map '/' def index "Hello Espresso World!" end end App.run That's just ruby code. I would be interested to see which one is faster. I am betting that the pure ruby approach is faster than the DSL method. 
I don't find it confusing. I understand the behavior, but I disagree with it. This style encourages nesting, but causes lots of weird edge cases: on "hello" do on post do res.write "hello" end on get do end end Okay: POST /hello # =&gt; 200 GET /hello # =&gt; 200 GET /foo # =&gt; 404 Not okay: POST /hello/1 # =&gt; 200 DELETE /hello # =&gt; 200 DELETE /hello/1 # =&gt; 200 The prefix-only matching is especially concerning to me.
So don't write it that way?
Huh, Erector looks interesting. I'm not convinced, but it's interesting. I'll take it out for a spin. 
Yes, it's part of Shaw's Learn Ruby the Hard Way tutorial series. But this code in particular is my attempt to extrapolate from one of the lessons. when beginning That was my attempt to handle the very first call, which didn't seem to need to be a string because the user never needs to call it. &gt; Be sure your other action methods do the same. That's what I'm trying to do, and what I thought I did. Setting *next_action* to the various strings. I think there's something fundamental I'm missing here... &gt; You don't need this line next_action = method(next_action).call Ok. Thanks. The case statement now seems to be looping within the while loop now, but the result of the case statement don't seem to be returning the correct methods. I'm getting mixed up someplace/somehow. I'll poke around a bit more and see if I can figure it out. 
If you write `on "hello"`, it means you want everything that matches that part of PATH_INFO. It's up to you then to define a catch all case (the `on default`). We could have 404 as the default status code, and in that case you would have to assign 200 explicitly. But it would also be a bad default for some cases. For example, sometimes you want 401 as the default error code. That's why I think the only real solution is to understand how it works and act accordingly. It's a bit like forcing yourself to write all `case` statements with an `else` branch. The nesting is also useful for matching other aspects of the request. For example, consider this project structure: https://gist.github.com/soveran/5699081 Also, even if I don't do it, you could write part of the response in an outer block and continue in the nested blocks, then return whatever there is in the response body: on "foo" do res.write "At foo&lt;br&gt;" on "bar" do res.write "At bar&lt;br&gt;" on "baz" do res.write "At baz&lt;br&gt;" end end end GET /foo/bar # =&gt; 200, "At foo&lt;br&gt;At bar&lt;br&gt;" That's a bit extreme, but it's just to illustrate that once you are inside an `on` block, you already have a successful match. 
...[or is it](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.180.9203)? No studies on screaming snake case yet.
You can write code like that, it's totally fine and many people do. What happens is that sometimes you may want to build your app differently and you won't find that flexibility with Sinatra. In that sense, Cuba's approach is more generic, like a primitive that lets you build a Sinatra. If all you want to do is HTTP verb + PATH, then Sinatra is more succint. 
The title is a bit irksome. Are all microframeworks for Ruby now assumed to be Web related? People seem to forget that Ruby is a general scripting language, not one designed for webwork (although it does that *quite* well). 
How can that be faster? You still have to type the letter, but you have to hit the minus key along with the shift before.
Regard less of the ratio of openings between the two, I'd go with Ruby if you don't have much/any other programming experience. Ruby is higher level than Java, and easier to learn. You'll probably be able to actually do more after two weeks of Ruby than two weeks of Java... I'm biased though :p
It's literally just due to muscle memory, and probably some bad typing habits. 
it's also a lot more straight forward to split() snake_case than camelCase.
I get multiple recruiters calling me each day for ruby positions. All based off of my github and linkedin.
Came here to ask about SCREAMING_SNAKE_CASE, my favorite name for variable formatting ever
One of the reasons I love Dvorak is because -_ is easily accessible on the home row :)
But....didn't PHP have this forever ago?
Not really clear as to what this has to do with Rails...
Rmagick is such a pain to set up if you're on Windows, though. I just use ImageMagick and then put together commands in a quick program.
What if I told you, you [didn't have to choose?](http://ruboto.org/)
Like this study (where the participants were mainly trained on snake case and then found it easier to read) the few dvorak tests done also have suspect results because the participants were only trained on dvorak before testing :)
ThePdfNameIsInCamelCase
Er, if they beat the people who were only trained on qwerty, that's still relevant to *at least* the large number of non-touch typists.
I want to start off by saying I love Ruby. With that said there are several places where Python beats Ruby. 1. Tons more resources for the new developer. Many of the documentation Ruby has involves Rails, and that might turn people who don't want to write WebApps away from Ruby. 2. Python's GUI libraries are lightyears ahead of Ruby's. 3. Linux is has very large Python community within it, so adoption of Ruby on Linux isn't as big as Ruby on Mac. 4. When people hear Ruby they hear Rails and think nothing past it. Just a shame, really, because core ruby is awesome! (I, to this day, have not written one Rails app. Been writing in Ruby for 3+ years now.) These are just speculations, so dont hold me to it. 
man, I've really wanted to change over... how hard is it?
Honestly I don't care much about studies pro or con in favor of Dvorak. Those are notoriously hard to control, but besides that I know that in practice I find it far more comfortable than Qwerty to type on and that's what matters to me. Also, even though it wasn't designed with computers or programming languages in mind, I often find shortcuts/key locations to be better on Dvorak than on Qwerty (the -_ key being one example, but other things as well like cmd+q, :q, j/k, position of braces, and so on). The only common ones that wind up being worse are copy and paste, since C and V are on your right hand.
Cuba, is the first web framework of Ruby that I worked with, even before Rails. The advantage I felt is the small learning curve, and you will get to learn whats under the hood rather than the heavily abstracted form shown by rails. 
that's just awful
Why?
As a RoR dev, I have recruiters knocking down my door right now. It's likely the same for Mobile devs. That said, I think mobile development is currently pretty niche-ey ... there's probably less work around, but those that can do it I'm sure are busy. If you wanted to cast the net wide, Ruby is probably the way to go. ...and as another poster mentioned, with Ruboto, you can write Android apps in Ruby.
 foo = 4 bar = 6 foobar = foo-bar What's the value of foobar? Or should it give an error, 'foo-bar undefined' ? 
Eh, it's not `split("_")` but it's not too hard. "camelCaseAndSuch".scan(/(?:^|[A-Z])[^A-Z]*/) =&gt; ["camel", "Case", "And", "Such"] 
Rather reminds me of FORCE = 1 TON, but you're probably all too young to remember BASIC gotchas. ("FOR CE = 1 to N").
&gt; What's the value of foobar? &gt; (let* ((foo 4) (bar 6) (foo-bar (- foo bar))) foo-bar) -2 Obviously, minus two. :-)
And [Python](http://www.python.org/dev/peps/pep-0008/#method-names-and-instance-variables) and [Perl](http://perldoc.perl.org/perlstyle.html).
Cheeky bugger ;-)
Yes you can do: on "hello" do on post do res.write "hello" end on get do end on default do res.write "not implemented" end end `default` always returns `true`. 
Try Colemak instead. You might find it easier.
I find in Ruby I stick to snake_case and in JS I tend to use snake_case for simple property's and camelCase for methods. I'm only bring this up because earlier this morning I saw that RubyJS supplies both. 
Ruby supports both, but its convention is to use snake_case over camelCase. Its only real rule is that if it starts with a capital letter, it's a constant.
PascalCase
I've taken second semester Java, Data Structures, C, and C++, but that's about it, at this point. I know my way around a RedHat box, though. 
Haha, nice. 
(def foo 4) (def bar 6) (def foo-bar 8) Wait, you use a language with infix grammar? Well, there's your problem.
Great post. Would like to see some examples somewhere demonstrating simple and advanced uses for krypt, but it sounds like docs are a priority so I'm sure we'll see those eventually. Keep up the great work.
Good post. TIL a bit more about Ruby's Binding class :-)
So you would rather wear out your shift key chording '_' or Caps then put fucking spaces around your binary operators as you should be doing regardless?
It really isn't. Your eyes get used to pretty much any formatting system easily. Judicious use of whitespace is much more important than quibbling about hyphens and underscores.
Funny thing, Emacs has minor mode, [Glasses](http://www.emacswiki.org/emacs/GlassesMode), that allows to display camelCase words with a separator, like camel_Case or even camel_case, if anyone were so inclined.
You could enforce a rule that operators are surrounded by at least one space (on both sides). some := 2 word := 8 some-word := some - word 
How would you use this in a pure rack app?
ya, my hands already hurt from work. so my main reason for doing it is comfort and RSI
very interesting, thanks for the tip 
yeah, that would make sense. 
Afaik if you don't have custom shell code in your .rvmrc file it is now best practise to use a .ruby-version file and a .ruby-gemset file
Why do you needed gem sets if you have bundle
I've used RVM in the past, but have been much happier with the simplicity of [rbenv](https://github.com/sstephenson/rbenv). You can install a gemset plugin for it if you like, but there's really no need with bundler. Also, I alias: bi='bundle install --binstubs=.bin' and add "./.bin" to my $PATH and to a global .gitignore
You don't. At all. RVM has many features, but imo you shouldn't use it for anything other than installing rubies and switching between them, and even that only on development / test, not production.
&gt; and add "./.bin" to my $PATH The paranoid among us might not like this idea. At the very least make sure to add it to the very end of your PATH.
Maybe you want to not use bundler? If thats the case though you are probably not using rvm either anyway. I've been much happier after moving to rbenv.
Yeah, it's a risk, but a very slight one. I wouldn't do it on a production machine, but it's fine for my laptop. You can do something similar with zsh as well, without manually editing your path. For instance, `lordzork/zsh-bundler-path-helper` or the Bundler plugin that comes with `robbyrussell/oh-my-zsh`
coming to visual studio!
LESS @box-size: 10px; @box-size-1: 25px; @box-size-2: @box-size-1-1; //what does this do? 
has any one ever worn out a shift key?
+1 for rbenv if you all you want to do is manage Ruby versions. Much simpler than RVM.
I hate RVM especially as someone who has to do devops. rbenv isn't bad but the king of all these ruby managers is chruby https://github.com/postmodern/chruby Seriously amazing especially as a devops person. It uses bash like it should be used!
You make a valid point though, but it's not (currently) the path of the least surprise. But for people not to go insane foo+bar should then be identified as a single identifier as well. Otherwise it would get very confusing: foo+bar-this+that 
Well, the debate here was: why would Ruby (an infix language) prefer _ over camelCase. You're right that this issue wouldn't exist with postfix syntax.
PHP gets no respect on reddit.
Sure, until someone decides to remove the extra spaces.
I just have a keyboard on the floor dedicated to the underscore character.
It looks exactly the same?
Sure. keys wear out. But that wasn't _really_ the point. Both Caps and '_' require a coordinated dual key chord, which requires more effort, slows typing, and introduces more opportunity for mistakes. It's the most common simple typing mechanic mistake I observe in both my own and others' typing.
http://ruby-lang.github.io/
Correct, but it now runs on Jekyll and is available on GitHub. Previously it ran on Radiant I believe.
You're right, that is a topic for another post. The goal here was to give an overview for those who have chosen to use RVM and its features. Rbenv and its features vs RVM will be covered later.
This is a very nice tutorial. 
Seconding mechanize. See here for examples: http://mechanize.rubyforge.org/EXAMPLES_rdoc.html Are you giddy? You should be giddy.
This looks along the lines of what I was looking for. Thanks!
My keyboard doesn't have many keys, and it didn't stop me from writing Greek characters, Japanese signs etc. Regarding the sign: hyphen-one−hyphen-two. With spaces, it's hyphen-one − hyphen-two. Some fonts are actually lousy in making the distinction (which shouldn't matter in a code editor anyway, with all these fancy colors nowadays); I guess it's ASCII legacy: it even "taught" some people that " is a quotation mark. And a sign for inches at the same time. Oh, crap.
Just as a side note, you can also write hashes this way (in 1.9 and above) as long as the key is a symbol: `hash = {key1: 'value1', key2: 'value2', key3: 'value3'}`. That's a lot cleaner and easier to read than its equivalent `{:key1=&gt;"value1", :key2=&gt;"value2", :key3=&gt;"value3"} `.
* gem "sinatra" * gem "activerecord" * gem "sinatra-activerecord" * gem 'sinatra-flash' * gem 'sinatra-redirect-with-flash * gem tux Why not just use rails 
It's a totally different framework with a whole host of pros and cons?
thanks!
sure, you could use rails. i prefer sinatra because i like having more control over what i'm doing. plus rails is not an ideal learning environment, which the tutorial is meant for. 
&gt;My keyboard doesn't have many keys, and it didn't stop me from writing Greek characters, Japanese sighns etc. Not with a single keystroke.
Is it possible to write full android apps using ruboto? Last I checked, which was a while ago, You only had access to a subset of The Android APIs. Is this the equivalent to ruby motion for iOS?
Thank you, great guide
You now have access to the complete Android API.
Very little profgramming uses non latin characters. This is a programming topic,
Yeah, definitely. I guess I'm trying to automate a few patterns that I find myself getting into: 1. A framework to define which attributes of a model are summable, countable, etc. over time periods, and provide convenience methods for them. 2. Provide a...hopefully, not too brittle of an interface that, with a Rake task, I can bake out all of these calculations. For concern #1, even just a mixin that handled `count_in week`, `sum_in_year`, etc. would be nice. Maybe I could just use `method_missing?` to attempt to dynamically perform the method if it hasn't already been explicitly defined. I can't tell how much of my need for this is an actual need or just out of my undisciplined propensity to slap on `past_week.sum(:word_count)`-type methods where it seems convenient. Concern #2 is more important to me. This would be a separate Module/ActiveRecord model, but let's say I define the `Message` model to have `sum(:word_count)`-type methods for time intervals of `year`, `month`, and `day`. I can have a rake script that generates these calculations and then stores it in its own table, i.e the aggregations would be a kind of single-table inheritance model, with each aggregation belonging to a model...so: `user('dan').sum_of_word_count_for_messages_in_day("2009-10-10")` Would generate a record that belongs to `user('dan')`, is an **aggregation_type** of `sum`, across the **dimension** of `word_count` for the **collection** of `messages`. The **time_unit** is a **day** and the actual **time_value** is `"2009-10-10"` So let's say I bake out all these day-length aggregations. If I decide later on, I want to do **week**-long sums, this aggregation_model -- *instead* of hitting up the archive -- would just query the table of *aggregations* and sum up the records that included the `7` *days* of `word_count(:sum)` values for the messages belonging to `user('dan')` This obviously can lead to ridiculously complicated abstractions...but I think the one thing that would make it manageable is that the hierarchy of time never changes...*days* will be made up of 24 *hours*, and so forth. Of course, in terms of data reliability...what happens when my script that calculates `day` values breaks...how does the `month` aggregation of those days know that it's complete? And time-zones will really muck up things. But, as I said, this was just a bandaid before moving on to a real data-warehouse framework :) 
If you're trying to do reporting and things like that, look into using PostgreSQL's materialized views. You can make a view of these things you're going to be querying, and just show that, instead of using Rails to do queries for your dashboard.
Because Rails isn't the 'do all, fix all' framework/tool to use in Ruby. It's possible to create things using different tools, the hammer is not always the correct tool.
So what I've found in situations like this is that very often you'll want to keep this rolled-up data. In order to make access to the aggregate fast, you want to persist it, either as materialized views as suggested by @riffraff98, or as real records in another table. Following your example, I might have a real table called `monthly_author_messages` that stored the aggregate data, and a `MonthlyAuthorMessage` model that hooked into the `Message` lifecycle through the aggregation API. If you design the aggregation API to live on these support models rather than on the delegating class (`Author`), it'll be cleaner, less coupled, and allow for more easily-customized aggregates.
Do you know if the performance is fine for ruboto now? I remember that being another concern before.
Wow...if I had any hesitation about starting a new git repo, I think it may have disappeared :) 
You just wanted an excuse to use that name for something, didn't you? ;)
I am just saying if you keep piling on gems to make your tool look and act more like rails then you are better off using rails.
Ruboto performance improves as hardware, Android, Dalvik, and JRuby performance improves. Startup time has been improved slightly, general code performance has benefited from JRuby updates the last year. In general, performance is fine for many tasks, but certainly not all. GSoC 2013 includes two projects for improving Ruboto performance, including adding Dalvik JIT for the new IR based runtime. 
It lets you use local override files, by default cloned from S3, which you can then mess with locally for dev more easily and/or offline. I guess it hypothetically adds a tiny bit of latency to startup for network interaction, but pretty small, and we run on EC2 so even less of an issue if you're there.
Originally I think it actually integrated with zookeeper/was zookeeper aware, but we ditched zookeeper while we were moving to use this ourselves. It's not an issue at scale because it's not intended to make config dynamic, we only offer a code based reader for config, because it's not intended to have your software rewriting it's own config at runtime... this is mostly intended to replace hard coding values in code and a better, more granular security model...
I will admit that the "Filebased S3 Configuration Kontrol" is a backronymed graft to make sense of the "Fsck", which seemed slightly more apropriate and acceptable as a name for an opensource project than than its other, more profane cousin it resembled :-)
Or you could have created a [filesystem checker](http://man.cx/fsck) for gluster.
If your are on linux you can compile it yourself with --prefix pointing to your home directory. I have used this guide once but it is fairly old: http://www.r-chart.com/2010/06/installing-ruby-on-linux-as-user-other.html You could also use rvm, which installs into your home directory when installed as a non-root user. https://rvm.io/rvm/install/ (Single-User Install Location)
Second vote for RVM on Linux. It's fantastic and has no requirement for root if you're installing it within a single user's home directory rather than system-wide. All my ruby installs are done via RVM these days, so I can easily have multiple webapps requiring different ruby versions running on the same server. If you're using Windows, the RVM FAQ recommends [Pik](https://github.com/vertiginous/pik/) but I can't comment on needing admin rights or how good it is because i've never used it.
 ./configure --prefix=/path/to/install/into then make sure `/path/to/install/into/bin` is added to your `PATH` in `.bashrc`. If that's too complex, checkout [chruby](https://github.com/postmodern/chruby#readme) and [ruby-install](https://github.com/postmodern/ruby-install#readme).
https://github.com/sstephenson/rbenv
You haven't even mentioned the operating system you're trying to install on.
There are three popular options, in order of how heavyweight they are: - [RVM](http://rvm.io/) - [rbenv](https://github.com/sstephenson/rbenv) together with [ruby-build](https://github.com/sstephenson/ruby-build) - [ruby-install](https://github.com/postmodern/ruby-install)
3rd for rvm. I use it for dev in OS X and also for deployment to a production Linux cluster. Makes dealing with VM dependencies a snap.
Ok. Thanks. This is what I'll try.
Mac OS X 10.6.8
Ok. Thanks. I've used RVM several times. I think I'll go that route.
I haven't had any problems today.
Yeah, can't go wrong with RVM.
I'll be there. Happy to grab lunch or coffee or beer. Or any food and drink based social gathering.
I will also be there. PM me and we can do something.
Yes!
This looks interesting. I use Foreman extensively for development, so I'll give this a spin.
Awesome. If you have any feature requests or bugs, feel free to use github issues. 
What part of it is slow? Retrieving gem index? You can try `bundle install --verbose` to see if anything unusual happens, like excessive redirects or 404s. Can't say I've noticed any slowdown myself, today or yesterday.
Yes, I have experienced some slowness from a few servers hosted on rackspace, but not locally. Maybe it's a network issue?
&gt; We are very happy to welcome Booz Allen Hamilton as a new Gold sponsor of RubyNation. LOL
Easiest way would be to use [irb](http://en.wikipedia.org/wiki/Interactive_Ruby_Shell). Just open a terminal, run irb and paste your function. From then on, you can can test it buy calling it, just enter pow(2,4) to calculate 2**4. Or you could save it into pow.rb, add puts pow(2,4) and run 'ruby pow.rb'. And it will print out 16. You could also go all out and replace puts pow(2,4) with puts pow(ARGV[0].to_i, ARGV[1].to_i) This way, you can pass numbers to your script, running 'ruby pow.rb 2 4' will print out 16. ARGV is an array which is filled with the parameters you pass to the interpreter. Let me know if you need more help.
Try running this: https://gist.github.com/anonymous/ee33ec3e1661a4408103
its working fine [see link](http://codepad.org/8YntQR1o) maybe ruby is not well installed
The ruby way would have that loop look more like this: exponent.times do result = result * base end Or to be even more concise: exponent.times{result = result * base} I rarely ever use for or while loops in favor of using mostly enumerables and sometimes (as in this case) the .times method of integer.
upvote for good content
hey, nice idea and neat implementation! 
thanks for this it worked... any chance you could explain the solution to me logically? 
What's the first thing you don't understand?
i is the exponent? the loop runs untill i is less than or equal to the exponent? what does += mean? 
"+=" is a shortcut. "i += 1" means the same thing as "i = i + 1". It increases the value of i by 1.
i is used as a counter, so the loop counts from 1 to the exponent. Also, since it's a while loop, it will run while the condition is true, in our case 'i &lt;= exponent'. 'i += 1' is the same as 'i = i + 1'. You can use this shorthand operator for all arithmetic operations and logical operations.
I would have done something more like def pow(base, exponent) (1..exponent).inject(1) {|sum, _| sum *= base} end but I like your solution, small and precise. Could have been: exponent.times(result *= base) However, you need to return the result explicitly afterwards, and result needs to be 1 to begin with, so the entire method becomes: def pow(base, exponent) result = 1 exponent.times { result = result * base } result end
This is a pretty good implementation of this kind of functionality. I've been using it with success for a while: https://github.com/wireframe/email_preview
To be honest, I wish they had called it [project](http://en.wikipedia.org/wiki/Projection_%28relational_algebra%29) instead of inventing their own term for it. Then it would have been obvious to do the full multi column thing from the start. 
Looks like a really cool tool, can't help but feeling like it would be really nasty in practice on a project of any reasonable scale.
F'ing BAH, trying to pretend they're a real development company (I used to work for them) 
Good read! Personally I'd use the existing puppet/chef modules/cookbooks to install and configure Jenkins though. 
you can golf it a little by doing something like this! def pow b, e ([b] * e).inject(:*) end
project should return a relation, so it's closer to #select than #pluck (or #pluck_all).
This is what I was looking for. Thanks!
I was able to get a DSL that works exactly like this with [Docile](https://github.com/ms-ati/docile). 
I'm not sure I follow you here. I certainly wouldn't advocate it for most project dependencies. Most project dependencies would use the normal library dependency system (gems in the case of Ruby, composer for PHP, etc.). But for those little one file short bits of code that are used on many projects it is overkill to create a library. You could just manually copy/paste in a project. But then as you enhance the code, the other projects using the same code don't get the benefit. The ability to diff, push and update means that you can easily move tweaks to those little snippets of code between projects with no effort. Seems like it would help on projects with scale that may have 10 or so of these types of files. Just "gist-dep update' and you have imported the fixes for all those files (sort of like "bundler update").
What? Up until 4, rails hasn't had a good way to only retrieve particular columns? That's an extremely basic feature of SQL... :S edit: Post.where(category: 'cats').select([:id, :created_at]) &gt; Ah ha, this will only query for the two attributes that are needed! Well, actually it creates hundreds of thousands of incomplete objects and will still suck the life out of your server. Still not good enough. Now I see why Rails gets its reputation for being slow... how could you leave the ORM not optimising this sort of basic query?
Find this difficult, here my solution : ======================================= class Family def initialize(name) @name=name @role=Hash.new {|h,k| h[k]=[]} @parent=$humanity.last end def name(n) @name=n end def add_role(person,role) @role[role]&lt;&lt; person end def show(n=0) marge=" "+" |"*n puts marge+"Family "+@name @role.map { |r,l| puts marge+r+" "+l.map {|p| p.name}.join(", ")} @role.each { |r,l| l.each { |person| person.subfamily.each {|f| f.show(n+1) } } } end end class Personne attr_reader :name,:subfamily,:age def initialize(name,role,&amp;b) @name,@family,@age,@role,@subfamily=name,$humanity.last,0,role,[] @family.add_role(self,role) if @family instance_eval(&amp;b) if block_given? end def add_family(f) @subfamily &lt;&lt; f end def age(a) @age=a end def family(name,&amp;b) if block_given? f=Family.new(name) add_family(f) $humanity &lt;&lt; f f.instance_eval(&amp;b) $humanity.pop f else $humanity.last.name(name) end end end def family(name,&amp;b) f=nil Personne.new("god","god") { f=family(name,&amp;b) } f end $humanity=[] ; %w{mother father}.each {|meth| define_method(meth) { |name| Personne.new(name,meth) } } %w{sister son}.each {|meth| define_method(meth) { |name,&amp;b| Personne.new(name,meth,&amp;b) } } #============================== x=family "smith" do mother "rose" do age "60" end father "bob" do age "65" end son "john" do age "38" family "f.john" do son "elliot" do age "10" family "f.elliot" do end end mother "elisa" do age 3 end end family "f.john2" do son "johnJohn" do end end end end x.show =========================================
Which framework do you think is going in the right direction?
Thank you for the informative article.
The webster english dictionary is a hash. Word = key, Definition = value. That's all there is to it. A hash is a key=&gt;value store. They exist in nearly every programming language
You seem to be set on using an "internal DSL" which needs to work directly in Ruby code. I've gone down that path many times and not been happy with the results. Sometimes you need to step back and think what syntax you really want, which will sometimes be a freeform "external DSL" non-Ruby syntax that requires a parser. It all depends on your situation and requirements... If you really want a custom syntax, you might consider trying to transform a lightweight JSON or YAML format into the data-structure you want as a basic starting point. If you want to take things even further, I am a fan of using PEG parsers like Citrus: https://github.com/mjijackson/citrus One of the benefits of JSON or a completely custom syntax is you can consume it with other languages later. This might be overkill. It depends on your situation.
I can't see any ads :/
Nicely written post, would work well as a university lecture as an introduction to the principles of concurrency. Nothing mind-blowing ... the Global Interpreter Lock is a lock!
Adblock is a wonderful thing
Yeah, there's no difference. And Jesse doesn't generally run ads on his blog. OP might want to check for a virus/ISP proxy/similar.
You need an entire article to say that the GIL is an interpreter-wide mutex lock? And sure they make promises about what it guarantees - thread safety. That's kinda the whole point.
Make sure you stay tuned for part 2, you might be surprised!
For a while every link on the site redirected to a page about your available books.
Ah yes, that did happen for a few mins. Google experiment code gone haywire. Sorry about that.
Because it wasn't thread safe!
Just curious how this differs from [Padrino](http://www.padrinorb.com/) or [Ramaze](http://ramaze.net/)?
On macs, rvm has a nice GUI front end called jewelry box. 
Eeek, maybe it's my prejudices, but I don't like the idea of developing my app in the browser... sounds too easy to fuck things up.
&gt; We thought to ourselves, “Cool! Ship it!” So we did. And Then Our Servers Fell Over The next morning, our on-call DevOps engineer got a 3 am wake up call. Uhh, great separation of production and testing environments there, guys...
Because people who write such blogs may be discouraged by trolls like you. 
Or maybe encouraged to include more content in them. I read the whole thing thinking *"I must be missing something... there's a revelation about some inner working, right? Some actual technical detail?"* Got to the end somewhat disappointed. So far, not even calling myself a fully-fledged ruby programmer, apparently I already completely understood the GIL. I was kinda hoping not to.
There are people that don't understand the GIL, like me.
postmodern, just like Orange from Grapefruit :) or Grapefruit from Orange... depending on your context 
jon_laing, Frontline is just a option. Use it when you need a "visual representation" of your applications. 
I get this error when trying to use Jewelrybox: rvm requires autoreconf to install the selected ruby interpreter however autoreconf was not found in the PATH. Anyway, I don't think this is going to work. I need Xcode installed too. To get the compiler. And to install Xcode (or even the stand-alone CLTs), you need root access. Ah well. Time to man up and just buy a new laptop to take to work...
Hi, author here. Care to elaborate the question?
Wherever happened to ramaze
Sinatra / Padrino I suppose. Much like Nitro and Camping, it was way ahead of it's time. http://ramaze.net/
My problem is less with the implementation than with your representation. A Family Composition has both persons/nodes ("John", "Bob") and relationships/edges. Problem is, those "relationships" are actually relative to a starting point: "Bob" is father relative to "John" but probably husband relative to "Rose". It looks like you are mixing both aspects, which make it difficult. You sort of recognize it yourself when commenting "john is a son of bob of the smith family and he has a son named elliot". The internal model of Family Composition is for me a graph, with people as nodes and relationship as edges.
I'm not getting the same errors. Is it because I'm using a slow machine? With the example as published, my array size is 5000 for MRI, JRuby and rbx. I changed the code so that it adds 100000 array items per thread, and got a slight discrepancy with jruby (499938), but MRI and rbx still came in at 500000. I understand that this doesn't undermine the point of the post, but I'm curious about why it's happening. I'm doing this on an ancient iMac. It's got two cores, but it's not very fast. Is that why the totals are more accurate? 
Did you look at the code, or try it before posting this comment? This gem builds a reusable standalone job class that can be called directly in other contexts like rake tasks. This implementation is in no way tied to the database. I put it in a database model in the example because, that's what 90% of rails programmers do, you don't need to. This gem generates boilerplate classes and methods, period. You mention replaceable-ness: By using a class macro like this, it would actually be easier to globally replace enqueue and dequeue behavior. In this model the end user doesn't even need to know resque is powering the queue. As for usefulness, it's debatable, as all things are. For me it's all about the interface. If I wanted to write verbose code I would still be using C. Why write 5 lines of code when I can write 2? What exactly are you trading off again? 
I built Rails Mail Preview a MacRuby based app https://github.com/fernyb/RailsMailPreview
If you do enough controller tests you might end up skipping them entirely. Just not a lot happening there.
Doesn't think kind of defeat the purpose of a test suite? To make sure you haven't broken anything else in the application with your new feature.
I don't think so. I've been using this technique locally while developing a small feature that touches a few different classes (or tests). I'm still advocating running the whole suite before merging and deploying. 
Seems like a painless version of mailcatcher? But not updated for 6 months? Hmm..
Hard to say what the reason is, but the point is that it's non-deterministic. Sometimes it works as expected, sometimes not. If you increase the number of iterations, I suspect the chance of an unexpected result goes up.
I get the non-deterministic part, and the necessity of understanding what's going on if you want to use threads. I don't understand what's going on, but I know that I should. :) It's just that these bugs are a little scarier if we can't produce them reliably. They're inherently very subtle to begin with. If you can't even see their effects much of the time, it makes them that much worse.
I haven't looked into this deeply, but it seems like you need to install it into your rails app, so include it in the Gemfile. That is a good way to make all your Windows- and Linux-using colleagues angry, when they can no longer install the bundle.
I think you are both right =) There's times you want a class you define (that you don't want to reopen) if you want fine grained testing. For example, maybe you want to test a method returns the posts you really want to mark published, and that you find the user you expect. Other times, it's faster and more clear for simple tasks to have a quick inline DSL. Options are good! @schneems my $0.02 btw, I had a poor reaction to the DSL method name "resque_def" I think the _def suffix bothered me, plus it names resque. Something more ambiguous like `background_job` or `define_background_work` could be nice if you swapped from say, Resque to Sidekiq, no need to touch models! Just a minor nit but figured I'd chime in.
Or just use 37signal's [mail_view](https://github.com/37signals/mail_view) made by DHH
Thanks for the detailed post. I've often wondered what exactly happens when the OS schedules one of ruby's (native) threads that doesn't hold the gvl. Your post answers that question brilliantly. Another thing I've often wondered about 1.9+ MRI: are RubyVM instructions always atomic? Headius's comment answered this one with a resounding "no." While I might have guessed that "send", "invokesuper", and "invokeblock" are not atomic, even "opt_aset" doesn't guarantee atomicity. That was surprising. One last thing: you can (ab)use the fiddle library (stdlib ffi) to call ruby's c extension API from ruby code. Since the c function "rb_thread_blocking_region" releases the gvl, you can use fiddle to run ruby code in parallel — tenderlove wrote a little block wrapper for this in a gist a few days ago https://gist.github.com/tenderlove/5733632
Thanks for the comment! And thanks for linking that gist, I wondered if that'd been attempted yet. Going to have to play with that :)
Is it really fair to compare Ramaze to Nitro? Ramaze is still alive and maintained last I heard. Shame it never got popular I remember having fond memories using it years ago. Really simple and intuitive. The rails juggernaut was merciless back in those days... 
502 error for me as of 7am PDT. Shame, I was curious of what it said, since my typical Sinatra API pattern is to do a before_filter setting content_type, combined with automatic parsing of the body for JSON. Past that, just the normal Sinatra gravy. 
Same, 502 from EDT @ 10:46 am.. here is a cached copy: http://webcache.googleusercontent.com/search?q=cache:ivAJA_mm44cJ:mfojtik.im/creating-rest-based-api-with-sinatra-rabbit+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=us
gem install will install the gem to your whole system. A gemfile is used so that you can easily transfer programs over other computers. When you download the program, you just have to run bundle install and the Gemfile (with bundle) will install all the necessary files to your computer without you needing to manually look up and gem install them all. Gemrat is to add gems to the gemfile rather than using gem install.
ok, thanks :)
Thanks. Not sure it was worth the wait - I don't really want to introduce Rabbit to my setup, since I like the bare metal of Sinatra, but still interesting. 
neat idea! most times editing Gemfile is tedious and appending by `$ echo "gem 'blah'" &gt;&gt; Gemfile` is inconsistent. 
I just `nano Gemfile`
Feature request: gemrat &lt;group&gt; &lt;gem&gt; 
+1
The code in the gist works, but you can't really do anything in parallel with it. There is no mutex around incrementing the program counter, so as soon as you try to execute anything in parallel, you'll either get a segv or the VM will exit with a complaint that the PC is wrong. I just wrote it for fun. :-)
I dont understand why I should use this. If you add all of your Gems like that, the Gemfile becomes a total mess and you will likely install two gems for the same purpose.
It seems the main usefulness is grabbing the latest version number without having to go to rubygems.org, but I agree that this would make your Gemfile pretty messy.
Adding gems to the gem file and bundle installing already obtains and includes the latest compatible version of the gem you wish to add with dependency resolution, and is a very simple two step process. Why should I use this instead? It seems like a solution without a problem. Also, then the Gemfile.lock created after bundle installing already locks the latest version of the gem you are installing as the current version of the gem for that app which will persist until the gem version is then updated.
Or use [REP](https://github.com/glebm/rails_email_preview) engine with views &amp; generators, i18n and editing via CMS -- [all](https://github.com/glebm/rails_email_preview) in the browser (or as part of your admin interface)
Are you committing a Gemfile.lock to version control? Bundle install should respect the versions in that until you update with bundle update, from my understanding.
I think I have it figured out, sort of. Not sure why games[:id =&gt; 1].update(:awayopponents =&gt; "NYG") doesn't work, but the following seems to work: games.where('id == ?', 1).update(:awayopponents =&gt; "NYG") Anyway, hope this helps someone down the road. 
More importantly, it installs per project, usually into the vendor folder. That way, no dependency problems are created.
&gt; If you care about your application performance ... you do not run background workers within request dispatching process.
That's not true for a ton of reasons, most importantly because bundle update will blow past major version changes. The right thing to do is use optimistic versioning down to the minor patch level.
Hmm. For rails i'd probably just use resque cause you likely already have a fair amount of infrastructure anyways. With smaller backend services (eg sinatra driving some external usually async computation and returning json) within the request handling i Process.detach(Process.fork{ ... }). This way the request responds immediately to the client (so no need for longer request timeouts in unicorn) and within the fork block exceptions are caught and sent to airbrake or whatever. 
Correct me if I'm wrong, but doesn't "gem install gemname" (or adding it to your Gemfile without a version number) already install the latest version?
thanks for the feedback xternal and Kimos!
Do you worry at all about security in production? I like to at least take a cursory glance at the github for a gem before adding it. Make sure that I trust the author and that the gem has some specs, looks legit and that it's understandable enough that if I have a problem with it I can jump in and change things.
As an (OS X) example, Tempfile gives me this: `/var/folders/1t/82x01m8j63sg7r9ct7w540y80000gp/T/`, as a result of Tempfile.new('foo.rb')
i don't think jumping to a method definition is a 'trick'
since i'm here, the best feature of ide's i've used is the live git diffing they do so I can see all new/deleted/edited lines and revert hunks easily. That feature keeps me out of vim more than anything else. Blue on the left hand rail? oh i edited this line. click blue, oh yeah, that's what it was before. awesome feature.
Short answer: yes, classes exist just for organizing your code. Any algorithm which is possible to write in one Turing-complete language can be written in another Turing-complete language, so there are not much things which cannot be accomplished without classes, or, for that matter, pretty much any idiom.
Awesome. 2.0.0p195 is stock on OS X 10.9 too!
Thanks for the straight answer!
my best trick for IDEs: Ctrl+q then you have the freedom for thinking and coding by using an editor 
You actually can get this in vim, if you so desire: https://github.com/airblade/vim-gitgutter
My favourite trick in IDEA is that when you're running in debug mode you can pause at some point and then choose "Evaluate" to execute code in that context. Combined with tests that setup the application to a specific state you get super fast development speed.
Oh man, this is awesome.
I will investigate this, I hope its awesome. This is one of features that kept me from switching to vim.
Here is the JSLogger API specs http://jslogger.com/api and a small article to guide through its architecture http://blog.jslogger.com/post/53277404395/a-quick-introduction-to-the-jslogger-api . So far, I guess the authentification still laks some refactoring...
You could add some more details about what it does and some of the supported features to the README
It's nice to see Rubinius still alive and kicking. I'm curious about maglev, how is the threading support in that implementation?
your "just for fun" gists are the best ones! I made this horrible gist in an attempt to marshal UnboundMethods between processes after stealing your fiddle code for calling rb_iseq_load: https://gist.github.com/benolee/868c72f16642e498e238
Great suggestion, thanks!
I like this. Big ups to Heroku for being nimble and taking advantage of latest stable ruby.
Tl;dr - no.
i am planing to make the charts even better, so if anybody want to contribute to the project, please be my guest.
What happen with that code and the style? No indentation etc...?
Has anyone watched this that can spell out what it is in words? I've already done 9000 things to make my tests faster but I am always open to new ideas.
Submitted a pull-request for lin-log charts: https://github.com/alexQueue/benford_s_law
It explains how you can use Ruby to create forks of current process and as such make a test-server. Then it explains how to use UNIX-sockets for passing around messages from a client to that server. And viceversa. It also explains a little about process-handling and exit-handling. It explains the techniques behind tools like Spork, Spring or Zeus. Basically it is a very nice video if you want to know more about Unixy stuff in Ruby. I doubt it it is usefull as technique to make your tests faster in practice, but it is really useful for learning some background.
No to worry, someone just made a [pull request](https://github.com/bennacer860/benford_s_law/pull/2) to fix that.
why do you want to use log 2 display? i am sorry i don't understand what does this change do 
You might want to have a look at the [R programming language](http://www.r-project.org/).
oh thanks this is perfect ;)
perfect thanks!!
&gt; like the idea of the $ prefix why's that? 
Because they are jQuery extended JavaScript Objects. They have a boat load of special functions and can be used with jQuery functions.
Hey, it looks like you're learning Ruby so here are some completely un-asked for suggestions: On lines 36 and 56 you can use map instead of each to be a bit more elegant The if statement on line 49 can be changed to just frequency[first_digit] += 1 if you instantiate the hash like this: frequency = Hash.new { |h, k| h[k] = 0 }
heh, pretty cool you did all that with a 9 line module. A different approach that also does this quite eloquently (albeit not in 9 lines), is using the specification design pattern made famous by Eric Evans. Comes also handy when you need to dynamically change the boolean chains at runtime. http://martinfowler.com/apsupp/spec.pdf Nice dsl!
As mnaim said, in Ruby this denotes a global variable so it's not the reason. Generally, people preface variables with a $ sign because it's a visual signal that it refers to a jQuery object. I'm not familiar enough with Angular to tell you the reason there.
Codeschool?
Heaps of things: * Learn a web framework. Doesn't have to be RoR, might be something smaller if you're not totally into webdev and want something with a smaller learning curve * Read the source of smaller ruby projects. Learn how different people structure ruby apps in the wild. How they apply Object-Oriented practices in Ruby, or functional practices, etc. * Write your own hobby projects. IRC Bot, Small MVC web framework, Blog engine, RSS reader, Reddit bot, Text game, w/e. The idea is to totally reinvent the wheel. **After**, you can go look at how other people have implemented these ideas. * Write pull requests for improving other ruby projects' documentation. Its the easiest way to start contributing to the open-source world, and people will love you for it. * Automate whatever you can at your workplace. Hell, automate what other people are doing. * Try others' projects listed on CodeAcademy. [Here](http://www.codecademy.com/courses/lang/ruby?filter_by_levels=all&amp;filter_by_locales=en).
Try building your own app that solves some problem you already face. The Code Academy classes provide you with more than enough information to build your own Ruby apps. Alternatively, you could get involved in an open source Ruby project, a list of which can be found here https://github.com/search?q=language%3Aruby&amp;ref=cmdform sorted in order of popularity on Github. Regardless of what you do now, it's important to write some real code.
Code.
Start reading two books - The Well Grounded Rubyist, and Metaprogramming Ruby. Maybe play with Sinatra a bit. Then pick up a copy of "Rebuilding Rails", work your way through it, THEN start learning Rails - it makes a world of difference when you fully grasp all the little metaprogramming tricks behind rails. 
&gt; visual signal that it refers to a jQuery object This seems like an un-Rubyish thing to do. If knowing the type (or general behavior) of an object is handy, why not put an n in front of anything numeric? 
&gt; Force users to add a facebook login And I'm gone.
Well, since the idea is to stop fraud by confirming user identities. Your leaving is also a positive result.
And in scenarios that users do not have Facebook? The whole basis of forcing users to sign up for another, at times, questionable, service will inevitably result in lost users and sign ups. 
Numeric things should have obviously numeric names (count, totalAmount, etc). In the case of a jQuery object you want the variable name to express meaning about what it contains but you also want to hint that it has additional functionality. This is particularly helpful in cases where you may accept a non-jQuery object in a method and then convert it to jQuery for your own purposes (someElement, $someElement). Don't forget that Ruby is a language not a way to program. It has best practices that do not apply to all other languages.
Pick up Eloquent Ruby and go through Hartl's Ruby on Rails Tutorial. I saw someone recommended rebuilding rails, and that is not something I am familiar with, but definitely sounds like it is worth reading.
Thanks so much. Sounds like something that won't be super useful to me right now but I'll add it to my list of things to watch when I get a chance.
Absolutely this. You've probably heard lots of "practice, practice, practice" throughout your life or even a paraphrasing of Gladwell "It takes 10,000 hours to be an expert", never mind that varies per subject. But most importantly is to make your practice purposeful! Write something with purpose, such as a project, something you've been curious about. Make sure its something just a little outside of your comfort zone. If you need help along the way then post or check out IRC, its much better to need help in a few spots than to pick something too easy.
I grabbed two other classes in active_model and their private methods didn't have underscore leading. It's odd that callback.rb does have it, apparently. 
I don't want Facebook to know everything about me. I don't like having everything connected to it. And there are many people who think the same way.
each language has its own conventions and best practices, and typically they exist for good enough reason to follow them, even if the only reason is so that other devs can easily read/maintain your code. When I write JS, I write in JS-style. When I write Ruby, I write in Ruby-style.
i haven't had the time to optimize my code but thanks for the advice i will make the changes tonight 
I felt that way when I first completed it, but when I started to build a blog on my own all the pieces started to come together. I think that will be the case with any tutorial, none of it really sinks in until you do some work yourself.
tl;dr Timeout is a sledgehammer and frequently breaks things.
Read Metaprogramming Ruby.
I guess I should rephrase and say that it seems like an "un-dynamic-ish" thing to do. Dynamic languages, afaik, shy away from prefixes that try to nail down the type/interface of an object. But this prefixing with $ is common in js code that uses jquery. On the one hand, it's a common convention. On the other, it's a dynamic language (js). So I was wondering what Ruby devs do when confronted with this mismatch. 
Now your question makes more sense :) You'll see it a lot in jQuery because it reminds you that you can do stuff with the variable that you might not be able to do in vanilla JS. That's why it's good to have the distinction. Another problem is that JS has so many bad parts, and their are fewer people to evangelise the good parts. The best we have is Crockford telling us to remember our semicolons, and to name a class with a capital letter, not because you have to, but because other people will be able to understand what your code does. There's so many reasons in Ruby that you don't need this reminder, mainly because it gives you so much freedom about what you can do, while still evangelising good practice. It's because of that, that it encourages you to give variables and methods more descriptive names, and to organise your code better. The fact that it reads more like a natural language also encourages that. Hopefully to illustrate: // js var names = ["dan", "mike", "ed"]; // because I have to specify 'var' so I don't accidentally make a global for(var i = 0; i &lt; names.length; i++) { // man I have to type all this? console.log("Hi! I'm " + names[i]); // No string interpolation doesn't bother you till you start needing to output html }; ========= # ruby names = ["dan", "mike", "ed"] names.each do |name| puts "Hi! I'm #{name}" # la la la this is so much fun end # or, in one line: ["dan", "mike", "ed"].each { |name| puts "Hi! I'm #{name}" } Sorry for the contrived example. What I'm trying to say is, when coding flows as nicely as it does in Ruby, you don't need to worry about reminders. And just to illustrate with another contrived example my point about jQuery, using a $ in a variable means that you're less likely to mistake a variable containing a jQuery object, for one containing a simple value. 
That is an excellent explanation. Thanks. 
No worries, dude. It goes way deeper than that. Like being able to override methods (in a controlled and safe environment, of course): &gt; class Greeting &gt; attr_accessor :name &gt; &gt; def initialize(name) &gt; @name = name &gt; end &gt; &gt; def to_s &gt; "Hi! I'm #{name}" &gt; end &gt; end &gt; &gt; puts Greeting.new("dan") Hi! I'm dan Also, just to bring back coffeescript as I did mention it earlier. Here's my earlier example: names = ["dan", "mike", "ed"] for name in names do -&gt; console.log "Hi! My name is", name PM me if you have any questions.
that plugin does have gutter, but not all the options that make rubymine's git integration awesome. meh i guess
Alternative implementation: module Allowable def allow(&amp;block) Thread.current[:stack] = [] yield Thread.current[:stack].any?(&amp;:call) end def when?(&amp;block) Thread.current[:stack] &lt;&lt; block end end 
This is actually a Python influence, see http://docs.python.org/2/tutorial/classes.html#private-variables-and-class-local-references
IIRC that double underscore = private is enforced by the compiler in python, isn't it? As in naming something with the __ makes it private, rather than it just being a convention. 
No need to sell me on coffeescript, I use it daily. I think that's where my mismatch is coming from. In js using a $section is fine because it's become ingrained. But having worked with Ruby (and then coffee), doing something like that is weird to me. 
Technologies used: sinatra framework, sequel orm, slim lang, ffmpeg. 
no, it still kicks ass. kthxbye
I can't recommend this book enough
maybe try ruby koans or keep practicing in www.rubymonk.com ?
Oh yes, the first book I read about Ruby. I was a Java developer back than and was astonished that a lot of Java design patterns could be reduced to a simple block / lambda / Proc, where you would need an Interface and a whole class in Java just to add a single function because of the lack of closures.
Interesting, I was not aware of that convention. The convention to return a boolean for methods ending with ? is not enforced. If it were, it would cease to be a convention ;)
That's some good reading! I'll have to add that pattern to my toolbelt.
I like this design because it makes it trivial to write a disallow method that does the opposite (or any other manipulation of the conditional queue, for that matter). Using `try`/`catch` binds `allow` and `when?` together. +1
How does one go from Code Academy to writing IRC Bot, Small MVC web framework, Blog engine, RSS reader, Reddit bot. I can't help but think of this http://oi41.tinypic.com/qpku15.jpg
Looks like the Pry gem isn't installed (did you include it in your Gemfile?). 
Try including pry in your project's .gemfile or install it globally with bundle install pry. Then you could start an ruby or rails repl (rails c, irb on command line) and typing require 'pry' of that works guard should work.
With libraries and documentation, of course.
If you use "bundle exec", installing globally won't help. Make sure pry is mentioned in your Gemfile.lock (created after doing a "bundle install"). If it isn't in there, add it to the file called "Gemfile" and run "bundle install" again.
would love to get some comments / thoughts about this. also if anyone has an idea how to publish this but still give users the ability to configure their own dashboards? (see http://stackoverflow.com/questions/17255069/creating-a-user-configurable-new-relic-plugin)
actually redis is pretty fault tolerant technology (if used in right way ;) ) my opinion: -&gt; when user submits form it should got saved into database (probably using ajax - so user can resubmit form without losing any data if something goes wrong here) -&gt; contact model is actually a statemachine, which on after_create trigger, enqueue making of first transition in resque (probably some method like def next_state with login encapsulated there). Also each transition enqueue next one in resque - making a chain. -&gt; resque has only one task: make_next_transition without any logic. it only calls model.next_state. Therefore: you can test model method very extensively. Also even if you lose your whole redis data, you can easily recreate it calling model.next_state on all objects - if model is in last state it will do nothing. Also - I believe if this emails are so important to you, you may consider switching to some hosted smtp service (like sendgrid).
I was going to suggest something along these same lines. I think this is the most straight forward approach. However, even though you should never loose any emails with this approach I think there are a few edge cases you might need to check for (just off the top of my head: of course the obvious error handling, and requeing on mail failure, also checking to see if a prior mail thread is currently running: i.e. what if the mail thread from the prior cron cycle is hung?).
You can use the [LockFile](http://rubygems.org/gems/lockfile) gem to make sure cron tasks don't overlap. I use this for billing related cron jobs and it works fine. As far as the edge cases you described, since you're keeping all of the messages in the database, you just don't change the flag on it until its been sent successfully so that should eliminate problems with re-queuing. Some sort of error notification as well as possible sanity checks (there's X number of messages unprocessed - this is unusual and probably requires a set of eyes) would be a good idea.
This sounds over-engineered. Of course you should not rely on email, so definitely persist the requests to some data store. But just about any "fault" should bubble up as an exception. So make sure you have some error catching system like [Airbrake](http://airbrake.io) on there and a monitoring system like [Pingdom](http://pingdom.com).
How convenient is the update process when a new version of chruby is released?
simpler than rbenv or equal? https://github.com/sstephenson/rbenv/ Not sure I like the "anti-feature" of "Does not automatically switch Rubies by default." It's kind of nice having a a .rbenv-version that switches to the ruby the project is using automatically 
I don't know about those, but I got "beginning ruby" by peter cooper and its pretty alright. You might be able to find the PDF out there. I guess this is not so much for OP but maybe relevant for some passing by readers. 
 sudo make install exec $SHELL :) Also, chruby is available via homebrew.
"The Ruby Programming Language" by Flanagan and Matz is where it's at.
I'd read the reviews and decide which suits me best.
I would hardly say RVM "pollutes" your env variables. Unless there is some feature that is significantly better, why would we want to switch to something "simpler" while it doesn't offer us the option of gemsets? Also I can't quite see why 'chruby version 1.9.3-p192' is any simpler than 'rvm use 1.9.3' While I am also a fan of simple, this doesn't seem to have anything significant over RVM other than stripping out all the optional functionality.
&gt; I would hardly say RVM "pollutes" your env variables. Type `set` ;) However, chruby does add three functions (`chruby`, `chruby_use` and `chruby_reset`) and sets a few additional environment variables (`RUBY_ROOT`, `RUBY_ENGINE`, `RUBY_VERSION`). &gt; Unless there is some feature that is significantly better, why would we want to switch to something "simpler" while it doesn't offer us the option of gemsets? Use RVM if you want all the bells/whistles and a turn-key user experience. chruby does use slightly different methods of switching between rubies (queries `ruby` for `Gem.default_dir` and uses `trap DEBUG` (bash) / `preexec_functions` (zsh) for detecting `.ruby-version` files), which actually [inspired RVM to stop hooking `cd`](http://niczsoft.com/2012/12/story-of-prompt_command-and-rvm/). Also, due to chruby's minimal nature and adherence to [TDD](https://github.com/postmodern/chruby/tree/master/test), you will have less bugs and less surprises with chruby. &gt; Also I can't quite see why 'chruby version 1.9.3-p192' is any simpler than 'rvm use 1.9.3' Parent commenter made a typo. It's actually `chruby VERSION`, where VERSION can be `system`, `1.9` or `jruby` or `rubinius-2.0.0-rc1`. Personally, I use [chgems](https://github.com/postmodern/chgems#readme) for gemsets. Also most people now use bundler instead of gemsets. &gt; While I am also a fan of simple, this doesn't seem to have anything significant over RVM other than stripping out all the optional functionality. That is kind of the point. Instead of competing with RVM feature-for-feature, we challenged many of the assumptions/features in RVM/rbenv. The end result was a very minimal piece of software that followed the "UNIX Philosophy" of doing only one thing, and doing it well.
A former client of mine highly valued his registration process, so we built in a feature that would save the entered information as quickly into the process as possible. I would suggest breaking the form up into at least 2 parts (huge forms are daunting anyway) where the first step collects name and email. If you can save that, then your client can always contact the user through a back channel. One reason to use a component like Sidekiq is because it will handle retries for you, and log failures, so you have something to check later. If you used cron, you'd have to build all that logging yourself. If you REALLY need the reliability you described, splurge on the pro version of Sidekiq, since it comes with support for RPOPLPUSH: http://mperham.github.io/sidekiq/pro/ Good luck! 
The Pickaxe book is good and easier but it leaves you with lots of WTFs and unknowns. If you want a detailed description of the language and understarnd what's really going on, then "The Ruby Programming language" is the book.
This was my introduction to Ruby and quite possibly the reason I don't fully understand it. Something about mixin bacon?
I'd go with The Well Grounded Rubyist and then read one of those two.
Sidenote on this, it's quite possible that the weakest link in the system is not queueing, etc, but the fact that it's email. Email has a tendency to get caught up in spam filters, suffer strange delivery delays, etc. Here's an idea to consider since the delivery sounds so valuable. When you send the 2 emails, also send the 2 recipients (I'm assuming it's 2 people) sms summaries with sender contact info and a timestamp. For $1k I'd say it's worth a $0.01 Twilio sms charge and an extra alert tone on somebodies phone. If they get an sms but not the email, they'll know something is up. Kind of like getting SMS that a package has arrived but not seeing it on your doorstep. EDIT: Also, it sounds like the system will have pretty low usage. If you're worried about introducing redis but still want a queue, and have a database, just use Delayed::Job and a single worker.
&gt; I would suggest breaking the form up into at least 2 parts (huge forms are daunting anyway) where the first step collects name and email. If you can save that, then your client can always contact the user through a back channel. I also thought about that. Currently contact information is asked for at the end of the form. I'm gonna move that to the front. Also I looked into using [Sisyphus](http://sisyphus-js.herokuapp.com/) or [GarlicJS](http://garlicjs.org/) to save the form in localstorage.
Thinner than the 'Pickaxe' book and it has a well document Soduku solver in the first few chapters. Only downside I found was it's coverage of procs, blocks and lambdas 'light' considering it's possibly the most confusing aspect of ruby. With exception only to variable scope.
Agreed. I like the O'Reilly book for an introduction to the language and the Pickaxe and http://www.ruby-doc.org for reference.
oh cool, thanks!
Care to elaborate?
sql*
Rails 4 on Ruby 2 is actually quite fast. In development mode you can feel the difference refreshing pages in comparison to version 3.2...
I was debating whether or not to update my existing project. So you think it's worth it? How is the speed in production?
It is impossible to write shell with rvm. The way it uses shell to make it work breaks nearly every shell script especially if you are executing from say ruby or python. Rbenv has similar issues just a lot less of them. Chruby uses standard paths and env/sh commands so it works with scripting cleanly.
http://ruby.railstutorial.org/ruby-on-rails-tutorial-book
Anyone aware of a workaround for [this](https://github.com/rails/rails/issues/4971)? I've been playing with the Rails 4 betas and engines, and I can't write any unit tests for my engine because of this. Very annoying, as i'm intending the engine to be a base I include into multiple projects so I want really solid testing for it.
How about memory usage?
&gt;big Yes. &gt;slow Not really, no. &gt;monolithic Not since Rails 3, no. It's split into gems so if you don't want everything and the kitchen sink, you can just pick out the bits you want. The main Rails gem is basically just a meta-gem that depends on everything, and provides the main "rails" command (for running generators).
Thanks for answering, instead of downvoting the shit out of me for picking on your tool of choice.
If you build a slow app, it will run slow in production. But seriously there's lots of optimization you can do. No reason rails or ruby should be a bottleneck. The point is you gain lots of developer productivity and if part of your system is highly performance-critical, then you design accordingly. 
No. http://en.wikipedia.org/wiki/Betteridge's_law_of_headlines
I used to think that. In fact, I still use sinatra for some projects. But the main problem with sinatra, is that you end up having to reimplement a lot of the functionality you get in rails for free. 
This is good - as someone who loves Sinatra, is there a chance Rails might actually appeal to me now? I tried it years ago and was not impressed with how heavy-weight it was.
I knew there were going to be gotchyas with this specific feature, thanks for catching this early and helping out!
If you are using jQuery I suggest https://github.com/kossnocorp/jquery.turbolinks for some glue that makes things work more transparently.
 I am getting new error, ITs getting complicated better leave it i guess D:\xampp\htdocs\omega4test\sites\all\themes\subtheme&gt;bundle exec guard DL is deprecated, please use Fiddle For a better pry experience, please use ansicon: http://adoxa.3eeweb.com/ansicon/ Compilation took 0.191s 23:50:08 - INFO - You must 'gem install win32console' to use color on Windows 23:50:08 - ERROR - Could not load 'guard/livereload' or find class Guard::Livereload 23:50:08 - ERROR - cannot load such file -- 2.0/ruby_http_parser 23:50:08 - ERROR - Invalid Guardfile, original error is: &gt; [#] undefined method `new' for nil:NilClass 23:50:08 - INFO - Guard::Compass is watching at your stylesheets. 23:50:08 - INFO - Guard is now watching at 'D:/xampp/htdocs/omega4test/sites/all/themes/subtheme' D:/Ruby200/lib/ruby/gems/2.0.0/gems/listen-1.2.2/lib/listen/adapter.rb:207:in `require': cannot load such file -- wdm (LoadError) from D:/Ruby200/lib/ruby/gems/2.0.0/gems/listen-1.2.2/lib/listen/adapter.rb:207:in `load_dependent_adapter' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/listen-1.2.2/lib/listen/adapters/windows.rb:33:in `load_dependent_adapter' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/listen-1.2.2/lib/listen/adapter.rb:198:in `usable?' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/listen-1.2.2/lib/listen/adapters/windows.rb:25:in `usable?' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/listen-1.2.2/lib/listen/adapter.rb:190:in `usable_and_works?' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/listen-1.2.2/lib/listen/adapter.rb:57:in `block in select_and_initialize' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/listen-1.2.2/lib/listen/adapter.rb:55:in `each' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/listen-1.2.2/lib/listen/adapter.rb:55:in `select_and_initialize' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/listen-1.2.2/lib/listen/listener.rb:288:in `initialize_adapter' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/listen-1.2.2/lib/listen/listener.rb:280:in `setup' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/listen-1.2.2/lib/listen/listener.rb:52:in `start' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/guard-1.8.1/lib/guard.rb:194:in `block in start' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/guard-1.8.1/lib/guard.rb:368:in `block in within_preserved_state' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/guard-1.8.1/lib/guard.rb:365:in `synchronize' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/guard-1.8.1/lib/guard.rb:365:in `within_preserved_state' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/guard-1.8.1/lib/guard.rb:190:in `start' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/guard-1.8.1/lib/guard/cli.rb:110:in `start' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/thor-0.18.1/lib/thor/command.rb:27:in `run' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/thor-0.18.1/lib/thor/invocation.rb:120:in `invoke_command' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/thor-0.18.1/lib/thor.rb:363:in `dispatch' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/thor-0.18.1/lib/thor/base.rb:439:in `start' from D:/Ruby200/lib/ruby/gems/2.0.0/gems/guard-1.8.1/bin/guard:6:in `&lt;top (required)&gt;' from D:/Ruby200/bin/guard:23:in `load' from D:/Ruby200/bin/guard:23:in `&lt;main&gt;' 
Get ready for a *shitload* of Stackoverflow questions in this vein. Turbolinks is a really terrible default, IMO.
Oh my gosh, hi peter cooper! You are right that I did not hear it from you (I already have the PDF (though it might be helpful for some), though, in my defense, I did buy the normal book (though it was before I had the PDF I think (but its nice to write in)) (I was doing the prep work to apply to app academy) and I like it! (I only said pretty alright because I have not read any other ruby books and I have only read 6 chapters of yours (that is what i was assigned (I plan to read more))). I think there is a typo on page 15 with Hello, world!Hellwo, world!Hello, world!Hello, world!Hello, world!Hello, world! Hello, world!Hello, world!Hello, world!Hello, world!=&gt; 10
Since jQuery and Turbolinks are defaults in new Rails (4) apps, you'd think they'd have included something like this in the defaults as well.
From where I'm standing it seems to introduce about as much bullshit as something like backbone but the upside seems nebulous. Have you looked into it? What's your experience so far.
I've been using a modified version of it since December (which landed somewhere between pjax and turbolinks), but I had to hack it up *a lot* to get it to do what I wanted. It's very useful if you can navigate the landmine of gotchas it puts in your way - avoiding a browser redownload/parse of CSS/Javascript can dramatically improve render times. The downside is that everything you know about DOM node binding and DOM ready is out the window, ads have a *tremendous* capacity to trip it up, and unless you're really careful with your Javascript you can easily paint yourself into a corner with some really freakin' esoteric bugs. If you're not careful with your resources, you can also build pages that balloon up to massive sizes in terms of memory usage, since you're not throwing away your allocations on every navigation. It's useful, but it's also a minefield that is going to cause more frustration than anything else they could have included.
It's a great read, and it's really fun, but in hindsight I don't think it's that great for learning. There are better resources if you really want to get running.
Why would they make something so broken the default?
Because DHH likes it and he's a colossal weenie.
I would be interested to know if you think www.codelearn.org is useful for you at your stage. Disclaimer: I am the founder of Codelearn.
i'm going to sound snooty with this but .. duh? the solution was quite obviously to use event delegation :).
Yep, that's the reason for everything in Rails. We're lucky that so much of it is good considering that the justification for what gets added is what DHH happens to like.
asset pipeline was a solution to a problem nobody had.
What makes you say that? I like that they made it super easy to use CoffeeScript, SCSS, other front-end libs, and have it all compile into a single JS and CSS file.
What was wrong with multiple files? The browser caches them anyway. Now you have the added complexity of the pipeline and have to install node.js on the server in order to deploy your rails app. 
 class String def format(*args) super(self, *(args.flatten)) end end ########## inline tests if __FILE__==$PROGRAM_NAME require 'test/unit' class StringFormatTest &lt; Test::Unit::TestCase def test_string_format assert_equal '2.00', '%.2f'.format(2.00001) assert_equal '1.00 3.00', '%.2f %.2f'.format([1.004, 3.0023]) assert_equal '1.00 3.00', '%.2f %.2f'.format(1.004, 3.0023) end end end And just like that, you get String#format. Enjoy
That looks like a great option, but if you've worked with owners of these Rails 2.3 apps, you'll know that the developers might not be in the picture. Suggesting any solution that the product owner can do themselves isn't feasible. At some point, a skilled developer (like yourself) is going to need to assist with the upgrade. Brakeman is a great solution and I am sure there are others, but none of those are useful to the guy who isn't even sure if he's affected.
Why flatten? That's just introducing unexpected behavior. And I'm assuming by 'super' you meant 'sprintf'. EDIT: I assume you flattened in order to accept an array of args instead of a variable number. If you really want to preserve that behavior (which the topic author dislikes) then you might as well just alias %: class String alias_method :format, :% end EDIT 2: Nevermind, apparently % doesn't accept a variable number of arguments.
I'd consider it the only comprehensive and accurate reference book on Ruby. You could, instead, read the official docs, but having such a great resource (esp. in pdf/epub) format lying around is indispensible.
My method takes any combination. An array of args, a bunch of args, etc. I like API's where I don't have to remember whether it takes an array of things or the things themselves...
Pretty sure you meant to write `sprintf` here.
The implementation kind of sucks, imho. In a just world, you wouldn't need manifest files - you'd just declare the files using the stylesheet include helper and everything would just Work. Instead we have this second-class compilation system that adds all this non obvious configuration.
Edited to add an inline test which verifies that I in fact knew what I was doing. See [Kernel#format](http://www.ruby-doc.org/core-2.0/Kernel.html#method-i-format) which a call to "super" will eventually reach. But yeah, sprintf might have also worked fine. As much as I am a pragmatist who loves that "sprintf" has meant the same thing since practically the dawn of the computer age, I like the english readability of "format". :)
Yep, you're absolutely correct. I should have thought a bit more about the meaning of the `super` call.
In theory - you have a point. In practice almost noone messes with the methods in `Kernel`.
You don't need node.js, I am using therubyracer as the JS interpreter. You can choose any other JS implementation supported by ExecJS.
As I understand it, here is a summary of the article: 1. Don't trust people 2. Read all the code in the libraries you want to use The article feels like someone just became aware of the rubygems.org exploit from a month ago (and addresses it with only a sentence or two), got REALLY SCARED of arbitrary code running on their machine, and reacted with the usual OMG_KILL_IT_WITH_FIRE * . **For those of you who are new to writing software, downloading libraries means using other people's code.** Hey, it turns out when you do "gem install", you're actually allowing people to run code on your machine. So yeah, it turns out you probably want to be careful what you do. As a direct reply to the actual article, it begins with a buzzword: "Social engineering", and then proceeds to bash on people for being trusting. Author of the blog post: Social engineering is not "a cool experiment", and you're barking up the wrong tree. Changes to libraries? That, sir, is why you LOCK THE GEM VERSIONS YOU ARE USING. But, if you really intend on falling prey to FUD and NIH, be my guest. Just don't scare the newbs away without giving them the full facts. ______ * For those who are curious: \&gt; KILL_IT_WITH_FIRE \#=&gt; "Camel spider, bro."
My point isn't only about Kernel methods but all of them (including operator methods). In Ruby's (and Smalltalk's) message passing OOP receiver.message argument(s) alone decides what computation is performed, be it "%03u".% 7 or 23.% 5 If you want statically typed functions/methods and operators you have to choose another programming language like SML that actually supports this style of programming rather than trying to force Ruby to conform to this foreign paradigm. In Ruby you would rather name the variables a and b with explanatory names, so people can see what they're dealing with and what's going on.
Pah, damn development on windows. Anyone know if this is specific to rails 4, the windows installer, or windows in general? PS C:\sites\blog&gt; rails s C:/RailsInstaller/Ruby2.0.0/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7-x86-mingw32/lib/sqlite3.rb:6:in `require': cannot loa d such file -- sqlite3/sqlite3_native (LoadError) from C:/RailsInstaller/Ruby2.0.0/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7-x86-mingw32/lib/sqlite3.rb:6:in `rescue in &lt;top (required)&gt;' from C:/RailsInstaller/Ruby2.0.0/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7-x86-mingw32/lib/sqlite3.rb:2:in `&lt;top (required)&gt;' ........ from bin/rails:4:in `require' from bin/rails:4:in `&lt;main&gt;' PS C:\sites\blog&gt; What is saddening is that before I reformatted and had windows 7, I was able to install rails 3 without any difficulty. Edit: I found out the the issue was and the fix is listed here. This seems to apply to people only who are using the new (v3.0) ruby on rails installer on windows. https://groups.google.com/forum/#!topic/rubyinstaller/gedIaMryCFQ Edit 3: Ah screw this, I am installing a Ubuntu Server vm.
There are multiple threats here: 1. Attacker convinces you to install a malicious gem. 2. Attacker convinces a developer to merge malicious code. 3. Attacker gains access to the repository of a popular gem. 4. Attacker gains access to the developer's system and pushes malicious commits. 5. Attacker gains access to rubygems.org. Self-hosting the rubygems you depend on will not defend against 1-4. Auditing every line of code, in every dependency, and every commit is not a sustainable solution. An attacker could disguise their backdoor as a simple programming mistake that introduces a vulnerability. I feel that we need a combination of code auditing, reputation and cryptographic signatures (`git commit -S` PGP signs your commit).
It's always worth giving different frameworks a try just to broaden your horizons - even if you don't like a framework you're at least likely to learn something from poking around with it. But to be honest... If you like Sinatra and it already does everything you want, you might be better off sticking with it rather than learning something new.
Could someone help clarify something for me? The author states that signing gems isn't enough and that we should host our own gem repositories. Assuming we've already audited some third party code, and assuming the gem in question is signed, why should we host our own? Shouldn't fetching the gem and verifying it against the signature be enough? Assuming we live in a perfect world where there's a robust chain of trust and all gems are signed, why should we feel compelled to host our own gems in terms of the arguments put forth in the article? (By this I mean excluding the obvious data redundancy and removal of the reliance on a 3rd party service for successful deployment).
I believe the only proper conclusion for Author's article is "write your own code", and I could be snarky and say something about the operating system. But maybe I'm just annoyed at the fallacies.
Thanks for the perspective. Never the less, I'm going to keep waiting in hope that I've greatly misunderstood what the author meant and that someone can explain it to me.
At least with a Gem you can read the code. With an EXE, you have no chance to review before you compromise your system by running it
There's another threat: Attacker provides a good gem, and at some time in the future, intentionally updates it with malicious code - say DHH goes crazier than usual. With such a big Gem, a code review is hard to perform. 
I agree - the only reason to run your own gem server is to be able to deploy without access to external servers - like when RubyGems.org was down due to being attacked - e.g. Heroku does this for you. Running your own Gem server doesn't help to stop attacks through gem code, it only isolates you from attacks against external infrastructure
What exactly are the common incompatibilities with gems and rails 4?
C) I would recommend saving money by buying [Ruby Pocket Reference](http://www.amazon.com/Ruby-Pocket-Reference-OReilly/dp/0596514816/) and using any of the dozens of free beginner tutorials online.
I think he's neglecting the ability to lock the version of the gem. Without that ability, one might not notice when a gem is updated, permitting an author to change a benign program to a malicious one. Beyond that, though, I can't think of a reason (other than the ones you mentioned) why it would be preferable to host your own gems. 
Reading all the source code for every piece of software you install is not a real solution in any form. Reading != understanding Giving source a "cursory scan" is only going make you feel good. You could be looking at an exploit and not even know it, or think you see something that is just a clever trick for the library. You use Linux ? You read all the source ? Reminds me of [this](http://en.wikipedia.org/wiki/Sakoku) attitude.
Only reason I can think of is if rubygems went down or something.. 
My argument is not against methods - I'm 100% for instance methods over "commands". My argument is against the use of an operator method, sacrificing readability and flexibility. I've opened a feature request for String#format(https://bugs.ruby-lang.org/issues/8573), suggesting @GSpotAssassin's code. Hopefully it will be approved.
The Kernel Array() method is inconsistent. Try passing a hash or a string with new lines inside and see what comes out. Hence, the reason for Rails's Array.wrap
 $ ruby -v ruby 1.9.3p429 (2013-05-15) [x86_64-linux] Brightbox $ ruby -e 'p Array("foo\r\nbar\n")' ["foo\r\nbar\n"] $ ruby -e 'p Array({one: 1, two: 2})' [[:one, 1], [:two, 2]]
Came here to say exactly this. The author says that you won't see experienced Rubyists do an array check, but both Array.wrap(a_hash) and [*a_hash] turn those hashes into two value arrays. That's definitely not always what you want.
Not knowing if something is an array is a smell, just like not knowing if something is nil. Avdi's [Confident Ruby](http://devblog.avdi.org/2013/05/19/confident-ruby-now-in-beta/) ebook is a great resource for understanding these smells and improving code that contains them.
Looks good! And there are tests! A few comments: 1. The naming convention for ruby files is to put them in directories based on their namespace (although for such a trivial class hierarchy I think putting it all in one file is fine) and to use an underscored version of the class or module name. If you want people to be able to `require 'fourchan-urler'` then the usual thing to do is to have a `fourchan-urler.rb` that just requires `fourchan_urler.rb`. This is a bit of indirection but it does prevent people like me from nagging you about conventions. ;) 2. You test the class of the object returned by new. This is just testing Ruby and can be safely removed. On the other hand, you don't test that an invalid host raises an `ArgumentError`. 3. You usually want to test one behavior per spec. I might write your tests [like this](https://gist.github.com/reinh/6a8fdf90d84312c79913), which also takes advantage of some RSpec 2 featues like `let`, `subject`, `its`, and the new recommended `expect` syntax for expectations. 4. I can see some edge cases that this code doesn't currently handle. What happens if the host is correct but the rest of the url doesn't match your regexes? 5. You might want to make a helper method on `FourchanUrler` that delegates to `Request.new` as a convenience. For instance: FourchanUrler.request 'http://boards.4chan.org/b/1234' 6. It's not important here because the computations are trivial but you should be aware that doing computations inside the #initialize block (obv) causes the computations to happen at initialize time. If it's taking too long to initialize the object or if you need to initialize a bunch of these objects but may not need to perform calculations on all of them (which can be common in a many map/reduce scenadios) then you could calculate them lazily by using memoization: def thread_id @thread_id ||= expensively_calculate_thread_id end 7. Another minor quibble: Your `Request` class isn't actually making a request so there might be a better name. I would probably just make `FourchanUrler` that class and skip the namespaced class altogether.
Rails is big hassle here: `params[:foo]` can be an instance of NilClass, String, Array, Hash, or a file upload.
You're a kinder human being than I am. I do sort of wish people could comment on that blog article to ask questions.. Who knows if the author will -ever- see this.
Thanks to report it. We've already fixed that, thanks!
Whilst this helps when refactoring code, ultimately a better solution is to make sure the variable is always an array in the first place.
Of course. I'm sorry I wasn't clear; I meant my comment to follow the same assumptions you made.
Error page when trying to upload a gemfile :/
Can you gist your Gemfile please? Probably my crappy code in action :-)
Actually, it's neither, it's an instance of ActiveModel::Errors (enumerable). It will never be nil. # File activemodel/lib/active_model/validations.rb, line 185 def errors @errors ||= Errors.new(self) end 
&gt; just like not knowing if something is nil What? If you always know when something will be `nil`, there would be no reason for `nil` to exist. I agree that you shouldn't be checking `nil`s unless your interface says `nil` is accepted, if that's what you meant...
Huh... didn't know about [*obj]. I feel like an idiot for doing [obj].flatten all the time. Even if [*obj] works oddly with hashes, that doesn't matter to me when I know the return from a function is guaranteed to be either an array, a string, or nil (I'm looking at you, ActiveLdap) and IMO it's more readable.
I don't want to use `at_exit`, but DHH won't give me a shutdown hook...
Yeah. 2 value arrays are the closest thing ruby has to a native tuple (and we don't really need tuples, arrays do it well enough, and they're easy as shit to write your own if you have some edge case that demands them)
What `[*obj]` attempts to do is explode and stick in an array. If its a string, it can't explode (well, it *could* explode to characters, but thats undesirable) much, so it just dumps it, in which [] array-izes it. Most collections extend enumerable so they get *
Awesome, thanks very much for the clarification!
Thanks for the compliment! I agree, comments would be nice, but they're also a dangerous thing to add to a commercial blog. ;)
I don't have a cat, so here's a terminal background. [Meow.](http://i.imgur.com/jNUcGTa.jpg)
Thanks for such a great feedback. I made several changes thanks to you.
If it's your own project, you should know what type `params[:foo]` is in each request. If you don't, the problem is with your development team. 
If you only want to use `#each`, I think it's better to just check if `obj.respond_to?(:each)`. 
Those are security vulnerability, it's not supposed to be possible to do that. So it has nothing to do with the discussion.
https://groups.google.com/forum/#!searchin/rubyonrails-security/%22active$20record%22/rubyonrails-security/c7jT-EeN9eI/L0u4e87zYGMJ They "fixed" this by post-processing JSON. If you send this JSON: {"stuff":[1,null]} Then `params[:stuff]` will be `[1]`. What happened to the nil? &gt; it's not supposed to be possible to do that. params was supposed to parse the request body when it's JSON. There's nothing wrong with that. There's also nothing wrong with `user = params[:token] &amp;&amp; User.find_by_token(params[:token])`. And ActiveRecord was supposed to support arrays in find\_by\_\*. All of these features *alone* works as expected. However, when you combine them, it causes a security vulnerability. And this is exactly what this discussion is about: When you have an object that you don't know what can contain (like `params`) you need to be *very* careful where you pass it. Rails-core fixed this vulnerability in Rails itself, but if this was a regular non-critical bug report, they would have responded with "wont fix, this is expected behavior; be careful what objects you pass into #where". But because this behavior (it's not really a bug) made many Rails vulnerable, they added a workaround to Rails. The root problem is still there: We keep passing `params[:foo]` everywhere, and Rails' request parsing is so complex that nobody knows all the rules by heart.
&gt; Why? Most of your files won't ever change (jquery etc) and the browser will cache them. Put them on s3 and you'll have no problems. It mostly affects the first time you go to a site, rather than caching. But even with caching, most browsers have a limit on how many requests they can make simultaneously. This does introduce a fair bit of latency, so why not just let your framework concatenate them all, once? &gt; Bullshit. You make is sound like the difference is measured in hours or something. It's not even one second difference in most cases. I can't speak with experience of bouncerates but I have read similar. Either way, I know sub-second delays have a noticeable effect on usability. And if you look at your stats, a non-insignificant number of visitors to your pages are likely coming from slow links or mobile devices, where a 200ms delay on the desktop over a fast link turns in a multi second delay over a slow link. 
Very nice! One question, what's with the boards_list array? As far as I can tell you just check for inclusion so you don't need those duplicate elements. Also, a nice syntax feature of ruby is also that you can condense a big array of words like that to %w(a b c d ... ) to improve the readability a bit.
Beside the case where attacker intentionally crafts the response, you should know what `params[:foo]` is within your own development team. In case of the attack, use `#to_s` if you want string. 
Or just upgrade.
&gt;This does introduce a fair bit of latency, so why not just let your framework concatenate them all, once? Because that has costs too. Costs in complexity, costs in deployment problems, costs in lack of flexibility, costs in developer time. And once again. Your biggest files are standard libraries used by millions of sites. If you link to google or jquery itself those a already cached by the browser before the user ever comes to you. Chances are your CSS and JS are pretty small in comparison and if you wanted to compress them you can do so yourself on an as needed basis. 
AngularJS has a number of modules which use a $ prefix, too many to list here. [This SO Question has some useful notes](http://stackoverflow.com/questions/12648543/angularjs-and-its-use-of-dollar-variables)
Generally speaking, JQuery and Angular are using $ as a way to signal the developer that they're working with a library function. There's no encouragement to go defining app specific vars with the $ prefix, quite the opposite. Some people do like to use $ prefix to denote a pre-fetched selector. e.g. `var $selector = $('#selector');` however it's not a standard.
Well the name gets mangled as `_classname__methodname` however it's not truly private.
Does anyone know what kind of problems might arise when updating a large Rails 2.x application which is still using 1.8.7 to 1.9.3 or even 2.0?
Well they just did so either you are wrong or you have different opinions on what "Retire" means (which you would need to elaborate on if you really want a discussion about it) 
Just because something doesn't follow "semver" doesn't mean it's versioning is meaningless. Software has been versioned decades before this "specification" was published.
&gt; You might still have an executable of ruby 1.8.7 somewhere in your system. it means that the Ruby that comes with your server distro is largely out of business. but anyway a lot of ruby projects don't work with 1.8.7 anymore so you are better off using rvm anyway. IMO this is much better than the python situation where the move takes just too much time
No. Anyone who's ever tried is dead.
That's why they outsource the project to 3rd party like me.
This is my last REE, based on 1.8.7-p374 released a couple days ago. https://github.com/karuna/rubyenterpriseedition187-374
He said he recommends you stop using his version, that there may be forks that'll get security patches you should keep using, just not his.
As a sysadmin, I would probably not allow rvm on production machine. I would probably go for an omnibus type installation (essentially everything need for that app bundled in one package, including ruby version, libs etc)
Very helpful, thank you.
I don't think Rails 2.x supports Ruby 1.9.3+ out of the box. Our upgrade of Rails 2.x to 3.x was nearly a disaster, and it is not something that I will ever go through again if I can avoid it. My best upgrades of Rails 2.x apps to Rails 3.x have been starting a new app, and carefully copy stuff over, rewrite some stuff, and see what breaks and what does not.
Which operating systems are you talking about? OSX just upgraded to 2.0.0-p247.
Why allow bundling but not rvm/rbenv?
Yes we did, but please don't use that argument against the succes of the gem ecosystem, where semver does have its part.
Because standard way of doing things with those tools are compiling a version on the target machine, which implies compilers and development headers must be present. It is one of many security precautions one should take. 
May as well consider Rails 4 at this point, too, so you nix another migration. Of course, make sure it meets your needs in its current state before you do :)
Thanks for your answer. Do I understand this correctly: You are avoiding having compilers and development headers present, so if an attacker have access to the system he is unable to build software on it? What prevents him from compiling the software locally, and copy it over to the machine, and running it afterwards?
I updated a Rails 2.3 from 1.8.7 to 1.9.3 about 6 moths ago. I had to add `# coding: utf-8` to some files, add a before_filter that converted `params` to UTF-8, and update some dependencies to the newest version.
Might as well remove the man pages, too. That way they won't know how to use your system after they're on it. 
rvm sucks really bad... use chruby
I would also suggest the Heroku guide for deploying Rails 4: https://devcenter.heroku.com/articles/rails4-getting-started
Because support, updates, and patches from the official maintainer of the language have ended. It's not dead, just retired.
I don't know why the developers did it differently in different files, but FWIW Jose Valim mentioned the underscored private methods in "Crafting Rails 4 Applications" which makes me think some of them use that convention.
You can't compile local exploits and deliver them to say, /tmp if there is no compilers. You're argument is flawed because there is a significant differences between building binaries and reading information.
I didn't, you used the argument that the gem ecosystem was successful because of semver. I just posited that semver isn't needed for rich a ecosystem of libraries.
While my comment was mostly facetious, I still stand by base point. There are two attack scenarios that you're trying to defend against: * Remote attacker gets code execution on your system (could be kernel-space, could be user-space) * Local attacker wants to privilege escalate up to root In the first scenario, you defend against it by using privilege separation on binaries, limiting the number of services exposed, selinux, etc. That way you hope that if they do get onto your system, it's running in userland and not in the kernel. In the second scenario, you're trying to keep someone from privilege escalating up to root. Yes, they could compile themselves tools - but they could also exploit setuid or setguid binaries, etc. Unless you're running such a strange architecture that the only place they can compile is *on your system*, it's easy enough to compile on their own platform and scp them across. After all, if they've got a shell they can scp or paste base-64 encoded binaries, etc. You don't lock down access to /usr/bin/base64, do you?
Yeah, upgrades of Rails usually require human sacrifices to the Ruby gods in order to have them go off without a hitch. But I personally recommend pulling the bandaid within a week of a major version release. You don't want to find yourself upgrading from 2.3.x to 4.0.x somewhere down the line.
He is still maintaining the _project_, just not the old version of the product.
That's what they do anyway, so yes. An OS-packaged interpreter is designed to be an OS-specific fork, in a way. It might not be different to the upstream *yet*, but they've given themselves the wiggle room to apply their own patches if they need to.
I also tried changing out the select for a select!, which I've heard is supposed to speed things up, since the brunt of Ruby's slowness is due to too much object instantiation, but that didn't change the time noticeably for me. But the `factors` method runs very quickly. Even calling it on 1 billion, it runs too fast for me to notice any slowness in irb.
Nevertheless, many common attack toolkits will try to copy code across and compile it locally. There may be a better way to do it, but if you're playing the numbers game then you can assume that a large proportion of people likely to attack your system aren't sophisticated enough to do so.
Just for the record, using C++ on a MBP takes about 3 seconds. Still curious why Ruby is that much slower. #include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; long factors(long number); int main(void) { int i = 0; while(factors(i) &lt; 101) { i += 1; } cout &lt;&lt;i&lt;&lt;endl; return 0; } long factors(long number) { const long limit = long(sqrt(double(number))); long factors_count = 0; for(long i=1; i&lt;=limit; i++) { if(number % i == 0) { factors_count++; } } return factors_count; } 
This is reaching - is there anyone that actually joins with `Array#*`?
You'd be surprised by the code some people write :-)
the biggest problem is going to be character encoding issues, with the 1.8 to 1.9 upgrade. Rails2 to Rails3 is going to be a lot more pain. I'm not sure if Rails2 works on ruby 1.8.
Largely depends on how many gems you use. We just did this and had to swap several gems and fix or rewrite parts of others. In addition to some general issues like date formatting and other stuff that changed in 1.9.3
Meh, operator overloading abuse. Don't do that, kids.
My 2 yen: Normally you have descriptive names that reflect what the variable contains. Arrays are normally plurals, a blue instance of `Dog` will be `blue_dog`, and some people will name hashes as `foobars_by_name` or some such that again reflects the contents. This is just common sense, and not Hungarian notation. When working with jQuery, about half of the variables are likely to be jQuery objects, which need to be recognised, and easily. However, they are almost indistinguishable, in natural language semantics, from non-jQuery objects like elements and nodelists, which also appear in great quantities. I could name my variables descriptively as `jQuery_wrapped_container` or `jQuery_collection_of_paragraphs` or `jQuery_this`; but those are too verbose for the frequency they see in code, and it is so easy to distinguish `container` from `$container`, `paragraphs` from `$paragraphs` and `this` from `$this` that the convention makes a truckload of sense.
I'd think this is in response to his recent post about the [temporary hiatus of RailsCast](http://railscasts.com/announcements/11), due to stress (possibly mental). Hopefully he'll be feeling better soon! 
Yep, or you could do both. http://www.ugtastic.com/railscasts/ How about I give you a hug too Mr. POOP_ON_YOUR_FACE cranky pants. &lt;noogie&gt;
Yep, money is a great way of showing support. But a little note and card never hurt either. :) http://www.ugtastic.com/railscasts/
Ryan is the man!
I actually think that the fact that we all gave him money by subscribing to pro is the problem. My guess is that because Railscast is a job now rather than a hobby, he's struggling to enjoy it as much as he used. When you get paid for something, you feel that you HAVE to perform.
It's too bad these benchmarks haven't gotten more attention. It's great work. I saw the story also posted on HackerNews but it didn't get the deserved attention. It's probably a hard week for articles being that it was Canada day yesterday and independence day in the states this week. Anyways - great work! I'm going to try out multi-process/threaded puma myself sometime this week. BTW your link to buncha_siege.rb seems to 404 for me. Now we just need an automated solution to run these benchmarks at a push of a button :) 
Shared...with wrestling mask...
I have to go with POOP_ON_YOUR_FACE on this one. *Sigh* Really, your handle has to be POOP_ON_YOUR_FACE? He's been creating for over 5 years or so, that has got to take a toll whether you're getting money or not. BTW, if I ever start making money off of UGtastic I'm pretty sure I will never, ever mind.
But the noogie?
I feel like maybe you and [this guy](http://www.poopinmymouth.com/)(SFW, I swear) should meet up.
thanks! Sorry, typo, I actually called my script `buncha_sieges.rb` https://github.com/jrochkind/fake_work_app/blob/master/buncha_sieges.rb I'll fix it. The app I used for simulating a workload, the buncha_sieges.rb script, and a bit of data, are all in that `fake_work_app` repo that the writeup is in too. 
How in their wrong mind wouldn't hire poopinmymouth freelance artist. Ya, you'll have to read that twice. 
Sure, i'll allow it for max timespan of three seconds.
I generally use the new syntax with new code, and if I'm editing a method that makes use of hash rockets, I'll refactor them. That said, just today I had to write a method that used a hash rocket because the key was a value from an object, and converting it into "value:" was not something that came to mind easily.
I am a big fan of the hash rocket. I guess the new syntax will eventually grow on me, but not any time soon. 
I've used 1.9 syntax for a while. It's just easier on my fingers.
If the key is a symbol, I'm using the colon. But there is still place for hash rockets.
I don't know what editor you use, but I've had hashrocket plus a space on either side hot-keyed pretty much as long as I've been programming Ruby.
Hashrockets 4 life! Seriously, I can't stand the new syntax when the key and value are both symbols. eff: :this
You can't get rid of hashrockets entirely, since hashes don't always have symbol keys. 
I'm dropping hashrockets whenever feasible.
yes, because i_cant stand: :this 
Until non-symbol keys can use the new syntax, I will use hash-rockets. Maintaining 2 different syntaxes for the same thing introduces cognitive friction. edit: And like others have said, "eff: :this".
In any hash where all possible keys are not known in advance, yes. Edit: To expand on this idea a little, it makes sense to me to use =&gt; where the key is data and : where the key is code/configuration/structure/schema. It's a fine line between the two especially in a language like ruby, so the idea is to use the alternate syntax to hint to the reader that a particular hash is intended to have a specific set of keys, and to use the original syntax in cases where the keys in the hash are expected to change as the data set changes.
Absolutely. The "new" syntax is far harder to read. A big part of coding professionally is making your code readable to others. The new way does save a few keystrokes. Big deal. If readability suffers (and it does) it isn't worth it. Grid forbid my Ruby should look like JSON. Yecch. 
And since consistency in your code is important, the logical conclusion is that you should use hashrockets throughout. :o) 
and that place is everywhere. I mean seriously. They just look cool.
rescue Exception =&gt; e &lt;- will that ever be possible without hash rockets? Seems retarded to have to keep both
I see what you did there buddy..
Better by a lot. 
I used to pair program with one of my coworkers, every time a hash-rocket was typed he would make a blast-off sound. Made me laugh every time.
Haha, good point, good point.
Side rant: I'm often getting annoyed at how much style people expect me to trade off in the name of reducing cognitive friction. For example, I'm sorry if other people don't know the operator precedence rules well enough to just read code that omits parenthesis for method calls. That sounds like a you problem, not a me problem.
Um, but what if it's not a symbol in that first case? 
That's why you'd use a hot key... To make it easier to type. 
This is the one comment in the thread I am going to upvote. I love ruby. I program in ruby as my profession. However, I think ruby sometimes makes shortcuts for some silly reasons. I don't want my programming language to always have the fewest keystrokes. I want it to tell me what it is doing. Sometimes that means telling me what it's doing in a very non human programatic way. Obviously this is an opinion but sometimes overlooked in the ruby community
I could just wire it into vim, but I have no reason to, when there's a perfectly fine syntax that's easier to type and means the same.
Honestly, it's just so much more readable. I love the hashrocket.
The *one and only* thing the hash rocket has going for it is that it makes it cumbersome for you to put several on a line. Seriously. do_something :foo =&gt; true, :bar =&gt; :alpha, :baz =&gt; {}, :quux =&gt; {} is a code stench. The naive solution: params = { :foo =&gt; true, :bar =&gt; :alpha, :baz =&gt; {}, :quux =&gt; {} } do_something params just shows that you *know* it's a code stench (marshalling likely non-obviously-related values into a Hash just for the sake of passing a single parameter). Listen to your code when it screams "Hey, buddy, do you know what SRP is?" in your ear.
The first one wouldn't really work, because `value` could be a variable/method.
Google "why's poignant guide to ruby". It should be mirrored somewhere, I'm certain.
Why don't you want to install Ubuntu? At least install it in a virtual machine. Windows sucks for ruby development. Actually Windows sucks period.
What is your experience level? Have you looked http://www.codecademy.com ?
I have previous (and I mean before the .com burst) experience with web design. Nothing more nothing less. So basically I know about as much as any idiot who has used myspace before.
I'm not really sure what you want to do. You can't learn programming unless you're doing it. And by that I mean you have to install Ruby and type something into irb to see if you got the syntax right and then copy that over to your actual program. [RailsInstaller](http://railsinstaller.org/) should bring everything you need to run Ruby programms and install Gems. Install a decent text editor with Ruby syntax highlighting like [Sublime Text](http://www.sublimetext.com/2). Pick a project you want to do, research what Gems you need and just start programming. When you have something working, start versioning it with git. Don't bother about branches yet, just use `git add` and `git commit`. If you recognize your code has logical errors, try to learn about testing in Ruby and practice test driven development / behaviour driven development. 
of course. hash-rockets make the code easy to read. BTW, what is the motivation to replace hash-rocket with colon notation? Was it to reduce the number of keystrokes or file size?
A key point is that the 1.9 hash syntax is *a* new syntax, it's not *the* new syntax. You can even see this if you type a hash into *irb* and hit enter. You'll get the standard style back. So don't think of the regular syntax as being old or a 1.8-ism, it's *the standard hash syntax* and the 1.9 *variant* is just something extra that's a nice to have in certain situations where it improves the look of code.
I'm a firm believer that the two syntaxes can live together in harmony. I use the 1.9 syntax for one-liners, for succinctness: @article.update_attributes(title: "New Title", status: :published) ... and I use hash rockets for multi-liners, so I can line them up for readability: @article.update_attributes({ :title =&gt; "New Title", :body =&gt; "New Body", :status =&gt; :published, :published_at =&gt; Time.now }) And, of course, hash rockets are necessary when creating a hash with non-symbol keys.
Windows Phone Apps can be build in C# or F#.
Solid advice here. Also no one says you should have everything from tryruby.com memorized in 15 minutes. There's a lot to learn and tryruby just points you in the general direction. But you have to do it on your own for it to stick. Think of it like learning how to ride a bike. I can lend you my bike for an afternoon and show you the basics of how to pedal. But to really learn it you'll have to buy your own bike and practice constantly. 
Webistrano used to be a thing. I don't think it's been maintained though. Found this with a quick search. https://github.com/peritor/webistrano
I found that a while back, but wondered if there was something more current. I guess webistrano can be adapted to do saas
Personally, I find that symmetry beautiful.
When you're doing symbol =&gt; symbol, sure hashrockets look better. But a lot of times you're putting in string or integer values on the right side and lining up: name: "two_for_fives", karma: 33, etc: "..." looks great.
Passing in a single hash with the params to (e. g.) a factory method avoids connascence of position. `bike = MotorbikeFactory.build(1100, :street, :red, :black, false)` vs `bike = MotorbikeFactory.build(type: :street, engine_displacement: 1100, body_color: :red, trim_color: :black, loud_pipes: false)` Yes, the second is longer, but I know what's going on without consulting the implementation of the method.
what bothers me is that the JSON syntax doesn't always work. You can't do this: { Object: "something", &lt;Proc&gt;.call: "Something", "wat": "what what" } basically, the new syntax only works if the keys are symbols. It's much much cleaner, so my company is using it, and only using rockets when we need to. For now, we are ignoring hashes that mix syntaxes. o.o
I find both pretty readable. the JSON syntax is cleaner, but the consistency of the Rocket is very nice :-)
My take is to use the new syntax when using a named arguments like approach and using hash rockets for creating regular hashes. So use the new style: do_something with: "10", and: "this" And use the hash rockets if the keys aren't really parameter names, but just data: params = { :foo =&gt; "bar" } do_something some_data: params I think it gives a nice separation of intent: is this just a bag of data, or are these named parameters? It might have been unfortunate that actual named parameters weren't introduced at the same time, then it would have been obvious: you use one or the other, but they're never the same. In either case: hashrockets aren't going anywhere.
I have to say that the new syntax just looks terrible when both key and value are symbols. something: :else Looks too close to this: Something::Else Versus the old syntax, which looks better *in this one case*. :key =&gt; :value In every other case I compulsively update old code to use the new style when I see it.
The "point" which you couldn't find is that the modern syntax is cleaner and requires fewer keystrokes and is in general easier to type. Since I've been using the modern style, I find the hashrocket style to be cumbersome, both in typing and in reading.
"it isn't worth it" Worth what? The people who've adopted the modern syntax obviously believe that it is more readable.
eff: :this I can't figure out what problem some people have with this. And they don't just have a problem - they HATE this! Certainly, such emotional responses are bound to affect one's use of the language.
I consider it pointless because it doesn't truly solve any problem, introduces ambiguity of key type and has limited ability compared to hashrocket thus cannot fully replace it. I'm glad you enjoy the modern syntax and I won't argue that it does use fewer keystrokes. But 'cleaner' is obviously subjective, as I think this is rather messy in fact: key: :value Thankfully we have the power to choose which syntax we prefer.
In TextMate, ctrl + L gives you the hash rocket buffered with spaces. I'm sure that other text editors allow you to create a shortcut for it as well.
&gt;What prevents him from compiling the software locally, and copy it over to the machine, and running it afterwards? More to the point, what prevents him from writing the malicious software in the copy of Ruby you have thoughtfully provided?
I don't use $ prefixes in Ruby or JavaScript.
On the other hand, I do use an editor macro to convert from old-style to new-style.
Iff. those are the correct keys.
You don't need capitalize on your print statements.
Have you checked out [_why's poignant guide to ruby](http://mislav.uniqpath.com/poignant-guide/)? It is very funny, and very accessible illustrated book targeted at beginners and it is available free online. You can skim through it and see if it works for you. Secondly, why do you think you need a unix environment to learn Ruby? As far as I can tell ruby works relatively well on windows (except for the occasional quirks but that's typically just a matter of googling an error message). I'm assuming that you see a lot of tutorials and guides out there written from a unix/mac perspective because it is just easier to present and follow that way. For example if you are running Ubuntu you can probably just copy and paste a single apt-get command into the terminal and be done. If you are running windows installing the same packages will typically involve going to seven different websites, downloading seven different installer files, then clicking through them in the right order. Beyond installation and configuration however stuff works more or less the same. I'm guessing that maybe you were trying to start off by installing and configuring a production style web environment on you development machine first. I'd recommend leaving that for later. At first try writing a few simple console apps that just print out stuff using puts. When you want to mess around with web development I find that a lot of people are completely overwhelmed with Rails at first. It might be a good idea to start with the leaner, simpler framework like Sinatra which lets you create super simple, single file web apps without any setup. I would say a typical learning curve would be: * Practice making simple console apps * Get comfortable with installing and using gems * Build a simple web app (no database back-end) in Sinatra * Read up on relational databases and SQL * Install mysql on windows, use SQL to create tables and run queries on them * Build a simple app using Sinatra and [DataMapper](http://datamapper.org/getting-started.html) connecting to your mysql instance * Once you are comfortable with all that, you can move to rails and MVC style frameworks. The key here is that if you are starting as an absolute beginner with no programming background you will need to learn a lot to be able to use the popular tools and frameworks. So don't try to jump in head first - take baby steps, and keep in mind that you have a long road ahead of you.
My understanding is pretty limited as well, just starting Ruby. But it looks like capitalize! doesn't return the string, just modifies the source. I would suggest using capitalize instead of capitalize!
puts "What's your first name?" first_name = gets.chomp puts "what's your last name?" last_name = gets.chomp puts "What city do you live in?" city = gets.chomp puts "What state do you live in?" state = gets.chomp puts first_name.capitalize puts last_name.capitalize puts city.capitalize puts state.capitalize
Ruby's methods that end with a "!" will often, by convention, return nil if they didn't change anything. So "Xeno".capitalize! will return nil. The intended usage of these methods is when you have a variable that you're performing a series of changes on. When you're doing a one-liner, you can generally remove the bang: "last_name = gets.chomp.capitalize" to get the expected result.
That is the way I did it
I use the hashrocket as we do have some apps running in 1.8.7. On my own projects i use 1.9 style. 
capitalize and capitalize! are two different methods. The ! on the end is just convention that the method will change whatever it is working with, not just return a modified copy. That is, the ! is just a different spelling, it isn't a symbol in this case that actually does anything.
Sorry, should have said "bang method."
You could try something like http://www.pubnub.com/ which will allow you to subscribe to a channel and listen for updates. From your server when new calls are added to the queue you "push" updates onto the channel. For a DIY solution check out Faye: https://github.com/faye/faye Another alternative (perhaps less reliable) would be to use JavaScript "long polling". http://stackoverflow.com/questions/14027005/simple-long-polling-example-with-javascript-and-jquery
There's [strano](https://github.com/joelmoss/strano) which is nicer and Etsy's [deploynator](https://github.com/etsy/deployinator) which I haven't really tried. Good luck!
Me either. It seems out of place in a dynamic language. I'm surprised how many people see it as normal. Mnay downvotes were dealt my way in /r/node on this topic.
without knowing what their 'answer' is, it's hard to tell what you are doing wrong, comparatively :/
Awesome, I took a brief look and this is some solid looking material to start on.
Also you are using capitalize and upcase when you take your input, so you don't need to capitalize when you do puts too.
Can you elaborate a bit further on this? (or provide a link that does) i.e.: 2.0.0p247 :001 &gt; print "hello, i am a human.".capitalize Hello, i am a human. =&gt; nil 2.0.0p247 :002 &gt; print "hello, i am a human.".capitalize! Hello, i am a human. =&gt; nil 2.0.0p247 :003 &gt; print "HELLO, I AM A HUMAN.".capitalize Hello, i am a human. =&gt; nil 2.0.0p247 :004 &gt; print "HELLO, I AM A HUMAN.".capitalize! Hello, i am a human. =&gt; nil &gt;...return nil if they didn't change anything... So in each of these lines, is nil returned because I did not save the string into a variable before using the capitalize method on it?
I don't think anyone's calling the new syntax a replacement. Myself, I think they are both alternatives. I've been using the new syntax exclusively for a long time, now, and I haven't seen the specific situations you mention. I use the syntax because I find it easier to type and easier to read, and those apply to practically every situation.
&gt; I don't think anyone's calling the new syntax a replacement. Myself, I think they are both alternatives. I've seen it quite a bit which is why I'm probably more defensive than most ;-) The definitive one (and possibly the root of other people holding the same opinion): https://peepcode.com/blog/2011/rip-ruby-hash-rocket-syntax .. it's a little tongue in cheek but I've spoken to developers who took it as gospel.
Your capitalize operations return the modified string, as evidenced by the fact that you see the output. However the expression evaluates to nil because that's what print returns.
capitalize! does return the string when it does something. But it returns nil if it does not do anything. It is doing something in each example above. Try this: :001 &gt; puts "hello".capitalize! Hello =&gt; nil :002 &gt; puts "Hello".capitalize! =&gt; nil Since it isn't doing anything to "Hello", it is returning nil.
i totally agree. i'm on the fence with the new syntax. i use it as long as the value isn't a symbol. *shrug*
`foo: 1` is just a short-hand for `:foo =&gt; `. Hash-rockets are still necessary for non-Symbol keys.
Awesome, answered before I could ask them haha. Thank you! Is it common to see many functions using the bang for performance? I am learning C++ along side Ruby, and this seems to me like it's akin to passing by reference.
Actually, it's the print function that returns nil. irb(main):014:0&gt; print 'whatever' whatever=&gt; nil But you are correct that sting#capitalize! will return nil if it doesn't modify the string. irb(main):015:0&gt; w = 'whatever' =&gt; "whatever" irb(main):016:0&gt; w.capitalize! =&gt; "Whatever" irb(main):017:0&gt; w.capitalize! =&gt; nil
Well ... it is definitely more *concise* to use the bang function instead of x=x.capitalize!, but it isn't *automatically* more performant. That said, there are more complex bang functions that almost certainly have a more optimized implementation than you might do on your own. Consider: *assume a is some huge array* &gt; a = a.sort vs &gt; a.sort! also &gt; a = a.sort! #careful! What's the value of a now? I don't *know* that a.sort! is faster than a = a.sort, but it *could* be. There's also the fact that when no modification occurs, the bang function returns nil (again, by convention, check your documentation if you're going to rely on this). That fact could be leveraged as a fact checker ... perhaps in a unit test where you are expecting to receive a sorted array. contrived rspec example: my_sorted_array.sort!.should eq(nil) Also, you mentioned *pass by reference* ... well [it's complicated](http://khelll.com/blog/ruby/ruby-pass-by-value-or-by-reference/).
All of the [Array](http://www.ruby-doc.org/core-2.0/Array.html) bangs return the array or `nil` if nothing was changed.
To elaborate on this, they all return the changed value or *nil* if nothing was changed. (I say **all** rather boldly, but I can't think of one that doesn't behave like that. Unlike &lt;another language with a recursive acronym for a name&gt;, ruby is pretty consistent with its library functions.
&gt; Since it isn't doing anything to "Hello", it is returning nil. And &gt;Actually, it's the print function that returns nil. Actually, both are true. Both "Hello".capitalize! and the print method are returning nil. It just turns out that print ALWAYS returns nil.
I would HIGHLY recommend Ruby Koans. http://rubykoans.com/ It's platform independent, teaches the basics of ruby starting with very small steps and getting larger. You won't necessarily learn how to apply it to create a program, but you will learn to read and write the language very well. I already had a lot of experience with ruby and still found some lovely tidbits of information.
Having build something similiar using Twilio/Rails/Heroku, my recommendation is use the Pusher addon on Heroku which gives you websockets. You get a lot of notifications before you need to upgrade to a paying plan. Every time your call queue gets updated (whether a new call comes in or someone drops off), just add a pusher notification as an after_request method which sends your current call queue count. In your page, listen to the pusher websocket notification and update the call count whenever you get a websocket call.
&gt; x.capitalize! is simply a shorter way of doing x = x.capitalize. No. Not quite right. Please don't believe markrebec. Look: irb(main):001:0&gt; x = "This is already capitalized" =&gt; "This is already capitalized" irb(main):002:0&gt; x.capitalize! =&gt; nil irb(main):003:0&gt; x =&gt; "This is already capitalized" irb(main):004:0&gt; x = x.capitalize =&gt; "This is already capitalized" irb(main):005:0&gt; x =&gt; "This is already capitalized" Do you see the difference? There's a nil in there. So if you're using the RETURN value from x.capitalize!, you could be in for a nasty surprise. The statement "x = x.capitalize" returns **x** if it was not modified. In contrast, "x.capitalize!" returns **nil** if it was not modified. Note that methods like this can be useful for checking idempotence.
I seem to recall that github uses something like this. A simple sinatra app around a whole bunch of cap recipes with hooks into Hubot. It probably wouldn't be too difficult to just roll your own if you don't need something as heavy as deployinator.
I'm guessing their answer is that you have to actually print strings... and not nil. =)
Technically correct ... which is the best kind of correct. :)
Since no one else will teach you about irb, I will. irb.
Just remembered something from my earlier experimentations with thin's --threaded mode. If I made two identical requests (same URL) they would be processed serially. If I varied one of the requests - even just appending "?q=a" - they would be processed concurrently. Given that ab sends the same request over and over, it might partially explain thin's terrible results in threaded mode.
Author here, Let me know what you think / what I should probably fix.
Way too many bangs for my liking... puts "#{city}".capitalize! Should simply be puts city.capitalize Too much signal to noise... 
I feel like the other answers are suggesting you launch a tactical nuclear strike against a mosquito. Chances are you don't care if the updates come in real-time. If every x seconds is good enough, then this can much more easily be done with a tiny bit of jQuery. Add something like a num_calls route, get '/num_calls' do content_type :json { "num_calls" =&gt; compute_number_of_calls_here }.to_json end And then in CoffeeScript you can have a function like, updateNumCalls = -&gt; $.getJSON('/num_calls').then (result) -&gt; $('#some_element_containing_the_number').html(result.num_calls) setTimeout updateNumCalls, 30000 I haven't run any of this, so excuse any errors, but this should push you in the right direction. **Edit:** if you're not using CoffeeScript, then here's some JavaScript instead: function updateNumCalls() { $.getJSON('/num_calls').then(function(result) { $('#some_element_containing_the_number').html(result.num_calls); setTimeout(updateNumCalls, 30000); }); };
At assembla.com there is a SSH tool, which is exactly what you are looking for :)
&gt;This is true but if he's a complete programming newb then he's not going to be using complicated libs that rely on c extensions for speed. Sure he is. Some random gem he picks is going to require something. What if he wants to use mysql or postgres? What if he wants to parse json? 
&gt; It's not a performance thing. Yes, it is. Bang methods tend to be more efficient than normal methods as they don't need to create additional objects. &gt; `x.capitalize!` is simply a shorter way of doing `x = x.capitalize`. Not quite. First of all consider this: x = "hello" y = x x = x.capitalize puts y versus: x = "hello" y = x x.capitalize! puts y Secondly, as I already said, `capitalize!` will be more efficient because it won't create a new string in memory, which `capitalize` will.
Yeah, their tool is called Heaven and is a Sinatra app with an HTTP API that wraps a bunch of Capistrano recipes, I checked with them about a month ago and they were not planning to open source it though (it's too custom to their infrastructure). From the ones I tried though strano was the one that really looked the part, I'd use that instead of writing a new one. (Although I did write a new one, but it's different and doesn't use Capistrano :P) 
Heroku resets your file system on every deploy and at least once every 24 hours so this won't persist https://github.com/kripy/yes-slash-no/blob/master/app.rb#L72 I recommend using environment variables to store the "switch" state instead. 
I think their definition of "fast" is a bit skewed.
 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Yes / No, [...]&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Yes / No, [...]&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; Serve from nginx.
http://i.imgur.com/dECJcrb.png
What makes them equal in style? attr's are slightly more obvious, less loc, and quite a bit more convenient.
And why do you need an image for that question?
Whilst I would personally go for a static html site, this way does make it easy to update from your phone in a bar with no wifi. Put this behind a caching proxy with sensible headers and it'll be fairly fast still.
As a sidenote using ENV variables makes your "switch" secure. Having a `/switch` endpoint is security via obscurity. Anyone can hit that endpoint, and all of the sudden your doesthemoonstillexist.com website is wrong.
Rack::Cascade + Common Base class + Sinatra kicks rails's ass every day of the week.
Show me!
I'm not saying there is only "one true way" as you put it. I'm saying that attr's (not "attr" itself, specifically) should be preferred over writing out readers and writers for every method. You can also save far more than 3 lines per method since you have reader, writer, accessor, and can have multiple attributes on one line. I personally think the attr_* methods should be used whenever you're using regular readers and writers but fleshed out more when you want to do something different from the norm with them. It's just being idiomatic and SHOULD be preferred to have a consistant style with other Ruby code. Again, I'm not saying it's the one true way, but it should be the preferred way.
I noted this in my documentation, recommending to use a UUID instead: https://github.com/kripy/yes-slash-no#installation
thanks for the reply! is just a [task runner](http://gruntjs.com/) based on node.js, it only triggers the HAML directives but it doesnt control anything. i'm a bit lost on how to connect between HAML and rails together, i guess i need to dig even deeper 
http://canrailsscale.com/
Cool, does it make use of live stream feature in Rails 4? What are you using?
Figured this out. Was pretty much as simple as ensuring sinatra was running with no ip (either run with -e production or use the -o 0.0.0.0 flag), and then most importantly, ensure the port the webrick server was running on was open on the windows server machine. Once the port was open, accessing it via ip:port works.
Using the haml gem is enough. Just switch templates to index.html.haml instead of index.html.erb, change the syntax to haml and that's it. Can use the haml-rails gem so they're created when using rails generators as well.
i've installed haml-rails and renamed it, still it came out undefined. ow well guess i need to learn the entire thing.
Are you running a rails app though? Sorry it's just hard to help you solve your problem without knowing what tools you are using to build this. 
ow no need for apologies please, i'm already happy if somebody would at least tries to help :) i'm not using any rails, i'm not sure if you used grunt before, but basically is just a task manager to execute ruby packages, etc. the environment mostly uses node and then you can install/execute any package on top of that, i used it to manage ugilfy, require.js, imageminify, htmlmin, etc. (more [details](http://dl.dropboxusercontent.com/u/39519/talks/fluent/index.html) if you're interested) my web is just a basic HTML without any backend (for now), the way i install HAML was just by installing the [grunt-contrib-haml](https://github.com/jhchen/grunt-contrib-haml) and [haml](http://haml.info/download.html) everything works well except the *render* directives 
Ah okay, i gotcha. Yes i am familiar with grunt, was using it for when working on this: https://github.com/agmcleod/melonjs-spine-runtime, mainly to compile the javascript sources into one and minify it. Though that project ive kinda abandoned to use the more generic javascript spine runtime, but that's another story. Alright so since you're using grunt to build static files, haml is only going to know methods you define, or libraries you include via a gem or multiple gems. haml-rails will definitely not help you here. If all you want to do for calling render is include a partial inside that code, such as a re-usable chunk of html, I would just write a render method like so: def app_path "/Users/aaron/Documents/mywebsite" end def render(path) Haml::Engine.new(IO.read(File.join(app_path, 'views', 'partials', "_#{path}.haml"))).render end If you need more options then that, might want to checkout the post here: http://stackoverflow.com/questions/6125265/using-layouts-in-haml-files-independently-of-rails
We've standardised on one attr_accessor or whatever per line, with a recommendation for alphabetical order. "But I want to group related attributes together!" "OK; prove your class does not violate SRP." Why? Ease of finding declarations quickly, and less magic for our analysis tools to ponder over. 
I've been using them from when they were in beta! I find their online IDE to be quite poor but I've been using the Mac App and I love it! Really, enjoy using them!
Okay, I'm keeping my eye on Rails Girl DC.
Where does one get the Mac App you speak of?
Yea I saw it in the support too but didn't really bother. Thanks!
Guess I should have promoted Rails Girls in general (http://railsgirls.com/) instead of just the DC girls, but it was the DC group that so impressed me. 
If you're talking about the future of Ruby I think you missed the most important talk of the weekend. Evan Light talking about how if we aren't careful Ruby will become like Java. 
You're a jerk btw, your long cringe-worthy speel on that page (i think it was supposed to sound feminist?) was just as dorky and idiotic as the misogyny we see in the programming community. Wasn't funny, wasn't witty, wasn't even interesting. Just made you look stupid. 
Thanks lovetrick69. Keep spreading the light. 
I would consider test[:c] || 'Default' to be more idiomatic than test.fetch(:c) { 'Default' } but either is fine of course. In my opinion we should all stop worrying and learn to love the nil.
This idea that we somehow need to be shocked in to understanding that women have minds capable of doing the same things men can is stupid. When I read code I don't see "girl code" or "boy code" - I just see code. The gender of the person that created it doesn't matter, nor should it. We shouldn't be trying to create this air where code or other materials which are developed by women needs to somehow become elevated because it was a woman that did it. People should be respected for their work based on merit, not gender.
I agree with you SkepticalMartian. In writing this post, I crossed the line you clearly and effectively describe. However, I genuinely believe what I found at RubyNation to be noteworthy. Not that one sex dominated the scene, but that real leadership was coming from a group that previously wasn't as present. One of the greatest things about Ruby is it's community. And it is that community's openness that is ultimately the reason so many people (of all colors and sexes) are able to effectively use the language. I left the conference jazzed about the future of the Ruby and what it could mean, and this was an attempt to share a part of that enthusiasm. 
Sure, I don't want to decry any situation where people get up and share knowledge of ruby and programming in general - regardless of who you are. Sharing is a *good thing* that helps us all grow and consider new ideas. You won't get any guff from me for being enthusiastic. I just felt it was important to point out that sex segregation is a toxic attitude that does nothing but foster a different set of rules for each sex to be judged by rather than just saying "this is code, we're programmers, judge me based on my work.".
Yup. That way you don't have to walk the object graph and can potentially load plugins at runtime from sources other than the plugins directory.
Can you please summarize the difference between the event pattern and the observer pattern?
Your usage of the signals gem within Rails looks similar to ActiveRecord::Observers with custom methods, fired by calling Model.notify_observers(:method, object). Care to elaborate what the pros and cons of each of those approaches in that context would be?
I am using system Ruby for things like cli-scripts and bootstrapping my OSX-system, which is perfectly fine.
With that mindset, how do you install packages on your Linux servers?
1. Local apt mirror and OS image servers. You could do it with just the apt mirror, but having OS images prebuilt is quicker. 2. Local apt repositories for our own code, ruby binaries, and chruby/gemsh packages. 3. Local gem server for things we haven't debianised. 4. Apache serving random static blobs out of /var/www for anything else (like tarballs of specific ruby releases we haven't got apt packages for yet). This is strictly a stop-gap and really only used for pre-staging deploys, but it's there if we absolutely need it. It's not a perfect setup, but it does make us relatively resistant to network tomfoolery.
Obviously this becomes an issue if the vals are true / false / nil.
Congrats on shipping your first gem! :) Well, since you asked for critics, I'll start a few: 1) As an open source project (but also for proprietary projects for that matter), please follow ruby's code conventions. For example, we use two spaces instead of tabs for indentation. 2) Similarly, potential users of your gem will see your code examples first. So you might want to fix up the format (indentation and whitespaces, etc) in the examples. 3) As a library, checking in Gemfile.lock is not recommended. 4) You have dependencies specified in both the Gemfile and the gemspec, it's recommended to include everything in the gemspec. (P.S. You are already calling `gemspec` from your Gemfile anyway.) Hope that helps. :)
Thanks for the tips! I am fixing that up now. &amp;nbsp; I was under the impression the dependencies defined in the Gemspec were for installing and using the gem, and the dependencies specified in the Gemfile were for developers wanting to develop the gem. I suppose that's wrong then. &amp;nbsp; PS: For ruby code containing lots of nested blocks (like RSpecs), I find the 2 spaces isn't enough to make each block visually distinct from it's parent. I have been unable to find a way to make 2 spaces display as 3 or 4 in anything other than Vim. Is it possible in Sublime or RubyMine?
Female SA here, providing op support to Ruby devs. (Including danfunk) The vast majority of the developers I work with are male. As a woman involved in development, I don't want people to stop talking about acheivements made by female coders. I agree with SkepticalMartian that when you read code there isn't boy code or girl code. However, the people on the project team do have a gender, which influences who they are, what they bring, and their experience over all. I'll still be looking for the articles and blogs that showcase the cool stuff women are doing. Even with all of the hard work that has gone into making coding and ops for everyone, I've still never worked with a coding team that was even 20% women. (Granted, this may partly be due to my rural location.) 
In this case, hopefully you can write the code in such a way that nil can be the default value, and then test[:c] will work fine, or if necessary, !!test[:c].
That works too, but sometimes it is better to have the explicit || 'Default' so that someone reading your code doesn't need to know how the hash was initialized. If you are using something like dependency injection, then Hash.new('Default') is actually harmful. Consider the most common case which is def foo(bar, options = {}) blah = options[:blah] || 'Default' #... end or def foo2(bar, passed_options = {}) options = {blah: 'Default1', moo: 'Default2'}.merge(passed_options) #... end 
Why not use shared contexts or shared examples? https://www.relishapp.com/rspec/rspec-core/docs/example-groups/shared-context
Sounds like a nice setup, but I do wonder. You don't trust external sources, do you review every package that you have on your local apt mirror? Local apt repos for own code sounds pretty sweat :)
We do trust the *content* of the external source (well, to the degree that package signing is a thing). We don't trust the pipe between us and them, or necessarily their uptime. Local apt repositories are actually very easy to set up. The simplest case is just serving static files over HTTP.
lol, I think to make a site answering the question of whether somebody is dead, static HTML will do just fine...
Cool project, I like the simple DSL, but I just hate to see people try to handle configuration management outside of puppet/chef or some other config management tool. This would make a great puppet module or chef library.
The problem with this is that test[:c] would be 'Default' if the key was there but the value was nil. test.fetch will only hit 'Default' if there is no key for :c in the hash. The other issue with the first way is that for simple string/int assignment it looks nice, but if you wanted a block of code to be executed on a nil return the || syntax is limiting.
This would be fine for strings but not if we want a method to be called or a block of code to be called in the case of a nil.
The shell is your code's parent process, so you can't change its environment, current directory, etc. In theory a parent process could have some sort of API to communicate with its children to do this kind of thing, but it certainly doesn't exist in the common shells you can expect people to be using. At best you can open a subshell (which would be a child process and hence you can set that stuff up before it starts) but then when the user exits it, they will return to the original shell unless they used exec to start your code in the first place.
Why? I Why not use gems? When you do that you have many features out of box: * every plugin is a gem so it easy to build new one (known structure, can be big) * plugins/gems depenedencies - when one plugin need another to work * you dont care how user require/include them * you don't have to load them from particular directory and a few others about whom I did not think
&gt; This would be fine for strings but not if we want a method to be called or a block of code to be called in the case of a nil. Well, that's true, though I thought we were specifically talking about the string 'Default' :-) If it's a block of code you want to execute when the hash doesn't contain the required key, you can do something like this: test = Hash.new { |hash, key| hash[key] = rand(10) } test[:c] # =&gt; 3, for example test[:a] # =&gt; 8 test[:t] # =&gt; 1 test.inspect # =&gt; "{:c=&gt;3, :a=&gt;8, :t=&gt;1}" You could always put some more interesting code in that block, of course
include AwesomeProject::Models in AwesomeProject::Workflow.
My initial reaction was "oh no, not another stupid gem", but this isn't actually that stupid.
Truth be told, neither did I until looked it up an hour ago :-)
The use case for this was plugins for a chatroom bot so extracting every little plugin out into its own gem would have been tedious.
If you want the user left at a command prompt in your new directory and then exec a new shell. That will exit your ruby app and leave them in a command shell. Something like: Dir.chdir '/xyz' exec 'bash'
I don't want them left a layer deep. This command can be used multiple times, and leave them multiple layers deep :(
Perhaps then it would be helpful to know what you're trying to do. 
The Practical Object Oriented Programming in Ruby book that I linked to was published in September of 2012. Having said that Russ' 2007 book is still quite relevant. So is th Go4 book from over a decade ago. Like you point out, patterns AREN'T language specific. It's a broader skill, this ability to identify repeating problems faced at various levels of abstraction, and knowing them makes you a better programmer, because you can better appreciate code that uses these patterns.
Some questions: * Is it all implemented via #method_missing? Or do you #define_method / use Forwardable (in the stdlib) for the 'Array Matching' and 'Delegation' resp. * Have you considered performance implications? * If so, how, and where are numbers I can look at? Speaking as someone who's done his fair share of metaprogramming hackery, I really enjoy seeing new entrants to the 'make metaprogramming easier' space. However, I also get nervous when I don't see a lot of data about how they do things / what performance implications their gems have. I think this is a really cool idea, and could see myself making use of it to clean up boilerplate around my apps. Good work!
That's fair, and correct. I thought it was pretty clear within the conversation that the bang method `capitalize!` returned `nil` if the string is not modified. It's also pretty rare that you'd ever actually use that return value, unless you were doing something like a one-liner where you wanted to use the capitalized value inline **and** use that opportunity to modify it in place for some logic that followed. However, I wouldn't recommend returning from a method like that with an unsure return value anyway, and if you were checking the value ahead of time it kind of defeats the purpose. I would also like to point out that my specific examples of `x.capitalize!` and `x = x.capitalize` do indeed give you the same end result - a variable `x` which contains your capitalized string. It is absolutely correct, though, that utilizing the return values of those methods changes things. If you were to do `x = x.capitalize!` you'd need to take the return behavior into account.
Use bash. When you run a ruby process your shell forks to run the sub process and it is not possible to modify the parent process.
I hacked this together real quick last night. I love the [Q.js](https://github.com/kriskowal/q) interface in JavaScript, and I'm working on a project where I wanted a similar interface in Ruby. The applications are obviously very limited, but I think it provides a nice way to work with simple asynchronous operations.
Agreed -- they give the same END result, but the lesson can bite you in the butt =). People sometimes like to try to do a lot of things at once, like modifying a variable and using it at the same time. str.capitalize!.match(/kitty/) ? "kitty detected" : "#{str} detected" That looks like someone trying to be cute, capitalizing the string for later use and checking it for kittycat all at once -- but if the string is already capitalized, you're going to get a nice surprise when there's no match method for NilClass =).
Great writeup. [Phusion Passenger](https://www.phusionpassenger.com/) also uses this trick. It's the only way to handle signals properly, and it's the only way if you want to wait on threading events *and* file descriptors (e.g. sockets). It should be noted that this trick is so common among Unix server software, that the Linux kernel provides a special file descriptor type optimized for this pattern, called [signalfd](http://man7.org/linux/man-pages/man2/signalfd.2.html). It allows any signal to be converted to a read event on a file descriptor. A signalfd uses less kernel resources than a pipe.
Right now it essentially uses defined_method. For the delegation I use class_eval instead since it's a trivial call to the dependent instance. I'll have to look into Forwardable. 
I really like forwardable, though I've never benchmarked it against define_method or other methods of delegation, I feel like it's probably faster (in terms of method dispatch time). It offers a similar (but not equivalent) API to yours in the form of `delegate [:methods, :go, :here] =&gt; :object` (with the shortened `delegate :method =&gt; :object` for single delegation). It would be reasonably straightforward to implement that whole feature, I imagine, by extending Forwardable via your module and then alias-chaining `delegate` (though I rather like the way the hash-rocket syntax reads, ymmv). Ultimately, it's a really neat little gem, good work on it. I'll probably be playing around with it on my future, metaprogrammy projects.
Very cool! I didn't know about signalfd.
I have a self-pipe trick that is not at all relevant to this discussion.
It's not ruby (maybe it could be) but I'm pretty sure you can haxor Ableton live with scripts. Haven't played around with it yet.
https://github.com/arirusso/unimidi
I do this exact thing in two of my Thor commands. Use FileUtils.cd and FileUtils.pwd
A little bit, not enough to really say anything about it. I've used other things that are similar to Celluloid's futures, but this to me seems like a much better way to handle multiple asynchronous operations whose results I need to act on together.
You're not supporting the [fundamental feature](http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/) of promises that makes them so powerful to use. Your `then` function always just returns the original promise right? But it should return a new promise so you can properly chain a succession of async operations. See the [chaining](https://github.com/kriskowal/q) section on js's Q.js readme.
Yeah, you got me there. I wasn't aiming to follow the spec perfectly or have complete Q.js parity (obviously), but the implementation I came up with fit the use case that I built it for. I suppose I should change how this is described and say that it's more of a callback aggregator, which is actually what I needed.
Pure Data
Silly question, but is your onboard soundcard activated for the project? Do you have more than one soundcard?
I want to change the shell path, not the app path
Blew my mind.
Wow, I'm really surprised how some people manage to find ways to overengineer their code. I mean, really? Tell me, do you really think something like this actually helps? Anyway, let me fix that code of yours: def print_double @nodes.each do |node| puts node.value * 2 end end There you go.
cool, thanks for sharing! I'll give it a shot later.
 Date.today.beginning_of_week
I'm not sure if you get it? Or maybe I don't. If you're suggesting you add that to class Ast, then you're violating SRP. That's fine (sometimes i do this myself), but you are tightly coupling the two modules and making testing harder. The problem with contrived examples like the one in the post is that they don't make much real world sense. As your application grows, however, they make understanding a codebase and testing it easier, which leads to code of a higher quality.
From the [ruby docs for String#split](http://ruby-doc.org/core-2.0/String.html#method-i-split): &gt; If pattern is a String, then its contents are used as the delimiter when splitting str. If pattern is a single space, str is split on whitespace, with leading whitespace and runs of contiguous whitespace characters ignored. Hooray principle of least surprise! `str.split(/ /)` should give you the behaviour you want.
that is ugly! But at least I learnt something today :)
Cheers, I found the answer, though I'm still unsure why this happens... I did not expect ruby to consider newline a space. 
Solution was to use: str.split(/ /) Still not sure why Ruby considers \n to be a space. 
&gt; Because that has costs too. Costs in complexity, costs in deployment problems, costs in lack of flexibility, costs in developer time. yeah I think standardising an asset pipeline reduces these costs. If you need something even more flexible, then you are adding to the other costs anyway. &gt; Chances are your CSS and JS are pretty small in comparison and if you wanted to compress them you can do so yourself on an as needed basis. Interesting perspective, but I am finding that my sites use javascript more and more. And my biggest files are images. 
It's persumably because that's what [C considers to be a whitespace](http://en.cppreference.com/w/c/string/byte/isspace).
I remember I wrote something like this for funsies a long time ago. The biggest hurdle was discussing on #haskell the difference between currying and partial-application. I still don't know what the difference is.
Neat.
Fair enough, I can see the intention. It is quite a specific use case where we needed split to return Array(2) instead of (3) 
It's a bit of "fix one case, break another" though, I agree. It's always possible to see a feature in a very different light depending on what problem you've got in your head. I find that something like 20% of learning programming is just about figuring out wtf the creators of the language had in mind when they made these kind of decisions. Many times realizing the intent behind the api can guide you towards design patterns that will be much easier to implement in this or that particular language.
Put them up in Amazon S3.
FYI currying is not equivalent to partial application. Currying: irb(main):001:0&gt; add = lambda {|a| irb(main):002:1* lambda {|b| a + b} irb(main):003:1&gt; } =&gt; #&lt;Proc:0x00000001f14b08@(irb):1 (lambda)&gt; irb(main):004:0&gt; three_more = add.call(3) =&gt; #&lt;Proc:0x00000001f00568@(irb):2 (lambda)&gt; irb(main):005:0&gt; three_more.call(10) =&gt; 13 Partial application: irb(main):001:0&gt; add = lambda {|a, b| a + b} =&gt; #&lt;Proc:0x00000001b1d950@(irb):1 (lambda)&gt; irb(main):002:0&gt; more_three = lambda {|a| add.call(3, a) } =&gt; #&lt;Proc:0x00000001afe730@(irb):2 (lambda)&gt; irb(main):003:0&gt; more_three.call(10) =&gt; 13
wow no one knows
&gt; but you are tightly coupling the two modules and making testing harder And **why** wouldn't you want to do it? Sure, if you're building some sort of a generic AST (you're most likely not), fine, but if that's an AST for a specific language used in a specific context - you aren't going to use those two modules separately, you are going to use it as a whole, and making your production code more complex to make testing a little easier - that's no go for me. Don't take me wrong, design pattern have their place, but usually they are **vastly** overused. (I still have nightmares after dealing with some Java libraries.) As experience has taught me, [KISS](https://en.wikipedia.org/wiki/KISS_principle) and [YAGNI](https://en.wikipedia.org/wiki/You_aren't_gonna_need_it) all the way.
That's true, but this library (and Haskell itself) merges the two concepts. In Haskell it's especially interesting, see: foo :: Int -&gt; Int -&gt; Int foo x y = x + y We can see this as a function taking two parameters, where we can "partially apply" one with: let add5 = foo 5 And get back a function with the 5 partially applied and accepting another `Int`. However another way (and arguably the correct way) to look at this is to see that the `foo` function was [curried by default](http://www.haskell.org/haskellwiki/Currying), the type signature implies this perspective too, which is clear when we rewrite it as: `foo :: Int -&gt; (Int -&gt; Int)` meaning 'foo is a function that take an Int and returns another function that takes an Int and returns an Int' The function application: `foo 5 10` is exactly equivalent to `(foo 5) 10`, in fact it could be argued that Haskell doesn't actually support partial application, it just has a very convenient syntax for passing arguments into a succession of curried functions that happens to look a lot like passing multiple args. Similarly, Ruby's `Proc#curry` method merges the two concepts. `Proc#curry` does in fact return a fully curried Proc...but it also has the slightly weird feature that you can pass more than one argument (if you desire) and this will result in a new `Proc` being returned with the appropriately reduced arity. Note that the _actual_ `Proc` arity is `-1` but Ruby internally keeps track of the number of args passed and raises an `ArgumentError` if too many are given. See the following: def add3(x, y, z) x + y + z end auto_curry :add3 Real currying: add3.(1).(2).(3) #=&gt; 6 Partial application (which we get for free): add3.(1, 2).(3) #=&gt; 6 add3(1, 2).(3) #=&gt; 6 (this syntax also works) ArgumentError (too many args passed): add3(1, 2).(3, 5) #=&gt; ArgumentError 
arcane? refine? Which is it? No usage docs? Why not post this here once it's ready for consumption by others, and not before?
Reason for fix: I accidentally linked to the wrong fork.
**Original Submission (100%):** [Rails strong parameters made object oriented](http://www.reddit.com/r/rails/comments/1i30sj) [[D]](https://github.com/cloudsdaleapp/arcane) **Posted:** 1h before this post by *[zeeraw91](http://www.reddit.com/user/zeeraw91)* (fixed by *[zeeraw91](http://www.reddit.com/user/zeeraw91)*) *Link not posted to same subreddit: [rails](http://www.reddit.com/r/rails) -&gt; [ruby](http://www.reddit.com/r/ruby)* [This comment generated by an automated bot.](http://www.reddit.com/r/originalfinder/wiki/index) [*Is this match wrong?*](http://www.reddit.com/message/compose/?to=original-finder&amp;subject=Error%3A+1i367a&amp;message=%2A%2AIncorrect+match%3A%2A%2A+http%3A%2F%2Fwww.reddit.com%2Fr%2Fruby%2Fcomments%2F1i367a%0A%0A%2A%2ACorrect+match%3A%2A%2A)
What makes this approach "object oriented"?
`include Models` should work since you are already in the `AwesomeProject` scope.
wut
This approach makes it easier for you to follow an object oriented pattern as you treat the relation between a model and request params as it's own entity whom can send/receive messages, an arbiter or in this case a refinery in opposition of bloating your controller with logic that doesn't always belong there. I always thought, and I still do, slim controllers is the way to go. EDIT: Arguably, the helper itself might not show off the object-oriented-ness, but that wasn't the goal from the start. My goal with this library was to get structure to permitted parameters, where and how they are defined.
I'm not a big fan of the way this reads aloud: @article = Article.new refine(Article, :create) The new/create and Article/Article redundancy feel awkward.
Have you all looked at the signed_form gem?
Reasons to use this over RVM? Judging by this web-page RVM is much easier/superior. http://jonathan-jackson.net/rvm-and-rbenv
Because this doesn't work? @article.update_attributes({ title: "New Title", body: "New Body", status: :published, published_at: Time.now })
*Much* simpler: https://github.com/postmodern/chruby
I've never been a fan of method calls that let you pass parameters in different orders. I'm highly suspicious of the need for that.
Why would you use gemsets over bundler these days? Plus this guy isnt even using rbenv correctly.. kind of a troll review? bundle install to your local project and each project has its own isolated 'gemset'
Because RVM does an excellent job of managing multiple distros of ruby, without plugins. It also wraps binaries without `rehash`ing. And I don't feel like switching? I use bundler.
Fair enough :) I'll take a look into what you said. 
Wow! That is great congratulations! I have been doing Java way, way to long and would really like to try Ruby/Rails. May I ask how long did it take you to get from zero to job offer? edit: words
Thanks! It's been a hell of a journey, and really the journey has only begun. It took me about 8 months of pretty much spending all my free time (between managing a full time job, kids, dogs and family) learning and practicing to go from n00b to job offer. I read a ton of books, took online classes and attended the 3-day Pragmatic Studios course. Supplementing that was working on web apps of increasing complexity.
Damn, looks like I don't have any excuses then. I have a full-time job, kids and a wife too. Thanks for making me look like a slacker! ;) I have been thinking of doing the online Ruby/Rails course too - how did you like it? 
The Hartl tutorial was really helpful to get a 30,000-foot view of Rails, behavior-driven-development, Git, etc. I *really* found great value in the Pragmatic Studio stuff--their online Rails course is basically the in-person course I did minus some of the more advanced stuff like user authentication.
Great man!!
Are you looking for something to teach you specifically ruby syntax or something a little less syntax heavy? I'd HIGHLY recommend [Design Patterns in Ruby](http://www.amazon.com/Design-Patterns-Ruby-Russ-Olsen/dp/0321490452/ref=sr_1_1?ie=UTF8&amp;qid=1373697101&amp;sr=8-1&amp;keywords=design+patterns+in+ruby) by Russ Olsen. It's answered so many common problems I have run into and have to work around. To me it seems like pretty advanced thinking/techniques but I'm not sure your level. Either way, it should provide some great insight! He dedicates a chapter to reviewing Ruby so maybe that would at least help some.
Congrats! And don't panic when you finally see their codebase and it's devoid of rails conventions, you have to try and forget about migrations and anything ActiveRecord related because they are using mongodb, and the ruby is riddled with confusing and overly verbose logical patterns because it was written by the founders who are actually python programmers. - :)
what books , websites etc. you read to learn coding and how long did it take ..
Wow, that is a particularly stupid blog. I like the part where the author says you need to do this to install ruby with rbenv: $ curl http://ftp.ruby-lang.org/path/to/ruby $ ./configure --prefix=$HOME/.rbenv/versions/1.9.2-p290 $ make $ make install Which is bullshit - you only need to do this: $ rbenv install ruby-1.9.2-p290 Bizarrely, he admits this underneath the graphic - WTF? Anyway, here's the opposing argument, since you asked: https://github.com/sstephenson/rbenv/wiki/Why-rbenv%3F
I understand RVM manages your rubies nicely, and most of these comparisons as to which manager is 'better' are pissing contests, use what you like. I'm just curious as to the use of gemsets. I've only started using ruby for about a year and a half now, I _think_ I understand the past history of gemsets prior to bundler, but am fuzzy on their use now. If you use bundler to install gems locally per project what does the gemset get you? `$ bundle install --path vendor/bundle` This is what I read: http://ryan.mcgeary.org/2011/02/09/vendor-everything-still-applies/ Is that bad practice or just "different"?
and they follow the "fat model, fat controller" pattern
I'm trying to do the same thing, so while I'm envious I'm also aware of just how fucking great that must feel. Congratulations!
You've heard of test driven programming, now enjoy the fun of implementing it on a poorly-documented system under time constraints!
It took me about 8 months of pretty much spending all my free time (between managing a full time job, kids, dogs and family) learning and practicing to go from n00b to job offer. I read a ton of books, took online classes and attended the 3-day Pragmatic Studios course. Supplementing that was working on web apps of increasing complexity. The Hartl tutorial was really helpful to get a 30,000-foot view of Rails, behavior-driven-development, Git, etc. I really found great value in the Pragmatic Studio stuff--their online Rails course is basically the in-person course I did minus some of the more advanced stuff like user authentication. [Agile Development with Rails](http://pragprog.com/book/rails2/agile-web-development-with-rails) was great at helping me understand high-level development practices. I also read through Hartl's Rails Tutorial book, though it's online for free. I really, really can't speak highly enough of the Pragmatic Studios courses though--their online Ruby course is really well done, their in-person Rails Studio was amazing (albeit expensive if you're paying for it yourself like I did).
This hit home for me.
Mind if I ask what geographical location you landed the job and what the starting salary was?
Congratulations. I worked in marketing for the first half of my internet career, and pretty much hated it. Just like you, I spent my nights and weekends teaching myself web technologies (focus on ruby/rails), and eventually transitioned into being a developer. I've been doing it for four years now, and it was a great move - I love it. Keep us posted!
Congrats! Nice to hear peoples success stories. Personally I've been learning rails and I keep going through spells where I will love it, and then I'll hate it; not sure I would make the switch to a full time rails dev...CoffeeScript though I have been loving!
Gemset isolate in a way bundler can't (outside bundler's runtime). That article is incorrect, you should not commit you're `.rvmrc` or `.rb-env`. Different devs, use different tools. The Gemfile should specify enough (which ruby, and gems). Use a unique gemset per project. Use the default gemset sparsely. Provide setup instructions in the README.md any dev can use to get started. If you use a gemset you don't need to use `--path`, as the gems are install under the gemset `gem env`. A reason, why I still haven't changed is because I'm lazy. RVM allows me to isolate gems. So much that I never need to type `bundle exec` to get the right binaries. Imagine a project with `rake` 0.8 and another project with rake 0.9. With rbenv, I would need to run `bundle exec rake db:migrate`. That's really long, and sure, I could alias it, but I prefer to work without aliases as much as possible. With gemsets, one project could have 0.8 and not 0.9 and the other with the inverse. With an approach like these I never have to type `bundle exec`. I like that. Just my two cents, but these things always boil down to pissing matches.
it's an alternate syntax for Lambda, another way of writing part of the code it is this @cal={ :add =&gt; lambda do |a,b| return a + b end, subtract: lambda { |a,b| return a - b }, divide: -&gt; (a,b) { a / b }, # having a space after '-&gt;' only works in MRI 2.0.0+ multiply: -&gt;(a,b) { a * b }, power: -&gt;(a,b) { a ** b } } here is an article about blocks, procs, lambdas http://net.tutsplus.com/tutorials/ruby/ruby-on-rails-study-guide-blocks-procs-and-lambdas/ Update: I just realized how bad it is writing code on Reddit without reading their formatting guilde.
&gt; job, kids, wife Me too. So if I replace my 5 minutes of reddit per day with 5 minutes of Rails, I'll learn it in 8 months? Kidding. Kinda.
Have you looked at [Play](http://www.playframework.com/) framework?
Simplest (and least secure) ruby calculator: puts eval(gets)
It's worth noting that `-&gt;` is new in 1.9.
I'm gonna say that: ruby -e "p 4 * 5" is even simpler. :D
Fair enough :) 
What did you do to demonstrate your skills? Demo sites? Github account? I've worked at enough place that require a degree or prior job experience. In any case, super congrats! 
Github + employer-required technical exercise + demo apps
Could you elaborate on your projects on GitHub/demo apps? What kind of projects/apps did you show to demonstrate your skills and to get the job?
And also, arrays *are* lists. They might not be implemented as *linked* lists (I honestly don't know exactly how they're implemented--they might actually be linked lists after all, but I find that unlikely), but they are certainly lists. And when it comes to stashing and retrieving lists of stuff, that's the important point. "Linked" is an implementation detail: "list" is what you care about.
The sad part is that this is just part of a reddit marketing blitz to get OP and his friends jobs by submitting their projects to reddit. Not a terrible idea, but something more interesting than a singly linked list in ruby (with new names for shift, unshift, push, pop) is likely to get more attention.
If you are wondering which approach is faster, I created a pull request
i've been telling people for a long time that school is overrated in any field except medicine
Implementation is important if you plan for scalability of a project. Linked Lists are faster for adding new elements (either in the middle or at the end) and deleting old ones, since they don't require an array copy or shifting an array. The trade off is slower access time (however, if you are using enumeration, then the access time is the same speed as an array, since you will only be accessing the next item in the linked list).
At some point, you absolutely care about "implementation details" like the algorithmic complexity of insertion, deletion, search, and etc.
I think you are confused. Insertion in the middle of a linked list is O(n) because you must traverse the list. If you know the location (e.g., have an iterator to the location) it is O(1). Insertion in the middle of an unsorted array is always O(1). For more info, see [Search data structure \(Wikipedia\)](http://en.wikipedia.org/wiki/Search_data_structure) or [this SO question](http://stackoverflow.com/questions/122799/what-is-the-time-complexity-of-indexing-inserting-and-removing-from-common-data). Edit: I am also confused.
You're right. I suppose the Wikipedia article means setting rather than insertion when it says that array insertion is O(1)?
Which is scenario 2 (they have a buffer), which still requires you to shift n items in the array down, which makes insertion a O(n) operation (or, if the array fills up, then it needs to do an array copy). There also memory concerns, since you can be in a position of using 9 items in an array, but the buffer allows for 16, which means 7 array spaces have been allocated but will not be used. EDIT: Replying to your edit: It's typically O(1) in cases where you are adding at the end of an array (which is a common operation, as you don't normally add to middle) and there is room in the buffer. If there is no room in the buffer, then it nends to allocate a new array of consistent memory, and copy the values over.
Link to the article you removed in your edit: https://en.wikipedia.org/wiki/Dynamic_array (for people reading afterwards). The typical case, inserting a new element at the end of an array would be a O(1). Because it uses geometric expansion, the times it will grow is quite small (if you start with an array size 1 and insert 10 items, you will only need 3 expansions, if you insert 100 items, then you need 6 expansions, and a 1000 items requires 9 expansions). Big Oh notation typically covers normal usage, so, considering you only do 6 expansions for 100 items, it kinda just drops that particular operation of expansion (since it's atypical). EDIT: Unless you are talking about this link:http://en.wikipedia.org/wiki/Search_data_structure I'm assuming they pre-allocated the size of the array (ie. they know they are adding 10 items, so they have an array of size 10 allocated), and that would be a constant time operation. An unsorted array means the order doesn't matter, so you are placing things at the end. If the order mattered (ie. you have to insert a value in a specific spot for some reason), then the chart shows that it's an O(n) operation.
Ok, I misunderstood the terms. Thanks.
&gt; Depends on the nature of usage for the object. If you plan on adding an unknown number of elements, using a linked-list data structure to format the data (adding an item to the end of a linked list is constant time, where for an array, it can be n, where n is the current size of the array, time if you have to expand the array and copy the elements over) and then creating an array from the linked list. No, Ruby arrays have `push` and `pop` methods built-in which allow you to insert at the end of the array in constant time.
I would argue that your algorithm could probably be better if you're doing a ton of insertions in the middle of an array anyway.
After some research, it's actually almost constant time. Ruby uses [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array), which means they have a bit of a buffer at the end of them. This means they still require to do an array copy when the buffer empties out, but that doesn't mean it has to do an array copy for every insert (I'm trying to find out if the growth is linear or geometric for Ruby). Linear means more frequent array copies for larger sizes, while Geometric means more memory usage (worst case scenario, you are only using half of the space allocated for the array). I only assumed no buffer, because it made the math easier (and was the absolute worst case scenario).
To install: $ gem install ruby-lint -v 0.0.4 Note that ruby-lint is still in the early stages and as such you will most likely experience bugs, false positives and other forms of unexpected behaviour (especially in Rails projects). If you encounter these please report them at the issue tracker: https://github.com/YorickPeterse/ruby-lint/issues/new Suggestions and other forms of feedback are also appreciated! 
you copy the version of Calculator you like and open up irb and paste it in then type irb&gt; calculator = Calculator.new
WTF are you talking about? If you don't understand the difference between linked lists and arrays, you don't understand the difference between O(1) and O(n) algorithms, and probably should stop trying to be a programmer.
I'd say any hard science requires the right schooling. Internal medicine, physics, engineering, etc.
Hah, cool. I like this :)
I *am* talking about the case where you have an iterator to the middle. It wouldn't make sense to use a linked list otherwise.
Ruby's allocation strategy is geometric. Read array.c.
That's the theory. But to make things more complicated, arrays usually perform better in practice because they're much more cache friendly. Even when you're inserting in the middle, you will need *a lot* of elements before your linked list beats an array.
Also, remember to comment your code and keep a healthy README
Heh, funny but Matz was and is a perl programmer himself. He'd probably be like "LARRY WALL IS MY HERO. LET'S WRITE SOME PERL!". If I remember correctly the principal influences of Ruby were perl and emacs.
Not as bad as my former coworker that had a Perl background. He liked to nest ternary operators :(
Smalltalk was a big influence, too.
Objects done right. :-)
You have to define the class for c before you can add methods to it. class c def talk print "This is a test!" end end 
I don't see how this would help me fenec....
yeah... i don't want to agree with you and thereby discourage someone from posting, but these projects are uninteresting, barely 30 lines, and the guys website doesn't even work. my issue is that it's presented as a definite answer when in fact it's cobbled together with no tests or examples.
I believe this refers not to the open source ecosystem of Ruby, but mostly to the fact that like Small Talk (which inspired it in part anyways) Ruby was meant to be a highly readable language and intended to be used to write APIs that are easy to understand. This is not generally true (or as true) with other languages. I think the criticism is kind of fair in that light, but I'm sure others will disagree.
&gt; highly readable I didn't mention specific examples of that, but even on that account Perl developers have tools and a lot of dialogue. On a minor note i invite you to consider (not answer, the point is for you to think about it) the question: "Highly readable for whom?"
No, you don't. You can add methods to any object in Ruby (look up "singleton methods" or "eigenclass"). His code fails, because the local variable `c` is not visible to the other file he's loading. Simply changing `c` to `C` and therefore making it a constant works fine.
&gt;On a minor note i invite you to consider (not answer, the point is for you to think about it) the question: "Highly readable for whom?" Without any context I can't really be sure what you mean by that question. I also don't know what you mean by "tools" and "dialogue" these things don't make a language inherently more or less readable. That said I don't have much experience with Perl, I'm simply explaining the context behind the quote which you misattributed to being about the community.
Ruby is the real magic. And probably the best language I've ever worked with- it's so flexible that even years into it I am still learning (fun!) things... Good luck! Also, unit-test EVERYTHING! It's easy once you get over the (very tiny) hump of simply not being in the habit of doing it. [Here's an example of what I tend to do](https://gist.github.com/pmarreck/5104951)- I write a block at the end of my class files which acts like an in-line unit test, so if I run the file directly, it also runs the tests for it at the same time (but not if it's included by another file).
You're [both wrong](http://www.reddit.com/r/ruby/comments/1ibz23/newbie_q_nameerror_undefined_local_variable_or/cb334vb).
Among other things. Its sort of a super-amalgamation of: + Perl + Scheme + Smalltalk + Lisp + Emacs (although this goes with lisp) + Python Fun fact: Ruby is actually slightly older than java ---- Steve Yegge has some interesting perspectives on this: + [Ruby Tour](https://sites.google.com/site/steveyegge2/ruby-tour) And a few bonus articles: + [Anti-Anti-Hype](https://sites.google.com/site/steveyegge2/anti-anti-hype) ^(this one is actually the one that made me pick up ruby as I grew fed up with python and the python community) + [Bambi meets Godzilla](https://sites.google.com/site/steveyegge2/bambi-meets-godzilla)
The website http://rupy.eu
Constant! I know that word! Thanks! Much, much appreciated.
If you're on a redhat-like system the package 'yum-utils' has a utility named 'yumdownloader' that can download the set of dependencies for a package. If you're trying to mirror an entire repo then you can look at mrepo. However, if you're deadset on writing something yourself there is a ruby-rpm rubygem that has most of the functionality you'll need.
I'm currently finishing up Hartl and looking for my next book/project. I've heard that Agile Development with Rails is highly dependent on scaffolding; is there any truth to this?
Thanks for this, I didn't know that was the case, seems like that could trip up people.
What version of RSpec are you using? I don't believe this is the case in the current version (2.14), though it's possible that very early versions (1.x) did this conversion.
Nice one, that would work too. Although my only concern would be in our current codebase == is the convention and I wonder if it would be cleaned up during refactoring by someone else. Are there any disadvantages, as far as you are aware of using `eql` over `==`?
I have updated the blog post with your suggestion. :-)
No bother, I have updated the blog post with your suggestion. :-)
I'm not aware of any disadvantages to using `eql` in your case. In fact rspec is moving away from the `should` syntax to an `expect` syntax that doesn't work with `==`. expect(1.0).to eq 1 # =&gt; pass expect(1.0).to eql 1 # =&gt; fail expect(1.0).to == 1 # =&gt; ArgumentError: The expect syntax does not support operator matchers, so you must pass a matcher to `#to`.
I was able to reproduce on 2.13.1.
As a general tip, you can use `be` as a prefix to test any inquisitive method. require 'rspec' class Bar def funky? true end end describe Bar do subject { described_class.new } it "should be a Bar" do subject.should be_instance_of Bar end it "should be funky" do subject.should be_funky end end describe String do it "should freeze strings" do "new string".freeze.should be_frozen end it "should not be frozen by default" do "new string".should_not be_frozen end end So, you could use `be_instance_of` or `be_is_a` equivalently here, since all objects have `#instance_of?`
Congrats! I'm in the same boat here...just about ready to start sending out the ol' resume and cover letter Any recommendations/advice regarding the interview process? I've been consuming every resource I can in my spare time, but I'm still slightly concerned about the transition 
Can you post the repro to a gist or pastie? I'm unable to reproduce myself but I might not be doing the same thing you're doing.
My guess is that it's ActiveSupport that's doing this conversion, not RSpec: 2.0.0-p0 :002 &gt; require 'date' =&gt; true 2.0.0-p0 :003 &gt; DateTime.parse('2013-01-01') == '2013-01-01' =&gt; false 2.0.0-p0 :004 &gt; require 'active_support/core_ext.rb' =&gt; true 2.0.0-p0 :005 &gt; DateTime.parse('2013-01-01') == '2013-01-01' =&gt; true 
`c` is a local variable, defined in the scope of `test.rb`, and won't be available from other files. This will work: c = Object.new def c.talk puts "Hi" end c.talk # =&gt; Hi But across file boundaries you'll need to export a constant: # a.rb C = Object.new def C.talk puts "Hi" end # b.rb require "./a" C.talk # =&gt; Hi Reminder: constants are names starting with an upper case letter. Review [Programming Ruby](http://www.ruby-doc.org/docs/ProgrammingRuby/) for more.
For those who hate rspec-mocks for its false positives and bulky odd API check out my gem Spy https://github.com/ryanong/spy
Awesome Implementation
Can you elaborate on why you think that expects aren't a good idea?
I believe all assertions should be grouped together at the end if possible and it follows the if this then that logic a lot better. Expect this to happen when I execute this and this should have happened also Vs When I execute this all of this should have happened. Also you have no idea when said stub is executed
I added this. Thanks for the feedback!
have an upvote for reminding me!
Metaclass is already defined as `Object#singleton_class`.
The date on the article is 2005 :)
Ah, good ol' Why the lucky stiff.
That was me being lazy with my Sublime Text settings when I set up this computer ;) Okay cool thank you I'll look into it!
Hmm... I implemented the first half of the script (up to the CSV part), and it seems to work fine. Try changing page = reader.pages[i] to page = reader.page(i) If that doesn't work, try uninstalling, then reinstalling pdf-reader ('gem uninstall pdf-reader' then 'gem install pdf-reader')
I should note that this same script worked out of the box yesterday.
Screw it, I just upgraded. No more LTS for me.
Currently, I'm puzzled as to how I got my previous results. A (RHS) date string is not automatically converted to a date in 2.14.2. I must have got something mixed up along the way. With a name like dchelimsky, I'm pretty sure you'd know rpsec better than me :-)
All I can think is that somehow your local environment got messed up. Try uninstalling and reinstalling that pdf-reader gem. Looking at the gem, the location of your errors makes no sense.
I haven't played with gosu in a while, and when I did it was in linux, but did you try installing the cocoapods gem? The osx getting started guide lists it as a prereq. https://github.com/jlnr/gosu/wiki/Getting-Started-on-OS-X 
For some reason, I didn't think to change the pages. I feel like a complete imbecile. It's always the easiest thing. I was scanning pages that didn't exist and after adjusting the range for the document it ran fine. 8000 addresses later, job's finished!
This isn't a problem with gem installation. The message "Failed to build gem native extension" generally means that there are missing system libraries or the like. For example that's a common error when folks try to install the `mysql` gem without having a mysql client installed (such as `libmysqlclient-dev` for most linux distros). I'm admittedly unfamiliar with GOSU (or even what it is), but the problem is right there in the stack trace for you: `File exists - ../linux/gosu.bundle or ../lib/gosu.bundle (Errno::EEXIST)` Something is trying to create a symlink (you can see the calls to `ln_s` in the trace) but the file already exists... I'd bet you tried to install GOSU, got part way through the process before it failed (likely because of missing libraries), and now after satisfying those dependencies you're stuck in a state where stuff is partially installed (i.e. that symlinked file already exists) and the install is failing with the above. Would I be correct in assuming you probably got a totally different error the very first time you attempted the install? You could try removing those files and attempting the installation again, but there's a chance you may run into 100 similar, minor problems (like other files that were created and not cleaned up when the install failed, or any number of configuration issues). As for your SO post, the one suggestion I have is to be a bit more verbose up top. Post the exact commands you're running, maybe a few more details about your environment, and full output and stack traces. For example, knowing nothing about GOSU I wasn't sure what the install process is like... is it just a rubygem, and you're just running `gem install gosu`? That kind of stuff makes it easier to figure out what the poster is trying to do (as opposed to what they're asking) when they might not know exactly what they want to ask in the first place. Final thought - is there a reason you're using ruby 1.8? Does GOSU require ~1.8.7? Looks like it's probably the OS X default system ruby... I'd suggest taking a look at rvm or rbenv (quick google will get ya going) and getting on 1.9.3 Good luck! EDIT: After seeing your reply to the poster above, and realizing that the symlinked files in the stack trace seem to be `.bundle` files, you may be right and it may be something up with your version of rubygems. I'd suggest another SO post with full details about the exact versions of ruby, rubygems, etc. you're using and full traces. Alternately, if you go with rvm or rbenv they'll each install and manage their own versions of ruby and may resolve any rubygems problems you're having. EDIT 2: Not "RESOLVE your rubygems problems," but you'd be using a different ruby, which would be using it's own rubygems, which would (probably) be working - system ruby would still have the issues you're having now.
Hey, thanks a lot. Good reply. I'll try installing rbenv and report here...
Yeah! Totally works! I used rbenv to manage my gems! Thanks man!
Yeah I just tried it myself and got the same/or similar errors. My setup is a bit different than yours tho so I'm not sure if that contributed. I'm running the OSX Mavericks dev preview and rbenv with ruby 1.9.3.
Congratulations, and good luck! As a student searching for future work, I'm kind of in the same boat. Hope it works out for both of us.
Damn! This is pretty awesome, I'll be using this in my upcoming project for sure! Stared+Watched :D
Why mongoid?
Thanks! :)
Ha! They really should have had a better error message for that.
Really nice work and great idea as well. I know a few people who will definitely use this.
It looks really cool, I am just wondering why you didnt use validations? instead of "current_user.can_create?" why not just throw a validation error when the widget is saved? That would also elimit the need for the controller method limit_exceeded!. If I was using a website I would much rather have a flash message or validation message saying I need to upgrade rather than a redirect to another page in the middle of what I was working on.
I've done this before and I'll warn you that it's difficult to do this without the company being able to claim some ownership. IANAL, but... First, check your employee agreement that you signed when you started. There may very well be a clause in there that any IP (intellectual property) you work on, if related to the business of the company, is the property of the company. If this is the case, continue at your own risk. It would probably be difficult for the company to make a claim and likely not worth their time, but it still could be a pain. Depending on your company relationship, you may be able to ask for permission, but regardless take the following steps. Step 1. Document your idea and progress in a journal/inventors log. If the worst happens, this gives you written proof of when/how you came up with the idea. Step 2. Don't use any company resources whatsoever. Do not work on it at work. Do not use one of their laptops. If you do not want them to be able to make a claim, you have to do this 100% using your own resources. The catch here is want to be able to use this at work, so it gets a little tricky. Maybe you can get their buy-in and make it open-source? That would be the best of both where you can use their resources and show it off publicly. 
Step 1. Do what dacort says and look through your contract. Step 2. Approach your employer about putting on paper that you do not want them to have ownership. Talk licenses. Perhaps you'd be okay with them having a license, and perhaps they'll be okay with that. If they won't put that on paper, don't even bother coding it.
I haven't thought about making it open-source, that might be a good way to go. I don't actually recall signing a contract...but it's a small company. I guess I could just introduce it as a third party site "Hey, look at this cool site that does everything we need!" to maintain the anonnmity. The thing is I would need feedback from the field to see how it goes (which I could do covertly as in, "So how is the site working for you?", type thing). The thing is, I'm not "classified" as a programmer, but I have done some VBA programming for the company and they have claimed some of my time for the R&amp;D credits way back when. I don't know if this helps with the contract stuff (been with the company for 3+ years). Another thing I was think was to create a generalized program and make a "plugin" for their work orders and other work orders to distance it as much as possible from their IP.
Agreed. Now I am going to attempt to build one (from scratch) for web crawling. Oh man, this programming stuff is frustrating/incredibly entertaining. Any tips, Rubyists?!
It doesn't work like that. Seriously, talk to your employer.
I think StackOverflow might be a better place to ask something like this.
My biggest suggestion would be to add suport for ActiveRecord ASAP, and heavily utilize associations and `ActiveRecord::Relation` to encapsulate some of the functionality that currently resides in your controller examples. I would assume for any of this to work, the `Widget` would `belongs_to` a `User`, which means on creation of the widget you could validate based on the associated user and whether or not they were allowed to create another widget (whether they've hit their limit for that resource). You could return a validation message that makes sense and do whatever you want with it (flash messages, redirect and display errors, etc.). This would prevent you from having to check if `@user.can_create? @widget` and would rather throw a validation error on `Widget.create(params[:widget])`. Same for destroy - you could add a `before_destroy` or `after_destroy` hook to the models, rather than needing to call `@user.destroyed @widget` after `@widget.destroy`. EDIT: Forgot to mention, in the scenario above the `Widget.create` would of course also be able to abstract the call to `@user.created :widget` in an `after_create` hook (and would normalize utilizing the actual object itself there, like the rest of your API methods, instead of using a symbol).
FYI: http://www.pulpproject.org/
Is your environment variable pointing to the location of the new installation bin folder?
We've been using our own version of something similar for almost a year in production on a super high traffic site: https://github.com/cmer/scope_cache_key Basically, we add #cache_key to scopes. This way, we can cache entire scopes (ie: all comments at once) and the we russian doll cache the individual records. it works quite well indeed! 
I may get downvoted to hell for saying this, but I think at least one person should say it: Use rvm instead. This kind of stuff doesn't happen with rvm. ------- If you installed rbenv, did you also make sure it gets initialized properly / gets added to the PATH ?
Make sure that your `ruby` and `gem` commands actually resolve to the rbenv shims -- do `which gem` `which ruby`. You can read the short section on how rbenv works [here](https://github.com/sstephenson/rbenv#how-it-works).
use `which` to find out what executable the shell is using. Specifically `which ruby` and `which gem`. Also, I'd try installing completion packages to solve the `complete` missing problem - http://braumeister.org/search/complet
&gt;/usr/local/Cellar/rbenv/0.4.0/libexec/../completions/rbenv.bash:16: command not found: complete `complete` is a Bash builtin function. Are you definitely using Bash?
No one ever breaks their rvm install, right?
I won't downvote but I switched to Rbenv precisely because someone told me "Don't use RVM. Rbenv is leaner and doesn't give you problems like RVM. It's not going to break on you." Furthermore, I suspect the Rbenv thing is largely my fault. I just don't get it. All I want is a easy f***ing way to manage different Rubies. 
Here's what happened, I did a brew remove rbenv Then my initial Ruby was broken, even after a shell restart. ruby gave me "no such thing, yada yada..." So with my face on my palm I did brew install rbenv Expecting to find my old rbenv Rubies already there. I did which ruby and it gave back system So I installed 1.9.3-p0. I then rehashed and suddenly everything is working fine.
rvm has had issues but is way beyond its growing pains. it has not broken on me in at least three years.
It would be ignorant if I hadn't used rvm and rbenv for long enough to get accustomed to both of them. I prefer rvm. rbenv, to me, is awkward in a few annoying ways. And rvm has not broken for me in three years.
My rbenv install hasn't broken in just as long. Yay anecdotes. Seriously, though, why not let people make their own decision for themselves? I myself couldn't stomach the `cd` hackery.
Because I thought the 'cd' hackery was such a bullshit point of argument, honestly. I got SO ANGRY at the rbenv author for specifically dissing rvm in his original README regarding the cd 'hackery', and completely disregarding all the work rvm had done -- work that HE used when he created HIS project, building on top of the ideas -- that I instantly took a dislike to him and the project, personally. Who the fuck does this guy think he is, and where does he get off, shitting on the hard work of the people who came before him? SERIOUSLY? Yeah yeah, you shouldn't do this. WHATEVER. It's convenient and it's not evil. IT IS NOT EVIL. You couldn't stomach the cd hackery.... Does that mean you never used rvm? Or does that mean you jumped the gun when rbenv came out? Because if the latter, you're a hypocrite, my friend. If the former, then fair enough, I respect you and your opinion and your dedication. But come on! What philosophy are you espousing here? What OS are you using? Are you on Slackware? On OSX? Let's draw a line in the sand and have the correct philosophical battles, here.
Cool little program. Now I want to play a round. My first refactoring would be to replace the check_ladders and check_chutes methods with a single hash lookup. The check_chutes_and_ladders method would just be: @square = CHUTES_AND_LADDERS[@square] || @square That hash could have a default proc that just returns the key, to remove the || @square Thanks for sharing. 
You have the maximum number of turns at 181, but wouldn't this be infinite? I could be wrong, but from memory, you could keep hitting the same chute over and over again, effectively never finishing the game.
Thanks. I agree that it needs some major refactoring, and I like your idea about just using a hash lookup. I probably wrote this about two years ago when I was first learning ruby. Chutes and Ladders is my default "Hello World" when learning a new language.
I think you're correct. The odds of that happening are just low enough that it never occurred during the 1000 games that it played.
Seconded.
&gt;Chutes and Ladders is my default "Hello World" when learning a new language. Ha. I like that concept. I might have to start something similar.
All I can say after this is that this is actually *one thing* that would look slightly more organised in lisp's syntax. Which in a way, makes me warm and fuzzy about lisp. Also, if I spent three hours getting my head around some of these, I might learn something.
Or you can just buy his book. It's really solid stuff. Here's the book: http://computationbook.com/. It's a direct link and I'm in no way affiliated with the author. I just think people should know this stuff.
The one major thing I learned from this is that I know nothing. I'm a ruby developer, but a lot of that went straight over my head. Ego check :/
Truth. This is the most convincing Ruby proof I've yet seen (and certainly hope to see) of [Greenspun's Tenth Rule](https://en.wikipedia.org/wiki/Greenspun%27s_Tenth_Rule).
Of course, Any sufficiently complicated Lisp program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Ruby as well. 
I have a friend who does something similar but with Conway's game of life.
not rly
Fun library, thanks for posting it here! :)
Congratulations! Great hearing a success story!
FYI, Vagrant's [Getting Started](http://docs.vagrantup.com/v2/getting-started/index.html) docs are very good.
I love this, although, now that I have been programming for many years, I haven't really been doing it as much. Recently, I've found myself wanting to just draw something, but its hard to send that over to someone electronically. I wish I had some flat device that I could draw on electronically, and send it to people....
I have one of these things - I think that's what you're talking about. They are called graphic tablets and are super helpful! http://ecx.images-amazon.com/images/I/31FeLd0gs0L._AA160_.jpg
I've heard of vagrant before, but had never looked into it before. Thanks. 
Very clever. Seems conceptually similar to this Haskell implementation: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
UML is a notation, not software. You can draw diagrams by hand using UML and they do not have to be large system-wide diagrams. I use UML notation all the time by hand for just a small group of classes and it helps me work out the class interaction. I agree the notation can be confusing at first (aggregation/white diamond vs composition/black diamond, for example), but having a common notation really helps with explaining your ideas to others. By far, the best book I have read on UML is "UML Distilled" by Martin Fowler. If anyone has dismissed UML, I suggest giving this book a try.
i use this on windows with virtualbox... the problem however is that starting it up can be hit and miss as virtualbox is a bit buggy with it... usually an ipv6 issue.. 
Then you can easily use that script to provision a base Vagrant VM and get isolation for free. You can find some example Vagrantfiles that use shell, chef, puppet provisioning.
This "article" can be summarized as: &gt; If you use #try I hate you and you are dumb. That is not at all a helpful thing to say, especially if you offer no alternatives or reasoning. The #try or #andand pattern can be seen as bad because it hides bad or inconsistent return values. It also makes code look messy. A better approach would be to encourage the use of something like the null object pattern. If you have a method that may or may not return a user and you are doing: User.may_be_nil.try(:name) You can return a null object that responds to name so your code can look like: User.now_cannot_be_nil.name And the null object can use something like ActiveModel and respond to name in a reasonable way: class NullUser def name '' end end
Least helpful, most childish, article I've read in a long time. No solutions, no explanation, just complaining.
I explicitly suggested using NullObject in the comments, for what it's worth, and was having meaningful discussions with people there regarding alternative options.
Well, a colleague wrote a gem to help with that: https://github.com/danielwellman/bane
yeah, I think NullObject is typically the pattern to reach for instead of #try. Sometimes one might also construct a ViewObject or something else around the data to be represented. It's true that I wasn't terribly helpful in the article, but I tried to be helpful in the comments. I've heard too many people argue that #try is useful, and I've run into basically no cases ever where it wasn't just laziness or papering over bad design (which is a *great* idea for current-you, but a *terrible* idea for future-you-or-other-developer)
I like this kind of article because it breaks the fourth wall from the outset, rather than inviting comments after the point has been made. Articles that are well-thought out and informative are great, but I also value those that invite open discourse. I'll assume, for knewter's sake, that he will not only participate, but perhaps update the article with what he's gained throughout. +1 for this kind of blog posting.
[Avdi Grimm has a relevant blog post](http://devblog.avdi.org/2011/07/05/demeter-its-not-just-a-good-idea-its-the-law/) in which he isn't a colossal douchebag.
Which guy from Cyrus are you? :)
I did this once too! Check it out: necrohost.com !
http://stackoverflow.com/questions/596780/how-do-i-simulate-a-slow-internet-connection-edge-3g-on-a-mac-is-there-a-fire
You could have too, it's very very easy to do. irb(main):016:0&gt; puts Benchmark.measure { 1000.times do fib1 = Hash.new { |hash, key| hash[key] = hash[key-2] + hash[key-1] };fib1.merge! 0 =&gt; 0, 1 =&gt; 1;fib1[4000];fib1[8000] end } 10.870000 0.000000 10.870000 ( 10.851947) =&gt; nil irb(main):017:0&gt; puts Benchmark.measure { 1000.times do fib1 = Hash.new { |hash, key| hash[key] = hash[key-1] + hash[key-2] };fib1.merge! 0 =&gt; 0, 1 =&gt; 1;fib1[4000];fib1[8000] end } 13.720000 0.000000 13.720000 ( 13.700253) =&gt; nil
For those who don't know what Docker (http://docker.io) is: it is "an open-source application container engine. It gives developers a way to package their app and all its dependencies into a portable container which can be deployed on any modern Linux machine, virtualized or not. Containers are completely sandboxed and do not interfere with each other (think “iPhone apps for the server”), have virtually no performance overhead, and can easily be moved across machines and datacenters. Best of all, they don’t depend on any language, framework or packaging system." Compared to regular VMs, Docker containers are much more lightweight. You don't have to allocate a static amount of RAM. The RAM is shared with the host OS - everything runs on the same kernel. This saves tons of money and hardware resources. Flynn is an open source PaaS built on Docker. A PaaS is like Heroku, but an open source one allows you to run it anywhere, even on your cheap VPS, which not only greatly reduces costs but also avoids vendor lock-in. It'll even support Heroku buildpacks so that you can run Ruby, or whatever Heroku already supports. Flynn is in an early stage of development and its authors are seeking funding so that they can concentrate on the project full time. They state that even if they don't reach the funding goal, they will work on Flynn, but it will take much longer and the end result won't be as polished. So if you can spare some money, please consider supporting Flynn!
Congrats! I find this post very inspiring. I'm currently a ruby/rails n00b spending as much of my free time as I can immersing myself in the subject. My goal is to hopefully change careers somewhere down the road and seeing as how you did it in such a relatively short period of time is very inspiring. Do you have any advice for a n00b? Looking back, is there any bit of advice you wish someone had given you when you were stating out? Congrats again!!
I like to mix it up and use every identifier naming convention I can think of in a project. It keeps things interesting. Also, when creating different tables in a database that use the same type of data, I like to make minor changes in the naming conventions just to keep my predecessors on their toes. For example in one table I'll use *"street_address"* and in another I'll use *"street_addr1"*.
I'm one of the Flynn developers. Autoscaling would scale up/down the number of instances of your app running on the cluster based on a set of load metrics. Currently it's just on the "nice to have" list, but a sponsor could change our minds about the priority.
This could entirely replace your setup. Essentially you would boot up one or more Flynn nodes (VMs, EC2 instances, bare metal, etc) and then you would be able to just `git push` your app to deploy it.
So my guess was correct, reordering it is subtly faster. order1=[] fib1 = Hash.new { |hash, key| order1&lt;&lt;[key,hash.has_key?(key-1),hash.has_key?(key-2)];hash[key] = hash[key - 1] + hash[key - 2] } order2=[] fib2 = Hash.new { |hash, key| order2&lt;&lt;[key,hash.has_key?(key-1),hash.has_key?(key-2)];hash[key] = hash[key - 2] + hash[key - 1] } fib1[0]=1 fib1[1]=1 fib2[0]=1 fib2[1]=1 puts fib1[10] puts fib2[10] puts order1.size puts order2.size puts order1.zip(order2).collect{|e| e.inspect}.join("\n") Outputs... 89 89 9 9 [[10, false, false], [10, false, false]] [[9, false, false], [8, false, false]] [[8, false, false], [6, false, false]] [[7, false, false], [4, false, false]] [[6, false, false], [2, true, true]] [[5, false, false], [3, true, true]] [[4, false, false], [5, true, true]] [[3, false, true], [7, true, true]] [[2, true, true], [9, true, true]] 
You are misreading that error. Even `nil.to_s` returns an empty string. The error you're getting is what happens when you try to concatenate two different types together: `"string" + nil`, for example. So the error is not in the code you pasted, it's somewhere else. Read the full stack trace to track it down.
I would really hope that no one would take my comment seriously enough to paste that git command in their terminal window.
well now that i read the first sentence a bit better ;). 
This code works perfectly for me in IRB: require 'time' t=Time.now # =&gt; 2013-07-25 14:08:13 -0500 t.to_s # =&gt; "2013-07-25 14:08:13 -0500" Are you doing something between setting `t` and converting it to a string? 
What do you mean by IRC 10 years ago? I recall it to be hostile, uninviting place, and I certainly was not intending any hostility or snarkiness. If the law of the land is "no silliness," then I'm happy to comply.
I basically use a rule of "few vs lots" If I have few options, I use if/elsif. If i have lots, i use case
There are two types of conditional 1: Tests for inputs from external sources. 2: Test for the internal state of your system. You should eliminate the second type. Why test something that you already know the value of?
Looks good, thanks!
Keep in mind that if statements and (especially) case statements are both forms of procedural polymorphism. OO languages have other, often better ways of doing polymorphism, so try to find them!
learn some kind of Lisp. e.g. http://clojure.org/ Emacs Lisp is also a good option to get familiar with Lisp: http://bzg.fr/learn-emacs-lisp-in-15-minutes.html
If you haven't picked it up already, I would suggest to look into Rspec or Cucumber and the like. Test/Behavior Driven Devolpment is a very valuable skill for your CV and complements your current skills perfectly. 
If you aren't already great at it, without a doubt, Javascript.
complement*
Ok, thanks. I'll take a look.
Some great suggestions here around complimentary languages. Let me chime in on the tools. Depending on where you want your career to go deploying Ruby without Heroku wouldn't hurt at all. - When to use [Varnish](https://www.varnish-cache.org/) / [Nginx](http://nginx.org/) and why - Why [Capistrano](http://www.capistranorb.com/) is a popular way to deploy code - How to demonize and monitor ruby processes - Why people use [Chef](http://www.opscode.com/chef/) - Knowing the key difference between how [Unicorn](http://unicorn.bogomips.org/) scales and [Puma](http://puma.io) - Understanding Git, [Git merging strategies](http://stackoverflow.com/questions/366860/when-would-you-use-the-different-git-merge-strategies) and having an awarness of [Git Flow](http://nvie.com/posts/a-successful-git-branching-model/) style branching models - etc... I've made no assumption on what you already know so please don't feel like you need to know all of this but as Rubyist these are things I look for in candidate's that I hire :). PS: I've not included Databases in all of this which I think is obvious to say is important when fleshing out a CV. PPS: Two books I would recommend highly (can easily be read on holiday in the sun) - [Seven Languages in Seven Weeks](http://www.amazon.co.uk/Seven-Languages-Weeks-Programming-Programmers/dp/193435659X) - [Seven Databases in Seven Weeks](http://www.amazon.co.uk/Seven-Databases-Weeks-Modern-Movement/dp/1934356921) Both of these books are fairly light hearted, give you a grounded understanding of the core differences in languages and databases, assume your a programmer already and IMO are very interesting reads for someone that is keen to look at languages from different angles. [Prolog](https://en.wikipedia.org/wiki/Prolog) == [mind blown](https://s3.amazonaws.com/f.cl.ly/items/3n2K0j1w1G2b0L3i2v3V/Image%202013.07.27%2015%3A03%3A25.gif) Good Luck
You should definitely try clojure!
As a Ruby veteran I've become quite fond of Go. Its abstractions are close enough to Ruby that it was very very easy to learn, but it's sweet spot is exactly where Ruby is weakest, highly performant, highly parallel code. Other reasonable options also in this sweet spot would be node.js, erlang, clojure, scala and Java. But of all those, Go has been the most enjoyable to code in.
I would suggest coffeescript as well, and maybe then delve into node.js.
Hi, startup hopper here. The hottest skills right now are ruby and JavaScript/nodejs. With those two and a solid understanding of OO you'll be worth a fuckton (USD)
Not proud, but that used to be me. Then I came to the understanding that code is written to be read by a human, not just interpreted by a machine.
Why don't you distribute it as a gem as well?
In my experience learning about other languages makes me a better programmer even in the language I typically use. When I write Ruby I tend to follow the mantra that methods should be as functional as possible. Nothing helps that like playing in a functional language. Languages that are functional tend to handle concurrency really well because they have immutable values (so they can be safely and easily shared). This makes them a nice complement to a language like Ruby where concurrency is still not great. [Riemann](http://riemann.io) is a good example of Clojure in the real world. It's used to monitor systems and crunch lots of stats. It's a great example of the kind of thing a language like Clojure excels at.
If you haven't looked into [Elixir](http://elixir-lang.org) you should play with it a bit. It's built on top of Erlang and I feel like it also hits in the places where Ruby is weak. Also, the syntax is heavily influenced by Ruby. I've been meaning to check out Go but I haven't gotten to it yet so I can't give you a good comparison of the two.
Maybe later, I haven't thought about distributing it as a gem )
On the front end angular, bootstrap are nice.
Be a better programmer: javascript and scheme
That's a great response. Of course I understand the academic value of learning other, more "foreign" languages. The reason I mentioned "do you have code running in production", though, is because as I get older, learning new languages is a much bigger "investment," given I have little free time anymore; and given the crazy amount of shiny new languages to choose from, I'm looking to make a choice that maximizes "payoff" (code I can write to get shit done now). Choices peaking my interest at the moment: Scala, Clojure, Go, F#, and Haskell. Of these, Go and F# are probably the most "practical" I'm guessing. I usually just whip Perl or Ruby out and get it done. 
Thanks! Ill check it out!
One popular technology for Ruby/RoR is queueing/background processing...check out the resque, sidekiq, and delayed jobs gems.