And to be doubly accurate, \_\_END\_\_ means it's no longer parsed as ruby - instead something similar to a file you can read from (that is, it means that everything after \_\_END\_\_ should *not* be considered code, more as if it were a text file). Copying and pasting looks like it's using CRLF for line endings, I converted it to LF only and it worked. Edit: and only now do I realise you've fixed it.
Rails 3 isn't released yet, this is just the auto-generated HTML from the release notes file in the Git repo. :)
ah thanks for clearing that up :) but yeah -o- emailed me a "fixed" ruby file. 
essentially. :P
Uh, pretty neat I guess?
i'm brand new to this. thanks for being supportive. :)
just looking at the 'scores' it's not clear whether a higher or lower score is preferable, some indication along these lines would be good IMO.
I just don't really get why you posted it. Don't get me wrong, it's awesome that you're learning Ruby, I just think you should wait until you make something interesting or valuable to others before you post it. How boring would this place be if everyone was like "oh hey I'm just learning how to cook, here's a hot dog I made!" or "I'm getting pretty good at video games, here's a video of me beating world 1-2 in Mario Brothers!" I guess five other people thought this was worth an upvote so maybe I'm wrong. 
haha good point :)
Now stop replying to me and go work on something more impressive!
You reset the database. I spent valuable cpu cycles running 10000.times { `curl -s global-count.heroku.com &gt; /dev/null` }
Phew. I was afraid someone I knew posted a link to something I'd written.
[richard rorty's essay *trotsky and the wild orchids*](http://www.scribd.com/doc/25772850/Rorty-Trotsky-and-the-Wild-Orchids) is about philosophy from the point of view of "private, weird, snobbish, incommunicable interests." brings up sublimated sexuality also — perhaps relevant to those language enthusiasts for whom sexiness is an important virtue?
Weeeel... (1) I am trying to make sure my interests are communicable (that makes them sound like STDs) and (2) joyful is not the same thing as sexiness. As for as these language extensions are concerned, I think they have turned out to be un-sexy from a Ruby point of view. Sexy is usually something that eliminates a ton of code. For example, you type: before_filter :authenticate, :except =&gt; [:about, :login] And tons of magic happens behind the scenes. Whereas `something.each { other[its.across][its.down].remove }` saves a whopping five characters and a space compared to `something.each { |its| other[its.across][its.down].remove }`. That doesn't seem sexy, although it does feel right to me because a word like "it" or the possessive "its" ought to be assumed.
sorry, I didn't really mean to make a point or anything, I just love the essay and tend to find it "relevant" to almost anything. I like your extensions! my beloved brother wrote [this thing](http://www.brockman.se/2005/hyphen-ruby/hyphen-ruby.rb) which does hyphenated-method-names and blocks.like {.this} and maybe something else.
Love the hack, tweeted it thanks!
interesting thanks
For those who are unaware, there's also bundler: http://github.com/wycats/bundler 
Socratic dialogue is always appreciated.
You can get perl to die automatically on I/O errors with `use autodie qw/:all/`. This also affects `system`, but there are [some caveats](http://search.cpan.org/~pjf/autodie-2.06/lib/autodie.pm#system/exec).
Why is probably still coding in Ruby.
I'm a little unclear on why he wrote two a nearly-identical solutions to the same problem. Surely zenspider knows about bundler...
bah I had read "sex for rubyists" disappointing link :/
Reasons to hate Ruby: 1. It borrows from Perl--heavily. Yep, that's pretty much the only problem I have with Ruby. I went from Perl to Ruby for my scripting needs, and unfortunately I cannot get out of the habit of writing very concise code: @ftp.close if caller[-2].match(/`(\w+)'$/)[1] != 'sync_all' ...or... Dir.open(@files_dir).each { |s| sync s if s !~ /(^\.{1,2}|^sire$)/ } I don't know. So much power in so few characters. It's sorta hard to read, but it makes perfect sense to me. I need to learn to write cleaner, more verbose code. But when I'm given features, I tend to use them. :(
useful, thanks
Fwiw, I didn't find those that hard to read.
sound cuts of at around 33:08... :( right when that chill guy brought up something interesting 
 Dir.open(@files_dir).reject{ |s| s =~ /(^\ {1,2}|^sire$)/ }.each{ |s| sync s } There, now it's idiomatic ruby :P 
Well, I don't either--but they just look ugly. Whenever I see others write code, it's just so nice. Maybe it's just my perception. :/
Lol. But so much less efficient and actually harder to read.
Instead of yet another "lightweight" blogging app "in under X hundred lines" I'd like to see something more heavyweight and complex that can compete with wordpress, drupal, joomla, etc. 
i really like the minimal approach of handsoap, but i don't like to deal with xml, so i wrote another alternative for interacting with soap services. it's called savon (http://github.com/rubiii/savon) and i can only recommend you to give it a try.
Hmm, this question doesn't seem specific to ruby, so you may want to try some other reddits too (javascript?). That said, I have used rmagick to do various photo manipulation on the server side (it can draw images as well). If you are wanting to do client-side stuff, then canvas or svg is probably your best bet (look at the various javascript libs to help you do this like [raphael](http://raphaeljs.com/)
Nice.
will do, thanks :) 
I know how you feel. I've read so much about Ruby, by so many people who seem to "get it", I always think whatever code I write must be disgusting. 
meh. The client is easy. You can just use a raw HTTP post and parse the result XML using whatever you want. Where is the decent soap server library for ruby?
it is possible, but your response time might be rather large. essentially, you just need to send out the string of image data from your route, and include the right content type. so yes, perfectly possible, but be aware of the speed issues. check out mime types on this page: http://www.sinatrarb.com/intro.html
What's different from [handsoap](http://github.com/unwire/handsoap)?
Neat, now if there only was a way of creating an exe file out of my ruby code... preferably one that DOESN'T unpack a gazillion files to the temp directory prior to running -_-
I don't understand why this stuff isn't released more regularly.
I was looking for the 1.8.7 installer about three hours ago, nice timing.
Considering that Ruby on Windows isn't a major concern for the core development team, I'm very impressed with the work the Rubyinstaller guys have been doing.
there's a subreddit for that
Yes, Ruby on Windows is not a popular configuration. The fact this even exists is a miracle. It's quite handy, it prevents me from having to run a virtual machine on this machine just to use Ruby.
Sounds like some one's first programming language is Ruby. When you use Ruby blocks, you are using anonymous functions, or Procs in Ruby. These functions can be passed around like data to increase functionality of a function. The most common example is to include a comparison function to something like a sort. You could use this function to make the sort ascending or descending. See [Structure and Interpretation of Computer Programs](http://mitpress.mit.edu/sicp/full-text/book/book.html). It goes over a lot of the programming mind set. Edit: Also See [What’s an example of when you use a Proc or Lambda in a Ruby web application?](http://stackoverflow.com/questions/1430905/whats-an-example-of-when-you-use-a-proc-or-lambda-in-a-ruby-web-application) [When to use a lambda in rails?](http://stackoverflow.com/questions/1232817/when-to-use-a-lambda-in-rails) [Please list specific examples of the benefits of using lambda expressions](http://stackoverflow.com/questions/1954909/please-list-specific-examples-of-the-benefits-of-using-lambda-expressions)
As a minor addendum to bluehavana's list, Yehuda Katz's most recent blog post might also be a good thing to read. http://yehudakatz.com/2010/02/07/the-building-blocks-of-ruby/ However, it is fairly advanced, so don't worry if it isn't all immediately clear. Just realise that they are *very* useful, and that they are your gateway to understanding functional programming.
Please check exerb-mingw: http://github.com/snaury/exerb-mingw Pik (ruby version manager for windows) uses it, no files extracted. http://github.com/vertiginous/pik 
A new installer will be only released when there is something to fix in the installer itself or a newer patchlevel of Ruby is released.
&gt; When you use Ruby blocks, you are using anonymous functions, or Procs in Ruby. These functions can be passed around like data to increase functionality of a function. &gt; &gt; The most common example is to include a comparison function to something like a sort. You could use this function to make the sort ascending or descending. to clarify a little, when you do something like the following: array.map {|element| element*2} # or array.map do |element| element.upcase! end you are using anonymous blocks. If you know you're going to be doing a lot of the same procedure on different things, you can do something like the following: upcase_proc = lambda {|element| element.upcase! } and then use it wherever you want, over and over again like so: first_array.map(upcase_proc) second_array.map(upcase_proc) third_array.map(upcase_proc) Another usecase of lambdas and procs (and anonymous blocks) that rails uses is code evaluation at runtime instead of at initialisation time in models. An example of this is passing a block to the :message option of a validate line (this feature might only be rails 3, but i think it is about to go into rails 2.3.x as well) which instead of being evaluated when the model class is first loaded, it is called when the validation actually happens, allowing you to insert request-specific values.
&gt; first_array.map(upcase_proc) Small note, though it is quite relevant to the concept: you have actually do: first_array.map(&amp;upcase_proc) By far the most common use case for anonymous functions is passing a single function as data and having the function taking in the block call the block, like in the case of `map`. So, Ruby optimizes for that case by having a special syntax for that. Note that when calling a function with an anonymous block, you don't have to create the block with the word `lambda` or `proc` like you do when creating the block and assigning it to a variable. Similarly, you don't have to assign a variable when you want to use an anonymous block that was passed to you: def test yield end test { puts 'Testing!' } as opposed to: def test2 blk blk.call end test(lambda { puts 'Testing2' }) The ampersand just allows you to go back and forth between the two "types" of blocks: test(&amp;name_block) def test3 &amp;blk blk.call end test3 { puts 'Testing3' } You probably knew that, but it's a good idea to understand the difference. &gt; Another usecase of lambdas and procs (and anonymous blocks) that rails uses is code evaluation at runtime instead of at initialisation time in models. I don't use Rails, so I don't know if this applies, but many methods that provide these types of features tend to use the fact that blocks in Ruby are *closures*, i.e. they take the context of surrounding code in which the block was defined: var = 3 closure_test { puts var } # somewhere far off where the variable "var" is not in scope def closure_test yield end I highly suggest the OP take a look at a book like [SICP](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start).
yeah, oops, i couldn't remember if i needed the &amp; or not. http://github.com/rails/rails/blob/31ea83eb898786f853bd7ce7075986fa120f949d/activemodel/lib/active_model/errors.rb#L67 is the code i mentioned. I'd hazard a guess and say that in fact using a proc/block/lambda there will not inherit the Model's context and instead inherit the scope from that method, which isn't particularly helpful.
Just to say great job Luis! Is it still just you working on this? I used to use this when I first started out on Windows; I've since moved to Mac but I'm very grateful to have used this as it's a fantastic setup for getting started quickly. I'm not sure others would've had the dedication to keep working on it the way you have. Keep up the great work.
Asking "where is the decent soap server library for x" is like asking where the tooth fairy lives; everyone can come up with an answer but they are all wrong.
Looks like handsoap might be a bit faster. Savon relies on Crack for its which utilizes REXML for XML parsing. handsoap uses nokogiri which is orders of magnitude faster than REXML for parsing XML, especially in large data sets. As far as pure functionality, one would have to get down and dirty with both to see how complete they are.
sadly there is no english documentation (or anything close for that matter) :( I guess I'll just play with it at work tomorrow
Actually, handsoap can use any of Nokogiri, libxml or rexml, but it defaults to use Nokogiri. The same goes for http-adapters, where you can chose between curb (default), net_http, http_client and Event machine.
I know it is the same but I would use "unless" to make it more readable Dir.open(@files_dir).each { |s| sync s unless s =~ /(^\ {1,2}|^sire$)/ }
No, a new installer is released far less frequently than ruby patches.
But the installer itself is still in development, I'm sure once the installer is considered stable, then Ruby patches will come faster.
MacPorts is the devil. [Homebrew](http://github.com/mxcl/homebrew). You'll never look back.
why lovedbyless and not communityengine? 
I used to use exerb 6 years ago. I don't remember the first step of the process. It used to create .exr files. It kind of looks like .exy files are created now instead. Once created, the exerb command looked something like this: exerb -o &lt;DesiredExecutableFilename&gt; &lt;filename.exr(or y) created in step 1&gt; I really worked great back then. However, I lost the need for creating executables and I haven't revisited it since.
Here's a link to using exerb 4.2.0 - the same one as listed above: http://lylejohnson.name/blog/2008/12/30/building-standalone-fxruby-applications-with-exerb/ I couldn't get it to work, possibly because I don't have a mingw installation of Ruby on my Windows machine. Hope it works out for you.
I have never understood what people have against MacPorts. I've been using it for over 2 years without any issues, aside from a couple ports that don't compile on Snow Leopard (`ghc`, I'm looking at you).
What really? I thought you were joking when I read your headline. If you're serious, please check out the basics of [Functional Programming](http://en.wikipedia.org/wiki/Functional_programming). 
doh! lovdbyless. I'm not sure that this is a thing that worth to mention. Even communityengine is not good enough when you look inside. I've ended up with writing my own social network. Where are Redmine?
Is it being judgmental to distrust a Ruby library whose example code looks like this: puts "Checking: " + item.url.to_s if(item.content =~ /www.wrong.com/)then item.content = item.content.gsub(/www.wrong.com/,"www.right.com") puts "Updated: " + item.url.to_s end
A big benefit of homebrew, IMO, is that it's drop dead simple to create or update a formula and maintain your own collection of formulas. Homebrew is also much more lightweight in general. In addition, macports duplicates stuff you already have on your system.
Using regexps with static strings always feels wrong to me.
It's pretty easy to create a new Portfile (and maintain your own set of Portfiles) in MacPorts, too. And there *is* a [reason](http://trac.macports.org/wiki/FAQ#ownlibs) MacPorts duplicates some libraries.
You might want to consider redirecting your mistrust into helpful patches that show the author the idiomatic Ruby style.
Suddenly I realized why it makes sense to have gsub! return self when it replaces something and nil when not: if item.content.gsub!("www.wrong.com", "www.right.com") puts "Updated: " + item.url.to_s end
Problems of MacPorts: * Compilation is slow. Try compiling LLVM or ImageMagick - takes forever. I know this is not strictly MacPorts's fault but come on, this is OS X where everybody else distributes software with binaries, so why not open source software? Backward ABI breakages don't happen *that* often in OS X land. * Ignores software bundled with OS X. For example 'port install some-ruby-library' will happily install its own version of Ruby and ignore the one in /usr, and you end up with *two* Ruby installations which can be confusing for a lot of people. Of course, this can be seen as an advantage if you want to have a newer version than the one OS X bundles. * It seems to have no notion of architecture. The Leopard -&gt; Snow Leopard upgrade completely broke MacPorts; even the 'port' command didn't work anymore, forcing me to reinstall MacPorts. If you think a 'port upgrade outdated' solved the problem after that, think again; that command only upgrades ports for which there's a newer version available. I migrated to Snow Leopard about half a year ago, but a month ago I found out that git-svn doesn't work anymore. Reinstalled git-svn -&gt; still doesn't work. After spending a whole day digging for the problem, it turned out that Perl is still at i386, while the Perl libraries that git-svn depends on have been upgraded to x86_64.
Also, the Homebrew theme for Terminal is awesome.
Ruby's BEGIN and END are identical to Perl's, and are mostly useful when writing stream processors to be called with -n. For example, this will print the sum of all numbers entered at STDIN (newline-separated): ruby -ne 'BEGIN { $a = 0 }; $a += $_.to_i; END { puts $a }' Because the main code is called once *per line* when you're using -n, BEGIN and END are then special because they're only executed once.
Ah, well there's the useful use I was missing. That'll teach me for never learning perl or awk, I guess. Thanks!
I don't get how this works :/
Before I read your comment I thought it would make it easy to emulate [awk](http://www.gnu.org/manual/gawk/html_node/Using-BEGIN_002fEND.html) with ruby. I'm not sure which came first, however, awk or ruby. EDIT: Oops. s/ruby/perl/ in that last sentence.
`awk` certainly came first, and yes, BEGIN and END do have the same meaning there as in Perl and Ruby.
Awk, surprisingly, predates ruby by a whopping 18 years. 
Argh. I mistyped.
Yes, I edited my post to point out my dumb mistake. When you're rubying for 10 hours straight it's the first word to pop into your ruby.
In that case: Awk: 1977; Perl: 1987; Ruby: 1995 I'm a little blown away by how old awk is.
Homebrew *just builds*. The whole thing is dead simple. No sudo too, which I like. MacPorts just makes a mess of everything- I don't know squat about C programming and compiling but I know I like to keep my mac clean.
The sigil is to make `$a` a global - without it, `a` is initialised only inside the BEGIN scope. As far as `$_` goes, I'm not sure if there's a different name for the 'default' variable in ruby - if anyone knows, please enlighten me. For the awk version, by the way, you don't need to initialise `t` - awk auto-initializes variables to blank/zero, so you can golf that down another smidge to awk '{ t += $1 } END { print t }'
Ed: 1971; Emacs: 1976 To be fair, '71 was when Unix was invented. So you really can't get earlier than that on a Unix system. Lisp, on the other hand... first compiler: 1962
You can address the scoping by not bothering with the BEGIN: ruby -ne 'n ||= 0; n += $_.to_i; END { puts n }' Shorter and a bit more readable imo.
This was in awk before perl, kids. :) And awk was the bomb before perl was the bomb.
I use the library to do PROPPATCH and PROPFIND on files and folders (collections). We have a content management system that uses that as a API for setting things like publish date on documents. Basic search and replace on html on WebDAV servers is probably easier to do by mounting the web server as a local file system first. (Magnus: takk for tipset!)
Pfft, the kids nowadays. Don't even know what awk is.
In what way does it make a mess? (I'm not trying to be a pain in the ass, I'm seriously interested -- I've seen people make vague allusions to the "awfulness" of MacPorts, but two years running I still haven't seen any major issues with it in my own use, so I have no idea what anyone else is talking about.)
Re: the last point, the MacPorts documentation does state that if you upgrade your OS or move to a new architecture, you should reinstall all MacPorts and all your ports. It's annoying and assuming Homebrew avoids an OS version/architecture dependency then that's certainly a +1 for Homebrew, but MacPorts made a different design decision (build ports for a specific architecture instead of universal, etc.) and the documentation notes this in its migration steps.
Were you doing drugs?
Well, at least Rails is smart enough to actually create that method for you upon first invocation so the subsequent calls will bypass method_missing. 
Yeah just seeing that now. I originally took a quick look through the code on github :) BTW here's some benchmarks from another article posted here on Reddit http://blog.nofail.de/2010/01/savon-vs-handsoap-benchmark/ ...which I just noticed was posted by you.
Looks like this answers your question from the other posting on Savon.
Did you originally code it to do lookups on users before you had proper authentication in place? I could see doing something like that if you were quickly refactoring after implementing authentication (where you get current_user). Reminds me of: def good @user.valid? ? true : false end
Doh! Missed the completely unnecessary lookup.
I've written code like this :-) The terrible thing is, when I find code like this other people have written, I get all paranoid that it might actually be this way for a reason. What if `current_user` isn't a user model? Maybe it's just a placeholder object constructed from a form or some such, I have to hunt it down and see. Likewise, this seems to imply that the tuple `(first_name, last_name)` is unique in the `users` table. Is there a validation to this effect? I have to look that up and see. It might take me an hour to perform the obvious fix if I'm not sure why it was written this way...
The issue I have with Macports is that it re-creates an entire BSD subsystem when I install something mildly complext without even prompting me. Having newer, unexpected, binaries in my path makes for some real head bangers when you are trying to deal with something that's not in Macports. I understand _why_ they do it - it makes it easier to write the ports. It's just a pill I'm not willing to swallow.
[Permalink](http://yehudakatz.com/2010/02/07/the-building-blocks-of-ruby/)
current\_user is often a method from the restful_authentication plugin.
&gt; ...which I just noticed was posted by you. hehe .. it's a little late on the week for a case of the Mooondays, is it? ;)
Close. Originally, I had separate User and Agent models and so I was looking up the agent that would match the current user. Since then I've refactored Agents to be Users and just did a blind update of the code to work during the refactor. Fortunately, I'm the sole developer and so I only get to embarrass myself.
Fortunately the code was only about 2 months old, so I didn't have to try and figure out what I was thinking. I knew immediately that it was redundant.
http://greg.agiletortoise.com/2006/08/23/set-base-path-for-rails-app/
The method xiaomai linked to ought to work, optionally I've used the --prefix option to mongrel_rails to do this too. I think the syntax is: mongrel_rails start --prefix '/foo'
I went with this method. Works great, thanks!
Pardon my ignorance, but how is this any different than "rake rails:freeze:gems"? 
The duplicates annoy me, obscure directories plus it's pretty slow. I've had dependencies fail too. I ditched it and started googling for (Snow) Leopard manual build recipes and just copy-pasted from there, but that's exactly what brew is- a repo of build recipes, and keeps it all in /usr/local/.
 validates_uniqueness_of :birth_date
&gt; The terrible thing is, when I find code like this other people have written, I get all paranoid that it might actually be this way for a reason. This is the type of thing that unit tests should help you avoid. Do you bother with unit tests? EDIT: just want to clarify, I had a long day at work and the tone of that might have sounded off.. I'm genuinely interested if you use unit tests and how they fail in this situation.
:D
I'm pretty sure reg writes [unit tests](http://weblog.raganwald.com/archives/2004_07_01_archive.html), probably in [Smalltalk](http://weblog.raganwald.com/2006/08/causality-or-correlation.html), translated by [lisp macros](http://weblog.raganwald.com/2006/11/significance-of-meta-circular_22.html) into some [lazyly evaluated functional form](http://weblog.raganwald.com/2007/02/haskell-ruby-and-infinity.html). But I could be wrong.
and the point :P
I can think of one reason you might want to use begin. You can put all your function definitions, class definitions etc in a being block at the end of your file so the start of your file contains the logic. It might be useful in those circumstances where you only want to send somebody one file instead of many.
Take a look at &lt;RAILS_ROOT&gt;/config/routes.rb
looks worse.. prolly beating a deadline?
All wrapped up in a [Mouse Trap Architecture](http://weblog.raganwald.com/2008/02/mouse-trap.html)!
Install this gem/plugin: http://github.com/shuber/proxy
This was obviously by intent and is meant to watch out for sneaky sales agents who change their first and/or last name to try to confuse your sale distribution's quotas! Works as designed! next.. 
I might be wrong about this, but i feel this kind of specific question is more appropriate for a site like http://www.stackoverflow.com than the ruby reddit
Cool interview with a member of the Rails Core team.
I was expecting it to circle back to Newbie programmer at the end. :)
http://www.luschny.de/math/factorial/FastFactorialFunctions.htm
Also fun is using a hash for a self-memoizing factorial: FACTORIALS = Hash.new { |h, k| h[k] = k == 0 ? 1 : k * FACTORIALS[k - 1] }
aka dynamic programming. great stuff.
That would just be too easy ;)
sudo gem install factorial
So . . . how does this fit into the progression? @values = [1] def fac(n) @values[n] ||= n * fac(n - 1) end It's a little slower than an iterative, but I think it's pretty.
You can do AJAX calls to sinatra just as easily as you do with other backends. I do that myself with a post to a sinatra backend. After all, AJAX is simply an asynchronous http request to the originating server.
Lambdas, blocks, procs, and methods. They're all the same thing: chunks of code, stored for later use. You use methods when you want to store code in your classes or modules. You use blocks when you want to store arbitrary code inside the method you are passing the block to. You use procs and lambdas when you need to store code in any other setting. Such as "has_many :foos, :if =&gt; proc { ... }", where neither a method or a block fits.
You can do a number of things: get '/:template' do haml params[:template] end And call `/?template=abc` (If you don't mind having query parameters) Or you can go for something more advanced like returning HTML or JSON from a Sinatra route: get '/' do haml :index end get '/some_route' do haml :partial end And call /some_route with an asynchronous JS request, replacing a known DOM element with the response. jQuery: $.get('/some_route', function(data) { $("#destination").html(data) }
Share more if you've got them. I came up with a few more last night, like: # Read a book on Clojure (def apply (o, s) (s.inject { |v, m| (m.send o, v) }) end) (def range (f, t) (Range.new f, t) end) (def n! x (apply :*, (range 1, x)) end) (puts (n! 6))
My standard interview question is to implement factorial in any language. People who do it recursively usually get it right. People who try to do it in a loop usually don't. Never seen anybody use any of these slick tricks in Ruby, even inject. Not as many people favor the trio of map (collect,mapcar), filter (select,remove-if-not,grep), reduce (inject,fold) as you might think. Passing inject a symbol was new to me. Anyone know why irb treats puts :hello differently from puts :+
This is exactly what I needed to get away from Selenium! Great job!
 #!/usr/bin/env python def fact(x): i = 1 for j in xrange(2, x+1): i *= j return i Seems to work properly for me. Even gets fact(0) correct.
Amen. Couldn't have put it better myself.
[awkisms in perl or ruby](http://hyperpolyglot.wikidot.com/awk) 
I especially like running sudo as root. extra protection, ya know...
How many of you have accidentally created an app named "console"?
Why does Nokogiri install for me? I must be doing it wrong :(
I typed that out but then saw the submitter didn't want to change urls. I didn't know what exactly that meant with respect to your example and query parameters.
Sounds like you don't have libxml2 installed.
Yup. Tell me about it. Its like the RMagick gem. It practically never installs without a fuss. 
Well, I'll take Nokogiri's XPath and XML support over Hpricot any day. Hpricot does decent HTML and CSS, but it's just not an XML parser.
I'll take PEBKAC for $100, Alex.
This is exactly what I needed to start testing JavaScript!
Thanks, I needed something to get my first basic eventmachine stuff running :) [w00t](http://gist.github.com/303535) require "rubygems" require "eventmachine" require 'em-http' class Tester def crawl(url) EM.run do http = EM::HttpRequest.new(url.to_s).get http.callback { puts http.response[/\\d* so far/] EM.stop } end end end bla =Tester.new loop do bla.crawl("http://global-count.heroku.com/") end
Worked fine for me on OS X 10.6.2. Your failure to install the gem != Nokogiri blowing ass Read some of the rest of this asshat's posts, and it's abundantly clear he's a hot-head that shouts off his mouth anytime he's encountered a minor inconvenience, either due to a real problem, or his own ignorance.
I actually kind of agree... but I'm not some ignorant troll going off half-cocked about it. I much prefer to use the libxml parser directly, a real and widely used C library that is very efficient. It can be on the order of 100 times faster than a pure Ruby implementation (like hpricot) and has a very nice API already. Nokogiri is also built on libxml, and the reason the parent is having trouble is that he forgot to install the libxml2-dev package. In short (IMHO, YMMV, etc)... hpricot &lt; nokogiri &lt; libxml.
Curious... could you show some examples? I can only imagine that things are a LOT more expressive (and, I'm guessing, safer too) in nokogiri over libxml.
I've never had a problem installing nokogiri. Granted, the reason for the install failure could be clearer; it doesn't really rely on a lot. Besides, who doesn't have libxml on their system already?
 def self.fac(n) That's a good place to be explicit about who self is. If you define that in a class/module it won't behave as you expect, since the @var will be defined on the class (current self in the class definition) while the method will be defined for instances of the class, and thus @values will be nil and throw an error when you call #fac.
Ok, a little rant from my side: I really don't get why people actually write that kind of sh*t. Yes, somebody had a good time porting squeak to Android. This doesn't change the fact that it is of no practical use what so ever... It's like people installing android on netbooks and a lot of sites going crazy about it. Android is just a flavor of linux with some custom libraries and UI layer. Once Ruby actually is "officially" supported or even SOMEHOW practical to use (good native UI bindings, good execution speed), start writing stuff. Before that: don't. You're breaking my balls here... breaking my balls... p.s. I didn't mean to, in any way, diminish the work people have put into those projects. In fact, they are fun projects and interesting from a technical standpoint. What I hate are sensationalist headlines and crappy speculations.
Just a side note, but if you have a route to `"/:foo/:bar"` you don't need to access it via the `params` hash: get "/:foo/:bar" do |foo, bar| "#{foo} #{bar}" end And then GET /hello/world will result in "hello world". (These parameters are positional, however, not named, but for simple routes it usually does the trick just fine)
What I wrote was just a top-level function. Why build an entire class just for a toy factorial method? That'd be over-engineering.
&gt; Anyone know why irb treats &gt; &gt; puts :hello &gt; &gt; differently from &gt; &gt; puts :+ I suspect it has something to do with the fact that the plus sign is an operator. If you want it to think of the + as a symbol, you have to do the same thing you'd do with a symbol that has spaces in it -- wrap it in quotes. :ren@guilt:~&gt; irb irb(main):001:0&gt; puts :'+' + =&gt; nil irb(main):002:0&gt; puts :'Four Score and Seven Years Ago' Four Score and Seven Years Ago =&gt; nil That sort of thing.
Apparently, you aren't one of the people applying for a job wherever `cgrubb` works. edit: Also, that looks like exactly the same algorithm as in the second example ("Discovered #upto") from the "Evolution of a Ruby Programmer" thing, except with `xrange` instead of `#upto`.
Yeah, that's what I thought after seeing the page.
"Nokogiri is crap because I can't install it!" What an epic, epic fail.
what did you expect from a rails programmer? 
from his resume: "TECHNICAL SKILLS Ruby, Rails, Rspec, jQuery, some Subversion and git, PHP, MySQL, HTML, CSS, some Linux, Photoshop" some linux indeed... anyways his entire blog is comedy gold
Ugh, don't use the Timeout class in Ruby.
Why not?
yeah, why not? this is the latest timeout code: http://gist.github.com/305141 it used to have issues since Error was subclassing Interrupt (so it was not very standard) but doesn't anymore... and ruby 1.9's native thread system should fix any threading issues it had with the MRI scheduler
Yes it is probably fixed in Ruby1.9. However for 1.8 I was sure I also had some concerns about it previously because if you are blocking on a syscall like read() ruby1.8's green threads never switch context back to trigger the timeout code. There was another library the provided a good timeout that was based on signals.
SystemTimer http://ph7spot.com/musings/system-timer But, really, it’s time to move to 1.9
I am on 1.9 now for my latest two projects. I hope everyone can transition soon. I haven't been having any real problems lately with 1.9 although I had lots of issues in the past with incompatible gems, but that has improved over time.
Katz is good. He always makes good posts.
It took me two scans through the code to notice the redundancy. At first I thought the silliness was that you can only find by one field, i.e. find\_by\_field vs find\_by\_field1**\_and\_field2 Not my fault though. C# is my new toy.
Moonshine is really cool. Makes getting up and running SUPER easy.
See the discussion over on proggit http://www.reddit.com/r/programming/comments/b2s83/the_new_ruby_haskell_interop_package_hubris_and/
Why is it that there is not one rails CMS that is anywhere near drupal, modx, joomla or any of the hundreds of PHP based ones? 
Lots of bugs with BrowserCMS. It also doesn't look good that there are no screenshots on that site. 
I guess they're not big fans of constantly reinventing the wheel like PHP developers are.
High quality, open source design isn't as rare as you think it is. People do it all the time. High quality, **free** design work is what you're having trouble getting. Peruse one of the MANY stock vector and template sites, and you'll often see that when you *purchase* something, you get the original PSD or vector along with it. See, the part about it being the *original layered graphics file* is the *open source* part. Open Source != FREE, so let's call a spade a spade and not mince words. The project is looking for high quality designers who will do work for free. Fair enough? Don't get me wrong, the project looks like a great idea, and seems to have somewhat of a community of developers and users around it. I hope to keep my eye on this and see it grow. Below is some additional information that might help sell the deal: It might help to post some the link to the project itself: http://radiantcms.org/overview/ Explain what is different about this CMS: * It's ruby * It's rails * MIT Licensed It also might help to note that it isn't just "design" they're looking for (whatever that is supposed to mean): * Development (html, css, js) * Graphics (Fireworks PNG provided to start) * Extension development * Marketing * Anything else you feel you can offer No matter your passion, I see plenty of opportunities to help with this project. Also, this project, like any open source project, has leadership that must approve your changes, so just keep that in mind if you're new to open source. There is a documented process for forking, making changes, submitting changes, and getting them implemented in the master. All on the website.
Refinery CMS is pretty badass.
There is a difference between *writing a method that implements a function over first-class entities* and *functions being first-class entities*. I think this post does a good job of showing the former but alas, says nothing of the latter.
Hm, neat point there! Thanks for bringing it up :)
I look forward to the next post, this one was good. I especially liked showing a progression of versions to the code. Thanks!
That's false. There are lots of rails CMS's but they all lack a lot of features.
Refinery is OK but come on it's nowhere near drupal or joomla.
I can tell a lot more practical functional tricks: # currying (1.9 only) plus4 = :+.to_proc.curry[4] # function as object (1.9 or 1.8 with activerecord) xs = [' a ', ' b ', ' c '] xs.each &amp;:strip! # a short hand for "&amp;:strip!.to_proc" # pattern matching x, *xs = ['a', 'b', 'c'] # pattern matching in proc params (1.9 only) # 1*2 + 3*4 + 5*6 + ... (1..100).to_a.each_slice(2).inject(0) do |sum, (a, b)| sum + a*b end and everything is a Maybe Monad ...
Sammy is almost Sinatra but in JavaScript. It might do what you want: http://code.quirkey.com/sammy/
Thanks for the kind words :)
:)) Wow, really nice, thanks!
Now combine that with http://www.reddit.com/r/programming/comments/b43ok/currency_arbitrage_in_100_lines_of_ruby/
I use Prgmr.com for my VPS. They are excellent, but they have a waiting list a lot of the time since they run out of space on the servers they have. Luckily, I've never run into the waiting list, so I can't say how long it typically is. Webbynode is also excellent. I'd give them a shot as well. As far as cloud hosting, I've only used Rackspace's Cloud. I can say their support is excellent and it was smooth for me when I tried them. As you said in the article, shared hosting is not the way to go and I agree wholeheartedly.
I always wanted to go with Prgmr.com due to their large RAM allocation. Unfortunately, every time I tried, they were fully booked.
Any experience with http://www.asmallorange.com? They were one of the early RoR hosts (and they advertise on reddit).
No direct experiences. Anything I've read about them is positive though.
Thanks 
I like Linode so far. They have been serving me pretty well for the short time I've been trying them out (1.5 months). My rails site is a bit of a side project, so nothing serious yet. VPS is nice, though, since I have control of what can get installed, plus I can reboot it or even wipe it clean and start over if I screw up too badly. Hard to beat $20/month either.
It's also not a grape. If one idiot says it is, it's probably not worth the trouble to point out that they are wrong.
it tastes just like raisins!
heroku?
expensive.
They are expensive, but they're not THAT expensive. Additionally, it's one less thing to worry about... setting up and maintaining servers can be difficult if you're a small team.
Mention at the end of the slides: http://timetobleed.com/memprof-a-ruby-level-memory-profiler/ memprof, a ruby gem to help you find memory leaks.
I continue to hold hope that _why will come back. Maybe in another guise but it will be easy to tell because he is so unique.
 %w( tribute to _why ).map(&amp;:to_sym)
That is less poetic. &gt; Poetry (from the Greek "ποίησις", poiesis, a "making") is a form of literary art in which language is used for its aesthetic and evocative qualities in addition to, or in lieu of, its apparent meaning. [Wikipedia](http://en.wikipedia.org/wiki/Poetry)
Other report of successful conversion to Nokogiri: http://kete.lighthouseapp.com/projects/14288/tickets/177-tags-list-rss-feed-increasingly-slower
don't get it...
good poetry is also marked by concision and economy of expression :)
I too, eagerly awake the second coming of _why.
Sure, if you want it to _not_ look like a flying saucer.
It's proof that you can write unmaintainable and ugly code in Ruby too. Throwing away some (all?) of the unnecessary code in the snippet and then formatting it properly yields: def dsl(&amp;block) klass = Class.new do def method_missing(method,*throw_away) @methods=[method,*@methods] end end klass.new.instance_exec(&amp;block) end p dsl { tribute to _why } My Ruby-Fu isn't that great but this yields the exact same results and is a bit more obvious as to what is actually happening. So a new class is being created which when called with any method adds the method name to a list and returns it. The rest is to just support the use of the block calling syntax. It seems to me that the fact that it appends nil every time looks like a bug. It's easy to fix though, just call `compact` on the array in `method_missing`
Considering the way he exited the Ruby community, I wouldn't trust him if he did. 
How was that? I used to be pretty active on the ruby list, but I've been off it for a while.
Basically, he deleted all of his presence, websites, and all his code repositories all at once. Third paragraph of [http://en.wikipedia.org/wiki/Why\_the\_lucky\_stiff](http://en.wikipedia.org/wiki/Why_the_lucky_stiff)
Wow, seriously fucked up. He always was a bit odd though, but he created some great stuff. Good to see that it has survived. Genius borders on insanity, perhaps he finally crossed the border.
I think a more _whysian way of getting rid of the "nil bug" might be: (@methods||=[]).unshift(method)
Why? (No pun intended) I think that `@methods=[method,*@methods].compact` is more _obvious_.
I was trying to find this post to show a coworker of mine and kept searching for nokogiri, thinking it must be in the title. Give me the last 10 minutes of my life back! :)
Oddly enough, that's what I had in a [slightly earlier version](https://gist.github.com/311734/2dcd34ee9549cb72b398b30f30485a6df1bb65ca). I only tried it in 1.9.1, where [*nil] is []. It's [nil] in 1.8.7. ~ ✖ ❶ ▸ ruby ~/why.rb [:tribute, :to, :_why] ~ ✖ ❶ ▸ rvm use 1.8.7 ~ ✖ ❼ ▸ ruby ~/why.rb [:tribute, :to, :_why, nil].
_why wasn't exactly known for being "[obvious](http://github.com/camping/camping/blob/master/lib/camping.rb)".
I had only ever heard of camping.rb, never looked at it. Wow. You win the thread.
That'd explain it, I'm using 1.8.7 here.
The Iliad contains approximately 15,700 lines... The Odyssey was written in [...] 12,110 lines of dactylic hexameter. 
I really hope that's him (looks like him). I don't particularly care what he's doing, just hope he's having fun.
if you guys are interested in a pure ruby PNP processing library, check out http://github.com/aberant/spittle . we created it to generate CSS sprites for websites, so it parses, saves, and combines PNG images while generating the CSS for you.
How many tests is that? What's the coverage?
Google translate: &gt; The Endo. &gt; &gt; Just now, trunk (1.9.2dev) RubySpec is all the spec's path. &gt; &gt; Release of 1.9.2, Yugui Mr. [ruby-core: 25707] in "RubySpec the &gt; Ah, I should not do to release the path "since the declaration and the sluggish I think. &gt; &gt; Yugui Hey, Could you resume the release schedule. &gt; &gt; &gt; But a sort of path, the problem is still there. Of 1.9 feature &gt; spec or are insufficient, the matter of the spec and implementing regulations as they are written, &gt; The only supported platform for Debian / lenny on IA32 with a non-error &gt; And then hammering on. In addition, Ruby is so even where the need &gt; to reconsider in &gt; Okay. Let's go little by little doing. &gt; &gt; Still, for the release of 1.9.2 I think it is more than enough results. &gt; &gt; &gt; Thanks to all of the following: &gt; &gt; - Rubyspec people (especially Brian Ford is me playing various) &gt; &gt; - Core team of people (M17N and could not fix Naruse relationship &gt; I think. Said Lee after his great contributions) &gt; &gt; - Brothers and maintainer (gave full answers to detailed questions.) &gt; &gt; - 1.9 rubyspec old who was doing a response (akasaka.rb relations &gt; People, Marc-Andre Lafortune, Run Paint Run Run, Vladimir Sizikov, &gt; ujihisa their friends) &gt; &gt; Sorry if you're very overlooked.
I take it you are talking about PBX, PSTN, FXO, FXS etc? Some such as ATA are needed since that is there most common name. I could just ignore the whole FXO/FXS port thing since through this series I plan on only using a VoIP gateway. VoIP is kinda needed to since it is kinda what the talk is about. But yes when I re-read it does get to be a bit much.
I see you are using FreeSWITCH. You might be interested in [librevox](http://github.com/ichverstehe/librevox), a Ruby library I wrote, which talks with FreeSWITCH via the event socket. Telephone isn't capable enough in my opinion, but [Blink](http://icanblink.com/) is a nice open-source alternative for OS X.
I hadn't seen blink before. It looks really good I will be trying it out. I am interested in your librevox gem actually. The next article will talk about using mod\_xml\_curl to interact directly with freeSWITCH. But in the article on PhrkML I will be talking about a open simple XML language, similar to Twilio, to build VoIP apps. Right now I am using haskell to connect PhrkML to FreeSWITCH over event socket. Before write about PhrkML at all I want to release a ruby implementation and will very likely use your librevox gem. :)
Neat. I also have some ideas for making a Ruby library which can generate the dialplan XML, to be combined with [mod xml curl](http://wiki.freeswitch.org/wiki/Xml_curl). If you have any questions or want to discuss something, feel free to drop by #librevox @ irc.freenode.net.
Yes we need to brainstorm at some point. I am following you and librevox on github now so I will ping you when I get ready to do the phrk gem.
There. I updated the post and tried to cut out all the extra information. It is hard to give even an intro to VoIP in a single post. There is a lot of stuff :p. Anyway let me know if that looks better.
http://www.ruby-forum.com/topic/204850#new
http://rubyspec.org/
What was so wrong with freeswitcher?
And you still can't get a stable installer over version 1.8.6 for Windows. 
Nothing per se, but I wanted to take a different path on a number of central issues, and since I am relying heavily on this piece of software in my business, I decided to make a fork, rather than trying to fit in. I have some neat additions planned for the future, though.
I did this years ago in png.rb... not sure why it needed to be redone.
I'm the opposite. I feel always drawn back to Netbeans for whatever reason. I'm using it for Python right now and quite like it too. 
Just an unimportant note (I haven't gone through the presentation, even). From the pictured slide: void func() { char *stack = "hello"; char *heap = malloc(6); strncpy(heap, "world", 5); free(heap); } This doesn't actually put any characters on the stack. It's roughly the same as: char global_hello[6] = "hello"; void func() { char *stack = &amp;global_hello[0]; char *heap = malloc(6); strncpy(heap, "world", 5); free(heap); } You'd need to declare an array instead of a pointer to put the characters themselves on the stack.
Wrong. 
Okay where can I find a stable windows-based installer, that gives you everthing for 1.8.7 and preferrably 1.9.1? http://www.ruby-lang.org/en/downloads/ Everything at http://www.rubyinstaller.org is a release candidate or a beta, hence the key term, 'stable'. So instead of just saying I'm wrong, how about you maybe provide some insightful or helpful feedback. 
The stuff at rubyinstaller works very well. It's all I use. It is stable, despite its "RC" label. Hence "wrong".
The RC label does matter very much at the Enterprise level. I don't care what you use when you're coding for fun or on your own. But there are policies at many corporations prohibiting the use of betas/RCs/etc. Therefore, I was explicitly looking for a release officially labeled as such. Not something that seems stable to random internet guy who uses it. That is why, you know, at the official Ruby site there are releases officially classified as 'stable'. I'm not using 'stable' as a simple adjective, it's more of a classification. So, therefore, I'm not wrong, because there isn't a release officially labeled as 'stable'. 
Great book.
Ok I'll let you not be wrong. This time.
This helped me. I am new to RoR. I was writing: @user = current_user @post.user_id = @user.id Instead of: @post.user_id = current_user.id So.. thanks for posting!
* Not as much crashing. TM crashes on me not uncommonly. Bout every day or two of work * Better code folding algorithm. The current one only does single line matching. It's impossible to get solid python code folding this way (and is pretty inflexible) * Better project management. The Project+ plugin is ok, but there's solid room for improvement natively. * Fix the menu searching. Textmate reliable crashes if you execute commands from the help menu search, so they've disabled this hot key. Allen says this is "a bug with cocoa", but Textmate is the *only* application I've ever used that manifests it. So even if it is a bug, there must be a pretty consistent and well known fix for it. * Some sort of intellisense/code completion. At least for the most common languages: C/C++, Objc, ruby, python. * Fix the way TextMate scans files every time it gains focus. Cache it, optimize it, background it, something I could go on. There's *always* room for improvement. Some of these features are implemented in plugins in some form or another. But they are often 1/2 ass or only partial. Also, you expect a different level of stability and support when a feature is native. You're never sure if a plugin developer is going to get busy with paid work and drop or lag on support. Sure it's extendible, so I could probably introduce and maintain plugins to do this. However, when I pay for an editor I'm not looking for an Editor Developer Project...I'm looking to develop my projects with the editor. Deadlines and all that.
Textmate 2.0 exhibits all the signs of vaporware.
Although it makes me sad to think about using rails on oracle and tomcat he does have a good point. Sometimes in the corporate world you are stuck with what you have. That shouldn't keep them from playing with the fun tools like rails. 
Figured I would post this, since Hobo finally hit 1.0. Awesome little framework that makes it dirt simple to prototype a site within days, and then not much more work to make it look pretty. Fairly well tested, and very active community. The only downfall is it's a bit of a learning curve because they use their own templating system (DRYML) and it takes some time to learn it.
The dryml thing strikes me as being a bit over the top too. The rest of it is really impressive though.
Yea, DRYML can be a bit odd at times. Until you really understand how it works it's a good bit limiting. However, the concept is sound "This is designed to be as dry as possible".
&gt; This is designed to be as dry as possible Well .. Most projects have that as a stated goal.
But rails is a web application builder?
How is this different than the Sinatra book on Sinatra's own website? http://www.sinatrarb.com/book.html
I don't undserstand why the designers of the language didn't add a finalize/destroy method to object. Such a simple thing and so useful. 
I hated the day I made this same discovery.
I really like the migrations generator. Can that be used separately?
I originally commented that you could not. I was wrong, so I removed the comment so as to not confuse everyone. http://cookbook.hobocentral.net/manual/hobofields is a link to the manual for the plugin that does the migrations (And you don't need Hobo to use it).
Awesome. I really liked that but am not crazy about all the rest.
even if finalizers are configured properly they're not necessarily going to plug a leak in your app. This is because finalizers are only called after an object is GC'd, but an object is only GC'd if used memory is above a certain threshold. but the size of the native resource is not factored into the calculation of 'used memory', so it's possible that hundreds of images of large size have gone out of scope, but they're still laying around in memory for a long time
Yeah, looks like just different style to me. Truth be told, I kind of like this one better. I like whitespace for many types of pages, technical reference or introductions, not so much.
My erector doesn't get enough attention either.
But I always lose that little damn wrench and end up using pliers to tighten all the nuts, which just ends up eating them up.
Dude... go over to heroku.com, sign up, and be done. It's pretty much that easy.
I guess that is what I needed to hear. It really was that easy! I'm such a noob. Thanks for that...
Ehm, no. It's faster than Markaby, Tagz and Nokogiri's HTML builder, but you're doing something wrong if ERB and Haml is slower for you. But, yeah. It's an excellent library!
Unfortunately, it doesn't make much sense in a garbage collected environment. The whole point of a garbage collection is to remove programmatic interaction with memory clean up. The reason why finalizers caught on is because in non-GC environments you had to cleanup yourself and is synchronous. The cleanup was made generic as an interface and thus any object cleaned up would have finalized called on it. This caused two separate issues to be tied implicitly together: memory reclamation and resource deallocation. In a GC environment, memory reclamation is asynchronous but in most programs resource deallocation still expected to be synchronous. So, you can use a "finalizer", but you have to define it and you have to manage the resource synchronously to the needs of your program just like any non-GC environment. The finalizer in a GC-environment is really just "last chance" code check to make sure an external resource has been freed if it hasn't already.
Where can I find the benchmarks against Markaby, Tagz, and Nokogiri? I don't see them tested in the [erector-benchmark project](http://github.com/alexch/erector-benchmark). All I see in there is ERb and HAML.
Heroku is great. 
I guess they were going to call it Viagra, but that kept getting spam filtered. 
I have some in [Parkaby](http://github.com/judofyr/parkaby): Markaby 13.250000 0.140000 13.390000 ( 13.631889) Erector 2.490000 0.060000 2.550000 ( 2.547752) Nokogiri 4.540000 0.090000 4.630000 ( 4.636510) Tagz 3.590000 0.120000 3.710000 ( 3.715065) 
Except for the fact that sometime around the 0.5.X revision they made a few major revisions to the public API. That to me is a big no-no. It caused a lot of headache for us to move forward to make the switch over. 
&gt;Unfortunately, it doesn't make much sense in a garbage collected environment. I disagree. There may be many things you want to cleanup not just the destructions of in memory objects. 
so is parkaby faster than erector? Also is parkaby more of a replacement for erb? Erector seems to be a new way of doing your app using inheritance rather than partials and such.
Yeah, [Parkaby is almost as fast as Haml](http://judofyr.net/posts/parkaby.html). Parkaby is really a replacement for Markaby (which could be used as a replacement for ERB). I haven't had time to see how Erector works (other than it's fast), but I guess I should take a look :-) Oh, and Parkaby is currently on hold, since I'll have to introduce some new projects in order to make it work on all implementations. Parkaby is mostly just an experiment, so don't take it too seriously. 
heroku gets expensive pretty quick though.
Seems awfully verbose. I love Haml specifically because it gets my views done in significantly less typing than the alternatives.
That is what I did not want to hear... I've heard this echoed by a few other people too. I haven't given any billing info yet, so hopefully I am safe.
It's free for a single dyno with up to 5MB on the database. If all you're doing is your blog, you should be fine for now; it's a great sandbox for that kind of thing. You'll know if it costs. You'd either have added a paid addon, or cranked dynos/workers up.
&gt;but you're doing something wrong if ERB and Haml is slower for you. According to their benchmarks it's faster. This is because its ruby and rails pre-loads it instead of processing templates.
The [erector-benchmark](http://github.com/alexch/erector-benchmark) sucks: * It uses Tilt, which currently implements ERBTemplate with instance\_eval, while in 95% of the cases you can solve it with an eval+def. [This simple](http://github.com/judofyr/parkaby/blob/master/bench/simple.erb) template was over 8 times faster with eval+def than instance\_eval. * It also involves ab, Sinatra and Thin, without taking care of issues like when garbage collection happens, the difference of route lookups and if Thin behaves different after being warmed up.
I was a MongoHQ beta tester but since I always keep MongoDB running on one of my own servers, I did not use my account much but I thought that they implemented very well. Their pricing does seem a bit high, but then spending some money every month to save labor time can often make sense.
Why is this post in a ruby subreddit? As far as I can tell it has nothing to do with ruby.
 def f ... end def g ... end def h ... end def f_g_h_are_used_out_so_use_this_instead ... end
Fair point, and my bad.
$25/mo for a 2GB database just doesn't cut it for me.
While it's not Ruby, as a Rubyist I enjoyed it, and that's what a subreddit is for :-)
A lot of the attraction of Mongo over MySQL et al is that it requires less labor to maintain and scale. It seems like a hard sell at the moment.
It's written by japanese people. They have a much, much more extensive history with encodings than anyone who speaks english. It's a terrible idea to only support UTF8, like python, because you end up pissing off all of east asia.
Someone obviously missed the big announcment on the rationale behind 1.9's m17n instead of just forcing everything to be UTF8 like Python 3.
&gt; What other language requires you to understand this level of complexity just to work with strings?! Does anyone have an answer for that by the way?
Discussion on Hacker News here is very informational. http://news.ycombinator.com/item?id=1162122 IMHO, Ruby allow you to work with encoding if you want. But if you want to work with UTF-8 universally, there's nothing stopping you from converting all data to UTF-8 when you read from external storage, that's the same with what Python do.
Those are all interesting points. Perhaps you should run your own benchmarks. It's so hard to know which ones are faster than others. Just the other day I ran into this http://www.kuwata-lab.com/tenjin/ which claims it's the fastest template engine in the world. 
Strings are a mess in a lot of languages IMHO. Especially since utf8, but hey I'm a big utf8 fan. Strings are not easy.
Beautiful :) I wish I understood the "inject" syntax... but unfortunately, I do not. I'm pretty new to Ruby.
It's like 'collapsing' the array, squashing it into one value. A simpler example: irb(main):006:0&gt; [1,2,3,4].inject {|a,b| puts "#{a};#{b}" ; a+b} 1;2 3;3 6;4 =&gt; 10 I hope it's clearer now
also for a better reference, read this: [Fold on wikipedia](http://en.wikipedia.org/wiki/Fold_(higher-order_function\))
Not really :( I'm still rather confused. Maybe you could just use 1 variable instead of a,b ? 
Sinatra is just badass in general.
1. why does there need to be an ISO standard for Ruby? 2. why would one want to push this particular effort which seems to both have been abandoned and totally behind the times (given ruby-core's stated desire to have everyone migrate to 1.9)? As a general statement, i'm against ISO standardization, and there is clearly a fair segment of the ruby community who agrees with that position. The (RubySpec)[http://github.com/rubyspec] project was designed to provide a living functional description of what Ruby is. Which in my opinion, particularly for a language as complicated as Ruby, definitely a preferable way to define the language. Standardization, or the failure for the LISP standard to accommodate what people needed is one of the things that seriously screwed the LISP community.
Upvoted purely based on the name. 
It actually looks close to the cancan gem by Ryanb that I use now. From an overview I don't see anything canable has over cancan except the name. I will probably play with canable to see what the real differences are. 
The stylesheet for this blog gets me every time.
Someone brought that up in the comments, and the author responded. &gt; CanCan has one file that defines all your permissions, whereas Canable defines your permissions in each individual model. Or as another commenter put it: &gt; I like the fact that this spreads the authorization across the models being authorized for, as opposed to the potentially unwieldy single Ability class of cancan.
No, the point is that after step #1, a holds the current aggregated value
Nowdays UTF-8 is commonly used in CJK's world, so I don't see any problems that Python 3 only supports UTF-8. Why you think it's a *terrible* idea? (Disclaimer: I am a Chinese)
For starters, most people in Japan cannot properly write their names in it. There aren't the right / enough glyph choices. So when you need to deal with (for example) any kind of registration or name data... it fails.
Sounds pretty nice. I like the idea of permissions being based on the instances of objects rather than classes. Could come in handy.
See here: http://avdi.org/devblog/2010/03/01/ruby-standard-org/ Short version: 1. I don't know if there needs to be an ISO standard or not. 2. I'm not pushing anything; I'm just trying to make it easier to discuss the draft.
Hahahahahahah awesome
3/4 = International IRC Dongathon Day
Fixed? [link](http://pastie.org/854042)
[Kalimotxo@segovia:~]$ dicks (03-04 13:20) 8=====D 8=======D 8====D 8========D 8====D 
Here's more, now that I'm awake: http://en.wikipedia.org/wiki/Han_unification
definitely a better version
This seems so juvenile :-) Props...
It's also not really that expensive to pop up to a 20GB database, either.
I laughed. Then I looked at who submitted this. Then I laughed harder.
It's good to see that 12 year olds are now picking up Ruby.
Totally OT, but is it possible to have your shell print out the date and time stamp on the same line of the command after you hit Enter? It just occurred to me that that couild come in handy.
I think you can pipe your `date` output to PS1.
[This is relevant.](http://www.smbc-comics.com/)
[zsh](http://www.zsh.org/) if you use bash, you wont have to learn anything new. It's extremely customizable. The best features are autocorrection and command tab completion. Example: sudo atp-get install zsh will correct to "apt-get" and work. You could also sudo apt-get in&lt;tab&gt; and it will autocomplete the command argument. Find a good .zshrc file and you're set.
So is that a default behavior in zsh or something I'd have to set up in a .zshrc?
Well, actually, I'm wrong. fact(x) shouldn't return anything if x isn't a non-negative integer. Thus, it should look like this: #!/usr/bin/env python def fact(x): if (x %1 != 0 or x &lt; 0): raise ValueError, "Factorial is undefined for floats and negative numbers." i = 1 for j in xrange(2, x+1): i *= j return i That fixes the problem. Man, I'm embarrassed.
Meh. Mistakes happen. No biggie. I think that interview questions like "implement factorial in language foo" should always allow for dumb mistakes that *anyone* can make. After all, testing and debugging are at least as important as writing code in the first place, because (presumably) *nobody* will always get things right -- even simple things. Add to that the stress that many experience during job interviews, and it's stupid to *not* allow some wiggle room. edit: I upvoted you for debugging your answer.
I use a very lightly modified version of [this one](http://stuff.mit.edu/~jdong/misc/zshrc), as far as I know, a lot of other people do too.
jdong... appropriate for the thread.
I totally dig sequel. I haven't played with Arel at all but sequel pretty much rocks.
I'm using Sequel for a project right now and it is definitely a breath of fresh air compared to ActiveRecord. I'll admit that I was scared off by Sequel's DSL for queries, opting instead to do it the string way.
There's a good back-and-forth between Sequel's author Jeremy Evans and Rails core member Pratik Naik in the comments.
this looks awesome! anyone used it? 
A commenter supplied the following more ruby-ish intersection: def intersect(a,b) stash = Hash.new(0) a.each do |item| stash[item] += 1 end b.each do |item| stash[item] += 1 end stash.reject { |item,count| count &lt; 2 }.keys end To which the author replied that it is more complex O(x + y) for the author's version O(x + y + however long it takes to do the reject). Am I incorrect in my understanding of reject that the complexity would be O(x + y + x + y) = O(2(x + y)) = O(x + y) for the version in the comments? #reject is just a filter function no? And the complexity of a filter function is O(n), with n = x + y in this case? Could just be early and I'm being stupid too...
require "set"
I was thinking the same thing.
You're right, the complexity of both is linear, ie O(n). However, I think the author was trying to say that when you're trying to squeeze all the performance you can out of something, those factored-out constants matter. Kind of like how different sorting algorithms with the same big-O time can have different performance in a benchmark.
Ya, that's what I figured after waking up a bit more... I'm guessing he probably shouldn't have mentioned big-O time though :P
This is how I like to do my array intersects in ruby: a = %w(foo bar bat biz) b = %w(foo bar bing bang) intersect = a &amp; b I'd say that's probably the most rubyish array intersection.
Got a link for us lazyweb types?
Has anybody looked into whether rubinious uses less RAM? It might be handy when you are hosting multiple rails apps.
Great writeup, thank you.
"This particular effort" is blessed by Matz. It is furthermore not "behind the times", but specifically designed to standardize a subset of Ruby that is supported by most current Ruby implementations, including 1.8 an 1.9, without being so prescriptive that it rules out implementations that currently deviate from MRI in various ways but that are still widely used and/or have valid reasons for the deviations. It is partly a political issue - making Ruby more palatable for government. Secondly an attempt at creating a common base that can be expanded later. 
[This](http://www.smbc-comics.com/index.php?db=comics&amp;id=1811#comic) is the relevant link.
Python does not convert to UTF-8. It converts to an abstract Unicode datatype which is generally represented in-memory as UTF-16.
Not utf-8. http://www.reddit.com/r/ruby/comments/b8ggo/ruby_19_encoding_rant/c0m2q1x 
I came here knowing that this terrible "common wisdom" would be repeated. It's wrong. Wrong. Wrong. Wrong. Name a bit of Japanese end-user software that does not run in a cell phone that is popular in Israel and Russia and America. Name just one. One! Now let me name a few bits of software substantially developed in America that are popular in China AND Japan AND Israel AND South Africa AND Germany AND every other industrialized country in the world: * Internet Explorer * Firefox * Safari * Google * Gmail * Facebook * Microsoft Office Microsoft Office is much more popular in Japan than its nearest Japanese competitor. it is demonstrably and provably the case that American programmers make most of the world's multi-lingual software. So it makes no sense to go to Japan for advice on how to do it. 
You are correct. My bad; I meant to say Python convert everything to unicode, not UTF-8. I did know the different between encoding and characters but I guess hearing people mixing it up on the internet too much must have messed up my brain, too. :-(
And it all horribly mangles Japanese names. Seriously, I've seen it happen - you put in 'orange blossom' and get out 'fruit flower' because they think it's a good idea to do the translation from Shift-JIS to UTF8 for storage. It's irrelevant whether *you* think it's needed, or whether it's needed for multilingual software. If it's not built into the programming language, you can't fix it later.
As I said on Hacker News: I believe that Python, Java, C#, Objective-C and Javascript *all* have the same basic approach to this problem. The Ruby way is better for handling some Japan-specific problems. But that's at the cost of making life harder and less predictable for everyone else. It's a pretty straightforward tradeoff. Of course people who are not Japanese will naturally be upset to pay a cost in complexity for a feature of benefit primarily to a programmers from a single country. Non-Japanese Ruby programmers will just have to decide whether their solidarity with Japanese programmers outweighs their personal and collective inconvenience. 
&gt; It's irrelevant whether you think it's needed, or whether it's needed for multilingual software. How can it possibly be irrelevant whether it is "needed for multilingual software." Multilingual software has a superset of the requirements of unilingual software by definition. &gt; If it's not built into the programming language, you can't fix it later. If it's not built into the programming language then it can be built into a library. Since there is only a single country in the world with a serious complaint about Unicode, I think that's a reasonable solution until they get the Unicode standard changed to their liking.
If Unicode pisses off "all" of East Asia then why does a guy with the last name "Wu" say: "Nowdays UTF-8 is commonly used in CJK's world, so I don't see any problems that Python 3 only supports UTF-8. Why you think it's a terrible idea? (Disclaimer: I am a Chinese)" 
I wasn't sure at first glance, but I like it. Also, I thought it was funny that he'd say this: &gt; I've put together a library that caches method calls using the ActiveSupport::Cache::Store of your choice. ... and then: &gt; I know there's bunch of caching libraries out there, but seems most are memcache-only and/or hopelessly tied to Rails Does anybody actually use ActiveSupport without Rails? 
Sitting next to the author of RVM at mountain west ruby conf. RVM has come a long way since this article. Everyone should check out the latest version on there site. They have all sorts of cool new auto testing features. 
Sure, MongoMapper for example. ActiveSupport isn't anything Rails-specific, just bunch of usefull extensions to standard library.
[Heroku also does this](http://heroku.com/)
Hey, it's not actually quite the same thing. With oncloud you never upload or deploy your code and it doesn't run on oncloud itself. You're actually just connecting to oncloud, which then serves as a proxy for requests.
I don't see the point of arel actually. Well may the best project win I guess.
So it's not so much free hosting as a fancy dynamic DNS system then?
If that's the case, then on a related note, [DynDns](https://www.dyndns.com/). Much more flexible IMO. :)
It looks like OnCloud can punch through NAT/firewalls. DynDNS can't.
Correct.
Huh? The grammar has never been so complicated that it took 10 minutes to compile. On my 2.13 Ghz macbook air ruby 1.8 takes 10 seconds to generate and compile parse.c and ruby 1.9 takes 11 seconds to parse and generate. Either the author mixed up his units (minutes for seconds), doesn't know how to benchmark properly/cleanly, or he's completely full of shit.
If you're interested mitchellh and myself are parked in #vagrant to help you out. Hope you'll give it a shot!
What are you talking about? UTF-8 includes mappings for all of the characters in Shift\_JIS. There’s no simplification happening going from one to the other. The only “issue” with it is that the Japanese long ago confused ¥ and \ and they don’t like that Unicode doesn’t consider them synonymous. That’s it. I speak Japanese; I’ve lived in Japan; I run my computer in Japanese. It’s true that historically, the Japanese were mistrustful of Unicode because they didn’t like Han unification, but A) you can’t unify Han characters using Shift\_JIS either B) the fact is that the Unicode consortium have taken every reasonable step to make UTF-8 superior to Shift\_JIS in every way, except for string length. Unless you really need to save a couple bytes here and there, there is no reason to use Shift\_JIS.
&gt; It's a terrible idea to only support UTF8, like python That’s an inaccurate summary of how Python works. Python’s string handling is radically different from Ruby. For one thing, Python strings do not have individual encodings per se. Python has two\* types `str` and `bytes`. Behind the scene, `str` uses, I believe, UTF-16 (the kind with crappy post-BMP support :-( \*\* ), but as a user this is never exposed to you. If you want to read data, you can read it in as raw `bytes` or have it decoded from whatever encoding you like into the system `str` encoding. The other direction works just as well, and if you have a character you want to write out, you can have it encoded as UTF-8 or SHIFT\_JIS or whatever that weird Korean encoding is. It doesn’t make sense in Python to talk about the encoding of a string, just the encoding of the `bytes` that are coming in or going out. \* NB: They changed the names of the types in Python 3, and I’m using that convention. In 2.x, they were called `unicode` and `str` instead of `str` and `bytes` respectively. \*\* Python can read and write high plane characters, but it misrepresents the length of strings containing them and iterates through them wrong. This problem can be fixed though if you compile your copy of Python with instructions to use UTF-32 instead. 
There aren’t any extra glyphs in Shift\_JIS. Name writing can be a problem, but it’s not a Unicode problem.
&gt; After compiling PHP I ran the unit tests and 7 failed[2]. All 7 had to do with bad conversions between signed and unsigned numbers (a negative signed int is a positive unsigned int). This is a production release so those failures are not confidence inspiring. Argh.
More of a "reverse-reverse proxy". Your users will actually connect to on-cloud, which relays the requests to you (punching through NAT), so it isn't a Dynamic DNS (it isn't about name resolution).
Hm, yes I think that this system would actually compliment the current permission system on my site. I'll give it a go.
[rubygems.org](http://rubygems.org/) is the new standard location.
if it's just a bunch of scripts.. then maybe github is the best place.. although they no longer host gems anymore. without knowing your apps, it might take a lot more effort to convert your scripts to gem conventions then to just put them up on github.
Right now it's just 12 lines that pulls the page, stores the numbers, then takes the numbers and counts how many times they were rolled. I am still expanding on it so it wouldn't be hard.
I'm most happy with gem distributers that do 3 things by the way: * Distribute gem at rubygems.org * Share code/wiki/etc at github * Make docs available at rdoc.info 
Awesome, I'll be sure to do that. Thanks for the info.
In case you don't know, the [jeweleer gem](http://github.com/technicalpickles/jeweler) makes it really easy to manage and publish gems.
I might be missing something (gotta tweak spec, as is it won't run due to syntax in lib/cacheify.rb)...but... I think the cache key used at line 42 is going to create caching at the class level and not per instance. Also, I want to run the spec because, ruby classes are read top-down. Won't setting cacheify :bar, and the dynamically defined method #bar get overwritten when Foo#bar is actually defined in the class? (I should probably just comment @ github) Cool idea, though. Good luck.
gemcutter became [rubygems.org](http://rubygems.org), and as xternal said, that's the default gem host. It's incredibly easy and simple. Once you set up your account and install the jeweler gem it's as simple as $ jeweler gem_name # creates bare gem # write/add your code, add description to gemspec $ rake version:write $ rake gemspec $ rake build $ gem push pkg/gem_name-version
sounds like github would probably be the best bet then until it's a little more solidified. then i would recommend checking out [jeweler](http://github.com/technicalpickles/jeweler) which makes setting up gems and deploying them to gemcutter dead simple.
That really is simple. I can't wait to try it out.
As long as we're aiming for simplicity, [gemify](http://dojo.rubyforge.org/gemify/) might be more appropriate.
As the author of Gemify, I'll say skip it for now, and rather wait for Gemify 0.3.
Just a note, you don't *need* jeweler. Pushing to rubygems is fairly simple without any external libraries.
I know. It just looks awesome.
Wow! I've been wondering if there was something a bit better than rdoc. It seemed there was no way to define parameters, return values, etc. I, basically, made my own little system to account for it. At work, we code our comments for phpdoc, which has support for those. Unfortunately, we don't ever use phpdoc. :( I haven't seriously gotten into documentation because most of my rails projects have been small. I am working on something a bit larger, now, and it would be nice to have proper documentation. I will check out yard and railroad, though.
I think that [Jeweler](http://github.com/technicalpickles/jeweler) was responsible for GitHub's decision stop hosting gems.
and get your gem metrics on getCaliper, which rubygems.org links to for all gems. (one of the caliper founders had to pimp it a bit) 
Ruby on Rails resource I meant. Sorry, was a little anxious to submit I guess.
Rails != Ruby
Well, you would be the authority on it. Thanks!
Use Jeweler
Jeweler doesn't get it. Use hoe.
I've used Hoe *a lot*, and Jeweler most recently. Here is what I've learned. Jeweler is awesome: * Does not care what text-formatting (MarkDown, Textile, SimpleMarkup) or documentation generator (YARD or RDoc) you use. * Does not care how your README or ChangeLog files are named. * Does not require maintaining a Manifest file. * Provides tight integration with Git. (I was pleased to see `rake release` automatically commit the new gemspec and push the tags.) * Can automatically populate various fields in the gemspec (such as `executables`). * Can manage the current version of the project in a `VERSION` file. This can be overridden by loading the project's `version.rb` file in the `Rakefile` and setting the gemspec.version field. * Releases gems to rubygems.org (aka GemCutter) by default. * Provides a `jeweler` command that provides many command-line options for how a new project should be generated. * Does not support Gem Signing, yet. * Very easy to get patches or feature requests accepted into Jeweler. Hoe is alright: * Still very tied to RDoc, and has some bugs related to handling MarkDown formatted README / History files. * Expects the README file to end in `.txt` and the ChangeLog file be named `History.txt`. You can explicitly tell Hoe which `readme` and `history` files to use in the `Hoe.spec` block. * Requires that you maintain a `Manifest.txt` file, listing all releasable files. * Can auto-infer various bits of information about your project from the `README.txt` file, but expects README to be strictly formatted. * Can auto-detect the current version by searching for the `version.rb` file in `Manifest.txt`. Hoe will expect a `VERSION` constant to be accessible in your project's top-level namespace, and that the namespace be the camel-cased version of the project's name (@zenspider: I think that's roughly the algorithm?). * Requires that you specify the current version when releasing new versions of a project (ex: `rake release VERSION="0.1.0"`). The specified version is compared against the project's `VERSION` constant. * Provides a very simple `sow` command for generating new projects. Only supports two (!) command-line options. * Supports generating projects using ERb file templates located in the `~/.hoe/` directory. Does not support multiple templates. * Is still coupled with RubyForge, but does provide a `release_to_gemcutter` task. * Does provide a minimal plugin system. * Supports Gem Signing (although RubyGems needs to overhaul it's signing/trust model, and GemCutter could also support the uploading of author certs). I have not used Echoe, so I can't give an informative opinion on it.
Shameless self promotion much? Maybe you should spend more time fixing bugs and less time on reddit.
I didn't know yard and railroad existed. Thanks for the tips. As for alternatives maybe doxygen?
There is also [YUML](http://yuml.me/), it's really great to add UML diagram into documentation. Since you don't have to store the image of the diagram locally. There is also a [plugin](http://github.com/nelsonsilva/yUMLmeRails) for Rails to generate diagrams.
Neither of them get it. Use gem-this.
Get back in the kitchen, hoe!
bugs?!? hoe is perfect! :P
Hoe doesn't care about the namespace, it really is just grepping for the VERSION const. Hoe's release system is fully pluggable, so it isn't strictly tied to rubyforge. I wouldn't call the plugin system minimal. It is pretty awesome and has allowed Hoe to be much more flexible and adaptable. Some neat things have come from it.
I felt like such a moron sitting here with my browser displaying all the "You're doing it wrong" pictures from that article, that I had to stop reading it.
 ~/test_hoe $ rake release VERSION="0.1.0" .... cd - WARNING: description and summary are identical mv test_hoe-0.1.0.gem pkg/test_hoe-0.1.0.gem Logging in Releasing test_hoe v. 0.1.0 rake aborted! no &lt;group_id&gt; configured for &lt;test_hoe&gt; When I run `rake release VERSION="0.1.0"` in a new project, Hoe attempts to release to RubyForge; denoted by the error about no `group_id` defined for the project. Also `rake post_news` and `rake publish_docs` are designed to work with RubyForge. This is why I said it is tied to RubyForge. When I wrote the hoe-yard plugin I only noticed two useful plugin methods supported by Hoe, `initialize_#{plugin_name_here}` and `define_#{plugin_name_here}_tasks`. Only two methods that run at specific points is pretty minimal... I was hoping for more methods that allowed me to hook into the pre- and post- conditions of various Hoe methods. 
I learned something while trying out the first example: def A puts "Hello, world!" end To call a method named as such, you need to include parenthesis.
One thing to keep in mind about rdoc is that folks are slowly getting away from using the old template style. I see much more Darkfish now, or sdoc layout. Not sure if that's a great thing, not the hugest fan of darkfish. That said, I enjoy reading yard formatted docs at rdoc.info. It's my goto spot now, so I suppose that gives an edge to yard. I should get back to it.
While the top of post is neat, I'd say, skip to the bottom and just read about the standard [Benchmark module](http://ruby-doc.org/stdlib/libdoc/benchmark/rdoc/index.html). Don't try to roll this kind of thing yourself unless you absolutely have a special case; it's reinventing the wheel.
It may be a pretty minimal api, but it allows for all of this: hoe-debugging (1.0.1) hoe-doofus (1.0.0) hoe-gemcutter (1.0.0) hoe-git (1.3.0) hoe-hg (1.0.5) hoe-rubygems (1.0.0) hoe-seattlerb (1.2.2) hoe-telicopter (1.0.0) hoe-yard (0.1.2) It doesn't have to have lots of API to be useful. &gt; I was hoping for more methods that allowed me to hook into the pre- and post- conditions of various Hoe methods. If you have a specific idea to extend the plugin system, please file a bug (on rubyforge! ha!) with your ideas/requests/patches. Since this is building upon rake, pre/post conditions are generally done by extending tasks via prerequisites. 
cool of you to step forward. but there are lots of people who are way worse in the ruby world - don't sweat it I stopped going into IRC altogether because of the stupidity of lots of people who answered questions there, especially on #rubyonrails then again, rails is their favorite DIY-CMS tool so I guess everything looks like a nail for them
Well .. You shouldn't use initial-uppercase for method names.
Ruby itself does...cf Array(), Integer(), Float(), String(), etc
yah.. i found myself yelling at the computer to just use benchmark.. glad he figured it out...
Hm .. Didn't know that. What are their purpose? Casting?
kind of.
They're method names too. Look it up. method(:Array) #=&gt; #&lt;Method: Object(Kernel)#Array&gt;
Good notes. I learned some stuff that was either new or I'd forgotten. I tend to do this with ActiveRecord and ActiveSupport all the time.
I recommend eschewing `attr_protected` for `attr_accessible`. It's best to provide a whitelist of mass-assignable attributes versus making a blacklist of attributes that __aren't__ mass-assignable.
I had the same thought reading the post. In general, I find anything security related is better as default-deny, be it code, firewall policies, etc.
Nice. I'll be in my bunk, reading....
I keep thinking... Maybe THIS is what the iPad or kindle is for. I may have to rethink my opposition to them. When are we going to get a linux version of them.
YARD! I throw my support to yard. In my projects I've added extra YARD features to make documentation more Rails-specific. They don't do model relationships, but they add method information from controller stuff. I haven't used it in over a year, so I'm not sure if I still have the code. My advice is to spend a day or two building up the tools you need for documentation. Once you have that all figured out, you can go balls deep coding without having to worry about other stuff.
In the end I still don't see what he was trying to achieve there. It seems like a really convoluted way to solve whatever problem he was having.
Use mechanize. Really. Hpricot falls down a lot. mechanize uses nokogiri and is much better suited for the job.
99% sure that it's because Firebug's Xpath adds tbody's when there isn't any in the markup.
But its the same xpath used when parsing the local stored HTML file, and that seems to work. 
I will have to rewrite it and follow some examples using mechanize and nokogiri tomorrow. edit: But the weird thing is hpricot works for the local html file.
If you save the file with open-uri, and compare it with the file saved by firefox, then you can see it's different. The web-site can reallize that the user uses which browser (ex: firefox, IE, iPhone, ...) by user-agent header. 
You are right, they are different. 
But even taking the xpath of the saved file doesn't solve the problem. I think there is a simpler way than using the long xpath, I will give it a shot tomorrow. Thanks.
And the local file was saved by FireFox. View the live source and you'll see there are no TBODY tags in it.
Fixed it for you: http://pastebin.com/3CuMDWXL Hpricot can use CSS selectors. I used SelectorGadget for isolating the correct selectors: http://www.selectorgadget.com
You, Sir, Are A Scholar And A Gentleman 
Yep - Firebug's XPath works on the DOM, not on the source document.
Why can't you do regular method type overloading in ruby?
whoa, selectorgadget looks awesome. Thanks for the tip.
Move on to nokogiri and forget hpricot. Hpricot hasn't been updated and quite a while. Every time I have tried to use it, it bugs out. You can substitute nokogiri with little to no code modification.
That question really goes to the heart of type systems and styles of object orientation. Think about two things. What does it mean to call a method on an object? The answer is very different in languages like Ruby compared to C++ or Java. How does a language like Java distinguish between different overloaded methods? Why can't Ruby do that at compile time? 
Because it's a dynamically typed language. How do you infer the signature of a method if the value passed in can be anything? 
Looks like a good read. Is there a good english translation or do I need to stab it with google translate?
The fact that dispatch is done in runtime doesn't mean that it could not be done based on its arguments. The decision to prioritize default values for arguments over multi-methods was absolutely conscious and is well analyzed, by Matz himself, [in this interview](http://www.artima.com/intv/rubyP.html) -- look under "Orthogonal versus Harmonious".
Interesting, but take a look at this: http://github.com/dyoder/functor/network . It solves the same problem, and is better "packaged" (ie. easily installable, maintained, etc). Though I'd love to be able to use non-equals matches also for message names, somehting like functor /find_by_(age|score)/, Integer nachokb 
Sorry in advance for the bad audio and shaky cam. It was what I could get with my iphone.
Funny he doesn't mention memory usage. For those of us using virtual servers to serve up multiple sites it's important. 
If you're interested in Ruby memory details, I found this slide show REALLY insightful about what and how ruby stores in memory: http://timetobleed.com/garbage-collection-slides-from-la-ruby-conference/
I wonder if putting multiple rails instances inside of glassfish would use up less RAM than using passenger for all of them.
Tab completion in vim??? Freaking cool!
rdebug makes printf-debugging obsolete
I think [SuperTab](http://www.vim.org/scripts/script.php?script_id=1643) works in conjunction with this, too. No multi-keystroke, just hit tab.
Just use SuperTab and NeoCacheCompl for everything this does with no ruby and jvm dependency
Netbeans already has all those features.
What's NeoCacheCompl? 0 results in google.
Maybe [neocomplcache](http://www.vim.org/scripts/script.php?script_id=2620)?
Some tips to work with capistrano, thin and nginx.
Unicorn has had this for a while.
You might have to hit another page first to get the cookie, or they may sniff the user agent. Their site does not anything when I tried with curl which is usually how I troubleshoot mechanize issues: allan@vent:~$ curl -is https://mypurdue.purdue.edu/cp/home/displaylogin HTTP/1.1 302 Moved Temporarily Server: Apache-Coyote/1.1 Set-Cookie: UserAgentId=8983728810084292282; Path=/ Set-Cookie: fos.web.server=esaprod53; Domain=.purdue.edu; Path=/ Set-Cookie: fos.secure.web.server=esaprod53; Domain=.purdue.edu; Path=/; Secure Set-Cookie: runId=7838440979679048239; Domain=.purdue.edu; Path=/ Set-Cookie: badprotocol=1; Domain=.purdue.edu; Path=/ Location: https://mypurdue.purdue.edu/cp/home/displaylogin Content-Type: text/html;charset=UTF-8 Content-Length: 0 Date: Mon, 22 Mar 2010 21:47:17 GMT Set-Cookie: BIGipServerPool_mypurdue_80=908055168.20480.0000; path=/ 
Thanks for the quick reply. Well ok the page you usually surf to is http://mypurdue.purdue.edu but if you just go to that page and login it works just fine. I just did curl -is on http://mypurdue.purdue.edu and got the following: [patrick@tux-laptop stockprices]$ curl -is http://mypurdue.purdue.edu HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Set-Cookie: UserAgentId=3323868651502807343; Path=/ Set-Cookie: fos.web.server=esaprod53; Domain=.purdue.edu; Path=/ Set-Cookie: fos.secure.web.server=esaprod53; Domain=.purdue.edu; Path=/; Secure Set-Cookie: runId=7838440979679048239; Domain=.purdue.edu; Path=/ ETag: W/"769-1255210842000" Last-Modified: Sat, 10 Oct 2009 21:40:42 GMT Content-Type: text/html Content-Length: 769 Date: Mon, 22 Mar 2010 23:55:05 GMT Set-Cookie: BIGipServerPoolmypurdue_80=908055168.20480.0000; path=/ &lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Pragma" content="no-cache"&gt; &lt;meta http-equiv="Expires" content="Mon, 01 Jan 1990 12:00:00 GMT"&gt; &lt;meta http-equiv="Cache-control" content="no-cache"&gt; &lt;meta http-equiv="Cache-control" content="must-revalidate"&gt; &lt;meta http-equiv="Cache-control" content="max-age=0"&gt; &lt;SCRIPT LANGUAGE="JavaScript" SRC="https://mypurdue.purdue.edu/js/clientsniffer.js"&gt;&lt;/SCRIPT&gt; &lt;SCRIPT&gt; &lt;!-- hide document.location="https://mypurdue.purdue.edu/cp/home/check/pre"; //--&gt; &lt;/SCRIPT&gt; &lt;/head&gt;&lt;body&gt; &lt;BR&gt;&lt;BR&gt; &lt;SPAN STYLE="font-family: verdana, helvetica, arial, sans-serif; font-size: 10px"&gt;&lt;CENTER&gt;&lt;a href="https://mypurdue.purdue.edu/cp/home/check/pre"&gt;Click here if this page does not refresh to the login screen in 5 seconds.&lt;/a&gt;&lt;/CENTER&gt;&lt;/SPAN&gt; &lt;/body&gt;&lt;/html&gt; It looks like that is just a forwarding page to the real login page.
When I visit the page with JavaScript disabled the login fields aren't displayed. I am not sure, but I don't think that Mechanize executes JS. The JS line is: document.writeln("&lt;input class='textform' type='text' id='user' name='user' size=" + size + " tabindex=1 onFocus='hadFocus(true)'&gt;"); edit: reddit seems to strip the quotes after the backslash, so I changed all " to ' inside the writeln
Thanks I hadn't even thought to try that. I wonder if there is a way around that javascript part?
i've had to work my way around several sites like this using mechanize. unfortunately, there's no way around the javascript issue other than good old-fashioned hard work. you'll want to use firefox with the firebug plugin. visit the page and open firebug so that you can view the requests/responses being made so you can see the GET/POST vars being sent to the server. You may also need to have a variety of cookies set, in addition to the referrer. EDIT: meant to say here, once you have cookies/referrer, form action/method/vars, you can just submit the 'form' without ever having to visit the javascript generated page. It bugs me that people seem to think that they need to obfuscate web pages this way. One example that comes to mind was one where upon form submission, javascript would make an ajax request to the server to get a 'key', and would then adjust the form action to include the key before actually submitting the form. took me a while to figure that one out.
In situations such as this, I typically first hit the login page to grab any cookies, then send a POST to the form's action URL with the proper params.
One great tool for debugging what's going on in your requests is HTTPClient (http://ditchnet.org/httpclient) if you're on OS X. I'm sure there are equivalents on the PC. Firebug is great for reading what's going on over the wire but it doesn't let you post/get with arbitrary stuff like HTTPClient does.
You can use iMacros, which is a Firefox plugin for making your own macros, and it has a Ruby interface. This would require having a browser open, though, as it works in your browser, but gets around Javascript issues. You can also try Selenium IDE, which is the same kind of thing.
Might also want to check out this screencast to get a sense of what we're doing: http://rubybestpractices.com/rubyproblems-teaser.swf
I've looked at this a lot recently, and found that selenium is best for actual integration testing, whereas Watir is best for one off scripts like I think you're wanting to do. Use watir, then you're just programming firefox with ruby and can do anything in js that you need. Works great!
Memory usage is modest, and depends mostly on the data being cached. In those examples, it ran at about 24mb RSS. This puts its starting point about +20mb over Varnish, but actually quite a bit lower than some of the other major caching proxies. I have an instance that's been running for a couple+ years, handling traffic for about 50 sites, caching static files for those sites which are under 100k, but NOT caching http responses from the applications (it's running a codebase that predates that capability), which hovers around 80MB, because it has 50-60 MB of cached data to handle at any given time.
Are you talking about multi-tenancy, with several different apps inside one Glassfish container, or just having your app running on several different runtimes within Glassfish? If you are just running multiple runtimes, you will generally be behind on RAM versus something like Passenger. If your app is thread safe, and you run it in glassfish with threads turned on, though, you can see some great throughput improvements, although it's still pretty difficult to come out ahead on the RAM comparison unless you use config parameters to tune the JVM's RAM usage. If you do that, you can win, but you get into an interesting dance of tweaking and testing to see if you can find settings that deliver the performance you want at a RAM cost which is acceptable. The glassfish gem is easy to use, so if your app will work with jruby, I'd suggest just grabbing it and trying it. It could work out well for you.
I am sure this is no reflection on the project itself (especially given the people behind it), but this page looks like a very typical online marketing landing page, which is off-putting for me. On the other hand, it launches on my birthday. Hrm...
Yeah, I wrote it, and I get the same feeling. We did start the discussion on twitter as a more grass-roots sort of thing. But really, we're aiming high with this project and we needed to make sure there was sufficient interest before putting in a lot of resources. Luckily, there seems to be some good buzz around it so far. I've been working day in and day out on this since the announcement, and I'm really happy to see where we're headed. Don't worry, as soon as the site launches, that landing page will be in the dust bin and the first thing the user will see is a list of problems :) You may want to watch the screencast (linked below) if you want something with a bit more meat and potatoes on it.
Hey greg, you need some feedback on the login page. When I entered something that was not an openid, the login form just reloaded with no indication of an error.
Am I the only one that had to read this title about 4 times before I figured out just what the fuck it meant to say?
There is no better framework in ANY language for lightweight web apps. Period.
We pushed a fix to that tonight. Sorry about that, we know it was confusing. It was reported the other day on twitter and just got around to it today.
*waves to greg* Good screencast, but I'd like to suggest you get a better microphone please (or turn down the gain or add a buffer between you and the mic).
Look man, I'm not topfunky. :) But yeah, in the future if I do screencasts I'll try to get the audio levels set right. I just ran across jing and wanted to try it for something. Luckily, for the time being, our content is written and not spoken. I don't have the soothing voice for that.
&gt;Are you talking about multi-tenancy, with several different apps inside one Glassfish container, or just having your app running on several different runtimes within Glassfish? My understanding of jruby is that each ruby instance runs in a different thread. I am guessing this would save a lot of ram. I guess there is JVM overhead too like you said. 
I didn't even know this existed. Good find.
Dispatcher could be simpler, I think. What's the point of '/' in every get()?
Stop reading reddit and go donate!
That's the actual request path. That way nobody gets confused. What's the point of 'et' in every get()? Clarity. What exactly would be the win of removing that?
Promise to use some of the funds for a haircut?
And ruin this sweet mullet? No way.
A Screencast that demonstrates how to run multiple ruby versions with multiple gem sets on the same machine. It's a great way to try out Rails 3.0 and Ruby 1.9.
Every request path begins with '/'. It would be more elegant to omit it (in Sinatra).
Thank you! That tip worked. I ran into a little bit of trouble because they generate a unique id for each page visit that you need to login but this tip is exactly what I am doing. 
I disagree with the idea that this is how the inheritance model should work, but it's a very clever hack. Nice post.
And the real answer is...redefine the semantics of super instead of contorting around it if this is how the community thinks it should work.
The community thinks it should work as it does now. In fact many modules depend on this behaviour - for example Comparable defines default == between? &gt;= &lt; &lt;= &gt; based on &lt;=&gt; - but you can override any subset of them you wish. If we switched to OP-proposed behaviour, it would be pretty much impossible to create Comparable (other than with metaprogramming hacks of course - these are always possible). super is part of Ruby VM, not stdlib, so it's difficult to hack it.
My inheritance model hack does not stop Comparable from working, so that's not quite true. You can easily try it for yourself and see that it works quite fine. The behaviour of the hack makes it so the last definition always takes precedence. Because it uses a mixin itself internally, it's no different from doing: class X include Comparable include InstanceMethods end This naturally works in Ruby. InstanceMethods will be placed after Comparable in the inheritance chain and Comparable's defaults will not override any behaviour defined in InstanceMethods. This is pretty much what metamorph is doing, except it's in the syntax of: class X include Comparable def &lt;=&gt;(other) .. end end Now, of course, if you did the opposite and included Comparable after defining your methods, Comparable would take priority. But the fact that you have the ability to choose either one makes this much more powerful and doesn't break anything (read: doesn't break anything in a way that can't be fixed with simple statement reordering). But super is not the problem here. "super" works just fine. Ruby's building of the inheritance tree is the problem (the fact that "MyClass" is at the top of the inheritance chain).
how is running passenger on my local dev box complicated?
It's a little more complex than that. For this hack to work "properly", it would actually take a complete redefinition of inheritance and method lookup semantics. Ruby's method lookup starts at the class itself and continues up the inheritance hierarchy to Object (or BasicObject in 1.9). When a module is mixed into a class, it is inserted in the inheritance hierarchy between the class itself and the class's superclass (or above the class's metaclass, if it exists). What the author suggests is redefining module semantics to insert *under* the class itself. This is no small change. To start with, each class would need to track an additional pointer to the start of the method lookup chain. Each method call would require dereferencing an additional pointer (not really a big deal, I guess). Like taw mentioned, it would break modules like Comparable, and there would likely be other consequences I can't think of right now. Perhaps the real solution is to add a new "Decorator" facility that behaves like the author wants modules to, wrapping classes from the outside. It could be implemented pretty trivially in pure ruby, or with some pretty significant but not overly difficult changes to the ruby interpreter itself the "real" way. EDIT: this could be done by adding a new keyword to be used instead of "include" and "extend". "decorate", maybe? Something like this: module MyModule def foo :module end end class MyClass decorate MyModule def foo :class end end MyClass.new.foo #=&gt; :module 
Speed is not *too* bad, but lack of access to git repositories of annoying.
Anything on a non standard port is blocked, and twitter lags pretty badly sometimes. It seems to come and go. How have you been enjoying the talks? So far the Arel one has impressed me the most in terms of "things I will do differently" but I think that's because I KNOW I'm upgrading to Rails 3, everything else looks "kinda nice to try someday." I heard the From Artist to Programmer one was good.
why not just extend the module on the object instance rather than including on the class ? 
Less about passenger being complicated and more about Apache. In addition to installing it you have to have a server running in the background that needs to be started up, virtual hosts to configure, etc. Compare this to just "./script/server". Maybe if you only work on a few limited projects but I bounce between a lot and the Apache feels heavy after doing just "./script/server" for some many years. I hate to change my workflow just to run a bit of PHP code beside my Ruby webapp.
i can see that... kind of. i work on a few projects *most* of the time, so maybe our needs are a little bit different. the one i'm in the most often requires ssl, and it's a lot easier to do that with apache than jump through the hoop of setting up stunnel or whatever people do to get SSL with webrick/mongrel. whenever there's another project that i want to add to apache, i just copy a virtual host, do a global replace on the hostname, and make a host entry with ghost. it's pretty easy. that allows me to run my most-used projects a) all the time, and b) not on port 3000, so i can ./script/server wherever i want. also, you're not *just* running script/server, you're running it ... every time you close terminal (unless you use screen i guess), every time you switch apps (or run designated apps on designated ports and keep that straight in your head), etc. it's great to just hit my vhost and know that it's going to respond. i'll admit it is an extremely minor pain in the ass when setting up a new box... but setting up a new box is kind of a pain in the ass. anyway, good stuff. looks like a neat rack handler.
[Enterprise](http://github.com/tenderlove/enterprise)
Good Man. Stick to the do, let the haters hate. 
Why not?
Don't know what OS you're on, but on OS X the Passenger preferences pane makes it easy. You just open it up, drag on the folder of your app, and it creates a virtual host and does all the legwork for you.. you get a hostname like "yourapp.local" and that works in all your browsers instantly. PHP works too if you uncomment the LoadModule php5_module directive in /private/etc/apache2/httpd.conf :-)
Because that requires you to have access to every instance (not to mention the overhead of extending an instance). Although that example doesn't show it, you may want to have the "foo" behaviour apply to any object of class A anywhere in your runtime. Consider this same behaviour for modifying the String class via mixin and having it apply to every String object, not just the ones you create.
If you omit it, then it is no longer clear as clear whether you're matching the full path or doing a partial match. I don't see any elegance there. 
From the examples in the docs, I would say the partial match (I haven't seen that one though) is more an exception than a rule. Hence my suggestion.
I don't even know if/how Sinatra handles partial matches. That's the point - if you start ever path with '/' most users won't *need* to check the documentation for simple stuff - they'll see an example and it'll be obvious that it's an absolute path, and unless they get a reason to need a partial path they don't need to consults the docs. 
Then just do the extend in the initialize method
You make this sound a lot easier than it actually is. You're also going in circles, as you've just touched on the actual problem. "do the extend in the initialize method" requires you to redefine #initialize. How would you manage to do this on a class you don't own without destroying the existing implementation? 
Ah, admittedly I hadn't read your post very closely. After reading it now I like the idea a lot more :)
Surely your argument about module inclusion 'breaking encapsulation' only applies if ruby encourages this dynamic inclusion into classes (and so breaking expected behavior of 'super'). But in ruby 'include' is a private method, and so cannot/should not be called without the classes knowledge. Although you can call it on a class dynamically using 'send' (as in your example) the fact you must use 'send' already indicates this is quite naughty and so really shouldn't be used and should not be a problem in most code. Because of this doesn't demonstrate a problem with ruby's inheritance system. 
_why not!
While "include" is indeed private and `A.send(:include, ...)` is a hack, nothing is stopping you from doing it the "clean" way and reopening the A class-- perfectly valid in Ruby-- and doing class A include B end Using send() is simply a shortcut to the above more verbose code. The idiom is the same though, and that's what matters. So while send() may be ugly, you can do this cleanly. But more importantly, I think you have to look practically at the Ruby community, not just at whether or not a hack was used. Just about every framework/lib does plugins/extensions this way. It's an extremely common idiom. If every Ruby programmer is bumping their heads against this same problem, I would suggest that there is something in the way of how people expect this to be done. If every programmer was calling a private method, I think it would be reasonable to question why that method was made private in the first place. Was it deliberate? If so, is the reasoning still applicable given the way it's being used? Perhaps the expectations of many people are wrong, but I personally don't believe so. 
It is very difficult to give you any idea without knowing anything about your background and interests
I'm considering applying to be a mentor, so this is rather biased! Basically anything to do with *nix systems programming using Ruby or multi-process stuff would get my vote (that's what I'm into at the moment!).
It would be nice to have a ruby port of python's rdflib
SciPy, NumPy are great tools for the whole scientific community, but there is unfortunately no Ruby equivalent 
I now consider this imperative in any Ruby environment.
Have you tried any of [these](http://rubygems.org/search?query=rdf)?
What are the use cases for this? Why would other people find it useful?
Thanks, I added some more info.
It isn't linked, but this is almost certainly inspired by [Probabilistic Functional Programming](http://web.engr.oregonstate.edu/~erwig/pfp/).
Sqlite? BerkeleyDB?
Would be kinda slooooooooooowwwwwwwww, methinks. Also, I just got it up and running on Snow Leopard box today, with Homebrew the pain factor has gone down several orders of magnitude. Didn't even have to break too much, and only one error during installation.
FWIW, I've found that for all my usual Ruby tasks, that ruby-gd is sufficient and *loads* faster. It is of course, much more limited. I forked it and made it [1.9 compatible](http://github.com/Spakman/ruby-gd), if anyone cares.
Slightly self-serving, but the shoes project could use a lot of help. It's a combination of C and Ruby, but having an easy to use, multiplatform GUI toolkit would be really good for Ruby.
The git talk was really good. Never considered using git in that way. I was shocked at how few people turned up to the JRuby talk.
_why, is that you?
Hardly. If I was, Hackety Hack would be on 3.0 right now, rather than approaching 1.0.
I missed that one for Rate a Rails App in 24 hours. It was an ok talk, but it could have been condensed into half the time.
Rewrite Net::HTTP to be more ruby-like!
MySql? I know it's not in vogue, but it fits your description.
sqlite is hopeless for concurrent access.
Can you give me some examples of parts of it that you think are un-ruby?
I wanted to go and see the javascript for rubyists, did anyone think it was good?
This is a great idea! I'm considering to apply for rsoc as well and this would be a worthwhile project to work on - it's also a very big one though, I imagine. My background is in AI (machine learning, optimisation, clustering, filtering). Maybe we could get something started?
well at least the name `rb_probdsl` is catchy ;)
If you can manage with a Key-Value store, Redis is amazing. Ohm is a nice wrapper for it as well.
I think that a gui toolkit any gui toolkit of quality would do wonders for the ruby community as a whole and go a long way in promoting ruby as a language.
A SciPy/NumPy port to ruby would imply a tool much more powerful than imagemagick for image processing 
Please also note the following remark: a great library for the scientific community has two main ingredients, a flexible and comprehensive API *AND* a community of people working with the code. So having a basic library is required for a start, but you need to make sure that people WILL use it, since this is one of the biggest requirements (if all the researchers of my domain are writing their programs in Python, I better learn Python rather than Ruby). So make sure you plan the library well (it should be easily expandable, eg. plugins, easy to incorporate existing C code, nice API, and an already large working codebase -- FFT, visualization, basic stats, image manipulation etc). The first and most basic thing to get started is by expanding on the ruby numerical array library ,I think. 
Like what?
I was thinking along the same lines. I would be more likely to consider taking on something like this if I had help. Do you have a github account? What kind of experience do you have with ruby?
Basically the whole thing. I wish it was a bit more like [HTTParty](http://railstips.org/blog/archives/2008/07/29/it-s-an-httparty-and-everyone-is-invited/) open-uri makes things better, but I just want Net:HTTP ripped out and replaced. Here is how Net::HTTP makes a get request res = Net::HTTP.start(url.host, url.port) {|http| http.get('/index.html') } puts res.body Here is how I think it should be done response = Net::HTTP.get(url) response.body response.headers or, if you need to add other options... response = Net::HTTP.get(url, :headers =&gt; [...], :timeout =&gt; 30)
try mongodb concurrently access probadly won't come from anything "lightweight" though
PostgreSQL
A more fleshed-out, gemified version of [something like this](http://gist.github.com/344012) would be awesome. Also a more ruby-ish socket API would be nice.
You should also add a TODO list to the repo to give people an idea of where you would like to see things head.
I agree with PostgreSQL and MySQL. I think both would be a perfect (and free) fit.
Drizzle is lightweight.
A WebView driver for capybara so that we can do headless browser testing in Cucumber. Requires C extensions to work in MacRuby.
The C extension is for Nokogiri btw which capybara uses. 
Most of my experience with Ruby is with Rails and web development (I did some work as part of GSoC in 2007 and 2008). I'm also using ruby quite extensively for prototyping ideas and algorithms, as well as interfacing to R using RSRuby. I'm [on github](http://github.com/nighthawk), too, but only have one public project at the moment. Will be quite a feat to build something like this from the ground up! It's certainly best to start small, e.g., with a foundation similar to NumPy. Though there are some existing Ruby projects that are directed for the scientific community. RSRuby, [Ruby for Scientific Research blog](http://rubyforscientificresearch.blogspot.com/), [AI4R](http://ai4r.rubyforge.org/) and [a](http://ai-app-prog.rubyforge.org/) [couple](http://web.media.mit.edu/~dustin/rubyai.html) [more](http://mind.sourceforge.net/ruby.html).
http://github.com/pauldix/typhoeus response = Typhoeus::Request.get(url, :headers =&gt; [...], :timeout =&gt; 30) response.body response.headers Only issue is dependencies but it's hella powerful.
As is http://github.com/maccman/supermodel
What do you not like about it?
this was posted here weeks ago
I don't understand. If HTTParty does what you need, why not just use that?
I didn't know about RSRuby, I'm going to have to try that out. I just started using R in my statistics for data mining class. There is also [NArray](http://narray.rubyforge.org/) which claims to be similar to NumPy.
+1 for shoes - not only a useful tool, but great for educational purposes (a good way to get kids started with Ruby)
Ohhh... Perfect!
i'd like to see why he things python has more semantic flexibility than perl
This is interesting, but there's already Johnson, which wraps SpiderMonkey so it should work cross platform and probably on different platforms too (except JRuby, but JRuby has Celerity). This coupled with env.js has been wrapped into the harmony gem, which seems to work amazingly good for testing JavaScript and dom code. Steven Parkes has been working on a Capybara driver for this, his [work is on GitHub](http://github.com/smparkes/capybara-envjs), it's not quite done yet, but I imagine we'll have this working fairly soon. This will give us a **fast** headless browsing solution which works cross platform, does not require a separate process, and is reasonably compliant. A WebView driver is still a cool idea, where compliance is more important than speed, but this seems like the nicer solution to me at the moment.
I'd say, though, something with the same API as Typhoeus but that worked "out of the box" with no dependency on libcurl would be awesome for those tricky deployments. A typhoeus-pure, if you will :-)
Do you have any tips/techniques for running it in a super lightweight environment? I use PostgreSQL on a small appliance (256MB RAM) and would like to find a way to trim all the fat I can. It's default config (Debian) used to be set up for small installations but I don't think that it is anymore and I can't seem to find any good advice on what to do.
Exactly. Perl's semantic flexibility is why it's so notorious to parse. It's *too* flexible. It's partly why the motto is "there's more than one way to do it." Python is supposed to be better than Perl for this reason. 
Yep. If I can get Shoes 3 out the door, I can start putting in actual time with Hackety Hack, and then we can convert _all_ of the kids. :)
Interested in what we do at kgb? Our tech team now has a website, and we're hiring in Cardiff and Cambridge UK. Check us out at http://kgbwizards.com
I've used Sinatra the past few days on a blog app and it's amazing.
Awesome. P.S. Fuck you, Google.
In this interview, Chad discusses what well-factored code is, how he gets there, and how to grow by pushing yourself out of your comfort zone. Chad is the author of "The Passionate Programmer" and "Rails Recipes."
This is stupid.
Yes the chart is wrong (IHMO). On semantic flexibility Perl is higher than Python and in some cases even Ruby (see: Devel::Declare). re: the closing statement "its probably an unsolvable problem to make a language as large as Ruby to be has consistent as a small language like Python". OK not 100% sure what it means be "large" and "small" here but Io could be a good counter example to this statement and how languages work on given chart.
Fuck you Stanford, Pomona, and Macalester. For different reasons than Google, though.
Thanks, very nice, NArray looks like a great foundation!
.... or you could just use set :scm_username, "myuser" set :scm_password, "mypass" 
I feel like this acronym should have been reserved as the name for some future Ruby virtual machine. But that doesn't really matter. 
I personally love the benchmarking feature of RVM. Especially helpful for apps that run on 1.9 and jruby. It also allows me to test rubinius and maglev for fun
I much prefer the two repository path approach. Works very well when you've got a bare git repo on the other end that you push to in order to deploy, and doesn't require anyone to have a password (I use pubkey auth everywhere).
We can do this in MRI too! Mostly. require 'mutex_m' module SynchronizingProxy def self.extended thing thing.extend Mutex_m proxy = Module.new thing.methods.each do |method| next if Mutex_m.instance_methods.include?(method) proxy.class_eval &lt;&lt;-eorb, __FILE__, __LINE__ + 1 def #{method} *args, &amp;block mu_synchronize do super end end eorb end thing.extend proxy end def self.included klass klass.class_eval &lt;&lt;-eorb, __FILE__, __LINE__ + 1 alias :old_init :initialize def initialize *args extend SynchronizingProxy old_init *args end eorb end end class IncludedAwesome include SynchronizingProxy end class ExtendedAwesome end a = IncludedAwesome.new b = ExtendedAwesome.new b.extend SynchronizingProxy 
Doesn't stop you needing the password for sudo stuff, like installing gems or server packages (apt/yum stuff usually.) A solution we've started using is to create config/deploy.local.rb with `set :password, "foobarsed"` and ignoring it from our source control (`.gitignore` in this case.) Then add `require "deploy.local.rb"` to your `config/deploy.rb` to have it included. Hides the password from your source control, but means you don't have to enter it each time. Make sure your local repo isn't insecure though. You do have it on an encrypted partition/disk image right? :) In fact we liked it so much, we added auto-requiring `deploy.local.rb` to the brightbox deploy gem if the file exists.
More like the fume.
Old news, but clear article.
This stuff is cool, but if it is to survive, it needs to catch on outside of rubyland. Anyone working on implementations for other languages? PHP? Python?
&gt; This stuff is cool, but if it is to survive, it needs to catch on outside of rubyland How so?
Some more work on getting JRuby going on Android (Ruboto) would always be welcome!
That's like putting fruitcake inside a real cake!
I still don't believe you! April 1st is the worst date to try and announce real news. Couldn't it wait 'til tomorrow?
For this, I say we all go over to Aaron Paterson's place and poke him in the eye.
real news?
I can show you exactly where he lives :)
April Phul's!
Nice post. Really helped me out.
Everyone who thinks about using Phuby: Make sure you also use [NeverSayDie](http://github.com/tenderlove/neversaydie).
College decisions came back today. That counts as real news for some of us.
One of my favorite rspec features that doesn't get enough love is the ability to easily setup matchers via the [Matcher DSL](http://www.rdoc.info/rdoc/dchelimsky/rspec/blob/cc75fdf748070d5ef9f34ea1e0824158533097f2/Spec/Matchers.html). It's a good, quick way to get more meaningful output as well as more expressive examples.
I really wish some other languages had BDD frameworks as nice as RSpec. Javascript especially suffers in this respect.
&gt; There is no method called (). Procs (who are the obvious beneficiaries of such change ) use the method call, but one could be an alias to the other. You can get this effect by using the overridden [] method. &gt;&gt; f = lambda{|a| a + 1} =&gt; #&lt;Proc:0x000000010111ef48@(irb):1&gt; &gt;&gt; f[2] =&gt; 3 Not exactly what the author meant, but similar.
that method is yucky imo :) but there is a hack that lets you invoke lambdas using (): http://github.com/coderrr/parenthesis_hacks/blob/master/lib/lambda.rb
&gt; that method is yucky imo :) I agree. The hack you linked to is pretty interesting though.
I think duby is a good place to play with these ideas. 
Is there a gem out there yet that converts rdoc to man?
TL;DW anyone?
Ruby tools are hardly superior. There are some nice things, but a lot of shortcomings too. I hope he didn't actually imply that in the talk. :| What killed Smalltalk was that decent implementations were closed and cost money when the competition was free and often open. Incompatibility between versions didn't help. Nor did playing in its own sandbox separate from other tools.
I think he just meant that the ruby community may be perceived as thinking so, thus starting, as he said, useless language wars.
Did anyone else find him too annoying to watch?
np, the computer world has plenty of overloaded acronyms ;)
Yes. I got up to about 3 minutes and couldn't take anymore.
Yeah, I don't think there's any risk of it dying out. This stuff is completely awesome and makes other template languages look like a joke. But I have heard there is a PHP implementation. 
I can't continue watching this man. Now, I'm going to search these comments for the answer to the title question.
I felt the same way, and almost turned it off. Instead I skipped forward about 15 minutes into it. And then I was hooked. Hooked enough to keep it on in the background while I worked, anyway. It gets better in the second half. He makes a nice point about professionalism in the [final two minutes](http://www.youtube.com/watch?v=YX3iRjKj7C0#t=59m0s) of the video clip.
Cool, thanks. IMO, I couldn't do what I do if it weren't test-driven. Life before TDD was madness. 
You should probably watch the video before you comment on the video.
It gets interesting around 0:38:00. Language arrogance is a big problem. Luckily, everyone loves to point out Ruby's shortcomings, which keeps Ruby in a state of constant change.
Cool! Is there an applet version of jruby, too?
[Already discussed **10 months ago**](http://www.reddit.com/r/programming/comments/8j3c6/railsconf_what_killed_smalltalk_could_kill_ruby/)
Cool. -- Wait, I need Silverlight?
I wondering if the same thing could be said of Lisp.
Its actually fairly popular in enterprise setups where they're largely java shops. You should talk to headius :). #jruby@irc.freenode.net or the mailing lists. There's a lot of folks running it. More than is reported as its people who aren't "rockstars".
Thanks for the info. When you say "it" is fairly popular do you mean jruby or Rails/Merb on JRuby? I ask, because embedding a bit of Ruby in Java is kind of low-risk and easy. But running a production, high-volume site using tons and tons of code that wasn't written for JRuby: that sounds much higher risk, so I'd like to hear more about others who have walked that path before.
JRuby is just Ruby, so there is no porting of frameworks, but additional gems may have C extension. This has historically been a problem, but many extensions have ported to Java. Once you get you app running in JRuby, you know it will work in production. This is not always the case when you have gems with C extensions... no way to catch a segfault.
- Half of the interesting gems don't work. The C based ones that is. - People that have special performance needs generally don't even consider Ruby - People that don't have special peformance needs just run a VPS or something with passenger. - Passenger is easy to setup and you can use apache. Installing tomcat/java just to run ruby isn't something many people would do. I'm not saying these are good reasons. But I do think they are the real reasons. We run a lot of ruby apps. We use ruby 1.9 + passenger + apache in production on virtual servers that run on our own dedicated server. Ruby 1.9 isn't that bad with memory or threads, but for high scale performance (which is something we simply don't need and therefor don't care about) the Java hotspot magic should do the trick. 
Pros: You get all of Ruby and all of Java. So any Java library you like you can now use in Ruby. Pretty much all of the major Ruby C libraries have a JRuby port Cons: If you're TDDing the feedback loop sucks. Waiting for the JVM all the time adds up and can be quite annoying. Actually annoying enough that we extracted out the small parts of our app that required Java (iText stuff) and have it now sitting as a separate Java server that we hit with Thrift. Another Pro: If you jump into #jruby on Freenode headius is awesome and more than happy to answer any questions you have
I have been benchmarking Ruby 1.8.x, 1.9.x, and JRuby 1.4.x and writing up the results on rubyplanet.net I used my personal Rails app project cookingspace.com as the application that I benchmarked.
[Github uses JRuby for their firewall install](http://github.com/blog/441-announcing-github-fi).
You summed up my experience with jruby/rails perfectly. Unless you have Java hosting expertise, skip it. I can't imagine the performance increase + time spent dealing with deployment issues would be cheaper than just scaling out to an extra apache|nginx + passenger web server. I would look to upgrading to Ruby 1.9/Rails 3 as soon as possible, and if you have any CPU intensive code bits, consider porting those something like Scala and interact with them via a RESTful API or messaging queue.
You should submit these stories to /r/ruby, there's obviously interest here.
&gt; Cons: If you're TDDing the feedback loop sucks. Waiting for the JVM all the time adds up and can be quite annoying. Have you tried using nailgun with jruby? This is an honest question from a jruby noob.
I thought Giles Bowkett's balls killed Smalltalk.
No, I haven't. I concede that Nailgun might fix the feedback loop issue but I can't say for certain.
&gt;Finally, iterate over the results: &gt; results.each do |row| # conveniently, row is a hash # the keys are the fields, as you'd expect # the values are pre-built ruby primitives mapped from their corresponding field types in MySQL # Here's an otter: http://farm1.static.flickr.com/130/398077070_b8795d0ef3_b.jpg end Why yes... That is an otter.
Does this work with ActiveRecord?
What is RDF good for? What are some practical applications of it?
Documentation? Rarely used? This is horrible advice.
Not really, if you care to read beyond that statement to "I always check the internet for up-to-date docs anyway" This is absolutely true for me and likely for many others. I don't even know how to use the gem installed rdoc or ri docs, primarily because I have never cared to find out. I use Google as my API reference tool. As such I'd prefer gem NOT to waste my time and install docs by default. This snippet is very useful.
WTF is with the downvotes? I'm not being sarcastic here, I'm asking a serious question.
Wow, so Ruby 1.9 is almost as fast as JRuby + Coroutines, and regular JRuby is a bit of a dog. 
Yes, on this particular benchmark; Don't extrapolate from this that jruby is slower in every way, though.
http://rdfabout.com/quickintro.xpd is a quick look at the data model http://www.bbc.co.uk/blogs/radiolabs/s5/linked-data/s5.html is a slide set from the BBC with a little more context. Play along, and when the NYT releases a ton of machine-readable data, you're already ready to go: http://open.blogs.nytimes.com/2010/03/30/build-your-own-nyt-linked-data-application/ 
not from the looks of it... i think the connection adapter would be the missing piece, probably a separate project.
See Tim Berners-Lee's (the inventor of the Web) presentations at TED 2009 and 2010, demoing some mindblowing applications of linked data and RDF: http://www.ted.com/talks/tim_berners_lee_on_the_next_web.html http://www.ted.com/talks/tim_berners_lee_the_year_open_data_went_worldwide.html 
Well, thanks for that! That's pretty damn cool.
Who knows. This is the internet after all. It doesn't make your question less valid. Once you start to understand what RDF is and how its used, you start to wonder why its not more widely used today. For a higher level read on practical semantic web applications check out [Pull: The Power of the Semantic Web to Transform Your Business ](http://www.amazon.com/Pull-Power-Semantic-Transform-Business/dp/1591842778). RDF is the foundation of the semantic web.
What do you mean specifically for Rails? 
Pilu's Web-App-Theme is pretty helpful: http://github.com/pilu/web-app-theme. It contains a few different themes.
Correction, remove the period in the link: http://github.com/pilu/web-app-theme
I created a generator for 37 Signals inspired admin interfaces. http://github.com/andyjeffries/andy_admin I only use it for internal projects or private admin areas, if you're selling a product and giving your customers an interface like that, you may need to check with 37 Signals (then again, I didn't copy any of their code and it is a redesign with theirs in mind rather than pixel for pixel copying... but it's at your risk anyway).
[http://en.wikipedia.org/wiki/Look_and_feel](http://en.wikipedia.org/wiki/Look_and_feel)
http://www.lipsiadmin.com/ lipsiadmin is a fantastic piece of software but might be more than what you are looking for.
Yes.
Good stuff. I've been using Navvy for my worker backend, since DJ didn't support MongoMapper, but I'll have to take a second look now.
Anyone know if it work with Rails 3?
Those gains on the benchmarks are fantastic.
NoMethodError
Dr. Nic has the following theme: http://github.com/drnic/install_theme It allows you to install any html themes and translate it into rails layouts.
Wow. That's really cool.
They sure look nice. I believe I shall use it in my next project. Thank you.
It does, but it does not get properly initialized (will be fixed shortly in 2.0.2), so you'll need to add an initializer that sets "Delayed::Worker.backend = :active_record"
An ActiveRecord adapter is coming soon. Sequel and EventMachine too. (maybe DataMapper after that)
It warms my heart to see the community carrying on all of _why's projects.
can someone explain to me the connection between Camping 2.0 and stay-at-home moms . I'm clearly missing something. 
Great work. I particularly like the smart routes (class PostX...).
But when you've only had 30 tickets raised in the last year, it's not really hard to respond quickly :)
Hmm, given the rather large support Sinatra has currently, are there any big advantages of Camping nowadays?
I've been lurking in #sequel, and I'm amazed at the level of support Jeremy Evans gives for this project. You'd think he did this as his day job (maybe he does, for all I know).
There used to be a site called redhanded or something to that effect where all sorts of crazy coders would rant and rave on _why's latest creations. The site was a masterpiece of creativity and was a very refreshing change from most other tech heavy sites. Many of the utterances were in the form of the above which had little or nothing to do with the subject matter and a great portion of it came from _why himself. Camping 1.0 was used in the same sentences as shark attacks, nose bleeds, menstruating cows and of course chunky bacon. _why(theluckystiff) was/is a truly amazing individual who's creativity far exceeded the code he left behind. 
I think what we really need is to work on shoes so that it's a standard way to distribute your ruby apps. Shoes bundles everything including the interpreter. Either that or crate. 
I was wondering the same thing...
As long as you're tricking out your IRB, you may wanna check out http://utilitybelt.rubyforge.org/ too.
Sequel Rocks. That is all.
Surprised to see this post! Good read, Arun!
This is about distributing *libraries*, which is stupidly non-standardized in Ruby at the moment, and a true problem.
I know. I am simply pointing out that that's just one problem. 
Some Glyph-related links that may also be interesting: * Example output: [Glyph Book](http://github.com/h3rald/glyph/raw/master/book/output/pdf/glyph.pdf) (PDF) * [User Group](http://groups.google.com/group/glyph-framework) * [Source Code](http://www.github.com/h3rald/glyph/)
For a thorough repository of irb-fu http://github.com/cldwalker/irbfiles
Thanks, I'll give it a try.
When I enable "wirble", "hirb" stops working. EDIT: Her is it the fix I found: "If you're using wirble and hirb be sure to enable wirble before hirb"
Thanks Sunny! :)
Brilliant! Thanks!
It's not often talked about but they are doing great work. They have the whole extJS widget set mapped to ruby.
Interesting. Like a ruby version of TEX
Well, yes and no: CSS3 does all the typographic work after all ;-) But the aim of Glyph is to be easier to learn and extend.
The arrogance of this guy is amusing. There's thousands or more open source projects out there that people may be contributing to, and to say people are leeches and do-nothings is really pathetic. 900 open tickets really makes one wonder about just how well written this thing is anyway. There are more respectful ways to ask others for help than this.
What an asshole. 
Ranting != arrogance Ryan is a super helpful dude. He's just tired of answering "when is Rails 3 coming out?" in #rubyonrails
It's unfortunate that the author can't/won't state his point like an adult. He has a decent point to make but unfortunately one of the toughest skills to learn is how to communicate effectively. The author fails on this point. Now any prospective employer is going to see this blog and wonder why they would want to hire someone who can't even make a basic point without swearing. You might be brilliant technically, but if you can't even communicate at the most basic level then you're not much help to anyone:( Hopefully with age this guy will gain some communication skills.
it's getting to the point where my intestines try to strangle me every time i see "prospective employer" used in that context. a "prospective employer" ought to be hiring me for my technical skills, not whether i swear on my blog. 
It's like a Maddox rant about rails, except not funny at all.
&gt; a "prospective employer" ought to be hiring me for my technical ski I agree with this. My point, which you chose not to address, was that in addition to your technical skills you also need to communicate, which in this case the blog poster clearly didn't do very well. 
The community is also full of people who like Rails but don't give two shits about it. This guy has a problem with that because he's a moron. When I'm on a project the last thing I want to do is to fix my tools. I'll work on a bug if it bites me and contribute if I can but that's it. I'm not going to Lighthouse to make Rails better. I don't care about Rails. I want to change the world but not by changing Rails. It's a good tool and honestly the bugs in 3.0 haven't bothered me very much so really, I don't care. I just use the 3.0 branch and it works good enough to not get in my way most of the time. If his itch is Rails then he can scratch Rails. My itch is not Rails. His rant would be akin to me releasing some code and then demanding that everyone who uses it fix bugs for me. That's idiotic. People would read the error messages on install and go elsewhere. He claims to be helping the project but he is really hurting it.
fair enough. nothing to do with employers, though.
You know every non trivial rails app is going to need background processing, scheduled tasks, monitoring, etc. For something that started out as a revolt against J2EE it sure is growing into something like J2EE isn't it? Take a look at torquebox for example. Maybe what we need is a replacement for rails, something like R2EE where there is a container which provides background services, queues, database connection pooling, transactions, multiple application deployment etc. Make it based on EM or maybe even unicorn. 
It would be easier to just not answer the question. That particular post isnt going to make folks want to work with him at all. I know I wouldnt.
Greetings all, I'm the guy that wrote the post. Care for an AMA on this?
I have to say, in my opinion the major difference is that it's modular enough that you can leave those things out if you don't need them. Particularly with Rails 3.
Open Source can be stressful, especially the release management part. A developer can begin to wonder if their efforts will actually result in something meaningful for real end-users.
The problem is that it's not really modular in the way it needs to be modular. Rails is still based on a PHP model more or less as opposed to a servelet model.
&gt;Now any prospective employer is going to see this blog and wonder why they would want to hire someone who can't even make a basic point without swearing. Only if the person hiring him has never cursed in his entire life and has only hired people who never ever curse. I'll repeat what I said at the page. I don’t want to live in a world where suitability for children is the overriding factor in how we speak to each other. You don’t either. Trust me. We are adults. We can speak like adults to each other. There is no reason to dumb down our speech to make it acceptable to a five year old. Five year olds are not reading this page anyway. I am really really really sorry that there are people out there who are so deeply upset by a couple of curse words like this. It really depresses me that our education system is not producing adults who have a little more resiliency. 
I thought he communicated fine. I understood exactly what he was saying. Then again I am not some anal wound up prude who gets upset because somebody said a curse word.
It seems to have inspired people to actually try and close bugs. Of course are a very small minority of people who get really upset if somebody says a curse word but I think they make up less than 5% of the society and are usually religious zealots who don't code. 
Maybe you should check http://doc.trolltech.com/4.2/qgraphicsscene.html for the available constructors of QGraphicsScene.
yes, there is a constructor with QObject * (and a setSceneRect method ) 
Kris is an excellent Rails developer. He is a great asset to my team.
"We're sorry, but something went wrong." I love ruby but this is oh so appropiate.
Gentoo ftw
Care to elaborate? Rails is closer to the servlet model imo, barebone PHP being nothing more than a preprocessor - all other things, like MVC engines feel like a hack over that for me. These things live in a giant &lt;? ?&gt; block of (technically) a template. Rails has a fundamentally different approach.
&gt; Source code contributors: Daniele Alessandri, Eric Nicholson, Ivan Porto Carrero, Jayme Edwards, Jb Evain, Jirapong Nanta, Kevin Radcliffe, Michael Letterle, **Peter Bacon Darwin**, Ryan Riley, Seo Sanghyeon, Shay Friedman, Timothy Chen, Unnikrishnan Nair, and Wayne Kelly. That guy has to be a redditor.
They should write the site using PHP or Java, that would sort it.
All the rails code runs from top to botton in each invocation. That makes it like the PHP model. In rails (like php) if you want persistent variables to persist you have to resort to trickery.
Even from a guy who's no longer developing on the .NET platform, I'm glad to see this happen. You can use things like Silverlight to run Ruby natively in your browser (which I just did, and am going to present to my Ruby group tomorrow night). Or you can build games on DirectX using Ruby. It really opens things up.
Good ideas here. I hope he succeeds.
I know this isn't strictly Ruby-related, but the Ruby community is pretty engaged with what 37Signals do, for obvious reasons, and so I thought it might be interesting to post it here.
Why would he suck seeds?
I agree with a lot of your sentiment. I find it gives a lot of high-level advice without getting to the nitty gritty. I already know meetings are a waste of time, I was hoping for some advice on how to deal with important clients that want to have them constantly.
Way to go! That has been long due. Ruby I still heart you.
And I hope the effort continues up. My ambitious goal is to get us at a double-digit number around Railsconf.
Whilst I agree with you about the coins analogy being horrid, claiming that I "personif[y] the whole 'holier-than-thou' rails-style" without actually *knowing* me is quite low and pathetic of you. Do not judge a book by its cover, and all that.
finally. A good post on why exactly this is good.
Here's my XML Transformer entry, &lt;transformer name="Optimus Prime" home="Cybertron"&gt; &lt;action type="roll" direction="out"/&gt; &lt;action type="destroy" target="Megatron"/&gt; &lt;send type="message" destination="surviving Autobots"&gt; We are here. We are waiting. &lt;/send&gt; &lt;/transformer&gt; 
Odd that it doesn't mention MsgPack at all.
Hopefully this will clear up some of the Bundler rage that people seem to be feeling.
Ah finally. We are getting to the point where I can develop in the Ruby goodness I love and my clients can have the IIS/Window stack they like.
Thanks. I wasn't aware of the rage but that's a very clear explanation of the new commands. Personally I feel like we should be moving in the direction of jar files somehow. Of course that presents new problems such as platform differences but I like the idea of bundling the libraries with the app. Who knows maybe we can take a page out of jruby and create WAR files too. 
sound like mixing ice cream and mustard to me but whatever floats your boat I guess.
Heh. I know some people that took down some perfectly good linux boxes running apache to windows because the department only supported windows boxes. It was a "policy." Tech needs clever solutions because of stupid policies (and the people that put those policies in place).
I know where you are coming from. People choose windows out of zealotry, There are some companies who forbid products that are not made by Microsoft. 
I like having the option of using Ruby on Windows specific projects, instead of Ruby not even being considered as a viable solution.
&gt; The rule here is simple, if you always need to work with the whole set of data and never parts of it, just write out the whole array/hash, otherwise, iterate over it and write out each object. I'm missing the point. Why won't he just create an array with the elements he wants to include, and dump that with one call? He could avoid fiddling with $/, calling YAML.load a zillion times, etc.
1. You might have several Gigs of data, so it won't all fit into memory. 2. Each piece of data requires significant processing which, you may want to only load a small part of the data for testing purposes, especially while you're working out your algorithm where the processing is complex.
No one chooses Linux out of zealotry. *EYE ROLL*
Very few people do. Every linux user is also is or was a windows user. 
The problem is that bundler does not go far enough. Instead of using bundler they should have used automateit or chef solo. Many times "gem install" doesn't do the job because you are missing required packages and the bundler does nothing about that. I don't understand why they didn't use chef solo or automateit. It would have solved all kinds of problems.
I don't think zealotry describes what I saw at work. It's was more fear of the unknown. 
Yet another reason people should use rvm. It makes it a lot easier to give an unprivileged user access to a complete Ruby environment.
yeah RVM is awesome! I think the sudo gem install has also started being replace by people installing gems to the user directory ~/.gems
that's true, but still wouldn't help digitalmob with his rubygems update problem!
rvm would help; each ruby it installs goes into the user's directory, and each rubygems system is per-ruby and controlled by that user. However, on a multi-user box, it would kind of suck to have each of 100 users with their own copy of ruby takin' up space.
Space is cheap. Why should storage EVER be a concern?
Or a Mac user. I know I am. I do all three.
For as much as netbooks cost, I think it's worth spending the extra $100 to get a full laptop instead. Granted the netbook is going to have longer battery life, but you can always plug in your laptop when it runs out of juice unless you are coding in the middle of a National Park. 
Cheap storage is cheap. But reliable, redundant and backuped storage in large organisations is not.
I personally wouldn't want to code on such a small screen. I personally am not a fan of a majority of their keyboards. Buy a normal laptop throw your favorite Linux distro on it and have fun.
I code on my netbook all the time (1000HE Linux). The only thing is staring at the screen can get annoying. I say go for it as long as you have a second computer that you can code on too (Github can help with that).
Not if you want your tests to run in less than a week.
Then you've got the right filesystem to handle block-level dedup, right? So it wouldn't matter.
No. By a PC laptop for hundreds less, install Ubuntu, enjoy. Textmate isn't worth hundreds of dollars. =) I've been trying to migrate away from vim. I've tried Kate so far and it's nice. Netbeans and Eclipse are good if you like IDE's. They're powerful, but tend to be hogs. You get the advantages of developing on a POSIX box without the annoyances of OS X. Edit: [8]
Space isn't cheap on a university budget with university bureaucracy. When I was in school (2006) we had a 100MB quota, and right now my ~/.rvm is 1.3GB.
Netbook much? A netbook is not an Apple Laptop. Also, why try to move away from vim, it's cross platform and fast? (Unless you're bad at it)
I code exclusively on a Netbook with Ubuntu and VIM. I'm with halogen64. Why would you want to get away from Vim?
I would say yes. I work on a Dell Mini 9 running Ubuntu and Vim and it handles quite nicely.
I've used it exclusively for over ten years; I just want to explore the landscape a bit.
Nice. How did I go this long without knowing about "git checkout -b"?
Thanks people for the quick response! Reading yours comments help me to decide to buy a HP netbook! I already have a laptop but is to big, it has a 17'' monitor'. I think I will use Github, or something like that, to synchronize my code and Ubuntu with Vim to program in Ruby. 
Do you use Ubuntu Netbook or the normal version?
Makes sense. Any replacements in mind so far?
no.
HP makes a nice netbook. FYI if you want to go the hackintosh route, you should go Dell Mini.
&gt;I know I am. I do all three. So you prove me right.
I dunno man. A netbook's screen seems very small to program on to me. Maybe some people like it, or as an emergency at-hand box or something, but as far as even a secondary programming machine? I just don't think the form factor is built to handle it. More importantly, I think it would kill my wrists. That seems, personal opinion with no experience, like a nightmare for posture, even relative to using a laptop computer. I just don't think I could do it. My 13" laptop is decent in form-factor, and in my opinion pushing what is acceptable in screen real estate. Shrinking the keyboard and screen to 9" seems like a bad move. I wish I could have it, I just don't see it working out.
wat
them sound like fighten words..
If you have a lot of tests forget it. Get yourself something beefy. Asus makes a 14" laptop which is a little bigger than a netbook but has an i5 processor.
Being from Chicago, I always have a hard time with Kansas City being considered the Midwest. Sorry
I have a Dell Mini 10v that is hackintoshed and I use it occasionally for coding. It's really small and it becomes rather taxing to have it run my tests, various app servers, etc. I only use it when I absolutely need to for coding. My primary machine is a Macbook Pro 15" and there are times where I don't want to bring it into situations where it might get stolen or broken so the 10v fits the bill.
Once you finish the Rails book you'll know how to use the Rails API's, you will have next to nil understanding of the Ruby language itself and you will still be wondering how everything works, do yourself a favor and grab a copy of the pickaxe and read that, it honestly should be required reading for every ruby developer.
I've been writing Rails apps professionally for over a year now. I started with AWDWR as well. After the book you'll be able to build something with roughly the complexity of the demo app. More if you really pay attention in the API chapters. After you've done a little more reading, I'd recommend you choose an app you want to create that seems reasonable given your skill level. Spend a bunch of time on this. Run into problems, discover good ways of finding solutions. The best way to learn this stuff is by trying it, failing, researching, and succeeding. Along the way, you should read 'The Rails Way.' It's a little dated, but goes into greater depth than the PragProg book. It'll help you make the jump to intermediate. Don't spend too much time reading though. 2 hours spent trying to get your app to work is worth probably 8 hours of reading.
I own the Pickaxe book and I feel that it's not really a good book for learning Ruby. The style of Ruby that Pickaxe shows is not what you see when looking at other Ruby programs that people have produced. Looking at the SongList container example at [http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_containers.html](http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_containers.html). I don't think any competent Ruby programmer would code it like that.
No, a competent ruby programmer would realize that they're just rewritting the hash class with a different name, but it's a tutorial to introduce you to the standard library, not best practices.
the pickaxe is a horrible book.. i've read it a couple times to try to figure out it if was just my problem. it teaches you non-idomatic ruby code and is just generally confusing. i would recommend getting "the ruby way" and "the ruby programming language" written by matz. 
Basically, this. Also, if you can, after you complete get your first app in a working condition, find some more experienced ruby programmer to review it and give you hell for bad style. If none are available, find the big RoR coders on github and go over their code, watch how it works. PS If you would do only one single thing to improve your Ruby/Rails coding, I would recommend learning the Enumerable module by heart. Knowing it can very often shrink code size by half (and very likely increase efficiency too). PPS If you haven't already, watch [railscasts](http://railscasts.com/).
I first learned from the pickaxe book and it took me a while to realize that I didn't really know Ruby at all. And that's after a few Rails apps. Then I just started reading other people's code for examples and finally read "The Ruby Programming Language" which is an excellent book.
There is one thing not mentioned there, and that one thing is made from solid gold: git stash. You are coding along, modifying your working directory. Nothing commit-worthy yet. Then, something else needs doing! Urgently! Deadline, yesterday! 1) git stash - all your modifications are tucked away, and you are left with clean working directory, as it was after last commit. 2) Work on that urgent thing and commit it, 3) git stash apply - all your previous uncommitted modifications are applied on top of the urgent thing and you can continue with whatever you were doing. Awesomeness. 
yo. AWD is alright, pickaxe kind of sucks. i read both, but a lot of things didn't really click for me until i read dave black's most excellent Ruby For Rails (http://www.manning.com/black/). i consider this book indispensable for somebody learning ruby. also, and i think someone else mentioned this before... railscasts are your friend. and peepcode. and pragprog's screencast. actually, dave thomas' screencast on the ruby object model (you probably don't want to watch that quite yet :) is awesome, even though his books are kind of bad. 
Going through the railstutorial.org site was essential for my learning of rails/ruby.
Wrong book (in my opinion). Try the Rails Way. It's starting to go a bit out of date but it's the best Rails book and I still go back to reference it regularly. Another book I recommend is Design Patterns in Ruby. While it applies to Ruby in general it uses many parts of Rails as examples. You'll understand better why Rails does things the way it does and why it's so difficult to do the same in many other languages. It's very well written and you'll rarely find yourself struggling to understand something. Even if you're already familiar with design patterns it's still worth reading this to see how Ruby makes implementing much easier. I wouldn't get too disheartened either. Rails can seem a bit magical at the start. After a while everything starts to click and you start to understand more intuitively how things should go together.
If you were confused like me, advance slides by pressing the arrow keys.
I guess we all tend to think geocentrically, but I'm pretty sure Kansas City is right there in the Midwest: http://en.wikipedia.org/wiki/Midwestern_United_States#Definition
[Public link](http://www.elance.com/job?jobid=19716847)
Page Down and Page Up work as well.
thanks for posting this! 
 function keyDown(event) { var key = event.keyCode; if (event.ctrlKey || event.altKey || event.metaKey) return true; debug('key: ' + key) if (key &gt;= 48 &amp;&amp; key &lt;= 57) // 0 - 9 { gotoSlidenum = gotoSlidenum * 10 + (key - 48); return true; } if (key == 13 &amp;&amp; gotoSlidenum &gt; 0) { debug('go to ' + gotoSlidenum); slidenum = gotoSlidenum - 1; showSlide(true); } gotoSlidenum = 0; if (key == 32) // space bar { nextStep() } else if (key == 68) // 'd' for debug { debugMode = !debugMode doDebugStuff() } else if (key == 37 || key == 33) // Left arrow or page up { slidenum-- showSlide(true) // We show the slide fully loaded } else if (key == 39 || key == 34) // Right arrow or page down { nextStep() } else if (key == 82) // R for reload { if (confirm('really reload slides?')) { loadSlides() showSlide() } } else if (key == 84 || key == 67) // T or C for table of contents { $('#navmenu').toggle().trigger('click') } else if (key == 90) // z for help { $('#help').toggle() } else if (key == 70) // f for footer { $('#footer').toggle() } else if (key == 27) // esc { removeResults(); } return true } 
All of the above comments are pretty spot on, though I'd also recommend picking up a copy of martin fowlers Patterns of Enterprise Application Architecture. Most of the patterns encapsulated by Rails came from this book and it gives a really good idea of how they work and when they're useful
Awesome presentation. Bookmarked.
Yep :)
I would like to thank everyone for their comments and suggestions and encouragement. I have copied all of your suggestions, books, and recommended vids. Look forward to going through them all.
Am I missing something?
Hey, I'd just like to point you to the website [guides.rubyonrails.org](http://guides.rubyonrails.org) - it's a great and somewhat regularly updated source for various (free) guides to working with different parts of Rails. Definitely do check it out. Oh, and good luck!
You can root your box with .debs or .rpms too. Both package formats allow you to run arbitrary pre and postinstall scripts.
Edited for clarity. Late night posts are bad.
Nice I am hoping to play with Hydra soon. I saw this presentation at RubyNation
I deleted my OP to correct the link.
Uh, isn't RoR already built into OS X?
I am no expert, and when I tried out briefly it was on linux. Do you want to try following this guide and see how it works out for you? http://hivelogic.com/articles/ruby-rails-leopard Or you can always have a Virtual Machine running linux. http://senthilnayagam.com/home/show/railsappliance http://www.vmware.com/vmtn/appliances/directory/220 Or google is your friend, I remember there was another ready Virtual Machine image with everything setup for RoR
My problem is not specifically with RoR. I mucked up the MYSQL install and, yes, i have tried to fix it myself. However, i can either keep bashing my head against the wall - all the while not getting work done -or i can ask an expert
why do you need a new computer for rails?
No Ruby is a language and it is included in the OS X developer kit. Ruby On Rails is a framework that sits on top of the Ruby stack.
Correct, and yes it is very easy to install RoR 'gem install rails' so my issue is more with my botched attempt at mysql.
Use the [homebrew](http://github.com/mxcl/homebrew) system. It works flawlessly to install MySQL, PostgreSQL, and many other neat programs (htop FTW!). 
Hopefully someone will pick up the job; I remeber having issues a couple years ago when first installing it directly. If not, and if you don't have a totally b0rked mysql install, you can try homebrew and, if you have problems installing the mysql gem, take a look at this: http://ozmm.org/posts/homebrew___mysql___snow_leopard.html The good thing about homebrew is that if you have issues with the install, it's much easier to delete it than when it's installed directly.
Dude I can do this for free for you… if you promise to get good and give back to the ruby / rails community heh..
Because of the 64bit issue?
&gt; No Ruby is a language and it is included in the OS X developer kit. Ruby On Rails is a framework that sits on top of the Ruby stack. No shit, Sherlock. Rails is trivial to install on OS X once Ruby is already there.
For an easy way to get mysql, install XAMPP: http://www.apachefriends.org/en/xampp.html You can use it to selectively turn on an off Apache and mysql. Works perfectly.
heh free is awesome. No chance of 'getting good' though. I really am just a designer. I live in Views and nothing more :) BTW. I now have rails properly in /usr/local but MYSQL is still borked. I'm thinking it is a socket issue coupled with some user permission gunk somewhere. 
durrr, use the computer you posted this on…
His newer book, The Well-Grounded Rubyist (sort of an update of the Ruby for Rails book), is fantastic as well. I think there's a lot of overlap, but Well-Grounded is updated for 1.9 as well.
It is actually installed in OS X along with Ruby as of Leopard: http://weblog.rubyonrails.org/2006/8/7/ruby-on-rails-will-ship-with-os-x-10-5-leopard Of course, it's an older version, but it's easy to update.
why not just: module Utility def self.be_useful(input) "I got #{input}" end end Utility.be_useful("Hello World") 
If you have just one method, it really doesn't make much of a difference, but if you have many methods in the module, `extend self` just looks a bit nicer and cleaner.
Yes, at the expense of making them look like mixin methods. I think it's much better style to be explicit and not hide the context of a method definition just so it looks nice.
Take FileUtils for example. You can use it like this: FileUtils.rm("/tmp/temp_file") FileUtils.cp("/home/jsixpack/.passwords", "/tmp/temp_file") or like this: include FileUtils rm "/tmp/temp_file" cp "/home/jsixpack/.passwords", "/tmp/temp_file"
Why not use 'module_function' ?
Middlewares are Lego bricks. Applications are the thing you make out of the Lego bricks, which in the end are just bigger Lego bricks that could be attached to other Lego bricks. 
FileUtils (im quite sure) uses `module_function`. Just like the Math module.
BTW, the interview with Obie Fernandez doesn't come out until Tuesday, May 27th. If you'd like to ask the guests questions, follow @coderpath on Twitter.
Just like last time, it's a registrar problem, not a "hijack"
As an interviewee, I fully endorse this message.
And they chose Linux after a careful analysis of the differences between Linux, AIX, Solaris, HP-UX and FreeBSD, right? Haha, yeah, right. Every Linux user chose it because that's what they love and/or that's what they know. Just like those managers who chose Windows.
&gt;And they chose Linux after a careful analysis of the differences between Linux, AIX, Solaris, HP-UX and FreeBSD, right? Well most linux users I know have used freebsd at some time or another. Every single one I have ever known has used windows. The same things can't be said of windows users. Most windows users have never used anything else. &gt;Just like those managers who chose Windows. They don't know anything else. They have never used anything else. Their choice is based on ignorance and zealotry, not first hand knowledge. 
As someone who knows the podcasters, I also endorse this podcast. Though my vote would be for "codercast" as the name :) 
You're wrong, it is a hijack, apparently (because of registrar being a bunch of idiots, but that's academical now). 
fixed
Well, if you're getting into ruby you'll be using ruby gems. You might as well check out: http://www.gemcutter.org and the source: http://github.com/qrush/gemcutter
I'm writing a small rails app for one of my classes right now. I just pushed it to http://github.com/bakineggs/brush_me_up . There's one resource that can be managed at the moment. I'm going to be adding in account functionality tomorrow night (probably using authlogic) and make everything unobtrusive javascript-y next week (project proposal w/ tentative schedule at http://github.com/bakineggs/brush_me_up/raw/master/doc/proposal.pdf if you're interested). Hopefully looking at this project could help you out a bit.
Here are some more Rails apps from Github : http://github.com/railsdog/spree http://github.com/engineyard/rails_dev_directory http://github.com/katipo/kakama http://github.com/insoshi/insoshi http://github.com/opencongress/opencongress http://github.com/riseuplabs/crabgrass http://github.com/edavis10/redmine http://github.com/michaeldv/fat_free_crm http://github.com/stevenbristol/lovd-by-less http://github.com/xaviershay/enki http://github.com/fdv/typo http://github.com/resolve/refinerycms http://github.com/bsag/tracks_manual http://github.com/micho/teambox http://github.com/wagn/wagn http://github.com/jamis/bucketwise 
Be aware of that Spree isn't really a well-designed app (at least not from my point of view). It seems to suffer from "this e-commerce app needs every single feature out there"-syndrom. Just have a look at the [models folder](http://github.com/railsdog/spree/tree/master/app/models/)…
I have said it before and I'll say it again. Bundler is inadequate. It could even be argued it's unnecessary. Bundler does not install OS packages that are needed by gems and there is no way to specify them in the first place. What good is specifying Rmagick in your gems when you have to install imagemagick and a series of *-dev packages? This is a solved problem. Automateit and chef(solo) already handle gems as well as system packages and yes even configuration. Rails needs to pick one of those. This way you can do everything from your ./automateit directory. Install apache, install passenger, configure apache, configure passenger, set up the domain for your app, install the required packages, restart apache, install and configure postgres, create your database, create the users for your database, and then migrate. All this could be done with automateit or chef. Bundler is a pale shadow that in the end is really not that useful.
just hired a dude on Elane. The MYSQL DMG didn't work quite right so we just used macports. a little fussing around and all is fixed. Not sure what the issue was and, being a non-programmer, I agree that I probably could have figured it out on my own but there really is something to be said for just paying an export $50 and letting that person do what they do best. thanks all for the tips. Due to them I was able to get rails issues worked out on my own which allowed for a lower bid on Elane that just focused on MYSQL
upvote for no other reason than these dudes are based in DC :)
I've learned more from looking at the Redmine source than anything else, but sometimes I think it's a bit too much for a novice like myself. It would be easier to learn from a smaller app that was well designed from the beginning, rather than one that grew and evolved over a period of years. As a learning exercise, I'm rewriting it from scratch.
You sir are very wrong. Chef is useful for setting up a system sure. But Bundler's job is dependency resolution and a constraint matching system to ensure that a machine has the ruby code necessary to run. It's not Yum, so i'm not surprised it doesn't package ALL your project dependencies (but then again, neither does rubygems), and it's not Chef so it's not specialized to doing only server deployment. Bundler has it's niche and it's an important one. -------------------------------------------------------- I also find it quite depressing that you don't see an application for Bundler outside of the scope of Rails. Bundler is not a piece of Rails equipment. It's a general tool which Rails happens to use. Much like Rubygems.
&gt;But Bundler's job is dependency resolution and a constraint matching system to ensure that a machine has the ruby code necessary to run. That's a job chef and automated can handle very well. They are supersets of bundler. &gt;It's not Yum, so i'm not surprised it doesn't package ALL your project dependencies (but then again, neither does rubygems), and it's not Chef so it's not specialized to doing only server deployment. The idea of bundler is that the server you deploy to must have the gems you need. It is very much a server deployment tool. Where it falls short is when the gem you require is dependent on packages in the OS. Bundler falls short in that scenario and chef shines. &gt;Bundler has it's niche and it's an important one. I disagree. There are other tools that fill that niche even better. To me bundler is a duplication of effort. &gt;I also find it quite depressing that you don't see an application for Bundler outside of the scope of Rails. I have been using puppet, automateit and chef. For my ruby apps (rails or otherwise) I most often use automateit. I have a rake automate task which makes sure all packages are set up propertly, all gems are installed, all symlinks are present, apache is configured properly for the domains I am using, passenger is installed and configured propertly, postgres is installed properly and configured for my needs (including kernel tweaking), the proper databases are created, the proper database users are created etc. Bundler wouldn't even come close to doing anything close to that. the nice thing is that it's idempotent so that I can run rake automate on every deployment without messing things up. I also have a bootstrap script which I copy to a fresh server and run so that I can get ruby, gems and automateit installed correctly. So on a new machine I do the following, copy the bootstrap script. Execute it. cap deploy. That's it. Automateit takes care of all the rest including installing apache, passenger, postgres etc. 
I prefer the idea of Catalyst.
&gt; I also have a bootstrap script which I copy to a fresh server Never heard of automateit (hasn't showed up in the rails related feeds I read), can you share this bootstrap script or maybe point me to a quick intro (specific to deploying rails)?
First you push your automateit project to the server. rsync -avz --delete * $1:/opt/automate ssh $1 '/opt/automate/bootstrap.sh' The bootstrap file looks like this. # Install the minimal set of packaged need to get automateit running apt-get -y install ruby1.8 ri1.8 rdoc1.8 irb1.8 ruby1.8-dev rubygems libopenssl-ruby subversion git-core stow build-essential ln -s /usr/bin/ruby1.8 /usr/bin/ruby ln -s /usr/bin/gem1.8 /usr/bin/gem # Install automateit gem install rake automateit --no-ri --no-rdoc ln -s /var/lib/gems/1.8/bin/rake /usr/local/bin/rake This part is optional, you might want to do it manually. # Apply recipes cd /opt/automate ./automate.rb Automate.rb looks like this. begin require './config/environment.rb' require 'automateit' require 'helpers' require 'socket' # let's turn our application into an automator interpreter @ai = AutomateIt.new @ai.include_in(self) options = {:preview =&gt; true, :log =&gt; QueuedLogger.new(STDOUT)} setup(options) process_host Socket.gethostname rescue =&gt; e ERRORS &lt;&lt; {Socket.gethostname =&gt; "#{e}\n#{e.backtrace}"} ensure process_errors end the function process\_errors sends an email when something goes wrong. You have to build the recipes but they are pretty easy. For example here is a recipe to install passenger. modified = false modified |= package_manager.install "apache2-prefork-dev" modified |= package_manager.install "passenger", :with =&gt; :gem, :docs =&gt; false version = `gem list passenger --local`[/ \((.+?)\)/, 1].split(', ').sort.last passenger_path = File.dirname(`gem contents passenger --version #{version}`.split.first) ruby_path = nil ["/opt/ruby-enterprise/bin/ruby", "/usr/local/bin/ruby", "/usr/bin/ruby"].each do |path| if File.exist?(path) ruby_path = path break end end raise "Can't find Ruby's path" unless ruby_path passenger_so = "#{passenger_path}/ext/apache2/mod_passenger.so" if modified || ! File.exist?(passenger_so) sh "yes | passenger-install-apache2-module" end modified |= render :text =&gt; &lt;&lt;-HERE, :to =&gt; "/etc/apache2/mods-available passenger.load" LoadModule passenger_module #{passenger_so} PassengerRoot #{passenger_path} PassengerRuby #{ruby_path} HERE Facts.passenger= Mash.new unless Facts.passenger #lets construct the contents of the passenger.conf file #based on params and defaults. file_content = {:RailsEnv =&gt; 'production', :RailsDefaultUser =&gt; 'www-data', :RailsPoolIdleTime =&gt; 600, :PassengerMaxPoolSize =&gt; 30 }.merge(Facts.passenger.to_hash).inject("") { |s, (k,v)| s +="#{k} #{v}\n" } modified |= render :text =&gt; file_content, :to =&gt; "/etc/apache2/mods-available/passenger.conf" modified |= apache_manager.enable_module "passenger" apache_manager.reload if modified Notice this also installs apache. You can use your imagination for the rest. 
I don't think you understand the problem. Bundler isn't about server deployment. Bundler is a tool for consistency checking an environment. I think it's much more useful as a development tool. The fact that it can be used to consistency check production/server deployments is an ancillary benefit. Bundler gives you a way to describe your app dependencies. It provides a method for for verifying your full dependency tree is consistent. AND it happens to provide a way to stash all of those dependencies in a sandbox for you to use. The sandbox is again, ancillary. It's there because frankly, once bundler has achieved it's task, it's got all the info/tools you need to do the packaging and sandboxing. Neither Chef nor Automateit do sandboxing nor dependency resolution. They are not supersets of Bundler's functionality or goals. Please stop spreading FUD.
Being from Kansas City but living in Michigan, I have a REALLY hard time understanding why Michigan (on the northern border of the U.S.) is considered Midwest, yet it's so.
As notheory already said, you misunderstand the purpose of Bundler. Bundler is not a subset of Chef/Puppet/AutomateIt. You'll most likely have to use Chef/Puppet/AutomateIt *and* Bundler together. The core problem is the fact that RubyGems supports multiple parallel package versions. Dpkg, RPM and many other native packaging systems do not. This single feature introduces a new class of dependency solving problems which Chef/Puppet/AutomateIt/apt-get/yum were not designed to handle. Read some of Yehuda's blog post about gem activation problems.
Okay? So what are you doing in a thread about ruby package management?
Commenting that Catalyst is better. Get over it, dipshit.
&gt;Bundler isn't about server deployment. Bundler is a tool for consistency checking an environment. So is chef and automateit. They are just better at it because they consider the entire environment not just the gems. &gt;Bundler gives you a way to describe your app dependencies. It provides a method for for verifying your full dependency tree is consistent. AND it happens to provide a way to stash all of those dependencies in a sandbox for you to use. This statement is false. Bundler aims to be that but it isn't. This is because many gems require packages provided by the distribution and will not work unless they are installed. &gt;Neither Chef nor Automateit do sandboxing nor dependency resolution. Both of them do dependency resolution. Adding sandboxing would have been easier than writing bundler from scratch. &gt;They are not supersets of Bundler's functionality or goals. They are absolutely supersets of bundler.
&gt;This single feature introduces a new class of dependency solving problems which Chef/Puppet/AutomateIt/apt-get/yum were not designed to handle. Actually that's the exact problem they solve. They abstract away packaging systems, and other resources giving you a uniform way to install and maintain packages and gems (and other things). 
Dude you need to clue yourself in. I'm not the only one telling you this. I'm just the only one stubborn enough to keep going. You are really really really wrong on this. EngineYard uses Chef for a **ton** of stuff. And guess what, they were also primary contributors to Bundler. There's a reason why they saw a need for both tools. &gt;&gt;Neither Chef nor Automateit do sandboxing nor dependency resolution. &gt; &gt;Both of them do dependency resolution. Adding sandboxing would have been easier than writing bundler from scratch. Can you please point me to the part of Chef that does gem dependency resolution?
No Chef was designed to do server setup automation. The fact that Chef can interface with package managers doesn't make them dependency resolution tools, it means it can interact with dependency resolution tools *like bundler*.
&gt;You are really really really wrong on this. EngineYard uses Chef for a ton of stuff. And guess what, they were also primary contributors to Bundler. There's a reason why they saw a need for both tools. I don't know what their reasoning was. My guess is that they thought chef was too heavy. Their default install is server based and chef solo is merely a "side effect" for them. The default chef install is insane in it's dependencies and nobody except a serious sysadmin is even going to attempt it. Automateit on the other hand is very lightweight. BTW I use automateit for this exact purpose so don't go around saying I am really really wrong or that I am stubborn. I know it works because I use it. My guess is that you haven't used either automateit or chef (I have used both) and chances are you haven't used bundler either. 
Whatever dude. You can go read their reasoning, there are plenty of blog posts about it. You clearly don't get why bundler exists, and obviously you're not going to let anyone convince you of it. Have fun being wrong, but please stop bothering other people about it. And as a parting shot, explain to me why ruby projects, web based or not, are adopting bundler as a way of maintaining their environments and dependencies, and not Chef or Automateit? :P Since you obviously think you have enough insight to tell me what i have and haven't used.
I actually like the first approach. Its simple to read, and obvious what the what code does. In my view that's what make code elegant -when the intention is obvious and the code is simple. Not sure how collect would make it simpler.
something like: Hash[lines.map{|line| line.split /:/}.flatten]
I've wanted something like this before... module Enumerable def hash_map hash = {} self.each {|o| hash.store(*yield(o))} hash end end my_hash = lines.hash_map {|l| l.split /:/}
I'd probably use inject. myHash = lines.inject({}) do |hash,line| key, value = line.split(/:/, 2) hash.merge({key =&gt; value}) end
This is slightly better in some ways in that it's an expression, but it's still very ugly: myHash = lines.each_with_object({}) { |x, h| { key, value = line.split /:/ myHash[key] = value } } This is one thing I miss from perl, where you can simply do %myHash = map { split /:/ } @lines;
More examples of using inject to convert an array to a hash and vice-versa at http://blog.jayfields.com/2008/03/ruby-inject.html
Sigh, I give up. I directed you to Yehuda's blog posts but you either didn't read them or you read them but still don't understand the difference between Bundler and Chef/Puppet/etc. Go ahead, throw out Bundler and use solely Chef/Puppet/etc. You *will* one day find out that Chef/Puppet/etc are not supersets of Bundler and that you actually need to use them *in combination with* Bundler.
in fact, Hash[ *lines.map{|line| line.split /:/}.flatten ] but still quite ugly. I'd probably go with the inject.
&gt;You clearly don't get why bundler exists, and obviously you're not going to let anyone convince you of it. Have fun being wrong, but please stop bothering other people about it. I get why it exists. I am merely pointing out that it does not deliver what it promises. It's as simple as that. Go install any modern rails CMS for example. If the gems were specified in bundler it would fail. They all require Rmagick and rmagick can't be installed without installing some OS packages. Bundler doesn't help you at all. Same goes for a lot of other gems. You want sphinx? Yup you need native packages, you want EM? you need some packages. How does bundler help you there? It doesn't. &gt;Since you obviously think you have enough insight to tell me what i have and haven't used. &gt;And as a parting shot, explain to me why ruby projects, web based or not, are adopting bundler as a way of maintaining their environments and dependencies, and not Chef or Automateit? :P Because many are not aware that automateit exists. Chef is a bit more visible but a brief foray into the chef wiki is enough to get most people running away in fright due to it's highly disorganised state and emphasis on the server based chef install. People are probably going "I need couchdb, openid and runit? No thanks". The only people who are willing to go through that much trouble are people who need to manage lots of machines. &gt;Since you obviously think you have enough insight to tell me what i have and haven't used. Have you used automateit? Chef solo?
&gt;You will one day find out that Chef/Puppet/etc are not supersets of Bundler and that you actually need to use them in combination with Bundler. I already said I use automateit in place of the extremely incapable tools that come with rails. I will continue to do so because bundler doesn't help me at all. There are dozens and dozens of gems which will not install unless you install OS packages first and bundler does NOTHING about that. It just fails. 
Naming convention… myHash → my_hash Anyway, but why do you say your first solution is "kind of fugly"? my_hash = {} my_file.each_line do |line| k, v = line.split(/:/,2) my_hash.merge!( {k =&gt; v.chomp } ) end 
If you think that's fugly, take a look at C++ that does the same thing.
array &lt;&lt; value in an each is fugly next to a collect; generalising the principle, then, hash []= in an each is fugly next to a nonexistent\_enumerator\_method I suppose I'm going for the functional-is-better approach here. 
I don't know if this is better or worse than other ideas, but I didn't see it when I read the comments: pieces = lines.map {|ln| ln.split(':') }.flatten Hash[*pieces] Edit: My bad. I see someone else did post something similar. Damn.
It's disheartening that you are getting downvoted. Edit: I just noticed that probablycorey [reimplemented](http://www.reddit.com/r/ruby/comments/buytk/collectlike_method_for_populating_hashes/c0oolls) similar behavior using ruby's powerful reflection functionality.
FYI, when you use inject on a hash, you have to return the hash as the last line of the block. irb(main):001:0&gt; (0..4).inject({}) { |h,i| h[i]=i.to_s; h} =&gt; {0=&gt;"0", 1=&gt;"1", 2=&gt;"2", 3=&gt;"3", 4=&gt;"4"} 
Agreed. The problem with Ruby that I've seen in larger companies. One guy writes the "cool" version that uses a bit of functional "inject" with some splat * coolness, to write a one-liner. But the poor guy in the cube next door is still learning ruby, and struggles with it. Code is meant to be read. The code you write should be boring and easy to read. 
Sounds like what you're describing is almost YAML format. And, in that case, a simple: &gt; require 'yaml' &gt; YAML.load(File.read('input.txt')) Would do the trick.
With this approach it's probably better to use update instead of merge in order to reduce the number of necessary temporary hashes.
There are multiple syntax errors in this. Perhaps you meant this? myHash = lines.each_with_object({}) { |x, h| key, value = x.split /:/ h[key] = value }
Just an FYI on installing DB2 drivers on x86_64 machines... If you have any build issues with the DB2 drivers, it's because it points to $DB2HOME/lib instead of $DB2HOME/lib64 - I found renaming lib and symlinking lib64 to lib seems to solve that issue. 
hash.merge() generates a new Hash object each time it is called and this creates a tremendous amount of garbage. The pattern to follow is simply: hash = lines.inject({ }) do |h, line| parts = line.split(/:/) h[parts[0]] = parts[1] h end Also, why is this question here and not somewhere sensible like [Stack Overflow](http://stackoverflow.com/)
If you're looking for the least amount of lines, this is probably pretty close to minimal: lines = %w[ a:1 b:2 c:3 ] my_hash = lines.each_with_object({}) do |line, hash| hash.store( *line.split(':') ) end p my_hash # {"a"=&gt;"1", "b"=&gt;"2", "c"=&gt;"3"}
Death to 1.8.6
lol no RIP for the ruby most people were first introduced to? ;) I'm not sad to see it go, but we had good memories i guess?
Oh dear, you're right... must have been asleep. That'll teach me to post code without testing it. :P
I have stayed away from DB/2 because I presumed it would be expensive as hell and really postgres does everything I need. How does the DB/2 soap server thing work? Do you write your soap services in java or something? Can it proxy the calls to your rails app?
This is great news. 1.8.6 was nice, but a lot has happened since then.
C++ the language does not even have inbuilt hashes. 
Yay, let's move foward :)
Anyone cares to elaborate and maybe explain what's wrong with 1.8.6 language-wise? I mean, I can see 1.8.7 has many features not available in 1.8.6, but those that I have seen can be easily implemented in 1.8.6. I thought you could have a relatively small (~1000 LOC) file that you require with 1.8.6 to make it compatible with 1.8.7. What am I missing?
Ruby 1.8.6 was my first love.
1.8.6 doesn't utilize the Enumerator class; Array#each wont return an Enumerator object if no block is given. But mainly 1.8.6 lacks YARV and thus is sloooow.
You're saying that like it's a bad thing.
Poor job, imho. "out" is useless, you already have "puts" in your "DSL". and "sum" should be: def sum elements; elements.inject(0, :+); end (also, sum() [and sigma() and mean() and whatnot] shouldn't be functions at all; you're much better off having them as methods on Enumerable anyway)
The backports gem provides some upwards compatibility like this: http://rubygems.org/gems/backports
ask in stackoverflow.com it's weird to ask in the ruby reddit
Using merge makes it functionally correct and easier to reason about. Greg Brown once wrote a large blog rant about why it is important to use immutable operations within inject, but the link is lost to me. But yes, it does create a tremendous amount of garbage. If you run a Haskell program with the garbage collector beeping, you will hear what is scientifically known as a shittonne of beeps.
#merge returns a new Hash so he's safe
Yet another reason jruby rocks so hard.
This is the third such project i've seen, after jsruby and red. 
yeah but mattknox is awesome :)
You can just call it a compiler, since that's what it is. :-) A compiler is just a tool that transforms one language into another. 
Cool. Learn something new everyday. 
Pimprish.
When faced with the decision between "tons of garbage" and "not functionally correct", I will always choose the latter. Until Ruby actually does something useful and clever when given a functional definition like parallelize it, as many pure functional languages do, it seems more responsible to go with the more efficient approach.
A little more description and screenshots would be helpful.
Something that actually describes what I'm looking at, or how to use it would be nice. I use passenger everywhere - I don't understand the point of this.
More info here http://github.com/colouringcode/passenger
RIP 
Wow, ASP.NET suddenly sucks a lot less. I'll still take Rails over it, though. :)
I just thought that I should say this somewhere, but VisualVM has got to be one of the greatest tools ever, and JRuby has the opportunity to use it. JRuby developers, take advantage of VisualVM, please.
Why is he comparing ASP.NET with an IDE to rails without? Netbeans, aptana, and rubymine are all excellent IDEs for rails and ruby development. 
It's not ASP.NET. ASP.NET is still the shitty ASP.NET. This is the less shitty ASP.NET MVC (nice going Ms marketing) which was copied from the open source castle project which was the unpteenth copy of rails. Say what you want about rails but it sure did cause an earthquake in web development and spawned a thousand clones in every language.
&gt; which was copied from the open source castle project Interesting, I hadn't heard that. How did you find out that this was the genesis for ASP.NET MVC?
Same dev team is behind MVC and Castle; at least, it's core members.
Because Rails is usually used without one and ASP.NET is almost always used with one.
Why the downvotes? Is there something incorrect, or do people not like ASP.NET being called shit?
Really? Who?
When passenger errors it tells the world that passenger is running and gives you a great big stack trace. These guys have given you control over what is shown and even given you a template generator to roll your own.
No need to splat or flatten Hash[ lines.map{|line| line.split /:/} ]
&gt;Because Rails is usually used without one and ASP.NET is almost always used with one. Everybody I know who programs in rails uses an IDE.
This place consists mostly of windows programmers who don't like to hear the products they bought being badmouthed.
He's not doing the language any favors by basically saying Windows developers should just give up. JRuby and IronRuby both perform fine on Windows and are easily viable options for doing real work in Ruby on Windows. JRuby more so than IronRuby right now but IronRuby is catching up quickly.
Site is down, [Google cache](http://209.85.129.132/search?hl=en&amp;q=cache%3Ahttp%3A%2F%2Fblog.sirupsen.dk%2Fme%2Fwhat-i-wish-a-ruby-programmer-had-told-me-one-year-ago%2F&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;gs_rfai=).
&gt; This place consists mostly of windows programmers The /r/ruby subreddit?
I meant reddit in general. 
&gt; so I started by going back to the roots. HTML &amp; CSS which I had coded when I was about 10 God, do I feel old.
I remember gwbasic on msdos 3.0 when I was 10...
I do agree with him on Python - having used Ruby a lot, moving to Python is rather painful. You miss the Enumerable mixin a lot... I hate that not everything is an object or class method in python - where somethings are just functions not belonging to a class. It bugs me. 
When I was ten, I was one year away from getting a [TRS-80 color computer](http://en.wikipedia.org/wiki/TRS-80_Color_Computer) and learning BASIC on it.
Yeah, I'm curious too. I didn't know Gu, Haack, Wilson or any of those guys were involved with Castle.
Windows isn't ideal but you can get the job done in it. I've developed, debugged and deployed RoR on Windows machines before and there's no huge surprise with using a non-*nix OS.
It's not the ruby platform that's lacking in windows, but the unix tooling. Most of the learning resources assume you have access to these, which can be frustrating for someone new to the language.
I _hate_ how there's this constant contest among people who write about programming to brag about how young you were when you started or how esoteric the programming language was. It adds nothing to the post and quickly turns any discussion into a bunch of morons making shit up and bragging about how big their nerd-penises are.
In my defense, I was only being nostalgic [when I did it](http://www.reddit.com/r/ruby/comments/bx733/what_i_wish_a_ruby_programmer_had_told_me_one/c0p197k)... and also to emphasize how much older (but hardly wiser) I now feel compared to the OP.
What the hell is this lame crap.
I used to drool over the coco at the entrance to Radio Shack :-(
Fail for putting stuff on facebrick :( I normally encourage learning/teaching programming. not gonna on facebrick though. Sorry!
&gt;One year ago, I started coding for real again. I dumped wasting times on stupid games and so on. I like building websites, so I started by going back to the roots. HTML &amp; CSS which I had coded when I was about 10 &gt;coding for real again &gt; HTML &amp; CSS lol wat
&gt;“Look at this! Ruby is so narwhal!” I stopped there.
To be fair, it's also because you're kind of a dick, dude. Soft skills matter. (not that I have any but...)
and no one I know does. /shrug
&gt;It's not the ruby platform that's lacking in windows, but the unix tooling. This. I've tried to get Ruby to work on Windows (the 1.9 Pickaxe book has some interesting suggestions), but it's just too much hassle. Better to build a server, offload all the Ruby to the server, and then bring the results back into Windows somehow.
[guitar solo]
Yes, if the array is large, this can produce a fair amount of garbage. For many use cases, the amount of garbage is quite small. I would still use merge, but switch to merge!. Returning a bare variable at the end of inject is a code smell for me. myHash = lines.inject({}) do |hash,line| key, value = line.split(/:/, 2) hash.merge!({key =&gt; value}) end
I don't know the exact cost of creating a hash with a single key and value only to have it destroyed an instant later, but I'm pretty sure it's higher than inserting another key into an existing hash. Leaving a bare variable at the end is precisely how inject() works and what makes it so powerful. Sometimes you want to leave the existing hash, sometimes you want to transform the whole thing. If it smells funny, it's like blue cheese, somewhat shocking at first but very tasty.
Useless. Of course you don't.
grid = "100x30".to\_grid; 10000.times{ grid = grid.next; puts grid.to\_s}
Good newbie-friendly tips sprinkled on the pages. Thanks.
In other news, you don't need a Thinkpad X32 to code Python.
The title is incendiary, but it's tongue-in-cheek. Of course you don't need a MacBook, but it seems like every other blog out there is how to get rails going on your mac.
Don't mean to be a hater, but I thought that it was obvious that ruby and rails were platform independent(mostly). I, also, overlooked the links to the tutorials. You should've linked straight to the first part of the tutorial with a small write-up at the top. I noticed that there are no links, within the post itself, to the next part of the tutorial, either. No worries. :) Good luck with your blog....
This isn't my blog, just passing it along in case somebody finds it helpful.
Sorry, I don't have Flash installed, nor do I feel like registering with Scribd. 
There is an animation example in the gist too: http://gist.github.com/384487 grid = "100x30".to_grid interrupted = false generations = 0 trap("INT") { puts "\rExiting after #{generations} generations..."; interrupted = true } until interrupted do system "clear" puts grid.to_s grid = grid.next generations += 1 sleep 0.1 end 
I thought that was 5x or 6x faster (1.00/0.16) ...
Well, its just the average, The benchmark differs each time so I just rounded it. All I care about is that it's faster.
You know I always thought migrations syntax was backwards. Instead of typing t.integer foo, bar, baz it should be [ foo, bar, baz], integer Add column works that way. The field name is first. 
Mmmm my first machine. Saving and loading from a tape cassette drive.. so analog, sooo slooowww. 
You know, I never really caught on to Cucumber. The concept of "stories" makes sense but it seems like a whole bunch of complex to me. This list looks pretty good but I really don't like adding tons of dependencies just to do testing, especially on open source projects. If you want other people to contribute/test you need to make it easy to do so. 20million dependencies just to test your code is not making it easy. Just my $.02
been out forever but I am always referring to it!
&gt; The concept of "stories" makes sense but it seems like a whole bunch of complex to me. It is kind of complex, but full stack testing is sort of inherently complex, right? &gt; I really don't like adding tons of dependencies just to do testing With Ruby's general focus on testing, who doesn't already have half a dozen test frameworks installed? And it's not like it's hard to just `gem install cucumber capybara culerity`, right? That said, I use rspec and Factory Girl, personally.
Relevant: http://github.com/rkneufeld/botfly
[rif](http://gitorious.org/ruby-irc) is another great framework
[isaac](http://github.com/ichverstehe/isaac) is another good one.
I wish there was some way to make a new block that already had the captures applied to it, so we don't have to add the two arrays together each time it gets called. It's bugging me that I can't optimize that out :P Nice job, by the way, I can't wait until I find an opportunity to use this.
select{}.collect{} is the most readable. You parse it reading left to right. In my opinion, all the "solutions" are problems.