I am talking about the module in which methods will be defined, as discussed in https://blog.yugui.jp/entry/846.
No. I don't see how my question, especially given the linked question and the linked article, could be interpreted as anything but a question about the mechanics of `def`.
I don’t think that terminology is used anywhere in the language or the implementation.
I don't think there is a term used for it in the language or the implementation. It is, nevertheless, a mechanical aspect of `def`. I'm using the language of the linked blog post.
I think some places call it the ‘definee’ so try searching for that.
I have searched for that as well. There's no way I can see to obtain it.
I'm not sure I have a problem with the inconsistency. `#zero?` and `#nonzero?` always return the correct "truthiness," and there's no point in actually _using_ the return value outside of a boolean expression, so what's the big deal?
Can you give example of what you want to know? You can get all sorts of information from whatever object you are currently within at any given point. On any given object you can call #methods and #instance_variables to see what is available to that object. On any class you can call #ancestors and see, in order, the class hierarchy that it inherits from. I threw some stuff into irb just to play with: 2.5.1 :001 &gt; def cheese(a) 2.5.1 :002?&gt; a 2.5.1 :003?&gt; end =&gt; :cheese 2.5.1 :004 &gt; a = method(:cheese) =&gt; #&lt;Method: main.cheese&gt; 2.5.1 :005 &gt; a.class =&gt; Method 2.5.1 :006 &gt; a.class.ancestors =&gt; [Method, Object, Kernel, BasicObject] 2.5.1 :007 &gt; a.methods =&gt; [:to_proc, :arity, :inspect, :to_s, :hash, :==, :===, :curry, :call, :clone, :[], :source_location, :name, :original_name, :owner, :eql?, :receiver, :unbind, :super_method, :parameters, :cheese, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :instance_variable_get, :public_methods, :instance_variables, :method, :public_method, :define_singleton_method, :singleton_method, :public_send, :extend, :pp, :to_enum, :enum_for, :&lt;=&gt;, :=~, :!~, :respond_to?, :freeze, :object_id, :send, :display, :nil?, :class, :singleton_class, :dup, :yield_self, :itself, :tainted?, :taint, :untrust, :untaint, :trust, :untrusted?, :methods, :frozen?, :singleton_methods, :protected_methods, :private_methods, :!, :equal?, :instance_eval, :instance_exec, :!=, :__id__, :__send__] Another method of note: :receiver I'm not sure if any of that is what you are looking for. I'm really not sure that the def keyword is really all that meaningful. It's like .new for creating Method objects, in my mind.
&gt; ion depends on at_exit and running exit you'll be stuck with having to restart the program to find others. But please correct me if I'm wrong, I haven't run the code I'm pretty sure `at_exit` will create a trap on process exit, so your check won't actually trigger until the program has executed. That means you could boot/run your application without the check firing. Worse you could hit NYI errors before getting warned depending on your code loading process and how good your pre-merge CI is &gt; Would appreciate if someone else has got any idea on how to be able to call my method Could you be more explicit? What are you referring to as "my method"?
Here I is the link on how TruffelRuby implemented an automatic synchronization without a GVL: http://ssw.jku.at/General/Staff/Daloze/thread-safe-objects.pdf (It is quite technical/academical + a lot to read though...)
I thought I'd illustrated that in the links from my original question, but to recap, let's try it another way. Given the following short program: module A end module B end block = proc { puts "&gt;&gt;&gt; starting block eval, default receiver = #{binding.receiver}, default definee = ???" puts "define_method will define method :foo in #{binding.receiver}" define_method :foo do end puts "def will define method :bar in ???" def bar end } A.instance_eval(&amp;block) puts "instance methods in A: #{A.instance_methods(false)}" puts "singleton methods in A: #{A.singleton_methods}" puts "-----" B.module_eval(&amp;block) puts "instance methods in B: #{B.instance_methods(false)}" puts "singleton methods in B: #{B.singleton_methods}" modify the occurances of ??? such that the desired output is: &gt;&gt;&gt; starting block eval, default receiver = A, default definee = #&lt;Class:A&gt; define_method will define method :foo in A def will define method :bar in #&lt;Class:A&gt; instance methods in A: [:foo] singleton methods in A: [:bar] ----- &gt;&gt;&gt; starting block eval, default receiver = B, default definee = B define_method will define method :foo in B def will define method :bar in B instance methods in B: [:bar, :foo] singleton methods in B: []
&gt; and there's no point in actually using the return value outside of a boolean expression, so what's the big deal? Consider a (simplistic) policy object that might use the return value of predicates to create a summary object for serializing and sending elsewhere: class EntrancePolicy def initialize(visitor) @visitor = visitor end def can_get_discount? @visitor.times_visited.nonzero? end # other rules def summary { can_get_discount: can_get_discount?, # other rules }.to_json end end Here, you might expect the return object of `#summary` to be a hash with boolean values that you could pass to, say, javascript or services written in other languages. Having predicates that don't behave like predicates hurts your ability to generalize about how serialized values might be interpreted elsewhere.
&gt;And that's the puzzle. As far as I know, there's no keyword or method that returns the default definee used by def. &amp;#x200B; No, I don't think so. You can use \` Module.nesting.first\` as a first approximation, but this won't work inside a class\_eval or instance\_eval block. But I don't think you really need it since \`def\` is lexical and not dynamic anyway. \`define\_method\` is dynamic, but then you have \`self\` to know where the method will be defined. But I agree that out of the four context in ruby (self, klass, cref, binding), \`klass\` is the only one you cannot introspect.
There are two things you need to distinguish: \- language support \- library support &amp;#x200B; For language support, ruby has been far ahead of python for a long time. Ruby has had continuations since forever, which are like the ultimate concurrency method. From there you can implement fully fledged coroutines (Fibers), and weak coroutines (python and js two way generators). And weak coroutines are essentially equivalent to async/await (in Python async/await is just a weak coroutine that yield/send to an event loop). &amp;#x200B; Then there is library support. I don't think there is a native one in ruby, but you have great gems for that (concurrent-ruby, async). But recall that fibers are more powerful than async/await, they are like goroutines.
Thanks! If I understand it right, they track whether an object is referenced by more than one thread, and only if it is, apply mutex protection on writes. &gt; our technique is capable of: &gt; • reading object fields without any performance overhead, regardless of the object being shared or not, &gt; • enforcing synchronization on the internal object data structures when an object is accessible by concurrent threads, i.e., when one thread performs a field update on a shared object.
Just to be clear, we are down in weeds where I don't typically go. So I am certain I am not explicitly helpful here. But I'm still talking, mostly in a questioning way, to hopefully learn some stuff down here. I just want to give that caveat first. I am wondering if you shouldn't be looking into the lexer and see what it is doing with def. As far as I'm aware, def just defines a node in the AST, that defines the method. As far as I would suspect, default_definee is `self`.
Nice write-up, although what it told me are that materialized views are not a good fit for most of my problems. But that is useful! If you are posting a link, I personally prefer you post it as a reddit link, rather than a reddit text post with embedded link. I think this is not just me but generally considered good manners? You can put your comments in a comment.
Thanks for the feedback. I'll be sure to follow the correct etiquette going forward.
I'm going to love materialized view when postgres implements automatic or regular updates of them. Having to manually update them sounds like too many moving parts to be nice to work with.
It seems like updates are still too expensive to be realistic as totally transparent.
&gt;As far as I would suspect, default\_definee is self &amp;#x200B; No: in \`instance\_eval\` the default\_definee (which I call klass since this is the variable name in mri) is self's singleton class. In \`class\_eval\` the default definee is indeed \`self\`. Otherwise it is the ambient class: &amp;#x200B; \~\~\~ ruby class Foo def foo def bar puts "bar" end end end [foo1=Foo.new](https://foo2=Foo.new) [foo2=Foo.new](https://foo2=Foo.new) [foo1](https://foo1=Foo.new).foo # in \`foo\` the default definee is Foo, so the \`def bar\` define a new instance method of Foo [foo2.bar](https://foo2.bar) \#=&gt; "bar" # bar is indeed available to foo2, not only foo1 \~\~\~
That seems to be an issue inherent to serialization, though. When we package up primitive data for the outside world, we have to take care to make sure the types are correct. A `!!` in front of the nonzero predicate return value can ensure truthy or falsey values are converted to types appropriate for data interchange.
sure that’d work too. but conventions are nice and `?` is often seen as a convention for boolean returns. everything has truthy value in ruby otherwise. having the method return an integer or nil is unexpected in an unpleasant way. i’d prefer a simple `nonzero` alternative to return a count.
Sure, all things being equal, a true/false return value would be slightly more convenient. I just don't see it as a big deal.
Asdf. It works for other tools too, not just Ruby.
Yeah, after working with them, materialized views seemed like tables that included the query to populate their data, which has not turned out to be as useful as just scheduling a regular process to flush and re-populate the table. Regular views, on the other hand, seem pretty useful for adapting a rails system to a pre-existing schema with a data dictionary that does not (natively) match.
This is awesome.
Just out of curiosity, why are you still using DJ? I've found it to be frustratingly dated compared to say, Sidekiq, but it still seems quite popular. Oh, and great post! I've used Scenic a little bit really meant to dig into the Pros n Cons. Thanks for doing that for me!
Well that was lame.
To me what is considered "expensive" is relative to the cost of executing a query. I've used materialized views to aggregate results from queries which have an execution time of 10+ seconds. In this particular case, the problem was the size of the data, not the lack of indexes. It was easier to present a user with near instant results albeit about 30 seconds stale. Users in this case were less forgiving of slow app performance and more inclined to forgive stale data.
Glad you liked it! &amp;#x200B; DJ isn't my first choice for a job queue. I much rather Sidekiq. I used DJ in this case as it can be done without Redis, so it is one less thing to setup and explain in my future tutorial.
Sorry, I didn't read carefully. Thanks a lot for your insight. &amp;#x200B; This is what I came up with if anyone on this planet is having the same stupid problem as me: &amp;#x200B; drop_list = [] all_options. each do |e| drop_list &lt;&lt; e.text end #puts drop_list drop_list.is_a? Array drop_list.each do |option| next if option == "" @driver.find_element(id: 'txt_source').find_element(xpath: "//option[@value='" + option + "']").click @driver.find_element(xpath: '//*[@id="search_button"]/button[2]').click @driver.find_element(xpath: '//*[@id="search_button"]/div/a[3]').click @driver.find_element(xpath: '//*[@id="main_action"]').click @driver.switch_to.default_content wait = Selenium::WebDriver::Wait.new(:timeout =&gt; 60) wait.until{@driver.find_element(:id, 'action_frame')} @driver.switch_to.frame('action_frame') @driver.switch_to.frame('app_display') sleep(10) puts "Found the frames" @driver.find_element(xpath: '/html/body/table/tbody/tr[2]/td/table/tbody/tr[2]/td/input').click sleep(10) puts "Here the fuck I am" @driver.switch_to.default_content @driver.find_element(:xpath, "//a[contains(text(),'Search')]").click sleep(10) puts "Clicking for search" wait = Selenium::WebDriver::Wait.new(:timeout =&gt; 10) wait.until{@driver.find_element(:xpath, '//*[@id="action_frame"]')} @driver.switch_to.frame(2) sleep(10) end
Sure, that seems like a good use case for materialized views. A good use case doesn't make it possible for postgres to have automatic/transparent updates of them though, which is what yxhuvud was asking/waiting for.
Hi, this sound great! PS: in this challenge [https://noopschallenge.com/challenges/drumbot](https://noopschallenge.com/challenges/drumbot) I noticed that while the music is playing when I scroll up or down the music stops when the player is off screen.. Any idea how this is achieved? Do they monitor the scroll position?
I don't think they do. Looking at the source, you'll find that [it uses](https://github.com/noops-challenge/drumbot/blob/master/react-starter/src/AudioEngine.js#L81) `requestAnimationFrame` to schedule a "beat tick". The code on the challenge page is in an iFrame. In most browsers, invisible iFrame's rAf is throttled (or paused completely).
Nice. Will be using 💪
Thank you.
You might look at using Faktory instead. It's Mike Perham's answer to polyglot Sidekiq: It hoists the real meat of Sidekiq into a server process (uses Redis as a backing store), so that the clients don't have to recreate all the complex scheduling and error handling logic themselves. Thus, they can be much lighter/simpler. There's a Crystal client, of course: https://github.com/calebuharrison/faktory.cr That said: Yes, you can totally have Sidekiq jobs in another language. Just bear in mind that the scheduler for Sidekiq is pretty complicated after years of battle-hardening, and it may or may not be well-replicated in whatever implementations exist outside of the official one.
Sidekiq isn't really language agnostic service that you can rip-and-replace easily. An app like discourse will schedule sidekiq jobs to do things in the background that are long-running tasks or simply don't need to be done on every page render. Generic examples would be things like updating search indexes, converting media, rendering markdown/bbcode to html, etc. All of the logic to perform those jobs are written in ruby and most likely `require` other parts of the discourse codebase. While it's certainly possible to port [all the jobs](https://github.com/discourse/discourse/tree/master/app/jobs) off to crystal, it wouldn't be a drop-in replacement.. and you'd be stuck on your own hacked-up version of discourse.
ok
The crystal one is official by Mike Perham himself. I've heard of faktory but was under the impression it's not as drop-in replacement like as sidekiq.cr is. I want to know if I can easily swap out the ruby sidekiq without tampering with the ruby source code in the Discourse software which does have sidekiq references in the codebase. I can't say how willing the project maintainers would be to accepting any code changes to switch to sidekiq.cr or faktory. The general impression I get is they'd reject it, or it'd take quite some time for them to consider.
Yeah, so as you linked there is sidekiq in the codebase, but I am not familiar enough with ruby to get how it's integrated / used(I understand the jobs and that logic in the files to a degree), like there is no import/require statement for sidekiq in those job files yet sidekiq is referenced... Globally I'm guessing? I'm not asking to swap it for any alternative, just if it were possible to swap for the official crystal port by the same maintainer. The repo mentions it's largely the same but some APIs/features are not at parity. Assuming the off chance that Discourse usage of sidekiq isn't affected by such, I was curious if little work was required to switch to the crystal version. Sort of like how mariadb in majority of cases is a drop-in replacement for mysql without having to tamper with the core projects codebase. Is sidekiq vs sidekiq.cr similar to mysql and mariadb in this case? Or would the Discourse code base not be compatible and need to be modified? The README for sidekiq.cr states it can share processing of jobs with ruby sidekiq sharing the same redis instance, so that suggests to me that maybe there is a chance. I don't want to maintain my own fork. I am interested in my own docker setup as I'm not a fan of the all in one container approach. Sidekiq vs sidekiq.cr, while performance win(and thus less cpu time) sounds good, you make a good point about considering actual jobs processed), my main interest was actually in reduced memory usage.
&gt;Is sidekiq vs sidekiq.cr similar to mysql and mariadb in this case? No, I tried to explain that in the first two sentences of my original comment. I'll try to make it clearer: Sidekiq is a job scheduling framework (written in ruby) built on top of redis that developers write their own jobs (***in ruby***) for. There are re-implementations of sidekiq in other languages, but if you want to adopt them and have any meaningful impact, you need to port all your tasks to that language. &gt; The README for sidekiq.cr states it can share processing of jobs with ruby sidekiq sharing the same redis instance, so that suggests to me that maybe there is a chance. Yes, a ruby sidekiq and sidekiq.cr instance could share the same redis instance and probably even pull jobs out of the same queue, but the crystal implementation is not going to start magically executing ruby code. You need to re-implement the jobs in crystal. Once you'd done that, however, a ruby application could happily send jobs off to the sidekiq.cr instance, as the request to run the job is basically just a message.
&gt; Yes, a ruby sidekiq and sidekiq.cr instance could share the same redis instance and probably even pull jobs out of the same queue, but the crystal implementation is not going to start magically executing ruby code. Ok, that's all I needed to know really :) I was thinking that maybe the ruby code/client was an API towards redis(or to sidekiq over a protocol rather than language api binding), and that the separate sidekiq processes would just monitor redis for work to do. I also thought that because I recall there being a port for sidekiq to connect to. Or perhaps that is the case, and those jobs you linked to are separate from the main ruby project code that runs Discourse, the jobs are just for the sidekiq jobs? (It'd be nice if they maintained it as a more clear separate service then imo) &gt; You need to re-implement the jobs in crystal. Once you'd done that, however, a ruby application could happily send jobs off to the sidekiq.cr instance, as the request to run the job is basically just a message. I should finish reading your response in full first :P Ok all clear now, thanks for taking the time to clear that up for me! Just to clarify. If I wanted to switch out the ruby sidekiq for sidekiq.cr or alternative job scheduler, the lowest amount of work to do such(regarding Discourse project), is to port that jobs folder over? (Assuming that the job scheduler is compatible with how jobs are managed via redis)
Yes
The most common reason for using DJ over Sidekiq is not wanting to run Redis, in order to reduce ops overhead. c.f. also using the postgresql adapter for ActionCable.
Its *really* not as hard as you think it is - read the ruby documentation and `The Well Grounded Rubyist` 1, 2 and 3 and youll be a pro. Might take you a month or two
Happy coding 🤠
&gt;however, a ruby application could happily send jobs off to the sidekiq.cr instance, as the request to run the job is basically just a message. Hi, (sorry for interrupting) but when you say that a ruby application (e.g. rails) can send jobs to sidekiq.cr, how to make the "call" from the ruby side (I mean how to register the job in the queue)? Because e.g. with rails we are calling an ActiveJob class, so I don't get how the link is made.. Thank you..
Sorry, I glossed over quite a bit there, but it is possible. It's actually described [in their wiki](https://github.com/mperham/sidekiq.cr/wiki/Getting-Started#create-some-jobs-using-the-client-api). It's not totally transparent, but you can do it. Might be a good use case for refinements.
Thank you!
&gt;the lowest amount of work to do such(regarding Discourse project), is to port that jobs folder over? Basically. If they've extended sidekiq (batching, delayed extensions, logging, etc), you're going to have to figure that out as well. Some of it might be nice-to-have features that you can make a judgement call about whether or not to port, while other stuff (like batching) will be mandatory to implement.
neat
Why tho
I'm with you on this one, I see it in a ton of JavaScript code where the authors are trying to be super functional. It doesn't appear to be buying that team anything in terms of reduced bugs or faster development cycle.
Even in JavaScript it makes more sense to have a pipe operator (that works like the elixir one, not this) than here
Because the philosophy of Ruby seems to be an infinite number of ways to one simple thing.
This is not what a [pipeline operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Pipeline_operator) is supposed to mean. What's been proposed here is alternative (and somewhat pointless) syntax for method chaining; calling it a "pipeline" is a misunderstanding of the feature. The only benefit to this syntax (if one can call it that) is the added ability to chain methods without brackets. But even then, the chosen syntax is inappropriate as it's *not a pipeline*.
&gt;The only benefit to this syntax (if one can call it that) What can it be if it isn't syntax?
I was referring to the word "benefit", not the word "syntax".
This is not how actual pipe operator (AKA function composition) works.
Ruby doesn't need this, at least in it's current form. Method chaining is already good with . (dot) operator. Also in other languages, example in Elixir the pipe operator also passes the result from previous expression as an argument to next expression, this doesn't.
Yeah when I read "pipeline operator" I thought this would work like in Elixir. But it seems to be just another way of chaining methods which doesn't really make sense to me. There's discussion going on in the link, don't know how it'll end up.
Ruby Bug Tracker discussion: https://bugs.ruby-lang.org/issues/15799 &gt; a topic of "ruby committers vs the world" in RubyKaigi 2019. Link to video of discussion Nobu referenced in the original topic: https://youtu.be/5eAXAUTtNYU?t=1944 I turned on Auto-Translate to English which marginally helped add a small bit of context, but was generally poorly translated. I strongly disagree with this implementation. People say "Stop making Ruby into Elixir" but I think adding the equivalent of the `|&gt;` operator would be really helpful in a lot of data processing tasks. Adding `|&gt;` as simply a new alias to call a method is misleading in the current context of other languages and I strongly feel that it does not provide enough benefit to warrant the confusion.
I agree. This goes against Ruby's principle of least surprise. If you've seen the operator before, you'll expect it to behave like Elixir's, but it's just an alias for `.`.
In `f = File.new("line", "w")`, `line` is quoted when it shouldn't. Also check out the YAML module in the standard library, it might make your script more flexible and will avoid syntax errors.
`f = File.new("line", "w")` You're not interpolating the variable `line`, you're just passing the literal String `"line"`.
I guess it depends on how complex your Sidekiq configuration is. If you're using it in a very straightforward way, Faktory will translate very well. Your job code might only need to change the words `Sidekiq::Worker` to `Faktory::Job`. There is a consideration of "where does the job server live" (as opposed to "where does my Redis live") which would probably be the hardest thing to consider. Once the server is set up, it feels exactly the same as Sidekiq. I've been using Faktory in production for about a year now, using both Ruby and Node. I use Ruby to enqueue a specific set of about 100,000 jobs each week. A node worker picks those jobs up and processes them, creating an additional 300,000 or so more jobs with the output data, which Ruby picks back up to process and finalize. If your goal is to have job processing happening in a different language from your existing Ruby code, I've found Faktory to be a perfect solution.
The function application operator '$' seems a much better fit for this. Why did he opt for the pipeline operator instead? Does he explain in his talk?
This is a TERRIBLE idea. If it's not actually a pipe operator why bother?
if you have this on github, i'll give you a code review. Otherwise, I can put some suggestions here, let me know, if you'd: a) want that 2) which place to put feedback Glad you got through it though.
Another thing to keep in mind is since you aren't specifying an absolute path for the file, you're going to dump the files in your current working directory (and not necessarily the directory that the ruby script is in).
&gt; Pipeline operator is added. &gt; This code equals to the next code. &gt; foo() &gt; |&gt; bar 1, 2 &gt; |&gt; display &gt; foo() &gt; .bar(1, 2) &gt; .display So what's the point of this?
odd, this time it created and the content of each file is correct, but each file has a ? on the end &gt; ls A Test Project 411? Test Project - Ignore 3 A Test Project 4112? Test Project SD 2 - ignore? A test project 4113? createprojects.rb short.txt
&gt; ...but I think adding the equivalent of the `|&gt;` operator would be really helpful in a lot of data processing tasks. It exists and is Enumerable interface for collections and `Object#then` for singular objects: name.then { |n| File.read(n) } .split("\n").first.to_i .then { |i| Math.sqrt(i) } # With method references, DRYer: name.then(&amp;File.method(:read)) .split("\n").first.to_i .then(&amp;Math.method(:sqrt)) # With method reference operator of Ruby 2.7: name.then(&amp;File.:read) .split("\n").first.to_i .then(&amp;Math.:sqrt) It does NOT look as elegant as Elixir-y potential code: name |&gt; File.read |&gt; split("\n") |&gt; first |&gt; to_i |&gt; Math.sqrt ...but the main source of "inelegance" is not the absence of operator (it would NOT look natural in method chains), but our way of referencing methods -- which is a hard price to pay for brace-less method calls.
This worked, good catch on that. I'll look into the yaml library. File.open("/Users/accountname/Desktop/short.txt", "r").each_line do |line| f = File.new(line, 'w') f.write("---\n") f.write("password_requirements::policy_apply:\n") f.write("- 'password_requirements::warning'\n") f.write("- 'password_requirements::linux_req'\n") f.close end
&gt; With method reference operator of Ruby 2.7: Yes, I've been looking forward to this addition. Wouldn't it have been cool if somehow we were able to take `|&gt; (expression)` and evaluate the expression in a similar fashion to method reference? I know you've done a ton of work playing with these ideas, so you'll probably shoot a hole in them in about 1 second: client.find(id) |&gt; JSON.parse # Somehow knows evaluate the `.` to &amp;JSON.method(:parse) |&gt; PricingAdapter.parse |&gt; @1.to_h # borrowing from the new block positional args ? |&gt; PricingModel.create Or how about all of those wild "File.expand_path/join" type things for getting data, or adding paths to $LOAD_PATH. After having seen the concept of Elixir's `|&gt;`, these kind of statements drive me nuts: data = JSON.parse(File.read(File.join(__dir__, "data", "samples.json"))) Even with the changes in 2.7, this still feels clunky, and like more trouble than it's worth. It's surely short sighted and probably has many technical reasons for it to not be that way: "How to tell where the scope ends" "conflicts with something" -- I'm not a language designer by any means. I think that there is some seriously nice potential by improving Ruby's syntax for these situations. Because of this desire, I find the current `|&gt;` proposal hard to stomach, as it's so much more elegant looking than the `2.7` style code you reference above.
&gt; Your job code might only need to change the words &gt; Sidekiq::Worker &gt; to &gt; Faktory::Job &gt; . Oh, that'd be awesome :) I haven't had a chance to look into Faktory yet, but if it's largely kept compatibility with Sidekiq and is as simple as you say I'll definitely give that a look. I've been told that I would likely only have had to be concerned about [this part of the Discourse codebase](https://github.com/discourse/discourse/tree/master/app/jobs) which contains the ruby jobs for sidekiq to use. That was regarding switching to sidekiq.cr, but would require that I port all those ruby files to crystal. The maintainers might be more open to accepting Faktory then if it's a small change but pays off. &gt; I use Ruby to enqueue a specific set of about 100,000 jobs each week. A node worker picks those jobs up and processes them, creating an additional 300,000 or so more jobs with the output data, which Ruby picks back up to process and finalize. I have experience with Node, but not with job scheduling like you're describing. The gist of it seems to be that you throw a bunch of tasks/jobs you want done into a store like Redis, then individual processes/programs(workers?) that are idle take a job from that, process it, and repeat? Sort of like scaling out the workload separate to the main program? It seems useful for separate services/languages to utilize or if you scale horizontally, but otherwise, you could just use async operations(if the language supports it). In that case, I guess I misunderstood what you meant by `Sidekiq::Worker` to `Faktory::Job`. I'd still need to port the jobs to another language/worker, or continue to use sidekiq unless there is something more suitable(I see that there is a faktory worker in ruby, but it's not clear if it makes much of a difference regarding perf/memory).
I think the inelegance largely reflects trying to mix OO and functional, though. We could get close, by making `Classname()` work in a sensible way as a sort-of constructor for most things, and for modules (like Math) make it default to returning a proxy that include's the modules methods (so you could do Math(42).sqrt). Then if you add |&gt; binding tighter than "." so that `name |&gt; File .read" means `File(name).read` rather than `File.read(name)`, you could do: ``` name |&gt; File.read.split("\n").first.to_i |&gt; Math.sqrt ``` I'm not convinced this would be a good idea, btw., just trying to think about whether there's a way of making the syntax work.
In Sidekiq, the ruby module to include into your worker class is `Sidekiq::Worker`. In Faktory, it is `Faktory::Job`. If you are looking to port these discourse workers over to Faktory, I'm not sure how invasive that might become. I see a lot of methods in [the source](https://github.com/discourse/discourse/blob/master/app/jobs/base.rb) that interact with the underlying dataset --&gt; So it probably isn't straightforward. But at least look into it more: - Server: https://github.com/contribsys/faktory - Ruby client: https://github.com/contribsys/faktory_worker_ruby#your-first-job - Other clients: https://github.com/contribsys/faktory/wiki/Related-Projects#workers My personal use case is this: - Create a task for each of 150 zip codes * 700 tire sizes, and some additional smaller sets of required data. - Leverage Node + Puppeteer in .js, or other tools in .rb to acquire data. Some of these jobs may create more jobs. - Parse and save the page data into domain objects in Ruby because data parsing in Ruby feels infinitely more comfortable than in .js. At least with my current skillset. (Ruby really slays in processing text!) This also may create more jobs. This ensures that all of those location + size combinations have their day in the sun, and if they don't because of changes to the site, I'm able to fix the code on my own time and resume without losing work. It's also easy to manage the concurrency by assigning a queue for each website worker so I'm not too hard on the server. There might be better ways to do this (things like Kafka come to mind) but I don't know how to use Kafka and found it overwhelming. Using Faktory was super fast and simple, and used tools I was already very familiar with.
Yeah, is the comment wrong, or is the operator just the same as a dot? Because an Elixir-like pipeline would instead be something like: foo |&gt; bar(2) |&gt; puts And be equivalent to: puts bar(foo, 2) Like it or not, at least it does something different, and allows chaining methods in a functional style which don't return some form of `self`. Unlike the example cited, which is just an alias to `.`
&gt; I think the inelegance largely reflects trying to mix OO and functional, though. Ruby always had it. The most distinctive Ruby's features -- our Enumerable and procs in general -- _are_ healthy mix of OO and functional. To be bitter, `.then` is a perfectly viable and useful idiom (we have it a lot in a codebase, and even less senior developers are indoctrinated into it easily), and it is perfectly Ruby, in line with the rest of the language and chaining that Enumerable made usual. But somehow it is just neglected by the community because the holy mix of `|&gt;` is the only "elegant" thing in the world. It wouldn't work well with blocks, it contradicts every design point in Ruby, it can't play well with `Enumerable` (like url → get → parse json → dig items → select active → sort by price → write to file), but it is nice and sweet, so anything that is not `|&gt;`, is Ugly and Unreadable apparently. The problematic thing is in completely different direction -- that it is not really readable currently to receive method's reference (but it gets better), but more of it -- that it is hard to half-apply methods, and pass around in that half-applied state (Ruby's currying is unusable), and THAT is a problem of "piping"... But that's not anybody seem to be concerned with.
Actually the “pipe operator” in the JS proposal (forgive me to assume that’s what you refer to with “actual pipe operator”) is flipped function application. That is not the same thing as composition.
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
I mean I don't even think Smalltalk has this silliness. In 20 or so years of development I never once saw the need to wrap `x != 0` with a method called `not_zero`, etc...
&gt; Ruby always had it. The most distinctive Ruby's features -- our Enumerable and procs in general -- are healthy mix of OO and functional. Yes, but I didn't mean *in the language*, but in *that specific use*. E.g. I get the desire to try to just have a pipeline, but you'd get closer to that with e.g. a "cast" style `File(name).read` than trying to shoehorn it into a fully functional style. I agree with you regarding `.then` as well. I don't *really* like it much, but used sparingly it can be ok. Though I think we can get closer with the "cast" style methods (even though they're "faked" by aliasing class objects today) to turn things into the "right" type of object sooner. An alternative idea , actually: An "as" method with my suggested wrappers, like this: ``` class Object def as(type) type.try_convert(self) end end def File.try_convert(ob) File.open(ob.to_s) end class Proxy def initialize(m, ob) @m = m @ob = ob end def method_missing(method, *args) @m.send(method, @ob, *args) end end def Math.try_convert(ob) Proxy.new(Math, ob) end p "/tmp/input.txt".as(File).read.split("\n").first.to_i.as(Math).sqrt ```
&gt; Yeah, is the comment wrong, or is the operator just the same as a dot? No, the comment is correct. This is literally just an alias to a dot. See the test case: def test_pipeline_operator assert_valid_syntax('x |&gt; y') x = nil assert_equal("121", eval('x = 12 |&gt; pow(2) |&gt; to_s(11)'))
Well that's kind of useless but whatever, there are thousands of aliases anyway.
There seems to be some people who have lately got Matz’s ear who are proposing some unnecessary additions to the language.
Wow, this is a terrible addition to the syntax. So bad that I almost downvoted. It is both misleading and redundant.
good news, you can also write `foo :: bar(1,2) :: display`. choice is great!
* [Change on Github](https://github.com/ruby/ruby/commit/f169043d81524b5b529f2c1e9c35437ba5bc3a7a#commitcomment-33927109) * [Twitter response](https://twitter.com/a_matsuda/status/1139110957450375168) * [My take](https://twitter.com/shioyama/status/1139168800794791936)
Here is the finished code that i got to work. ended up using .rstrip to clear the errant characters at the end of each line to remove ? and ?? being created. #ruby code used to read a list of files to create from a txt document #reads each line, strips the CRLF/LF and adds an extention #what file should be read? #each file should be on a new line fileinput = "/path/to/file/filesinput.txt" #begin loop for creating files and adding contents File.read(fileinput).each_line do |line| #set extension for file names extension = ".yaml" #create clean file names cline = line.rstrip + extension f = File.new(cline, 'w') #content of file f.write("---\n") f.write("password_requirements::policy_apply:\n") f.write("- 'password_requirements::warning'\n") f.write("- 'password_requirements::linux_req'\n") f.close end
Faktory is definitely what I would recommend if you aren't using Ruby. I don't support sidekiq.cr anymore, it's a prototype I built a few years ago when I was considering bringing Sidekiq to other languages. Instead I decided to use a different architecture that became Faktory. I accept PRs to keep Sidekiq.cr working with the latest Crystal changes but that's about it.
Trash
Check out this operator-less [pipe_operator](https://github.com/lendinghome/pipe_operator) proof of concept: # before JSON.parse(Net::HTTP.get(URI.parse(url))) # after url.pipe { URI.parse; Net::HTTP.get; JSON.parse } Multiline blocks: "https://api.github.com/repos/ruby/ruby".pipe do URI.parse Net::HTTP.get JSON.parse.fetch("stargazers_count") yield_self { |n| "Ruby has #{n} stars" } Kernel.puts end #=&gt; Ruby has 15120 stars More realistic example: # before loans = Loan.preapproved.submitted(Date.current).where(broker: Current.user) data = loans.map { |loan| LoanPresenter.new(loan).as_json } json = JSON.pretty_generate(data, allow_nan: false) # after json = Loan.pipe do preapproved submitted(Date.current) where(broker: Current.user) map(&amp;LoanPresenter.new.as_json) JSON.pretty_generate(allow_nan: false) end
Perl6 has similar functionality. Oh, and did I mention they **have types and "appropriate" static typing zOMG!@#**: &gt; my Str $s = 'abc def' abc def &gt; $s&gt;&gt;.uc.substr(4).reverse (DEF)
"Committers versus the world" indeed.
For extraction / decode from images: https://github.com/middagj/quirc-ruby However, it sounds like your intention is to 'scan' the code from a webcam with a browser based application? If so I would do the scanning the browser and just send a request to the backend with the decoded info. This means using a javascript library, I've not used any of them but something like https://github.com/schmich/instascan seems to fit.
sounds like they finally found sense and copied Elixir
How's this for _maximum surprise_: result = 3 |&gt; pow(2) puts result this outputs `3`, because the precedence of `|&gt;` is lower than assignment (!)
Thanks for sharing!
Yes that was briefly considered, but I think the conflict with global variables made it basically out of the question.
Yes but now there can never be any other pipeline operator. Those two symbols (\`|&gt;\`) were "symbolically" important (pardon the pun). I think if it had been any other symbols, there would not have been such an uproar about it.
thanks
&gt; I don't support sidekiq.cr anymore, it's a prototype I built a few years ago when I was considering bringing Sidekiq to other languages. Oh ok. It'd probably help if the github README for it said something about that :) It doesn't mention that it was a prototype or that you don't support it anymore. At a glance it looks like it's still maintained/developed. &gt; I accept PRs to keep Sidekiq.cr working with the latest Crystal changes but that's about it. It'd probably be a good idea to point that out on the repo README :) As someone who only just became aware of Sidekiq (not a ruby user), I came across that repo at some point when looking into Sidekiq and the opening paragraph and table made it seem interesting over the ruby version. I had later found out about Faktory but wasn't sure how it compares(I don't think you have any similar comparison to the ruby Sidekiq vs the Faktory ruby worker). Sending new users that way might be a good idea? &gt; Faktory is definitely what I would recommend if you aren't using Ruby. Do you still recommend Sidekiq for Ruby over Faktory's Ruby worker? Another user provided some good insights about Faktory, so I am more aware of it now and have made a note of it if I ever need such functionality for a project in future, Faktory seems like it will be my go to :) Thanks for chiming in!
The incorrectness of this pipe implementation apart, piping must make people feel very l33t given how every new kid on Javascript, R, Python insists on using it. It does have value for short repetitive scripts, but piping can quickly make code hard to read.
i feel the yield_self and then methods are already very oop ways of piping.
Exactly my thoughts. Why forcing a name and symbol which is widely recognised by the whole community as something else?
Dang he lost some weight.
Anyone got a TL;DW?
Not exactly, the Elixir operator takes the output of the previous statement and passes it into the next, in a functional way. Ruby's is just syntactic sugar to chain method calls.
From google and reading [http://ergoemacs.org/emacs/lisp1\_vs\_lisp2.html](http://ergoemacs.org/emacs/lisp1_vs_lisp2.html) I don't really get the reason why "There's no chance for Elixir-like pipeline operators in Ruby". Can any why explain that in few words?
Because the elixir pipeline operator is a functional language tool. The result from the previous statement is passed as the argument to the next. So instead of `foo(bar())` you have `bar |&gt; foo`. Much more legible if you don't want or need to assign intermediate values to variables. Ruby's pipeline that's being considered is just syntactic sugar on method chaining. `object |&gt; foo |&gt; bar` is equivalent to `object.foo.bar`. Its just uneccesary, unless you think the pipeline operator is more legible, which most don't seem to.
**1.** In Elixir, `|&gt;` is the main chaining tool. In Ruby, the main chaining tool is method chaining. So, in Elixir (pseudocode): url |&gt; HTTP.get |&gt; String.strip |&gt; JSON.parse |&gt; |&gt; Hash.fetch('items') |&gt; Enumerable.map(&amp;1.to_s) |&gt; File.write In Ruby, we already have (`???` is instead of "wannabe pipeline operator")... url ??? HTTP.get.strip ??? JSON.parse.fetch('items').map(&amp;:to_s) ??? File.write Notice how half of the "pipeline" is made by just chaining method to previous results. For piping to properly parse, work, and be unambiguous, there should be something _consistent_ with this "chain to previous". Ruby 2.6's `then` (introduced in 2.5 as `yield_self`) is this consistent thing. **2.** In Ruby, `Foo.bar` can't be treated as "a reference to the method", because of optional parentheses to the method call. So, "a reference to the method" (for inserting it into pipeline) **need** to be less atomic. It used to be `Foo.method(:bar)`, in Ruby 2.7 it is becoming `Foo.:bar`. So, the closest Ruby can get to my imaginary Elixir example is url.then(&amp;HTTP.:get).strip.then(&amp;JSON.:parse) .fetch('items').map(&amp;:to_s).tap(&amp;File.:write) It is a bit unusual but not that bad (and pure symbol-count is even less than Elixir's); there are a lot of haters of those "new obscure syntax", but it is pretty consistent and easily explainable. The things became worse when you need to pass some additional argument to an intermediate method. In imaginary Elixir, you still can something like something |&gt; JSON.parse(symbolize_names: true) But in Ruby, you are back to blocks and their internal variables something.then { |body| JSON.parse(body, symbolize_names: true) } To make it DRYer (look at `body`/`body`), 2.7 introduces (super-questionable) "default block argument" convention: # 1. currently merged but challenged by many something.then { JSON.parse(@1, symbolize_names: true) } # 2. seem to be current preferred option at Ruby's bugtracker something.then { JSON.parse(@, symbolize_names: true) } # 3. another option discussed something.then { JSON.parse(it, symbolize_names: true) }
I'm so happy we have Aaron around!
&gt;I don't know enough about Elixir but I'm guessing it does not allow that. Elixir does allow that and its parenthesis are optional just as they are in Ruby. That's why I am asking. I am guessing, there must be very technical underlying problem with this approach, but I am not sure. I am not getting how this reference to Lisp 1 vs Lisp 2 is related to this problem at all. All in all it's not like we are trying to implement this in Ruby itself. Arity is a normal thing in Ruby and we get explicit ArgumentError exception when trying to circumvent it, so where is the core of the problem?
&gt; Elixir does allow that and its parenthesis are optional just as they are in Ruby. I don't think so, least not when it comes to defining anonymous functions. [I just tried it in iex](https://i.imgur.com/V29RLrQ.png)
I think that's about something else: [https://bugs.ruby-lang.org/issues/15799#note-29](https://bugs.ruby-lang.org/issues/15799#note-29) Also: ``` defmodule Main do def method do IO.puts "hello world" end end Main.method() Main.method ```
I think my favorite thing to clean up would be `JSON.parse(File.open(File.join)))` chains, and text processing functions.
``` defmodule Main do def value do 3 end def call do value = 2 IO.puts value IO.puts value() end end Main.call() 2 3 ```
Right but that's with named function definition. Anonymous functions are I guess defined in the same namespace as variables.
In your example sum is just a variable in both cases. First you are assigning a function to a variable, then you are re-assigning the same variable with a value. You only can access the last assigned value. There is (afair) no language which allows to do what you are trying to do. Use use inspect in iex. Fist the variable contains a function, later its an integer.
I couldn't find a date anywhere on the blog post, but it looks to have been written in early 2016: https://www.reddit.com/r/ruby/comments/4chozc/rails_5_actioncable_the_good_and_bad_parts/ "Rails 5 has recently introduced" was a strong clue, but the giveaway was the Performance section -- I won't claim it's going to win shoot-outs, but it's been in a state where I'd expect much better results than that, for quite some time now. The rest of the points still mostly apply, though "what about old browsers" seems less significant as the years go by.
Here’s a possibly dumb question: If I set up AC to use on an app, how are server processes and threads handled? For example, a heroku dyno might be 1-2 workers with 10-15 threads each - does AC tie up one of those threads indefinitely? I work on a quite large Rails app that could see benefits from using it, but I’ve never been able to find a straight answer. I don’t want to set up and run AC for a few specific cases only to cost us more in dynos.
Yep, that’s why I said crufty
Haha, thank you for the offer! Kinda makes me wonder if how I did it is not the best possible way? It does what I want though.
Thanks for pointing this out! Would love to see an update blog post from the authors.
If you're talking about puma threads, then no, action cable won't take them hostage.
&gt; TL;DW Too Long; Didn't Weep?
Sadly there don't seem to be any slides available or article. Basically is a dive into the details of how compacting GC is implemented, the problems they are facing, the current state of affairs and what is left to do before the final release.
It has at least one broken link due to `master` references that no longer exist: e.g. `https://github.com/rails/rails/blob/master/actioncable/lib/action_cable/subscription_adapter/evented_redis.rb#L33-L37`
I still can’t fathom how astute members of Ruby’s dev team think this is piping.
There are style concerns at least, if you were curious, and had docker installed, you could run the following: `docker run --rm -v $(pwd):/app quay.io/lightside/flake8 /app`
Without diving deep into your code I suggest you look at http://elementalselenium.com/tips/2-download-a-file and http://elementalselenium.com/tips in general (there are other download articles there) but I'm not sure how up to date it all is. Hopefully that will help you figure it out. Beyond that I don't have any specific advice And an awesome resource for testing scripts: https://the-internet.herokuapp.com
Honestly I think that's a pretty terrible pattern. IMHO methods should be arranged by importance and the deeper you go, the more specialized it gets so that if I read a class I can see on top what is the most abstract business logic and at the bottom it has detailed data gathering type methods I don't need to care about in most cases.
&gt; I read a class I can see on top what is the most abstract business logic and at the bottom it has detailed data gathering type methods I don't need to care about in most cases. I do this by organizing classes into public and private methods. Public methods go on top to expose intention and private methods hide the complexity below. This cop orders methods per visibility block, so 'important' public methods are ordered and remain at the top; private methods are ordered separately below. For example: ``` class Beep def b; end def a; end private def d; end def c; end end ``` becomes: ``` class Beep def a; end def b; end private def c; end def d; end end ``` I've tried arranging private methods in large classes by importance and grouped by domain. Both make future refactoring difficult and tedious. I tend to jump around however they're organized when scanning, and alphabetization helps me consistently know where I need to be looking.
It's not true! Ruby can absolutely have Elixir-like pipeline operations and here is a working proof of concept: https://github.com/lendinghome/pipe_operator # before JSON.parse(Net::HTTP.get(URI.parse(url))) # after url.pipe { URI.parse; Net::HTTP.get; JSON.parse } # with arguments and method chaining support "https://api.github.com/repos/ruby/ruby".pipe do URI.parse Net::HTTP.get JSON.parse.fetch("stargazers_count") yield_self { |n| "Ruby has #{n} stars" } Kernel.puts end #=&gt; Ruby has 15120 stars
Start prefixing method names with letters like `a_important_method`, `z_not_important_method` \s
Just one step away from just rubocop:disable it all the time ;)
Great point. I do that also, but I still tend to want my constructor to be the first methods in the file for example. Or I have a priority in mind for internal methods based on their scope. Granted I am doing close to Sandi Metz rules Ruby usually, so more than 100 lines per class I'll avoid anyway, but still I think there is sense in the order and arranging it alphabetical is just overhead that does not give me that much benefit. If I wanted an alphabetical list of methods I would just use an IDE with that feature I guess.
he seems absolutely delightful
It's not quite the syntax we all have been craving. I haven't really looked in to the implementation, but I do believe it uses instance\_eval all over the place, is very fragile and produces bug which are very hard to debug.
&gt; I still tend to want my constructor to be the first methods in the file for example. The `IgnoredMethods` config option addresses this to avoid ordering `initialize` by default. &gt; Or I have a priority in mind for internal methods based on their scope. I see where you're coming from with this, though I think this would become overhead if more than one person were responsible for the class. &gt; Granted I am doing close to Sandi Metz rules Ruby usually, so more than 100 lines per class I'll avoid anyway The motivation for this gem was a class that has &gt; 500 lines, and arguably should. Metz's rules are pretty great, but I see them more as guidelines. &gt; If I wanted an alphabetical list of methods I would just use an IDE with that feature I guess. I'm not aware of any IDEs that provide this feature.
Syntax feels more natural and concise than Elixir's IMO, especially in multiline block form. The README goes into details of the implementation and how it would be much safer/performant if implemented as a core part of Ruby - but yes - it's definitely just a proof of concept, don't use it for anything! Thanks for the feedback!
I hate to see resources without date. Thoughtbot entire site is like this..
&gt; So instead of foo(bar()) you have bar |&gt; foo. Much more legible if you don't want or need variable assignment for intermediate values. Is it though? I defenitely have to reason about `bar |&gt; foo` more than `foo(bar())`. Perhaps that's because I'm relatively new to functional languages and have been using procedural languages most of my life... I can certainly see how in some situations it would clean things up... but would: baz |&gt; bar |&gt; foo be the equivalent of foo(bar(baz()))
&gt;&gt; I still tend to want my constructor to be the first methods in the file for example. &gt; The IgnoredMethods config option addresses this to avoid ordering initialize by default. So it orders alphabetically except for a bunch of edge cases?
Why are you using Selenium? Do you need to manipulate a form or something? Why not use one of the HTTP libs like Faraday or HTTParty? I don't see anything Selenium specific in your example code... I'll also second elementalselenium.com for tutorials/tips.
`initialize` is one method, not a bunch. `initialize` as the first method is a pretty widespread convention, not an edge case.
&gt; The IgnoredMethods config option &gt; IgnoredMethods config option &gt; IgnoredMethods config &gt; IgnoredMethods Whatever, downvote me all you want, you're the one who can't take constructive criticism.
The \`IgnoredMethods\` config is for flexibility. If I have a class with \`initialize\` and \`call\` as the only public methods, I don't want \`call\` to be reordered before \`initialize\`. &amp;#x200B; I posted this for feedback so I can make the gem better. I downvoted because you were misrepresenting my intention.
This may be good for `require`s, `include`s, and Rails' declarative validations. Though with requires, I like to do core and stdlib first and 3rd party second.
Please have a look on this Social Network of Ruby Developer [https://www.railsroot.com/ruby-on-rails-developers](https://www.railsroot.com/ruby-on-rails-developers) Its have quite good numbers
when your knowledge is timeless
You don't need selenium to download a file. It is in fact __really bad__ at doing it. File downloads trigger system level dialogs, and selenium does not work well with them. What you want is the path to the file, and any sort of http library. Those libraries can pull files off of the internet and save them. If you are testing something, you should just test that the download link is available, then use a non-selenium solution to download the file.
right
Thoughtbot's blog has dates? [Example](https://thoughtbot.com/blog/make-the-most-of-your-browser-s-address-bar). It even says when an article is last updated.
Yes. In some cases it can help comprehension dramatically. In simple cases like this, it seems superfluous. An example that I like to use is the steps it takes to open a file. Consider `model = MyModel.new(JSON.parse(File.read(File.join(__dir__, "data", "sample.json"))))` Vs `model = File.join(__dir__, "data", "sample.json") |&gt; File.read |&gt; JSON.parse |&gt; MyModel.new` It also specifically allows multiline syntax much more cleanly: model = MyModel.new( JSON.parse( File.read(File.join(__dir__, "data", "sample.json")) ) ) Vs File.join(__dir__, "data", "sample.json") |&gt; File.read |&gt; JSON.parse |&gt; MyModel.new This kind of stuff is where this style of syntax has people wanting longingly for Elixir style piping. As you've seen, there are ways to accomplish something similar in Ruby now, but because you have to do some extra moves to obtain a reference to a method, it's a little less desirable. In 2.7 you could do something like: File.join(__dir__, "data", "sample.json") .then { File.read @1} .then { JSON.parse @1 } .then { MyModel.new @1 } Which I think will be generally nice. Additionally they are adding `.:` to be a method reference move as well. I personally think the syntax required to use that move is a bit too glyphic: File.join(__dir__, "data", "sample.json") .then(&amp;File.:read) .then(&amp;JSON.:parse) .then(&amp;MyModel.:new) I've read a lot of people upset about the addition of `@1` to be shorthands to reference block args, but I personally look forward to it greatly.
"If the pipeline operator were to be an alias of then"
It was posted to reddit on [March 29th, 2016](https://amp.reddit.com/r/ruby/comments/4chozc/rails_5_actioncable_the_good_and_bad_parts/) so you're spot on. The _original author_ responded a day later.
Keep in mind that: 1) ActionCable does not scale well. Consider avoiding it if you regularly have thousands of active users per dyno. 2) (not unique to ActionCable) you may need to up your maximum number of file descriptors since these connections are persistent. If you need it to scale well, check out AnyCable. We ended up ditching ActionCable in favour of Phoenix Channels
I don't see him doing any listening. The one reply I could find was him quickly waving away all the objections.
This is terrible and incredibly confusing. It should alias `then`, not `.`.
For your function `[1, 3, 5, 10, 20, 30, 35, 40, 48, 31, 12]` returns: [{:from=&gt;1, :to=&gt;5, :modifier=&gt;2}, {:from=&gt;10, :to=&gt;30, :modifier=&gt;10}, 35, 40, 48, 31, 12] And `[1, 3, 5, 10, 20, 30, 35, 40]` returns: [{:from=&gt;1, :to=&gt;5, :modifier=&gt;2}, {:from=&gt;10, :to=&gt;30, :modifier=&gt;10}, {:from=&gt;35, :to=&gt;40, :modifier=&gt;5}] Here's a simple approach, which only looks at subsequences that have at least 3 numbers in: [1, 3, 5, 10, 20, 30, 35, 40] .each_cons(2) .chunk{ |a, b| a - b } .reject{ |step, range| range.flatten!.size &lt; 3 } .map{ |step, range| {from: range.first, to: range.last, modifier: step.abs} } Which returns a slightly different result: [{:from=&gt;1, :to=&gt;5, :modifier=&gt;2}, {:from=&gt;10, :to=&gt;30, :modifier=&gt;10}, {:from=&gt;30, :to=&gt;40, :modifier=&gt;5}] You can see there's an overlap `10-30, 30-40` instead of `10-30, 35-40`, but hopefully you can adapt this to suit your use case.
hence the "what could have been" :(
Watched this morning, cool talk. TL:DW compact ruby memory to use less memory and compacted memory means more efficient usage of cpu cache thus speed gain. The thing is hard because C extensions. Aaron is working on a more performanct/better approach (there's a "first" version patch ready that uses a simple algorithm to compact memory)
Thanks, I hate it.
Couple of things: since you arw using anyway, easier to launch package scripts with `yarn start:dev`, little less typing. Also I dont think babel is optional in 2019, code without it is less conscise and expressive for no good reason. And installing babel is one line in package.json, babelrc file with 1-2 presets and one extra object in webpack rules definition. So I would recommend adding babel asap after badic setup is working
O use http.rb, its great gem, and with connection_pool to manage connections is very robust and production-ready
POODR is a musthave for any ruby programmer IMO
For me this syntax is very foreign. At a glance it just looks like a list of method calls which operate all by their own without any clue that they are actually chain of operations which depend on each other results. Maybe that's something one could get used to, but many other languages I've use share some common logic in that matter. You have famous |&gt; in Elm, Elixir, Javascript and F#, though the order of parameters differ. Haskell has $ or Data.Function.(&amp;) - all this constructs are signaling that there is direct relation between operations. &amp;#x200B; Unless we are dealing with custom DSLs - in Ruby we got used to the fact, that block is just a context which executes all listed operations. This is the reason I would strongly advocate against using this type of syntax.
IMO it looks stupid.
If you just want to parse a static site for a download link use mechanize. If you need to execute java script use the kimurai framework.
I know about TensorStram. In my opinion, TensorStraam is good at advertising. Author's advertising skill is very high. But what about the quality of the library itself? I'm pretty skeptical.
Why are you skeptical about the quality of TensorStream?
we use jruby when it was version 1.7. API stuff, but was great for us. Best if to go here: https://gitter.im/jruby/jruby and ask and be more exact with you libraries dependencies, and any special architecture
I’ve used JRuby professionally though it’s been a couple of years. I don’t recall ever running into a gem I needed that didn’t work fine. It’s rare mostly because most gems are pure Ruby, and the few that need native support (Nokogiri comes to mind) do have Java platform support. Startup times are slightly longer, on par with any JVM startup, but not so much it should scare you off. Look what your buddies writing Spring services are waiting through on a startup. Your JRuby Rails app starts looking pretty speedy. The two best reasons to use JRuby, though, in my experience, mostly relate to working on Ruby in what’s already mostly a Java shop: You can wrap common library jars in your own gems to share common functionality across platforms, and the existence of the jruby-complete jar means you can deploy your entire Ruby environment on systems that already have Java by default with a single file, so there’s a lot less grumbling from devops about supporting your weird requirements.
Hi!, thanks a lot for your reply! It sounds like there shouldn't be any major issues. But would you choose it over MRI today?
Thanks, will take a look there as well.
Depends on the circumstances, but I definitely see no reason to rule it out. Used to be JRuby had a big performance edge over MRI, but I’m pretty sure that hasn’t been the case for a while. The questions I’d be asking myself mostly concern how easy it is to deploy one or the other in your specific situation, as well as the need for Java interop. Unless somebody has more recent information, I don’t think there’s any inherent reason to strongly prefer one or the other. Try both and go with the one that’s easiest for you to work with.
I would second this one. IME the issues against jRuby are gems with C Extensions like Nokogiri and the general Java complexity/differences from ruby. Also if your whole shop is used to pure MRI, introducing Java may unnecessarily partition your code environments, e.g. limit who can debug. Regarding the gems though there are usually Java equivalents that actually do better XML, as in are compliant with the most recent XML spec which the ruby parser isn't, so YMMV. Other issues may be deploy strategies could be more complex if you're used to ruby. Not impossible just different, although things like passenger 6's Generic Language Support may help ease this one. My experience is from 5 years ago though so take it with a grain of salt. If it's for Java interop then it's a no brainer. Also we have a mixed Java/ruby environment at my current employer and we sometimes run a Java app and just access the Java information via a web API internally on the server, which may also be an option. Of course, you may just be able to offload the background worker/multi-threaded stuff to a common application or farm it out to multiple workers if this is the case. Stuff like sidekiq can help make up for a lot of the concurrency shortfalls in ruby.
at least I personally think that `.then { File.read @1}` is more readable than `.then(&amp;File.:read)`...
We did use jruby and return to mri mostly because the jruby seemed like memory hog. Dunno the details, happend before I joined.
Hey, gray\_-\_wolf, just a quick heads-up: **happend** is actually spelled **happened**. You can remember it by **ends with -ened**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
What do you think of marrying jruby with Groovy? At a first glance, it looks like JRuby's API and Groovy's object model ought to make a (relatively) seamless FFI possible.
What about Mirah?
I found JRuby very smooth and fast in production, I like it and it's recommended if you will need to handle complex concurrency. The startup takes much time but it is not a hassle of you have a good machine.
I will be deploying the app as a container on Kubernetes. So from that point of view there should be no difference I think.
From the railsconf video it sounded it should use less memory due to threads vs processes
Can you give an example of what you mean by 'much time'? Just to get an idea
I have an old AMD A6 processor with 8 GB RAM and in the morning it took like one minute to start up and a lot of ram. But after that all was fast enough.
We do have one project at work (an XML cleanup of upstream sources for downstream SOLR injest) that uses groovy but TBH it was a whim of one of the Java devs who wanted to try Groovy. He likes it and it's not a problem project but he's admitted the other devs shouldn't have to have to deal with the burden of learning Groovy so it's the only project deployed using it. I think this, your coworkers having to possibly maintain it, should probably be the a strong factor in your decision. It's the main reason I haven't tried to deploy any elixir apps, as our shop is Java/ruby only, it needs a business/team buy in. :(
That's partially eliminated if you load your application before forking to multiple processes. But sure, as always, measure yourself if possible :)
bad bot
delete
Yeah, containers narrow things down a LOT. If you don’t need Java interoperability or can’t name a specific case where you’re benefitting from “real” threads (remember, there’s a whole ecosystem of folks getting by just fine without), then there’s no specific reason not to just ‘FROM ruby-2.whatever’.
We use jruby at my day job and I can not stand it!!! We have to use it because of some legacy platforms that we integrate with and need the native Java communication options in jruby... But I have found at least 3 popular benchmarking gems and apm gems that didn't support it or was very experimental. Been using it since 1.7 to now 9.0.1.15 I think. Honestly it's been a pain to debug, we have found a few jruby bugs over the years. It is slow to support the updated Ruby API/functionality, etc. Honestly there are so many options out there for concurrency and threading and you most likely won't ever need things to the level of jruby. And then you won't have to deal with the mind numbing headaches of JVM. MRI/c-ruby will be doing even more native concurrency as it keeps heading towards 3.0. I always favor: K. I. S. S. Y. A. G. N. I. and just using the standard/easiest to develop option. Hardware and scaling costs are so so so very cheap compared to development.
What's your database, if you use SQL server then the jruby gem needed is the JDBC adapter, and it is not supported past active record/Rails 5 5 afaik. MRI uses a different gem for SQL server and does work with Rails 5+
You may have to tweak all the JAVA OPTS memory settings for jruby too. You will be limited to app servers but you can use puma
I really like Elixir's pipeline operators, and sometimes I wish I could use them in Ruby. However, [`then`](https://til.hashrocket.com/posts/f4agttd8si-chaining-then-in-ruby-26) already does everything we need it to, and while it's really useful in the right place, it's not used frequently enough to justify such a massive change to the syntax as aliasing it to `|&gt;`.
Is it just exactly an alias of the ordinary dot operator (`.`) with different precedence? Any other differences than that?
Whether "Elixir-like pipeline operators" are possible in ruby is one thing. I don't totally understand it, and have no opinion. But whether they are or not, I can't see any value in introducing `|&gt;` as simply an alias of `.`. (That's what it is I think?) I don't see why whether "elixir-like pipeline operators" are possible determines whether `|&gt;` as a synonym for `.` is a good idea. Whether they are possible or not, I don't see a reason we need a synonym of `.` with different spelling.
For what purpose or benefit would you be looking for? Are you already using Groovy?
Yeah, already using Groovy, with the not-so-occasional dip into Ruby for one code path or another. Library advantages and the like. TBH, the tooling around testing and linting Ruby is far more mature, but the platform I'm on is anchored in Groovy.
We use JRuby in our ETL pipeline and while there are some upsides -- integration with Java is really neat -- we also have a lot of annoying issues with it. Its memory footprint is pretty big, debugging and profiling is painful, we get random class loading errors where Ruby classes that are clearly defined are not found, and I've found the lazy enumerators to be pretty broken too. For us, JRuby seemed like a good idea when we first implemented it, but now we're trying to find an alternative to it.
Awesome, thanks. Didn't know abouot each cons, seems really powerfull ! I'll play with it and see if I can handle the overlap. &amp;#x200B; Thanks !
There is absolutely nothing about alphabetical ordering that is intrinsically valuable for a source code file. This seems like a rule that is meant to appease an aesthetic preference that also may harm readability if a better ordering rubric is available.
It isn't normal to `#dup` every object you receive in a constructor and store in an instance variable. But if you intend to modify them then yes `#dup` them. Ruby's style is not to be defensive about everything up-front. If you need it, then yes add it.
I'd rather not add another language to my stacks if I can avoid it. My team already has to cope with PowerShell, ruby, groovy, some java, some Perl, a significant amount of bash, some rust, some go...I'm probably missing a few. It's not that we start projects in new languages, it's that the toolings and platforms we're directed to integrate with either expose bindings in a language or are written in them. And where those tools are open-source, we'll dive into the tooling source code as part of troubleshooting. One of those platforms is Groovy- and Java-centric, so...
I used to support a gem that started being JRuby only, then moved to JRuby recommended, and finally barely paid any attention to it. On paper, I love the idea and I think the work that goes into it is fantastic. The folks working on it are brilliant, especially Charles Nutter. In practice, I found it frustrating to work with. The performance benefits never appeared, probably due to lack of configuration or something on my part, and the incompatibilities with many gems in the greater Ruby ecosystem was extremely frustrating. Every time I’ve explored porting an MRI app over to it, I ran into incompatibilities or inconsistencies that rendered it DOA. I don’t think any of that was necessarily JRuby’s fault. When I was following its progress a few years ago, it seemed pretty clear that MRI was notoriously difficult target to chase. The folks in charge of it (MRI) didn’t seem too eager to help folks writing alternative implementations. JRuby is still a marvel, it’s the most successful alternative to MRI AFAIK, and I’m glad it exists. My guess is that for Java teams, JRuby probably offers some significant benefits and is much easier to work with in production. If you’re starting a new project, you’ll have a better experience if you start with JRuby than if you try to adopt it later. Can’t hurt to try. Personally, if memory efficiency and true multithreading were high priorities, I wouldn’t be looking at Ruby at all. Those reasons alone would not be enough to use JRuby.
I don't think I would be using Java specific stuff in my app, and as for the threads the thing I was interested in is scaling with threads instead of processes to save memory. Does it make sense?
I will be using MySQL
It sounds to me like you're really looking for data immutability which granted ruby (and most OO languages) isn't great at doing. However I did quickly find [this gem](https://github.com/stitchfix/immutable-struct) that would allow you to create Immutable Structs which would lack the writers. That might be what you're looking for to do this one. Also in your current initialize method you could probably utilize a [splat or double splat operator](https://www.freecodecamp.org/news/rubys-splat-and-double-splat-operators-ceb753329a78/) to do the same thing you're doing now. Good luck!
No.
The problem with sensor\_stream is that it has only one developer. For large libraries like sensor\_stram, it's very difficult for a single developer to maintain quality. For example, in Red Chainer, Narray (Nompy) was created by masa16 tanaka and others, Cumo (Cupy) was created by sonots, and the DeepLearning part was developed by hatappi. Each library is independent. This makes testing easy. Other libraries, such as ruby-dnn, can also use NArray and Cumo. But, I think the sensor\_stram-opencl is interesting. Ruby's OpenCL library is unique.
Yes in this case I think itd be good practice to dup. But most people would probably overlook this.
Why do i feel like this is going to be the next `and`/`or` that style guides advise against using ..
&gt; I was interested in is scaling with threads instead of processes to save memory. Since quite a while Linux as copy on write (COW) when forking. So even if you are using multiple processes most of what is loaded before fork is shared with the children. It would depend from app to app, but it's entirely possible that what you'd save by using threads would be lost by running on top of the JVM that is noticeably bigger than MRI. Hard to tell without measuring, but this is just to say that it isn't as clear cut as you might think, and that in my humble opinion it doesn't seem to be a good argument for choosing JRuby.
Thanks for your insight. But what is up with "sensor\_stream" or "TensorStraam", used multiple times in place of the actual library name TensorStream ? I mean, your message is grammatically and semantically correct, and other library names are correct too, but then you're never getting TensorStream right? Not trying to nitpick, I'm just saying it's kind of bizzarre and it does make your analysis look a bit less trustworthy. Or am I missing something? Something like a subtle or hidden joke? Just wondering! :)
there is literally no added functionality. the only “new” thing you can do is exclude parenthesis on certain method calls
Totally agree. I find it easy to reason about with "these are instance variables of this block". I'd love to see `|&gt;` do this conversion for me, but honestly this change in 2.7 gets me close enough to being quite happy. It also let's you control the order of vars, which will help with compatibility into whatever old code you have lying around. Succinct, powerful, and (I think) reasonable.
Checkout the [https://api.rubyonrails.org/classes/ActionView/Helpers/AssetTagHelper.html#method-i-stylesheet_link_tag](stylsheet_link_tag)
Normally there is already a new rails install (assuming it's a rails project) already link a css file called application.css located in your app/assets/stylesheets folder. It should be included by default in the head tag of your layout (this file: \`app/views/layouts/application.html.erb\`) Using the stylesheet\_link\_tag helper since the stylesheet come from the asset pipepline. (It will be build and placed in the public folder) &amp;#x200B; The stylesheet\_link\_tag is used to link css file that needs to be build by the asset pipeline. You could for example place a normal css link tag: \` &lt;link rel="stylesheet" type="text/css" href="something.css"&gt;\` and have a css file \`something.css\` in your public folder and it would work. Though you would lose the advantages of the asset pipeline. &amp;#x200B; As for the link\_to helper, it also end up producing a normal html tag &lt;a&gt;. So you could replace it with \`&lt;a href="/mylink"&gt;test&lt;a&gt;\` or \`&lt;a href="&lt;%= link\_helper\_here %&gt;"&gt;test&lt;a&gt;\` The way you style it is just like a normal link. You match it with a css selector. So one way to do this is add a class or id to it like this: \`&lt;%= link\_to :test, url\_helper\_here, class: \['a-link', 'red-link'\] %&gt;\` or \`&lt;a href="/mylink" class="a-link red-link"&gt;test&lt;a&gt;\` and then in your css &amp;#x200B; \`\`\` .a-link { font-weight: bold; } .red-link { color: red; } \`\`\`
I use translation software and it seems that Tensor has been automatically converted to Sensor. This is my mistake and there is no further meaning.
But \`then\` is nowhere near the pipe operator when it come to convenience. You cannot justify the need for such change based on the usage of \`then\` which is 10 times more mouthful. At this point you either need a block with defined variable or the \`method\` method. New syntax, which is ment to make that easier, ie \`:.\` and the \`@1\` block arguments are not in stable Ruby yet.
The idea is to change the order of operations, so one could skip the parenthesis in the method called using the new operator. I don't have strong opinion if thats is actually a much needed change, but I am willing to give it a try. The whole mess comes from the operator itself (both symbol and the name). But it looks like some other useful variants where already proposed (chaining operator). With new syntax you could do something like this: ``` User |&gt; left_joins :posts |&gt; where state: :active |&gt; where created_at: &gt; 2.days.ago |&gt; order :id ```
Precedence of operators. You could skip the parenthesis in chained methods.
This is a good overview of pipeline operators in various languages: [https://mamememo.blogspot.com/2019/06/a-brief-history-of-pipeline-operator.html](https://mamememo.blogspot.com/2019/06/a-brief-history-of-pipeline-operator.html)
I've been using jruby for two years now, the two biggest problems seem to be, start up time and compatability. The start up issue makes using TDD a bit harder, if your a bit smarter about tests it isn't much of a problem. I found gems such as guard don't work very well at all, which is annoying but nothing I can't live without. They are also bringing out something called truffle Ruby which I think is being developed by some people at oracle, that should hopefully be a much nicer Ruby running on top of java. Ultimately it's not a bad choice, businesses like it so you can use old java code, mri is much nicer to work with but you just don't get the same java integration. This won't count for every scenario but I'd rather be using jruby over java. If there's no java involved then mri all the way.
What do you mean by "smart" with regards to testing? I just use Spring with Rails and MRI. What could I do with JRuby?
I guess I'll stick with MRI then. Thanks!
By smart I mean with what you include with certain tests. We found that our helper files contained a lot of stuff that would slow down test start up, and when you just want to run 1 spec it can get really annoying. I'm pretty sure for some of the tests we just didn't use active record and that helped speed it up a little. So if you have dependancys your loading for tests that don't need them you might as well just not load them. Generaly I find using rspec as you would with mri is fine with jruby. There is a variable you set somewhere in the config that can speed up start up when in dev mode as well. I have no idea what it's called though or where it is.
Main reason is Range Literal. before: `(1..10).each{|i| p i}` after: `1..10|&gt;each{|i| p i}`
wsl is good
I used a vagrant VM for several years and now I use WSL. I do full stack Rails development quite happily, but I should note that I haven't yet had a chance to try webpacker + Rails yet. Never had any issues with anything other than nodejs crapping out when trying to install packages, which is easily fixed with the "--no-bin-links" flag
Most of those code schools suggest you have a mac or a unix environment for a fairly good reason. Frankly it's more than just ruby that you want -- you want a lot of libraries and an easy way to install them, you want a compiler toolchain that you don't have to fuck around with and 'just works', you want a sane filesystem and shell, etc. Plus you won't end up fighting against a lot of rubygems and third party software where windows QA / Support is an afterthought. You can definitely have a productive development workflow on windows alone, but it's a lot easier to develop on something that resembles the platform you'll be deploying on. WSL is the best possible option for someone on windows. A VM would accomplish the same thing but would require more resources and initial configuration. RubyInstaller is a meme.
Use Linux for programming
WSL has been my tool of choice. Provides a linux subsystem on a windows PC. No virtual environment needed
Just commenting to save the no bin links tip
It totally sucks that the default answer to this for ruby in 2019 is still "get a mac" or "use linux" but the problem with running on windows (even WSL) is there will always be some weird corner case issue that exists only because you're on Windows and you'll be learning to overcome that versus learning ruby. When you're starting out, the mountain in front of you regarding learning, will be mostly non ruby related, i.e. the DevOps side of learning. IMO it will be easier to learn the basics of linux and the terminal than to jump through the hoops of running ruby on windows. WSL IMO doesn't count here because it still requires you know the linux basics, which if you do, why not just use actual linux for development? Also at some point you're going to need to learn how to deploy your app, which will require linux. AWS/Heroku/Google type of cloud solutions are great but a lot of companies will run internal hardware/VMs for their deploys so those may not be options.
&gt;Since quite a while Linux as copy on write (COW) when forking. So even if you are using multiple processes most of what is loaded before fork is shared with the children. COW works really well for sharing binaries. CRuby is terribly behaved from a CoW perspective. &amp;#x200B; Aaron Patterson's work on compaction will help quite a bit. There are a few other potential improvements like: * Introducing a frozen generation so a major GC doesn't casue 35% of memory to copy over. CPython now has somethning like this to prevent reference counts causing every object to copy. * Freezing and not allocating into the Ruby managed heap pages inherited from the parent process * Using jemalloc to compact malloc managed memory like Redis does (this could be a huge improvement) * Using malloc/jemalloc to explicitly manage a separate memory areas for pre-post fork * Not mutating the C memory linked to by a frozen pointer (relies on the first point)
Nice. Clean and simple.
I just tried to instal rails in WSL and had a hella time doing basic crap in it. I would definitely use Linux or macOS as well especially if you’re just starting out.
Ruby on Windows is bad for several reasons. Make a new partition and install Linux Mint.
&gt; CRuby is terribly behaved from a CoW perspective. It certainly could be improved, but it's far from as bad as you make it seem. I work on a gigantic Rails application (you'll have no issue figuring which one), and am regularly doing memory profiling and optimization. We're running unicorn and are able to have the vast majority of the resident memory shared with the parent process (several hundred MB). Tenderlove's work is very much welcome, but it's not exactly to improve the rate of shared memory. It's to reduce the parent process memory footprint by compacting it before you fork. As for preventing the GC to discard shared pages, it's been done years ago (in first in 2.0 IIRC, and then improve over in 2.2).
found it very helpful, particularly HTTP 500 error troubleshooting
I would suggest using Docker. You can install docker, then mount your application directory to the container directory and then you can run IRB or rails or what ever in the container on your local code base. You can use an IDE(VS Code is pretty decent) on your local machine, and run the code / IRB in the container. Just make your entry-point of your container /bin/bash or what ever shell your container has, and then start hacking away. This is superior imho because; you don't need to screw around with setting up VM's and installing Ruby/Dependencies(there are many already built containers readily available), you don't pollute your OS with Ruby/Dependencies, you don't need shims or rvm to quickly change versions(just use another container), and you can easily use it for other languages like python, java, .NET Core etc...
\&gt; What do you feel is the best way to host a Ruby / Rails App? &amp;#x200B; [Hatchbox](https://www.hatchbox.io) makes deploying to my own hardware easy and is almost a sysadmin — I can scale across a load balancer and multiple instances with ease. Thanks @excid3 &amp;#x200B; \&gt; I'm a beginner and am looking for a simple and affordable solution. &amp;#x200B; [Heroku](https://www.heroku.com/) is probably the de-facto solution. It's affordable if you value your time and sanity. Since you're a beginner you probably won't hit enough scale to make Heroku chew through hundreds of millions of dollars. &amp;#x200B; You can also use [Dokku](https://github.com/dokku/dokku) on your own hardware. It sets up "git push dokku master" to deploy, has a nice plug-in system that makes everything (postgrseql/redis/elasticsearch/etc.) work out of the box. It's great stuff. &amp;#x200B; Some will recommend Capistrano/Mina/whatever, and those are fine if you want to spend as much time coding as you do figuring out why your nginx config is failing. I have better things to do (code) so I don't bother with being a sysadmin and would rather pay someone to do that for me. You might be in the same boat. &amp;#x200B; There are others worth exploring, but if I were you I'd get used to things on Heroku before heading off on your great adventure.
Installing Linux is a better option, but you can definitely do most of the App Academy/Odinproject curriculum on Windows without much problems. You'll have to waste some time setting stuff up which would've taken you a few minutes in Linux. It becomes a pain when you have to use Rails but that's much later.
Sure, if you're already using Groovy, that seems to make sense to me.
I have needed this kind of thing before. Will try to keep an eye on it.
Wow! Thank you so much for the helpful response! :) &amp;#x200B; How do I use "stylesheet\_link\_tag" in my "html.erb" file? I want to have a css file called style.css in this directory (app/assets/stylesheets/style.css) &amp;#x200B; Here is my project: [https://repl.it/@WaffleRuby/NameGen](https://repl.it/@WaffleRuby/NameGen)
The Windows Ruby port always has problems for me. It's never just worked, I would avoid it if possible. WSL will be the easiest and best way for you to use Ruby on Windows.
&gt;Hatchbox makes deploying to my own hardware easy and is almost a sysadmin — I can scale across a load balancer and multiple instances with ease. Can you elaborate? The word deploying refers to me as putting your app in some kind of remote servers (basically the cloud) I wanted to understand what this tool does. I've already heard about it and thought it was an online service but since your own hardware is concerned I wanted to understand. Thank you..
Best might not be easiest, but IMO the best approach is just get a VPS ([DigitalOcean](https://m.do.co/c/0f021fe7c318) is nice), set up Capistrano, Phussion Passenger with Apache or Nginx, set up MySQL or Posgres, and that's it. It's one of the cheapest alternatives too. Digital Ocean has lots of guides for setting up most of what you'll need, and the Capistrano and Phussion Passenger websites have great documentation too. Eventually if the application grows, you might want to give the DB or web server it's own VPS, depending on your particular usage. But that's a good problem to have, you can worry about that when it happens, most projects don't need much. I think that's the standard way for the Rails industry to deploy apps, as it gives you full control and "just works", but I know many people use Heroku and similar alternatives too.
JRuby is excellent in all ways and runs great on Windows: [https://twitter.com/headius/status/1115390776555581440](https://twitter.com/headius/status/1115390776555581440) If you really want MRI, here is a recent article about installing it on Windows: [https://stackify.com/install-ruby-on-windows-everything-you-need-to-get-going/](https://stackify.com/install-ruby-on-windows-everything-you-need-to-get-going/)
Used professionally wsl with rails ranging from 3.1 to latest and ruby 1.8 (yes, no kidding) to latest ruby. Used webpacker, yarn, etc. The thing is solid, but you need a fast computer to be enjoyable (specially fast io, like a nvme drive) and disable defender (at your own risk) and configure windows update to update once updates are ready for organizations (don't recall the exact setting name).
I love Linux, but some companies require windows or Mac, for vpn, etc. And with windows/mac a wide variety of hardware works out of the box (no need to hunt a specific laptop that work well with linux)
WSL can work well (and WSL2 will probably be even better once its polished up) but I'd hesitate to recommend it to someone just getting started. You're gonna run into issues, and if you're not already familiar with both Ruby and *nix adding on another layer of edge cases isn't going to help. That said, if dual booting (or a full switch) to Linux isn't an option, WSL is better than trying to get a native windows ruby up and going.
For sure, while I'm sure they're out there, I've never worked at a company that didn't make an exception for the developers when it comes to using Linux over Windows/Mac. YMMV though. To me that would be a strong signal to not work at a company if they're making me do Rails development on a Windows PC.
He means that you spin up your own Digital Ocean droplet or AWS instanced and it will install and configure an environment for your app and I believe it will also deploy it. I tried Hatchbox for our complex appp and it didn’t work out but for smaller apps I think it would be fine.
I second this. Just keep in mind that RoR isn’t popular at DO because the documentation is out of date and it’s missing a lot of details. Who knows maybe I’ll help fix it soon
Windows 10 has Linux deeply integrated through WSL. You can even pick the specific district even though most people will go with Ubuntu
You don’t need to do that anymore now that WSL is here. The only thing people need to do now is pick their distro and it’s tightly coupled to windows power shell now. Even Cygwin is obsolete
Why? WSL is full Linux on Windows. What did you run into? Which distro did you use?
Imo this is the best option if OP is willing to learn Docker. It’s nice being able to restore your dev environment on any computer and not having to run a full blown VM
I don’t recommend JRuby for new people. While it’s come a long way and its performance is awesome since it’s real multithreaded, too many things still have compatibility issues big and small. It’s just easier going with MRI ruby for new people
Windows is bad by itself. A crappy OS anyway.
Not everyone likes the command line. Windows 10 is also different from its predecessors, and it’s still a better GUI OS than Linux.
99% of the engineers love the command line since it's much more powerful than any graphic interface. Windows has a horrible DNA, and nobody can fixes that. That is why it lost the OS server war so overwhelmingly.
Consider Cygwin and its Ruby package.
It seems that you are not using sprockets yet Normally there is an "index" file And you just add comment in that index file to include other stylesheet files (sprockets "magic") Rails official guide explains it in detail already: https://guides.rubyonrails.org/asset_pipeline.html Read it :)
Yes it superior to Windows in many ways, but Linux won mainly because it’s free. Not all programmers love the command line. If that were true no one would be using Mac or Windows
Upvote for Jekyll. I have coworker friends that write full blown Rails apps just for a tiny vanity blog. That’s fine for some cases, but I feel like Middleman &amp; Jekyll could use more exposure.
What is a typical use case for this tool?
Heroku is super simple for getting up and running quickly. Digital Ocean seems to be the go to when you want to take it a bit more seriously. I highly recommend this walk through for getting DO set up https://gorails.com/deploy/ubuntu/18.04 (tried it myself and works perfectly)
if youre a good developer you can transfer your skills to any language. who cares if ruby dies off. i've already shifted from ruby to swift, but I still use ruby a lot for web/server stuff.
We are preparing to use it in our production environment, so a few other fixes/features will follow along. If you notice something is not right/missing, please do open an issue. Thanks for checking it out!
A good comparison would be that pallets is sidekiq for workflows. It is designed with simplicity, extensibility in mind and it is very fast. &amp;#x200B; A workflow is split in several tasks, each depending on one another, as defined by the developer. Jobs should ideally be very granular so that pallets can process them fast and in a concurrent manner. Other highlights include reliability (jobs cannot be lost), and retries on job level. There are many configurable levers that help in making pallets suitable for your use-case/processing patterns. &amp;#x200B; As an example, you might think of user signup: first, create the user, then their subscription and possibly its Stripe equivalent (let's say). After that, a confirmation e-mail is sent.
The article is not about the author questioning his skills in a non-Ruby world. It’s about how he doesn’t feel like community is involved in designing new features and how some doubtful trade-off decisions are made by the core team instead.
Things like that hardly determine languages's future. Frankly speaking, I see no point in the so called "pipelined operator" but pattern matching is a must for every modern language. I don't think there's a person who regrets it exists in any other language, it's not about syntax, it's about writing succinct correct programs. Anyway, I want to double the opinion it's not the language that matters, it's you and your skills.
The question is always: Do you trust yourself to run, administrate and secure a server on your own. If you can do this and want to invest the time, get a VPS, set up nginx, passenger, etc (most VPS providers will offer you an image that comes pre-configured with this). But please always consider that you are responsible for keeping Linux and all the software you run on it (Databases, etc) up to date, apply security patches, and make sure that you don't accidentally leak something to the outside. Services like Redis or MongoDB listen on all connections and are accessible without authentication in their default configuration. If you do not reconfigure or correctly set up your firewall, your stuff might be accessible from the outside world. If you don't want to do this or you don't know how (following guides only gets you to a certain point, the rest comes with experience), please use something like Heroku and let them handle the server for you.
How do you pass parameters to the `run` method?
Why is pattern matching a must? Rich Hickey disagrees.
I just don't get this article at all. It seems to be clickbait, not anything with any substance. 1. Pattern matching: in the author's own statement, he said he's used one gem, and there are others. If what is included doesn't work for your needs, that's what libraries are for. That's why jQuery got so popular - it's not that you can't do everything with native Javascript, but why would you when there's a great library out there? Adding a partial, improper, or unpreferred solution to MRI doesn't solidify it's fate - you can *still* use those gems. They aren't blacklisted or outlawed. 2. Pipe operator: Okay, so someone merged something that people didn't like. Name me one language that *hasn't* done this. Go ahead, I'll wait. But the comparison to "how other languages do it" is asinine. You're not going to work on a Wordpress/PHP script and expect it to be programmed anything at all like a Ruby script. 3. Frozen string literals: This was *not* made a default for backwards compatibility. This isn't iOS where everyone gets the latest and greatest the moment it comes out. When Ruby 3 hits, it will take years upon years for people to migrate to it. Unlike something like Rails, Ruby just doesn't have the big press releases and articles published to it, because it's usually "there's a couple new syntax things but we made everything 9% faster!" It'd be very easy to miss something along these lines when upgrading. If this were more elaborate and provided dozens of examples, I'd bite. But, even still, development continues, and it's getting better release by release. This seems to be a case of the author walking into a room containing only a table with a million dollars in cash piled on it. On the pile of money, there's a note saying "This is you'res." Instead of being happy about the money, the author is complaining about the grammatical error in the note, and saying there's fault in the person giving it. I'm not saying Ruby is perfect. It isn't. What language is? But, if you're not happy with the community and where Ruby is, **GET INVOLVED**. Don't write a clickbait article about it.
Hasn't core.match been there for a couple of years now?
Yea but he said in a talk a while ago that pattern matching doesn’t solve all of the problems that people claim it does. It doesn’t make conditional logic any easier.
Sure but it is clearly useful enough to be in there.
Nice. I've gotten into the habit of manually doing something similar to `SanePatch` when I patch dependencies. Except instead of supplying an exact version, I sometimes supply a gem dependency. For instance, maybe I'm fixing a bug in SomeDependency 2.2, which my app is using, and _know_ the bug isn't fixed until SomeDependency 3.1 (because the bugfix was released then, but not before, but I'm still stuck on an old version). So i don't want to raise until SomeDependency 3.1, which is `"&lt; 3.1"` rather than `"2.2"`. Such semantics can be easily implemented using `Gem::Version.new(version_string)`, which gives you an object which can be compared with `&lt;`, respecting version semantics. Not sure if SanePatch includes this, but it would be a good feature! Maybe I'll look and see and PR it if not.
In general, many applications could benefit from looking into smaller overhead like Jekyll or Sinatra before automatically jumping to full blown Rails
That could be a nice addition for chases where you are really sure that the patch won't cause any problems until the version where the bug is fixed. Generally, I think it's good to always double check your patches after upgrading gems since they could break because of some other change in behaviour.
Is Jekyll adapted for non dev users (for writing blog posts)? I mean does it have some kind of forms or should we writing the text files (.md or other kind) in the filesystem?
I quite agree with that. Having watched most of Rubykaigi2019 videos I think Ruby's future looks quite bright actually, soon will get: 1) an optional type checker developed by Stripe 2) real concurrency, 3) memory improvements through GC.compact that Tenderlove is currently working on 4) Fiber improvements (see ioquatix) ..... and the list goes on. I don't really think these kind of statements `I'm worried about Ruby's future` add any real value to the community. They sound somehow radical in my opinion but maybe I am wrong. Matz and Ruby developers are quite open for discussions and they are quite responsive in Redmine, Twitter... as well. I am doing Ruby/Rails the last 5 years and overall I am very happy how the ecosystem has evolved these years and how awesome the community and the Ruby developers are.
You use contexts for this. Check [this wiki page](https://github.com/linkyndy/pallets/wiki/Sharing-data-within-a-workflow) for more details. Roughly, you can provide context when you run a workflow: ``` MyWorkflow.new('this_is' =&gt; 'some_context').run ``` And then you can read/write context inside tasks with the regular Hash notation: ``` puts context['this_is'] context['more_context'] = 'is_better' ```
the article is not complaining about the ruby community. on the contrary, it’s arguing the community is not listened to. there’s a lot of confusion is about *how* to get involved, if you’re not already part of the small cabal of japanese core ruby devs. they don’t seem to be influenced by too much outside influence, which is what the article is about.
I read the comments before the article.. But, well, all of his worries are relevant imho.. E.g. about implementing something already existing. I don't know if this happen often, but at least one time I saw rails adopting a gem in its core.. So I absolutely agree about some NIH syndrome involving here... The author might be biased by its own expectation of ruby direction but all of his points are cleanly argumented..
I'm really a beginner with ruby so all of those points pass over me but regarding getting involved, he gave an example with the pipe operator being heavily rejected precisely by the *community* without any effect..
This is also what I understand about the article and this makes total sense..
I don't really agree with that. &gt; if you’re not already part of the small cabal of japanese core ruby devs. There are already many non Japanese devs in the core team, Tenderlove, ioquatix, Jeremy Evans to name some of them, you can find more here https://github.com/ruby/ruby/graphs/contributors. In addition to that many talks in Rubykaigi are in English from the Japanese devs. &gt; the article is not complaining about the ruby community. on the contrary, it’s arguing the community is not listened to. Again I don't find this to be true either. Here is a recent prove for that https://twitter.com/yukihiro_matz/status/1139419951444271104 &gt; there’s a lot of confusion is about how to get involved First sentence from the official website of the language: `If you are interested in getting involved, here are a couple of places to start` https://www.ruby-lang.org/en/community/ &gt; they don’t seem to be influenced by too much outside influence, which is what the article is about. Again, not sure if that's true either please have a look at the redmine issues, Matz and the Core team are never closed to feedback.
Reading this comment and reply was really relevant to what I thought when I was checking out the GitHub page last night when you first posted this. I had a really hard time appreciating it's intent because of the `foo bar baz qux` examples. I know that these are commonly used to abstract the meaning and just supply a template, similar to lorem ipsum, but I truly dislike most usages of it. I find it much harder to imagine what I might do with a tool when I'm left paying attention to "Wait, was this `bar` used yet above? No? Which one was this in the code above now?" I think the terms look too similar, and they all have the same meaning: i.e., no meaning. I'd really encourage you to replace the foo bar example with something more concrete, similar to the scenario you mentioned above. It would be much easier to follow and get inspired by. Thanks!
&gt;We're running unicorn and are able to have the vast majority of the resident memory shared with the parent process (several hundred MB). Are you measuring from /proc/smaps like this? [https://gist.github.com/authorNari/2176775](https://gist.github.com/authorNari/2176775) I think measuring RSS will give you highly misleading numbers. I've seen as bad as only 24mb of a 230mb parent process remaining shared after multiple major GCs. &gt;Tenderlove's work is very much welcome, but it's not exactly to improve the rate of shared memory. It's to reduce the parent process memory footprint by compacting it before you fork. That's not what Aaron said last time I talked to him about this. Heap fragmentation is a major cause of CoW issues. Reducing heap fragmentation and not leaving gaps is eactly how we the improve the rate of shared memory. &gt;As for preventing the GC to discard shared pages, it's been done years ago (in first in 2.0 IIRC, and then improve over in 2.2). 2.0's bitmap GC only prevents copying caused by marking. Sweeping and allocation cause the same problem, just more slowly. One can cause most shared memory to copy even on 2.7 in a few lines of Ruby: [https://gist.github.com/jamatthews/01bd8099fed9017e0a0401cd2058259f](https://gist.github.com/jamatthews/01bd8099fed9017e0a0401cd2058259f)
Very straightforward, thanks for your contribution!!
Glad you find it useful!
All of the decisions are made in the open and people are allowed to put their best arguments forward. That is, if you have concerns voice them in the appropriate channels?
thanks for the clarifications. it does indeed seem there’s some outside involvement. it would be great to see or know how involved they were on the particular issues mentioned. on the one hand i agree that a couple of warts does not define a language, but these are two glaring ones. they both smell like feature envy gone sour. particularly the piping one, which is laughably off in intention and definition.
&gt; Are you measuring from /proc/smaps like this? Yes. We're also tracking PSS vs RSS. &gt; That's not what Aaron said last time I talked to him about this. Heap fragmentation is a major cause of CoW issues. Reducing heap fragmentation and not leaving gaps is eactly how we the improve the rate of shared memory. Well, I don't see quite see how, unless you're suggesting MRI would re-use gaps in the parent pages to put new objects. I'm under the impression that it isn't the case, but might be wrong on that one. &gt; One can cause most shared memory to copy even on 2.7 in a few lines of Ruby It's because your snippet doesn't allow the objects to go in the old generation. You can use https://github.com/ko1/nakayoshi_fork for that.
&gt;Yes. We're also tracking PSS vs RSS. Wow! That's crazy good compared to what I've seen at HotelTonight/Airbnb and heard from Stripe and GithHub. I wonder why it's so different? Do you have some huge binary libraries? &gt;Well, I don't see quite see how, unless you're suggesting MRI would re-use gaps in the parent pages to put new objects. I'm under the impression that it isn't the case, but might be wrong on that one. That's exactly what happens. MRI has absolutely no idea what's a parent or child page. I was working on adding this to MRI, and Aaron kindly spend some time discussing it with me. &gt;It's because your snippet doesn't allow the objects to go in the old generation. You can use [https://github.com/ko1/nakayoshi\_fork](https://github.com/ko1/nakayoshi_fork) for that. Nakayoshi fork doesn't fix the fundamental issues with mutating memory after forking: This will cause almost all memory to copy simply via GCing empty space [https://gist.github.com/jamatthews/0b3e65dc27117b775ccd2dfaf6d9e2bf](https://gist.github.com/jamatthews/0b3e65dc27117b775ccd2dfaf6d9e2bf)
HTTPX seems awesome. I will try it next time.
I hear you, but I am also a big believer in "update gem dependencies *often*." If we trust semver, we should likely be able to upgrade to anything but a major release without problems. In practice, I feel pretty comfortable trusting that a patch release update won't break my patches -- or my other automated tests will catch it if they do. I want to be continually updating to latest *patch* releases (if not minor) to get security patches and bugfixes. Often with a simple `bundle update`, which gets latest versions of all depenencies matching any reqiuirements set. I am aware that many ruby and especially Rails maintainers don't do this; I'm not totally sure why. I think it's the best practice, and the way bundler was intended to be used upon invention, and my goal is always lowering any barriers to doing this. So having to manually check/update a local patch every time I run a `bundle update` that updates even just to a new *patch* release of a dependency would be an additional barrier. But if you aren't in the habit of trying to keep your dependencies up to date, and updating dependencies is a once-in-a-while major deal, this wouldn't seem relevant. But it's always my goal to try to get to continuous updating of dependencies to get any bugfixes, perf improvements, security patches, etc., instead of making it a once-in-a-while big-deal thing. But then there's also the even more clear-cut case, where I am monkey-patching a back-port of a bugfix or feature that's *already* in a later release of one of my dependencies, but I can't update to that latest release for some reason. In that case, I really do know what future version will make my local patch wrong. I have been using this technique for a while (more manually, not with SanePatch or similar re-usable code), so have developed a sense from experience of what makes sense and ends up working for me. (And I agree this general technique is a great idea!).
You should probably just use refinements.
Gotcha. From your [base class](https://github.com/linkyndy/pallets/blob/master/lib/pallets/task.rb) I see the context is set in the initializer, which makes it possible to run tasks independently, e.g. `MyTask.new(foo: 'bar').run`. That's important for code reusability, and I'd suggest adding a section to the README about "Running tasks outside of a workflow".
Indeed, you _could_ run them like that. However, I'm not sure if that should be part of the "public" API, or promoted at least. A task should only make sense within a workflow, at least that's what I've intended. What use-cases do you see for running tasks outside a workflow? I don't feel convinced this should be an "advertised possibility", aside of the fact that you can of course do this if you're able to figure out it's possible.
Thanks for the tip! For the intro section of the README, I wanted something really concise, to present the main "idea" of pallets. Then, the rest of the README, plus the wiki pages, they all feature "real life" examples, to better reflect usages, as you very well mentioned.
&gt; Do you have some huge binary libraries? Not that much. But we have a ton of static in memory data. e.g. I18n strings, in memory "databases" (think YAML documents committed in repo and loaded on boot), massive Active Record Schema Caches data structures, Journey routes, and of course code &amp; ERB templates. And most importantly we've spent (are are still spending) some effort tracking down and fixing code that was mutating global state and freezing it extensively, as well as eager loading various things that were loaded lazily, so that they end up in the parent memory. (HARB is super helpful for that: https://github.com/csfrancis/harb) &gt; I wonder why it's so different? No clue. To be fair we're far from a 100% rate, as said previously we'd be happy with any incremental improvement over what we have today, but CoW is already saving us massive amounts of RAM (over 700MB of shared pages per children last time I checked), and it's way way above the ~10% ratio you are reporting. But of course it has a tendency to slightly deteriorate over time when the children process requests, hence why we're tracking this kind of mutations down. &gt; That's exactly what happens. MRI has absolutely no idea what's a parent or child page. I was working on adding this to MRI, and Aaron kindly spend some time discussing it with me. Right, it would be better if they were frozen entirely. However the older the page is, the more likely it is to be full of very old objects, hence less likely to be written over. &gt; Nakayoshi fork doesn't fix the fundamental issues with mutating memory after forking. Of course not, but it remove a massive source of invalidations. In the first gist you posted most of the 1M strings will be new objects (even though it depend on the GC tuning variable), so the first time GC runs in the child, these objects headers are mutated and the shared pages are trashed, hence why Nakayoshi run 4 full marks to ensure all the surviving objects are marked as part of the oldest possible generation. As you mentioned some page will still have free slots and this will lead to some loss, but if you are booting a big Rails app you should have plenty of pages full of old objects.
I understand your use case and I think that it makes a lot of sense. I guess the practicaly of this depends a lot on the development culture and project/team size. This gem was extracted from a large size production app where it was used for all sorts of patches, so the approach to just act as a reminder after upgrading a specific gem worked fine. It would be awesome if `SanePatch` would allow for more flexibility to also cover such use cases. It‘s my first approach at releasing a (hopefully) somewhat useful gem so I really appreciate the feedback!
I agree that Refinements should be used more but depending on the use case you still want to ensure that they work properly after upgrading the underlying gem. In a perfect world `SanePatch` wouldn‘t be needed since everything the patch does would be covered by tests. `SanePatch` just allows you to take the more lazy and sometimes more pragmatic approach.
I agree that Refinements should be used more but depending on the use case you still want to ensure that they work properly after upgrading the underlying gem. In a perfect world SanePatch wouldn‘t be needed since everything the patch does would be covered by tests. SanePatch just allows you to take the more lazy and sometimes more pragmatic approach.
I understand your use case and I think that it makes a lot of sense. I guess the practicaly of this depends a lot on the development culture and project/team size. This gem was extracted from a large size production app where it was used for all sorts of patches, so the approach to just act as a reminder after upgrading a specific gem worked fine. It would be awesome if `SanePatch` would allow for more flexibility to also cover such use cases. It‘s my first approach at releasing a (hopefully) somewhat useful gem so I really appreciate the feedback!
If anyone is looking for a workflow engine for Sidekiq, it's right here: https://github.com/mperham/sidekiq/wiki/Batches
Each entry in the cart is a single item. You don't want items.each loop at all. There isn't items. There is an item. car.each do |item| if updated_cart.key?(item.key) # then increment the count value that is already in updated cart else # add the value 1 to key :count in item.value # then assign that result to the key item.key in updated_cart end
Ruby is not going anywhere, while those design choices are not perfect, and I also dislike them (I don't think a proper OOP program needs pattern matching anyways) I think this is a bit too much drama. I know big companies which are using Rails which will just continue using Rails.
Pattern Matching is basically `switch` with super-powers, which is a bad practice in OOP languages anyways. I don't see how this is a __must__. If you want to use Ruby as if it was Elixir, just use Elixir.
This is similar to a gem I wrote several years ago called [orchestra](https://github.com/ntl/orchestra). I've since abandoned it, the pattern has problems -- namely, you end up with a big bag of "global" state being freely passed between units of work. Eventually, you start seeing units of work set state that then gets picked up by future units of work, which is an encapsulation problem.
I admire Rich Hickey, I really do. And of course one can shoot oneself leg with pattern matching by ruining proper encapsulation, after all it's just a tool. What RH is talking about is you cannot enumerate all possible states in your program and call it a day. Problem is programs are different and the things they operate are different too. PM is good where it forces you to cover all possible cases so that your program will behave predictably. If it happens such strictness is unreachable for some reason it's possible you're modeling your domain in the wrong way. Now you get a chance to think about it by looking at the code and saying whether you like or not. No doubt modeling state of a big application with a simple enumeration is doomed to fail but the idea of splitting big models into sub-models isn't new not in Ruby, nor in Clojure. All of the above is about PM at large, for small applications like monadic type constructors PM is a clear win.
&gt; 1) an optional type checker developed by Stripe Will that be built-in to the language?
There is no difference in abusing pattern matching in OOP and FP. If you cross boundaries by drilling down through state in OOP we say you violate the Law of Demeter, in FP folks say "your code sucks" or something similar. What PM helps you to do is ensuring your program doesn't have gaps, unhandled state and so on, this is so universally useful that I dare to say it's a must. And from what I see I'm not the only one, many popular recently developed languages (off the top of my head: Rust, Swift, Kotlin (not full-blown PM), Elixir) have support for PM in one form or another. Even Java has a discussion about adding pattern matching to the language, I suggest you go teach those guys how to OOP. WRT how to use Ruby it's up to me. Ruby's strong sides still outweight its shortcomings even I programmed in a variety of languages. I ended up with supporting a toolset of gems I use at work and I'm really happy with it.
Jekyll out-of-the-box is designed for devs writing content in markdown files and using Git as the CMS. There is a plugin (Jekyll-admin) that gives some of the more traditional CMS functionality. There are also other things you can use to get this functionality. [Here](https://jekyllthemes.io/resources/jekyll-hosting-and-cms-solutions) is a list.
 cart.tally.each{ |h, n| h.values[0][:count] = n }.keys
Rust, Switch, Kotlin and Elixir are all typed. Ruby is dynamic, it's not the the same thing. Just throwing in language constructs won't make your software better, sure, you might have less bugs when writing conditionals, but if you need to check too many conditionals in Ruby in the first place, your code is trash anyways. I also don't like Ruby adding in optional typing :/
How about creating a class for your data structure with constructor taking your keys as arguments and setting them as attr_accessors, then overriding filter method getter where you do a case-when for transforming values and then override to_s method where your compose your string.
This is a very good point, though Elixir is dynamically typed after all. This is the only new dynamic language that comes into my mind. In my opinion, statically typed languages won, in a way. Anyhow, my point is no matter what language you work in you should be able to trace what your program is doing at any point. Approach like anything in anything out isn't really sustainable in the long run. From this view, PM shouldn't harm you, quite the opposite.
class Query attr_reader :days_ago, ... def initialize(days_ago:, days_ago_filter:, key:) # assign to instance vars here end def readable_filter @readable_filter ||= case when ‘lt’ ‘Less than’ else filter end end def to_s # compose your string here and use readable_filter in place of filter variable end end Or you can so better with class Filter attr_reader :filter def initialize(filter) @filter = filter end def to_s # put case-when statement here end end Then you can do in Query class: def initialize(days_ago_filter:) @filter = Filter.new(days_ago_filter) end def to_s # just use filter variable to compose your string from there end
I’ve been using middleman, and it does almost everything I need, but it it seems to be poorly supported these days, in particular dealing with 3rd party CSS and JS libraries has been a pain. Is there a good write up of the differences of Jekyll vs middleman? I’m thinking about switching, it am worried about doing so, and then finding out it doesn’t do some important feature I need.
Personally, I'm a fan of Jekyll + S3/CloudFront. This gem is a handy helper on the deployment side: https://github.com/laurilehmijoki/s3_website
Having the name as the key for the hash makes me wonder.. &amp;#x200B; I feel it more prudent to have a name key the says what the item is, or some sort of unique identifier for the item you're looking at, e.g.: \`\`\` \[ { name: 'avocado', price: 3.0, clearance: true }, { name: 'avocado', price: 3.0, clearance: true }, { name: 'kale', price: 3.0, clearance: false } \] \`\`\` This is an array of individual items, which represents your cart. When you check out, you can do something like: \`\`\` def consolidate\_cart(cart) \# first I make a hash of { item =&gt; number of occurrences }, \# each\_with\_object starts you with a thing (a blank hash in this case) that we can build upon as we go, it becomes the second argument to the loop, which I have named 'memo' item\_to\_quantity = cart.each\_with\_object({}) do |item, memo| \# this is shorthand for memo\[item\] = memo\[item\] || 0, we initialize the quantity to zero if we haven't seen this item before memo\[item\] ||= 0 \# add one to the quantity memo\[:item\] += 1 end &amp;#x200B; \# now we take that hash and just shove the quantity into the keys and return an array (with map) of items with the quantity now attached item\_to\_quantity.map do |item, quantity| item\[:quantity\] = quantity end end \`\`\`
I don't necessarily see it like that. Tasks do various operations and often, they contribute to the "bigger" picture (the workflow), by setting state (the context). Subsequent tasks may need whatever was created by previous tasks (say, you create a User object in task A, and then you send them an e-mail in task B). So, the thing you refer to as a "problem", I see it as a _feature_. How exactly was this _pattern_ causing problems to you? I am curious to see your point of view.
I am aware of batches for Sidekiq, however Pallets aims to address a \_slightly\_ different problem. &amp;#x200B; First, Pallets is more about workflows, and less about batching; workflows typically contain several groups of jobs (as they are referred to in Sidekiq batches) and are less dynamic (as opposed to Sidekiq). The aim is to define a finite set of actions (think of a state machine) that is known at **definition time**. &amp;#x200B; Second, you can indeed do [complex workflows](https://github.com/mperham/sidekiq/wiki/Really-Complex-Workflows-with-Batches) in Sidekiq, however the amount of code needed is significant, since Sidekiq was not designed with workflows as first class citizens. Pallets' intention is to make workflow processing easy and simple, using a beautiful DSL. Also, given workflow operations are at its root, Pallets is very fast. &amp;#x200B; Last, batches are not included in the free version of Sidekiq (which is a very logical decision, given the nature of the project). Pallets on the other hand, revolves around the idea of workflow processing. &amp;#x200B; In the end, I greatly appreciate Sidekiq for everything it offers; it's a great tool that made background processing so swift and nice in so many of my projects. I've created Pallets to address a different need, which doesn't necessarily intersect with Sidekiq's.
&gt; for small applications like monadic type constructors PM is a clear win. How are monads linked to pattern matching? Do you mean ADTs/sum types instead?
Some monads such as Maybe and Either are represented as simple ADTs, that’s why I referenced monads, not in general but as a particular example where PM is especially useful.
&gt; which is a bad practice in OOP languages anyways Replacing switch statements with polymorphism is a trade-off, not some hard rule you should always follow. Polymorphism makes adding new variants easy, a switch statement makes adding new methods easy (it's the [expression problem](https://en.wikipedia.org/wiki/Expression_problem)). I prefer switch statements if an object has multiple internal orthogonal variants and/or if these variants are closed (e.g. `paid(paid|notPaid)` and `orderStatus(initial|packed|shipped|delivered)`). These variants are also closed and no one should be able to create a fifth `orderStatus`. Something you can't avoid when using different classes to represent the different variants.
**Expression problem** The expression problem is a term used in discussing strengths and weaknesses of various programming paradigms and programming languages. Philip Wadler coined the term in response to a discussion with Rice University's Programming Languages Team (PLT): The expression problem is a new name for an old problem. The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retaining static type safety (e.g., no casts). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I see. I think all sum types profit from pattern matching+exhaustive checks, not just the ones which can be made into monads.
I don't consider 'not writing tests' to be 'sane'. This gem seems to just replace best practices (refinements + tests) with a dependency, I don't get it.
It helps me to talk through all the operations that need to happen and create methods for each step. So you need to translate that filter into a human readable word, so how about a \`filter\_to\_readable\_string\` method. Then you need to turn numbers into music keys, that's \`music\_key\_to\_readable\_string\`. Once you write those methods you convert the values in the hash using them.
PR created: https://github.com/Jcambass/sane_patch/pull/2
Sure, here are some possible use cases: * Sharing business logic between workflows and other parts of the application, such as an API * Running one-off tasks from the console or from `rake` * Writing unit tests for tasks More generally, hidden functionality and an undocumented public API is a pretty big barrier to adopting any gem. There are established solutions for managing workflows in Ruby applications, and if I look at prior art in this space such as [gush](https://github.com/chaps-io/gush), their documentation feels very comprehensive. It covers all the things the gem can do, and doesn't make assumptions about my use case and how I should or should not use it.
I don't find refinements work to fix a bug (the most common reason I'm monkey-patching a dependency), because you don't necessarily have control over every place that might call the relevant code that needs to be patched for a bug. You can only use refinements when you control the call site, but the call site could be in the gem being patched itself, or in some other dependency.
I am really confused, but I saw a bunch of people talking *as if* the Stripe implementation was already accepted as something to be built into MRI in the future... but I couldn't find any statement from Matz or any other committers that this was so, just a statement of interest in *some* kind of type checking, not that Stripe's was the choice. Is this just a marketting campaign by stripe? I think ruby can do better than stripe's. It's possible that stripe's can iterate to that something better. But since stripe's implementation totally works *without* being built into MRI (it was written to do so, right?), I don't see any reason to hurry to include it in MRI, rather than see how it does as an optional addition and let it iterate based on real use and feedback as that. In general, I think MRI is far too quick to add half-baked things these days, and kind of agree with the OP.
Remove the end statement. You aren't in a code block so no need to end.
There isn't supposed to be an "end" there. What does it end? There's no matching "begin" or loop or anything.
I’m not sure if I understand the rationale behind the naming...
I completely agree with your unit tests use-case, not so much with the others (tasks are merely subdivisions of workflows, you should never have/want to run tasks by themselves). But I understand your point and I can add this to the documentation 🙌 You've mentioned other gems' documentation is very comprehensive. Given you've checked the wiki, what else do you feel it's missing from there? I would gladly add more to it.
Very nice addition.
What do you mean by "a proper OOP program"? Pattern matching \*can\* easily reduce code complexity and make things easier to read and understand.
\&gt; has an \`end\` \&gt; unexpected \`end\` Doesn't this answer your question? It doesn't expect that \`end\` to be there. So remove it.
Where does #tally come from? Looking in IRB with ruby 2.6.3, I don't see that as a method on Array.
The `end` exists in a place the ruby interpreter does not expect it, a place it is not legal to be. "unexpected" means a place where it should not be.
It's coming in 2.7: [`Enumerable#tally`](https://ruby-doc.org/core-2.7.0.preview1/Enumerable.html#method-i-tally)
I tend to agree with his view, things like pattern matching and pipe (as merged/considered) seem to be very poorly thought out "must check the boxes" for people moving over to elixir or one of the other hot languages. Instead of taking the time to really consider how ruby can (or if it should) implement similar features well it seems like they were kind of just hobbled together to "exist" at any cost.
&gt; File.join(__dir__, "data", "sample.json") |&gt; File.read |&gt; JSON.parse |&gt; MyModel.new Interesting. That does make comprehension easier once reasoned about. Curious though, does this only work where the output from one function is the explicit only input to the next function? Like say i want to pass something to `JSON.parse` in addition to the output of `File.read`, e.g.: File.join(__dir__, "data", "sample.json") |&gt; File.read |&gt; JSON.parse -, {max_nexting: 12, allow_nan: false} |&gt; MyModel.new Which with your `then` example I think is easy enough to do: File.join(__dir__, "data", "sample.json") .then { File.read @1} .then { JSON.parse @1, {max_nexting: 12} } .then { MyModel.new @1 }
I can’t think of a time I would have wanted this...
In languages like Elixir where the compiler complains if you miss a case, that's fine, but for Ruby, if it's gonna just be a switch statement, it breaks the [open-closed](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle) principle. Sure, sometimes you'll need to check things, but it's the exception and not the rule, not a big fan of the language investing more on the "exception case".
IME all workflows start out nice and static, evolve into a much more dynamic set of steps which can't be represented by a class-level DSL. I've tried several times to simplify the Batch API but failed every time - there is always some loss of functionality. Good luck!
&gt; does this only work where the output from one function is the explicit only input to the next function? In other languages, the rules about this differ. In Elixir for example, it pipes the result as the first argument. A very simple pseudocode in Ruby would look like this: `'... File.read =&gt; JSON.parse(max_nesting: 12, allow_nan: false)` and would be treated as `JSON.parse(file_content, max_nesting: 12, allow_nan: false)`. Some languages only allow a function with a single argument, some pipe the result as the first argument, some pipe the result as the last argument. I think largely, people familiar with this concept don't care whether it's first or last, but they want to see this operator work similarly. With the current implementation in Ruby, it does not work like this at all. It is essentially evaluating a message to send to the object being piped (the result of the left hand side of the operator), as opposed to passing this result to some other method/function. So, you can't use this to call methods that aren't inherently on the object itself. If you are familiar with Enumerable's `&amp;:upcase` shortcut, it's similar. You can call methods on the object itself, but if you want to pass that object to some other function/method call, it takes a bit more scribble. `'myfile.txt' =&gt; upcase`). It's very similar to just using a normal method call `'str'.upcase` but has slight tweaks to the order of operations. At this time, the only way to accomplish the above style of code is with `.then` and `@1` (or whatever gets released at 2.7).
Yeah, this does seem like an easy thing to confuse with `index_by`
Totally agree with you. But a library doesn't have to be a jack of all trades. It can specialise in one/some use-cases which it should execute impeccably. After all, trying to cover **all** scenarios is mission impossible and there will be conflicting scenarios, sooner or later. With Pallets, I tried to limit these scenarios and to provide a very suitable alternative for the scenarios I've settled with. I believe in simple things that try to solve fewer problems, but in the best way. The same way as Resque and then Sidekiq solved background processing.
Do you really live at 69420 Cool Ave?
[Refrigerator](https://github.com/jeremyevans/ruby-refrigerator) and FTW.
I wish, man.
I did try it without the "end" immediately after making this post.
Or [with\_index](https://ruby-doc.org/core-2.5.0/Enumerator.html#method-i-with_index), really bad naming honestly.
So, if you have the same key that would always entail the same price and clearance?. If so you can do this: \`\`\`ruby cart.group\_by { |k,| k.first.first }.to\_h {|k,v| \[k, v.first.first.last.merge(count: v.count)\] } \`\`\`
This is good starting point. I'd add that it's important to avoid writing too many high-level tests, since they can be slow and harder to maintain. For example, if you have multiple validations on a model, testing against just one of them should be sufficient to validate the overall flow. For the remaining validations, writing lower-level tests would be more suitable.
Thanks. I tend to agree!
scrape and save to the database the whole html of the page, parse it later.
Right, I mean, I totally agree with the quick concise example. That's why I suggested simply using actual words instead of foo, bar, etc. Like I said, I spent a lot more time trying to parse foos and bars than appreciating the code around them. Anyway, just wanted to give that feedback. Thanks for publishing your project, I do a lot of scraping tasks, and this project feels relevant. Cheers!
Have you used Kiba with this style of project at all? Just wondering if you feel like they play well together, or rather kind of replaces each other. If you have used them together, how did it feel?
Once you have the scraped data, you can [write it out to a local file](https://ruby-doc.org/core-2.5.0/File.html#method-c-new). For bonus points, you can have your program see if a local file exists. If it does, read that. If not, go scrape the source.
Thank you.
I mean the articles from *upcase*.. All the courses and the tutorials..
*A* Ruby style guide.
I appreciate your feedback! Will change the example soon 🙌
Not sure why you are getting downvoted. Heroku is by far the best approach for starting out. You can focus your time and effort on developing your application and don't have to worry about patches or upgrades or scaling infrastructure, all of which is required when using Digital Ocean or any capistrano target. You of course pay a premium for this service, but it's worth it.
To be honest, I didn't think about this. I will give it a try in the weekend and let you know what I think!
Sounds like an interesting project. I will take a closer look at the repo, when I’m back home from work.
 require "json" require "ibm_watson/visual_recognition_v3" include IBMWatson visual_recognition = IBMWatson::VisualRecognitionV3.new( version: "2018-03-19", iam_apikey: "your_api_key" ) url= "https://watson-developer-cloud.github.io/doc-tutorial-downloads/visual-recognition/640px-IBM_VGA_90X8941_on_PS55.jpg" url_result = visual_recognition.classify(url: url).result puts JSON.pretty_generate(url_result)
Ah yes, that is something that is lacking :(
All that code for simple authentication?
I'll take a look shortly at what you have so far. If I think it's sufficiently high quality to be a viable project, I'd be happy to contribute. Tex or latex format is fine with me. That's how I typeset most of my own technical stuff.
Have you thought of creating GitHub issues as a way of being more specific as to what you need help with?
good idea, the least I can do is mark chapters which haven't been translated, which ones need more attention for editing/todos/etc also, there's separate code/figure folders, etc
Personally, I'd say Think Python is written very well - suited for those new to programming. I messed up a bit in trying to introduce shorter code (i.e leaning towards code golfing) - the idea of the book is to teach concepts from basics, not the final shorter code (I realized this later). There's a *goodies* chapter at the end where such things can be naturally introduced and expanded upon.
I don't think there are a lot of lines - we just put user into the context and add one more mutation. Gems like *devise* add user to the *ApplicationController* and handle the authentication inside of it, so it might feel shorter, but it's the same code, just hidden inside the external library
I'm currently working on api using graphql and using active storage for image uploads. Any suggestions?
Not really looking to take over, but I would definitely be interested in working on some GitHub issues to help out!
Take a look at [https://dev.to/evilmartians/active-storage-meets-graphql-direct-uploads-3n38](https://dev.to/evilmartians/active-storage-meets-graphql-direct-uploads-3n38) and [https://dev.to/evilmartians/active-storage-meets-graphql-pt-2-exposing-attachment-urls-2mdn](https://dev.to/evilmartians/active-storage-meets-graphql-pt-2-exposing-attachment-urls-2mdn)
I think Pawel doesn't throw anything close to the shade on the current pipe operator that it deserves. IIUC, the pipe operator now is basically another means of chaining method calls on the value returned from a previous method call; that is ```ruby d1 = a |&gt; b |&gt; c d2 = a().b().c() ``` will result in identical values for `d1` and `d2` (and the parentheses in the building of `d2` would not be there in "real" code). What would be *far* more useful would be an adaptation of Elixir's pipe operator, such that ```ruby d3 = a |&gt; b |&gt; c d4 = c(b(a())) ``` would be *far* more useful; it would make the code for every project I've touched in the last seven years more readable and readily understandable. So, of course, that's not what we're getting.
- add password_digest - add bcrypt - add some tiny methods to create the pass and read it - add current_user in some controller no devise, you can do it by yourself in under 100 lines of ruby
I took a closer look at the code. I would like to help you with the the project. I have several years of experience with Ruby, so maybe I could help with the code examples.
How is performance of GraphQL in Rails? Specifically, how does it compare to a similar REST endpoint? What about compared to GraphQL served by Apollo?
Same. I'd be interested in the idea of chipping into an effort like this but don't have the bandwidth to take over.
A very imperative way would be to set a variable to an empty hash, then iterate on the flat hash and insert the new values one by one into the new hash. This is a rather basic programming task honestly, if you have already tried something you should post it.
Kind of difficult to know what will work and not without more context. (e.g. will the keys always be named this way). Assuming that the keys will always have those names, then you could just `each_with_object({})` and regexp the keys and extract the index/name (e.g `/builder_rule_(\d+)_(\w+)/`). Though I think an array of hashes might be cleaner than having a hash with "indexes" as keys.
Kind of difficult to know what will work and not without more context. (e.g. will the keys always be named this way). Assuming that the keys will always have those names, then you could just `each_with_object({})` and regexp the keys and extract the index/name (e.g `/builder_rule_(\d+)_(\w+)/`). Though I think an array of hashes might be cleaner than having a hash with "indexes" as keys.
I think you're trying to make up for a bad form when you could just fix the root problem. Why is everything coming in flat? Use arrays in your form inputs.
Often I try to find some hints by analyzing some software version I saw in the terminal or any hints that leaks from the screen captures if any.. But everything related to IT is moving so fast that the date is really relevant.. At least knowing that a video is talking about a 10 years old version may help to identify any caveat or even to dismiss the tutorial altogether if it's really not relevant anymore..
It'll be [a gem](https://sorbet.org/).
Root problem is third-party plugin. Wouldn't make sense to rewrite that whole plugin for this one thing.
I think that something like this could work... &amp;#x200B; input = { "builder\_rule\_0\_filter"=&gt;"artist\_name", "builder\_rule\_0\_operator"=&gt;"contains", "builder\_rule\_0\_value\_0"=&gt;"New Found Glory", &amp;#x200B; "builder\_rule\_1\_filter"=&gt;"bpm", "builder\_rule\_1\_operator"=&gt;"less", "builder\_rule\_1\_value\_0"=&gt;"150", &amp;#x200B; "builder\_rule\_2\_filter"=&gt;"days\_ago", "builder\_rule\_2\_operator"=&gt;"less", "builder\_rule\_2\_value\_0"=&gt;"40", &amp;#x200B; "builder\_rule\_3\_filter"=&gt;"release\_date\_start", "builder\_rule\_3\_operator"=&gt;"between", "builder\_rule\_3\_value\_0"=&gt;"2019-01-01", "builder\_rule\_3\_value\_1"=&gt;"2019-12-31", } &amp;#x200B; Key = [Struct.new](https://Struct.new)(:id, :attr) &amp;#x200B; Rule = [Struct.new](https://Struct.new)(:filter, :operator, :values) do def process\_key!(key, value) case key.attr when "filter" then self.filter = value when "operator" then self.operator = value when "value" self.values ||= \[\] values &lt;&lt; value end end &amp;#x200B; def to\_h { "filter" =&gt; filter, "operator" =&gt; operator, "values" =&gt; values.map.with\_index { |v, i| \[i, v\] }.to\_h } end end &amp;#x200B; rules = {} &amp;#x200B; input.each do |key, value| key = [Key.new](https://Key.new)(\*key.split("\_")\[2..3\]) rule = rules\[[key.id](https://key.id)\] ||= [Rule.new](https://Rule.new) rule.process\_key!(key, value) end &amp;#x200B; rules.each do |key, value| rules\[key\] = value.to\_h end &amp;#x200B; puts rules.inspect
`def massage_response(response_hash)` `output = {}` `response_hash.each do |k, v|` `key_array = []` `key_array = k.split("_")` `output[key_array[2]] = {} if output[key_array[2]].nil?` `if key_array[3] == "value"` `output[key_array[2]]["values"] = {} if output[key_array[2]]["values"].nil?` `output[key_array[2]]["values"][key_array[4]] = v` `else` `output[key_array[2]][key_array[3]] = v` `end` `end` `end` `massage_response(your_data)`
It might make more sense to just not use that plugin.
Is the Art of Recursion dead? Let's hope not: decode_params = -&gt;((param, value), memo) { key, subkey = param.split('_', 2) if subkey decode_params[[subkey, value], memo[key] ||= {}] else memo[key] = value end } result = params.each_with_object({}, &amp;decode_params).dig("builder", "rule") You're welcome.
thanks all for the response I'll try to see if I can convert tex to markdown, it will help in breaking down the book into chapters and allow specific issues to be created (there are problems like math equations, but I think that could be worked around) I'll create another thread within a week or so with details
Thought I should present a version that is refactored into a decorator. class ParamsDecoder &lt; SimpleDelegator def decode_params each_with_object({}) { |pair, memo| _decoder(pair, memo) } end private def _decoder((param, value), memo) key, subkey = param.split('_', 2) if subkey _decoder [subkey, value], memo[key] ||= {} else memo[key] = value end end end result = ParamsDecoder.new(params).decode_params.dig("builder", "rule")
Hey ASIC\_SP &amp;#x200B; I'm not super active on reddit, but I'd like to take an active... let's say "leadership" role in this. I would like to suggest that perhaps you don't relinquish control, unless you're looking to step away, because you've got an awesome project started here!!! &amp;#x200B; I'll shoot ya a PM with an email.
Let's talk about Rails since I don't have the experience with Apollo server. When request arrives to */graphql* (by default), it's being routed to the *GraphqlController#execute,* which uses the *GraphqlSchema* to prepare the result, so technically we're on the same level with REST endpoint 🙂. You can think of a *GraphqlSchema* as a regular serializer, it does not add much overhead–as in controllers, performance mostly depends on the performance of the code *inside* types and mutations.
That paywall is really annoying (even more on mobile since switching to incognito requires some steps to go to the browser from the in-app HTML viewer..)
 d1 = a |&gt; b |&gt; c d2 = a().b().c() Sorry to be the bearer of some truly horrifying news but in the first line, `d1` will be assigned the value of `a` because, astonishingly, pipeline is a lower precedence than assignment. However if you write `d1 = (a |&gt; b |&gt; c)` then yes.
You're right. That illustrates another confusing plot point, making me wonder even more how much thought was really given to all this by ruby-core. I sit corrected.
From their github: &gt; Fullstaq Ruby is installed via the OS package manager. Rubies installed with rvm/rbenv install are not managed via the OS package managers. &gt; Fullstaq Ruby updates are supplied through the OS package manager, which can be easily automated. Updates using rvm/rbenv install require more effort. So basically you're 100% reliant on a distribution being available with the version you need, and if some newbie sysadmin decides to update everything, your app can go down in a heartbeat. No thanks. *This is why there are version managers.*
Grotesq.
You are in fact **not** 100% reliant on a package being available from us. The goal since the beginning is to allow anyone to build packages themselves, so that if we are slow or somehow becomes defunct, you can easily take matters into your own hands. The goal is to make building a package so simple that nearly anyone can do it: just install Docker, edit a config file and run a command. This is achieved by automating the entire build process, and by releasing the entire build tooling as open source. There are almost no manual processes. The scripts right now already allow you to do all this, but we don't have documentation yet on how to do things. This is [planned](https://github.com/fullstaq-labs/fullstaq-ruby-server-edition/issues/1) for [epic 5 of the roadmap](https://github.com/fullstaq-labs/fullstaq-ruby-umbrella/projects). A newbie sysadmin also cannot "upgrade everything" and break everything. See our [package versioning policy](https://github.com/fullstaq-labs/fullstaq-ruby-server-edition#minor-version-packages-a-great-way-to-keep-ruby-security-patched). Each tiny Ruby version is a separate package name (fullstaq-ruby-2.5.5, fullstaq-ruby-2.6.3). There is a minor version package (e.g. fullstaq-ruby-2.6) which allows auto-upgrading the tiny version, but it is **not** possible to auto-upgrade the minor version. There is no package that auto-upgrades from 2.5 to 2.6 for example.
If anyone is going to EuRuKo Rotterdam tomorrow: I (Hongli Lai) will be talking about Fullstaq Ruby during my talk "What causes Ruby memory bloat"! Please come find me if you have questions.
&gt; A newbie sysadmin Why would you let a newbie sysadmin upgrade your production environment unsupervised and without doing staging fist?
How could I use this on Kubernetes?
You could install the packages inside your debian/ubuntu/centos-based containers. But we have a better solution planned: a container-optimized edition. It is planned for epic 6. The container edition is a set of Docker base images, and will be based on (and will be drop-in compatible with) the official Ruby images provided by Docker Inc. We will address container-specific security concerns as well. In particular, we will provide a solution to allow easily running containers as non-root, while also solving the host UID mapping problem.
It's too bad this can't be done using `rbenv install`. Every time someone comes up with a simple improvement to a well known procedure, it's another additional set of commands to learn, *and* type up in the in house docs.
In theory we could integrate with rbenv install, but do you understand the implications of what you are asking? You can't get auto security updates without OS package manager integration. I am also curious why you perceive this as 'another set of commands to learn'. We provide packages via RPM/DEB, you already know how to use YUM/APT. We specifically avoided custom installers so that people don't have to learn a new tool. The only new things to learn is new package names to pass to apt/yum (and adding a repo).
Sounds good. When is the epic 6 planned for? I'm working on a new project and would love anything light on memory etc in production (that's why I use k3s for kubernetes).
We don't have any time-based planning. We work on this project in our spare time, and frankly for the past 2 weeks I have been rushing like crazy - working after working hours until bed time, and in the weekends - to get this released. This is not sustainable, so we are architecting this project from the beginning to allow contributions. So the answer to your question is: the more contributors we have, the faster!
This is awesome! Will make server setup &amp; maintenance easier and open up optimised rubies (Jemalloc, malloc_trim) to a wider audience.
&gt; TruffleRuby is experimenting with something special. They want to implement an automatic synchronization. The important part here is that this would be done only if the service is using threads so that the single threaded performance stays high. So, TruffleRuby would save us from doing the synchronization manually. So this stuff is really confusing, but I don't *think* that is true. I don't think that what TruffleRuby is trying to do will save you from the race condition demo's at the top of the OP, or save you from having to do synchronization for such things. Rather, it's about a lower-level kind of race condition we aren't used to thinking about at all in ruby, where the actual memory is corrupted leading to data that isn't even readable by ruby at all. MRI uses the GIL to prevent this, but that means no true parallelism. TruffleRuby is experimenting with another way that will allow true parallelism, without the GIL (like JRuby), but be higher performance than the way JRuby does it. But according to the semantics of Threads, as standard on various platforms and as implemented in ruby, there's no way to keep you from having to worry about "higher level" race conditions. The only way to do that is to try to provide different semantics/API's entirely, that aren't "Threads" -- the things we've heard about MRI experiments with "guilds" are one such thing.
What do you mean by "I tried running this"? What do you mean by "it didn't work"? All you're showing us is a file with a trivial line of code; I have no idea what you're attempting or why it's failing. One of the first, and most valuable, lessons you need to learn is how to ask questions comprehensively.
ok. Can you tell me what you did? Did you install ruby from here: https://rubyinstaller.org/downloads/ ? Did you install an environment manager, like [uru](https://bitbucket.org/jonforums/uru/src/master/)? Can you run ruby from the terminal?
Probably would help to post error messages so others can possibly guide you through.
Are there any benchmarks that compare the imrpovements between this and normal MRI?
Hmm... Thanks for the hint! I will reinvastiagte about this. But it sure sounds like you are right!
&gt; citing concerns that Jemalloc may cause regressions in non-server use cases, as well as other compatibility-related concerns. How to the jemalloc compatibilty issues manifest if some code is not compatible? Are we talking simple things like "Won't run and shows an error message like 'Yeah, no jemalloc'" or are we talking about strange memory leaks, heisenbugs and other non-obvious behaviour? Speed-up is nice but only if it is obvious when something goes wrong? Cheers
With low level things like memory allocators, heisenbugs and random crashes are realistic. Most of the time you won't run into problems, but specific libraries *could* cause problems. Unfortunately there is no list of incompatible libraries. We will have to find out by experience.
Thank you for the info!
Oh so, Ruby Enterprise Edition is back.
Exactly this, and also, OS package updates should not break for the given version. And when you do full OS upgrade it shouldn't be a trivial task you pass on to anybody anyway. You probably already depend on OS provided NGINX or PostgreSQL, but worry it breaks your Ruby? Didn't you compile your Ruby against some system shared libraries anyway? Well...
Try to reinstall Linux, it looks like windows now
I am worried now.. Will it be a paid version? Will regular Ruby (MRI) become a second class citizen?
Do I have to use docker to build it? Does it have to be built into RPMs/debs? For instance, we put all of our rubies in `/opt`. What I'd really like is a [Habitat package](https://www.habitat.sh).
Do I have to use docker to build it? Does it have to be built into RPMs/debs? For instance, we put all of our rubies in `/opt`. What I'd really like is a [Habitat package](https://www.habitat.sh).
Yes Docker is required. Only RPM/DEB is supported. If this is not a good fit for you, then I invite you to submit a feature request ticket in which you describe your case. Then we can have a look at what we can do.
There will be no paid version. This is fully open source. It is intended to be a community project where anyone can contribute. There are no monetization plans.
Gotcha. Well, I probably won't do that but thanks!
If the concern is “someone could press a button that breaks everything,” well, that is a pretty universal problem across software engineering and devops. You have my sympathy for dealing with legacy infrastructure, but if that is a frequent problem, then it sounds like moving to immutable infrastructure, high availability, CI / CD, quick rollback, and blue/green deploy strategies for updates should be a high priority.
&gt; Along with hard caps for database connections, maintaining too many processes can quickly use more memory than a server has available. Just a note on this: Threads are a much bigger issue with database connections. Your example of 10 process with 10 threads each needs connection pool size of 100 in the naive approach to avoid blocking. 100 connections per box on the web side + whatever you need for background jobs, which can be a lot with something like sidekiq, and you quickly have connection scaling issues. Unfortunately Rails connection management is extremely simplistic and wasteful and PG doesn't handle a lot of connections well. Rails will grab a DB connection the first time you hit the DB during a request and not return it until the end of the request. So if you do have 'CPU bound' requests, you're best off calling `ActiveRecord::Base.connection_pool.release_connection` before diving into the CPU work so you don't bind up a connection for the duration. This will allow you to tune down the size of the connection pool with reduced chance of blocking on it. Maybe someday we'll get fine grained connection usage in Rails.
Seems interesting! One thing that would be really helpful for my use cases is to have packages that don't contain rubygems/bundler. This is useful for operators whose apps use standalone bundles and would prefer to leave out ruby's package management altogether (since it can be a security risk). I realize this is pretty nontypical, so I understand if it's a low priority :)
I want to like it, but it looks so ugly and cumbersome.
Finally. I'll definitely be trying this out
awesome!
Would love to hear from someone using https://dry-rb.org/gems/dry-types/ how these two compare.
great !!
I’ve come around to the syntax after using it a bit, it doesn’t look very good if you use it with just one line, but in a do/end block it looks quite nice. Also, for anyone interested, the VS Code extension isn’t out yet, but is coming: https://twitter.com/darkdimius/status/1141785271958167553?s=21
I like Matz approach of a separate file much better.
I get the Java comparison, but Typescript? I don't have a problem with TS at all. Anyway, I like the idea of declaring param/return types where you can see them. Not to mention writing your code in one file, your tests in another, then your types in a third? It gets to be a bit much, I think.
You shouldn't really need types when using Ruby. OOP was born in Smalltalk in a dynamic world. Java is basically a simpler C with sprinkled OOP, kind of like Delphi is Pascal with classes. And it's sad that most people think of that when they think of OOP. C# is for obvious reasons very similar and continued to evolve in that direction, and now taking JavaScript with them (in TypeScript). Type systems are great, I don't dislike them, but in languages like OCaml or Elixir where they make sense.
For the record Elixir is dynamically-typed, but I generally agree with your post. Hence being in /r/ruby in the first place. That said, going back to your original post, if we're going to have types, I prefer the inline style over a separate file.
Is it something like this? https://sorbet.org/docs/rbi
I thoght Elixir was like OCaml where they force you to be typed but they can guess most of the time so you don't realize as much.
So your apps are not using Gemfiles and bundler at all?
No, it's more like Ruby actually. They do have type specs to annotate which is comparable to Sorbet.
It’s so much not ruby way. First of all in how it looks. But also in its purpose.
You can do the same thing in your Dockerfile and skip the external dependency: FROM ruby:2.6 RUN apt-get update &amp;&amp; apt-get install libjemalloc1 &amp;&amp; rm -rf /var/lib/apt/lists/* ENV LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so.1
Really? I very much appreciated how it was valid ruby syntax.
&gt; You shouldn't really need types when using Ruby. Could not agree more. This is the first thought that ran through my mind when I checked out the docs and examples. If you need type checking in ruby, then either your code is already a mess and should be refactored, or you’re stuck in thought patterns based in a perspective of a different language. If this library could actually speed up runtime, it would be a different story... but if anything, this will slow down execution and create bloat at the same time.
This.
&gt; You shouldn't really need types when using Ruby Obligatory "Ruby has always had types, but with a dynamic typing system".
I used to use [Contracts](https://github.com/egonSchiele/contracts.ruby) a lot, and this looks fairly similar
&gt; If you need type checking in ruby, then either your code is already a mess and should be refactored, or you’re stuck in thought patterns based in a perspective of a different language. I really disagree with this idea that if you want type checking than your codebase must be a mess (beyond the fact that every codebase beyond a certain threshold of LOC and number of developers becomes a mess in one way or another). You can write shitty code with or without a type checker, and I don't think any of the proponents of type checking are saying that it's a replacement for good design patterns and proper refactoring. Whether or not my code is a mess has very little to do with the benefits I get from type checking.
Thanks for the tip!
My error here. I should have said, “You should t really need type*checking when using ruby.” And, I agree with you.
Are therefore real world examples/war stories where this helped speed up an existing codebase, with quantifiable results? Numbers would be the best pitch, don't they?
I'm also wondering about the performance.. As others said, I don't care about checking the types, of so I wouldn't have used Ruby in the first place.. But if "cheap" statically typing can significantly improve the runtime, why not?
Just to understand the underlying philosophy... Is the type checker here for "safety" purpose (I mean bug free) or is it for performance reason in order to increase the runtime speed? I mean what was the most important reason for this gem?
We’re using dry-struct and dry-types for creating entities in our new event sourcing patterns. Seems like the biggest difference would be the analysis Sorbet can do. And there’s no way to enforce dry-types in a low level way, like for method arguments. So while both deal with types, they are different beasts.
Sorbet enables static analysis: so you can type-check your program without having to wait for run-time validations. This, for me, is the biggest advantage as you can get a lot of the benefits of a type system without incurring any run-time cost.
What feature of Elixir or OCaml makes static typing suitable for them but not for Ruby in your mind?
Negative.
Not a feature in particular but the fact that they are functional, and because functional programming comes from math, and in math everything has an explicit domain, it makes sense to do it in the program too. You get mathematical goodies that way. But OOP was not from an academic background, is about sending messages.
`sudo gem install capistrano -v=3.6`
That is a foundational fix that you should do first. It will make everything else eqsier
Elixir is dynamically typed.
This looks fucking gross
It is not entirely the same thing. For one, only jemalloc 3 yields reduced memory usage. Jemalloc 5 does not. If you apt get install jemalloc then you can only hope your distro doesn't distribute a too new jemalloc. You can install jemalloc from source, but then you need to compile (which sucks) and you are responsible for security updates. Fullstaq ruby guarantees that the right version of jemalloc is being used, for all supported distros. We are responsible for jemalloc security updates.
I feel like if your codebase is so large to necessitate building a type system for ruby you should have just moved to a different language that had types backed in. This just seems brutally inelegant. And coupled with it doesn’t work with any tooling means you have the worst of all worlds
It's mostly created for safety check of your code, it has special static analyzing command line utility to check your code for possible errors due to the type check, and also your code bacames much stable when you know what params you are using.
I didn't say it was. I was asking for clarification on the comment.
Give me a bit to play with a few more things and I'll have some more articles yet. This in-particular should be interesting: [https://github.com/sorbet/sorbet/issues/968](https://github.com/sorbet/sorbet/issues/968)
Watching obvious serious decline in core development in last two or three years, at least. Issues mentioned in the article are just tips of an iceberg, there is a *heap* of other recent half-assed contributions included in the language, making it a big mess one won't touch it with a 10-feet pole. So sad when parents (looking at you, Matz) are killing their beautiful child …
Yeah, it may be those new inexperienced, short sighted, cool-aid drinking donkeys swarming ruby, who are doing the harm …
You can always encode OOP code in a functional language and vice versa (it’s mainly a matter of changes to the syntax and explicit self, explicit method dictionaries to simulate duck typing/interfaces). Therefore your argument doesn’t make much sense unfortunately. According to Wikipedia OOP originated from MIT. Your claim about Smalltalk being the first OOP language seems to be incorrect as well: Simula is about 10 years older.
&gt; Matz approach of a separate file Anyone has a link?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [Open-sourcing Sorbet: a fast, powerful type checker for Ruby · Sorbet](https://www.reddit.com/r/RubyLang/comments/c38006/opensourcing_sorbet_a_fast_powerful_type_checker/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
In case you need inspiration: I'd be interested in more advanced types, especially generics. The documentation only seems to scratch the surface on them (https://sorbet.org/docs/stdlib-generics). For example, I have no idea how to create a `min` function parameterised over a less-than function: `min :: (a -&gt; a -&gt; Bool) -&gt; (a, a) -&gt; a`
Or you know, you could use [Crystal](https://crystal-lang.org/) and be magnitudes faster, typesafe, and not suffer a frankenstein'd syntax.
and used by nobody. I love that from time to time crystal appear as performance and typesafe. Used by 100 users.
So what? If only 100 people use a hammer, would you use a screwdriver to put a nail in?
stripe build a tool for ruby, used by them and other people, and you just post use crystal, used by nobody. Your comment deliver zero value. if you like crystal very much, well done, I guess there is a reddit /r/crystal waiting for you.
Compared to ruby, not many people know of crystal, so pointing them to an alternative is something I would consider a nice thing to do. Giving people options is allways good, no? Then they can decide on their own if they like it or not.
I'm not saying that is bad or crystal is bad or giving options for people to use other stuff, but again, this is about stripe sorbet, and you just decide to tell us about a hobby programming language. How this help any professional developer to pick a non productive language, when the topis is sorbet? Is just toxic
I use Crystal in production in a comercial product. Calling Crystal a hobby language and non productive is toxic, no my mentioning it as a alternative. As a ruby-inspired strongly typed language, Crystal is very much relevant in the context of Sorbet which adds type checking to ruby.
if you are using crystal in production good for you. Please be free to make a thread and share your findings.
Ugh, a Java build system. &gt; startup --host_jvm_args=-Xmx3072m # we need at least 3G to reliably build Why.
There's a few resources out there on this, but [here's one](https://developer.squareup.com/blog/rubykaigi-and-the-path-to-ruby-3/).
To me, any type checking system in ruby that doesn't naturally support "duck typing" (accepts any object containing certain methods/method signatures) is very sad.
I completely agree with this. I think interfaces would work well in Ruby.
Performance did not change, you still use the old interpreter to run the scipt. Their tool just checks those scripts for errors. And can't really infer types, as I understand, you need to specify them.
Disclosure: I work at Stripe on the Sorbet team We have been working closely with Matz and other Ruby core contributors. It is our plan to support Ruby 3's types which, as you say, will be kept in external files. For more background on our collaboration with the Ruby core team see https://sorbet.org/blog/2019/05/16/state-of-sorbet-spring-2019 Sorbet already supports external type annotations. The original driver was to allow us to type the Ruby standard library, 3rd party gems, and dynamically meta-programmed code but the same system can be used to add type annotations to your own code. See https://sorbet.org/docs/rbi for more details.
Disclosure: I work at Stripe on the Sorbet team We have been working closely with Matz and other Ruby core contributors. It is our plan to support Ruby 3's types which, as you say, will be kept in external files. For more background on our collaboration with the Ruby core team see https://sorbet.org/blog/2019/05/16/state-of-sorbet-spring-2019 Sorbet already supports external type annotations. The original driver was to allow us to type the Ruby standard library, 3rd party gems, and dynamically meta-programmed code but the same system can be used to add type annotations to your own code. See https://sorbet.org/docs/rbi for more details.
Try https://crystal-lang.org/ then :D
Disclosure: I work at Stripe on the Sorbet team Sorbet is not designed to improve performance of your code. Sorbet is a type checker not a compiler, and the current Ruby VM doesn't have an awareness of static types.
Disclosure: I work at Stripe on the Sorbet team Sorbet is not designed to improve performance of your code. Sorbet is a type checker not a compiler, and the current Ruby VM doesn't have an awareness of static types. Our motivation for building Sorbet is captured in https://sorbet.org/blog/2019/05/16/state-of-sorbet-spring-2019
Thanks..
Disclosure: I work at Stripe on the Sorbet team I know you know this, but to clarify for other readers most users of Sorbet will just put Sorbet gems into Gemfiles and go. The command line you list above are only for those who want to contribute to Sorbet. The reason for Java is that Bazel, the build tool we're using for Sorbet, depends on it. We chose Bazel because it has a sophisticated way to create something like incremental builds across multiple languages and tool chains by caching intermediate artifacts. We've found that once we got Bazel set up properly it's made a very positive improvement in our development experience. See https://bazel.build/ for more information.
Disclosure: I work at Stripe on the Sorbet team Our motivation for Sorbet is captured in https://sorbet.org/blog/2019/05/16/state-of-sorbet-spring-2019. Crystal and other languages are quite appealing in many ways, but don't necessarily help with a large existing code base.
Good to know. Whether I like it or not, every work on Ruby is welcome and deserves my thanks, as I love Ruby :) Thank you guys for your hard work!
I haven't done more than some of the example demos on their try it page, but do you not get the impression that you'd be able to do interface style type annotations after a little more development on the project? The demo made it seem extremely powerful, so I would feel a bit surprised to learn that a) that's not already a thing, or b) it's not likely to be a thing. Maybe it doesn't work out as well because of the static analysis vs runtime? Speaking a but out of my league here...
&gt; You can always encode OOP code in a functional language and vice versa Yeah and you can write every turing machine with lambda calculus too, that doesn't mean you should always use lambda calculus. As for Smalltalk, yeah it was not the first OOP language, but it was the first pure OOP language. Its a pity OOP nowadays is just "structured-programming with classes". You can do proper OOP in, say, Java, of course, but things like type annotations are just too much clutter.
Sorbet supports interfaces: https://sorbet.org/docs/abstract#interfaces-and-the-included-hook
If you have a proper dynamically typed program, following Object Oriented Design, what you need to worry about are not types so much, but nil. Type Systems mitigate that somehow but it's an overkill. What if Ruby didn't have nil, and instead, had something like an `Optional` type? Of course that change can't be made without breaking everything, but dreaming is free :)
They use Ruby as if it was Java. Not good.
Does the VM support static types? Or is it external?
Does Crystal keep people on its payroll or something? Crystal != Ruby. It's so obnoxious that this keeps coming up. Come back when it'll use my existing Gemfile.
Why not configure your SMTP server to forward emails to Kafka? Then your code has no awareness of how emails are getting delivered. SMTP is a versatile protocol.
&gt; I know you know this, but to clarify for other readers most users of Sorbet will just put Sorbet gems into Gemfiles and go. The command line you list above are only for those who want to contribute to Sorbet. Oh, I see, you're providing binaries, so you're less bothered by a bulky build system. Unfortunately that still leaves everyone using platforms you're not directly supporting needing a Java and bazel install to develop with it. Or at least they will if you ever get around to supporting such use. Is that planned? Right now trying to install the gem on FreeBSD unsuccessfully tries to install the Darwin sorbet-static. &gt; We chose Bazel because it has a sophisticated way to create something like incremental builds across multiple languages and tool chains by caching intermediate artifacts. Isn't the binary all C++? Or do you mean it helps in the larger context of development at Stripe?
Ahah I know right^^ That's true, as ruby compatibility is not a goal, it's like a whole new language. So gemfile will never work.. Sadly.. Did you try it though?
Why?
One thing I just realised while reviewing the public interfaces project: this is an awesome opportunity for lots of people to get some open source commits in. When I looked yesterday, there were only two classes from standard library that had .rbi files. https://github.com/sorbet/sorbet-typed/tree/master/lib/ruby/all Seems like there's a lot of opportunity for folks to fiddle their favorite tools in the stdlib and get some open source karma.
Nah, it’s off topic. Otherwise, it would be expected for people to post an equivalent comment for every single typed language.
If the thing that implements the interface needs to formally declare that it implemenets the interface, that's not duck typing. I can't totally tell for sure if they do or not from the docs, which I find a bit confusing (may have to spend more time with it), but it looks like maybe it is not "duck typing", but things implementing the interface need to formally declare that they implement the interface. Which is not what we call "duck typing".
I've poked around with it but I can't use it professionally until I'm confident it won't let me down. Looks very promising.
About about shoes looks abandoned? Sometimes things are stable and feature-complete. There's also https://github.com/ryanmelt/qtbindings
Very cool. Hope you don't mind a small critique: This method, def logger @settings[:logger] || Logger.new(STDOUT) end will inintialize a new `Logger` object every time `logger` is called (when `@settings[:logger]` is nil). Consider memoizing: def logger @logger ||= @settings[:logger] || Logger.new(STDOUT) end or simply adding @logger = @settings[:logger] || Logger.new(STDOUT) to your `#initialize` (and `attr_reader :logger`). https://github.com/luong-komorebi/action-mailer-kafka/blob/master/lib/action_mailer_kafka/delivery_method.rb#L64
Ruby people never seemed to care about the gui hence i don't believe any ruby-only gui framework is feature-complete. I might be dead wrong though. Qt seems interesting.
Ah. I misread. No, Sorbet does not support duck typing. Why not be explicit about implementing the interface? Duck typing seems error-prone.
At least for right now we don't plan to directly support a FreeBSD automated CI build but if somebody from the community wanted to put one together and maintain it we'd be happy to integrate via a webhook. The core binary is indeed C++, but the overall deliverable gems and tests include C++, Ruby, and bash. Even within C++, though, Bazel lets us cache pre-linker object files across CI builds even when they are run on different machines.
To be specific, the writing of the implementation and the writing of the consumer need to be coordinated. But maybe the thing is coming from a third-party gem. But I still want to write a a consumer, with typing, that I know can take that class from a third-party gem. Or other things that share the same "type" -- the same methods with the same semantics, which is the essence of what an OO "type" *is*. It's true that this kind of typing can only check methods/method-signatures, not semantics, but that's true of actual declared-at-implementation "Interface" typing too (including in Java). The difference between not-declared-at-implementation ("duck typing"), is that the (possibly multiple) third-party gem(s) providing the (possibly multiple) implementation(s) doesn't need to know what type I wanted to define, it may have been written earlier -- but I can still declare, with typing, in a way that will be type-checked (whether statically or at runtime; some of sorbet types already can not be checked statically) -- I can accept any object conforming to this type, even if the person who wrote the object didn't know that I was going to name that 'type' or what I would call it. That's what "duck typing" is. What seems to you more error-prone about duck-typing than declared-by-implementing-class interfaces?
Disclosure: I work at Stripe on the Sorbet team Sorbet does track the Nil-ability of types. T.nilable(Foo) is a Foo that might be Nil. Otherwise a Foo cannot be nil. For more https://sorbet.org/docs/nilable-types
Have a look at jrubyfx
The name of your package means "maternal grandmother" in Danish, Swedish, and Norwegian.
Ruby GTK3 is still maintained.
ruby bolsters an impressively easy way to create web guis which enables people outside of programming to participate in the design which is cheaper and easier. nothing against a stable gui application but if you plan to do that ruby is not the best choice.
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
I think wxwidgets is the current "closest to native" choice, and it has a bit of history. Not as much as QT or GTK, but totally good. Here's [a list of options.](https://wiki.wxwidgets.org/WxWidgets_Compared_To_Other_Toolkits)
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
I can't speak for GUIs much, but tkinter will suck for what you want to do with it. Maybe look at Qt? L And jruby is great. Compile time is short and it really improves Ruby's speed. Plus you aren't limited to the GIL ruby imposes over you and allows you to run POSIX-style (real) threads. I'm not sure about limitations of jruby though. I think I remember reading all pure ruby and c libraries will work correctly with it(?)
I mean, in the sense that it's basically *not possible* not to have types, there's not really any language that doesn't.
I don't see how separate file is workable without "IDE" support. I need to know the types when looking at at the method code (and it's comments formatted for autodoc above it). I've always appreciated that it is perfectly convenient to write ruby without special IDE support, with any old text editor. (Although syntax highlighting is sure nice).
Are you looking at the right version of shoes? Shoes v4 was last touched 2 months ago (albeit an edit to the README): https://github.com/shoes/shoes4
Ruby/Tk for Windows, Ruby/Gtk for others.
[github.com/lemonandroid/mittsu](https://github.com/lemonandroid/mittsu) &amp;#x200B; github.com/lemonandroid/gam
&gt;github.com/lemonandroid/gam [https://github.com/LemonAndroid/gam/tree/master/ruby](https://github.com/LemonAndroid/gam/tree/master/ruby)
it's also feature complete so you do have access to all GTK functionality.
I'm confused, why do you want action mailer to send emails to a kafka topic? What use is that?
I'm a big fan of the tools they provide having given it a brief look myself, like go to definition in vs code, being able to tell me how many params a method has while typing it out, or simple autocomplete. I'm tempted to use this with the typed disabled for that alone.
HTML/CSS
Thank you for this feedback. I posted this here to welcome feedbacks/reviews like this. I will try to have that fixed in the next release ;)
A lot of you here share the same questions : why is this even a thing. Well, please allow me to share with you some context. In my organisation, we built a microservice architecture around a main application running on Rails. This application receives and serves a bunch of requests per day, part of which generates notifications to send to customers. Emails are one of many ways to deliver notifications. It may be a user just signed up and we send him an email, or he has a bank notice and we sent him a document via emails. Initially, we do them all within Rails. We used services like Postageapp or Sendgrid to send our emails to our customers (we dont own an SMTP server ourselves). These services also have some nice functionalities like marketing campaigns and statistics. However, we face a problem when sometimes, customers doesnt receive the emails or we want to do more with our emails such as pipelining all outgoing emails into a data analysis system or to audit emails sent to customers (we are B2B so sometimes customers is strict and want to see what kind of emails their employee receives from our app). On the other hands, emails are just one of many ways for us to deliver our notifications and all the notification have been going into Kafka, so we thought we could put emails to Kafka and process likewise. The result is this gem + some internal microservices. I thought I would share this to the world so that if anyone is in need, they can reuse our gem. Someone mentioned configure our SMTP server to forward emails to Kafka. That was not really an option for us since we dont own an SMTP server. And yes we did try the following: set up a custom action in our inbox, every emails send to our customers get cc to that address, then this custom action will send it into our services for later processing. But it doesnt really scale well and the flexibility is not that great.
May I ask how the emails actually get sent? Kafka doesn't have the ability send emails or any other notifications so there must be another process listening for the messages and sending them.
Yes we have an internal microservice to deliver the emails. Currently that service supports sending through Sendgrid API, listen to their webhook and store all events (like customer opening emails, deleting emails, unsubscribe to mailing list ...), and a bunch of other things. Kafka is just a message queue. It's a mean to communicate between services, it doesnt send emails within itself. We also have another microservices to publish notification (for example, mobile app notification via Pusher or Firebase).
"rumor" (RUby MORfology) was taken ¯\\\_(ツ)_/¯
Why would tK suck but QT would not? I thought TK covers my needs so if you could explain i would appreciate that. regarding shoes... how does integrating existing code works with it? Do I just use my ruby code inside shoes app?
This looks interesting, how are you obtaining new results to update the db? Do you have a couple of scrapers or something like that? Thx
Sorry for late reply. &gt; not sure if it comes from yard or rdoc, but the one you see all over, right? I think it's coming from YARD. &gt; You've seen this before, no? Yeah. &gt; I'm not sure if yours is YARD-based and has all YARD features? No, this project is not YARD-based.
**Side question: does anybody know if Ruby GTK3 comes with the notion of, and implements a GUI** ***update thread?*** For those who don't know, in non trivial GUI frameworks there's this thread which is where all changes (read and writes) to the GUI have to happen in order to prevent GUI locks and other problems. I never got to understand if this is a thing in Ruby GTK3 (or GTK3 alone). Does anybody know? Thanks!!!
*libui - Simple and portable (but not inflexible) GUI library in C that uses the native GUI technologies of each platform it supports.* [https://github.com/andlabs/libui](https://github.com/andlabs/libui)
Web UIs are nice
GTK3? Gosu? green-shoes?
What even is it? There's no description.
How does one use this with Ruby?
In the readme of the root folder there is one
The football.csv datasets for now get the results from the footballdata.uk.co csv datasets, see &lt;https://www.football-data.co.uk/data.php&gt;
They are part of the core language, e.g. it's NOT external library. But at the same time they are not used by the VM to optimize the code. They are used by ExDoc to show types in the documentation and by Dializer to find type inconsistencies and possible bugs.
Oh I see. Thats cool. I wish you good luck.
Just look into rack. Rails works on top of it and you can just run your own non rails app with it. https://github.com/rack/rack
I would go for sinatra. Very minimalistic dsl that abstracts away the request and parameter stuff, but not much else. http://sinatrarb.com/ The example on their webpage exemplifies it well: require 'sinatra' get '/frank-says' do 'Put this in your pipe &amp; smoke it!' end
I've been messing with Roda lately and I would recommend. https://roda.jeremyevans.net/
Tk lacks a lot of the finer controls I would expect to find in a GUI library, at least with the hooks present on python I haven't used it in ruby much but can't imagine support is much better. That's why I'm steering you away from it. My suggestion is to take a look at many libraries, even those for other languages, and see if anything has the extensibility that you would want - specifically for dragging and dropping. If you're ok with getting dragged into OpenL ruby has a two year old library for it.
I haven't tried it, but it looks like someone made ruby bindings for it: https://github.com/jamescook/libui-ruby
Yep, Sinatra it's definitely the way to go.
I would go for grape https://github.com/ruby-grape/grape
[https://github.com/patriciomacadden/hobbit](https://github.com/patriciomacadden/hobbit) is my favorite thing right now and [https://github.com/patriciomacadden/hat/](https://github.com/patriciomacadden/hat/) makes it easy to hit the ground running.
Grape doesn't provide a server though right?
You can mount it with rack https://github.com/ruby-grape/grape/blob/master/README.md#rack And I would also recommend that you add puma to your Gemfile
Every non-rails project eventually turns into a rails-like project, but worse.
It’s not an alternative to Ruby. No more than Go or Python or whatever. Somewhat similar syntax can be an argument for someone with no experience. Everyone else can learn any language syntax over weekend. It’s the tooling, libraries, adoption, resources, etc - that’s what matters.
[But \*my\* version will be better](https://en.wikipedia.org/wiki/Second-system_effect). :P
**Second-system effect** The second-system effect (also known as second-system syndrome) is the tendency of small, elegant, and successful systems, to be succeeded by over-engineered, bloated systems, due to inflated expectations and overconfidence.The phrase was first used by Fred Brooks in his book The Mythical Man-Month, first published in 1975. It described the jump from a set of simple operating systems on the IBM 700/7000 series to OS/360 on the 360 series, which happened in 1964. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Nice. Thank you.
Rack is great for a lightweight, direct, production-viable server. If you just want something for development or testing then WEBrick comes with your standard Ruby install and works well enough if you want to just avoid external dependencies
Err, no. Not really sure where you came up with this. Perhaps every non-rails project written by rails devs to solve rails problems? :)
Aparently there is a sort of "update thread": https://developer.gnome.org/gdk3/stable/gdk3-Threads.html &gt; GTK+, however, is not thread safe. &gt; You should only use GTK+ and GDK from the thread`gtk_init()` and `gtk_main()` were called on. &gt; This is usually referred to as the “main thread”.
&gt; (**maybe** the GIL could prevent some shortcomings but I don't think is any guarantee...) That's what I am saying. It's all uncertain! How can one use this in production if even basic concepts like this are still undefined?
My personal favorite micro framework is [Roda](https://roda.jeremyevans.net/) if you want to give it a try.
I think it would be very extremely unlikely that Ruby GTK+ would be thread safe but build atop of thread unsafe library. With that said, the [Ruby GTK+ docs](https://ruby-gnome2.osdn.jp/hiki.cgi?cmd=view&amp;p=tips_threads&amp;key=threads) says: \&gt; The warning is this: If you call Gtk methods from outside of Gtk's main thread, there is a chance that the Ruby interpreter (not merely your Ruby application!) will crash with a segmentation fault (seg fault) error, seemingly at random. This is not an exception you can catch. It is fatal and crippling, and very difficult to debug. &amp;#x200B; So I think that answers your questions, you need to use \`Gtk.idle\_add { ... }\` and \`Gtk.timeout\_add(interval){ ... }\`, like you would do on a C program.
a second vote for roda — used to use sinatra until o found how much dryer controller code becomes with roda.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rails] [Fullstaq Ruby - Ruby, optimized for production (faster, less memory, RPMs\/DEBs, Rbenv integration)](https://www.reddit.com/r/rails/comments/c402lb/fullstaq_ruby_ruby_optimized_for_production/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I hope this is relevant...I just figured out how to deploy a Ruby web app without running the dev server directly. You can use nginx and uWSGI to serve up a Rack application. This example shows you how to do it with Sinatra but will apply for others as well. If you are just getting started though you can do it even easier by just running a sinatra ruby script directly that will default to port 4567. &amp;#x200B; [https://www.devdungeon.com/content/deploy-ruby-web-apps-uwsgi-and-nginx](https://www.devdungeon.com/content/deploy-ruby-web-apps-uwsgi-and-nginx)
I can't vouch for this, but take a look here: https://github.com/pmq20/ruby-packer However, it looks like all the issues revolve around newer OSes not working properly. That said, if that doesn't work and you're trying to make some sort of script, is to do one of the three following options: 1. Write an install script. You'll have to craft your own that supports RVM, RBENV, homebrew, or no ruby version manager (and probably install one). In addition, you'd have to manage and test this in different environments, such as macOS, Linux (and different versions), Windows w/ subsystem, etc. All the things that you'd want to support. If you don't want to support Windows, then you don't need to write code that supports it. 2. Write your script or application in such a way that it works on different versions of Ruby. macOS has ruby pre-installed, but it is an older version. Linux, OTOH, may not, and Windows definitely doesn't. This would save you from having to worry about installing a specific version of Ruby , but you'd still have to worry about having *a* version of Ruby installed. 3. Work with a different language/platform, preferably one with support for compilation to multiple OSes. Ruby is a scripting language, not one that natively compiles, so distributed apps isn't really it's goal. That's why deploying an app (like a Rails app) to a server requires installing Ruby (and is compiled for the platform/OS it resides on), a ruby version manager, and all of its dependencies every time.
what was the drama from 4 years ago?
I think ruby core devs should make this under the ruby supported platform(kotlin style) ruby js ruby on jvm and ruby
ruby-packer (as already mentioned) is probably the best choice to try out first. I tried making executables for one of my gem here and it worked: [http://nts.strzibny.name/making-a-ruby-executable-with-ruby-packer/](http://nts.strzibny.name/making-a-ruby-executable-with-ruby-packer/) &amp;#x200B; My other tip would be to look into Vagrant distribution since they package Vagrant for all main platforms.
I second Roda. It's one of the lightest and fastest option. If you need an example of Roda "in the wild", here is how I used Roda to implement a small server variant of my library: [https://github.com/strzibny/invoice\_printer/blob/master/lib/invoice\_printer/server.rb](https://github.com/strzibny/invoice_printer/blob/master/lib/invoice_printer/server.rb)
What is your use case? Because generally speaking, there's probably a better way... As others have pointed out, `ruby-packer` is designed to "compile" a binary that is "runnable anywhere"... while I haven't used `ruby-packer` I have used [`PAR::Packer`](https://metacpan.org/pod/PAR::Packer) extensively, and can tell you with absolute certainty a few things: * statically compiled binaries are bloated bullshit * trying to compile the interpreter into a single executable file is wrought with heart burn * this is doubly true if you have bindings to system libs (C Extensions in Ruby are uncommon but exist) * There's probably a better way... So, talk about [snaps](https://snapcraft.io/, [flatpack](https://flatpak.org/), or my favorite [habitat](https://www.habitat.sh/), where we're bundling a minimal runtime that can be executed anywhere. Each of these include their own `glibc` for example. They'll also include their own Ruby. These are what I like to describe as "Containers without containers" solutions. I.e.: they have all the benefits (i.e.: "bundled dependencies", which no one will admit is the single driving factor behind Docker, if it's "process isolation" then the person selling you docker is a liar) without having to run containers. (although I'll admit I find [qubes](https://www.qubes-os.org/) intriguing). Anyway, this really sounds like an [XY Problem](http://xyproblem.info/) (and I really hope you take this commentary in the constructive vein it's meant... I've been told that linking the xyproblem website is condescending... and I _really_ hope you don't take it that way, I just really think it describes the problem... well... with your problem... lol really well.) I think my direct answer to your question is: don't! Ruby is not "portable" like C is. Meaning that, you _need_ a Ruby environment to run Ruby scripts. Chef is actually a really good example of what I'm talking about. _ANY_ configuration management tool needs a client on the receiving end to be able to interpret the "Code" and translate that to commands. _ANY_ CM tool. If you don't, you run into scaling problems like Puppet had in the beginning... Initially, you had to setup ruby and it was a PITA... so Chef (the company, because naming is hard apparently) figured out "hey if we just bundled our own ruby then it doesn't matter", so if you look in `/opt/chef` you will find that Chef installs its own Ruby, gems, et al. in its own isolated deployment. I am absolutely in no way employed by or paid by Chef. Though I think I should be, as much shilling for them as I do... lol. I just think they make a really good product.
what about using jruby with a portable JVM?
Don't use ruby..."deploying" it to endusers is a nightmare, esp if you want to obfuscate your code.
Roda
&gt; ANY configuration management tool needs a client on the receiving end to be able to interpret the "Code" and translate that to command Ansible seems to be doing fine without a client agent.
 Crystal might be worth taking a look at. Compiles with Ruby-like syntax
&gt;ANY configuration management tool needs a client on the receiving end to be able to interpret the "Code" and translate that to commands. ANY CM tool. Ansible is laughing at you right now.
IMHO This type of comment makes reddit amazing
You could use jruby and make an executable JAR. The warbler gem can help with making the JAR.
Do you know if it's possible to subscribe to a channel from an IBM Message Queue server? Btw, this series is really good, I mean it changes from really basic stuffs.
“We supplies binaries” think this should be “We supply binaries”?
This problem [is on rosettacode](https://rosettacode.org/wiki/Longest_common_prefix#Ruby) with a variety of different approaches you can try. [This one's](https://www.ruby-forum.com/t/determining-the-common-prefix-for-several-strings/111143/10) pretty nifty: head :001 &gt; %w[abcdef abcigw abcwer].join(?\n)[/\A(.*).*(\n\1.*)*\Z/, 1] =&gt; "abc" Just google `longest common prefix`for more.
[This horrible mess.](https://github.com/opal/opal/issues/941)
Crystal worked perfectly, was able to copy almost everything over, and just had to change a bit of the syntax and it works just as well. Thanks for the suggestion
thanks!
Start out with finding the longest common prefix between the first two strings. The longest prefix between all of them has to include the first two, so that's the longest it can be. Now check it against the third. Does it work, or does it have to be shorter? If shorter shorten it. Continue to end. Unless you wind up at the empty string (no common prefix), you're done.
I didn't dig into your versions specifically, but I can share something we observed over the past week. The latest version of chromedriver, is now the w3c standard supporting driver. And the chrome team has made it clear they will now only support that which is part of the standard. It hit us hard to lose access to the js logs. We used to use that to diagnose data connection issues, but it is no longer supported, as it is not part of the w3c standard. It may be that your missing disable infobars option is no longer supported as well, but I didn't see anything stating that directly.
Glad it worked out for you!
That's not nifty, it's incredibly expensive with catastrophic backtracking. I can think of a few O(log(n)) approaches that would be much cleaner. Use hashes and binary search instead.
Your algorithm looks OK, but not super efficient. We'll get to a faster way in a sec. Before that though, you can simplify some things: if size == arr.select {|word| arr.first[idx] == word[idx] }.size can be re-written to use Enumerable#count: if size == arr.count {|word| arr.first[idx] == word[idx] } but even better, you can use Enumerable#all? like so: if arr.all? {|word| arr.first[idx] == word[idx] } That's what you're really trying to say, after all - do all these items have a given char at a given position? Now, you can make things more efficient by realizing that once you've found a single non-match, you're done, so make that inner test: if arr.all? {|word| arr.first[idx] == word[idx] } prefix += arr.first[idx] else return prefix end That cleans things up a lot! You can improve it further by getting rid of all those arr.first[idx]'s and simply grab the test char at the start of your each loop. With that out of the way, this would be my take, after noodling on this for a bit and trying to get down to the most efficient &amp; clean algorithm I could come up with: def prefix(arr) # Init state to first item being the prefix (unless the array is empty!) prefix = arr.shift || '' match_count = prefix.length # Run the rest of the array items, if any arr.each do |str| # For each one, find the first place the string doesn't match the current prefix # and save that as our new match count, making sure to not exceed the existing # count or the length of the string we're testing [str.length, match_count].min.times do |i| (prefix[i] != str[i]) ? break : match_count = i + 1 end end # Once we finish all the items, what we're left with is the longest substring of our prefix prefix = prefix.slice(0, match_count) end
I’ve used [DocRaptor](https://docraptor.com) for XLSX with good results. Not sure if it has everything you want, but probably worth a look.
&gt; w3c standard I think this is the issue. If I add the argument :w3c =&gt; false the switch does work. However other things don't work (namely, downloads fail). I could live with the infobars being there, but the download folder not being accepted is not good. I wonder what the 'w3c' way of passing chrome options in is.
Thanks for this! Found the first part very enlightening
It's MIT license so I would say just do a fork of your own OR write an extension gem that will add the functionality you need. Maybe the maintainer would take a PR? It's happened before with cancan gem when Ryan Bates burned out and the public eventually carried on with cancancan. It happens but then this is the value of open source.
Using [rubyXL](https://github.com/weshatheleopard/rubyXL) for your purpose for a long time
The question arises because it's unprofessional to incorporate abandonware into a new project. I cannot commit this project to maintaining their own fork (the question would be moot if I could).
I use RubyXL, but I start with a template that’s formatted the way I like it (including any formulas already set). ``` template_path = File.expand_path("templates/messages.xlsx", __dir__) workbook = RubyXL::Parser.parse(template_path) workbook.calc_pr.full_calc_on_load = true sheet = workbook[0] sheet[4][4].change_contents("Hello world") sheet = workbook[1] data_row = 5 messages.each_with_index do |message, i| sheet.insert_cell(data_row + i, 1, message.body) end ``` etc. Works great and I’ve made the templates look pretty pro too.
Thanks for the suggestion. I'd skipped over rubyXL after reading its intended purpose ("making minor modifications") but if it works for wholesale file generation I'll give it a whirl as well.
I really like your `arr.all?` and don't understand why you didn't use it in your final solution.
Rename model to IssueKind.
You might: - Option 1: Change your table &amp; model name to something like IssueCategory and avoid using Type altogether in the future. - Option 2: Change your model name to IssueCategory &amp; explicitly set self.table_name = "issue_type" in the model declaration. - Option 3: Leave things as it's and avoid using the Type word in the future. I prefer this since IssueTypeType is just a minor issue &amp; I can ignore it.
SJW :) lovely
not very experienced with graphql either, but maybe try with an interface [https://graphql-ruby.org/type\_definitions/interfaces](https://graphql-ruby.org/type_definitions/interfaces)
Short version: def prefix(arr) arr.first.each_char.inject("") do |accum, n| accum &lt;&lt; n if arr.all? { |x| x.start_with?(accum + n) } accum end end Though in reality I'd probably do something like this because I think it reads better and the use of a class provides better encapsulation. Though both approaches are essentially the same. class CommonPrefixFinder attr_reader :strings def self.call(strings) new(strings).call end def initialize(strings) @strings = strings end def call chars.inject("") do |prefix, n| prefix &lt;&lt; n if all_have_prefix?(prefix + n) prefix end end def chars strings.first.each_char end def all_have_prefix?(prefix) strings.all? do |str| str.start_with?(prefix) end end end
The one from rosettacode is short and also pretty fast. &amp;#x200B; def lcp(*strs) return "" if strs.empty? min, max = strs.minmax idx = min.size.times{|i| break i if min[i] != max[i]} min[0...idx] end &amp;#x200B; If you think about it, the longest common prefix of a set of strings must be the same for the lexicographically minimal string and the lexicographically maximal string. To find the max and min of a set is linear and all the work is done inside the `minmax` call, which is probably implemented in c. &amp;#x200B; I've benchmarked it with the one from u/zaphnod, arrays of 1000 random words, called 1000 times &amp;#x200B; with no common prefix user system total real zaphnod 0.250446 0.000647 0.251093 ( 0.251885) rosetta 0.000321 0.000001 0.000322 ( 0.000324) with a common prefix user system total real zaphnod 0.498682 0.000547 0.499229 ( 0.500169) rosetta 0.000097 0.000001 0.000098 ( 0.000098)
Nice
&gt; I wonder what the 'w3c' way of passing chrome options in is. I think you are doing it the "w3c way" it's just that the w3c didn't specify, in my case, access to the js sandbox, and potentially in your case a way to disable infobars. So Chrome in w3c mode, will not do these things. I had forgotten that you could use the "legacy" mode, but as I understand that thats will go away. SO we aren't building anything that relies on the legacy functionality.
We use Apache poi for excel generation. You can give it a try. Add the jar files,install java &amp; rjb , import the required libraries,then start writing your XLS. I know it's not a neat solution,but it allows us to do a lot of things in xls.
It would be nice if there was a support for External Data thing... like adding ODBC data source, define query and update the sheet. Though the last one would need perhaps real Excel, but I'm fine with just setting things up...if there only was a way to do that.
Nice!
Option 1 is the only option which follows not only rails conventions, but general data modeling best practices as well. Guaranteed OP will consistently face issues using “Type” going forward (unless properly used in a polymorphic association).
Watir's options structure / handling is weird so I usually pass it a `Selenium::WebDriver::Chrome::Options` instead of trying to figure it out. Something like this should work: options = Selenium::WebDriver::Chrome::Options.new.tap do |o| o.add_argument('--disable-infobars') o.add_argument('--disable-popup-blocking') # if desired o.add_argument('--window-size=1366,768') # if desired o.add_argument('--disable-dev-shm-usage') # if in container o.add_preference(:download, directory_upgrade: true, prompt_for_download: false, default_directory: 'C:/DownloadFolder/') o.add_option(:detach, true) end browser = Watir::Browser.new :chrome, options: options
I've grown to like [Rack App](http://www.rack-app.com/)
weird my colleague showed it to me in the IDE and had the vs code extension running...
Yeah you can get it from the sorbet slack but it’s not really ready for prime time, I couldn’t figure out how to set it up.
We had to go with DeliveryTypeType, not to be confused with DeliveryType 😕
Ah cool, thanks
Not sure if it meets all your needs, but I found \`write\_xlsx\` easy to work with. I used it to set formats/styles and generate charts and it just worked. I didn't try to do any page setup though. I'd give it a shot.
Nice. I don't really mind writing `enum contact_method: { Email: "Email", SMS: "SMS", Phone: "Phone" }`. And don't need an additional dependency with somewhat forwards-compat risky monkey-patching needs, just to avoid that. But I do want real pg enums. Does this gem have something to offer other than the shortcut for `enum contact_method: {...`? I guess the migrations that give you enums? And don't require you to switch from schema.rb to structure.sql? I'd guess that was actually the hard part, especially for every Rails version? If I understand it right, I'm down with using it for that!
This pretty much sums up why I have no interest in Sorbet: The code was made worse to make a tool happy. I'll reconsider if they ever add structural typing, but I feel this will be too late, a lot of bad code will be written to appease a nominative type system and the 'style' will become engrained in the community.
And we're writing JavaScript now. using(Module.new do refine NilClass do def empty? true end end refine Object do def empty? false end end end)
Screwing with binding.pry is the only thing I need to hear to not like this. Will give it a try but that's not good.
Other thing I would like to mention is that when I added this to my gem yesterday it set the typed comment at the top to true or strong. When I ran tc it came back with no errors. Not sure why it defaulted to true but everything was on from the start.
This is a great writeup. Very clear about the issues, the errors, the troubleshooting process. Stuff like this is important for technology to improve. I'm sure the Sorbet folks will use it as feedback to improve the product. Considering it's only been open sourced for a few days, most of it's not at all surprising but the `binding.pry` stuff is disappointing. That's a pretty serious hit to workflow that will need to be addressed.
That does work in terms of applying the --disable-infobars etc but downloading files fail with it applied. Weird.
Make sure `C:/DownloadFolder/` exists before you launch the browser. Also, depending on the permissions, Windows may not allow Ruby to create a file or folder in `C:\`. Try setting the path relative to your project and use the correct slashes: download_dir = "#{Dir.pwd}/downloads".tr('/', '\\') Dir.mkdir download_dir unless Dir.exist? download_dir args = %w(--disable-infobars) prefs = { download: { prompt_for_download: false, download_directory: download_dir } @browser = Watir::Browser.new(:chrome, options: { args: args }, prefs: prefs) I tested this in Chrome v75 on Windows 10.
Aha, "structural typing"... looking it up... is basically what you call static 'duck typing' style. OK, now I know what to complain about being missing. Ruby-ish static typing has got to do structural typing, I agree, it's the obvious thing for the nature of ruby.
&gt; Aha, "structural typing"... looking it up... is basically what you call static 'duck typing' style. Yep, Go for example is structurally typed which is why you don't have to explicitly implement interfaces all over the place.
The next level is using the Attributes API to marshal them to/from objects rather than strings.
feels like even we have to go with the same kind of solution
yeah right, it makes sense
thanks for this
I've never really seen anything like this, not even in the docs, but if the protocols are the same, maybe there is some chance for interoperability. If that's possible, that would definitely be a great blog post material ;)
I know that Rabbit should be using the AMQP protocol if I'm not mistaken.. I bet that the IBM one should also be compliant but I don't know much and I'm not sure at all.. I asked because I will have such a use case soon..
Yeah, AMQP is the most widely used protocol in RabbitMQ. If there is no chance to make it work though, you could try setting up a middleman app that will consume a message from RabbitMQ or IBM Message Queue and push it to the other queue
This one can be a good solution indeed..
https://exercism.io Hello, it appears you tried to put a link in a title, since most users cant click these I have placed it here for you ^I ^am ^a ^bot ^if ^you ^have ^any ^suggestions ^dm ^me
 &gt;This pretty much sums up why I have no interest in Sorbet: The code was made worse to make a tool happy. _cries in Rubocop_
There's a lot of gems out there, take one that's maintained and popular. If you are using bundler with your project, don't hesitate to use bundle open &lt;gem&gt; This will open the source code of the gem for easy browsing and even editing.
Cool... Just subscribed to your podcast, looking forward to checking it out
In case anyone's missing context, he's not doing that to satisfy Sorbet, he's doing that to shave two lines off his `empty?` method. What would have been something like: return false if val.nil? return val.empty? if val.respond_to?(:empty?) false Becomes: val.empty?
Thank you!
I need a good supply of valium to maintain large rails apps. Especially when hired on as a contractor to help a small company with theirs. Good luck understanding how it works or finding where things are.
So, Rails then? :)
Yeah, I've been there before with my company. That's why we now screen the projects we take on. We don't take on projects that have 0% test coverage. Even with test coverage it is very hard to understand where things are. In my experience, an app without tests it turns into a nightmare pretty quickly.
Excellent policy. And yep — I've begun doing the same. I've also stopped working for shops like [toptal.com](https://toptal.com), where I don't have the option to decline a job or cancel after a week.
I might keep exploring some of the other options here, but I wanted to chime in with a small observation. I recently set up an ETL project that generates a few hundred XLSX files for a client. (Generally speaking: one folder per price region, one file per product brand). I was using `axlsx`, slightly begrudgingly because of OP's comments. I took the top suggestion here, RubyXL, and gave it a spin. I found that the generation of my files took more than twice as long. The reports were each generated with the following code: Axlsx::Package.new do |xlsx| xlsx.workbook do |wb| wb.add_worksheet(name: 'Sheet1') do |sheet| sheet.add_row(report_headers) records.map{|r| report_values(r)}.each do |row| sheet.add_row(row, types: CELL_TYPES) end end end xlsx.serialize(filename) end # vs book = RubyXL::Workbook.new sheet = book.worksheets.first report_headers.each_with_index {|header, i| sheet.add_cell(0, i, header)} records.map{|r| report_values(r)}.each.with_index(1) do |row, y| row.each_with_index do |val, x| sheet.add_cell(y, x, val) end end book.write(filename) It didn't look like RubyXL had the same style of API that axlsx had (similar to the CSV library), which is why I'm using the indexing moves. My ETL chain takes ~20 seconds with `axlsx` and ~ 50 seconds with `rubyXL`. About 12 seconds of which is getting data from a DB. If someone has a more idiomatic or performant-but-reasonable way to write the above in RubyXL, I'd love to see it and try it out. The one thing I noticed is that the types are inferred from the ruby data type in `rubyXL` (which I very much appreciate: If I send it a String, it's written as a fricken string), but explicitly specified in `axlsx`. I'm not sure if this is one of the main hits to performance. Anyway, I just wanted to mention this, as I found it to be a bit of a bummer. I am generating hundreds of files, and the performance penalty has me wanting to stick with axlsx, even if it felt janky to set up in the first place (pinning to specific github ref, adding dependencies that weren't in gemspec (zip)). I'd love to drop this dependency, but right now it's not reasonable.
If it helps, here are some of my current ideas: &amp;#x200B; * ActiveRecord basics, ActiveRecord deep dive * Databases/SQL * PostgreSQL/MySQL deep dive * Rails + JavaScript * Rails + React/Angular/Vue/Ember/other * Refactoring * OOP * Rails forms * AWS/Heroku
The biggest behind the scenes change is a total re-write of the reactor to use nio4r instead of IO.select. Heroku customers should see fewer (or no) H13 errors on dyno restart now. Lots of good stuff, look at the release notes or attached PRs for more info. 🏎🏎🏎🏎
Added it to one one the current projects.... Cool!!
I'd say start out with [POODR](https://www.poodr.com/) and [Sandi Metz Rules For Developers](https://thoughtbot.com/blog/sandi-metz-rules-for-developers). If you can follow that and refactor often, you'll always get to good code.
❤️
I wouldn't give Rails as an example to learn for people who just started learning Ruby. It's full of meta "magic", indirection and complexity that just isn't explained.
Thank you!
I feel like it's a little buried under the fold in those release notes, but that's such a big undertaking.
Awesome, thank you! I'm live in production with it.
Rails 5.2.3 wants `~&gt; 3.11`. Any issues with upgrading to 4?
There's no known breaking changes, but the reactor change was large so we wanted to be safe. Should be fine, try it out locally and if it's fine go ahead and deploy. There might be bugs (as with any release) so you could wait for a 4.0.1 release if you wanted to be extra cautious, but I don't think you need to.
❤️❤️❤️
Agreed, but it is maintained and popular. I'm not sure the best way to find something that's a good example, honestly.
I’ve started POODR several times. Maybe this time l finish! Still, it would be good to have several examples of awesome Ruby/Rails FOSS projects to consult.
How about five examples of gems with great code to explore?
I like roda and sequel gem :)
Not 5, but some gems I personally inspected and learned from: &amp;#x200B; \- [https://github.com/shrinerb/shrine](https://github.com/shrinerb/shrine/blob/master/lib/shrine/uploaded_file.rb) well documented and straightforward. \- [https://github.com/mperham/connection\_pool](https://github.com/mperham/connection_pool) very simple but shows a practical use for blocks and thread safety \- [https://github.com/alexreisner/geocoder](https://github.com/alexreisner/geocoder) personally inspected it when I was developing my gem and wanted to see the good way of hooking into Rails and ActiveRecord \- [https://github.com/chaps-io/access-granted](https://github.com/chaps-io/access-granted) this is my own gem so it's a bit of plug, but I'm really proud of how simple and clean it is :D \- [https://github.com/ruby-grape/grape](https://github.com/ruby-grape/grape) the most complex of the bunch but still miles ahead in terms of simplicity compared to Rails
The primary purpose is to support `schema.rb`. The helper stuff is a very minor convenience. If Rails core ever decides to break compatibility with string enums, it would be trivial to extend the module builder to do its own metaprogramming instead of using `enum`.
🤔 That's an interesting thought. Any object that conformed to the usual marshal API would probably be sufficient.
Difference is you can (and should) change the Rubocop defaults. Bit harder to just 'change' a type system's 'settings'.
https://github.com/sshaw?tab=repositories&amp;q=&amp;type=source&amp;language=ruby
Managing complexity as your application grows. Rails has a bit of a reputation for messy codebases, but all the cases I've seen it's been a lack of discipline in the development teams and not an issue with Rails or Ruby.
Thanks!
thank you! The README could be more explicit about the schema.rb support, for those experienced devs who realize the value there.
Anything specific? There's a lot that could be covered there.
Yeah, it's a big topic mostly because it can be talked about as a factor of any other topic. Things that work great in a small codebase and are the pragmatic correct choice for that project just won't work with a big project. Here are some ideas based off of things I've done at past jobs -- I - Service Objects to encapsulate business logic, mitigates differing logic between app requests, api requests, and background jobs. I use the rule of using a Service Object as soon as logic is needed twice. I tend to have a mix of fat controllers for unique tasks and slim controllers + service objects. - Following through on refactoring, or changing of patterns. In large codebases consistency is key, if a team decides on a different "way" of doing something, they should propagate that change through the whole codebase. If you don't stay consistent you'll end up with a codebase you hate working on because you can't intuitively guess how things work. - Automated linting &amp; style enforcement with Rubocop, enforced in CI. This can really mitigate style differences between teams as well as squash useless comments in PR review. - Managing memory bloat. Regular gem audits. Regular refactoring, removing dependencies and bringing that code in-house wherever the dependency is trivial. Avoiding massive ActiveRecord query sets. Most memory bloat I've seen is just too many damn objects being created. Ruby's default memory allocation strategy is pretty greedy, sometimes customizing that is justified too. - Managing a healthy up-to-date Rails environment with regular updates. I'd consider this part of a healthy continuous refactoring/improvement cycle. Someone should always tasked with bumping gems as updates come in and there are no conflicts or bugs. Avoiding this task will lead to an eventual painful forced update when a CVE-mandated update results in gem dependency deadlocks &amp; incompatible versions. Sidestep the issue by staying up to date.
https://docs.rubocop.org/en/stable/
Is there any performance improvement (or does the name actually doesn't matter)?
The talk that I mentioned in this episode: https://www.youtube.com/watch?v=V4fnzHxHXMI I highly recommend it! :)
The core team have long been wishy-washy on the topic of enums. And notwithstanding that I disagree 100% with the rejection of your PR, they're all the more rudderless in the ORM department since Sean Griffin departed.
True but I tend to use a Whole Value factory instead, which gives a uniform abstraction level for value objects, null objects, exceptional values and allows singleton/flyweight patterns for memory efficiency. c.f. https://www.rubytapas.com/tag/whole-value/ (if you have a RubyTapas subscription)
Thanks for making the free tool open to public. Is it open sourced yet?
I don't think that's a good idea. rubocop et al. will have a hard time detecting it, when it's not immediately obvious, for example: hash[['member'].map(&amp;:to_sym)[0]] My recommendation: Either others have to check which type of key is expected, and they'll figure it out soon enough, if their code isn't working. Or you accept both as a convenience and stringify symbols before passing them along. &amp;#x200B; How is Amazon Lex?
Not yet but will be in the upcoming week or two. I'm done polishing it. Sorry for the delay...
I've been there before. It can definitely feel intimidating; or even imposter syndrome can kick in. Just have to remind myself to approach it one line of code at a time, get feedback from season developers on that project, ask questions, and look through whatever documentation, charts, diagrams, or resources available.
* mruby * usage of ruby/mruby in japan/asia in general * augmenting ruby with things like rubex/helix * rubymotion cc /u/amirrajan * usage of truffleruby * frontend on rails/sinatra/hanami
Although let us note it was actually Sean Griffin who rejected it. :|
Yes. Notwithstanding. Had he continued his work, it might have led somewhere where enums weren’t a second-class citizen.
Nate, I love the intention of the article though it comes out more like a combination guilt trip and sales pitch. But it worked on me, I'll grant you that. I'm tired of not knowing enough about performance and going about it ad hoc every time, so I'm considering buying your book. Is it very Rails specific (as the name implies) or will most of it apply to any Rack based web app? I'm fairly sure I can wrangle anything into my tools of choice (mainly Roda these days), but I'm looking for a bit of reassurance on that.
Hopefully by the end of next month I’ll have some cool things to share. Keep an eye on DragonRuby.org
&gt; On the most popular Brazilian Facebook group for Ruby on Rails, someone posted a job posting where NOT having a degree in the field was a PLUS... Some Ruby shops want CS degrees, some don't want CS degrees, but most don't care either way. I wouldn't worry about this. &gt; Ruby doesn't currently have an integrated type checking system... Ruby 3 will have a standard .rbi signature annotation to support tools like Steep, Sorbet, etc. &gt; GIL. The GIL is an implementation detail in CRuby. JRuby and TruffleRuby do not have a GIL. The plan is for Ruby 3 to introduce "Guilds," which will allow groups of threads to compute in parallel on different cores - even in CRuby. [This article](https://developer.squareup.com/blog/rubykaigi-and-the-path-to-ruby-3/) I wrote covers a little bit about static type analysis and guilds in Ruby 3.
&gt;performance WAS/IS important in every single application I've built professionally Your post sounds quite angry. Maybe with a few more years of learning you'll come to appreciate that different styles of programming, different languages and different frameworks all have their own applications and use cases and Ruby wasn't the one for you. Lots of apps are still mostly authentication/authorisation/CRUD used by a relatively small number of users and Ruby and Rails suits that kind of application well.
&gt; Your post sounds quite angry. Not my intention, like I said on my disclaimer. &gt; Lots of apps are still mostly authentication/authorisation/CRUD used by a relatively small number of users and Ruby and Rails suits that kind of application well. I absolutely agree with that, but then we are talking small work for small companies; What about systems larger than that? If GitHub wasn't created and it was on your lap to decide the underlying architecture, how would you justify the usage of Ruby like they did? Also, in a large company, if you were to do something small, how would you justify introducing another tech stack in case Ruby wasn't used before? You shouldn't build something only you'll be able to maintain.
You should go try out Node for awhile and report back! :)
No good reason, really.
I thank you for your article, but it seems you didn't read the entire post, where I specifically wrote about Ruby 3; And as I said on the title, I did mean the "today" bit.
We have millions of lines of Ruby microservices in production today and are very happy with the testing, monitoring, performance, etc. I mention Ruby 3 features because they seem to fill in the only gaps you mention and they're due to land in 2020. When choosing a language in today, I'd look at features coming next year.
&gt; We have millions of lines of Ruby microservices in production today and are very happy with the testing, monitoring, performance, etc. So you are the kind of person I'm looking forward to get good answers from :) Why did you people choose Ruby to begin with? What were the architecturally relevant use cases that lead you to choose Ruby over the other options? How did you justify the extra resource cost? Which implementation of Ruby are you using, and why? Now that your code-base grew, what are some successes and failures you've been through, due to the usage of Ruby? Would you have used Ruby again if you were to start over? Why should someone use Ruby to start a project today? &amp;#x200B; Thanks
Frivolous dependencies apply to any language and framework though, not Ruby/Rails alone. And you should be writing tests regardless of the language.
Additionally, most people aren't going to give a fuck about your disclaimer when you call them a bunch of amateurs with no real world experience. Saying "no offense" doesn't magically make an offensive statement stop being one.
Sounds like I hit a nerve there. Please point me to where exactly did I say that the entire community consisted of a bunch of amateurs? &amp;#x200B; As an aside, you could try and answer the questions, using your professional view on the topic, arguing why am I wrong and why you feel like you are right about X, Y and Z topics.
I wasn't around to make the initial selection of languages. &gt; Which implementation of Ruby are you using, and why? Mostly the latest CRuby releases of 2.5 and 2.6 with a bit of JRuby, mostly to interact with JVM services. &gt; Would you have used Ruby again if you were to start over? I didn't choose it in the first place, but if I had to rewrite most of the Ruby microservices I'd probably redo them again in Ruby. &gt; Why should someone use Ruby to start a project today? It's an expressive language that helps programmers get work done quickly with extra time to wire up metrics and tests. There are lots of solid Ruby libraries. It's a well-established language with a good trajectory for future features and optimizations. And, importantly, Ruby tends to make programmers happy.
"...and the majority of the community behind it seems like a bunch of amateurs with no real world experience"
precisely, as in the majority and not the entirety, like laerien above for instance, who has demonstrated experience and counter points and actually contributed to the discussion instead of meme-ing or making it somehow personal.
Again, if you insult the people you're asking for advice from, don't be surprised when they don't want to answer your questions. Especially when some of your gripes have more to do with bad habits than any language or framework in particular.
&gt; and a whole lot of people seemingly happy with that because "universities don't prepare you for the market" (read, teach you fundamentals instead of web frameworks). In my experience that is not what that means, it means that academia in most places makes you ready for.. you guessed it: more academia. Someone that have completed a CS degree might demand more money than one that hasn't. And in my experience it takes a while longer to integrate someone that have just finished a computer science degree than it does compared to someone self-taught, a freelancer or someone with a CS degree that have actual working experience. &gt; and the majority of the community behind it seems like a bunch of amateurs with no real-world experience. But yes, it is beautiful. What in the world do you base this on? And in any case, where is your own contributions?
Do you feel part of the group of amateurs, is that why you find it insulting? I really don't understand why exactly are you trying to make it personal mate, if you know you aren't the kind that I described on that essay of the post, why are you feeling the pain for them? Instead, contribute to the discussion, I did make the concession on the disclaimer for you to brutalize any points I've brought up, as I DO want to enjoy Ruby, but the points I've brought up are what stop me from doing so.
No, I'm not an amateur. I really just don't understand why people feel the need to come in this sub and complain about Ruby not being like whatever language, and then get surprised when people don't want to listen to their shit especially when their gripes are language agnostic.
&gt; Someone that have completed a CS degree might demand more money than one that hasn't. And in my experience it takes a while longer to integrate someone that have just finished a computer science degree than it does compared to someone self-taught, a freelancer or someone with a CS degree that have actual working experience. That's a good point, and I have absolutely nothing against self-taught people as I am one for the most part, but usually self-taught people don't dedicate enough time to understand fundamentals, like why do SQL databases work the way they do, how does TCP/UDP work internally, what is the algorithmic complexity of their code and how to improve it, because these don't directly translate to a delivered piece of software, though you can't scale software without knowing these bits and you'll make it really costly for your employer to simply load balance a bunch of unoptimized applications. &amp;#x200B; &gt; What in the world do you base this on? I base this off my own experience, as the entirety of the post is about me asking people to show me I'm wrong. &amp;#x200B; &gt; And in any case, where is your own contributions? Didn't get this bit, what are you talking about?
I feel the need because I care about Ruby and I want to be able to justify using it in the future, but with the experience I've got I'm constantly being off-put by it, hence why I'm asking people who are more lived/experienced specifically in Ruby than I am to show me why my prejudices are wrong, that is all, nothing else. You mention my gripes being language agnostic, which are them? Please, I'm just asking to contribute, someone else in the future might find this post with the same prejudices I have and them become (or not) more inclined to justify to their team why should they use Ruby.
I would argue that frivolous dependencies can be\* less of a problem with Ruby than with other popular languages because the standard library is quite robust. Same goes for Rails; you really shouldn't need a hell of a lot that the language and framework don't provide. These are designed to be complete toolsets, not to require you to cobble together a huge list of additional things to do anything useful. \*I say "can be" because if you're the type of programmer who adds dependencies first and questions them later, you can still end up with a huge pile of unnecessary dependencies.
&gt; In reality, frivolous dependencies can ruin your day, Sure, but this isn't unique to Ruby. Lots and lots of languages have dead-end dependencies. One of the things good about the Ruby ecosystem today is that you can get by entirely on dependencies which are long-running and backed by major players. &gt; you only get the huge part of the productivity boost if you're not writing tests This runs entirely counter to my experience. The productivity boost comes *with* the writing of tests because it's so much easier to test ruby code than other languages. The metaprogramming lets you create some incredibly powerful tests, and tests, for me, are the source of productivity in the long run, not the bane of it. &gt; performance WAS/IS important in every single application I've built professionally (I don't work with making websites and CRUDs) That's legitimate. Ruby is not the fastest language. If you are writing some very CPU-bound applications I would not recommend MRI Ruby for you. There's a reason it's more popular in database bound type apps. On the other hand if you need multithreading, legitimately, JRuby is your friend. &gt; soon you'll be doing type-checking as well, but without the added benefit of a compiler optimizing your code You'll be *optional* doing type-checking, which you can enforce or ignore as you see fit. This means you don't have to wrestle with the type system because some remote library only takes its own defined objects you cannot extend. This is so much better than dealing with a non-optional hardcore type system. &gt; and the majority of the community behind it seems like a bunch of amateurs with no real-world experience. This also runs entirely counter to my experience. I've worked with a bunch of ruby professionals who have a great understanding of the language and frameworks. Maybe they do things differently in Brazil, but it's all CS grads where I am. &gt; With all that said, I could still definitely see myself build small prototypes/scripts with Ruby, but how should I argue using it for a new real project? What justifies the extra cost of server resources? Well, if you're dealing with amateurs who have no idea what they're doing, I cannot recommend Ruby. Ruby gives you a lot of rope with which to hang yourself. You always run the risk that some idiot on your team will decide to redefine a method in a way that is useful at the time that screws you all. That's the tradeoff, and for some teams and some organizations, that tradeoff is worth it. For a small team that knows what they are doing, Ruby is far more likely to get you to the phase where you actually need to worry about resources. The development cycle is much, much faster than it is with other languages. Yes, you have to write tests to make sure that your interface is solid, but you should be writing tests to make sure your implementation is solid too. Just because verified that, for example, the price given is in a Dollar amount doesn't mean that you don't need to check that it's a non-negative value in a reasonable range. It sounds like your disillusionment is coming from the fact that while Ruby makes it very easy to paste together some code and get a half-ass POS working, that doesn't make the code good. That's entirely true. The barrier to entry is low! For a professional with a decade of experience, though, it's a nice change from dealing with the "safety scissors" of other languages.
The names are all just for fun, however this may provide some improvement for some servers https://schneems.com/2019/06/26/puma-4-new-io-4-your-server/
Right, your comment completes my thought, basically. We saw this issue with the whole left pad debacle for JavaScript, and to my knowledge people make the same type of comments about Python packages. Bad dependency management isn't limited to Ruby.
&gt; but usually self-taught people don't dedicate enough time to understand fundamentals, like why do SQL databases work the way they do, how does TCP/UDP work internally, what is the algorithmic complexity of their code and how to improve it And in my experience people fresh out of of computer-science spends days or weeks wondering about these things, instead of just hooking up a client and start using it, sometimes wondering about these things aren't worth it, and sometimes it is. &gt; &gt; And in any case, where is your own contributions? &gt; Didn't get this bit, what are you talking about? You call people amateurs with no real-world experience, but here we have you, an expert with real-world experience, so I was wondering what you are contributing to, because it would be sad for the open-source world not to have access to your superior skills and knowledge.
schneems is a ruby hero. Puma advances are awesome. I still use passenger, mostly because the set up and management of running multiple processes and having them set up right with the web server (and restarted/automatically started when needed) are so brainless. If someone could do that for puma to make the 'operations' set up equally painless/brainless...
Wow, I was almost giving up hope on this thread, thank you so much for this! &gt; Sure, but this isn't unique to Ruby. Lots and lots of languages have dead-end dependencies. One of the things good about the Ruby ecosystem today is that you can get by entirely on dependencies which are long-running and backed by major players. That's true, I guess I was projecting this a bit as I grew increasingly frustrated by the community, touting how you should use dependencies everywhere without care. &gt; This runs entirely counter to my experience. The productivity boost comes *with* the writing of tests because it's so much easier to test ruby code than other languages. The metaprogramming lets you create some incredibly powerful tests, and tests, for me, are the source of productivity in the long run, not the bane of it. I agree that tests are extremely important, specially as a productivity measure in the long run; My gripe with it specifically on Ruby was doing it to circumvent the lack of type-safety. Yes it's not really a bunch more of tests to write, but it's still tests to be added. For example, if you were to implement a strategy pattern, you'd need to create a test module that tests whether the object passed implements the wanted method, and you'd add/import that test to every file you want to test the strategy you'll be implementing, meanwhile on a statically-typed language you'd only define the interface type and the compiler would tell you if you are wrong or right, at compile-time which is even better, so that was the productivity gain/loss rationale. &gt; That's legitimate. Ruby is not the fastest language. If you are writing some very CPU-bound applications I would not recommend MRI Ruby for you. There's a reason it's more popular in database bound type apps. On the other hand if you need multithreading, legitimately, JRuby is your friend. That's true, though I've never heard of someone who actually used JRuby in a real project, I just know how there are some important dependencies that don't play well with it, making me not really take it seriously besides scripting. &gt; You'll be *optional* doing type-checking, which you can enforce or ignore as you see fit. This means you don't have to wrestle with the type system because some remote library only takes its own defined objects you cannot extend. This is so much better than dealing with a non-optional hardcore type system. But when wouldn't you be doing type-checking? If you can give your system the kind of safety that things are returning what you need it to, then wouldn't you be able to skip writing tests like the one I've mentioned on the strategy-pattern implementation? Also, if you had a big system to architect, where and how would you argue using Ruby over the other options? Thank you!
IMO your question itself is trollish in nature with a heavy academic bias showing through... a lot of it seems based on software ideology. Many of your points against ruby could be used applied to any language, e.g. dependencies, and are just realities of software creation. Every language has it's pros and cons. There is no silver bullet. APIs constantly change, features get added, entropy is ever increasing in software. These issues exist in every software project, no matter the language, just by the very nature of "standing on the shoulders of giants". There is no case where you should always use \_\_\_ language and similarly there is no need for a ruby developer to justify their use of ruby if it works. If your project specs require things ruby excels at, then use ruby, if they need what C brings to the table then use C. This is the very nature of software design, use what makes sense for the problem you're solving. Very few software projects fail on the choice of software. In my experience, they fail because of poor management/execution, bad timing, or no market. Plus a lot of your argument is moot, as a business owner, if I want to be successful based on a language choice, I'd base it on developer talent available for that langage. In which case, we'd all be using JavaScript.
&gt; And in my experience people fresh out of of computer-science spends days or weeks wondering about these things, instead of just hooking up a client and start using it, sometimes wondering about these things aren't worth it, and sometimes they are. That can also be a valid point. &gt; You call people amateurs with no real-world experience, but here we have you, an expert with real-world experience, so I was wondering what you are contributing to, because it would be sad for the open-source world not to have access to your superior skills and knowledge. Now that's just childish, don't you agree? I'm no expert, I've just 5 years of experience, but I've been working on large products with a few great mentors and do study a lot every day, and with that routine I realize more and more how little I know and how much more I need to study, which is the opposite I see from people from the community of web-frameworks, acting like they are experts when they write about "How to TDD a To-do app in X framework". I came here precisely because I'm not experienced in Ruby and seek advice in justifying it against my prejudices, which are a mere reflection of what my colleagues who work on these large products have against Ruby. I need to know how they are wrong and how can I convince people otherwise, but I can't do that if I'm still agreeing with them, right?
cc /u/jasonswett 👆
&gt; IMO your question itself is trollish in nature with a heavy academic bias showing through... a lot of it seems based on software ideology. How can it be trollish if all I'm doing is asking for people to tell me exactly how am I wrong? Also, academic bias? My school was trash and I've left it for a year so I could study in a library and actually learn something useful, I just finished it because having a degree is better than nothing. With that said, fundamentals are important for scalability, and that basically applies to anything that isn't some hot-site or CRUD. &gt;Many of your points against ruby could be used applied to any language, e.g. dependencies, and are just realities of software creation. Every language has it's pros and cons. There is no silver bullet. APIs constantly change, features get added, entropy is ever increasing in software. These issues exist in every software project, no matter the language, just by the very nature of "standing on the shoulders of giants". There is no case where you should always use \_\_\_ language and similarly there is no need for a ruby developer to justify their use of ruby if it works. &gt; &gt;If your project specs require things ruby excels at, then use ruby, if they need what C brings to the table then use C. This is the very nature of software design, use what makes sense for the problem you're solving. Very few software projects fail on the choice of software. In my experience, they fail because of poor management/execution, bad timing, or no market. Yes, though as it is for every language, at one point you'll need to choose one to solve the architecturally relevant details of your product, and when that time comes, why Ruby? When is it worth applying? That's basically the post's question. &gt; Plus a lot of your argument is moot, as a business owner, if I want to be successful based on a language choice, I'd base it on developer talent available for that langage. In which case, we'd all be using JavaScript. That's a viable answer, it shows sensibility because you wouldn't pick some language no-one would be able to maintain afterwards, but at the same time at some point you'd need something that JS (by your example), wouldn't be able to give you without some massive effort/cost/entanglement, that's when you'd need to pick another language, and if so, why would you pick Ruby, considering the points I've mentioned? Notice, I'm not trying to convince anyone here not to use it, I'm asking people to show me I'm wrong and explain how.
You're not wrong, Walter, you're just an asshole.
Are there plans to update puma_worker_killer?
Good bot.
&gt; For example, if you were to implement a strategy pattern, you'd need to create a test module that tests whether the object passed implements the wanted method, and you'd add/import that test to every file you want to test the strategy you'll be implementing, meanwhile on a statically-typed language you'd only define the interface type and the compiler would tell you if you are wrong or right, at compile-time which is even better, so that was the productivity gain/loss rationale. This is true, but consider what your test needs to show -- that it actually interacts with the strategy pattern properly and that means, among other things, that it doesn't throw an error. If your code properly executes the logic, it will answer to you "yes, indeed, I am getting back what I expect." You can rely on a compiler to tell you that you're passing a sensible type, but you cannot rely on the compiler to tell you if you're seeing sensible results. Since you have to test the former you end up testing the types by default, or so I've found. &gt; But when wouldn't you be doing type-checking? If you can give your system the kind of safety that things are returning what you need it to, then wouldn't you be able to skip writing tests like the one I've mentioned on the strategy-pattern implementation? I have never in my life written a test which checks for types. I've always written tests which check for behavior. A type check is really nice when you've locked the type down, but it can be a giant pain in the ass if you're constantly changing the signature as you develop. An example from my actual project. I have these *enormous* rows in a DB field and I end up not wanting to load giant ORM objects filled with data when I need a few columns. So I'm going hardcore, loading up the data into a lightweight OpenStruct. Now there's no type system which is going to save me from trouble -- because with an OpenStruct I'm defining methods on the fly! A type system can indeed be useful though, once I lock down the code to always be using ORMs, I can say "ok this method should never be called with anything but an OpenStruct" later in development and catch errors. Probably didn't want to wrestle with the type system mid-development, and more importantly, it would not have saved me anyway. Programming is often about manipulating lists and sets of strings and numbers. A type system can guarantee that you are using the right container, but it can't say anything about the contents. &gt; Also, if you had a big system to architect, where and how would you argue using Ruby over the other options? If I had a well established system with requirements set in stone, Ruby would not be my goto. On the other hand, if I was doing software development as I've usually had to, with many many changes over the way, Ruby (among other languages) makes it a lot easier to architect on the fly. That's the sweet spot.
Well, you killed it :) Thanks a lot for the thoughtful answers, I'll update the main post with what I've learned so far
Just released 0.1.1 with support for puma 4
A better (and less nerve-poking) way to approach this point would be to recognize that *you* were less experienced at the time, and thus less able to identify and select quality gems. Finding an excuse to cram every spiffy gem you stumble across into your Gemfile and then finding yourself painted into a corner later because of spotty quality and support is a really common rookie mistake, and one you’d run into with most other ecosystems as well. Play with shiny things in your own projects; go with rock-solid and boring at work. Blaming the community as a whole is a bad look, and yes you’re doing that by suggesting the Ruby community has a unique quality problem you don’t think you’d encounter elsewhere. A lot of people in your position are instead humbled by their past choices and glad they’ve learned to make better ones.
It's the painter, not the brush. Bad software can be written in any language. Having a type checker can alleviate a certain category of problems. Having dynamic types can alleviate another. Dependencies are not inherently a bad thing, but vetting the quality and stability of them is as much a skill to hone as any other part of software engineering. Blind trust has no place in building software. Not even in the standard library. Test, measure, improve. Rinse &amp; repeat. And again, the right tool for the job means Ruby won't be a good fit for all projects. It's just a pretty good tool for a lot of them.
gelfin, I agree that my means of approaching topics aren't the best, I'm honestly sh\*\* at explaining and probably could have written a much smaller OP. That said, at no point I've put the whole community on the spotlight nor blamed anyone but some bloggers (which I didn't even name either), neither said that it was specific to Ruby, specially since the JS community is much "worse" in terms of dependency shoveling. What I really fail to see though, is how a mostly architectural decision question was so derailed towards having/not having CS degrees, people feeling like I've personally named them amateurs, and that I somehow claimed that adding a bunch of frivolous dependencies is a problem exclusive to Ruby, when these were marginal details to illustrate my disbelief on the community, which I've considered great when I first started. I do take the blame for not expressing myself in a more clear way, but I can't be responsible for other people's lack of interpretation skills as well as their egos. I would never in my life feel any bit discredited if I've seen someone else making a post like this, and instead, going through it myself and knowing what people can be like, I'd understand why they felt that way.
I can't agree most.
I wish I had any helpful links, but I don't. I do have helpful info from time in the trenches though. 1. Make sure gem and bundler are using the version of Ruby you think they are by doing a `ruby -v` 2. Gems often fail to install on the `building native extensions` step because an underlying non-ruby library is missing. Learn to look for that in the build log that it will output. 3. Nokogiri takes a while. It makes a great coffee break time.
So does this make using ActionCable more viable without a non-ruby server like AnyCable?
For me, reasons to start a fresh project in Ruby would be as follows: &amp;#x200B; **Management** * The team knows Ruby, it's the language the work best in and/or majority of other projects in the house are written in Ruby. Cost of having specialists in a few languages can be greater than gain from super-optimization. * POC has to be delivered really fast - Ruby tooling excels at that. It's a bit worse when you maintain for a long time, but frequently time to deliver first working version and start validating the idea is the key. **Technology** * Tooling, such as Sidekiq. I must say I have never worked with a software that much reliable. Of course, you can say that nowadays Sidekiq is just a protocol and you can schedule jobs or run workers for any language, but still Ruby is a first-class citizen and you don't have benefits from Sidekiq Pro in other languages, I believe. * Working with non-typed data. I work a lot with huge amount of JSON and unfortunately data quality is not to cool. Sometimes one key can hold integer fo 98% of records, but remaining 2% has string (i.e. "123") for some reason. I recently tried to rewrite some processing to strongly typed language and it was pure hell. Types are nice, but when your domain is not typed, they don't help. * It's mostly trial-and-error. In Ruby you can pause executing your program, rewrite something (for example class method) and resume it. I know this is very narrow application, but I've been there. And I don't know any other language with such superpowers (lisp maybe?).
Right now there is no way to externally hook into the reactor, though this paves the way to do something like that. Convo on twitter. https://twitter.com/julikt/status/1143639874957918208
I understand that you don't want to hear this, and I also know that you specifically said you didn't want to hear it, but hear me out, please! I understand that you want to know about every tool and how it functions, especially one as prominent and important as a ruby version manager or even bundler, but I wouldn't worry too much about it right away. The team you are going to join will know the most common errors that you will face with the gems that they use, and your brain-power is much better spent worrying about the codebases you are going to work on, than how the community deals with Ruby version switching, or how Bundler solves its dependency graphs. You run the risk of getting absolutely overwhelmed and burnt-out with this mentality, so calm down, and accept that you don't need to understand everything at day one. You will have plenty of time to explore the tools that you will use every day as a Ruby programmer later, whilst you are making solid contributions to your codebases.
I'll take a stab at a cursory explanation of the role of some of the popular Ruby tools, like rvm, chruby, rbenv, bundle and gem. RVM, chruby and rbenv are the three most popular Ruby version switchers. They switch the current version of Ruby being used, assuming you have multiple versions installed. To switch to ruby-2.6.3, for example, you can `rvm use 2.6.3`, `chruby 2.6.3` or `rbenv global ruby-2.6.3`. RVM and chruby both achieve this by setting environment variables like $GEM_PATH, $GEM_HOME, etc. On the other hand, rbenv uses a directory of shims - little files for each gem binary that point to the current Ruby gems. RVM does much more than just switch Rubies, which you can tell by the fact that it's over 20,000 lines of shell. rbenv is the second heaviest, at just over 1,000 lines of shell and a C-extension for realpath. chruby is the lightest, at [just over a hundred lines of shell](https://github.com/postmodern/chruby/blob/master/share/chruby/chruby.sh#L1). Unlike chruby and rbenv, RVM also installs Rubies. With chruby and rbenv, most folk use the ruby-install or ruby-build tools, respectively. RVM can handle ancient Rubies and esoteric systems by using custom install logic and patches. RVM installs dependencies for you in several different ways, including using your package manager. rbenv leaves installing dependencies to you, except it ships its own bundled openssl. ruby-install supports popular package managers. I'd recommend using chruby as your version switcher and ruby-install to install Rubies. These are the simplest thing that can possibly work, and by far the least code to read if you want to get up to speed on what they're doing. Alternatively, you could use RVM, or use rbenv with ruby-build. [RubyGems](https://guides.rubygems.org/) is the package manager that ships with Ruby. [Bundler](https://bundler.io/docs.html) is a dependency resolver, that has merged with RubyGems and now also ships with Ruby. You can use RubyGems/Bundler to create gems, install gems, resolve the correct dependencies for gems or apps, etc. You can install a gem with RubyGems using the `gem` command: gem install hola Or, for a Ruby project you can declare your gem dependencies in a file called `Gemfile`, then resolve which gems exactly should be installed, list those in a Gemfile.lock so others can use those exact same versions, and install those gems by running: bundle The [#ruby channel](irc://irc.freenode.net/ruby) on IRC is a great place to chat about stuff like this, if you want some more feedback.
I don’t need to know the details of every tool, I usually trust that tools and libraries operate consistently and according to my mental model. My problem is that when I’ve used these tools in the past, they have violated that trust. I would like to learn these now so that when I join the team as a Senior Software Engineer next week, I can focus on the codebase and not worry that I’m going to get stuck on some trivial error.
Somehow I was expecting some benchmarks...... I guess we will have to help ourself : /
ActionCable is a bad design. Rack full hijack is probably impossible to support with native HTTP/2. &amp;#x200B; You can do WebSockets over HTTP/1, HTTP/2, right now with [https://github.com/socketry/falcon](https://github.com/socketry/falcon) and it does it in-process, scales up to 100k connections.
I compared it with 3.x in my micro benchmark and didn't notice much difference t.b.h. &amp;#x200B; \- Puma 4 1500req/s [https://travis-ci.com/socketry/falcon/jobs/210246853#L616](https://travis-ci.com/socketry/falcon/jobs/210246853#L616) \- Puma 3 1600req/s [https://travis-ci.com/socketry/falcon/jobs/210246659#L607](https://travis-ci.com/socketry/falcon/jobs/210246659#L607) \- Falcon 2600req/s [https://travis-ci.com/socketry/falcon/jobs/210246853#L647](https://travis-ci.com/socketry/falcon/jobs/210246853#L647) &amp;#x200B; I've found those travis results to be pretty stable. But it's a micro-benchmark. I have a much bigger picture benchmark, which I can run today.
Good question, a bit loaded but good. The benchmark that he posted (like most benchmarks that people post) was a little...misleading. Puma was artificially limited to 16 threads, but could have gone up to the system's: $ cat /proc/sys/kernel/threads-max 491393 Granted puma would probably be CPU bound well before getting up to that maximum. But that would have been a better benchmark comparison. Still falcon is a good project, and Samuel is a great OSS dev. Fundamentally the two projects think about concurrency differently. To get the full benefits of something like falcon, all your libraries have to be aware that you're running in evented mode. (Though you could say the same with running inside of multiple threads, by requiring the system to be threadsafe). Many years ago there was a push for evented code that was integrated with eventmachine, but it ran into adoption issues as there ended up being 2 versions of just about every gem, i.e. `foo` gem and `foo-eventmachine`. I think in the future with if/when auto-fibers come out maybe there's some more room to do more evented type programming. I believe it would effectively mean that calls to current GIL releasing methods would effectively act as a hook into a fiber based event loop which would eliminate the need of a lot of libraries from manually having to make their code event aware. (That being said, I could be totally wrong here, but that's my take on it). For now there's no major plans to change the way we're doing concurrency. Maybe auto-fibers change that, maybe guilds change that. Maybe falcon "wins" and everyone talks about puma the way they talk about thin or mongrel one day, we'll see! ;) Also to note the reactor __should__ be more performant, but benchmarking it is hard. We've not done it. https://twitter.com/ioquatix/status/1143623012098306048
I posted another comment, have you tried testing puma with a REALLY high thread limit instead of the default 16 threads? Also I had a question about auto fibers &gt; I think in the future with if/when auto-fibers come out maybe there's some more room to do more evented type programming. I believe it would effectively mean that calls to current GIL releasing methods would effectively act as a hook into a fiber based event loop which would eliminate the need of a lot of libraries from manually having to make their code event aware. (That being said, I could be totally wrong here, but that's my take on it). Is that a correct take on what auto-fibers would buy an evented server?
Yes to the extent possible we are aiming for something like that.
Also, if you give me some details on what kind of thread count I should use, I can try running a full suite of benchmarks today comparing 3.x, 4.x, passenger and falcon? Just let me know what you think are reasonable parameters.
The NIO4r reactor API is not designed to be exposed to user code. If you decided to do that, use \`async\`.
The other reply to this comment does a good job at expressing my primary feeling with this: The important thing your program does is usually not specific to a class or interface name, but instead what happens to the system on the other side (a value is presented or calculated in a certain way, an interaction with something happens as expected). The book Practical Object-Oriented Design by Sandi Metz did a fantastic job of helping me understand the value of tests (not to mean why testing is important, but to better interpret what tests are valuable, and how to implement them). I felt that the biggest take away was that the important thing in software design is what comes out the other side (the public interfaces, per say). The fact that the data getting passed around is a hash, or a struct, or a very specific data type isn't _usually_ important: The final results in the interaction is what's important. I do think that Ruby lends itself to generating more unexpected errors that are essentially type errors that a compiler might be able to capture, but I also think that with a certain amount of experience, you learn how to cope or even exploit this, just like every language has certain papercuts to work within. I think the example provided alongside this, using OStruct until your data is better situated is great. Frankly, there could be many parts of the system that would otherwise need to be annotated with very little actual value, and instead inhibit you. As for my background, I use Ruby to process and parse data for a business intelligence product. I also have experience with C#, Python and Node. I personally prefer Ruby as I feel like I'm able to solve problems quickly, without feeling like I have to architect complex software to do so. The "get-to-the-pointability" of it is the best of any language, I feel.
From one senior to another - I'd expect you to Google first and try some solutions and then explain that to me if you couldn't get past it. Of course you could still spend some time diving into their codebase (that sounds pretty interesting tbh) but if you are asking me for help I wouldn't care about that. Just what you have and haven't done yet for that particular error.
\&gt; The benchmark that he posted (like most benchmarks that people post) was a little...misleading. I'm sorry, but I clarified that it was a micro benchmark. I don't know how I could be any more honest about it. Try not to frame this as a competition. We are all have different reasons, but I like to believe we do it because it's something we love doing. The travis benchmarks are designed to provide objective comparison w.r.t. performance regressions which I do pretty systematically in many test suites. If I see a big drop or some other issue, it's time to investigate. That's about as deep as it goes. But it also provides a useful history of \*relative\* performance changes. The actual benchmark sweeps the available CPU core count and looks at how the performance changes. Falcon runs with all the defaults, Puma runs in cluster mode so it is roughly fair in terms of avoiding the GIL.
But isn't it expensive when you want to use mixed model concurrency? And without that it's basically unicorn.
Sequel code is terrible to read though
By default, puma will spawn a new thread whenever it can, up to the maximum value. In theory anyway it should be somewhat self-regulating as when CPU becomes saturated, it won't have overhead to spawn more threads. In practice i've seen it spawn a ton and spend all it's time context switching and contending for a single resource depending on the application. That being said you can certainly tune it to a machine. I guess I would be curious to even see what it goes up to. Setting it to an arbitrarilly high value like 10,000. Though if you were trying to hone in on a _perfect_ value, I think we would have to get a bit more creative, maybe picking values and bisecting based on throughput. I'll try to take a look at your benchmarks and play around with them soon. Do you have any docs on getting tests setup. I'm hitting this right now: 17.38s error: #&lt;Async::Container::Threaded:0x00007fc4c6926c28&gt; [pid=26514] [2019-06-26 16:52:03 -0500] | Errno::EPERM: Operation not permitted | → /Users/rschneeman/Documents/projects/falcon/lib/falcon/command/virtual.rb:53 in `change_privilege' | /Users/rschneeman/Documents/projects/falcon/lib/falcon/command/virtual.rb:53 in `assume_privileges' | /Users/rschneeman/Documents/projects/falcon/lib/falcon/command/virtual.rb:65 in `block in spawn' | /Users/rschneeman/.gem/ruby/2.6.3/gems/async-container-0.14.1/lib/async/container/threaded.rb:79 in `block in spawn'
Try removing \`method: :update\` from the link to Edit Comment.
 [https://gyazo.com/c852a0ad694c48cfc52d767df33f5224](https://gyazo.com/c852a0ad694c48cfc52d767df33f5224) this is the outcome
Any other ideas ?
I've learned people don't read the fine print when it comes to microbenchmarks. Which is true even in my case. For example: &gt; The actual benchmark sweeps the available CPU core count and looks at how the performance changes. Falcon runs with all the defaults, Puma runs in cluster mode so it is roughly fair in terms of avoiding the GIL. I didn't know that. &gt; I don't know how I could be any more honest about it. I didn't mean to imply that you were misleading. I don't think you are misleading. Honestly, the correct thing to do would for me to instead get the benchmarks working on my machine rather than just fire off what was on my mind. The upside of the comment I posted, is it got me to realize that I should practice what I preach which is: running benchmarks with different changes instead of commenting and trying to get someone to do it for me. &gt; Try not to frame this as a competition. We are all have different reasons, but I like to believe we do it because it's something we love doing. Absolutely. I love your work!
HI AARON
HELLO!! 👋🏻
I love Aaron, I wish I could give him something.
What are you using falcon virtual for? It's an experimental Nginx replacement. It looks like it's bugging out trying to drop privileges for some reason. I don't think any of my benchmark scripts use it.
I’m still in the puma for local dev and passenger + nginx for deployment phase.
:wave: Well, all I have to talk about for the last 4 years are my experiences selling the stuff I have to sell, so you can understand why it comes out that way. It is *not* actually very Rails specific. I use "Rails" mostly as a marketing term because if I marketed everything as "Ruby" then 90% of my target audience would think "ah yes, but does it apply to my *RAILS* application?". So that puts *you* in the unfortunate other 10% I am optimizing against. I'd say about 10% of the content is specific to Rails (mainly ActiveRecord). The rest applies to any Rack-based webserver. I do stand by my 100% money-back guarantee - if you buy it and find you disagree with my estimation, just tell me and I hit the refund button.
Would you suggest eager assigning instance variables for performance improvement? Especially for classes with many instance variables (mostly gems? like ActiveRecord?)
thanks - say no more. oh wait, unless you have a TOC to share because i couldn’t find one yet. or can i take your article as a reference of what to expect?
Here's one: [https://gist.github.com/nateberkopec/1c9bb9532b8f3ee6e4a7ebd18403f8f6](https://gist.github.com/nateberkopec/1c9bb9532b8f3ee6e4a7ebd18403f8f6)
&gt;something like falcon, all your libraries have to be aware that you're running in evented mode. (Though you could say the same with running inside of multiple threads, by requiring the system to be threadsafe). Many years ago there was a push for evented code that was integrated with eventmachine, but it ran into adoption issues as there ended up being 2 versions of just about every gem Falcon is already as fast or faster than Puma in [cases that I've tested](https://github.com/socketry/falcon-benchmark). But **additionally** if you use concurrency aware wrappers, your scalability can [go through the roof](https://www.codeotaku.com/journal/2018-06/improving-ruby-concurrency/index#performance). You don't need to rewrite code or gems, but it definitely makes sense to leverage concurrency if you are concerned about scalability. Without going into a ton of details, most existing gems have very poor scalability/concurrency/parallelism engineering. Of course, you can suffer head of line blocking if you don't use concurrency aware gems. It might be worse than puma if your system has a lot of latency, but in Puma, the result is that it simply won't accept more connections, while falcon will try to accept more connections, but the latency will go up according to your blocking operations.
thanks!
But at what cost?
This output is from a fresh clone of falcon followed by “rake test”. I would like to be able to run your benchmarks. Great job with the PR. For running in prod I personally recommend setting min == max so you don’t have to have the overhead of having to spawn a thread while also serving a request. Spacing threads faster though will certainly help bootup for that case. It will also help webrick a ton which spawns a new thread per request.
Ahh.. that makes sense. Okay, I'll have to check what's going on. \`falcon virtual\` is passing in travis but the entire thing is just a giant pie in the sky dream of "Let's try to replace nginx". I did the bare minimum to get it to replace nginx in my prod environment and am going from there. Stuff like dropping privileges is kind of weird on different platforms, so maybe there are issues, e.g. on your system maybe it's trying to use the same perms as you currently have and that's failing, or maybe there is something wrong with the group. Please create an issue and give me the details of the user/group/permissions of the \`examples/hello\` and \`examples/hello/falcon.rb\`
I run many puma instances using pm2. Works pretty well and is relatively painless to set up and maintain.
Thank you for doing this, great idea! I think I can contribute some time to this. I’ll take a look tomorrow to see what I can take on.
I am actively developing my Rails apps on Windows 10 + WSL for a couple of years now, without any problems. I am also using Redis, sidekiq and Postgresql without a sweat.
What editor/IDE do you use? I recently tried using Sublime Text from the Windows host and the file permissions would screw up on save.
I can highly recommend Visual Studio Code. It is also very convenient to use with WSL.
I love esoteric ruby language stuff like this!!!
We don't know your mental model about the tools, so we can't point out, where it's wrong. Things that gave me headaches with bundler before: - nokogiri needs to have native extensions which need to be installed as root, but bundler is working at the user level. - If you use git sources in your Gemfile, these can change, become incompatible or get deleted. I'm not sure what the best way is, but I think, forking them to a repo you control is better. - Bundler is working out a compatibility set of gem versions and installs it. I think in Ruby there is only one version of each gem in a project whereas - if I recall it right - npm can have different versions of dependencies. https://lexi-lambda.github.io/blog/2016/08/24/understanding-the-npm-dependency-model/ Things I've seen other people do wrong: - adding `Gemfile.lock` to their library, not adding `Gemfile.lock` to their app
You can't create files from a Windows app in the Linux distribution, not with ST3, not with VS Code. See [https://docs.microsoft.com/en-us/windows/wsl/faq#how-do-i-use-a-windows-file-with-a-linux-app](https://docs.microsoft.com/en-us/windows/wsl/faq#how-do-i-use-a-windows-file-with-a-linux-app): &gt;**IMPORTANT NOTE**: One of the key limitations of using WSL is that directly accessing/changing files in your Linux distros' filesystem using Windows apps or tools is not supported. See: [Do not change Linux files using Windows apps and tools](https://blogs.msdn.microsoft.com/commandline/2016/11/17/do-not-change-linux-files-using-windows-apps-and-tools/) &amp;#x200B; You have to have your files in /mnt/c or whatever in order to be able to use a Windows app. [https://devblogs.microsoft.com/commandline/wsl-2-is-now-available-in-windows-insiders/](https://devblogs.microsoft.com/commandline/wsl-2-is-now-available-in-windows-insiders/) mentions to put your files in the Linux root file system again, so maybe that'll do.
Do you know [https://rbspy.github.io/](https://rbspy.github.io/) ?
Migrations are one of the best parts of Rails. I don’t understand what problem you are trying to solve.
And this article is written in such bad english that everyone is just left wondering: &gt; But you can't have multiple migrations patterns in Rails. Only one migrations.
Love this kind of deep dive into Ruby internals. Thanks!
Thank you! Are there any installation guide's you'd recommend following?
Thanks! Are there any installation guide's you'd recommend following?
I didn't knew that. Looks nice. I will give it a try.
deferred assignment (especially if not always needed) is faster. Please look at the Jeremy Evans RubyKaigi 2019 talk for more details.
Hey I changed that part like this. Do you guys still have trouble understanding it? \&gt; When multiple teams are working on the same Rails application at a fast pace, they would create migrations without knowing what migrations the other teams are creating. But you can't have multiple sets of migrations in Rails. you can only have a set of migrations. Because of that, it is not easy to share the migrations withouts slowing down the other teams.
I think you'd have to go sample-by-sample in both wav files, combine the samples (bitwise AND, I think?), and write a new file. There are better tools to do this sort of thing though.
nah you just sum the values, its very simple. to mix the tracks in different ratios you just scale the values. I can certainly reccommend trying different bitwise operations though, lots of fun to be had there.
Thanks! Any recommendations on tools?
[SoX](http://sox.sourceforge.net/) is the imagemagick of audio (by that i mean its a very useful swiss-army-knife command line tool, not that it has an unmanageable list of dependencies lol
Not really, no. Why does it matter that there is 'one set of migrations'?
&gt; The team you are going to join will know the most common errors that you will face with the gems that they use, and your brain-power is much better spent worrying about the codebases you are going to work on, than how the community deals with Ruby version switching, or how Bundler solves its dependency graphs. I disagree with this. Pretty much every team I've ever come onto I've known more than the team about the issues they were having. The solutions are too often "Nokogiri failed to compile? Try one of these 10 things I found on StackOverflow" I agree with your other points though - I just wanted to point out that I've met few people who actually read log messages and error logs and have the time/knowledge to know how to fix them properly
I don't know why everyone is going down your throat here. I am like you and I want to know the tools well (because it _does_ matter that you understand them) &gt; A meaty article explaining any tool in the ruby packaging ecosystem and its object model I don't have any articles for RVM/Rbenv/Rubygems but I liked Andre Arko's "How Bundler Works" talks (see https://www.youtube.com/watch?v=4DqzaqeeMgY). The TL;DR is that pretty much all of these tools work by manipulating some analogy of PATH (e.g. GEM_PATH, literal PATH, etc). Rbenv uses "shims" to intercept things in the path and I think RVM overrides "cd" to do its magic but don't quote me. Moral of the story is that your gems are in a predictable place and these tools have rules for switching your path to point to that place &gt; An answer to a “WTF charlock_holmes? how do I fix this particular ruby package error?” which grounds its explanation in the internal object model of a ruby packaging tool In my experience this is not usually an issue. It's more like "WTF? some C extension won't compile" and you need to set some flags or set library paths properly so that the C compiler knows what lib version to pull in (looking at you OpenSSL) &gt; A walkthrough of the codebase of these projects which suggests in what order someone should read files if they want to grasp the structure of rvm/rbenv/bundler The best place to start is by looking at the commands themself. Want to know how Bundler works? Look at `bundler/bin/bundle` and follow the food chain until you are satisfied I don't do anything official but I'm always happy to help answer questions about tooling (I've been figuring it out on my own for 8 years or so now). Feel free to PM me if you have questions
While I don't want to crap on anyone thinking outside of the box. I get the feeling this project arises because of a poor merge/branch strategy rather than because of migrations themselves. If you're rebasing the main branches, e.g. staging, production, onto your feature branch as you develop and only committing back to the main branch via merge requests, e.g. on github or gitlab, this problem goes away. Granted, you may have to redo the timestamp portion of your feature branch migration and reset your feature branch database when you rebase but I think it's much saner than allowing anyone to commit migrations onto your main branches ad hoc. While you're probably approaching this from an agile startup perspective. In my experience most large organizations have DBAs and they're not going to let you use rails migrations to apply schema changes to any database that production relies on, at least that's been my experience.
s/especially/only/ If you need them, then there's no point in deferment. In fact your code will be more complex because you have to add conditionals to check if the ivar was initialized or not. IMO the "deferred assignment" advice is only to address quirks in the VM, and the Ruby developers (I include myself in this statement) should actually work harder to make eager assignments faster.
It depends. Eager assignment probably won't impact performance in terms of "ivar array expansion". Also if you eagerly assign them, you can avoid scattering "has this ivar been initialized?" conditionals through your code. In other words, you can write *confident* code. However, if initializing a particular ivar is expensive, and you don't usually need that value, then it's probably better to lazily assign. Personally I like eager assignment because I like to be confident about the rest of the code I write in my class. Generally I'll only make them lazy if it turns out we don't actually need the value.
Whoa! My first gold! Thank you! 😊
did you notice who OP was?
I love this post because it's something I never would have considered. A cool peek under the hood, Aaron!
It's not expensive for businesses with budgets to buy quality tools.
Unless you are dealing with very very performance-sensitive code, I'd suggest doing what makes most sense for the code's readability and maintainability. I think this kind of investigation is most useful for those working on performance tuning MRI itself (or those of us observing it just cause we're curious to know more about how MRI works, which is always valuable). But the performance characteristics will change over time, and the reason I use ruby in the first place is to productively write nice code. Mangling any niceties of the code for hoped for performance increases is best avoided unless you really know you need it.
&gt; nah you just sum the values, its very simple. It's really not that simple, actually it's a very big and complicated topic. If you just sum the sources - you can get clipping, if you want to avoid clipping, you have to decide between a bunch of different tradeoffs. The naive approach to avoid clipping would be to divide each signal by 2 prior to adding them, but now you're mix doesn't maintain the volume of the inputs and if your goal is that the output 'sound the same' as the individual inputs you can't even divide by a constant as human loudness perception isn't constant (or even linear) in either amplitude or frequency.
What are the effects of having `attr_reader` and `attr_accessor` since they're defined at the class level..?
Aaron, this was almost as glorious as you are. You're breathtaking
Great question! I don't think they will impact the IV Index table. Probably because you can define `attr_reader` inside a module, then include the module in a class. So the recipient of the `attr_reader`call isn't necessarily the place where the IV Index Table will be stored.
lol thank you!
Another interesting example is subclasses. The IV Index table really knows nothing about other classes: require "objspace" class Foo def initialize @bar = 10 end end class Bar &lt; Foo; end p({ FOO: ObjectSpace.memsize_of(Foo), BAR: ObjectSpace.memsize_of(Bar)}) Foo.new p({ FOO: ObjectSpace.memsize_of(Foo), BAR: ObjectSpace.memsize_of(Bar)}) Bar.new p({ FOO: ObjectSpace.memsize_of(Foo), BAR: ObjectSpace.memsize_of(Bar)}) Output: $ ruby thing.rb {:FOO=&gt;520, :BAR=&gt;456} {:FOO=&gt;672, :BAR=&gt;456} {:FOO=&gt;672, :BAR=&gt;608} `Foo` grows, then `Bar` grows
&gt; There isn't much value in testing "Are you a String? Do you respond to .listings?" but instead whether the interaction is as expected: "Does .listings have the content I expected?" OP deleted his post and I doubt many people will see this, but you encapsulated *exactly* what I was getting at in fewer words. I'm going to steal this, with the side note that if you're testing what `.listings` returns, you implicitly verify that the object in question has the method you want.
I had a question here, what happens if you don't assign the ivar in the initialize method, but suddenly bring it into existence in a method in a particular instance of a class, that hasn't been called on other instances of the class. How do the other instances of the class adjust their ivar index table? so for example `class Foo` `def initialize` `@a = "hi"` `@b= "my"` `@c="name"` `end` `def finish` `@d = "is"` `@e = "Slim Shady"` `end` `end` `Foo.new` `Foo.new` `Foo.new.finish`
`Foo.new.finish` will expand the IV Index Table because `@d` and `@e` haven't been "seen" yet. Ruby automatically expands the index table every time a new instance variable is "seen", regardless of whether it's in the `initialize` method or not.
Got it. Thanks!
The thing about WSL2 that differs from WSL is that it is a VM running on the windows machine. It also flips the 'use /mnt/c' of WSL1. [https://devblogs.microsoft.com/commandline/wsl-2-is-now-available-in-windows-insiders/](https://devblogs.microsoft.com/commandline/wsl-2-is-now-available-in-windows-insiders/) Because its a VM and not sharing the network stack, the IP address of the VM now needs to be bound when you run rails s (such as -b [0.0.0.0](https://0.0.0.0)) and accessed in the browser as the secondary IP, but that should be resolved with additional workarounds. After years of WSL development, I've moved to development on Linux.
I hear he likes hugs, especially on Friday.
Your use of string ranges is something I've not used before. And in investigating it I guess I exposed a special case that might be even considered a bug. So it became obvious that `'a'..'zz'` is valid once I verified that `?z.succ` is `'aa'`, which makes enough sense from a lexicographical sorting standpoint. So I tried a bunch of cases to see what is handled correctly: - `('a'..'zz').count =&gt; 702` - `('1'..'99').count =&gt; 99` - `('2'..'99').count =&gt; 98` - `('ab'..'zz').count =&gt; 675` - `('b'..'zz').count =&gt; 0` :( Is there special handling for multi-character alpha-only range upper bounds? This is in MRI 2.6.0.
Weird, I'm getting 701 here on MRI 2.6.2
Okay maybe the issue is fixed already :D I'll give the micro update a shot
Just verified that 2.6.1 does not exhibit this behavior.
Nice! This reminds me of the fact that Singleton classes have their own scope regarding instance variables. Good to know that chances of memory leaking here are slim.
Ah! This bit about subclasses should be added to your blog post as well, IMO :) Thank you for the clear explanation.
Gotta practice somehow!
Ugh, this probably hurts the inline cache performance on inherited methods...
Thanks for the great article!. Are you planning to apply some heuristic to calculate how big the ivar table should be when an instance is created, like to profiling its most common size after warming up the code?.
Why not keep the source in LaTeX though?
Hey, thank you for an insightful comment. I didn't know that large organizations don't let you use rails migrations to apply schema changes. I wonder what they are moving on to after DBAs. &amp;#x200B; \&gt; If you're rebasing the main branches, e.g. staging, production, onto your feature branch as you develop and only committing back to the main branch via merge requests, e.g. on github or gitlab, this problem goes away. True. What I meant was that it is difficult to keep the development at a fast pace when there are multiple teams developing the same application because you have to keep track of migrations the other teams commit while you commit your migraitions. \&gt; Granted, you may have to redo the timestamp portion of your feature branch migration and reset your feature branch database when you rebase Exactly, and that process gets tough when you try to develop a large app at fast pace imo. That was what I meant by saying "slowing down the other teams". \&gt; but I think it's much saner than allowing anyone to commit migrations onto your main branches ad hoc. &amp;#x200B; I'm probably not getting what you meant here. Obviously, you can always revert changes as long as it's version-controlled. You don't necessarily need ActiveRecord migrations to achieve a consistent schema management.
Okay. I hope you get what I meant with this comment. https://www.reddit.com/r/ruby/comments/c62a62/easier_database_schema_management_with_ridgepole/es84gnu?utm_source=share&amp;utm_medium=web2x
I think I get your reasoning for the project and hey if you can make a project that solves a problem... ANY problem, more power to you. re: DBA's we're talking about places with MASSIVE databases. Think large enterprisey and government and you'll get close. Those DBAs are secure in their jobs for life, plus after working with them they do A LOT of optimization that I'd never catch and it makes a huge difference. re: not getting what I meant here. If you have developers pushing directly to your main branches, i.e. master, production, you should stop that and force a merge request via some sort of scrum or build master. Basically someone that can push back on merges and keep the stable branches er ... stable. Good luck on your project!
I'm more comfortable with Markdown and I feel it will make it easier for contributors too.
&gt; DBA's we're talking about places with MASSIVE databases. Think large enterprisey and government and you'll get close. Those DBAs are secure in their jobs for life, plus after working with them they do A LOT of optimization that I'd never catch and it makes a huge difference, e.g. normalization of data in tables. I see. That is very interesting. &gt; If you have developers pushing directly to your main branches, i.e. master, production, you should stop that and force a merge request via some sort of scrum or build master. Basically someone that can push back on merges and keep the stable branches er ... stable. Oh... I got it now. I probably misunderstood your comment because we have `master` branch for development and `release` branch for production haha. My bad. Thank you man! It's always to good to share your content on the internet because you can get feedbacks from a guy like you :)
👍
Yeah, your post was totally on point with how I'm seeing things currently -- you wrote the sentiment that was brewing in my belly. Also, I totally used your OStruct move today for that exact reason. I've often avoided it because early on I learned that it has poor performance. Maybe? I don't know. Creating a few hundred thousand of them was negligible, but it made my code way easier to work with today while slashing hashes into reports, `map`ping, `select`ing, `reject`ing, and `min_by`ing. So, thanks for the tip!
Happy to! I ended up writing a kind of fun rowloader library that let me pass in the ActiveRecord relationship (which doesn't have a huge load) and a set of symbols to define the relationship, and then it creates OpenStructs in the response. The performance gain was about 10x. You can do faster, OStruct is not *the* fastest, but it's basically a wrapper around a hashmap.
What is the plan to handle fundamental differences between Python and Ruby? For example, I see that you've maintained python's distinction between "fruitful" and void functions, even though everything in Ruby is an expression and thus has a return value. It's also weird how you directly translate functions to methods and thus introduce methods all on their own without even mentioning classes/modules. That makes sense in python because it has lots of floating functions like range, min, max, etc. but in Ruby you almost always associate a method with a class or module. It could be fine to introduce them like that, but I _would_ call them functions since they don't have a receiver in the sense that most methods do. It seems strange to translate this book chapter by chapter rather than using it as a general outline for how to teach a language and then write the book from scratch.
All good points and needs to be addressed. I certainly agree that I didn't have the experience to undertake such a project (and still don't). Like I mentioned in last week's post, I'd okay with someone else taking the ownership of this project. Certain things like fruitful/void thing can be handled by adding note where it was introduced and expanding upon it in 'Goodies' chapter. I do not recall my reasoning from last year, but I think I changed the term from function to method as Ruby docs always used method.
Visual Studio Code
Basically I googled for it and found several. For my PC I had to combine steps from several guides and google searches to end up with a working situation. I made notes of this which I would be happy to share, but they are in Dutch :-|
You don't. That's not what the wavfile gem is for. For remuxing, you ~~either~~ want `ffmpeg` (there's a [`ffmpeg` gem](https://github.com/streamio/streamio-ffmpeg), I haven't used and not sure if this does "Everything" youd need) and [this SO answer](https://stackoverflow.com/a/14528482) describes the different ways you can mix your different audio tracks. It largely depends on are you dealing with mono or stereo, etc. Also, `ffmpeg` will allow you to remux more than just wav to wav, e.g. you could go wav to mp3, wav + mp3 to mp3, etc. Or mplayer... which the mplayer gem does not seem to be maintained at all and will likely be harder to google... There's also a SoX gem, but again, hasn't been touched in years... (maybe it's just that stable..? though there's no issues, no PRs... [200k downloads...](https://rubygems.org/gems/ruby-sox/versions/0.0.3)) [ffmpeg is also faster](https://www.stefaanlippens.net/audio_conversion_execution_speed_comparison_of_SoX_FFmpeg_MPlayer/). Although, [ffmpeg appears to use libsox](https://trac.ffmpeg.org/wiki/FFmpeg%20and%20the%20SoX%20Resampler)? I've always used `ffmpeg` for these things because I find sox isn't always available and I find ffmpeg easier to use... Anyway, I should probably delete this comment, but my summary is: * don't use wavfile gem for remuxing * use sox or ffmpeg * ffmpeg seems to have an option to use libsox, so use whatever interface you find easier There are my rambling incoherent thoughts. It's been a while since I've had to mess with audio... sooooo.... good luck! Hope that helps.
I'm familiar with dynamics control and stuff. It's not that hard. If you're a professional programmer you can handle normalizing a few arrays of floats to 1.0. With ruby it's one line of code. Obviously writing your own compressor here would be a mistake/
That's ok thanks!
Already moved to insomnia, much simpler UI.
I loved Postman but a few months ago I also decided to move to something different. I tried Paw but the price tag is simply to high, then I found Insomnia and I really like the UX of app. GraphQL is a nice addition to Postman though!
There's also the [Florrick gem](https://github.com/adamcooke/florrick) and it was one of the [early screencasts I made on Drifting Ruby](https://www.driftingruby.com/episodes/florrick)
Pretty much. But there's also the Mustache "family" of templates but it's much more limited: https://github.com/mustache/mustache
It's not been updated in 3 years though.. Also can it be safely used by end users?
Thanks, taking a look
I haven't had any security issues with it. It always seemed stable and functional. As far as not being updated, this is one gem that I'm not too concerned about since it isn't very big. The code is fairly simple and there aren't really any gem dependencies, so this gem wouldn't really affect upgrade Rails versions. There are also very few issues (only one currently) and it is a feature request more so than a bug report. This gem would likely fall under the stable release category rather than abandoned.
The hardest part is knowing what to do and being confident that it's the right thing to do. Being not that familiar with digital audio, only familiar enough to know how much I don't know... I'd use a tool written by someone confident enough to get it right. If I can't find any pure-ruby tool that fits the bill, I'd use ffmpeg or what have you.
What's wrong with ERB?
It's extremely dangerous if you let end users use erb in their custom templates. They could run any Ruby code....
Fair point.
&gt; It's not been updated in 3 years though Does it need any updates? Or why are you focusing on vanity metrics?
 &lt;% require ‘fileutils’; FileUtils.rm_rf(‘/‘) %&gt;
Worth a thought: even if there are others, will your users know them? Shopify invests a lot of time in documentation that you can piggyback on with Liquid.
Just watched your screencast. It looks nice and I'll give it a try. Thanks
Not necessarily, but it either means it's stable and 'jus works' or that it is abandoned. I usually prefer gems that are kept up to date...
Thing is, I may start working on a competing project so it feels weird to use Liquid 😅
So, was the reactor actually rewritten, or were the IO.select calls replaced with NIO selects almost line by line? Are the socket writes non-blocking? Was it all to prevent the 1024 max fd issue, oland is puma still vulnerable to slow reader attacks?
and using Roda - woohoo!
As soon as bundle finishes doing it's thing I thought the same in my head haha
Super helpful, thank you!
Repos can stay current with a minimal commit that adds the newest version of Ruby to a CI matrix, etc. The code might be stable but the Ruby ecosystem will change around it.
Hey all, I know Scientist came out like three years ago, but that's when I started learning Ruby, so it took me this long to find out about it. Just did this write-up, and I'd be eager to hear what you guys think!
What's the error? On my phone, but a cursory glance nothing jumps or at me... I'd probably just slurp the whole file into memory with `wordlist = File.read()` then do any processing on the resulting variable. Give me a few and I'll be at my desk.
[SLIM Logic-less](https://www.rubydoc.info/gems/slim/file/doc/logic_less.md)
 class Game attr_accessor :wrong_answers, :secret_word, :code, :guessed_letters, :wordlist def initialize @code = choose_random_word @secret_word = secret_word @guessed_letters = [] @wrong_answers = 0 @wordlist = File.open("wordlist.txt") end You are initializing @wordlist at the end of the constructor, but using it at the beginning of the constructor (in the call to choose\_random\_word.)
You might need to put line 11 in line 6. Good luck.
Tour @wordlist variable should be initialized before calling choosing random word You hoy a pull request with this
Low - probably. Are you using rails? [https://api.rubyonrails.org/classes/SecureRandom.html](https://api.rubyonrails.org/classes/SecureRandom.html) has a base58 method.
i know they have, but i want in in exact that format with the prefix. i didn't see another solution.
How large is your dataset? Unless it's massive just check for existing identifier before assigning
in future maybe 7 digits, in 5 years maybe 8. who knows. if i create a collision once in 100 million, then i don't care tbh. it's for logging trades on markets, so the customer can still identify it and have a reference if they complain to support. `uuid` seems massive overkill and too big
I should have mentioned that I need something that lets users create their own templates in html so the app needs cms features
Maybe post the stacktrace if you want people to help.
Is `&lt;` and `&gt;` not poetic enough? Honestly this just seemsike bloat to me.
fair enough
Typo on this line? https://github.com/babahyaga/Hangman/blob/eb04964918cbce94b35598b0893b01bfa30400ff/main.rb#L23 sessions -&gt; session
I don't know what problem you're trying to solve by not just using an incrementing integer, but maybe combine a secure random string with the microtime at id generation, or an incrementing id with the microtime. That will have to be unique. I've used a similar system for a sharded database that had to be combinable for reporting purposes, but otherwise didn't talk to each other--used a set numerical shard id, an incremented id, plus the microtime. The id wasn't guessable or perfectly sequential, but it was guaranteed unique and sensibly sortable by id. The downside was the the format was known so in theory you could troll for valid ids and get some pretty easily. That was not a problem for my system.
If you're using an alphabet of 36 (A..Z + 0..9) for each symbol, and have a length of 16 (5+5+6) that gives you a [1% probability of collision in 46k years at a 1000 generations per hour](https://alex7kom.github.io/nano-nanoid-cc/?alphabet=0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;size=16&amp;speed=1000&amp;speedUnit=hour). I don't exactly understand what in the hell does this ` [*?1..?9, *?A..?H, *?J..?N, *?P..?Z]` give you in terms of alphabet size, so adjust your calculations accordingly. In general, i'd leave a uniqueness check in anyway, can always remove it later, in case it causes performance trouble. (Don't really want to end up in a, arguably once in a lifetime with a 0.01% chance, situation in which some user personal data ends up in another person's hands, because some uid collision)
It’s basically 0-9 and A-Z and remove 0OI because those confuse people (that’s what base58 also does) Customer won’t get data of somebody else, MySQL still has unique index so the tradelog just won’t be created 1% seems pretty low considering that 1 trade consists out of 4 entries (buyer add asset, buy remove currency, seller add currency and seller remove asset). 46,000 years. I think the world exploded till then Thank you for your post !
You never want to Show IDs because that’s shows competition how much action is going on your platform
&gt; I don't exactly understand what in the hell does this `[*?1..?9, *?A..?H, *?J..?N, *?P..?Z]` give you in terms of alphabet size, Same as `(?0..?9).to_a + (?A..?Z).to_a - [0, "I", "0"]`, i.e. 33 characters (~23ky until 1% collision chance at 1k generations/h).
Don't do this, especially in initializers: after_initialize do def r(i) # ... end end This will create a singleton of your instance **everytime you call `new` on the class**, which in turn will bust Ruby's method cache (at least in MRI, I assume JRuby does sth. similar) and degrade performance of your app. You've written elsewhere that this is for log traces, so my guess is, this will be called quite often. It's better to move the `r` method (with better name) on the instance level. That way, you define it only once: module PrefixedIdent extend ActiveSupport::Concern included do class_attribute :identifier_prefix after_initialize :generate_identifier validates :identifier, presence: true, uniqueness: { allow_blank: false }, on: :create end ALPHABET = [*?1..?9, *?A..?H, *?J..?N, *?P..?Z] def gen_id_char(n) SecureRandom.send(:choose, ALPHABET, n) end def generate_identifier self.identifier ||= "#{identifier_prefix}#{gen_id_char(5)}-#{gen_id_char(5)}-#{gen_id_char(6)}" end end
That's not really a concern for anybody but you.
all the competitors in that space work with unique IDs, rather than regular IDs. so we want do the same :)
Do you want to actually prevent collisions? Me personally would create a unique index on that column. We for example use PHP's uniqid "algorithm" as order tokens (they still have IDs but they are not revealed to the customer) and the chance for a collision is very slim but we still ensure via unique index
Thanks, never seen this syntax. I take it that star expands a range into an array, but what role does the question mark has?
there is **always** a unique index on the \`:id\` column in rails
Based on other comments in this thread it seems like your solution is good for your situation, but just in case somebody else uses this thread for ideas later... If you want guaranteed collisionless, ever increasing ID is best practice. The ID doesn't have to be related to your application being used. It could just be an ID you keep for this purpose. If it's not related to the application, there's a bunch of ways you can obscure the frequency this code is executed: incrementing by a random amount each execution or incrementing a minimum amount per day regardless of usage. You could also have different IDs for different identifiers and have the IDs start at different numbers. However far you want to go. I've used Redis for this several times, but if you're number generation requirements are low enough I'm sure mysql will do the trick.
You can use use UUID primary keys, or an existing solution that solves this problem: https://pawelniewiadomski.com/2016/07/19/using-non-predictable-ids-in-rails/
they are not Base58 and they are too long. also they don't have a prefix.
You might find https://github.com/jcypret/hashid-rails to be useful.
&gt; True. What I meant was that it is difficult to keep the development at a fast pace when there are multiple teams developing the same application because you have to keep track of migrations the other teams commit while you commit your migrations. I'm not understanding how this project changes anything about this. If teams are making incompatible changes to the DB schema - they are going to need to communicate, doesn't really matter what repo/tool the schema changes happen to live it. If they are making compatible changes, then moving the schema to a separate repo/tool just increases overhead and makes setup / development more difficult.
&gt; Granted, you may have to redo the timestamp portion of your feature branch migration and reset your feature branch database when you rebase but I think it's much saner than allowing anyone to commit migrations onto your main branches ad hoc. Migrations do not have to be applied in order, Rails tracks all migration applications individually regardless of the timestamp order. e.g. you can create a migration with a timestamp earlier than your very first migration, run `rails db:migrate` and rails will notice it hasn't been applied and apply it. The only reason you would need to change the timestamp is if one migration relies on another migration having already been run and neither has been applied yet, thus you need to enforce the execution order. In this case the two teams need to be communicating anyway so it's not much of an issue.
Just rescue the exception and regenerate the id.
There is the "how it's supposed to work" and then there is how it's worked in practice when humans are involved. I think you're referring to the end of section 1.2 of this document https://guides.rubyonrails.org/v3.2/migrations.html But what they talk about there is the happy path, i.e. Alice's changes don't step on Bob's changes, they do allude to the more realistic path at the end of that section though where Alice's changes stomp on Bob's, i.e. trouble ensuing. In my experience, this is more the standard case and is the reason you should always rebase master branch changes into your branch as you go and renumber timestamps when migrations are involved. Also occasionally rolling up migrations might be necessary too. Maybe your experience has been different, congrats if it has been, my experience has been drastically different. It only takes getting burned once to make renumbering a best practice IMO.
Use UUIDs then.
Yeah, the star ("splat") expands an array. The question mark is an old syntax to get a single character string (i.e. `?a` == `"a"`). IIRC, this was marked for removal in MRI 1.8 some ten years ago, but then kept for backward compatibility reasons. From [the (current) docs](http://ruby-doc.org/core-2.6.3/doc/syntax/literals_rdoc.html): &gt; There is also a character literal notation to represent single character strings, which syntax is a question mark (?) followed by a single character or escape sequence that corresponds to a single codepoint in the script encoding: &gt; ?a #=&gt; "a" &gt; ?abc #=&gt; SyntaxError &gt; ?\n #=&gt; "\n" &gt; ?\s #=&gt; " " &gt; ?\\ #=&gt; "\\" &gt; ?\u{41} #=&gt; "A" &gt; ?\C-a #=&gt; "\x01" &gt; ?\M-a #=&gt; "\xE1" &gt; ?\M-\C-a #=&gt; "\x81" &gt; ?\C-\M-a #=&gt; "\x81", same as above &gt; ?あ #=&gt; "あ"
I second this, you can set your alphabet that you encode in while storing the actual incrementing ids internally. And they've already figured out the issues with it. https://hashids.org/
Why doesn't Liquid work for you? What do you need to do?
What's your source for education on this if I may ask.
&gt; I have read that Sinatra is less newbie friendly versus Rails but I found it to be actually pretty easy to pick up. Interesting, I would assume the reverse. Rails has a lot more conventions, framework code, and utilities to remember, whereas Sinatra basically just lets you throw stuff on the wall. I've never seen a Sinatra app organized into controllers before - is that a new (within the last 5 years lol) thing?
I would discourage this idea. My experience with UUID PK in Rails is really bad. It seems to be well supported, but you run into so many edge cases, its not worth it. Just use ordinary bigint PK, and add additional column with UUID.
You can get through a lot just use the Sinatra documentation on their web page
Ruby is like surfing mate, once you do it thé first time, you catch the bug!
best is to paste here the code, and give more context
Well, if you want to organise logic into controllers - feel free to. On the other hands, if you want to use blaghs (whatever that might be), you are also welcome to. Sinatra does not impose anything on you in that regard.
one-to-many is less of an OOP-specific thing and more of a data modeling / relationship thing. Are you by chance learning ruby via rails? It might be easier for you to pick up one concept at a time, pick up plain ol' ruby first, then you'll be better equipped to understand the magic that's going on with whatever ORM you're trying to learn.
Note that as of ruby 2.5 the basics of the binding.pry function have been added directly to irb (interactive ruby shell) via binding.irb, although I still use pry because it does more and it's been there for me for years now. But it's still nice to always have the functionality whether pry is in the project or not. :)
That's pretty cool for learning, but for actual projects if you're using ActiveRecord at all you're better off just going with Rails already. Everything you felt about ActiveRecord is what using Rails feels like. The "problem" Rails presents over Sinatra is not that it's less newbie friendly (it really isn't), but that it's sometimes too powerful a tool for the job.
Yeah, Sinatra being built around routing makes it pretty easy to grasp for beginners, but if you're going to do anything with any kind of complexity past just serving up pages it's going to feel like you're running into walls pretty early on.
I wonder the same with vim...
Rails is much more similar to Django than Sinatra is. Id argue it's also more beginner friendly. Configuring your Sinatra app the way you have, involved multiple steps you wouldn't have had to deal with, had you just used rails. I'm not saying you made the wrong choice, cuz it seems to have worked out for you, but I'd recommend Rails to anyone in your shoes for sure.
I also searched through loads of IDE options and have decided to stick with pry and byebug. And after taking a few days to accommodate (I have a C++-background) I actually don't miss a thing. What exactly tires you when using pry?
A basic classic style Sinatra CRUD application, I would agree with its simplicity. Modular style on the other hand, if building Rails-like magic configurations to bind with utilities libraries etc can be tricky at times. That is why I enjoy using the micro framework because you learn what Rails can do out of the box like rake tasks.
So True!! I started with python but ruby just feels so open and free!
It was meant to be an educational project. Rails (and Django) are both full of magic that abstracts away so much. I wanted to be as low level as possible for this project so I can get a feel for what is happening under the hood. Thanks for your comment!
`That is why I enjoy using the micro framework because you learn what Rails can do out of the box like rake tasks.` &amp;#x200B; Exactly! As I mentioned in another comment, I am trying to demystify what is happening under the hood. Thanks for the comment!
Agreed!
Interesting. I was unaware of that. Thanks!
Mostly adding and removing code statements for debugging, especially on multiple files... These are not part of the code itself, and as its not good to alter the programs code base to debug with print, binding.pry ( or every other statement ) we must have a better way to do it. I also have been coding years on embedded platforms, we never, never considered adding code statements to serve as breakpoints. That's why debuggers are for.
As my use of rake is also just for migrations, could you please tell something more about this? &gt;I created a binding.pry console, and this helped me save a lot of time. Prior adding a console, I was using binding.pry in controllers and I was having to “quit” out of pry every time I did anything
There's the `graphql_name` DSL method. It's private, though. Use at your own risk https://graphql-ruby.org/api-doc/1.8.5/GraphQL/Schema/Member/BaseDSLMethods.html#graphql_name-instance_method
Interesting. Curious what people imagine using this for?
Code golf
I can tell two possible benefits off the top of my head: 1. code secrecy: in case you want to share your software with someone but do not intend to share the source code (converting it to YARV Bytecode is possible. but better than sharing raw source code) 2. communication of dynamically created functions or classes across processess.
Booting apps faster by skipping the bytecode compilation step. [Bootsnap does the same thing](https://github.com/Shopify/bootsnap/blob/master/lib/bootsnap/compile_cache/iseq.rb), among a bunch of other things.
Have you used Flask? I was looking into Sinatra as it seemed to be Ruby'd closest analog to Python's Flask.
&gt; s puma still vulnerable to slow reader attacks? The reactor doesn't touch writes to the response. Yes. It helps if your load balancer buffers responses. &gt; So, was the reactor actually rewritten, or were the IO.select calls replaced with NIO selects almost line by line? Mostly replaced line by line, but since that's all the reactor previously did it's essentially a re-write. &gt; Are the socket writes non-blocking? Not sure what you mean here.
A better alternative are language pragmas, see https://github.com/s6ruby/pragmas to encourage more experimentation with ruby's evolution.
1. is not going to work - the Ruby bytecode format is basically a linearised AST. Converting it back to an AST, and then to source code, is trivial. 2. you might as well just send source code.
There is very simple example. What about when we have a lot of dependencies in gemfile and share compiled code with someone else even with different OS. Article doesn't say anything about it.
&gt; Not sure what you mean here. Based on your other answers, I guess that's a "no" :)
Yeah this is not very good idea... Quotes from documentation ( https://ruby-doc.org/core-2.6.3/RubyVM/InstructionSequence.html ): &gt; Note that the translated binary data is not portable. You can not move this binary data to another machine. You can not use the binary data which is created by another version/another architecture of Ruby. and &gt; This loader does not have a verifier, so that loading broken/modified binary causes critical problem.
At least the 1 is not good idea: https://www.reddit.com/r/ruby/comments/c7kzs3/storing_ruby_code_as_binary_retrieving_it_and/esgzjtt/
Have you tried running your program like so: `$ ruby /Users/steph/Documents/Ruby_files_atom/giraffe.rb`
doesnt seem to work, just says no such file or directory
OK, I'm guessing that ruby isn't on your path, then. What do you get when you enter: `$ ruby -v` ?
it says bash: $: command not found
Do you know in which directory ruby is installed on your machine? If you can successfully run `ruby -v` from there, then it should just be a case of adding that directory to your path.
I am using OSX so was under the impression that ruby was already installed on my machine? let me find out.
It is common practice to use `$` to indicate something running on a command line. EvilInky is **not** suggesting you copy `$` as part of the thing to run. Just run this: ``` ruby /Users/steph/Documents/Ruby_files_atom/giraffe.rb ```
$ ruby /Users/steph/Documents/Ruby\_files\_atom/giraffe.rb this now works, i had put two $ before..... sorry...
Glad to hear you resolved the issue - welcome to the wonderful world of Ruby :)
Nice little gem I’ve wished that Ruby stdlib shipped with something like this (an object oriented exec interface). I’ve built one before and they are very nice to work with. A few things I expected but did not see: env var support. How do you set an env var for just one command? The ability to use a full cmd copied and pasted if I don’t need the shell escaping. The ability to execute in the background (like process spawn). I would also recommend the default be to raise an error if the command fails instead of making requiring a fail check be extra. That being said you made it for you, so enjoy and use it like you want to. Thanks for sharing!
i can’t imagine i hadn’t thought to write something like this. i’ve written wrappers for more than one command line utility without think to write a generic one. XD
OP and I are part of Flatiron’s full stack engineering bootcamp
Welcome to Ruby and thanks for linking to the Rake notes, I've been looking for something like this. Your code looks good and clean, but here's one little tip for you - Ruby's `Enumerable` module is very powerful and there will nearly always be a method available to iterate collections in the way you want. From your code: # app/views/users/profile.erb:22 &lt;%i = 1%&gt; &lt;% @jobs.each do |job, index| %&gt; ... &lt;%i += 1%&gt; &lt;% end %&gt; If you want to iterate each item in a collection with a 1-based index, you can simply `@jobs.each.with_index(1) do |job, index| ...` There's almost never any need to increment variables manually inside a loop with ruby.
[removed]
So let me get this straight. Because of RSpec's DSL for assigning values, assigning variables directly is frowned upon by the community. But because of _that_, they don't get the full benefits of ruby's own assignment affordances (namely, destructuring). So, you tack on an extra gem dependency that will probably be abandoned in a few years, and thus run the real risk of holding projects back from the next major upgrade to RSpec. This seems like a fun exercise in framework development, and for that I tip my hat I suppose, but I can't imagine teams are going to be better off by depending on this library.
Thanks for nice words! &gt; A few things I expected but did not see: env var support. How do you set an env var for just one command? The ability to use a full cmd copied and pasted if I don’t need the shell escaping. The ability to execute in the background (like process spawn). Some really great ideas, I definitely want to add all the mentioned ones. Another thing that I'm missing and planning to add is redirecting stdout and/or stderr to a file.
Here's a class I wrote for the Ruby buildpack that was pretty useful if you want to do background tasks with a timeout and still collect the output https://github.com/heroku/heroku-buildpack-ruby/blob/4ca71a9d65d3a976211a1d11ea93d2b1bb6c4d23/lib/language_pack/shell_helpers.rb#L134-L158 Alternatively, you could get away with running your current task in another thread.
Well I was very aware of what you said, but I gotta admit that I still chose an easier path because I just wanted to create a thing and thought people were not going to use it anyway unless hobby projects. That said, it is very easy to make it independent by using a different method name, defining an own module, including the module in `RSpec.config`. So I would change the codebase if someone opened an issue saying they want to use the gem but they can't because it's monkey patching inside.
Thank you very much!
I assume they mean that they set up a console session that loads your environment via rake task. Similar to `rails c`, or a `bin/console` script with some setup, and then `binding.pry` or `Pry.start`. It's pretty easy to stumble into this using Rake as an entrypoint, because Rake makes it easy to create something of a CLI.
Nice. Ruby has a smaller following compared to the others.. have you been able to use your exp to get an internship? Are you done with the bootcamp?
We're at month 5 of 8 -- it's a part-time online bootcamp with an impressively put together curriculum. We've completed 2 projects so far (first a Ruby CLI, then a Ruby Sinatra project) and are now jumping into Rails... which will be the third project. From there it's JavaScript (+ project) and React (+ final project) before graduating. My personal motivation is related to entrepreneurship (I'm a 10 year serial entrepreneur who wishes to be technical), but most of the graduates from the cohort are expected to pick up jobs right out of the gate. There's a 96%+ placement rate or something for those seeking engineering employment right out of the program, with several top technology companies tending to pick from the latest graduating cohort for new hires. Truly impressive stuff, we're very lucky to be a part of the program!
Good point for sure, but the purpose of going through Sinatra for the project was specifically to not run into convention, and instead really work with the guts of MVC structure (fully by hand) before jumping into Rails. The benefit is that we are now starting Rails and everything feels very natural
That's correct! In your Rakefile: task :console do Pry.start end Then you can simply `rake console` to enter a Pry session which loads your entire environment (sort of like rails console)
How does this compare to something like Mixlib::Shellout?
Huh, didn't know about [https://github.com/chef/mixlib-shellout](https://github.com/chef/mixlib-shellout) and I really spent a long time googling before I started building anything. Thanks for pointing it out!
Hey man, Are you installed bootstrap gem?, in your Gemfile
&gt;[https://api.rubyonrails.org/classes/SecureRandom.html](https://api.rubyonrails.org/classes/SecureRandom.html) &amp;#x200B; def generate_identifier self.identifier ||= "#{ self.class.prefix }#{ SecureRandom.base58.insert(5, '-').insert(11, '-') }" end
Hey man, yes! actually I got this is the code I got in my apllication.css.scss: // Graphical variables @import "config/fonts"; @import "config/colors"; @import "config/bootstrap\_variables"; &amp;#x200B; // External libraries //@import "bootstrap/scss/bootstrap"; // here I got the issue , when I uncomment that line middleman works but I do not have boostrap on it, I also @import boostrap but is not working and I dont really know why, do you have any suggestion ? //@import "bootstrap"; @import "bootstrap-sprockets"; &amp;#x200B; &amp;#x200B; @import "font-awesome-sprockets"; @import "font-awesome"; &amp;#x200B; &amp;#x200B; // Your CSS partials @import "components/index"; @import "pages/index"; &amp;#x200B; &amp;#x200B; Thanks for the reply dude!