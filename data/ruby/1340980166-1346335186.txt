Did you tried to use Fabric (http://docs.fabfile.org/en/1.4.2/index.html)?
I've used raphael before on a rails project and it went fine - raphael is a javascript library so it won't really be touching the ruby (Except you need to get values from ruby to javascript). In a haml view from the project: :javascript var datax = #{datax} var datay = #{datay} var r = Raphael("#{title}-chart", 860, 180); var line = r.g.linechart(0, 10, 860, 160, datax, datay, {gutter: 1, shade: true, colors: ["#8db086"], smooth: true}); 
Try my remote-session gem! https://github.com/joeyates/remote-session The Remote::Session#sudo command does more or less what you're after - it opens a sudo session and runs a number of commands. The main things I did to ensure sequential interaction worked was to set the command prompt to something unique and recognisable, so I could monitor for it being returned. 
Our biggest developers conference is probably Strangeloop but I think we would really benefit from having a dedicated Ruby conference. What do you guys think?
&gt; Without #real, over time, you will receive errors regarding complex numbers and the score attribute I'm curious to see an example where this happens, given this specific expression. In ruby 1.9 numbers inherit from Numeric and Numeric#real returns self. It's only Complex#real that returns the real part, but afaict there's nothing in this expression that'll result in a Complex type. &gt; Have you tried your (:&amp;score) suggestion? Yes, I use this idiom quite frequently. It should produce equivalent results to collection.sort_by { |resource| resource.score }. A common mistake is to forget the ampersand ("&amp;") and just use a Symbol, which is what the grandparent's example does. Maybe that's what happened when you tested it? &gt; Our attempts to use (&amp;:score) stem from developing with Rails/AR. Sinatra/DM is different. I'm quite familiar with DataMapper. I'm the maintainer ;)
STL represent. 
I gave (&amp;:score) a try. This does not work. Are you trying this suggestion out? Regarding #real, I have no test case on hand. In the course of development the error occurred, adding #real solved the problem. I plan to have another iteration coming soon with production code. You can remove #real and I would expect this error to reoccur after some light use of the app. 
This looks very promising. I will check it ASAP.
Dynamically interacting with commands I can live without. The problem I had with execing bash was that I couldn't get to the output (and do any decision making) until the shell terminated. In other words, if you run: exec bash send_data sleep 5\n send_data ls\n send_data exit\n The channel callback was only called once the exit terminated the shell. This very well may be due to some stupid error on my end. Anyway, it looks like the remote-session gem does exactly what I need. Thanks for the help though. 
Registered, I would definitely love this.
The learning curve might be prohibitively steep, but configuration management tools like Puppet or Chef are specifically designed to let you poke and prod remote systems. http://puppetlabs.com/
&gt; I gave (&amp;:score) a try. This does not work. Are you trying this suggestion out? Here's a program that shows how it works: require 'rubygems' require 'data_mapper' DataMapper.setup(:default, 'sqlite3::memory:') class Link include DataMapper::Resource property :id, Serial def score id * 2 end end DataMapper.finalize.auto_migrate! 2.times { Link.create } puts Link.all.inspect puts Link.all.sort_by(&amp;:score).reverse.inspect __END__ [#&lt;Link @id=1&gt;, #&lt;Link @id=2&gt;] [#&lt;Link @id=2&gt;, #&lt;Link @id=1&gt;] I included the actual output at the end of the script. Feel free to try it out yourself.
What's the advantage (if any) to rbenv over RVM? Nevermind, I'm an idiot and could just look at the readme: https://github.com/sstephenson/rbenv/
sqlite3 is already installed by default, is it not? (been so long since I've set up Ruby on my Mac that I don't remember)
Oh... you know it may be. It's been a while for me too.
[railsinstaller](http://railsinstaller.org/) has a OS X option now. Pretty easy.
&gt; Step 3: Databases Holy. Shit. Don't do that.
I've been in dependency hell even with bundler before. Gemsets are awesome, and a great way of quickly eliminating environmental problems as you can quickly blow them away and start anew.
I'm in Cape Girardeau, but I could come up for a Ruby conf. Also, I've cross-posted to /r/StLouis for you. :-)
I'm talking about the Rails.app kickstarter and similar projects.
The *Right Way™* to get non-developers into ruby/rails is teaching them the basics, which includes what tools they will be using and how to install them. This may not be the best guide out there, but it's a step in the right direction, unlike the Rails.app idea.
I hope you also posted this in /r/rails.
Probably should Rails-specific links to /r/rails; unless it also touches on deeper Ruby topics. I would pick /r/rails over /r/rubyonrails, since they have more subscribers and bothered to set an icon.
Some who are new to developing on rails may just say "Well, why not install all of them?" and not realize they won't be using all those packages together, probably ever. If they install correctly, I guess it couldn't hurt too much aside from disk usage and having more processes running, but if they run into any issues the install process will become much more frustrating.
Doesn't give you rockstar ninja status in interviews for the next best social media startup. 
I highly recommend just using Ubuntu or the like in a VirtualBox VM for development. Use VirtualBox's port forwarding to get to it. It's way more portable and you can keep your Mac free of gunk because, let's face it, Apple likes systems to be "just so". You also have the added benefit of running it on your prod OS... unless you deploy on OSX. I'd be surprised if you do, though. I've seen enough weird differences between EXT3/4 and HFS+ f'ing up apps on deployment in orgs that don't stage or QA on their production environment. 
 http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/ http://www.codinghorror.com/blog/2012/06/the-php-singularity.html
Me? I wasn't being sarcastic, I believe this is much better than a unified installer.
Check out the github link. https://github.com/Exvo/amfetamine
"unless maybe you have multiple apps that are interconnected" &lt;- this! Also, you don't need to dedicate a shell window/tab/pane to running your web server. It's always available.
Let me know what you think!
I guess you'd still have to dedicate a shell to tail -f log/development.log though.
 Link.create(:title =&gt; params[:title], :url =&gt; params[:url], :created_at =&gt; Time.now) could easily become `Link.create params` if `:created_at` had a default value (`:default =&gt; Time.now`).
Recommendation: ditch the number on voting actions, it's not variable at this point. The controller action should be updating scoring more like one of the following: link.vote(:up) link.vote_up then push that logic into the model. A controller doing mutating arithmetic on a model attribute is a smell. It also lets you deal with atomicity in a better spot when you get there. Also, it makes the code in your controllers more explicit and readable. 
Not a bad idea. I was hoping to expose some things without having to write accessors for each one though. For example, in-game objects could use width and height to stay in bounds without revealing too much about themselves to XXXScreen classes.
Then you can selectively use delegate on those property. 
Because explosions.
Thanks @aesnt, @danneu also helped me realize this. I changed the title and clone of repo 1.0.x. Would you say that the change is sufficient in helping readers understand what the post entails? 
Hi jhawthorn. Someone suggested this in the first post. I tried it before and now, it does not work. No sorting occurs. If this works for you, please let me know. I am very interested in why no sorting occurs. **Edit:** @jhawthorn's suggestion does work.
Yes, it works, I can see no reason it wouldn't. if you're having trouble getting something like this working (or even if you aren't), you should invest in some test cases so you or others can very quickly see if a problem does indeed exist.
@pax7 Exactly! `Link.create params` is bad because of the mass assignment exploit. I missed @waxjar's recommendation of `Link.create params`, I generally agree with `:default =&gt; Time.now`, although `dm-timestamps` OneUps that suggestion too. I'll edit my response to not give the wrong impression. Thanks! 
Ah, you're right :)
Class methods and instance methods are the same in Ruby. You can override new on your own class and super to your base class's new just like you would with an instance method. https://gist.github.com/3028855 Also you may want to consider bascule's comment too. Generally composition is more flexible than inheritance. If you decide to go down the road of mixing your stuff into SDL::Surface directly then make sure you do it via a module instead of just opening the class up. It provides a trail of evidence (Object#ancestors) to see who mucked with a class in the future.
&gt; RVM is better suited for developers who need to test against multiple versions of Rubies, not developers who only need one Ruby. Odds are, if you are a ruby developer you'll _eventually_ need more than one version of ruby. It's much easier to go from RVM with one version -&gt; RVM with multiple versions than it is to go from system repository ruby -&gt; some way to get multiple versions.
I like gedit, but I still prefer vim over it.
If you are a student or setting up a server, you probably only need one Ruby. Also, Fedora and Ubuntu provide JRuby packages.
I'm not sure what you mean? 
You're doing a read-modify-write ostensibly without any form of locking, in which case multiple clients voting on the same item at the same time will [interact unpredictably](http://en.wikipedia.org/wiki/Race_condition). e.g. 2 clients vote on the same link, one possible set of operations could be: 1: l= Link.get 1 # =&gt; {points:1, ..} 2: l= Link.get 1 # =&gt; {points:1, ..} 1: l.points + 1 # =&gt; 2 2: l.points + -1 # =&gt; 0 1: l.update(points: 2, ..) 2: l.update(points: 0, ..) In this case one upvote and one downvote gives you a link with a score of 0, ignoring the upvote. If client 1 was slightly slower and updated last it'd have a score of 2 ignoring the downvote. You'll only get the expected behaviour if you were lucky and client 1 completed its update before client 2 fetched the record.
That's true, and I definitely wouldn't need a tutorial to tell me how to install some databases
Very strange. I can't find references to that im_a_child in the rubysdl source anywhere....wtf. Anyways, my *guess* is that something's going on where Surface checks if it is being subclassed and expects that method to exist on children for some kind of side-effect. If so, that's pretty shitty. But I really don't know because I can't find it. I checked the latest version, maybe that's why. Either way, good luck!
For even more awesomeness, use vagrant to manage those VMs with chef or puppet, or even just a script if thats more to your liking.
true that
Learn by counterexample; that's how I phrase it, anyway.
Great responses- thanks guys!
I'm personally okay with that. If I need concurrency beyond the natural request/response cycle or websockets or any of those new things I need to make Yet Another Web Chat Room, I can go pick a technology that is well suited for that. As it is, Rails hands me a super productive stack to do most any basic/moderate web application. If they add those other things and keep the simplicity that Rails/ActiveRecord/etc. has, I'll happily use them. Until then, I'll go use whatever is the best tool for the job.
It was more impressive in 2005, i.e. before other frameworks caught up. Anther big part of the allure was Ruby itself. I stuck with Ruby (for a lot more than web dev) but use Rails less frequently these days. I like Sinatra for most things now as I tend to prefer to assemble things out of smaller parts than use a large framework. But sometimes Rails is still the right tool for the job. If you pull in ActiveSupport and ActiveRecord that's a good sign you should just use Rails.
Aaron Patterson said they are looking at concurrency and streaming, amongst other things, for Rails 4.
I absolutely love Rails routing. I think it is one of the best features of the framework, and makes building a restful application much easier.
So basically gem up parts of your rails app for reuse in the bolted-on-framework? I find maintenance of hacks like this to be way too much glue. It can also be too abstract/meta for new developers to pick up. It can work though. Did you have some other idea?
Right, but I used to like having the option of doing that only on my production instances with jammit, especially since we'd CDN all JS and CSS only on production.
Check out Destroy all Software and Objects in Rails.
I love Rails because I love Ruby. If it was written in any other language, I wouldn't be as excited about it.
Rack and Thin/Unicorn are the reason Rails does not support websockets. Rails3 is supposed to focus more on Concurrency. I find it sad that it's taken so long to enable multi-threaded mode by default. I suppose having to support MRI 1.8.7 held things back.
Newcomer? *blink* O-kay. /rant on On a serious note, I'm afraid your attitude is not helping arrange these things. Dev pride in their craft is wonderful, but it NEEDS to subsume to the greater needs of the dev community. The Ruby community has actually done WONDERFUL work so far, with the likes of rubygems (hey, open-source website that actually holds the gems), bundler, rails, rake, test-unit/minitest -- and, to some extent today, rspec (I'm not judging, just saying that rspec is now very widespread). And then you have the fringe Ruby stuff. And people, instead of focusing on a behavior they want, which makes sense, and can be accepted and universalized, decide they can implement their own damn thing better because they don't understand this concept. Mind you, sometimes it's the creator of the first solution who's an asshat. In that case, it might be very justified to make your own. .... Though I bring your attention to Tim Pope, who is most definitely an asshat, but an extremely brilliant, intelligent one, very witty and funny, and who wrote some AMAZING vim plugins without which Rails development on vim would just not be reasonable. Your attitude is not helping because you are just accepting this, instead of working to bring the community together by encouraging people to communicate and bring their minds together to discuss and create a better solution. /rant off.
I love how Rails really thinks of actually getting things done and production deployment. * `form_for` will give me that hidden 'utf-8' character to force old version of IE to always submit data as UTF-8. * `form_for` will gives me CSRF protection. * Bundler gives you the same environment when working in teams and reduces error between development and production environment. * Flash session. * Mailer * Rake task * Migration - How do I ever did development in team or migrate live data before this? * JS/CSS asset pipeline - You probably need this in production. * Builtin Cache concept - You probably need this in production. * (Soon to have) Queue Other frameworks can do many things Rails does on initial development. But not all of it will think of all those little features or those boring production stuff for you (utf-8, seeding, rake, migration, caching, assets, etc.). In other word, Rails is not just "development" framework, it is a "web application" frameworks that really gives you guideline from setting up environment, development, testing, deploying to upgrading/migrating data.
Help me understand... How does that make my code more clear and concise than using a conditional in the beginning of the method?
That's an interesting idea, but I feel like it goes against a lot of things that make Ruby very powerful - like, say, duck typing, and so forth. With Test-Driven Design, you can generally ensure that your code will ... Work. Ruby has an endoskeleton: the hardness is on the inside. Languages like Haskell have an exoskeleton: the harness is on the outside. Why are you trying to create an exoskeleton for Ruby?
Wanted to try the first line in console and got this: "applestranslation missing: cs.support.array.words_connectororangestranslation missing: cs.support.array.last_word_connectorpears" I know why it didn't work, and I even fixed it in the meantime, but it revealed how this method works and I found it funny.
Play developer here, I like rails routes better than Play's.
I think this is the one. On OO patterns. https://www.destroyallsoftware.com/screencasts/catalog/conflicting-principles
he's demonstrating that use of `Proc#binding` inside the callee can have unexpected and weird effects on the caller
Rails4 is also dropping support for MRI 1.8.7 and enabling multi-threading by default.
I'm having a hard time invoking this on my iPad. What were those effects, and why weren't they expected? Thanks
It was Rails that got me into ruby, and now I use Ruby for all sorts of non web things as well. Ruby is really great for doing web screenscraping, talking to WebDAV servers and all those things I used to do in perl. Sinatra is wonderful for simple webservices. Rails is great for all those little gems that is so wonderfully integrated into it for doing things like oauth authentication, s3-storage and so on.
A slightly faster, clearer example. [http://pastebin.com/UkrfbWiG](http://pastebin.com/UkrfbWiG)
Why is this not the expected output?
@dkubb I am in the process of forming a question for stackoverflow about how to fix the possible race condition. Are you saying that moving the up/down code to the model will resolve this? 
Would this prevent race conditions? 
So what is not expected here? 
I gather by the OP's comment, they are expecting that `b.should eq(1)`.
See also; http://egonschiele.github.com/contracts.ruby/
I was just looking for a different approach, sometimes it's fun to just try new things and see if they actually fit or not. It was also a good excuse to try and write a gem, which I had never done before... And regarding your comment about the idea going against "Duck typing", could you elaborate a bit on that? I don't see it really. Thanks for the comment :)
Hey, it's a pretty simple example, but if your method is called: "do_your_thing", but there are 2 ways of "doing your thing", instead of having the conditional inside it, and both ways of doing "your thing" inside it, you can separate that behavior into two different methods, and let the gem know when to pick one or the other...
Which is a weird thing to expect, considering that he explicitly try to evaluate the code in the binding of the block. 
See: Yii, CakePHP, Lift, Play, Grails, Django, etc. I'm not saying there's anything wrong with them *per se*, I've just found them all to be very clunky without Ruby. I'm sure if I was psyched about their underlying languages I would be all over them.
awesome, much appreciated.
Well, actually vim and emacs are really powerful. I wouldn't trade my emacs for Eclipse or Netbeans.
I'm poking fun at the rampant wheel-reinvention in the Ruby community, not accepting it. And I'm one of the people who fought to get the Debian packaging team to work with the Ruby developers. So I don't _only_ joke about it; mockery is merely one of the services I provide.
I'm getting upvotes?! I was being sarcastic. A typical Rails installation is a little difficult. Each time I've done it the process is different. There are a number of needless hoops to jump thought. I wish that whole "Convention Over Configuration" philosophy applied to the installation process. I get a number of mismatched versions. I gave up trying to write the process down, it just changes too often. At one time the below command worked, but not anymore. sudo apt-get install ruby-full build-essential rubygems apache2 &amp;&amp; sudo gem install rails &amp;&amp; rails hello &amp;&amp; cd hello &amp;&amp; rails generate controller hello &amp;&amp; rails script/server &amp;&amp; wget http://127.0.0.1:3000 -o -
Stop looking for "awesome" and simply try to find someone who knows his shit.
Well - duck typing was just one example. You can build preconditions and postconditions that work with duck typing, if you deal only with things like data structures and such - but I feel like you're building type safety for Ruby, in that case.
It's a forgivable mistake, no? Your average Google search will recommend using the system package manager. I've had mountains of trouble (even in 2012 on Linux).
In order to find an "awesome" developer you'd better have some very interesting projects technology wise, and good cash.
Post to reputable job boards. Trust your gut, get references. Do a 'trial period' where the prospect completes a small contract. Ease in to the relationship and feel it out. And if you're looking for a hand with any dev work, send me a message :)
Go to the Ruby/Rails developer meetups. I was going to say that as my answer anyway, and then you said in another comment that you're in Austin, where I live and know first-hand that such meetups exist. [Austin on Rails](http://austinonrails.org/), [Austin.rb](http://austinrb.org), [Austin Ruby on Rails meetup](http://www.meetup.com/Austin-Ruby-on-Rails).
jobs.rubynow.com and the 37signals job boards would be a good place to start.
Lots of companies seem to know the value of a good developer but they still want them at a discount. Treat them professionally--give them an office, respect, and pay them well. Entrepreneurs think that an MBA and an "idea" entitles them to 95% of their tech company and that they can give a sliver to the people who execute and make it happen. Remember that Mark Zuckerburg was a developer, he made it happen. The "twins" were shit-talkers and salesmen. What did they really do?
If this position is critical to your business then get ready to pay, a lot, for a seasoned ruby dev. Also, keep your expectations realistic. You are not going to find that guy with 5 years of RoR experience who will work for 65K-85K in a cubical all day pumping out features. If this position is critical to your business then I suggest going to the Austin Ruby on Rails meetup http://www.meetup.com/Austin-Ruby-on-Rails/. Let them know you have a position and you are willing to pay top tier prices for top tier people. Make sure you have the hiring power and ability to discuss pay because most ruby devs I know are contractors and are not scared to talk money up front. You need to be prepared to answer them when they ask what you are offering and you need to be able to have the power to negotiate. DO NOT go to a recruter. If you are considering this path then just hire some guys out of india. You will get the same quality dev for a cheaper price. Also, buy two ruby devs; they work much better in pairs (trust me on this, your product's quality will increase 10 fold). Also this: http://jobs.37signals.com/
Hey...wait a minute... we're an Austin based startup looking for rails developers too! I actually heard that Chicago is where we'll find a ton of skilled rails devs. Odd... but hey. Alternatively, have you checked out the AustinOnRails scene? -daftstar p.s. don't buy speakers out of unmarked white vans ;) 
My idea was not necesarily focused on type safety, you can do that, yes, but you can do much more. Did you check out the samples on the git repo? In here you implement a validation similar to what AR does: https://github.com/deleteman/Conditionator/blob/master/sample/sample-validation.rb and here: https://github.com/deleteman/Conditionator/blob/master/sample/sample-failsafe.rb you control the flow of the program, without checking for types anywhere....
&gt; Also, buy two ruby devs; they work much better in pairs (trust me on this, your products quality will increase 10 fold). I was recently looking for RoR work, and I turned down a position primarily because I would have been the only RoR dev on staff. I am not alone in feeling this way
"Good cash" can be replaced with "willingness to trust a remote worker". The less cash one has, the more ~~timezones~~ kms away (from the USA) the awesome devs are (and there are plenty in central/eastern Europe for example). https://37signals.com/svn/posts/3064-stop-whining-and-start-hiring-remote-workers
Thanks for the nice write-up!
Favor composition over inheritance. GameScreen can delegate to a surface.
I love how the only time anyone ever uses `block.binding.eval` is to point out how it's broken. I worked a bit on the Rubinius code for this and most of the problem was in trying to make it duplicate the pathological MRI behavior. Please, just don't use it. There's never a good reason, ever.
If you're in Austion, go to the Austin On Rails meetups and talk to Damon Clinkscales, the organizer. He's very well connected in the local community and can help you network with some quality developers. Just be prepared to compensate appropriately for the level of experience, responsibility and risk exposure that you are looking to hire into.
The best devs I know have next to nothing on Github. The vast majority of their work is owned either by their employers/clients, or by their own startups. If you want to know how someone codes, make them write code during the interview.
Well, the obvious difference is the ability to use private GH projects.
Don't forget non sequential.
This. This is how many of the RoR companies in Pittsburgh recruit because it's such a strong, tight-knit community.
Anything that moves the logic away from the point of execution only makes behavior harder to understand. This is also, f.e., why ActiveRecord callbacks overuse tends to produce spaghetti code. I appreciate the attempt to introduce a design by contract style, which can be quite valuable, but I really, *really* don't like the indirection and non-locality.
Ruby devs are like Alpacas. You can't buy just one, or it will die of loneliness.
Hm, I've got a problem from other side of barricades: I'm Ruby developer with 3 years of experience, strong skills in design, UI and administration of Unix systems and skills in Erlang, C and Go programming languages. Also I have some number of Open-source projects. And I want to find some remote job in English-speaking country. As I see a lots of experienced and smart people here, I'm asking: what I need to do? 
I only outsource to the philippines (from america). cultural distance is much more important than actual distance. 
You guys have been a tremendous help. Great information, Thanks so much!
You know, that makes sense. I was deceived by all the optimistic Santorum comments. I've been thinking a lot recently about how lucky we are as Rails devs these days, but how quickly this can change. As you say, ask a fortran dev. 
Personally, I'd advise you head hunt. That is, find developers who you specifically want to employ. Rather than casting a net, instead you aim and fire. However, that's quite tricky and you might not know anyone, so.. I run a 15,000 strong Ruby e-mail newsletter - Ruby Weekly - which.. includes jobs each week. An ad is $129. It's very popular (we have a backlog) and our recent advertisers include Apple, IBM, Zendesk and AT&amp;T. These ads also make it into digests on Ruby Inside shortly thereafter. Another site called Top Ruby Jobs also seems to be quite popular (it's run by the Envy Labs/Ruby5 folks).
I'll keep playing with [TDDium](https://www.tddium.com/) until these guys have a more complete offering, then I'll look at it.
In some cases you might find that it is easier to find talented developers that can learn and just teach them Ruby on Rails through pair programming. The allure of San Francisco and New York are hard to beat in some areas so you might have to train your own Rails developers to have more Rails developers in your area. Of course, this is all dependent on having existing high quality Rails developers though.
Thanks @dkubb
Just this, the very fact that you can execute arbitrary code in the context of the block's binding is kind of a weird feature. Not many languages support it, probably for the reason that it can create really weird coupling between caller and callee similar to a general [binding of caller](https://github.com/banister/binding_of_caller) implementation. I don't think anyone is saying it's surprising (though unexpected changes to locals could 'surprise' the caller) -- more that it's an odd language feature.
That's not going to be a difference for very long...
http://blog.headius.com/2008/08/qa-what-thread-safe-rails-means.html The GIL is overhyped. A Global Interpreter Lock only prevents threads from running simultaneously across multiple cores. Even with a GIL, threads can still be used to encapsulate IO bound operations that block. Python also has a GIL, which doesn't seem to hinder it's performance too much.
What is a compelling reason, maybe a specific use case, where Mechanize is preferable to using Capybara?
Feel free to drop into the #datamapper IRC channel if you ever want someone to look over your code. There's a good community and good people there. The only thing is the channel is not #rubyonrails, so it may not be active 24hrs a day. If no one answers your questions hang out for a bit and someone will respond. They may even leave you a memo using our bot and memo system.
That is why I called blocks "damned": its binding is not very useful, but binding makes block so heavy weight and hard to implement right.
Well, it is "explicit" for you, cause you see both methods at same time. Imagine, that `def a` is placed in another file (other directory, inside of numerous gems). And after all, it is not about side effect, but about amount of hard work for implementing heavy weight feature hardly tighten with most useful language construction, which (feature) is used only for implementing templates!!!!!! Every time you create a `proc` (using `def a(&amp;block)`) your runtime pays for templates need. How mush time your program spend in ERb? How many times you use proc? My program does not use ERb at all, cause it backend. But it still ought to pay for ERb needs. ERb should to be implemented in other more lightweight way, so that block has no need `binding`. (excuse me for my english)
The bindings are actually pretty simple since the interpreter has to keep track of the stack frames anyway. The thing is that MRI's binding.eval is just *so* fucking broken.
Sorry - fixed!
The association we had in mind was the traffic semaphore. Some people actually use it for for CI :) http://urbanhonking.com/ideasfordozens/2010/05/19/the_github_stoplight/
the best devs I know do open source, or contribute to a ruby community. they may not be the best coders, but they have clear passion, interests and good values.
be clear about what your project is. many developers want to work on a particular field, keeping it secret and stealth is not a good idea, unless you have millions of VC capital. Sharing your idea is important, keeping it secret loses all outside help. the value of an idea is in the executing of it, not in the knowledge of it.
&gt; Interpreter hash to keep track stack frames anyway. Well, I could save block into some callback queue, which does not need for any stack frames of proc. But binding will be stored with block, and will capture all variables, including that I don't need at all.
&gt; Imagine, that `def a` is placed in another file (other directory, inside of numerous gems). So just like other functions? Some function can erase your entire hard drive. Documentation exists for this purpose. &gt; Every time you create a `proc` (using `def a(&amp;amp;block)`) your runtime pays for templates need. How mush time your program spend in ERb? How many times you use proc? Good JIT runtime/compiler can always optimize away unused bindings. 
spelling mistake on first sentence, "scrap" should be "scrape"
Ok, thanks. I'll work in this direction. 
Thanks for the heads up! :)
I'm the author of the articles linked to here, so feel free to ask me any questions about Practicing Ruby or these manuscripts in particular.
I've used Mechanize in every one of my Ruby projects over the last 2 months. I love it. I have to automate a bunch of web tasks that don't have an API and Mechanize makes the entire process so straightforward. For anyone else whose interest is piqued and/or getting started with Ruby, the Bastards Book has some really great examples of Mechanize in action.
&gt; ["apples", "oranges", "pears"].to_sentence Wow. Nice! Looks like I can un-write that helper method now.
Am I the only one being confused when CI systems use the term "building" for running the tests/specs?
Actually i found out about Chocolat ( http://chocolatapp.com/ ) and started using it. Developers are awesome and so far im enjoying using it as my main code editor.
Hahaha, odlično korisničko ime. 
They're also likely to sport fine woollen coats.
In fact, jruby and rubinius already stuck with this overhead: if you store block in a global array (as done in eventloops, gui and other), no one jit in a world can predict its following usage, so that, you ought to save `binding` with block itself. JRuby currently even suffers from fact that `#[]` method could be called against strings with regexp, so that it could teoretically set `$1, $&amp; etc`, cause of that `Array#at` is faster than `Array#[]` . And you think they could be easily get off block's binding? I doubt. Every compatible ruby implementation will pay for this.
You could always store your sessions in the db. The only thing stored on the client is a session token
welcome to the ranks. Your number is 110/34/Mango.
I don't get the python hate though, both it and ruby are great imho. 
I tried learning ruby a couple of time, but I'm not sure why, I find the syntax very weird.
I suspect most PHP programmers could write an article like this after exploring another language. Not to hate on PHP (you can get a lot done with PHP), but it isn't a pretty or carefully designed language. PHP is a "beloved monster", but anyone from Python, Ruby, Clojure or any number of languages could tell you these sorts of things. Languages designed to be expressive, concise, productive, consistent, or or strict will feel really different (and sometimes beautiful) coming from a language with different design priorities.
He uses stupid four times - twice on PHP, once on his wasted time, and once on Python. I took that last one, just like the previous three, to be poetic rather than factual. He was expressing his emotions at the time of dealing with Ruby. He calls Ruby evil repeatedly.. He just happens to explain why he says 'evil', and he doesn't explain why he says 'stupid'. *shrug* In the end he says he doesn't dislike Python, it's just not for him. Honestly, I have a strong dislike for Python, because I feel like it tries to be an OO language but it has things that get in the way of that happening, yet it doesn't feel like a functional programming language, either. The syntax feels a bit awkward -- and I hate hate hate the meaningful whitespace (for some reason, though, I like HAML). This being said, I've used Python, and it has good points. Once you get into its groove, it has its own logic which it follows flawlessly. Ruby, on the other hand, feels much more ... human-readable and human-writable. I learned how to think in Ruby really really fast, for some reason, and only occasionally stumbled upon some principle where the Principle of Least Surprise was violated (lambda/proc in 1.8 anyone?) Why do I find it more fun? Eh . it feels like a more human tool to me... But that's just me :)
What is your main programming language?
My [primary] "hate hate hate" on python is the meaningless distinction between statements and expressions, making lambdas in python about as retarded (pejoratively _and_ in the dictionary sense of the word as well) as you can get.
can't get over adding question marks to function names. just seems wrong :)
We just started using it about a week ago. We're happy. Thanks for supporting capybaby-webkit, that was important for us (but not a deal breaker). 
https://m.twitter.com/dhh/status/220982214408683520 This alternate link will work without requiring javascript. This comment generated by an [automated bot](/r/link_unscripter).
mainstay trowelled Apocrypha leave Huguenots ghosts tipped timpanists obsoletes Man seaplane miserable initial's anions misspellings fogbound walloping's twits starriest consolidation's monotone blockhouse reoccupy enzymes statuary generally superintendents tribesmen gewgaw centrists hobs colds enameling Barclay verbs Sinhalese sawyer steels grafted Sexton's pretending hectors taster's longest starchy downscale Eastman edema's involved quill's hales diarists unassigned Isiah's sung weightier redrawn Winthrop doles eject satire's Robbie Utrecht's overlay's polished exceptionally Morrow commode culverts uselessly traveller Tokyo's wadding Airedales Pryor Colombo's pinhead's Sankara accompanist Navahos harbor's prowl pardon operating prurience dreadlocks excitable reevaluated rheumier Landon scandalmonger's Canopus interminable knocking genteel odometers veneer's losers sugary cleanness's payment's radius Carson unmade counsellors docudrama blast refiners interfere microwaves ransomed caterwauling repaints needed kids steadfastness's canvasback quenched gonged frizzling pedants tilts Loews's aphrodisiac's accumulation investigation's mucks carpenters misspelling's Marcy depopulation bourbon glop optimism's monopolies transliterations Winston's attitudinized outbound licence assaulter unpins bifurcate
Not quite. Procs use a binding. We're getting close, but you can't use Ruby as a functional language just yet. Even the curry function of 1.9, which is actually a misnomer (it's not currying, it's partial evaluation) is not exactly up to par. But we're getting close!
haha but in Ruby you want your code to sound like English! In truth, the question mark or the exclamation mark are just conventions to let the dev know that the function returns a boolean or is destructive (it changes the object on which it operates), respectively. It's a useful convention.
It's worth mentioning that Ruby is not a one-size-fits-all. Ruby is written in C. Quite a few bindings or gems are also written in C for performance reason. Ruby performs great - but if you have to crunch data, you might run into some issues. It's not a number-crunching beast. It's great for lots of other things. And there's lots of solutions to DEFER the badly-performing operation so it's in the background and the user does not notice. If you're stuck using Ruby on a job that requires the performance of C, I'm sorry. The best thing you can do is write a gem in C and use that for the data crunching.
It's funny you know, because he gave a talk on 'progress' and 'not getting old', yet I feel like that's what we're seeing here. He talks about how progress is kicked in the foot by the 'think of the newbies" argument, yet I feel like that's what we're seeing here too. Because fuck, pimping out rails is something you have to do and learn. Quick example our current project has over 150 gems. DHH is half troll, half serious. Take it with a grain of salt. - Now with that said: screw FactoryGirl, use Fabricator, screw Cucumber, use Spinach. IMO
I think the real truth here isn't about the libraries but about skills. You will be able to better leverage more advanced tools the more you've worked with more basic ones. The problem with his comment is that it suggests if you learn RSpec or Rails early that you can't learn or later adapt a project to MiniTest or Sinatra later.
It was pure irony in motion when DHH got the entire room to literally chant in unison "I will not fear change". Also, it's odd that DHH promotes Test::Unit over RSpec, yet he praised CoffeeScript over JavaScript in his RailsConf keynote.
There are some minor stutters during gameplay, is this really the GC or on-demand loading of resources? If it's the latter, then you could pre-load and prerender everything to make it a lot smoother. I love the rotations to indicate damage.
I was using shoulda + text/unit + mocha for a long while, and it's really pretty close to RSpec in terms of functionality. What got me to switch is community support. When the products are effectively equivalent, the product with the most community pull tends to be the most easily usable. That said, RSpec's documentation sucked really hard for a very, very long time - long enough that it took me several years to really get ahold of it, and that was only after I worked on a project that used it. I don't think that one or the either is God's gift to testing, or entirely unusable. But I also think it's myopic of DHH to ignore the fact that RSpec exists and is popular because it fills some very ugly holes in Test::Unit. Minitest makes those holes a lot less obnoxious, but that doesn't really make RSpec less viable.
thanks for this, I don't use Twitter so I wouldn't have noticed otherwise :) btw I left my email on the "keep me updated" form that was there before but I haven't got any news there.
In your blog you say you're doing "amazing things in Ruby". I checked out your github page. Everything looked kind of average, nothing amazing. Sorry.
Really? Wow. That was pretty fucking useless.
Okay, that makes sense. There certainly is that distinction between communities - not that anyone *needs* to switch languages to become more language than framework oriented.
It's a confusing conflict of aesthetics - Test::Unit is barebones as hell, while Rails itself is a hoary den of custom DSLs. Anecdotally, I've observed that the hardest thing for new-to-ruby people to figure out is which parts of Rails are methods, which are mixins, how arguments are structured and which parts of the syntax are implicit (although this last problem is common to many terse languages, especially Scala) Personally, I'll take rspec and some sort of fixture generator (factorygirl or dm-sweatshop pehaps) not only because I find it easier to produce sensibly-structured isolated tests, but because the resulting test suites read much like the application code.
RSpec... Trying this hard to shoe horn code to read like English just makes for a painful API with entirely too many edge cases. MiniTest is far more predictable. This is a good thing. Fixtures... They're simply too inflexible. Barring perfect fixture names, they separate the test data too much from the test. With factories, at least a factory can be specialized within a test to clarify the intent of the test, this is doubly important as most software developers choose sub-par names. It provides yet another vehicle for conveying intent that simply does not exist with fixtures. TL;DR: DRY is less important than clarity.
Exactly... If stuff like that *can* break the test, I would want it to break the test so it can uncover an unknown problem. As long as sufficient info is logged to reproduce it of course - random irreproducible test failures are no fun. 
Stupid question: is there an honorarium/travel assistance for speakers coming from far away, e.g., the US?
Does dhh say anything nice ever? Well except his own projects, nothing but golden things to say about those
Has anyone here written any substantial Android apps with this yet? What were your experiences? I know from playing around with the Ruby IRB app that the startup time is quite slow, but performance is surprisingly good on my HTC Evo Shift 4G and my Toshiba Thrive. It seems like a nicer way to develop for Android.
not to mention his approval of scss(sass) over css but not haml over erb. We all have our opinions and DHH is full of opinions
I didn't write the article.
The overwhelming majority of the time, usage of mocks gives you a test that's extremely tightly coupled to this or that implementation detail. It's OK to mock out something that requires a network connection, for example, but only if the downstream module you're calling has a very well-defined stable interface and it's the interface you're mocking. Anything else will result in frequently broken tests when implementation details change and the broken test won't actually offer you any information value.
Actually, I probably would have found that problem in a similar way. We use Faker (ffaker) to generate fake data via a rake task, so we would have either seen that bug in development (or worst case, via Airbrake) and then written a regression test for it. I mean I'm not the best test writer ever, so far be it from me to be all purist about anything :)
Honestly, Im not exactly sure of the cause and im not exactly sure how I would pre-load and pre-render everything. Im using chingu to create enemy gameobjects. I am destroying every object that is hit by a bullet, and then creating a new one. I was before, just reseting the enemy object when hit instead of destroying and re-creating a new object. I wonder if that would help? Ill be over on the #gosu channel later
Thanks! Im really enjoying ruby and gosu for that matter. Its been really fun learning.
Interesting you always hear of a new gem. [Here is a gist comparing FactoryGirl to Fabricator](https://gist.github.com/1135434)
It's almost like he prefers good over bad, instead of new over old.
I could not live without haml. I will never understand the haml-hate. Whitespace over closing tags until I die!!
In general I don't agree with Rails love for DSL's. Learning RSpec over Rails test suite is nonsense in my opinion. The resources on trying to learn rspec are minimal vs rails that are available in abundance. Haml, scss and coffeescript .. I get the appeal and see how it works for a team of only rails developers. I bring on a front end dev that just works in javascript and html/css and they are lost and spend time now trying to learn non transferable skills out side of the rails dev world (I know they can be used in other environments but usually aren't). Its generally a waste. 
that's a fair point, i felt that way until i had to use haml at work. I must say it like it now and i prefer sass syntax opposed to scss syntax
I think of DHH as Rail's alcoholic dad. He just came back from the bar long enough to yell at the family about something. Get back in your Zonda HH and drive back to the bar. http://www.autoblog.com/2010/09/07/pagani-zonda-hh-commissioner-revealed-as-30-year-old-chicago-sof/
I'm still new enough to Rspec to not want to claim to have a valid opinion about Factory Girl. OTOH, I'm still new enough to Rspec to shudder whenever I think of The Rspec &amp; Cucumber Book. My gods, the thing is so full of snake oil it actually slips out of my hands. I *like* Rspec, a great deal. And TDD is a brilliant move forward in programming. But I'm not convinced that Cucumber is doing anything worthwhile. And there isn't enough Rspec documentation, definitely not enough free documentation. And the official documentation needs to be read with half a ton of salt.
I came here to say this. Nice to see someone else thinks the same thing.
How fast are your tests? I suspect that's what he's talking about with regards to rspec and factorygirl.
Test::Unit all the way but don't listen to me and drink the DHH kool aid if you must.
HAML is far more superior than ERB in many ways. 
Extremely fast. The only visibly slow tests are those that test combinatorics methods, which generate permutations of Strings. Also, I tend to use [DataMapper](http://datamapper.org/) which is lighter than ActiveRecord.
and while we're on HAML (I prefer Erb myself, writing HTML is not hard for me :P), there's something potentially better: [Slim](http://slim-lang.com/).
Project names have officially gone too silly.
I think that's basically what I just said. Tightly coupled mocks result in frequent failures, which tells you that you have tightly coupled code.
My point is that if you are test driving your code, you are far less likely to write those tests (and thus the highly coupled code that makes them pass) in the first place.
I'm working on a similar solution with DataMapper + PostgreSQL, I'll try to refactor it into a gem so we can do some benchmarks. A very simple example is available [here](https://gist.github.com/2956209), forked from someone else.
Amalag posted this: http://www.reddit.com/r/ruby/comments/w3qac/dhh_speaks_out_against_rspec_and_factorygirl_do/c5a6ss5 Personally, it just feels cleaner and stable.
http://slim-lang.com/
http://slim-lang.com/ Also, I believe HAML is designed only for generating HTML, where as ERB can generate arbitrary text.
It took me a while to figure out why I think haml's syntax is hugely simplifying, while python's is not: programming languages require a lot more brainpower to read and write, so the extra typing feels less awful in ruby than it does in html when you have to write out, say, 50 lines of either. 
Hmm. It looks like JRuby 1.7 has done some significant improvements to match 1.9.3 -- interesting! Still, it doesn't outperform MRI for everything ( http://shootout.alioth.debian.org/u32/jruby.php ), but it's certainly good to know. I'm still kinda waiting for Rubinius... :p
Gotcha; yes, this would be true.
I think VBScript is more accurately "the visual basic of web programming."
People don't use HAML because ERB is hard. They use it because it's more readable and easier to maintain, being whitespace-based and not having to worry about well-formedness.
I have my reasons for that, which will remain unspoken...
how does 'using a binding' subvert procs in any way? Why can't i use ruby as a functional language? 
I only wish that Spinach could more easily integrate with an existing cuke suite. It would make it so much easier to migrate these 500+ features if I could do it piecemeal.
Oy, don't judge. Maybe his shit isn't open source (some of us work for a living, lots of clients/employers don't exactly leave all their proprietary business modelling out for everyone to see), maybe he keeps it on bitbucket, or on a server somewhere you can't get to. The plain fact is you don't know, so you shouldn't judge. It's rude, and you should feel ashamed.
I think his point was that if you're test driving, you can't implement a mock that would be tightly coupled because you can't predetermine the mocked implementation details on account of having written the test before you wrote the code. Test driving in theory should force you to be very careful about your interface. In practice, the back-and-forth of write test, write code, update test, update code probably prevents the theory from holding true 100%, but it'd certainly limit the potential for coupling. I'm still not a huge fan of strict TDD, but I don't disagree with the argument.
Thanks, I had no idea this existed! Just added an update to my article.
Fair enough. I guess I have a keener eye for syntax and HTML/XML. However, if one prefers HAML, they should probably checkout [Slim](http://slim-lang.com/).
Indeed. I really like the session storing ability of mechanize. I have a few scripts I run in a cron. Mechanize let's you save the session cookies and load them again when the script runs later and only login if a login check function returns false. 
do that instead if you're using rvm rvm [version of ruby] do [command] rvm 1.9.3 do bundle install
Useful references: http://pragprog.com/book/ppmetr/metaprogramming-ruby http://pragprog.com/screencasts/v-dtrubyom/the-ruby-object-model-and-metaprogramming http://www.ruby-doc.org/core-1.9.3/Binding.html And you -can- use Ruby as a functional language, but you can't pass functions around. Er. So you can't really use it as a functional language. Just mostly.
Hmm, in that light, I can see how that conclusion makes sense. As for strict TDD, I've reported you to the TDD Inquisition, they're coming, but you'll never `expect { it.to.happen }`
 def do_your_thing rand &lt; .5 ? do_your_thing_way_one : do_your_thing_way_two end def do_your_thing_way_one # ... end def do_your_thing_way_two # ... end 
I'm chuckling at "fancy DSL". It takes about fifteen minutes to learn haml, because it's little else than HTML that does away with brackets, closing tags, and other ceremony. Say what you will about runtime performance, but learning haml is something a chimpanzee could do in his spare time – if he understands HTML already. Since it compiles to HTML, there is always the option to convert some haml to HTML for those people who can't be bothered to take those 15 minutes out of one day. As for SCSS, I would say something similar: it's basically nested css so you don't have to prefix every identifier with its parent. It also adds some nice features for easy re-use of css chunks and variables – two other things that CSS needed. When you sneer at me for not using Photoshop to template front-end designs, and demonstrate open ignorance of the burden of learning these two simple DSLs, and throw in slights at Rails to boot, I dub thee a Class-A dope.
To answer the question of the 50% threshold, look at using [Boolean](http://dev.mysql.com/doc/refman/5.0/en/fulltext-boolean.html). I have a question that maybe you've come across, my FULLTEXT search indexes haven't copied over to the test DB (the Cardinality and Collation are different - possibly causing the Index type to be BTREE) From dev: event_groups | 1 | fulltext_event_group_name | 1 | name | NULL | 16 | NULL | NULL | | FULLTEXT | From test: event_groups | 1 | fulltext_event_group_name | 1 | name | A | 0 | NULL | NULL | | BTREE 
You can change the min number of characters before the search kicks in with **ft_min_word_len**
So you are really going to use that as an example that this is better: &gt; Also, writing small amounts of HTML in ERB is &gt; %i not &gt; hard. HTML is &gt; %i not &gt; hard. I'm confused by why Rails devs prefer adding more layers of abstract, even when the abstraction has no benefit and simply adds complexity/performance degradation. Unless I'm missing something. I really don't know haml syntax.
Sphinx supports the concept of record deltas in the database. these are available for searching immediately. I typically set a con
Cron to reindex every fifteen minus for performance reasons. My database is about six gigs, takes about twenty seconds to reindex.
what the hell? you're talking about 'closures' ? If we're talking about functional languages in the loose sense (which i assume you are as you haven't mentioned anything about mutable state) then 'lisp' is a functional language; and lambdas in lisp most certainly ARE closures, so are functions in python, as are 'functions' in a tonne of [other functional languages](http://en.wikipedia.org/wiki/Closure_(computer_science)) The fact that procs/lambdas are closures does not count against them; and if that really is your argument then lisp is not a functional language, either. I also don't do much haskell, but it appears that anonymous functions in haskell [are closures too](http://www.haskell.org/haskellwiki/Closure)
Of course you can have an unbound method object: class A def a() end end A.instance_method(:a).class #=&gt; UnboundMethod p.s you seem to talk a lot, but i have a feeling you dont actually know what you're talking about a lot of the time;) 
LISP is indeed a functional language. Lambdas in LISP are closures. Functions in Python are closures. Lambdas in Ruby aren't closures.
Absolutely agree
I did. did you? Scroll down to line 306 of that very document, it says this: A lambda, therefore, is Ruby's true closure. Can you please accept you're wrong now? Thanks
Can i just run it like it says here: http://activeadmin.info/documentation.html? And what does this thing do: rails generate active_admin:resource [MyModelName]?
Use the source, luke! github makes it easy. https://github.com/gregbell/active_admin/blob/master/lib/generators/active_admin/resource/resource_generator.rb I've never used ActiveAdmin, but looks like that particular generator simply copies a file into `./app/admin/model_name.rb`. What file? Just this simple template: https://github.com/gregbell/active_admin/blob/master/lib/generators/active_admin/resource/templates/admin.rb There are other generators in there, including an "install" generator that does more, including adding routes, assets, and migrations. https://github.com/gregbell/active_admin/tree/master/lib/generators/active_admin
I find it inferior in every way; I'd love to know why you see it as superior.
&gt; It has some limitations, of course, since it doesn’t use any kind of headless browser (unlike Capybara), i'm still curious why nobody's written the Mechanize DSL on top of Capybara yet. 
Well, any library that wants to can, simply by including this gem as a dependency, that's the point of gems. But I hear you that adoption is more likely when something is in stdlib. ruby's stdlib is a bit ill-maintained, alas. Both in the sense of not including things it would be nice to include, but _also_ in _including_ things that are not really mature or stable or well-maintained enough to be included. Alas. 
Awesome, thank you so much! I was so caught up on trying to figure out how to do it in the to_json method that it never occurred to me to look into ActiveRecord. I'd just been staring at it too long to think objectively.
Hi, ActiveAdmin is prettier out of the box, but ActiveScaffold still has a few advantages, and I feel it's more customizable and easier to integrate in existing applications.
lol: in·er·tia/iˈnərSHə/ Noun: A tendency to do nothing or to remain unchanged: "bureaucratic inertia".
Ah, NOW I know who you are. I thought you seemed familiar but I honestly couldn't place the name. Thanks.
Also: you're right. I'm a complete idiot. For some reason my brain wired the words completely incorrectly. 
Interesting. I will check this out when I have a few hours. Don't know if I'd switch (since I can knock things out in HAML pretty fast at this point), but I'm always interested in cross-pollinating ideas. I agree with your point about ERb.
Yes, writing ruby is hard if you don't write ruby.
What does this show you except that you have a stray "if" after your "end"?
Also, is "then" legal in an if statement in Ruby?
I really hope this is not a production app. The WTFs-per-line is really high in this code.
I _love_ markdown. But the discussion was about erb/html vs haml.
yes,but it's not needed in this case. You are forced to use it for single line if ... then .. end statements.
The point was that Haml isn't designed for writing content, and even the Haml authors advocate using `:markdown` filters for content. Even the Haml site uses Markdown for its content.
I have line wrap turned on, so I just let them be ;)
right. but it is astray if you want it evaluated, which one could reasonably assume is what you'd want here.
Mocking != stubbing. The mockist strategy for testing: Always stub network calls. Mock everything outside the domain of the unit test. Implement integration tests that mock *nothing* to ensure that the application logic works. The end result is that failures in unit tests always appear in the correct place, and run blazingly fast to boot.
Well, not *forced*, you can resort to semicolons: if arg; puts 'yes'; else; puts 'no'; end 
You would omit the "then" if using semicolons: if true ; 1 ; end The only place I've seen the keyword "then" used in Ruby is in case statements. 
I interpreted stray as "extra", perhaps you just meant "out of the normal place".
http://www.ruby-doc.org/core-1.9.3/UnboundMethod.html An unbound method object can exist, but it can't be called until it's bound to an object.
And can pay the $175 a month
The application I really want to get a good test coverage of is the one with an awkward association that I can't quite seem to get right in Factory Girl, so it keeps putting me off. I've got to do something about it now before the project gets too unweildy though, then I can refactor with peace of mind.
I found that with factory girl, some things just wouldn't work. I just use fixtures now. 
Yep, same. I love testing ever since I went to Test Unit. it was actually the DHH RSpec drama that made me realise that testing felt like a chore. Back to the roots. 
dhh said nice things about CoffeeScript and SASS.
Factories are fine and well for integration tests, but for unit testing you should really be stubbing/mocking stuff. Way more efficient, and that way you aren't testing active record or whatever, you're just focused on testing your code.
I'm currently upgrading an older project of mine from untested Rails 2.3 to test-unit'ed 3.2. I'm by no means complete in coverage, but I'm now testing the main points (can_see_page, can_edit_user, can_upload_file, can't_see_admin_stuff, etc) and I am a zillion times more confident. About 1/3 of the time in the upgrade was 2.3-&gt;3.2 syntax changes, and the rest is just time writing tests. Your biggest impediment in your current project is going to be seeming like the slow one. Either that, or your partners will just saddle you with writing tests for their code, and you'll become the QA monkey. It kind of only works if everybody does it, but I'm guessing your partners simply don't know how. "Results" should be measured in code that doesn't break. Do you guys ever get regressions (old bugs returning)?
What do you mean? I was talking about having several valid and invalid fixtures for that model and checking whether they validate properly.
what is your end goal -- what sort of programs are you intending to write?
1. Install pry gem 2. Put these lines of code where you want a breakpoint: require 'pry' binding.pry 
Have you tried miniskirt? It's like FactoryGirl simplified, and in my experience it's easier to see how to make associations work.
minitest-rails was just released today: http://blowmage.com/2012/07/10/announcing-minitest-rails +1 for minitest and miniskirt
A good starting point is reading [The Rspec Book](http://pragprog.com/book/achbd/the-rspec-book). Despite its name it's not just about Rspec, it's about TDD in general. As you go, don't forget that testing is hard. Sometimes it's harder than writing the code itself.
Start off with the [windows ruby installer](http://rubyforge.org/projects/rubyinstaller/). Then google, download, and use cygwin. It's a sort of unix shell emulator for windows. you'll be able to use more than just ruby on it much easier then if you were just using CMD.
Writing tests against a pre-validated attribute is a useful introduction, because it allows the test writer to focus on (possibly) new grammar and method calls. Those tests won't survive into production, but that's OK, because their real purpose is to make the learning curve more shallow. Once the author has written and run his own test suite a few times, he won't need those first tests any more. Think of them as the unit test equivalent of scaffolding.
Then don't bother starting on Windows. Go download [Virtual Box](https://www.virtualbox.org/), install Linux in a virtual machine, and use RVM to install Ruby: http://rvm.io/rvm/install/
The biggest problem, so far as I can tell, is that DHH doesn't like it.
Ah, so learning a lesson "the hard way" amounts to reading a complaint from DHH? :) *HORRORS*
The validations (like `validates :name, :presence =&gt; true`) are already tested in the Rails framework. Of course, if you write custom validations it makes total sense to test them.
Depending on how much development you plan on doing with Ruby directly, you might just want to start out with [RailsInstaller](http://www.railsinstaller.org). As for an editor, I strongly suggest working with [Sublime Text 2](http://http://www.sublimetext.com/).
I agree with your take - from the perspective of what you are verifying, it is somewhat pointless. However, when considered from the point of specification rather than test, it is an extremely nice way of codifying how an object should behave. It gives you a set of specs that, if suitably rigorous, will catch unintended changes in the specification of an object. 
Slow though.
http://installfest.heroku.com/installfest/choose_your_operating_system?back=installfest%23step3 Should get you going.
If you want to post a gist I can take a look at it...
Slim: Better than HAML, faster than ERB.
Engine Yard...but I'm partial
hooray!
You mean like: proc = Proc.new{ |e| puts e} array.each(&amp;proc) array.reverse.each(&amp;proc) [ETA: Ampersand in front of an object calls `object.to_proc` from memory. For more fun, as of I think ruby 1.9 you can do this with symbols. `&amp;:to_s` will give you the equivalent of `Proc.new{|e| e.to_s}`]
The more you know! I recall at some point being unable to do this outside of rails - obviously this was from way back in 1.7.x.
out of interest, is effort being put into improving the start time? or is this an unsolvable problem?
Although, you can't nest control-statements within interpolation.
Make sure to tell /r/rails.
Handy. I have this problem all the time when trying to parse JSON with Yajl. Vanilla ActiveSupport::JSON.decode parses it no problem but Yajl complaints about invalid UTF-8 characters. And when I say complains, I mean, blows the hell up. I've been cleaning failed parse attempts with Iconv for some time now, but this looks like a prettier way to do it in 1.9 at least. For 1.8 I'll probably still have to stick to my Iconv code.
You can also try Saint - Simple Admin Interface http://saintrb.org/ 
1.8.7 specifically, it added the Symbol#to_proc method, which is what is called when you do &amp;:symbol.
Thank you a lot for your feedback! 1. I am alternating `.mdown` and `.md` between my projects. Still not sure which is my favorite - I use `.mdown` for the majority and my perception is that that's the common used one. But I'm absolutely not claiming to be right on this :) Besides, I don't think there's an official extension [as discussed here](http://superuser.com/questions/249436/file-extension-for-markdown-files). 2. I intended to add RDoc but I will have a look closer at YARD before. 3. Thanks! Didn't know about that. I will have a look at minimagick. Thanks for pointing that out! 4. Seems legit. Will fix that. 5. It is thrown in the `spritesheet` executable. Will move that into the model. Next I wanted to look into integration testing for command line interfaces. Directions much appreciated. ;)
Testing commandline executables isn't much different than testing other forms of code. However, this greatly depends on how your executables are structured. In general it's a good idea to decouple your code into smaller chunks which can be tested individually. This is a good idea in general but it also makes it easier to test the executable since you can just test the various parts individually. For example, the following can be a bit hard to test: def complicated_method documents = Dir['./doc/**/*.xls'] rows = [] documents.each do |doc| reader = SomeSpreadsheetReader.new(File.read(doc, File.size(doc))) reader.rows.each do |row| rows &lt;&lt; { :name =&gt; row[0], :age =&gt; row[1], :company =&gt; row[2], :file =&gt; reader.filename } end end DB.multi_insert(rows) end This is hard to test not because the code in itself is complex but because it does a few different things. The logic of this method itself consists of the following: 1. Get all XLS files 2. Convert them to spreadsheet objects 3. Create a number of database records 4. Insert these records into the database using a single query If you were to break this up as illustrated below (use at care, don't break things up when not needed) it becomes easier to test things: def spreadsheets(dir) documents = Dir[File.join(dir, '**/*.xls')] documents.each do |doc| yield SomeSpreadsheetReader.new(File.read(doc, File.size(doc))) end end def get_rows(spreadsheet) rows = [] spreadsheet.rows.each do |row| rows &lt;&lt; { :name =&gt; row[0], :age =&gt; row[1], :company =&gt; row[2], :file =&gt; spreadsheet.filename } end return rows end This allows you to use this code as following: rows = [] spreadsheets('./doc') do |spreadsheet| rows += get_rows(spreadsheet) end DB.multi_insert(rows) This in turn allows you to easily test the various parts individually without having to worry about the rest. tl;dr: break things up in smaller chunks, this makes things easier to test (including executables).
I'm not entirely familiar with the rspec syntax these days. However, I use Bacon and the example shouldn't be too hard to convert: describe 'A test for creating files' do should 'create a file' do some_method_that_writes_a_file('./file.gif') File.exist?('./file.gif').should == true end end You might want to expand this by checking for a minimum file size (to ensure that it actually writes something) and a few other checks but I hope you get the idea :)
Yes, simply modifying the HTML shouldn't do any harm. p.s. In the future, Rails specific posts should go in /r/rails.
Thank you - I apologize for posting in the wrong forum.
Just wanted to double check on my assumptions.
Yes, modify as per will &amp; if you encounter any errors, port here. further, if you need a tutorial have a look at --&gt; http://www.kuwata-lab.com/erubis/users-guide.02.html#tutorial in general, if you avoid modifying anything between the following two tags: * **&lt;%** *foo* **%&gt;** * **&lt;%=** *foo* **%&gt;** you should be fine
54 characters since last time I heard. When embedded Ruby blows up you'll be huge.
Yes :V
That one doesn't work at all for me, I get this error: -e:1: formal argument cannot be a global variable gets.split.each { |$,| $: &lt;&lt; (Float $, rescue eval... ^ 
Yours only works if the input is three characters. Like: 1 3 + not something more complicated like: 2 3 4 + *
I am more confused after reading this article than I was before reading it.
sorry for not replying sooner, but thank you. That was exactly what I wanted, silly me for not figuring it out by myself though :P
You need to get a SSD drive. 
It's like 5 secs for me. Which is still a lot but I've seen how long rails takes to start on non-SSD drives. 
why are you restarting it so much?
What the hell are you doing (wrong) that you need to restart the app server so often?
That approach further minified: $:&lt;&lt;(Float$_ rescue eval$:.pop(2)*$_)while gets" ";p$:.pop
ruby-debug19 has been more or less superseded by '[debugger](https://github.com/cldwalker/debugger)'. This has not neccesarily been advertised well. And not saying it's neccesarily going to be any easier to install. And it's still got bugs (which ruby-debug19 does too). It's a miracle you got ruby-debug19 to install though. 
Short methods that do something simple like that are a good coding practice IMO, but to each their own I guess.
Between Rails server, Rails console, Rake, and RSpec, there are plenty of times when you eat the startup cost.
No problem!
`reload!` should fix most of your problems with having to restart `rails console`. You don't have multiple instance of rails console for a single project do you? I literally live in rails/tmux/vim. I have a frame for `rails console`, `rails server`, and an editor at a minimum per project.
55 characters... nice. I want to see that 54 character solution now.
Ruby has had a built-in debugger since 1.4. require 'debug'
Even if we accept the image as 100% true, I bet the total area of the pie is still smaller than, say, ASP.NET.
This is actually way worse in Windows than Linux. Ruby 1.9 on Windows is worse yet, weirdly. I think there's a patched version of Ruby that helps with require being so slow, but I can't find the link right now.
Prepare your anus. * that's right yozz-meister, procs are said to implement "non-local returns"
Just found out today that running rspec spec instead of rake spec omits the dropping and re-creating of the entire database schema with every test run. Which mean your tests start much sooner and are done much faster.
Depending on which flavor of proc you use. `return` in lambda-flavored procs behaves like `next` in all procs, which is what you expected `return` to do in the first place. Also, `proc` behaves like `lambda` in 1.8 and like `Proc.new` in 1.9. So, yeah, good luck with that.
I'm doing the same, but I am stuck keeping the old SQL Server database and it's current schema. There are a few painful spots. :( 
Are you using the same shell for all of them? Also, ruby 1.9.3 and rails 3.2 add significant startup time improvement.
Using a performance-patched ruby helps a fair bit: https://gist.github.com/1688857 Spork (or Guard) is obviously great if you can get it working satisfactorily. Testing in isolation is great in theory; difficult in practice, especially for "established" apps.
OP uses [vim](http://www.reddit.com/r/programming/comments/wgglq/vim_creep/).
Ouch! The schema on my DB became a mess so I just started from scratch and wrote a few scripts to migrate data to the new schema. That was actually kind of fun. I had little interest in trying to get all those user account and profile tables working in RoR. Edit: I did play around with Django for a bit and found it easier to integrate with an existing DB. I wanted to use the built-in Django admin pages as a quick band-aid admin solution for the ASP.NET pages and it worked well enough. Going pure RoR now though.
Mitigate? Short of refactoring thousands of tests to eliminate environment loads, I'm in the process of setting up a 16-core server class machine that runs a custom-compiled ruby with various performance hacks, forks on request from a pre-booted app instance and load balances tests across 31 runners. Projection is a full test run in 55-65 seconds on this setup. So technically, I agree, but that's a *really* sketchy definition of "mitigate". 
I started writing a wrapper around the ASP_NET_MEMBERSHIP stuff and that big jumble of tables that it makes, but realized that I could, in fact, make a new users table. Unfortunately, most of the other tables are tied into various other systems in the office so they can't be changed as easily. I'm having decent luck with setting the table name, the primary key name, and making liberal use of alias_attribute. activerecord-sqlserver-adapter does have some problem with EXPLAIN queries on occasion, though. I had to disable that. 
Yeah... try getting your tests to run in 10 seconds with a huge platform. Ours take about 10 minutes for the whole suite (down about 40% in the last month from upgrades and some GC stuff, and we have some more things in the pipeline to make it faster, but I don't see it reaching less than 7 minutes).
https://gist.github.com/1688857 or simply `rvm reinstall 1.9.3 --patch falcon`
♥
Are you using [guard](https://github.com/guard/guard-rspec/)? When configured properly it (tires) to only run the tests relevant to the changed files and pops up a little growl every time it runs the tests Also [rerun](https://github.com/alexch/rerun) can come in handy 
I can't help you but I would also open an issue on the github page https://github.com/sinatra/sinatra/issues
Use Guard and Spork for testing. Guard watches any changed files and instructs Spork to run your tests for you.
Don't forget `bundle install`.
Seems to work fine here... here's my info: *** LOCAL GEMS *** backports (2.5.1) bicrypt (1.2.0) bundler (1.1.3) eventmachine (0.12.10) haml (3.1.4) rack (1.4.1) rack-protection (1.2.0) rack-test (0.6.1) rake (0.9.2.2) rubygems-bundler (0.9.0) rvm (1.11.3.3) sinatra (1.3.2) sinatra-contrib (1.3.1) tilt (1.3.3) $ ruby --version ruby 1.9.3p194 (2012-04-20 revision 35410) [i686-linux] [2012-07-13 10:32:34] INFO WEBrick 1.3.1 [2012-07-13 10:32:34] INFO ruby 1.9.3 (2012-04-20) [i686-linux] == Sinatra/1.3.2 has taken the stage on 4567 for development with backup from WEBrick [2012-07-13 10:32:34] INFO WEBrick::HTTPServer#start: pid=29185 port=4567 foo session : Hello World! localhost - - [13/Jul/2012:10:32:39 EDT] "GET /foo HTTP/1.1" 302 0 - -&gt; /foo In bar session : Hello World! localhost - - [13/Jul/2012:10:32:39 EDT] "GET /bar HTTP/1.1" 200 3 - -&gt; /bar 
simple thing you probably already know, but: does your browser/user-agent have cookies turned off or not support cookies? You need cookies for sessions. 
Are you aware of spork good sir?
For the same project? Rails boot time can change a ton based on the gems you're using.
This is why we need sarcasm tags
&gt;def revive local_arg Ugh. Put your method parameters in parentheses, people. https://github.com/bbatsov/ruby-style-guide/
Unanimous so far: get the Ruby down before hitting Rails. Otherwise (the inevitable car analogy) it's like trying to build a car without understanding how gears and levers work. 
Thanks Guys. I figured the answer would be what it is. I have downloaded and installed Ruby in windows and am now going to research koans...
Would you build a house before first learning how to use a hammer?
Be sure to do Ruby first, even if it's just reading and following the examples at [TryRuby](http://tryruby.org/levels/1/challenges/0) and in [why's (poignant) guide to ruby](http://mislav.uniqpath.com/poignant-guide/book/chapter-1.html). These will make understanding Rails much easier. You might even find that a simpler framework, like [Sinatra](http://www.sinatrarb.com/), are more up your alley. Edit: Also be sure to check out [Ruby Koans](http://rubykoans.com/). I've used them to learn Ruby as well as Python with the [Python Koans](https://github.com/gregmalcolm/python_koans).
I'm in the same situation as you, preparing for Dev Bootcamp in the fall. I went through Ruby first, with _tryruby.org _Why's (poignant) guide _Learn Ruby the hard way _Ruby Koans And now that I started the Hartl tutorial I feel way more confident about all that :) Simply because all the ruby tutorials will be way more nice to you about teaching how to use the console etc... which rails tutorials seem all to assume you know all that already ! Have fun sir, Ruby and rails are really fun ;)
Good advice! I am one of the crappy rails programmers with no knowledge of Ruby. I think I'll check out some ruby
You wouldn't go back to Python? I think I might. I enjoy writing Python as much as Ruby, they do have their pros and cons.
On the Ruby tutorials now.. its going pretty smooth. I like it so far
Absolutely do Ruby first, and then pick the framework of your choosing. [Here's my reading list that I recommend for my friends (most of which can skip #1 but some are totally new to development).](http://ckrailo.com/ruby)
&gt;You might even find that a simpler framework, like [3] Sinatra, are more up your alley. This is how I really got into ruby. A project at work required me to build a RESTful api for a mobile app to interact with during the development phase of the project. I had worked with ruby a little bit before but not much. Using ruby in this project was so fun that I looked forward to working with it everyday and really got why ruby devs love ruby...it just makes sense.
&gt;You might even find that a simpler framework, like [3] Sinatra, are more up your alley. This is how I really got into ruby. A project at work required me to build a RESTful api for a mobile app to interact with during the development phase of the project. I had worked with ruby a little bit before but not much. Using ruby in this project was so fun that I looked forward to working with it everyday and really got why ruby devs love ruby...it just makes sense.
&gt;You might even find that a simpler framework, like Sinatra, are more up your alley. This is how I really got into ruby. A project at work required me to build a RESTful api for a mobile app to interact with during the development phase of the project. I had worked with ruby a little bit before but not much. Using ruby in this project was so fun that I looked forward to working with it everyday and really got why ruby devs love ruby...it just makes sense.
Is this the first language you are learning? I would say Ruby is without a doubt in my mind, worth learning it. I come from a Java and .NET background and now a Ruby programmer (not a rails guy). Now I look back and think how much of my programming has actually improved in less than 6 months or so because of Ruby. I think differently and if I ever have to program in Java or .NET, I will program more elegantly. Once you grasp a few concepts in Ruby, I would suggest you to jump right into [Enumerable](http://ruby-doc.org/core-1.9.3/Enumerable.html) and use as much as you can in your program. Also, check this [style guide](https://github.com/styleguide/ruby/). You would appreciate Ruby much more if you have ever programmed in Java, VB or to a lesser extent C# before! 
hey. 2 year ruby developer here, never touched rails. am I the only one?
I use sinatra for everything, rails felt too cumbersome for me to bother. :)
I've never met a programmer and thought "well thank god they started by getting a good programming foundation before they started learning a framework; otherwise they'd be a mess!" I'm gonna be different and suggest that since you are familiar with front-end tools you learn rails first. Learn what's possible, learn what's fun, then learn what you can do to be better. There's huge demand for Rails programmers that have the kind of background you do, even if you aren't a pro with Ruby for good reason.
He he, I got hired on for what I thought was a job in php only to be told the first day that I was on the rails team. I had the hardest time because I thought everything rails was doing was in the core ruby docs. Then I realized how much sugar rails had added. So yeah, I'm right there with ya. 
if you wanna learn ruby I would suggest you first try [project eurler](http://projecteuler.net/) than move on to rails remember: rails is productive if you do things the way rails wants you to do things
In some time, you'll realize that Ruby is better on POSIX environments (such as Linux and OS X). But, for now, stick with you feel that is more comfortable.
Would be very interesting to hear those pros and cons. I've only done extremely simple stuff in python and i found the strictness somewhat limiting.
I've loved twilio since they came out, definitely a good service!
APIs I guess
Please, don't use 8 space tabs. Here's a nice Ruby style guide that most of the code in the community more or less follows: https://github.com/styleguide/ruby/
Do yourself, and us, a favor and put your code on github. :) For OO programming, I've heard good things about [Learn To Program](http://pine.fm/LearnToProgram/) Good luck!
and by "you", I mean OP, of course. :)
Publicly [I have a few things](http://github.com/kristopolous). Professionally, I've actually tossed out C and perl for the most part and replaced it with ruby a lot of times. It's poor performance is rarely an issue in the kinds of services I write, and the core features are highly symmetrical, which makes it easier to learn. The third party support documentation is *absolutely abysmal*. Just on Friday I made a comment with a colleague, "Look at me, trying to look up documentation for this as if it exists." But other than that, it's been ok. 5 years ago I was probably 10% perl, 20% python, 10% php, 20% c++/c, 10% java, 10% bash, and the rest being a bunch of misc stuff. Now it's probably like 40-50% ruby. It does its job well. As far as emitting web pages/apps for users, I'm a big fan of the principles of mvc, and a big hater of the frameworks that purport to do them. But the idea of thin controllers, dumb viewers, smart models really hits home in how I try to do things. This implicates that the server code is thin and uses the right tools. It's harder then code bloat, sure. But eh, that's what I get paid for.
Very interesting. I think i agree with you on most points. Totally agree about low quality of some gems. Even the standard library is kind of horrible. :/ To be honest last time i touched Python was a couple of years ago, long before i started with Ruby. It's on my list of languages to learn, but first i want to look at something completely different, like Erlang or Haskell.
And this is when I found out I wasn't testing enough.
I've been learning quite a bit of coding and how to use the language, but where can I learn more about the ACTUAL language? Like what are the growth factors, why and when is garbage collection needed, etc.? Have you got any good resources (either tutorials/articles or books?) that you could recommend? Preferably Ruby specific tuts/books. Thank you very much! :]
A resources I found quite handy (but not to many people seem to reference/know about) is [NetTuts+](http://net.tutsplus.com/category/tutorials/ruby/). They have nice practical tutorials like how to write a Ruby wrapper etc. Another cool thing are their 'Session Tutorials'. If you're starting out with ruby you might like these as surplus content [Ruby-for-newbies](http://net.tutsplus.com/sessions/ruby-for-newbies/). (Sorry if that sounded like a sponsored reply. I have no affiliation with the Tuts+ network.)
I did a writeup on those parameters here, if you want to know more about them specifically: http://www.coffeepowered.net/2009/06/13/fine-tuning-your-garbage-collector/ I don't have specific resources; what I've learned has mostly been from the odd collections of documentation and blog posts from around the internet. Sorry. :( I'd recommend just googling for "Ruby garbage collector internals" or something like that. There are lots of slideshows from conference presentations online that have lots of really good information in them. At the end of the day, the best thing you can do is read through the source code to the language itself, but that assumes a level of familiarity with C that you may not have. No better time to learn than the present, though!
Have issues with encoding and replacement all the time, will give this a shot and definitely fork at some point. Nicely done. :)
My ruby mentor pointed me towards creating a Todo app, it was a really good exercise so I highly recommend that one! You should also read a ruby book to get the hang of the language, that help me out tremendously! I really liked "Eloquent Ruby" and "Why's (Poignant) Guide to Ruby" is a pure must for any new Ruby programmer On the IDE, I just run good 'ol vim and that works more than fine with ruby. Go vim(or emacs) or go home
For a first project how about some usage of APIs like the twitter one, there are nice gems for that and you can write a little twitter client or bot. For IDE you could try out the free c9.io it has a nice vim mode and builtin ruby interpreter which should suffice at the start. if you post a link to a c9 project others can even collaborate and chat with you. also get a github account so we can review your code, and you have nice version control.
If you have the time to spare, I went in depth on procs, blocks, closures, lambdas, etc, in this screencast: http://www.youtube.com/watch?v=VBC-G6hahWA
If you want a whole IDE, RubyMine is pretty good, but I encourage you to adapt the ideal of your OS as the IDE, and use SublimeText for that. As for projects, pick something you care about. I wrote a wrapper for the reddit api in ruby, things like that can teach you the most
Well said. 
If you do write a Crawler, I recommend not releasing it as a gem. There are far too many naive Ruby spiders/crawls floating around. That said, some other project ideas: * Log parser * IRC bot * Web Scraper * Chat Server * MUD * Your own custom Shell
My first reply was not so much about IDE. I did mention editors, but other than that, established crawler tools. But again, as others have said, with Ruby and/or Rails, the built-in support MOSTLY eliminates the need for a true IDE. The whole concept of IDE was built around visual elements and unless you envision something like Adobe Dreamweaver and dragging-and-dropping, you don't need, and probably don't want, to deal with it anyway. I am aware that this is a bit foreign to many Windows programmers, but assuming you are doing a Web application, what you do is open a terminal (command, if you are a Windows wonk) window, navigate via command-line to the base directory of your project, and start the default Rails server "rails s". Then you open your default browser, and in the address bar, type "localhost:3000", hit enter, and see your Rails webpage . From there, you make changes in your editor, and view the changes by hitting "refresh" in the browser. For most uses, it's as good as an IDE, just as fast, and costs nothing. Rails itself supplies debugging tools that in many other situations would require IDEs. 
Agreed. No experienced Ruby programmer would actually release a "crawler" as a gem. There are already too many generic tools that together do a better job than any limited, specific new one. 
Such tools as...?
I already listed them. I didn't mention open-uri, but that's how you get where you're going via http. Then Nokogiri (or some other parser, but Nokogiri is generally considered the best stand-alone) to find the information you are hunting for in the page (the value of a text field or check box, for example). If you want to DO SOMETHING to that web page, like check a checkbox or click a submit button, Mechanize is probably the best elementary tool for that. If you are looking at doing more in-depth web page parsing or manipulation, Selenium is the choice for many people. If you want to spend the learning curve and go whole-hog, automated parsing and manipulation of remote (non-local-server) web pages, as best I know (and I have been doing this a while) there is still nothing that beats WATIR. 
yup, checked that
Skimmed through your post, it seems to be exactly the kind of writeups/posts I was looking for :] Thanks for the reply! Heh, I guess learning C is inevitable then. 
This is a part of an old abandoned project of mine. I'm now extracting and publishing some of its saner components. Now, this code is over three years old and rather hairy, as befits an academic project, and [at least one other pure-Ruby Rete implementation](https://github.com/Codalytics/ruleby) has emerged since then. It's probably more polished and stable, but I like my DSL better :) I wouldn't recommend going live with this just yet, but at least it's not collecting dust in a private repository anymore, so maybe it'll gain some momentum if anyone's interested in this sort of thing.
Thanks for releasing this. Apart from the dsl, are there any other material differences with ruleby?
I haven't looked much into ruleby. It's the same algorithm, so there can't be many fundamental differences.
In 1.9 I do this... stringy.encode("UTF-8", :invalid =&gt; :replace, :undef =&gt; :replace, :replace =&gt; "").force_encoding('UTF-8') In 1.8 I do this... Iconv.conv('ASCII//IGNORE', 'UTF8', stringy) I'm not sure if they are 100% the same but I use them for sanitizing JSON after parsing failures related to encoding and funky characters. I also can't get Iconv to build properly in my 1.9 environments but I also haven't tried to fix it either.
 arr = [1, 2, 3, 4 , 5 , "banana"] l = lambda {|*a| a.each {|e| e}} puts l.call arr, arr.reverse or a more succinct variant that I just realised was possible [in fact 3rd edit as I realised just how succinct one can be]: puts [arr, arr.reverse].each {lambda { each }} Sorry, I'm just learning myself and thought that would be an interesting exercise. Remember the DRY (Do Not Repeat Yourself) philosophy. Nice language.
Interesting approach, I would not have thought of it, it just won't work on the real thing because I do a couple operations in between, but other than that I might keep this kind of technique in mind. Yes, I'm also loving it
That's an idea taken from Scheme.
Cool, thanks, yeah, that's more or less what I've tried. In my experience in 1.9, if the string _started out_ in UTF-8, that operation you provide as an example.... does nothing, it's a no-op. Encoding from UTF8 to UTF8 does nothing, including nothing with :invalid, :undef, and :replace args. Not sure about the Iconv version, was hoping Iconv had an actual "fix bad bytes without a transcode" function I hadn't found yet, not sure if the convert function is going to have the same issue. 
Hmm, should be pretty cool for 2factor, someone make a plugin for devise so I can be lazy.
My use case requires that I keep repos on our own servers :(
I agree, GitHub is amazing, but the idea of open source alternatives is even better, especially when commercial solutions won't work for your use case.
Github isn't open source. The idea that making an open source clone of non-open-source software that you like offends you... offends me. 
So, let me get his straight. You must host this code publicly, but you can't host it on public-use servers? This is silly.
Let me guess, you don't work for large companies?
I think that it "offends me" might be a bit strong on my part. Part of me agrees with you, but it still sits wrong with me. As a commercial product, Github might not be open source, but they have done _so much_ to contribute to open source; not just in providing free hosting, but in greatly lowering the barrier to entry for contributing and collaboration. It seems like a slap in the face that Gitlab is always pushed as a "Github clone". If you want an opensource alternative to Github, [Gitorious](http://gitorious.org/) is great and even predates Github.
I've heard of it. That link is broken though. Can you tell me more about it, and/or why its better than using ruby-debug?
fixed the link above ^^ I wouldn't say pry is better, it's a different experience altogether with slightly different goals. But it still has a lot of overlap with ruby-debug (and the brilliant [debugger](https://github.com/cldwalker/debugger/) project). pry is kind of hard to explain, think of taking the juicy bits of ruby-debug, the heart of irb, jack it all up on a unix shell analogy (cd and ls commands) with a smattering of ultra powerful commands like 'edit-method' and 'show-source' and u have something close. As a once-upon-a-time user of smalltalk, i can say it feels like a console version of the the smalltalk class browser. It also seems people are hard at work building [plugins](https://github.com/pry/pry/wiki/Available-plugins) for it. It definitely needs a cheat-sheet too. I admit to feeling a bit overwhelmed by it sometimes. EDIT: it seems there's a plugin [pry-debugger](https://github.com/nixme/pry-debugger) that exposes the debugger (ruby-debug) gem functionality, turning pry into a kind of front-end? Looks like we can have the best of both words \o/
hmm, i'm not sure i agree with that. There are plugins that let you move up and down the stack, plugins that let you next/step and set breakpoints. I don't think the fact they're plugins rather than built in counts against it either, as (im guessing) it was designed with this pluggable architecture from the beginning. So long as i can next/step/up/down/break, i dont see why it's not a debugger? Even if it's not ALL debugging functionality found in some debuggers, i still think it's enough to justify it being called a debugger, IMO.
Exploring objects (while super cool) != debugging. &gt;&gt; require 'debug' Debug.rb Emacs support available. ~/.rvm/rubies/ruby-1.9.3-p194/lib/ruby/1.9.1/irb/context.rb:166: (rdb:1) help Debugger help v.-0.002b Commands b[reak] [file:|class:]&lt;line|method&gt; b[reak] [class.]&lt;line|method&gt; set breakpoint to some position wat[ch] &lt;expression&gt; set watchpoint to some expression cat[ch] (&lt;exception&gt;|off) set catchpoint to an exception b[reak] list breakpoints cat[ch] show catchpoint del[ete][ nnn] delete some or all breakpoints disp[lay] &lt;expression&gt; add expression into display expression list undisp[lay][ nnn] delete one particular or all display expressions c[ont] run until program ends or hit breakpoint s[tep][ nnn] step (into methods) one line or till line nnn n[ext][ nnn] go over one line or till line nnn w[here] display frames f[rame] alias for where l[ist][ (-|nn-mm)] list program, - lists backwards nn-mm lists given lines up[ nn] move to higher frame down[ nn] move to lower frame fin[ish] return to outer frame tr[ace] (on|off) set trace mode of current thread tr[ace] (on|off) all set trace mode of all threads q[uit] exit from debugger v[ar] g[lobal] show global variables v[ar] l[ocal] show local variables v[ar] i[nstance] &lt;object&gt; show instance variables of object v[ar] c[onst] &lt;object&gt; show constants of object m[ethod] i[nstance] &lt;obj&gt; show methods of object m[ethod] &lt;class|module&gt; show instance methods of class or module th[read] l[ist] list all threads th[read] c[ur[rent]] show current thread th[read] [sw[itch]] &lt;nnn&gt; switch thread context to nnn th[read] stop &lt;nnn&gt; stop thread nnn th[read] resume &lt;nnn&gt; resume thread nnn p expression evaluate expression and print its value h[elp] print this help &lt;everything else&gt; evaluate Use both Pry and Ruby's debug, when necessary.
I'm not cargo-culting, i'm just saying that Pry has enough features to wear the moniker 'debugger', it easily supports the 80%-90% case for debugging in my experience. Look at the [definition of debugger](http://en.wikipedia.org/wiki/Debugger) found on wikipedia. Pry (with relevant plugins installed) clearly meets it IMO.
Pry (with plugins) has analogs for all those commands except 'watch' and catch and the thread stuff, btw ;) And the stuff which it doesn't currently have can be fairly trivially implemented too :)
[Pry - An IRB alternative and runtime developer console](https://github.com/pry/pry/) It can be a debugger, but that's not it's design goal. When developers say "just use $FOO", that is cargo culting. :(
Good to know. Although, I think it's important to understand the core tools of Ruby (if not just for the historical perspective), since MRI's APIs may change in the future and break pry-debugger; or you may be on a system where you cannot install pry-debugger. Ruby's builtin debugger will always be there and will always work.
For the record, we are currently using cldwalker's nifty `debugger` fork as the engine for our debugging functionality. So pry can't be said (atm) to 'replace' debugger (ruby-debug) as we actually rely on it ;)
Also for the record: ruby-debug != Ruby's builtin debugger. It annoys me when people say Ruby lacks debuggers, when it has had one built-in since 1.4.x. Now with the advent of pry-debugger, we are practically swimming in debuggers.
Gitorious is good, though the parent project with multiple child repos model is different to github, I like how it works for an internal blessed repository workflow. If you have oodles of cash to spend (5k per 20 devs, ~ $250 per dev per year) Github for Enterprise is another option.
yep, that is a completely different outlook than everyone else but it sounds pretty valid. I hadn't really thought about scoping the demand for the language but you are not the first person to tell me about. .. over the past few days i have gotten a basic grasp of it and what i can do so i would be comfortable jumping around and finding a framework that fits for me. Thanks!
[Sinatra: Up and Running](http://shop.oreilly.com/product/0636920019664.do)
The [rubykoans](http://rubykoans.com/) are also a great way to start and learn about edgecases present in ruby. It also goes into test driven development (TDD).
Take a look here https://www.ruby-toolbox.com/ That's basically half of the ruby ecosystem.
I just wrote this up for a friend... **Codeschool** http://www.codeschool.com/ Codeschool has awesome interactive classes that are perfect to getting introduced to new concepts and immediately being able to put those skills to use. Highly recommended. **Ruby Koans** http://rubykoans.com/ Ruby Koans is a fantastic way to become familiar with ruby. It is a series of test assertions composed as Koans. These assertions encourage you to ponder the meaning of a statement, and modify code until the test assertion passes. It is rather brilliant, and fun to do even if just for the fact that they are puzzles. **Rails Tutorial** http://ruby.railstutorial.org/ruby-on-rails-tutorial-book If you are interested in writing software of making apps, definitely check this out. It gives you an introduction to some unix tools, version control with git, and is a start to finish tutorial on building a twitter clone. It even shows you how to get the app deployed. **Railscasts** http://railscasts.com/ Fantastic screencasts on loads of tools built in ruby either for use with Rails or independent of rails. It is neat to see the kinds of things you can do leveraging tools others have built. **Destroy All Software** https://www.destroyallsoftware.com/ The best set of screencasts I have watched on higher level concepts in composing software architecture and Test Driven Development. Definitely worth watching.
I would like to add Rails for Zombies on this list.. or at least add it to your codeschool item. Rails for Zombies - http://www.railsforzombies.com - A good, fun, and interactive way to dive into the basics of Rails done by Codeschool for FREE. It is also a good way to see if you like Codeschools teaching methods.
Definitely. Work through Rails for Zombies. This will start giving you a sense of code structure in ruby, an in particular the language that Rails uses. But of all the resources, if you want to build apps (and I would argue that Rails is probably the best place to start), work through Rails Tutorial. 
For sure, but that's the problem. The feature has been requested [many times](https://github.com/gitlabhq/gitlabhq/issues/search?q=public), but the general answer is 'no'. Too bad, really. I think a lot of people/organizations would get great use from it.
And being that Git is naturally distributed... Good idea!
I was aware of GH Enterprise, but we tossed that idea out early due to two main problems: Too expensive, and not open source (which is a problem since we needed something customizable.)
Instead of spawning `ping` programs, you might want to use Ruby's built-in [Ping](http://rubydoc.info/stdlib/ping/Ping) module built-in. It essentially tries connecting to the host, and depending on the Exception, either the host is down or the port is closed.
http://pragprog.com/book/ruby3/programming-ruby-1-9 Thats the only book you need
Also `y` for when inspecting YAML.
1.9 doesn't seem to have the Ping module any more, but you should be able to use the "net-ping" gem.
When you're on-passing a block for example def my_method(&amp;block) (1..10).each(&amp;block) end my_method { |v| puts v }
Correct, ping normally sends ICMP Echo Request packets. Traceroute actually sends UDP packets with incremental TTLs, and watches for ICMP Time Exceeded packets. You can also use [UDPSocket to send data and hopefully illicit an error](https://github.com/ronin-ruby/ronin-support/blob/master/lib/ronin/network/udp/udp.rb#L63-86).
One of my early ruby books was [Ruby Cookbook](http://shop.oreilly.com/product/9780596523695.do) it has lots of simple starting points for doing practical things. I would also suggest Eloquent Ruby by Russ Olsen.
Whole post could be replaced with [this link](http://www.ruby-doc.org/core-1.9.3/Array.html#method-i-join)...
I don't understand how this is not clear unless one does not know how global variables and default method arguments work. Consider the following: $foo = "abc" def bar(arg = $foo) puts arg end bar # prints "abc" $foo = "def" bar # prints "def" Sorry if it seemed like I undermined the post itself - I just think that as far as reddit goes, such basic content should be posted to /r/learnruby instead of /r/ruby :)
People should not be surprised that if they modify global variables, bad things happen. This isn't "overlooking", this is common sense. Let me rephrase the problem from the OP: "modifying a global variable will globally modify the behavior of the program". It does not seem surprising. Don't forget to also "protect yourself" from modifications of $/, $\, $;, $&gt;, $=, etc.
This is a problem?
Also j.
&gt; And who might that someone be? That someone could be the author of the gem you just installed. &gt; Aren't you the guy writing the code, and therefore the guy responsible for the global variable? If not you, how about your team? If I distribute a gem, I can no longer be responsible for the global variable in the gem's consumer, of course.
The ONLY case where I could see this being useful is if someone with little Ruby experience writes a gem, which ends up getting used by a third party, which overrides this global (or others). But really if you are the third party and you notice that pulling in some gem screws up every call to Array#join() and String#split() you'll either a. understand why this happened and fork/fix/pull request the gem, or b. don't understand why, remove the gem, and solve your original problem without it.
&gt; Does your library handle the 1.9 issue of UTF-8 to UTF-8? Yes, that's the whole point of it. You have a string which starts out in UTF8 (or any other encoding), but has some illegal bytes in it. Remove those illegal bytes, while remaining the original encoding. Why do I want to do this? Some instance of quite exactly what you said: &gt; I just throw them out because they offer no value. Spending time figuring out how to fix them wouldn't offer any real benefit. Yep, that's the situation I'm in (frequently), too. Although what I'm throwing is _illegal_ bytes for UTF8, not 'funky characters' that are legal for UTF8 but incorrectly OCR'd or something, the gem would do nothing for that. 
&gt; tenderlove, so do you think Rails should not have fixed this bug, instead you just should have said "Well, don't change the global variable, don't expect Rails to actually work if you do"? [Yes](https://github.com/rails/rails/commit/e482100d6ed022d00ba31c6c4377f6f947173337), but that isn't the point of this debate. If you change global variables, it effects your program *globally*. **Globally** includes third party software.
Could be wrong, but I think "User.find" is trying to find the user by id. So it's looking for a User with the email address as its id. Obviously that will fail. I'm not sure how you would use MongoModel to search for Users by email address, but that's what I'd suggest you look into. Maybe "User.find_by_email"?
If Array#join _forced_ you to use $, it would be a problem. It doesn't. Therefore, it isn't.
Can we quit using the term [Ghetto](http://en.wikipedia.org/wiki/Ghetto) already, please? Vastly inappropriate. If you want to play the blame-game, use tarpit or something.
Indeed. The point is that it effects third-party software in generally unpredictable and undocumented ways. In this case, it just does something weird to your logs, that at worst will make some other tool tryign to parse your logs confused. It is easy to imagine other cases where it could cause much more severe and obvious problems in the third party code -- that nobody would have predicted, that are not documented, and that are caused because someone writing the third party code did not consider that `$,` might change, and the person changing `$,` had no way to know what it might effect in third party code. Personally, I still think the answer is "Never change `$,`, and it's unfortunate that it exists at all"
If you really do only have UTF8, you can also, as others have said, do: string.encoding # =&gt; UTF-8 string.encode("UTF-16", :invalid =&gt; :replace, :undef =&gt; :replace).encode("UTF-8") Encode to UTF16 and back to UTF8 to get ruby standard library to replace bad bytes for you. In my experience, you have to go to _something else_ (and then back) to get stdlib to do this for you, but that should work. *IF* you know you are in UTF8, or another unicode encoding, so you can go to another unicode encoding losslessly (and then back). My solution works on any encoding, unicode or not, is the difference. My solution may or may not be faster or slower than the double-encode if you know you are in unicode, I have not benchmarked it. 
Or don't change `$,`. I am curious how many people have ever legitimately done this; I suspect, if at all, most have only done it in very short awk-ish one-liner style scripts. Personally, I continue to believe it's a mistake that ruby even offers such. Might make sense in sysadminy few-liner perl-ish script type tasks (which is probably why it's there, perl style) but is an accident waiting to happen in complex software using non-trivial gem dependencies. 
The problem is that many many times people leave the second argument out, **not** thinking "Great, this way the user can set `$,` and it'll respect that, because the right thing for this code to do is use whatever is in `$,`", but instead thinking "Yeah, I want the empty string as a join char, and it makes my code more readable and concise to leave out an explicit argument since it's the default." I _know_ I have, and I am skeptical of anyone who claims they haven't. Nor do I particularly want to think about "So, is the right behavior here to respect `$,` or to explicitly always use the empty string?" every time I call #join wanting an empty string. I am not even sure how to answer that question. At any rate, I personally will start always supplying an explicit empty string second arg in cases I want an empty string. I think. It'll make my code uglier. 
I might actually prefer a gem that somehow caused a raise if any code ever tried to reset `$,` (and possibly other similar globals). But I'm not sure that's tenable, once you figured out how to do it it'd still be hard to ensure your gem got loaded before anyone else possibly modified these variables. 
Raising an exception when using a method according to the Ruby docs is an abuse of exceptions. This is not an exceptional case. If anything, I'd rather see an error if someone has redefined $, without my knowledge. Honestly though, there are tons of other equally terrible things you could potentially do in Ruby, so I don't understand why anyone should be afraid of this one case.
FYI: Your link is wrong
That's not an unsolvable problem, it just happens that's the way "map" is defined. Redefine "map" in Array (or your own Array class) to duplicate self and modify or use something like self.class.new and then fill it with modified values and you have solved that problem.
In Ruby 1.8 `Array#join` used to use `$/` as the separator. This was changed to `$,` in Ruby 1.9. You shouldn't rely on the default value of the separator argument in `Array#join` for 1.8/1.9 compatibility. Also, stop abusing the word Ghetto.
&gt; Ah, but then you don't get to choose whether to return the subclass or Array. Why would you need that choice? If the calling context explicitly needs an Array, it can do the conversion itself... class Sub &lt; Array def map(&amp;block) self.class.new super(&amp;block) end end &gt; 1.9.2-p290 :006 &gt; a = Sub.new([1,2,3]) =&gt; [1, 2, 3] 1.9.2-p290 :007 &gt; b = a.map{|i| i*i} =&gt; [1, 4, 9] 1.9.2-p290 :008 &gt; b.class =&gt; Sub 1.9.2-p290 :009 &gt; c = b.to_a =&gt; [1, 4, 9] 1.9.2-p290 :010 &gt; c.class =&gt; Array The linked Rails patch is changing a section of code that is already rather hackish itself, since its behavior is based around "value" being a (sub-class of) Array instead of Enumerable. If it's not an Array, but some other enumerable collection, it just returns the collection itself-- which seems rather broken to me, because the collection might contain a Hash that won't be converted to a "HashWithIndifferentAccess" as any Rails-newbie would expect. To be quite honest, HashWithIndifferentAccess has always been rather pointless. There is a proper time to use String keys and a proper time to use Symbols-- and it's not hard to figure out which is which. HINT: use Strings when the keys are based on program input, instead of the code itself.
Not heard of that, no. But it is a great idea.
Or, as others have suggested, write your own map and/or array class with desired behavior.
Then you can't subclass from *that* subclass without guaranteeing that the signature of initialize() doesn't change. Changing the signature of initialize() is fairly common in Ruby, especially if you're already inheriting from Array or Hash.
Doh! Good points.
Why do I have to guarantee that? I don't even touch "initialize". You can subclass "MyArray" just fine and use it. The map function will query the class of the object it is called on, generate a new instance of that class and then fill it with, say, "&lt;&lt;". Here's the source: class MyArray &lt; Array def map t = self.class.new self.each do |e| t &lt;&lt; yield(e) end return t end end class MxArray &lt; MyArray end n = MxArray.new n &lt;&lt; 3 &lt;&lt; 4 n.map { |i| i + 1 }.class # =&gt; MxArray &lt; MyArray
I'm going to have to agree with the only comment on the article: &gt; Camel case? using a while loop to iterate over a range? Methods that start with get and set? Class variables? to_s with parenthesis? Seriously, the author should look into some Ruby best practices and a style guide. He might as well just write Java... &gt;The material is interesting, though the article is too simple to be taken seriously. 
Yeah, this is really bad Ruby; I couldn't really pay attention to the article because of the style.
I idiomized (is that a word?) it even a little further in my comment below. Especially on the generating a new chromosome and a random array bit.
This article's very odd... who's abandoned unit tests? Read the excellent guide to testing speedups: http://grease-your-suite.heroku.com/#1 For faster test setups, change from RSpec + FactoryGirl to minitest + miniskirt. 
Thanks to you and laerien. 
Alright, I think I've fixed it. Its about 2 am where I am right now, but, I think it looks correct. 
I agree. Testing has always had this weird issue where people argue whether something is a unit, functional, or integration test. While there's certainly value in having well-defined nomenclature, at the end of the day what really matters is if your automated tests give you confidence that your code is working the way you intend. Moving it to a different folder doesn't really change much. For my part I've just been burned way too many times by mocking in Ruby tests that I'll stick with factories.
When you need heavy mocking/stubbing then your code is too coupled. Factories and fixtures are fine for acceptance tests, but they should not be needed in the unit tests.
what do you use for unit tests? 
I get this, and it seems to be shared amongst a few of you here. But this is a complaint about the ORM library used, not a complain about factories, which is what the original post was complaining about. But, most of the code in my models is logic for building and fetching the right data from the database. Most of my tests are tests of this logic. I.e. ensure I'm only getting back objects where the "is_visible" flag is set to true. With such a narrow definition of a unit test most of my tests are outside of that scope, which still leaves the question, what's the best way to do these non unit test tests? Factories are still the best option I've found even though they are slow due to the creation and persistence of lots of objects in the database. 
Yes, often it is, that's what I meant, if that's what you've got. What do you need testing object "factories" for, though? Maybe I'm not clear on what you were asking. You asked "what do you use for unit tests?" What do you use for _what_? Why do you need anything other than, you know, the stuff you're testing?
That's the sense I got too, but that would mean he's complaining about the way an ORM library works, but for some odd reason decided to title his post "why I don't like factory_girl". 
I don't think it's odd, I think it's legit. Yeah, it's a bit 'witty', attention getting. I don't think it's a "sense" you and I are getting, I think it's pretty clear what he's saying. He doesn't like Factory Girl because it is, in his opinion, a hacky workaround to fundamental design flaws in Rails, that distracted the community from fixing the (in his opinion) fundamental design flaws, by ameliorating them, in a way that can only get you so far. If it hadn't existed, then the community would have been forced to confront the (in his opinion) fundamental flaws head-on instead. Yeah, he's being clever, but that's what he's saying, and I think it's a legit point of view, in principle. (I think the solutions to what he considers fundamental design flaws are a LOT harder than he probably thinks they are though, people will try and fail and try again; and sometimes failing can make things _worse_ overall with over-engineered monstrosities; which may mean that ameliorative measures _are_ important. Although personally I try to avoid FactoryGirl too. :) ) "Why I don't like the warnings on the side of cigarettes: Because they make people think they're doing something about the problem when they actually do _nothing_ to reduce deaths caused by cigarattes, they should just illegalize them!" (by analogy, not neccesarily what I think)
I think that solves half of the problem with fixtures, which is keeping them valid. The other problem I have with fixtures is that it's unclear to me, looking at a given piece of fixture data (or factory to generate this fixture), which tests use it. Over the life of an app tests come and go, but I'm always afraid to delete fixtures because maybe some other test also depends on the fixture, and fixtures are often intertwined. After a couple of years I'm left with a giant steaming pile of fixtures. 
I can only speak for myself. I just create them, in a setup method, with the same code I'd use to create ActiveRecord objects in the actual app. I just go ahead and create them. foo = Something.new(:whatever =&gt; foo) foo.something = something_else foo.save Whatever. If that gets too complicated -- in what are supposed to be _unit_ type tests, not larger 'acceptance' type tests -- I start thinking my design may be too tightly coupled spaghetti. And sometimes my testing setup is a mess. :) So that's what I was trying to say. I too am curious if others do what I do, or have other alternatives. 
I'm thinking your models are much simpler than mine. For example, where does something_else come from? I gave what I thought was a very simple example. A comment depends on a post and an author. That post then depends on another author and possible something like a subreddit. You're example would get much longer if it created all of that manually. A factory is a simply way to say foo = Factory.get(:comment) #give me a valid comment with valid dependencies This seems much better than creating all the dependencies manually in each test. Clearly this is more DRY. 
Sometimes I make helper methods shared accross tests to create standard things. Yes, I'm probably doing by hand what Factory.get(:comment) does. def sample_comment # whatever Factory.get(:comment) does, possibly # referencing other similar helper methods end I never said don't use factory_girl or whatever! Yes, my way is rough sometimes. But I don't need to learn another API besides the AR one I already know, nor do I have to figure out how to do weird edge case things with a different tool other than the AR that I already need to get my app to do instead. But, yeah, it's a mess sometimes. Everything I've tried has been a mess sometimes. I'm not trying to convince everyone to do it my way, that's just what I do. I gather the OP's point is that AR should be redesigned in some way so that this is easier. The details of that are unclear to me, and I don't think OP was saying people are 'wrong' for using factory_girl now, just things would be better if it were not neccesary. 
I've been trying to mix both approaches for a while, among others I wrote a gem called [transactionata](https://github.com/colszowka/transactionata) that hooks into the Rails Fixture load process and allows you to define test data once per Test/Unit class. With RSpec, I've recently had good success with disabling transactional fixtures altogether, then adding database cleaner, generating my test data and wrapping all specs in transactions. Basically what Rails fixtures do, but with dynamic data. Code kinda looks like this: &gt; # spec/spec_data.rb (required from spec_helper) &gt; &gt; DatabaseCleaner[:active_record].strategy = :transaction &gt; DatabaseCleaner.clean_with :truncation &gt; &gt; RSpec.configure do |config| &gt; config.before(:each) do &gt; DatabaseCleaner.start &gt; end &gt; &gt; config.after(:each) do &gt; DatabaseCleaner.clean &gt; end &gt; end &gt; &gt; # Factory-generated test data goes here Then, in most tests I either use some of the ready-made test data, or use FactoryGirl.build. In most cases, persistence is not required for testing things. This still leads to all the factories running when tests start up, i.e. when using spin/spork and running just a single spec file it'll be slower than with fixtures, but overall it is quite fast (of course that depends on the amount of test data). I also got this feeling that having a well-defined suite of base data actually leads to cleaner tests, unfortunately coming along with the inherent tradeoff that when reading the actual specs you have things that behave in a certain way but no explicit reason why (just a Widget.find), as opposed to i.e. using Factory Girl all over the place, where you can immediately see what is going on by the attributes passed in. I think that this can be mixed well with the FactoryGirl.build approach or explicit (re)setting of the important attributes on the existing records though, for cases where a very specific condition is tested. I also experimented with various other things based on the approach mentioned above: Generating fixtures or db data dumps out of it (as Aaron suggested), loading it (and starting/stopping the transaction) only on demand using rspec tags and so on. I usually cancel my efforts after a while because the maintenance of it might be a bit unwieldy, and I'm pretty fine with the current speed of my specs. For example, dumping the spec data (as fixtures or db dump) could happen based upon a md5/sha of the seed data file, but that wouldn't incorporate changes in the domain logic (i.e. in the models), so you might end up with brittle test data just as with fixtures. Regenerating every time any code changes defies the purpose of the data cache on the other hand. That being said, I think having some kind of standardized approach for defining test data seeds, dumping on demand and loading them would be awesome.
I don't use Rails or Ruby, but it sounds like the domain code is coupled to the persistence mechanism. Here is Bob Martin's talk about how to structure a Rails app where the DB is on the edge of your app, not in the center... http://confreaks.com/videos/759-rubymidwest2011-keynote-architecture-the-lost-years 
Read your article, but I couldn't piece everything together into a working simulation. I looked at a couple more articles and pieced together [this guy.](https://gist.github.com/3147851) Edit: Added 2 bits and some mutation to make everything more interesting and keep the algorithm from getting caught in locals. It converges upon the ideal value within 1 iteration most of the time simply by generating 10 combinations out of 16 possibilities. A smaller chunk of the time, it converges to a decent value in 10 iterations. Only once did witness it evolve the ideal solution from a population of nonideal solutions, and that took two generations. Fun idea, but the problem domain is so small that it's hard to show off a GA. Looking forward to part 2 :)
i'm unconvinced of the benefits of this in most cases. If I take out the code which deals with the DB from my models there is basically nothing left. And I still need to test the code that deals with the db. 
I would have pitched this at a higher level: Class methods vs. instance methods are an Object Oriented topic, not a ruby topic. Perhaps a better title would help: &gt; New to OO? Learn the difference...
This guy's got it. Dependency injection and inversion of control solve coupling but make people wanting simplistic ar objects scared. We need more mature patterns to get more lip service
Not a song specifically, but I've always through [Shakespeare](http://en.wikipedia.org/wiki/To_be_or_not_to_be_%28Shakespeare%29#Text) could be more efficiently rendered in code: question = (2 * b) || !(2 * b) if mind.nobility(suffer(outrageous_fortune.slings, outrageous_fortune.arrows)) &lt; mind.nobility(take(arms, sea.to_troubles)) sea = [] exit 1 sleep 0 end ... etc
The idea is to test the code that deals with the DB separately and have it in a library and test the app separately, the app testing code should not test activerecord.
Being on the eigenclass doesn't guarantee that a method is a class method. If you `extend` an instance it adds the methods to the eigenclass of the instance.
Don't brainstorm too much. The key thing in programming is that you are testing your code. The specific library used is not really that big of a deal. i would suggest you get comfortable with writing tests, lots of tests, and reading the unit test coverage of existing popular libraries including the ruby standard libraries. To get started writing your own tests for your own code, use the built-in framework ( minitest ) which comes free with every ruby installation. Don't fixate on TDD vs BDD etc just start reading and writing tests. Start learning ruby idioms ( by reading existing open source ruby code and by reading the many excellent books out in the market ) Once you feel reasonably comfortable with the concept and practise of writing tests, then check out TDD/BDD style testing with libraries like cucumber and RSpec. The important thing in testing is your test cases and test suites. The library used is not that big a deal ( DHH, the guy who wrote the initial version of the ruby on rails framework still continues to use the built-in test framework. And given the stability of rails, i would say he has done a reasonably good job ;-) 
MiniTest and Test::Unit are explicit, transparent and simple. That's what testing should be about.
Your comments_count example demonstrates the trouble I have with this whole debate. There is something that I just don't understand here... Your test isn't going to work because, as you said, AR is going to turn #count into a SQL query. So to make your test work, you could implement comments_count by counting up the number of comment objects in your post -- the standard OO way to do something like that. Great, you just made the test faster. But you made your application slower. When I do a count, I *want* it to do a SQL statement. I'm building a SQL application. Loading all the comment objects just to count them is crazy... I don't mean to call you out personally or anything -- I mean "you" in the general sense. I wish my tests ran faster, but I don't want to reimplement the entire object graph (meaning: all my attributes and various relationships, has_many, etc) outside of AR just to make that happen. But isn't that what Klabnik, etc, are proposing? 
&gt; But, most of the code in my models is logic for building and fetching the right data from the database. Most of my tests are tests of this logic. I.e. ensure I'm only getting back objects where the "is_visible" flag is set to true. Yes, that is exactly my problem too. Currently I'm working on a Rails application that needs to export objects into a bunch of different XML outputs. I have a bunch of tests for those outputs, and they all start with building up a set of AR objects in the database. I could make those tests go faster by implementing Comment and Post outside of active record. But then I'm just duplicating a lot of code that AR gives me for free.
Don't spend a lot of time thinking about the code you are going to write for a reusable library. Just make you sure you write a LOT of code. That's how you make it awesome.
Minitest. It's the Ruby standard, very fast, and simple to learn. It provides all the basics for unit tests, spec tests, benchmarks, mocks, etc. I also like to add in miniskirt (for factories) and mocha (for mocks/doubles). 
My test suite is Guard running Rspec, with FactoryGirl in place of fixtures. I also use Spork to speed up the tests a bit (caches the rails environment). Can't if that is what would work for you, but that's what I like.
Just a warning, everyone who responds here is going to be running a different stack. I run Rspec + Mocha, vcr occasionally and fabricator. Ditched autotest a while back because I like running specs manually. A good CI environment is a worthwhile replacement to autotest/guard.
We evolved an app architecture similar to the one he presents. However, it is also proprietary. It is truly a joy to work with though :) I would say the key characteristics are roughly: * It is a Ruby/Python app, not a Rails/Django app. Most files are [domain logic](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215) that don't import the web framework. * The Rails/Django ORM is hidden behind [Repositories](http://devlicio.us/blogs/casey/archive/2009/02/20/ddd-the-repository-pattern.aspx) * The domain objects are plain-old-Ruby/Python-objects, not web framework DB models. * The Rails/Django http container is wrapped to implement a protocol independent [req/rep](http://en.wikipedia.org/wiki/Request-response) container. * In unit tests, we are free to either mock the repositories, or [fake](http://martinfowler.com/articles/mocksArentStubs.html) them with in memory dictionaries. * In unit tests, we use mocks to cut the object graph, since the component under test shouldn't need to travel long [distances](http://en.wikipedia.org/wiki/Law_of_Demeter). * Plugging in the real database implementation is an afterthought. We had a significant portion of the app working with memory fakes before we got around to it.
Miniskirt's great. factory_girl functionality in &lt; 40 lines of code with better interpolation.
Minitest. Its there by default. And its fast.
Part 2 is out: http://rubysource.com/genetic-algorithms-in-ruby-part-ii/
i'm sure you didn't meant it this way, but your comment comes across as condescending. I've been doing rails for a long time, my first production rails app was written before rails hit 1.0, and I've been doing rails ever since. I've written a lot of rails sites from scratch and maintained a lot of rails sites that were originally written by others. My latest rails site is http://video.disney.com which should give you some idea of the data models in one of my rails apps. If you look at a specific video (http://video.disney.com/watch/let-s-go-to-the-mainland-4be70e0e0d8ccb6a6e9faf04) you'll see that a video belongs to a movie or a show, which belongs to a property, and it may or may not be part of a collection. Now, nearly all of the logic for these models is related to external systems whether it's a database, the system that transcodes videos, the system which generates thumbnails, the api which contains the data about some Disney data, etc. There is very little logic which lives entirely in the ruby process space with no IO. Testing that code is really really easy. My point here is that we should be talking about ways to do the hard part of testing, not the easy part. 
rspec, definitely. I've found that pure unit tests, ones that test a single class only and mock the class' boundaries, aren't that useful in Ruby. Mocking is just a little too easy and powerful. It seems better to concentrate on tests at a slightly higher level which touch more of your application stack.
Event machine is pretty useful. Threads is something that people have a lot of trouble understanding and this makes it really easy to work with. I would have liked to see a larger example with an actual use case though. The code snippets don't really give you more information than the api documentation. For people looking to build scalable applications, [Resque](https://github.com/defunkt/resque/) is definitely something to look into too.
How timely for me, I seriously just bought Ruby Motion 15 minutes ago. Upgrading my computer now before I install it, will definitely check this out. Thanks for the link! edit: My God, BubbleWrap.... looks awesome.
A good CI environment is a worthwhile _addition_ to autotest/guard. But a CI does **not** replace autotest/guard as the feedback loop is simply _way_ too long.
`you.must_be :new_here`
You gotta give us some constraints or details. What do you like working with or on? What is your skillset?
Yea these extremely simplistic examples and tutorials are dime a dozen. Getting something more complicated up and running is not so easy and the documentation is often minimal to none. Also why eventmachine as opposed to something line unicorn?
Please, **avoid** defining your own `String#shell_escape`. [Shellwords](http://rubydoc.info/stdlib/shellwords/Shellwords) already adds [String#shellescape](http://rubydoc.info/stdlib/shellwords/String#shellescape-instance_method), [String#shellsplit](http://rubydoc.info/stdlib/shellwords/String#shellsplit-instance_method) and [Array#shelljoin](http://rubydoc.info/stdlib/shellwords/Array#shelljoin-instance_method). Also, probably not a good idea to suggest readers copy/paste code that hasn't been audited for security. :) Other than that, great blog post!
Oh, so Ruby stdlib finally got it. It definitely wasn't there in 1.8.6 and before back when I wrote it first, `shellwords.rb` contained only totally worthless `Shellworld#shellwords`method back then.
Yeah, that will help a lot. Surprisingly Perl had far nicer interfaces to a lot of these than Ruby for very long time, Ruby probably copied very early Perl 5 interfaces and never updated them until recently.
If you do some operation on a big directory tree, thousands of useless forks/execs will add up eventually. I've made enough backup scripts to know that. Security, reliability, conciseness, and readability difference is really not in territory of opinion here. It's not Ruby vs Python thing, it's general purpose language vs something extremely narrow. At best shell script will be just as good as Ruby (very rarely). There will simply never be any case when it will be better.
I wrote a gem called 'graphable' which extracts a neo4j graph from an activerecord-y model of a database. It's not particularly well tested (extracted it from another project, it was written over the course of a few days, cowboy style). But it's pretty neat for this kind of task, I think.
If you choose your environments, you can as well choose to install Ruby there. If you try to have something running even on just up to date mainstream GNU/Linux and up to date OSX, you'll quickly figure out just how inconsistent shell is. If you absolutely have to be compatible without bothering to run a single command to install Ruby (on few systems without it), Perl is the way to go. It's on pretty much every Unix system for the last 15 years and works far more consistently between systems than sh ever did or will.
It's also important to keep in mind that the Rails MVC conventions are not explicit. The connection points between models, views, and controllers aren't always obvious in your application's code. Its design decisions favor convention (knowing what should happen by default) over configuration (specifying what should happen in application code.) So don't feel bad if you can't trace a particular thread, that just means there's something you need to look up or ask your boss about.
I think [this article](http://thedailywtf.com/Articles/The-Mythical-Business-Layer.aspx) does a good job at explaining what I mean.
Quick, rough analogy. If you go to a sit down restaurant, you order off a menu, from a waiter/waitress, and a chef makes your food in the kitchen. The menu is like the view layer. The waitress is the controller, and the chefs are the model layer. Also, it seems to me from the phrasing of your question that it's not MVC you don't get (which is OK), but rather, the Rails implementation of things. Don't sweat it, the best thing you can do is just sit down and grind on your own project for fun. If stuff is in the "wrong" place or you mess up, it's OK. With experience you'll get it, that's what matters most. Roughly speaking, younger developers will probably really start clicking around 3 months.
Ummm...It's important to spend time thinking about your code. If you don't think about your code, who will? And more code doesn't always equate to better code. The point i was making is that one can write perfectly good test code with either minitest/testunit or rspec and that when one is learning to write tests, it's not very productive to spend too much time debating which is better. They both have their advantages and dis-advantages.
Keep in mind what Rails calls "MVC" is not the original MVC pattern. Good to know if you ever converse with any SmallTalk guys ;)
On the other hand, every component of MVC can always be broken down into more than one layer. Actually anything you can write functions/abstraction/libraries for means a layer is already created. Only a novice needs black-or-white rough guide to follow. They can only become experienced when they learn the important of the word "it depends". At which point, they will know that the "M", "V", or "C" are all blurry lines depending on the situation. Heck, even "code" and "data" can be the same thing. 
I haven't used ruby or rails yet, bit I would like to know the results.
Right, but you've explained "model" and "view," but not "business logic."
/u/joesb explained, in plain English (not like an encyclopaedia), what "model" and "view" are in the grandparent of your original comment, but not "business logic." You've said "model" and "view" are basically as generic. Therefore, it can be assumed that if an explanation was needed for "model" and "view," that one is needed for "business logic."
I suspect it will be mostly ActiveRecord. The Rails philosophy is "use what's there until there's a reason not to". Except with testing (RSpec) or views (Haml).
And javacript, and css, 
It's a shame you got downvoted so hard, especially in /r/ruby, where you think they'd undesrstand. If it's any consolation though, I totally agree. Bash is an outdated language, and we shouldn't be using it for modern programming. People will come around eventually - I think they just have emotional ties to bash. Thanks for the code, btw. I will definiitely be using your `unall` - it's somehitng I've been looking for for awhile now!
Hi I'm also working on a task tracking app, checked out your project out of interest. Since you have a simple and working app there you're a lot further than I am, I guess I'm aiming for something way too complex to finish it ever. Anyways, your code looks good and very clean with lots of comments. Tests look good also. I didn't try to run the program, so I have no real user experience. Since you asked for comments, here are some: - You can use OptionParser to parse command line parameters - Classes for the different command line commands might make the handler code a little easier to follow - Maybe a little too much documentation on the small and obvious methods, like the one below: # Clears the current task # # @return [void] def clear_current_task() Having good method names that describe the real intent of the method reduces the need for documentation. "handle_categories" is on the other hand the opposite of this and should have a different name: # Displays all the categories available # # @param [Array] args the arguments passed to the app by the user # @return [void] def handle_categories(args) Can't figure out any other relevant issues there. Good luck and keep up the good work.
I know the feeling with YARD, it definitely feeds OCD with "gotta comment them all". I had the same thing with javadoc, but luckily it's possible to get over. For the option parser, here's some simplified code from my own project: http://pastebin.com/uz54MKmM The trick in execute() is that OptionParser.parse() returns a list of unparsed items, where I get the version number. edit: The help method should contain the full help page for the command, but instead there's just some test text. opts.to_s returns the options in a nicely formatted way, so it's easy to make the full help page. Also it's pretty easy to build functionality on top of that structure, I have a command that list the commands and prints out their summary. 
I'm from the old generation who came to Ruby from Perl, long before Rails and immigrants from Java came. Perl took its commitment to being language for writing admin scripts very seriously, and there was also CPAN long before gems with a lot of admin scripting functionality.
Wow, how presumptuous of you it is to think that it is my job to provide a layman's description of engineering concepts based on what [other](/u/joesb) [people](/u/KerrickLong) believe is necessary. You seriously underestimate the cost of the demand you're making which makes you come across as overly entitled. At what level would you like me to simplify this discussion for you? Do I presume that you have a basic knowledge of multi-tiered architecture? If you don't already understand "model" and "view" do I need to assume I must explain lower level concepts so I can illustrate the similarities in their definitions to those in a "business logic layer"? Am I allowed to assume that you work in a field where you are doing software engineering of some kind? How much can I assume you understand about the fundamental of object oriented design? Do I need to dumb down all of these topics as well since you don't want an "encyclopedia" definition? I need to know much more about my audience before I can provide a satisfactory answer to your oh so rudely put demand. A layman's description of domain specific knowledge like this is incredibly difficult, time consuming, and is not something you should feel so entitled to. In the future, if you don't understand a concept and want to demand an explanation try politely asking instead of demanding. You'll get no more help from me today than what you see below. Something being "generic" does not mean it demands an explanation. When I sated that business logic layers were just as generic as model and view I was speaking of their definitions. It was a rebuttal to [yourparadigm's comment](http://www.reddit.com/r/ruby/comments/wxouv/when_did_modelviewcontroller_finally_click_for_you/c5heygu) that business logic layers shouldn't be discussed "for the sake of the novices". That point is fallacious to the point of absurdity. In short, just because something is difficult for novices does not mean that it is worthless, dangerous, or should be avoided.
I never demanded a thing. I told you that you'd neglected to explain one thing while explaining others--I thought, it turns out you weren't the helpful one at all, that was /u/joesb. You don't have to participate by explaining anything, but you certainly should _refrain from participating_ if you're going to do nothing but be a contrarian.
I'm sorry for my misunderstanding but the following, posted to someone who was not providing layman's descriptions, came across to me as a demand: &gt; Right, but you've explained "model" and "view," but not "business logic." Followed by: &gt; Therefore, it can be assumed that if an explanation was needed for "model" and "view," that one is needed for "business logic." That said I apologize for misinterpreting your intent. I seriously disagree that I am being contrarian. I participated because someone's assertion that you should avoid using a term because it could confuse "novices" seemed fallacious. My contribution was to illustrate that point by showing that the definitions of "model" and "view" were slightly more generic than that of a "business logic layer". The reason this logic is fallacious is that if we're deciding not to use "business logic layer" for the sake of the novices then under the same logic we should avoid MVC as well! Given the existing definition of model/view/controller by /u/joesb, I provided a link to a good description of what makes up a business logic layer. I don't believe it is wrong of me to assume that anybody who wants to take the conversation further should first have read the description of a business logic layer. Edit: I say "that said" way too much... re-wording.
yes. since ruby on rails is the most used web framework and activerecord comes with it, activerecord is taking the lead. by the way, i'd appreciate if you guys could spread the survey. 
Oqa, thanks for the link to your code, definitely interesting and although I had done something similar at first, I would like to avoid having tons of options that start with a -, for example -init or -task and so on. My idea was to have something more like git or rake where you have real action words and then options on those action words (or commands) About the help message, I am working on it. The idea is that the description of a command returns a small summary of what the command does (what you see when you do 'r2do -h'), but for all the various options then there is the help (once implemented you will be able to do 'r2do help task' and get all the help related to the 'task' command) The next release v0.0.8 has some refactoring of the code (including handlers refactored to Commands) as well as the ability to rename a Category and a couple of fixes for some small bugs I found, but it also includes the help for each command, with a nice detailed explanation of each command and the options available. I hope to release it by the end of today.
Looks good, but one thing I don't understand is your use of "unless not" a lot, or "if not", it makes the code more complicated than it needs to be, for example: unless not task.nil? why not: if task.nil? or if you wanted to check something was not nil, you could always say unless task.nil? the not is inverting the condition and can make it very difficult to follow in complex code
First of all, sarcasm. Of course you should spend time thinking about your code - your suggestion is "Don't brainstorm too much - write lots of tests". This does not ensure good code. As Dijkstra said, "Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence." As far as rspec/minitest, that is a choice of personal preference.
I see you've been inspired by [my blog](http://jscal.es) - glad someone's reading it! And gracias for the shoutout on the GitHub readme :) Nice post, by the way. Definitely checking this out.
1.8.6 doesn't provide GC tweaking via environment variables. It was first introduced in 1.8.7 REE, and then picked up by MRI in 1.9.2 and 1.9.3.
You might see gains just switching to REE. It's fully compatible with 1.8.7 MRI, and it has a number of features tuned towards running Rails apps rather than just small Ruby scripts. I used it for years before we made the switch to 1.9.3, with great success.
Images of the actual graphs would be nice.
Good idea, I've added some to the post
there is an "other" field you can type your choice.
Minor heads up: You probably want to pick a different name. "graphene" has been used by this popular project: https://github.com/jondot/graphene for quite a while now. Given that your gem also deals with graphing, it'd be a good idea to give it a different name to prevent confusion.
Thanks for the heads up, but there's no good way to change the name of a gem once published. Since the other project isn't a gem, I'm leaning towards ignoring it.
"Tribute" by Tenacious D: https://github.com/judofyr/timeless/blob/master/content/tribute.rb (by judofyr)
The OP (jscoder) explicitly mentioned brainstorming and not being able to decide as to which tool to use for testing. I personally feel that when one is starting out in programming, brainstorming on choosing a testing library is counter-productive. your opinion may vary. Kudos on mentioning Dijkstra, one of my heros :) 
Now up to version 0.0.2, which adds Dot and Accumulator Bar graphs.
I think I put in a comment reasoning why I didn't use idioms - the concept of how the mating was done was very important, so, I wrote it out in full. 
because people want to have a hole in their wallet. (apple computer plus 200 plus 100 to be a developer, at the least 900, not including tax)
Why? Most people these days use CoffeeScript and SASS because it is already there.
I'm sure if Rails 4 would change to Datamapper, a lot of people would migrate.
Getting something complicated up isn't the job of the tutorial - that's what you have to do! Putting the pieces together requires knowing what the heck the pieces do by the themselves. But, I'm working on a Celluloid article that should also cover a large application that uses all of the concepts. I'll post a link here once I'm done. 
tl;dr - They share a similar DSL style; Sinatra is leaner and leaves more in your court The DSL between the two takes on a similar look for sure. However, the grape DSL is much broader than Sinatra's. Three differences in Grape to notice off the bat: Grape by default will serialize the response from an action to JSON, XML, etc. In Sinatra (by default) you'd do some_hash.to_json or whatever at the end of the action. This is an example of what the Grape authors means when they say Grape is "opinionated". Also, Grape has a built in version method so you can nest routes or use a header to control the API version routing on a request. A typical web app tends to not support multiple versions at once; this is why it makes more sense in a library dedicated towards API instead of one used for both webapps and APIs like Sinatra. Lastly, I believe it supports a few kinds of resource/route nestings out of the box, which Sinatra does not. 
Use relative file paths in your requires — http://guides.rubygems.org/patterns/#loading-code Consider using a [Struct](http://www.ruby-doc.org/core/Struct.html) for Title. Document your code, [rdoc.info](http://rdoc.info/gems/filmbuff/frames) is your friend. Trim the README a bit—I know how to use gems, what's different about yours? You're mixing configuration on [instance and class](https://github.com/sachse/filmbuff/blob/d606dd517af4b34f7e7caf70b1660d40379d73b5/lib/filmbuff/imdb.rb#L16) which may cause confusion, but this is due to httparty. Many people are foregoing httparty for [faraday](https://github.com/technoweenie/faraday)—it's more flexible and has a nice middleware architecture. Nice, though. :-)
Pretty good overall. These are just suggestions but That loop in find_by_title could definitely be refactored. My approach would be an IMDb::Movie class. I would have an initialization method called new_from_api and just pass the results to that and make the Movie class handle all the parsing and assignment. I see you have a Title class, why not use that for all movie results? This may also be a bug next unless row['id'] &amp;&amp; row['title'] &amp;&amp; row['description'] I believe the condition only gets flipped on the first. Considering getting rid of your gem dependency for HTTParty. Or use it as a default but support people using their own http libs, either through configuration or allow people to monkey patch it. You can give people something to override. Get rid of legacy mode. Just force people to move over otherwise you're maintaining cruft. These suggestions are just after a quick browse and you may have a valid reason for why you do it that way. Hope that helps.
&gt;If you want to support your lib's legacy api, I would suggest releasing a tiny update (0.1.6?) updated to use IMDB's new API. Then, begain a new branch with 0.2, breaking compatibility however you like. Explain somewhere in your README. Good idea. I'll probably do that instead of what I have now. And yes, seems like I better make use of RDoc. Thanks.
Yes, seems I better create some documentation. Thanks for the heads up about Struct and maybe some "selling points" in the Readme, good ideas :)
Can you please expand on what materials you used and how much money you spent, ultimately?
I spent $10 on the kindle edition of the [book](http://www.amazon.com/Engineering-Long-Lasting-Software-Computing-ebook/dp/B006WU5G4C/ref=sr_1_1?ie=UTF8&amp;qid=1343153369&amp;sr=8-1&amp;keywords=software+engineering+for+saas), that's all. Once you complete the first homework they give you a credit for an amazon micro-instance as well as a pro github account. You can use the micro-instance as your dev environment, download and use their pre-configure VM, or in my case I just set up all the necessary software (git, ruby, etc) on my own machine.
 next unless row['id'] &amp;&amp; row['title'] &amp;&amp; row['description'] is: next unless (row['id'] &amp;&amp; row['title'] &amp;&amp; row['description'])
That's good, I like that :) I wasn't much for all the break if and next unless etc.
Sweet. I just got a task to make a metrics tool with line graphs today. Will see how this works :)
Is there an option to remove the background image on the resulting graph?
&gt; DHH, the guy who wrote the initial version of the ruby on rails framework still continues to use the built-in test framework I don't take DHH's opinion too seriously any longer.
Well then they wouldn't necessarily be 'unit tests' at that point, they'd be 'integration tests' right?
My clients are happy to write or review cucumber scenarios... I guess this would be a good class for me.
I think you can make it a solid color - http://gruff.rubyforge.org/classes/Gruff/Base.html#M000049 ...pie_chart('/chart.png') { |chart| chart.theme = {...} }
Right. Terminology is tough, though, because many Ruby tests are called "unit tests" despite ultimately going through a lot of the application stack, even down to the database. Rails projects tend to do this, especially.
Agreed. I think every time I read something about EM, it has the EchoServer example. That's nice for the first look at EM, but sure doesn't give much insight into the peculiarities of the library for building something "real". I haven't found many write-ups explaining anything complex, but what helped me the most was just going through other libs that use EM.
Returns the standard Rails 500 error page.
Indeed. I'm in the process of jumping ship to Unicorn specifically because it does rolling restarts. Given that Unicorn does its own pool management (which was really the biggest win of Passenger over competing solutions at the time), and I don't trash my app if I have to reload my webserver for a config change, it's looking like a flat-out better solution at this point. I am deeply grateful to the Passenger team for what they've done to accelerate the state of Ruby deployments, but Unicorn is a hard product to beat these days.
EngineYard ate the server.
realised it very late :D there is nothing wrong in being tardy, it's all about learning :D
Yup, we're aware of Unicorn. It's pretty cool technology. We've even [contributed](http://unicorn.bogomips.org/CONTRIBUTORS.html) to it so we know what's so good about it, but also what we can improve upon. A few differences between Phusion Passenger and Unicorn are: 1. Rolling restarts in Unicorn require twice as much memory because there will be a point in time where all old processes and all new processes are simultaneously running. It also requires some process management scripting. Phusion Passenger Enterprise improves upon this by being fully automatic and by restarting processes one-by-one. If something goes wrong during a Unicorn rolling restart you have to do some manual process management to fix things. Phusion Passenger Enterprise features something we call _deployment error resistant_ which we will talk about in the next Roadmap Preview. 2. Phusion Passenger does _dynamic_ pool management (number of workers are dynamically adjusted according to traffic) 3. Phusion Passenger directly integrates into the web server. If you run more than 1 app on your server this is a big administration win.
All done, thanks!
The biggest win of Passenger for many makes it crazy easy to set up and manage deployes for newbs. Deploy your rails/rack app to the server, one line (or sometimes no lines) in apache conf, the end. touch tmp/restart.txt to restart, that's it. 
Passenger made my life a lot easier, good for them making some money out of a product that is vital to my business. More money for them allows them to spend more time and resources on it. I would love to see some more tooling that allows me to monitor passenger remotely. 
Not necessarily, but sometimes. You have methods in Ruby that modify their receiver without a bang, say Array#shift, and you have methods that do, say Hash#update!. You also have methods from ActiveRecord that raise an error when they have a bang, but return true/false without the bang. Methods with a bang can be confusing in ruby, but the only consensus is that the bang itself means “be careful”. Usually, when writing methods yourself with a bang, it’s a good idea to include a method without the bang. If you cannot think of such a method, it may even be preferable to just not use the bang at all.
Yup, the bang method only exists if there is another method that does the same thing but not so dangerous. Ie. certain Array methods. Absence of a bang doesn't the method won't modify the receiver. btw. Hash.update is without a bang, at least in 1.9.3.
How do you link to full example, absolute URLs to rubydoc.info, absolute URLs to some custom place you have installed the rdoc on the web, absolute URLs to actual source in github (master or versioned?), something else? Just curious how others are doing this, I have not been sure of the best way when I've wanted to do this. 
wow, have gems finally stopped requiring `s.rubyforge_project`? Hooray! I missed that news, I've been putting dummy `rubyforge_project`'s in, from the days when it actually was required (which was bizarre even then, even when rubyforge was the most popular host, why _require_ it? It was always weird). 
I wrote Celluloid, and yes I agree ;) What the author is trying to say here: "The thing is, all threads inside MRI/YARV aren’t really concurrent – everything is run under a single thread. This is called the Global Interpreter Lock." Is that MRI lacks *parallelism*. No two threads are actually running simultaneously, instead they are time-sharing the Ruby VM via the GIL and YARV's timer thread (on 1.9). This is indeed true *concurrency*, as in there are several threads of execution contending for a limited resource. The problem is that there is no *parallelism*, i.e. only one Ruby thread can run at once. This is the same as systems like e.g. Node.js which only allow one thread to execute at once. It's just instead of manually splitting your code into a bunch of callbacks, you just write the same synchronous Ruby code you'd ordinarily write, and threads provide the concurrency instead of a callback-driven approach. Otherwise, great article!
yep, it's all true. Sometimes you need actual parallelism, sometimes you don't. People should remember that when threads were invented, hardly any systems anywhere had more than one CPU -- they were in fact invented to be useful without true parallelism, and in cases where concurrency is useful anyhow -- and they still are useful there! I think there's a widespead misconception that you would never want to use threads under MRI or other GIL interpreters. It's not true, there is a large class of problems where threads are still useful even with the GIL (i/o bound, periodic timers, etc); there are also some problems where it's not, true. And thankfully using threads under MRI got a _lot_ better the most recent versions of MRI, and more gems are being written to be threadsafe where appropriate than used to be. And Celluloid is pretty awesome. 
I will consider resizing to make the page load faster. 
FWIW image resizing in the browser is also not always brilliant either, so it looks jagged and nasty (eg, it looks horrible in FF/Win7). If you resize it to the appropriate size in a paint program you should be able to antialias it and have it look good in all browsers, *as well* as it downloading faster and not wasting memory/battery power/bandwidth on lower-end devices.
would you pay for it? :)
The section I care about most, "Why Backburner", says "to be filled in". Differences from Resque? Besides not using Redis.
If the pricing is acceptable and the additional features are worth it, yes definitely. We pay our engineers very well, if things like these will make their work go smoother, or our products work better, it's always worth it.
Yes, we will remove it. The donation page has been renamed to 'donation' for a while now in preparation for this. The passenger-make-enterprisey tool will disappear as well.
Seems &lt;%= adverb %&gt; to me. What's the &lt;%= noun %&gt;?
I'm a programmer not an English major, Jim. :P
Didn't Twitter change over to Java? Maybe this page is left over from before the change.
http://www.igvita.com/2010/05/20/scalable-work-queues-with-beanstalk/ http://adam.heroku.com/past/2010/4/24/beanstalk_a_simple_and_fast_queueing_backend/
Is their actual web page rendered with Java? I would think they would stick with Ruby and ERB for that part.
This looks like RoR and the ERB rendering engine.
Front-end RoR, back-end Java. Otherwise known as a programmer's reverse mullet - party in the front, business in the back.
It just looks too perfect to me to be non-intentional.
The last blur doesn't look very blurry kinda looks like DNC
This, my friend, is the greatest thing I read all year. 
could be this: https://github.com/sstephenson/eco/
I have filled in the "Why" section with a detailed explanation of the different job queues and their underlying persistence strategies. Check it out in the [README](https://github.com/nesquena/backburner)
Stop correcting people's grammar, Hwan!
Hmm, is that github I found the actual source of the free passenger? Is the free passenger source publically available? I never realized that. Will it continue to be? It's got an MIT-style do-what-you-will [license](https://github.com/FooBarWidget/passenger/blob/master/LICENSE), will that be changing?
Cool. I never looked into that. It may change to a differnet license, but your current plans are for it to be an _open source_ license indefnitely? Sweet. Hopefully we mean the same thing by 'open source' -- that people have the right to modify code and release a modified version. (Which is included in the [OSI's definition](http://opensource.org/docs/osd), point 3)
Actually, they were looking at [moving to Scala](http://www.artima.com/scalazine/articles/twitter_on_scala.html).
I find that ESL students have a better analytic knowledge of English grammar than do English majors.
So true. The study the language in a much more formal way than most native-speakers do.
I like that (as i gather from the tutorial, I haven't used it) the Stripe-specific code allows the credit card number to never even TOUCH my server, it goes straight to Stripe and my app just gets a token that it uses to communicate with Stripe in reference to the transaction. Is there any way to do that with ActiveMerchant, with a vendor that supports that kind of flow, like Stripe?
As someone who got my start in web development using classic ASP, I was momentarily horrified by this. 
whole dev team here is laughing at that.
I am very flattered!!
Posted as a comment on the OP directly, but I'll put it here too: Super useful, thanks! I'm going to have to read it a couple more times to fully understand what's going on. But one question about supervise. In your example you're doing supervise_as inside the loop. websites.each do |website| supervisor = MarkupPutter.supervise_as :mp, website But you say " puts an entry of that name in the registry." So wait, aren't you four times (once for each website) putting an actor in the registry as :mp? Over-writing the previous one each time? That doesn't seem right? Worse, if you don't over-write, might you possibly end up using the _same_ actor each time in the loop instead of creating a new one like last time, since you're looking it up with ` Celluloid::Actor[:mp]` each time. If you re-use the same actor 4 times in the loop, you're going to lose the whole point here -- which is doing each HTTP request in a seperate thread. If it's only one Actor, then those :get_markup calls, even with the future, are going to stack up and be processed serially by a single actor, instead of occuring concurrently in their own threads. IF it's only one actor involved. But if it's actually multiple actors, but you're over-writing them in the Actor registry.... then I'm not sure the old ones that have been overwritten are really supervised? What's up with that? 
I'm an English Major, my name is Jim, and I'm a programmer...... do I get some sort of cookie? My browser says yes.
nah man, they're still waiting for the JVM to start up and "get warm"... could be a few days.
If you're curious, this capistrano task does exactly this: http://ariejan.net/2011/09/19/capistrano-and-the-custom-maintenance-page/ They propably don't use capistrano for deploys anymore, or this is one leftover of simpler times :)
I replied on RubySource - do check it out. 
~~You're talking aboit off-site gateways (Stripe, PayPal, Google Wallet). Active Merchant supports a number of these.~~ Ignore that. I got my facts mixed up. You have to pass Stripe the CC initially, but after that it manages it for you. Generally speaking though, you don't need to store CC info anyway if the customer is making a one-time purchase. if you're doing subscriptions, that's a different matter (although Stripe isn't the only option there).
&gt; You still have to pass Stripe the CC in the first place, just like any other gateway. Yes but the important thing is not that you pass CC info, it is *where the CC info comes from.* Your server does not have to pass the credit card info to stripe - your javascript sends it directly to their servers (instead of going through your server back-end first) and you receive a unique token identifying that credit card. You tell Stripe to charge "Whatever card is associated with this token". The credit card info never touches your server, thus absolving you of having to comply with PCI standards. If you use accept a form post with credit card data, regardless of whether or not you store it in any persistence layer, you are still "Processing and transmitting" credit card data and need to be PCI compliant. Only when you use JS to post directly to stripe's servers is your production machine outside the scope of PCI compliance. In that configuration, I suppose it's fine to use ActiveMerchant to handle the transaction of "charge this card, make sure there are no errors" etc. But I'll only use a payment gateway that allows this sort of hand-off like Stripe's.
Someone more talented than I - Please do 'Harder, Better, Faster, Stronger'!
Except nowhere near as many features.
Tests are neither boring nor tedious. What's boring and tedious is spending your entire working day in a debugger because you don't have tests.
Exactly. Also, tests generally seem more boring and pointless when written after the fact, when the code has already been manually tested. TDD is much more fun.
Having seen the video of tests running, it's clearer now that the OP isn't referring to *writing* tests, but rather watching tests run slowly. 
tests are boring and tedious, bugs too.
There's a few things in FilmBuff::IMDB#find_by_title that could be brushed up. First, the .merge! call on options should just be .merge. A bang with assignment works, but is unnecessary. Also, instead of using #each heavily, there's two steps that could help. First, break the method down into smaller steps (possibly extracted methods). This is more intent revealing, and would probably also make for a nicer backtrace should things go haywire. Also, consider other Enumerable methods; #select could be used to filter the list rather than #each followed by keycheck; #inject could possibly build the results array in a more idiomatic way. One could argue that using #each has the same end result, and that's true. But one of the points of picking different enumerable methods is, it is often more immediately clear what the intent of that line of code is. For instance, if you pick #select or #reject, I know you are filtering a collection right away without having to even read the next line. BTW, I liked seeing the locale use in there. I was not aware HTTParty had that option, so thanks for the tipoff!
well, sometimes you just read the information and do not have anything to add, this is one of them. :) thanks for the write up. keep 'em comin'.
I can't believe I watched that whole thing. It was pretty useful to see how someone works, especially since I hardly ever use a debugger.
Why not use an [RSS library](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/rss/rdoc/index.html) to read the feed easily for you?
A friend of mine came up with (quite clever, i think) regex: .{24}\.gif . == wildcard {24} == numbers of characters \ == escape character .gif == ending with .gif I case anyone needs a solution..
I'm so facinated by http://rubular.com/ ! Thank you for throwing that link at me :&gt; 
I will definitively have a look at that.. Thank you for the link 
 /http:\/\/i\.imgur\.com\/([^\.]*)\.(gif|jpg|png)/
Why install gcc when clang works just fine?
Assuming I'm understanding correctly, this should suffice: /http:\/\/i\.imgur\.com\/[^.]+\.(gif|jpg)/
And *why* can't you just use a class for storing this data? Seems like it'd be much easier than using an insane hash for doing so.
No it doesn't please read the article again. &gt; If you need to install any Ruby that’s older than 1.9.3, such as 1.9.2, 1.8.7 or REE, you’ll need to install GCC 4.2. Apple does not ship the Command Line Tools with gcc-4.2 compiler anymore (you can check by running which gcc-4.2), so you need to install it via Homebrew.
&gt; What do we do if we want to sort the elements in a hash by key? In 1.9.2 you can use Enumerable#sort_by to do this.
Even better than overriding `[]` would be to set the default in the initializer: class FreeformHash &lt; Hash def initialize(*args) super(*args) self.default = proc { |hash, key| hash[key] = FreeformHash.new } end end edit: or the method found in the comments if you don't want to use a subclass of Hash: Hash.new{|h,k| h[k] = Hash.new(&amp;h.default_proc) }
Is Hash safe to override? Some of Ruby's other base classes aren't, but I don't know about Hash.
I've had no problems compiling 1.9.2 with clang, older patchlevels had some issues, but you've updated your OS through two major releases and four minor releases in that time, so you're hopefully running the latest patchlevel. If you're still building 1.8.7 maybe you should think about upgrading. After all, you have upgraded your OS at least three times since it was released.
&gt; If you're still building 1.8.7 maybe you should think about upgrading. After all, you have upgraded your OS at least three times since it was released. Yes, tell that to the people that makes decisions, we have a lot of legacy Ruby stuff, especially gems that doesn't work, or fails in higher versions of Ruby. So we need to remove these gems, and get that functionality elsewhere. 
Just being turing complete isn't terribly difficult. My [brainfuck interpreter](https://github.com/probabilityZero/brainrb) is much less than 352 lines of Ruby and it's actually rather verbose. RLTK is great, though, and so is the Kazoo tutorial.
If you don't like boring blog posts, please visit the website directly: https://www.phusionpassenger.com/
You're right, I concede I did not know the internals well enough to state exactly what was happening. The behavior seen (that of an array of tuples being yielded to the block) is consistent with Hash#to_a which is why I assumed that was happening but it makes a lot of sense that it would be implemented differently in C instead of in ruby itself. Thanks for pointing this out!
I was just wondering, given all the great options like unicorn, thin, etc, why anyone would still use passenger. Oh, and because I'm boring.
Ah, it looked like you were yawning. Wondering is a whole 'nother ball game. =) For clarity's sake: discussing and compairing alternatives == not boring. "Yawn" statements with no further clarification don't add much to the discussion and just fall into the "haters gonna hate" camp.
I just came here to say what [jheimark](http://www.reddit.com/user/jheimark) already said.
nice one. how does it work in the backend?
I believe none of the other options are as easy/mindless to setup and maintain as passenger. Last time I checked anyway. 
You should also post this in /r/rails.
That extra model might be handy for weighting subreddits. ...I should suggest that feature to reddit itself.
I'm trying to wrap my mind around this. So, a user has one subscription. A subscription model has one user that it belongs to. This subscription has many (a collection of) subreddits. That it?
If I were designing it: subscription belongs to one user AND belongs to one subreddit. This way, you have a clean association between the two objects. Use a has_many :through if you need them to have access to one another. This also allows you to control the verbiage (a subreddit could have other types of users - admins, for example) inside the subreddit model: has_many :subscribers, :class =&gt; "User", :through =&gt; :subscriptions am I being clear? btw name == Holes reference?
I also prefer using a linking model: class User &lt; ActiveRecord::Base has_many :subscriptions has_many :subreddits, through: :subscriptions end class Subreddit &lt; ActiveRecord::Base has_many :subscriptions has_many :users, through: :subscriptions end class Subscription belongs_to :user belongs_to :subreddit end Achieves the same purpose as having a users_subreddits table but allows you direct access to those objects more easily. Also, as [colindean](/u/colindean) mentioned you can do things like weighing popularity etc without doing a sql join... In addition, with this method it is easier to add an accepts_nested_attributes_for :subscription to your other models if you wanted to include default subscription etc. to a User sign up form or anything else. **edit:** has_many :**users**, through: :subscriptions
&gt; Thanks for the feedback. However, Rack session :expire_after is just a cookie expiration time, which is a completely separate issue. &gt; And I don’t see how I’m reinventing anything. I’m simply using existing hashing algorithms to hash time-sensitive data. Enlighten me if I’m mistaken… Moving this to Reddit because it's easier to get notifications here. Rack sessions don't have to be cookie-based. The only reason I mentioned it is because your use case indicates that you're checking for expiration: &gt; Give it to the client, get it back, and see if it still is (or ever was) valid. You don't give much context in the blog post about what you're using them for. Are they identifying something? A password of some kind? Authentication? Authorization? As far as reinventing, I don't want to come off as harsh but it's hard to understate this: inventing your own crypto lib using primitives is a dangerous idea. Inventing something for its own sake is awesome and commendable but your library needs to come with a big warning that it is not standard, just a toy, not for use in production, etc. Your code is vulnerable to a number of attacks including but not limited to timing on the equality operation and length-extension. Bottom line: HMAC was developed SPECIFICALLY so that nobody would have to write a keyed hashing function anymore. It was written to combat the ubiquity of ad-hoc keyed hashing algorithms - that is, it was written to avoid doing **exactly** what you have done with this project. Like I said, I don't want to be too harsh because you are writing code that works and this is a good learning experience. If I come off as mean, it's only because I want to impress upon you the importance of getting crypto right. Some reading: http://en.wikipedia.org/wiki/Hash-based_message_authentication_code http://en.wikipedia.org/wiki/Key_derivation_function http://en.wikipedia.org/wiki/Bcrypt
Yeah... if I weren't in such an "enterprisey" environment (or constrained by vendor stuff), I'd definitely be in the "avoiding like the plague" camp. Since our integration with other departments requires MSSQL as well, I'm constrained by having a solid adapter for that as well (it's mostly a Windows shop, sadly, with the exception of my department and a few others). Since we've started building out new enhancements that go completely beyond the scope of the vendor's product, and one of the mandates is that I add no new tables to the Oracle database, our new stuff is backed by Postgres... it's _so nice_ working with a modern, standards-compliant, open source RDBMS. I will never understand the sort of mentality that leads one to _pay for_ a cantankerous proprietary system over a _free_ sane one. That being said, I wouldn't mind helping out with those adapters. I'll have to take a look at their status next year when I have a bit more time on my hands. I'm surprised they don't at least have an Oracle XE server available... actually, I'm pretty sure you can even run 11g for free in a non-production environment.
&gt; Streaming requires application servers to support either multi-threaded or evented I/O. Most Ruby application servers are not up for the job. This is either willfully ignorant or FUD to sell your product. If you define "most ruby application servers" as Unicorn and WEBrick, this might make sense. Come back to reality.
Yes, I should mark it as experimental. It is intened for time-bound authentication. Except that it must securely contain its own drop-dead time, it's not intended as a generic encrypted data container. Encryption is an implementation detail. Here is the specific authentication problem I was trying to solve: regardless of what transport container (e.g. HTTP cookie, a pidgeon) and crypto you use, an auth token needs to be a piece of data that says "this user is okay". But at some point that auth _token data itself_ needs to expire, regardless of anything else. Often this is done by marking or deleting it from a db or redis store. I wanted to see if, instead, the token itself could be used to securely determine its own state. This library is an attempt to wrap that behavior in an easy API. One obvious way to implement the behavior is by encrypting a timestamp, sending it, receieving it, decryping it, and checking the time value. Another (which I chose) is to use hashing. But that's an implementation detail. You've given me some great info on hashing, which I will now attempt to read and understand. But regardless of what method it uses - two-way encryption, HMAC, or my inferior hashing method - the function of the library is only to generate a token and know when it expires.
Not sure where this hostility comes from. If you read the article you will see that I have listed exactly which app servers have problems, who criticized them first, for what reasons, and which application servers *are* already up for the job, and for which jobs. Let's do the counting: 1. Phusion Passenger 2. Unicorn 3. Thin 4. Goliath 5. Puma WEBrick is unfit for production so I'm not counting it. Stuff like Mongrel and Ebb also exist but they're not maintained so I'm not counting them either. In this list, (1) and (2) are out. (3) and (4) are effectively out too because although they're evented, I've explained in my article that it's hard to make Rails and other non-evented code bases work on them without lots of issues. That leaves only (5). I think 4 out of 5 would qualify under the definition of "most". You can disagree with my on whether (3) and (4) should be considered out but please understand that this is supposed to be a balanced article. But full disclosure: yes I *am* selling my product, in addition to publishing an informative article. That does not automatically make it FUD.
I developed a solution using Eric Wong's (of att &amp; git-scm) Unicorn variant of Rainbows! to do streams in multiple commercial applications that have been sold and deployed internationally for about the past two years. Major oil/gas, government organizations, avionics, and defense companies use our version that is built on something you say is impossible. By the fact that we've been integrating a Unicorn/Rainbows! solution for years means your opinion is wrong. And the fact that you are selling things based on this opinion (so people would count on your judgement being correct) makes it dangerous. I strongly suggest you sit back and do a bit of homework before you try to sell things for profit or at least know who you are lying to, because you'd be hard-pressed to pull a fast one on the internet like that . edit: I'm glad you've gotten around to supporting 1 model of multi-threading. Maybe you can [get around to](http://rainbows.rubyforge.org/) supporting 17 styles of multi-threading like Wong has done for the past 700 days or so.
Should also note that [Sinatra](http://www.sinatrarb.com/) (and by extension [Padrino](http://www.padrinorb.com/)) already supports [streaming responses](http://www.sinatrarb.com/contrib/streaming.html).
This is neat and clever. But. I can't tell if this is dependent on storing things in the session -- you need to store the salt somewhere, if you have to store it somewhere other than the session then you lose the advantage of "don't have to store anything", so I think this technique does depend on the session? If it depends on the session -- if you are in Rails, you don't need it, because Rails already applies a similar technique to the sessionID itself. But if you don't have that in Sinatra (I don't know) I guess it's useful -- but you might want to instead just use the same technique for session middleware in general, same as Rails. For my own 'token' needs, I generally need them to persist beyond a session AND I generally need them to be "cancellable" at any arbitrary time ("my token's been stolen, cancel it!"). Of course, that may be because I'm in Rails, so the session-bound token use cases are already automaticaly taken care of me by Rails session. 
Gosu is great and very well maintained, not it's fault that rubyists don't seem to want to make games. Nonetheless gosu gives you all the tools you need to builda great game.
I'm a casual gamedev and like to take part in Ludum Dare contests. My two key obstacles with Ruby were performance and packaging. A key to Ludum Dare is having a game that other entrants can run so they can rate the games. I [ported](https://github.com/peterc/potc-jruby) Notch's Prelude of the Chambered using JRuby and lwjgl and it seemed OK except it only ran at about 12fps instead of 60+. No matter, for my first Ludum Dare I decided to go with JRuby and use lwjgl so I could wrap it up into an applet people could run on any OS. I wasted 6 hours trying to get this working, even asking JRuby devs questions, but making applets with complex dependencies is far from simple (even for them) and I had to give up. I eventually found a way to package it all up into an executable, but it only semi-worked with lots of complaints from Windows users in particular. Regular MRI Ruby is even worse for packaging.. so I abandoned Ruby and went to JavaScript/HTML5 for my future games. And yeah, performance. I'm into pixel games and like the ability to have full control over every pixel within my game (a similar approach to Notch). Create a Ruby app that has a viewport of 640x480 and then set every pixel to a random color on each frame. See what fps you get.. 20-40 if you're really lucky. Now do the same in Java, you'll be getting 200+ fps. And that's without any logic. Ruby isn't useless for gamedev but it doesn't suit many cases, even though the OO makes it pretty sweet on the logic side. Packaging and performance are still big problems.
I feel like we could crib heavily from XNA/Unity here, building a MVVM-ish system seems natural for games. I've fiddled off and on with building frameworks like this, but I've never got far.
Upvoted for getting me to read up on a useful pattern. The nomenclature of a ViewModel sucks, but seems gold conceptually.
The VM name is pretty shite, I like to think of it as the Model-Dispatch-Widget pattern. Since it emphasizes the fact that the Model and Widget are not necessarily in 1-1 correspondence. I also don't like the name controller (I prefer Dispatcher) for various more complicated reasons, the very least of which is "MDW" is easier to say (for me) than "MCW". As far as the pattern goes, I think it fits pretty nice. the internal models would be reasonably 'heavy' in terms of memory, but also would be longer lived. The Widgets would be much lighter (ideally only having a reference to a few existing Models), and represent, say, the player on the screen or w/e. The hard part to divine is the dispatcher's role. I think it makes sense to try to isolate various parts of the game ecosystem behind Dispatchers, so that the set of long-lived model objects connect to many dispatchers, which dispatch to many Widgets -- those widgets might be logical representations of resources or monsters or w/e, or they might be physical things to render on screen, the only important thing is that they respond to some notion of "Update" with, perhaps, a turn number. Notably, all of that is speculation without much experience, but I would desparately love a system which clearly delineates the logical model (which would ostensibly contain any persistance/core logic (eg, health systems), presentation/high-level logic model (ie, the widgets and AI routines), and the game-loop proper. Perhaps it even makes sense to further separate into something like: Model, Dispatcher, DispatchGroup, Dispatchee. Where the Dispatcher (ie, the main game loop) informs each DispatchGroup (eg, the presentation layer, the AI stuff, the Multiplayer code) to update, each DG contains many dispatchers which can work together (and contain references to Models) and notify each other of there updated status -- each dispatcher could specify dependencies which block it's ability to update. (So that, for instance, a Player Widget could block updating until the surrounding Environment Widget group finishes updating). Anyway, that might be overkill.
&gt; It seems to me that right now Ruby is evolving into a more diverse and functional language, ensuring it can do more than just serve rails apps... Ruby has been a diverse and functional language for over a decade, well before Rails was ever a thing.
Understood. But I'm sure you'll agree that a decent amount of the ruby community, and therefore internal and external development of ruby, is highly rails-driven. For instance, internally the MRI GC makes sense in context of a rails app but not in that of a running game. And externally, rails features dominate the gemscape. My comment was meant to describe the state of the ruby community and rails-created white noise in that community more than ruby itself. But the many who jumped into it for rails, such as myself, are beginning to mature and appreciate its capacity more, and are poking around for other cool creative outlets, like my thread here. What a perfect time to discuss an ambitious undertaking!
For the majority of 2D games you'd write I think it's extremely unlikely you'd need to individually update every pixel in the window, every frame. If you were writing a game that really needed to do this, i'd say it's a pathological case, and bad performance in this situation should not cause you dismiss Ruby as badly performant for gamedev generally. 2D games along the lines of Angry birds or tower defense are very doable in Ruby with good performance, I'd even wager that an intelligently written RTS game could be done with reasonably good performance. Regarding packaging, there are a couple of tools to ease this process. Most notably the [Releasy](https://github.com/spooner/releasy) gem. EDIT: 3D games written in Ruby can also be performant if the openGL toolkit is properly utilized. For an example, see here: http://www.youtube.com/watch?v=7FVSbWaX_UU
&gt; But I'm sure you'll agree that a decent amount of the ruby community, and therefore internal and external development of ruby, is highly rails-driven. I sure don't. In fact, as a core developer of Puppet, a Ruby application that predates Rails and is in use managing mission critical systems from the NYSE to Los Alamos, I take umbrage at the assertion that Ruby is based on or driven by Rails. If you think Rails drives the development of Ruby, you have it *precisely* backwards. Rails' development was informed by the characteristics of the Ruby language, not the other way around. Ruby is not, as you have noticed, a good platform for real time games with complex graphics requirements. Stop-the-world GC, as you rightly noted, makes it difficult if not impossible to write, say, an FPS or RTS. But this has nothing at all to do with Rails. There are plenty of other reasons Ruby is not suited for highly optimized game development, including its lack of unboxed values, its lack of performant low-level threading and coordination primitives, its lack of graphics support, and etc. TL;DR: it sits too far above the metal to be performant enough for graphics heavy lifting. But as a high level language, what makes it unsuitable for some tasks (like low-level graphics programming) makes it very well suited for other tasks. It just so happens that a web framework like Rails is one of those tasks. If you're looking to make the next CoD in Ruby, I'm afraid you will be disappointed. But if you're looking to make simpler (but perhaps no less fun) games, or looking to learn more about game development, I think Ruby can be a useful language despite having a design that is ill-suited to some forms of game development.
&gt; On Stack Exchange we really don't like open ended discussion, we love solving specific problems instead (give a quick read to our FAQ) - which I'm guessing is why your question was closed on Stack Overflow and it already has a close vote here. One of the reasons Stack Overflow is such total crap these days. They close everything that's more complicated than lmgtfy.
I wrote a stub [panel-de-pom/tetris attack clone](http://github.com/bolthar/RTetrisAttack) a while ago, using raw rubysdl. It was fun to write, it's a pity I never completed it... The only problem I had is that it seemed to have some performance problems when trying to, for example, blur surfaces with alpha. That was with 1.8.7 - with 1.9.3 it runs really fast and smooth.
Stack Overflow sucks now for asking questions--even if you're the guy rewriting ruby. It is run by a bunch of (mostly) high strung dick moderators who are closing and shutting down any questions that don't fit into a narrow mold, and the definition of what is ok is so narrow that pretty much any question is "wrong." I was in the top 10% for the last 3 months, and now they've pissed me off enough that I won't be posting anything anymore. 
Totally true. If they were smart, they'd just leave things open and assign them a low ranking in their internal search. Instead, the mods are dicks and close anything that isn't, as you put it perfectly "let me google that for you." Dumb folks with power. How does this happen? 
Mods on power trips are another problem, yeah.
Also, while I've never had the opportunity to use it, Puppet looks like a beast. Props!
I've developed a number of [relatively advanced 2D games](http://spooner.github.com/games/) using Gosu, Chingu, Ray and/or Chipmunk. Regarding performance, the only real deal-breaker in CRuby is the garbage collector. I've never had problems with games that use a single screen, even with many animated sprites, but once you have a scrolling background, GC stutter become very apparent once the time for an individual collection goes over about 20ms. Nevertheless, it isn't impossible to overcome this issue by intentionally avoiding creating masses of objects (I don't mean being ultra-conservative with objects, but just being aware that you can't go crazy with them). In terms of general performance, you just have to use the resources you have to build the most complex game you can get away with (i.e. don't even think about having over 100 particles managed by Ruby at any one time, but that doesn't mean you can't have particle systems in Ruby). I see no reason why people can't make fun 2D games in Ruby (or very low-fi 3D games if they are keen), if they are just realistic about it. We certainly lag behind Python (Pygame) and Lua (Löve) in terms of frameworks, but as long as you are aware of the GC, there is no reason we can't do just as well as them in terms of results. I'm currently developing a Gosu extension gem, [Ashton](http://github.com/spooner/ashton), which adds high-level interfaces for opengl shaders and rendering to images, as well as some very useful higher level objects to aid game development (such as 2D lighting and a particle system that barely raises a sweat managing tens of thousands of particles). It is implemented as a C extension and directly uses OpenGL, so overcomes most of the limitations of Ruby speed. Shaders and image rendering have always been available in Ray, but that has never attempted to build up the community that Gosu has. Ray also offers nice wrappers over OpenGL drawing primatives, such as polygons. The old "ruby-opengl" gem has a number of issues (most specifically being notoriously hard to convince to compile for Ruby 1.9 on Windows). The "opengl" gem is the fork of this gem for 1.9 which has pre-compiled binaries so you can be sure all your users can find it (assuming you don't build an executable, that is). I think the big issues with developing in raw OpenGL are that the optimised systems for rendering are not very efficient in Ruby, so they don't give much advantage. To create and manage VBOs, for example, you need to write directly to binary data, which is far from performant in Ruby. On the flip-side, Gosu/Ray both offer methods to use VBO functionality transparently and Ashton uses VBOs transparently to optimise its particle system. For all your CRuby packaging woes, my (https://github.com/spooner/releasy) gem builds executables for OSX and Windows on any OS. It even manages deploying those files to Github for you :) I recommend people having worries about the feasibility of Ruby game development come to #gosu [irc.freenode.net](http://webchat.freenode.net/) and chat to some of the people, like myself, who develop games with Ruby already. The problem with something like Rubinius, although great since it should solve the GC issues that CRuby has, is that it just doesn't work well on Windows. A game really needs to run flawlessly, and be easily packaged, on all 3 main operating systems. Now stop reading this and make some great Ruby games! 
StackOverflow has found a good niche in debugging and moderately complex "how do I?" questions with actual answers. I miss the opinion questions, but wish we had moved them to a new area rather than banned them entirely.
Fair enough. I guess I was trying to be trite and flip with my 'smart ass' answer. Your comments are right on. Thank you for keeping me honest.
why did they take down the source code from github? i would have liked to play with it, write a tutorial or something for fun.
LOL, it was awesome for me before I needed it. Maybe it's just me, though. It's not about extending modules, but about overriding instance methods.
calm down fella! He didn't say anything about development. "My comment was meant to describe the **state of the ruby community** and rails-created white noise in that community And he is right, most gems are rails, most articles are rails, most projects are rails. Just because your pet project isn't rails based doesn't change the fact that most people associate/equate Ruby with RoR
I don't understand the problem statement being considered here. You want to redefine an entire class, at runtime, after instances of that class have been created, such that your changes effect already instantiated objects of that class as well as any other future instantiated objects of that class? I've never needed to do that. Am I misunderstanding the problem statement? I don't really understand what problem he is trying to solve. If it was really just that _some but not all_ programmers can cook, and should have cooking behaviors added to them.... then several of the methods he rejects seem superior and cleaner. But he rejects them because, apparently, he wants to make ALL Programmers, past and future instantiated, able to cook.... then why wouldn't you just have Programmer include the class in it's definition? Or monkey patch it in during app boot but before any instances havebeen created? `Programmer.send(:include, CanCook)`. I don't understand the problem you are trying to solve. 
`define_singleton_method` is all that's required BTW. The anonymous module is unnecessary IMO.
just out of interest, but why would you use pygame when there's gosu? :) 
Is gosu actually good? It doesn't seem to be used by anything, and SDL-based stuff is used a lot. Another issue, Ruby cross-platform installers still suck epicly compared with Python cross-platform installers for some reason (unless you use JRuby which is fine, but most gaming libraries require native libraries).
it's pretty simple: array.map{|a| a.send("to_#{data_type}") }
just changed append api a bit for v0.0.2
You should submit this to my new site i've been working on for reddit :) [Pineapple tutorials](http://pineapple.io) -- its a list of tutorials and resources for programming (not Q&amp;A like stack overflow, and not discussion like reddit). I haven't officially made a thread for it yet, but i think your resource would fit perfectly there, it's definitely quality enough.
You should be proud, you built something useful. I agree with that strategy, a low level barrier is important if you plan on this being crowd-sourced. I'll keep checking it and exploring the site. Kudos. 
Thanks! You have no idea how much i appreciate that. Trust me, that app has pushed me to the limits of what I think my sanity can handle, and trusting that i'm designing it the 'right way' so people actually use it. so thank you again!
Site looks great and behaves wonderfully: http://pineapple.io/resources/reddit-on-rails-part-1 What are you using for the description helper? Bleep...bloop.. :)
I also love mongodb, slim and twitter-bootstrap. Nice.
That is exactly what I talked about at [RubyConf 2010](http://www.confreaks.com/videos/490-rubyconf2010-writing-games-with-ruby).
Cool! I made a [similar URL shortener](https://github.com/tech-no-crat/shortenious) with sinatra as well. Mine uses HAML for views, redis for storage and coffeescript.
Nice project, but could you add a copy button to minimize the amount of clicks it'll take to copy &amp; paste.
Why not use something like Mongoid / MongoMapper which will allow you to create nice model classes which then get passed around? Just wondering if you wanted to keep it real small. I am currently writing a neat budget keeper for the wife and I and am in love with MongoDB (using with Mongoid).
It seems that there is no video there, but I excitedly await it's arrival.
Whenever I think I might want to stub Time.now I slap myself hard on both cheeks and refactor. Years have gone by since I've even thought about doing anything to Time.now. In that very first example I would move the time checking into a separate method (say, update?) that returned true if enough time had elapsed. This separates updating from the decision to update making the object more testable. Now you can set @last_check to any time in the past or future and you don't need to worry about what Time.now will return which means you don't need to stub it. PS: you should watch Greg Moeck's talk on mocking: http://www.confreaks.com/videos/659-rubyconf2011-why-you-don-t-get-mock-objects
[Timecop](https://github.com/jtrupiano/timecop) works pretty well for this.
Why not share your benchmark code? Maybe you're doing something to accidentally throttle the benchmark.
&gt; Maybe you're doing something to accidentally throttle the benchmark. As I said before, I suppose that I couldn't 'cook Oj' :) Here is the benchmark: http://pastebin.com/1xhsTT5e It seems that I was wrong about parsing: `Oj.load(json, mode: :compat)` is slightly faster than alternatives. But dumping still much slower.
That's a very small structure. Housekeeping routines may dominate over the actual parsing/serializing. I'd try at least some kilobytes worth.
I tried yajl-ruby and it seemed a little faster than oj (with files ranging from small to several MBs), but for some reason it seemed to have problems saving small floats (smaller than 0.0). There were incorrect values randomly so I switched back to oj.
https://github.com/funny-falcon/bin_utils/blob/master/test/benchmark.rb
I actually need it for building small &amp; simple web-apps using Sinatra, writing puppet modules &amp; misc automation scripts for system administration. I actually just wanted to know the philosophy of Ruby. Stuff like having the brackets optional while calling functions seem odd, passing code blocks to functions, ARGV array excludes the program name etc etc.
Its there, just not streaming. You have to download it. I've asked Coby to get it get the final version out.
this guy.. right here. i've seen so many people with anemic domain models do such odd stuff when they just needed to add something simple like an update? method. i'm sad that i only have one upvote to give you
OMG This so much funnier than the regular faggot ruby posts. You mispelled a word just like I just did.
Parentheses are optional when calling methods so as to allow them to look like properties if so desired. `ARGV` excludes the program name because it's available elsewhere. Passing blocks to functions is certainly the weirdest part of Ruby when coming from another language, but it's also the most powerful. Imagine that you want to replace all the words in a string with their ROT13 versions. In Ruby, you can use the block form of `gsub` to do just that: foo.gsub(/\w+/) { |match| match.tr 'a-z', 'n-za-m' } Rather than the static "replace x with y" functionality of most substitution facilities, Ruby lets you define an entire function to provide the replacement text. I could very well be wrong, but I can't help imagining this operation would be far less pleasant in most other languages. In short, "make programming as pleasant as possible" is the Ruby philosophy. If your intention is to just pick up Ruby for a little while, then just read examples until you get something working. If you'd prefer to add an immensely powerful language to your arsenal, you could do worse than taking doldrim's advice and starting with the Koans.
This is a great book for intro and midlevel understanding of Ruby: http://pragprog.com/book/ruby3/programming-ruby-1-9 For deeper knowledge, I recommend this one: http://pragprog.com/book/ager/exceptional-ruby
I don't understand. This is very confusing. *Why are you testing a library you don't control?* Generally you can trust the library maintainers to write tests like this so you don't have to. Sure, sometimes they don't write such tests, but I'm uncertain what value a test would provide. At most it could tell you "it broke", and if you use it to tell you "it broke… *again!*", why are you still using the library? It sounds like its time to find a different one. There's no sense in continuing to waste time on a library with behavior so inconsistent you have to test it yourself.
Check out 'The Ruby Programming Language' written by David Flanahan ( of Java and JavaScript fame ) and Matz ( the creator of Ruby ). It's not for a noob though. 
relying != relaying
**Eloquent Ruby** is probably the first book you want. It's not a complete language reference, but rather a guide to writing *idiomatic* Ruby. It probably fits your request better than any other single book. **The Ruby Programming Language** is a nice terse introduction to the language. It attempts to be the K&amp;R of Ruby (hence the name of the book). If you like that to-the-point style of K&amp;R, it's a good choice. **Programming Ruby 1.9** (aka the **Pickaxe** book) is one of the best complete language reference books. But mostly those first two, especially the first one.
Agreed. These are good books for learning the "ruby" way of doing things, and are quick reads if you are already a competent programmer.
If you've got Python under your belt, you probably don't need to read a book to learn Ruby; the two languages are like cousins. OTOH the book I bought to cover the hidden bits when I could already program in Ruby was The Ruby Programming Language. 
I think this question would be best direct to the [rails subreddit](http://reddit.com/r/rails). That said... When I was starting, I checked out a bunch of resources. Like bubbleb0y said, http://railstutorial.org http://railsforzombies.com/ Nothing's gonna make you better than practice though, so think of some idea and build it. For specific features, watch some stuff on http://railscasts.com/ , Ryan Bates does an amazing job of explaining what's going on in those.
I really like it. What I really miss about many ruby gems is such a high level documentation, most times you get some examples and the auto generated docs, and that's about it. The style is clear and easy to look at, you always know where you are in the documentation.
If you already have experience with programming, http://ruby-kickstart.com will get you up to speed in no time. Targeted at programmers, contains videos and a great set of [exercises on github](https://github.com/JoshCheek/ruby-kickstart). Watch the videos, do the [exercises](https://github.com/JoshCheek/ruby-kickstart) and you'll be in the game in less than a week. For me, these were way more useful than the ruby koans, despite the coolness factor of the latter.
What happens when you submit a picture of Nicholas Cage?
Yeah good point about the ToC. I intend to include it when generating the html, but I just haven't gotten around to it yet. For syntax highlighting I have this file: https://github.com/flyingmachine/whoops/blob/master/doc/site/lib/redcarpet_syntax_highlighter.rb It's being used here: https://github.com/flyingmachine/whoops/blob/master/doc/site/Rules#L49
For the code given in the blog post that is what I would do. There's a couple ways that you work with relative times though. In rake I removed flexmock support and had changes like this: https://github.com/jimweirich/rake/commit/928e0a23#diff-4 In this change, some rake tasks have a timestamp (such as file tasks), so it was just as easy to say "your timestamp is close to now" or "your timestamp is in the near future" by stubbing the object I was interested about rather than stubbing Time. In larger, more complex objects adding the necessary accessors may look weird, but it's a sign your object is too complex and should be broken apart into simpler, more testable objects. 
I don't think it's overstating to say that the Well Grounded Rubyist may have changed my life a little bit.
Using GitHub as a publishing platform was proving to be a little too complicated for both the users and ourselves. So we decided to build a much simpler in-site public author interface for creating new books. You should expect to see this live in a couple of months.
hahahahaha ive never seen that, maybe ill put that one on the 404 page too
looking forward to it! great work by the way.
Thanks for the feedback. I'll submit another post when I get the documentation "shell" together.
That dude guy?
substr = -&gt; s, n { (0..s.size-n).map{|x| s[x..x+n-1] } } substr['beware', 2] # =&gt; ["be", "ew", "wa", "ar", "re"]
a="beware".split('') (0...a.size-1).each.collect{|i|a[i]+a[i+1]}
 user system total real redka: 0.440000 0.010000 0.450000 ( 0.451499) wedgex: 7.630000 0.060000 7.690000 ( 8.181313) vderyagin: 7.190000 0.040000 7.230000 ( 7.302901) cloudedice: 0.410000 0.010000 0.420000 ( 0.412885) 
Are you a wizard? $ cat beware.rb n = 2 temp = "beware" derp = temp.scan(/(.{#{n}})/).flatten puts derp[0] $end $ ruby beware.rb be 
That's an excellent point.
Weekend has just started for me &amp; have started reading Eloquent Ruby. I am having fun reading it. Thanks. 
Converting time to a String is expensive in Ruby. Oj uses a float as the default which is faster. In some modes it also converts back to Time instead of a String like JSON. The benchmarks have extra code in them which tends to level all the tests. While the effect is small it is not necessary. The las test with Oj::Doc is not the correct usage of Oj::Doc. The corrected benchmarks are here. http://pastebin.com/giBK030H For loading the small JSON string Oj is still faster than Yajl or JSON and for dumping it is more than twice as fast.
 a = "beware" (0..a.size-2).map{|i|a[i,2]}
In the interest of code golf, you can use s[x,n] instead of s[x..x+n-1]. Also, instead of subtracting one from the end of a range, you can use an "up-to-but-not-including" range: x...x+n (three dots).
I gotta say guys....bravo. This is the first time I've ever visited this subreddit, and the first time I've ever tried coding in Ruby, and I come in here with a dumb newbie question, and I get 4 good answers in 10 min EAAAAAAAAARRRRRRRLY in the morning, and keep getting fantastic tips all day. You guys are top-notch. Kudos. :)
This probably isn't as fast as some of the others, but is also useful to keep in mind: def substrings(s, k) chars = s.chars.to_a chars.slice(0, chars.length - k + 1).zip(*(1...k).map {|i| chars.slice(i, chars.length - k + 1)}).map(&amp;:join) end 
Link?
A link to the code would be swell.
god-damnit! https://github.com/metamorfos/rubdo
Just so you know, the class of things these are are N-grams, in this case, bigrams. http://en.wikipedia.org/wiki/N-gram
[The Benchmark module.](http://ruby-doc.org/stdlib-1.9.3/libdoc/benchmark/rdoc/Benchmark.html)
Sexy API. Nice use of Proc#[]. 
&gt; There's no reason or benefit from breaking up ~120 lines of code into 5 files. If your criteria for breaking code into multiple files is # of lines, you have a problem. While I wouldn't have placed version info like he did, it's easy to navigate a project if files are organised like this. You get a grasp of the different parts easily.
If you can't get a grasp of 120 lines of code unless it's broken up into 5 files, YOU have a problem. 
Good article. Lots of poorly defined behaviour there, although I like the implicit variable declaration because ruby is not block scoped. I can see the argument for explicit being better than implicit but I still like how it currently works.
In fact, if you inspect what the expression local_variables at the start of a method gives you, you'll see it already sees all of the local variables. def foo p local_variables x = 1 if false y = 2 end end foo # outputs [:x, :y] aliens.jpg EDIT: better example
Methods not returning the value from an `ensure` block is expected, since ensure executes as execution is leaving the method (due to a `return` or an exception). `super` will also implicitly pass down any `&amp;blocks`. The difference between `^` `$` and `\A` `\Z` really grinds my gears. Countless parsing/security bugs have been created because of this subtle difference.
Interesting article, thanks for posting. It seems to me that ruby is actually amazingly consistent and predictable given its wealth of exotic, maybe even experimental features.
&gt; Methods do not return value from ensure statement Ensure is like unwind-protect in Common Lisp or finally in Java. Its purpose is to cleanup resources (files, sockets, etc.) in any case including exceptional exits of the method or block. I wouldn't expect code like this def compute_foo_result foo = Foo.new result = foo.compute_the_result return result ensure foo.cleanup end to not return the result, only because I happened to call Foo#cleanup as the last statement in my ensure block.
Fixable though. "beware".scan(/(?=(.{#{n}}))/).flatten
No prob. Been there forever... a very under-appreciated library.
Nope, it's a great tool for any web app project. It's easy to get started the community support is great and ruby is a great language for getting stuff done. TL;DR I use rails for stuff. https://github.com/craigmcnamara
You should think about PHP. The language sucks, but it's so trivially easy to find good hosting for it.
Nice!
Nowadays it's trivial enough to find Rails hosting too. So no reason to go with a language you don't like.
This is actually one of the best situations you can find yourself in, learning-wise. You have predefined functionality you have to implement, but the logic part is already worked out. It's not client work, it's internal, so if it takes you a bit longer it's not a huge deal. As for using Rails, well, as other people here have remarked, it's very mature and stable. A couple of years ago, I bet my freelancing future on it, and that worked out well. Just don't to making any promises you can't keep. You don't know the technology stack, you have absolutely no base for an estimation.
I left a company after we successfully converted from using Visual FoxPro 9.0 to using Rails. You're risking nothing, so long as the Rails code is solid, tested, and performs as expected.
You're not betting the company on it, you're betting the initial time investment to learn/write the app. Once that's done, you *should* have a more robust, and tested solution, which should put you in a better position than before, and be worth it. I'd say it sounds like a good idea to go for it, on the positive side: getting something up and running quickly is an advantage of the Rails framework, this is a great opportunity (in terms of type of project) to learn on. And also: Rails is mature enough to be able to find other developers to support, not some esoteric language, and I'd say coming from Coldfusion, consider this futureproofing to some extent, perhaps being young and starting my career with Rails has skewed my opinion, but I'd guess 5-10 years down the track it's gonna be easier to find Rails developers than Coldfusion developers
I used to be an independent rails developer. A contractor. I cannot tell you how many times I was called in and picked up code started by someone who didn't know rails but thought rails was the right solution -- but then proceeded to implement an absolutely crap system. That's not to say you're an idiot. You're probably very smart. But you can't know what you don't know. And what you don't know is 'the rails way' of doing things. You have 3 options as far as I can see. I'll list them from most attractive to least attractive: 1. Get a part-time rails expert pronto and get them on the system with you teaching you how to do it. They'll be at least twice as productive as you and will make sure things are done correctly. Be ready to pay $100/hr or more for at least 20 hours per week for a couple months. 2. Bust your ass and learn everything you possible can. Overload stackoverflow with questions. Go to your local ruby group (hope you have one) and get people to review your code. Do Mike Hartl's tutorial multiple times until you know it in your sleep. Don't be afraid to throw away all your code and start over once or twice. 3. Proceed thinking you know what to do and tell management you can handle this no problem. Struggle for a while -- meanwhile implementing things incorrectly in a way that makes if virtually impossible for someone to come in behind you and fix it. When eventually someone is brought in to fix it (which eventually someone will be, mark my words) they'll recommend pitching the whole thing and starting over. I've seen all three of these scenarios play out. They are the three most likely options. I believe #1 is by far the best. I've been the consultant in scenarios #1 and #3 above and can tell you #1 gets the best management reception by far. good luck! 
Start small. Replace small parts of the web site or if you're making new pages / features / apps use rails. Use technical spikes to ensure that your new solutions work. Beware of waste and unnecessary features. Automated tests. CI. Learn to trust your CI. Automate as much as possible, use proper scripts / tools. Reduce feedback cycle, how long does it take to get from feature request to production? Impress business people with how fast you make make reliable stuff with the new stack. Make friends with them, get them envolved in the development (agile style). Try to figure out what the business really needs and don't let them micromanage the development.
Thankfully, I do have experience working in IT. I've done a lot of programming with PHP, Python, and done server admin work with Linux and others. So I'm not completely out of my depth, just new to RoR and new-ish to Ruby--though I do really like what I've seen this far. 
I'm very, very much aware of what I'm getting myself into work wise. Not only do I have to "decrypt" the program logic (which is plain wrong in some places), but also learn rails, get our database transitioned over, and get our hosting set up and tested. Sadly (happily?) this is going to be less work over the long term than trying to mess with this antiquated set up we currently have. Needless to say, my life is full of stress at the moment. 
That's good. I guess I didn't really explain it well, but my reason for bringing that up is just to make sure you have the experience to know just how much time you'll have to devote to this project rather than other things that come up in the life of a sysadmin. So it does sound like you know what you are getting in to. Other than that, I would say you are not going to come up with any "gotchas" just because you use ruby. RoR has proven itself just as well as any other enterprise language/framework. You can count on it to work as expected and it's not really a "gamble" going with RoR rather than the other heavyweights like Java, .Net, PHP, or Python. Of course this _does_ depend on your ability to actually write decent code in ruby ;)
Agree strongly with kulehandluke. There's a great parable called The Fallacy of Chesterton's Fence that describes it, which I'll paste here because it's awesome: In the matter of reforming things, as distinct from deforming them, there is one plain and simple principle; a principle which will probably be called a paradox. There exists in such a case a certain institution or law; let us say, for the sake of simplicity, a fence or gate erected across a road. The more modern type of reformer goes gaily up to it and says, "I don't see the use of this; let us clear it away." To which the more intelligent type of reformer will do well to answer: "If you don't see the use of it, I certainly won't let you clear it away. Go away and think. Then, when you can come back and tell me that you do see the use of it, I may allow you to destroy it." This paradox rests on the most elementary common sense. The gate or fence did not grow there. It was not set up by somnambulists who built it in their sleep. It is highly improbable that it was put there by escaped lunatics who were for some reason loose in the street. Some person had some reason for thinking it would be a good thing for somebody. And until we know what the reason was, we really cannot judge whether the reason was reasonable. It is extremely probable that we have overlooked some whole aspect of the question, if something set up by human beings like ourselves seems to be entirely meaningless and mysterious. There are reformers who get over this difficulty by assuming that all their fathers were fools; but if that be so, we can only say that folly appears to be a hereditary disease. But the truth is that nobody has any business to destroy a social institution until he has really seen it as an historical institution. If he knows how it arose, and what purposes it was supposed to serve, he may really be able to say that they were bad purposes, that they have since become bad purposes, or that they are purposes which are no longer served. But if he simply stares at the thing as a senseless monstrosity that has somehow sprung up in his path, it is he and not the traditionalist who is suffering from an illusion.
I'm looking into your feedback with the args, Any tips on what dispatcher I can use? Havn't been using ruby long at all...
On the bright-side I will say my first project with ruby on rails was a great experience. (bear in mind this was about 6-7 years ago) Coming from asp/.net was a real eye-opener seeing what you could achieve. There's the usual mind benders figuring out what the errors mean as you get to know the framework &amp; language but within a week I could knock up something basic with ease. If you've come from another web framework (asp, php etc) there are loads of great features that rails does out of the box. I love coding in Ruby, it's a fantastic programming language. Heroku is a great option if your company is ok with putting their data in the cloud. It'll save you getting into server admin and give you a very easy way to deploy your app. There are a few quirks specific to heroku but these are generally well documented as it's so widely used. For your back end admin you may also want to check out http://activeadmin.info/ which is great for quickly getting your CRUD admin area going. Good luck with your project!
I came into a similar role about 2 years ago with a classic ASP application that had around 750K+ lines of code. Several files were about 60K-80K lines. No source control at all. No rollout or testing procedures either. First instinct was similar, let's just gut the entire thing and got to Rails. (Which we are finally starting down now). But I realized that the time to produce success was so far in the horizon. There was no conceivable way to migrate bits of functionality over. We'd be stuck in the "Big Rewrite" which would be doomed to failure. Instead, we started with modest improvements on the existing code base. It seems horrible, but we just picked up a page here and there, cleaned it up. Consolidated code etc... Implemented source control (day one. Git made that easy), created some rollout and agile management procedures and interestingly our once completely unstable system now has half the amount of code it had before, is hitting weekly sprint rollouts with new functionality and fixes. AND we've generated a lot of excitement into what a new technology system can provide as we started now taking cleaned up bits of the system and porting those over to the rails system. But we couldn't have done that without investing the time to understand and clean up what was already there. Remember it might be legacy, but if it's making money it deserves respect because it is already out there anything else is just an idea at this point.
Where the heck are you looking? Or are you just trolling? Most of the big name "reliable PHP shared hosting" that I've used also supports Ruby and/or Rails applications to some extent. Though at the price you're quoting they tend to be shared hosting environments which limit your app/deployment options... I won't go through the exhaustive list but here's a short selection of the services I've used with the pluses and minuses that I've run into: * Dreamhost.com 1. + Shared hosting 2. + Cheap (8.95/mo) 3. + "Unlimited" transfer/storage plans 4. + Supports everything under the sun 5. + Great customer service 6. - Occasional downtime 7. - Tends to lag behind in Passenger/rack versions which can force you into a version corner. * Linode.com 1. + Relatively cheap for a VPS 2. +or- You have complete control 3. +or- Administration is up to you 4. +or- Deployment is up to you 5. +or- Version management is up to you 6. - Outside of your price range * Appfog.com 1. + Interesting payment model (based on memory usage... not storage/transfer/cpu) 2. + Free for up to 2 GB 3. + Can dynamically scale 4. +- Limited deployment options (you might not care based on their available options) 5. - Expensive if you need to scale to more than 2GB 6. - New company to the game (general availability happened only a few weeks ago) so there may be bugs/problems. * Heroku 1. + Big name in the Ruby game (lots of support/documentation) 2. + Free for 1 dyno (check the details on this to make sure you know what you can/can't use) 3. + Can dynamically scale 4. - Expensive to scale relatively speaking Full disclosure: I recently won a contest that Appfog was running and that's how I first learned about them. I am not being payed to promote them.
In ruby's core library, a method `foo!` does not mean "this method modifies the receiver" it means "this method modifies the receiver and there is a non-bang version that returns a modified copy of the receiver". Time#utc is equivalent to Array#delete_if. Both modify the receiver, both don't have a useless `!`. 
My solution: def sublen(str,len) res = [] s = str.size - len + 1 s.times do |i| res &lt;&lt; str[i,len] end return res end 
I haven't used these guys personally, but one of my friends just mentioned RightScale to me. http://www.rightscale.com/products/plans-pricing/ They also have a free plan that might be up your ally if you're just trying some Rails stuff. Just make sure what you're doing will fit into the "free" category and you should be good to go.
Also haven't used these guys but a Google search picked them up rather quickly: http://www.hostgator.com/shared.shtml No idea how good they are.
Wrap your head around the abbrev code above. Once you have that, you have a hash table where the values are the messages you CAN send. Then you can just use send but now you know that you're not sending on any old method. As an example, test to make sure that the user can't use `to_s` as their input.
Once you've read the documentation for the two versions how can one version's behavior be unexpected? The principle of bang methods modifying the receiver *and* being pared with a non-bang method has been a design principle of the ruby's core library since at least ruby 1.6. Unfortunately, incorrect understandings ("dangerous", "modifies the object", "unexpected") of the meaning of a `!` at the end of a method name crept into the community as Rails became popular.
The version file was placed there by bundle, where would you have placed it?
I'm not a rails contractor any more. But when I was I cleaned up at least 5-6 projects started as the first rails project of someone else. I'm not saying you'll fail -- I'm just saying other people have. It doesn't matter to me either way. I'm not asking for work and I'm not available if you asked. Good luck either way.
Unfortunately I couldn't get around to trying this gem out sooner. Now that I've tried it, it seems it also cannot do what I need: require 'remote/session' session=Remote::Session.new( hostname, username:username, password:password) session.run('variable="some_string") session.run('touch /tmp/prefix_$variable') This code will simply create the '/tmp/prefix_' file. The sudo method allowed me to submit an array of commands, which would run one after another. But I still couldn't control the flow which is unfortunate, because it seems like you are actually parsing the output and maybe you do have full control of the flow within your library.
this looks cool, but if youre working with a larger system, and you know the vicinity of the problem, how does this benefit over using 'binding.pry'? would you wrap your whole program?
Pretty comprehensive! Although, it fails to mention [task arguments](http://robots.thoughtbot.com/post/18129303042/how-to-use-arguments-in-a-rake-task).
nice work donv!
This is a ridiculous hack! And I mean that in a good way. Very neat.
ah no, you're right, I misunderstood what was going on there.
Much nicer syntax than [my attempt](https://github.com/postmodern/combinatorics/blob/master/lib/combinatorics/list_comprehension.rb#L5-80).
I can't make up my mind whether I love this, or whether it's evil. 
&gt;"ta", "ti", "tu", "te", "to" ta chi tsu te to
I almost want to click 'nsfw' on this, hehe.
Love it, nice write-up. Just out of curiosity, how do you prevent the client from creating its own socket and spamming 'register' thousands of times?
[they made a smalltalk companion book](http://www.amazon.com/The-Design-Patterns-Smalltalk-Companion/dp/0201184621)
If that dude didn't sound so arrogant, that blog post MIGHT be readable. [Edit: and as a result, I'm now going to tell everyone I know _not_ to buy his book, 'Clean Ruby'].
The most obvious approach i can think of at the moment is to reuse a session id delivered along with the html page for socket connections as well. Server can actively refuse multiple connections using same session ids or invalid session ids. I would really be interested in what people with more experience working with web sockets have to say in ts regard.
That's very true. I was trying to figure out a way to gemify this. I think we might be able to do away with the globals, though we'd probably end up with the potentially uglier class-level variables in (ugh) Kernel.
change it to def myMethod (array) The * sign allows extra parameters under the name after the star, thus you'll see *args, and it puts it in an array under that name. Thus, you were asking for the length of the array containing the array you pass to it
If you're just passing in one array it should just be myMethod(array) You use the * notation when you want a variable amount of arguments, but if you're saying [1,2,3,4,5] is the input, that's only one argument: myMethod([1,2,3,4,5]) versus like myMethod([1],[2],[3],[4],[5]) or something.
Cosman246 is right. def myMethod(array) is what you want. As an interesting side-bit, the (*array) syntax can be used on the calling side for an entirely different reason -- it expands an array into individual arguments. An example: def foo(a, b, c) a*b + c end array = [2,4,1] foo(*array) =&gt; 9 So in this case, calling foo(*array) is the same as calling foo(2,4,1). Not what you're looking for now, but you might run into it in the future.
I think you missed something which is very important. Ruby uses duck typing. It doesn't care about what you are gonna pass to your function. The only thing that matters is that the object you pass can respond to the messages you are invoking on it (i.e the methods you want to call). EDIT: I'm seriously wondering why I'm downvoted. This is very important. And saying "creating a method that takes an *array*" is wrong exactly because of that. Which is also what enry_straker pointed out.
The best place to ask these sorts of questions is www.stackoverflow.com
An introductory guide to them: http://www.rubyinside.com/rubys-unary-operators-and-how-to-redefine-their-functionality-5610.html
thanks to everyone for excellent replies and your help! its so easy i feel stupid now!!
A large portion of all software out there probably sucks, rails or not. But your sample was not representative -- you only need to call in the consultant to rescue you when things are going really wrong
I do both. Git repo inside Dropbox.
I realize this may not directly fulfill what you're looking for, but I couldn't resist. The biggest amount of Ruby learning for me came from http://pragprog.com/book/ppmetr/metaprogramming-ruby. It's not generally touted as an intro book, of course, but if you've already got some Ruby basics down it explains some really fundamental aspects of Ruby; this greatly helped me understand what was going on under the covers and really got me excited about the language. It also helped dispel some of the notorious Rails "magic" before I ever got to using Rails.
And then `cd ~/Dropbox; git init` as well right? Triple suspenders.
INFO does not seem to be supported on Windows: irb(main):002:0&gt; Signal.list =&gt; {"EXIT"=&gt;0, "INT"=&gt;2, "ILL"=&gt;4, "ABRT"=&gt;22, "FPE"=&gt;8, "KILL"=&gt;9, "SEGV"=&gt;11, "TERM"=&gt;15}
The more fundamental aspect to realize is that ruby doesn't require explicit typing. No types needed. nada. Not in params. Not in local vars etc. Another key thing is to realize that stupidity is the key to success in programming. The faster you commit them the more you learn. We're all in similar boats. It's just that some boats are further out to sea than others :) 
The blog post says ALL OF YOU ARE WRONG AND I AM RIGHT AND I AM GOING TO GO IN CIRCLES TELLING YOU HOW WRONG YOU ARE AND FINALLY TELL YOU WHY I AM RIGHT. Besides, it starts with "THE GANG OF FOUR IS WRONG", which is rather inflammatory, even if it's true. That sort of stuff is what people put in blog post titles so people will read their blogs. And when people do that, I get annoyed. There are better ways to explain things to people.
IDE = Sublime Text 2 
Sublime Text 2 mentions Ruby on Rails. Is there a reason I should use Rails with Ruby, rather than just Ruby itself?
Sublime text 2 user here. I recommend learn ruby the hard way, a free book online for learning pure ruby. Rails is the web app framework that uses ruby. Start with rails for zombies for learning that, and the railstutorial free book is great as well
If you want to make web apps Rails or Sinatra is a good place to start, depending on how complex your app will be.
Sublime Text 2 is simply a great, fairly light weight Multplatform text editor with incredible customization capabilities as well plugin and snippet support. With regards to Rails, learn Ruby first. It will provide you with a foundation that will make later Rails development (should you desire to persue that) a lot easier.
http://www.ubuntu.com/
Depends on what you're trying to do.
@koggit and jurre What are the advantages of developing w Ruby on Linux instead of Windows? I have tried Dual-booting Ubuntu before (about 7 years ago) and it was generally a nightmare (compatibility issues etc). Is it better now than it used to be? Would it be easy to dual boot with Windows 7 on a Lenovo Thinkpad?
Dual booting Ubuntu is incredibly easy now on most PC's. I have had problems with the touchpad on my HP linux box, so I just use a mouse. Go to canonical's main page and it will walk you right through installation. It really is a snap (just have a 2-4 Gb thumb drive ready). The advantages of using Linux... Learning another operating system is great, using BASH instead of the windows command prompt is great, it's very easy to install packages and you can use RVM. I am sure there is more but I haven't done any development on a Windows machine in a while so I can't compare them as well as others might. With how easy it is to install Ubuntu now, I don't know why people aren't doing it more.
Thank you. Installing Ubuntu now. What IDE should I use for Ubuntu for Ruby and Rails?
I can't say I speak for the Rails community at large, but I don't believe they use an IDE. A unix-like OS is an IDE when you know how to use it. If you spend some time focusing on learning the innards of Linux/OSX you'll realize why a large amount of developers would rather use them instead of Windows for (almost) every language that isn't Microsoft's.
Wow, never knew this. Learn Ruby THW, is basically a port of Learn Python THW anyway. 
Most people don't use an IDE for ruby/rails (or most dynamically typed languages for that matter) development, as jzelinskie said basically your *nix system is an IDE by itself. As for text editors lots of people love Sublime Text 2[0] (I agree, it's a great editor), or you could go the hardcore route and learn VIM[1]. If you really do want an IDE I've seen some people use RubyMine[2]. [0]http://www.sublimetext.com/2 [1]http://www.vim.org/ [2]http://www.jetbrains.com/ruby/
&gt; but you shouldn't use those packages Why not? Fedora gives you Ruby 1.9.3 and RubyGems 1.8.15. Fedora ensures that when you install gems as a normal user they are installed into `~/.gem/$ruby/$version`, and as root they are installed into `/usr/local/lib/gems/...`. Suggesting RVM/rbenv to beginners is overkill and cargo-culting. Not every new Rubyists needs to switch between every implementation and every version of Ruby. Simply develop against the most recent Ruby package and you'll be fine.
Agreed here, make an alias like remote_ls="ssh foo@bar ls" Reload bash profile and you are set
okay, you want it to automatically execute commands on a remote server, and _then_ drop you into a shell on that remote server? Does it need to be the same shell that those commands were executed in? If so, I'm not sure there's any way to do it. If it's just about executing commands on a remote server, there are several ways to do it. It's actually one of the things Capistrano does, you could just use Capistrano. You may be able to use Capistrano to do what you need in general, maybe just have it end with a fork ssh call to drop you into the server? I dunno. But it won't be the same shell the command were executed in. I'm not sure there's any good way to do that. 
&gt; The situation is that I have to login in to various locations with and run the same commands to various ip's repeatedly through out the day. Check out Capistrano, it's _more_ than you're thinking,but kind of invented for this sort of case. &gt; I wanted to automate as much as possible so that I simply copied the ip, ran my script, which logged me in completely and ran a couple commands, then gave me control. But yeah, it's the "then gave me control" part that's potentially problematic. 
If by github for windows you mean the gui they built, it is buggy as shit--at least the OS X version. As soon as you go outside add, commit, push, pull, things go ugly. Just a word of warning. 
I use that often if I need, say, a hash of arrays.
Nice, I hadn't realized fetch had an optional second parameter, agree there are times this comes in handy when the `defaults.merge options` thing isn't right. 
The problem with `my_hash[:key] || :default` is when `false` (or more rarely `nil`) can be a legit value. So you wind up with the OP's ternary operator example with has_key?, which is much less readable than the fetch with second argument version. I have definitely had bugs before where I used a `||` forgetting to consider the possibility of a false value. Sometimes when I wrote the code originally, it wouldn't have made sense for there to be a `false` value there, but then things get expanded, and that code still uses `||`. I'd rather write what I mean to begin with and avoid the potential edge case problem -- what I mean is "if hash key does not exist", what `||` _says_ is "hash key does not exist (so long as it's a ordinary hash who's default return value is nil), or exists with a `false` value, or a `nil` value -- which isn't the same thing. Sacrificing precision of semantics for readability.... well, you don't have to with the readable fetch-with-default-arg. 
You just have to need to switch between two versions at some point (and you *will* have to at some point) and you're in trouble. Setting up rvm/rbenv takes about ten minutes max if you're totally new to it and there really is never a reason not to do it.
[Hash#fetch](http://rubydoc.info/stdlib/core/Hash#fetch-instance_method) is awesome for extracting options, with default values; without having to mess with `Hash#merge` or `Hash#default_proc`. Also, it accepts a block! hash.fetch(:foo) do # complex calculation here end
MiniTest is excellent for fast tests. Also try MiniSkirt for fast factories.
Hi r/Ruby I'm the developer of Latinum and I wanted to share it with everyone since it seems like a common problem (dealing with resources/money correctly). I implemented it for a business management platform I'm working on (https://github.com/ioquatix/financier) but I found quite a few deficiencies with the existing Money RubyGem. As I had some time pressure it turned out to be easier to roll my own rather than try to fix existing problems, so thats what I did. Feel free to ask any questions.
Is there a significant difference between using this and [Rerun](https://github.com/alexch/rerun)? I found it really fast (as in: fast enough that by the time I switch from Vim – which auto-saves on focus loss – to the terminal the tests are already finishing running).
I'd be careful with the name as it might be protected by paramount.
Nice work! I do have a couple questions. In the README you say "It is currently a work in progress and not designed to be taken seriously at this time." Are there any known bugs/error or is this disclaimer just a precaution? Also do you have a vague ETA for a "stable" version? 
Thanks for your complements. This is a good question. 1/ There are no bugs or issues, but that is because it hasn't been widely tested yet either. It has a moderately comprehensive test suite but that again doesn't cover all possible use cases. 2/ At this point I have the intention to change the `Bank` object to be named `Exchange` or something more general as `Bank` implies money but latinum is for general purpose resource calculations, however I expect it will be mostly backwards compatible with `Bank = Exchange` in `bank.rb`, and I'll bump the major version number at that point. Basically, it is fully usable and I hope to maintain backwards compatibility but there is the small chance of a large change in the API. I'd expect by the end of the year it could be considered pretty stable if not much has changed in that time. I wish I had more time to spend on it but I don't right now =(
Cool, that is a good idea. Is bitcoin precisely 8 decimals? Latinum doesn't assume anything about the number of DP, it just keeps track of exactly what you input, e.g. Latinum::Resource.new('0.123412341234', 'USD') Is valid, as is Latinum::Resource.new('0.123412341234', 'BTC') ... without any changes to existing code. However for formatting purposes, it might be nice to add it in by default =)
Rerun spawns a new ruby process. The fast MiniTests example uses load() to reload code in ruby, instead of require() which only loads file once. As far as I know restartomatic, shotgun, watchr, guard and autotest spawns new separate ruby forks each time tests are run. The fast MiniTests example is complete running the tests before my fingers leave to 'S' key to save the source file.
First red flag, mentioning Redis in the same sentence as document-oriented databases...
It is also incredibly easy to get an Ubuntu or Linux Mint VM going, for free, on a Windows box. Pick up the VMware free client (VMware Player). Here is an article I found helpful when getting Linux Mint up and running - I didn't even need one when doing the same with Ubuntu. http://www.asiteaboutnothing.net/c_linux-on-windows.html
`present?` isn't for "the edge case of checking whether a key exists in a hash or not". Checking whether a key exists in a hash or not is already built into stdlib Hash -- `has_key?`. As, you know, in the example in the OP. Did you read it? ActiveSupport `present?` does something different (can be called on strings, arrays, and nil value. Returns false for nil, empty string, or empty array; returns true otherwise. It is convenient, but has nothing to do with checking if keys are defined in hashes). (Actually, I haven't quite accurately defined all it's edge cases, see: http://guides.rubyonrails.org/active_support_core_extensions.html#blank-and-present ) But yes, my point is that the `||` idiom is full of gotchas "you have to be ready for when using this idiom" -- so why would you prefer this idiom to one nearly as readable but without those gotchas? Like, you know, the one the OP suggests. 
I have. And I do use fetch in my code. No need to be a dick about it.
very cool. Id like to check some of the later courses once you get past the super basics. Cheers
oh the irony i keep getting some 502 errors
Thanks for your honest feedback. I don't think I was going in circles but I've heard from several people who have said things along the lines of saying it was "inflammatory, even if it's true." I'm amused by that because people recognize that it is or may be true. I was really confused when I went to get clarification on what delegation really is because the examples that I've seen everywhere seemed to get it wrong from my new understanding. I wrote to Henry Lieberman and he suffered my questions without complaint as I tried to grasp the concept in several emails. I reached out to Jim Coplien who put me in touch with David Ungar who confirmed my understanding of delegation. Ungar clarified the two notions of delegation for me and finished with saying there was "a huge difference!"
You probably just had too much exposure to C at an impressionable age :-)
[1,2,3,4,5].zip(['a','b','c','d','e']) # =&gt; [[1, "a"], [2, "b"], [3, "c"], [4, "d"], [5, "e"]] 
 a = [1, 2, 3, 4, 5] b = %w(a b c d e) a.zip(b) # =&gt; [[1, "a"], [2, "b"], [3, "c"], [4, "d"], [5, "e"]]
i probably should have made this a text post. if you go through to the link and ctrl+F for 'clean_number' you'll see the goal of the exact section wants you to remove unwanted characters. clean_number = number.delete(".") Then is says this: &gt;Try working with the delete and delete! methods to clean up all right parentheses, left parentheses, hyphens, and blank spaces. RUN your program and you should see better data coming out. my question is. should my method look like: clean_number = number.delete(".") clean_number = number.delete(",") clean_number = number.delete(" ") clean_number = number.delete(")") clean_number = number.delete("(") or is there a shorter way like: clean_number = number.delete(".", ",", "(", ")", " ", "a...z")
awesome. glad I could help.
I don't get this connection that is being made. Did schneems write the ureddit site? http://blog.reddit.com/2012/08/university-of-reddit-explore-any.html http://www.reddit.com/r/universityofreddit/ I don't see his name anywhere on any of the announcements or on the subreddit... Edit: Formatting.
[String#delete](http://www.ruby-doc.org/core-1.9.3/String.html#method-i-delete) returns a copy of the string with all the characters in the intersection of it's arguments deleted. Any parameter that starts with a caret (\^) is negated So let's play with it: "hello world".delete("o") =&gt; "hell wrld" "hello world".delete("ol") =&gt; "he wrd" "hello world".delete(" ") =&gt; "helloworld" "hello world".delete("o", "l") =&gt; "hello world" "hello world".delete("aeiou") =&gt; "hll wrld" "hello world".delete("aeiou", "^e") =&gt; "hell wrld" "hello world".delete("a-z", "^l") =&gt; "ll l" Now... this seems to show us that we can choose multiple characters all at once, and they don't have to be a group set (as in deleting "ol" deletes all "o"s and all "l"s, but trying to provide multiple arguments fails, and we can also delete characters in a range ("a-z" is every lower case character), as well as negate a selected character by providing it a second argument with a caret. Your first large block, the way it's written, is all sorts of wrong. String#delete returns a new string, so you would be removing one character from the original string and putting the resulting string in the `clean_number` variable, and then removing another character from the original string and overwriting your `clean_number` variable with that new string, which contains the character you previously deleted! The second "shorter" method would not work. As shown, providing multiple arguments just doesn't work. The method wasn't designed to work like that. CHanging it to something like `clean_number = number.delete("., ()") might work... but I can already see a bug: "(123) 555-1234".delete("., ()") =&gt; "123555-1234" Ok. Lets add in the hyphen: "(123) 555-1234".delete("., -()") =&gt; "123555-1234" uh? what? see if you can figure out why this happens. I explain it up above. I would suggest not using String#delete at all. You know what characters you want, but you do not know every single character you do not want. There are hundreds more that you should be throwing away than the 10 characters you want to keep. Look into [String#gsub](http://www.ruby-doc.org/core-1.9.3/String.html#method-i-gsub). Specifically, this special pattern "`\d`", which matches any ASCII decimal digit, and grouping "`[]`", and the negation operator within a group: "`[^\d]`". edit: I dunno why I posted this. I'm feeling generous tonight, but it has quickly dissipated. Next time you run into a problem like this, Read The Fucking Manual. On the right side here, there is a link to ruby-doc.org, the same place I linked to in this comment. It tells you exactly what you want to know. Don't feel like wading through documentation? Either tough it out, or try whatever you were trying to do in either IRB, Ruby's Read-Eval-Print-Loop tool, or at tryruby.org, also linked to the right. When I code, I have multiple terminals open at all times, one of which is nearly always a Rails console or IRB so when I come upon a section of code I'm not sure is the best way of doing something, I can always switch to it and test it out. Get in the habit of testing out what you think you want to do before deciding you should or shouldn't do it.
There's a few things worth mentioning about the code in your article: 1. Use 2 spaces per indentation level instead of tabs. While there are no Ruby equilivants of Python's PEPs the general standard is to use 2 spaces. 2. Constants, unless they're class/module names, should be written using `SCREAMING_SNAKE_CASE`. This means that `Prompt` should be `PROMPT` instead. 3. Don't globally scope your constants and methods. While this is only a learning exercise it's better to get this right from the start. 4. Document your code. Again this is a learning exercise so I can understand why this wasn't done. However, once you start writing more serious code you really should document your code using tools such as YARD, RDoc or even Tomdoc. Other than that it doesn't look too bad for a beginner, welcome to Ruby :)
http://schneems.com/post/25098659429/databases-rails-week-1-introduction
Just an another answer: $ irb &gt; a = [1,2,3,4,5] &gt; b = %w(a b c d e) &gt; [a,b].transpose =&gt; [[1, "a"], [2, "b"], [3, "c"], [4, "d"], [5, "e"]] 
I don't mean to sound unfriendly but is there a reason you didn't just google this?
And then a day later you realized that ureddit.com is an aggregator for /r/UniversityofReddit and was not written by the author of this RoR course. https://github.com/ureddit/ureddit/commits/master
Truth: https://github.com/ureddit/ureddit
Wow, thanks, didn't know it.
even better (and more secure): ssh-agent + pubkey auth.
Really, what does this offer over setting up ssh/config with ServerAliveInterval, public keys and ssh-agent? Not only is this less secure (password auth vs pubkey auth), it also means you have to type your ssh password once and it will just make problems once you start deploying from your CI pipeline. This just feels like a half-assed solution to a well solved (and well documented) problem.
Seems better to just use passwordless public-key authentication? That may be what this gem is doing, but it seems better just to learns how that stuff works and do it yourself rather than have it taken care of by a gem that's somewhat of a black box. There is a (small) learning curve with ssh but it's a very powerful tool and it seems like more people could benefit from knowing how it works and what it can do.
It comes across as arrogant because you're making a somewhat pedantic point and, while it may be true, you're placing a huge emphasis on how *right* you are, and how *wrong* everyone else is.
As long as there are lazy students, there will be people on the internet willing to help them.
I tried, either I didn't search using proper terms or I didn't look hard enough. Probably a mix of both
Thanks! I've updated it to remove the ruby-debug dependency. It should install fine now. I'm glad you really like it and if you create any public documentation with I'd be super happy to check it out.
http://ruby.railstutorial.org/ruby-on-rails-tutorial-book is a great next step Take a look at section 3.1 and there's some discussion on static pages, and early on you go over routing and how to set up a root route (i.e. a route for / in your app). Here's some more about routing: http://guides.rubyonrails.org/routing.html As for creating tables in your db, you make db schema changes via "migrations" which are basically DDL scripts. Creating a new model will generate a db migration, but you can also create a db migration on your own as follows: rails generate migration &lt;name&gt; which will create a new file containing the migration that you can then edit. More deets on migration: http://guides.rubyonrails.org/migrations.html
http://railscasts.com/episodes/310-getting-started-with-rails might be useful, also, you should probably post this in r/rails instead of r/ruby. 
University of Reddit: Ruby on Rails http://ureddit.com/class/40250/web-programming-with-ruby-on-rails
Can't agree with this more.
No one's touched on your question, re: sqlite. Creating and modifying relational data structures/schemas is handled by [Migrations](http://guides.rubyonrails.org/migrations.html).
thank you
thank you
thank you
thank you
The error was on schneems site. Schneems.com At least I saw an error on his site, at the URL given in my previous post.
Oh interesting, I got 502 on ureddit.com at the time of your comment but was able to read his blog with no problem. My bad. Edit: That said, his blog is hosted on a third party site (tumblr), so not sure how much we can fault him if their service was 502ing.
Off-top: can you give a link to a hosting?
This could show a bit of the differences: http://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-php/
thank you 
Try [Ruby on Rails Tutorial](http://ruby.railstutorial.org/ruby-on-rails-tutorial-book)
I don't live in the US, so I don't have any idea about the software industry there, but I think you can learn something from my experience. I started learning Ruby and Ruby on Rails just November last year. Granted, I've had a reasonable amount of experience in software development already, but I just got out of college, so I wasn't really that much relevant in the job market. What I did was I went to every local event or conference that we had in my country. Not all of them are necessarily about Ruby, but I do encounter a lot of Ruby developers in those events. Eventually, I got a job from a Rails shop because I know at least a few people in the industry already and I got them to put in a good word for me. Today, I'm the facilitator of the local Ruby user group here in my country, and I know almost every Ruby developer here now. My skills aren't considered senior-level yet, but I'm almost certain that I won't have any trouble finding a job as a Ruby on Rails developer in the future because of my connections. **TL;DR**: It's not about what you know, it's who you know.
Seconded. I think the RoR tutorial is the best and most comprehensive introduction to Rails available right now. Can't recommend it highly enough.
NYC Ruby/Rails engineer here (completely self-taught) who makes pretty good money writing code for a well-funded startup in Manhattan. If you want to end up coding Ruby professionally, I would recommend that you start building web applications with Rails right now. Follow the Rails Tutorial, watch a whole bunch of RailsCasts, and then start coding something real and useful that you can show off. Forget certificates or degrees, start building things and comitting to public repos on Github so that you can show the world what you can do. If you ever want to meetup for coffee/beer to discuss this stuff (and possibly have me pass your info along to other startups) PM me.
Wow that's awesome; i just signed up to a bunch of groups on Meetup.com and am extremely excited to start going to the ones locally to me
Its a good thing then that i have a strong desire to learn
Great article! I love Sinatra. So clean and simple to understand.
Are you skilled in any other languages?
Just thought I'd post the process I encountered when hooking up mysql2 to MAMP.
Yes HTML, CSS , JavaScript and some Python 
video series?
Technically speaking, HTML and CSS are not programming languages. Just a bit of pedantry, but some people might hold it against you in an interview setting. 
One of the better ruby hackers I have worked with was self taught &amp; didnt' go to Uni. I felt cheated that I spent 3 years at university when he was imo a better programmer than me. Follow thoughtpunch's advice, and also try to get a real handle on how &amp; why rails works. I jumped in &amp; hacked away for a while without getting a real handle on how rails works, why, conventions, activerecord especially (using it effectively for a range of scenarios), etc. Good luck
yes I did. Editted the comment.
thank you so much , once i finish with the RoR tutorial i will most definitely take a look at those online classes.Actually i might do it side by side.
Thanks!
Ah, you're right. I was under the (thankfully apparently common) misconception that they were one and the same.
Yes, correct.
thank you so much!! I will deff take a crack at them once i finish off the RoR tutorial.
Sorry! I'll delete it.
IME the internet companies in NYC have pretty stringent interview processes that generally involve whiteboarding solutions to programming problems. It might make some sense to get experience programming in another setting first.
Might have actually read this if the title and tone weren't so obnoxious. Why do people feel the need to write like this?
As the wiki says, &gt; The difference between the two is clearest for functions taking more than two arguments. Say you have f(x, y, z) = N. Currying that function produces three functions that all return a function that takes a single argument. You would call it something like this: curried_f(1)(2)(3), as opposed to the original, which would be called f(1, 2, 3). Partial application in this situation, for instance, could be f(5, y, z), which would return g(y, z), a function that takes two arguments. The 'Mathematical view' bit of the article indicates how insanely complex currying can get (which, for some people, means fun).
upvote for a websockets example that is not a chat application
I know it is done for brevity, but that coding style makes me stop reading the article and moving on. Just because a computer can read it that way doesn't mean I should have to read it that way.
 def f a, b = 1, *c; end
The whole point is to make a compatible ruby parser. If strange ruby makes you that uncomfortable then yes, you should move on.
Whoa, this isn't about a ruby parser. I'm talking about readability, that is all.
I'm just talking about readability. Ruby methods are rarely thrown on one line because they aren't as readable. I understand emphasis on the arguments, and I appreciate that and the time spent to write the article. Constructive criticism is all, nothing more here.
_"makes me stop reading the article and moving on"_ is **not** [constructive criticism](http://en.wikipedia.org/wiki/Criticism#Techniques_of_constructive_criticism). 
I think that I am using the block form to connect, though that alone probably isn't working. What's the difference between the other two, by the way? Obviously, "disconnect" makes the user disconnect from the database, though I wonder how to cache and reuse -- or, what it means, rather. Thanks for responding.
So, a database connection is not actually a 'user', exactly. In a Rails app, for instance, Rails comes with a database connection pool. It'll open a connection to the database, and re-use that single connection for all your (non-concurrent) requests. Or if you're doing multi-threading type stuff, maybe it'll be more than 1 connection, but either way N connections get opened, and kept open, and re-used over and over again. Normally for anything but a VERY high traffic app, 20 simultaneous connections should be plenty. Now I'm not quite sure what the equivalent is with Sinatra and Sequel. The upside of Sinatra is that it's simple; the downside of that simplicity is that it doesn't do very much for you, you've got to do it all yourself, or put together tools to do it yourself for you. But to start with -- I suspect your code is opening a database connection for every request, but then never closing it.The request ends, but the database connection is still hanging out, even though none of your code will ever use it again. Eventually the Postgres database will time it out and shut it down; but in the meantime, it's an open connection that counts against your 20, even though it'll never get used. So the first thing to do is just do that disconnect at the _end_ of every request, just like you did a connect at the beginning. (might want to do it in a `rescue` block, so even if your app has an error and raises and exception, the database connection still gets closed rather than leaking). I don't know Sequel, but if that does what it sounds like, you won't have a too-many-connections problem anymore. Now it would be more _efficient_ to not be opening a new database connection every time you handle a request, to be caching them and reusing them. Like Rails does for you, but like your use of Sequel/Sinatra is not doing for you. But I don't know Sequel/Sinatra, and rather than re-invent the wheel, you should ask what the right/easiest/supported way to do this with Sequel is. I bet there is one, but I don't know what it is. 
in fact, googling around to see how to do this with Sequel... I can't figure out what Sequel wants you to do. The Sequel documentation says it supports 'connection pooling', which is related to what you needs... but I can't find any documentation or examples of how you use this, using a connection from a pool when you need one instead of creating a new one all the time. It seems to me to be under-documented. But I don't use Sequel. Maybe ask on a Sequel listserv or something. 
This is not true. You see it all the time for empty methods.
&gt; As a result, block invocation treats its args as a multiple-assignment instead of like a method call. The details of how scoping works through S-expressions elude me, but are you saying that :args implicity defines a localised scope (thus blocks 'need' to use :masgn instead?)? My rubyists conception (coming from the high level, not sure how this makes sense in C-land) is that a 'block' (or at least, the best part of a block) is the fundamental structure contained within a 'method', and also a 'Proc'. Do the scoping issues actually determine that methods should look so different to the other two, or is this a design decision (for what reason?)
This may not be the kind of response you are looking for, but for me the syntax is less important that the functionality. If I can work back and forth between any valid ruby Strings and Sexps, without worrying about niggling issues like this, Sexp's will probably move from 'something to dabble with' to 'something I'll probably invest serious time in'. Also, as said above, I'd really like method definitions to look more like lambda/Proc.new if that is at all possible. Hope that is useful in some way. Thanks for all your excellent work on both parsetree and ruby2ruby by the way!
Thanks for sharing, keep it up me thinks :)
Apologies then, that is how it was ment. Take it as in insult if you insist.
This is true, thanks for the correction.
Hey, nonrecursive. Feedback is certainly welcome! Here's a little background on this blog: I was inspired to start writing by a comment I think tenderlove made at the Steel City Ruby Conference. Basically, he said that not being the world's expert in a topic is stupid reason not to blog about it. If you figured something out there are probably 20 people with the same problem Googling it. I would add that writing blog posts is also an excellent way to to improve the depth of one's learning in a topic. You don't really know if you know what you're talking about until you try to explain it in black and white. In addition to posts about Ruby, Rails and related technical topics, I hope to do some writing in the future about my transition from academia (philosophy) to writing code for startups.
Yeah, I actually really do. I'm from Canada. Love to travel. Good food and beer in local restaurants is what I am looking for. Areas to just walk around. Things like that. No idea how much time I'll have around the conf, but I've gotta eat and I'd rather go hungry than eat at fast food chains or over priced generic hotel restaurants.
Ya I've been thinking about starting a programming blog for like a year now and this same thing has been holding me back. I'm sure anything I think would be cool to write about has already been written about 1000 times. How do you pick your topics? Do you have some kind of schedule for when you'll write? What finally got you to actually start the blog? Also, how has using Octopress been? 
I'm not entirely sure I fully parse your comment... my brain is a bit addled right now. Blocks and methods are different. They're both chunks of executable code, but that's pretty much where similarities end. Methods have a hard/opaque scope on them and blocks don't. Blocks are closures and methods aren't. This makes methods more efficient to invoke but less powerful in some ways. It also makes them safer. 
I'm kinda pumped that it's gonna be within easy walking distance of my apartment.
pm'd
In my example the controller is only including the module with the smaller scope that has one method via the include statement. The "extend in the included method" approach is common but kind of reinvents the wheel for no reason. Ruby has both extend and include for good reasons. They don't need to be wrapped around each other. This approach does only what is necessary.
not really.
Ok. I get all of what your saying there. My question is really "why is dealing with arguments not largely the same for both methods and blocks/procs?" I understand that the scope is different, but they are basically performing the same task, one just checks an additional scope than the other? I'm not sure if its just 'how all compilers work', or whether its a deliberate design decision to make them so different. Maybe its a stupid question (hey, your the expert) - perhaps I'm just out of my depth here.
Sorry 'this' meant causing an error on trying to parse "{|b=2|}", which I have come across before. If this was fixed, and any other niggly issues (if any others exist - I'm not sure), I'd be much happier to make the leap into working with sexps more regularly...
how did you become so good? I have been programming for over a year and I can't do anything
Well...it isn't mine, but I am in it...
Yes just use the self.included / extend pattern. It works fine and is very common.
Right... well... I wrote this blog post to try to get 'this' issue solved. Thus far I've gotten no feedback to the questions raised so I'm no further in getting ruby 1.9 parsing completed.
rails for zombies is a good instructional site, link over to the right on the sidebar
Like omegle.com but for developers?
Wish I could help more, but it seems from our conversation that I can't - perhaps my knowledge of this are just isn't what it should be. I very much appreciate all your efforts anyhow. I guess my belief is still though that block and method args syntax should be as similar as possible though. 
Is there a certain skill level required for this?
You mean something like http://rubypair.com/ ?
Apparently we're just commenting without actually connecting with anybody, so the plan is to setup some mail notifications and expand on http://rubypair.com or make a subreddit. Yes, skill matching is a must. Wonder if there's a way to not make this thing fail. I'm pessimistic.
Now now, let's keep our options open
This could be our first project.
I get a 500
need list of who is available right now or some kind of a calendar. To make it real use some online code editors or tmux or whatever :) 
I'm learning Ruby right now because i'd like to you use it to build small scale website, and most of the time simple ones, but they need to have a CMS that is online and accessible by the client. This article is about building static websites and i honestly don't see the advantage of using things like nano or jekyll. If you're just going to upload HTML pages to the server, why not just write them yourself ? You can still use Git for version control if you want it, and if you know your stuff, the HTML/css will be cleaner and lighter. I'll still continue to learn ruby through rails, then i'll check Sinatra which i think i more suited to my needs because Rails sounds like an overkill for what i want to do.
yes i agree but we are talking about STATIC website. If you are going to need to change the content of the website, then why not go for a real CMS ? With a solution like this, the developer is almost the only person able to change the content of the website, unless the client is ready to dive into some code. It's like 1990 all over again.
&gt; yes i agree but we are talking about STATIC website. If you are going to need to change the content of the website, then why not go for a real CMS ? When we talk about static websites, we are rarely if ever talking about websites that never change. The term generally means a site where the served up content does not change *independently* of the content or templates. That is, the HTML does not depend on any factors of the users browser, database content, the phase of the moon or request variables. If you're strict about it, it means each url map to one and exactly one file that is served up without modifications. Static site generators are generally used when your site could easily fit that criteria, but where there's lots of content that may change, where the layout may change, and where there may be complicated relationships between various parts of the content that may benefit from dynamic processing *once* each time the content changes. E.g. a blog where the category pages must be updated every time a new post is added for that category fits nicely if you offload your comments to somewhere like Disqus. The site is static in the sense that every page looks the same every time you retrieve it *in between content or layout changes*. The benefit is simplicity, security and performance: You only need an exceedingly dumb web server. You could even serve it off, say, S3 if you want, or shove the pages into Github. A trivial static webserver can return the pages orders of magnitude faster than Rails can process a request. etc. &gt; With a solution like this, the developer is almost the only person able to change the content of the website For some solutions that is true. But there are static site generators that use a more conventional CMS to write and edit the content before "publishing" a static site. But even so, for plenty of uses it is perfectly fine if the developer is the only person that can change the content - first of all a lot of these generators are written predominantly *for* technical users, secondly a lot of non-technical users will never ever touch their own sites and depend on developers to do all updates for them because that's the way they like it. There are plenty of use cases where static site generators are totally inappropriate, but there are also plenty of use cases where they are very convenient. 
The gem you are looking for is `activerecord`, which is the component rails uses internally as well. The other rails components like `activesupport` are available as stand-alone as well. Of course, you'll need to setup the connection to the database yourself: require 'rubygems' require 'active_record' ActiveRecord::Base.establish_connection( :adapter =&gt; 'mysql', :database =&gt; 'database', :username =&gt; 'user', :password =&gt; 'password', :host =&gt; 'localhost') After that, you are able to create model classes just like in rails. If you want to split them up in separate files, you'll need to take care of `require`s and gem handling yourself. This [blog post](http://blog.aizatto.com/2007/05/21/activerecord-without-rails/) contains a lot of basic stuff to get yourself going.
Sinatra using the ActiveRecord gem.
Did you ever think you'd end up as a programmer while studying at Harvard?
Short answer: no. And Zuck was in my class! I considered taking the intro CS class, but it's a really hard class and looked like such a big commitment that I feared it would detract from my studies in philosophy. Plus, it seemed like everyone who took it already knew how to code. I knew nothing. In retrospect, this is not a great way to think if you want to get the most out of a liberal arts education.
(Author of article here - apologies it was so long) Just to touch on rubygeek's and RickyMarou's points here, static site generators don't fit all - if many - use cases. But where they do fit they make building and maintaining sites pretty straightforward. If you're going to script up a bunch of HTML files and serve them, then modifying any common content is a pain - grep becomes your best friend. The main reason I can see not to go with a real CMS is that many of them require a reasonable amount of technical ability to use. That was my beef with Wordpress - I was still having to train clients, having to backtrack the mistakes they made. In the end it was a better experience for all if I ended up doing the work. Sinatra is great and will probably fit nicely with what you want to do. It's not fundamentally different from the old "Rails as CMS", and you'll have a lot more control than using an off-the-shelf CMS. 
I would suggest DataMapper, for two reasons 1) It emphasizes decoupling models from the database (through the use of a DataMapper-pattern object. DM2 does this better than DM1, but DM2 isn't ready for primetime yet, as I understand) 2) It's not nearly as mysterious as rails. The code is significantly clearer, the API for everything is much more straightforward (and DM2 even moreso), and generally (I think) promotes better practices then AR. This is just my opinion, others will undoubtedly disagree, but for my part, I much prefer DM when I can use it.