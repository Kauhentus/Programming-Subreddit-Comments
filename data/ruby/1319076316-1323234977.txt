&gt; All data seems to suggest otherwise. What is this data that suggests otherwise? The only thing I see you saying is that two different ways of measuring produce different results. What is your data that tells us which of these ways of measuring is 'right'? 
Rubinius without the GIL can run C extensions just fine. Instead what we do is shift the locking to the extension code, basically creating a Global Extension Lock. This means that safe, managed code can fully utilize the system, and only when C extension methods are used is there some locking introduced.
Yeah, if it were just _ruby_ code that would break if you removed the GIL (because it was not written thread-safely even though it used threads), I don't think it would be a barrier -- the problem is likely more C extensions and the C MRI. Is what I was trying to say. Anyone writing threaded ruby code (threaded ruby code especially) ought to be writing thread-safe code that doens't rely on the GIL to be thread-safe.... because if you are writing threaded code especially, odds are especially high someone will want to run it on jruby anyway at some point. But the C extensions, my understanding is making them play well with a GIL-less ruby would be much trickier and require re-architecting the entire way they interact with ruby in the first place. But I could be wrong there, as I don't really know how to write a C extension myself. 
Nice, Pry seems to be getting alot of love on this subreddit!
That's a very nice solution. Is there also a way for an extension to somehow signal "I (hope I) know what I'm doing - please let me run lock-free"? That would be great!
Yep, that will be available in 2.0 final. It will probably come in the form of some code you put in the Init_*() function of your extension. Something like: #ifdef CAPI_ALLOW_THREADSAFE rb_disable_extension_lock(); #endif 
Great, thanks!
Introducing yet another ruby testing tool I've never heard of, "steak"? My whole problem here is not knowing which tools to pick, introducing another yet tool is not helping me! Especially implying it's "the" way to do BDD in rails, when I'm not sure it's actually a particularly popular one. 
Actually, I'm saying both data sets are producing the same result (of no correlation), which would be unexpected if you believed downloads correlate with usage. Reading the full article through again, this conclusion is stressed quite a few times. The only time the two data sets have different results is in the *overall* data correlation, which, as explained, is not even an interesting or surprising result. Again, I think you're getting too caught up on how the data was collected rather than what the data is. The data represents real world usage of gems. The fact that they differ in how the samples were collected is actually proved to be irrelevant when you analyze the data. If the NewRelic data *did* show a correlation over the entire set, and GemStats did not, maybe you would have a leg to stand on when saying that a possible interpretation of the data does yield different results. However neither data set was able to show a reliable correlation with downloads, which means, in my opinion, the hypothesis that downloads correlate with usage is doubly busted. ...unless of course you argue that the samples themselves are unrepresentative, which I both don't agree with and don't see any reason to believe is true. I suppose the best way to debunk this data would be to show that the sample is unrepresentative-- which, as I pointed out earlier, would be easy to do, since the data is all there just waiting to be analyzed.
The article is a bit old. Steak was a library ("more of a gist than a gem") that added some stuff on top of the Capybara DSL. As of Capybara 1.0, it's part of Capybara itself. &gt; "the way" It's more about the process than the tools.
EDIT: It just occurred to me that we may be talking about two different things. If you're looking for "real world usage" as a measure of how *good* a gem is, I agree that dependencies and redundancies shouldn't count toward the definition of "real world usage". This hadn't even occurred to me while reading the article, because I do not look at "usage" to gauge the quality of the code, I look at the source code and determine that myself. The only reason I look at "usage" is to gauge the number of bugs I'm likely to encounter while using it. Remember that while reading my previous comment and this one, and I think they'll make more sense. ------- Again, I disagree. The article even status that it all depends on your definition of "usage". And the only reason I'm interested in usage is to gauge how many different scenarios and contexts that gem is deployed in (whether in development, staging, production, top branches, or whatever other context you can think of), because the more contexts in which that gem is used, the less likely I am to encounter bugs in whatever contexts I use the gem. My point is that, for me, for the only reason I care about "real world usage", the number of downloads represents that by definition. Granted, the number of downloads will be inflated due to people downloading it and never using it for the context in which it was downloaded, but that is likely pretty consistent across the board, so as a relative measure (when comparing two similar gems), it still works pretty well.
Write tests.
You can do that in 1.8: class Point attr_accessor :x, :y define_method(:initialize) { |@x, @y| } end p = Point.new(1, 2) [p.x, p.y] #=&gt; [1, 2]
AFAICT, the main reason to use Rubinius at this point is because it has nicer error messages than MRI/YARV does.
oh, nice :)
I just want to say that this should be the most requested feature on ruby 2.0. We do this - Ruby wins
We have plans to add support for/switch. I think it would be best to allow for multiple solutions.
I'm really happy to see more and more discussion on presenters/decorators/view objects.
I kind of think it's a nightmare on purpose to prevent other alternative's popping up. Same thing with Launchpad.
The *rumonade* gem provides "real" monadic patterns in Ruby, modeled on Scala's standard library: https://rubygems.org/gems/rumonade Option(params[:car_id]). map { |id| Car.where(:id =&gt; id).first }. map(&amp;:owner). map(&amp;:name). get_or_else "&lt;not found&gt;" This means something like: car = params[:car_id] &amp;&amp; Car.where(:id =&gt; params[:car_id]).first owner = car &amp;&amp; car.owner name = owner &amp;&amp; owner.name return name || "&lt;not found&gt;" The benefits in clarity, testability, and composability of these sorts of logical chains really builds when using the Option pattern instead of the traditional nil-testing. Also, check out the Either class, where instead of Some/None, one is chaining computations on Right(result) or Left(error). 
damn you one liners
FFFUUUUUUUUU. I always forget to submit my own posts. ;-)
You are my hero.
If someone pulls my head out of my ass, I'd be pretty mad.
I have no idea what's going on here
maybe he was stuck for several years so it feels like a relief.
Maybe, but I'm pretty sure it's hard work to insert your head into your own ass.
What?!?!? First of all, why are there rage comics in my beloved /r/ruby ? Secondly, WTF does this have to do with ANYTHING? I don't mean to imply in my question that I wish to know how this relates to Ruby, but what I am interested to learn is what does this submission have to do with anything that has been or will ever be on this planet. WHAT THE FU... Awww, nevermind.
I was at MWRC that year, and this talk was the highlight for me. Highly recommended.
I think the application actually uses Sinatra. He uses the cgi library to un/escape html it looks like. 
yeah, i think that's what I meant. But why use cgi for instead of ERB or other tools. 
Because he isn't using ERB. He's using his HTMLGen class, a neat little hack that, if you'll notice, works entirely on 2 lines of method_missing.
yeah, but what is the benefit of that? Speed?
Because that's the way he did it. I suspect he wanted a builder-style syntax without the dependency.
Related: read Manning's Well Grounded Rubyist for more on this stuff. Also, you could [download the source](http://www.ruby-lang.org/en/downloads/) and look under class.c for all the relevant C code for MRI mentioned in that video.
yeah but he also made [redis](http://redis.io/), so ... I don't know... sounds like he knows what he's doing. 
From the README he says that templates "suck". Not sure I'd take his word for it after his ignorant bcrypt comments. Edit: "ignorant" is probably the wrong word there. I just felt like he was as guilty of adhering to "dogma" as much as he claimed everyone else was.
I didn't know that title covered such things. I just ordered Metaprogramming Ruby, it covers this type of stuff as well.
If you've heard things like "ancestor chain" and "method lookup" and wondered what they mean. Watch this video. Just watched it this morning. Highly recommended.
Do tell?
He sort of ends up apologizing for it: http://news.ycombinator.com/item?id=3140722 For what it's worth I think redis is an pretty piece of software and no doubt he's an amazing developer.
got the code to that class? Cant seem to find it. 
If he uses method_missing, he definitely isn't doing it for speed.
Umm sorry, did you think you were gonna run your rails app without installing rails? How much do you need your hand held?
It seems that people in 2011 have forgotten how things were before Phusion Passenger came along. The phrase "Rails deployment that just works" should be placed in context. Let's take a step back into memory lane. The year is 2008 and you were using FastCGI on Lighttpd. You had a Rails app. You forgot to install the proper Rails gem. You go to your app's URL and behold. 500 Internal Server Error Ok, something went wrong. But *what*? "Aha!" you thought. "I'll look in the web server's access log!" Nothing there. "Damn it. Let's look in the error log". Nothing there. "Uh, ok. Rails log file then?" Nothing there. You pull your hair out. So no. Phusion Passenger can't do *magic*. It cannot fix any and all of your problems. But it will do its damn best to tell you what went wrong so that you can fix the problem instead of wondering why it doesn't work. *That*, my friend, is what the "just works" refers to. Of course if you have any constructive suggestions on how we can do better, I'll gladly hear it.
You are an epsilon semi-moron. There is, of course, a degree of common sense and an IQ prerequisite to everything and and you do not meet it.
2.0.2 ? How old is that?
Haha, wow, didn't expect such an up-roar. I should explain: THIS IS NOT MY WEBSITE. I was reading a tutorial a while back on using Ajax in Rails and the tutorial offered this page as a "good" example of Ajax implentation. I just found it ironic is all.
Of course, you are directing your highly judgemental comments at the person who created that page right? (which isn't me) Or is finding humor in irony now a crime of ignorance? I can't seem to keep up with all the new laws redditors come up with these days.
you need to look up the word "ironic".
Merriam-Webster says: &gt; incongruity between the actual result of a sequence of events and the normal or expected result; an event or result marked by such incongruity I stand by my statement.
Early 2008 I think
probably should have explained that somewhere... looks like this post has succumbed to the downvote army already.
I was just thinking about posting an image like this the other day.
He's just pointing out the irony in the way they designed their error page; he's not complaining that he (it isn't even his ss) shouldn't be getting an error.
The passenger dudes are Redditors. TIL.
I really like Metaprogramming Ruby and this video is a summary of the first few chapters, both are great resources!
I'm patiently awaiting my delivery from Amazon. I stopped by B&amp;N today to see if they had a JRuby book and... yeah, they didn't have a single book on Ruby. I was disappointed :(
I had a similar idea a little while ago actually, except in my mind the organisation was going to handle a little more of the administration/organisation side of things, rather than just provide a medium for people to hook up. I was focusing mostly on software, and lets face it most charities or clubs or whatever do not have the resources or knowledge on hand to organise a software project.
I agree that most organisations do not have the staff to perform project management. This definitely seems to be an issue with the case of a GiveCamp where you only have one weekend to do all of the work, but with something more ongoing, where you plan on spending a few hours a week/month, it seems that you can work with someone who is less experienced with managing a project. I think this is where the developer/designer would also be able to possibly work on there skills in managing a project. I think that there are a lot of developers/designers who have not had the opportunity to really take hold and manage a project, or at least work with the end client to really nail down a project and take control over it. So, with that said, I believe you have both parties being able to take something away from the project. The client, who woud benefit from the free work, and the volunteer who would be getting experience that could go on a resume and create a warm fuzzy feeling inside for helping people.
http://www.sparked.com/ check it out.
In my hometown we have this: http://www.gmcvo.org.uk/ You might also want to check out http://www.vso.org.uk/ in particular http://www.vso.org.uk/volunteer/STV/it-specialists.asp?gclid=CIPdrrqRgawCFYob4QodIAKDKA We also have http://www.do-it.org.uk/ which might inspire you!
I have no idea how good it is, but someone posted this on the nyc-ruby mailing list a couple of years ago: http://webserves.org I spent a couple of years back around 2005-2006 trying to volunteer and was continually frustrated. Please update r/ruby if you make progress
I would definitely look at sparked.com which seraph787 made me aware of. I will definitely update r/ruby if I make progress. Thanks!
We experimented with a weekend long online hackfest for social good at Mendicant University this weekend, and had some decent results. I think there were a few things that made this event go smoothly, some MU specific, some not. But the key thing we did that I think made a big difference is that we selected projects that at least one of our students was already involved with in some way. This gave us a nice two way bridge: the volunteers who showed up had a programmer to talk to about requirements, the organizations had someone to talk to who was already familiar with their needs. I could see this basic model being generalized to some sort of ongoing effort. The website would be a place where technical liasons could advertise projects for volunteers to work on. For the MU hackfest we had simple tech profiles about each project, so I'd recommend having a mechanism for doing something like that. Here's an example: http://projects.mendicantuniversity.org/hackfest/2011/09/14/mission-of-mercy.html Anyway, there is a lot more I could say about this, but maybe it'd be better to do so over email. Feel free to contact me at gregory.t.brown@gmail.com
tl;dw for those who can't do video?
Doesn't ruby 1.9.3 not need these patches? Is ruby 1.9.3 not out yet? EDIT: Nevermind, I see 1.9.3 release isn't out yet. When I saw a preview release Aug 1 and the plan for final release within a month I think, I naively figured they'd hit it. Has ruby (or rails) _ever_ come close to hitting their target dates? I'm thinking we won't actually have to deal with ruby 2.0 until 2015 or something. 
Ruby 1.9.3 is available as RC1 (see http://www.ruby-lang.org/en/downloads/) and as pointed out by Peter Cooper on his blog (http://www.rubyinside.com/ruby-1-9-3-faster-loading-times-require-4927.html) it appears that a patch similar to Xavier Shay's was committed by Masaya Tarui a few days after. So it looks like the patch shouldn't be needed if you use 1.9.3 today, although I haven't tried lately so I am not 100% sure. I am not using 1.9.3 yet though since it's not stable yet so I don't see the point. I use 1.9.2 as default Ruby these days so for 1.9.2 you still need the patch to fix the slow startup issue.
I see you edited while I was replying :) Looks like it's planned for release in Feb 2013: http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/40301. 
Just noticed that a post by Peter Cooper has also been submitted to this Reddit concerning Ruby 2.0 - http://www.rubyinside.com/ruby-2-0-release-schedule-announced-roll-on-2013-5536.html
Thanks for finding that, I was trying to figure out if there were any dates for 1.9.3, but not finding any info. I could have sworn I saw an earlier plan that said final release in September. Hmm, not till February, huh? I wonder if people are using RC1 in production. I have an app that I'm in the middle of migrating to Rails3/1.9.x, and I'd really like to go straight to 1.9.3, but not sure I can wait until Feb (assuming they hit that). 
Oh wait, tha'ts Feb 2013 for 2.0! Anyone have ANY idea when a 1.9.3-p0 is expected?
rvm knows about 1.9.3rc1 now. rvm get head rvm reload rvm install 1.9.3-rc1 If you're me, then you get a certificate error, and go about googling what to do about that, so I haven't actually installed it yet, but rvm seems to know 1.9.3-rc1
Thanks for the link. Here's a link to what might make it to 2.0 (from the above link), its also by the thread initiator. http://www.rubyinside.com/ruby-2-0-implementation-work-begins-what-is-ruby-2-0-and-whats-new-5515.html
I didn't find anything interesting about this at all, pretty much amateur hour here. -1
I do. Everyday on #rubyonrails and various other irc chans.
What would we like to see in ruby 2.0? I'll go first: * gil removal - I want true concurrency! * native epoll/kqueue methods would be good too
There are many people with different level of skill out there. Maybe this isn't meant for you, but will help some other persons.
Weird, I couldn't find any official release date for 1.9.3-p0 -perhaps I have missed it- while I could easily find it for 2.0. I bet it will be released by the end of the year though or very early next year I think since they're almost there with it. It's not a big deal compared to 1.9.2 IMHO, so perhaps that's also why there seems to be a little more emphasis on the 2.0 release here and there.
WTF? Lame
I don't see you posting anything better.
Was there a comparison with returning nil? If you write a function, would it be better to return nil or not bother with a return type -- which would return implicit of the last line of the function? Why was returning a symbol so much faster than everything else?
I think symbols are singletons (or something real close to singletons) which probably plays a role in the difference between speeds. I added the following: def implicit_last_statement 1 + 1 end def explicit_nil 1 + 1 return nil end And re-ran (with ruby 1.9.2-p180) and got the following results: Rehearsal ------------------------------------------------------------------ Explicit "" return 17.510000 0.030000 17.540000 ( 17.528459) Implicit "" return 17.680000 0.030000 17.710000 ( 17.689267) Explicit '' return 17.810000 0.040000 17.850000 ( 17.838777) Implicit '' return 17.590000 0.030000 17.620000 ( 17.612614) Explicit symbol return 9.600000 0.010000 9.610000 ( 9.611302) Implicit symbol return 10.190000 0.020000 10.210000 ( 10.194446) Explicit nil return 10.240000 0.020000 10.260000 ( 10.246717) Implicit last statement return 10.080000 0.010000 10.090000 ( 10.094462) ------------------------------------------------------- total: 110.890000sec user system total real Explicit "" return 17.580000 0.030000 17.610000 ( 17.589883) Implicit "" return 17.670000 0.030000 17.700000 ( 17.693682) Explicit '' return 17.760000 0.040000 17.800000 ( 17.786944) Implicit '' return 17.650000 0.030000 17.680000 ( 17.674322) Explicit symbol return 9.810000 0.010000 9.820000 ( 9.815872) Implicit symbol return 10.050000 0.020000 10.070000 ( 10.058501) Explicit nil return 10.370000 0.010000 10.380000 ( 10.378464) Implicit last statement return 10.040000 0.020000 10.060000 ( 10.050314) First, you'll notice that my results don't exactly match his (relatively speaking). But there was barely any differentiation between the results in the article anyways... As far as the explicit return of nil, there is an extra statement to execute if you return nil, so it makes sense that it might take ever so slightly extra time to execute. More importantly, I don't really see a case for returning nil instead of the last statement where you aren't checking the value of the return. I.e., if you are concerned with the return value, then you likely don't want to return nil unless its meaningful, and if you are ok with changing the return value from the last statement executed to nil it seems like you are just executing the function for side effects and don't care about the return value...
Also, I thought the metaphor was great. While you may be beyond the content, there are some who are not. (-48 comment karma, eh? So, you're THAT guy...)
Wow, what a worthless microbenchmark.
They're [interned strings](http://en.wikipedia.org/wiki/String_interning) -- so yah, they're basically singletons.
I see I got downvoted, but I am not just being flippant. This type of analysis is almost certainly flawed, likely not measuring what it thinks it's measuring, and what do you really learn from this? That you can make 100 million method calls in a matter of seconds. IT DOESNT MATTER. If you're optimizing your programs by thinking "I should use explicit returns", then you're wasting your time on the wrong things. This was never going to be a bottleneck, and even if you wanted to learn more about it you should have looked into how the interpreter(s) implements it, and not some lame surface level benchmark.
I've posted better, and I too think this is lame. FWIW you don't have to post anything at all in order to have a valid complaint of lameness.
Thanks for the confirmation.
https://github.com/gazay/spik/blob/master/lib/spik.rb#L11 that's a lotta logic in #method_missing
That's the worst benchmark I've seen in a very long time, and that's some achievement. Just look at VM code that they get compiled to identical code, done. String is slower because it needs to allocate fresh string object since it's mutable, symbol just returns the same object each time. Everything else is same VM code.
Thanks!
I got halfway through the article before I realized it wasn't about stabbing :(
And great test coverage: * https://github.com/gazay/spik/blob/master/test/integration/missing_method_test.rb * https://github.com/gazay/spik/blob/master/test/spik_test.rb
Yo dawg, I heard you like DSLs...
I'm pretty sure that implicit returns are not *possibly more* idiomatic ruby; they are idiomatic ruby. If you read the source on a few widely used libraries and gems (say, fastercsv, date, cancan, minitest, or rake), or read a book like "Eloquent Ruby", you'll note implicit returns dominate against explicit ones. I think the community decided on this one.
So true. You probably have a better chance of winning the lottery than ever bottlenecking or taking a hit on this. The question should be, "what is idiomatic?" I think the answer on that is "implicit".
Sometimes you just have to mock the victim to death. 
This is one amazing abomination. Kudos for figuring out how to make ruby do that... 
If you publish this as a regular page, it won't require a login to Google.
It would be cool if there was a "Is able to return IP from HTTP Response" column. Especially when trying to minimize the amount of network calls, I'd rather not have to do a DNS call and THEN do an HTTP call which will internally do another DNS lookup. I could just do the DNS call myself and then use the "host" header in the HTTP request, but I'd rather let the HTTP library do that for me. Curb e.g. supports saving the IP in the response object 
Ryan Bates has listed the materials that he uses for RailsCasts [on his about page](http://railscasts.com/about). This seems to be a nice setup and he has done well with it.
&gt; Especially when trying to minimize the amount of network calls, I'd rather not have to do a DNS call and THEN do an HTTP call which will internally do another DNS lookup. Install DNS cache.
Gary Bernhardt from Destroy All Software uses ScreenFlow I believe. A lot of others use this for their screencasts. If you are using Linux: recordmydesktop can create a pretty good screencast and you can use Pitivi (http://www.pitivi.org/) to edit the whole thing.
Is there a modern resolver that doesn't cache lookups? Maybe rb2k's DNS records all have zero second TTLs?
While I haven't done a ton of screencasts, Screenflow is well worth the money and easy to work with. You may need some additional software if you want to do things like dampen noise levels in audio, though.
how do save this so i can see it in my docs list ?
They don't, but while installing a local DNS cache would solve that, I think that just having it in the HTTP library would save a bit of infrastructure work.
this post only has 4 karma so i think a lot of people agree with me, it sucks.
Not on the list: https://github.com/tarcieri/http
I like ffmpeg for screencasting. I am on a Lenovo t410s (1440 x900 resolution) running Fedora 16 beta. ffmpeg -f alsa -i pulse -f x11grab -s 1440x900 -r 24 -i :0.0+0,0 -acodec aac -strict experimental -ar 44100 -ab 160k -vcodec libx264 -vpre lossless_fast Desktop_Recording.mp4 
I use Screenflow too and give it a big thumbs up. It's ideal if you want a one stop shop for editing too, although I have FCPX for adding live video elements too.
[Queue](http://www.ruby-doc.org/stdlib-1.9.2/libdoc/thread/rdoc/Queue.html) It's in the standard library and sounds like what you're looking for. Set up the queue before making the new thread and both threads will be able to share it. Then, just write any data from stdin to the queue and it can be consumed by the other thread.
http://pastebin.com/zsxn8kjb
That implementation works (minus a few typos) but still has some problems. I imagine your main thread is supposed to do #getsanity and if it is 1, sets it back to 0, and does something related to there being a new message. Here's a quick cleanup and simplification: class Testa def start sanity = 0 Thread.new do loop do s = gets.chomp exit if s == 'end' puts "You entered #{ s }" sanity += 1 end end loop do sleep 1 # wait a second # do something puts "Sanity is #{ sanity }" sanity = 0 end end end Testa.new.start The key thing here is that the "sanity" variable is defined before the new thread is made, so they both have access to the same data. This can be problematic but in your case, exactly what you need. Class variables can be useful but are often used when they aren't needed, and you could only ever have one Chuck or Testa. There are a lot of performance modifications you could make, but I don't know exactly what you plan on doing in the main thread and some won't apply. You could still use Queue like I recommended but yeah, it's a little bit of overkill if you just want cheap notifications like this.
pipe and select; read up, go forth, and conquer the unix world!
&gt; * you need quickly to deliver fix &gt; * the fix is very trivial (e.g. tiny fix in Rail’s view) &gt; * the fix affects not running code (e.g spec file) I understand how you can get away with this in the third case. (although why do you care what spec's look like on production servers? Nobody runs tests in production, do they?) But if the fix, even a tiny one, is in a Rails view, won't the entire Rails app need to be restarted anyway? Production rails apps don't recompile views after first use, right? Personally, no matter how small the change, I don't like the idea of having something deployed that isn't tagged in git. I _think_ this procedure leads to that? I think maybe this technique is for someone with a lot more complex/large deployment env than me! 
Keep in mind that MRI 1.8.7 does kind of terribly with threads due to use of green threads. Based on my experiences with threading, I _suspect_ (but could be wrong) this won't work out very well under mri 1.8.x no matter what you do, threads will end up blocking but still not switching out. Consider using jruby or mri 1.9.x, in theory they should both handle thread-based concurrency better, as they use native threads rather than green threads. I haven't extensively tried either one yet, but I know in mri 1.8.7 even relatively simple operations involving threads just don't work out like I'd think/hope/like. 
Hmm, I don't think it's a good idea to access a shared variable in each thread _without_ using syncronization of some kind. See the Monitor class for instance. It _might_ be okay in any ruby implementation that still has the Global Interpreter Lock (although I'm not certain, ruby documents very little as to what you can count on when using concurrency), but if you're using threads, odds are eventually you're going to want to explore a ruby implementation without the GIL (say, jruby), and then I think it will likely be disastrous. Concurrent programming using thread model is hard even when using a language that does support it clearly and robustly (say, Java). But in general, you can't have access to variables like that from multiple threads without using synchronization primitives at some point to guard access. I think. 
&gt;although why do you care what spec's look like on production servers In our deployment flow the code in master branch means production code. It means that code already on production or in delivering process. So anybody can easy frind *real* code in repository. Thus we must provide delivery even it does not affect running code (spec file etc...) . &gt; But if the fix, even a tiny one, is in a Rails view, won't the entire Rails app need to be restarted anyway? Production rails apps don't recompile views after first use, right? Yes it should be restarted. But you need in this example only restart your passenger/unicorn. You don't need to restart resque workers for example, becase view fix usaully does not affect worker. &gt;Personally, no matter how small the change, I don't like the idea of having something deployed that isn't tagged in git. I think this procedure leads to that? No. We always create tag after merging fix to master branch. And in our examples you may see that we use tags ("cap banana patch FROM=v7.0 TO=v8.0") The recipe resolves git reference/tag/branch to real revision ( "git ls-remote git://scm.railsware.com/banana.git v7.0"). Becase sha1 is 100% commit identification in repo. So recipe operates with real revisions instead of "symlinks". But you are not limited to git tags. You may use any valid git reference. You are not forced to use tag. You should it use for production env but may use references for staging env for example. Recipes give you flexibility and freedom. It's only automated tool that helps you. As I said it's not NEW deployment strategy. Its about how to quickly in right way delivery the code changes. 
You have -48 karma, so what does that say about you? Listen, I get it, you are the guy that wants to tear down everyone else. The article you are targeting here is the first one from a young guy trying to learn and grow in Ruby and the community. Easy target for someone like you, I guess. Do yourself a favor and try being positive for a change. If you have real criticisms of the article, what are they? Do you have better debugging tools? Just saying "it sucks" does nothing other than increase your negative karma. I am sorry you didn't like this article. I did. Have you written any articles for the community? I'd love to read one.
I seem to remember Windows XP not caching lookups. I know Windows 7 does, however. So do Linux and OS X. There's also the obvious solution of resolving hostnames yourself and caching the IP address _before_ calling the HTTP client.
Using Screenflow (http://www.telestream.net/screen-flow/) on Mac — it is easy to use but powerful tool.
It's kind of impressive, but this really seems to be a solution in search of a problem.
I definitely agree, but I wanted to keep it simple. This is about learning Ruby and simple threading communication, so it doesn't need to be completely accurate and can be a bit looser on performance/safety. crypt0s' implementation showed that he wanted to share variables but didn't know how to do it outside of using class variables, so I just wanted to show how. In theory, yes, you need a mutex if you want multiple threads to read/write to the same variable. You also want to have blocking behavior for the main thread using either Monitor or Queue. You could also use a non-blocking form of #gets only use one thread. I didn't feel it was right to dive into all of these details for a simple question.
It's only tool, which require some level of awareness. If you have one simple task - put everything on production and restart rails worker, you don't need this tool. But, if you have deployment routine with several big steps, you can stick with it. For example, on my project full deployment takes about 10-15 minutes. And fetching sources + restarting workers it's the smallest one. So, for my project it's handy, because instead of full redeployment cycle it's take about 1-2 minutes. Of course, you should be aware using this tool and have good understanding which part of your app can be touched by your patch.
Too old (February 1, 2009) and useless. [A better useless benchmark.](http://shootout.alioth.debian.org/u64q/performance.php?test=knucleotide)
This is great. I wish someone would chime in on whether all of those guidelines make sense or if there's something out of place. As a rails beginner, I have no way of telling if the author is 100% correct :)
Ruby and PHP are in the same "class" of language performance. Be careful when going off of benchmarks because they usually don't reflect real-world conditions.
cap deploy:upload look into it.
I can't see how this is that much quicker. If you're using a simple setup where you deploy straight from master or a production branch in git or another scm, it takes a couple of minutes tops. Surely doing all the tagging and messing around would take longer than that anyway? using remote_cache strategy in capistrano means your server only needs to check out the missing commit, not wait for the entire codebase. The only quicker way, would be fixing a small typo by editing the file directly on the server
yah - capistrano recipes have to be some of the most reinvented parts of a rails application. you really dont need this blog post/framework to solve the problems they are describing, everything can and should be doable with the default recipes or your own cap tasks if needed.
Sure, a few things that were retarded right off the bat: 1. No one uses the ruby debugger 'debug' - the `ruby-debug` project is a far superior product, he should have demonstrated this instead. Mentioning it in passing only to say 'you should actually use this instead' doesn't make sense. If he's suggesting you should actually use it, why doesn't his example include it, instead of `debug` which he assumed you wont' even use. 2. No you do not use `trace_func` for debugging! Way too unwieldy, you would use `ruby-debug` for this instead. 3. There was *no* context given for the article, he could at least have designed a program with a bug in it, and then demonstrated how the introspection mechanisms aided in uncovering this bug. Instead he was just showing a bunch of reflection/introspection methods outside of any debugging context - so yeah, not so much "debugging" just "introspection". The article needed context. 4. In summary, the article just seemed a mess of introspection/reflection mechanisms given with no debugging context; coupled with outright bad and stupid suggestions for actual debugging tools - like `debug` and `set_trace_func`. For my own debugging choices, i normally use `ruby-debug` and more recently `Pry` (which i note he failed to even mention). EDIT: maybe this is also a reason why so many 'rubysource' articles (which you appear to spam this reddit with) do so poorly -- you only get amateurs to write them. How about you get rubysource to concentrate on producing good, well researched articles by experienced developers instead of just making the site a platform for "young guys to learn and grow in the Ruby community" (vomit) ? 
Also have a look at [Mutex](http://www.ruby-doc.org/core-1.9.2/Mutex.html)
This article is way too old to be useful (unless, you're on CentOS :p) Ruby 1.9 / YARV, JRuby, Rubinius - they've all made VM/implementation improvements since 2009, and I'm sure PHP has, too, but I don't follow it as closely. 
Finally, some actual pertinent feedback. We'll take it, even if the delivery is full of venom. BTW, this kind of feedback (at least, the numbered list) is great for the comments of the post. As far as spamming reddit, I am the Managing Editor of Rubysource. When we have a new article, I want the community to read it. Is there something wrong with posting these links to reddit? We aren't collecting info or charging for anything. I don't mean to spam, I mean to say "Hey, here's a new article on something Ruby". EDIT: So, reading [this page](http://www.reddit.com/help/faq#Whatconstitutesspam) it seems you may have a point. While I certainly do read a lot of content off of reddit, I almost solely post our rubysource articles. I will cease doing so. If someone else wants to post the article (deeming it worthy), then great. I won't blindly post all our stuff anymore. Again, thanks for the feedback. /EDIT Our current articles on Rubysource are aimed more at beginners or "amateurs", as you put it. Again, I don't see why that is bad. The community, IMO, needs content focused at all levels. You had an opportunity here to take your relevant feedback and make a conversation around this article that was constructive. Then, someone might have learned something, someone might have been a better Ruby developer. Someone might have benefited from your knowledge. Instead, you went the Bully Route. If you are as good of a developer as you seem to think, it's too bad you use that talent as club instead of a light. You consider yourself beyond the level of this (and, apparently, all of our) article(s). That's great. It doesn't mean the article is worthless. I feel like you've been told this a couple of times in this thread. I guess you just aren't gonna get it. I'll ask again. Do you have a blog or any content that you've put out to the community? Maybe, here at Rubysource, we could learn from your example. Thanks for the feedback.
sorry for being an asshole, i had a bad week
1.9.3 is a step backwards for debuggers IMO, they decided not to expose a bunch of symbols necessary for libraries like `ruby-debug` to operate effectively, yet provide (AFAIK) no alternative way to access this information. 
Dread to think what his C++ was like if it was barely twice as fast as YARV.
Dont' forget that MRI 1.9.x still has a GIL, so you won't get real concurrency, whereas JRuby and Rubinius don't, so you will. :)
Looks like an interesting [set of changes](http://www.rubyinside.com/ruby-1-9-3-preview-1-released-5229.html) over 1.9.2. Can't spot anything that I can immediately go out and do on my project though... Any ideas?
ZOMG everyone look at how my shitty code compares to my shitty code in a different language! Now fail to extrapolate useful data about the languages themselves from this!
This pretty much sucks... I don't understand why this happens, don't they do debugging themselves?
API-wise there's not much of a change. 1.9.3 is mostly a maintenance 'under-the-hood improvements' release. The most notable change is that `require` should take less time to load now, making Rails projects have faster startup times.
I can confirm, loading up a rails console or rspec test suite is now significantly faster! Little by little, it's getting there.
Maybe they use [pry](http://pry.github.com/) or irb rather than ruby-debug. (I'd never heard of ruby-debug.)
There's a ruby 1.9 version of ruby-debug (https://github.com/mark-moseley/ruby-debug).
In the name of efficiency, or did they just forget or neglect debugging?
yeah ruby-debug works fine on 1.9.2, the question is whether it works fine on 1.9.3
just in the name of encapsulation, they didnt want to expose too much private api
Hot damn, I like it.
Although my Rails servers rarely restart, this is still useful since I use the rails console quite frequently. Thanks for replying!
you could try also patch https://gist.github.com/1272991 to further improve require timing
The source code is linked. Take a look yourself.
Has anyone actually used Spree? We've just had to ditch it for a project due to the god-awful documentation. It's also heavily tailored to one specific purpose, rather than being an easily adaptable eCommerce platform.
&gt; If you're using a simple setup where you deploy straight from master or a production branch in git or another scm, it takes a couple of minutes tops If you application deployment is trivial and nothing extra for deploy needed and you don't care about tagging you may just use regular deploy with remote_cache strategy and be happy. But if you have big application then deployment definitely is NOT trivial. Thus cap patch can helps.
Goddamn... TIL.
I use XSplit for Starcraft 2, but also for programming demos. It works out of the box, and until it's out of beta, it's free. Totally just run and go. http://www.xsplit.com/
The links don't work - the entire pastebin.ca site is dead. Verified from multiple locations.
ruby-debug19 builds, but wont load due to the missing Symbols (lol C). `require': /home/hal/.rvm/gems/ruby-1.9.3-p0/gems/ruby-debug-base19-0.11.25/lib/ruby_debug.so: undefined symbol: ruby_threadptr_data_type - /home/hal/.rvm/gems/ruby-1.9.3-p0/gems/ruby-debug-base19-0.11.25/lib/ruby_debug.so (LoadError)
BOOOOO. Wasn't the in-built debugger supposed to work nicely now?
True, but for many concurrency needs the GIL is not a problem, if the threads are well behaved. Often blocking and context-switching on I/O is all you need out of intra-process concurrency.
Sounds like your bash profile needs updating or just need to run `rvm use 1.9.3` to setup environments for the current shell. This page has more info: http://beginrescueend.com/rvm/basics/
try this? http://blog.sj26.com/post/10263431961/using-ruby-debug-on-ruby-1-9-3-preview1
rvm use 1.9.3 --default
Thank!
I had weird unresolvable errors with RVM, and felt that it was over complicated for what I need it for. I read people arguing about this HN - some people make a fuss out of the fact that it does some supposedly risky things like overriding the unix 'cd' command. Rbenv is much more simple and seems like a robust solution to me. I feel like this is an important question because they both do the same job - just pick whatever you're most comfortable with. I think it's unfortunate that so much drama has surrounded this question and think Wayne deserves all the respect ( and donations ) he can get for creating such a useful tool for the whole community. 
If you want simplicity, use rbenv. If you want many features, use rvm. I think that's the only thing that matters here. Both tools are great and it doesn't matter which one you use as long as you feel more productive and happy when you're using one of them. One more thing. If you don't like to keep binaries in ~, you should install rbenv via homebrew.
RVM works fine for me. Though rbenv and ruby-build looks simpler under the hood, does that even matter? It doesn't to me, so I'm sticking with RVM.
There may be some potential issues with `cd` and `rvm`, but it's worth making a few points: + Concrete examples of actual problems are few and very rare + You can disable `rvm`'s overriding of `cd` by setting `rvm_project_rvmrc=0` in `/etc/rvmrc` or `~/.rvmrc` See [this post](http://batkin.tumblr.com/post/8847990062/on-rvms-cd-script) for some more discussion. (At the time the post was last updated, `rvm_project_rvmrc` was *disabled* by default. Now it is *enabled* by default - you have to opt-out now, but it's dead easy to do.)
Well, there are other supposedly risky things in rvm, one is using "umask 022" in system-wide installations ...
You can also create a text file called .rvmrc and put it in the directory of your project that uses 1.9.3. It could contain a single line: rvm use 1.9.3@myproject --create That way the system switches when you enter the directory, the project has it's own gemfile, and the rest of your system can have a different default and global gemset. If you want to do it that way.
You'll need something like selenium or watir to interact with javascript. Mechanize won't work for you there.
Simplicity is a matter of perspective. The article found at http://www.jonathan-jackson.net/rvm-and-rbenv states the exact feelings I had while comparing RVM and rbenv. As if RVM weren't already easy enough to use with the help prompts and website documentation/examples, there is an OS X GUI for it. http://jewelrybox.unfiniti.com http://unfiniti.com/software/mac/jewelrybox I don't really see rbenv as more simple. It's just a different approach to ruby management. Less features != more simple. Less heavy might be a better description. Simplicity depends on your needs and level of comfort with software use. I very much enjoy using RVM and will continue to use it. 
If you're just coming over the the Mac world and not quite comfortable or interested in always using the command-line for RVM, there is now a GUI you can use. You can install and remove rubies, manage gems and gemsets, and switch rubies all from the application. You'll even be notified of RVM updates via Growl notifications. http://jewelrybox.unfiniti.com http://unfiniti.com/software/mac/jewelrybox
Hey, that's really useful thanks. 
I switched and I never really had a problem with RVM. I have noticed that using rbenv has reduced my overhead. I wrote an article about how I install it and my workflow: http://www.mentalbrew.com/blog/2011/10/24/using-rbenv-to-manage-your-ruby-installs/
I started a store with it. Eventually I had to abandon the project because Spree was causing me so many issues. It took me several weeks of work just to get the thing running properly only to find out that once orders started coming in things were still messed up. Also, their documentation is a joke.
I had not looked in to MagLev before, but now I like what I'm seeing. It's model of running a persistent server seems to have some interesting advantages. I assume the server will run across multiple processors? If so, it sounds like this would enable easy and efficient method of running multiple tasks in parallel and communicating with MagLev's persistent objects. It would be interesting to see some benchmarks comparing this to multi-threading on jruby, rubinius, and ruby 1.9.2/3 - to see how it stands up with processing time and memory usage when stressing multiple processors.
Woah, might give jewelry box a try. We're also considering buying rubymine licenses for the office, so I think a version manager might be left to our production box only. 
Maybe I'm really tired, but that seems backwards to me. I like various Rubies on my dev box so that I can test that things work before pushing to a production box. For example, you have an app on 1.8.7 in production. You're considering updating to 1.9.2, so you fire that up on dev box and see what breaks (hopefully nothing) *before* you update the production box. Sandboxing and testing is really what RVM et al are good for.
http://blog.wyeworks.com/2011/11/1/ruby-1-9-3-and-ruby-debug These seems to work, although listed as unstable.
Multiple production environments for our products. As we roll our services, some of the newer products require different rubies depending on the customer. Also, it's be for our clients sandboxing environments.
Oh, I gotcha. That's a great use case, too.
There is one big hole in shims approach - it makes all the gem and ruby binaries available in your shell ... just not always functional. Having something installed in one ruby (like haml) will make it shim available in all rubies - just not working. Shim approach is working against the system - building another abstraction layer not respecting UNIX mechanisms - like PATH search - just fooling your system (and you). It is not possible to run a shim/ruby without rbenv loaded - it s required to to make the environment working as expected - in contrary RVM by default builds environment files which sourced once make your system aware of the exact combination of ruby and gems you want to use.
Holy Snap Peas!! JewelryBox is like Peas and Carrots, and Life is a box of chocolates! In all seriousness, being an early user of JewelryBox I have come to find that it has eliminated alot of over head in managing my gemsets, rubies, and just seeing exactly what my RVM install is doing. I would highly recommend it to anyone currently running a multiple Ruby environment. 
Not sure if this helps, but a quick googlin' of "ruby email client receive" gave me this: http://capturedsparks.com/2008/06/receiving-emails-with-ruby-on-rails/
What format will the body of the email be in? If you can write the body in yaml format, then just use the standard yaml methods to read and parse the information.
Yeah, it's really sweet!
Well, you can already read the body. That's half of it. The other half is specifying markers that you can use the get the data you actually need out of the email. Otherwise, you're going to be writing a natural language parser.
Have you looked at Rubytoolbox.com? I've seen mail processing gems in there
gets an upvote from me
OS X caches lookups: $ sudo tcpdump -ien1 port 53 [...] 15:00:37.155821 IP 192.168.1.233.62424 &gt; dns.sea1.speakeasy.net.domain: 2037+ A? yahoo.com. (27) 15:00:37.156088 IP 192.168.1.233.58254 &gt; dns.sea1.speakeasy.net.domain: 6496+ AAAA? yahoo.com. (27) 15:00:37.715613 IP dns.sea1.speakeasy.net.domain &gt; 192.168.1.233.62424: 2037 5/0/0 A 209.191.122.70, A 67.195.160.76, A 72.30.2.43, A 98.137.149.56, A 98.139.180.149 (107) 15:00:37.715616 IP dns.sea1.speakeasy.net.domain &gt; 192.168.1.233.58254: 6496 0/0/0 (27) Are the only lookups from running: ruby20 -rsocket -ve 'Addrinfo.tcp("yahoo.com", "http"); Addrinfo.tcp("yahoo.com", "http")' multiple times. If you want to customize caching use or modify resolv-replace.rb (ships with Ruby). 
I use mailman: https://github.com/titanous/mailman It's pretty simple for pulling an email from imap/pop/stdin and running it through a sinatra-style controller.
Ripper improved immensely. I sent in a lot of bugfixes to make its output sufficient and consistent enough to perhaps implement Ruby itself - its output was too buggy before to actually do that.
I don't know- the email will be in Outlook. This is actually my first time taking a programming class. So, trying to work my way through it. 
Okay, this seems to make some sense. I could use an array to store project names and then tell the program to create another array with the names of projects found. Now, I have to figure out read and store hours. 
Thanks, I'll look into that. 
I switched because I was sick and tired of running cd . ( or rvm reload ) all the time.
yeah, ruby-toolbox.com (FTFY) is awesome.
Pro tip: You're gonna need to be a bit more specific? Also I guess maybe try one of those freelancing sites.
feel free to pm with details
There are plenty of answers here, but I thought I would also mention another alternative is to use rbenv (https://github.com/sstephenson/rbenv) ... There is a lot of drama that went down between rvm and rbenv; which you can google, but it's another available option that you might be interested in.
PM me if ryanto and defconnor opt out...
Interested if no one else takes it up.
this is very cool and all, but is anyone as irked as me by him having all classes and tests in the same file? *shudder*
I'm using ruby 1.9, so threading should be "native".
This is cool. Basically, I wanted the thread to check for input, then throw that some was detected to the main process, which would in turn execute a method to change the color of a light. I couldn't do that from within the thread, since that wouldn't be working on the same object instantated by the main thread...would it? I guess I could always globally define the object, couldnt I?
Feel free to pm me
How does this compare to Devise?
Perfect timing as I am setting up capistrano for some projects at work.
Any objects defined before the thread is made will be accessible by the thread. After the thread is made, then any new objects will be restricted to just that scope. Example: a = "Hello World" b = 2 Thread.new do a.downcase! b = 7 c = 23 puts a # hello world puts b # 7 puts c # 23 end sleep 2 # waits until thread is done executing puts a # hello world puts b # 7 puts c # NoMethod exception Be careful though. If two threads read and write to the same object, you can get some very funky behavior (try it without the sleep). If you want to do something like that, you need to use a Mutex to synchronize the threads. I didn't use a mutex is my code way up above because I was abusing how MRI (stock ruby) uses threads, but you won't be that lucky all of the time.
Very informative. Would like to know more about executing hoc commands from cap shell if it's possible.
[Relevant](http://speakerdeck.com/u/tomstuart/p/programming-with-nothing)
The speaker is a co-founder and the CTO of a startup called Panjiva, and he will be talking about how Ruby is used in his startup
Check out the "railscasts" on OmniAuth. Great stuff. 
OmniAuth's greatest strength is that it plays very nicely with every OAuth provider whereas adding the likes of Facebook and Twitter to devise can be a PITA, and usually involves devise anyway. OmniAuth's Identity strategy is fills the part that Devise was providing, so I look forward to trying it out. It'd be great to only have one Authentication library in play.
What do you mean "hoc commands"?
I meant to say ad hoc commands. Instead of writing a rake task just type in a command.
The only issue I've had with OmniAuth is authenticating with Google using OAuth. Although, I think it has more to do with Google's outdated documentation though. It's great with rapid prototyping/deploying facebook connect apps though.
That's? $ cap shell cap&gt; help --- HELP! --------------------------------------------------- "Get me out of this thing. I just want to quit." -&gt; Easy enough. Just type "exit", or "quit". Or press ctrl-D. "I want to execute a command on all servers." -&gt; Just type the command, and press enter. It will be passed, verbatim, to all defined servers. "What if I only want it to execute on a subset of them?" -&gt; No problem, just specify the list of servers, separated by commas, before the command, with the `on' keyword: cap&gt; on app1.foo.com,app2.foo.com echo ping "Nice, but can I specify the servers by role?" -&gt; You sure can. Just use the `with' keyword, followed by the comma-delimited list of role names: cap&gt; with app,db echo ping "Can I execute a Capistrano task from within this shell?" -&gt; Yup. Just prefix the task with an exclamation mark: cap&gt; !deploy cap&gt; 
Devise uses OmniAuth for OAuth strategies. This latest release of OmniAuth takes the one advantage Devise had, building an application specific authentication instead of using OAuth, and built it right in to OmniAuth. Now there is very little reason to use Devise at all.
*Now there is very little reason to use Devise at all.* We can hope :)
what an awesome find. Thanks for sharing
Look at capybara. It can drive selenium, mechanize, headless webkit, etc.
Just to help me understand, OmniAuth takes care of creating the user model for you and provides with all the controller helper methods to ensure that the user is authenticated correctly and all that jazz?
http://chneukirchen.github.com/rps/ Most project generators ([Jeweler](https://github.com/technicalpickles/jeweler), [Bundler](http://gembundler.com/), [Hoe](https://github.com/seattlerb/hoe), [Ore](https://github.com/ruby-ore/ore)) will generate a similar directory structure.
Ok, I think that this is the point at which you describe in more detail what was wrong with rvm on your system. The only time I had to run rvm reload is when I want a new ruby and I know that I have to update rvm. That's it. So, what exactly were you doing to have to run cd . or rvm reload so much that it got you fatigued?
thanks, lots of good information in this post
I'm not sure if this is the type of answer you are looking for, but in just about every ruby project I really like using bundler to manage my dependencies. I also recommend taking advantage of rake if you notice yourself needing a bunch of tasks. 
I would recommend against using Bundler for libraries that have **less than five** dependencies. Just a `.gemspec` file should suffice.
This also helps (immensely) with running tests! :)
`bundle gem foobar`, and away you go.
It's the next 75% that's going to be fun!
I got about 75% through a project which is now stalled for both business and time reasons. When I started, in July, I agree that the documentation was god-awful and it was far from a professional, usable framework. It still isn't amazing, but the progress over a few months is considerable.
The /rps/ draft seems interesting, but it's not been updated in over a year, and recommends using an API (Config.datadir) that's deprecated and due to be removed. 
Asset pipeline messes up urls inside of your stylesheets (background etc). It also makes it much harder to use firebug. Before you knew which file the problem was now you don't. 
Thanks for that.
I just love that view, showing the projects that have been just updated. Browsing their code can be fun at times. I recently noticed when the MagLev Ruby implementation was about to hit 1.0 by seeing the activity on that list.
Devise doesn't create the user model for you, nor does Omniauth. They do provide the methods for authentication though.
http://version1.api.memegenerator.net/cache/instances/400x/10/10911/11173786.jpg
ya rly
The Ruby Packaging Standard usually doesn't need much updating. I guess someone will need to fork the repository and update the `RbConfig` example. Still, putting static content in `data/` is a good practice to follow.
This is exactly what I thought when I read the title. You have to remember, when you think you're 80% done, you still have 80% left to complete. Those detail get you every time.
The superior pilot uses his superior judgement to avoid exercising his superior ability.
I liked this quote: | Maybe the best programmers aren’t those who spectacularly solve crazy problems, but those who don’t create them, which is much more silent. – Lena Herrmann Another one that comes to mind is: "Simple can be harder than complex. You have to work hard to get your thinking clean to make it simple." - Steve Jobs
Always had this thought figment at the back of my mind. I work at a large Ruby-centric consultancy. Have a few colleagues who a frequent at conferences and have a 'large community following'. Are they the best developers ever? No. I know a few other silent guns who have no community involvement, no blog and don't travel to conferences, who are much more humble and hardworking.
im making the swish from php to ruby thanks to him
Isn't this the pot calling the kettle black? Engine Yard is famous for seeking out and hiring the self-proclaimed "rockstars" of the Ruby community, even if all it has them do is glorified tech support. 
You may wish to look at a project inspired by Hackety Hack, [Kids Ruby](http://kidsruby.com/about). Name aside it's more meant to allow Ruby learning for beginners without too much information overload. For online format, [TryRuby](http://tryruby.org/levels/1/challenges/0) is pretty nice. If Rails might be of interest you can take a look at [Rails For Zombies](http://railsforzombies.org/).
Is Kids Ruby under more active development than Hackety Hack or something? Or more stable?
If you're open to something other than Ruby, I suggest taking a look at [Processing](http://processing.org), which is based on Java. The Processing "language" is basically a set of Java classes that offer a simplified learning environment. There is also a [Ruby interface to Processing](https://github.com/jashkenas/ruby-processing/wiki) available, but I have no personal experience with it, so no comment. 
Hackety hack is very much active. Check out their github if for some reason you think otherwise. The devs are helpful, active, and quick to respond. 
I thought so as well, was just wondering the impetus for the Kids Ruby project.
For years I've been asking myself this same question. When I was growing up I was fortunate to have entered school as they were getting their first Apple IIs or Commodore 64s. The glory of these machines was if you wanted to program, BASIC was at your disposal immediately. Why is this great? Because you could get instant feedback on your code. I feel like we've significantly departed from this in that the solutions people "want" to solve have moved far beyond the realm of what they can get instant feedback on. Is this a good thing? I'm not entirely sure, but I know Hackity Hack and Shoes have been amazing tools when trying to convince people to give programming a try. The same people, however, become quickly upset when their problem set moves beyond the realm of what can be demonstrated quickly. In my first more naive attempts I would suggest BDD. Watching the red-green cycle is, after all, immediate feedback on smaller chunks of larger projects. Suggesting BDD, however, was incredibly shortsighted and stupid as ended up being more off-putting for the extreme novice than helpful. Recently I've found myself wanting to deviate from my script. It isn't the environments we need, but more documentation for a new programmer. The most valuable things I had when I was a budding programmer turned out not to be the Apple II or the instant feedback. We can still have that, and more, with IRB today. What I had, and what we're missing today, are the multitude of hobbyist programmer publications putting out regular articles on the subject of programming. It wasn't the machine or the environment, but the community surrounding both. When I started I could go to the local library and find 10 different publications publishing information on programming the Apple II. I could flip to the back and find published code which I would then diligently type into the computer and watch fail spectacularly due to a typo. Today, the community of programmers has grown up, and our documentation has grown with us. The closest thing we have to the hobby communities of yesteryear are our local users groups. Are there any local users groups running intro days which we could direct newbies to? Are they taking notes on their meetings and publishing their activities? I don't think there are... yet. Maybe there should be. It might go a long way. Maybe you should try and get something going with your local Ruby or Python users group. I'm sure there are plenty of other programmers and parents who would love such an environment. The best instant feedback is that from your peers and mentors. Be an available mentor. As a double bonus, every time you have to lead someone who knows less than you, you end up learning more than you'll realize. End brain dump.
Hackety Hack maintainer here! You're seeing crashes on OSX? I haven't heard of any reports, so that's really unfortunate. Is there any way you can send me a copy of the logs? There should be error messages if you hit apple-/, that brings up the error console. Being the single maintainer of a project that supports 12 operating systems is rough.
Originally, Kids Ruby was supposed to be built with Hackety, but then the guy that runs Kids Ruby decided to just throw it away and re-implement it. He didn't really tell me why.
I will certainly do so next time I get a chance. For now I'll check out the issues on github and see if I have any suggestions. 
As someone who started on an Apple IIE, I have to echo your general sentiments (at least, the ones you started the post with) - it was much easier to go from null to "hello world" in a few minutes with the guidance of a good book.
Thanks for Hackety Hack! It has always worked great for me. I have helped several people pickup ruby/basic programming.
Not sure I grok what you're asking for... but Ruby is already installed on OS X. Why not start grinding on [Learn Ruby the Hard Way](http://ruby.learncodethehardway.org/book/)? It's really not very difficult to type your code in your text editor, save, and run your code in the terminal. I think you can get through a good dozen or 13 lessons before you'll hit a situation where having an older version will cause a problem. Once you get there, you can install a more current version easily enough using [RVM](https://rvm.beginrescueend.com/rvm/install/). Might be fun? 
Got an iPad? Codify (soon to be called Codea) is highly recommended. 8 bucks well spent, I'm a big fan. The language is lua, which if you know perl/ruby/python is a pretty easy pick-up. Lots of examples, and an active community at http://twolivesleft.com/Codea/Talk/discussions - the only big caveats right now is it's really new, so some basic capacity (persistent data, for example) is still "on the way" - and you do most of your editing in the IDE built in, which is on the iPad. It's nicer than you might think - but it's not the same as a computer. (Likewise - I can't comfortably use my macbook in bed, so meh) No iPad? (GET ONE!) - No worries, Try Love2D at http://love2d.org/ - also lua based, and there's a library that lets it run Codify apps. Problem here is no IDE, but vi/textedit/notepad works for me. Nice part is Love2d is totally cross-platform, and making something you can hand out to people is easy. Neither of these lend themselves to web-form-dialog-box type stuff - they're more particles and sprites and such - but there you go. PS. I love ruby too, and hackety-hack (you might look at Shoes if you want to stick with ruby). And I love Perl. The above should not be considered "don't do ruby!", they should be considered "look at this neat thing that's new that you might want to consider". 
Thanks so much! Did you see the new web site we put up last week? I'm at a Ruby conference in Kiev right now, or 1.1 would already be out with more lessons, too...
Great, thanks. It's certainly not perfect, but I can't fix it unless I hear about issues, you know? I develop it mostly on OSX Snow Leopard, and I haven't seen crashes. :/
Orly?xD
single maintainer doesnt seem to be doing much work: git shortlog -ns 224 Fela Winkelmolen 109 Steve Klabnik 108 Dan Bernier 11 Corey Purcell 5 steveklabnik Barely 100 commits since you took over the project 2 years ago...similar thing on shoes i noticed, just sayin'
Yep! Often I spend hours and hours and hours tracking down things, and then don't even get a commit out of it. One great example is Shoes' Windows 1.9.2 support: I've spent _about_ 2 man-months on the problem. Haven't found the solution yet. I also don't mean to disparage other's contributions by referring to myself as a 'single maintainer.' In those two years, I'm the only person who's committed consistently. Everyone else has been revolving door. You're also forgetting the website. And the shoes site. And the associated shoes projects. ;)
Thanks! These are some outside the box suggestions that I'll look into (although I don't have an iPad and probably not planning to get one until the new ones comes out at least.) 
And no code to check existing keys for weakness on load, and refuse to use them? What the hell.
Embarrassing yes, but probably didn't impact anyone using Ruby in production since it only affected trunk since 2011-09-01. I'm curious - When would this be an issue? When would you ever be generating RSA keys in Ruby? 
I agree that this doesn't seem probable, but on the other hand... why would this feature be in Ruby if nobody uses it? (it kinda worries me that such crypto code is in Ruby to begin with. Isn't the purpose of an OpenSSL binding to *not* have to do crypto yourself?)
If you could detect/guess the co-prime exponents it wouldn't be very good encryption, would it? 1 is a valid exponent, but shouldn't be always the the exponent since it massively reduces the brute force guessing space.
It should be relatively easy to imagine a situation where you'd generate a keypair in Ruby: just take any interaction that wants security, and imaging writing it in Ruby! I know this sounds snarky, but the choices are (1) use language bindings or (2) shell out to openssl binaries and attempt to parse results. Why *wouldn't* you generate keys *in* Ruby. Just imagine a web admin UI for setting up an SSL HTTP server. Or config system for setting up a VPN. Or a data interchange system where security and non-repudiation are necessary. A good programmer will want to do all of that in-language with a stable API rather than depending on brittle interactions with command line utilities.
how is it brittle to shell out to openssl?
Fairly brittle (and a lot slower due to forking overhead). Command line utilities are aimed at making it nice for humans working with the tool, not necessarily for programs to read predictable output. It's analogous to choosing to write a HTML screen scraper when a web API is available.
It should NEVER be the exponent. Never ever. Exponent of 1 in RSA basically means that you don't encrypt the data at all, but just leave it as-is.
Thanks for the correction. My understanding of the math is insufficient. Is it possible to detect the exponent from an encrypted package?
You're still not doing crypto yourself (in that you're not implementing RSA in your own code). However, in this case, the binding was using the OpenSSL API so wrongly, you end up without encryption. You pass a valid exponent to RSA key generation and this code effectively drops it on the floor by doing bit-by-bit math on n *bytes* rather than n *bits*. It's still using OpenSSL to do the encryption. This is just badly-botched glue code to the library.
The point about encryption is that it makes your encrypted plaintext look like random data. So - no.
Right, thanks for the clarification.
Cool. I wasn't sure if the exponent might be a part of an envelope or metadata.
In many scenarios it might be. Unless you want plausible deniability, it would not hurt to send it together with your encrypted message - the exponent is part of the public key, which is usually freely available to anyone anyways.
 doc.rewind before you iterate?
Upvote for you! 
in b4 xkcd reference!
Not just local. This is how you can manage more diverse background workers and other stack parts for [Cedar](http://devcenter.heroku.com/articles/cedar) on Heroku.
&gt; why would this feature be in Ruby if nobody uses it? Don't even start down THAT rabbit-hole... any 20 year old language has a lot of cruft.
This is a bit outdated, and will throw lots of deprecation warnings if you're using the latest cucumber. The correct way is: Given /^I am a new, authenticated (user|admin)$/ do |type| email = 'dayman@nightman.net' password = 'password' step %{I have one #{type} with email "#{email}" with password "#{password}"} step %{I go to the new user session page} step %{I fill in "user_email" with "#{email}"} step %{I fill in "user_password" with "#{password}"} step %{I press "Sign in"} step %{I sleep for "2"} end To rip an example out of a codebase I've been working on lately.
I'm not sure why you think devise doesn't generate a model for you? There's a dedicated generator that comes with it: rails generate devise MODEL Taken from https://github.com/plataformatec/devise You probably means that you don't HAVE to create the model, although it's quite convenient to have that power.
We had a crash today while reading the tutorial in (3) Basic Ruby, submitted a [issue](https://github.com/hacketyhack/hacketyhack/issues/135) to github. Don't know if there's any relevant info in there for you.
Thanks! It's a start.
That is exactly what I meant. You can use the generator but don't have to.
&gt; Clever little bits of code just waiting for the unweary teammate to trip over. Un***wary***. Christ's sake, people, he's unWARY, not unTIRED. What the fuck is going on here? I bet Diane is much, much better at attention to detail than this. Otherwise, I agree. (crossposted from the discussion of the same piece over at r/programming)
Criminy. Is Steve Jobs getting credit for *that* now, too?
Thanks for the correction, I've updated my notes accordingly :)
If you're on a Mac, QuickTime Player has support for creating screencasts out of the box. `File -&gt; New Screen Recording`
The PHP hello world example should simply be: &lt;h1&gt;Hello World&lt;/h1&gt;
clojure did something similar for 1.3 - the monolithic clojure-contrib was broken up into a bunch of separate packages.
This feels like it might be a bad decision, at least as far as new users are concerned. Most of those 'getting started with Ruby' tutorials rely on the standard library to demonstrate the flexibility and readability of Ruby's syntax, I doubt people would stick around for long of they had to spend 10 minutes mucking around with terminal commands and installing gems prior to doing any actual coding in these tutorials.
Presumably they would be pre-bundled gems. So, you would still have a standard library, just in gem form. I fully support this. :)
gem poisoning, anyone?
That's great if they are going to use something like bundler. Actually they should look into reviving shoes, crate or something so you can ship your application as one binary.
If they wanted to learn programming or ruby they could use interpreter websites like tryruby. If they wanted to do actual development I think that they ought to learn some terminal commands since there will be many times in the career of a ruby programmer that it will be needed. I'm no terminal whiz either but I feel the learning curve for ruby/rails is just about right for getting the right people in is just nice.
Shoe is still active. What needs reviving about it?
LoL shit I thought you mean "string theory" from physic -_-
Haha, sorry I think I might have been a little too clever with the title. ^_^
Yo I heard you like gems in your gems, so in 2.0 we put a gem in your gem so you can gem!
Return of DLL Hell? 
&gt;The positive difference must be statistically significant. Statistical significance means shit. He should have reported something like effect size instead. In any case it's probably pretty small.
That would be same as Ruby, too...
The real question should be: What do you mean with "faster"? The difference between both String variants is not how fast they're executed, but how fast they're parsed. A double quoted string without interpolation should result in the same VM-code as a single quoted string. Therefore, the only difference is in the time it took the lexer to parse them, and that happens (usually) just once. It looks like double quoted strings are just syntactic sugar. Can someone with deeper knowledge confirm this?
The real question should be: What do you mean with "faster"? The difference between both String variants is not how fast they're executed, but how fast they're parsed. After that, both are of the same Class: String. A double quoted string without interpolation should result in the same VM-code as a single quoted string. Therefore, the only difference is in the time it took the lexer to parse them, and that happens (usually) just once. It looks like double quoted strings are just syntactic sugar. Can someone with deeper knowledge confirm this?
The purpose was to see if there is inherent overhead in using one vs the other without interpolation.
There was a BreakingPoint blog post about this a couple years ago. Still relevant? http://www.breakingpointsystems.com/community/blog/ruby-string-processing-overhead/ 
Good statistics.
And people think Gimp is a poorly chosen name.
I don't think Wayne would call this a poorly chosen name... 
Definitely interesting, good find.
I'm usually happy if they have any documentation at all...
This is an incredibly trivial result. Is a double or single quoted string faster? *It doesn't matter.*
I got that, but to be of any value, you have to state what kind of overhead you're searching for. Your "test case" suggests heavily, that you're only searching for compile-time overhead. For most people, that's irrelevant. Anyway, I believe there is no overhead in running the program and almost no overhead in parsing the source (perhaps some caching effects in the lexer). Maybe a short trip to the source would clarify this.
Shoes is in effect a ruby distribution. What needs to happen it's for shoes to be recognized as such and made generic so that we can use it to ship ruby apps as a standalone executable.
I just visited Bundler's page a couple days to _actually understand it_, that navigation had _exactly_ what I looked for, it made me smile.
Definitely where I'm headed to next. 
Currently using it on two projects, both with heavy customizations. 
Best part is it actually says what it does. Unlike most such docs that say something like: "Version 1.3.1 removes support for frapinatory visual elocution and fixes a bug when building with older versions of readline. OK, but tell us what it does! 
Wayne is awesome. That is all.
Speed of development, perhaps.
Also, the version switching in the top left. *Fantastic.*
I have three SM deployments in production, AMA.
It used to be called bdsm...
It also exports to upstart scripts so you can deploy to linux server.
I'm glad you became a mod ;)
Uh: http://api.rubyonrails.org/classes/Array.html#method-i-to_sentence
Rails stdlib is indeed voluminous.
true that tureus. And thanks vowelboy valuable find!
You'll only need activesupport rather than the whole rails framework for this piece, but it's still a rather large library if this is all you're using.
I was gonna say * a) I suspected Rails did this already, it's so good at 'humanizing' in g * b) I wonder if there's an easy way to base this on I18n config instead of hard-coded to English. Turns out * a) it does and * b) yep, it does use i18n config too. woo! Even if you want to pull this out to be useable without requiring all of active support, you ought to copy the i18n part too, it's not very complicated code with great benefit to flexibility. However, I wonder if the i18n approach can be improved. I wonder if Rails approach is enough for all languages -- mightn't there be languages that are not like english in using the same connector between all words but the first? I have no idea, if so, perhaps look in an 18n key for a completely custom proc implementation if defined. *(I also remain in awe of the Unicode standardizers for managing to analagous surprisingly diversely 'implemented' things working for all languages, like capitalization, sort order, and comparison-normalization. )*
What about Software like Github, Gitorious? Of course SSH key generation is an important feature.
Sad but true. And on RubyForge, there's usually no code either.
Do you know any good introductions/tutorials to it? I've been talking with some coworkers planning to do a cross-platform deployment related project and I thought they should be using SM, but I don't really understand Wayne's doc's and couldn't find any good intros to learning/figuring out how it works...
&gt; It looks like double quoted strings are just syntactic sugar. Can someone with deeper knowledge confirm this? I did some tests comparing string concatenation with #{} interpolation in Ruby 1.8, and found that interpolation was significantly faster. So that suggests that double-quoted strings are not just syntactic sugar. Perhaps someone could repeat the tests for 1.9.3. (I'm a bit busy right now.)
Pity about the name, which just seems thoughtlessly offensive. It's bad enough that I already have Gemfiles containing 'colored' and 'mongoid'.
Maybe I'm missing the point, but why wouldn't you just use HashWithIndifferentAccess ?
You could try some of the online resources like [Learn Ruby the Hard Way](http://ruby.learncodethehardway.org/) or [Rails for Zombies](http://railsforzombies.org/). Having a [good reference book](http://pragprog.com/book/ruby3/programming-ruby-1-9) is also a good idea when tackling any new language. Ruby on Rails is probably a great way to make use of Ruby, though there are other approaches that work. The advantage to Rails is it's very easy to find support on places like [StackOverflow](http://stackoverflow.com/questions/tagged/ruby-on-rails). If you know JavaScript, Ruby isn't going to feel radically different. 
[Ruby Monk](http://rubymonk.com) is another good place to start. You can do their interactive coding exercises for free.
[Ruby Koans](http://rubykoans.com/) is the first thing to come to mind. The zeroth thing to come to mind is to learn how to be a good programmer. Kernighan and Pike's *The Practice of Programming* is an oldie but a goodie.
There are some tests [here](http://blog.purepistos.net/index.php/2008/07/14/benchmarking-ruby-string-interpolation-concatenation-and-appending/) and [here](http://www.breakingpointsystems.com/community/blog/ruby-string-processing-overhead/), both from pre 1.9 times. For 1.9, I did some fast tests and compared the resulting VM code. It appears, as if there is a VM operation that concatenates strings which is used with interpolation. When using single quoted strings and (+) oder (concat), you won't get that function but calls to the respective methods. So, yes, it's not syntactic sugar. String interpolation is optimized on VM level, while concatenation is not (perhaps threading plays a role here).
http://tryruby.org/levels/1/challenges/0
Tranny is short for transmission, as in a car's transmission. A transmission takes input speed and torque and converts it to a different output speed and torque. Whats offensive in that?
The best documentation right now is, ironically, the [rvm deployment best practices page](https://rvm.beginrescueend.com/deployment/best-practices/). It goes through all the details of setting up a server. The docs will get better when it's a bit closer to being stable. It's gone through a lot of changes in its lifetime so far. But I love it.
HashWithIndifferentAccess only allows you to access a symbol key via a string key and vice versa (as well as providing a few other party tricks like stringify_keys and symbolize_keys). It allows no structural or content transformations. Read through the readme and you'll see its not just about changing :foo to "foo".
It's a slur for transgendered people. It's like calling a gem 'homo'
I've never heard that, but then I don't work in a garage! It's commonly used [in this sense](http://www.urbandictionary.com/define.php?term=tranny&amp;defid=1669554).
You should consider making it a mixin rather than making someone inherit from it.
Coming from the web and wanting to use Ruby to leverage more complex sites you will want to look at something like Rails. Rails is complicated but there is also tons of good free documentation. Ruby and Rails can actually be quite different. You have to keep in mind that Rails is a DSL written in Ruby. There are other options out there for creating web content with Ruby however Rails is pretty ubiquitous. I think I disagree with the JavaScript not feeling radically different from Ruby. There are a few similarities but in my opinion JavaScript is a pretty fundamentally ugly language. Ruby is completely the opposite. Both are extremely powerful and flexible though. You should probably also look into a good testing library like RSpec. You might also want to look into Cucumber when you get around to it. I know a lot of people don't like it but I feel it's invaluable especially in the web realm where a lot of people you might work for (say grandma) couldn't understand technical specifications to save their lives. Basically I think it will be a fair amount of work but it will be well worth it.
I feel Rails for Zombies isn't the best intro Ruby resource. It assumes prior knowledge of Ruby. That said, prior knowledge could probably be achieved through the use of Learn Ruby the Hard Way. YMMV, these feelings are just... like... my opinion man. I also don't understand your comparison between JavaScript and Ruby. They're significantly different languages that (at least to me) feel very different. Javascript is a [prototype-based](http://en.wikipedia.org/wiki/Prototype-based) language, and as such developing in it is done in a much different way than in Ruby. You can abstract away much of the differences between Javascript and Ruby's object models through the use of various libraries in Javascript, but that doesn't make the language itself similar. I think a better analogy would be if you're familiar with the concepts present in object oriented programming, then Ruby won't feel radically different from other object oriented languages someone has used in the past. In fact it may even feel more natural. 
I can see this one. It was actually the first thing to come to mind, for me. My dad and I use the same terminology when it comes to our cars...
While I'm familiar with that use, I'm afraid that it's still going to offend people who are unaware of it. Kind of like the English use of 'fag' == cigarette -- it would still be a poor choice of a name for a gem, regardless of the intent. :-P
What I mean versus JavaScript is that the two can end up being very similar with the right libraries, like jQuery, and best practices: // JavaScript $thing.each(function(i) { i.go(); }); # Ruby thing.each { |i| i.go } Obviously there are differences, but if you're familiar with one, the other won't seem so exotic.
Chris Pine's [Learn to Program](http://pine.fm/LearnToProgram/). I don't care how much programming experience you have, that book is the greatest introduction to Ruby that exists.
[The Well Grounded Rubyist](http://www.amazon.com/Well-Grounded-Rubyist-David-Black/dp/1933988657) is a good desktop reference.
I recently started programming with Ruby as my first language, and I also recommend this book!
I think Learn to Program is the best book/website to start with Ruby. I then moved on to [Rails Tutorial](http://ruby.railstutorial.org/ruby-on-rails-tutorial-book), which I think improved my ruby abilities, as well as Rails. I've purchase several books, but I think these two free resources, plus google, ruby-toolbox, and the ruby api docs have been the most help of anything.
&gt; two can end up being very similar with the **right libraries**, True... but we're not comparing libraries, we're comparing languages. The differences become very obvious if you dig one layer deeper and inspect the code that makes jQuery work. Take a look at the additions and changes necessary to make a prototype-based language like JavaScript behave like a Class based OO language like Ruby. I'm not saying it's bad.. it just is. While they can be made to look syntactically similar, I wouldn't feel comfortable making the assertion that "If you know JavaScript, Ruby isn't going to feel radically different". On the contrary, if you know JavaScript Ruby should feel radically different (in a much better way in my opinion). Your statement sounds more similar to "If you're familiar with using jQuery in Javascript then you'll find much of the functionality to be present in the core implementation of Ruby." Edit: You also make the assumption that those familiar with JavaScript will be familiar with jQuery... which isn't always the case.
I love Ruby Koans. If we're going back to other references for ~~general~~ programming and algorithmic knowledge I would also recommend: * Don Knuth's ["Art of Computer Programming"](http://www.amazon.com/Art-Computer-Programming-Volumes-Boxed/dp/0201485419) * Abelson, Sussman and Sussman's ["The Structure and Interpretation of Computer Programs"](http://mitpress.mit.edu/sicp/full-text/book/book.html) (free) * Reading lots of code. Reading other people's code and learning from it is one of the most valuable reference materials around. :) Edit: "general" was the wrong word to use. Thanks [worst](http://www.reddit.com/r/ruby/comments/m7sui/should_i_and_where_to_start_with_ruby/c2yz11e)!
I think you are thinking like someone who's already a programmer. If you're already a programmer, then learning a new language is always easy (well, except if it's got a WAY different model, I admit I still can't learn Erlang. And I vaguely recall my first OO language was challenging). If you're not a programmer yet and all you know is "a little" javascript? For already programmers, I'd simply recommend the pick axe. For someone who just knows a "little javascript", they need something that will teach them _to program_ using ruby as the instructional language. 
I am going through the whole ru y series of books at the moment. So far this book was definitely the biggest help compared to anything else I have tried.
Chalk up another one for koans. DO NOT try and learn Ruby and Rails at the same time. Having an incomplete understanding of Ruby syntax and methodology was the thing that held me back from having Rails "click" for the longest time.
If you want to run with your JavaScript knowledge you could always try [Node](http://nodejs.org/). ([Try it in your browser](http://jsapp.us/)) If you're going with Ruby there are lots of good leads here already.
I used to work there, did some of the verification work for that post :)
+1 for Ruby Koans. I also recommend [Eloquent Ruby](http://www.amazon.com/gp/product/0321584104) to anyone starting out in Ruby and/or Rails.
Ruby is a magnificently beautiful programming language. Rails is a very, very nice (though a little tubby) web-app framework. Definitely take the time to explore it. 
I'm surprised no one mentioned why's poignant guide? [Why's Poignant Guide](http://mislav.uniqpath.com/poignant-guide/) You'll be using the term 'chunky bacon' more regularly after this... 
I ran across http://tryruby.org/ the other day, too.
Great read. Some of my co workers with a C# / .NET background are having a hard time figuring out ruby and rails. This will help them out tons
Everyone led you right. I don't have much to add since there are some amazing suggestions here. I would just encourage you to also check out some of the power tools the community likes via [git](http://git-scm.com/), [github](http://github.com/) and [heroku](http://www.heroku.com/).
I bought the pickaxe. That said, the Ruby Koans are amazing. I've gotten out of the habit, but I used to try and solve one a day (though I usually did like five). It helped me learn vim too!
Quick! Someone take ['Homo' honey](http://www.casite.com/index.php?option=com_content&amp;task=view&amp;id=24&amp;Itemid=58) off the shelves because someone is offended!
for long-polling, you need to wait on the server side. That's the key. There is an article I wrote a while ago : [Twootr goes Comet](http://yoan.dosimple.ch/blog/2008/02/28/) Mostly, if $chat.empty? -&gt; wait a bit and look at it later. I don't think WEBrick is the best suited server for that, you should give a look at EventMachine: https://github.com/novelys/node_chat
As someone has already suggested _why's guide, let me then suggest [Railscasts](http://railscasts.com). Ryan Bates has a fantastic style of coding. It's amazing how easy he makes it look.
It's also slang for transmission. 
Not to piss on your advice, but AoCP is not even close to a reference for general programming knowledge. It's an incredibly advanced set of texts and will probably scare the shit out of anyone that is first trying to get into programming...
It may not be the best for a brand new programmer, but once you get the basics down, [Practicing Ruby](http://practicingruby.com/) is well worth subscribing to. [Here's an article from a few weeks ago.](http://practicingruby.com/articles/shared/hmnhpjilxnah)
It's about context.
You might want to look at [Juggernaut 2](https://github.com/maccman/juggernaut). It uses node.js to run the push server, and redis to queue the push messages. You really don't need to know anything about node.js or redis, though, other than how to install them. The great thing about Juggernaut is it's easy and it's fast. It will use websockets if available, or degrade down through flash sockets, long-polling, etc.
Both are great but wayyyy out of scope for a newbie. For a newbie, Petzold's CODE is a far more useful book.
Lol, you're not pissing on anything since it's a completely valid point. That said, I was responding to a comment which referenced "The Practice of Programming" which is a book designed to help existing programmers learn from the experience of other programmers with examples in many languages... as such I thought this comment thread had moved beyond simple intro texts. Finally while AoCP is wordy, I don't think it's as inaccessible as you make it seem. Some people are put off by the examples in assembly... but if you can get past that it has a wealth of knowledge that would be great for any beginning programmer trying to expand his or her base knowledge. It will require personal study and expansion in order to be useful. That's what makes it a textbook and not a reference. In the end it depends how "beginner" the beginner really is [Dunning-Kruger effect](http://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect) and all. Is the beginner a new Ruby developer with existing computer programming experience who would read "The Practice of Programming"? Or is this a guy who's never done more than use jQuery to access elements on a web page (such as the OP).
You're absolutely right. Completely out of scope for a newbie... but I was responding to a comment which referenced "The Practice of Programming" which is also out of scope for a newbie. It wasn't intended to be advice for the OP but a response to a comment thread.
Strange, I always thought that Bundler’s homepage had poor content, was unnavigatable, and couldn’t for the life of it convince me what Bundler was for or why I should use it. I still don’t.
Amazing. And not in a good way. This is the same kind of unnecessary complexity that you get from RVM.
While I agree that AoCP is a crazy wealth of knowledge, I just cracked open my copy of volume 1... Knuth starts talking about induction on page 11. That's some pretty heavy stuff for someone without any academic training in comp sci to see on page 11. On the other hand, if one is able to read and understand even 50% of what's in the AoCP there will be very few problems they can't figure out a solution to.
yeah, that would work really well. Unfortunately, the constraints of the assignment prevent me from using anything outside of ruby core, so Juggernaut is off the table.
Yeah, that would also work. Unfortunately the assignment's constraints prevent me from using any gems, so I have to go with straight ruby. I decided to try an empty while loop that looks like this &gt; while $chat.empty? end so that it won't proceed to responding until something is put into the $chat array. Now I have other problems to worry about, but this seems to solve the biggest one I had.
There's a fundamental problem with what you're trying to do. WEBrick is a synchronous web server meaning it processes its requests one after the other. If you want to long poll... that means you're going to have to force WEBrick to freeze and not respond to other requests while waiting to fulfill the poll. How is $chat getting set? Who is setting it? If its a HTTP POST to a different URL you're screwed b/c you can't process that post while blocking the server with the long poll. I suppose it COULD work if the messages were coming in from another thread connected to a database or a message bus. In that case you don't want "if !$chat.empty?"... what you want is "sleep_until_chat_is_not_empty" then respond with the message. Anyway... the normal way to do this would be to use an evented web server like thin. This allows you to process thousands and thousands of long polls at once without one blocking the other. Sinatra has a streaming feature that handles all the event deferrable stuff for you and the end result is pretty simple. Here's some sample code that does what you're trying to do https://gist.github.com/b55c77ec0ca8b98a6685 
Oh this is a class assignment? Ok... Then just use Queue. Queue.pop will block until something is pushed into it. $chat = Queue.new ... resp.body = $chat.pop This all assumes somewhere else there's another Thread doing a $chat.push(message) 
unfortunately due to the parameters of the assignment, I cannot use Sinatri, Rails, or any gems and must only use things that are available from ruby's core items. It looks like thin is a rails gem, so I don't believe I would be allowed to use it. Is there anything similar to it that doesn't use "outside" code?
Yeah I don't have my book on me at the moment. I guess my opinion is colored by my schooling, background, and fuzzy memories of going through the book for the first few times. I cede my opinion to yours sir. :) Thanks for the input!
yeah, Queue seems like it'd be a good fit. Now to figure out how to enable the multi-threaded bit that it would need. At the moment, I have only two methods: the one above, and a similar one that takes post data and fills the chat queue. Here's it(simplified again) &gt; class Push &lt; WEBrick::HTTPServlet::AbstractServlet def do_POST(req, resp) $message = req.body $chat.push($message) end end My only real concern now is making it into a separate thread. Would I add the "something = Thread.new" bit before the definition for do_POST/GET and then at the bottom of the method add in the "something.join"?
Yeah... see we're getting back to the same problem... WEBRick is a synchronous system. You cannot process a POST while a GET is waiting. If this was just NORMAL polling ... where it immediately responds with "no messages for you, try again later" rather than waiting for one to come... you'd be fine. The only thing I can think of to make this work would be to have two WEBRicks listening on different ports in different threads $chat = Queue.new poll = Thread.new { WEBrick::HTTPServer.new :Port =&gt; 4001 ... } push = Thread.new { WEBRick::HTTPServer.new :Port =&gt; 4002 ... } poll.join; push.join Are you sure the class is asking you to do LONG polling and not normal polling? Long polling is a pretty advanced topic in Ruby given its synchronous nature. 
Looking more closely at your initial question.... here's the deal. In the case where the queue is empty webrick HAS to do something. It can't just NOT reply. It's choices are * hold open the TCP connection until data is available causing the client to wait... this is called **long polling**. This is hard to do in a synchronous environment but simple to do in an async environment (event-machine, thin, twisted, node.js) * return an error code of some kind... a status = 404 makes sense. This way the client can choose to try again in a few seconds. This is call **polling**. * sever the TCP connection without responding - this is simply **bad form**, breaks the protocol and is not what you'd ever want to do. I suspect what the teacher wants you to do is if message = $chat.shift resp.status = 200 resp.body = message else resp.status = 404 end
well, the actual assignment is to make a basic chat program that supports multiple users without using rails. He keeps using the phrase "long polling", but also let us know that he won't really care about our code as long as it works. I'm going to attempt the Threaded approach you put up above for the moment. It seems to be a logical way around doing it. If it doesn't, I'm considering saying to hell with the no rails requirement and just using thin instead.
Your teacher is high. I don't never know where to start. Good luck. Also make sure you figure out how to get a message sent to ALL members of the chat room not just the one who asked most recently. That'll mess you up. ;-)
So there are choices other than rails and webrick. (in fact, those are two different axes, one can deploy a Rails app with webrick if you want). EventMachine is not rails. you don't need rails, but you need SOMETHING that will allow concurrent request handling, so while one thread is blocking on the request waiting a while to return the response, another thread can still make a request in the interim. In fact, Rails probably _isn't_ the best choice for this, because Rails by default does _not_ allow concurrent request handling, and acts kind of weird when you ask it to (with config.threadsafe!). Sinatra would work, sinatra by default has concurrent request handling. EventMachine would be the 'right' most performant way to do this, but Sinatra will probably work. Heck, even just writing a cgi-bin application might work, although it would be a terrible choice for a real world app. It's just WebBrick that probably won't work. 
can you use apache? How about a simple cgi-bin application? Oh, but wait, you can't use a database or external store either? I am not sure what your teacher is expecting, perhaps he doesn't mean what you (and everyone else) thinks he means by 'long poll'. 
or, give up on the 'long polling'. Just have javascript in the client poll (ordinary poll) every 3 seconds or so to see if there are any new messages?
yeah, that would definitely work out. I'll give it a try.
no apache, all servers must be written by hand. Most assignments have been fairly easy(restAPI, basic server, and a few others), but this one has been giving me quite the headache. Luckily he's more of one of those "An attempt means you are at least thinking, which is worth a good grade" type teachers
Can't wait to use the next gem called faggot! 
I know, lifofifo prefers to type 'rbenv rehash' all the time, definitively shorter the 'cd .' ... and btw. in latest rvm reload is done automatically ;)
so what if people are offended? 
That book is a real treasure, and was one of my first experiences with Ruby. Thx for the link.
that's nice. rest-open-uri almost does this properly but there are still some issues (which is why there is also a rest-openuri-postpatch)
Hey, remember RJS, that terrible idea that Rails eventually removed? Well now it's back! Uh. Yay.
From what I understand, it uses the accessor, being the equivalent to *self.price*.
http://www.rubyist.net/~slagell/ruby/accessors.html the 'price' in price_in_cents is invoking the accessor method to retrieve the @price instance variable. Edit: instance variable, not "instance method". typing without thinking.
`:price`, `@price`, and `price` are all pointing at the same thing, when used in the appropriate places in the example. edit: oops, the `price` in `def initialize(isbn, price)` and in `@price = Float(price)` is technically a different variable (did not see it at first glance). You could change `price` in those two spots to `the_price` and everything would still work and make it a little obvious that it is different from the `price` in `Integer(price*100 + 0.5)`. edit2: oops, I realize I think I wasn't quite getting what you were asking. the `price` in the `price_in_cents` does go through the `attr_accessor` in order to retrieve the price. If you removed the `attr_accessor` from that class, then the `price_in_cents` method would return an error. You could however fix the `price_in_cents` method by changing it to `Integer(@price*100 + 0.5)` in order for it to access the instance variable directly. I don't remember if the pickaxe pointed this out, but `attr_accessor :price` is just a shorthand way of writing: def price @price end def price=(number) @price = number end
Also consider: def price_in_cents=(cents) self.price = cents/100.0 end Now you can treat BookInStock as if it has a price_in_cents attribute that is automatically consistent with the price attribute. This is fine for an example, but it would make much more sense to have the real attribute be price_in_cents, as an integer (or 100ths of cents if you need greater precision) than to store a float price. Avoid the temptation to use floats for anything that has a decimal place. They should only be used if you want an approximation of a real number in a fixed size.
an attribute is a property of an object, not a method. it is a piece of data that is part of the object's state. so, for a `BookInStock` object, its attributes will be the isbn and the price. now the attributes are part of the object's *internal* state, and cannot be accessed by other code. to do that, you need *accessors*, which are methods that expose ways for external code to read and modify the attributes. what `attr_accessor :price` does is autogenerate the following two methods: class BookInStock def price @price end def price=(new_price) @price = new_price end end (`attr_reader` and `attr_writer` just generate one of the methods apiece, `attr_accessor` generates them both) how that works is: code *within* `BookInStock` can read and write `@price`, since they are part of the same class. external code cannot access `@price`, since it is an attribute - but it *can* call the *methods* `price` and `price=`. so you can say book = BookInStock.new book.price = 10 puts book.price ruby provides a little bit of syntactic sugar by letting you leave off the parens after `book.price` and rewriting `book.price = 10` to `book.price=(10)`, so that it looks like you're reading and assigning to an attribute, but you're really just calling the corresponding methods. so now what about `price_in_cents`? well, picture the following scenario: you have yet another attribute, `@price_in_cents`, and you provide an `attr_reader` for it. you also write code so that whenever someone writes to `@price`, you multiply that by 100 and update `@price_in_cents` as well, to make sure the two keep in sync. but what if you don't add an actual attribute, but just provide a *method* `price_in_cents` that does a just-in-time multiplication of `@price * 100` whenever you call it, and returns the value? note that from the point of view of external code, there's *no difference*. all it can see is a method, `price_in_cents` - whether that method is providing an accessor to an attribute, or just doing a calculation and returning the value, is an invisible detail. that is what a virtual attribute is - a method, or pair of methods, that behave as though they're reading/setting the value of an attribute, but are actually just running some code that is not backed by a specific attribute. here's another example that might make things clearer: class TemperatureSensor attr_accessor :degrees_c def initialize(temp) @degrees_c = temp end def degrees_f @degrees_c * 1.8 + 32 end def degrees_f=(temp) @degrees_c = (temp - 32) / 1.8 end end a = TemperatureSensor.new(100) a.degrees_c # =&gt; 100 a.degrees_f # =&gt; 212 a.degrees_f = 32 a.degrees_c # =&gt; 0 so degrees_f is a virtual attribute here, but reading and writing to it are identical to reading and writing to degrees_c. in fact, if you changed the code so that there was a `@degrees_f` attribute and a pair of `degrees_c` and `degrees_c=` methods, you would not be able to tell the difference. 
Thanks, it's making a lot more sense now..especially with your Intenger(@price*100 + 0.5) example. so the @price is really just the attr_accessor :price in this case.
Never heard the terminology "virtual attribute" before, did you just invent it? :P
Yep :P I'm that good! Haha no I just encountered it while reading Programming Ruby 1.9
yeah it's not really a term that's used much (read: at all) by ruby developers, at least in my experience.
You can't really see the presenters as they are shot from really far away. 
Thought I should put this here... IMO, `@price = price.to_f` and `(price * 100 + 0.5).to_i` read much better. It's rare to see people convert like `Integer(f)` etc
I agree, I like `.to_i` and `.to_f` better.
But not enough for an upvote? :)
You were down voted, so nobody is going to see this anyway, but here goes: Avoiding offense is not the point. Nobody cares if you are offended. But creating an environment (in the workplace or elsewhere) in which transgender people (or women, or homosexuals, or jews, or blacks) would not feel welcome, that *is* a problem. Marginalization is the term, and it's the feeling of never being part of a team, or never being able to trust people around you, because everyone sees you as a joking matter or a stranger.
one subtlety is when parsing ints out of string values: $ irb ruby-1.9.3-p0 :001 &gt; "10".to_i =&gt; 10 ruby-1.9.3-p0 :002 &gt; "10.6".to_i =&gt; 10 ruby-1.9.3-p0 :003 &gt; "hello".to_i =&gt; 0 ruby-1.9.3-p0 :004 &gt; Integer("10") =&gt; 10 ruby-1.9.3-p0 :005 &gt; Integer("10.6") ArgumentError: invalid value for Integer(): "10.6" from (irb):5:in `Integer' from (irb):5 from /home/martin/.rvm/rubies/ruby-1.9.3-p0/bin/irb:16:in `&lt;main&gt;' ruby-1.9.3-p0 :006 &gt; Integer("hello") ArgumentError: invalid value for Integer(): "hello" from (irb):6:in `Integer' from (irb):6 from /home/martin/.rvm/rubies/ruby-1.9.3-p0/bin/irb:16:in `&lt;main&gt;' 
I did upvote?
Thank you so much for the detailed explanation. It's all coming together now.
There's no live render of the game board in his version. anyone got that stitched up?
Why would you ever want to do that?
You mean like [mod_ruby](http://modruby.net/en/index.rbx/mod_ruby/whatis.html)?
I suppose it could be useful for tiny projects with just a couple of pages, but even then, I'd much rather go with Sinatra.
Yep: ruby-1.9.2-p290 :001 &gt; def rog?(p) ruby-1.9.2-p290 :002?&gt; puts p ruby-1.9.2-p290 :003?&gt; end =&gt; nil ruby-1.9.2-p290 :004 &gt; rog?("a") a =&gt; nil ruby-1.9.2-p290 :005 &gt; 
Yep, you can define methods anywhere, a class or module is just a way to organize them.
I'm confused... so, you're saying that something like this doesn't work for you? def foo?(i) puts i end foo?('bar') # =&gt; 'bar' The same can be done for bang (!) methods, as well. I think you just put your argument list in the wrong place in your definition. def foo?(a,b,c), def foo!(a,b,c). 
I'm just fascinated someone would assume, that you should put the question mark after the parameters.
Well, then you've got Passenger :)
You put the question mark before the parameters, not after. def integer?(num) Same goes for exclamation points. def hardcore!(man)
still recommending jeweler in nov 2011? Please, no, just don't do it. http://yehudakatz.com/2010/04/02/using-gemspecs-as-intended/ Even if you don't use bundler otherwise, bundler's "rake release" task does a _fine_ and much lighter weight job of automating gem release. I use it myself. I kind of wish someone would split out those gem-development-management rake tasks to a seperate gem (they really don't rely on bundler at all), and that they'd catch on instead of jeweler. But heck, this article even recommends bundler anyway, just use bundler rake release! Gemspecs are already executable ruby code, there's no reason to instead write something other than a gemspec and use it to dynamically generate a gemspec, absolutely none. And it can lead to headaches, as well as make things more confusing to developers, as explained by wycats. 
I'm not trying to troll here, but coming from a php 'background', I don't really see what's wrong with this. Isn't apache just a server like webrick/thin/whatever?
Uh, yes, which is probably why the article talks about mod_ruby.
thanks!
Thank you all, now I know
There's no such thing as methods "not in a class." Methods defined outside of any class definition are actually defined to be instance methods of the main object (an invisible instance of Object). Further, Ruby also makes such methods private instance methods of the Object class itself so these methods are available from everything that inherits from object (which is to say just about everything). I find this unintuitive and possibly program-breaking behavior, so I generally don't use it except in short scripts. It pollutes every single object in your entire program, even objects from libraries. And of course you can define methods with a question mark and parameters at the same time. The question mark isn't anything special, it's simply one of the allowed characters in a method identifier (as long as it's the last character, same with !). So, you mean to do **def something?(arg1, arg2)**. You do see question mark methods with parameters occasionally. Things like **Object::is_a?(klass)** and **Object::respond_to?(message)**. But anything more than a simple query ("are you empty?" or "are you a banana?") is not idiomatic Ruby. There's no actual restrictions on these methods (it's just a naming *convention*), but they're generally used only for simple query methods that ask a simple question and return true or false. Certainly nothing with side effects or large parameters lists.
I'm just fascinated that you're such a dick.
You'll get pretty bad performance, starting up the ruby interpreter each time. But it can certainly be done. 
Absolutely agree. Specifying configuration elsewhere, and generating the gemspec configuration *from* that is mind bogglingly backwards. Highly recommend using bundler, or if you're not a fan of it, just write your own gemspec anyway, it's really not hard
I don't know what "Event this show pattern to avoid" means (typo?), which is confusing me as to your question. But yes, I think this is probably a "worst practice" precisely because it's so difficult to figure out what's going on. What is declared in the body of the Hello class? Well, that depends on what this mysterious class-level format method is doing. What's it doing? Oh boy. Okay, let's look at: format :text do def render "Hello World" end end The #format method will create a new anonymous class, which extends FattyRBP::Format , and whose class definition includes the body of the block passed to #format -- which is the definition of the render method. Then it will take that anonymous class, and store it in a class-level 'formats' hash, under the key :text. Why would you want to do that? Well, when you call: Hello.render(:text) oh boy. Hello is a sub-class of FattyRBP::Formatter , so it has a #render method it inherits from there. What does that render method do? It looks up what's in the class-level formats hash under key :text. You know, that anonymous class we discussed above. And it instantiates one of those. And it calls the #render method on that instantiated object. And that object has a render method -- cause remember, that #format class-level method created the anonymous class with the body passed in as a block to #format -- that is, a body consisting of the definition of one method, "render". Defining it to return "hello world". I have no idea why anyone would want to do this. Perhaps they were just direct translating something from another language, although I don't know what language that is where something like this would make sense. A functional language maybe? 
thx for input, regarding the actual context of my question, see "Edit" ... that makes me conclude that the educational value of showing such cryptic ruby anti-pattern in a ruby best-practices book is yet to be confirmed :-)
Even totally unrelated to the fact that there are class-level variables involved, that's just a really weird way to do things. At the very least, if you're setting up a DSL like that, why would you require every single block argument to #format to include a "def render..."? That's just weird boilerplate at that point. You could implement much the same system that worked exactly the same way, but put the actual definition of a method called "render" _inside_ the #format definition, so the actual use of the DSL could just look like: format :text do "Hello World!" end Now, it'd STILL be weird code, but at least it'd be a better DSL! Changing it to support that would be an interesting excersize in learning ruby meta-programming type techniques, at least. But yeah, if you want to illustrate how class variables are dangerous (as they are essentially global variables with a bit of namespacing) ... that's an odd example, since it's got some confusing meta-programming that's got nothing to do with class variables. 
yeah, using bundler you actually DO write your own gemspec. (well, maybe bundler has some task to generate a stub one once for you first starting out, not sure). The bundler 'rake release' task simply conveniently, in one step: 1. Builds the gem itself from the gemspec that you probably wrote yourself. 2. tags it with the version number in your git, and pushes the tag to upstream git. (And complains if you're trying to release a copy with uncommitted changes). 3. Releases the gem to rubygems.org. None are very hard things to do, but somewhat convenient to do them all in one line, and not have to remember how to do them all individually. But no magic in it, you could have done all those things yourself, using 'gem' command line and 'git' command line. But even using the bundler 'rake release' task, you generally write your own gemspec. 
&gt; You'll get pretty bad performance There is a link at the bottom of the article to one person's experience with using cgi to run php scripts. That person basically concludes that performance is actually better at low loads but drops quickly when compared to mod_php under load. So yeah, use this only for very-simple, low-traffic pages.
But on top of that, I would strongly suspect that the PHP interpreter loads a lot quicker than the ruby interpreter to begin with, since PHP was designed from the start for this kind of use. So someone's experience using cgi to run php scripts may or may not translate to ruby.... with ruby it'll probably be even worse. 
That makes sense I suppose. Doesn't the same apply to PHP though?
Well maybe I did come off as a dick. Thanks for pointing that out. But it is surprising to me someone would assume a different treatment for symbols ending in a specific set of characters. 
see below. probably, which is why everyone uses mod_php, but I suspect (just a guess) ruby interpreter is even slower to load than php interpreter. 
No. What you're doing is confusing loading the Ruby interpreter (which is a simple matter of exec'ing a binary and loading up the shared libraries it uses, most of which will be resident in RAM anyway), and loading up Rails. Rails takes a long time to load because it's a LOT of Ruby, and there are lots of things to load. Ruby by itself loads up very quickly, and erubis is only one library which also loads very quickly. So using Ruby like this will work just as well as any other CGI script. I actually ran my personal web page exactly like that for many years, at least in part because Rails hadn't been written yet, but Ruby was already a better language for that sort of thing than Perl.
you're right, I'm wrong. Using some very braindead benchmarking on my workstation, ruby interpreter even seems to load FASTER than php, comparing ruby -e "puts 'foo'" to php -r "echo 'foo\n';" have no idea if that's a legit comparison, but ballpark. 
I know naming your gems is fun and totally the author's call, and I don't even care, but some are just hilarious. More honorable mentions for failure: * [CobraVsMongoose](http://cobravsmongoose.rubyforge.org/) - XML parsing I guess? * [Unicorn](http://rubygems.org/gems/unicorn) - Rack web server * [Rainbows](http://rubygems.org/gems/rainbows) - Slow client rack server * [Pony](https://github.com/benprew/pony) * [Raindrops](http://rubygems.org/gems/raindrops) * [Thor](http://rubygems.org/gems/thor) * Any gem that includes 'ruby' in the name. We know it's ruby. (I thought _ext was the convention for pure vs extension gems) 
&gt; Are you a white guy from Memphis who loves Asian culture? Use the Japanese name of the nearest household appliance. One interesting one is making a Japanese version of your name or an English word. Like maruku (the *mark*down to html converter). Edit: I am not saying this is poorly chosen. I liked maruku. OTOH, I do have issues with names that are very commonplace. Becomes difficult to do google searches. Jeweler was one such name. Adding ruby to jeweler hardly helps.
I've been using jeweler for a year or two. Works fine -- the one grief is that it uses a VERSION file rather than allowing us to point to a version.rb file in our lib dir which we could do if we hand-write the gemspec.
I understand this part, but wonder if everyone else follows it to the letter: &gt; You can make feature changes and bug fixes in Major versions. You can make backwards compatible feature changes and bug fixes in Minor versions. You can only make backwards compatible bug fixes in Patch versions. Bumping major versions for features means the version number would go up very fast. I thus land up having major features in minor versions, minor features in patch versions, and often even backward incompatible stuff in a minor versions. Any suggestions would be welcome. I really need to sort this out without having major numbers going through the roof.
Haha, I knew "trollop" would end up in there. I also wrote a gem called "tween" for "betweening" (often called "tweening") and got some strange reactions.
Remember when switchtower was sued and had to change their name to Capistrano?
not a gem but this would top the list if it was [BDSM](https://bdsm.beginrescueend.com/)
It was actually the spark of inspiration for the post, then I learned about [tranny](https://github.com/joshkrueger/tranny) and it was all downhill from there.
Another classic, Shemail [commit of the rename](https://github.com/purify/mail_style/commit/cd25d3c3e1b2c81fa2b1381daf02bfb3bafbe2be)
I love how people are bitching about a name that wasn't even intended to be offensive, when RVM get head exists and has been mentioned a few times as 'colorful'.
&gt;Avoiding offense is not the point. Nobody cares if you are offended. But creating an environment (in the workplace or elsewhere) in which transgender people (or women, or homosexuals, or jews, or blacks) would not feel welcome, that is a problem. And you think the fact that a gem called tranny exists is going to create a hostile workplace? Are you fucking kidding me? 
The [sex_it_up](https://github.com/aantix/sex_it_up) gem sounds quite useful, I might give it a go on my next project.
I don't know how the [app](http://rubygems.org/gems/app) gem didn't make the list. It's a great little configuration gem but try searching for that somewhere other than rubygems.
Okay, the Girlfriend gem is really, really weird.
nokogiri, inappropriate, seriously? The main reason why gem names like lolita and tranny are inappropriate is that they're very hard to google out.
No, and that's not the context in which I wrote my response — the context was that you expressed your frustration with the concept of "offense". But aside from that: The *existence* of the gem hardly does anything. Its usage in a work environment is a different matter — "tranny" is considered one of the most hurtful slurs by the transgender community, and they would generally perceive it the same way as a black person would perceive a hypothetical Ruby gem called "nigger". If such a gem existed, surely people would not find that acceptable, for fear of their coworkers feeling less appreciated. If you have further questions, I'm sure [r/asktransgender](http://www.reddit.com/r/asktransgender) is more than willing to help you out.
What about whiskey_disk?
Ha. I wrote CobraVsMongoose: it implements an XML ↔ hash translation convention called BadgerFish which was a daft enough name to start with. It **is** a stupid name, though.
Yeah, we decided to do the streaming at the last minute, and we couldn't find suitable hardware. In fact, a few talks don't have audio :( But hey, it's better than nothing, right? :)
I feel like "hoe" is a perfectly fine name for the gem. It's a "rake" helper. Makes perfect sense to me.
&gt; 10(+) awesome gem names
I don't think nokogiri's that bad. When I google "nokogiri" the first page is only get results related to the gem. The name alone doesn't tell you what it does but since its unique its easy to google and its common enough. Hoe goes with rake so that makes sense too. I'm surprised the "poorly chosen" list doesn't include [Sphincter](http://rubygems.org/gems/Sphincter) although it works with sphinx and I've been told the body has many sphincters. 
This might be the stupidest Ruby-related thing I've ever seen. The names are humorous, and I'm sure chosen entirely on purpose. You really think the guy who named his gem "Tranny" didn't know *exactly* what he was doing?
He claims he didn't. Transmission slang, not bigotry.
Though that one is a animation term.
It's used in animation, yes. All it really is is transitioning between two values over time using various forms of interpolation. Animators will use tweening to transition the position or rotation or scale of something over time to simulate fluid movement. Without tweening, animations are jerky and locked to the keyframes the animator outlined. With tweening (and specifically, with tweening using an interpolation method other than linear), the animations are much more fluid and not locked to any frame rate.
I never claimed to have the most erudite sense of humour, but I think "shemail" is hilarious. It's descriptive, memorable, and it's funny. What's wrong with that?
One of my favorite gems is also my least-favorite named gem: **backup**. Very difficult to Google for information specific to the gem.
I like Thor, but it definitely could have been named after a god more related to command-line programs.
Nokogiri is the only one of those names that I will remember what it does at the end of the day. I wonder if Japanese people have the opposite problem?
Then there are people who name software after musicians. Ruby has *Sinatra* and python has *Satchmo* :). My first program 21 years back was called "pig", Program for Invoice Generation, but everyone said it was a dig at our boss! I was following in the tradition of sed/awk/grep etal.
At least its more imaginative that "main" which is also a great program.
&gt;Its usage in a work environment is a different matter — "tranny" is considered one of the most hurtful slurs by the transgender community, and they would generally perceive it the same way as a black person would perceive a hypothetical Ruby gem called "nigger". So again... You think if somebody used the gem tranny that would be creating a hostile workplace. That's your position right? 
&gt; You think if somebody used the gem tranny that would be creating a hostile workplace. Yes, of course. It's not really up to you or me to decide what hurts other people.
&gt;Yes, of course. It's not really up to you or me to decide what hurts other people. You are insane. More than that you are dangerous to society. Your desire to limit the expression of others and to make sure all conversations between adults take place at the level of the most banal, vanilla, inoffensive matter possible must be fought.
What the fuck? Do you think it's "insane" to require that adults behave courteously around me and each other? Wherein did I express a desire to limit the expression of others? It's *your* decision to hurt and alienate your coworkers, now that you know how your language makes them feel. It appears I gave you that freedom — you can thank me later. Your freedom to hurt people is not an obligation, though, so feel free to cut out the antisocial behavior and be nice to those around you. Who knows, it might turn out to benefit you in the end.
&gt;What the fuck? Do you think it's "insane" to require that adults behave courteously around me and each other? It's insane that you would take offense at the word tranny. &gt;It's your decision to hurt and alienate your coworkers, now that you know how your language makes them feel. It appears I gave you that freedom — you can thank me later. My co workers are adults. They don't cower in the corner every time they hear the word tranny. &gt;Your freedom to hurt people is not an obligation, though, so feel free to cut out the antisocial behavior and be nice to those around you. Who knows, it might turn out to benefit you in the end. People like you must be stopped. You are so fragile, so delicate, so easily offended and you demand that all those around you walk on eggshells lest they utter a word that will make you gasp and drop your monocle. FUCK YOU. Hey is that offensive enough for you cunt? I'll leave you this. Watch out it may offend your delicate sensibilities. http://www.youtube.com/watch?v=cycXuYzmzNg 
&gt; It's insane that you would take offense at the word tranny. I don't, and you're not reading what I spent all this time typing out for you. I couldn't care less about the word "tranny", but guess what, it turns out most transgender people don't feel the same way. &gt; My co workers are adults. They don't cower in the corner every time they hear the word tranny. How do you think they would react if you called every black coworker of yours "nigger"? I was about to respond to the rest of your post, but it turns out you are an obvious troll. Go away.
People using RVM really should look into rbenv; it does things the correct (UNIX) way.
My first Ruby work was a project I took over. Imagine my shock when I saw gem 'chronic' and gem 'crack' next to each other in the Gemfile. They make sense when you know what they do but our corporate naughty word sensors go haywire when you IM or e-mail about them.
They actually have a json endpoint for the iPhone page: http://www.urbandictionary.com/iphone/search/define?term=reddit
Well, I just looked at rbenv... &gt; The problem is that rvm actually overrides the gem command with a shell function! This does not appear to be the case. $ which gem /home/meta/.rvm/rubies/ruby-1.9.3-rc1/bin/gem It doesn't seem to have created any aliases either. Nor does it override cd as claimed. I'm no big fan of rvm, but false claims don't encourage me to check out rbenv.
Good work anyway, OP!
Congrats, but the name is absolutely terrible. :(
It may have changed since that was written; on a vm with RVM installed I get the following: 22:37:14$ rvm --version rvm 1.8.6 by Wayne E. Seguin (wayneeseguin@gmail.com) [https://rvm.beginrescueend.com/] 22:37:33$ ruby --version ruby 1.9.3dev (2011-09-23 revision 33323) [x86_64-linux] 22:37:38$ which gem gem () { local result command gem "$@" result="$?" hash -r return $result } 
Every time I see someone claiming "xyz is the Unix way" I think "*facepalm*". RVM uses Unix technologies and is by definition doing things the Unix way. What *is* the Unix way anyway? /proc is not Unix, it's Plan 9. Epoll and kqueue are not Unix, they're Linux and BSD extensions. Bash is not Unix, it's GNU. Why is this ill-defined "the Unix way" better? So RVM installs a hook for the 'cd' command - so what?
Well, when I say 'the Unix way' I am referring more to the philosophy; it could be argued that RVM breaks Eric S Raymond's [rules of simplicity, modularity, robustness, transparency and least surprise](http://en.wikipedia.org/wiki/Unix_philosophy). Each to their own, though.
But it transforms hashes. I myself call transmissions trannies, but that's not what occurred to me in that case, honestly.
I'm not judging you about it, just mentioning to tsigo that you didn't know.
***@DuckThatTweet*** *Twitter Profile:* &gt;***Mallard J Duck*** &gt;*No url set in profile.* &gt; &gt;User since: *2011/11/14* &gt; &gt;Location: *a lake in the woods with wifi* &gt; &gt;*Quack Quack* &gt; &gt;Friends: **0** Followers: **2** Listed: **0** Tweets: **24** *Last tweet/conversation (at time of this comment):* ***DuckThatTweet***: &gt;&amp;#91;2011/11/17&amp;#93;&amp;#91;04:40:34&amp;#93; &gt;[&amp;#91;Translate&amp;#93;](http://translate.google.com/#auto|auto|@Brutha%5FSherm29i told my grl wen she duck me betta duck me gud , cause if another grl could she would duck me gud quack 'google translate this tweet'): [*@Brutha_Sherm29i*](https://twitter.com/Brutha_Sherm29i 'twitter user profile') told my grl wen she duck me betta duck me gud , cause if another grl could she would duck me gud quack [&amp;#91;This comment was posted by a bot&amp;#93;&amp;#91;FAQ&amp;#93;](http://www.reddit.com/help/faqs/tweet_poster 'tweet_poster FAQ')[&amp;#91;Did I get it wrong?&amp;#93;](http://www.reddit.com/message/compose/?to=tweet_poster&amp;subject=Error%20Report&amp;message=[Oops!](http://reddit.com/r/ruby/comments/mfbjc\)%0d%0dPlease leave the subject and this link unaltered, but feel free to add a description here. 'report an error')
Made a twitter bot using the twitter gem. It finds recent tweets that use "fuck" 3+ times, replaces with duck, then adds a quack. I am having some trouble with the @mention aspect, but I am pretty happy for a first ruby app. Let me know what you think. [github link](https://github.com/ewag/duckthat)
Not so shockingly, code that's written explicitly for Windows works faster on Windows. It doesn't help that the source code for File.expand_path is absolutely atrocious.
Thanks :)
That's what i also mentioned in my blog post, that it's also bad on Unix systems. But the builds done by The Code Shop project include also patches what could be used on Unix too so there might be also a way to get Ruby 1.9.3 faster on other platforms too. Well, i hope that these problems will be solved in Ruby's core anyway in the future.
That could have saved me an afternoon :( 
I agree, it is a bad name. Names are something I suck at. 
I'd put a space in between the username and the message since the first word is becoming part of the username but other than that it's pretty cool :)
&gt;I don't, and you're not reading what I spent all this time typing out for you. I read every word. Especially the ones where you said that simply by using a gem called tranny I would be creating a hostile workplace. &gt;How do you think they would react if you called every black coworker of yours "nigger"? yes because using a gem called tranny is exactly like calling every black co-worker a nigger. Got it bro. http://www.youtube.com/watch?v=cycXuYzmzNg Now go take your religious uptight ass back to church. 
&gt; yes because using a gem called tranny is exactly like calling every black co-worker a nigger. [r/asktransgender](http://www.reddit.com/r/asktransgender). You'll find the insights they can provide enlightening.
Good form on the Ruby code so far (using iterators/each instead of 'for' etc). Keep it up! Ruby rocks.
Are they going to tell me that mere existence of a gem called tranny in my project is going to make them complain to the management? http://www.youtube.com/watch?v=cycXuYzmzNg
fixed. Thanks
I like the name
It's ruby 1.9 shorthand for :x =&gt; y
This is the new 1.9.x syntax. RIP Hashrocket! http://peepcode.com/blog/2011/rip-ruby-hash-rocket-syntax
It's a hash syntax substitute for losers that don't like the amazing and beautiful hashrocket.
I just love the fact that it takes less than 10 minutes for community to answer the question. Love you guys!
I love the hashrocket. I suspect I'll continue to use it until I'm forced to change.
fantastic bot idea. i'm doing other fun things with the Twitter gem right now, it's good to see other people's ruby.
They're going to tell you how hurtful your attitude is, and most importantly, *why*. Because while you clearly do not understand currently, you seem capable of achieving that insight.
Awesome. Links to the stuff you are working on?
I'm still not sure how I feel about the 1.9 symbol hash syntax. I get that it looks like hashes I use in other languages... but it also masks the fact that the key is a symbol unless you're aware you're using a shortcut. When it comes to using it in code with developers who may never have used 1.9, or new Ruby developers, I don't feel like this feature follows the [Principal of Least Astonishment](http://en.wikipedia.org/wiki/Principle_of_least_astonishment). Then again, since it's a shortcut for an existing language feature I can't really complain. The hashrocket will still exist for keys of other data types, 1.8.7 backwards compatibility, and people stuck in their ways (like me :]).
Yeah, that's a pretty old RVM. Current is 1.9.0. Or at least, that's what I have. Nevertheless, I'm potentially interested in cleaner tools than RVM. Ideally they need to not involve more work, though, and having to build Ruby separately doesn't really sound like a win.
not quite yet, although perhaps i'll commit to github/karma whore it out when it's done :) EDIT: i shared this twitter account on my fb, and it's gotten reposted a handful of times already.
If current is 1.9.0, I don't think 1.8.6 qualifies as "pretty old"
Well, Ruby 1.8.6 to Ruby 1.9.0 was 9 months... It all depends how often releases happen. For RVM, releases happen every week or two.
I use [this hack](https://gist.github.com/1320801) to incorporate the man page into the actual Ruby script.
And Django
Cool stuff, only thing I'd change is the regex. Instead of /[Ff]uck/ you could use /fuck/i and capture case-insentive fucks. Or you could try /f+u+c+k+/i and capture stuff like fffuuuuccccckkkk!
How about no.
I'm less than halfway through Zed Shaw's Learn Ruby the Hard Way and I am a beginning programmer, so don't take this as criticism at all, just curiosity: Why did you require twitter_oauth? It looks like the twitter gem has that functionality in it [already](http://twitter.rubyforge.org/).
Why not just UrbanLex?
More like wasteful and extravagant hash rocket.
Upvotes for both of you!
Please note that troff is being or has been deprecated on some systems , and replaced with mandoc. Check http://en.wikipedia.org/wiki/Man_page If you use OptionParser (which IIRC helps to generate help), then you have a utility help2man which will generate the manpage. See http://www.gnu.org/s/help2man/
Python's dictionaries use a similar syntax, as do javascript objects, so it's not totally out of nowhere. Also, it's shorter, which is kind of nice. And the syntax isn't an advertisement like the "hash rocket"... which is kind of cool.
Not sure how I feel about this syntax yet, will prob stick with :x =&gt; 'y' BTW does not work in RBX but I don't think that matters much for this question.
&gt; BTW does not work in RBX Correct. &gt; How compatible is Rubinius? &gt; ... For now Rubinius is targeting MRI 1.8.7 (1.9 is on the post 1.0 list)
Right, just pointing out a potential issue (if they choose to delve into alternate interpreters)
Basic problem being it takes forever to evaluate each number one by one. How can I complete this action a lot faster?
Except for being totally incorrect except for the simplest regexps, it's an awesome idea.
No they are not. Nobody but you is going to be butthurt because somebody put the line gem 'tranny' in a file. Only a complete and utter retard like you is going to raise a stink and attempt to get people fired because of that.
Bugger it, I'll get one even though it's summer. I like companies that do quirky things like that.
I still prefer Aptana. Rubymine does some things that just bug me. 
Please explain. I'm trying to decide which IDE I should use.
I can't find a way to show Terminal (not ruby/rails terminal) in RM, but in Aptana I get it as a window inside the IDE, for rails development this is a huge bonus as I need have only one app open. RM on mac annoys me by having dialogue boxes that are not sized, so to read the content and use them the first thing I have to do is resize the box. This is a minor annoyance, granted, but I'm trying to work, not play with the GUI. Back to the terminal, running rake tasks, generate etc, is much easier from the command line and without having to cmd+tab from app to app I see what's going on when I hit return. RM only lets me see one project at a time, it needs multiple instances of the GUI to have &gt;1 project open at once, Aptana lets me see the entire file structure in the navigation frame. This is useful if I have an abandoned project that I need code from in the new version I'm making. Aptana lets you import Textmate Rubles and themes. +1 for Aptana. Aptana is free, even though I have RM free for a year on an academic license, I much prefer Aptana. Another small annoyance with RM, when a major new release comes you have to install it beside the old one, then delete the old one, it doesn't update itself. Aptana 3 is just getting better and better. It's my IDE of choice for everything that doesn't need C#, and it's built on Eclipse so you know there is support and integrity behind the builds.
Thanks for the explanation, that was really clarifying. If the IDE gets in the way of the development flow, then it's no good.
Interesting, Ill check it out as well. Thanks for sharing!
You should give both a shot. You can use RubyMine free for 30 days, that's what I did -- and between Aptanta and RM I far prefer RubyMine, and I use RM on both Windows and OSX. I have not yet run into dialog resizing issues, maybe this was an old bug?
Still using the terminal and a text editor here (switched to Sublime Text 2). Maybe I'll finally give an IDE a shot. Just curious, does it make sense to have one IDE that I can also plug Clojure and/or node.js development into? Or would you recommend a separate IDE for each one? I don't want to re-learn new keyboard combos for every single IDE.
Their intellij product supports all the languages they officially provide, but it's more expensive. their clojure plugin is just OK, not as good as slime in emacs, but their ruby and JavaScript support is better than emacs. My only complaint is that it uses a ton of RAM. 500MB or more. 
&gt; running rake tasks, generate etc, is much easier from the command line I think this is just a matter of getting used to the IDE. I slowly memorized my most often used shortcuts for commands e.g. generate, run rake task, all of which give you a separate dockable log window to show output. I'm still a bit fuzzy on its git integration, however, and haven't had the time to really learn it since my workflow is such that I typically do all my git operations once at the beginning - typically before opening up the IDE - and once at the end typically after closing down the IDE. I would definitely recommend the 30 day trial to see if you like it. But remember to *actually* use it as your only IDE for at least 2 weeks before deciding whether you want it or not. Anything less and you risk making a decision without enough information.
Can you provide an example that won't convert cleanly? The following regexp converts just fine: https://gist.github.com/1376872
+1 for aptana if for no other reason than the default theme is very easy on the eyes.
Certainly, gotta love the community.
I dont't get whay you mean about the syntax of the hashrocket being an advertisement. Care to elaborate?
Thanks everyone for the accurate and fast answers! I probably should start following some blogs about the language so that future changes like this don't catch me by surprise.
It's only been recently that *require* has been getting so much attention afaik, and it seems to me that this "problem" only exists because of Rails and/or Bundler. I would think there are other more important areas that could be sped up on Windows, e.g. IO operations.
&gt; While mandoc works well with the mdoc manuals used in the BSD Operating Systems, it poorly handles older troff macros such as man, me, and the roff language itself. This makes it a poor fit for GNU/Linux distributions, which primarily use man troff macros and low-level roff for their manual pages. -- [Wikipedia](http://en.wikipedia.org/wiki/Mandoc)
In Ruby: &gt;&gt; "foo\n" =~ /^foo$/ =&gt; 0 &gt;&gt; /^foo$/.to_javascript =&gt; "/^foo$/" In Javascript: &gt;&gt;&gt; "foo\n".match(/^foo$/) null You cannot go much simpler than that. It will "convert" to a regexp that matches something different.
i'd like to try sublime text 2 but its so damn expensive, that it just makes me stick with vim
unfortunately ends the 27th, less than 10 days to try before deciding to purchase :(. They should at least extend it up to christmas.
The best I've found is [ruby-kickstart.com](http://ruby-kickstart.com/). And it's free.
Thanks 
I've tried Aptana, Netbeans (6.9), and RubyMine, all from Ubuntu. I'm currently sticking with RubyMine, and I like it quite a bit. I believe the most important aspects of an IDE are correct syntax highlighting and code navigation (jump to definition, find usages, find file in project, etc.). Of the three IDEs, RubyMine was by far the strongest in these two categories, with the features working as expected 100% of the time. I didn't realize until RubyMine how low my expectations were set from using Aptana and Netbeans. Disclaimer: It's been over a year since I used Aptana, and I still do all my git and gem management from the console.
...how is this any different then `bundle open somegem`
It's not that bad. And the demo mode is pretty unintrusive, and fully featured. Try it. It also had a vim mode you would like.
Configuration is a solved problem, and class variables are not part of any of the standard solutions. The usual way to do this in *rails* is to use an initializer (and often a config file) that loads a global value with an environment hash - then you use the value like `produce(FAVORITE_ICECREAM[Rails.env])` Occasionally, you'll have something that really is class specific - if it can't *vary*, then its a *constant* (and usually derived from some other constant in an initializer): class MyClass FAVORITE_ICECREAM = $FAVORITES[Rails.env][:ice_cream] end If you have configurations that are different for different customers, either make them environment variables, or put an *example* config file in place, and gitignore the real one - all my projects have a `database.yml.example` file in the repo, and `database.yml` in the gitignore. Class variables are hardly ever the right answer - they are simply namespaced global variables.
Those aren't class variables in the PHP example, they are instance variables. If they were class variables they would be declared static. If the PHP example had used actual class variables it would have the same behavior as shown in the ruby example. 
True, if the variable was referenced with self::$myvar. However, if static keyword (static::$myvar) was used in getMyVar() -method it would give you the same output as the example using instance variables.
This. I commented on the actual post, hopefully he'll amend it
Problem? 1. You're using global variables, eck 1. You're app will explode without $FAVORITES, it should degrade gracefully or raise a proper exception 1. You're excepting that :ice_cream exists 1. You'll get warnings if the class is reloaded (avoid using constants), or properly use DEFINED?(FAVORITE_ICECREAM) *sigh*
For configuration, I think probably using a singleton pattern is going to do you better. The ruby stdlib 'singleton' library can do it for you, although you can then put some class methods on top with some methods to hide the singleton and make calls shorter. It's still essentially a 'global variable' whether you do it either of those two ways though. Lately in Rails I've been trying to put config state on controllers instead, where possible, instead of a global. Ends up working out better for a variety of reasons, including, if done right, the ability to over-ride on a per-controller basis. The Rails #class_attribute helper method can be used to create class-level state which is over-rideable per-subclass, accessible at the instance-level without calling class.self, and even over-rideable at the instance level if you want (so a particular controller could conceivably load different config depending on the params of the current request). 
Class instance variables are way cooler.
Sorry to sound mean, but author could have just have told us to use "gem man" in one sentence rather then giving us a whole long story. I thought there was a lot more to it. btw, there's also lightning. If you know the name of a ruby file. http://tagaholic.me/2010/04/08/lightning-speed-for-your-shell.html vim-ruby abbrev.rb less-ruby string.rb
It's actually possible to make things a bit faster than this by stubbing out the bcrypt calls in Devise entirely, although there's some gotchas that arise with that. See [this article](http://www.rubyinside.com/careful-cutting-to-get-faster-rspec-runs-with-rails-5207.html) for details, comment thread for gotchas/solutions. 
Awesome idea! I would've coded it more like this: if r.text.scan(/fuck/i).size &gt; 2 # replace fucks wtih ducks and add a quack tweet = "@#{r.from_user} " + r.text.gsub(/fuck/i,"duck") + " quack" # send tweet end
https://gist.github.com/6db5c7620c677f666ba5 - My solution.
AWWWWWWWWWWWW YEAH! :)
So, an alternatative is simply using 'require' everywhere you use autoload, yes? * First, I've never completely understood why people use autoload instead of require in the first place. Performance? * Second, doesn't require (which obviously can't be removed) have the same multi-threading issues as autoload? 
1. Yes, performance.
I will be sad to see it go. The performance gains it offered were extremely valuable. edit: What can be used to take its place?
Also $FAVORITES could be a constant since it's a mutable hash. However, the next question is SHOULD it? Discuss.
1. Loading only when, and if required. So often smaller footprint in addition to other points mentioned in other posts here. 2. require: &gt; There was a similar discussion back in early 2008, started by Yehuda Katz (of Merb fame) that I'd advise you read if threading is going to be a big deal to you. He seems to imply that big issues only crop up under heavy concurrency situations, but the problem is there regardless. There seem to be similar issues around **require too** though so I'll be taking the "cross that bridge when I get to it" approach.. ;-) http://www.rubyinside.com/ruby-techniques-revealed-autoload-1652.html
What about simple conditional requiring. Does this not work? I have various classes for some of which I have created shortcut or wrapper methods. The ones that are not often used might do: def foo ... require 'gem/whatever/foo' Foo.new whatever ... end These are part of a library. So i never know for a particular program which ones a user might use. From what I checked, they only should load when the wrapper method is called. btw, This does not answer your question. Just putting this across as something I've used. Would like to know any pros and cons you can think of.
Yeah, I think that would do it. It would certainly change things so that you no longer have a big file that requires all the other ones, but rather in each file you require its dependencies. The interpreter can deal with redundancies.
Happy to see some "derp" in the source.
If 'require' is a performance problem, then calling it ever time the method is invoked is even worse than calling it on class load. If 'require' is not a performance problem, why were people using Autoload in the first place?
The reason for using autoload is to avoid the startup time of having a bunch of stuff require'd at once even if it's not needed at startup, *not* to avoid the cost of loading completely. 
Require just loads the required file once and then returns true: irb(main):001:0&gt; require 'fileutils' =&gt; true Later it doesn't load anything and returns false immediately: irb(main):002:0&gt; require 'fileutils' =&gt; false So, you still have to make an additional method call in your method, but you only have to pay the full price (loading, parsing, etc.) on the first call.
Yaaaaaaaaaay!
&gt;Error establishing a database connection wa wa waaaaaaaaaaa 
I don't think mass assignment actually helps... a,b,c=1,2,3 a=1;b=2;c=3
yeah, the autoload concurrency problems should only crop up under high concurrency too, right? If require has just as much of a concurrency problem as autoload (as far as I can tell the _exact same_ problem, right? isn't autoload just a require-on-first-use?), that seems like an odd reason to get rid of autoload. Obviously you can't get rid of require. 
Helps in some cases, mainly for deconstructing arrays. b=a[0];c=a[1] b,c=a Obviously, not in the example he gave.
Aha, nice :) Thanks!
No mention for goruby? laaaaame.
I know you probably already thought of this, but how about making an open ended final assignment. I mean, let them make a project of their desire. Of course, the students will run their projects by you, and you subsequently approve the project, or reject the project if it is too simplistic. It makes the students who are intrinsically motivated happier, and the people that are extrinsically motivated by grades as well. As a recent college graduate from a private university in Philadelphia, I respect and admire that you are spending some time altering the curriculum for the course to benefit the students. Most programming courses I took, were too simple, or too difficult and not pragmatic enough making me lose motivation. Most professors honestly could not care less, unless their check for teaching the course did not clear. I discovered Ruby/Rails a little over two years ago, and I've enjoyed every minute I've spent with it. Found out about Ruby by the vanishing of Why the Lucky Stiff on Twitter and decided to find more information about him and what made him unique. I subsequently downloaded and printed Why's Poignant Guide to Programming and read through it. Then I purchased Foundation Rails 2 by Eldon Alameda. Then I took a year off from studying Ruby/Rails, since I had to graduate on time. After graduation in June, I decided to pick up Michael Hartl's Rails Tutorial 3 and haven't stopped Rails development since. Now I'm starting to notice my lack of Ruby knowledge, and I am working through Ruby Koans. I created a few web applications. They are under projects in my [weblog](http://www.icantbecool.net). 
Even better trick: a=b[0] a,=b 
this is fantastic reading.
y
Lots of wasted effort. Haml doesn't NEED to be faster. What it needs is to create pre-compiled ERB templates, like CoffeeScript or SCSS make pre-compiled tamplates. There is absolutely no need to have it active at runtime at all. Speeding up something that should not be there in the first place is a bonehead waste of time. 
Congrats! Looks like a great improvement.
Amen
It's possible what you said is true but the poster made a tangible improvement to HAML for what HAML is. Aren't your claims are off-topic for this thread?
ummm, It doesn't look like a wasted effort at all. If you look at the link, it seems like a bunch of people wanted this too.
I haven't made it past this yet: &gt; Ruby on Rails WEB framework If you want to sound like you know what you're talking about, don't put the word 'web' in all caps. It's not even an acronym. 
Hey, dude—the point's over there.
Finally! \o/
I have come to feel that singletons are almost always a code smell.
Lol is this poster into iconic homos? Elton john is an iconic homo lol 
Not sure, but I interpreted the question as more like, 'Wouldn't putting a require inside your method introduce a require-check every time you run the method?' i.e., Yes, it returns false really quickly, but it returns false in a non-zero amount of time.
More so than class variables? I think they're really just two different ways to write almost exactly the same thing -- they're both single global state, they're both basically global variables, both namespaced in a certain class. So I think they're both kind of suspicious, but sometimes it's not worth architecting it 'right' (you try to make everything as ideally flexible and well architected as possible, you end up with over-engineered mess sometimes. see Java). If you're going to be having all sorts of class variables or global variables that represent config, I'd rather wrap them up in an object and put that object in class or global variable -- which is what a singleton pattern is. At least then you can swap out that 'global config state' object for another one as one unit, although you still only get one at a time cause it's global. But you have single global state sticking config in class vars too, but they're littered independently accross dozens of vars, this seems to be in no way preferable. 
Author: Reginald Braithwaite Elton John: Reginald Dwight Coincindence? I think not.
nice!
That would be cool too
&gt; Keeping track of and managing your model’s structure across multiple migration files is not agile. If you're digging through migration files, you're Doing It Wrong. The schema file shows you what the DB table's structure is **right now**. The migrations it took to get there are inconsequential. You write a migration to change that schema from what it is right now to what you want it to be.
Agreed, in fact it wouldn't really affect that at all. You'd still have plenty of change_column migrations later on, for example. I think that's the motivation for this gem automating it, as you're generally interested in the current schema (and your domain model), not writing hand-crafted migrations, which for most cases are pretty boring and standard (especially when prototyping).
Good point, makes sense. Venting out your frustration in the wrong place, though.
i hate having to pull up schema.rb to see the attributes when i have a model open. i have used [annotate_models](http://github.com/ctran/annotate_models) in the past, but this seems way cooler.
Thanks man, this makes a ton of sense. Thanks for the info!
Nice and clean. power to redditors!
This is the greatest thing ever, I can keep my deployment instructions out of my application repository now.
trying to be Mongoid, one step at a time.
Seems like I would just use Datamapper if I wanted this. But I really think this is a bit too much "magic" with little benefit.
One thing I like about this is being able to see all the columns/attributes in the actual model class file. I understand it's point is so you don't have to write migrations, which I'd probably get used to although now I don't feel a burning need to avoid it -- but right now I am annoyed to have to go look in db/schema.rb (or the database itself, or a console inspection of the model class, sure) to see what attributes exist, when I want to know is generally when I'm looking at the class definition. 
cantbecool &gt; thanks a lot for feedback! There is general problem with Lithuanian students - most of them really want to get well defined tasks, especially it's big problem with unmotivated students when they start to argue why their task implementations doesn't meet expectations. So some kind of quality and quantity requirements and structure must be in place. But there is complete freedom in what application students want to implement. I'm even open to any suggests to change project during semester, I'm happy when student decides to do something else (hopefully better) after spending some time digging initial his/her idea. So generally students can do whatever project they want as far as it's written using BDD (they actually even can use any other Ruby web framework and other testing framework). So I believe that completely removing any requirements would be too complicated to implement in my case. But maybe I can try it one semester. Thanks!
Can you declare/create foreign indexes, indexes, unique constraints? What about migrating data (for example, moving the data in a column into two cols or a new table)?
Wish this was on Amazon...
ActiveAdmin is the only option I've seen so far that works (at least partly, filters/searching do not work) with Mongoid, sadly all the rest seem to focus on ActiveRecord :(. 
I'd really like to read the book, but there's no way in hell I'm paying $54 for a 60 pages e-book.
This guy seems to be a pretty good link spammer. This ebook of his has been around for years and keeps showing up once in a while on hackernews or proggit. 
I purchased it for $40. Where did you get $54?
$40 + VAT, unfortunately :/
Maybe it simply just is a good book?
I found this approach works a lot better. http://iain.nl/backends-in-rails-3-1
I've ran into this dilemma before (I can't seem to justify a full Puppet or Chef setup, yet I want a simple way to deploy new servers). [This is what I came up with.](http://serverwizard.heroku.com)
Thanks! I love the pragmatic approach.
I'm in the middle of learning to deploy rails to ubuntu and this looks like it could be the answer to my woes. Thanks.
Definitely [Try Ruby](http://www.codeschool.com/courses/try-ruby).
yes..i think the same...it book is for rubyst with experience in web development (maybe persons come rails world)...for me the book was a bit boring...the explanation isn't balanced...but you can extract very important ideas from it...how develop medium apps and if you're a php or java programmer with ruby background can notice how fast and simple is use sinatra.. other thing than I don't like is than when I read this many code was outdated...particularly the datamapper part (and found information and tutos in the web about dm is hardest compared to activerecord) maybe you've luck and buy a new edition... if you buy this book take your time..learn ruby well and read the book slow and you could extract very usefull information from it
Typus is another good option.
While I agree that the price is in the higher segment, the guy does have some reputation ([tinyrb](http://code.macournoyer.com/tinyrb/), [thin](http://code.macournoyer.com/thin/)) and he tries to make a living out of that I guess. I see nothing wrong here.
Personally I first tried rubymine and got hooked to how it operates. I'm used to it and find it hard to stray away from it, so I purchased a license. I may look into com possibly and stick to the roots.
..when a guy like Yukihiro Matsumoto(ruby creator) gives a book a good review, it's a good indication to invest in that book!
Every month or so I see yet another blog article stressing this point... and I couldn't agree more. When I went from Java to Ruby as a Ruby neophyte, I made the mistake of "forgetting" a lot of the pattern knowledge I had gained. As I've progressed as a developer, my blinders have come off and I've seen great code re-use and design simplicity while slowly remembering all of the patterns I had "forgotten" about. Not to mention simplifying my testing.
I think the reason ruby programmers tend to have a bad taste in their mouth with regard to design patterns is that most of them have been exposed to bad java programmers at some point. Bad Java programmers sometimes jump for design patterns at every opportunity, before they're necessary, rather than refactoring *to* them when it cleans up the code. It ends up convincing people that design patterns are actually anti-patterns, which is unfortunate.
I don't feel like this is exclusive to Ruby programmers. I just think it's a natural reaction to the over-engineering that new developers are prone to experiencing. While I think you're absolutely right, I think gaining a distaste for, and the rediscovery of design patterns are a sort of right of passage for any programmer. :)
&gt; Today, I talked with NaHi about enhancing const_missing to enable autoload-like feature with nested modules. It sounds like const_missing will be enhanced to allow similar functionality before it's deprecated.
In the situation mentioned, could he not have also inherited from the Customer class and added his method. That would save having to go through a "method_missing" all the time. I admit I am rusty on all the design pattern knowledge I have 10 years back while working in Java. Did a lot of over-engineering back then, am slowly getting back to refactoring using patterns now.
Wouldn't it be easier to create a module and mix it to the model class? Inheritance is used much more in Java, but it isn't always a good solution.
SimpleDelegator in the standard lib already provides this. require 'delegate' class FancyUser &lt; SimpleDelegator def full_name "#{first_name} #{last_name}" end end @fancy = FancyUser.new(plain_user) puts @fancy.full_name 
Simple stuff now, but when I was a noob I had no idea. So hopefully this helps someone. &lt;3
I have never understood the need for this type of DSL for JSON. Just use hashes, arrays, strings, integers, etc.
Rails provides an excellent XML Builder by default to build RSS and ATOM feeds, but nothing to help you build complex and custom JSON data structures. The standard to_json works just fine, but can get very verbose when you'd like finer grain control of what is generated and performance is a factor. If you wanted to include URLs or do any data modification you'd have to add additional custom methods to your model just for the json output. Trying to build API's solely relying on to_json becomes frustrating after trying many times before. Also, since your .json requests are considered views, it's nice to have individual files for that sole purpose. With the to_json approach, it'd look like: @user.to_json(:include =&gt; { :posts =&gt; { :include =&gt; { :comments =&gt; { :only =&gt; :body } }, :only =&gt; :title } }) With JSON Builder you have your own view alongside any XML builders: id @user.id name @user.name age @user.age created_at @user.created_at awesome @user.awesome posts @user.posts do |post| title post.title comments post.comments do |comment| body comment.body end end 
I guess I should have elaborated more, I tend to use presenters for JSON output (and most other view logic). You can easily include Rails.application.routes.url_helpers in the base presenter class. I agree Rails' to_json is the wrong approach. Add as_json to the presenter (1.9 hash syntax for simplicity): { id: @user.id, name: @user.name, age: @user.age, created_at: @user.created_at, awesome: @user.awesome, posts: @user.posts.map do |post| title: post.title, comments: post.comments.map do |comment| body: comment.body end end } 
I tried to use this about 2 weeks ago but it kept generating invalid JSON when I had an array in the response. I'm on my phone now without access to my code, but I recall that it was the same issue that someone had posted to your Issues section. Any idea what I'm talking about, and do any of your recent commits fix that? I can provide more details later when I get to my computer. I ended up using Rabl instead of this, but I actually really prefer this gem's very explicit syntax and how it's similar to XmlBuilder.
Yes, I know exactly what you are talking about and it literally kept me up 2 nights ago while on vacation and, well, this is what it produced, version 3 a whole new rewrite which now include tests. (I know shame on me for not having them last time) I suggest you try it one more time and I think you'll be much happier especially with the new DSL. Creating arrays on the old &lt; 3.0 became very verbose and a few other oddities that have all been fixed and tested for (especially those that issues were created for). Let me know if you have any feedback, on here or on GitHub. Thanks!
That's great to know! This is really perfect timing for me. I was actually planning on digging into the json_builder code over the next few weeks to see if I could fix the issues myself because I really don't like Rabl at all. I'll try switching over to using your latest version when I get a chance in the next week or two and let you know if it works for me. Thanks again!
Agree. Dont really see the point of these type of gems.
Interesting. Couple comments: Authors could use better (more professional) pictures. In the photos they look like they use this for porn exclusively. What input video files does it take? I can't find that on the git page.
Any ffmpeg supported codec. 
Ah, makes sense. Thanks.
Put them in a model anyway. Just because they're not backed by a persistance layer doesn't mean they're not models. Subclass for any shared behavior, like normal, and go crazy. IE: class ApiBase def fetch ... end end class FirstApi &lt; ApiBase def get( something ) header = {header: something} fetch end end 
This is what I will do. Thanks for the suggestion!
Agree with jmoses's suggestion that each API should have its own class. You should also have Model objects representing the data you get back from each API. If you are using an API to get news stories, it should return a Story object. 
"Clone the project with" link leads to https://github.com/devthenet/voyeur/tarball/master, not https://github.com/devthenet/voyeur/
What's the difference between just doing `rvm install` command and having the necessary developer packages?
I don't know how it ended up that people think that a model can only talk to a datastore. Models represent data. You can read that data from the 'net, or construct it using the current time and hard-coded astronomical patterns, etc.
I blame it on Rails being most developers introduction to the MVC pattern, and in all the Rails books/tutorials, models are *always* backed by the DB.
The situation is hardly any different with other MVC web frameworks. Rails was not my first, and every introduction I read to frameworks I used before Rails followed the same pattern of treating models as always relating to a persistence layer.
It is very hot off the press, but was born from frustration with the approach taken by its alternatives (treetop, citrus, racc, parslet). Relying on an external grammar file with code generation doesn't make sense to me in ruby. Parslet is lovely, but quite fiddly to make work with recursive grammars and it's very easy to run into its key weakness "stack level too deep issue". Whittle also handles left/right associativity, left/right recursion and operator precedence out of the box, with a clean DSL (I hope!).
Parslet is also all ruby all the time, of course. Sounds like it comes down to LALR (Whittle) vs PEG (Parlset), different approaches to parsing, you preferred LALR? Nothing wrong with having two options for parsing in ruby, one LALR one PEG, both pure-ruby-no-code-generation and both with great DSLs!
Yeah, that's why I used Parslet before writing this. I don't want to trod on anybody's toes, but basically I needed a pure ruby parser than can handle very recursive grammars without hitting "stack level too deep" and I needed to be able to define the associativity of operators (I'm parsing Tutorial D). http://en.wikipedia.org/wiki/D_(data_language_specification). I think LALR is a lot easier to work with too.
In order to get around Ruby development, indeed there's all that stuff you mentioned. You should get your hands dirty on: * Unix. All Mac OS, Linux and BSD derive from it, so that's what you need. This is a starter: http://bit.ly/Uh0vp * Git is good for tracking your code. There's a great book by Scott Chacon called `Pro Git`, it's available online @ www.progit.org * Ruby is installed in the Mac OS already. There are also packages available in .deb for Debian-based distributions such as Ubuntu or Mint and in .rpm for Redhat-based distributions such as Fedora or openSUSE. When in doubt, there's always Google and IRC. Remember to practice all the time ;)
I find the syntax to be aesthetically pleasing :)
http://pragprog.com/
Git is a version control system, I like http://gitimmersion.com/ as an intro to it. make is a build system for C programs. It compiles each neccessary file, references the correct libraries for your os, and will install the resultant programs. You do not need to learn much about it unless you get into C programming. I'd skip learning about it or maybe look for a 20000 ft overview, the details are arcane and convultued. install I'm guessing is an OSX command for installing software to the correct place. sudo is a way to temporarily (for the duration of whatever command comes after) increase your privileges. You can act as root with all the power and danger that comes with it. homebrew is a package manager/installer for OSX that is supposed to make installing packages (like ruby) easier than doing each step by hand. I'm a linux user and have never used it. I can't think of any 1 resource that would explain everything. That being said, I also think that if you can pick up a few things every time you use a guide, then you will be in good shape. sudo is a good example as it's one of the commands you'll be using a lot. I'd start with figuring out what sudo does, then expanding to understand file permissions and a shell (Bash or ZSH). As those are tools you'll be using a lot. checkout https://wiki.archlinux.org/index.php/Users_and_Groups for a decent overview of the permissions. git is a different story as you'll be using that a lot if you start programming. spending some time learning the basics and how it works (http://think-like-a-git.net/) is time well spent. Good luck, happy to follow up on anything. 
I started using it to rewrite a parser I'd developed w/Parslet, and I'm very happy. Syntax is very straight forward, development is quite fast. Well done.
I'm interested in benchmarks between Parslet and Whittle, esp wrt GC/memory-usage. Also, thank you to keeping it entirely Ruby, and not writing it in C "for some performance".
I haven't run any yet and probably won't do until I'm at least a few versions in, as the internals are still changing (though the DSL not). If anybody else does them I'd be curious to know too :)
I meant my statement more as a general statement than as directly applicable to the post, but I totally agree that most (all?) intros to the various MVC patterned web frameworks seem to tie the M piece strictly to the DB, and give little to no direction in what to do when the DB isnt necessary. 
I like the DSL syntax, very clean. using `def [](*args)` is very clever. 
Sounds like he could also benefit from [presenters](https://www.google.com/search?q=ruby+presenter+pattern) (link goes to google results)
"Beginning Ruby" By: Peter Cooper taught me everything I needed to know about Git, SQL and all that other crap that a programmer needs to know but is not directly related to the language itself. And to top it all off, he's a Redditor apparently. If you're looking for someone to study with, PM me and maybe we can get frustrated togther over skype. I'm learning still too and wouldnt mind having a friend who is motivated to learn also.
Sounds like Ruby needs an LR(k) parser next.
I MUCH prefer Whittle to Treetop. Much better DSL. Thank you for this!
I considered investigating the ease with which Whittle could be adapted to (optionally) handle that, but one thing at a time ;)
Thanks, it is fun to play around with :) The DSL can probably be improved further with regards to repetition (for lists), but I'll have to think about that carefully.
Oh, very very nice. Clean, readable, actually makes intuitive sense. Thank you for this 
A long, long time ago, back when proggit still allowed self-posts, [I asked a similar question](http://www.reddit.com/r/programming/comments/7wa4l/suggest_a_programming_language_for_a_newbie_to/) and got a suggestion to try out [Hackety Hack](http://hackety-hack.com/). It's aimed at kids but is great for complete beginners. From Hackety Hack, to [why's (poignant) guide to ruby](http://mislav.uniqpath.com/poignant-guide/book/) and [Chris Pine's Learn to Program](http://pine.fm/LearnToProgram/), I quickly got to speed to ruby. The above links may not be too useful to you if you're already a programmer well-versed in other languages. I'd suggest focusing at one thing at a time. Trying to learn git, bash and a ton of linux utilities can be overwhelming. Just install ruby and write simple ruby programs. Not rails apps, ruby programs. Simple things to get you up to speed with ruby's syntax and standard library and then move on to more things. But do everything one step at a time. I don't program ruby anymore, I've moved on to the darkside (C#) but I think I may be of some use to you on your journey. Like bacondog, I extend a helping hand if you need help.
Aewsome! Thank you :)
That's pretty cool. TIL.
It could be done via inheritance, it could be done by extending the object with a module too. Method missing is the worst way.
A few weeks ago I was looking for a Ruby library just like this, and I was surprised when I couldn't find anything suitable. Thanks for taking the time to write this - it looks very promising!
each isn't listed in Enumerable.instance_methods because Enumerable doesn't define each. Instead, each is the method that a class needs to define on its own in order to be able to mix in Enumerable. Basically, Enumerable doesn't know what each means to an object, but once it finds out, it can define everything else in terms of each.
I can't speak for any of the others, but _Metaprogramming_ and _RSpec_ are great books. I'd even put them on the "Just beyond beginner" list.
Something like this maybe: hash = Hash.new hash.methods.inject(Hash.new { |hash, key| hash[key] = [] }) { |memo, key| memo[hash.method(key).owner] &lt;&lt; key; memo }
You can use Method#owner to figure out where a method is defined and Kernel#method to get the Method object: class Object def method_hierarchy hier = Hash.new { |h, k| h[k] = [] } methods.each do |name| hier[method(name).owner] &lt;&lt; name end hier end end
G'Damn... Thanks r/ruby!
For sure, metaprogramming made me go from "i get ruby" to "woah" I recommend it as the book to read after pickaxe
Try the free and awesome [ruby-kickstart.com](http://ruby-kickstart.com). It will get you up to speed in pure ruby in no time. I am yet to find a clearer or more efficient introduction. There's an intro to sinatra in the last session which is a nice bonus. As for the command line tools, you don't need to know everything right away. Discover the patterns that you need on a daily basis and then add more little by little.
any way to get it to tell you what _line_ of the what _file_ it's defined in? (what file it's defined in may not be obvious from the module name, if someone was doing something tricky). i'm guessing the ruby vm probably doesn't track this, but would love to be wrong. 
My next question was exactly what you're asking about. I did some digging, and found a REPL alternative to irb called [pry](http://pry.github.com/) 
And pry can do that for you? Wow, might be the killer feature that finally makes me set up pry. 
You don't need all that stuff to try out ruby: http://tryruby.org/ I faced the same thing when I dug into the command line. A big part of the frustration is not knowing what question you're trying to ask when you hit a wall. Understanding *Users* and *Permissions* is critical. Second is understanding what the **PATH** environmental variable is and how it affects everything your user does on the command line. a few bash learning /reference links I've gathered over the years: * http://www.gnu.org/software/bash/manual/bashref.html * http://theory.uwinnipeg.ca/UNIXhelp/ * http://ss64.com/bash/ (OS X Specific: http://ss64.com/osx/) * http://mywiki.wooledge.org/BashFAQ * http://www.heimhardt.com/htdocs/bashrcs.html 
That depends.. what are you running? Sinatra? Rails? Either way: I host all my ruby related things with unicorn and varnish. Varnish is a caching server. You could also replace varnish with nginx+memcached (for caching). Switching from thin to unicorn was a pretty nice performance boost back when we did it on a project I was working on before. :-)
My first reaction before clicking through was, the first book had better be *Eloquent Ruby*, then found out TFA is written by Russ Olsen.
funny you said PATH. I was getting extremely frustrated why brew install ruby 1.9.3 was working yet ruby -v showed 1.8.2 SURPRISINGLY no where on google did it say anything about path. I looked and looked for all different terms, and then on some random stack overflow post someone said "you need export path". That wasnt helpful at all... but i thought it looked slightly familiar. I rmemebered it from 2 months ago when i was configuring macvim and setting up the colors along with my vim theme for terminal. sure enough, i open up bash profile, paste it in and everything works. I was actually really surprised how no one said to do that... and its not on the homebrew homepage. Let me make a clarification to my original post too! In my first post i talked about git, make, install, whatever. After trying to install ruby, its not so much the commands, its absolutely the paths that are equally if not more frustrating. How many bin folders do i need? do i really need 30 bin folders, in 20 different usr folders? how about 50 etc folders that will make things easier. Someone explained this really nicely to me /usr/bin is for mac /usr/local/bin is for what addons you wanna do That makes sense to me, but paths are still etremely confusing to me because thats one tiny part. Thanks so much for those links ill check them out :)
You need to be more specific (what kind of app, what data store etc.). Without knowing any details you basically have to choose the webserver, which uses less resources (memory or cpu, whichever you have more of). Nginx is fine, but if you have plenty of memory have a look at [Jetty+Jruby](https://github.com/strobecorp/kirk). [nice jruby related benchmarks](http://torquebox.org/news/2011/03/14/benchmarking-torquebox-round2/)
The most requests a second are handled by the setup that never hits your application. Aggressive caching, CDN use, avoiding long renders, caching partials to memcached, etc., etc. Wherever you're trying to get performance out of your environment, you can cut it down with smart code with much more benefit. 
How would you compare Metaprogramming to Russ Olsen's two books taken together? 
Alright, I guess I wasn't clear enough on my question - I'm looking for the most well-performing Ruby application setup. Take any hypothetical situation you want. Let's say it's serving up a CMS of sorts. Caching is always a solution, on any platform, so that's a given. What specific frameworks would I be using with Ruby? Would I use Ruby-written webservers or something dedicated such as nginx or apache? What sort of benchmarks are out there?
Honestly I'm new to Ruby web development so I don't really even know, I'm looking for direction here. I do however know that when I see application benchmarks touting 160 reqs/sec (simple 'hello world' benchmarks) I'm a bit confused on how it could be so slow. Is there a nice overview on exactly what is say.. Rails or Sinatra or Rack?
Thanks. Those sort of benchmarks are just disappointing to me. Is 160 reqs/sec for a basic application really something to show off? Where is the bottleneck here?
Sinatra is a simple framework for making basic websites (based on the frontend model). It's probably best suited for smaller websites, I do however like using it for anything. Rails is a bigger MVC framework which is a bit more popular (but also a lot bigger and slower since its pretty huge). Rack is a modular webserver interface used to interface between a bunch of ruby web frameworks (like sinatra and rails) and various application servers like unicorn, mongrel and thin. You can read about [Sinatra](http://sinatrarb.com/) and [Rails](http://rubyonrails.org/). [Rack](https://github.com/rack/rack). There is a lot of information out there! I recommend watching screencasts and just try to create some projects. :-) I like using sinatra because it's usually quicker than Rails and my applications aren't that big anyway. As for benchmarks: That entirely depends on what your application does and how well it's cached. Most of my applications are heavily cached so 99% of requests never hit the application servers, allowing high reqs/s. 
Best performance I got IRW was with nginx and trinidad + threading. The threading allows for a high level of concurrence and a stable memory footprint. There are probably better jruby implementation than trinidad, so you could probably squeak out even more with a little work.
is it a Rails app? Then that's the bottleneck. But I have no idea what kinds of benchmarks are typical for other web environments/languages? Or what conditions the benchmarks are run on? 160 reqs/sec sounds like a lot to me, shows what I know. Those numbers will be per-process. If you have nothing running on your server but a web app, then would run as many application server processes as you have CPU cores, and get bandwidth that scales up pretty linearly there with number of web app processes. 
So the details can depend a lot on what application framework you are using. (All the way down to the 'no application framework' of using CGI, which you don't want to do). It's not like PHP where it's all the same, nor is it like Java where it's all the same for entirely differnet reasons. It's more like, say, C. Imagine "what is the most well-performing C setup for a web app?" There's not really any answer to that, there are too many variables. If performance is what you care about most, you probably don't want Rails. You maybe want Sinatra. If you REALLY care about performance (in terms of requests-per-second) above everything else (including being able to write in a familiar style of programming instead of learning a completely different way to do it), then you probably want EventMachine. But you've got to write in certain ways using paradigms most of us aren't familiar with to use EventMachine. Then the particular deployment infrastructure you will use can depend on where you start (Rails, Sinatra, EventMachine), whatever. And you'll probably get better advice if you ask specifically for that. The specific deployment infrastructure can be changed more easily than the framework you are using, first things first. 
Dude where was this post like a month ago when I bought a bunch of ruby and rails books???? Scumbag subreddit gives great advice... One month too late!
Why? :)
Because only good things have come from it and you've been more active on the sub-reddit. :D 
Can you summorize what exactly is the difference between "metaprograming" and regular programing in Ruby?
Yes Pry does have what you want, just use the ever flexible [ls command](https://github.com/pry/pry/wiki/State-navigation#wiki-Ls): behold: https://gist.github.com/1407780 
I'll add a book: I learned a lot from PragProg's [Build Awesome Command-Line Applications in Ruby](http://pragprog.com/book/dccar/build-awesome-command-line-applications-in-ruby). It got me to make the move from brain vomit scripting to structured program design, even for the most trivial of scripts. I noticed that throwing OptionParser into simple scripts (like a personal CLI script that retrieved temp for the next 6 hours so I knew what to wear) would compel me to polish it into a program I felt comfortable sharing. Since CLI scripting is one of the most utilitarian experiences of budding Ruby developers (like me), this book gives you aim and direction, so I've got to recommend it. The Metaprogramming book is massive. Huge ups. I was a true noob when I read it, but it was so well-written that I never got lost. The whole fictional narrative used to explain the reasons for refactoring was absolutely brilliant, even if you don't need metaprogramming. Really shines a light on the path of some of the most prevalent but not immediately obvious tricks you find in Ruby apps. And the RSpec book also gave me an internal narrative for how to test.
What did you buy? Pragmatic Programmers is always a good source from my experience. I always browse them first. Until I found out about [Hartl's Rails Tutorial](http://ruby.railstutorial.org/), I was building apps by reading Apress' Beginning Rails and PragProg's Agile Dev with Rails books simultaneously.
Jruby based app servers are likely to be your best bet.
best setup for ruby web performance is caching a lot
I picked up some good books, just not the appropriate level for my skills... I got The Ruby Way, the O'Reilly book, and PragProg Agile WebDev with Rails. The last book suits me pretty well for learning, but the O'Reilly and Ruby Way are really dense.
I know it's not a Ruby-specific book, but I would add "Mastering Regular Expressions" by Jeffrey E. F. Friedl. The knowledge of Regular Expressions are priceless in any programming language.
surely you simply pass it in a method call? For example to a helper, or to a mailer call Polluting the thread space seems a bit extreme
And how You would pass that ID when it is needed in model observer?
got me there. Callbacks too. I suppose I'd have to manually call each function instead of using observers/callbacks
Okay, that's a decent list, but this a critical issue that seems to never be addressed: Depending on your programming experience, the "beginner" books should be a different choice. For a newbie: *Programming Ruby* ("Pickaxe") For a seasoned programmer: *The Ruby Programming Language*, published by O'Reilly (and edited by Matz and _why) The reason? The Pickaxe is far too patronizing for anyone who knows what a variable or an object is. It drags on with the shitty jukebox example. If you're experienced, that's so drawn out that it's unbelievably painful to read through. On the flipside, *The Ruby Programming Language* is closer to K&amp;R in being short and direct. It flat out tells you lexical and syntactical structure, then burns through the various elements of the language. It's also incredibly good as a future reference in case you forget something. Oh, and Matz and _why did the editing of *The Ruby Programming Language*. It is also the *authoritative* book for Ruby. (If you're unfamiliar, the canonical naming scheme for authoritative programming books is "The `X` Programming Language".) Personally, I think the list for a seasoned programmer should be this: 1. The Ruby Programming Language 2. Eloquent Ruby 3. Ruby Best Practices 4. The Ruby Way
This was always my favorite response to this question:" http://m.onkey.org/how-to-access-session-cookies-params-request-in-model
Step 1) Stop using observers Step 2) You no longer have a problem
Why the hate against observers? I think the observer pattern is a wonderful tool, so long as it is used properly (like all tools) 
And actually I'd revise my statement that you don't want ordinary CGI. The most performant setup for a ruby web application, that can be anything at all? "puts 'Content-type: text/html\n\nHello World''' served by apache, or another even faster web server of your choice that can run scripts. It'll blaze! Generally for a real app, for both dev efficiency and maintainability, you're going to want some kind of framework support, you're not going to want to do it all yourself with nothing but CGI. But if you did, it might still be the fastest. 
We (where I work) usually just set a class instance variable for stuff like this. class User cattr_accessor :current end Then in the controller: class UsersController &lt; ActionController::Base def login ... User.current = @current_user end end Then you have the current user in `User.current`. You can change the `cattr_accessor` to a Thread local variable, like the post seems to suggest (it's timing out for me, so I can't read it) if you have a multi-threaded environment. It's not "polluting the thread space", it's what it's for.
Seems kind of hokey and stinks of global variable. Why not just add a last_updated_by_id to model and set the user id when the data is updated. Then it's available to the observer and additionally acts as a audit record (although a limited one)
That's a very specific solution as mine was more general, but there's nothing wrong with that. I've used that on several projects as well. Again, I haven't been able to read the article, so if it's directly related to finding the user that updated a model just now, your solution is a much simpler one.
This.
I would highly recommend not using grape. There's little to no activity. Use sinatra instead.
That blog post was written by one of the Grape maintainers who is working on a startup with me (the Grape author). Grape was inactive for a long time but is now extremely active, just check the commit log. :)
Oh hey Michael, didn't expect your response. I'm glad to hear that you're back on it. 
Metaprograming is essentially code that writes code. It's so baked into the languages and popular gems that if you've done any "regular" programming in ruby you've probably used it without even knowing it. Consider the following class: Class Foo attr_accessor :bar end The `attr_accessor` here lets us do things like `foo.bar = "baz"`, but how did the `Foo` class get the `bar` accessor methods? Here, `attr_accessor` is a method which in turn creates the two accessor methods: def bar=(b) @bar = b end def bar @bar end So in the middle of defining a class, we stopped and called a method which in turn created two methods in the class we were defining! Stuff like this is used a lot in ActiveRecord and Rails, and is the basis for most of the "magic" done in ruby.
I'm using this for a class project. I like programmatically defining status messages but the extra nesting sucks. Maybe it would be better to just do start "this is beginning" some_code :goes =&gt; 'here' 100.times do |x| start "hello, i'm the number #{x}" result = serious_function( :serious =&gt; true, :how_serious =&gt; "This: " + "#"*x "serious" ) finish "later dudes! Oh, btw the result was #{result}" end finish "Peace!" Then the nesting would go like this this is the beginning hello, i'm the number 0 later dudes! Oh, btw the result was This: serious Peace! You could also add error messages start "Weeeee!" if something_bad_happened shit "EPIC FAIL!" end finish "EPIC WIN!" Just a suggesting... Maybe I will get used to the nesting. Edit: formatting
Ignore all that. My output is looking niiiiiiiiiice
&gt;"I'm going to learn ruby" If you want to learn ruby, start writing ruby programs.. Use the editor of your choice on your platform. I assume you're using windows.. If you're using Mac OS X, surprise, you're using a variant of Unix. Ruby luminary Russ Olsen recommends "Beginning Ruby" by Peter Cooper as a good starter book. All that other stuff implies you have ambitions of writing a web application.. That's a big learning curve.. Database, html/css/javascript views, web-app framework like Rails. Start small - command line app.. Ruby is my language of choice for that. I've written tons of useful stuff that I run off the command line. To get a decent working web app going, no substitute for learning all that other stuff.. Unix is the platform of choice for that. I understand it can be done on Windows but I've never tried it.
Thanks. I'm using OS X and macvim I have no problem with that learning curve, i'm already familiar with MVC, just haven't used it that much. Also bought that book like a day ago. Html/css/javascript is cake. I havent ever really done REAL oop though, so this is what I'm finding most confusing The one other thing cuaisng problems this whole time that was frustrating me to no end was I didnt know how $PATH worked, so all my versions were wrong. I also learned which rails which proved valuable, never knew about that command :) so far i now know git, brew, gem, rails server, ruby, mysql Do you know if i can use MySQL Workbench using the version of mysql installed with brew install mysql (from homebrew). i know at one point i had a preference pane but i hated that, i want just command line. mysql workbench doesnt seem to 'see' mysql though, even though its installed (v5.5)
&gt; I’m also absolutely amazed that this project has 0 issues on github Hmm, you sure that's not just cause hardly anyone uses it? Heh, I admit I hadn't even heard of it until this post. How hard/easy is it to use it with Rails? &gt; I understand why people like “the less is more” and “convention over configuration” but personally I would love to see more explicitness in Ruby ORMs. Metaprogramming is a dangerous weapon and we shouldn’t forget about this. So, so true, and AR is definitely a prime case. I think anyone who has done significant hacking on ruby using other people's fancy gems, has come to the conclusion that there is DEFINITELY such a thing as too much magic/metaprogramming/implicitness. 
Does anyone know if there is any ORM, that would just set up associations automagically whenever it found a foreign key in the database?
Method#source_location.
We use DM and love it, mostly. We've run into a fair few squeaky corners, but we've either learned how to workaround them cleanly, or have had issues fixed. Not all though... one major one still outstanding is a bit ugly, but hopefully that wil happen soon. Right now, if I had to move to another ORM, it would probably be AR, but I just don't like the way it uses those magic finders ike find_by_username, where DM allows you to iteratively build a query with a *really* clean syntax. I haven't looked too much at Sequel, but I felt that it was trying to achieve a different goal than both DM and AR, in that it actually looks a lot like raw SQL written in Ruby syntax, which (I would imagine) can lead to pretty verbose code at times. We're waiting for DM2 and hoping that at that point, AR would really not have a smidge of appeal. We can't really use AR without either writing hacky code, or performing *substantial* schema migrations anyway, since we're working with a really old DB schema. We are progressively "modernizing" our schema, but DM means we can get on with actually writing code and not have to rebuild our entire storage model in order to use Rails.
Also bugs me *immensely* how tightly coupled AR is with your underlying DB schema.
I've gone through the same progression, and I try hard to minimize the dependencies in my projects these days. You also have to pay attention the surface area of a dependency. There are a lot of rails plugins/gems that touch controllers, models, generators, tests, routes, and more. I stay away from these for the most part. 
I'd suggest [Unicorn](http://unicorn.bogomips.org/) and your favourite load balancer - nginx is a fine choice, Varnish may be worth a look for some very tweakable caching. Similar performance may be doable using multiple Mongrel or Thin servers behind them, but involves more configuration as each instance needs their own port. Ideally with Ruby 1.9.3. JRuby is also well worth a look. Performance is competitive and set to improve substantially in newer JVM/JRuby releases, and concurrent threading allows multicore support with no additional effort or duplicated processes, which helps offset the somewhat higher memory use. 
Agree with this article a lot. One thing I have found really helpful is breaking my app into separate apps/services. It is a lot easier to upgrade those gems when the application itself is doing only a few simple things (and thus has only a couple of gem dependencies). Also, it allows you to slowly upgrade your services. If there is one gem that is preventing you from upgrading then that service is locked, but your other services are free to upgrade. 
Except, sometimes when I try that myself, I just create my OWN dependency hell, between my own separate apps/services, if I wasn't clever/correct/careful enough in designing them. Is it inevitable that one gradually spends more and more time thinking through architecture and infrastructure, and less and less on actually writing code? I'd rather be writing code, really. Resisting pull to architecture astronaut. 
i would say more time refactoring, keeping it simple
oh yeah, the goals of all my too-much-architecture endeavors are always to architect things so they can be as simple as possible. :)
set the user attribute on whatever object is being observer. If you don't have that attribute, make it.
I thought AR did that if you get it to generate a schema from your existing database.
Not offhand. My Mac Mini has been broken for months. I use linux exclusively myself. Can you use the plain vanilla mysql client from the command line? E.g. mysql -u root -p If you can't manage that, then hit the manuals.. You can get a lot done from that simple client by the way.. oop... The Cooper book should cover that pretty well. Good Luck..
Tell me about it :) .. Ultraspinx to thinking sphinx.. Went through tons of pagination sollutions before will paginate ruled the rooster. Done maybe 4 different feedreader gems, switching cause libs wasn't maintained any more. And of course all the rails 1 to rails 2 to rails 3 conversions. Feels nice to be on the egde with the best tools though :p 
It's so creative that I have to give it a try.
Let us know what you think. We have a lot of plans for this in the recent future, namely bringing it up to par with everything dropbox can do, better web front-end, cross-platform, etc. 
I'll investigate that.
Why the use of git via shell access instead of a library like [grit (which powers github.com)](https://github.com/mojombo/grit)? Just curious. I feel like it would save a lot of parsing code and make expanding upon the web stuff MUCH easier. In general, really neat proof of concept. Can't wait to see what you guys do to expand upon it :D
[SparkleShare](http://sparkleshare.org/) is a very similar, but more mature project.
We have seen it, mentioned in our readme. We will be taking a different approach from them though with different goals. Namely focusing on simplicity, supporting windows, and exposing a versionable, well-formatted web front-end that allows for browsing, exploring, sharing, uploading and editing content all from your local computer.
Excellent point and I would expect us to switch over to grit from the shell commands in a future version. We have a lot of plans for expanding this project. Thanks for your input.
Lots of people use Sequel including myself and it is an amazing library.
lol sprockets.
This confuses me. &gt; this translates to – &gt; $(function() { &gt; return alert("jQuery Works!!"); &gt; }); &gt; So in CoffeeScript, intializing jQuery amounts to writing "$ -&gt;". Um, nothing in that output involves JQuery at all, so where did the 'initializing JQuery' come in. Does the author know what JQuery is? In the second code example. JQuery is involved... but without using document.ready? Really? Why?
If you look at wikipedia, the standard jQuery - $(document).ready(function() { // jquery goes here }); can be just written as - $(function() { // jquery goes here }); So the jQuery object can just be referred to as "$" if you have included jQuery in your page. I hope this helps.
I posted the very same question in SO to see if it catches up http://stackoverflow.com/questions/8345092/ruby-seria-parallel-port-manipulation
It also just occured to me that this is one thing you get with a NEW language/environment, like ruby was for most of it's community not too long ago -- when starting in a new field, you automatically get to ignore backwards compat, maintenance, dealing with old code (cause there IS no/very little old code, yet), and make everything as great as you can, from your experience with the LAST language you used. This is perhaps one reason why new languages with small communities seem to attractive to some people -- it's actually in part not related to any features of the language or environment itself, it's in fact it's actual _newness_, giving the developers of libraries/frameworks in that language the opportunity to do things "right", not like the crap they did in the last language they abandoned, without worrying about how it interacts with a non-existing existing ecology of code. Wait a few years, and that new language/environment will now have it's _own_ collection open source libraries that aren't as good as people want, and you have to either abandon them for something new (causing backwards-compat problems for people who are using em), or worry about backwards-compat and stabiltiy (slowing down your ability to replace it with what you now realize would be better). Easier to abandon the whole language/environment/community for a new one where you can start from scratch! Heh, programming innovation as a story of polluting one language/community/environment, and instead of fixing it up, abandoning the brownfield to despoil a new homestead instead. 
Here's the github site: https://github.com/davetron5000/methadone From the name, I am wondering whether this was earlier called "gli".
lol, i didn't understand the library name until i checked it out on github: &gt;Methadone - kick the bash habit and start your command line apps off right 
Dammit, another stupid gem name to go on the list: http://unethicalblogger.com/2011/11/13/ten-poorly-chosen-gem-names.html
I can't tell if this project is supposed to be a joke or not.
What is your goal? Learning Ruby just for web programming? Learning Rails? 1. You don't need a server for non-web scripts just run "ruby whatever.rb" or test stuff in "irb". For non-rails but still web related stuff you can probably just rub webrick on localhost. 2. rails is very complicated and probably not a great way to learn ruby. 
Definitely, definitely [The Pragmatic Programmer](http://pragprog.com/book/tpp/the-pragmatic-programmer). And then also [The Mythical Man-Month](http://en.wikipedia.org/wiki/The_Mythical_Man-Month).
I'd like to learn Ruby, for mainly web programming + Rails (when necessary), and I'm open to more than just web apps when I know more. I'm starting off with web apps because that's what I'm already familiar with, having coded front-end things for some time in html, css, php, javascript, jquery. In my mind I'm (very loosely) equating ruby/rails to javascript/jquery, so I obviously need to know the essentials first before I learn any gems/addons.
For really basic web apps you could also try [Sinatra](http://www.sinatrarb.com/). Very simple and easy to get started. There's also [Padrino](http://www.padrinorb.com/), which is based on Sinatra, but provides more functionality. Rails is the heavyweight framework and most feature-complete.
I would recommend something much lighter than Rails when learning Ruby from a web POV. Something like Sinatra (http://www.sinatrarb.com/) gets you closer to bare ruby programming without the bulk and magic Rails has when you're just starting. Save learning Rails for when you know Ruby better.
Okay, thats a great start thanks. I will go there and check it all out :) What does the 'thin' command do when I'm installing gems?
Learn basic ruby first. It's simple you can install it on your computer and then run your own scripts from the command line like so: rb /path/to/ruby/script.rb There are some really nice introductory books on Ruby and they can teach you some very useful techniques that can be used in a variety of languages. I started with [Learn to Program](http://www.amazon.com/Learn-Program-Second-Facets-Ruby/dp/1934356360/ref=sr_1_10?ie=UTF8&amp;qid=1322777217&amp;sr=8-10) and it helped loads towards understanding the language and ultimately understanding rails.
If you want to use Rails to learn Ruby, keep in mind there are other Ruby web frameworks out there too. Merb and Sinatra are examples of such frameworks. Learning Rails didn't make me learn Ruby as much as it made me understand other ways I could interact with it and use it to solve problems (specifically in the area of web development). Eventually I went back to learn Ruby so I could understand how to better leverage its power. With that being said, your setup of Ruby + Rails + MySQL should be a fine start to go with the "dive right in" and "learn as you go" style of acquiring skills and knowledge. Since Rails is a very popular web framework you'll be able to find more examples and answers to questions if/when you get stuck. I recommend you learn everything at http://guides.rubyonrails.org backwards and forwards.
All of the Ruby books listed here don't require you to be at a computer: [Best way to learn Ruby and Rails](http://astonj.com/tech/best-way-to-learn-ruby-rails/). (In fact they are my favourite types of books!) (The Rails books do need you to be at a computer.)
Could you choose a name that clearly describe what this library does/provides?
It's still not v1.0 so I'd be happy to take suggestions for a better name. Also, this is not GLI; GLI still lives and is for making different types of apps than methadone makes. And no, it's not a joke :)
[Thin](http://code.macournoyer.com/thin/) is a gem.
Get a grasp on ruby first, run through this a few times - http://tryruby.org/ 
I'll keep it simple. Sinatra is what you are looking for, you can use ActiveRecord if you need to access the database, there are other options too. I'm not sure I would use hpricot these days, I would use nokogiri along with mechanize for parsing web pages. https://github.com/tenderlove/mechanize
So, for a VERY simple 'web app', you COULD just put a ruby script in your /cgi-bin, and access it the same way you'd access anything else in cgi-bin. But since you'd be unlikely to want to develop a real web app this way, I'm not sure if you really want to start that way. But if you want to play around with basic ruby syntax hello world type stuff, and for some reason prefer this to just running it on the command line the normal way, you _could_ do that. But I'd recommend getting the pickaxe book or some other ruby book and just executing on the command line the normal way "ruby name_of_script.rb", instead of trying to do it through a web server. And ignore "ActiveRecord and hpricot", not sure who told you that. If you need an ORM, then, sure, ActiveRecord is one, usually used with Rails. If you need XML processing, use nokogiri actually, not hpricot. If you just want to learn ruby, don't worry about any gems you "should probably use" that doesnt' make any sense. You use gems to solve particular problems or provide particular functionality. If there's something you want to do that you suspect there's a gem that will help wtih (like parsing XML), then ask for suggestions on those particular things you want to do (nokogiri!). 
PS: I suspect now your background is with PHP, and that's why you're thinking of getting started with 'a web app'? Indeed, that's how you do it with PHP, and it makes sense with PHP. With a general purpose programming language, especially if it's your first, even though you want to jump right to the 'web app' part, it really makes sense to at least start out with some basic tutorials that have nothing to do with a web app. you could be done with that part in a couple days or a couple weeks or a couple months, depending on how much experience you have with other langauges, and how quickly you take to it. 
First of all. What is your programming experience? Is ruby your first language? Do you have any experience with Object Oriented Programming. Have you ever written a web page?
yes I'm the designer and front-end developer for my web company, I don't have experience with OOP other than when I learned C++ in highschool. I'm quite familiar with PHP for scripts though, not necessarily OOP. Also, after reading _why's guide I'm about halfway through and haven't had a problem understanding anything yet. I'll have no problem learning I just need a place to start that's not *too* overwhelming.
I read this I found its extremely stimulating _Why's Poignant Guide To Ruby_ http://mislav.uniqpath.com/poignant-guide/ Chunky bacon!!
Yes true, I assume this is referring to me by the way just you hit wrong reply. I've already bought 2 books on ruby, I've read countless guides and I'm halfway through _why's book which is my favorite so far. It all makes sense but I don't know what type of app to build if its not web related. I mean all in high school we made like a "candy store" app or a "height calculator" or stupid things like that, but those concepts I've got down well. I felt I should just go for something challenging. Lemme ponder on this a bit. What might be a more reasonable application in your opinion?
What's the easiest way to read/write to a mysql database, is there a gem for that to make it easy or is that easy to do in ruby itself. Also, thanks for the nokogiri suggestion! Great.
What about writing a simple blog platform? Or a simplified clone of Twitter, or Reddit?
The Active Record [README](http://api.rubyonrails.org/files/activerecord/README_rdoc.html) page might be the best place to look for ideas about accessing a database. You'll be learning it anyways for Rails, so why not look at it right away.
I'd say ... go through some Rails guide first. Make some simple blog app or something, that should give you a good idea of what goes where and how it all ticks. Next step would be to look into nokogiri and scraping, just wry a quick script in pure ruby for that. Once that works, you will probably be able to ask more precise questions, or just put it all together yourself.
You might try The Little Schemer and The Seasoned Schemer too. I think they're perfect for reading on the bus or subway.
Aha! If you've already done some basic ruby learning, and now you want to start on a web app, then that's the question: "What's the easiest way to get started learning how to do web apps in ruby?" Rails is the old stand by. Sinatra also has it's partisans, and is considered lighter-weight and simpler. I have not used Sinatra myself, so can't speak to it. I think you'd do fine starting with either one, and finding getting started tutorials for that one. I think you'll do better picking either Sinatra or Rails and getting started then trying to basically 'roll your own', which is what your original questions sort of led to. Whether you pick Sinatra or Rails will then kind of answer your question about "what should I use to talk to MySQL?" There are several options in ruby, and while both frameworks will _allow_ you to flexibly choose what you want to use, to get started I think the easiest thing to do is just to take whatever the framework you're starting with supports most 'naturally'. For Rails, that's ActiveRecord, and any rails tutorials you find will show you how to get started with ActiveRecord. For Sinatra, I have no experience, but I think maybe it tries to be less opinionated about a 'standard' (which sometimes can make it harder to get started with, because you don't have the experience to choose yourself when you're just getting started), but I think DataMapper is popular -- I'm less familiar with what a Sinatra tutorial you find on the web is likely to suggest, but if you find a good tutorial, just go with whatever it suggests. tldr; pick a ruby web framework, probably either Sinatra or Rails, whichever seems to appeal to you from reading their docs/tutorials, and then use whatever database access solution the best tutorial you find for whichever one has you using (For Rails it'll be ActiveRecord, I dunno about Sinatra). 
awesome, thanks!
I'd say the well grounded rubyist by David black. Barely have touched my computer while reading the majority of it.
I second this recommendation. Black's book is awesome.
And looking back at your original questions: * nah, don't bother with trying to pare Rails down, just ignore the files you don't need to deal with. Yes, it can probably be done, but it's not a beginner task, and you don't need to. * nah, there's no reason to look for a way of starting a Rails app that's easier than 'rails server'. There ARE some other ways, but they're all at least somewhat more complicated, not simpler, 'rails server' is the easiest simplest way to start up a Rails app. How you'd do that with something that WASN'T rails -- well, it would depend on what it was, and it wouldn't start with a Rails app! * * If you want to "execute simple ruby scripts locally", well, that's what "ruby name_of_script.rb" is for, but that's not a web app. * And, if Rails IS seeming too complicated or over-engineered to you, well, that's why people like Sinatra. But it may be that Sinatra is harder to get started with for a newbie, I'm not sure. Rails _tries_ to be as easy as possible for someone who has no idea what they're doing to get started with, in part by making a bunch of default choices for you rather than making you think through every possible thing you'd ever want to set up how. (whether it succeeds or not can be debated. :) )
I found the little schemer to be a fun book to read away from a computer. The puzzles are fun to solve in your head. EDIT: As below, the little Lisper is also acceptable ;-)
not what you asked at all since it ain't ruby, but the question gives me fond memories of The Little Lisper, although I'm not sure how well that would actually work without a computer to try stuff out on, but the book doesn't _mention_ computers at all! edit: Damn, I see two toher people already suggested The Little Schemer, presumably an updated/scheme-specific version of the old Little Lisper. Damn, that's a cool book(s), eh?
[Design patterns in Ruby](http://www.amazon.com/Design-Patterns-Ruby-Russ-Olsen/dp/0321490452/ref=sr_1_1?ie=UTF8&amp;qid=1322784459&amp;sr=8-1) is great for this. Much more lighter and entertaining than it sounds, and a fantastic introduction to both OOP design patterns and more advanced Ruby techniques.
that's my favorite book: http://pragprog.com/book/btlang/seven-languages-in-seven-weeks read it in subway or somewhere and play with the code with what you read and learned, it is not only for rubyists, but you have a well grounded view about your possibilities [or google for the pdf]
The little schemer was the required book for my discrete structures class last semester. I should've gotten it :-\ seems fun
As you're new to the language, I recommend Josh Peek's free [ruby-kickstart.com](http://ruby-kickstart.com), an amazingly fast and clear introduction to Ruby. It's ideal for programmers. Without understanding the language, chances are you'll get lost in the frameworks, gems etc. So, ruby-kickstart and then Sinatrarb.com for quick and clean barebones access to web functionality. Good luck!
how did you get through the class without it, if it was the required book?
We never really referred to it, to be honest. It was meant for us to read to learn Scheme, but I managed just fine without it - just from coding for fun and whatnot
There are two sequel books: The Seasoned Schemer &amp; The Reasoned Schemer. I have all 3. I can give a strong recommendation for the first two, haven't had a chance to sit down with The Reasoned Schemer yet, but I've read good things about it. It introduces logic programming in a scheme setting. I may get around to it this month, got a lot of hurry-up-and-wait coming up at work. Not actually programming but programming related is Mythical Man Month. It's not a bad read for engineering project management in general. Useful concepts to know even if you aren't running projects, can help provide insights into how to formulate requests to management for additional resources and the like as well as how to run your own part of a project. It certainly helped me to better articulate some of the problems I saw at a previous employer which allowed me to start pushing some improvements through and not just sound like a whiner.
you don't need to use the AR magic finders, I don't like em either. &gt; User.find(:username =&gt; 'foo) It also, these days, supports what I think is probably pretty similar iterative building with clean syntax with ActiveRelation, perhaps inspired by DM. You also quite possibly don't need any migration to use AR on a legacy schema, you can generally specify explicitly the things that otherwise are conventional to match your schema, you don't need to use it's conventional setup. There might be a few places that isn't true, but fewer than there used to be, not too many if any. It can still be a pain to look up and figure out how to do this though, since it isn't ordinarily done. There are plenty of things to be annoyed at with AR, don't get me wrong, but I think it's not as bad as you think in the places you mention. 
Could you elaborate on the difference between methadone and gli. Also, is this similar to vision commander/main. What is it doing better than the others. Thx.
I can't recommend this enough. I like to read in bed before night so I can lay awake in agony thinking of difficult to understand concepts. This book is perfect. It's a bit theatric, and at first I skipped a lot of his theatrics however after realizing a lot of it has STUCK with me when trying to figure something out (catepillars stabled to the table are arrays... block code is a 'tunnel' that slides down from the method into the block), i find that reading the theatrics are excellent ways to remember the book :)
1. ruby yourscript.rb 2. rack / camping / sinatra / padrino / ramaze / renee / harbor 3. https://www.ruby-toolbox.com/categories/orm https://www.ruby-toolbox.com/categories/html_parsing 
I would have to agree with this, and I would like to add that all of Dan Friedman's books are good. One in particular that I would recommend after *The Little Schemer* is *The Reasoned Schemer*. However, *The Reasoned Schemer* is no longer completely about scheme, it is instead focused on a logic programming framework built on top of the Scheme programming language. For this reason it is not very applicable unless you are specifically interested in the subject of logic programming, even if it is a good read. Edit: Wow, I should really look farther down the page before posting as it has already been suggested multiple times. I will add however another thought provoking book, Logicomix. Again, this book is not really related to ruby, or directly to programming, it's actually a historical graphical novel about early work on the foundations of mathematics and programming.
[Relevant](http://www.youtube.com/watch?v=35TbGjt-weA)
There was a good episode of Ruby Rogues about this lately: http://rubyrogues.com/metaprogramming-in-ruby/ Put it this way, it took them over 5 minutes to really nail down what they were talking about. Not their fault but because it's so hard to define in Ruby :-)
The Pickaxe is good if you're already familiar with programming but for total newbies? Within a few pages it's leaping into 'messages', functions, classes, methods, etc, without nailing down exactly what they are. If you're a *total* newbie, this is intimidating, though it's easy to forget what you once didn't know ;-) Chris Pine's *Learn to Program* is a Ruby book that goes from absolute zero on all of this stuff (as is my Beginning Ruby, as listed in the post).
Ahh, very good point. I remember reading the first few chapters of the Pickaxe and getting annoyed at how silly and verbose the examples were. I couldn't imagine why the book drawled on about basic concepts that anyone who knows OOP already understands. After the first chapter or two of nonsense, I just skipped to the chapter titled "The Ruby Language".
Not working on my MacBook Pro. Probably some terminal setting...
Currently it only supports xterm 256-color compatible terminals, I've tested with success in Terminal.app and iTerm 2. I'll add better TERM detection and support next time I get bored waiting for a database cluster to rebuild. :)
glorious!!
works with ruby 1.8.7 on ubuntu 10.4 server vm via ssh using putty! nyan 
OP - did you write this gem? It is pretty cool but thanks especially for giving me some insite into how to build such a thing.
I did indeed, in a moment of boredom. Inspired by Kevin Lange's original C implementation - https://github.com/klange/nyancat
If you don't have the `rb` command, it might be under `ruby`.
[code](http://www.amazon.com/Code-Language-Computer-Hardware-Software/dp/0735611319/ref=sr_1_1?ie=UTF8&amp;qid=1322844063&amp;sr=8-1) is really low level, but is awesome for getting a good core understanding of how things work.
Looks great. It's on my list. Thanks.
nicely done.
methdaone is for making a vanilla command line app, basically simplifies using OptionParser, but still provides complete access to the OptionParser API if you need it (compare to trollop which is much less powerful than OptionParser). GLI is for making a "command-suite" style app, like git or svn. It is very similar to commander, however GLI is actively maintained and has much more extensive documentation. main is a different beast entirely, but has many fewer features than OptionParser, GLI, or Commander. I will now plug my book that goes into more detail: http://pragprog.com/book/dccar/build-awesome-command-line-applications-in-ruby though it is mostly focused on principles and not so much tools.
I was wondering if I had missed some episodes, because both this post and the mp3 is labeled as 034, but the last one was 030.
It is for sake of simplicity that business logic and persistence logic of an object is located in the same class within Rails applications. In complex applications you will have a model which "models" the behavior of a domain object, and an additional model for persistence logic. However, in the majority of cases the extra persistence model will be unnecessary complexity, hence the decision to merge business logic and persistence logic in Rails models. None of that code should be in the controller. Use a Presenter class that will handle all of the logic of the initialization and modification of your models. The Presenter class should have a tiny API, and the controllers' job should be only to initialize the presenter with user-provided data, and make the presenter object accessible to the view. The view will access the presenter attributes which should provide the view with exactly the data it needs (we want nearly no logic in the view). Using this paradigm, the logic is moved from the controller into very testable Presenter classes which can also be reused in other Presenters as well. Picture this. A class is initialized with any necessary information passed as a Hash. You expose functions and attributes in the Presenter that allow you to customize your query and return the desired information. If you can fully exercise the Presenter from the Rails Console, then you've done it right. Integrating the Presenter into your controller will only take a few minutes, as all you should need to do is initialize the Presenter, and possibly call a few functions per controller action. I hope this makes sense, it is a paradigm that has works well for me to simplify overly-complex controller code in Rails applications.
OK, I understand the concept. Logistically however, where would you put all this code (helps if you are familiar with how Rails/Sinatra apps are structured) [https://gist.github.com/1424670](https://gist.github.com/1424670) As you can see, there are a whole bunch of variables that get call external libs and save the data to present in the views.
I 2nd LegionSB and jmoses, the idea got pounded into me through Rails tutorials
Before I break everything out, take a look at what I have so far. All the data for accessing the APIs is modularized into libs like so "APP/lib/foursquare.rb", "APP/lib/facebook.rb", etc. The application controller passes some params to those libs and stores the results into a whole bunch of variables for the view. You can see the code here: **[https://gist.github.com/1424670](https://gist.github.com/1424670)**
First, let me recommend to you that you get a macbook air. Then you will have a computer for your subway ride :-) Second, try "Godel, Escher, and Bach". This is some great reading.
I'm very curious to know what a 'fake program' is . . .
Place models in lib/models and presenters in lib/presenters. Require libs as necessary in your controller. I am not as familiar with large sinatra apps. The sinatra apps i have written looked much like your gist. For a small app, sometimes the controller is all you need, and you can sacrifice structure for clarity.
My commute looks like [this](http://discernwithme.com/wp-content/uploads/2011/09/01_crowdedSubway.jpg). I don't think it's possible :( Thanks for the recommendation!
This is fantastic! Thank's a lot. 
&gt; you have to forgive him because file systems were quite limited back then and filenames could only be a few characters long. The pattern was &lt;filename.ext&gt; - 8 chars for the name, 3 for the extension. That's not the case for the system the original `make` was created on. It was invented on a Unix system at Bell Labs. He's right that "*file" is a weak name choice for copycats, though. 
The source looks like brain**** ! :D Hey, i want my cursor back. Cursor vanished on Mac Lion in iTerm2 (xterm-256color).
I like this comment &gt;Rein Henrichs – 2011-12-02 17:29:45 &gt;But Josh... if these files don't have the word "file" in them then HOW WILL WE KNOW THAT THEY ARE FILES? QED. It does seem silly to append the word "file" to a file.
Thanks for the link. I remember reading your slideshow on writing cli apps in ruby a year or so back (it was related to GLI, iirc). I loved it, helped me a lot even though i did not get around to using GLI.
If you want to understand ruby outside of just a web context check out [Ruby Koans](http://rubykoans.com/)
I know personally I hate reading whole manuals. If you run into an issue and can't figure out out your best bet is to hit * [Stack Overflow](http://stackoverflow.com/) for pure development questions or it's sister site [Super User](http://superuser.com/) for unix and sys admin related questions. * IRC - [Freenode](http://webchat.freenode.net/) tends to be pretty popular for developers and sys admins, so you can try asking on the channels there. 
I'm a beginner and I retain information better by "doing" rather than reading. But thanks :)
I would try to run Sinatra under 1.9.2. Sinatra officially supports 1.8.7, but the rest of your dependencies may not. Also, since your are running 1.8.7 make sure you are requiring rubygems before anything else in your application.
Looks like dependency pollution Use rvm, Gemfiles and gemsets: http://beginrescueend.com/gemsets/basics/ Sinatra shouldn't require `mongrel_experimental`
well I really would like to do that... however my host told me they can't compile it without giving errors. Locally i just used homebrew to make a new installation of ruby in /usr/local/bin and its fine... i dont see how they are having so many problems with it. I also know homebrew is only for your local machine... what is the equivalent of doing that using ssh on my server?
Homebrew is really for installing *nix libraries to your mac that aren't already available on it. You should just use an official package repository like apt-get, rpm or yum, assuming you're running some sort of *nix on the server (such as ubuntu). What kind of host are you running with if they're installing the ruby instead of you, do you have root access to the machine? Using rvm on the server to install 1.9.2 is not a bad solution, I've used it for production servers (if only because proper packages for ruby 1.9.2 either haven't been made or haven't yet reached upstream package repos).
You'll suffer a lot less hosting rack apps if you have your own server, rather than shared hosting. I'd consider getting the cheapest plan at somewhere like linode.com, and following some of their howtos for deploying apps. http://library.linode.com/frameworks/sinatra/debian-6-squeeze This one shows you step by step how to set up sinatra for Debian 6, and the instructions are more or less identical on Ubuntu. It looks like a lot of work and things to know, but it's stuff you can use over and over (a good chunk of it applies for OSX too, which it sounds like you're developing on). Also, although it isn't done in that example, you should get in the habit of using rvm rather than whatever ruby your operating system has - this is way more flexible, allows you to manage gems for specific apps much better, and lets you try different types of ruby very easily. https://rvm.beginrescueend.com/rvm/install/ As a first step I'd also recommend setting up [virtualbox](https://www.virtualbox.org/) on your mac, and try doing some installs of Ubuntu, and running some Sinatra/Rails/Whatever apps there, so you can learn in a less breakable or expensive environment. I've also written a couple of little how-tos for deploying sinatra apps -: [With Unicorn](http://robmcgrail.com/code/simple-deployment-with-unicorn-nginx), and [with thin](http://robmcgrail.com/code/simple-deployment-of-a-rack-app-thin-cluster-over-unix-sockets-to-nginx). They're more just for myself, and full of horrible corner cutting, but might help out later on in the process. As for the actual errors you're getting, I can't think why you're app would be requiring mongrel_anything, unless your telling it to use that as part of your rackup command? I guess you should paste up your config.ru. Or perhaps just trying specifying regular old mongrel as your server in your rackup command, like: $ rackup -s mongrel config.ru Or thin, which also looks to be installed: $ rackup -s thin config.ru (Word of warning, if it turns out thin works, be aware that you shouldn't run an app on a single thin... it'll run really slow the minute more than one person starts using your app...) &gt; i dont see how they are having so many problems with it. homebrew will often download a pre-compiled copy of the thing you're asking for. Your server's repositories probably don't have a precompiled version of whatever it is, so they need to worry about dependencies and such. &gt; I also know homebrew is only for your local machine... what is the equivalent of doing that using ssh on my server? On Ubuntu/Debian the equivalent to sudo brew install x is: $ sudo apt-get install x You'll probably need to put the sudo in front more often than you do in OSX - ie. all the time. Good luck. 
thank you! i figured it out. now in furiously fighting with activerecord working with mysql and without rails. by the way i have a VPS, i just didnt know how to install ruby myself (locally it was easy.. on the server they have all kinds of bizarre setups though so I didnt even try) This error is driving me insane with active record though.. kind of discouraging for learning ruby when ive spent days just getting something to 'start' working, let alone writing code yet. every single refresh i get new GEM ERRORS. fuck you gem fuck you.
Right, well if everything is working on your local machine, I'd just keep working on your app there, and when you have time I'd ask them to wipe your VPS clean with Ubuntu, and follow some instructions for installing ruby with rvm: http://www.giantflyingsaucer.com/blog/?p=1792 If you're not having errors on your local machine, there's no reason you should have them on your server - you should start with a clean slate and install the exact same gems on both machines, and things should just work. Also, if I was you, I wouldn't even bother with mysql at this stage, unless you're writing something that writes to the database constantly. I'd try using sqlite3, like rails does in dev mode. This just saves you having to deal with a mysql server until you really need to. Finally, if you're writing a beginners app in Sinatra, I wouldn't use activerecord either. All my sadest ruby times have involved active record. If you're not too invested in it yet, I'd try Datamapper to start with: http://datamapper.org/getting-started.html You should read that getting-started page, and consider giving it a try. It's light, simple, a lot of Sinatra code uses it, and for whatever reason I always feel more... in control with it.
wow awesome, thanks so much. i will look into all this. I really liked how activerecord worked with Classes relateing to tables. That seemed extremely easy, and relying on convention rather than specifying it in. does DM do that?
PS i just fixed it with this: sudo ln -s /usr/local/mysql/lib/libmysqlclient.18.dylib /usr/lib/libmysqlclient.18.dylib my eyes hurt so bad right now from this. all i think about is ruby all the time. i think im obsessed
Using a serial port is pretty basic, here is a simple example I wrote for interfacing with a switch and LED: require 'serialport' @serial_port = SerialPort.new "/dev/ttyS0", 9600 @serial_port.dtr = 1 # Turn on a constant outgoing voltage @serial_port.rts = 0 # Turn off LED power def switch_active? @serial_port.cts == 1 end def led_on? @serial_port.rts == 1 end def turn_led_on @serial_port.rts = 1 end def turn_led_off @serial_port.rts = 0 end def toggle_led led_on? and turn_led_off or turn_led_on end Simply wire the DTR and CTS pins to a switch, and RTS and signal ground pins to an LED. To use the data pins you would need a microprocessor hooked up to interface with.
As mentioned elsewhere, Nokigiri is good for scraping apps, as it is more feature-complete than hpricot. If you must automate tasks on a website, as opposed to simple scraping, you can use Mechanize, which requires Nokigiri. Mechanize is an improved, ruby version of the old Perl Mechanize. For really heavy or complex web automation, nothing beats Watir. It's not the fastest, because it actually operates through a browser and so you have to wait for page renders. But it does things the others simply can't. 
wow thats awesome about mechanize. i heard people mention it before but didnt know what it did
Welcome to `r/ruby` :P
Because there might be cases where you want new global behavior out of some classes, but don't have control of (or don't want to change) all of the code that might reference those classes.
So-called "monkey patching" (mixins) has definite advantages over certain other paradigms, like multiple inheritance. With multiple inheritance, it is easy to, for example, create ambiguous or self-conflicting class definitions. Mixins do not eliminate that possibility but it is greatly minimized. Monkey patching is a derogatory term, and mixins really do not deserve that label. Yes, it has its problems, but it is still an improvement over much of what has gone before. Mixins are also a part of what gives Ruby its dynamic nature: any class can be modified on-the-fly. You can make Ruby re-define itself as it goes... this is an extremely powerful feature. While many people do not use that functionality to its fullest (or even at all), the fact is that most programming languages cannot effectively self-modify and it brings capabilities beyond what those other languages allow. (At least, allow in any reasonable amount of time or space.) On the other hand, many people think that is something that "should not be allowed" and that it brings something of an element of anarchy to the table. Personally, I think that is a good thing. Let those who want control or "discipline" program in Java. I'll take the greater power and flexibility of Ruby any day. Also, as the earlier poster noted: mixins are excellent if you want to modify the way something works for a particular project, without actually digging into, modifying, and trying to document changes to the code of core classes. The need is simply eliminated. Instead, you have a module file with a few lines of code and (preferably) some comments about why you bothered to modify a core class. This is vastly more easily maintained than hacking your base code, and you don't even need to remember that you did it, so your next project does not hit bugs from your messing around. The basic differences between using a mixin to make modifications, and creating new classes to extend other classes, are: (1) mixins do not create extra disk or memory resources that must be maintained, as separate classes do, especially classes that extend other classes, which are often bloated and redundant, because (2) you are actually making modifications to existing classes, and (3) you are not limited to simply "extending"... you can modify at will and even simply remove or replace functionality, which is more useful than it may first seem. Does that seem less "disciplined" or structured than most OO approaches? You betcha. Yahoo, cowboy! 
I think you are using the term monkey-patching incorrectly. mixins and monkey-patching are not the same thing. class Bob include SomeMixin end ^^^ that is NOT monkey-patching. class Object def my_crazy_shit # do something end end ^^^ that IS monkey-patching. So why use mixins instead of inheritance or composition? Because it's cleaner in a lot of cases. You can only inherit from one other class, but you can mixin more than 1 module. I'd flip it around and say that for this reason alone you should default to mixins and if you realize you really need inheritance, then and only then use inheritance. Composition is a different animal all together. 
I'd just like to point out that few people give Objective-C crap for having categories, which are essentially the same thing as mixins. As long as you use them carefully they are not universally considered a bad thing. (it seems like Perl, Java, and Python folk are the ones that most often sing the "Ruby sucks because those idiots *like* monkey patching" line. each for different reasons, some more right than others) Problems usually only arise when libraries use mixins, as you as a user of those libraries now have to make sure that they all play nice together and that none of them step on the toes of any other. If you are writing one-off mixins for your own code bases and are careful not to clobber native methods or methods added by libraries that use mixins, you will be fine. The key point here is carefully. There are a lot of careless devs out there and so saying "don't do that" by default is not necessarily a bad thing, but it leads to people saying "never do that. you will outsmart yourself and get bitten!" ... they may or may not be wrong on that.
Exactly. Original Unix filesystems had a limit of 14 characters per filename and didn't have any knowledge about so-called extensions. "config.make" would have been a completely acceptable filename back then. Also, "config.make" would be an even worse name for a makefile. It says that it is a configuration file of the "make" program, not a recipe for getting your stuff built and deployed to production.
You're entirely right. However, "monkey patching" is rather poorly defined. There was a debate over its meaning in Ruby at http://stackoverflow.com/questions/394144/what-does-monkey-patching-exactly-mean-in-ruby A common approach in Ruby is to consider overriding existing methods to be monkey patching, but adding methods not to be, even though most non-Ruby definitions would include both. Going with the most general of definitions, such as "a way to extend or modify the run-time code of dynamic languages" is problematic in Ruby, because it would cover too many practices that aren't inherently bad. I guess the other argument, of course, is that many things can be considered monkey patching but that monkey patching *isn't* inherently bad. I'll let other people argue that one ;-)
"Monkey patching," as in changing the methods in the actual classes, isn't used all that often. It just has too much possibility to break things as its effect is global. Using a mixin or singleton class to limit the scope of that method change is perfectly fine. It will only affect your code and it's up to you to understand what's going on in your code, so I really don't see any major problems.
Depends entirely on the context - what you wrote does not entirely make it clear. class Bob include SomeMixin end might not be monkey-patching, but class Object include SomeMixin end is. Whether you monkey-patch with `def` or with `include` makes no difference (except for reusability and maybe readability), rather whether the class is being created or updated (or according to some people, whether methods are being added or replaced).
The language is giving you the flexibility to move methods to where they belong, so you can avoid code smells such as Feature Envy. You don't have such a strict split between language designer &amp; language user. A good example of this is Symbol#to_proc, which started as a monkey patch, and made it into the core language. Another case would be where Ruby's literal syntax means that although you could subclass or wrap an object, it would be uglier: "A string".monkey_patched_method Vs. MySpecialString.new("A string").monkey_patched_method
Subclassing is safer in that it does not override an existing class, however, sometimes you need to override an existing class. An example of this is some of the extensions the rails framework adds to basic objects such as strings. Methods such as 'camelize' and 'underscore' are used throughout the framework. They could have done something similar to: RailsString.new("CamelCase").underscore but it's much cleaner just to do: "CamelCase".underscore
Another case for monkey patching is if you use a third party library, the code is already using the existing class everywhere. You could subclass all you want but the third party library would still use the original class. If you need to change the behavior of the third party library by modifying the class, monkey patching is the way to go.
Thanks for the tip, it makes sense.
Agreed - it's a sharp tool, to be used carefully. I think Jim Weirich gave a presentation around these sort of issues ( maybe this one? http://confreaks.net/videos/374-rubyconf2010-the-polite-programmer-s-guide-to-ruby-etiquette ) and how to mitigate some of the issues with clashing methods.
I use monkey-patching as sparingly as possible, but I find it useful for two things: 1. If there is a bug in some gem I'm using. Often, I need to monkey patch because the gem is locked to some version by necessity (another gem depends on it, or the new version has breaking API changes), or because the bug I'm looking at hasn't been fixed. I'll submit a patch, but I really dislike using custom-built gems because in my experience, it's more of a maintenance headache than monkey patching. I document the crap out of it: what the bug is, why it exists, what the monkey patch does, tracker numbers if appropriate, and under what circumstances the patch can be removed. If possible, I'll detect the version of the library and spit out warnings if the version increases, saying the patch should be looked at. 2. To add logging. For instance, in one application, I've added logging code to all net/http calls because I very often want to know details about the request for debugging, or timing information. One-off monkey patching to add logging can also be very useful. It's a balance. You're adding a potential maintenance problem (tight coupling) and compatibility issue, and you need to weigh the risks and benefits. It's more okay for an application to monkey patch than a gem, for instance. It's more okay to add methods than change them. It's more okay to change methods to fix bugs or add minor side effects (logging) than it is to change the API.
this highlights why it's a powerful and also very dangerous thing to do, though. what if your monkey patch fundamentally changes behavior (which presumably it would, or else why wouldn't you just add a new method?) -- the internals of whatever library might not behave like you'd expect them to with the monkey-patched method...
&gt; The basic differences between using a mixin to make modifications, and creating new classes to extend other classes, are: (1) mixins do not create extra disk or memory resources that must be maintained, as separate classes do, especially classes that extend other classes, which are often bloated and redundant, because (2) you are actually making modifications to existing classes, and (3) you are not limited to simply "extending"... you can modify at will and even simply remove or replace functionality, which is more useful than it may first seem. Huh? Mixins take the same negligible disk resources regular classes do, they take similar memory to a regular class does (a mixin is a `Module` that has to be loaded, organized, and stored just like a `Class`, which is a kind of module), and you can add, remove, modify behaviors when subclassing. The reason I use mixins is to provide a home for modifications/feature sets for other classes, allowing them to be tested independently of the classes they modify. `ActiveSupport::Concern` provides a nice API to manage these: http://api.rubyonrails.org/classes/ActiveSupport/Concern.html http://www.fakingfantastic.com/2010/09/20/concerning-yourself-with-active-support-concern/ http://opensoul.org/blog/archives/2011/02/07/concerning-activesupportconcern/
great points, I'm assuming that monkey patching is inherently ~~bad~~ risky and that the definition has to be something more than vanilla mixins. The working definition I use, which I didn't see on the SO page, is this. There is one primary class definition, and changes to the class outside of that primary definition is monkey patching. Think of a rails model app/models/post.rb. Anything defined in there is not a monkey patch. Changing that class in some other file is a monkey patch. My reasoning is that ideally i should be able to see the functionality of a class from the class definition or through the inheritance chain and mixins used in the primary definition. Functionality added in other places can be hard to find and/or know about. This is what makes monkey patching risky. I need to think this through a bit more and write it up in a more polished form. 
Deploying to a Windows server? You might have better luck going with a *nix flavored host.
hell no. lol. its cent os 5 i believe
Sometimes the architecture of the dependency you are using does not allow you to make the change/addition you want by subclass, composition, or (careful use of) mix-ins. I think that's the _only_ legitimate reason to use monkey patching. And even there, it should only be a stopgap until/unless you can get changes into the dependency to support what you need. (Sometimes easier said than done with a very complicated dependency like Rails). Why do people use it even in other circumstances? (And they do, Rails 3.1 builder monkey-patching a method into String conflicts with Hpricot doing the same). Because they are unfamiliar with OO design? Or because it can be quicker and easier than a good OO design, with the trade-off of less maintainable, forwards compatibility problems, and conflicts with other code? 
There's some debate as to whether introducing new methods is truly monkey-patching. Some say that it's only monkey-patching if you're overriding existing methods on a class you don't own. I'm not really sure of my position on this topic yet.
I agree with d11wtq but i don't see ActiveRelation so nice. 
*[mmm trunk](http://i.imgur.com/3qabb.gif)*
&gt; There are good efforts surrounding the improvement of Rails test speeds, but I would like to suggest that these are just working around a larger problem: booting Rails is slow. If we can make Rails boot times fast, I think it would eliminate the need for testing outside the rails context. I agree wholeheartedly. Let me know if there's something I can do to help!
If one of the subshell problems is: `git ls-files` in the gemspec.... ...rather than replace it with a generated gemspec and it's maintenance issues, I'm curious about replacing it with a non-git-aware pure-ruby Dir solution instead, which in most cases is good enough. Even if it had to be Dir with a blacklist of excluded files duplicating the .gitignore, I'd rather repeat myself there then have to regenerate the gemspec all the time. (Crap, if you _really_ wanted to, you could read and parse the .gitignore in ruby yourself. Not sure whether you'd really get a performance advantage after all this, but it could be tested). 
[Relevant RailsCast.](http://railscasts.com/episodes/287-presenters-from-scratch) RailsCasts is starting to be like XKCD, where there is a relevant RC for most situations :)
Is there an English link to this page. I could not find one. Thx
This guy has the best idea http://www.reddit.com/r/ruby/comments/mqcrd/using_the_decorator_pattern_to_simplify_your/c333ir7
It may be that both are right and that the url structure reflects one or the other. I wouldn't stress about it, seems you are getting it mostly right
&gt; Models should be viewed strictly as a data integration layer. They interact with your database at a very high level, and do some data manipulation tasks. Ideally, business logic should be stored outside of models in an additional layer. Wrong. Model is for business logic. It doesn't even need to store data anywhere. Just because most Rails tutorial only have model class extending from ActiveRecord doesn't mean you cannot have pure Ruby class as model, too.
I don't completely follow, and there often more than one way to model a given situation -- it can depend on exactly what you're going to want to do with it. And when you're doing modelling like this, it's actually more about rdbms schema than OO. So one important thing to keep in mind is whether a relationship is 1-to-many, 1-to-1, or many-to-many. Does a category belong to only ONE city? Any given category goes with just one city, and a different city needs a different category? Or, when you add a new category, do you need to add that one new category to ALL cities at once? If the latter, then category to city is many-to-many. belongs_ to is many-to-one (one city has many categories, a category has only one city). Again, this is as much about relational database normalization than OO. You might want to pick up a good book on relational databases, and pay attention to the chapter on normalization. I'm not sure exactly what the 'forums' adds to it; it seems like you indeed could model it with just posts, cities, and categories, yeah. Esp if each city has exactly the same categories. But maybe adding 'forums' makes something easier, I dunno, ask your friend why he thinks it should be there. The 'why' is more important than the 'what' for learning, there isn't neccesarily one right answer (although there are some wrong ones). 
I disagree with your friend. There should be only three models -- `City`, `Category` and `Post`. Still, `Post` `belongs_to` both `City` and `Category`. And `Category` does not belong to `City`. This allows you to query all antique-related post in every city. Think of it as `City`, `Gender` and `Person`. You will clearly see that `Gender` does not belong to `City`. `Gender` (or `Category`) is in no way dependent on what `City` it is in. And a `Person` will be either male or female and lives somewhere (belongs to both `City` and `Gender`). A guy has gender of "male", not "San Deigo male". `Forum` is just a view on `Post`s data, i.e. view of all `Post` in a certain `City` **and** of a certain `Category`. 
Responding over there, too.
The problem with this in Rails is that it doesn't give you URL helpers, which are often useful in rails decorators.
Wouldn't they work if you override the `class` method to point to `__getobj__#class`? Haven't tried it but it seems like it should work.
Either way, class names should be singular. So, it should be class Post, not class Posts.
I'm not sure, I just know that this was really complicated. Jeff was showing me some code for Draper early on, and it was crazy... Even then, this is how gems are made. First you have to remember to do this every time, then it's something else, and now you've got half of a gem in the works, you know?
Interesting, I just tried it in the rails console and it worked without overriding `class`. &gt;&gt; app.post_url FancyPost.new(Post.first) =&gt; "http://www.example.com/posts/1" That doesn't mean that it works everywhere but at least `polymorphic_url` works on a SimpleDelegator instance. 
Hrm. It might also be that newer versions of Rails provide nicer access to this kind of thing.
I think the example of CachesCoordinates is really bad -- unless you're reusing that functionality elsewhere, sticking it outside of the model and including it is just more confusing. Models grow, and it becomes difficult for somebody not immersed in an application to maintain a mental model of what all these private/internal functions do -- but that's just the nature of the beast. "refactoring" by moving code that is only used by a particular model outside of that model isn't helpful (though it is very helpful if you find many of your models doing the same sorts of things again &amp; again)
As someone who contributed to CakePHP in it's early days and worked extensively as a PHP developer before discovering Ruby I can share a few points. I found the Ruby syntax to be cleaner and easier to read when compared to PHP. The community as a whole (Ruby, Rails, Sinatra, et al) tend to be more welcoming and helpful; additionally they encourage best practices. Ruby has gems, or libraries, that can be easily managed with a variety of tools, my favorite being [Bundler](http://gembundler.com/). The community has been a long time advocate of proper testing as is evident by the vast number of Ruby testing frameworks. The last I checked Rails was outperforming CakePHP in almost all categories. While CakePHP has worked tirelessly to ~~copy~~ imitate Rails it has fallen short and resulted in a large, bloated and slow framework. While I enjoyed my time contributing to Cake I found that certain community members attempted to rule the project with an iron fist regardless of the impact on the project or community. Cake has consistently been a step or three behind Rails; they are reactive not proactive.
You found a good example of "real world" vs "so it should/ could be done". Learn from it :) Just ask yourself the question: What most people would do on craiglist? :)
honestly, unless all your devs are fluent in ruby (and familiar with rails) i think it's going to be a hard sell. the end result - a web-dev shop running ruby/rails is definitely "better" than a web-dev shop running php (for a lot of reasons -- higher level of talent attracted, better test-based design, more maintainable code, etc) but getting there would require firing &amp; hiring a bunch of new devs, or paying to train all the existing devs in a new technology. that said, i'd say start small -- do you have some internal tools that you could "port" to rails? do that and show your senior engineers/CTO how the end result is much preferable to the php version. that gets the door cracked, at least.
I think using a dir glob would probably be slightly slower than the generated gemspec, but definitely faster than the subshell. I just prefer using a generated gemspec because file add / delete don't happen *that* often, and I always mess up my dir globs (editor temp files, random scripts I leave in the repo, etc). I think I might be a messy programmer! :(
Look at my fork on github and figure out how to integrate systemtap! ;-)
/r/lolphp
I have been a fan of Ruby for many years and have used it on a number of "Professional" projects. I currently work for a company where we use it for US Government projects including DoD projects. This should ally any fears that it's not mature, or not used on "real" projects. I like it and we use it because you can get outstanding results with less investment in time and tools. You don't need much in the way of tools (actually many people like vim which is free). Additionally it is very easy to learn and is a very simple structured platform. At the same time you can extend it as you wish, using caution of course, so it can also be used on more complex problems. Only thing to consider is if you are a Windows shop you will need to switch to developing and deploying on something else. Rails is well supported on OSX and any current Linux/UNIX variety. Some will tell you it works on windows just fine, but you WILL have issues. 
Internal initiatives are always a great way to learn new a technology stack!
cool, thanks. Me, what I always mess up is forgetting to regenerate my gemspec at the right time. (My projects may add/remove files more often than yours! But actually, it's the thing that doesn't happen that often that's even easier for me to forget to deal with!) I LOVE the gemspec that doesn't need to be regenerated (and thus doesn't create a commit in the repo either) every time the list of files in the project changes. I'd be loathe to give that up for even 100ms of start time. These days, with bundler being able to use 'edge' (or any given commit point) gems direct from github (or disk), it's important to have an accurate gemspec at pretty much every commit, not just at official release points. Or you'll REALLY confuse people trying to use your gem direct from repo/file system checkout. 
Don't sell your company on Ruby. Languages are tools nothing more. Sell the company on an internal project which just happens to be designed using Ruby. Show them the improvement in testing that just happens to come along with this project due to the attitudes present in the Ruby community. Show them any benefits you've come across. That will sell them much more than any language feature or functionality comparison.
Exactly. I have written many models, in Rails apps, that do not interact with the database. Sometimes I do eventually create tables for them, but there is nothing saying your models are only for interfacing with the database.
&gt;Only thing to consider is if you are a Windows shop you will need to switch to developing and deploying on something else. Rails is well supported on OSX and any current Linux/UNIX variety. Some will tell you it works on windows just fine, but you WILL have issues. this 1000x over.
It runs on the jvm
Or crap, what about using the ruby-git gem (C compiled, uses git binary), to still actually get the 'git' list, but live without a generated gemspec. https://github.com/schacon/ruby-git Wonder if THAT would be fast enough. It's not a subshell, but it is an external process (I guess). 
You use Ruby on Rails for DoD work? I have to call shenanigans. Having just been the part of a large government modernization (JEE) that subsequently inherited a number of Rails projects I can say with absolute certainty that Rails is a prohibited technology. This has nothing to do with the maturity of the language or framework but rather perceived security vulnerabilities or limitations. If you're **really** using Rails you need to be very aware the dangers that wait ahead for your team and company. We inherited those projects because DoD fired the previous contractors and immediately began an investigation into whether they knowingly violated the rules set forth for acceptable technology. I was a part of numerous conference calls where Feds were advocating a "Congressional investigation into these wrong doings". 
I think it could be helpful, even if you're not using code the outside of the model. It's good to separate concerns that ought to be separate, so you can deal with less code at a time, test (and verify tests) more easily, and generally keep a tidier code-base. There's definitely some threshold where it doesn't make sense to separate things, but if you start having a dozen or two methods, it could make sense.
Have a look at RubyMoney readme file. Simply be redefining the currencies there, you can easily handle things with a bigger precision : Money::Currency::TABLE[:usd].update({ :subunit =&gt; "1000th/Cent" :subunit_to_unit =&gt; 100*1000, }) Should already switch your USD money to use 1/100000$ as the base unit, while still having correct calculations everywhere. You can also use [cashrb](https://github.com/semmons99/cashrb) if you're only insterested in one currency, using the `:cents_in_dollar` parameter. 
Not natively. JRuby is run through an interpreter on the JVM. If you were looking for JVM performance there are vastly superior tools to Ruby as Twitter has demonstrated with their switch to Scala and Java.
Why do you feel you should make the switch? The language is just a tool to get the job done, and if they already know PHP and are using an MVC framework like Cake, it seems a little silly to switch. My company is straight up Ruby/Rails, and I love it, but it's definitely got it's share of issues (speed, deployment, etc.)
ya, that's why I mentioned that we should fix this in Bundler. If Bundler could better understand the checked out repository, or even generate a gemspec when it checked out (or updated) a git repo, then we wouldn't need to have the gemspec checked in. I'd prefer to not check in the gemspec, but if I want to work with bundler and edge deps, I must.
JRuby is one of the most performant Rubies, stop spreading your FUD. Also, 'not natively' is not true, it's just as native as Scala. Twitter was bad at writing Ruby code, they tend to think in static types. That's perfectly okay.
He might be using it for an internal project, or perhaps as a gateway to an already established database. I can imagine a ton of situations where Rails is completely appropriate and within the DOD guidelines as they have been explained to me. Do you have a reference for the DOD ban on Rails? This is of great concern to me.
Everybody gets to ride a unicorn to work. On a rainbow.
I never said JRuby was slower than other ruby implementations. Also, 'not natively' is entirely true. Scala, Java, Clojure, Mirah, et al produce JVM byte code; JRuby does not. From [Wikipedia](http://en.wikipedia.org/wiki/JRuby) -&gt; "JRuby is tightly integrated with Java to allow the embedding of the **interpreter** into any Java application with full two-way access between the Java and the Ruby code" JRuby runs in an interpreter whereas the other languages I mentioned do not. 
^this Most are scared/lazy to learn a new tech especially if they are comfortable/lazy with the one they are currently using. All it takes is one detractor and you will find the battle non winnable. Excuses will range from: hiring, training, deadlines, etc.. Here is the breakdown: 1) Scenario 1, outright rejection relating to FUD. You will be looked upon as the "FOTM" guy and the conversations at the x-mass party will be awkward. 2) Scenario 2, company decides to port something over to rails. One team rolls over to ruby giving managers time to sweat on missed goals as you re-factor. Then the first snafu the team hits with respect to ruby will immediately determine that the decision wasn't sound and that the team should roll back. You will be looked on as the "FOTM" guy and conversations at the x-mass party will be awkward.. The only way to win in the corporate world is to: 1) Join a company that is already using the tech 2) Be in a position to promote the change (team lead, manager with tech background) 3) Work on it at home
The document I have is within the DoD intranet, I cannot share it with you. I will however ask one of the more senior program managers if he can direct me to external documentation. Another similar document is the DHS TRM (technical reference model) but I cannot find a complete listing of that online either. As for the code, none of our code was going to be public facing. We were told that the language and framework were unacceptable for **any** DoD development. Agencies beyond DoD also reference these guidelines, FEMA comes to mind as they also had a similar run in with a number of RoR projects. This was a very hot issue as we received quite a few RoR projects that were previously unaccounted for in our modernization efforts and they needed immediate attention before we could redeploy them into the new production data center. This program (in this context program refers to a collection of large projects) was no small undertaking by any stretch of the imagination; the total program costs exceeded a billion dollars for the modernization. We had ample access to the folks behind DoD technical decision making and were unable to secure even temporary exemptions to run the Rails applications in the development. 
Hmm, I don't think bundler is broken here. I don't think it makes sense for bundler to generate a gemspec automatically -- how's it going to make the right choices about what files to include, let alone what version to consider the copy, or the other metadata in a gemspec? If it was possible for bundler to guess at all this stuff without a gemspec.... then we wouldn't need gemspecs at all, we could just upload source to rubygems, and gems could do the same thing you are suggesting bundler do, just automatically generate a gemspec. But a gemspec has actual important metadata in it that's not guessable from just the source. I think bundler is doing exactly the right thing in looking for a gemspec in source, and I suspect any attempts to 'fix this' are going to make things worse. You've got to describe what files are included in the gem, one way or another, for both rubygems and bundler. If you want to just include ALL source files in the gem, that's easy enough to do with a Dir blob. If you don't, well, you're just going to need to deal with getting them described in the gemspec, either by generating it or by dynamic code in the gemspec. I _greatly_ prefer dynamic code in the gemspec myself, it has many advantages. Also note that the dynamic gemspec is, I'm pretty sure, NOT executed for gems you actually install from rubygems. For those, there's the built gem package, the end, right? The dynamic gemspec is only executed for things you have source for (the gem you are working on right now, or edge/git/file-system checkouts), right? Because there's no actual built gem package in this case, so bundler needs to know how to do the equivalent of building it. 
JRuby has a JIT that emits bytecode. Also, you [can compile it](https://github.com/jruby/jruby/wiki/GeneratingJavaClasses) which _also_ generates bytecode. 
Actually this is half wrong. JRuby is a mixed-mode runtime. By default, it interprets and then JITs to native Java bytecode. So it certainly does not need to run interpreted at all. It is just beneficial to run interpreted until hotspots are found. It can pre-compile all code though.
Curious about the deployment issues, I've never run into any issues with Capistrano.
ORM models are just abstractions of database tables or the equivalent in NoSQL. Your first step is not to try to "learn ORM", but to learn how to use the data storage of your choice. Once you know how to relate tables to each other, for example, all you need to know is what belongs_to and friends map to in database speak. Don't try to learn this from the top down, you'll just be confused because you don't understand the components that make it work underneath. You don't need to know how to apply the 25th normal form, just the basics of how tables relate to each other and how to combine them to get the results you want.
SparkleShare also requires Mono, which is a deal-killer for me.
I'd encourage you to work on philosophical and process issues, rather than tools issues. How well is your code tested? How often do you release? How well are your servers managed? Switching to Ruby won't fix any of those issues.
Almost as bad as folders that have a name ending in "folder", or directories with a name ending in 'dir'.
I disagree—it makes it easier to test that specific piece of functionality in isolation and it makes navigating the code base easier. I'd rather look at the top of a 200 line source file to find a reference to the file a method is in rather than scroll through a single 2000 line file. Dismissing those sorts of conveniences as being "the nature of the beast" is counter-productive and should be considered a regression in best practices.
The biggest problem with that article is the adherence to the idea that there's only four places to put code. My app directory looks something like this: app/ assets/ concerns/ authenticated.rb # devise hooks for controllers that need authentication controllers/ helpers/ mailers/ middleware/ models/ support/ form_inputs/ # custom simpleform input definitions uploaders/ # carrierwave views/ Rails is a starting-point, not a rule book.
God speed, OP.
Woot, just submitted. It seems to imply multiple submission are fine, is that true? What kinds of talks are you guys looking for?
I agree, and don't forget about `lib/` -- and even (dun dun dun) -- vendor! Split subsections of your app into a gem, load them separately! It's unfortunate to see the state of ruby devs who forget all the ruby they learned and be totally bound up to Rails. 
awesome talks!
That is some seriously funny stuff. I love the reply train that ensued.
Hey weird, I wrote one of those emails. The post is embarrassing to the recruiter and messing up the email compounds it. I sincerely hope that one of the other companies that piggybacked on the reply-all train ends up getting some interviews out of it. I was laughing out loud by the end. Almost worth having my email spread around without my permission.
Yeah, submit as many as you'd like. Though, you'll probably only get one accepted! Who knows though, we're up for breaking rules. Glad to hear you've submitted! As far as talks go, pretty much anything goes. We do love to see talks that integrate beer in some way, too.