I'd put "start building" close to the top of those paths rather than at the bottom. You don't actually need most of that stuff, including half of the "required for any path" list, to create something basic that works. I think it's important to actually understand the basics before you start piling on everything else, and I imagine most people would feel like they're drowning if they try to take it all on at once.
&gt; So the half that is an encoding isn't special to ASCII-8BIT It's half special! Not all one-byte encodings are ascii compatible. If ASCII-8BIT strings had "no encoding at all" then `"\x00".force_encoding("ASCII-8BIT").encode("UTF-8")` would raise `Encoding::UndefinedConversionError` and `"\x00".force_encoding("ASCII-8BIT") + "\x00"` would raise `Encoding::CompatibilityError`. &gt; I guess it's only valid for unicode encodings? Encodings which can represent the full unicode character set are not one-byte encodings, so this bug does not affect those encodings. `String#codepoints` does return the correct result for ISO-8859-1 strings and ascii only strings with ascii compatible one-byte encodings.
Why not?
&gt; Sure. This sounds completely reasonable. But lot of people is not so open minded as you to allow me to disagree with them. So? Some people in this world will naturally like you. Other people will be indifferent. Still others will naturally dislike you. There are folks out there with different views that will hear you out. On the other hand, some will disagree with you without giving you a chance to state your case. Excuse my french, but seriously, why not just say "fuck 'em?" You're not entitled to be listened to by anyone out there.
As a close-to-being-a-college-graduate who's excited to get into web development, this is really helpful. It's also nice to know my two favorite server-side languages are the two preferred ones on this list (Ruby and PHP).
Am a DevOps specialist and that's a pretty non-exhaustive list.
This is fun good job man!
Thank you! It's not the last part I plan to deliver more goodies in next parts very soon.
&gt; So when you are discussing sprockets with contributors does the conversation often lead to ethnicity, gender, sexual orientation, etc? Contributors are whole people with full lives. I see many of them in person at conferences and we talk about whatever is on their mind. &gt; Do you accept pull requests with the goal of ensuring that all genders and races have equal representation in the codebase? If 50% of my users were men, but I was only getting 1% of my contributions by men i'm inclined to know why exactly my project isn't getting all the help possible. If there's something reasonable we can do to increase the number of contributors to a project, i'm all for trying it. That's actually what inspired the code of conduct, i talked about it more in another thread you might have missed https://www.reddit.com/r/ruby/comments/5zlbg4/funding_rubygemsorg/df1vq6m/ &gt; My chosen pronoun is 2 gigabytes long, are you obligated to use it to refer to me in issue threads because I say so? Many contributors are pictures of something other then themselves. If I guess and i'm wrong then i'm not being technically correct. It's easier to stay away from pronouns. Besides it saves time, allows for easier automation and makes my writing more DRY/reusable, all things programmers care about regardless of your views on gender. &gt; Contemporary social justice activism is not about decency. I'm a self contemporary social justice warrior and my activism is about decency. Sorry to break it to you. I guess the question at this point is, what are you trying to accomplish in this thread. If you're saying "i'm upset and feel disenfranchised" then I hear you, i'm trying to build a bridge here. It sounds like you're more upset with the __idea__ of a social justice warrior you've concocted in your head (or in whatever media you subscribe to) instead of this interaction. I'm a person, flesh and blood. I'm trying to engage with you while you're trying to tell me that people like me don't do this. I hear you when you said you have to work for everything you've got and that life is hard for you. I would think you would want to spend more time working and building up your bank account instead of arguing that someone trying to be an inclusive human is a fundamental threat to your life. Maybe social justice warriors do take a real toll on your life because of the time sink in engaging with them. Maybe if you didn't intentionally try to start fights with them, you would save some time and even some money. My goals in this thread is to be a whole human being full of complexity, but also one that stands up for other humans. Ruby is an inclusive language and an inclusive community. It's one i've been a member of for some time now, and one of the reasons is due to people taking time to calmly and rationally have conversations with newcomers who seek to be divisive. If you didn't notice your original comment being down-voted to oblivion to the point where you had to delete it, i'm not the only one here who feels this way. So what do you want to accomplish here? What did you want to accomplish with your original derogatory comment about social justice warriors? 
&gt; No two people claiming to advocate some virtuous behavior or lifestyle are going to have the exact same interpretation of it, or agree on the same things. Your idea of social justice may or may not partly intersect with the ideas I have shared. Totally, that's why I don't think it's appropriate to attack a whole class of people based on their idea of "preserving decency". Maybe their version of decency is different than yours, but that's not what you've been doing. You're labeling them into a different group and condemning all of them based up on made up arguments instead of taking responsibility for your own views. Attacking the entire group and dismissing them out of hand because they want to fix problems is silly. I've already talked about this at length in other threads on this same post. &gt; If the points I raised earlier don't apply to you, then they don't apply to you. I am arguing against the fringe, you are claiming not to be the fringe (I think). You're putting people in buckets "us" and "them". Where I'm somehow not a "them" because i'm not "too extreme". We're all people. I appreciate the "but you're different" exception i've earned, but i'm not different. Or rather we're __all__ different. &gt; If Hitler had a github repository, I'd contribute there too, I am not interested in people's lives when I program, I am only interested in the project. If you "don't care who you work with" then why go out of your way to alienate anyone? The problem isn't your desire to work with someone, it's someone's desire to work with you. &gt; if there is an incentive for me to do so. Not limiting your team choices is incentive. Not making people feel awful is an incentive. As a company you've got plenty of incentive to not have horrific PR and to keep your options open to hire more people. Look at #deleteuber recently as an example here. ## Let's switch gears. There are more than two genders. If you don't believe me, go ask someone with a PHD in biology. Their response will SHOCK you ü§ó 
I'm obviously not excited about sharing this news but a lot of people have been asking when nominations would open up for this year's edition so I feel like I have to mention it here. 
&gt; I guess it's only valid for unicode encodings? TIL `String#codepoints` returns (Unicode) codepoints for all valid strings in US-ASCII, ISO-8859-1, UTF-8, UTF-16(BE|LE), UTF-32(BE|LE) *only*. For all other encodings, `String#codepoints` returns "codepoints" in other character sets. Thanks! 
I think I explained my feelings about prizes and rewards in the post. So this is not what I would redirect people to, as you can see at the end of my post. I wish the best to these initiatives, but I do not want to vouch for them.
I feel like this is a bit like the old generation of Ruby bigshots have gotten their award and don't want to keep handing them out to the up and comers. They need to keep their stranglehold on those keynote slots.
&gt; They forget to explicitly use ‚Äúpresent?‚Äù, ‚Äúblank?‚Äù, and ‚Äúnil?‚Äù I do that a lot too but often this is intended. You have to remember that e.g. `blank?` also returns true for empty strings and you might not want this. In a lot of cases I really just want to check for foo.truthy? Also what I like to do but it heavily depends on the actual case: Instead of do_something if user.admin? I sometimes leverage short circuit evaluation user.admin? &amp;&amp; do_something Also if you redirect in a condition you often have to return to avoid double rendering/redirect exceptions. Rails suggests to do `redirect_to() and return` while I prefer `return redirect_to()`.
Please. That conjecture makes no sense after everything Olivier has done for the Ruby community. His post is pretty clear in why Ruby Heroes is ending.
I don't get it. How was it good enough for all the usual rockstars for so many years, and now after they've all got theirs it's a terrible idea? They can keep calling themselves Ruby Heros, but new people who work hard? No it'd be harmful for them to have it. It's pulling the ladder up.
Would anyone really replace a when/case clause with dynamic method calling like that? Seems more like misdirection to me. 
the point was that no one was getting it EXCEPT the 'rock stars'. It was supposed to be an award for unrecognized rubyists who do brilliant work, to pull them into the limelight. But it just ended up being a game of 'pass the parcel' among well-known rubyists who already knew eachother and attend all the conferences. The award was not performing its job, it was a boys club...many much more deserving rubyists did not get a look-in because the award was instead being given to friends of previous 'ruby heroes', who then in turn nominated their friends, and so on. For example, the author of byebug never got an award, yet "coraline" did. Why? because coraline is all over social media and an expert at self-promotion and a good buddy of previous years ruby heroes, yet the byebug author has almost 0 social media presense. But it is very arguable that the author of byebug is more deserving. 
Also important to note that a security review will flag this as a `dangerous send` as it is trusting the user input without sanitizing it. Would rather see messy `if` statements than this. 
Thanks for all your efforts over the years in encouraging and growing the Ruby community. It's obvious this is something you've given a huge amount of time and thought to and while you seem down about the situation I just wanted to let you know that your work was appreciated. 
When it goes for handling default cases using hash, consider: CASES = { 'a' =&gt; 'A', 'b' =&gt; 'B' } DEFAULT_CASE = 'C' def somethod(name) CASES.fetch(name, DEFAULT_CASE) end IMHO it's quite readable.
qml binding works, but sucks, it worked on my mac and linux not bsd 
https://github.com/collectiveidea/interactor ‚Äì Changed the way of development https://github.com/dry-rb/dry-validation ‚Äì Changed the way of validation https://github.com/dry-rb/dry-types ‚Äì Changed the way of serialization https://github.com/jeremyevans/sequel ‚Äì just love this
FYI https://ruby-doc.org/core-2.4.0/Hash.html#method-i-default-3D CASES = Hash.new('C').update({ 'a' =&gt; 'A', 'b' =&gt; 'B' }) # CASES['foo'] # =&gt; "C" 
 path = some_path if foo? path ||= another_path if bar? path ? redirect_to(path) : fail 
cool, will give it a try, thanks :) EDIT: didn't seem to help :/
Worked with? Pry. Being able to debug by just dropping a REPL right at your pain point feels magical. It's a whole other world from breakpoints and watches I'm used to from other languages.
sinatra and datamapper. auto_upgrade! in datamapper handles simple database migration stuff nicely
Camping is fun, but not a particularly "serious" framework. Sinatra is the standard 'microframework' which has been copied to many other languages.
Apologies about the book on Github. I recently discovered it's English isn't great but it's not totally unreadable. 
Tuts+ free tutorial [here](https://code.tutsplus.com/series/singing-with-sinatra--net-19113) is a good one. Though it's from 2011 it'll still work because the Sinatra API has been stable. 
There is nothing wrong with camping. If you like it then keep on using it. The only downside might be that you don't have a large community to answer your questions.
erb is probably the most popular or "preferred", because Rails uses it as standard. But most software these days lets you choose from a handful of somewhat popular ones. Slim is my favorite. But you'll never go wrong starting with erb, it is most common if not the most loved, and it's not going to go away or confuse any other developers. 
[dry-container](http://dry-rb.org/gems/dry-container/) and [dry-auto_inject](http://dry-rb.org/gems/dry-auto_inject/) made a big impact on the way I build applications. [fear](https://github.com/bolshakov/fear) helps me a lot to manage failures and nils.
&gt; I take it this is a implementation of the Service Objects concept that was making the rounds in Rails world a couple years back - right? Yes, it's like a Service Object but in other vision. &gt; Are there any downsides to Interactor? Or drawbacks? I don't know. I use it every day. I really love it. You can put all your business logic to Interactors and then test only Interactors ‚Äì 90% of your App is covered by tests
If you compare your version to Tomarse's, his version is much more readable and much easier to digest because the logic is very easy to follow.
At the end of it all, I'm still a 22 year-old student who's been looking at Ruby and writing things in Ruby for like....4 months. Hopefully my school can provide me with an internship in a workplace that uses a Ruby web framework so I can get more of a solid ground in it. 
@google.com shouldn't necessarily hint @gmail.com as @google.com is valid for employees of Google.
Sounds awesome :) I hear that sidekiq is good for that? I also wrote an introduction to concurrent / parallel programming that might be helpful. It's for Clojure / the JVM, but the concepts at the beginning are universal: http://www.braveclojure.com/concurrency/ I've also updated the site quite a bit! Still not as mobile friendly as I want but it should be a little better.
Notably absent: getting better at programming. The difference between what this document calls "front end," "back end," and "dev ops" aren't nearly as significant as what they have in common. For instance... SOLID/YAGNI/KISS shows up in "back end." Design concepts are relevant to all paths.
Yes that's exactly the idea :)
Well... My experience of Camping teaching me "how to web" is pretty close to yours. It was many years ago, but I don't think Camping become worse for this :) BTW, if you are a student, are you aware of Google Summer of Code? It is unrolling right now, and it is a great opportunity to try doing something with Ruby.
I did not, but now I think I will apply. :D
I didn't say that. I write acceptance tests, but I'm more concerned about the effects of a link click or form submission than which type of HTML tag contains a piece of content. If I got that specific about mundane details, I'd have no time to test or even code the features that really matter. 
It's not necessarily "un-sanitised" (by which I presume you meant whitelisted) - you could simply raise an exception if the input is not within a pre-defined list. In which case, it would be OK to run `send` with it - you just need to be careful! Also, in *most* cases there's no real security threat here - like in the above, at worst, the user could run a different method names `process_xxxx` - i.e. probably nothing! The most common **real** security concern is in code that looks something like this: user_input_1.constantize.new(user_input_2) ...Because now you're giving the user a LOT more flexibility in what can be executed.
I understand now why you think this is not useful - you misunderstood its purpose. Page objects are not meant to test which tag contains the content etc., they are used to you're able to write "click the 'forgot password' button in the login form", and then, when you change the class / name of the "forgot password" link, you only need to change it in the page object, not in every test that uses the link.
I understand where you are coming from but I started learning web development in the modern era so I don't have to fight my prior instincts like you would. Do you mind me asking what kind of app you plan on making?
I'm working on a service which automatically runs bundle update on your project and pushes up a branch and opens pull request if there are updates. Basically I like to keep dependencies updated but its always a pain if you have too many projects, so this is a service you hire to do most of the tedious work for you :)
So bundling up a lot of tools together? That sure sounds great, it seems like it would benefit larger open source projects or enterprise situations where less time worrying about keeping dependencies up to date would save money on training and related activities
I like this gem. It doesn't seem to do much that's generally disruptive. Being overly "helpful" can be worse than being not helpful at all. My personal domain is a `.ca` and one website I use tries to auto-correct it to `.com` each time. That's a valid TLD! And it's not even `gmail.ca` or something like that. 
Your hobby project is quite impressive, I myself haven't worked with maps before but I really like the 3D elevation map. Is that third party software or did you do that yourself? Being new enough to web development I have to admit that there is a lot of front end, personally I prefer the back end but I'm not going to completely ignore the front end (would be a bit silly if I wanted to make a website in my spare time)
I'm currently working mostly on [HexaPDF](https://hexapdf.gettalong.org), a full-blown PDF library which presents some nice challenges (e.g. memory/speed optimizations, implementation of image and font formats, ...). When I have time I do maintenance for [kramdown](https://kramdown.gettalong.org), a pure-Ruby Markdown-superset parser and converter. So I'm more into the "backend" stuff which I find more interesting than the "frontend" stuff since UI design and such are not my strength ;)
Thx! I did the 3d stuff myself, with guidance from a mapbox blog. A built a bunch of other front-end Nick nacks too, enough to develop a healthy respect for JS.
Thanks for the positive feedback :) Also some client services companies charge clients to do this sort of thing on a regular basis, so it would save them time. Plus the company I work for has some large ruby projects which the existing solutions out there simply don't work for. They either focus too strongly on security, just notify you instead of actually updating code, or just don't traverse into subdirectories. My project isn't quite ready for prime time yet but it is called dependencyd.
If you're already using Turbolinks 5 on the backend, you can just use the native libraries: https://github.com/turbolinks/turbolinks-ios https://github.com/turbolinks/turbolinks-android
For Android &amp; iOS webview apps, do you mean users should be able to access your site via a phone browser? Or download your app from their app stores?
Both very impressive looking projects, I am myself looking for a project on GitHub or related websites that I feel strongly about and if I'm honest I am looking for work in general, just a summer thing for the moment though so it's hard to find a job. I have to agree with you, I prefer backend as well, I am very unobservant so I prefer just implementing the systems that support the front end. I am a game developer so it would be helpful to be decent at front-ends, but oh well, gotta live with it lol
JS can be a great language when used right. It is really applicable to all situations now thanks to Node. I'd love to be better at front end development, I'm trying and thankfully getting better
Exactly :) I'm going to support a daily check as well as every time the master branch is updated, or when a new version of a dependency your project replied on is published. There is also an emphasis on ruby at the moment, but I actually stared with ruby and javascript (npm) ... I just reeled in the scope a bit so that I might actually finish it :)
check out https://gemnasium.com/ is has some feature overlap you may be interested in
In that case, your best bet is probably to spin up a new React Native app that manages your front-end views, and makes API requests to your backend Rails app. Your Rails app would not deliver views to your React Native, it would deliver JSON. React Native apps can be released to both the iOS and Android app stores. 
i already knew Ruby for a while before i started so it was easy for me to pick up, and i don't remember which docs i read but i scanned the camping book and it seems like it covers the bases. i don't subscribe to the mailing list so i'm not sure whether it's good or not. honestly i think Markaby is a lot easier to learn than ERb or HAML, but if you are not already pretty comfortable with HTML you may want to start with that first before adopting a templating system.
That's awesome, tty-prompt is getting better and better. Keep up the good work.
I've been building https://sendcheckit.com - from a technical perspective the most challenging thing has been dealing with encoding issues with emails. You don't deeply realize how many layers of cruft the internet is built on until you start trying to accept email from a variety of sources.
Item Data groomer for League of Legends so the JS site is more sane and I don't have to do all that in JS (which I found to be quite obnoxious when I tried it the first time). Also using rake to allow for the site to be updated automatically using the aws cli so I don't have to do it manually.
It seems like you are mixing some things together. For the most part you suspect that people opposing CoCs are people doing the harassment. Please stop;)
It seems that the glance was super quick :) Could you explain what wirble, an irb enhancement has to do with CLI prompts library? I mean at a push you could ask someone a question by presenting them with irb interactive prompt but I wonder how you would process answer? How do the libraries you have just mentioned provide multi selection menus or password input etc...? The tty-prompt library helps creating intuitive prompts that delight users and developers. It solves problems I came across over the years writing CLI applications. If you feel this is not the right tool for your needs and wirble/bryce/interactive-editor solve your problems well then by all means go with them. 
Thank you, it's getting closer to 1.0.0 version. I like seeing it grow in ways I haven't really predicted thanks to awesome contributors. The next important bit is a tab completion feature that will make it ultimately useful :)
As a hobby, I am trying to do this thing https://github.com/molybdenum-99/reality It was started as a conceptual demo of accessing common knowledge in a computable form (through Wikipedia and Wikidata) and now slowly moving towards pluggable generic open data access framework. There are several offsprings made in process, like [semantic Wikipedia parser](https://github.com/molybdenum-99/infoboxer) and [generic API wrapper](https://github.com/molybdenum-99/tlaw).
One thing I'd really like to see, which is sort of only relevant to the auto-completion you mention, is a simple generic gem for generic auto-completion on most major shells (that support it). It would be awesome, but it seems like a really hard thing to tackle without some kind of abstraction in the shells themselves.
In my free time I'm working mainly on [Shrine](http://github.com/janko-m/shrine), a fairly fresh library for handling file uploads in Ruby. Some of the most challenging tasks are implementing streaming uploads and downloads everywhere to minimize memory usage, good API for background jobs, utilizing all the advanced S3 features of the [aws-sdk](https://github.com/aws/aws-sdk-ruby) gem, figuring out how to make it work nicely with ROM/dry-rb and Hanami, and making all Shrine features and dependencies opt-in so that it's as lightweight as possible. I learned a lot about IO in Ruby while working on Shrine. Another interesting related project is a Ruby server implementation for the resumable upload protocol [tus.io](http://tus.io/), [tus-ruby-server](https://github.com/janko-m/tus-ruby-server). It thought me a lot about Rack that I didn't yet know about, clarified what are exactly the roles of web servers like Puma, Unicorn and Passenger, and I also learned some advantages of using EventMachine over Rack when receiving file uploads. Tus-ruby-server currently has filesystem and Mongo Gridfs backends, and I'm currently working on the S3 backend, to effectively make the Rack app a mediator between the client and S3, translating the tus.io protocol into the S3 API. --- At work I'm mainly working on Elasticsearch optimizations, because in the last 3 months our app has started receiving up to 100x more data than it has ever before in the last 3.5 years (new big client). It's interesting how many different optimizations you can do with Elasticsearch, and after 3 months you still find low-hanging fruits. Our biggest gain was from simply upgrading Elasticsearch to the next major version (though the process wasn't simple of course). Doing data migrations on a production app always reminds me how difficult that is (to make it zero-downtime). I'm also really happy that at work we don't use Rails, but [Cuba](https://github.com/soveran/cuba), which is about the simplest possible web framework you can use (174 LOC). And I love it, because it's all we really need for a JSON API, and from all of the bugs that we had, none of them were caused by unexpected complex inner-workings of our web framework.
Very good. Not sure why but I often type gmai.com. So it's a nice way to mitigate such typos. I'll use it the next time I touch the authentication part of our system! I'd suggest having a built-in support for Rails. It's like 90% of use cases for Ruby projects anyway. And a guide on how to hook into model validations would be helpful - especially for suggestions. They way I see the suggestions should work is: 1. For server-side only rendering: the first time a value is submitted, it should be treated like an error but highlighted yellow instead of red. Page asks to confirm the value is valid without implying it's invalid though. (Similar to Amazon billing address validation - if the address isn't in USPS database yet, Amazon wants you to confirm) 2. For AJAX validation: do the same on the fly. Each cases should be supplied with example code. BTW - as someone mentioned previously, it's very important to not be overly "helpful" with suggestions. But at the end of the day, it's up to the developer to use or totally dismiss the suggestions, right? 
I'm not sure if you've seen this, but this is a good place to start: https://youtu.be/SWEts0rlezA
I recently made https://github.com/ioquatix/rack-freeze which helps with making multi-thread safe rack middleware. Today I've been working on a native extension for https://github.com/ioquatix/trenni and trying to figure out how to make it as fast as possible.
Working on a Sinatra based personal assistant like Alexa using Tasker on my Android to communicate with it. It's fairly simplistic and uses regex to match speech but it works for me. 
Have you used [Prawn](https://github.com/prawnpdf/prawn), and if so, can you touch on how HexaPDF compares to it?
As a hobby, I work on a CMS. For work, I create web apps for clients, focusing on ecommerce (Shopify apps), I also build out connectors between services, automation of tasks, and more. Ruby is truly great and has helped me develop more sanely the past few years.
Ah regex both the best and the worst thing to use lol don't get me wrong, regex can be great but when you haven't used it in a while it can be hard to use it again 
Wow, you have a lot going on. I've never heard of Cuba before, might be work a peek
&gt; HexaPDF Looks nice! Do you think you'll add the ability to fill out PDFs using FDF or is that out of the scope of the project?
I'm planning to extract the underlying reader from the 'tty-prompt' which is a generic abstraction for gathering input characters. I can see many applications of it outside of this gem. For example for creating your own shell. As far as completion goes I want the behaviour that can be easily overwritten with a custom implementation. Let's say that by default it matches on file names similar to readline but you can overwrite that not only on what gets matched but also how the matches are displayed. I only want to mimick readline where it makes sense, otherwise I want to create a new type of reader. The most important advantage of the reader will be no dependency on the underlying console apart from actual Ruby installation and hence it should work on all major OSs. Any thoughts?
Nice one, thx.
Yeah, I'm fairly skilled at regex but not SSML so I havent made the leap yet. It does look a bit ugly when you have something like plugin.on(/(?:please\\s)?turn off (my|the) computer\\Z/i) { `shutdown -t now`} 
Maybe in due time! Stuck between work and building in admin features for some interested race directors. If there is a particular area that interests you, happy to give you a quick rundown. 
I encourage you to give tty-prompt a try! There are few prompts in the examples folder to give you a taste of what's possible. Even if you don't need to use it at the moment you may find it beneficial to know about it if you ever need to gather complex input from users. Also, if you feel as though the docs are not explaining things well enough consider submitting PR. Cheers!
&gt; For the most part you suspect that people opposing CoCs are people doing the harassment Do I? What gives you that impression? It's not that they are the ones doing the harassment per-say. However people who are against codes of conduct are, by the nature of their actions, opposing efforts to curb harassment. Not sure if you saw it, but I talk about related issues in this thread https://www.reddit.com/r/ruby/comments/5zlbg4/funding_rubygemsorg/df0mv0i/. Start after "best advice". Yes, you're allowed to oppose someone's methods, however you're walking a fine line between accidentally opposing their goals. As a conference organizer and open source maintainer, i've not heard any other better ideas for helping curb unwanted behavior than explicitly calling it out as unwanted.
Sequel, Sinatra, Sidekiq, Slim, Sass. Mostly the 'S' ones.
I've just finished writing a little gem called [Uninterruptible](https://github.com/darkphnx/uninterruptible) which allows for hot-restartable socket servers to be written with a minimum of effort. I'm currently writing up the build process, so any comments or questions about it would be appreciated. Next stage is to move all of our existing servers for authentication, RPC etc. servers to start using it.
Testing, rest apis, mobile apps (rubymotion) 
I hear Docker and Windows, what do those have to do with ruby?
Yes, I have used Prawn, there is even a pure Ruby PDF converter built into kramdown that uses Prawn ;-) The difference boils down to HexaPDF being a full-blown PDF library whereas Prawn is a library for generating content. You may want to have a look at https://github.com/gettalong/hexapdf/#difference-to-prawn where I summarized some differences (and https://github.com/gettalong/hexapdf/issues/10#issuecomment-283109238 to see some more). Tl;dr: HexaPDF can potentially do anything with PDFs (merging, splitting, decrypting/encrypting, optimizing, content generation, image/text extraction, ...) whereas Prawn only does PDF content generation.
Yes, the ability to fill out forms will be available in a future version.
I'm working on an audio &amp; video streaming platform similar to Youtube for the Asian music scene. 
Wonderful! It's `myfullname.ca` so any Canadian domain will work. 
I'm currently using ruby for my PhD thesis, using information from Scopus database. There are script to batch downloading and update the database of journals and authors, and a web front-end to analyze and refine the information.
I think making it modular is a good idea. It would be cool to display documentation along with matches, for a command, as a custom mod. I don't like readline much, it has a pretty clunky API. I made https://github.com/ioquatix/samovar which I use for all my command line apps. It's designed from the ground up for supporting auto-completion accurately but I've never had the time to add it. One of my friends used it to make a telnet MUD. That was pretty cool.
Not sure if this helps or not. Check your GEM_PATH http://www.schneems.com/2014/04/15/gem-path.html If you can't get `gem install &lt;gem name&gt;` to work, it's worth the time to spend figuring out why as likely it's an indicator of a much larger problem. &gt; ERROR: While executing gem ... (Net::HTTPServerException) 400 "Bad Request" I've never seen this one before in relation to `gem install`. You could use something like charles proxy to sniff the outgoing network request. If you're not already invested in your current setup, it might be worth it to try to delete/clean what you've got and start from scratch following a getting started tutorial. Check out http://daverupert.com/2016/06/ruby-on-rails-on-bash-on-ubuntu-on-windows/ maybe.
No problem, the current, more elaborate version is available only since yesterday :)
I know I will sound like a jerk. But do yourself a favor, shrink a NTFS partition and install Linux. If I know you are developing rails on Windows I won't even look at your resum√©. And I totally know many people think that way. The Web world is a Linux world.
Oh I know. I hate Windows for learning to develop non-Windows things. I'm just partially stuck with it at the moment. I'm a student, so when summer hits and I don't have any schoolwork to worry about, I'm wiping Windows 10 off this computer and installing openSUSE or Fedora. Edit: Actually I'm just going to another USB SSD, save a system image of Windows 10, then use the one I already have that I wrote an image of openSUSE to and get to cookin'.
So what frameworks does the book touch on?
None. It's just Ruby and OOP, but the code examples are centered around writing code that generates HTML. It's actually done but I've been meaning to update/change some things. https://leanpub.com/rubyforwebdesigners
As far as I'm concerned, the main reason we use Cuba is because our application is older than Roda, so we didn't feel like switching web frameworks (though I think it would be easy). My web framework of preference is definitely Roda, I like the design much better than Cuba's (it's less magical), and it ships with many many more features which are opt-in. Well, one limitation of "Rack" web servers is that none of them seem to have an option of forwarding interrupted requests. When a user is uploading a large file, and the HTTP connection breaks before the upload has finished (e.g. due to a flaky connection), it would be great that the Rack app can still receive the (partial) request, so that it can save the part of the file that managed to be sent, and let the client know in the response how much of the file was uploaded, so that the client can retry the remaining part that wasn't sent. I mean, it's not a deal breaker, the tus.io protocol defines chunked uploads, so the whenever a chunk upload fails only that chunk needs to be retried, but then the client has to know that they have to split the file into chunks in order for resumable upload to be possible. It would be great it the client doesn't have to act differently depending on the features of the web server. I'm not aware of Rack rebuffering and 100-continue handling issues, could you clarify?
Wooo Buddy, it sucks to be **stuck** using Rails on Windows. I did it for **fun** (cringe) and I've got it running with no problems both on BoUoW and Win10. Shockingly, BoUoW works (smile!). Like actually works, and you might want to stick with it and solve your original problem with this in mind - [don't change linux files from windows](https://blogs.msdn.microsoft.com/commandline/2016/11/17/do-not-change-linux-files-using-windows-apps-and-tools/), don't worry though apparently [this black magic] (https://medium.com/@pck/how-to-use-sublime-text-3-from-command-line-with-ubuntu-bash-terminal-in-windows-10-subsystems-for-aa2ad59d088c) is possible if you want a gui editor for your linux files. Compared to my Win10 install, running BoUoW Rails runs faster and of course its got the latest updates, [this guide](https://gorails.com/setup/windows/10) includes all the major caveats (no PostgreSQL) and special steps compared to a linux rails install. Really important though if it's unclear - the two installs are completely separate.
10+ year php/js dev, ripping through online ruby courses in my spare time simply because I find it interesting. There are loads of good software, lots of good content/conference talks to learn from in the ruby community that is really applicable everywhere. For a hobby project I've been building an app that allows people to layer onboarding experiences over their website (rails api / react + redux). 
For me it's [Sequel](http://sequel.jeremyevans.net), [Roda](http://roda.jeremyevans.net), and [Rodauth](http://rodauth.jeremyevans.net) though I still didn't get the opportunity to use it; all of them written/maintained by Jeremy Evans. Other than being really awesome to use, those gems' design inspired me when I was writing Shrine. Minitest definitely helped me write simpler tests. Sidekiq is pretty amazing. Dotenv is great for env-based configuration. Aws-sdk gem is a superb API wrapper for Amazon S3. Faraday is a really nice HTTP library, as well as Typhoeus (though they can also work together). And let's not forget Bundler!
&gt; I don't get what you're saying with by "saving part of the file" without going through one of these scenarios, and where rack is in your way, but I might be missing some insight that you got from your tus experiments. I actually meant a scenario where HTTP connection breaks while sending the request body, after it has already sent request headers. The request headers would always need to be sent whole (otherwise the request shouldn't be propagated), but the request *body* doesn't. So the scenario falls in between your two bullets. The web servers would get the `Content-Length` header, and as far as I know they shouldn't mind if the actual size of the received body is smaller than `Content-Length`. This particular thing is not a limitation of Rack, it's just that I didn't find a web server for Rack apps that supports forwarding partial requests. Btw, to clarify, with tus the request body are pure file bytes, it's not a multipart/form-data request. If the request body was multipart/form-data encoded, it would be a trickier since some parts of the request body contain file information, so it's not that first 10 bytes of the request body equal to first 10 bytes of the uploaded file. &gt; * puma: buffers the payload to a tempfile (other servers only do that after a threshold). &gt; * rack: parses the payload, rewinds the fd, parses each multipart part into a file with a specific name based on headers &gt; * how the file(s) is(are) named is the result of a lot of rules, not all of them properly specced &gt; * each part is a new tempfile (with a clearer name) &gt; * rails/roda/yourapp: params hash points to the part files. Now you can do stuff like authorizing operation. &gt; &gt; The issue here is that authorization may fail, based on the request headers/cookies. But until you've reached the layer you control, you already traversed the payload (O(n)) at least twice (middleware-dependent, can be more), while doing a few IO-bound operations (mostly tempfiles, which might be mapped to RAM). So you have to take that overhead into account. I also thought at first that this is what happens, but I found out recently that Rack actually parses the request body lazily, only when you force it by calling `Rack::Request#params` (and it seems that Rails also keeps this behaviour). This would mean that as long as you call `#params` *after* you've performed authorization, the request body should be parsed only when the authorization has succeeded. Btw, [as far as I can tell](https://github.com/puma/puma/blob/604885b1fe2b4d2be0658c78914ebf16c13fb173/lib/puma/server.rb#L788-L795) Puma switches to a Tempfile after a threshold as well. Btw, you might find it interesting how the Goliath Ruby web framework (built on top of EventMachine) handles requests, allowing you to react with * [`on_headers`](https://github.com/picocandy/rubytus/blob/e081bb019e3b768ef4079ebb3b110c1b9fff37b4/lib/rubytus/api.rb#L15-L23) - triggered when all request headers have been parsed * [`on_body`](https://github.com/picocandy/rubytus/blob/e081bb019e3b768ef4079ebb3b110c1b9fff37b4/lib/rubytus/api.rb#L25-L32) ‚Äì triggered whenever a new chunk of request body has been read from the socket * [`on_close`](https://github.com/picocandy/rubytus/blob/e081bb019e3b768ef4079ebb3b110c1b9fff37b4/lib/rubytus/command.rb#L36-L40) ‚Äì triggered when connection has been closed The code linked above is from [Rubytus](https://github.com/picocandy/rubytus), another Ruby tus server implemenation. &gt; Also, since you deal with file uploads, you can't say you're streaming the client payload directly to S3 if you're using ruby/rack, because as you see, you have a few in-between steps that you can't avoid. Maybe you have more input about this? I agree with this. Though with tus-ruby-server there is no request body parsing, because as I mentioned with tus protocol the request body contains raw file content, so there is nothing to parse. But even if there is no request parsing, your statement still holds because the whole request body is still first being buffered to a Tempfile, and only then forwarded to the Rack application. It would be great if you could upload request body to S3 as it is being read from the socket :) However, I think I might be jumping the boat here, because while Puma buffers the request body into a Tempfile, this isn't the behaviour of all web servers. Unicorn and Passenger use [`TeeInput`](https://github.com/defunkt/unicorn/blob/e9b9af6ca2957752cb9c6ca6e935ef081751e61b/lib/unicorn/tee_input.rb) for the `rack.input`, which dynamically reads from the socket and caches read body to an internal Tempfile to make it rewindable (mimicking the `tee` command-line tool). This means Unicorn and Passenger might already support the streaming from the socket I mentioned, and I think they leave you to handle interruptions while sending request body. &gt; The idea was basically to give time for the headers to reach the app layer so you could get the cookie and authorize or smth else. The problem in this case is lack of rack support for such a case, as it can't model such partial requests and intermediate responses. So, servers like puma have to simulate header handling and send 100 Continue as early as possible. Most clients have anyways a timer implemented, and when the server doesn't send the 100-response, they just assume it's a misbehaving server and start sending the body (curl does this btw). Thanks for clarifying, I didn't know that!
I literally just messed up my DNS. So here's the entire contents of the article: ---- https://gist.github.com/schneems/1fc59e106dc9b7ebc722f918e2ef1a91
Main site is back up
I responded to this survey and I think you should too. Even though Phusion is a commercial project, their OSS app server is awesome and they're really nice people. I personally don't use Phusion anymore but I was happy to let them know why.
Thanks for the kind words whatasunnyday!
No, it is not a common thing to do. Common procedures are using environment variables or symlinking/copying files on the production system. So no credentials present in the git repository. Relatively new are encrypted secrets, which can indeed be placed in the git repository: http://weblog.rubyonrails.org/2017/2/23/Rails-5-1-beta1/#encrypted-secrets
&gt; The request headers would always need to be sent whole (otherwise the request shouldn't be propagated), but the request body doesn't. I'd say this is a potential DoS vector under some circumstances. Think about an attacker leaving partial content in the server. I was reading that this tus server follows the resumable upload spec from nginx, and therefore uses multipart/byteranges mimetype to govern the POST payload. A well-behaved client will therefore adapt the byte range to the quality of the network, and as long as you send smaller chunks, it'll be ok. I used goliath a while ago, but I think it didn't change much. It's interesting because it's a "framework-server" in a way, as it has enough features to allow you to use it without an higher level layer. But lack of interoperability is a downer when integrating with smth else. But it's a perfect candidate for your uploads example. &gt; It would be great if you could upload request body to S3 as it is being read from the socket :) nginx uses sendfile in linux, if I'm not mistaken. Would be great if servers/rack/smth would let you stream socket-to-socket in the Kernel. I first thought of IO.copy_stream, but I'm sure that eventmachine allows this and goliath already supports (fingers crossed). About the server buffering throw TeeInput, it has a drawback when applied to puma, which has a read-reactor, and socket interaction (what concerns reading/parsing the request) happens there, so that it can interleave to other sockets when it has to wait for that one, and when it is ready, it passes the socket/request to a worker, thereby leaving the reactor. Performing a delayed Teeinput-like behaviour could starve a worker with possibly slow IO, DoS-ing your worker, which can't pass back control to the IO loop. Both passenger and puma "outsource" request buffering to the frontend proxy, and use the single-threaded worker for everything, so there is no workaround for them. Again, thin/goliath might have support. Would it be possible to do stream directly to S3 without buffering in ruby? Not with any of the most-used servers, sadly. and the Rack spec rewindable input might be in the way, so you'd need to interact directly with the server API a la goliath. 
I've only ever used WEBrick and Puma but I filled it out.
this is one of the anti-patterns created by the rails defaults. [Rack actually defines only 2 environments: `development` and `deployment`](https://github.com/rack/rack/blob/1482870b381b1517305c8c0aac05feb4d5b3aa6a/lib/rack/server.rb#L229-L244). The latter is a seldom-used relic, and I assume a lot of rack apps are deployed with `Rack::Lint` in the middleware, the horror. Rails started shipping with 3/4 environments and declaring a yml file indexed-by-env for the database, and this deployment pattern never went away. Even sidekiq (many ages ago) used to prefer a redis.yml file indexed-by-env. It's curious that these defaults seem to be pretty standard only to rubyists. I was discussing with a co-worker who came from java referring my "development" instance, and he insisted referring to it as my "test" instance. Our "staging" servers were usually called "test" servers by our testers, even if the DNS entry was in the ".staging" subdomain. I started advocating for reducing app configurations to 2 environments (we were already using envvars for "service discovery"), but there was a lot of resistance to change, as these notions were part of what they perceived as the "rails way", and `Rails.env` was used a bit everywhere in the source code. So I gave up. This will never change. 
Send us stickers! 
Funny. Usually when Rails prescribes how to do something or does it automatically it's derided as restrictive "magic". Here the author's own non-Rails-specific decisions caused problems and we get an article complaining "...without guidance from the framework...".
&gt;We only want to know when was the first time a country hosted it. But hashes are unordered no?
This belongs in /r/rails imo. I don't use any of those gems, they are all rails specific.
Use of `RAILS_ENV` is one of those "tells" that indicates code was written by programmers who haven't been exposed to anything beyond rails. You don't _pull_ config, you _push_ it. This is the essence of 12factor.
&gt; I'd say this is a potential DoS vector under some circumstances. Think about an attacker leaving partial content in the server. If you mean DoS in terms of storage, the tus protocol defines file expiration, and tus-ruby-server automatically deletes old uploads after some time (both completed and uncompleted), so I don't think there is any vulnerability with the attacker leaving partial content; I would say that it's even common that large file uploads are often left unfinished (e.g. user changed their mind, terminated the upload, and started uploading a new file). &gt; I was reading that this tus server follows the resumable upload spec from nginx, and therefore uses multipart/byteranges mimetype to govern the POST payload. A well-behaved client will therefore adapt the byte range to the quality of the network, and as long as you send smaller chunks, it'll be ok. The tus protocol actually specifies the `application/octet-stream` MIME type when sending chunks of the file, as far as I know this isn't related to Nginx (though I might have missed some discussion). &gt; I used goliath a while ago, but I think it didn't change much. It's interesting because it's a "framework-server" in a way, as it has enough features to allow you to use it without an higher level layer. But lack of interoperability is a downer when integrating with smth else. But it's a perfect candidate for your uploads example. I really like that Goliath adds linearity into the asynchronicity of EventMachine. However, I didn't find Goliath to have all the web framework features that I wanted, like proper routing and [keeping the response headers when raising the error early](https://github.com/postrank-labs/goliath/pull/327); and Roda was so darn convenient. But the ability to hook into request parsing is definitely useful. &gt; nginx uses sendfile in linux, if I'm not mistaken. Would be great if servers/rack/smth would let you stream socket-to-socket in the Kernel. I first thought of IO.copy_stream, but I'm sure that eventmachine allows this and goliath already supports (fingers crossed). By socket-to-socket you mean "your server socket" to "Amazon S3 socket"? Well, it's already possible to stream directly to Amazon S3, because `TeeInput` (or any `rack.input`) is an IO-like object, which you can give directly to aws-sdk gem, and it will read and upload it in chunks. &gt; About the server buffering throw TeeInput, it has a drawback when applied to puma, which has a read-reactor, and socket interaction (what concerns reading/parsing the request) happens there, so that it can interleave to other sockets when it has to wait for that one, and when it is ready, it passes the socket/request to a worker, thereby leaving the reactor. Performing a delayed Teeinput-like behaviour could starve a worker with possibly slow IO, DoS-ing your worker, which can't pass back control to the IO loop. Thank you for bringing this up, I completely forgot about that issue. Yes, I would say that this makes it dangerous to stream the file content directly from the socket to S3, because as you said slow clients will kill your throughput. In this case I think it's even great that Puma first buffers the whole request body in a tempfile while still in the reactor, and only then passing the request to the Rack app; I suppose that's what people mean when they say that Puma handles slow clients well. &gt; Both passenger and puma "outsource" request buffering to the frontend proxy, and use the single-threaded worker for everything, so there is no workaround for them. Again, thin/goliath might have support. Did you by any chance mean Passenger and *Unicorn* here? They are the ones that use `TeeInput` for `rack.input` to dynamically read from the socket when the request body has already reached the Rack app, so I thought they are prone to slow client attacks. Also, could you clarify "frontend proxy buffering"? Is nginx capable of first buffering the whole request body, and only then passing it the web server (removing the dangers of `TeeInput`)? If yes, does it do that by default? &gt; Would it be possible to do stream directly to S3 without buffering in ruby? Not with any of the most-used servers, sadly. and the Rack spec rewindable input might be in the way, so you'd need to interact directly with the server API a la goliath. Well, after this discussion I would say that it's dangerous do that, because of the slow clients vulnerability that you mentioned. However, EventMachine has a much stronger reactor pattern than regular web servers, so any IO operations that happen (e.g. HTTP requests, database calls) will unblock the event loop and it can continue serving other requests while waiting for the IO operation to finish. That way the IO in the app is slow, it won't hurt the throughput of your application. I hope that these "IO operations" include reading from the request socket as well.
There are a bunch of different relatively mature background job gems, some of which use threads, and some of which use a postgres-store. Have you looked at these? Also, I definitely recommend checking out [concurrent-ruby](https://github.com/ruby-concurrency/concurrent-ruby]) for your concurrency needs. it's pieces you can put together, but it's got a basic thread pool executor basically built in. 
What's the guidance for large Rails apps? `respond_to`? Fat models?
Too far from Sweden :) 
Is this your a translation of your own earlier post? http://rubyblog.com.ua/2016/08/ruby-specification-pattern In any case, very interesting! And sorry to be the first to ask the stupid question: Is there a gem for this?
As I commented elsewhere, follow well known refactorings: http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/
I'm more surprised that you didn't see active model serializers that solve your problem to a great extent. But even without them, you fail in your own yard. Any framework would fail you if you can't see how you can improve your code. Simple service objects would suffice. P.S I don't promote Rails and don't use Rails for high requests per minute APIs.
I suppose it depends on the project, and of course the gem. I've worked on both types of projects, and they both have their needs. If the goal is to get the app written quickly (but still with good quality; mvp not prototype), some gems can be extremely helpful. I've also done the upgrade process on a few large projects (rails 3 -&gt; 4 and 4 -&gt; 5), and it's not that hard to update/prune dependencies. Upgrading isn't usually hard. Most of the time, as long as the gem is still maintained, it's as easy as a bundle update, and reviewing the changelog/update notes for the gem. I'll admit it's not immediately clear whether a gem is still in use on a project, but I'd argue that the same goes for old code. I've worked on a few very large long-term projects that have abandoned code all over the place. But finding out if a gem is still in use isn't that hard. You just need to review the docs for the gem (or dig into the source code a bit) and find out how it works, then search through your app for those uses. If there are none, remove the gem, and see if any tests break. If not, you're good to go. Something I've also found very helpful is to leave a comment with each gem to say what it's for, to make it easier for maitainers. I've started doing this with every gem, and it helps me out a bunch. However, all of that said, I definitely review gems thoroughly before adding them to a project. I'm definitely skeptical of gems that are very tiny, and only do a small thing, and I look closely at how active the maintainers of a gem are (how many stars on the repo, how many commits in the last month, how quick are issues closed, etc) as well as how good the tests are. If the gem doesn't check all those boxes, I completely agree: run away from the gem as fast as you can, and write the functionality yourself (or, contribute to the gem, but that's a whole other discussion). On the other hand, there's plenty of great gems out there, and often times, if the feature I'm working on is a common use case, there's a gem that works perfectly, and it saves me a ton of development time.
&gt; True, it's not a proper framework, full-stack or small-stack, but it does give you some screws and hammers, which is more than I can say from most of the other app servers, which go full-rack. I mean, the examples dir has so many advanced stuff that you can reuse, and even a grape integration, which mitigates the "proper routing" requirement. Cool, I didn't know you could combine Goliath and Rack-based web frameworks like that! I can already see how you could hook up Roda nicely here. &gt;&gt; Well, it's already possible to stream directly to Amazon S3... &gt; Not directly :) you do have this teeinput in the middle, which means that, when you pass it around for consumption, it will first buffer to disk and only after pass the chunk (if I understood correctly). It will also do this in ruby-space, which is userspace. The sendfile syscall allows to stream fds in kernel space, which is what gives nginx advantage regarding serving static files. There are limitations with the approach (linux-only), and most ruby servers outsource this task to the frontend proxy anyways (nginx, etc), but they will have to buffer and pass you the handle. You're right that `TeeInput` doesn't achieve direct streaming. But I remembered now that Unicorn allows you to configure whether you need the input the be "rewindable", so if `Unicorn::HttpServer#rewindable_input` is set to `false`, Unicorn will actually use [`Unicorn::StreamInput`](https://github.com/defunkt/unicorn/blob/dfb6864d75e07deeea2d86fdcc418db34cb98330/lib/unicorn/stream_input.rb), which doesn't buffer the read bytes from the socket (`TeeInput` is actually a subclass of `StreamInput`). So that sounds like it, but yes, you would still have to be in Ruby-land. &gt; Only slow-write clients, not slow-read clients, so puma reactor is in fact a half-reactor. Buffering the request body is the least they can do, since afaik there is no mechanism built in to "pass the incomplete request back to the reactor to finish and then return to the worker". Very interesting. So if I were to stream file content in the Rack response to a slow-read client, the current worker will be come available to serve new requests only when the whole response has been read by the client? That definitely doesn't sound ideal. &gt; It's possible, but it hasn't been done. eventmachine could certainly handle that, but in order for all operations to unblock the reactor, you have to use em-aware libraries, or use the em-API directly. I think that's the reason why em has been mostly "deprecated". Oh, yes, I remember that the libraries that do IO need to be em-aware, and that definitely adds complication if I want to use `aws-sdk` gem for handling communication with S3.
In this case: add_numericality_constraint :books, :published_year, greater_than_or_equal_to: 1980 What happens when I try to save a book published in 1970? How are the errors surfaced to the user? Do I also have to add a similar Rails validation?
Deos the article mention what they moved to? They'll still need Models and Controllers -- all the other refactorings are on top of that. I've implemented most everything they discuss on top of Sinatra -- but its still MVC.
FTA: That's why we decided to implement the new API as a standalone Hanami application mounted inside Rails.
Missed that line - thanks. Hanami has MVC as its bedrock too. But it strongly guides devs to follow the refactorings mentioned. 
The Sinatra README has a section on Slim, which i'd recommend as a markup of choice: http://recipes.sinatrarb.com/p/views/slim Let me know if you're interested and i can dig up more resources. 
I'm not the author of the library but my assumption would be that this gem helps you add constraints from the business logic also to the database layer. So yes, I would expect the constraints to be mirrored in your active record models. Of course, that opens up a possibility that your model and DB constraints may drift apart if not kept in sync.
Nice about the unicorn configurable input. I actually like the small optimizations of unicorn, and these IO issues are just a side-effect of ruby. &gt; So if I were to stream file content in the Rack response to a slow-read client, the current worker will be come available to serve new requests only when the whole response has been read by the client? That definitely doesn't sound ideal. Indeed. I started investigating SSE for this project I was working with, and how could I implement something in ruby, and ran into this state of affairs: The only servers that can chunk-send to a client without sacrificing throughput are goliath/thin (em) and reel (celluloid-io). EM was a showstopper, so I went with celluloid-io. [This](https://gist.github.com/HoneyryderChuck/591d48cfde04219f801fa7fd7966571c) was the result of my early experiments. The TL;DR is: you have to have a secondary server running in the same process to handle SSE with an IO loop; in puma you handle the SSE endpoint by hijack the socket, writing the headers and passing it to the second server, which handles the SSE payloads from then on. (I used reel helpers and celluloid-io for convenience, but this example could totally be rewritten with pure IO.select ruby. I should definitely have a try at that). 
i forgot to enclose my second example with an || ! So my bad, the question is about: 10.times{ |i| puts i } v. 10.times do |i| puts i end See now the confusion about these being interchangeable?
i forgot to enclose my second example with an || ! So my bad, the question is about: 10.times{ |i| puts i } v. 10.times do |i| puts i end See now the confusion about these being interchangeable?
Yes that's the two syntaxes for blocks. But while doesn't take one. It's doesn't yield anything either, it just take a loop condition and iterate while it's true. It doesn't apply to an object or anything. 
Doh! Sorry. I usually start at [the Release Highlights which breaks down the new syntax features and library modules, and public enhancement proposals](https://docs.python.org/3/whatsnew/3.6.html). 
Uhh that's Python again.. we're Ruby here
Depreciated: Readable commit/changelog 
Well, I have 12 versions of Ruby installed and I've had this machine about a year. I actually uninstalled 3 or 4 old versions last night when I wrote this post and I haven't installed today's release of 2.4.1 yet. So I find myself doing this relatively often I guess. I'd rather automate this rather than kick myself each time I get a new Ruby, try to run `bundle install` and find I've forgotten to install Bundler again. The script itself (https://github.com/rbenv/rbenv-default-gems/blob/master/etc/rbenv.d/install/default-gems.bash) is 43 lines of bash. If it were to stop working I might even be able to sort it out myself. Of course, I'm not saying that you need to do this. This is just a suggestion, my way of telling the Internet that this is how I do it and that maybe you'd be interested in doing this too. I find benefit in it and you may not. I'm interested in how other people look after their environments too, perhaps you could share your setup?
Yes but what bug fixes?
FWIW there's already a [Reddit thread where the latest version is being discussed](https://www.reddit.com/r/Python/comments/60ui88/python_361_is_now_available/)
Hey Josh, Love the gem. Will be using it in my next project. Just curious, do you think it's possible to monkey patch the model with the model validation as well using some meta programming fu?
Thanks Peter. Great write up.
&gt; Resolution of bug #12884: Using a HashWithIndifferentAccess with a default value in a function with a keyword parameter converts it to a Hash. I was wondering when `HashWithIndifferentAccess` migrated from rails to stdlib, being mentioned in a bug fix like that. But nope, it hasn't. And the actual linked issue makes clear "It has nothing to do with HWIA. I can reproduce the situation without it."
It's insane to think about these regressions sneaks their way out into releases. 
Finally someone made a more rubyish wrapper around the FOX toolkit! Check it out! https://github.com/flajann2/fxruby-enhancement
I use the same plugin to install a bunch of default gems in each version`pry`, `awesome_print`, etc. It's quite useful since I've been hacking around with things in a pry session numerous times and found I didn't have a common tool installed. &gt; The cost of the approach outlined is the risk that the plugin will stop being updated or fall out of date in the future. Possibly but considering it was written by the rbenv author it's not exactly likely, nor is it breaking a big deal. 
Not op, but great explanation.
`Resolv`is a [class in Ruby's standard library](https://ruby-doc.org/stdlib-2.3.3/libdoc/resolv/rdoc/Resolv.html). Because it's in the standard library, and not in the core, you must first `require` it before you can use it: kelp:~ vais$ pry [1] pry(main)&gt; Resolv NameError: uninitialized constant Resolv from (pry):1:in `__pry__' [2] pry(main)&gt; require 'resolv' =&gt; true [3] pry(main)&gt; Resolv =&gt; Resolv [4] pry(main)&gt; Resolv::IPv4 =&gt; Resolv::IPv4 [5] pry(main)&gt; Resolv::IPv4::Regex =&gt; /\A((?x-mi:0 |1(?:[0-9][0-9]?)? |2(?:[0-4][0-9]?|5[0-5]?|[6-9])? |[3-9][0-9]?))\.((?x-mi:0 |1(?:[0-9][0-9]?)? |2(?:[0-4][0-9]?|5[0-5]?|[6-9])? |[3-9][0-9]?))\.((?x-mi:0 |1(?:[0-9][0-9]?)? |2(?:[0-4][0-9]?|5[0-5]?|[6-9])? |[3-9][0-9]?))\.((?x-mi:0 |1(?:[0-9][0-9]?)? |2(?:[0-4][0-9]?|5[0-5]?|[6-9])? |[3-9][0-9]?))\z/ [6] pry(main)&gt; 
You can actually also use the `&amp;` shorthand. For example: instance = Foo.new foobar(&amp;instance.method(:bar)) 
&gt; interaction api What do you mean? 
Yes. `do` is optional
No problem. Just add `require 'resolv'` at the top of your `C:/inetpub/wwwroot/Plex-Board/app/models/service.rb` file, that should do it.
I'm disappointed to not see a fix for [13107](https://bugs.ruby-lang.org/issues/13107) in 2.4.1. Among other things, it broke the MongoDB driver. Rails requests will sporadically cause segfaults. I have to keep anything that uses MongoDB back on 2.3.
The biggest issues for me are speed (or lack of speed), lack of reliability and poor calculations performance. It's the last case that forced me lately to use other languages in my last projects (machine learning being an example) 
Is it possible you build a new front end that would connect to the other 2 running apps with a json API?
Is it possible you build a new front end that would connect to the other 2 running apps with a json API?
Im currently working on : http://babyfit.co it logs baby activities, tries to predict baby needs and lets us share pictures with friends, family as well as share metrics with medical staff. http://outcomereference.com compiled all medicine, sports medicine, nutrition and mental health scientific studies and will give an aggregated view of the impact of lifestyle factor. For example, search "obesity" and it will tell you exactly what are the causes (with probabilities and impact) as well as all possible consequences. Like BabyFit, it's an ongoing effort, there's always new scientific research everyday and I'm looking to have an advisor mode where users can get customized advice depending on their lifestyle choices http://damava.com is Uber for caregivers. It asks for education, past experience from local caregivers, manages their calendar. Then people like you can ask what kind of caregiving service they need, time and location, then discuss with the provider and pay (Braintree). It's by far the biggest app and I'm in the final stages I'm also starting today a runner log app. You can add pictures and also details of your run. Think "The Big Picture" meets Strava. Probably reactjs front end, Postgres, capybara
I showed it in another response, but a bash function could also be used for the same effect. &gt; Possibly but considering it was written by the rbenv author it's not exactly likely, nor is it breaking a big deal. About a year ago I was trying to experiment with rubinius, but the ruby-build installer was utterly broken. I couldn't get ruby-install to work properly with rbenv, and had to use chruby/ruby-install to get a working rubinius setup. I ended up switching to chruby altogether. Anyways, from then on I started using bash scripts, or functions defined in `.bashrc`, to handle this kind of configuration and it's improved my experience. I don't _want_ to run the risk of ever having to debug why a tool like rbenv and a particular plugin are doing something weird. Whenever we're talking about development environment setup, we're not talking about things that matter _all that much_ in the scheme of things. But our approaches to how we solve certain trivial problems often bring insight into how we approach software. This is an example of the age old question -- do we pack more features behind a particular interface, or do we compose a new interface that uses the ones we've already got?
The presence of this article suggests some ruby programmers besides myself have an interest in talking about their development environment. Alls I did was share my thoughts.
&gt; About a year ago I was trying to experiment with rubinius, but the ruby-build installer was utterly broken. This likely isn't the fault of `rbenv`, Rubinus's release process is utterly broken and causes issues for everyone. Specifically they don't have stable release tags, release 2.10 can point to one commit today and a different tomorrow, if they find an issue they just move the tag. &gt; I don't want to run the risk of ever having to debug why a tool like rbenv and a particular plugin are doing something weird. Instead you debug you're own collection of bash scripts that may well only work on your machine and no others then claim it's better. &gt; But our approaches to how we solve certain trivial problems often bring insight into how we approach software. This is an example of the age old question -- do we pack more features behind a particular interface, or do we compose a new interface that uses the ones we've already got? And this is what I mean by you're reading too much into a simple plugin. Instead of understanding the problems with Rubinous builds, contributing a reproducible issue to `ruby-build` and helping with a fix, you instead decided to roll your own collection of bash functions. I could also make grandiose and likely false claims about your development approach based on this. e.g. I could assume you're a poor team player and don't contribute to the community. But again, that's way too much to assume based on choices made about a simple plugin and I wouldn't assume this; Just as you should not assume using this plugin tells you anything about a developer's architectural design choices. 
&gt; This likely isn't the fault of rbenv, Rubinus's release process is utterly broken and causes issues for everyone. Specifically they don't have stable release tags, release 2.10 can point to one commit today and a different tomorrow, if they find an issue they just move the tag. I don't want to drudge through this, and I have a very different perspective on rbenv's rubinius drama, but it'll suffice to say that rubinius's release process is _not_ utterly broken for me when I use `ruby-install`. &gt; Instead you debug you're own collection of bash scripts that may well only work on your machine and no others then claim it's better. I don't debug my bash scripts. They all work because they are simply sequential calls to commands I already know how to run anyways. I.E. `ruby-install 2.4.1 &amp;&amp; gem install pry bundler`. &gt; And this is what I mean by you're reading too much into a simple plugin. &gt; Instead of understanding the problems with Rubinous builds, contributing a reproducible issue to ruby-build and helping with a fix, you instead decided to roll your own collection of bash functions. I could also make grandiose and likely false claims about your development approach based on this. e.g. I could assume you're a poor team player and don't contribute to the community. But again, that's way too much to assume based on choices made about a simple plugin and I wouldn't assume this; Just as you should not assume using this plugin tells you anything about a developer's architectural design choices. There already was an outstanding issue building rbx via ruby-build. It didn't look like it was getting fixed any time soon. At any rate, how we construct our development environment does reveal a lot about how we think through problems. You are free to write me off as a programmer because of my approach. It wouldn't strike me as any kind of grave personal offense, but I would probably find your reasoning illogical. Having different perspectives and approaches is not a bad thing, though. It's reading a lot into my commentary to suggest that I'm rendering personal judgment on the qualifications of a programmer based on how they automate setting up a new installation of ruby. My approach insulates me from changes to whatever ruby version picker I happen to be using, which I consider a win. It also insulates my ruby version picker from whatever installs up the baseline gems. I like having that freedom. You might prefer a more comprehensive end to end solution.
It's interesting to me how different people view different solutions to problems. I see comments on this article where the idea that "ruby is backwards" is expressed. I feel the same way about Python, so I assume it's just a personal thing. For example, List Comprehensions are the most backwards thing I can possibly imagine. Being a native English speaker, having a sentence like: She and he will go to the mall and maybe we will run into these people I mentioned at the beginning of the sentence who are named Joe and Suzy. ...is _nuts_ But that's exactly how List Comprehensions read to me. S = [x**2 for x in range(10)] The predicate nominative comes before the subject... twice! "It's values should be squared; it who is a range of 10." Compare that to ruby: S = {0..10}.map{|x| x**2} The range is the subject and then we use pronouns after we know what we're dealing with. "There is a range of 10 who's values should be squared."
All I got from this is that I still don't know how regular expressions work, lol.
The documentation isn't as complete as I'd like it to be yet, but I can make myself available to offer hands on help for anyone who would like to test drive it. :)
Great list of high quality gems. Cucumber and poltergeist for integration testing are the only ones I use in every rails project and not in that list.
Thanks for sharing! First I thought this was an April's fool in preparation... Currently I cannot see the usefulness of this new operator (yet). &gt; For example, what if we wanted to detect strings that do NOT contain \r\n? Solution given was &gt; "this is a test\r\nand more" =~ /\A(?~\r\n)\z/ But you can also do "this is a test\r\nand more" !~ /\r\n/ or the admittedly way more complex "this is a test\r\nand more" =~ /\A(?:.(?!\r\n))*\z/ So, I still have to see a really compelling example. Edit: formatting
Nice... I haven't heard of this before, and I consider myself to know regular expressions very well! In a nutshell, this syntax can (in some unusual scenarios) provide a nicer solution to pattern matching problems - but you *could* of course solve these problems without the new syntax. Here's a little expansion on what I consider to be the best example in the article: &gt; For example, what if we wanted to detect strings that do NOT contain `"\r\n"`? You could achieve this using a plain old regular expression, but the syntax is a little clunky: /\A([^\r]|\r([^\n]|\z))*\z/ This is saying "each character must either NOT be a `\r`, or (if it *is* a `\r`) cannot be followed by a `\n`. (There's also an extra edge case in there, to match strings like `"foo\r"`, which unfortunately makes it even uglier.) Another approach one might try is to use a negative lookahead to solve the problem: /\A((?!\r\n)[\s\S])*\z/ # Or equivalently /\A((?!\r\n).)*\z/m This is using the clever trick of `[\s\S]`, instead of just the usual wildcard `.`, to match *any* character in the string (including newlines!) - which can also be achieved via the multiline regex modifier flag (`/m`). Compare the above two approaches to the one described in this article, which is now possible with this new "absent operator" syntax: /\A(?~\r\n)\z/ ...And that's so much easier to read! :)
Thank you for your responses. I'm looking into converting the two apps into rails engines. Is it preferable to keep one app as is, and mount the second as an engine into it? Or to create a new app and mount both existing apps as engines?
You lost me at aasm. That's ~~50k~~ lines of code added to your project when handling state is trivially easy. Edit 11k loc
I'm hoping the article provokes more thought and ideas. I struggled for examples myself (though did come up with one in the contrived 'matching pairs but not across CRLFs') but no-one else was talking about this new feature so I hope it's started a conversation others can extend :-)
Hey thanks your suggestion, I'm not sure it would be possible without a lot of "magic". How would you infer the model from the migration(s)? Or would it be parsed from the database schema somehow? To me it sounds like it would complicate an otherwise simple gem.
Yeah, it is not super useful when it's the only thing in the regex. It gets potentially more useful when it's just part of the regex. And potentially more confusing. :)
* aasm: I had been using the [state_machines](https://github.com/state-machines/state_machines) variant instead (I think both descended from the same common abandonware). Anyone wanna compare and contrast the two for us? (although my experience so far has led me to want to avoid state machine gems at all, and just write what I need, wondering if aasm would change my mind... ) * &gt; Rolify allows the application to assign roles such as User or Admin on a User object I had not heard of this one, and have never ever thought "I wish i had a gem for this", it's pretty trivial to add a `role` column (or many-to-many if you need users to have more than one role) to your user table and write some convenience cover methods in like 30 minutes. * I _definitely_ like Pundit better than cancan(can). Pundit is so much simpler architecture, and still lets me do everything I need, even stays out of my way when I need weird things. 
This is kinda how I feel about it. http://www.haneycodes.net/npm-left-pad-have-we-forgotten-how-to-program/
What's the difference other than the name? 
Is HAML no longer a thing and everyone is using Slim now?
Whenever I've been tempted to use either, I always regret it basically because gems reliably use erb, but not reliably anything else, so I end up with a mixture of different template languages, that I have to live with or convert manually. It's not just gems either. If I buy a theme, for example, it's going to be in HTML, which erb approximates. It just turns out to be more work in the long run, and the slightly prettier, more esoteric syntax of haml or slim just has never really paid off on balance, for me. 
Why would you use refile instead of carrierwave?
Hi Pete, I store my users' uploaded images on s3 because I host with Heroku and don't persist to disk. refile makes it dead simple to get up and running with user image uploads + s3; carrierwave is a little bit more complex and also requires fog::aws.
They didn't use Rails but did stick to Ruby. 
I agree it's confusing! Except for your `{`/`end` mismatch, I expected this _would_ work: while true { puts "g" } But indeed it doesn't. I guess it turns out that while doesn't _really_ accept a block, it just has syntax that _looks_ like that, it is it's own special unique thing. I didn't realize that either, and I've been rubying for 10 years, and I agree it's confusing! `while` is actually pretty rarely used in most ruby, and people (obviously) always write it with `do`/`end`, I had never tried to do it any other way so had never noticed before it wasn't really a method taking a block arg, I always assumed it was too. 
Give us a little background information. Why are you doing this?
How are you deciding which hashes need to be combined and which stay separate?
I found a guide for creating a rails engine, but nothing really about how to convert a standalone rails app to an engine that can be mounted. Do I need to start over with "rails plugin new 'enginename' --mountable" ? 
No need to do it manually https://html2slim.herokuapp.com http://erb2slim.com
One argument for using Refile over CarrierWave is that CarrierWave loads the whole file into memory, *twice* ‚Äì once when caching, once when uploading to permanent storage. This is unacceptable for larger files, because your server is just going to run out of memory. Refile uploads files to S3 in a streaming fashion. Another argument for Refile is that it ships with a plug-and-play JavaScript for direct uploads, making even multiple uploads directly to S3 a breeze, while with CarrierWave you have to add *lot* of configuration to do that (there is a RailsCast about it), and carrierwave_direct doesn't even support multiple uploads to S3.
Depends if your paying for time optimization or cost efficiency. Some clients just want a MVP. They think they will have money to reinvest later. They are a bit foolish, but they pay the bills.
Why is that foolish? It's a lot cheaper to test and idea and have 50 packages with unoptimized code than to have those same devs write really beautiful, well-organized code. 
Let's see if I understand this... Consider a simple app where users submit links. We create a Contributor model to represent this behaviour. This Contributor **has** an Account. We connect Account to Devise. To create a new link, with the currently signed in account, we call: contributor = current_account.contributor contributor.links.create(url: '', title: '') Additionally If we want to give administrator privileges, we can create an Admin model. And the Admin would also have an account. The account (in this example) always belongs to a single person, so we create a Bio model, which contains that person's details: &lt;%= current_account.bio.avatar %&gt; &lt;%= current_account.bio.name %&gt; Does that make sense? 
Nah man, gotta get on that compliance testing. http://inspec.io/ Serverspec is old news. 
You should be able to find all this information in the rails guide: http://guides.rubyonrails.org/engines.html
Why is there such a strong hate for using gems? I see so many people want to reinvent the wheel or build their own thing that doesn't match conventions set by open source community gems. Yes, it's a lot of added code but it's not code that is maintained by you and it's code that other libraries may build against. It's also maintained by a whole community and used in a lot of other projects. 
The more dependencies you have, the more overhead you have to keep them up to date/prevent them from conflicting. Case in point: we're using an older version of AM Serializer and the responds gem. Can't update the serializer because newer versions don't support responds_with.
When I call`cloc lib/` (`brew install cloc`) inside the cloned aasm/aasm repository, I get only 1,6k LOC.
But that case is fairly easily solved with negative lookahead: irb(main):019:0&gt; "abc def abc\r\nghi ghi".scan /(\w+)(?:(?!\r\n).)*(\1)/m =&gt; [["abc", "abc"], ["ghi", "ghi"]] irb(main):020:0&gt; "abc def abc ghi\r\nghi".scan /(\w+)(?:(?!\r\n).)*(\1)/m =&gt; [["abc", "abc"]] Granted, it's shorter with the new operator but the improvement is not dramatic. And if it is weighted against the change in the regex engine which might introduce new bugs but certainly will increase complexity, I am not sure the improvement is actually one. &gt; no-one else was talking about this new feature so I hope it's started a conversation others can extend :-) This is all fine. And we are discussing here and I have voiced my opinion. Btw. I believe it is on the authors who introduce something like that to come up with the "business case". They are doing it for a reason and I hope it is not only research interest.
but but but... *country* ?
I'm surprised `annotate` didn't make this list
&gt; ...And that's so much easier to read! :) It is a bit easier to read - but so much? And how many real world use cases do we actually have for this? Is the added complexity of the regex engine really outweighed by the utility? Edit: especially in light of /\r\n/ !~ a_string having the same effect
Hey Tech_Tuna, one of the current Komodo devs here. I'm interested in the deficiencies found in Komodo. I don't want change the subject of this thread but "Jenky" is the opposite of our design goals heh. Have you shared your thoughts on our forums by any chance? For what it's worth, I've used IntelliJ as well and loved it for Java but I'd still use Komodo over it if we supported Java. Too much going on in the IntelliJ UI for me. Interesting comments all around so far.
Why would we assume they left ruby when they decided to not use rails? The sounder choice when changing frameworks is to not _also_ change languages -- i.e. I'd expect teams that change frameworks to stick to the same language they are comfortable with.
Why is Yarn called Yarn when a Yarn existed long before it? Seems dumb. Not that this has to do with Rails but...
To add to this, it seems stylistically that :: is used to navigate namespaces. So if you have your classes stored in a module you can do something like... ClassCategory::SpecificClass.new or ClassCategory::SpecificClass.class_method
Oh, good point, I totally forgot that. So yes, double colon for namespace resolution and dot for calling methods
CW does have a config that helps, where moves the file instead of copying. 
Yeah one certainly needs to be realistic on both sides. A perfect app that no one ever signs up for is worthless, but a cobbled-together mess will be very hard (and expensive) to maintain if people actually start using it. Then again, Saleforce exists and they do quite well... so...
Yeah I really like it being a PORO. Reading into the docs for it, it makes for more explicit code but you have more control and are able to really see the flow. The issue I have is the groups are dynamic... they'll be created and deleted by the site admin. Group A can see index action for Files, Group B can not, but they can see index action for News.. as example. Trying to wrap my head around how to do that with Pundit in a non-messy way. I'm wondering I should have a "permissions" table with `group_id`, `controller`, `action`. Then in "FilePolicy" for example I can (crudely) do: # .... def index? # User can only see Files if their group has a db entry for controller = File &amp;&amp; action = index group_permissions.map(&amp;:action).include? 'index' end private def group_permissions @group_permissions ||= user.group.permissions.where(controller: 'File') end # .... Is that a messy direction to take?
Dynamic is easy, I'm not the biggest fan of attaching concrete permissions to controllers and actions, what happens if you want to reuse the policy elsewhere? But, not knowing anything about your system I can only assist with what I've seen. Let's give this a try! Hang your logic on the group itself instead of fiddling with it's permissions (you can talk to my friends, but not my friends, friends.) `Group` could have some logic in it (I prefer empty AR models these days and do everything from Service objects that always wrap a context/domain, but that's another story...) class Group &lt; ApplicationRecord def grants?(resource, type) grants = permissions.where(resource: resource).pluck(:grant) grants.include? type end end (optional) You could change your `pundit` context https://github.com/elabs/pundit#customize-pundit-user if you have a `current_group` set in all controllers for example. Then you could change your ApplicationPolicy to use it in all your sub policies with a good name like `group` instead of the default `user` which comes out of the box After those changes in `FilePolicy#index?` you could use your new `grants?` method ... def index? group.grants?(:file, :listing) # Assuming you changed your pundit_user end ... # or ... def index? user.group.grants?(:file, :listing) # Assuming you didn't end ... I prefer changing the `pundit_user` since it's what actually has the keys, and it makes the code dead simple. Does that help at all?
My friend, yours is a fairly reasonable end of this spectrum. If there are people suffering in the way you are suggesting, they have my sympathy, and I would not want to intentionally target anyone specifically for who they are, for no fault of their own. As far as I am concerned, I have met men and women, and people who claim to be all sorts of different animals, genders, no gender, multiple gender, quantum gender state, gender depending on moon phase, etc. If, like you imply, gender is in the mind and not the anatomy, then my terminology is incorrect, I am not particularly interested in learning these semantics, sort of like how I don't particularly care whether objective-C now uses [alloc init with potato] instead of (double)goofy: (NSString *) hamsandwich; Due to my lack of interest and apathy for identity politics, I am not particularly interested in whether someone is white, black, frog, man, pig or queer. I should not be forced to make their problems a part of my life. This is the core of my argument - my liberty, nothing else is relevant to me, because I simply do not want to consume my limited mortality with things I choose to not take an active interest in. If I misuse my liberty, people have the liberty to ostracize me - this is the system working perfectly, a free market of ideas wherein those with the best ideas inevitably shape society. If your ideas are the best ideas, society will naturally shift towards them. I will not be one of them. Sort of like how if someone else makes a better fork of an open source library, everyone is free to use their fork. Proponents who force people to conform to their specific idea of social justice are essentially saying that this fork is the one true fork, and if you do not use it, I will tweet to your employer and shame them until you are fired. 
Cool, but what's the use case for Redis? Do you think people trust Redis for persistent transactional data storage? I don't see a lot of people choosing redis over postgres or mysql.
* `Foo` is a class (or module, typically) * `Foo.bar` is commonly referred to as a *class method* as it is defined on the class and has no access to instance variables (aka ivars, attributes, etc). * `Foo.new` is a class method that returns an instance of Foo * `Foo.new.bar` is an *instance method*. Here we see method chaining where Foo.new returns an instance, and then we call the instance method (bar) on the new instance 
Interesting article, and what a speed bump! It seems as though Elixir (and the Phoenix framework) have been a favourite for many Ruby developers looking to try out new things, so I am curious to see what happens when Crystal is released. 
So I've had someone related to it reach out to me and suggest this: https://techracho.bpsinc.jp/hachi8833/2017_03_23/37689 .. it needs translation from Japanese, but appears to be attempting some use cases.
I think Crystal is a much better fit for ruby developers. You can still think in objects and the you already know how to use the standard library.
There are MVC frameworks there already. None of them are likely to be rails exactly because Rails uses so much meta programming and dynamism that's just not available in compiled languages.
Yeap, you can also include a `case` statement inside `define_method`, that's why I had write that metapgrogramming is not useful comparing with conventional method in this situation. Metaprogramming is not like a design pattern, it is writing code that writes code during runtime to make your life easier. And that comes handy in many situations, for example, when you have specified large set of things so that using metaprogramming reaches much faster rather than without that, when you are creating dsl, etc. I can give several examples where metaprogramming was used fairly widely: [aasm](https://github.com/aasm/aasm) [rails-activerecord](https://github.com/rails/rails/tree/master/activerecord). In rails metaprogramming was used widely not only in activerecord, but other parts, I gave that example as most expressive. Metaprogramming is usefult, but do not abuse it. Typically metaprogramming is used for defining methods in runtime, handle situations when method not defined, but needed handling it using `method_missing`. For example, [StringInquirer](https://github.com/rails/rails/blob/master/activesupport/lib/active_support/string_inquirer.rb) in rails' active support, gives you possibility to call any method ending with '?' sign for comparing i.e. Rails.env.development? Rails.env.staging?
I have a cronjob that dumps by database nightly and saves the .sql to an FTP server. That was one of my first automation exercises. I also have some nightly cronjobs that runs through certain DB tables and checks for particular changes or patterns that might be interesting to look at the next day.
Automate your automation learning, yo.
Does your internet connection ever get flaky? Is it the local wifi signal? A DNS problem? Excessive latency? Bandwidth overwhelmed? A widespread internet issue? AWS outage? How would you check and monitor this in an automated fashion?
I scrape websites with Selenium and (occasionally) Ruby. I run these jobs overnight on a Raspberry Pi and dump the data to a network hard drive
What do you do for work? If you're in school, what kinds of boring things to you need to do for your classes? Specifically anything involving a computer! :) It's much easier to automate and solve a real problem than a contrived one. 
I made a thing where I sent emails to a list of colleges asking for free stuff in Ruby.
Fun fact: most edible mushrooms are full of selenium, which is a pretty handy nutrient. 
Meta
It definitely could be, but I'm trying to keep Payment as much as just an interface to the database as possible. There are a few different types of payments (different processors, ach vs credit, etc) that have different criteria that make them voidable or not, so its just an extra bunch of junk that would clutter up the Payment model. It's a slippery slope!
what does the mail log say?
I have to email a time sheet every week. The hours never change so using Ruby and Prawn I enter the hours into a PDF, enter the date of the week, sign it, date it and email it. Then I get an email to say it has been done. 
+1 on the style guide
You can cat any ruby script
Yeah, the downloads count from rubygems is not super meaningful as a number itself. It's slightly useful as a comparison between gems, or over time. Even without bots, depending on different development and deployment workflows, 100 downloads could be just one developer/project using the gem, or 100, no way to know. 
You have a class called `UseCase::Base`. At what point do you ask yourself, "is this a bad idea?"
&gt; Ruby Tapas Episode 346 I do not know if I agree with Avdi's entire approach. If he is saying that User is a bad abstraction because objects are representations of non-real-world objects, then there is going to be some pain when you link say something like a product object because it exists in the real world and within the system. - I have a `user` who has an `account` is not really different to I have an `account` which belongs to a real-life `user` But then - I have a `user` who has an `admin.account` - I have a `user` who has an `user.account` - I have a `user` who has an `customer.account` In the above case, a `person` would have `3` `accounts`, `3` separate logins etc, which I think is more inline with what he is saying. Also the fact that `user` could be replaced with `rest-client/automation system` etc etc, which I think forms part of his side of the picture. But the comparison to that is: - I have a `user` who has an `admin.role` - I have a `user` who has an `user.role` - I have a `user` who has an `customer.role` But once again `user` is deemed to be a `person`, which again I think forms part of his discussion. So this looks to be very much a naming issue. - A `user` is expected to be a `person` - A `account` is expected to be `something` which interacts with the system Both `user` and `account` have properties and methods. Now back to your code ... &gt; Consider a simple app where users submit links. We create a Contributor model to represent this behaviour. This Contributor has an Account. No a contributor does not have an account, an account is a contributor. Minor distinction, but it would mean you are just changing `user` to `contributor`. It is whether the account has the privilege to `contribute`, does the account posses these properties. contributor = current_account.contributor contributor.links.create(url: '', title: '') There is a law of demeter issue here, and that raises part of the concern I think. You should not reach across `current_account` to `contributor` to `links` to it's methods. So the `current_account.contributor` is simple `account`, which has it's own credentials. Now there will be some befuddlement here with the idea of `roles`, what is a `role` and `what` is an `account`. If an account only has the option to `contribute` then it is a `contributor`. And that is where my mind explodes, and I simply view the world as follows: * `user` is an entity which interacts with the `system`. * `user` has a `role`. * `role` determines what it can do in the system. Summation ... `users` is a syntax which we have accepted, `account` is just being injected because `users` may not be `persons`. `accounts` have purposes, `roles` have action. So in conclusion, WTF ... 6 to half a dozen, and it will be determined by the application needs. 
I'm a CS student and the most boring part of my first year is copying our student's handbook by hand. Because my lovely professor believe that that's the most effective way for retaining material. Is there a framework for this? Hahaha. Anyway, my first idea is to make a script that behaves like `npm init` for jekyll. One that asks for the title, link, tags, categories etc. of a new post and generates the appropriate `.md` file. That should be pretty trivial, right?
My first automation was to text me my savings account balance when it dipped below a certain amount.
I use Ruby for web automation. These days I made a tool to inform me about new anime episodes. Uses embedded jruby in a java app. Made an eBay sniper to buy auctions before. Made some rails sites for displaying information about my CSGO / Minecraft / ark / team speak server. Made a rails app for my proxy service I usually get inspiration from what I want during the day
Are you [sure](https://github.com/ruby/ruby/commits/v2_4_1/vm_insnhelper.c) ?
Should be easy enough... might want to pick up a raspberrypi and some servos to help though.
I have dodgy internet connectivity, can this be done with Ruby? I've been teaching myself Ruby on Rails for a couple of months so I understand‚Äã I've not really been properly programming in Ruby, I've really only been creating simple Web apps, but I'd definitely give this a go if it's achievable!
I'm thinking about setting this up but for now it's all in the repo so it's versioned too. Sorry if this wasn't the answer you were after.
Do you know standard GitHub wiki, existing in any repo, is a repo on itself, and could be versioned and edited locally, then pushed?
"UseCase" is an unnatural term for talking about an applicative operation. The term "command" is already well understood, anyways. "Base" is another unnatural term. It's meant for deduplication via inheritance, which is almost always going to lead the code in the wrong direction. I can go deeper here if you want, but suffice it to say you are not helped by presuming that every command (or "use case" as you say) has a single dependency -- a repository. There will be commands that don't depend on a repository. There will be commands that depend on more than just a repository. It's probably going to save you a lot of headache to just implement the constructor in the command objects themselves, and drop the `Base` altogether.
at least on my server it's `/var/log/mail.info`, check apache configuration.
does not exist on my server.
what distro are you running? In CentOS my exim logs to /var/log/exim/*.log You'll need to find the mail log like /u/gray_-_wolf said. Its the only thing that will tell you whats wrong. Unless you want to sniff the port 25 connection and try to listen in with TCP dump. 
[Use cases](https://en.wikipedia.org/wiki/Use_case#History) have been part of the literature and in industrial use for at least thirty-five years now. Jacobsen's 1992 book *Object Oriented Software Engineering: A Use Case Driven Approach* is one of the half-dozen classics I expect to discuss with every new hire, and there have been hundreds of other books and thousands of blog posts, conference presentations, and so on, on the topic. It influenced Kent Beck's XP and TDD approaches. To say that it is an "unnatural form" suggests that one has not had as broad an exposure to the skills and literature in our craft as one might think. /u/s_makagon: I just finished a quick read of your post. For background, I've been using a use-case driven approach in several projects for well over a decade now, in multiple languages. Your `Repository` looks fine, but I would argue against a `UseCase::Base` hierarchy, especially in a dynamic language like Ruby. "Prefer composition over inheritance" is as helpful as [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design%29) when creating good software or improving existing code. Our typical use case "high-level service object" usually looks something like class RegisterAsNewMember def self.call(input_params, repo = UserRepository.new) new(input_params, repo).call end def call # Short, high-level logic goes here. Tell, don't ask. result end def result Result.new result_params end protected def initialize(input_params, repo) @params = InputParams.new input_params @repo = repo self end private def_delegators :@params, :confirmation, :email, :name, :password attr_reader :repo # ... implementation details # Validates and encapsulates input parameters. Raises on invalid data. class InputParams &lt; Dry::Types::Value # or equivalent attribute :name, Types::MemberName # tailored/validates string type attribute :password, Types::Password attribute :confirmation, Types::Password attribute :email, Types::Email end private_constant :InputParams class Result &lt; Dry::Types::Value # or equivalent attribute :success, Types::Strict::Boolean attribute :message, Types::Strict::String end private_constant :Result end Our actual class has a somewhat more detailed `Result` class, but you get the idea. The point is to have *no* externally-visible state; the returned `Result` instance is the sole "export" from the black box. We leverage [dry-rb](http://dry-rb.org)'s [`dry-struct`](http://dry-rb.org/gems/dry-struct/) Gem to give immutable value objects with attributes that *must* match criteria. The nested value objects are private constants because the caller shouldn't care that we call this a `Result` object; it should care whether it was successful and what the result message was. Doing it this way makes testing much more straightforward, and enables you to reason more easily and reliably about the code and its effects. Good luck.
&gt; To say that it is an "unnatural form" suggests that one has not had as broad an exposure to the skills and literature in our craft as one might think. Use cases belong in an entirely different context than code. I was not implying that the term itself doesn't belong in a programmers vocabulary. To name a base class‚Äã "UseCase" is to suggest that use cases can be epitomized by a single object. This is not _generally_ the case. Deployment is an important concept in most types of software. If I suggested a class called `Deployment::Base` was a mistake, that wouldn't imply I think that deployments shouldn't exist.
I am sorry for not explaining clearly. I am running debian. I found the log. It says "retry time not reached". edit: grammar
Nope, that's awesome, I have used them in the past, but didn't know there was some way to manage them offline. The wiki documentation in Utopia is also a limited form of dog-fooding - I can try out new ideas and have a running site right next to the source code to evaluate it, and it also ties in loosely with the yard documentation.
Hello, recently I've been building this gem and it's starting to get some shape. Fell free to peek into code and comment, I'd be more than glad. Initial purpose was to learn some basics of ORM/ODM, then I realized there is no up-to-date Ruby gem for Firebase, so maybe it can be usefull for someone.
This blog post is totally unconvincing. "Mutation is bad" but corrupting your Public API with arguments that exist solely for mocking is "good"? God help us all. I'll be honest, I *hate* the practice of modifying public APIs just to add surface area for mocks. It's conflates what should be two separate goals, API design and testability, out of misguided idea that other tools Ruby gives you for achieving mocks are "bad" or to be avoided. It also de-localizes reasoning, so that now to understand how any piece of code works, you have to go investigate its call-site to understand what the reified dependency that gets injected actually *is*. De-localized reasoning is an *extremely bad* thing to have in any codebase. DHH had the exact right idea here in [Dependency injection is not a virtue ](http://david.heinemeierhansson.com/2012/dependency-injection-is-not-a-virtue.html). *Don't* corrupt your API by adding method arguments that exist solely for testing purposes. *Do* feel free to mutate things that *aren't* the subject of your test. This is a strength of Ruby, not a weakness. If you want to write Java, go write Java.
It becomes arg since you passed it directly into the method. You didnt stash the return anywhere to use it again later(outside of the get_input method) if thats what you intend. 
Think of it this way: what does "deployment" *do?* Those activities are your domain objects; you express their collaborations through their interfaces, and what we might previously have coded as a subclass of `Deployment::Base` becomes simply calls on these objects to achieve the deployment or report its failure. Given a set of well-encapsulated and -designed domain objects, the actual invocation of them becomes trivial and uninteresting, worthy of a class only in languages that sharply limit what you can do outside them. Yes, it's a major shift in how you think about development if you're coming from languages like Ruby, Java, or C#. But that doesn't make it alien to those languages; if you come out of a functional background, this is *basic.* But it took me about five years before the light well and truly came on, too. But I've been writing software for some time (since '79); my observation has been that the longer someone has been using one style of development exclusively, the harder it is to become proficient in another.
If you explicitly define all your methods (`def &lt;method_name`) it makes it easier to lookup definitions and also can make the stack trace more clear when debugging. Obviously method_missing gives you more flexibility. I'd probably only recommend using method_missing if you are making a DSL. 
The problem with Elixir is that it doesn't have polymorphism (in functional world it's called multi-methods) and because of that you end up dispatching the methods by hand. They say Elixir has protocols and it's same as multi-methods - that's a lie, because if it would had true multi-methods, there would be no need for ugly stuff like `tuple_size(tuple)` or `Map.keys(map)` there would be plain and simple `size(tuple)` and `keys(map)` instead.
Haven't tried drawers, cannot comment.
I am sorry, seems like I misconfigured exim4. I solved it by reconfiguring it with sudo dpkg-reconfigure exim4-config.
Thanks for your comment. I'll be honest too that I can't agree with you on any of your points. The point of the post is constant mocking which mutates core/third-party classes is "bad" and "horrible", especially if you do it globally; and one of the ways to avoid that is dependency injection. If you have another approach to achieve that, then congrats! Give it a go, and feel free to share your approach. The example in the post as you can see, it doesn't change, complicate or "conflate" the API much (yes I lie), we can still invoke the default behavior of `Clock.current` with no injection needed. But the impact is hugely different, since it clearly describes which dependencies needed for that class to work. "API design and testability are two different things" is the most ridiculous thing I've heard this month, how can your API design be good while it is untestable??? "Do feel free to mutate things that aren't the subject of your test. This is a strength of Ruby, not a weakness." Thanks Gods for having DHH in our lives, so we have someone to rant on. Let me tell you one thing, we're allowed to pee in the kitchen sink doesn't mean that we should. And lastly, I would advise you to go write some Java, instead of Ruby, and understand more about how to write proper code.
Well my cousin was about to download 360 images from some webserver, and he was sitting there manually changing a id in the url, the downloading the image. So i made a quick ruby tool that does exactly that. If you want to try it yourself, the url is http://cube.crider.co.uk/visualcube.php?fmt=svg&amp;size=200&amp;&amp;cc=n&amp;co=50&amp;r=y1x34&amp;fd=ttttuttttttttrrttrtttfftfttdtttdtdtdtttlllltltttbbbbtb see that "y1x34" part? 1 is the id (up to 360) Its part of some animation idk.
Note also that traditional regexps let you do this exact same thing with a _single_ character, like: `[^c]` -- match any character that is not `c`. I have used that from time to time, and have sometimes wanted to do the same thing with a multi-char string -- which is exactly what this let's you do. I'm pretty sure (although I am actually kind of just guessing, I haven't demonstrated it or anything) you could express the semantics of this new thing in terms of traditional regex operations -- although in a really illegible and hard to write manually way, but as an automatic transformation into a fairly illegible regex. Involving a of sequences of lots of negated character classes with single characters, separated by vertical bar alternation operator. A really long illegible sequence. But especially if that's so, this new thing isn't _that_ weird, it's just a convenience. 
Great post, though more useful for anyone else reading the thread... I'm very comfortable with objects named after verbs, as you describe :) The main gist of what I'm saying is that the notion of use cases shouldn't show up in code. It can't be guaranteed that a single use case can be epitomized by just one object, since the overall operation could cross over several consistency boundaries, round trip through a microservice or two, and eventually update a read model somewhere.
Thanks again for examples. It's just great. Yes, I have couple more questions if you don't mind. When I was implementing business logic this way - one part that was questionable for me is validation. We can validate format of data we accept using `Dry::Struct`, but what about business rules. For example if I have business rule that email should be unique. Where and how would you check uniqueness of email?
&gt; But the impact is hugely different, since it clearly describes which dependencies needed for that class to work. Nope. It actually does a really *bad* job of documenting dependencies, breaks encapsulation of your `Clock#current` method, and in general, like I said before, results in de-localization of reasoning in the codebase. Consider: either `Clock#current`'s caller reifies a different "clock", or it relies on the default. What does `Clock#current` return? Well in the case of the default, it returns the result of `Time#now`, an instance of `Time`. In the case of the caller passing in a different "clock", `Clock#current`, returns...well, we literally can't make any guarantees about that. *How* the caller of `Clock#current` calls the method now has a huge impact on the behaviour of *consumers* of `Clock#current`, which de-encapsulates the knowledge of how `Clock#current` is called, and the internals of `Clock#current`. Like a global object, you've introduced spooky-action-at-a-distance, a rich and plentiful source of bugs. Thus it's not enough to say that `Clock#current` requires that its "clock" argument responds to `.now`. In actual fact, because of the de-encapsulation, the *only* way to avoid breaking downstream consumers is if the "clock" argument to `Clock#current` perfectly preserves the semantics of `Time.now`. What was previously an easy-to-preserve invariant of the method is now subtly and easily broken unless you introduce a lot of code to try to re-preserve it. In Java, you could use the compiler's strong typing to maintain the return invariant of `Clock#current`'s type even with the introduction of the "clock" argument. Ruby offers you no such guarantees, so blindly copying Java's strategy for DI quietly landed you in a world of troubles that Java didn't have to care about. Good luck writing your integration tests in a way that decently accounts for any of this -- every DI-able argument you introduce to your public API vastly complicates how many different codepaths your integration tests need to exercise. &gt; "API design and testability are two different things" is the most ridiculous thing I've heard this month, how can your API design be good while it is untestable??? It's not that your API should go untested. It's merely an engineering 101 observation that "API design" and "testability" are *competing goals*, and that there are tradeoffs involved. Adding magic parameters that API consumers "shouldn't call" to public methods sacrifices good API design and encapsulation (as demonstrated above) for testability. Sometimes sacrifices are necessary, but they need to be well-justified. Here, they are not. There are simple ways to achieve testability without corrupting the public API, and you haven't *justified* why it's preferable to avoid them -- you've merely called them "bad" and "like peeing in a sink" without any real argument to back that up. I argue that, given the loss of encapsulation, loss of method invariants, introduction of unprotectable non-public method arguments to public methods, and exponential complication of integration testing, your "cure" is worse than the disease. &gt; And lastly, I would advise you to go write some Java, instead of Ruby, and understand more about how to write proper code. I've got years of professional Java experience. The average Java codebase is a mess, and I wouldn't look to the Java community for any great understand of how to achieve good software quality. They do provide plenty of examples of what not to do, though.
I don't really buy the mutation argument; its a bit melodramatic and unlikely to bite in most cases. I agree that DI is preferable in many cases though, not because of mutation but because it is a better driver of TDD *for me personally*. Others mileage may differ. In the case of the example you provide, I'd be tempted to suggest an alternative and trot out the old 'code to an abstraction not an implementation' i.e. don't use Time directly; the benefit being that you would not have to repeat the DI. Good article though since I've not really thought about these things in a while.
Protocols definitely provide polymorphism and you can implement the size or keys function you want very easily: defprotocol Size do def size(xs) end defimpl Size, for: [List, Map, MapSet, Range, Stream] do def size(xs), do: Enum.count(xs) end defimpl Size, for: Tuple do def size(xs), do: tuple_size(xs) end defimpl Size, for: BitString do def size(xs), do: byte_size(xs) end You could then `import Size` and call the `size` function with any of the types that an implementation has been provided for. In many cases where this would be useful the type in question will also be `Enumerable` so you could simply call `Enum.count` instead. This is almost exactly the same as multi-methods in Clojure and Common Lisp. `tuple_size`, `map_size` and `byte_size` are Erlang standard library functions and Erlang doesn't have protocols or anything similar.
the namespacing parts i understand. what i dont understand, is if we end up with the plugin folder+plugin.rb setup (like a local gem) - what happens to all the controllers?
First of all I have to admit that my approach might be not good enough and introduce an ugly API. You could see a better alternative introduced by realntl above. I would like to add / clarify some comments on your reply. When you say the dependence on "clock.now" which might be a error-prone, that's exactly what I said above, we explicitly declare the dependencies of the class (maybe not in a good way). And if someone passed other "clocks" instead of Time to the function, then good luck. *You should know your code*. People passing silly parameters is something you can't control. &gt; There are simple ways to achieve testability without corrupting the public API, and you haven't justified why it's preferable to avoid them -- you've merely called them "bad" and "like peeing in a sink" You put my words in different context and it's a million miles different. The thing I compare to "bad" and "peeing in a sink" is monkey-patching and "Do feel free to mutate things that aren't the subject of your test". Monkey patching is bad because it makes maintaining codebase harder. Ruby gives us the freedom to modify the core classes doesn't mean we should do it. And sorry to hear about your bad experience. &gt; I've got years of professional Java experience. The average Java codebase is a mess
Use Angular if you are up on it... they do the same (mostly) stuff... just in different ways... ;)
interesting. thanks. I've never seen that syntax before.
it's the exact same syntax you used in your second example, just with different indentation. Yes, I do it sometimes too. Although if your code has _lots_ of these large if/elsif branches, there's probably a better way you could be structuring the code on a more macro level in many cases. 
&gt; If you need to understand the entire codebase to modify any of it, that's incredibly bad for the long-term maintenance of the project. If you don't understand the codebase and are going to modify any of it, then it's more than incredibly bad for the long-term maintenance of the project. And I think you misunderstood what Encapsulation in OOP is (correct me if I get you wrong). Encapsulation is a mechanism of wrapping the variables and code acting on the data (methods) together as a single unit. I would consider _The loss of encapsulation_ you mentioned is "decoupling". And yes, I know RSpec did a trade-off with "limited monkey patching" and bunch of magics under-the-hood to achieve the so-called nice syntax and features. It's so easy to use and looks so nice. But rethink why we need them while there are so many "simple" ways like you said? One more additional point is that RSpec 4.0 has planned to go zero monkey patching totally as stated in this post (not sure if it's dated) http://rspec.info/blog/2013/07/the-plan-for-rspec-3/, and they did write a blog post about the decision. You can easily google that. &gt; Why would monkey patching contained solely in a test make overall maintenance of the codebase harder? You seem to like putting words in my mouth or perhaps I didn't explain clear enough. As mentioned in the post, the core methods (`Time.now`, `Kernel#rand`, `Kernel#sleep` particularly) got modified/mocked/stubbed/ignored and it could affect the behavior of other core classes or libraries depends on them. And of course, the "monkey-patching" in RSpec isn't as nice as what you see in the implementation of the post. The "counter", "mutation", "original method" are kept and accessed *globally* in the test example. So let's say if: &gt; it "examples" do &gt; &gt; expect(Time).to receive(:now).and_return(time) &gt; &gt; # Test setup &gt; user = User.create(params) # ActiveRecord#touch depends on Time.now &gt; &gt; some_task_that_call { Time.now } &gt; &gt;end It's hard for us to make sure that ActiveRecord won't get affected in this test.
Protocols are too heavyweight to be a generally applicable. And that's the true reason why you have all those ugly `map_size(map) ... tuple_size(tuple)`. Not because it's Erlang standard. Elixir doesn't use same standard library as Erlang, it added tons of new stuff, so it seems strange why not to add `size` function. The true explanation is - because it's hard to do so in Elixir. That's why it has all those ugly `map_size(map) ... tuple_size(tuple)`, not because of compatibility with Erlang. And, you seems to miss the point of polymorphism/multi-methods. There's no much sense to have one or two multi-methods (like Elixir), to get its true power everythign should be polymorphic (like Julia or Clojure or Ruby).
I prefer def putter return "yup" if a return "nope" if b return "ok" if c "billy bob" end
&gt; What's confusing me is I don't understand where the return value of gets is stored after the method call. The return value of `gets` is stored in `arg` after the method call to `gets`. After the method call to `get_input` the return value of `gets` is stored nowhere.
Check out HAML or Slim
If you prefer jade's syntax you'll want to look at slim (http://slim-lang.com), the syntax is almost the same as jade's. Sinatra should have support for it, just need to configure it. Regarding nested templates, the Sinatra docs have some info: http://www.sinatrarb.com/intro.html#Templates%20with%20%3Ccode%3Eyield%3C/code%3E%20and%20nested%20layouts You may also find some Sinatra addons useful that provide extended functionality, e.g. http://www.sinatrarb.com/contrib/content_for.html 
Well, exact same syntax plus the `then` keyword
i can see that redid is more convenient for you to develop squad, but most times our crud applications are not just storing and retrieving fixed resources. we depend on an ORM to handle complex queries and such. Won't we lose all that relational power with redis?
I would probably start by writing it identically to your second syntax, but like others have said, I prefer a private method better than either. I've never been a big fan of early returns. To me, they are less clear and obscure the flow. 
It's funny how you get used to something and then you feel that it is the best way. I like early returns at the beginning of my methods, typically for validation or special cases. Then I know that everything is the way that I expect it later on. Then again, I don't like my methods more than about 5 lines anyway.
I am not a fan of this method as it (though in a very flat and simple manner) introduced multiple exits from the function. This case obviously isn't that bad now, but as a general rule I like to avoid this.
Your second example is superior bc u are isolating the variable assignment from what you do with said variable. I would use `case` and inline `when ... then` pairs &gt;:D
I understand your problem and you might like Utopia, it provided a view layer that aligns more with your expectations. I'm on mobile but if you want more help just let me know.
agreed, I don't know why that got upvoted. 
This can be flattened a bit... putter = case when a then "yup" when b then "nope" when c then "ok" else "billy bob" end Though in Ruby [case statements are slower than if statements.](http://midwire.github.io/blog/2011/08/26/ruby-performance-case-vs-if-elsif/) So I would be inclined to do... putter = if a then "yup" elsif b then "nope" elsif c then "ok" else "billy bob" end
Also pretty new to Ruby; my one suggestion is to switch to Rails... you'll get so much more done 
That guy should be necessary reading for rubyists.
oops good call
Wouldn't `post.comments.count` run `SELECT COUNT` instead of loading all the comments into memory?
Yes, but if you're calling `post.comments.count` in a loop, then you've got N+1 queries. posts.each do |post| post.comments.count end If you've got 100 posts, this will cause 101 queries, which will be slow. 
oh I get what you mean now. If you use `includes` then it will load all them into memory before doing the count. I do this with `joins` and `where`. 
An alternative using guard clauses: def putter return 'yup' if a return 'nope' if b return 'ok' if c 'billy bob' end
I understand your concern. But in my opinion (which is similar to the framework), a model should be simply a representative entity, which means that if you want to change the data in the console, you can do it, because it does not apply to the business rule. If you want to use a rake task to work on your data, you could create a PORO that uses the params to handle validation
Yeah, this is a nice solution to that problem.
 [a, b, c, d].zip(["yup", "nope", "ok", "billy bob"]).find { |input, _| input }.last 
We use the `parallel_tests` gem. Yes we distribute tests across multiple nodes and for acceptance tests we dynamically allocate them to one of three nodes. In total the test suite takes less than 5 minutes. On your laptop it would probably take more than 12 hours to run
https://www.ruby-lang.org/en/news/2017/03/22/ruby-2-4-1-released/
FWIW, #round already supported this argument. Never thought to try a negative value though - pretty useful.
that's not just only key-value with Redis, but also included relational functionality in Squad or ORM. Please refer to README in that Github link.
Just to spell this out, in case anyone reading is at all confused: * Ruby version `2.4.1` is currently the latest version (released a week ago). * Ruby version `2.2.7` contains some bug/security fixes, for the `2.2.x` branch. This is only to support projects that cannot yet, for whatever reason, upgrade to version `2.3.0` or above. If you are creating a new ruby project today, you should (probably) use `2.4.1`, not `2.2.7`.
How exactly does one hire a Bro Army?
This is actually pretty convenient. 
For a couple of years I thought I'd prefer #3 because of the syntactic sugar and for being able to maybe inject a lambda for testing or whatever. As it turns out, I never used the syntax or the injection. So I just stick with something similar to #2. Might sometimes be redundant (class and method names are basically the same) but that's not always true since not all policy classes will necessarily have only one method.
&gt; Tests are another user of an interface. From a perspective broader than software, one tests a part using the same interface that connects that part with the rest of the system. The goal of a test is to ensure the 'thing' works as it will be used in production. When you start adding functionality that only operates when tests are running you're no longer testing the code as it will operate in production. In my time I've seen numerous bugs slip through because of this. I almost never use 'test dependencies' or mocks anymore as a result. About the only thing I mock are external interactions, e.g. external HTTP calls.
Interesting article as always, just there is a little typo in `map` block where was used both `do` and `{`...`}` construction in one block. def all_names fetch_data("/users"). map do { |data| convert_to_name(data) } end instead of def all_names fetch_data("/users"). map { |data| convert_to_name(data) } end
you can find them at any Ultra festival.
I'd say having Sunday as the first (0th) day of the week is in keeping with older languages and standards that most developers are used to. I would generally treat Sunday as the 0th day of the week and be surprised if I encountered something different.
Not really an explanation - just my own speculation... Rails has a lot of core extensions, which allow you to write short code that looks good, but arguably makes it a bit harder to understand the Ruby standard library, Rails and how they overlap. Most of this is from the sunshine bag that is `ActiveSupport`. I dug into the history of `to_datetime`, which I have never used before (I didn't know it was defined on the String class). Apparently, it was added 10 years ago in this commit: https://github.com/rails/rails/commit/4685fa0c20fbf3e78eaad94756e0f4a644447a10 I don't know why the author felled compelled to add this method, but I have noticed that Rails has quite a few of these `to_*`methods defined on core classes. I just did a sample from a fresh Rails 5.0.2 project on a String. "foobar".methods.grep /to_/ =&gt; [:to_json, :to_c, :to_blob, :to_time, :to_str, :to_sym, :to_s, :to_i, :to_f, :to_r, :to_d, :to_date, :to_datetime, :to_json_raw, :to_json_raw_object, :to_yaml, :to_yaml_properties, :psych_to_yaml, :to_param, :to_query, :to_enum] Compare this to plain Ruby and you "only" get: [:to_c, :to_str, :to_sym, :to_s, :to_i, :to_f, :to_r, :to_enum] In conclusion, Rails 5.0.2 adds the following methods to String: [:to_json, :to_blob, :to_time, :to_d, :to_date, :to_datetime, :to_json_raw, :to_json_raw_object, :to_yaml, :to_yaml_properties, :psych_to_yaml, :to_param, :to_query] Anyway, when you call `"Sunday".to_datetime`, you are, as you discovered, actually just calling `DateTime.parse("Sunday")`. This tries it's best to extract something meaningful from the string, but there's really no guarantee that it gets it right. `"Black Friday".to_datetime` returns March 31, 2017 for me at the moment. Only if the parser has no idea at all, it will error. `"Groundhog Day".to_datetime` throws an error. In conclusion, date parsing of "human strings" is a recipe for suffering and you should always look for ways to avoid parsing unstructured date strings. So what is up with `Date.today.sunday` ? `Date.today` returns an instance of `Date` and if you look at this 5 year old commit: https://github.com/rails/rails/commit/da26dfbefdccac4ab1f3195ae747685d2b11be13?diff=unified you will see that it's being augmented with more methods. In this implementation, the methods `sunday` and `monday` have been defined to return the date for either the sunday or the monday of the week in which the Date instance belongs. And if you look at the source, you can see that these two methods explicitly assume that a week starts with monday and ends with sunday. In comparison, plain Ruby assumes that sunday is the first day and saturday the last. And why this difference? I can't give an exact answer, but Ruby has Japanese origins and when I look at https://en.wikipedia.org/wiki/Japanese_calendar it seems that Japan regards Sunday as the first day of the week. So maybe that's why? In conclusion: - Ruby or Rails have never been able to handle "next" or "last" as modifiers in date parsing. - `"friday".to_datetime`forwards to `DateTime.parse`, which silently ignores ambiguity or unknown segments in the date. So it's dangerously unreliable alone. `DateTime.parse` is a plain Ruby method. - `Date.today` returns an instance of `Date` - `date_instance.sunday` doesn't return the last or the next sunday - it returns the sunday within the current week (relative to the date instance). Same goes for `date_instance.monday`, these are Rails (ActiveSupport) methods.
The problem is that i have to use 1.9.3 at work, i would love to be up to date thought 
Have you contact RubyMonk yet? That might help solving the issue faster
While an interesting read, I'm rather confused as to the focus on Rails as a source of this problem. It seems that the source of confusion is how `DateTime.parse` acts. Rails adding `String#to_datetime` doesn't make it notably more confusing, in fact it does exactly what I would have assumed. 
According to a quick search I just did, ISO 8601 says the week starts on Monday. That must explain why Rails does what it does, but IMO it's a terrible standard.
[Here's a map](https://commons.wikimedia.org/wiki/File:First_Day_of_Week_World_Map.svg) of what different countries consider to be "the first day of the week". (Although, I suspect it's a little misleading since not everyone in a given country will agree... For example, I'm in the UK and was taught in school that Sunday was the start of the week.)
I was genuinely surprised to find out that some people consider Sunday the first day of the week just recently, after spending 20 years dealing with american people on the internet. I guess nobody thought it worth mentioning in all those years.
Yeah, I wonder how this will play with Docker images which usually run as root user.
To be honest, I wouldn't expect `"Sunday".to_datetime` to ever work in the first place.
If you are looking for someone to fill in while you find a more permanent member of staff, give me a shout - I'm based up in Glasgow.
Also, thoughtbot talked a lot about your gem in [the latest Bikeshed episode](http://bikeshed.fm/105)!
Thanks for the offer Jhon but I dont think we will need a filler in case we'll keep your name in mind.
no offense taken but this is the rate for a junior dev in uk considered that we are open to first timer, that only a reference that can vary depending on the experience of the candidate and sincerely I don't think you could compare salary from two country in a such mathematical way because they're not based only on the cost of life but more on the market demand supply. FYI this is a very useful article on UK rate's for ruby dev: https://hackernoon.com/uk-ruby-salary-bench-marking-2017-e852d1d7702e if that are the rates in NY I'm happy for all the dev there and if I'll ever come to visit I know who to offer me a pint ;)
I used this technique recently in [tus-ruby-server](https://github.com/janko-m/tus-ruby-server), where I needed the functionality of streaming large files from [Filesystem](https://github.com/janko-m/tus-ruby-server/blob/e0b3685349934686574a0afa0aa179546ab2be4f/lib/tus/storage/filesystem.rb#L79-L88)/[Gridfs](https://github.com/janko-m/tus-ruby-server/blob/e0b3685349934686574a0afa0aa179546ab2be4f/lib/tus/storage/gridfs.rb#L113-L138)/[S3](https://github.com/janko-m/tus-ruby-server/blob/e0b3685349934686574a0afa0aa179546ab2be4f/lib/tus/storage/s3.rb#L116-L121) into the Rack response, and creating an Enumerator which responds to `#each` an reads the file in chunks on demand solved it really nicely (it wasn't a lazy Enumerator, though, just a normal one). Really useful, I'm happy someone wrote about it.
None of that is the issue, not sure why the focus is still on rails... All that is going on here is an issue that is as old as the gregorian calendar itself, is Sunday at the beginning of the week or the end? Whomever wrote `DateTime` thinks it goes at the beginning, whomever wrote `Date#sunday` thinks it goes at the end (which is the ISO standard). That's the confusion, nothing to do with API design or monkey patching, just a conflicted calendar system. Ruby's time systems aren't always consistent on this either, e.g. there is Date`#cwday` and `Date#wday` to support both and which one will get used under the hood varies a bit.
I had no idea so many countries considered Monday the first day of the week. The crazy part for me personally is that I actually lived in France for the better part of a decade, and either I've managed to completely forget this bit of information, or I somehow never picked up on it in all the time I lived there.
To be fair, it's pretty much irrelevant which day is the "start of the week" ... We're all in agreement that Saturday-Sunday is "the weekend", and that's all that really matters, for the most part. I suspect that this disagreement has religious origins. Originally, "the sabbath" (Saturday) was on the 7th day of creation - thus Sunday was the start of the week. Then, over the centuries, Christianity shifted to [celebrating the sabbath on Sunday](https://en.wikipedia.org/wiki/Sabbath_in_Christianity#Early_Christianity). Maybe now, some people are interpreting Sunday as being "the 7th day of creation" instead - hence the confusion?
I feel sorry for junior engineers in London then, it must be a nightmare surviving on that kind of salary in a city like London. 
Your first attempt would work except there's one tricky thing. Setter methods which use `=` need to have an explicit caller otherwise it's treated as a simple variable assignment and the method will not be called. For example, you could write this: # init last_ok puts last_ok self.last_ok = "project 1" puts last_ok The fact that you often have to add `self` before calling setter methods is something you just have to remember. An alternative would be to name the method something without `=` such as `set_last_ok`. Then you can say `set_last_ok "project 1"`
Abstractions aren't fake. We are talking about substituting one function that emits time based on the system clock for another that emits a fixed time. This is actually _less_ complicated, by a substantial amount. The tests prove it out -- if you go with the hard reference to `Time.now`, then instead of controlling the clock used by the test subject, you have to use a gem like timecop to shift the gravitational force of the universe just to make the outcome deterministic. So, no, I never "fake" time. Timecop, on the other hand, that's definitely "faking" something.
I'd prefer the first one myself, though you are repeating on the puts, it's not something worth worrying about for such a trivial example. By the time it gets complicated, I'd expect the bodies of the branches to be method calls.
Very interesting. What type of reporting (if any) does it have? For example, I'd love to be able to get totals by line items across multiple invoices. 
Agreed. There are already so many page object frameworks. PageObject, taza, siteprism, etc. 
It would be interesting to add support for "line items" within invoices. It would be easy to add and would actually probably save me quite a bit of time if it helped with auto-complete. Alternatively, you could just group based on titles, but it would be less accurate. I have quite a bit of data in financier so I'd need to retro-fit something in order to generate reports.
No, for simplicity here in the article I keep it in the memory. You can store it in files or database, though.
This sounds sort of like the concept of database normalization, but applied to classes.
Four Days on Rails isn't relevant anymore. It's using Rails 0.10
You say crappy developers. I say crappy beauracracy when i actually do the right thing and introduce a new class, then management (or usually the tech lead reviewing stuff) have to prove to themselves and juniors that they do something important ask us to put it as another column in existing class because "don't repeat yourself". In my mind "oh well, you give me no incentive to actually tell you my idea you would consider it silly (sigh, these freshers). So i won't hesitate to look away when you reject my professional opinions" 
Are there instructions for starting Hanami from an existing Ruby script? I.E. not from the `hanami` executable?
I thought something was strange when I got to the part about configuring fastcgi.
Locomotive is useful among these.
Wouldn't that set the `last_ok` property on whatever is `self` at the moment? So in contrast to `Last_Ok.project` it wouldn't act as "global" setter, correct? Or am I missing someting?
That's exactly how I respond to those damn things. Went to buy a Postgres book yesterday and the site had two. Nope. 
We can always respond to that with, "business concerns, and my professionalism, dictate that I don't take costly shortcuts." But many of us often don't.
Contests, login codes, surveys, item updates. All kinds of uses. I've done several in the past.
Post the error message, please.
I think this has roots in functional programming, and the that like the if else / case have not done a functional language yet and the procedural roots are hard to pull away from... &amp;nbsp; I like how I can use the most frequent guard clause ( unless the default is most common ) to make the function more efficient. &amp;nbsp; BTW... whatever language you are using, codewars is a great way for you to up your game and then see how people better than you ... and me ... do it.
Michael's tutorial is ok, but if you want a really good book, Rails 4 in Action 's great. I'm not sure if there is a 5 out yet, but I can tell you the aforementioned will get you in a much better spot than the Rails Tutorial. 
I feel like you picked the worst date for this question
I mean that I want to _start_ Hanami from inside an existing ruby process. Something like this: `Hanami.start(my_app)`
My Bad! I will post it when I'm back at home.
Yea crystal is nice but you can't embed it into other things AFIK.
Ok so here's what I did and the error: 1. Open Terminal 2. cd desktop 3. cd programming (&lt;- this is the folder I created on my desktop for my Koans and other programs) 4. cd Koans 5. path_to_enlightenment.rb Then I get the error that says "-bash: path_to_enlightenment.rb: command not found
You need to specify the path to the file: $ ./path_to_enlightenment.rb "`./`" refers to your current directory &amp;nbsp; Edit: If the file is not executable, you will actually need to launch it through ruby: $ ruby path_to_enlightenment.rb
Awesome! Thank you :)
Yes. Read it. It is an amazing book. If it's not in your Amazon cart, being checked out right now.... then why the hell are you still reading this. 
Seriously though. It will let you know everything you need to start developing complex applications. 
In my experience, the primary benefit of interactive online courses is that they remove the initial barrier of setting up a development environment and having to ever use the command line. Ironically, this approach castrates programming languages and reduces them to toys that do novel things in a browser's interpreter. Books got me past the beginner's slump that interactive courses had me stuck in for so long. * _Learn to Program_ by Chris Pine is good for an absolute beginner. * Once you've gotten through that, official documentation and stackoverflow will carry you a good deal further. * If you want to understand ruby under the hood, _The Well-Grounded Rubyist_ by David A. Black is a great book for filling in the foundational understanding that beginner stuff skips over
The websites are really designed for people who have never written code before, not for someone learning a new programming language. Google and books about the programming language are going to be much more helpful. Go on amazon and try and find a book with some good reviews :/ Edit: Programming languages is how I learned that any free service online advertising "learn x" is subpar compared to a good book on the subject. The quality of free education on the internet is pretty bad compared to actual educational resources (books, textbooks). I have found this to be true for pretty much every topic.
Check out OptionParser , it's freaking great for Ruby scripts
I don't get it. Shopify paid people to find bugs, then reported every single one of those bugs. How is the pessimistic view possibly valid? ie, how does Shopify look evil in this? Should they have refused to pay analysts? The "optimistic view" then appears to show the mruby team blaming Shopify for choosing to use mruby.
Oh yes, sorry, my bad 
[Learn x in y minutes](https://learnxinyminutes.com/) is good if you already understand the basics of OOP, and just want a quick syntax cheat sheet. For more depth I would recommend reading Eloquent Ruby by Russ Olson. I can also recommend the [ruby section](http://www.theodinproject.com/courses/ruby-programming) of the Odin Project, though you'll probably find yourself skipping quite a bit of it.
It's a joke. Calling Shopify "evil company" refers to the latest SJW crusade this time against Shopify for hosting someone's store: https://www.wired.com/2017/02/shopifys-breitbart-fight-proves-days-tech-take-side/
Try "ruby path_to_enlightenment.rb"
I feel the author felt compelled to weave that into the story due to the outrage in some parts over Shopify hosting Breitbart; that outrage might be a big part of the conversation and awkward to not address. In any case, I don't think most of us would blame Shopify for allowing it -- can't imagine Google or Apple get as much hate for all the bad actors using their services and devices.
I like rails but .NET is really good. Your risk is now political. If you keep with .NET you will be labeled as an old curmudgeon who doesn't want to learn anything new. .NET had real benefits with the static typing and easy access to developers. A strength of rails is the ability to iterate fast. But in your case you know the requirements, you are mostly doing upgrades. They do have .NET on Linux via mono, but that may not be an easy sell. .NET had moved fast. Their MVC was heavily influenced by rails.
Do you want to be written up for insubordination? Because that path of conversation usually leads to being written up for insubordination. Usually what happens in companies where i live.
Just look at `/bin/hanami` in hanami repository require 'hanami/cli' Hanami::Cli.start and continue from there.
Thanks! This worked. I needed to specify running it in ruby.
I would just write a SQL query for this.
There are two (maybe more) obvious gains from using keyword arguments: the resulting hash is a new value and not a reference (slight performance loss because of the extra object, although I might be wrong here), which means you can mutate and delete options without affecting code out-of-scope; and the best one I've been seeing in my usage is most explicit error messages. Being able to see which keys are missing helps you debug the code in a better way than the cryptics "wrong number of arguments" or my favourite, "no implicit conversion of X into Y". It's a basic but sometimes effective poor-man's "static typing" :) The bad is the inconsistent handling of hashes. It only supports the "new" 1.9 hash convention for symbols, it only accepts symbols as keys, and therefore doesn't do anything to solve the inconsistency of declaring hash keys. One must therefore take the good with the bad and move on. 
Here is the downside. You get a lot of code that looks like this: Foo.bar( a: a, b: b, c: c ) I.e. a method's parameters are often variable names at the callsite. This leads to redundancy where the keyword argument name mirrors the value.
In the example there's no join. Looks like this would result in a lot of N+1, no?
Is the executable bit set on pathtoenlightenment.rb? ls -l It should start like rwx------ If not, chmod u+x pathtoenlightenment.rb
No. It will auto-includes needed data (without creating active-records). The example also shows the db query: User.deep_pluck(:name, :posts =&gt; :title) # SELECT `users`.`id`, `users`.`name` FROM `users` # SELECT `posts`.`user_id`, `posts`.`title` FROM `posts` WHERE `posts`.`user_id` IN (1, 2) 
Sometimes it's hard to write only one SQL query to get all data you needs. For example, User has_many Groups and you want the user name and all the groups' name.
I gave a talk at the last RubyConf about this. There's more to KWArgs than most folks realize (in a good way): https://www.youtube.com/watch?v=4e-_bbFjPRg 
Matz watched my talk (no pressure!). He said they'd done some things in MRuby so it's not just na√Øvely building hashes all over, so the performance is only a little slower than positional args.
Try it with more than one argument to see how performance scales. I'm curious. It was much worse when keyword args first came out. Nice to see it's better!
Oh I have no idea! I'm pretty new to Ruby and very new to Mac so I don't understand what you're asking.
Awesome! Thanks for the tip on phrasing! That definitely helps. I was using different phrasing and all it was telling me is how to download and open Koans. I'm such a noob, lol
The clarity of mapping is a good indicator of the contract between the caller and called and makes future relationships clear during future renaming and refactoring. Jim Weirich's talk on Connascence is great but I'm mobile so have this wiki link in the meantime https://en.m.wikipedia.org/wiki/Connascence_(computer_programming) 
Nice üëçüèº
It's not "clear," it's redundant. The callsite is obvious enough with just positional parameters when the contract is right. I attended Weirich's talk on connascence back in 2008. It offered a novel approach to explaining principles of code design. Argument position is a kind of coupling, for sure, but keyword arguments just trade that coupling for a different one -- the name of the variable _within_ the method cannot change without affecting every callsite. If we always order positional arguments in descending order of importance, then I think positional arguments are the cheapest to maintain. Keyword arguments are great for optional arguments, of course. That's where they shine.
Okay, thanks for your opinion. 
A lot of my work involves sidekiq workers, so that's a pretty good example of when you shouldn't use keyword arguments. Sidekiq serializes it's arguments so it can throw it in redis, so you generally need to stick with simple data types like numbers and strings and things. 
Does it need to graphical? Otherwise, use pry? https://github.com/pry/pry
I don't need to sell it, the tech setup / architecture decision is mine. I already moved to Linux a couple of years ago - as explained I have stuff running under Mono already. But it's moved beyond that now and its running under 'NET Core' which is the official Microsoft version.
Yes I like Ruby a lot, really nice friendly language. I take on board your points about Rails being opinionated - I like that it takes a lot of decisions for you and was one of the things that has made me consider it.
Ha, yes I was searching for it and thought I'd missed something!
This is not true if you're using Sidekiq via ActiveJob. AJ transparently handles keyword args!
I've been burnt by this. One project eventually just passed marshalled strings around.
pry+awesome_print can do a lot of what you're asking. Not all, but a lot
I didn't see where DDD was defined? I don't know what it stands for. 
I thought the performance Delta was nearly eliminated in ruby 2.4.0?
oh cool, I didn't know pry could do that. graphical (like the smalltalk/squeak browser) would be preferred, but it doesn't look like there's much out there like that for ruby
I guess that changes if you change the signature to `lord: , **options`. I think that's a more real-world approach, since in big projects, one tends to pass the options hash a few levels down and destructively get the desired options at each level. Using `**` to ignore the undesired options is something I also use it for. 
&gt; def mutate(str) &gt; str &lt;&lt; "bling" &gt; end &gt; str = "bling" #=&gt; "bling" &gt; mutate(str) #=&gt; "blingbling" &gt; str #=&gt; "blingbling" 
&gt; This does not prove anything as GC is smart enough to reuse the same slot again and again, at each call This isn't a counter of the number of object slots allocated - it's a counter of the number of Ruby objects allocated, whether they use a new slot or not. It's incremented from `newobj_init`, the routine which initialises a new object, which is run for new objects after they have been allocated no matter where they are getting their storage from. It's not incremented when a new slot is allocated. &gt; when keyword argument(s) is(are) used, rb_args_info struct is allocated for their handling A `struct rb_args_info` is allocated when parsing for each call site yes. But this isn't a Ruby object, it's a C data structure. I said no objects were allocated, and they aren't.
Thanks, this is helpful. And where would you suggest putting the class files? create a directory under /lib? (heh, and now I need to go off googling the best way to approach writing a class, as I have very limited experience with that)
I don't see how any of stated goals couldn't be achieved with Rails application.
I wrote a gem for this a few years ago: https://github.com/ntl/invokr After analyzing the callsites where I was using it, I realized i was introducing a few problems. 1. Explicitly passing in parameters is just way clearer. `**hash` obscures what's being conveyed at the callsite 2. `**hash` implies I've already _got_ the arguments in a `Hash`. That is almost never the case because the design principles move us _away_ from working with hashes (primitive obsession). I've stopped using the gem, to be honest. Mostly I use positional parameters for required inputs, and keyword arguments for optional ones.
This look pretty good, I like it! Are you indexing the README's, or just the gemspec descriptions? Looks like the READMEs maybe? Ruby toolbox hasn't been too useful to me for finding things, this is looking pretty good. Want to share anything about the implementation? I'd be curious. 
To the parent ruby script, the other ruby script is just a process, so treat it like a normal process and use stdout, stderr, exit codes, etc. I think you want to look here: http://ruby-doc.org/core-2.4.1/IO.html#method-c-popen
Ruby 2.3.3 Rails 4.2.1 The first app is a standard jbuilder API setup. Below is the second apps 'client' (initialized at startup) that makes the get calls: def initialize(organization_id: nil, wegoaudit_url: nil) self.organization_id = organization_id wegoaudit_url ||= "http://#{ENV['WEGOAUDIT_LOCAL_IP']}:9292" self.base_uri = wegoaudit_url end def audit(audit_id) raise ArgumentError unless audit_id.present? response = get("/audits/#{audit_id}", query: { organization_id: organization_id }) error = response.body['error'] if error raise WegoauditClient::ApiError.new(error['message'], error['code']) else response.body['audit'] end end def audits_list response = get('/audits', query: { organization_id: organization_id }) error = response.body['error'] if error &amp;&amp; error['code'] == 'user_not_found' [] elsif error raise WegoauditClient::ApiError.new(error['message'], error['code']) else response.body['audits'] end end private def get(path, options = {}) connection = Faraday.new(url: base_uri) do |faraday| faraday.headers['Content-Type'] = 'application/json' faraday.options.timeout = 600 faraday.adapter Faraday.default_adapter basic_auth = DoorStop.authify(WegoAudit::DOORSTOP_SHARED_SECRET) faraday.basic_auth(basic_auth[:username], basic_auth[:password]) faraday.response :oj end connection.get("/retrocalc#{path}", options[:query]) end
it needs to create an audit_report, and it gets the data from the client (in my other comment), which isnt working since its all one code base now class Calc::AuditReportsController &lt; SecuredController def create data = wegoaudit_client.audit(params[:audit_report][:id]) audit_report = AuditReportCreator.new( data: data, user: current_user, wegoaudit_id: params[:audit_report][:id]).create redirect_to calc_audit_report_path(audit_report.id) AuditReportCreator def create execute audit_report end def execute ActiveRecord::Base.transaction do create_audit_report end end private def create_audit_report @audit_report = AuditReport.create!( name: data['name'], user_id: user.id, organization_id: user.organization_id, data: data, report_template: report_template, wegoaudit_id: wegoaudit_id) associate_measures create_field_values import_wegowise_data end
I don't see how that's any worse than `Foo.bar(a, b, c)` where you can't be sure what the args are and might get confused about the proper order. Why is that "redundancy" you point out a bad thing? I agree it's annoying to type, and often long for ES6's... whatever that is. It may also be a signal of bad OO design if you're having to pass through a group of args frequently. 
I'm not sure "order of importance" is always self-evident and the same determination will be made by different people at different times. I tend to like positional arguments for one or two args -- the "order of importance" is a little bit less subject to ambigutiy with only two args. If the method takes any additional args, I tend to make the first one or two positional and the rest keyword. Especially if they are optional args. I lean to making all optional args keyword, unless there's only one arg and it's optional, and even then I consider it. 
Nice. If you felt like making the code open source, I'd be curious to see it! Curious about your custom 'trust' ranking. I think whether or not you make the code open, you might want a few words about that and the factors it takes into account in the About. 
What you just described is pretty much my exact approach. I don't tend to wind up with more than two required arguments ever -- which is not that I have a hard and fast rule about it, but that's how it shakes out :)
The redundancy is "bad" in the sense that it is unnecessary, and more costly to maintain, and slightly more cognitive load. I wouldn't put it on the short list of things that matter most, or even the long list, but in a bake off, `Foo.bar(a, b, c)` is superior. You don't have to ask "why are those things there twice?," and when the name of the argument in the implementation of `Foo.bar` changes `a` to `aa`, you don't have to go changing every callsite. It's splitting hairs, but it's a discussion about hairs being split...
Thanks!
How does this compare to libraries.io?
I'm biased but... Just did with a simple query: [codescout.io query: testing](https://www.codescout.io/search/ruby?q=testing) [libraries.io query: testing](https://libraries.io/search?q=testing) 1. I think my interface is much better and much easier to read. 2. Had to click on ruby in libraries.io after the search to get anything relevant to ruby. 3. We could argue that our search results are pretty similar, but I would say that my query is slightly more relevant already. I don't even claim to have very relevant results yet. This is something that I will work on a lot in the coming weeks when I'm done with the interface. I'm thinking of integrating artificial intelligence in the ranking system. Anything that I can do to get better results actually. I'm pretty serious about this. I really want to make a killer search engine for libraries and I think what we have already is not enough. The points I want to focus on are: 1. Very relevant search results. 2. Most results show high quality information (links and text). 
Beautiful design / UI!
It's now under: [graalvm/truffleruby](https://github.com/graalvm/truffleruby)
Yeah, this is the most fine grained level of detail for looking at code. In a real world rails-ish example, a callsite might look something like this: `bank_account.deposit(params[:amount], params[:account_id])` All I'm really saying is that after keeping an eye on what callsites look like for a few years, I believe that generally the context around the arguments (the name of the method and its receiver) tends to make it pretty clear what's happening. We want the code to be as clear as possible, but _no clearer_. Too much information may be better than not enough, but it's still inferior to precisely the right amount of information. Cheers!
Help me understand what a nano-framework is.
Microservices that expose an HTTP API (or any interface that is designed for synchronous communication) are prone to a whole host of problems. Use a queue. If a service is unavailable, it should not cause any other service to become unavailable. It should not force other services to retry their requests. When you restore its availability, it should immediately process the backlog of requests that queued up when it was unavailable.
It's awesome, and I like your videos.
If anyone wanted to write occasional blog posts about the state of truffle, I'd love to read it, and would add it to rubyland.news. 
Did you look to see if it is small instead of guessing?
&gt; actually trying to use it doesn't work I can't help but feel that this "announcement" is a tiny bit premature ;)
It like micro-framework, even simpler.
I like how you are presenting the project and how you made the videos. It looks promising and I feel like tinkering with it. Hope it gets some traction.
What "Find tool" are you using, how?
I don't know how to do that with the Bash find tool, but here's a thread that may help you do this with Ruby: http://stackoverflow.com/questions/16444716/rename-files-in-same-path It won't give you the code you need, but if you look at the last comment on the page you can see how to get the directory name to apply to the file name.
Looks good! I wonder what the default order for the searched gems is based on, what is "relevancy"? 
For this project, you're right. Some projects have a repository description that is more meaningful than the one that was written on the gem or the github summary. I still need to work on that I guess.
Truffle?
Well it's not combining in the literal sense... it is a totally separate project from those, but in terms of combining their goals and eventually replacing them, that is true. This allows us to run C &amp; Java extensions in a Ruby implementation that's going to be the fastest implementation to date and bring Ruby to the front of the market again as far as speed concerns go. 
Like I said, this is an update. I simply wanted to let others, like myself, who want to be on the cutting edge to know what's going on. And look at Chris' most recent post today. Things are moving fast now after they worked through the initial load.
It used to be that achieving a "senior" level was something that took 10+ years. As the bar for attaining a senior title has lowered, "principal" has taken its place. Think of it as a level up from senior. You can expect to command 25% more salary with that kind of title.
8+ years of experience as an absolute minimum (10 being ideal). I'd say an ideal candidate would either be great at something outside the wheelhouse of the dev team (e.g. C extensions) or well practiced in architectural patterns that have delivered proven results. Other mitigating factors might be community clout, for instance.
That song... I must have been under a rock for the past 7 years.
That's my favorite part of the post :) Here's the original https://www.youtube.com/watch?v=OQSNhk5ICTI 
This varies a lot between companies. Principal is typically just a step higher than senior. However, in some companies a Principal Engineer might have been the first engineer at that company or someone who helped to build the original product. I'm not sure what would make someone a Principal, but it could be as simple as having more authority than anyone else in the company when it comes to Ruby. You can give yourself more authority by doing things like contributing to Open Source, writing a blog, writing clever algorithms, mentoring other devs, etc.
Our engineering team recently went through a process to define each of our 5 engineering levels. Associate, Software, Senior, Principal, and Architect. I can answer specific questions you have (at least relative to our team) but the jist is as follows. A Principal engineer will not only be expected to follow our process and best practices but also to be an active contributor in defining and driving improvement. A principal engineer can be expected to lead large projects including design that involve coordinating with many teams or across artifacts or both. A principal engineer is expected to be an active participant in our hiring and branding (open source/blogs/tech talks). A principal engineer should be capable of providing feedback to other engineers and should expect to spend a decent portion of their time reviewing code and designs with peers. A principal engineer should exemplify good engineering judgement, offer appropriate analysis to stakeholders and deliver work on time. The levels/competencies build on one another, so there are a whole slew of things that more or less cap at senior which we'd obviously expect a principal to exemplify. The biggest difference is a principal should be able to own and drive pretty much every facet of their job, be an expert in a portion of the codebase and have an understanding of most of it (this obviously changes at certain scale or within different organizational structure). A principal in my opinion is closer to an architect than a Senior engineer. Many people won't make it to principal, fewer yet should attain title of architect. I think you'll find experience is important but it really is intelligence that elevates people. One of the brightest software engineers I've worked with has less experience than I, but is vastly better at it, and I'm a Principal in a very well respected org. One thing you may notice, while we are a ruby shop, none of these things are ruby specific. Any engineer who can demonstrate this skill set would qualify as a Principal engineer in my opinion. Ruby is just a language. It has some interesting bits for sure, but it's far from what matters when assessing an engineers level/compensation etc. We've hired 2 Principal engineers recently who have never written ruby before! I myself had never written ruby prior to accepting the job! Edit: Sorry if this comes off as high and mighty or anything. It's not my intent. I agree with the other posters that titles are a wash and every company will have a different set of expectations for a given title. This is merely my experience. I've interviewed 'Architects' with 10+ years experience that don't pass our bar for Senior (in some cases barely SWE) and I've interviewed people who present as an engineer who usually we hire at Senior or even SWE that quickly are promoted to Senior/Principal. The important part is knowing that you can and should be thinking about how your skills are developing (can further develop) independent of language or framework. You'll find that will force you to focus on some of the more thematic elements (design patterns, trade off analysis, algorithms, data structures etc.) of software engineering vs syntax/semantics.
The hip thing at the moment would be put it in a container. Ruby env/bundler I think are the default tools for this.
I agree, but our infrastructure and tools teams seem reluctant to support them at present.
We use salt to install RVM, rubies, gemsets, bundler, etc. It provides us a lot of flexibility to run multiple Ruby versions, upgrade versions, etc. Containers are the cool way to do it, but if you aren't containerized, using some infrastructure automation tool + a ruby multi-install manager is really easy.
I've had great experience with combining `bundle --standalone` and `fpm` to produce `.deb` packages that contain my ruby project and all of its gem dependencies. This is much better than containers, IMO. It actually allows rubygems and bundler to be kept out of production entirely if you so desire -- though this quite doesn't work with rails as it is coupled to bundler.
Really good. Those tools should definitely be packaged as a gem!
Ruby is not a particularly good choice for Machine Learning or building bots, at least compared to Python. That said, I am working on my own Ruby chatbot. This list is a good starting point: https://github.com/arbox/nlp-with-ruby And there's also the option of using JRuby and leveraging java libraries, which I will probably do at some point in the future.
Meh I don't wanna engage in a holy war here, but I don't disagree in a general way, Python **is** the best option when it comes down to specifically doing math stuff. Now...for a **chatbot** with 'AI' (which, again, not necessarily implies ML) Python is not only ugly, but making simple things more complex. 
I agree with you there. Ruby makes creating dsls so nice. A friend of mine made lita, I'd recommend that as a starting off point to OP.
We use this at my company, my favorite CMS for Rails by far.
To the people here who use gemsets: do you use bundler as well? If yes, then what are the advantages of using gemsets instead of just letting bundler activate the desired gem versions? Iirc rvm gemsets originated from a time before bundler and were useful back then.
DI is a pain itself
Yeah, and while there's no getting around it in Java or Objective-C, I've never encountered any situation where I needed it in ruby.
I don't understand how this is useful. The first example could be written as: module MyApp class MainBox def initialize @server = Server.new 80 end attr_reader :server end Server = Struct.new :port end box = MyApp::MainBox.new box.server.port # =&gt; 80 Less code and more readable. Do you have an example of how this would improve the "manual" way? Also, I generally avoid lazy loading as much as possible unless it helps performance. Thread safety is a concern and it makes benchmarking code more difficult.
The example of manual injection and how the library improves the situation is explained in the presentation. This specific part starts at minute 9 https://skillsmatter.com/skillscasts/9918-dependency-injection-with-little-boxes.
What other ones have you tried? 
I would put that on your site as well.
I use Capistrano.
Don't like the use of 'let' in this case. That key word is just synonymous with rspec that it seems weird to have it available in app code.
Interesting, there is an issue open that suggests an alternative name for this https://github.com/manuelmorales/little-boxes/issues/3. Do you think that would have been better?
Thank you :)
You can do it via `Hanami.configure { ... }`. Please generate a new Hanami project and have a look at `config/environment.rb` to understand what goes inside that block. After that, `Hanami.boot`, and then `Hanami.app` is able to accept requests.
Congrats! I've played around Hanami and really like it as a break from Rails (which truth be told I don't really use, just have poked around with) and Padrino (which we use daily). Like Rails I haven't done much with it but I'm still a fan :)
I'm starting my next big project this week. I'll definitely check this out. Can you please give us a summary of the benefits of using Hanami over Rails?
Congrats. Also it's very refreshing to see half the core team are female!
But you do have scipy/numpy equivalents in Ruby like Daru. Ruby is unpopular since nobody say it's useful. Please consider using Ruby, the state is changing! An early stage project for reusing Python tools is e.g. https://github.com/mrkn/pycall
Ruby is not a good choice for ML in the case if you want to get everything out of the box and don't care about fine tuning. Fine tuning requires understanding, not only one big red button "Do It for Me!". I agree that we don't have for now straightforward solutions with conventions over configuration for the mass market. But Ruby already has all important bindings for all important libraries for ML. You only have to exactly know what you are going to need.
Try using Lita for the scaffold, event and dialog turn management. And the logic can be implemented either in Ruby or via microservices in other languages. Keep trying, Ruby is great! 
It looks great, but i think you should write a CLI for it
awesome!
&gt; This flexibility is desirable. It's present even in Rails. How would do you choose to use a particular logging library to use with ActiveRecord? You inject it: ActiveRecord::Base.logger == my_custom_logger. Indeed, it is _sometimes_ desirable. Using container based DI however just confuses the issue. It's an artifact of the Java world where you have to artificially create seams everywhere to allow mocking under test. This isn't necessary nor desirable in Ruby. DI really stands on two principals: 1) It's better to add code than refactor existing code 2) It's better to trade encapsulation for user flexibility I simply disagree with both as general tenants. On 1), I find this leads to ever growing codebases and a resistance to refactoring which tends towards large codebases that drift further and further from their actual use case. Every time 'something may change' you end up coding to an interface and adding yet another injection point, this leads to abstraction hell. On 2), DI not only allows but expects the user to break the public API of a module and stick their hands deep into it's inner workings to provide all the needed dependencies, even if they don't really know or care what those dependencies are doing. This fundamentally breaks the idea of implementation hiding and encapsulation. Rather you should think carefully about what you expose to the user and provide simple configuration options to control what they should control. The logger example you used is exactly this, providing a redis client to a module is another. Injecting everything turns into a shit show real quick, look at the example code: https://github.com/manuelmorales/todo-backend-little-boxes/blob/master/lib/todo/box.rb That's a _simple_ TODO app, what does this configuration look like for a 50k line Ruby app? How many lines / files worth of this boilerplate is there going to be? How hard will it be for me to look at the code and find out what code is _actually executing?_ How deep in the stacktrace going to be when I'm tracing code execution and how many pointless lines of indirection is it going to contain? In terms of DI reducing coupling, maybe, in a small sense. ClassA directly instantiating ClassB is only one small aspect of coupling, and it really doesn't matter much which file contains the call to `new`. Breaking coupling is much more about writing code in a reusable manor and clean boundary separations which DI doesn't help (nor hurt). DI may 'fix' the instantiating dependencies issue, but it replaces it with point 2 above; Now you have to care enough about the implementation details of ClassB to provide it all it's needed dependencies. That pretty much blows down any chance of clean boundary separations. tl;dr Dependency injection of the form `ActiveRecord::Base.logger == my_custom_logger` or `MyThing.configure { |c| ... }` or other patterns is fine and good, but there aren't many places you actually need that type of control. Limit it's use and use any of the myriad of simple constructs Ruby allows to support it. Don't think you need to dynamically rewire every constant in your application, YAGNI and your code will be harder to work with. 
Congrats, y'all!
Amen
Personally, I think, hanami has cleaner structure and less magic.
I'm actually creating a web app soon which will pull double duty as my personal portfolio site and a personal blog. I was thinking of nesting the functions inside the main site. / -&gt; main site/portfolio /blog -&gt; blog After poking around Hanami for a bit, I noticed it has a concept of dividing things up into individual Hanami apps that all run from one process. Do you think this aligns well with what I was thinking of doing?
One of the things I found interesting about the repository pattern is the idea of using one database in the beginning and then being able to easily switch later, because you'd just code up another repository for your models, rather than rewrite the persistence logic inside the models. It could even play a role in storing things in multiple databases, like someone doing Postgres + Elasticsearch etc.
Yes, that functionality is perfectly designed for what you want to do.
In Rails for example you can mount any Rack apps within your routes file. If those apps should be Rails-based, you could create a Rails Engine.
"Pretty easily"? I wouldn't say so, on any of the three counts. It's a hassle and you have to fight the Rails Way a fair amount to get something that is fast, modular, and testable.
90% of the time, the reason an app will be slow is due to databases etc. This reminds me of the "rails doesn't scale" argument. It does. 
pundit all the way. Although I personally have no problem with riddling views with permissions-checks, I think it's the right thing to do when you need to guard things that show up in the views by permissions. I'm not sure if pundit changes that in any way. But despite not having that issue, I've been much happier with pundit. It's a much simpler 'architecture', while still accomplishing the basic use cases just as well as cancancan in my experience, but the simpler architecture makes it easier for you to write your own things for non-basic use cases, which I found myself fighting with cancan(can) on. 
I definitely like simple. Thanks.
This is a great resource. Somebody has put a lot work into exploring the edges of ruby space!
My last company used Radiant which was horrible. I started playing around with Spina a little while ago, but the documentation wasn't great and I had a hard time getting everything setup.
You have no idea what you talking about.
Congratulations! You only do 1.0.0 once :) Multiple apps, Callable standalone Action objects, proper request body params validation and the repository pattern are some of my favourite architectural features. I've also looked to what you have in the roadmap, and if I could suggest some things on top of that: * Why not go one-repo/multi-gems? I'm sure there is some coupling/deps between the many subgems (like -utils being used a bit everywhere, etc). By having them centralized in one repo, you always test against the latest, and can choose between test components in isolation or test everything together. I went this route in some projects I maintained, and it boosted productivity by a thousand. * The most cumbersome and outdated component in rails is the asset pipeline. From what I see, hanami didn't really fix this. I saw that you're thinking of integrating with webpack a la rails, but why not go one step beyond and just "don't" integrate at all? The way I see it, hanami could just provide a boilerplate of the webpack config with a few "opinions" bundled (babel/es6/sass/common-chunks...), and leave the frontend altogether. Webpack already can proxy to a backend (which could be an hanami API), can serve/rewrite html, and has the tools to achieve the maximum nirvana of server-rendered SPA: it handles streaming content far better than any ruby server, can support multiple CSS dialects, all the frontend frameworks are there, and it would be disappointing to have it like in rails, where webpack is just for your "javascripts" and you get yet some more html helpers to learn. Now I just have to find a project to try it out properly. Keep up the positive work! 
Oh really. 0.0 What are some other important advantages?
Where's the "Rails Article" I was promised in the title?
**Here's a sneak peek of [/r/rails](https://np.reddit.com/r/rails) using the [top posts](https://np.reddit.com/r/rails/top/?sort=top&amp;t=year) of the year!** \#1: [Rails 5.0 has been tagged for release!](https://np.reddit.com/r/rails/comments/4qofer/rails_50_has_been_tagged_for_release/) \#2: [My 'Learn Ruby on Rails' book now free on Google Play](https://np.reddit.com/r/rails/comments/5lqek4/my_learn_ruby_on_rails_book_now_free_on_google/) \#3: [Atom.io packages for Ruby on Rails](https://np.reddit.com/r/rails/comments/52q2s4/atomio_packages_for_ruby_on_rails/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
You seem to think I said something disparaging about rack. Since you're dead wrong, I'm forced to conclude that you have missed my point: there's no point in trying to make a "small" web framework. Go learn you some people skills.
Isn't it a stretch to say it's as good as pacman or apt? Those systems have decades of work behind them.
what does 'sideload' mean here?
You can always move things to helper methods if it calls for it
Your examples sell it for me. I can never remember the syntax for expectations with rspec. 
FYI: From yesterday's Vienna.rb meetup as an alternative the (static) generated HTML slide deck -&gt; http://slideshow-s9.github.io/demos/planet.html (Use space or the cursors to flip through and the t key - for toggle - to toggle overview and slideshow mode).
Working with simple data structures, that are decoupled from database schema, is probably the biggest advantage. You can project your data however you want, using probably the most advanced query API that's available in Ruby. Apart from that, reading data is separated from writing, so you're not stuck with the same data structures used for reading/writing, which gives you more freedom and simplifies handling complex forms (or any input). Having said that, this is only the beginning, because Hanami is backed by rom-rb and it doesn't use its full potential yet. We'll be working closely to improve it in Hanami 1.1 and especially in Hanami 2.0, and in the meantime rom-rb will become even more powerful.
I have some question to your questions ;) &gt; Why not go one-repo/multi-gems? Do you actually know any other large project besides Rails that use it? Sure it solves some dependency problems, but on the other hand makes project management on Github kind of more difficult - you just get one giant pile of issues and pull request which is just hard to manage. &gt; hanami could just provide a boilerplate of the webpack config with a few "opinions" bundled You know that not all projects in the world use webpack nor all should, right? What about them? Also, there is [hanami-webpack](https://github.com/samuelsimoes/hanami-webpack) gem which, I think, is going in the direction you suggested. And I feel this is a right way to do. Also, I don't think that using `Hanami::Assets` is required by any other component, so you could probably just "unplug" it from your setup.
Databases? Or eagerly converting large collections into ActiveRecord objects which, believe me, takes a lot of time usually attributed to database slowness.
It looks like a nice implementation of the container pattern. I like the idea. I'm aiming to try it out! 
 !!!
Also worth checking: https://github.com/serodriguez68/poodr-notes
&gt; Do you actually know any other large project besides Rails that use it? Sinatra (https://github.com/sinatra/sinatra/) changed, for the same reasons. Don't know if it fits your definition of "large". :) And Rails does fit hanami model. &gt; but on the other hand makes project management on Github kind of more difficult It does optimize for maintenance happiness rather than governance, but then again, that's more lack of support from github (rails works around this by using labels, which at least eases discoverability). I'll just counter-argue with these 3 use-cases: * What do you do when someone reports an hanami issue and it's actually hanami-utils/model? Do you kindly ask them to re-issue it in the proper project/repo/issue tracker? (gitlab supports moving issues across projects, don't know if github caught up with this.) * What do you do when PR is submitted and the owner uses API from subproject which has been deprecated/removed? Do you kindly ask them to update deps to master and rewrite? * How do you synchronize the release of related projects? Does a "release manager" have to guarantee a "fresh" local copy of the release branches (locally linked), and test/version/build/push-release separately? At how much is the release process clocked? Whether a fully-separated issue tracker or a common-filter-based is the best solution is debatable indeed, but its tight coupling to a git repo is IMO a "feature not a bug" from github. You could also take the celluloid "multiverse" as example. It always had separate projects (celluloid/-io/reel/dcell etc...), and guaranteeing stability across them was time and nerve consuming. As of 0.17, celluloid broke down into 4 github sub-projects and a git submodule (ugh...). It burned out a lot of contributors, and full stability across all projects isn't there (try running reel with latest celluloid). And of course, no one ever migrate wikis or issues. In hindsight, modularizing was a good idea, git subrepos were probably not. There was the idea to create an "omnirepo" (see [discussion](https://groups.google.com/forum/#!topic/celluloid-ruby/88WLEeHULJ4), but the energy just isn't there anymore. &gt; You know that not all projects in the world use webpack nor all should, right? Hence my suggestion (aka "get out of the way"). Or else we'll have "webpack-rails", "wepback-hanami", "webpack-react-salad-hanami", and so on. Btw, curl jquery latest and copy to public/ still works, and doesn't involve any asset build tool integration :) &gt; Also, there is hanami-webpack gem which, I think, is going in the direction you suggested. I just had a quick look, and I see a ruby script wrapping the call to the webkpack cli script, some config helpers pointing to webpack path/port/host, and view helpers. Hardly what I suggested. &gt; I don't think that using Hanami::Assets is required by any other component. And that's a big advantage from hanami. Since I suggested "webpack-in-the-front-hanami-api-in-the-back", I really like the possibility of unplugging any html/css/js delivery from the backend. IMO hanami could (not should) provide what it thinks is a good configuration start point for webpack/gulp/grunt/whatever (ex: babel/es6/sass/post-css/...) and let the developer get familiar with yarn/npm/node in general to handle the front end. If you are: adding view helpers specific to the wrapped build tool; clobbering central configuration with build metadata; letting hanami fetch the assets from the webpack server and not the other way round (with data); wrapping the webpack cli and its options in ruby scripts - it's not my suggestion, and it increases cognitive load, and doesn't provide (IMO) tangible benefit besides the integration it provides. All of the above are breaking suggestions for a 2.0, of course. 
It's not something you can get with so many years of experience, it's something you are hired or appointed to because you have the demonstrated _skill_ and capacity to carry it off, it's a _role_, not a qualification ticked off. Should be anyway, if they're still speaking English. In actual fact, software engineer position titles can mean almost anything at all these days, it seems! 
I'll take the opportunity to plug http://rubyland.news again. Uses a Rails app rather than pluto or another static site generator, but is a feed aggregator of stuff about ruby. it's code is open source, although currently it's app code for rubyland.news, not generalized to be re-usable. It could be, might in the future. I think using a dynamic app with a db, in Rails, rather than static-content generator has some advantages. But pluto is cool too, not trying to diss it! 
Tried an actual query for something I wanted to see what the options were. "versioning", "activerecord versioning", "activerecord version", none got `paper_trail`, which turns out to be what I was looking for, although there may be other options too, not sure, hence wanting to try out the search engine. :) After looking at the description of paper_trail once I found it, I tried "activerecord change tracking", which got an alternate "public_activity", which seems to be related, but not the more popular paper_trail. 
That doesn't necessarily make it dated. The principles she's teaching are sound.
She's the best. Her talks and books made me realize how few trully understand OOD and how those pooping on OOP don't know shit anout it. 
we are using crows (https://github.com/piscolomo/crows) is great to use outside rails-based projects. Is like pundit but really minimal and easily adaptable.
I think there's a time and a place for OO and functional styles. I like to blend them and use whatever works best.
seems like a gem that solves a specific purpose, which is good, and the API seems to be designed well. The only thing is the README could definitely be lengthened to give some more context about what is happening under the hood and why you would need this. Think about what it would be like if you were to stumble upon this gem when trying to solve a problem. Would the README be enough to convince you it's a gem worth using? 
Hmm I kind of feel like autoloading is one of my least favorite parts of rails now...
BigDecimal takes a second parameter that's precision. I can't try it from my phone, but I think it might work
Thank you, I just tried it. With these I get the same result: A = BigDecimal(19.12, 15) factor = BigDecimal(0.94, 15) With precision 16, the result of the second multiplication changes to 19.1200000000000000000974468085104219. And from 17 on, I get ArgumentError precision too large.
For this particular case (staying within rational numbers) you could convert the values to rationals in order to not loose any precision: irb(main):008:0&gt; A = BigDecimal('19.12').to_r =&gt; (478/25) irb(main):009:0&gt; factor = BigDecimal('0.94').to_r =&gt; (47/50) irb(main):010:0&gt; A * factor / factor =&gt; (478/25) irb(main):011:0&gt; A / factor * factor =&gt; (478/25)
This is great. I didn‚Äôt know about the Rational class. I should be able to do my arithmetic without relying on BigDecimal precision.
No. What you are talking about is normal binary floating point arithmetic, which leads to stuff like `(1.2 - 1.0) != 0.2`. BigDecimal provides arbitrary-precision floating point decimal arithmetic, which avoids many of these problems.
Eerily similar to https://robots.thoughtbot.com/writing-a-domain-specific-language-in-ruby
Very nice. Would you also add support for GitLab.com? 
I'm trying, but I couldn't look at it carefully yet. Their website and their API are running real slow here and that is discouraging. Also, I've tried, but couldn't get [this API endpoint](https://docs.gitlab.com/ce/api/repositories.html#list-repository-tree) to return me a valid value. Are you familiar with GitLab API?
From what I saw Postman wanted to offer more features than a Chrome Extension could support, right? In this case this thing should live in a browser, there's no purpose in moving it out of it. I plan to make it work on Firefox soon (it should be working now, I thought it would be easier since they have the same API and so on, but meh).
Makes sense. Thanks for the nice tool. I can see this being useful in other programming languages too.
Lol that's true. For that reason, I don't bother actually going to talks and I just wait to watch them on YouTube.
A better way to do this is simply making your code depend on any old IO. Then you can pass in a StringIO for testing.
This one can be solved with simple arithmetic.
This one is even better: [https://www.codescout.io/search/ruby?q=versioning](https://www.codescout.io/search/ruby?q=versioning) 
How does this compare to OctoLinker? https://github.com/OctoLinker/browser-extension Or is "Unlike Octolinker, Module Linker creates real &lt;a href="..."&gt; links, so there are no problems with middle-clicks, Ctrl-clicks etc." the only thing? (Not that that isn't useful)
Having read all of POODR and half of 99 bottles, the second doesn't supersede the first. 99 bottles makes it easier to see how you can actually use the concepts from POODR, but it's arguably harder to get those concepts from it.
Very little. It's yet another qualification that's an attempt to differentiate the wildly varying qualities of experienced developers. It's bullshit and ability to sell one's self at a particular 'ideal' or imagined level of performance. As someone else says, junior 'x', 'x', senior 'x', wtf ever. Sure, there's people that are 'more' senior, and they perhaps deserve some level of qualification to differentiate them, but, like most things in life, it's ultimately about maturity and the ability to satisfy business needs. As people learn what others look for in a 'Principal' engineer, there will be more of them, and then people will be looking for something even better, that has slightly more experience than a 'Principal' Engineer. So on and so forth, the cycle continues.
I literally just read about this an hour ago in a book. Funny now I stumble upon it. xD tl;dr this is meant to emulate casting. ```to_ary``` returns the object in an array-like way, and there's also ```to_str``` etc.
So thinking about this further, I guess since `Point` really shouldn't be able to be cast as an `Array`, I shouldn't define `to_ary`. It would be more correct to use `to_a` and explicit destructuring: class Point def initialize(x, y) @x = x @y = y end def to_a [x, y] end end point = Point.new(3, 2) x, y = *point
&gt; Unfortunately the part of when to use to_a vs to_ary I didn't quite understand. In either case, it seemed like they were returning a new object which was an array representing the original object. The difference between the two methods is that #to_ary indicates the object is really "arrayish". You can compare that with #to_i and #to_int: NilClass has #to_i for convenient conversion but it does not have #to_int because it is in no way int like. See: irb(main):001:0&gt; ObjectSpace.each_object(Module) {|m| p m if m.public_instance_methods(false).include? :to_int} Float Integer Numeric =&gt; 564 irb(main):002:0&gt; ObjectSpace.each_object(Module) {|m| p m if m.public_instance_methods(false).include? :to_i} Complex Rational Process::Status Time ARGF.class IO Float Integer String NilClass =&gt; 564 irb(main):003:0&gt; ObjectSpace.each_object(Module) {|m| p m if m.public_instance_methods(false).include? :to_ary} Array =&gt; 564 irb(main):004:0&gt; ObjectSpace.each_object(Module) {|m| p m if m.public_instance_methods(false).include? :to_a} RubyVM::InstructionSequence Time ARGF.class MatchData Struct #&lt;Class:#&lt;Object:0x00000001d090e8&gt;&gt; Hash Array Enumerable NilClass Gem::Platform Gem::List =&gt; 564 Does that help?
I think the best way of thinking about it is if you can lose something in the conversion. If you can get one way only conversion, use the to_a method, but if it is fully compatible with an array representation, use to_ary. In the Point example you can always get back to the point by feeding it into new, but for example in the case of String#to_i then you won't always get back what you put in if you convert it back to a string. Case in point: "abc123".to_i.to_s == "0"
It does. :) ty
For actual agile development, Practical Object Oriented Design in Ruby (POODR) by Sandi Metz is a must read.
Haven't read Programming Ruby, but [The Well Grounded Rubyist](https://www.goodreads.com/book/show/3892688-the-well-grounded-rubyist) is a wonderful book for anyone learning Ruby.
FYI: Why not design your own planet themes? It‚Äôs just embedded ruby (ERB) with Rails-style helpers (`link_to`, `stylesheet_link_tag`, etc.), see [`planet.starter.html.erb`](https://github.com/feedreader/pluto.starter/blob/master/planet-starter/planet.starter.html.erb) to get started. Happy planet. Cheers.
I recommend reading pdf from https://www.pgcon.org/2016/schedule/track/Applications/929.en.html as well :)
I really liked http://rubymonk.com/ when starting with ruby. No book and free, but maybe it's helpful for you, too.
Why not abstract each service into it's own class? When service logic is placed into a single method this could result in unwieldy methods. The App class seems to also violate the open/closed, and single responsibility principles. Also, I prefer separating Policy related logic (as policy objects). 
GIL and concurrency are the big elephants in the room, but in my experience memory consumption is almost always comes into play before becoming CPU related problems. This is especially true if you use a lot of `includes` in your AR queries. Couple that with 512MB Heroku instances, and you'll be in a world of hurt. I'm looking forward to trying jemalloc to reduce these problems.
I'm not sure if Point really shouldn't be able to be cast as an Array. Maybe it should be? But yeah, with #to_ary you can pass it to nearly any method at all that takes an array, and it'll be treated like one. Array(Point.new(1,2)) #=&gt; [1,2] If your object can't really be considered to be an array generically, don't do that. It may be that a Point can be generically considered a two element array. 
Not just automatically "destruture", automatically and silently convert to an Array in any context that wants an array argument. 
I wrote this, AMA!
What board games did you decide to bring to Railsconf? Not going to attend this year, but always interested to hear about the latest &amp; hip board games!
I've been playing a lot of games with my 6yo so I don't really have anything new that's age appropriate. I've been playing a lot of Go Fish, Uno, My First Carcassonne, Labyrinth and The Magic Labyrinth. I like to bring card games because they are so portable and usually quick playing. Maybe Hanabi this year?
I hear ya. I've been trying to teach my 4 year old the benefits of capybara and rspec. When that failed miserably, we played Candy Land.
I wonder how many bugs there are in financial transaction software that haven't been discovered yet.
That appears as if it may have been a huge pain in the ass. Well done. 
1. Please proofread 2. The rails course popup ad cannot be closed on mobile
The creator of Redis called multiple databases ["my worst decision in Redis design"](https://groups.google.com/forum/m/#!topic/redis-db/vS5wX8X4Cjg/discussion)
From a design point of view for redis it would've made the implementation harder but I wonder if there are any operational caveats
&gt; The redis-namespace gem allows you to share a Redis database among several applications by prefixing every key with a namespace but it's a terrible hack that no one should use. Why? Key prefixing is a standard way of organizing data in any key-value system. If you need different tuning options (persistence settings, etc), then run multiple redis instances. Using the awkward and half assed multi-database support in redis is the worst of all worlds since it's really just a key prefix that is entirely non-descript, it's just some meaningless number.
The fact that mperham started out strongly encouraging 'diy' namespacing, and has switched to the opposite pole of discouraging that an encouraging the built-in 'multiple databases', suggests that manual namespacing didn't work out well either. Apparently many users of redis really want some way to use the same redis instance for separated collections; but this is something redis can't actually provide, and the redis creator/maintainers are uninterested in providing. Users will probably keep trying. 
Looks useful. One thing I'd like to see is the ability to configure the base image for the rails container. I've been using the https://github.com/phusion/passenger-docker images.
Remember that MVC is a pattern for building user interfaces. Any preference for aligning views, models, and controllers will inevitably push the design of a GUI towards resembling the underlying model layer. Since the model layer of a stock rails app is a relational database schema, your GUI will just end up looking like a data entry system for a SQL database. Think about how easy it is to wire up an ActiveRecord object to `form_for` with CRUD controller actions implicitly living in the middle. This is basically MS access with a bit more customization baked in. Honestly, web form based data entry systems are about the only kind of app where Rails' conventions are actually helpful. Look at basecamp -- it's a giant data entry system. An astute, pragmatic programmer can sniff the need to deviate from rails conventions a mile away -- they need to build a user interface on top of a software system that _doesn't_ look like a giant relational database.
So namespacing is bad practice, use multiple databases. But databases are not recommended by the redid author, and as I recall from the redis 3 logs, you can't have clustering and multiple databases at the same time (did that change?). Isn't there a better queue as a service that provides better performance/reliability balance , with more persistence guarantees? Even if rabbitmq is not the most suitable, what about discus, built by the redis author to fix how people were using redis? What are the Java devs using? 
Just curious, where did you get the idea that I strongly encouraged namespacing? Namespacing was something that was demanded by users migrating from resque to sidekiq so I supported it but I've always avoided namespaces when using Sidekiq myself.
I thought I clicked on the wrong link.
I know a lot of Ruby folks blog with Middleman, so I thought I'd post a sort of meta-post from my new blog about how to use the new(ish) [external pipeline](https://middlemanapp.com/advanced/external-pipeline/). If the post doesn't fit here, maybe I can move it over to /r/webpack. I'm also interested in feedback on the format and style. If folks like the style, I have a few other articles in the queue *edit: spelling about things like using Algolia with Ruby.
The profanity is distracting and not professional IMO.
I mainly develop my frontends with angular 4, so my question is: Can it generate rails 5 app in api mode?
This is written as a ruby gem, so particularly good for ruby/rails apps deployed on kubernetes/migrating from Heroku, though should work with any app running there, possibly with a few tweaks. I also posted to [kubernetes reddit](https://www.reddit.com/r/kubernetes/comments/6372fa/herokulike_conveniences_for_kuberneteskubectl/) last week but surprised no one seemed that interested there, maybe not many people moving from heroku to kube? Dunno, but thought I'd post here to see if anyone is interested!
I don't like this format....The brain can't focus on two simultaneous events
Basically what I read was "there's cinvinience with what rails provides, but ignore it and write it all yourself." You could've made a post explaining how to create custom controller actions and had gotten almost the same point across. Unless I'm totally missing something here..
That demo video was great advertising material. I think I'll use this to get my non-ruby colleagues up and running so they can concentrate on building the app instead of the dependencies. Cool stuff!
Why would you go from Heroku to Kubernetes? You go from being able to focus on developing your app to having to focus on a whole platform and managing and securing that infrastructure and maybe then you can do some app dev. For people who are already on Heroku I don't see a big use case for devs moving to kubernetes, because now you have a bunch of infrastructure to manage. And, if you have a big enough team to manage Kubernetes then you're probably not looking at Heroku for running your stack.
There is tension around this but the short answer is being able to offer an SLA (service level agreement) at a reasonable price. Unless we used Heroku private spaces we can't offer our customers s good an SLA as Heroku gives us, and out customers, largely big enterprises, want that.
In that case, I was using "come down hard" as "strongly against". Definitely not great word choice on my part.
I'm also wondering this. Most of the article would still be relevant if there were separate classes per service. It then says "The last part is the unusual part" and goes on to talk about about publishing events, but I don't understand how that relates to putting all the services into one class?
Noob question: Does this mean I can now use Google Cloud Platform as an alternative to Heroku? I learned how to create simple Rails apps recently and was very surprised to see how few Web hosting companies supported Rails. I've got nothing against Heroku, but it's good to know there alternatives.
You can deploy a rails app to App Engine. This might be helpful: https://cloud.google.com/ruby/rails/
Great, thanks for that, I'll check it out.
I partly/mostly agree, but a) the decision isn't mine to make, and b) it's truer for plain old Heroku than Heroku private spaces. It should say something about the pricing that they don't SAY anything about the pricing on any publicly available page I can find. It's an enterprise solution with enterprise pricing. I'm not saying staying on Heroku is the only option or that kubernetes is the "right" one for us or many other similar size/scale companies... There's a few other solutions out there I'd consider first, like Convox and Flynn, but they have less track record and may be harder to sell to many enterprise clients than kubernetes. Does workflow is built on kube and is a compelling choice in my mind which we may move to while staying on kubernetes, though I wonder how their recent acquisition by Microsoft will effect development and priorities. In any case this tool, and my/our choice in building it, illustrate some of your point in that we had to build it because it didn't already exist, but we did so in a way that should benefit the ecosystem and others making the same/similar choice... The comparison not the article between a house and lumber is inaccurate... Open source is not free as in beer, not for a business, but it is more akin to a prefabricated structure that may or may not suit your needs, or perhaps 3D printer plans for a fully automated building printer like the one demonstrated in Russia recently. If it works out of the box, great, but it will have maintenance costs... If you have to customize it, that is a harder to estimate cost than simply using it.
Thanks!
You always could with Google App Engine but your possibilities were limited because it was JRuby.
Very interesting project, thanks for sharing this.
On the one hand, I like this because it means adding another side-effect of user approval requires touching only the new event handler. On the other, it reduces understandability in the code: I can no longer look at UserApproval and see a clear flow of actions, or even a clear set of subscribers who will respond to the event. I tend to think of UseCase classes like UserApproval as having the responsibility of coordinating other objects to perform a workflow. This makes the application understandable at a glance, and isolates high level behavior from low-level implementation. 
&gt; I explicitly endorsed running multiple instances if the reader has a budget &gt; $0. It's not clear that budget has much to do with it. If you're running enough data through Redis for any of this to be of much concern you're likely choosing instances based on total memory needs and have CPU to spare due to redis's mostly single threaded nature. i.e. It's often effectively zero $ cost to run multiple redis instances on the same box and you'll often see improved performance from it. &gt; Databases allow you to FLUSHDB so you can clear out one dataset while leaving another untouched. In ~6 years of using Redis for all sorts of applications I've never had the need to call FLUSHDB on a production db, so I don't consider that to be enough of a win to offset the bad naming. If you do need to do this there are various strategies to achieve efficient delete by pattern and I'm sure someone will create a module for it in Redis 4.
What's interesting in this is that we should pretty much all have experience with the advantages/pitfalls of this paradigm. Anyone who has used JavaScript (on the client) in anger has had to deal with callbacks in general and event handlers in particular. The pain of a Pub/Sub system is also the advantage: that the invocation and execution of code are decoupled. The precise context of why code is run gets stripped down to "because it was subscribed and an event came through". Tracking problems through that barrier is not trivial, and the decision to add it to your code should not be made lightly.
I love stripped down guides. This was nice and concise, but I still picked up a few things that I didn't know. Thanks!
Interesting. I don't see the same thing when viewing in a simulator window https://www.dropbox.com/s/7ey5b27dj4klsrc/Screenshot%202017-04-12%2015.57.06.png?dl=0 I wonder if your browser is reporting a different size. Luckily i'm better with Ruby than I am with CSS. 
It's never been terribly useful. It's way more wrapped up in itself than in Ruby. That said I enjoyed the hell out of it.
thanks!
`UserApproval.new(user).call` Any time I see something like that I just shake my head. Why is this a class? it's a function. You're allocating an object for no purpose other than to confuse the code. Shit like this is why we have super computers in our pockets that can barely render a few images. This isn't Java, you don't need functors. Re pubsub: I'm guessing this isn't really pubsub, i.e. there is no flow decoupling here. While it's not demonstrated I assume `broadcast` is synchronous. In which case this is just a obfuscation of method calls which doesn't reduce coupling and certainly doesn't improve readability. 
Is this phenomenon Ruby-specific are we really dealing with something endemic to all interpreted languages? If so, aren't we better-off sticking to the JVM or BEAM? I'd be interested to hear how Node compares though it suffers from a different vulnerability - unhandled errors. What about PHP and shared nothing? Would this be a win over Ruby as far as memory management goes?
Me, I have around 20 years of getting-paid-to-program experience too, and I love books. When I first learned ruby 10 years ago, I bought the pickaxe book, and read substantial portions of it. Read it next to the computer with an editor and terminal open, trying things, of course. Started real projects before I had finished reading it, but kept reading it as I worked on em, as well as using it for reference. I've read nearly every word in the Rails Guides by now too, here and there, and learned a lot from them too. Not books (sadly print books are not what they used to be, darn internet), but in a book-like format, they could be a book in a different era. I find them invaluable for becoming intimate with Rails. Different learning tools for different folks I guess! I have found books, both reference materials and narrative explanations/tutorials, to be very helpful as I've learned new languages and platforms. On the other hand, when I was 16 and tried buying some of those encyclopedia MacOS reference manuals on dead trees that used to be a thing.... never really did figure out how to write a MacOS app from that -- or any other way at that time. Found it very frustrating that I didn't seem to 'get' it. (And the internet wasn't much of a thing at that time to use to learn programming! Pre-web, although I was nerdy enough to have discovered the in retrospect tiny world of gopher) Then I found the web, and via awk, Perl (putting a FileMaker db on the web, then we figured out SQL and moved it to an rdbms, i forget what), ColdFusion, Apple WebObjects, PHP, and Rails, and now here we are! 
The pipeline is external, not eternal. ;)
It's a known issue I think. There was a previous update that was supposed to help things a bit (you should be using the Creator's Update build if you aren't already). Might be better to post in /r/bashonubuntuonwindows and/or the Github issue tracker. 
It's true this isn't a factor of compiled or interpreted languages, however this exact behavior isn't truly universal. It depends on a forking webserver that has some kind of a built in kill switch. The JVM does not have forks and usually their webservers are running hundreds of threads instead. Also you cannot kill a JVM thread, however you can send it an interrupt. The primitives for handling this case on the JVM are a bit better, and the tooling is more mature, so maybe it's easier to figure out where the problem is and fix it (though i'm not a JVM/Java/Clojure/whatever dev so I don't know. Node is single threaded. Ruby is pretty unique in it's ability to kill threads, though that's not what we're looking at here, it's the killing off of a fork which is more universal but not implemented by every webserver or every language. cc/ /u/lordmyd 
&gt; For people who are already on Heroku I don't see a big use case for devs moving to kubernetes, because now you have a bunch of infrastructure to manage. Heroku is expensive, slow and limits the types of archtectures that can be built. In general you end up moving a lot of support systems to AWS long before anything else, at which point moving your app servers into AWS isn't terribly expensive in terms of ops time.
Very impressed about all of those scripts. If someone succeed at using FactoryDoctor I‚Äôm interested.
I don't know about the newest edition. Followed the previous one when I started learning Ruby and it helped me a lot. I can imagine the newest edition doesn't change much in general. By the way, before Beginning Ruby I followed [Learn to Program](https://pine.fm/LearnToProgram), and found it a really good guide to start programming (and uses Ruby to explain everything).
indeed, thanks!
Because 'q'.to_i is 0. And 0.to_s is '0'
The following ternaries are redundant... def letter_correct?(letter) @word.include?(letter) ? true : false end def win? @guesses == @word ? true : false end ...do this instead... def letter_correct?(letter) @word.include?(letter) end def win? @guesses == @word end
To make the app portable, instead of ... "/Users/cswanson/Dropbox/coding/ruby/hangman/5desk.txt" ...load this... "../5desk.txt"
Yea... that's why I sat on it for so long. I only know Java and now I'm learning Ruby, which is why I didn't expect this kind of behavior.
Source: jrochkind on reddit. 
i've worked in Ruby for several different companies both large and small. one used JRuby, the rest used MRI/YARV/CRuby.
Thank you for reading.
Just visiting family, will be checking all of this out after the weekend. Thank you so much for taking the time to do this! edit: had a look over all this, makes total sense, appreciate the help.
Maybe this means they'll finally get off 1.9
Devise is an authentication framework. Bcrypt is a hashing algorithm. In fact, the default hashing algorithm used by devise _is_ bcrypt.
Also, although Devise' hashing is supposedly pluggable, as far as I'm aware bcrypt is the only decent option for devise, so there's really no reason to change it.
For what it's worth, nist recommends PBKDF2 over bcrypt. Sophos has a good summary on their recommendations for salting, hashing, and stretching - https://www.google.com/amp/s/nakedsecurity.sophos.com/2016/08/18/nists-new-password-rules-what-you-need-to-know/amp/
The majority of experts don't support that however. https://gist.github.com/tqbf/be58d2d39690c3b366ad https://paragonie.com/blog/2016/02/how-safely-store-password-in-2016 http://www.openwall.com/presentations/PHDays2014-Yescrypt/mgp00004.html &gt;For what it's worth, nist recommends Well, NIST also recommended Dual_EC_DRBG.
I really like what bundler-audit does, but I'm conflicted about incorporating it into CI. Builds should be deterministic. If it passed tests yesterday it should pass tests today. I run brakeman in a cron job to ensure it gets fired regularly without impacting on above.
most people just use git without a wrapper anyway, so in order to convince people to use a tool there should at least be an overview of the methods in the readme
Just yesterday I was wondering if people still consider RubyMotion for new projects or did React Native win their hearts instead? Or maybe developers started using Swift? The promise of RubyMotion does not sound so appealing now that there are those alternatives.
Thanks for pointing that out. I have updated the item about password complexity. Please let me know what you think about the updated text.
Very cool
This guy seems really confused about the difference between continuous and discrete values
The Windows Subsystem for Linux is native and doesn't require a VM. Give it a try!
Yeah, it was pretty smooth. I was able to install RVM, then Ruby, Rails, Bundler, all that good stuff. I haven't tried Rspec though, as I use MiniTest for this specific project.
some docs with usage examples would be helpful. Sounds like something that might be useful to me, but who knows?
Thanks for your input guys.What makes me want to learn ror is the language and viewing how helpful the community is.
Can I ask why a VM is out of the question? Vagrant seems like a perfect solution to this problem. Of course, if it's really just out of the question, you could also get yourself a Raspberry Pi and do your RoR work on that. It's not a powerhouse of a machine or anything, but they're perfectly suitable for learning RoR. 
My current laptop is running out of memory.Otherwise I would totally do it. A Raspberry Pi would be cool idea tho.
Yeah true enough. As per usual it often comes down to the specifics of the problem, and picking the right tool :)
I installed them just fine, haven't played around with them yet in terms of code change.
If you only have one work area (@ work or @ home) it would be a good idea to avoid using a VM if you have Win10. I use Vagrant and I am frequently running into issues with regards to sluggishness/file update issues.
It seems fine, if basic. It would be better to use functions to return values or objects, rather than directly affect things. It would probably also be better to convert the list to a class so that you can act on it as an object, with the array being one of it's attributes and the functions being member methods just to make it easier to reuse in the future or to build into new things.
You can remove the empty parenthesis when you call show_help
You don't need to #to_s after chomp because it always returns a string. 
ror works great in Windows. until you start dealing with server gems like unicorn or puma etc. or spreadsheets. or images. or testing. in short, you can start out on Windows just fine, but eventually you *really* want to change over to some Unix based distribution. 
It kinda depends on what your goals are. If you want to get better grips on AWS, i'd say to use RDS for your db storage, and ops works for the app itself. Go through the process of setting up chef scripts, putting them on s3, and testing the deployment. Though if you do go this route, i recommend testing your chef setup by using vagrant first. Once it's working, it's a matter of re-using the chef deploy recipe that you use/build in order to deploy new builds. If you do want to try out docker, EC2 is a pretty good call, or something like digital ocean would be fine as well. You aren't going to really run into any performance problems by running docker. With docker deploying is a matter of building the image on a machine. So you can do that over ssh on the DO droplet or EC2 instance. Or you can build it locally, or with CI, and push it to something like dockerhub, and then connect to the host machine by having it setup as a docker-machine, and pull the latest image. You can also use something like capistrano to deploy to DO or EC2, that's just more rails/ruby specific.
I find they are more than capable of handling light app development work. I have a pi 2b running vpn and a couple of ruby slackbots, and it does just fine. 
thank you this is the answer I was looking for. Im kind of getting sick of boxing myself into the .Net stack. Its crazy how amazingly helpful the ruby community is especially on reddit. Thank you all
Just noticed this v2 of your Rails Infographic. Well done! I'm going to share this with the students in my current Rails course. My only suggestion is a return arrow from the db back to the model.
This is really good. A couple of suggestions If you use `#fetch` you can specify the default @guesses = options.fetch(:guesses, []) Rather than setting `@guesses` in the initialize. Move to a method and use memoization to set the initial value def guesses @guesses ||= @word.length.times.map{'_'}.join end
They are perfect for service providers such as OpenShift or Heroku, but not *necessarily* needed for a single VPS running one app. In that case it might be just extra work. They don't help with VPS setup at all (you would still need to use Ansible for instance). In a sense you would move the packages from base system (VM) to the container so the provisioning definition would be somewhere else. However they are projects making the deployment with containers easier such as Dokku that we currently use at work. Dokku solves the container part but we still use Salt as our deployment tool. TL;DR containers won't solve the deploy part really. I personally don't use them unless running sites in OpenShift Online or Heroku where I use them indirectly (I am not setting them up). 
Just pulled brewer@0.0.83 from rubygems and everything specified in the gemspec seems to be there. ‚ü© gem which brewer /Users/oliver/.rbenv/versions/2.2.5/lib/ruby/gems/2.2.0/gems/brewer-0.0.83/lib/brewer.rb ‚ü© tree /Users/oliver/.rbenv/versions/2.2.5/lib/ruby/gems/2.2.0/gems/brewer-0.0.83/ ‚îú‚îÄ‚îÄ Gemfile ‚îú‚îÄ‚îÄ Gemfile.lock ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ Rakefile ‚îú‚îÄ‚îÄ bin ‚îÇ ‚îî‚îÄ‚îÄ brewer ‚îú‚îÄ‚îÄ lib ‚îÇ ‚îú‚îÄ‚îÄ brewer ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ adaptibrew.rb ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ brewer.rb ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ communicator.rb ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ helpers.rb ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ procedures.rb ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ recipe.rb ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ settings.rb ‚îÇ ‚îî‚îÄ‚îÄ brewer.rb ‚îî‚îÄ‚îÄ spec ‚îú‚îÄ‚îÄ adaptibrew_spec.rb ‚îú‚îÄ‚îÄ brewer_spec.rb ‚îú‚îÄ‚îÄ hardware_spec.rb ‚îú‚îÄ‚îÄ helpers_spec.rb ‚îú‚îÄ‚îÄ settings_spec.rb ‚îî‚îÄ‚îÄ spec_helper.rb
I see. Did not catch the edit since the post was open for a while. Glad you figured it out.
That is impressive. Well, I for one will no longer be telling people that you can't develop Ruby web apps on Windows.
&gt; You can also use something like capistrano to deploy to DO or EC2 And then setup [Jenkins](https://jenkins.io/) to automate *that*... ;-)
sooo... long story short, if ansible is too complicated for you, docker will not help you. I'd rather suggest something like heroku. docker is bleeding edge tech, not easy convenience. At least not from a rails viewpoint. 
I've had bad experiences with Heroku. I've been VPSing my own apps for years... I'd rather not go 'backward' so to speak. I guess I should just buckle down and learn Ansible, or some Ansible alternative. Sigh... so many damn things to learn in this dev world.
Could you provide some more info such as OS and version, VIM version, as well as the source of .vimrc and .ctags, and any error messages involved? I know I've seen this work for people in VIM, but I'm hesitant to link to any guides given the last sentence in your post.
Tagbar, Easytags, Exuberant Ctags, as a trio. I'm a lazy sod, though, so I just grab SPF13Vim when setting up a new system and trust that all that will be there. Less my own adjustments, anyway.
I think this might help you: https://andrew.stwrt.ca/posts/vim-ctags/
Tell your coworkers that typing is not even remotely near the top of the list of things that determine the actual productivity of a developer.
I've had nothing but problems with Ruby on Windows, I would not recommend anyone use it. However, Windows now has Windows Subsystem for Linux (WSL, AKA Bash on Windows) that can run Linux binaries natively on Windows without a VM. I've been using ruby on it for a bit and it seems rock solid. That's definitely the route to go, not the Window port of Ruby. The only downside is that you need Windows 10, so if you didn't want to upgrade to Windows 10 you're out of luck.
Well, this is a PS4 vs XBox question :) You will find enough people vouching for both (and, if that weren't enough: puppet / salt etc). My personal preference is Chef - it has Ruby like convention-over-configuration, feels like Rake etc. but I'm sure you can dig out a similar number of pros/cons for just about any other framework. I just spoke to a senior Ruby guy a few days ago who took over a legacy app which had a bunch of fairly complicated, totally undocumented Chef scripts, so he dumped them and rewrote everything using Ansible (as he wanted to try it). I'm sure you could dig out just as much stories going the other way around... tl;dr: It's totally up to you... there's no single 'best' tool imo. Try and decide which one you like.
So much this. Also, I've always thought it was useful to be comfortable with an editor that is installed on every Unixy machine in existence.
This is still a WIP, but it's in a pretty good state. Feedback and contributions are welcome!
The Cheek knows his shit
I've been using it for some time with [vim-ruby-xmpfilter](https://github.com/t9md/vim-ruby-xmpfilter), it's super nice. I first discovered it in Avdi's RubyTapas screencasts, I was amazed how does Avdi manage to output result of Ruby code on a given line from inside the editor. This video very neatly explains the advantages of `seeing_is_believing` over the default, great stuff!
Edit: Ah nvm. You're calling it through fetch from the initialize, makes sense, awesome! Appreciate the feedback.
My issue with Windows was lack of some gem compatability (specifically IIRC therubyracer, but this was about 5 years ago now.) Hopefully better now!
I know you asked for ctags but this is great as well https://github.com/tpope/vim-rails
&gt; https://andrew.stwrt.ca/posts/vim-ctags/ Easytags sometimes makes things crawl on my setup...
Oh, I forgot, feedback and contributions are welcome.
Sorry, but this sounds like a bad idea. I don't want my rake tasks swallowing errors because my environment is set up wrong. That's a disaster waiting to happen. The rake task should be explicit about what it's doing so you know the code path when it runs. For example, pass in an environment variable, or use the rake task arguments - if a gem is missing where you need it, the script SHOULD fail. My 2 cents.
You won't believe what happens next! 
Hate to say it but it's true. Young people can be learning, and it would be unprofessional to share this at work even if I wanted to.
That, and Forwardable. So few know about it.
`binding`, enables so many cool things
I've never been asked this question, but I believe this question is: a) probably for juniors or other programmers recently switched language; b) tries to check _passion_ towards chosen language (not everybody believes it is necessary, but I do), like "...when I've dug deeper, I was fascinated by this and that" (versus "I can write this language or that language and fascinated by nothing). My answer would be probably `inject`/`reduce`, it is like a good koan, hard to master, easy to use and incredibly useful.
Yes, like /u/HomemadeBananas said, from my experience 300 is a "baseline" for the newly published gem. "Somebody at least tried it" starts from 400+ currently (or even more, because the number of mirrors and analyzers grow). To wrap this up, I'll answer the title question (how do you find them) is: * RubyFlow * Google (when I know that "I need a gem for this" and look for it, usually with `site:github.com` qualifier) * this subreddit * https://github.com/trending?l=ruby (just curiousity, sometimes brings real _gems_)
This looks very very cool..... http://blog.bigbinary.com/2017/04/18/binding-irb.html
Meh, [Pry](http://pryrepl.org) is much cooler (and did it first!) ;)
 Process.kill("TERM", Process.pid)
What a *daft* question! No you're not weird, the rest of the ****** world has gone mad!
Not a method but %w{god I love this so much}
I was mostly just confirming your comment, binding is cool. Why? because you can do binding.pry or binding.irb The .irb is nice because it works "out of the box" and without having to install anything other than ruby. ps: What other things do you do with binding?
It's a terrible base to start. The Ruby image doesn't use `bundler`, JS image doesn't use `yarn`, Webrick shouldn't be used in production, there's nothing there for zero-downtime deployment. These dockerfiles are `/dev/null` material.
you can do some wacky things, like grab the 'self' of the block context, e.g def hello(&amp;block) puts block.binding.eval('self') end class Hello hello { } #=&gt; Hello end
&gt; power_assert https://speakerd.s3.amazonaws.com/presentations/69a52ae0228e013253c562b11b8dfdf5/PowerAssertInRuby.pdf
I've asked this question to people who looked good on paper, but had lied and couldn't name an HTML tag. Made a fairly quick interview. I feel like this is more of an icebreaker than a serious question (name literally any HTML tag and we move on). The goal is to put people at ease so they relax during the interview. Thanks for the feedback though. Good to know not everyone is going to have that reaction. 
The Perham in this with the top comment? Nice..
I still remember my first tech interview where I had to live code and completely froze up and couldn't remember a div tag. ugh. i still have nightmares about that.
Does that mean you're really a lisp programmer at heart? :-)
Nice, thanks!
You are, baby. 
Fully agree. Also check out each_with_object. Can get your block down to even fewer lines of code because the accumulator (object) is automatically passed to the next iteration/returned.
SomeModel.build_&lt;associated_model_name&gt;(params) or constantize
Thor is probably your best bet. Other CLI gems would be the tty suit (tty-prompt, tty-screen, etc.), and possibly HighLine.
Thanks. Reading through Thor and Highline now and they seem legit 
Hope this helps: https://github.com/markets/awesome-ruby#cli-builder
Couple of my favourites, which really add up to Ruby being my favourite language: * `Enumerable#grep` * `Enumerable#flat_map` * `Enumerable#one?` * `Object#===` * `Class.new` * `Enumerator.new`
This is so dang useful!
That's really interesting, thank you for sharing! I had forgotten that Postgres can treat CSV as a database table, it's nice to see how easy it is to declare it with Sequel.
I feel like making a "work environment" with a fancy Rakefile is also an option.
Make sure you use canonical links when linking to a file/directory on GitHub. On GitHub, you can press the "y" key to update the URL to a permalink to the exact version of the file/directory you see -- [source](https://help.github.com/articles/getting-permanent-links-to-files/). I've tried to fix your links: Relative | Canonical -|- https://github.com/basecamp/sub/blob/master/README.md | https://github.com/basecamp/sub/blob/bb93f151df9e4219ae4153c83aad63ee6494a5d8/README.md Shoot me a PM if you think I'm doing something wrong.
we'll publish it on YT later
Every time I use this method, I tell the string I'm calling it on "boiiii you just got chomped!"
This was actually my first thought. :)
Not precisely a method, but the most underutilized ruby syntax is the word "class". Keep classes small, and extract complicated lumps into new service classes more often, so each class does one thing only. 
Niiiiiice. 
Object.method(:foo).source_location
Also, `%i{foo bar baz}` for symbols.
There's two other easter eggs in the codebase that I can think of...
Great post. Native extensions should be avoided if possible, they can have a significantly higher maintenance cost than pure Ruby.
Array#repeated_permutation. Cuz checking all possibilities is now fun and easy.
I lost a lot of hair over this same issue http://stackoverflow.com/questions/24853991/rails-4-0-linode-heisenbugs-part-deux
I didn't know about `%i[]` for symbols. Thanks!
I wish `#inject`/`#reduce` and `#each_and_object` passed the element &amp; accumulator to the block in the same order; I always get the ordering mixed up.
Yeah, fair point. I remember each_with_object having the accumulator second because it's -with- the object.
Great post! Also worth checking out &amp; fairly similar: Sidekiq Pro [Statsd integration](https://github.com/mperham/sidekiq/wiki/Pro-Metrics), which works nicely with Librato.
http://orig01.deviantart.net/68a8/f/2014/252/3/2/who_let_the_chomps_out__by_kingasylus91-d7yjhnt.png
Care to share what it was lacking to cause you to move to the custom one?
I know this isn't Ruby-specific but so many Rails and Ruby apps depend on Redis that I thought it would be useful to the community.
I have a question for readers of this thread. If you didn't upvote this, why not? My research shows that about half of Rubyists use Docker. And seeing the amount of beginner-level Docker conference talks on RailsConf etc, I am inclined to think that there is relatively little experience with Docker. Would this project not be helpful? If it does not appeal to you, why not?
Yes, I read that, but I didn't want to do that manually... plus you know, I like package manager managing (&amp; updating) all packages :) 
this is why I've really become fond of redis via elasticache. cloudwatch has all this monitoring built in, and it's simple to add an alert (and handle backups, resizes, redundancy, or use cluster)
That would be .map for sure :)
You can put a file named a.sql or any other names you like, and mount it to /docker-entrypoint-initdb.d in postgres image. The postgres image will run sql or bash scripts under that ~~file~~ directory when start. Reference: https://hub.docker.com/_/postgres/
Awesome, thanks.
Not that I know of, but you might consider suggesting it to the SciRuby community.
in a similar vein here's my ruby-on-rails + docker + ECS + terraform sample. https://github.com/jdwyah/rails-docker-ecs-datadog-traceview-terraform I did a talk about it at boston.rb https://www.slideshare.net/jdwyah/diy-heroku-using-amazon-ecs-and-terraform
For those who didn't read the article; it's about a guy who missed a small grammatical typo in an article that went unnoticed for 4 years. It has nothing to do with Ruby.
Well...the typo was about a Ruby article. Did you read the whole thing? I ask because the post wasn't about typos. 
'%I{foo #{bar} biz}' Capital I for interpolation. Works with %W too
Yep! I use that all the time, I just wasn't aware that you could do the same for symbol arrays. Ruby is grand.
`Object#instance_eval` does wonders for meta-programming and DSLs.
So, i appreciate the feedback. For some feedback of my own: I think you're a bit cynical here. I've gotten a ton of positive feedback about this post from my mailing list subscribers. Sure it's rainbows and sunshine, but sometimes we need that. I need that. This might be the first such post i've ever written, which would make you my first rainbows and sunshine detractor. By and large programming is a grind and people need bright spots. Most people anyway. If you're not on the list, most of my posts are hyper-technical. But the more technical a post is, generally the less applicable it is. We're all human. Being human is part of being a Ruby developer. This post is about that. Sure, we all make mistakes. That's easy to acknowledge, that wasn't the interesting part of the post. What isn't easy to do is respect and seek the feedback of people of varying skill levels. In a world where there are plenty of job adds for "only senior level Ruby developers", it's easy to forget that fresh experience brings fresh perspectives. Yes juniors may not know a lot, but it also means they don't have a lot of bad habits either. You seem like a person who cares about a lot of things. You took a lot of time to respond to me and I respect that. I hope you channel the same energy and effort into open source contributions. If not I hope if you ever find some typos, you or a bug in a project you take the time to report it. 
This is an incredible article. Very useful for anyone getting into rails, or for anyone who perceives that they know ruby's api in and out
Or use a design to avoid this in the first place by extracting the options into an options class and having a method along the lines of: def option_given? [foreign_id, unset_foreign_id, name, description, estimation].any? end
Side note, you can also return enumerables for a method: class Whatever def children # enum_for turns any method that yields into an Enumerable return enum_for(:children) unless block_given? @children.each do |c| # do some stuff yield c # do some stuff end end end
Nice. I'll have to look into that and Enumerator a bit more. Thanks !
I don't understand the _p_ variable in the block in the _each_cons_ example. Where does it come from? What is it?
Then make that happen, interviews are a two way street and there isn't a better time than now given the current hiring climate. Happy to help if I can. 
It's not a variable. [It's a method.](https://apidock.com/ruby/Kernel/p)
Thank you.
If the text is what you're after, it looks like someone found the API endpoint directly and hit that instead of scraping pages, but it's a couple of years old: https://github.com/vizvamitra/youtube_subtitler/blob/master/youtube_subtitler.rb#L118 Always check Github, you'll find lots of these types of problems solved over there
can anyone please explain simply what the benefit or use case of a lang server is? 
https://github.com/ruby/ruby/blob/0472578b26793e45434769200a806cb6190e5700/numeric.c#L5621 It uses DBL_EPSILON, which will generally come from [float.h](https://en.wikipedia.org/wiki/C_data_types#float.h), but has a fallback definition [in that file](https://github.com/ruby/ruby/blob/0472578b26793e45434769200a806cb6190e5700/numeric.c#L59-L61).
Thanks. If the situation was really bad, I'd certainly start looking around...again... ;-) The trouble is that to find a better team than my current one in ruby, I'd have to go abroad. The Ruby market is fairly small here. Keep up the informative comments, I enjoyed learning.
Hello ! I was attracted to Ruby first because I came from Java and Ruby is OO while dynamically (duck) typed which made me curious. Then I found jobs using Rails. The RoR community and teams are big on testing, and some other good practices, from my own experience more so than Java teams. It's also often more small business / entrepreneurial mindset than big companies, which I personally enjoy more. Rails is a fantastic tool to work with, it's very mature and if you take the time to dig into it and learn it deeper than the basic tutorials, you'll discover treasures of really good, well thought out features. Don't get fooled by the ease with which you pick up the basics: both Ruby and Rails can keep you busy for years learning new things about them. I've been writing Ruby code professionally for about 10 years now and I learned a new way to leverage Enumerable yesterday (thanks, /u/moomaka). Beyond that, good JS skills are a must have nowadays. It's a language that has long been reviled because of inconsistant implementations, and early design decisions (cf Crockford's "Good Parts" book) but it's much easier to handle nowadays, and it can be really fun to dig into too. I also like to play around a bit with Clojure, but not so much lately. I'm pretty sure Python, Erlang and Haskell must be a lot of fun too, but there are only so many hours in a day ;-)
This is exactly what I was looking for. Thanks!
I don't think this subreddit means what you think it means.
jajaja I found this on sept. 2015. Useless but funny, though.
Let's say I want to make a calculator with Ruby. What tools can I use for the interface and how would I run the application (I.e. a .exe or .jar).
Thank you, what about Ruby desktop apps? Or is Ruby used mostly for server side scripting?
Cool project! I would still primarily use Crystal if I wanted an ultra-performant Ruby-like language, but it's awesome to see Ruby implemented in so many different ways.
There are some desktop apps, but it's pretty rare. I don't actually know what is involved with deploying those. 
Alright, thanks. I noticed something called JRuby, apprently you can run JRuby from Java and viceversa, so I'll look into it as I'm a Java programmer and I may be interested on checking how can I make some tasks easier with Ruby and run it from Java.
Yes, JRuby runs ruby in the JVM, so if you have that installed you're all set. 
I can't tell you how many times I've gotten headaches from looking at other C-based languages like C#, Java, and PHP. Ruby, and FP languages like Haskell and Elixir make doing anything in those previous languages almost infuriating.
The company my father works for is looking for interns to build Ruby/Python applications. Being that I know both, I definitely want to go for it. I just gotta make a decent resume without having much job experience (wooo...). Anyway, my plan is to eventually be able to make Rails/Padrino+Sinatra web apps using CRuby/JRuby. Haskell and Erlang/Elixir are for personal enjoyment, or for even if they begin to pick up in web industry use. That way I could have versatility with experience. 
I did a large web project in ASP.net, and swore I would never do *that* again. I had been using Python at the time for any one-off scripting needs, so I started looking at Python frameworks. They all claimed to be the "Rails for Python", so I thought I ought to take a look at the thing that everyone else was trying to emulate. I did a project in Rails and was hooked. I love the Ruby language, and it's the first tool I reach for, unless I have a compelling reason otherwise. Most of my dabbling over the years has been with it, although I'm starting to dig a little more into the various javascript platforms now.
PHP is based on procedural paradigms and has more Basic rather than C roots. C# and Java are OO and owe more C++. FP languages have their own problems, i.e. avoiding side effects and the lack of internal state can be frustrations in their own rights. Ruby has the flexibility to write using OO, functional or procedural paradigms though; i.e. its expressive. 
&gt; If not I hope if you ever find some typos, you or a bug Typo.
If you are just starting out with Ruby, I wouldn't recommend JRuby. Your java skills won't necessarily be much use starting out, and its a few steps more advanced. Its good to just learn how the most run-of-the-mill ruby apps get done. eg. * run a ruby.rb file directly * run a small ruby cli app * run a single file rack app * run an api with a small framework like sinatra * run a basic web app with rails If you do those 5, you'll pretty quickly have a broad understanding, and its not much work.
With the last bit: I think a benefit of FP is avoiding changing states. That gives you one less thing to worry about at runtime. I know Ruby has functional capabilities (although really all languages have to have functionality), but as your sort of stated; it's not the quickest and therefore not up to par with languages built for functionality (duh). It all really matters on what you're doing/you wanna do though.
"command" is a good word for them, too. Nice. But yeah -- do you happen to know how these types of objects become known as 'services'? is it a laziness thing? Like.. maybe someone was actually implementing service helpers, and someone just repeated the pattern for in-app functionality?
Do you like to... dabble? Know what I mean nudge nudge wink wink say no more say no more. 
But go has the electrolytes the microservices crave!
I believe it stems from the DDD pattern language.
Nothing off the top of my head, no. Lots of good stuff a little google-fu will get you to quickly to, I'm sure. DigitalOcean has **fantastic** guides that I highly recommend them for. Fairly easy to set up, good support. I like them a lot.
Told you at the beginning of the post i can't spelll ;)
&gt; Module mix-ins are nothing but multiple inheritance No it's not. It's syntactic sugar for singular inheritance (Ruby supports no other form). But you're right that it doesn't help the situation. Chances are if you have a single model that gets that large you've run into the 'God Object' and may consider other ways to separate it. Often this can be handled through multiple implementations based on some switching logic. e.g. an `Order` model can be broken into separate classes based on it's status.
Why not just do this in your SQL query: DATE(timestamp) = ? Instead of this: timestamp BETWEEN ? AND ? Then you could just pass in the date object directly, instead of needing an awkward range between two Time instances. That seems like a smell to me.
That's a performance optimization, though. I'd rather materialize a view with a `date` column, which would be far more performant than `BETWEEN`. And, at any rate, I'm not sure I'd want `Date#all_day` obscuring a performance optimization.
It looks like you're missing the Ruby development package for your package manager (ruby-dev or ruby-devel, depending). If you'd like any real-time help please stop by the [Ruby IRC channel on Freenode.net](irc://irc.freenode.net/ruby).
It looks like an error you'd see on Windows, for sure. However, the paths don't match up to a Windows machine, cgywin or not
I'm very interested to hear how you would implement "select all of a customer's records for the day in their preferred time zone" using the casting approach you suggest without resorting to any database vendor-specific SQL extensions or extra session configuration. "All records on the given UTC day" is rarely a useful concept.
There are two obvious approaches, the first one would use `BETWEEN` with timestamps, and the other could use dates: 1. Use timestamps for the column that drives _that_ query. 2. Subscribe to events that signal changes to customer time zone preferences, and update the date columns corresponding to the given customer's data. I get that there are special circumstances for sometimes having to use time ranges for SQL queries that, logically speaking, work with dates. This is a general purpose method monkeypatched onto `Date` by activesupport. I don't really see anyone using this in a way that passes code review muster. If you need to use time boundaries to constrain date ranges, that should be an obvious and explicit part of the query implementation, IMO. And, in the end, I prefer the latter approach anyways. Inevitably there are only a few reports in the whole system that need time-zone aware date range filtering -- e.g. time series charts. I vastly prefer building a denormalized view that serves such queries. It performs better and involves the least amount of convoluted ORM or SQL goup.
Materializing a view isn't a performance optimization? Depending on the shape, size and access patterns of the underlying table, a matview is likely to be a sledge hammer hitting a knitting needle.
We've had this argument before, we don't need to repeat it. I say it's a form of multiple inheritance, because the class doing the mixin inherits from both it's declared parent class (as well as it's ancestors), and the mixin(s) included (as well as their ancestors). one superclass plus one or more included mixin(s) is multiple. But at any rate, we seem to agree it's a form of inheritance (whether 'multiple' or 'singular'), which is all that matters for this discussion. Perhaps in the future I'll say "mixins are a form of inheritance" and leave out the word "multiple" to make you happy. 
I have heard so much about Oj speed but have a hard time integrating this with ActiveModel Serializer(0.10.x) in Rails 5. If someone has done this successfully, I would like to know how to override the serializer to use Oj instead of default Ruby JSON. 
Honestly, based on name alone, Date#all_day seems more intuitive than #Time#all_day.
&gt; You can just use ERB for this. Yes, basically I can. It will be even uglier template than Liquid ones, without any advantages (except for less dependencies, but it is not a problem for my project). &gt; Most templating languages assume you're trying to generate HTML. Thanks, I know :)
A date really is just a time range. As humans, we have divided time into periods that make sense to us. Days, weeks, months, years. With timezones thrown in. We use them so often that we have convenience methods to work with them, but in the end they are all just periods of time. And a lot of it is ambiguous. We don't agree worldwide what date it is now, or [what week](https://blogs.msdn.microsoft.com/oldnewthing/20160311-00/?p=93144). Months have different numbers of days, there are leap years, etc, etc. For computers, just providing two UTC timestamps is unambiguous. Consider: yesterdays_invoices = Invoice.where(created_at: Date.yesterday.all_day) yesterdays_invoices = Invoice.where('DATE(invoices.created_at) = ?', Date.yesterday) About equally readable. Now consider: last_weeks_invoices = Invoice.where(created_at: 1.week.ago.all_week) last_weeks_invoices = Invoice.where('EXTRACT(WEEK FROM invoices.created_at) = ?', 1.week.ago.to_date.cweek) Not only is the second less readable, it is also not database independent. This code is Postgresql. In MySQL I could use the WEEK() function, in SQL Server it would be DATEPART(), in Oracle I wouldn't know. Which is why we use an abstraction layer around our database, of course. So for consistency, readability and cross-platform compatibility, I prefer just using ruby time ranges everywhere and letting the database abstraction layer figure out the query. That way I'm only dealing with time quirks in ruby, not both in ruby and in SQL. Optimizing for developer time is the ruby philosophy, after all.
&gt; It will be even uglier template than Liquid ones, without any advantages (except for less dependencies, but it is not a problem for my project). Maybe I misunderstood you, but I thought you were looking for a templating system that respects whitespace? ERB does, albeit with some small quirks. class Foo &lt;% for i in [1, 2, 3] %&gt; def foo_&lt;%= i %&gt; &lt;%= "puts #{i}" %&gt; end &lt;% end %&gt; end Yields: class Foo def foo_1 puts 1 end def foo_2 puts 2 end def foo_3 puts 3 end end
Depends on the context. It is very true for named dates, I would definitely prefer `Date.today.all_day` over `Time.now.all_day`. On the other hand, when you start doing calculations it quickly makes sense. E.g. `3.days.ago.all_day` has great readability, even though it is a Time object. Converting to `(Date.today - 3.days).all_day` or `3.days.ago.to_date.all_day` is not an improvement.
There's some small stylistic things you could fix easily by using rubocop. It'll teach you good habits. Some of these are a bit subjective, but generally accepted as good practice. 
I myself am a vim guy, but I heard from few people that rubymine is pretty good too
I guess I'd say that's why it's an optional operator, instead of the default behavior of the "." method accessor -- sometimes you want it, sometimes you don't. ObjectiveC originally (and maybe still?) kind of had that as the default method accessor -- calling any method on nil would just silently return nil. I think it was judged to be too liberal in the end, because of cases like the OP discusses, and I'm not sure if current ObjectiveC still does it. (ObjC preferred saying "sending any message to" instead of "calling any method on", which I actually like for ruby too, with it's very similar object model, both inspired by smalltalk. But it hasn't caught on in rubydom. :) )
i dont undestand, why?
Of course it is. Since we were talking about performance optimizations, I brought up the approach I'd take.
This looks interesting 
&gt; A date isn't "just" a time range -- it's a concept that is important to us humans when we reason about the passage of time. Specifically, it's one that doesn't carry with it a whole lot of baggage like time zones. So, when the code says, 1.week.ago.all_week, and it returns a time range instead of a date range, I'm pretty surprised by that. I want my code to be written in terms of human understanding, not machine understanding. I want to write code that is easy to read, understand and reason about for humans, and that is automatically converted to a format that computers understand un ambiguously. Hence I prefer `Invoice.where(created_at: 1.week.ago.all_week)` over `Invoice.where('EXTRACT(WEEK FROM invoices.created_at) = ?', 1.week.ago.to_date.cweek)`. The second one just takes a lot more brain power to parse and understand. &gt; What happens when 1.week.ago.all_week needs to be converted from UTC to CST? Do we add a "helper" to `Range` like this: `1.week.ago.all_week.to_timezone('CST')`. Make sure `1.week.ago` (a Time object) is in the correct timezone before calling all_week on it. Adding a helper function to Range would be silly. Of course, this issue doesn't magically go away when using SQL's DATE() function. You want timezone support, you need to specify it somewhere. &gt; All of these attempts at making the code look denser or "cuter" with these excessive "helper" methods are fraught with problems. I'm not making code look denser or cuter, I'm making it more readable and I am avoiding dealing with multiple datetime libraries. Using the `all_day` "helper" method is no more or less "cute" than using SQL's DATE() "helper" method. 
Yep, it started looking for me that way too when I clarified my use case on Reddit :)
This is awesome! Sidekiq remains my go-to jobs processor. Out of curiosity, if I wanted to try out Sidekiq.cr with an existing Rails app, there's no way to integrate it directly, right? I would just essentially have to have a barebones Crystal app/service that invokes the jobs?
There is value in learning the patterns of other languages (learning about design patterns blew my mind as a C programmer, learning about pattern matching blew my mind as a Ruby programmer, etc) That said, you can do most things in most languages if you are competent/dedicated enough. Some languages are nice to use because the developer experience in that realm is better than other solutions (I'm looking at you Net::HTTP). It's important to dabble to know things exist and to increase you awareness. I came to Ruby because a job opportunity came up that used it and I've been riding that train for the past 6+ years. I still think Ruby is great for most things and it is one of the more powerful languages in the sense the it is so flexible and dynamic that it's like play-doh (you can do just about anything but occasionally just make a giant mess). I don't enjoy dabbling in other languages really. I'm interested in them, but "dabbling" to me implies small side projects for the kicks, and I'm not interested in that (I get more frustrated that I'm so slow and can't just use what I know). I used to be more into dabbling, but these days I feel like I'm a lot more pragmatic. I want to build things, and if the thing I want to build is better suited to another language then I'll look into it. The short of it is: know enough to know the basic paradigms of other languages so you can know what tool to grab if something isn't working. Ruby is a great all-purpose language with a few downsides and many upsides. Find some other tools to fill-in when Ruby doesn't feel like the best solution
Hi no im actually on linux..
correct im on linux.. 
I think it would be cooler to hack this in with `method_missing` so you could do class Weekday &lt; Enum monday tuesday ... end
I did that for a project of mine, with method_missing and const_missing (I wanted something in between Java's and Crystal's enums) [(code)](https://gist.github.com/Exilor/2d2639b84bb6515499df0c8dbc83d5ba) | [(tests)](https://gist.github.com/Exilor/9021f031351f99eac08090cd1e8cd32b)
I'm willing to help and give feedback if you could provide code written up to this point via a public github repo.
Almost 2,000 downloads from RubyGems, the day of it's release. Amazing! Thank you!
[removed]
Yeah, you would somehow need to disable the hook after the class is defined. I couldn't think of a nice way to do that.
One of very unfortunate additions to Ruby, like silly `.()` operator. It breaks referential transparency (ie. introduces inconsistency to the language), because it makes an exception to the rule as it does not work on regular `nil` object: nil&amp;.nil? # nil, but should return true nil&amp;.to_a # nil, but should return [] etc for all existing NilClass instance methods. 
What are you using to render the screen? I am trying to figure out how to do so with a tic tac toe game I am working on. It seems boring to play tic tac toe with a nested array haha. I have been looking into gosu but having trouble installing the gem for some reason.
Thank you for your work.
Right, it can't use your Ruby/Rails code. You'd need to port 1 or more worker to Crystal and target Sidekiq.cr to a special queue. Your Ruby code can send jobs to this queue for Crystal to work on.
This is not Rails-specific, it doesn't come with ActiveRecord bindings. For AR, you would probably better served by one of the many gems that integrate with the database-specific enum type. 
good point!
Three months, huh. So, you want to show off your Ruby skills, make your interviewers be like "Wow that's a person we want to hire!". Those things can help you achieve your goal: 1. Contributing to open-source 2. Building a complex app (might even try web sockets!) 3. Using frameworks &amp; libraries other than Rails So, here is what I suggest. Pick [Hanami](http://hanamirb.org/). It's a decent framework with a promising future. It's still in early stages of its development, so you will have to experiment, read Hanami source code, communicate with other Hanami users @ GitHub and Gitter. Some parts of Hanami lack thorough explanation and docs. Here is a chance for you to contribute. If you go for Hanami, you will come across such things as ROM and dry-rb. Read about it, experiment with it, will be good for your Ruby skills. So, about the app you'll have to build. There are just some of ideas 1. Time tracker (like Harvest) 2. Blog with real-time editor 3. Currency rate forecast ... Personally, I'd start with the time tracker and move forward to blogging features. A great tool for personal use, don't you think?
There is some interesting stuff there, but why on earth would I want a separate class for each controller action? That feels like an unnecessary level of abstraction. It's going to clutter your filespace and generally you wind up wanting to share logic across actions in a controller, this just makes that difficult with little visible gain. Am I missing something?
I don't have an opinion personally, but I was curious if there was a documented reason on Hanami's website. &gt; Hanami is Architecturally Sound If you've ever felt you're stretching against the "Rails way", you'll appreciate Hanami. Hanami keeps controller actions class-based, making them easier to test in isolation. Again, i'm not super opinionated here, haivng not worked with it, but... &gt; It's going to clutter your filespace This isn't a concern to me, i vastly prefer many files with little code in them (with good naming, but that is its own problem) to a few files with lots of code in them. &gt; generally you wind up wanting to share logic across actions in a controller Use modules or class inheritance? This doesn't seem like a problem to me.
What's the actual downside to having more files? You can always take a set of related files and move them to their own directory.
Rails is a great framework. It's heavy, feature rich, and very productive. I think the hardest part of Rails is learning how to do things without Rails (e.g. how do you do proper CSRF protection, how do you properly sanitize your inputs, how do you manage a session with cookies). Rails is trailing a little behind the cutting edge but it's still solid and very useful
Yeah, I think this sort of thing is tough. It reminds me of the JS communities attempt to write 'good architecture' by breaking things up into lots of tiny single-purpose purportedly interoperable components. It can make _putting them all together_ a challenge, and can make dependency management a challenge. I have some of the same reactions to my limited experimental playing with the new "better than Rails" crop of things like hanami and it's dependencies. Rails is actually pretty decent these days IMO. Certainly there are still things about it that drive me crazy, but I don't know if it's enough to make me leave it for a much less mature "pick up all the pieces from the floor" style platform. Of course, in the best of all worlds, you have lots of properly encapsulated and well-designed pieces, which are ALSO used in a "just works out of the box convention-over-configuration makes some choices for you" platform, which you can _also_ customize as you need to make different choices. _And_ it all keeps working as the pieces evolve independently without lots of dependency conflicts. Of course, this is exactly what Rails is _trying_ to do. That it doesn't succeed completely is not so much because the historical and current committers are not good or have wrong ideas about architecture. it's in part because of legacy decisions, but it's _mostly_ IMO becuase this is a _hard_ thing to do. Other things trying to do it will run into the same or different but equally frustrating problems as Rails, as they mature. 
good point, it's nice for situations that don't result in critical transactions and where we could err on the side of being too liberal, like logging error messages. 
Why would you expect it to work on `nil` like that? The whole purpose of the lonely operator is to avoid calling a method on `nil`. It's not to call the method, and if it fails, return nil. It works the same for `nil` as for anything else. [1].at(0).odd? # =&gt; true [1].at(1).odd? # =&gt; NoMethodError for nil [1].at(1)&amp;.odd? # =&gt; nil ([1].at(1))&amp;.odd? # =&gt; nil # since [1].at(1) # =&gt; nil, we can replace inside the parens in the previous expression (nil)&amp;.odd? # =&gt; nil 
Value testability and separation of concerns more than a simple filesystem tree. 
The true purpose of `&amp;.` operator in Ruby is still debatable - see discussions at [#11537](https://bugs.ruby-lang.org/issues/11537) or [#11816](https://bugs.ruby-lang.org/issues/11816), for example. The point was about `nil` being a regular object in ruby, unlike special `NULL`-esque value in many other languages, and it may receive any standard or custom methods. Existing implementation breaks *safe-navigation*, ie. methods chaining when `nil` belongs to correct possible results of intermediate expressions. It should be implemented in the similar manner like `try` in Rails (ActiveSupport).
So, I am making this little thing for fun, but I would love some help/feedback about how to feed user input to the Ruby interpreter, if that makes sense. Basically, at some point I want to end up with the functionality of IRB inside my program, any thoughts on that?
Instance Methods aren't OOP anymore... who would've guessed that!
In this case, it's duplication of efforts, or in combating duplication, logic is moved further away from where it's needed. This causes maintenance issues down the road.
https://github.com/allcentury/ruby-framework-benchmarks https://github.com/luislavena/bench-micro
In Hanami, you wouldn't write authorization into every action class. You would include it in app configuration, so it gets included in every controller in that app. Also, a Hanami project is modular, so you might have an app that handles the web and another for specific admin, and you could have separate authorization modules for each app. This would still maintain dry-ness, and actually improve it (instead of having a before_filter in every controller, you'd have it in one module). [Here is the Hanami guide for shared code](http://hanamirb.org/guides/actions/share-code/)
No, I'm saying it should be implemented on class level like in ActiveSupport, but with `:respond_to?`-like check included. Now it's on parser-level, with nil/non-nil binary check.
So if the values responds to the method called, execute it, but if it doesn't respond to it, then return nil? i.e. `'string'&amp;.odd? # =&gt; nil` ?
&gt; With Hanami you add another level of abstraction You don't. I mean, it's a new framework so it's understandable that you didn't read their docs, but until you do it's best to refrain from making statements about it. 
In the debate between `foo &amp;&amp; foo.bar` vs `foo&amp;.bar` the second is clearly the winner, since it's shorter and they are functionally identical. I think the bigger question implied by this post is whether or not code should do nil checks at all. Certainly one should get rid of unnecessary nil checks, but it's hard to picture programming certain applications without them. 
/u/lord-of-the-lake is the creator of this library btw.
Does that have to mean dumping all your actions into a fat controller, though? If you have shared behaviours, then those should be extracted to modules or classes that can be included only in the actions that require them.
Mechanize is wonderful. 
I didn't write it, however I am curious to learn.. what is dictating that a true transpiler must be written in the target language?
Well, if you write a transpiler that takes Ruby code and turns it into Brainfuck code, and that transpiler is written in Ruby, you should be able to transpile the transpiler itself into to Brainfuck.
As /u/prh8 has said already, the shared code for Hanami actions work very similarly to middleware in Express / other JS based libs - it's very easy to configure new shared middleware modules to handle specific use cases, e.g. authentication and have them included in every controller or you can specifically include them in each action you need them in (e.g. you can handle protected routes with Pundit this way)
Great 
Mechanize is great and fast if no js support is required. Otherwise Watir 
Capybara with PhantomJS works well headless. See github for examples.
Thank you! Renaming my method solved it
Yeah but phantomjs is discontinued now no?
Other reserved words: alias and BEGIN begin break case class def defined? do else elsif END end ensure false for if in module next nil not or redo rescue retry return self super then true undef unless until when while yield
Thank you. This will save me some time
at my company we use separate classes for each action and it works out great. it is especially useful when ur actions require several methods and services to carry out its job. as a general rule for me, if it requires more than one method, its a class. i cant stand opening up a class and seeing 20 methods for 4 primary tasks. one class for each task ends up creating a much cleaner code base for us (some of our legacy code still heavily uses controllers and its a mess.) theres no reason why action classes cant share logic either. 
&gt; It's going to clutter your filespace I'm pretty sure you can declare multiple actions classes inside the same file.
Note that the `allcentury` benchmark is specifying an ancient version of Hanami. Hanami 0.7.0 was the first "real" dev release from January 2016, according to [Rubygems](https://rubygems.org/gems/hanami/versions). It would be nice to see those benchmarks updated across the board. EDIT: Auto-incorrect-induced tpyo.
Very cool. I just heard about this today at RailsConf. I think the idea can be further improved by generating the cache at 'gem install' or 'bundle install' time. I posted a Github issue for that: https://github.com/Shopify/bootsnap/issues/16
Seems like the VSCode-Ruby team is working on it https://github.com/rubyide/vscode-ruby/issues/118#issuecomment-278221193
nice and simple to use :)
Not discontinued. Not necessarily under further development but it still works just fine.
I can't help ypu, but /r/commandline might be able to.
cryptic doesn't necessarily go hand in hand with "concise" either. For example "foo &amp;&amp; foo.bar &amp;&amp; foo.bar.foo" is more cryptic than "foo&amp;.bar&amp;.foo" imo. 
you mean ruby extensions in crystal or crystal/rust interop?
imho you're best chance would be to look up some tutorials for ncurses and then some ruby-ncurses binding (for example https://github.com/ruby/curses )
I don't think RUST guys would care about using crystal interop... But Ruby folks being able to write modules that are 10x faster using basically Ruby syntax would be AWESOME... I think Crystal is a little young for it ATM but that might get a LOT of great Ruby devs ( the module writers ) into helping Crystal get up to speed on needed features / direction...
FYI you can still use reserved words as method names, but you have to supply an explicit receiver. For instance, self.alias would work.
Is it using electron under the covers?
Doesnt seem too shocking. Several 3rd party gems are a part of the default Rails bundle when you do "rails new". Im shocked gems like factory girl arent at least an option when starting a new rails application. With controller testing taking a back seat in rails 4.1 (no assigns() assertions), this is a good step. Capybara is the de facto browser testing gem. Im happy to see this. 
I wouldn't say part of Rails. It's now included by default in the Gemfile and the integration it's much more straightforward 
Really liking the sound of 5.1, honestly I like the direction Rails is going in in general.
Linux, Windows, macOS, Android and iOS are cool. Have you seen Kivy interfaces though? Dayum, are those hideous! Look, I love cross-platform thingies, I'm all for cross-platform development and code sharing, but, heck. Kivy won't give you any kind of native look&amp;feel unless you spend way too much time designing each and every control. Is it really worth it? &gt; Where are we? Do we really need another "I come from early 2000s"-looking UI library? 
&gt; but why on earth would I want a separate class for each controller action? I guess a single god object with a separate method for each action is a sounder pattern? :) This actually follows the pattern of putting a language level first class abstraction upfront to model your own, javascript has first class functions, Ruby has objects. It also models around the whole rack app/middleware interface as a call-able object, and I assume you can bind endpoints to procs, although I'm not sure. And it fits any type of endpoint structure (REST/RPC...). Rails routes/controllers were modelled after REST, and dont work very well beyond that. It leaked at some point (some years ago), when defining :controller/:action as a route would even call controller private methods, just to show the many ways you can shot your own foot when not segregating interfaces. The file system clutter argument doesn't make sense. I assume you can define many of these classes in a single file, although, if hanami has reinvented the whole autoload leviathan, I'd come out disappointed.
This is probably most useful for someone coming from a different language and wanting to know "ok what's the Maven equivalent here" and whatnot.
A text editor like Atom will also highlight the words on the reserved list for you. It can be very helpful if you are new to the language. 
It's not maintained by Rails team or anything. It's a dependency, which is only used if you write tests using the new "systems tests" feature. I would say that Rails team taking some responsibility for _integration_ of Capybara is a great step though, and hopefully will lead to easier job of writing reliable and maintainable capybara tests. 
Go take a look at the widgets here: https://kivy.org/docs/api-kivy.uix.html Ok they were not designed by Apple or Google, so grated you can't expect that level of quality, but anyway I don't get all this choosey attitude when it could still allow you to build a clean, modern interface, and considering, again, that the other alternatives for Ruby are literally from decades ago, or non practically usable! Ruby needs one of this things and it needs it now. It's fundamental for new programmers coming to the language to be able to make something which looks at least decently good and which they can distribute to other platforms. If you are new comer trying to decide between Ruby and Python, based on some factors including graphics, reading blogs and so on, and finding that Ruby has Shoes, and Python has Kivy, what do you think you will choose? If a more expert coder wants to quickly prototype an app for their clients, what do you think they will pick between Ruby Tk / Python Kivy? Come on... People needs to get stuff done - albeit not perfectly sometimes - and earn their days, and I would love to keep bringing Ruby in my toolbox. If you just want to philosophize on art concepts, take a walk at your local modern art museum and get out of the way.
Yeah, I know, I just took it from the original repository name :D I've actually never used electron myself, but I have been following all the recent JS scene (including the **fatigue**.. ) and I do have mixed feeling about it... but if it can help Ruby with UI these days..
Exactly. But are you sure we do?
I also found this: (https://stackoverflow.com/questions/1761148/where-are-methods-defined-at-the-ruby-top-level), which may help your understanding.
Thank you /u/sciencerulez. That makes sense. 
Quoting Metz: "Duplication is better than the wrong abstraction". You want to wait before to DRY your code, as it may lead to premature optimization and coupling. Start from a small amount of sharing and slowly add code that is really necessary to all your components, not the way around. Sharing everything by default leads to tech debt: conditional callbacks, anyone? I see DRY like Greatest Common Divisor: divide your numbers in smaller numbers (or code in smaller components), then only pick numbers that are "common" and maximize the amount over the time. Here's how Hanami works.
Anyone have success using webpacker on Windows 10? I am having issues starting the `webpack-dev-server`.
This looks cool. Are there any example apps using this library? What makes it exciting is that gnome is coming to Ubuntu!
Here [ruby-gnome2/gtk3/sample](https://github.com/ruby-gnome2/ruby-gnome2/tree/master/gtk3/sample/) you will find 3 directories : * tutorial : this is the adaptation to ruby of the official gtk3 tutorial on how to write Gtk3 application. * misc : you will find a lot of examples on how to use the Gtk3 widgets * gtk-demo: this is the ruby adaption of gtk3-demo application. Furthermore you can find here my terminal (not perfect): * https://github.com/cedlemo/topinambour And a little app that I use to register part of my screen via gstreamer. It is just a little tool poorly written but it shows you that you can easily write the tools you need: * https://github.com/cedlemo/gifshouldbedead Furthermore, you will find examples for almost all the gems directories: * https://github.com/ruby-gnome2/ruby-gnome2 And of course ask any questions related to the ruby-GNOME2 gems here : * https://github.com/ruby-gnome2/ruby-gnome2/issues
Your domain does not seem to be in your possession anymore m'bro
`--conservative` is something I've been wanting for a while, exciting, haven't played around with it yet but hopefully it performs as expected. As the OP says, "The --conservative flag mimics behavior that was possible before by editing the Gemfile and bundle install" -- but I've found even _that_ behavior, editing the Gemfile to require a more recent version of a single dependency and then `bundle install` to get a more "conservative" update -- to be mysteriously unreliable lately, sometimes it doesn't seem to work right for me, although it used to. But: &gt; --major &gt; Prefer updating to next major version (default). Wait, does this mean that `bundle update` with no args will only update to the _next_ major version, even if further major version increments are available? That's not what `bundle update` with no args used to do... if that's what it does now, how does one get the old behavior? I'm hoping this is a doc bug, and `bundle update` without args functions as it did before. In fact, I kinda suspect these are all doc bugs, and "next" doesn't accurately describe the behavior of `--major` `--minor` or `--patch`. I'm guessing for instance `--minor` _really_ means "only update minor version, keeping major version fixed", which doesn't neccesarily mean the _next_ minor version, it could be several ahead. That'd be what I'd expect and desire, anyway. I'll have to find some time to play with it. 
Thank you for your hard work.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [ruby-gnome2/ruby-gnome2/.../**builder.ui** (master ‚Üí 86c8b38)](https://github.com/ruby-gnome2/ruby-gnome2/blob/86c8b389663564f1175b3962bfa174d31cc358d5/gtk3/sample/misc/builder.ui) * [ruby-gnome2/ruby-gnome2/.../**builder.rb** (master ‚Üí 86c8b38)](https://github.com/ruby-gnome2/ruby-gnome2/blob/86c8b389663564f1175b3962bfa174d31cc358d5/gtk3/sample/misc/builder.rb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dgy35z3.)^.
&gt; glade Looking at: http://ftp.gnome.org/pub/GNOME/binaries/win32/glade/ it seems that the latest windows build for glade is from 2014. It would be good to have a more updated version. Maybe you could get in touch with the glade maintainers and ask them to make a new windows build? I could do that myself, but I am sure that if you ask them they would be a little bit more motivated and release it faster, possibly ;)
Great article! I appreciate the section that details where it is appropriate to use something like Resonad. It provides good context. Thanks for sharing!
Via MSYS2 it seems that you can find a more recent version : see [the list of provided packages](https://github.com/msys2/msys2/wiki/Packages) : * mingw/mingw-w64-glade 3.20.0-2 User interface builder for GTK+ and GNOME (mingw-w64) * mingw/mingw-w64-glade3 3.8.5-2 User interface builder for GTK+ and GNOME (mingw-w64) Based on this page https://glade.gnome.org/, the 3.20.0 is the last version. 
s/method aliases/prepend &amp; super/ module CoolFeature def foo p 'cool foo' super end end class Thing prepend CoolFeature def foo p 'foo' end end Thing.new.foo # =&gt; "cool foo" # =&gt; "foo" 
So it's just his attempt at ridiculizing Ruby, ... I thought I had discovered something more important, but no :)
4 hours?
Just pick one. Which one doesn't really matter. Find something you want to code, don't be too ambitious, and try to write it. Both python and ruby are good languages to start. React isn't a language, it's a javascript library. Although javascript is unavoidable today, I don't think it's a good language to start, it has too many warts, too much ambiguities for a newbie. However, if you've only got 4 hours of experience coding (do you count setting up your environment in those?), don't expect to be out looking for a job anytime soon.
Personally, I wouldn't choose the word "fullfilling" with respect to Unicode, rather "interesting" because of all the things one has to deal with ;-) But yes, it definitely helps to know Unicode better. As for the example given in the FAQ where U+212B is changed to U+00C5: Although the visual representation is the same there is *some* loss of information. What if the user specifically chose to use the angstrom sign codepoint, for whatever reason? When later extracting text from the generated PDF, the wrong Unicode codepoint would be used. I think it's better to use a font that contains correct Unicode-to-glyph mappings (mentioned above as NFC-Complete font) or let the user perform the normalization step. Small caveat here: HexaPDF does *not* currently handle this case correctly, i.e. multiple Unicode codepoints mapped to a single glyph. In such a case one of the Unicode codepoint is used. This will be handled correctly in a future version.
?? What you didn't understood by *modules* (mixins) ?
Check for job offers in your area for every language to have a good idea of the demand.
i'm sticking with dry-monads and dry-transactions from the dry-rb universe, because it's nice to know there is an active ecosystem and community around my choice of syntax. i'm happy to share any learnings you would like. 
I have to admit, I'm confused as to why `Thing.other_other_thing.inspect ` returns `:surprise`. Shouldn't it return an array of values? What am I missing here?
Is it me, or did anyone else not want to read an article when the title doesn't use proper grammar? I mean, not that I would disagree with the title (much) if it had not had punctuation at the end.
I didn't write that, and I understand everything so far as I know, but ruby had module mixins long before it had `Module#prepend`, and it's only `Module#prepend` that finally gives ruby everything you need to 'decorate' methods like this properly. Well, unless you do the `method_chain` type stuff Rails used to. Maybe that's what you were thinking of when you say 'method aliases'. In my and many other people's opinion that was not a sufficient solution. But prepend is. Btw, "What didn't you understand" is seldom a good conversational strategy. 
Thank you so much, great idea! 
Roda is amazing. I genuinely think it hasn't taken off due to lacking a flashy website. The ability to have fine grained control over nested routes in a sane manner is, by itself, a huge win. My DB access, authorization and authentication all became far more elegant and simple after switching. The tree approach lets me actually write routing patterns that work completely as expected on the first go. For anyone curious, just do a comparison of the code you end up with in say sinatra managing a route like '/users/:id/resource_1/:id/resource_2/action', and have users, resource_1, and resource_2 all contain their own REST verbs. 
It's not. It's a good choice among a number of good choices. But it's not 2007 anymore. Everyone else has seen what Rails does well and most of its best ideas have been poached repeatedly.
Seriously, Roda / Sequel for single page web apps. Why bother with anything else?
Check out [cinch](https://github.com/cinchrb) if you want to roll your own
You mean the sum total of it's good ideas has been incorporated into _each_ competing solution? I think that's the author's argument. Solution X or Y has picked up the odd piece that made Rails great, but none come nearly as close to being a one-stop shop. I'm not saying he's right (I wouldn't know), but I think that's what he's arguing.
Rails set a lot of new standards that have, in fact, become standards for web frameworks. You look at web frameworks before Rails and compare them to frameworks after Rails. They all start looking a *lot* more like Rails in that second group. Not every one incorporates everything, but Rails also doesn't have some of the features that those newer tools bring to the table. I think the best thing I can say about Rails is that nothing has completely superseded it in the decade-plus since its release. There are a lot of other options that are more or less lateral moves, and there are options that are better in specific cases. But there hasn't been something that has set a new benchmark that has completely rewritten the book the way Rails did. Rails is still a very good option. But all of the traits that made it *unique* back in the day are largely no longer unique.
It's quiet in here.
don't forget trailblazer. I am not sure how they all differ either. 
The "best choice" for what? After 12+ years of Ruby I prefer Sinatra or Grape. Not all "opinions" in opinionated software fit my goals.
I'm really happy that you've found great success with Roda, it's definitely one of the best Ruby web frameworks. &gt; That included several problems we had with streamed responses (which Rails calls Live Streaming for some reason I don't quite follow, although I suspect that's because they introduced some optimizations to start sending the view's header sooner and called it streaming support, so they needed another name when they introduced ActionController::Live) after each major Rails upgrade. Because of `ActionController::Live` I had no idea that most web servers already have streaming support with pure Rack (though a different kind). While reading Sinatra and Roda code I found out that you can make a lazy enumerable where `#each` yield chunks of the response body, and web servers will immediately send those back to the client. And that's the only streaming I need at the moment, I don't need SSE yet (which as I understood `ActionController::Live` is all about), but I didn't find out how to return a Rack response body in a Rails ‚Äì Rails abstracts Rack too much. And with EventMachine deferring and Rack hijacking you don't have to tie your web workers to client's download speed, which I'm researching now for [tus-ruby-server](https://github.com/janko-m/tus-ruby-server); but I know you already wrote an extensive blog post about streaming ;) &gt; I replaced [...] Devise with a custom solution I'm curious, have you tried [Rodauth](https://github.com/jeremyevans/rodauth)? I look forward to being able to try it finally. &gt; it allowed me to easily lazy load the application code, which allowed the application to boot instantly with Puma, without the need of autoload and other trickery. This is truly amazing. And it's only possible because Roda routes incoming requests dynamically (as opposed to Rails' routing which compiles statically, is incredibly complex, and has less features). At work we use Cuba (my preferred framework is still Roda, of course), so I'll try to do something similar to speed up application boot time, as it currently takes up to 5s to load and we're really conservative about dependencies. &gt; It's basically one simple source file that handles routing and plugins support and basically everything else is provided by plugins you can opt-in/out and each plugin, being small and self contained, is pretty simple to understand I *love* this design, each feature is contained in a single file, and you don't have to load the code for feature you don't use (which means it requires very fast). I found it to work very well in [Shrine](https://github.com/janko-m/shrine) too, that way I was able to make Shrine much more configurable, and have configurable dependencies (e.g. you don't need the heavy `mime-types` gem if you're determining MIME type from file content). &gt; So, one of my main motivations to get rid of Rails was to get rid of ActiveSupport, since Rails depends on ActiveSupport, including its monkey patches and auto-loading implementation. I know this frustration. "Cool, [Chewy](https://github.com/toptal/chewy) looks like a very nice wrapper for Elasticsearch‚Äî oh, no, it loads ActiveSupport". That's one of the reasons why I created [Shrine](https://github.com/janko-m/shrine), because I wanted flexible file uploads without ActiveSupport (CarrierWave and Paperclip depend on it, Dragonfly and Refile don't). It's really easy to write libraries without ActiveSupport, Ruby is already incredibly rich in standard library, so I don't get why library authors automatically reach for ActiveSupport. If you make your library not depend ActiveSupport, it will be available both to people who use ActiveSupport and to people who don't, so it's objectively a better decision. &gt; But ActiveSupport was still there as a great warrior! This time it was dependency of... guess what? Yep, FactoryGirl! I'm surprised you even got FactoryGirl working with Sequel, I thought it only works with ActiveRecord. &gt; At some point I might decide to create my own simple jobs processor just to get rid of Sidekiq's monkey patches If you're referring to [this](https://github.com/mperham/sidekiq/blob/3c09d3e910d0d07b5c640d07d4d72a8786e7c9c7/lib/sidekiq/delay.rb), isn't that opt-in now in Sidekiq 5? ------- Thank you for sharing this story, it was really inspiring to me! I believe that you'll find yourself having to fight less and less, as I feel like the Ruby community is going in a good direction now with the wider adoption of generic libraries.
At its core, event listener is simply a pub/sub system. A listener can subscribe to the event publisher to be notified when a particular event triggers. For example, you have a class `Menu` and a method `add_listener(l)`, which store listener `l` to an internal array. Whenever an event happen inside the `Menu` class, it loops through the array and invoke the listeners. Example: def add_listener l self.listeners &lt;&lt; l end def press_event_happened self.listeners.each do |l| l.on_menu("pressed") if l.respond_to?(:on_menu) end end The only thing it needs to check if the listeners passed to `add_listener` satisfy the basic contract. In the example above, that basic contract is the method `on_menu`, and listeners must implement `on_menu`. In OOP world like Java, this is normally done through an interface. In a larger ecosystem with more complex relationship between publishers and listeners, there is normally a centralized hub that accepts and processes events. Publishers no longer keeps a list of listeners for their events, but rather posts (publish) the events to the hub. The hub distributes the event to the interested listeners (subscribers). This decouples the publishers and listeners completely from each other, thus simplifying the code a lot.
Agreed. If you don't want to be a Rails citizen, it doesn't make much sense to live there.
[wisper](https://github.com/krisleech/wisper) is a nice gem for this.
To me, an half-blown developer, that meant going experimenting with the "rack-server" gem, and injecting small pieces of Ruby into HTML as you would do with PHP; don't hit me with a large trout yet. I used it for a little toy project but I had no idea how much I would learn and have fun by doing this. Particularly there were many questions I started asking myself that led to great aha moments concerning how HTTP works and how frameworks had built around it. Also, you start thinking much more creatively (dangerously?) because everything is "just ruby (tm)": for example I made a silly silly "app" consisting of a single HTML &amp; ruby file that only showed a button. When clicked by a client, the page created a copy of itself with a random file name, redirected the client there and deleted itself. That other page of course would do the same: when its button was clicked, create a copy itself, redirect the client there, delete itself... Call it "secret web pages", call it stupid, but it was fun and I learnt a lot. It gives you a sense of freedom that is totally different from rails, and maybe it should be experienced by new and old developers... probably a student would get a better overall understanding‚Äã of the underlying architecture (HTTP), and really understand why, for example, the RESTfull got that much success, ecc... In Rails, I would have never attempted at something like that.. I would have been too scared of messing up the big "magic machine", and anyway when learning Rails I was too busy following guides about how this and that should be done. Of course, I would absolutely **not** suggest rack-server even for a simple CRUD app, but hey, you know about those two lines of ruby utility code you always wanted to shove into an HTML file, in place of PHP? Eh, just go and do it, it's fun! :)
Haha, right? Learning anything at that point is going to be a plus. 
I almost wouldn't mind so much that grammar is a lost art in brogrammer culture in recent decades, if people weren't so blasted *proud* of it. If you are a developer, your primary responsibility and work product is *communication,* whether that be with teammates, other stakeholders, or your future self. One of the primary *artefacts of* that communication is the code (including tests) that you write. Good code is necessary but no longer sufficient; as a dev and as a lead, I would *greatly* prefer straightforward, understandable, reasonable code that was communicated well, rather than artfully "optimised" code that is going to take a senior dev an entire afternoon to wrap her head around a single feature. It *doesn't matter* how fancy your code is. It matters *existentially* that your code works well *and* is readily understandable to others. Two words: *bus factor.*
Will `dry-monads` users be able to switch to your gem without rewriting their existing code? I mean, `dry-monads` gem uses those `right`, `left`, `fmap`, `bind` and other functional thingies. Are those names aliased in your library? 
didn't know this was possible. 
[sarcasm]Hm, amazing web design.. The missing half of first letter of each single line makes it amazingly easy to read[/sarcasm] [Come on, how hard can it be to get this simple thing right?](https://imagebin.ca/v/3L5CHbwRecyo)
thank you for the positive feedback, comments like this encourage me to keep on writing articles like this. I'll try to improve on my grammar in next one.
Thanks - would love to more articles like these (how to write more idiomatic ruby)
I mean there are multiple books in the sidebar that are exactly about that.
I've used rubocop in a project, it's helpful for code formatting. But I don't think it can tell you can use a select instead of a map? 
Nice - will look into using it further
Hi, yes, I read about it when it was announced, but I still didn't feel the need for implementing such patterns in our app. Validation is not a pain point in our application, nor dependency management. But it looks useful to some applications. But I agree we probably share a very similar mindset and would benefit from common libraries sharing the same principles as us.
I'm pretty sure Trailblazer isn't Rails specific, you could use it with any framework AFAIK.
&gt; I found out that you can make a lazy enumerable where #each yield chunks of the response body This was the traditional approach but in addition to that it's also possible to use Rack hijacking mechanism to handle streaming (SSE included) properly (Rack doesn't guarantee that the server should start streaming the responses immediately for each `#each` call, although most web servers would work this way). The hijack mechanism is even simpler in my opinion. But if you try to understand how ActionController::Live works, by spawning a separate thread and all the logic it requires to make it work, you'll understand how complicated it is to debug such code when bad things happen. That's why I prefer to keep things simple as much as I can. In my opinion ActionController::Live overcomplicates streaming for very few benefits handling some cases transparently in a way the user might expect. This approach is too dangerous in my opinion because it may lead to some deadlocks under some conditions, as they indeed happened a few times with my app after upgrading to new Rails releases. I'm not particularly worried about slow clients because the application is behind a proxy, it just happens that some requests to download a big spreadsheet may take a while to finish, so I want to stream them so that the user starts downloading them immediately. Or when generating a big HTML document from multiple pages for printing purposes... &gt; I'm curious, have you tried Rodauth? I considered Rodauth among other solutions but ultimately I thought they would require more time adapting our authentication logic to them than implementing our own. With a custom implementation it's much simpler to maintain such custom logic anyway. I realized I didn't get much benefits from such auth frameworks. Our authentication strategy is quite odd so we always have to implement a custom strategy whatever auth framework we choose anyway. We have a custom password hashing algorithm inherited by the time the application was written in Grails. Our real clients don't authenticate with a password but through a custom encrypted token mechanism agreed between the client's own authentication mechanism and us. At some point they intend to implement some SAML 2 IdP and this could change, but so far our application wouldn't benefit from some authentication framework. &gt; This is truly amazing. And it's only possible because Roda routes incoming requests dynamically. It makes it easier, yes, but I would find a way to explicitly lazy load such code if I had decided for Hanami or Sinatra anyway. Even Rails API is not too bad, I mostly dislike its internal source code style. &gt; I'll try to do something similar to speed up application boot time, as it currently takes up to 5s to load and we're really conservative about dependencies. These days I stumbled upon Bootsnap which promises to speed up requires in Ruby apps. You might want to give it a try: https://github.com/Shopify/bootsnap I didn't have the chance to try it yet, but I intend to try it after I'm done with other items in the backlog. &gt; (e.g. you don't need the heavy mime-types gem if you're determining MIME type from file content). I noticed the mail gem recently replaced `mime-types` with `mini_mime` to make it ligher in memory usage: https://github.com/mikel/mail/commit/634d91145cb65a85dff9da61eddc9e2de0609f8b Maybe you might be interested in checking it out. &gt; I don't get why library authors automatically reach for ActiveSupport. I actually get it. I value extensions such as `blank?` for example, and I'd love Ruby to add `blank?` to core Object implemented as simply as `nil? || empty?`, however it would be incompatible with the more complex ActiveSupport implementation and so it's hard to get it acceptable. This is something I think doesn't work really great with the way Ruby core tackles such requests. They usually say: "give it a try, implement a gem adding this and if it becomes popular we can add it to core". However what really happens is that once they get popular but with a somewhat different behavior, then we can't add to Ruby core because it would break apps using that gem if it was implemented in a simpler way, in such a way Ruby core developers would agree with. I just think it's wrong for a library to modify Ruby core classes. I do that in AutoReloader, patching both `require` and `require_relative`, but just because I couldn't figure out another way of implementing it, while keeping autoreloading transparent from a user's point of view. And one can configure the app to only patch those in development mode anyway so that they wouldn't affect production code. &gt; I'm surprised you even got FactoryGirl working with Sequel It's trivial to make FactoryGirl work with any class. You just need to implement the "save!" instance method that should raise when it can't save. Since Sequel doesn't implement save!, we can safely add this method, making it behave as FactoryGirl would expect. It's also useful in other parts of the application since it's easier to call save! when you want it to raise instead of remembering what param should be used. It's also much less to type ;) &gt; If you're referring to this, isn't that opt-in now in Sidekiq 5? I was referring to this: https://github.com/mperham/sidekiq/blob/master/lib/sidekiq/core_ext.rb Thanks for the kind words :)
I'm not sure what you're trying to say. But anyway, ruby 2.0 was released in 2013, many of us have been using ruby much longer than that. But I'm not a huge fan of the OP gem either. 
Maybe it should be an option you can choose, but personally with email clients or other messaging systems I hate it if I accidentally close the thing and get disconnected. Discord is designed so you can be online and available while doing other things.
I started in Python beginning of this year and a month later switched to Ruby. Developers at my company offered to help me and answer questions. Been at it for 2 months now. Enjoying it so far. It wasn't a big deal to switch. Doing Python helped get some basic stuff down and up to where I was it was just a change in syntax and how certain things were done. Just start learning and you can always learn another language. That's how i've looked at it. Once you learn one, it won't be hard to learn another. 
Thanks :)
True again, but its original purpose was (AFAICT) to mitigate Rails.
I've seen that same mistake made elsewhere where this blog was posted. Maybe that says something bigger about the position of the naming of the product.
I had to search ... thanks OP.
You should visit TryRuby.Org and go through the tutorial. You might like it! Good luck.
Could you tell a bit more about the benchmark? Ideally provide both data and code?
I hadn't tried Hanami yet, but I want to offer a counter opinion regarding Sinatra. There are [good routing benchmarks](https://github.com/rack-app/rack-app) on Github (that guy did a great job with testing the core router of each framework)... they put Sinatra a bit on the lower side (still great, but can be so much better). In [these benchmarks](https://github.com/luislavena/bench-micro), Sinatra performed about 4 times slower than Hanami... and used up more than twice the memory per request. IMHO, Sinatra might have started taking on too many features to provide a true Rails alternative. It seems to me that Sinatra and Rails share much in philosophy when it comes to the role of the framework within a web application.
I'll try to focus better on those. Usually I'm too deep in the topic theory that I just miss those, not on purpose but due to fact my brain focus on correct code and verbal definition of the problem :) b.t.w. if you are in a mood to help me with this and add yourself a commit credit on your Github profile, the article is open source. So if you be so kind and create a pull request https://github.com/equivalent/scrapbook2/blob/master/archive/blogs/2017-04-27-expresive-tests-rspec.md once I merge it in it will help improve the quality. Plus this way I will see where I was doing those mistakes so I avoid them better in future. It would be super helpful, thank you ;)
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [equivalent/scrapbook2/.../**2017-04-27-expresive-tests-rspec.md** (master ‚Üí 830828a)](https://github.com/equivalent/scrapbook2/blob/830828a0bacd58298e150c777038139f346f73d5/archive/blogs/2017-04-27-expresive-tests-rspec.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dh2glr7.)^.
I just tried Bootsnap and it saved me something around 300ms in boot time. Also, I noticed that if I don't implement lazy loading and load everything upfront, it will take just about half a second more to load. Loading everything up-front with Bootsnap takes about 1.5s, including Bundler's time.
The data used is from the company I work for, but I could make another one with public data 
I want to argue with this but I'm realizing I still think about Rails and Sinatra in forms from years past when they had less in common. I'll have to scope out Hanami, sometimes it's hard to keep up with what's good when you have a full client load lol.
interesting... yeah we're really only using the router to organize our code. maybe it's time to give hanami the ol college try.
Nowadays, it would be better to use Roda than Sinatra. Roda is a modern replacement for it, like how Hanami is a modern replacement for Rails. 
PG and Redis is all the datastore I've ever needed. And it's such a battle tested setup it's difficult to put jobs on something less tested just out of fear for the potential maintenance headache it can create when something does go wrong
Sure, I can appreciate the simplicity of scheduled polling. Email generally isn't all that time-sensitive anyway, but every once in awhile, I'm gonna want to see an email within seconds after it arrives (_e.g.,_ bank login 2FA code), and if I can automate instantaneous syncing, why not? Besides, faithful mirroring of local and remote stores is the kind of problem where *NIX utilities should have no reason whatsoever to fall short of popular GUI alternatives. I thought the whole purpose of using command line utilities is that they're more versatile?
You should look into [clippy](https://github.com/envygeeks/clippy), which works cross-platform, while this one works only for Mac OS.
You could also just use `pbcopy &lt; file`
That gem literally does that: https://github.com/EvandroLG/copy_to_clipboard/blob/master/bin/copy_to_clipboard#L21 So it doesn't work on linux.
You might wanna read [Put HTTP in its place with Roda](https://www.icelab.com.au/notes/put-http-in-its-place-with-roda) written by one of the `dry-rb` maintainers. This is actually a part of a series post which aims to combine roda, dry-rb, rom-rb (sequel underneath) to create an architectural approach that closely resembles Hexagonal, DCI architectural patterns.
It's indeed a valid approach although I don't feel the need for some of its abstractions yet, but I see where it comes from. Thanks for the pointer :)
Working on a Hanami app right now that I hope will be in production soon. One of the "apps" in my Hanami monolith is a chatbot interface that takes input from users via Facebook Messenger. I've found Hanami's container apps architecture well suited to keeping this contained as another mechanism for interacting with my app. The app uses https://github.com/hyperoslo/facebook-messenger to receive webhook requests and then I manually call Hanami's router with the "payload" of the message (which is a route like /action/1234) to route it to an action. The single class actions in Hanami is also really valuable here as it's not a RESTful design (there's no CRUD, just specific actions you can take to make a state change), and it's really nice to be able to have the behaviour for one interaction from bot -&gt; server contained in one action class. It's also a breeze to test. At the moment I'm using ActiveRecord as an ORM as the support for associations etc. didn't quite look ready in Hanami and I'm ready to take on digging deeper with rom-rb / sequel. Eventually I'll revisit this but for now AR works exactly as you'd expect, so the whole app has a certain Rails familiarity to it. 
Sounds like a job for crankd https://grahamgilbert.com/blog/2013/07/12/using-crankd-to-react-to-network-events/ https://github.com/MacSysadmin/pymacadmin 
wat
What part don't you understand?
you don't 'run' a gem by running 'bundler console'. You need to read more, you have a fundamental misunderstanding.
Sounds like Rails just wasn't a good fit for your particular project and whoever chose it made a bad call.
&gt; To my knowledge, IMAP IDLE doesn't "catch you up" on notifications you missed while the connection was gone. Correct, most clients will check the mailbox for new mail just after refreshing the `IDLE` connection to catch any mail that may have appeared. In other words you end up polling in some form one way or another, `IDLE` just gives you faster mail delivery between polls. 
&gt; REST architecture (most requests will simply respond with JSON in a per case basis); This statement doesn't make sense. What does REST have to do with the content type of the response?
Discourse is an excellent product. The free software aspect and principles behind it I find inspiring. It's cool to read an interview with someone who has so far managed to straddle the commercial/community divide so well. 
Hey, cool. For sure. Seeing as I have no public contributions to the coding community, this could be a start lmao
Dunno what you're trying to do but you can execute .rb files like this: #!/usr/bin/env ruby puts "Hello!" Then run it: ./my_script.rb No console, no bundle nonsense. Is this what you're looking for?
&gt; I actually get it. I value extensions such as blank? for example, and I'd love Ruby to add blank? to core Object implemented as simply as nil? || empty? I understand the usefulness of `blank?` and `present?` when writing web applications, but I don't think they're needed in generic-libraries that aren't necessarily tied to the context of a web framework. I don't remember any part of any library that I wrote that would be more elegant with ActiveSupport extension, and I know ActiveSupport pretty well :) Well, each to their own, I guess, but I think we both agree that it's better to write libraries without using ActiveSupport, since then people can choose not to have ActiveSupport as their dependency, which is safer in general because [ActiveSupport can break things](https://github.com/janko-m/shrine/commit/0a09cf90af94822e890114bc7521da44301bf402).
Ah. Well, I can accept a comparable amount of polling if it means that new messages arrive instantaneously. In any case, I tested it out, and imapnotify definitely doesn't poll for new mail after reinstating a dropped connection. The technical challenges here are big enough for me to save this problem for later, but frankly, I'm surprised no one else seems to care enough to have created a solution by now. Thanks for your insight, though.
I understand how to run it now, thanks that helped but I'm still confused as to how a gem application runs. I've created my gem now and running it with ruby -Ilib works. The problem is I don't want the user to input that, I want it to work like this: gem install &lt;mygem&gt; &lt;mygem&gt; -f foo -b bar I'm trying to make a regular CLI application distributed as a gem. I ran rake install and the gem installed successfully, and when I do which &lt;mygem&gt; I get this: jose@jose-desktop:~/.rbenv/shims (master)$ which hechiza /home/jose/.rbenv/shims/hechiza But after installation running it gives no input at all. If I go to that path, I get this little bash script: #!/usr/bin/env bash set -e [ -n "$RBENV_DEBUG" ] &amp;&amp; set -x program="${0##*/}" if [ "$program" = "ruby" ]; then for arg; do case "$arg" in -e* | -- ) break ;; */* ) if [ -f "$arg" ]; then export RBENV_DIR="${arg%/*}" break fi ;; esac done fi export RBENV_ROOT="/home/jose/.rbenv" exec "/home/jose/.rbenv/libexec/rbenv" exec "$program" "$@" 
lol glad I could help? I get that now, but now I have another problem I guess the gem's binary isn't being built right. I don't suppose you know how that is done? I am having trouble finding a resource on this I can't be the first person to want to distribute a ruby application as a gem (cries)
Rubocop https://github.com/bbatsov/rubocop
One man's horrible embarrassment is another man's epic troll.
You can use Ruby itself for that. $ ruby -w test.rb test.rb:12: warning: assigned but unused variable - greeting test.rb:7: warning: instance variable @name not initialized test.rb:6:in `greet': wrong number of arguments (1 for 0) (ArgumentError) from test.rb:14:in `&lt;main&gt;' For syntax only use the `c` option: $ ruby -wc test.rb test.rb:12: warning: assigned but unused variable - greeting Syntax OK And actually this is what Rubocop uses under the hood.
Rubocop does detect unused local variables, not sure about instance variables though. Detecting valid method calls is something Rubocop is unable to do.
ruby-lint doesn't execute your code, instead it performs semantic analysis. This is much faster (e.g. you don't have to wait 30 seconds for your Rails application to start), but also much more limited due to Ruby's flexible nature.
Author here, as mentioned Rubocop is the closest equivalent. I'm not aware of any other tools that come close to ruby-lint _and_ are actively maintained.
If only `blank?` was implemented I'd be fine already. Usually I commonly have some hashes containing strings or arrays as values, sometimes. Not only in the web requests context. So, sometimes I'd do something like `(hash[key] || '').empty?` when I'd prefer to use `hash[key].blank?`. Or at least if Ruby provided some sort of `non_empty?` method to strings I could use `hash[key]&amp;.non_empty?`... There are tons of feature requests like this in Ruby's issues tracker, so I don't think this is only useful to web apps.
I didn't switch to Sequel because of AR's poor pool implementation but because of its poor API. It wasn't on day one, but it was in the first week :) I already knew Sequel when I created this Rails app and liked it a lot already, but I wanted to try to stick with Rails default stack if possible. I liked Sequel because it was lazily evaluated. But just before I created this Rails app, ActiveRecord introduced lazy evaluation through Arel and I decided to give it a try since I thought that both AR and Sequel would be similar to each other after Arel was introduced in AR. Man, I was wrong and I realized this a few days later and replaced my models with Sequel in the very early stage. By that time I already knew what I needed, since I was porting an existing application to Ruby, and I was already aware of other Ruby frameworks. But still, both Sprockets and Rails automatic code reloading in development mode were very appealing to me to stick with Rails. Rails served me pretty well for several years and it wasn't urgent to move to another framework anyway... I consider replacing Rails with Roda a minor upgrade. When I moved from Grails to the Ruby land it has way more impact in the development pace. Or when I moved from MySql to PostgreSQL. Moving from Rails to Roda will basically save me some time I'd spend when upgrading Rails and having to fight some issues that would force me to dig into Rails source, besides giving me more flexibility to do what I want much more quickly and to more precisely estimate some tasks. But I wouldn't call it a really big deal, as if suddenly everything got much better because I left Rails. Getting out from Grails, replacing MySql with PostgreSQL and ActiveRecord with Sequel were the major upgrades in my opinion in terms of benefits and impact in the development pace.
&gt;"convention" dirs work as a strict structure when one is starting in the webdev world and still doesn't have the whole HTTP / HTML / MVC etc figured out. I understand that in some environments even experts would prefer to stick with Rails conventions. When you're working with a big team or several projects or when you experience a lot of turnover, then sticking to Rails conventions will make it easier for a new developer to catch up with the team as they know where to look for things like controllers, views, models, mailers, workers and so on. &gt; support for front-end frameworks / bundlers, SPA Rails 5.1 is even more SPA friendly. It nows understand that it doesn't make sense to invest much in Sprockets and that Webpack is the way to go. A backend framework shouldn't make any decisions on the front-end technology from my point of view, so I don't think Rails should pick some solution such as React, Angular, Ember, Vue, whatever... But it should be out of your way regardless of which front-end tech you adopt. It would be nice however to add at least one JavaScript test runner by default. Jasmine, Mocha, whatever. It would be supporting a good practice. &gt; Out of curiosity, what's your dev workflow? Do you have watch turned on while a ruby server serves the webpack assets? Or do you put a node server in the end and proxy by uri to the ruby API? I don't feel the need for serving another Node.js app just to serve our static resources. In my webpack config I add the [assets-webpack-plugin](https://github.com/kossnocorp/assets-webpack-plugin). It will take care of generating a JSON file from which I can extract the the actual path from the identification. This JSON file is updated in the webpack watch mode. Then I have a few helpers that will take an id and find the proper path accordingly to this JSON file. Those files are generated directly into public/assets (or public/static, whatever). I wrote a set of 3 articles on webpack early past year in case you'd be curious about it: http://rosenfeld.herokuapp.com/en/articles/2016-02-29-getting-an-spa-to-load-the-fastest-possible-way-and-how-webpack-can-help-you http://rosenfeld.herokuapp.com/en/articles/2016-02-29-scripts-loading-trade-offs-a-performance-analysis http://rosenfeld.herokuapp.com/en/articles/2016-02-26-improving-spa-loading-time-with-webpack-and-why-sprockets-is-in-your-way &gt; Quite the hard problem. I think there are ruby constraints (global namespace, performance of require lookups) which are in the way of making start/stop more performant or reloading safer. This problem won't go away ever, probably. Actually, [AutoReloader](https://github.com/rosenfeld/auto_reloader), the gem I created, works pretty well for my needs. Even better than what I was used to when using ActiveSupport::Dependencies (Rails mechanism). If you're curious about it, I wrote two articles about autoreloading in Ruby: http://rosenfeld.herokuapp.com/en/articles/ruby-rails/2016-07-18-a-review-of-code-reloaders-for-ruby http://rosenfeld.herokuapp.com/en/articles/ruby-rails/2016-07-18-autoreloader-a-transparent-automatic-code-reloader-for-ruby
Out of curiosity, why you decided to drop the support? Lack of time or you didn't find it useful anymore? I've tried digging in it a bit to bring it a bit up to date and I must say, it's not exactly easy :/
Hi! Yep, I've built two open source production applications [https://github.com/ossboard-org/ossboard](https://github.com/ossboard-org/ossboard) [https://github.com/hanami/contributors](https://github.com/hanami/contributors) Also, I'm building small hanami project in my job (private management system with API for working with other services). I can say my apps use less memory than equals (by features) rails apps. You can clone open source hanami projects and check it locally. About pitfalls: I use hanami around 1.5 years, and I can say that the biggest problem of this framework is the ecosystem. We (hanami core) are working on it and now it **much** better than one year ago :) Also, we always happy to see any help with this :D
In practice, no matter how many times I try to explain this to teams, most ruby programmers I encounter view REST as a means of more or less distributing their relational database over HTTP. If I had to point to the one big downside of rails, it's the assumptions and mistakes that are baked into the framework so deep the programmers can't function outside of web MVC / ORM. For instance, consider all these features: form helpers, strong parameters, serializers, nested attributes, and hash with indifferent access. They all reduce the amount of applicative code between your relational database schema and the outside world. I'm not going to stand in judgment of everything rails does to couple the ORM to the GUI. It's not for me, I'll say that. When I bring rails programmers out of web development, though, they really struggle with encapsulation, namespacing, alternative approaches to transactional storage, etc. So tying this back to REST, what you say about it is very true, and I emphatically agree with it. But many rails programmers arrive at a very mistaken notion of what REST is.
Yes, I have a production app with Hanami in my job at http://creditas.com.br Our app is an API serving content to a few SPAs applications built on Ember JS, following its JSON API Spec convention (a.k.a hypermedia). We started it a year and half ago, replacing a legacy Rails application. So far so good. Despite missing "automatic" relationships between Entities, we're doing very good using it. Hanami Validations and Hanami Model are two of most used in our case. Being an high level abstraction for Sequel helps a lot on our reliability over this time. All new developers who didn't work with Hanami previously did not find any issues in learn it. In fact, some of them came to us about knew about our choice. Hope it helps somehow.
Good to know but that was not my point. The main point is that it breaks what I'd expect from regular programming in general. For example, if `action_view` is a requirement for `action_view/helpers/number_helper.rb`, I'd expect to see `require 'action_view'` inside it so that I could just require that file in isolation.
&gt; We search transactions GET /transactions?q=search_options &gt; But we can store searches as well, so in that case Search would be a resource and we would have something like POST and GET /searches GET /transactions/searches/:id. #retrieve data from a stored search POST /transactions/searches # create saved search from data in post body DELETE /transactions/searches/:id. # remove saved search PATCH/PUT /transactions/searches/:id. # update saved search (partial or full, but this is a neckbeard debate) Notably 'searches' looks a exactly like a resource route from rails. I don't get how this is complex or requires thinking about abstractions, it's about as dead simple as it gets. If you don't do this you just end up reinventing the same thing without consistency and often can't leverage HTTP semantics to your benefit. At the end of the day REST is really just about using HTTP as it was intended to be used, any other approach is fighting that and tends to have to re-invent a lot of wheels (caching, etc). 
The requests are served. I'll look for open fds to make sure the connections are closed, but I assume so since the number of requests necessary to fill up the memory until the process gets killed is quite big. And what should I use logging for? The requests are already logged by the library, nothing interesting there. 
I agree very heavy with the first part. I tend to work in systems these days where the queries needed by the GUI are completely separated from the transactional part of the system. In such cases, ORMs are very useful for standing up view databases for painting screens and web pages. This type of scenario is generally called "CQRS" but I try to avoid a lot of the DDD jargon. That said, I have spent a lot of time helping to build a framework for "write heavy" systems (if I understand your use of the term correctly). I use event sourcing as a generalized approach to the storage of transactional state, and the resulting machinery looks a lot like systems built around Kafka -- logs, optimistic locking, high throughput, etc. The best part of a framework for this architectural style is that programmers of all experience levels can learn the ropes and actually make headway. By contrast, lot of systems built by expert "architects" end up being unapproachable for much of the organization.
Where I find the generalization fails is that write heavy applications tend to lump actions into various buckets that have very different needs. Data comes in via some ingestion system, ends up in Kafka, some readers need to do 'near realtime' processing (direct reader from Kafka), some systems need to do 'delayed real time' (often something like batched writes to S3 from kafka with a job queue to process them as they come in) and some systems are bulk post processors which is kinda related to 'delayed real time' except that it's usually something like Spark processing a much larger chunk of data. A lot of applications need all three and each requires very different approaches so it's hard for there to be a 'one framework to rule them all'. 
&gt; When you're working with a big team or several projects or when you experience a lot of turnover... From a management point-of-view, couldn't agree more. Building community around an OS project is hard, and Rails achieved this. &gt; so I don't think Rails should pick some solution such as react ... [It actually does](https://github.com/rails/webpacker/blob/36f13000c3bfa528cc56df23bd827084d8021595/lib/tasks/webpacker.rake#L8-L10). Being Rails, it doesn't surprise me, as being opinionated is a trademark. They could have gone full-webpack (currently only javascripts), but I guess it's just a question of time and proper community experience with webpack. That is, if rollup doesn't surpass it, and then "here we go again" :) &gt; I don't feel the need for serving another Node.js app just to serve our static resources. In dev, it totally makes sense, since you can use the same process to watch for changes /serve assets /proxy to app. But you'll have to write the inital html payload in js-land. I will have a look at your articles though, I'm still stabilizing this stack in my workflow, and having input from other sources always helps. About, the reloading, I understand when you say that your gem works for your needs. But I haven't seen a solution yet that fits most people's needs, due to a lot of factors (no jruby support, weird autoload/require caveats, etc...). Its importance is a by-product of starting processes in ruby being slow in comparison to other interpreted language envs (and let's not talk about jruby :) ). Programming in go and experiencing it's compile/run cycle kind of made me realize that maybe ruby doesn't need better reloading, it just needs to boostrap faster. But that's just my opinion. 
For Searching and a few other cases where we benefit from caching we do implement our own caching strategy, which is more efficient than if we would simply use the QUERY_STRING as the key. I just fail to see how using REST would help me in this case by making it easier for me to build the caching mechanism. Could you please give me an idea on how I could use REST to our benefit? I mean, how exactly it would be easier for me to build the caching for this particular request if REST was adopted? We have a separate caching class to handle searches because the key depends on many things, including user's locale for example. However, most requests would finish in less than 20ms. I don't care about caching the processing of such requests. ETag is enough in those cases. For the few cases (basically only Search and Transaction View) the response would take more time to generate, like 100-500ms, then we take advantage of custom caching strategies to speed them up when possible. &gt; you're only saving a bit of external IO and still doing all the work so this likely have a minimal impact on your app's performance. From my experience this will vary a lot among applications. We have custom tools that report us a lot of details about the performance (both back-end and front-end). What we have noticed for our application is that slow responses are almost always caused by slow client connections, which affect about 10% of our users. In those cases, what really improved the performance was optimizing exactly this IO you think would have minimal impact. We have the server-side under control, so we know requests wouldn't take more than a second in the worst case (unless when generating big XLS reports or a big document to print). However, depending on the client's connection, it might take 10s to finish some request because of latency and bandwidth issues... To give you a more concrete idea, I just got some number from the past week in production. To load the initial page, which is one that takes most of the time to be in such a state the user can interact with, we spend about 50ms in the server-side at most. However, 50% of the users load it in 1.8s or less. 96% in 4.9s or less. All of them have finished loaded until 5.5s. The worst case was using IE11 from New York and for some reason 3s were spent on JavaScript and 0.5s with a redirect (which is basically instantaneous in the back-end, so it's basically the user latency here). On the other side, the fastest request finished loading in 256ms (same script included). As you can notice, most of our performance issues happens in the front-end, not in the back-end. So that's why we focus most of our performance improvement efforts in the front-end, not in the back-end. It doesn't make sense for us to focus on fixing problems that do not exist yet, that's why we focus on the problems we're aware of, which currently means JS. Since our clients are very specialized (mostly a subset of lawyers), they are very unlikely to experience a big growth in such a way we would have scalability issues from one day to the another. As the clients number grows, if it grows, then we'll measure this impact and act upon it, but I won't fix the problem before it happens.
What you're describing sounds like lambda architecture. I can see how in such an environment there isn't a lot of room for generalization. I tend to have a mechanical perspective of the transactional system as being based on streams -- we typically send command messages to services via queues, and a stream will work fine as a queue. I store events on event streams, and by exposing those streams to other services I get pub/sub (without any need for a message broker). It's often next to impossible for systems built on relational databases to switch from e.g. mysql to postgres. That's because there's inevitably inconsistencies in the underlying query language (including how they access storage engine specific features). For streams, though, I find that such a substitution is pretty straightforward. The way I look at frameworks for transaction processing services (i.e. write heavy) is that you start with a "kit" that scales pretty well, but you can eventually replace parts with specialized components later on when it's necessary -- and without much (if any) changes to applicative code. If you're already at "twitter scale" you might _begin_ with needs so specialized that you might have to consider each part differently, but that's an unusual case. Most of the time, teams can start with streams as a universal storage and message transportation primitive. In those cases, the underlying abstractions for reading/writing messages offer a much higher degree of machine affinity and generalization than ORMs. Of course, we're way off topic now, but this stuff is always fun for me to talk about :-)
You have a very tight `while` loop there. GC might not even have a chance to run. Try adding a `GC.start` in the body of the loop. It's going to be way slower, but you can at least see if that eliminates the "leaking".
Exactly my experience. It seems that one always ends up re-implementing basic things that you get for free in Rails. I really hope for Hanami to strive, but to be honest, for the regular startup it's just too much work.
&gt; But you'll have to write the inital html payload in js-land. I don't understand why you think so. We generate zero HTML in our webpack config. We only extract the final paths from the generated JSON in order to link to them in the views generated by the Ruby web app. Regarding the AutoReload gem, I'm curious on what kind of scenario it wouldn't be a good fit. I'd love to hear if you have any examples. It should even work with JRuby. When I load my full application eagerly it takes only about 1.4s to load everything upfront (well, not everything since some gems we require use autoload). It's not a small application. And quite some time is spent by fetching some metadata from the database when Sequel is creating the model classes. So, while I think Ruby could certainly improve the time needed to evaluate code, maybe by caching the bytecodes it generates when parsing a Ruby file, it's not as slow as you might think. And if we lazily evaluate Ruby code as needed, then we can boot our Ruby web app instantaneously, like it does for our app. But even if we can reboot it instantaneously, you wouldn't want to restart it everytime you change some code. Sometimes you might decide your app would benefit from some in-process/memory caching in some cases and you wouldn't be able to test this well if your app restarts everytime your code changes...
&gt; For Searching and a few other cases where we benefit from caching we do implement our own caching strategy, which is more efficient than if we would simply use the QUERY_STRING as the key. I just fail to see how using REST would help me in this case by making it easier for me to build the caching mechanism. I don't really understand the question, are you asking about HTTP caching or some other caching? If you're data is valid for 5 minutes then with a GET request you just set the `Cache-Control` header appropriately and the client just doesn't send the request so there is no 'key' other than the URL. &gt; However, most requests would finish in less than 20ms. I don't care about caching the processing of such requests. I guess I don't understand the application. If you have thousands of fields and such dynamic queries that you have all the issues mentioned how are you servicing them in 20ms given the DB query + ruby app server time, etc? &gt; From my experience this will vary a lot among applications. We have custom tools that report us a lot of details about the performance (both back-end and front-end). What we have noticed for our application is that slow responses are almost always caused by slow client connections, which affect about 10% of our users. In those cases, what really improved the performance was optimizing exactly this IO you think would have minimal impact. If you used stable REST style urls using GET and HTTP caching the request would have never even been made (vs etag based approach). Nothing is faster than doing nothing. &gt; It doesn't make sense for us to focus on fixing problems that do not exist yet, that's why we focus on the problems we're aware of, which currently means JS. Makes perfect sense. So I have to ask, since your backend appears to be trivially small and simple, why are you harping on Grails vs Rails vs Roda vs whatever? I mean, you seem to have a tiny scale use case so why does any of this matter? i.e. If your load times are that out of whack why on earth did you re-write the backend for the second time instead of fixing the frontend? 
Mostly due to a lack of interest. I wrote most of ruby-lint before I knew about how to build a proper compiler/analysis tool, so the code can be quite confusing to understand.
I said whole component, not whole framework. I was referring to the ActionView component not to Rails. I said that I can't just require `action_view/helpers/number_helper.rb`, but I'm forced to manually require `action_view` before, which will also load the support for the full ActionView component. I guess I'm unable to properly communicate my intention to you... I hope that makes it clear but let me know otherwise and I'll try to put it in another way...
I don't think this will help, unless I have a vast misunderstanding of ruby GC. It will just run when it needs to, you don't need to manually call it.
How much RAM was the process using? Did you manually kill the process or was it killed by linux OOM killer or what? I'm not a ruby GC expert but I believe if you haven't hit the malloc limit and/or run out of free slots, your process will just keep using more memory (i.e. it won't GC until it needs to), and because your script isn't doing much it will take a while for either of those to occur. Try running the code again with something like `RUBY_GC_MALLOC_LIMIT=65536 ruby myscript.rb` and see if it keeps growing much past 64k of RAM.