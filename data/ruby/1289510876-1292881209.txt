Heck ya, ordered my copy. Looking forward to it.
I've read both the "Pickaxe" book and "[The Ruby Programming Language](http://amzn.com/0596516177)" (co-authored by **Matz** and **_why**), and I have to say TRPL is much better. It's a no-BS book about every single Ruby detail. Covers all the quirks and features I didn't even know existed. I definitely owe my knowledge of Ruby directly to it, but my introduction to the Pickaxe (only (free) book at the time). Pickaxe may be good to start with, but you can learn the same from TRPL and TRPL provides a much better reference later on.
Not that I think that $10 is too much.. but it makes my eye twitch when I see the ebook and the physical book are the same price.
I read the original (1.6) version of the pickaxe and felt pretty good about it. I already have the 1.9 version of "The Ruby Programming Language." Any reason to own both?
No probs!
Cheaper from Amazon in UK with pragmatic delivery charges. £21.60 still pretty good value.
"It is written for experienced programmers who are new to Ruby, and for current Ruby programmers who want to challenge their understanding and increase their mastery of the language." - From the Amazon page you linked. That makes it hard for me to recommend blindly, as I'm no experienced programmer, and have only begun to scratch the surface of Ruby. It'll be a fantastic help later, once I've gotten some Ruby under my belt, but right now, I don't know that it'll be as wonderful an introduction as I need. Also, friggun 10 dollars, man. Fuckin' a.
That's just for this special. Once it ends, everything will go back to the way it was, with $45 for the softcover, and $25 for the pdf. *sigh*
Truth. It *is* written for experienced programmers. That's part of the reason I felt the Pickaxe book was rather patronizing and sub-par.
Me too.
Probably not.
Ok, sorry?
&gt;&gt; (Kindle owners—there’s a lot of code in this book, and the Kindle and code listings aren’t great friends.) This precisely explains why my "ebook reader" is an iPad + GoodReader, and not a Kindle. It holds my entire bookshelf of expensive tech books in a little tablet that fits in my messenger bag.
Oh no! I wasn't trying to insult you or anything! I was "sigh"ing because of the ridiculous prices of these books. Especially the electronic versions. You're cool. Sorry sorry sorry.
Bah, I clicked "Buy Using Paypal" and it redirected me to the pragmatic login screen. Anyone familiar with paypal? The payment status is "Pending", should I try and re-buy it? Edit: Ah nvm, looks like I needed to sign up for the website. I'm dumb.
I suppose the question is, why are you learning Perl?
It's the language used at my job. I use Ruby for all my own stuff.
I learned perl well before ruby, and as much as I prefer ruby, there are situations at work where something was written in perl years ago, and it's less work to maintain than it is to rewrite it. 
The most infuriating thing to me so far (obviously, simplified): use Data::Dumper; my %a = (1, 2, 3, 4); while (my ($k, $v) = each(%a)) { print Dumper(\%a); } being an infinite loop. Took me ages to find the bug.
Ah, @netzdamon as well, that makes sense. Remind me to find a company built in the past 5 years when I go job hunting next!
AUTOLOAD is evil. And besides, **nobody** who programs Perl would used hacked OO like that these days - you'd use Moose. package SomeClass; use Moose; has 'color' =&gt; (is =&gt; 'rw'); has 'age' =&gt; (is =&gt; 'rw'); has 'weight' =&gt; (is =&gt; 'rw'); has 'height' =&gt; (is =&gt; 'rw'); 1; Not much different to the Ruby. But then, I don't want to ruin your stereotype that Perl is a mess, so maybe I should just shut up now ;-) 
Other things that you will grow to hate about Perl: * Having to explicitly check for errors on every function, except when you shouldn't. Good luck figuring out when that is. * Along those same lines, lack of structured exceptions. You get to parse error strings out of a special variable using regular expressions. Have fun. * Stuff like "eq" vs "==" and loads of other quirks. * Byzantine scoping rules. * Having to remember what a function returns for list vs scalar context. This alone is a source of endless bugs. * Getting yelled at by the community every time you forget to use strict/warnings/whatever-the-pragma-of-the-year-is. Followed by a lecture on why they aren't the default behavior. * Lack of anything resembling the simplicity of begin/ensure/else. * Watching your code blow up because you forgot to put a "1;" at the end of your module. * Ugly syntax, especially hash dereferencing syntax. * Using hashes for *everything*. * Writing C extensions with XS. WTF. * A crap ton of operators. You'll just have to figure out which ones matter. * As you've experienced, crappy, bolted on OO. At least there's Moose now. * No threads by default. Get used to fork. There's more, but I'm tired of writing. You'll figure it out. &gt;:)
Aw - give Perl a break. Keep in mind, Matz had Perl (and other languages of course) in mind when he designed Ruby - of course he's going to borrow the good parts and leave the bad parts behind. From "An Interview with the Creator of Ruby", http://linuxdevcenter.com/pub/a/linux/2001/11/29/ruby.html Stewart: I gather you had worked with both Perl and Python before creating Ruby. What bits of Perl did you incorporate in Ruby? Matz: A lot. Ruby's class library is an object-oriented reorganization of Perl functionality--plus some Smalltalk and Lisp stuff. I used too much I guess. I shouldn't have inherited $_, $&amp;, and the other, ugly style variables. --- Instead - marvel at the fact that perl does OO pretty much at all! It's really something grafted onto the language as an afterthought; the fact that it can be used so successfully and widely (and that the ugliness above can be hidden so well in modules) is a testament to Perl's flexibility. Can newer languages do it cleaner? of course - it would be sad if they didn't. But making fun of perl because of unweildy object programming is like making fun of COBOL because it's "wordy" - well, duh. If you really want to do OO in perl (and you don't mind module hell) - try Moose. 
Moose isn't Perl just like jQuery isn't JavaScript, though. Unless I'm mistaken and Moose is an official part of Perl, and not a third-party library? If the latter, it's fair to criticise Perl's OO hacking way of doing accessors. 
Am I getting old or something? Who doesn't know Perl? 
Moose is pretty much an unofficial standard for anything larger than a maintenance or one-off script.
If Im not mistaken somewhere in there you had to use $a instead of %a didn't you... I haven't coded in perl in a long time, but if I recall sometimes you have to refer to the hash as %a and other times as $a... I honestly think that's dumb as hell. 
It's not dumb if you understand context.
Yes. Ruby programmers owe thanks to Perl. Just as Java was designed with eyes firmly planted on C and C++, Ruby was very strongly informed by Perl and Smalltalk. I think Ruby was far more successful in improving on its influence, but that's a different topic. :)
I agree with this – I realize the historical context of the two languages needs to be taken into account. Like I said, learning Perl now only makes me appreciate Ruby and how it's moved things forward.
While the JS/jQuery comparison isn't an unreasonable one, I don't think it's fair to dismiss Moose entirely on the basis that it's not part of the core distribution, just so you can point and laugh at an ugly idiom that few Perl programmers would even consider using.
You're not alone. I had the same thought. 
That's not the version for 1.9.2 though.
Nope - that's just confusing at first. The real issue is the iterator. In Perl, each hash has one iterator. This one is used for both each() and foreach, it is internal to the hash, and it is implicit: you can't get to it. Which also means, you can use only one of these constructs at a time. Now, Dumper() function uses the %a iterator, somewhere. This means that the %a iterator from each() gets silently overwritten in each pass of the loop. Thus, the "safe" way to write this is to extract the keys array, and then iterate over that (as that is a separate object, and thus has its own iterator): use Data::Dumper; my %a = (1, 2, 3, 4); foreach my $k (keys %a) { my $v = $a{$k}; print Dumper(\%a); }
Using that standard, any feature not built in to the language will always be considered a hack, because it requires code to implement it. You'll probably consider Ruby uglier than VB because it takes so many line to implement COM dispatch VB has as a built-in, regardless of how the final Ruby code will looks as nice, as VB's version.
Epic I purchased. Thanks so much!!!!!!!!
Been meaning to learn some Ruby. This is an excellent opportunity. Ordered. **Edit:** This should be xposted to /r/programming.
Any programmer who thinks $45 is too much for a book like this isn't earning enough money.
You guys keep us posted, because I'm sure hundreds of thousands of reddit readers are interested.
Learning Perl will make you appreciate any other language more.
The perl code and the ruby code are **NOT** doing the same thing. You could write an Attr.pm module to do the exact same thing that attr is doing and call it via: use Attr qw(color age weight height); Nobody writes an Attr module, though, because Moose already handles that.
Will do. 
Perl is much more C-ish in this regard. You've got all the tools you need to implement fun features already in the core, but you could just use a well tested library instead. Let me cite from "Modern Perl": &gt; Perl 5’s default object system is minimal. It’s very flexible—you can build almost any other object system you want on top of it—but it provides little assistance for the most common tasks. I think the problem is that perl doesn't change fast enough. Moose (or something) should have been official a long time ago. No other programming language brings together administrators and developers like perl does. However that is not always an advantage. Come to think of it, it's very much like the ruby and the rails community...
I KNOW, RIGHT?! I learned Perl back in college and didn't think anything of it. Fast forward a few years, I'm regularly using Ruby and writing Rails apps and whatnot. Then I get a client that primarily uses Perl which makes me refresh myself on the language. And my god! Luckily for me, the Perl devs on my client are writing some really nicely structured, fantastic code. But I could believe some of the unreadable bullshit I was seeing in manuals and online. 
It's not about pointing and laughing, it's about seeing how Ruby improved things.
This is the same argument being discussed in the other thread. In Perl you need a library to pretty this up. In Ruby it's part of the language.
This is the same argument being discussed in the other thread. In Perl you need a library to pretty this up. In Ruby it's part of the language.
It's still a gross distortion to compare the two snippets to one another. The module/function you'd write to implement this in Perl would NOT be using AUTOLOAD, and you'd only have to write it once. Actual usage in a module would still be nearly identical.
I just bought it! :) Paperback version is coming to Colima, Mexico! see you all.
So all you have to do is remember that something with the hyperintuitive name "Moose" exists and install it from CPAN, and then all that crazy syntax just goes away! Awesome, Perl community, thanks for the great work. As a bonus, as I remember it, Moose has existed since Perl 5.8, and Perl's now at 5.12 nearly a decade later and it's *still* not bundled with Perl itself (and loaded automatically instead of having to start off every Perl script with "require Moose;"). Thanks, Larry, you're doing a hell of a job. Which means that every nontrivial Perl script has to start out with the following boilerplate: #!/usr/bin/env perl -w use strict; use Moose; just to get Perl up to the basic level of functionality that you get for free with Ruby. That's not crufty at all.
How the fuck is "Moose" something that a reasonable person would be expected to search for in order to gain a "class" keyword?
Actually the Pickaxe has a nice listing of the Ruby-Core and Standard Library with examples for both. Some of it may be in rdoc, but some people prefer a desk reference book, which Pickaxe works well as. Also, there is a chapter on the writing extensions in C that The Ruby Language doesn't discuss much at all. I have both as they really serve different purposes. 
What's wrong about that? Ruby doesn't have packages so it is the equivalent of actionview.helpers.prototypehelper.javascriptgenerator.GeneratorMethods. Ugly, but not a joke ;-)
I don't think that makes it sub-par, it's not titled *Introduction to Ruby*, and experienced programmers need resources too. As programmer, it's damn annoying to pick up any given programming book and see it is wasted on introductory stuff. Picking a book at random from my collection: *Python for Unix and System Administration.* It's a pretty narrow topic for a programming book and it's 3 chapters and roughly 100 pages before anything useful is written about Python or Unix (or rather, about 20% of the book). You don't pick up a book like that unless you're fairly familiar with the words in the title, I don't need a 3 page explanation of Python's str class unless you're doing something novel with it. (and I'm not singling out this book in particular, the market is plagued with this problem)
Are some of these meant as Ruby criticisms? I read "Using hashes for everything" and "A crap ton of operators", and I wasn't sure if you were trolling.
The joke is that the page has unescaped HTML tags in the form of &lt;script&gt; tags.
Nice try Perl dude.
Nobody mentioned this: `sudo apt-get install rubybook`
I've never touched Perl in my life. Here's some string operators for you: "% * + &lt;&lt; &lt;=&gt; == =~ [] []= ". There's tons more for nearly every other class. And everybody's nuts about hashes in Ruby; because they're so powerful, it's common to find entire classes that are really just hashes of hashes of hashes. I could care less about the downvote, but I don't understand why it was administered.
Thanks, the section on writing C extensions definitely seems worth the $10.
So… What your saying is the joke is that the page is borked and you can't read the api docs, and not that you think the module inheritance name-spacing is a fluster cluck? 
And then Moose improved on that. Evolution at work, hurrah!
Crapload of operators (admittedly, Perl 6, but still relevant): http://www.ozonehouse.com/mark/periodic/ For instance, more than once I wrote $a == "foo", instead of the correct $a eq "foo" (== only does numeric comparison, and parses any strings, making "foo" zero). Also, a bunch of operators can have two different meanings, depending whether they are in a list context or a scalar context. For instance, "@array_var = 0...3" assigns (0, 1, 2, 3) to the variable (a range between zero and three). "$scalar_var = 0...3" assigns 1 (!). Sure, real OO languages have overloaded operators, but... it's just not the same. (Also, here's an upvote to cancel that downvote, you were genuinely asking and didn't deserve it.)
hahaha or err there's no 'or'
Thanks for posting this. I haven't looked at appsumo in a while and was about to purchase service with a few of these companies. 
I've looked at the appsumo deal, but honestly most of those services are free, the only bonus is there giving you some credit and getting you right into billing, this is a great deal if your about to put a production application online, not your development app, don't waste your cash. Most shit is free.
I don't know about you, but I tend not to put development apps online.
TL;DR; Basic Auth
It's still different though. We're talking about the core object system of a language, what I would have thought part of the essential bones of an OO(-like) language, not out-of-the-box COM dispatch abilities. Another way of putting it is writing your own, say, sorting algorithm because a language doesn't have it in its standard library, is different from writing your own object system.
Thanks, that was a good perspective. So the Perl approach is for core-type libraries to be sometimes handled by CPAN? Is this philosophic preference, or has it just happened this way?
No inheritance going on here.
Not sure what else it would be. Rails is a lot of code, if you haven't noticed. Where else do you put the generate methods for prototype's JavaScript code generators while ensuring easy modularity and keeping only related code in a well-scoped code module?
I was actually looking for something fairly similar this afternoon. Unfortunately, there doesn't seem to be much in the way of an example of this. Does anyone have one?
It's used like irb. What kind of example are you looking for?
Just a "aaaaand here's a script using it". I was struggling a little bit to get irb to work the way I wanted it to also.
Huh? The readme has an example: require 'ripl' # Your custom setup Ripl.start If you're looking to customize the shell, the readme and man page have examples.
&gt; We're talking about the core object system of a language, what I would have thought part of the essential bones of an OO(-like) language, not out-of-the-box COM dispatch abilities. But first you have to decide whether being OO is essential, just like you quickly dismiss my example as different because you have decided that having COM-dispatch ability is not essential. Which is probably true for you, but certainly not true to a lot of people, and may be not to you in your next project either. You can get by scripting Perl without using OO, and OO is probably not appropriate. But when you need it, it's as simple as including Moose. &gt; Another way of putting it is writing your own, say, sorting algorithm because a language doesn't have it in its standard library, is different from writing your own object system. People *will* complain about having to write their own sort and say that it is a hack if the language gets in their way of writing such function and in the end they still have to invoke it as @result! &lt;&lt; user.#sort!([cloned_array!%!@#]) Being a hack or ugly language is not about whether a language already has exact match with what you consider essential for your programming domain. It's about whether the language make it hard for you to implement the concept, how simple it is to use the created concept and whether or not using it feel like fighting the grain of the language to use the concept, e.g. how often the abstraction leak and whether it play nice with the existing standard library.
I'd say it was intended. Can't find a citation, but in one of the perl books Larry Wall compares the language to actual pearls and how other people brought him their pearls and the language evolved. CPAN certainly was one of Perls most important innovations. However, looking at the pearl we all know as "Perl 5", I think some of its layers are old and flawed. 
That's nice, I can appreciate that. Thanks for the insight.
&gt; But first you have to decide whether being OO is essential No, first you have to decide whether a language touts itself as having OO abilities (or has COM-dispatch abilities) out-of-the-box, and then you can judge the language's implementation. Not whether you believe a certain missing feature is essential, or non-essential, but the language never claimed to care about it in the first place. I.e., criticism of Perl's OO-system: Fair. Hypothetical criticism of a language's lack of COM dispatch: Unfair (unless COM tasks are something the designers have decided the language is useful for). What would be fair would be criticism of a half-implemented COM dispatch library, which was incomplete and required user hacks or third party libraries to smooth over. I definitely agree with your list of what makes something a hack language (but were we talking about that?). I'd add to that a language that lacks a degree of conformity, for example bash doesn't fit any of your listed criteria but I think it's in a sense the epitome of a hack language, because it has a sense of being a cobbled-together set of mostly unrelated tools.
This is not practical or encouraged, but it is an interesting abuse of rack :)
Gem spec files are *so* trivial to create by hand. I mean seriously, a task to bump the version number? Apparently editing with vi and changing the version number is *just too difficult*. On top of that, Jeweler seems to have cargo culted a bunch of nonsense regarding specification_version that it should not care about. Not for me.
I can think of all kinds of silly ways to use this.
It does a little too much for my taste as well, and I'm not a fan of the generator style in general. That said, I was excited to see this release because it will finally fix this annoyance I see in projects that rely on jeweler: &gt;/home/phiggins/.rvm/gems/ruby-1.9.2-p0/gems/jeweler-1.4.0/lib/jeweler/commands/check_dependencies.rb:13:Warning: Gem::Dependency#version_requirements is deprecated and will be removed on or after August 2010. Use #requirement 
Actually all that `specification_version` cruft is generated by [Gem::Specification#to_ruby](http://rubygems.rubyforge.org/rubygems-update/Gem/Specification.html#method-i-to_ruby). It's even re-added to your installed gem specifications, just look in the `specifications/` directory on your system. For those who don't even want to bother with gemspecs at all, there is [Ore](http://github.com/ruby-ore/ore#readme) or Hoe.
Another incarnation of [Open KeyVal](http://openkeyval.org/)? That would be trivial. Bonus points for showing those pesky PHP guys that again such thing can be done in few lines of Ruby ;-)
What gems have you released?
I agree that jeweler doesn't make much sense and cargo culted a lot of crap. Eg, the Version module is absolutely retarded imhfo. That said, once you have more than one gem, having something to help manage your multi-project-wide tasks (like hoe does) is an absolute necessity. Jeweler misses the boat in a lot of ways, but the most important of them is that the author really doesn't understand (or value) code reuse.
Wow! I just tried assigning a list to a scalar, and it really does return 1, what the heck? 
Isn't Heroku expensive? Is one dyno capable of running one concurrent process? If so, then IMHO it seems to be expensive.
I enjoyed the [rails tutorial](http://railstutorial.org) so much I bought the package even though the free html version is more than enough.
 curl "http://localhost:9292/eval/File.read(File.join('','etc','passwd'))"
You can be an ENGINE YARD PROGRAMMER for fuck's sake!
This won't fix it for windows will it? The errors/warnings i got when installing on windows were much more than a simple Ruby C API error, if i remember correctly :( By windows -- i mean the Rubys installed via the RubyInstaller :)
I updated the post so that you know where the links are taking you.
widen that page, son.
Can anyone point me towards how to "web-ify" a commandline ruby app, auto-updating the screen-output of the "commandline" app? I have a few scripts that prepare our CD-updates; they are called via commandline and I'd like to make them available via browser. Thanks!
Much more complicated than this. I also want to know.
Try [bcat](https://github.com/rtomayko/bcat) to pipe commandline output to the browser. If you're looking to execute commands from your browser, try [nirvana](http://github.com/cldwalker/nirvana).
bcat seems just nice, but TODAY IS NOT MY DAY... cts@1heix:~$ bcat/bin/bcat bcat/bin/bcat:56:in `require': no such file to load -- bcat (LoadError) from bcat/bin/bcat:56 cts@1heix:~$ sudo gem install bcat Successfully installed bcat-0.5.2 1 gem installed Installing ri documentation for bcat-0.5.2... Installing RDoc documentation for bcat-0.5.2... cts@1heix:~$ bcat/bin/bcat bcat/bin/bcat:56:in `require': no such file to load -- bcat (LoadError) from bcat/bin/bcat:56 cts@1heix:~$ err???
If I'm not mistaken by my bad luck today, both commands only work if you want to execute scripts locally. I have them sitting on a server and want to access them remotely (well, semi-remotely as we'll keep this within the LAN)... Any further ideas, anyone?
It's not a list. In a list context "..." is the range operator; however, it is a completely different operator (so-called "flip-flop") if it is evaluated in the scalar context. Thus, the type inferred for the result (in this case, the type of the variable being assigned to) determines the semantics of "..." (and many other Perl operators and functions).
 $ ruby -Ibcat/lib bcat/bin/bcat OR: $ gem install bcat $ bcat
Seconded. This website is probably the best rails tutorial I have used.
Common Mike. You need to give the direct link, not a bit.ly link. ;-)
Arel is an excellent improvement to Rails-- my favorite new feature. If you're the kind of person who likes to learn from other coders, you may like the interesting writeups about how Rails 3 uses Arel and why the author wanted it. Here's a good first article: http://metautonomo.us/2010/03/28/advanced-activerecord-3-queries-with-arel/
Just run `bcat` from your path. The bcat binary from the checkout won't be wrapped by rubygems, so the rubygems won't be loaded.
If you haven't seen it, take a look at [tenderlove's writeup](http://engineering.attinteractive.com/2010/10/arel-two-point-ohhhhh-yaaaaaa/) of how he refactored Arel on the way to 2.0.
Notice the word "refactor" is nowhere in tenderlove's writeup. All the superficial changes he made added up to little. In the end, Arel was a rewrite from the ground up.
Good point. I certainly wasn't implying that Aaron had just tweaked a few things. His work is commendable and I wanted to point that out!
Well... he did. for quite a while... but in the end no amount of superficial bandaids will fix a fundamental problem like a bad algorithm/design/gaping wound. A rewrite was truly necessary to get the performance we wanted to get out of it. We avoid "The Big Rewrite™" like the plague, but objectively, there are times where it is completely necessary.
I have updated the post to have the base url for all the resources. My apologizes to the creators of those resources. My intentions were never to take away from your PageRanks. Also, I will be adding resources recommended by people in the comments on the post, HN, and Reddit shortly. So if you have any you want added let me know soon.
Updated the post to include suggestions by commenters on the blog, HN, and twitter.
I've always found this method to be somewhat problematic at times. Specifying a constant using a namespace (with "::") and lexically nesting the namespaces IS NOT the same thing. Check this out: class TopLevel module Constants HelloWorld = "Hello, World!" def self.hello_world puts HelloWorld end end end TopLevel::Constants.class_eval do def self.new_hello_world puts HelloWorld end end TopLevel::Constants.hello_world # =&gt; "Hello, World!" TopLevel::Constants.new_hello_world # =&gt; const_resolution.rb:9:in `hello_world': uninitialized constant HelloWorld (NameError) 
 phiggins@gibson:/tmp$ ruby -v ruby 1.9.2p0 (2010-08-18 revision 29036) [x86_64-linux] phiggins@gibson:/tmp$ ruby const_resolution.rb Hello, World! Hello, World! However... phiggins@gibson:/tmp$ ruby -v ruby 1.8.7 (2010-08-16 patchlevel 302) [x86_64-linux] phiggins@gibson:/tmp$ ruby const_resolution.rb Hello, World! const_resolution.rb:12:in `new_hello_world': uninitialized constant HelloWorld (NameError) from const_resolution.rb:17 
Engine Yard? Really? Aw Shucks mister. That sounds just swell. 
That is sick and wrong. And awesome.
No biggie, ::TopLevel::Constants::HelloWorld
Having a variety of equality tests is something Ruby picked up from the Lisp world. 
Nice article, I think I first encountered the extra levels of equality when working wish hashes a while back, which use .eql? along with .hash to determine whether keys are equal. In the end they all have their place and use, although I admit the naming can be is a bit confusing. === feels like it's the sort of symbol that'd be used for extra-strict equality, but in fact it's the loosest of all.
=== isn't loose, it has completely different semantics. It isn't really equality but can mean anything from "is a member of" to "is included in" to "is an instance of" and even to simply "call this proc" 
Yeah, actually I'd originally said in my comment that it's not really equality but removed that parenthetical before posting. The thing is it sometimes is a sort of equality (depending on the object), and it's sometimes something else. There's pretty much no definition for it as far as I know except "how you'd like it to match in a case statement". I don't really know what I'd call it, but whatever it is it's not what you'd imagine when seeing ===. Perhaps "matching" is a better word than equality.
warning - i upgraded from 3.0.1 to 3.0.3 and it broke Paperclip.
Fun fact: you can have a Set of duplicate IPAddr objects because the implementer didn't get his many equality operations right.
* all arrays are flat (and the dereferencing hoops you have to jump through to deal with that) * the implicit and confusing way that arrays devolve into to scalar array lengths in some contexts * the fact that half of cpan is unmaintained and buggy and you can't tell which half but yeah, perl invented the concept of dynamic "scripting" languages, so props are required. without perl we would not have ruby and python.
Hands down the best tutorial I've seen: http://railstutorial.org/ He explains things in such detail that you just get it. The hardest part was setting everything up.
Write gemspecs by hand, [as described by Yehuda Katz](http://yehudakatz.com/2010/04/02/using-gemspecs-as-intended/)
Why does the output format of the XML matter to you? The semantic structure of the document is not affected by whitespace-only text nodes (newlines), presence/absence of entities, use of single or double quotes around attributes, etc. The fact that you care about the output format is probably a smell of some sort. Are you trying to assert on the document structure? If so, you should try lorax (http://github.com/flavorjones/lorax) which provides methods to test for semantic equivalence of two Nokogiri documents. 
Nice! I didn't know about Ore. I'll go look at it. Thanks!
Great idea, can't wait to use this. Are there any other "interactive" tutorial sites about Ruby or Rails? They don't have to be about zombies.
I've spent all night going through it and enjoyed it. It did explain a lot too me and feel a little more confident trying to build my own site. 
It doesn't really matter, I'm just being a perfectionist. :p
I enjoyed the Polite Programmer talk. Great times were had!
Am I the only who dislikes the new API? I very much preferred the old interface.
yep, on lesson 4. Really awesome. 
Agreed! As a novice/intermediate level Rubyist, they brought up some topics I never really considered when coding, that I do think about now. Rubyconf in general was awesome! (except the hotel wifi issue)
Wifi is a regular problem at hotels &amp; conferences in general. Tethering off your iPhone or Android seems to be the workaround these days.
My new years resolution this year was to learn Vim. It's one of the best things I've done to advance my programming in a long time. I highly recommend anyone to sit down and force yourself through the learning curve, you'll be very happy you did in the end. 
Very nice. Do you have any tips to share that you've learned this year? Things you learned most useful?
Ironically, that's what was causing all the problems. Everyone had brought their own mi-fi hostpots, which took down the network that was supposed to be for everyone.
 Rack::Handler::Mongrel.run Rack::Handler::Mongrel.webapp :Port =&gt; 9292 a webapp webapp
The picture Reddit chose for the post is def not Yehuda.
You say the reason you stopped using Emacs because you didn't feeling like you were gaining anything over Textmate, and go on to list "Split Windows" as a reason for switching to Vim(??). This I don't understand as one of the greatest features of Emacs is splitting the buffers and running a REPL is one, and the app your coding in another. Support for this interactive, Lisp-style of programming, in any language that offers a REPL, is the main reason to use Emacs over any other editor. While VIM is incredible for editing features, it doesn't seem to have the built-in support for running REPLs, although I know there are some packages available that seem to mimic this functionality (Notice that I said "built-in". I know there are projects like slimv). But ultimately, choice of editor is personal, and is dependent on many factors, with no editor being *the* best choice for every language. IHHO, Textmate, with tabs, snippets, good regex search/replace, find command, is still works incredibly well for Rails or any multi-file project (html, css, js, haml). That said, I've seen coders absolutely fly on Vim coding Rails/Ruby. 
Thanks, Tom!
When I see *ruby* and *ghetto* in the same sentence, it reminds me of Zed Shaw…
First thing I did on that page was Command+F &gt; Zed.
Mike Perham doesn't use these libraries, so let's remove them? Remove WEBrick? Seriously?
&gt; my suggested list for removal **(where removal means move to a rubygem)** I don't know any good alternative to Webrick, but he has a point. A lot of stuff in the stdlib is seldom used because there are gems out that do a better job. Why not replace the stdlib-stuff with the (better) gems. 
He has a very good point. A lot of it is old and poorly documented (hence the bounty out to document it), and most isn't used. I, personally, think that the libraries should be updated. Maybe take the gems and put them into core? Just a thought.
I think that's reasonable, when the better gems are then put in the stdlib, kind of like FasterCSV replaced the CSV library. But I don't think pruning the stdlib makes sense without a REAL idea of how many people depend on those libraries. If the argument is that they are poorly written, then the solution is to rewrite them or replace them, not rip them out.
Net::HTTP is indeed terrible. I had serious problems POSTing to a URL because the library would strip of the ?query parameters from the URL. None of this was documented in any way and I only found this about by running a packetsniffer and then verifying it in the sourcecode later. Bug report says this is a feature and you should send the parameters by POST. I ended up using other API calls to work around it. Are there any good alternatives to Net::HTTP?
I've used EventMachine and Typhoeus before, and I love both of them.
That's how POST works though, POST requests don't use a URL query string, they send the parameters as part of the request body. A GET of http://www.example.com/foo?a=1&amp;b=2 is essentially equivalent to a POST of http://www.example.com/foo with a request body of a=1&amp;b=2. I don't think it makes sense to talk about a query string in a POST request.
This is nothing new. Lots of crap in there should be ripped out. Whatever's left should be packaged as gems so that they can be maintained separately, and therefore easily updated.
The library shouldn't strip them from the URL I provided.
There's a bounty?
I don't know why you got downvoted, because you're correct. The OP is doing something weird/wrong. In a post, the parameters are expected to be in the request body and not the query string. Putting parameters in two places opens you to ambiguity (which one takes precedence when they collide?). I do know that the http spec allows for query strings in ANY uri, but it seems weird to want to mix query strings params with request body params. Having said that, I know that for many scenarios what the OP wants DOES work just fine, and is not ambiguous, but I'm of the opinion that it's far cleaner to define parameters in one place only. I'm not certain if anything in the http spec supports this viewpoint, but I can certainly see (and agree with) rationale behind this design decision.
Same thought, but who cares, use what you like, if you don't like it move the fuck on.
Well, I can understand if you need to interact with some bizarre/broken software that needs both, but I don't think it should be particularly unexpected given how POST works that a library attempting to send well-formed requests may strip it out. If you're after atypical behaviour you may need to write your own request.
I've never pair programmed as part of an interview. What I would be looking for it proper use of RSpec (knowing when to use context, let, subject, etc), never implement more than needed to make the specs pass, seeing every spec fail and making baby steps (fix just the failure/error RSpec gives, don't rush towards a solution). Also, be sure to commit and refactor.
Anything? Seriously, though... at my current job, they did a pair programming interview and I was mildly surprised when the person I was pairing with grabbed the keyboard and made my test pass, then wrote another one. (They'd been practicing a variant on ping-pong pairing.) Don't assume the pair programming interview is [just] a test situation -- pairing is about judging your fit as well as your skills.
While the Ruby's STD Lib docs could use some love, I'm not sure about removing the whole thing from the language. I've written a desktop app in Ruby (Github dashboard notifier/viewer with gist support) using only the standard library (+ wxruby for the GUI) - if I had to look for each package separately, make sure that it's the best one (I can imagine seeing 8 different libs just for http) etc - that would take a lot time. Currently I always look first in the std lib, and if I can't find what I'm looking for - then I start my gem search. *edit* my grammar still sucks
&gt; Are there any good alternatives to Net::HTTP? [Lots.](http://ruby-toolbox.com/categories/http_clients.html) The right answer depends on what you're looking for: a better API, better performance, etc. From what you've already mentioned, I'd suggest httparty which I'm partial to.
It should use the URL i provided it. Otherwise it should be documented, there was no documentation for the method. It's perfectly valid to send both POST and get ?query parameters. For HTML forms you can specify get parameters using &lt;form action="query?key=value"&gt;. If the variables are used as get ?query parameters on other pages I don't see any need for converting them to POST variables.
Rails uses: 1. POST, 2. GET, 3. route. For comparison PHP uses 1. Environment, 2. Get, 3. Post, 4. Cookie, 5. Server. I've never had collissions and they can always be accessed via params hash (or $_REQUEST in PHP). If there would be colissions they would be overwritten in the order above.
httparty uses [URI#request_uri](https://github.com/jnunemaker/httparty/blob/master/lib/httparty/request.rb#L133) and not URI#path in this case which would have been good for me in this case. Great site too, thanks, bookmarked!
Good to know, thanks for that tidbit.
I guess I'll ask some questions about rspec. How do you create a custom matcher? How do you create a shared example? Given the following code, why does the shared example always receive nil from @foo? describe "something shared" do before(:each) { @foo = "bar" } it_behaves_like "something shared", @foo end 
This would appear to be the full list: https://github.com/rdp/ruby_bounties/wiki/ruby-bounties
I believe it was a nod to Zed's infamous post.
I think with the improvements to the Ruby Gems system stuff like this shouldn't even be in the core. Take it out and allow it to evolve separately and when it fails at it's job let another Gem replace it. I understand that this sometimes makes the barrier to entry worst. But I think things like [Ruby Toolbox](http://www.ruby-toolbox.com) fix that problem.
Net::HTTP [isnt that slow](http://blog.segment7.net/articles/2010/05/07/net-http-is-not-slow). However, I think REXML and WEBrick are prime candidates for gemification. I would even push for WEBrick to be rewritten. We probably should have had this conversation when 1.9 was first announced.
Ruby 2.0 isn't released yet, so there's still time to have this conversation.
If you are a good programmer, then you have nothing to worry about. If you aren't, then keep working on OSS until you are a good programmer. Don't TRY to pass the interviews. If you're ready, you will pass them. If you are not, then you will know what you have to work on.
:-)
If you'd like to do it in Ruby, [httparty](https://github.com/jnunemaker/httparty) is supposedly the new hotness. I haven't used it, but I've heard good things. You can also just use the 'net/http' stdlib. Something like the following: require 'rubygems' require 'json' require 'net/http' def to_param(items) items.collect { |k, v| "#{k}=#{v}" }.join '&amp;' end def get(path) params = {} get = Net::HTTP::Get.new("#{path}?#{to_param(params)}") http = Net::HTTP.new("http://whatever-the-nfl-site-is", 80) result = http.request(get) return JSON.parse(result.body) end 
It isn't just a feature... it is to the HTTP spec. Garbage in... Garbage out...
hell, no! what we need is a better mechanism to maintain the stdlib, not fragmenting the distribution into a bunch of gems. a batteries-included ruby with things like webrick, drb, yaml, etc is an extremely useful thing to have.
Please point to the section in the spec saying ?query parameters shouldn't be used for POSTs.
I'm going to go with yes. Personally, even when I'm doing just regular ol' network experimentation (not exploits), I use Metasploit's Rex library for protocol work, over the standard net/ stuff. 
And here is [the discussion](http://www.reddit.com/r/ruby/comments/ea2nq/the_ruby_stdlib_is_a_ghetto/) of [the source](http://www.mikeperham.com/2010/11/22/the-ruby-stdlib-is-a-ghetto/). :)
This. The biggest thing I tell people about interviews is: it is a two-way street. You are interviewing them just as much as they are interviewing you. If you honest with them, say what you know and be up front with what you don't know. If it doesn't work out, it is not because you are a bad person or incapable. It just wasn't the right fit. Don't be afraid to turn them down. If the people you are pairing with are elitist or jerks, do you want to work with them? Trust me, working someplace that doesn't fit sucks.
God a job acceptance in Finland (I wanted to take a year off before college). We talked, they did the stuff I hate (front-end shiznizzle), and decided that it wouldn't be best for me to work for them.
If the module-name has two parts that have "helper" in it, there is something seriously wrong.
No! You want to remove them because you don't use them, but I know them well and use them a lot!
Whipped up something quick... feel free to expand on it. I'm getting an invalid json response in the json parser for HTTParty but it could be something wrong with my request. I'll check it out when I have a solid internet connection later today. https://gist.github.com/gists/711855 Edit... I just realized that feed is for a flash app on the NFL's site. Since Flash doesn't digest proper json, proper json parsers can't parse it. If you have a link to another feed of theirs I'll play around.
I run the technical pair-programming interviews where I work (in ruby on rails). I'd say the most important thing is to stay calm and be honest. To me, it doesn't matter so much *what* you know (i.e. proper use of rspec matchers) but how you behave when something doesn't work. If you calmly and quickly troubleshoot the situation, that gets you way more points in my book. I can teach you how to use ruby/rails properly once you're hired. Ultimately, as others have pointed out, you're going to be yourself and it's going to work out or not. It probably won't come down to whether or not you can use rspec well.
I have checked the source myself and found that Net::HTTP's post methods do NOT strip the query part of the URI, they just don't use it. You can extract it yourself with URI#query.
[Net::HTTP#post_form uses URI#path](http://codesearch.google.com/codesearch/p?hl=en#fKFrbe9QqQ4/lib/ruby/1.9/net/http.rb&amp;q=net/http.rb&amp;l=415) which returns the request URL without the ?query parameters. Here's a bug report: http://redmine.ruby-lang.org/issues/show/655 I think I found a different report when I first encountered the issue.
Might as well start on ruby 1.9 if you don't have any legacy issues. Learning ruby: http://www.pragprog.com/titles/ruby3/programming-ruby-1-9 Learning rails: http://www.pragprog.com/titles/rails4
There's a special offer for 'programming ruby' at $10 right now. Make it so.
If you want to be future proof then go with Ruby 1.9 however there aren't many differences in the syntax and the default system packages (for both Linux &amp; OSX) are 1.8.7 so you may want to start with 1.8 so you don't get bogged down with having to setup your dev box from the off. Learn at least a bit of ruby so you start to get an idea of how it works (I think this is for 1.8): http://ruby-doc.org/docs/ProgrammingRuby/ Latest version of the book is here (for 1.9): http://pragprog.com/titles/ruby3/programming-ruby-1-9 And then get a copy of: http://pragprog.com/titles/rails4/agile-web-development-with-rails Get a project and spend a week creating your first proper rails app. Make sure you have your project in [git/svn/source control system du jour] and then read up on Capistrano for deployment: https://github.com/capistrano/capistrano/wiki/Documentation-v2.x Profit! :) At least that's how I did it!
Its recommended today to use Ruby 1.9 But if you are running for production you have to try Ruby Enterprise Edition: http://www.rubyenterpriseedition.com/ Also, you have to specify your question, is it only about using 1.8 or 1.9? 
Learn the difference between advice and advise.
Grab the [on-sale $10 copy of Programming Ruby 1.9 from pragprog](http://www.pragprog.com/titles/ruby3/programming-ruby-1-9). Grab the super amazing [Agile Development with Ruby on Rails book from pragprog](http://www.pragprog.com/titles/rails4/agile-web-development-with-rails). Enjoy.
I suggest starting out with [Ruby Koans](http://rubykoans.com/), 1.9. They are a really fun and motivating way to start off with Ruby! It gives you a great overview of the language. And then afterwards moving on to the things your other fellow Reddits suggested! Best of luck!
What? No comment to use Python + Django yet? 
Unfortunately Ruby EE is only 1.8.7 compatible right now. Although REE may be a bit easier on the ram, the difference isn't much to be concerned about. Even if we're talking production, until REE gets up to 1.9.2 compatibility it's still not worth it imo to go back to 1.8.7 just to save a bit on resource utilization. With that said, once REE gets to 1.9.2 compatibility, I'll be the first one to jump.
This is /r/ruby
You can start with ruby 1.9 and rails 3, it will be a good investment. Rake will be your best friend when it comes to automation (very similar to Make). Personally I started to learn ruby / rails watching the "create a blog in less than 15 minutes", but it is not online anymore. Try there for a good start: http://rubyonrails.org/screencasts
I understand that. But this is also Reddit, which uses Python &amp; Pylons-- so a typical response I see often is to use Python and Pylons/Django/Web2py...
And they have a black friday special where everything (except that sweet Ruby 1.9 book) is 40% off
If you're just looking to build small apps for workplace, I'd run through the ruby koans, http://rubykoans.com/. Then play around with Sinatra, http://www.sinatrarb.com/. For small apps Sinatra is much easier to manage, understand, and get started with than rails. Even if it turns out that you do need something as complex as rails, building from the ground up with Sinatra will give you a good idea of what rails is doing behind the scenes. 
Not if a major goal of the main package is to provide helpers to rails applications.
The best way to learn is to start doing it. You're going to make a lot of mistakes, but don't get discouraged -- learn from them. A lot of other comments already should send you in the direction of good information to read in order to get you started. Good luck!
I'm also a sysadmin and a ruby enthusiast. I'm not surprised at the responses here, but I don't know that they're great advice. Ruby is going through a tough time right now as I'm sure you've gleaned on your own. 1.9 is faster and generally better. That said, we use 1.8 in our shop because there are way too many gems and useful libraries that aren't yet 1.9 ready. Another reason we stick with 1.8 is that 1.9 is a dev branch and as such things change much more than they will once 2.0 is out. I'm very excited for 2.0, but I'm also committed to waiting. In the mean time, we're using Ruby Enterprise Edition. Also, I found Rails to be largely overkill for the kinds of projects I've undertaken. I absolutely love Padrino as a big brother to Sinatra and a littler brother to Rails.
You're a sysadmin that's new to programming? How is that even possible?
Before automating tasks with Rails, I would learn [Rake](http://rake.rubyforge.org/) and [Thor](http://github.com/wycats/thor) for writing maintenance tasks. I would go with 1.9.2, it's fast and passes 99% of [RubySpec](https://github.com/rubyspec/rubyspec#readme). I would also install [RVM](http://rvm.beginrescueend.com/) so you can easily install 1.9.2 and even [JRuby](http://jruby.org/) (in case you have some Java stuff to interact with).
Plus, you can install multiple versions of Ruby and, I'm pretty sure, manage and specify them per app with RVM. Therefore negating any legacy issues with previous apps already running. At least I think so, please someone correct me if I'm wrong. 
Rails is not necessary to learn Ruby. In fact, I'd advise against it. Learn the language before a specific framework. 
You won't want to use Ubuntu's Ruby on 10.04 LTS anyway.
When I said I am new to programming, I mean never programmed a complete web application. I have been writing scripts , mostly modifying existing scripts either in python or ruby to my needs. I am not trying to build my career upon ruby itself. I want to learn both Python &amp; Ruby at some point. My Question here was If I am starting today and want to learn ruby and ror in next 5 months,What is the best path.... I dont understand things like rack,yaml etc.... they are confusing for me. I am seeking advice from experienced ruby programmers for step by step learning path to become rails developer, about the tools I need to learn one after another in right order. I have purchased Programming Ruby 1.9 from pragprog and started reading it :-)
Thank you Riddley, I think you understand my question better as we are on the same lines( Sysadmin + Ruby Enthusiast ). Performance is not an issue, I want to learn the concepts and understand ruby and use it. Building frontends to the ruby scripts seems to be very usefull hence wanted to learn rails also. Thank you for your advice will look in Padrino. 
You don't need to worry about things like yaml and rack right now. The basics you need to know are: Ruby, HTML, Javascript, CSS, and Rails (although you could wait until later for javascript and css). I think you're approaching this the wrong way, don't think about all the tools you don't know about, think about what you want to build and then figure out what you need to build it. I would choose a simple project (e.g. implement a blog where the owner can add new posts and users can create accounts and comment on posts) and then go for it! You don't need yaml or rack for that. After you've done that you'll have a good idea about what you should learn next. 
Yep, hence I said learn some Ruby first. From my point of view the best way to learn a language is to do a project in it; you'll have some high's &amp; lows but by the end you'll have a good idea of what it can do and whether you like it or not. I loved the look of Ruby when I first saw it in the pickaxe book but for me it didn't really hit home until I did a project in it for me that first project was in Rails. In my opinion, if you are a web developer Rails makes sense as to learn early as generally it just works out of the box, there is a lot of documentation/blogs/books written about it and it gives you a really good idea of what you can achieve in Ruby - as well as what a kick-ass web framework should do. Obviously if you aren't interested in web development then you might be better off looking at a different packages or even languages suited to what you wish to learn. e.g. if you I was a game programmer and interested in learning lua I would download something like http://love2d.org/ and make a game with it. Frameworks can give you a good understanding of what you can do with a language, of course, some people will confuse the language with the framework, but if you are still interested in the language after you've created something in it you'll have that desire to understand the language better. 
So ... kinda like how you'd combine anything with git for source control?
Thanks for the tip, bought the book now!
If you are interviewing for an RSpec-position. I don't know the answer to any of those questions, largely because I haven't used RSpec for two years. Does that make me a bad Ruby programmer?
I clicked the link expecting coverage of something more along the lines of mojombo's [Grit](https://github.com/mojombo/grit) library. The actual article was pretty useless. You could swap in almost any programming language and have the same article.
And (along w/ learning language basics) I would even suggest messing with Sinatra before getting into Rails. You can learn a good bit of the Ruby basics (off the top of my head, modules, blocks, instance variables) by building some really simple Sinatra applications, and you'd have something fun to show your friends when you're done. You'd even learn a bit about Rack, which is what Rails 3 is all about now.
I was definitely thinking Sinatra before something as heavy-hitting as Rails for learning, but I didn't want to show any favoritism. tl;dr: You're correct :)
If the NFL.com server is sending the data in the right way, basically in the same fashion as the [Twitter JSON Streaming API](http://dev.twitter.com/pages/streaming_api_methods), a feature of [yajl-ruby](https://github.com/brianmario/yajl-ruby) (Yajl::HttpStream) may be what you're looking for. If your project is intended for eventual public consumption rather than your personal use, be sure to check with nfl.com if this usage of their site is OK. Odds are, it isn't, unfortunately.
No, it doesn't make you a bad Ruby programmer. However, it may mean that you are less qualified than someone else for that position. I would at least look into how to use a technology before going to an interview for a job that uses it.
ohh god. He just suggested hidden methods being injected into your models. "What's your user class do" -- "I don't know, let me read every file in the project to find out".
While the support replies are less than helpful, the poster seems to be missing the fact that for [Passenger](http://www.modrails.com/)-hosted Rails-apps, the root directory is indeed the /public subdirectory.
Is this at grockit by any chance? I enjoyed their on-site pair programming interview (this was a few months ago), but another company I liked offered me a position so went with it (that, and grockit has a two onsite interview process... also they're in the mission district). I felt like for something like this, there's really nothing you can do to "prepare" for it. I was already familiar with RSpec (had been using it for work and personal projects), so that part was easy. They were using [erector](http://erector.rubyforge.org/) (hehehehe) for views, which I wasn't familiar with, so that's something I couldn't have prepared for. In the end, they expect that you already know some of the things, but need to learn other parts. This is sort of like trying out your first week/month at work and making sure you'll be a good fit.
Cool. A former co-worker of mine was trying to do this a few years back. It looks like [he hasn't worked on it recently](https://github.com/cardmagic/lucash/) though.
I like this because [rush](http://rush.heroku.com/) seems [pretty quiet](https://github.com/adamwiggins/rush/commits/master).
What I really want and have been toying with, is a ruby based launcher ala quicksilver or Google Quick Search Box. Hit a certain global key command, up comes a window and just type in a bit of ruby to tell your machine to do something: tweet "i'm listening to #{itunes.current.artist}" rails_dev = [:macvim, :terminal, :chrome] rails_dev.launch hide :except =&gt; rails_dev deathcab = itunes.albums.where { |a| a.artist =~ /cutie/i } itunes.play deathcab, :shuffle =&gt; true remind_in 30.minutes, "call Mom" 
Why don't you just compile the HAML code into HTML and check at that point? From the HAML docs: engine = Haml::Engine.new("%p Haml code!") engine.render #=&gt; "&lt;p&gt;Haml code!&lt;/p&gt;\n"
You mean as opposed to directly outputting the user input? I'm not sure I understand what you're suggesting. This is what i have in my view currently: = Haml::Engine.new(current_user.userinput).render(self) And in the model: xss_terminate :sanitize =&gt; [ :userinput ] If you mean i should sanitize the compiled HAML in a sort of inbetween input and display process, then I'm not sure how I would go about doing that.
I think I misunderstood your question -- so you don't want to just remove the %script, but you want them in there differently?
Ideally, %script would be escaped. But removal would work as well.
I like this and I haven't even clicked the article yet.
i.e. no, there isn't.
Yes it should, if it's following the original HTTP spec, RFC 1738. [Long post by me on my web site](http://lpar.ath0.com/2008/10/26/rfc-3986-considered-harmful/), but the tl;dr summary is that query parameters in post are incompatible with the current HTTP spec. This also means RFC 3986 is incompatible with the HTTP spec, and changes the meaning of URLs from the meaning they had in RFC 1738.
[See writeup with spec quotes on my web site](http://lpar.ath0.com/2008/10/26/rfc-3986-considered-harmful/)
 before_save :remove_script, :only =&gt; [ :userinput ] def remove_script self.userinput = userinput.gsub(/%script/, '') end This is working to remove script tags, but I don't know how to match '-' and '=' for the first character in a newline only
I just checked, and it looks as if httpbis is going to change the meaning of HTTP POST to follow RFC 3986. So at some point Ruby will presumably need to be updated. But that's the reason, Ruby's following the current HTTP spec.
So in the last week I've been through 3 pair programming interviews in Ruby. The biggest thing I think you need to remember is that your working as a team, so say what your thinking and ask questions, don't blindly code. Another good way to go about it, is to let the interview write a test (unless they want you to) then write the least amount of code to pass the test (in other words TDD). This shows them that you can take natural breaks while coding with someone else to discuss what your doing and see if its the best choice. As far as what I had to write, it was 2 code kata's and a problem I worked for the company prior to the interview. The first was to write a postfix notation calculator - http://en.wikipedia.org/wiki/Reverse_Polish_notation. i.e. calc("3 4 +") =&gt; 7 The second was to write code to find the prime factors of a number - http://katas.softwarecraftsmanship.org/?p=71 i.e. prime_factors(10) =&gt; [2, 5] The coding problem was to write Tic Tac Toe with an unbeatable AI and some significant amount of tests, then when I went in we spent an hour or two refactoring the code I had written. I think this wasn't so much a test of my programming abilities, but how I interacted with my pair. In my opinion pair programming interview is the best way to interview a candiate, and there really isn't a good way to prepare for it, other than having a lot of pairing experience. Just know that going in if your unsure of the next step in the problem don't worry about it discuss it with your pair, because that's how it's going to be on a real project. tl;dr Be personable and talk out loud.
Random uninformed, vague and bloviating blog whoring, what's not to like?
It's Eric Hodel. I think he's at least informed.
I made a good-faith effort to present the bounds of my qualifications. I can't say I'm fully informed, but I have used most of the libraries Mike mentioned. 
I use the following helper to do that: def overwrite_content_for(name, content = nil, &amp;block) @_content_for[name] = "" content_for(name, content, &amp;block) end
Thanks! That's a very well put and comprehensive answer. Ideally the library would have worked as we expected and used the full URL as passed to it and not taken an ideological standpoint to strip it. Just did some googling and found the [principle of least astonishment](http://en.wikipedia.org/wiki/Principle_of_least_astonishment) is [quoted as core to Ruby](http://en.wikipedia.org/wiki/Ruby_\(programming_language\)#Philosophy). So IMO it's a matter of least surprise or enforcing standards.
That's awesome. 
To be clear Eric Hodel is one of the Seattle.rb guys. While being on the prickly end of the ruby community, they definitely know what they're talking about, particularly having built a lot of it. Hodel's point, whether you agree with him or not, is that people should Act, not just Speak. And that's fair enough. This is a conversation that happens in every open source community on a recurring basis. Also, given that it's seattle.rb and the degree to which they are self-assured, i doubt you can accuse Hodel of "blog whoring" :P
Well, based on the W3C documents and the state of the world circa 2000, query parameters on a POST would suggest that the caller was confused about how form submission worked, i.e. user error. It's only since HTTP became a method of connecting REST-based services together that query parameters on POST have made any sense, as they literally never happen with a web browser as per the W3C specs.
Just FYI: the stuff you posted in your Edit is an awful way of sanitizing HTML. there are roughly one billion ways for me to still execute JavaScript after that. Run the generated HTML through a whitelist sanitized before putting it on the page, much better approach!
I submitted the link - I'm not associated with seattle.rb, and I don't know drbrain personally. I read his article (via twitter) and thought it was interesting, and wanted to share it on r/ruby. No blog whoring going on.
Excellent, thanks. That works just fine. I had tried to code something similar last night, but I believe I left off the underscore at the beginning of the instance variable. That's why I thought it didn't work in Rails3. I am mentally sending you thank-you cookies. :)
Ok, the first rant was fun, now it's becoming annoying… If you don't like the standard library, just don't use it or contribute to it, and stop pissing everyone.
I disagree. I think opening up discussion about improving the stdlib is good for everybody using ruby. If nobody cared about this kind of stuff, ruby 1.9 would still have CSV and Test::Unit instead of FasterCSV and minitest.
I really dislike how these articles seem to be all about getting people to go to his blog. The use of the word "Ghetto", the fact that he's not just discussing this on the ruby core mailing list. Even after [Eric](http://blog.segment7.net/articles/2010/11/24/the-ruby-stdlib-is-not-a-ghetto) wrote a really well considered reply, basically calling Mike out for not doing anything about it, Mike goes on to blog more pointless stuff again. [this discussion has already been largely had on the mailing list, anyway.](http://blade.nagaokaut.ac.jp/cgi-bin/vframe.rb/ruby/ruby-core/32009?31817-33332+split-mode-vertical) 
Huh... I'm not sure how to do that. I was under the impression that since HAML uses pretty strict syntax that you'd need exactly "%script" on the page to get a script tag to compile. Is that wrong? I am also sanitizing the HTML, but I don't know how to sanitize it after the HAML compiles
After switching up the controller, so that the input is stored in a variable, rather than passed directly to the the Haml engine, I am now able to run sanitize in the view = sanitize Haml::Engine.new(@haml).render(self), :tags =&gt; %w(div a br span h1 h2 h3 b em img ul li ol hr), :attributes =&gt; %w(style href id class title src) How does that look?
I really think that, in theory, a *ton* of the stdlib should be moved out into gems. There's really no good reason to include application-level stuff in a stdlib - doing http is not a stdlib function, or at least, shouldn't be. Now, from a practical point of view, I'd hate it, as I ship a gem that relies only on the std lib for utilities. But honestly, I'd support pulling a lot of these things out into non-standard libraries.
I hate how ever rails tutorial builds the same damn thing, a fucking blog. Cool blog thou.
Currently, there is no Rails-way of doing this, but it's coming in Rails 3.1. There will be a new API called provide that will not append to the previous call. Much more about this here: http://yehudakatz.com/2010/09/07/automatic-flushing-the-rails-3-1-plan/
Maybe, but having net/http builtin is a huge bonus. It's pretty hard to not have to use net/http these days. 
I honestly don't think so. It's not like sockets, where rolling your own is prohibitively difficult, or yaml, which is used in the ruby build process itself. There's a number of http libraries for ruby, and I think that favoring one (imo the worst one) as THE http library is poor form.
Holy yak shaving batman! Yikes! Good work, but man that's a long way to fix Matrix#regular?
https://github.com/fesplugas/typus is another alternative for rails admin
Did you publish this qor gem? Or is this just a tease? It's not in your public repo list and I could not find it on Rubygems.org. I used to wield ActiveScaffold quite effectively and I could really use something like this. ActiveScaffold looks like it hasn't made the Rails3 transition. Please let us know where we can get it.
Nice but the https didn't work in the clone - I had to use http instead. I think it's a windows thing.
Don't allow the `style` attribute, it will allow for XSS attacks. You should really trust the default whitelist, it's there for a reason. EDIT: actually I'm wrong, I just checked the docs and sanitize actually sanitizes the CSS inside `style`, so it should be safe. I'd still test it just to make sure.
There are widget frameworks you should look at like apotomo/cells and erector.
We did this with a DSL not yaml files which makes it better I think.
This is developed by The Plant (http://theplant.jp) as a company product, But we will think about open source it or not.
Thanks for the advice. I tested a bunch of examples using obfuscated xss attacks, and none of them passed through. I was intending on writing an upload field for users to submit their own stylesheets, but i wasn't aware the ability to use binding and such to embed script into css, so I might reconsider that, or try to find some way of sanitizing the content. Thanks for the help.
ActiveScaffold has been the goto backend for a lot of my projects and I too would like to know if qor will be publicly available. This looks pretty fantastic!
doesn't every framework tutorial do the same thing? Not just Rails.
net/http is used by rubygems, open-uri. and xmlrpc/client. Sometimes it's good to have a builtin defacto solution, for when developers just need the most basic HTTP functionality without adding dependencies. Splitting net/http out would disrupt the dependencies for many gems that are already out there.
Right, the gem I write is dependent on it. However, let us distinguish between a practical hassle, and a theoretical benefit. You could easily bundle everything in the stdlib as gems, included with the interpreter. That would solve the chicken and egg problem there, and allow them to be updated stand alone.
He says qor is an internal project/product. Are you interested in helping to update AS? I could be game.
why bother killing babies in real life?
Is this the same thing as selector namespaces that were discussed at rubyconf 07?
extreme example but i do see your point. just because something is easy, doesn't mean it's a good idea. 
Probably. From Shugo's post at ruby-core: &gt; Refinements are similar to Classboxes. However, Refinements doesn't support local rebinding as mentioned later. In this sense, Refinements might be more similar to selector namespaces, but I'm not sure because I have never seen any implementation of selector namespaces.
&lt;flame&gt; Why not write your own number crunching libraries for Ruby then? :D Good post, I read it all the way through. I'm currently in the process of learning Ruby and I'm quite enjoying it but I can also see it's limitations. So last week I decided to dive into a bit of python to see what it's like 'over the fence' as it were and I was impressed with what the platform had to offer. The thing is, (for me anyway) it's really hard to break out of the Ruby mindset to solve problems when you move to Python, for example in Ruby: - "Hello world!".length =&gt; 12 Is a very natural construct in my brain, whereas in python it's len("Hello World!") =&gt; 12 I know this is a petty argument and rather trivial but I find it hard to adjust. My advice would be to approach Python from scratch and forget your Ruby knowledge because it gets in the way of your progress. People say they're both practically the same but in my view they're not.
This is a pretty simple question: You find the tool that you need to use, and let the other choices fall out of that. In this case, the tool is SciPy, and that mandates Python. That's exactly correct - doing it any other way is silly, sort of like using PHP if you want Rails.
as an aside what are the benefits/reasons for using php or rails? what guides that decision?
If you used jruby you could tap into the vast java library for numerical computing or anything else you wanted.
this is really quite awesome, and long overdue. I can't wait to see it merged.
FWIW, len() is a classic wart of python, but it's not the norm.
You can learn some very basics from [tryruby.org](http://tryruby.org/). If you enjoy math / solving problems, you could work on [projecteuler.net](http://projecteuler.net) problems using Ruby.
HI...I like your post although I do it in the inverse way..first I learn python and later ruby, for me ruby is much more pretty and powerfull but I understand than it hasn't so many libraries like python (and so less libraries for scientifics)..I think than the programmer must choose the correct toys for his job and if you need a scientific languague maybe ruby don't fix so well, even so I think you could use jruby, but if you wanna learn python is not a bad decision....I like a lot ruby...much more than python though haven't critical (or critiques sorry I'm italian and don't speak english so well) to python...only I could say I don't like his community (they're like a bullies..find fights all the time vs ruby, java, c#,clojures,smalltalk,lisp and scala peoples) FOR ME RUBY IS THE LANGUAGE FOR THE HAPINESS AND PEACE
* Step 1: Get yourself the [Pickaxe book](http://www.pragprog.com/titles/ruby3/programming-ruby-1-9). Give it a quick read, then keep close for reference. * Step 2: Make irb your new best friend. * Step 3: Work your way through the simple exercises in the [Ruby Koans](http://rubykoans.com/). The koans teach the basic principles of Ruby through a set of unit tests.
You can invoke the (ugly) method \_\_len\_\_ for the same effect. E.g. &gt;&gt;&gt; "asdasd".__len__() 6 
The one that you like (or the one your employer likes) guides that decision. It's like asking which baseball team you should root for. You're just going to start a flame war starting a conversation like that.
...and if you get through all of that, go [here](http://pragprog.com/titles/rails4/agile-web-development-with-rails) to learn rails
Or Jython...
I was originally a perl person, spent the majority of my career with Python, but the last 4 years or so has all been Ruby. The elegance beyond the language is what hooked me: rdoc, gems, irb. Object.methods is another great Rubyism, nevermind calling length on something, let me autocomplete available methods in a shell and bring up the docs. All that aside, the complaints about package management, etc., are why there are Linux distros with packaging systems. Your whole scenario reminds me of a recent thread in the Fedora Ruby SIG, and kinda blows my argument to said list about going to a completely RVM setup out of the water. Then again, if you're on a mac, install homebrew and pip and cross your fingers. If you are on windows take up religion or booze. 
(in this case you were wondering, Rails is the SF Giants in this metaphor)
&gt; Anyway, I’m hoping to get this all sorted out soon and start doing some heavy stats with the new language. I’m excited to be joining a group of people who are focused on data and experiments instead of HTTP requests and NoSQL and jQuery and event processing. That’s not a jab at the Rubyists I know. I’m just excited to put a language (and not just a framework) to good use. This is somewhat of a cultural/perception problem. There are people that use Ruby for statistical analysis, but they are drowned out in the larger community of Rails and web-dev folk. It would be nice if outreach material existed for using Ruby in Mathematics, Physics, Engineering, etc.
There is no key, but I work in the same office as Jim and will ask about something like that. Is there something I can help you with?
You can have my solutions if you like. I did them over a year ago, so I can't guarantee that they're good, idiomatic, ruby, but they all pass. http://dl.dropbox.com/u/80354/koans.zip
Start from the official Ruby web site: http://www.ruby-lang.org It has some introductory material, in particular: - Ruby in 20 minutes - Ruby from other languages ...and links to a lot of useful free resources!
That's PERFECT! Thank you, thank you, thank you! 
If there is no answer, is it a question? A man who queries an empty tree will find no leaves.
it looks good. I'd be in favour of open sourcing it unless you think it will become a product that your company will one day sell. Unless it's a core business concern/differentiator, the benefits of outsourcing far outweigh keeping it closed. Not only do you give back to the community that gave you rails, but you free QA testing and hopefully bugfixes and improvements from other people using it. Open sourcing rails in the first place has been by far the smartest move they made.
&gt;Or Jython... Which sadly has been neglected for a long time.
Working on a pure-ruby statistics library right now. I'm looking to add more then release it.
&lt;/flame&gt;
analagous to http://reddit.com/r/haskell_proposals
There is no key, just like there's no answer key when you're working on your own project. The koans are given as tests with assertions, so you modify them and make them pass. Having somebody else's answers won't teach you anything.
I totally agree, but when you're stuck on number six and live in rural Missouri, it's frustrating. This early in the koans, there's only one answer, and if I know what it is, I can figure out why it works.
I like it because it's interactive and I don't have to carry around a book or re-type examples. Think I should get that book after I complete the koans? Or will that be redundant?
You write: "To separate our filter from our criterion, we have to have a way to pass the criterion function into the filter. And, as I’ve said, that’s just not possible in Java." But this is setting up a straw man. While it's more verbose than Ruby, you can create an interface that defines a method signature for your generic criterion: You would follow the pattern for the Java Comparator interface: http://download.oracle.com/javase/1.4.2/docs/api/java/util/Comparator.html Look, I switched to Ruby for many of the same reasons, but in Java you can pass around objects that implement methods that will fit your case. So I think your essential gripe about Java is the lack of specifically anonymous functions that can be declared through syntax.
When you run rake, it shows you what was wrong: The answers you seek... &lt;"FILL ME IN"&gt; expected but was &lt;[:peanut, :butter, :and]&gt;. Please meditate on the following code: ./about_arrays.rb:57:in `test_slicing_with_ranges' A big point of the exercise is to trust the computer to tell you when things are wrong. From the Ruby Koans site: &gt; Red, Green, Refactor &gt; &gt; In test-driven development (TDD) the mantra has always been red: write a failing test and run it, green: make the test pass, and refactor: look at the code and see if you can make it any better. &gt; &gt; With the koans, you will need to run the tests and see it fail (red), make the test pass (green), then take a moment and reflect upon the test to see what it is teaching you and improve the code to better communicate its intent (refactor). 
I'm still thankful for your answers, but is there a chance we used different versions? The file I'm working on looks very little like the one that you finished. http://min.us/iKzfQ.png
I'm stuck on number 6. I'm supposed to fix line 16 of this code: http://pastebin.com/eTnQDwwQ I'm told the answer is "NoMethodError" but I'm not sure what that means, and it doesn't work.
Nice try, idea-starved entrepreneur..
For one, PHP is a language, and Rails is a framework. Let's adjust this argument... Why use PHP with CodeIgniter versus Ruby on Rails? One immediate issue is efficiency and deployment. Not efficiency of the developer. And Phusion Passenger has eased deployment. But I have seen nothing that makes RoR as easy to deploy as a PHP app, especially on servers you don't have root control of. One might say, but Heroku! Yeah, Heroku is fucking expensive. And RoR is expensive, in terms of resources needed per application. Compare a simple blog with PHP/CodeIgniter to a simple blog with RoR. The RoR blog app is going to need a much beefier server and more resources than the PHP alternative... AND, you can deploy with PHP by just dragging over files. /I've used both
Before you reimplement *anything* in C you have to ask yourself whether it's worth it. Developing something in C can be anywhere between 2x and 10x slower than developing in Ruby. The C implementation might be faster in microbenchmarks but you might not notice any improvement in real-world workloads: for example if 0.5% of your time is spent in the Rack gem then making it 10x faster will make your app 0.45% faster. Sounds like a waste to me if you spent 60 hours reimplementing Rack. So far Rack hasn't shown itself to be a significant hot spot. The only thing I can think of that needs improvement is the multipart parser. However that part is likely to be I/O-bound rather than CPU-bound or GC-bound so rewriting it in C might not help. I think it's better to offload multipart parsing to the web server which, when properly implemented, can do it infinitely concurrently.
Very much no; Rack is basically a protocol, and not only is hardly any time spent in it, but it really doesn't do that much.
Rack is pretty small. It's just a little glue between your app and the server, so I doubt there would be much improvement in performance.
Well, if you're having trouble with an individual koan, just ask. Otherwise, the tests tell you if you got it right or wrong. Oh, and there's no right or wrong answer for some of them. It's a matter of style, whatever works well for you and passes the tests is right.
Ok it makes sense. Thank you guys!
I'm stuck on number 6. I'm supposed to fix line 16 of this code: http://pastebin.com/eTnQDwwQ I'm told the answer is "NoMethodError" but I'm not sure what that means, and it doesn't work.
Anyone that knows Python will ask why you did that of all things.
Except that that would then be vulnerable to a memory exhaustion DoS by sending arbitrary headers, as symbols are never garbage collected.
The line should read like, "assert_equal NoMethodError, ex.class" This happens because on line 13 you call: nil.some_method_nil_doesnt_know_about If you were to do this in irb, you would simply get a NoMethodError because the method you are trying to call does not exist for the nil object. But in this case the line that throws the error is surrounded with a rescue block. When the error is caught the code enters the rescue block passing the exception to the variable ex. So when you say ex.class it returns NoMethodError, the class of the error that was caught.
PM me if you have any other questions.
I have a couple of ideas: - autotagging system for ruby - a rails engine to add private messages to any app - a rails engine to add chat rooms to any app 
Try the ruby koans, rubykoans.com
I will, thank you!
Yeah, entirely possible. Mine are about a year old. Sorry :( edit: My workplace is blocking your link, so I can't see the file, but I'll look at it when I get home.
Just as important as the introduction is knowing to define `respond_to?` as well. Good resource [here.](http://technicalpickles.com/posts/using-method_missing-and-respond_to-to-create-dynamic-methods/)
Those happened because people developed solid replacements and approached Core. minitest and FasterCSV were done by [Aaron Patterson](https://github.com/tenderlove) and [James Gray](https://github.com/jeg2), respectively, both core contributors. The YAML parser was also replaced (by Aaron). One can talk about it, but until someone steps up and does it, nothing will change.
A MVC framework using the Ruby language.
No apology necessary, I was just making sure I wasn't missing something. I've actually figured out the initial problem, now working on one that apparently doesn't exist in your version at all...
&gt;&gt; Rack provides a minimal interface between webservers Webservers are written in C. If Rack was written in C it would be CGI not Rack.
He's specifically talking about the gem, not the specification.
Well I'm not asking you which is the best baseball team, I'm asking you what are the strengths and weaknesses of the two teams.
If Rack was written as a Ruby C extension (what the OP likely meant) it would still be Rack, not CGI.
Also, being pure ruby means it runs properly (and quickly) on jruby and rbx.
This IDE requires so much overhead. I still prefer Textmate or VIM. I know it may be unfair to compare those two to a full-blown IDE but I just don't feel that Ruby is complicated enough to warrant an IDE.
Very interesting.
Don't try this. It is extremely hard to parse and handle data correctly in C while avoiding memory-corruption vulnerabilities. Experts need only apply.
As a full time RoR developer, I can say with certainty that a major IDE like Rubymine is a definite time-saver. Sure, like any IDE, you don't really need it, but the better document management, built-in test integration, and better presentation really make a difference when you're working on what can end up being very large projects.
I'm vehemently anti-IDE, but I've been really impressed with RubyMine. It has enough time-saving features that it's easily worth $70 to me. I used Notepad++ for years, switched to RubyMine about 3 months back, and have been extremely happy with it.
Heh, I actually sat down and read the Rack source, and it's pretty neat; it looks like there's a handful of utility classes for HTTP-related stuff, but most of it is actually miniature Rack apps that add one HTTP feature at a time. Pretty clever, and I'm glad it's in Ruby, instead of less-readable C.
Rewrite RubyGems&lt;/troll&gt; This is a cool idea, will likely become a good list for new developers wanting some real-world challenges.
I just looked at the feature list and it looks... impressive. I don't usually go for IDEs either, but I'll give this a try.
You could also get it for $4.99 if you registered that you already owned the print book. There's no verification for this process, you just search for it, click "Register" then hit "$4.99 upgrade to Ebook". You have to be a member for this though. I don't necessarily think you should do this, but them having deals like this is kind of silly when their verification process is nonexistent for their other deals.
i don't think it will be redundant. i'd recommend it highly. or "ruby for rails" by the same author if you want to learn some rails stuff at the end. the rails way and the ruby way are great references, not sure if they're updated for 3.x yet though... skip the pragprog stuff (pickaxe etc).
I love Rubymine! It was the reason I took up Emacs :)
A decent, well documented id3 library.
PHP's weaknesses are [well documented](http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=php+sucks); it's a horrible language.
I wrote a piece of software in Ruby years and years ago--well predating even the very first version of Rails--which turned out to be a DSL using these very practices. Nearly nobody in the entire body of Ruby literature has held it up as an example--even prototypical--of how you'd build a DSL using Ruby. The only person who even mentioned it as being something like that was why the lucky stiff--and he staged his dramatic disappearance, leaving me with nothing. Ah well, enjoy, anyway, a classic Ruby DSL: [gurgitate-mail](https://github.com/dagbrown/gurgitate-mail).
I have used rubymine for a while now and have been running the betas and the release candidates but version three is making me rethink my choice and I don't think I am going to pay for the final product. It's become heavier and slower with this release. It has always been baffling to use with a confusing menu system but I have put up with that by learning the shortcuts. There is something wrong with the new version I think. It chews up a ton of CPU, it hangs up sometimes and has to be force killed, sometimes copying or cutting causes it to freeze for extended periods of time etc. I love the code insight it has but on linux anyway this version is barely usable.
See my post on the other thread but I think 3.0 is a step backward on linux. 
I've been using the EAP RubyMine for a while, and I can't go back to 2. Haven't had any CPU or crashing issues, though I am on OSX. Rvm support finally works in this version, so rejoice!
I love rubymine. I've been using it for about a year now. But this new release, I need to edit the plist file and change the JVM memory setting to over 1GB and restart the IDE at least once a day to reclaim leaking memory. It used to just offer IDE features I missed from Eclipse etc. in Ruby, but now it is becoming an impediment to my work and gives me huge lists of problems. This version is barely usable.
Great stuff in there for the n00bs.... 
Lynda.com has a really good Rails 3 and Ruby course. http://t.co/JlBJknm
Everyone is debating Ruby vs. Python and missing the real value of the article: 1) Ruby is almost a lisp. This higher order functions stuff has really opened my eyes. I've looked over all my code and see tons of opportunities to make my code more concise and DRY. Just a cursory search seems to indicate this has been discussed in the Ruby community but not all that much it seems to me. Because of this article, I'm going to be looking much harder at lisps like clojure. 2) Webapps have been both good and bad for Ruby. As postmodern said discussion about applications for Ruby beyond webapps has gotten drowned out by the frenzy over Rails. And Python has indeed thrived in the scientific/stat/number crunching community. This is really unfortunate for Ruby. So far I've never used Ruby for a web app. I've tried a couple of times and got bogged down in learning html/css. But I use ruby all the time for command line apps with the help of command line scripting frameworks like boson and thor.
Hi...I've rubymine since version 2.0...the beta and RC for 3.0 are slow, heavy and bugies...but I think it's because they wasn't finished yet...RM 2 works perfect for me and now I use emacs only for lisp and clojure...I prefer RM for ruby and javascript (now this accept coffeescript)...the beta has many bugs I hope this final release be better...sorry for my english I'm italian
Why not? I find 1.8.7p249 to probably be one the best MRI builds especially for stability across platforms.
Had no idea about Alt-Cmd-] for auto-aligning assignments!
He says he's interested in learning Rails, and the latest version of Rails requires a more recent Rake than can be installed with Ubuntu's Gem and Ruby. And personally, I switched to 1.9 a while back because I need Unicode support.
Hey thanks for getting back to me. Although it sounds awesome to take on updating AS to Rails 3, it does look like someone is already on it. Check this out: [Link](http://vhochstein.wordpress.com/2010/08/28/setup-activescaffold-rails-3/) . I started looking into Rails 3 and AS further as I got excited about collaborating on this and happened to stumble on that site and the GIT fork [here](https://github.com/vhochstein/active_scaffold). Hope that helps a bit. On another thought it would be pretty sweet to come up with a plug-in/theme to allow AS to look/feel like qor. At least the interface for qor looks pretty awesome. Let me know what you think, maybe we can start a GIT repo.
text mate is hands down the best code editor i've used... 
I stick with 1.8 because SWIG hates 1.9 and I have some industry required libs I don't want to have to reverse, that aside I still stand by the best consistency across platforms statement. As for Rails goes I don't use it, Sinatra + Sequel and my Ruby foo are more than enough for me, Rails just seems to get in the way of what I want to do.
As a fellow sysadmin and Ruby enthusiast that riddley guy speaks truths. Although Sinatra is #1 in my book, I'd say you're better off just finding gems that provide DSL's for systems you already work with than say learning Rails and a bunch of superflous shite like ActiveRecord, etc.. etc.. that you MAY never use. For instance I'm a fool for Sequel, ActiveRecord and I don't get along, you could wind up liking DM. Take the approach that will help you to find a reason to use Ruby. Without that you'll just be copying code for the sake of some dumbass tutorial. If you want to make your life easier head over to [the ruby-toolbox](http://ruby-toolbox.com/) and start playing with some gems. There is too much variety in Ruby land to just stick to what the crowd is doing.
It's good to see an overview of the implications of refinements from someone with as much experience as Nutter. I really liked what I read in the refinement proposal, but the performance implications did concern me. It will be interesting to see how this turns out.
My business partner is a talented designer, skilled with css, sass and haml, etc. If I got him interested in this project we could definitely spice up the look. I'll chat with him about it. Thanks for the link to the fork, I will check it out. If you want to reach me off of reddit, steve@aelogica.com is my main work address.
That man is too smart. I like how he had a dissenting opinion on refinements, because I didn't (couldn't) think of ANY of those reasons. Perjaps refinements can come around in a couple years, but I don't think we'll see them anytime soon after this.
People have been talking about selector namespaces for a long time, but I'm not a fan of the current proposal at all. Charles' response seals my dislike.
Yeah, refinements had bad 'code smell' when I read the proposal, it's good that someone was able to come up with concrete reasons why they're a bad idea.
Somehow the subject line made me think of local band [I Love You But I've Chosen Darkness](http://en.wikipedia.org/wiki/I_Love_You_but_I've_Chosen_Darkness) :-)
I find RM terrible for javastcript it seems to get confused with the syntax a lot and doesn't auto format properly. 
Well, I didn't want to reward his whining, but two of us did something productive and actually contributed significant improvements to net/http documentation anyway.
My boss likes PHP and I like Rails. I use PHP...
Oh, I think they smell great. In fact, I think it's a glaring hole in open classes that they can't be scoped. However, I don't want to see someone half-ass refinements. "That open classes can't be scoped is a hole." Discuss.
If you're asking about crawling the metadata: YARD is really two separate utilities: 1. Parse source code and store the data into the "Registry" 2. Iterate through the registry, and generate human readable documentation through templates If you have the yard gem installed, you should be able to use the [API](http://rubydoc.info/docs/yard/0.6.3/YARD/Registry) to fetch values for [@option tags](http://rubydoc.info/docs/yard/file/docs/Tags.md#List_of_Available_Tags) on demand See: http://rubydoc.info/docs/yard/file/docs/Overview.md
I thought he was the "rubinius guy", is he the "jruby guy" too?
I don't think he's involved in rubinius at all.
ah, whoops. Some blog post a while back about benchmarks of Rubinius that he wrote made me associate him with it. My bad.
Yes, that new book is awesome. Its the only book that I've bought 3 editions of now, and this is by far the best. They don't hide the 'magic' as much, and really try to explain stuff as it goes along instead of just assuming that you'll pick up the conventions. 
Yea, for the length it's rather good. There are parts you'll likely skip if you're just trying to get to the content, but its entertaining, short and good. You can go through it in an evening and it isn't a bad starting place at all. 
so monkey-patches have a 'good code smell', you fucking tool?
wait so.....you're showing us it but we can't use it?!.....what's the point?
how come you post so many reddit articles? are you half-bot, or are you actually that much of a reddit nerd? :)
No, contrapositive inference is logically invalid, you fucking tool. Monkey-patching is a bad idea. Trying to make monkey-patching look more acceptable by limiting scope is also a bad idea. It's a bit like early BASIC interpreters making goto look better by using labels instead of line numbers, you're not really addressing the reason why it's bad.
A little from column A, a little from column B...
With Python (*e.g.* Django) I can test a quick website with the simple web-server that ships with Python. (I think it uses [this](http://docs.python.org/library/basehttpserver.html).) Is there an equivalent in Ruby? It helps when I can concentrate on the web-development, rather than on sys-admin tasks like installing, configuring, and starting a more serious HTTP server. ... Oh, I see now. [WEBrick](http://microjet.ath.cx/webrickguide/html/html_webrick.html) ships with Ruby as of 1.8, is pure Ruby, and is used in Rails by default (with `sqlite`). Perfect!
Great article, great discussion - thanks for posting here
Your goto analogy is totally off-point - the main aspect of goto that makes it 'bad design' is that it results in hard to follow spaghetti code, and this is not affected by changing to line numbers. Whereas in the case of monkey-patching the bad-code aspect to them is that they have global-scope -- and this IS totally ameliorated through the use of refinements. Also, nobby, 99.99% of Headius's arguments were raising issues as to the efficient _implementation_ of refinements, not against their conceptual coherency. There was one minor point he made about changing the 'intent' of client code - but the whole intent argument IMO drops off the face of the earth with a typical `instance_eval` anyway, let alone refinements.
"Mc Anally" hahahahha I bet this guy got teased to fuck in high school.
Be sure to read the comments, the discussion there is far more valuable than the initial post.
Reducing the scope of monkey-patching just means that only your code breaks when the code you were patching by unsupported means is changed without notice. That doesn't make it a good idea.
Don't wholly agree with the article, but it's a good point of discussion.
Actually, those steeped in Python lore do not call len a wart when discussing, and admitting, Python warts. More of a considered decision after weighing the alternatives.
I think of mocks as a sort of scaffolding: needing them indicates you're doing something fishy in your code that should be fixed, but they're invaluable to get to the point where you *can* fix it.
Well I'm not quite sure what you're asking, but I would start off by making sure that your second app isn't using a layout either at the application or controller level. That would result in header and footer stuff being appended. If thats not the case, what does the code that prints the status look like? Are you just doing a :render =&gt; :text "status unknown" in the controller? or is the request ending up on a view?
Thanks so much...deleting the layout did the trick. I've got a simple rhtml: Status: &lt;%= @status %&gt;
Yes, in your rails controller, you can have it generate XML/JSON for easy parsing in the respond_to block: def index @objects = Object.all respond_to do |format| format.html # (renders your ERB template of the action's name) format.xml { render :xml =&gt; @objects } format.js { render :layout =&gt; false } end end If you are looking for sending status messages, you can do that too, for example: format.xml { head :ok } format.xml { render :xml =&gt; @object.errors, :status =&gt; :unprocessable_entity } format.xml { render :xml =&gt; @object, :status =&gt; :created, :location =&gt; @object } If you are trying to get your rails app to just render your view without the layout (which would typically contain the elements consistent with every page, eg &lt;!DOCTYPE html&gt;), you can do: format.html { render 'index', :layout =&gt; false }
Very cool. Thanks a lot for spending the time to explain this. very much appreciated.
Sympathy comment/upboat
AFAIK, the closest irb comes to this is: curl -s https://gist.github.com/725338.txt | irb -f but this only plays back and exits
this is great, thanks
I love virtualized solutions like this. Also check out [the TurnKey Linux Ruby on Rails Appliance](http://www.turnkeylinux.org/rails). They have a ton of other appliances for other uses, too.
I'd caught this a few days ago, I have a project that could make use of it. Too bad the C dependency sort of limits some deployment options. libots hasn't seen love in quite a long time, and I've been half tempted to port it to Ruby entirely. It makes a lot of sense in places where Apache Mahout is too heavy but a dictionary key/value count method is not complex enough. 
In case you aren't already doing so, I would suggest looking at using JRuby, so you can interface Java and Rails directly.
Eh, it sounds like it should be firing. I'm assuming you copied the code for the third select, from the first or second select. Check to see if you forgot to change a variable name in the copy.
I didn't c&amp;p the code, so that's not a likely issue. I'm using event-based observers, though I've also tried using the :frequency option.
Post your code.
Posted above.
I have used gurgitate mail. It's nice but I don't know if I would use it again. 
Not too sure there. Try writing the handlers yourself using jquery or prototype instead of using the rails helpers. I always found observe_fieldto be fairly hit and miss, and your code will be a lot cleaner if you separate the js. 
I'm viewing this on my phone but I don't see the third observe_field.
my bad. Added to the post.
 2.minutes That's the problem right there. By patching (spotty) knowledge of times and calendars onto Fixnum, DHH created an insane type system. All so that *number literals* can be used in pretty time calculation syntax. What the heck is a Fixnum if it can be raised to a power, ckecked with a bit mask, and tell you how many seconds are in a [typical minute](http://en.wikipedia.org/wiki/Leap_second)? If `2.minutes &gt;&gt; 9` doesn't raise an exception, what could that expression possibly mean? Refining the circumstances in which patches are applied doesn't make the major use case, ActiveSupport's time tricks, any more sane. 
2.minutes returns a Fixnum, not a Time object, so 2.minutes &gt;&gt; 9 will return 0, since 120 &gt;&gt; 9 is 0. 2.minutes.ago &gt;&gt; 9 will raise an error. Edit: I realize that's not your point, but I figured I'd point it out anyway. To your point: while I agree that people can definitely go overboard with monkey patching, I don't think the minutes syntax is necessarily the best example of that. For certain apps, and I think a task manager qualifies for this, manipulating time is a pretty common thing. What's more clear: Time.now - (time * 60) or time.minutes.ago Keep in mind that those methods work on any instance of Fixnum, not just number literals. 
And this is my problem with the feature in general: it will encourage bad practice by somewhat sanitizing it. (Like Rails programmers don't engage in enough bad practice already.)
If you think that adding methods to Fixnum is bad practice, why not argue for making built-in classes immutable? I'm not going to get into an argument over what's bad practice and what's not, as I think it's largely a matter of taste. But from where Ruby is right now, it can move in one direction (closing built-ins) or the other (reducing the headaches caused by extending built-ins). It makes no sense to remain in place.
Immutable isn't part of standard Ruby yet either, as far as I know. I think it makes perfect sense to not completely prevent extension of built-ins, but also not encourage patching them. Both extremes are bad.
Why would it be bad practice to `refine` built-in class?
Because typically, the internal arrangement of classes is not part of the supported API, and the classes are quite likely to change in a way which breaks your refinement.
My point is that the status quo is unstable. If you have built-ins that anyone can change, then you're going to run into the famous problems Ruby/Rails has had: ActiveSupport's `to_json` method conflicting with the JSON gem's `to_json` method, the [Chainsaw Infanticide Logger Maneuver](http://markmail.org/message/vjex6huhwk6o5wqu) that Zed warned about, and so on. Now, this isn't the end of the world, because people react to problems and fix their code so that things don't conflict anymore, but that's a social solution to a technical problem. You're saying that refinements would make it easy for others to write bad code; but _everyone_ writes bad code in their own particular way, even you and I, and the status quo in Ruby allows _my_ bad decisions to affect _your_ code. _That's_ what we need to fix. To paraphrase the saying, there's never been a language that made it impossible to write bad code.
Your bad decisions affect me as soon as I use your code. Refinements just allow you to hide some of your bad decisions so that they're less likely to come to my attention. I'm still far from convinced that that's a good thing. Basically, Zed should have looked at the quality of the code he was using before he started using it. But his final point is right--monkey-patching is a horrible thing you do as an absolute last resort. My feeling is that this proposed change will encourage it.
I got very turned off by rspec when the rails guys I was working with started mocking everything for no good reason. http://en.wikipedia.org/wiki/Mock_object#Reasons_for_use 
But monkeypatching is only a bad decision because it can clobber someone else's code. As soon as that's fixed, what's wrong with it? If ActiveSupport defines `Fixnum#minutes` using a refinement, then people who think it's a good idea can make use of it, and people who think it's a bad idea can ignore it and use the pristine classes they're used to. "If we give programmers more freedom, then they'll do bad things." To me that sounds like an argument against putting a lock on your thirteen-year-old son's bedroom door. "If we give him privacy, he's going to masturbate." He's gonna masturbate no matter what. Let him wank in peace.
Find the error and backtrace and paste it. Probably has to do with how SQLServer uses a completely different method of limiting results to certain size and offset (e.g. "LIMIT 1, 0" for selecting the first record). Are you using this adapter? https://github.com/rails-sqlserver/activerecord-sqlserver-adapter
oh yea, it crashes. Now i see the problem
It's all too cumbersome and disjointed. Surely there is a better way of dealing with testing. I don't like cucumber at all because you can never get non programmers to write tests so it's a waste of time. rspec is slow as hell. Factory Girl makes you redefine all your associations in your factories. That's just dumb and not very dry. Also having to type t.season {Season.first || Factory(:season)} is also dumb and you have to do it every single association. 
SELECT TOP 1 *...
&gt; But monkeypatching is only a bad decision because it can clobber someone else's code. No, it's also a bad decision because it's more likely to break, and because it confuses people when it results in classes behaving other than as expected (see Zed Shaw rant). I'm not arguing for purity; if I were, I'd be suggesting that monkeypatching be prohibited. No, programmers who want to monkeypatch can already do it. I'm just suggesting that maybe we shouldn't give your 13 year old son a Fleshlight and a subscription to Hustler.
Python has some good math libraries (see another post in this subreddit), that's about the only thing I can think of.
I agree, python often has better libraries for math/science type stuff. The NLTK is great for natural language processing. Learning something new will keep your mind nimble, I say do it. Source: I am someone who knows ruby and python
How did I not know about these? There's tons of them!! Thanks so much!
Yes, it is a very useful tool. Not a perfect language, but a well evolved one. Lots of good quality libraries, excelent documentation, etc etc. It also covers a lot of stuff outside of the web development world (these days Ruby is pretty web-centric). I have to say that if I had the choice I would use Python for most of the tasks on which I use Ruby, but I don't have that choice for now (I work for a mostly Ruby-centric company). Anyway, this is a matter or preference but if you don't try both you will never know which one fits you better. Also, knowing more stuff is better, expand your horizons :) source: I use Ruby daily at my job but sometimes I use Python. On previous jobs I used Python full time (I have worked with both languages for 3+ years each and know them well)
I find the urllib2 library in python better suited for reading remote files. See http://www.reddit.com/r/ruby/comments/dr1ip/ask_rruby_read_x_amount_of_remote_pagefile/
Try it. Personally, I prefer Ruby (I love both), but Python has GREAT support for math/science/frontend stuff.
Yes. Python has some cool concepts, nice frameworks and is very capable. Knowing it will make you more employable, and probably a better ruby programmer. It's scientific, NLP, machine learning (pybrain) and mathematics functionality rock. Ruby is amazing for web work, but python really allows a few extra things. You can also mess with PyGame then. 
Can anyone recommend a good place to start reading, for a mildly competent rubyist? Last python tutorials I read were long rambling stream-of-consciousness console sessions, whereas I work best with top-down approaches. 
cool.....but hoping for more *stuff*
You might find this interesting: [Python vs. Ruby: A Battle to The Death](http://vimeo.com/9471538) The talk is actually targeted at people interested in ruby who already know Python, but he does a pretty cool comparison of the two languages which might help you anyway. 
Seems at this point there's a lot more GTK apps written in python too. Sometimes a library you want to use leaves you no choice. In all honesty, every time I use python I curse. I love simple things in ruby like String.length and Array.length, and am always frustrated when some functions sit in the root namespace like len()
"Should I learn X?" Yes. But don't stop what you're already doing, unless they're bad habits.
Dive into Python How To Think Like A Computer Scientist Programming Collective Intelligence (not a python instruction book, but if you know ruby you'll learn both at the same time) There's also the new Learn Python the Hard way, which I've heard good things about 
I think learn python the hard way is more for absolute beginners. The entire thing is there to force you to start writing code until the thing "clicks"
Python is very popular and a generally good language. If you're looking for a job, there seems to be more jobs in python than in ruby (at least from what I've seen). I've written in both and can still write python, although I enjoy writing ruby whereas python feels more like work. My two major grievances with python are that they still insist that you don't need a case statement (hogwash!) and the whole indent thing instead of explicit statement closures - I'll just never get the hang of that. Ruby takes a page from perl where it leaves you free to express code in different (while still correct) ways. Python has the philosophy that there's always a single right way to do things. This is of course a personal preference, since both have their merits for different kinds of people, but I personally like being able to write something the way it makes sense to me. My advice after seeing your comment below coloring yourself as a "mildly competent rubyist" is to stick with one language until you're good enough at it to get paid for it (whether or not you actually do get paid). Whether that's ruby for you or python or something else is irrelevant (unless it's .net, then no). I actually cut my teeth on classic ASP and Access/VBA. For my age at the time I was making better money doing that than most of the other kids in high school and college. I really didn't get into open source languages until I got into linux, but picking up a new lanugage was easy when I took those concepts I learned on the dark side and applied them to learning something new. Where I see people getting hung up often times is learning all the fashionable languages at the same time so they can tout the size of their e-penis to their friends. Don't be that guy, learn one language, learn about algorithms and big o notation, get good at programming in general, then venture out into another language. If you're doing web stuff, that second language needs to be javascript. It's unfortunate, because you don't have a lot of the tools you have in better languages like ruby or python, but if you're doing web dev it's reality. Either way though, it will be a breeze when you are already a good programmer.
I am learning python right now so that I can use the matplotlib stuff. It is really similar to Ruby, but it is a bet less consistant in that not everything is an expression with an l-value. There are no mixins, the syntax for things is a bit \_\_ugly\_\_. Classes cannot really have data hiding, ie private members etc. There doesn't seem to be such thing as constants. Lambdas can only have one expression. Numpy is quite good, I really like using the pylab and matplot lib stuff though. There is complex number literals. The indent based syntax is interesting, I'm having a bit of fun with that, it is nice to not need to type end to close all blocks. At first it was difficult to know which version I should use, 2.5, 2.6, 3? I settled on 2.6. All in all it is disappointing and I don't see why people would use it other than the good math libraries and plotting.
The answer to the question, "Should I learn [language X]?" is always and invariably YES. Sure, there's not a whole lot of difference in the way that Ruby has you think and the way that Python has you think. But still, Python has its own idioms, idiosyncrasies, and quirks that will influence the way you code, just as Ruby does.
That might be true. I haven't picked it up yet as I haven't expanded to Python fully, although I very well may soon for the math, science, and nlp libraries. Porting many of those libraries is next to impossible, and the python modules for them are in fact using FORTRAN code (at least for the math ones) that was written and tested many moons ago to do the job. Not a weekend hackathon to get the stuff usable on a serious level. You want this stuff to be able to work perfectly if you're doing serious math modeling. 
You should never stop learning. Learn Python for the things it does better than Ruby. Learn Python to come to realize how much better Ruby is in so many ways. As others have said, Python has some much more mature libraries (math, scientific, mostly), but is a pretty bad fit for anything web related. A language with syntactically significant whitespace doesn't mesh well with templates or with HTML where whitespace is insignificant. But mostly it's good to learn at least a little bit so that you understand everything better. C and its pointers are really painful to understand at first, but once you get them, you both appreciate that languages like Ruby and Python hide anything having to do with pointers from you, and also understand what is really going on under the hood. Python and the first parameter to its object-oriented method definitions, called by convention (and only by convention) self, helps you understand what is actually happening under the hood in most OO implementations, then appreciate that Ruby makes that a more clean interface. Python's built-in doc strings, techniques for only importing small things from packages, etc. lets you realize that there are other options out there, but also the potential pitfalls of using them. Learning a statically typed language like Java lets you appreciate compile-time checking of certain things, but also lets you realize how much freedom that takes away from you. 
I know they work on any instance of Fixnum, not just literals. My contention is they shouldn't work on Fixnums at all. Forget Ruby and just sit back and think a bit. The concept "two minutes" is not a number, such as 120. It's a number and a unit. In fact, it's an interval between two points, the arc between two marks on an analog clock. The concept "12:00 AM January 1, 1970" is not a number, such as 0. It's a point. You can point to it on a calendar, on a clock. A method such as `minutes` should be a member of something like a TimeIntervalMultiplier class (*not* derived from Fixnum), and it should return something like a TimeInterval object (also not derived from Fixnum). Then the `ago` method should be on the TimeInterval object (not on Fixnum), and it should return something like a TimePoint object. This way, nonsensical operations like division, absolute value, and bit shifting are not lurking in the interface when you're coding up some time &amp; calendar calculations. The first step would look ugly, but the rest of your code would look like usual ActiveSupport fare. two = TimeIntervalMultiplier.new 2 foo = two.minutes.ago Meanwhile, the rdocs (and tab-completion help) for Fixnum, TimeIntervalMultiplier, TimeInterval, TimePoint are clean and clear. There's no time stuff in the Fixnum class and no bit-shifting nonsense in the time classes. Oh, and the time classes have their own sensible `to_s`, `to_json`, `to_yaml`, whatever methods. Wouldn't it make sense for `two.minutes.to_s` to output "2 minutes" instead of "120"? **Edit** Staring at the ActiveSupport code, I'm glad to see that `Numeric#minutes` returns an `ActiveSupport::Duration` object. But I still say the `minutes` method should be a member of some class other than Numeric. **Edit 2** On further investigation, I'm less happy. `ActiveSupport::Duration#method_missing` delegates to Numeric (Fixnum, whatever) methods. So, even though Duration doesn't inherit from Numeric, it sneakily performs nonsensical Numeric operations, e.g., `2.minutes ** 6.days`. Oh, I give up. This is tiring. 
i learnt python when i was getting into blender scripting. (these days, i use it at work too). a lot more projects use python as a scripting language than do ruby, so it's well worth having in your toolbox.
&gt; But monkeypatching is only a bad decision because it can clobber someone else's code. As soon as that's fixed, what's wrong with it? It can result in a class which makes no sense. Numeric objects which have methods to do calendar calculations, shift bits, figure out my income taxes, and perform RGB-to-HSV conversions are no longer numbers. They're all-singing, all-dancing poodles on David Letterman's show. Plus, the Numeric rdocs (or tab-completion help) would be too huge. Even if they're not huge huge, the method names are all just dumped in alphabetical order. The all-singing, all-dancing Numeric would make a bit more sense if documentation and introspection tools could categorize the methods (elementary arithmetic, bit-wise arithmetic, calendars, taxes, colors, formatting, serialization, introspection, metaprogramming, etc.), but they can't. 
&gt; Because typically, the internal arrangement of classes is not part of the supported API Who says you can't use only public API when you do refinement? Refinement is not re-opening the class, it doesn't interfere with internal of the class. It doesn't alter behavior of any callee outside, `using` lexical scope. &gt; and the classes are quite likely to change in a way which breaks your refinement. Refinement can also rely only on public API. How is that going to be more fragile than writing the same external method that rely on the same methods of the class? Are you sure you are not mistaking refinement for monkey patching? 
&gt; Who says you can't use only public API when you do refinement? If you're using the public API, why not just subclass?
I'm using Python because of PYMT, a very well written multitouch library. There is nothing like this in Ruby. Apart from the libraries, Python is a nice language with less metaprogramming than Ruby, but more strictness and explicitness. Could be better for large teams.
More useful than ruby. 
Let me clarify: identify something that's wrong with monkeypatching that _wouldn't_ be solved by refinements.
I am a Rubyist who learned Python and you should definetely do. There are big sectors where there is no overlapping. Python is much better for big calculations and scientific programming. I also tend to like the whitespace conventions and the no black magic.
Because I can't tell the third party library that created the object to create my subclass instead. And that refinement may only be useful in some scope, I can't expect the library to include every possible method that may be useful in only some small context. Again, are you sure we really are on the same page on how refinement really works?
For those of you who want to do integration testing but don't like Cucumber, you should take a look at [steak](https://github.com/cavalle/steak).
If you're getting a library to create its own objects using your code, you're unlikely to be using the supported API.
If you want to deliver a message across town, don't train a poodle to ride a bike and hand it to the poodle. A poodle on a bike is not a courier, it's a confused poodle doing a stupid pet trick. Therefore, it's too hard to train for variations on message delivery. But back to real-life Ruby. ActiveSupport "trains" Numeric to do time and calculations by patching in some methods that do a lot of naive 60\*60\*24 stuff. But not every day is 86400 seconds, not when daylight savings comes and goes. Like a poodle, it's not really up to the task. What if you want your app to handle the Hebrew calendar? Not only does every Hebrew day start at a different time, they are all slightly different lengths. And Hebrew has a different concept of hours. What if you need your app to correlate Gregorian dates and times with Hebrew dates and times? Are you going to try to swap different definitions of `#day` into Numeric? Are you going to patch `#gregorian_day` and `#hebrew_day` into Numeric? Or what if your app needs not only conventional calendar days, but also "business" days? How long is each business day versus each calendar day? How many seconds are there between the start of business on Friday and the next business day? Refinements won't help your Numeric or Fixnum handle more than one notion of times and dates. Being able to specify how much of your Numeric API gets exposed is not the same as being able to use specific classes for specific calendars. 
Some questions after quick observation. Why would you need a rake task to install it into a Rails app? Is there something specific to the Amazon Product Advertising API that would need you to do so (sorry, haven't looked deep into it!). Or should I be able to add it to my Gemfile and be good to go? I also see your project is a fork (https://github.com/robacarp/amazonian), have you considered a pull request back to the original project? A link to the Github repo from Rubygems.org would have been nice too (for quick inspection of the code). As for testing, simply use what you're familiar with and start simple and granular and go from there. Good luck!
I was originally going to do a pull request and implement only some higher level functions for the API. However the scope of the project has grown and spidered away from that in such a way that very little of the original code still remains. Is it still a good idea to submit a pull request? Thanks for the tip on the link, I hadn't noticed the 'Edit' link on rubygems.org for filling in links to stuff like documentation etc. As far as the rake script, it'd just generate the initializer file. The API requires a key/secret-key pair for each account and so the gem needs this to be set. Thanks for the tip.
Many public API of an object can be said to be just a combination of other smaller public API. Have you used C#'s extension method? How do you think that works? What's wrong with it in your opinion?
black magic? Really? 
http://guides.rubyonrails.org/
So why not do a generator?
My angle is this: -- Why would you itch for another language than Ruby? I think there are two big reasons: (1) Math/science libraries; (2) Lack of true threading. So my answer is . . . JRuby. I can extend all of the heavy math/science libraries I want, and keep Ruby syntax. When I need better thread control, I get it from the JVM. Again, I get to keep all of my Ruby syntax, but I get access to the goodness of the proven Java libraries. About the only thing I would want from Python are the generators. And whoever said PyGame: That's true, too. 
Yea that sounds very cool. Let me know if you guys are interested. I always try and have a couple of things going anyway :D if you'd like to reach me I'm at aamador@derosetechnologies.com. Always good to find like minded people around the tubes. -Arian
I don't use C#, and I don't see what the comment about combining smaller APIs has to do with anything.
And Heroku's take on acquisition: http://blog.heroku.com/archives/2010/12/8/the_next_level/
Amazing.
It was inevitable that Heroku got bought, but it saddens me it was Salesforce. Heroku is so awesome and brilliantly executed. I have my doubts Salesforce will maintain that level of quality in the long run.
ew.
If very little of the original code exists, I would perhaps create a new gem that caters specifically to the needs of this specific Amazon API. It would also be a great opportunity to exercise your TDD skills. Bootstrap a new gem with Jeweler, start writing some tests (and watching them fail) and begin writing your implementation. Come up with a new name for the gem, and push it up to Rugygems.org. If you think the community would benefit, post it to [Rubyflow](http://rubyflow.com/) or send it to the guys over at the [Ruby5 Podcast](http://ruby5.envylabs.com/) and enjoy being a contributor to OSS :).
Had exactly same feeling when I first read it. But I guess it was inevitable and let's hope SFDC won't bloat our beloved Heroku with enterprisy overload... 
Oh crap. Time to escape Heroku.
I can suggest you to take an online course such as: http://rubylearning.org/class/ For the point #3 I suggest you this online tutorial: http://railstutorial.org/ruby-on-rails-tutorial-book , you will learn to create a website using ruby on rails and also how to use git and heroku.
http://1.bp.blogspot.com/_t4C3ygzAGNk/SZjiY5O31AI/AAAAAAAAAIU/WYngW2_RG98/s400/wtf_is_this_shit.jpg
**Thank you!!** This is exactly what I'm looking for. Have you personally tried the courses at the http://rubylearning.org website? Git is something I'm somewhat familiar with, but would love to learn more. This helps a lot! Thank you!
I think Heroku is really awesome and brilliant for a narrow band of apps, but as soon as you need to start evolving your product it quickly becomes a bit unwieldy. I find myself spending 6 hours on what should take 1 because of the restrictions they've had to put in place to get it all snapped together. Still, this is interesting new to say the least.
Yes, I tried it, the course is two months long, you will have many exercises to do and to discuss in the forum with the mentors and other students. You need at least two hours per day to study/complete exercises but surely it worth it :)
Awesome! I'll definitely take a look at that. Do you have any sample work you've done you'd care to show? I'd like to see what all you've been able to do after doing that course. Thanks again!
definitely do railstutorial.org that helped me a bunch. once you get through that and understand the concepts, make sure you have a project in mind and use the railsguides and railscasts to help you figure out the "how do i do this in rails?" as well as having the Rails 3 Way by your side as a reference.
Awesome, will do!
I wouldn't bet on Salesforce corrupting Heroku. I'd bet more on the process running in the other direction. The heroku folks are *scary* smart.
 nooooooooooooooooooooooooooooooooooooooooooo!
As a production unix admin at Salesforce. I'd like to say that we are also scary smart =)
I worked with the heroku guys. You guys may be smart and competent, but when I say scary smart, I mean a different level. I'd invest in whatever they were involved in sight-unseen.
What a retard.
So, what did you go with instead as a superior solution to whatever problem you're talking about?
Salesforce.com please don't fuck Heroku up. 
I had the same problem with heroku. I lost hours getting sass working, and their json pure dependency was failing silently with early versions of rails which was another 6 hours of pain. In the end I went with an ec2 instance and haven't looked back. Sure I don't get push button scalability, but ec2 does have some pretty nifty tools in this area. That said, Im really impressed with heroku, it just wasn't the service for me
Yes. What's the next question?
Is contributing to projects usually this easy? I want to start contributing to a wide variety of projects, but I don't know where to even start. How does github work? I've looked around but I think I need someone to explain it to me.
I totally agree that they're _scary_ smart... I just think you underestimate the corrupting force of The Enterprise™.
I don't think you should get too bogged down with Rails, it's a great framework for making large web based systems but it's probably a bit "too much" for someone wanting to start out with grasping what they can do with Ruby as a language. I'm currently in a similar position to you in terms of just starting out. I got the pick axe book which is pretty great
I'm curious if there's any source available for this. Perhaps I missed it in the article, but it would be interesting to see.
we made a mini text based adventure game, but only as a exercise. 
[Sinatra](http://www.sinatrarb.com/), [Sequel](http://sequel.rubyforge.org/) and [DataMapper](http://datamapper.org/) might be good for the website project.
You don't need to use github to contribute to Ruby, that's just Mike Perham doing the usual git fanboy thing. Ruby's main development is in SVN. You can just check out the code, make changes, then use svn diff to produce a patch file. Create a ticket in Redmine, describe what you changed and attach the patch, and the appropriate person takes a look at the changes and evaluates them for inclusion. (I also submitted a bunch of improvements to the net/http documentation last week.)
I don't know, the Salesforce people seem quite unlike Oracle.
Ruby has true native threading these days.
Using github is not the only way to contribute to ruby, it's just what a lot of ruby developers are used to. Github has [some pretty good documentation](http://help.github.com/) on how to get started with git and github if you're curious.
I can't be the only one upset by this. Salesforce.com makes oracle look like google. They are run by suits to the extreme.
&gt; I don't use C# You don't have to actually use it to at least know what it is. It's just a way of broaden your knowledge and actually seeing pros/cons of a feature. &gt; I don't see what the comment about combining smaller APIs has to do with anything. Because, these "convenient" methods made of combining smaller API are still best belong to that same class; Object should be the one to know how to act on itself. But the original author couldn't possibly have written all possible convenient method, `refinement` is a manageable way of putting methods where it belongs. Again, do you know the different between re-opening the class in Ruby and using `refinement`?
Infinite upgoats activate! Damnit, that actually doesn't work. 
Gotcha, where are you in the whole learning process and how long ago did you start? Any other recommendations or tips?
Thanks for the awesome suggestions, ill definitely give them all a look!
This is gonna be exciting. Either this is a good thing, or Im moving away from Heroku.
Just came here to see why some people are so pessimistic? The fact that Salesforce can compete with giants like Oracle and Microsoft with ease means a lot.
Time to start praying that Heroku will be at least 50% as awesome as it is now.
#1 I'd definitely suggest you go through Ruby Koans http://rubykoans.com/ They're set of small excercises that teach you small specific things about the Ruby language. 
Could someone explain what CI is to me?
[Decent explanation here.](http://www.martinfowler.com/articles/continuousIntegration.html)
Hahaha, this is awesome. Actually I've seen that Koans thing before and will give it a try. Thanks for your over joyed/shouted response.
Well, I can get rails app deployed from scratch to Rackspace in 15 minutes now. That's launching an instance, creating the rails app, getting a db running, and setting up my tool chain on the box. I don't have to deal with read-only file systems, lack of fine-grained cron, connecting to a db with other services, etc. etc. It's more effort on my part to scale up, but most of the cloud services have tools for helping to scale automatically. It just requires you to do some more prep-work. Heroku is a very fine product, until you want to go off the ranch, and then you'll waste a lot of time figuring out how to get around their system. 
If you like Koans, you could also give a try to Ruby Quiz http://rubyquiz.com/ It contains over 150 challenging problems in Ruby. There's also whole book devoted to the Ruby Quiz by Pragmatic Programmers http://pragprog.com/titles/fr_quiz/best-of-ruby-quiz You might get some kind of malware warning when going to the Ruby Quiz site. I'm not sure if that's Google's or the site's owner fault, but it still works fine for me.
Oh sweet, good to know about that malware thing. I'll check into all of these things, definitely will have the time to do so in the next couple of days. Thanks again!
I'd try: reverting your PATH to its original value, and [installing rvm](http://rvm.beginrescueend.com/rvm/install/). Refer to the rvm docs on how to install and switch rubies. Remember to put this at the end of your .profile: if [[ -s ${HOME}/.rvm/scripts/rvm ]] ; then source ${HOME}/.rvm/scripts/rvm ; fi 
I second this, the hivelogic tutorial was the way to go right up until RVM was released.
I'm still waiting for a good example of why refinement is needed rather than subclassing, that uses only supported APIs of the class being refined.
And don't forget about [homebrew](https://github.com/mxcl/homebrew/wiki) for everything else.
Standard `String` class only has method to do `downcase` and `UPCASE`, but not `CamelCase` or `Title`. * The latter two methods deserve to belongs to `String` class as much as `downcase` and `upcase` do. Still the standard doesn't provide it. * You want to use it on string return by third party, too. Even if it's all your code, requiring code to return subclass of `String` is just plain stupid. * There's no need to reach in to internal of `String` class to implements both methods. I really can't believe that you never see class with "supported API" that can be implemented in term of its smaller subset of "supported API". They are there because they best belongs to that class, and if the methods you are writing also best belongs to the class, why not make it so?
Undo your that path stuff. 1) The xcode on the disk is outdated. Huge download. Suck it up. 2) macports - for SQL servers, unix tools, etc 3) http://rvm.beginrescueend.com/ - Quick Install. Done. 4) rvm install ree 5) gem install rails
If you ever really mess something up in your bashrc, you can do something like **/bin/bash --norc --noprofile** to start up a new bash instance that won't read from your bashrc or profile. From there, you can undo the changes to your init files.
Fix your PATH variable. Open .profile file in some text editor and make your PATH look like this: `export PATH="/usr/local/bin:/usr/local/sbin:/usr/local/mysql/bin:$PATH"` otherwise /usr/bin /usr/sbin etc will not be in path and that's where most of the important commands are located (including `ls`). That's why your terminal is complaining. 
Based on my brief experience, Sage, NumPy and SciPy are rather nice, and I don't know of any equivalent Ruby projects that are as active. I see others are mentioning PyGame, which is great. This list can go on and on, but it sounds like you already want to learn Python, so I would just give it a try and see where it goes. I can't personally vouch for it, but Zed Shaw's online book has a handful of exercises that may be worthwhile. http://learnpythonthehardway.org/index
In that situation I'd just write camelcase and titlecase methods that took strings as arguments and sat in the scope of my own code. OO is just a tool, not a religion that must always be followed.
One of many problems with Net::HTTP
The best way to cure Net:HTTP is to kill it. You know, homeopathy.
From a pure language standpoint, I think Ruby is a little more expressive, and it's easy to read and understand the intent of a lot of the code you see, although the many DSLs and metaprogramming going on make the learning curve a tad harder to write against those libraries. Python also lacks the approachable gem/rake/bundler/rvm tools. Similar stuff exists, but a) the compelling need for a RVM-like tool never really existed with Python since it never had the 1.8-&gt;1.9 performance gap, and b) pip/virtualenv do similar things, they just aren't quite as noob friendly. Python is a little more ubiquitous, and some version comes preinstalled on almost every linux distro from the last decade. It also comes with Tkinter preinstalled, allowing for small\* GUIs to be built and deployed almost anywhere [*I wouldn't try any large scale app GUIs with Tkinter though]. Python Image Library also has no 1:1 Ruby counterpart, although mini_magick covers many aspects (but feels a like a bit of a kludge). If you play with Arduinos, pySerial is a little more straightforward to use than ruby-serialport. Python is also a little more widespread as a backend scripting language for other tools or software packages. ESRI GIS software has Python bindings, AppEngine has them (although you can hack Ruby onto the JVM there). All of my stuff is pretty specific use cases though. Without an obvious need, you'll find it difficult to find a reason to learn Python while already knowing Ruby (and vise-versa). The biggest difference to me is the communities around each. Python's feels a little more serious and business oriented and a little more slow moving, while Ruby's is a little more playful and experimental, where users are quick to adapt new things. Also, for learning the language as someone who already knows programming, I like Dive Into Python.
Perhaps we can dilute down a good HTTP library and insert lines of it into Net::HTTP one at a time.
Probably not going to happen, there is too much code already locked into it's API. This is an easily fixed problem, but what's more shocking is how long it went unnoticed.
&gt; I'd just write camelcase and titlecase methods that took strings as arguments and sat in the scope of my own code. Refinement also only sit in the scope of your own code. Again, you don't even seems to know how Refinement is supposed to work. &gt; OO is just a tool, not a religion that must always be followed. Sure, but then what's wrong with using it if it works. ADDED: I think I'm gonna stop this now. There's no point in discussing with someone who doesn't understand what exactly is he arguing against. May be this might have been better if you didn't sidestep the question when I ask if you know the differences between re-opening the class and refinement.
This doesn't say anything. There is no information anywhere in this article except a link to Wikipedia.
So... all that long reply and you didn't answer his question at all. Yay, not using monkey patching will magically make your time calculation time-zone awared with Hebrew calendar support. His question was not "what is the problem *in the whole world* that refinement can not solve?", he asked "what was the problem *with monkeypatching* that refinement doesn't solve". If you convenienty took it to mean the former, you might as well just say `refinement` cannot solve halting problem.
&gt; No, it's also a bad decision because it's more likely to break Not if this monkeypatches also only rely on public API. &gt; because it confuses people when it results in classes behaving other than as expected (see Zed Shaw rant). It behaves differently only in the scope that use `refinement`. There's nothing unexpected about asking for different behavior and then getting that behavior.
For crying out loud, man. I've already answered over and over. 
Ok, please point me to that &lt;delete&gt;post&lt;/delete&gt; part.
&gt; 512MB or larger lol.
Arg! No, you can't simply do this by default! When you do this, Net::HTTP uses a blocking DNS resolver via TCPSocket.open - if you have any DNS problems, or the people you're looking up have DNS problems, your site will block effectively forever, because Timeout does not work on system calls! First you must fix Net::HTTP's DNS resolution to use Resolv.getaddress instead of IPSocket.getaddress, then fix it so that *doesn't* fail verification (difficult at best!), THEN you can require VERIFY_PEER. Perhaps I shall submit a patch to the gem to this effect. Or at least an open ticket. Edit: ticket opened. Edit mark deux: apparently resolv-replace is the solution for this problem, thanks Dr. Brain.
thank you. assign to eric hodel to help move it forward faster.
kudos for actually answering his question with a solution!
And then your refinement clashes with a change made to the original class, and you have a problem. Yes, the problem is limited in scope, but it's still a problem.
Right, anyone who disagrees about the desirability of refinement must not understand it. Sure.
My favorite is the reference to Konata from [Lucky Star](http://api.rubyonrails.org/classes/ActiveModel/Serializers/JSON.html)
No kidding. I wonder if it's really a bug in Ruby or if it's actually yet another quirk of OS X that has to be worked around. I also wonder if it was fixed in p302.
How is that any more problem than I make a subclass with new method and then the super class is extended with new method that has name clash with the subclass? And the only problem refinement will have is that you can't call the clashed method from the refined scoped. It doesn't affect any code outside the scope. That's even better than subclassing.
No. Anyone who thinks refinement will cause problem to other code that didn't use it or that it will break when internal of the refined class change must not understand it. Ok. So you understand it. Please tell me how it is different from monkey patching and what is its pros/cons.
According to DHH at RubyConf, there was some guy on Reddit who was criticizing second(), third(), etc, so he put in forty_two() out of pure spite.
Explaining why refinement was good, you said subclassing wasn't sufficient "Because I can't tell the third party library that created the object to create my subclass instead," -- implying that you *would* be able to get some other library to create your refined versions of classes instead of the versions they are expecting. Surely that contradicts the idea that refinement doesn't affect any code outside your local scope?
I don't understand your middle paragraph. Which "it" needs to be fixed? Net::HTTP (and the rest of Ruby) can be switched to Resolv by require 'resolv-replace'. Can you link to the ticket?
criticizing on what basis? 
cluttering the language. If memory serves the tale goes that all the way to the 10th ordinal (as in tenth()) were being proposed and that idea was shot down with the logic of where would you stop? Why not the eleventh? Then why not the forty_second()? I'm not sure how much it clutters the language; but if you really want it you can just add it in on your own anyway.
is resolv-replace in the stdlib? I can't use any code that's not in the standard library. Maybe that would solve my problem, I will take a look. Edit: that actually looks like it would solve the problem quite nicely. Thanks, you've solved a problem that's been a pain in the ass for a long time.
resolv-replace is part of the standard library. I like Resolv, I've run millions of parallel DNS requests through it and added a bunch of English documentation.
that they were unnecessary, and to just use self[1], self[2], etc. DHH said they *were* unnecessary, but he liked them, and then put in forty_two() just because he could.
Yeah, as soon as I googled it I realized it did what I asked for, but via monkeypatching which makes me unhappy. The constraints for the gem I maintain are essentially theoretically zero impact on the app when you install it, so I'm not sure what effect resolv-replace would have across all the different apps. Sigh. It does seem like the ideal way to do it - I'm honestly fairly surprised that there isn't a 'native-resolv' file you can require to do them in pure c, and have the default be pure ruby.
See part 2
thanks for the replies. I personally would rather just read array.second or array.third, it's just that much easier on the eyes.
Where is part 2? Write something about how to handle loops with a DSL.
If you install a newer 1.8.7 this bug goes away.
&gt; Explaining why refinement was good How can I explain how car is good when in your mind you still think that car works by drinking children's blood? Language has pros and cons depending on how it works. Explaining how some feature is good need knowledge on how it works. How can I talk about the benefit if you have wrong picture things work inside your head? &gt; you said subclassing wasn't sufficient "Because I can't tell the third party library that created the object to create my subclass instead," -- implying that you would be able to get some other library to create your refined versions of classes instead of the versions they are expecting. No. It doesn't imply that. Your parent reply of that quote is the suggestion to use subclassing instead. That's wy I said your suggestion doesn't make sense because you can't control the class that the third party will create. So your own suggestion of "why not use subclass" is useless, you don't even realize your suggestion didn't work. Refinement doesn't mean third party code will see version of classes they are not expecting. It only implies that I can see the new version, not that anyone else will. There's the proof you don't actually know what refinement is.
&gt; No. It doesn't imply that. Oh, so you were throwing out irrelevant objections to subclassing which also apply to refinement? I think that proves you're not interested in honest discussion.
Yea, i find the metaprogramming on that gets a little hairy for beginners. 
I remember that thread. I thought the complaints were especially ignorant considering this is a common convention in the lisp world as well.
&gt; Oh, so you were throwing out irrelevant objections to subclassing which also apply to refinement? Ehh... what? What are you talking about? What also applies to refinement? This? &gt; ... implying that you would be able to get some other library to create your refined versions of classes No. *Refinement is not creating new class*. I getting to see the refined version of an object doesn't implies that the refined object is actually created differently in the third party code. Seeing the object differently is not the same as getting it to be created differently. What's so hard to understand about that? &gt; instead of the versions they are expecting. No. They still have the versions they are expecting. Only I see the refined version. Now say again. What objection in that quote which applies to refinement and I threw away?
Isn't it a little different? The Lisp functions first, second, third, etc. are to provide a way to easily access List elements (syntactic sugar for legacy functions car, cadr, caadr, etc). Ruby Array elements can be easily accessed by using the subscript operator and element index. That said, since the Rails methods in question *are* in ActiveSupport::CoreExtensions::**Array::Access**, it is perfectly logical to have *Array* convenience methods in it. 
You could view the lisp functions as friendlier versions of car, cadr,etc., or you could view them as sugar for list-ref (which is equivalent to the subscript operator, although involves a bit more typing).
At least it isn't Bob. I still do not want to know what that girl is thinking. It probably cannot be unseen. But then again, I come from a Python background, so I do know how to use a collection of vaguely related pop culture references as programming language and API documentation.
This isn't exactly an answer, but a client recently had a reason not to use it, his reason. That php is still more widely accessible and if he needed to package his app php would allow for least amount of friction for their deployment.
At some point you have to take a leaf out of Idiocracy's book. &gt; After several hours, Joe finally gave up on logic and reason, and simply told the cabinet that he could talk to plants and that they wanted water. But seriously, you could argue that RoR is forward looking and that PHP is so commonly used because, in the past, it was the best option available, but as time progresses it is becoming an increasingly outdated technology that is still being supported only as a matter of legacy. Anyway, good luck with convincing the customer to do what is right.
This is indeed true, but I mainly targeted this quesiton for customers who don't already have deployed applications on one platform, since when you convince someone to migrate to a different technology and it works out badly, you're the one to blame.
You should definitely try it. Python and Ruby are constantly fighting and both of them are very strong. I personally like Ruby for all the syntactic sugar and metaprogramming. I like the DSLs and expressive code over Python's explicitness. On the other hand, Python forces more constraints on you, which can make you a better programmer. Every language has it's specifics that might give you unique perspective on programming in general. If you're already comfortable with Ruby and enjoy it, try to just search for things that work differently in Python and see if you prefer the Python's way.
http://twitter.com http://groupon.com http://livingsocial.com http://gowalla.com http://yellowpages.com http://attinteractive.com http://43things.com http://basecamphq.com http://hulu.com http://scribd.com http://justin.tv http://slideshare.net http://github.com http://shopify.com http://ravelry.com http://customink.com The list goes on and on. Obviously everyone is not using PHP :)
The biggest issue I could see from a business standpoint is support after the fact. They're probably worrying about you getting hit by a bus (or even just leaving the project) and, suddenly, the fact that their product is written in a language/framework that not "everyone" is using is now affecting their business. I've sold folks on Rails/Sinatra before, and it's getting easier to do, but I've had to approach it from a business standpoint more than a technical standpoint.
My main arguments would be: Ruby is a terse language in which you can express business logic in a understandable and maintainable way. Ruby is known for its emphasis on QA and has many testing tools. I would argue that Ruby/Rails is still growing and PHP has a head start. Furthermore, there are a lot of great products for PHP and its easy to get started with. So if you have a generic problem to solve, go with a generic solution, that might well be in PHP. If you have a complex, unique problem, I would go with Ruby. Disclaimer: I focus my answers to my own likes and dislikes. I want to solve complex and unique problems and I like to do it in Ruby. I don't like implementing some CMS or configuring a blog. If it's something I don't want to do, I would give up the job more easily. I think PHP and Ruby are equally good at making web applications. They are both great tools for the job. It's success lies in the hands of the person yielding the tool.
&gt; If IE6 is so bad, how come everyone is(was) using it? &gt; If Vista/Windows 7 is so good how come everyone is(was) using XP? A bit off topic but that kind of cycle repeats itself with most things.
Also, it's a lot easier to find a host who'll support php over ruby. There's a lot out there now who support Ruby on Rails, but PHP is very pervasive. 
&gt; I think PHP and Ruby are equally good at making web applications. They are both great tools for the job. It's success lies in the hands of the person yielding the tool. I think this right here is key. I've met a lot of terrible PHP developers and a lot of terrible Ruby programmers. The skill of the people don't have much to do with how well a language could tackle a problem imho. I think if there is a clear delineation where one toolset clearly prevails over another for a given task, then it's not really much of an argument to make. If it isn't that easy to make the decision for a task, then I would vote for the client's wishes. If you disagree, then move on - at least how I generally approach it.
Is this for a new project, or is this working with an old codebase? I would point out that not everybody is using PHP. In fact, for custom websites, PHP is actually not that common at all, simply because PHP targets people that have a website but don't know the first thing about building/maintaining codebases or deploying software. Witness the ease of installation of PHP programs on shared webhosts. If you're making a project that targets an end user and requires no knowledge beyond how to put files on a server using FTP, PHP is great. If, however, you want to do something beyond that, it's best to use better tools, of which Ruby on Rails is but one example. Of course, if you're working with an old codebase in PHP, all of these arguments go flying out the window.
"I can do your project as specified for $X in Y time, but in my expert opinion you have over-specified some technical details. If you remove the extraneous technical requests, I can implement your business requirements faster, better, and cheaper." Pick $X high enough that if they chose to stick to their guns on awkward implementation details the project will still be fun - even in PHP - because you can't believe how much the customer is overpaying.
Why have the argument? There are plenty of other clients.
&gt; If RoR is so good, how come everyone is using PHP? They don't know any better ;-) 
Sure, but odds are, the host that supports Rails is actually enthusiastic about it, and will put in effort to do a good job of supporting it properly. On the other hand, odds are the host that supports PHP is competing mainly on price, and is trying to get the biggest number of customers possible--and will do a half-assed job of supporting PHP. My place of work is the latter type of business. No Rails support, and *decidedly* half-assed PHP support. But at least we have a lot of customers! And that's what the share-holders care about.
*"Many years ago, PHP was the best choice. But it's snowballed ever since, not because it's so great, but because non-technical people see others using it and assume it's the best solution. I believe otherwise, so if you're dead set on using PHP, I would have to recommend you find another developer."* It'd probably be best to judge how stubborn the client is *before* including that last sentence. It doesn't give a good impression if the client is just asking an honest question.
I don't use Jekyll; the hacker in me says I should, but I'm addicted to Posterous for uploading videos and pictures. But this looks like a really cool gem idea. The only criticism is that you should probably rename that test file and start testing for real. :-)
Yeah testing has always been my weak point. Still getting the hang of it.
Tell them "I can do PHP, I could do this project in PHP for $X. The reason I use Rails is because I can do the same project in Rails for $Y." Where Y is significantly lower, even if you have to make X higher than it normally would be as a stupid tax. "Everybody" is using PHP because they don't know any better or are forced to because they are expanding an existing codebase. What I'd do actually is make him explain to you why PHP is better than rails. When he says "Because everybody is using it" just ask who and then ask why they are using it. The point is to get him to admit he doesn't know what he's talking about and from there say that you do and this is your recommendation.
They could say http://facebook.com. The fact ruby is being used doesn't say much on its own. PHP is also widely used.
Yes, let the Advocates and Outreach people handle the convincing.
The client is making an [Appeal to Popularity](http://www.logicalfallacies.info/relevance/appeals/appeal-to-popularity/).
Give them a quote that's twice as high for implementation, and three times as high for maintenance.
They are paying you for your expertise. And there's this: http://rubyonrails.org/applications 
I can do your project in Rails for $x, but if you want PHP it's going to take longer and cost you $x * 2
What if customers leaves me becaues of my high PHP price and goes to a cheaper PHP shop? (Something other than "Let him go to hell..." please!)
:(
I own a Ruby on Rails-only shop (20+programmers, http://ragnarson.com/). When it comes to customers it's quite simple. We develop in RoR as the community is way more mature than PHP. It's driven by people with high standards, following the best practices: agile, refactorings, TDD/BDD, readily available large number of high quality libraries, using cloud hosting from day one (http://www.winniecloud.com/, http://heroku.com/). PHP people slowly migrate to RoR, although it's quite hard for them. They are not used to a single best way of writing software, they do not do TDD that much, finally they prefer to reinvent the wheel due to NIH syndrome. Each PHP company has different approach to programming. This is where RoR people differ. RoR customer can always switch to another high quality development team and it will take them a week to get up to speed. PHP customer needs to take into account that his project will have to be rewritten sooner than later and almost always when he switches development team. This is rarely the case with RoR. Bottom line is: we are doing RoR only. If you want PHP you have to go somewhere else. No, we can't recommend any team - by using PHP they suck by default in our opinion. Just remember that we estimated the project for X amount of time. Then it's possible that the customer will go for PHP. After X time we call him and ask how is the project going. None of such customers were done by that time, most said they will recommend us instead :)
Hehe, just sayin', I also used the word 'hyde' for a Jekyll-like solution. :) http://github.com/sinefunc/hyde My first foray into ruby ever.
Filtering customers who are evaluating purely on price is an *intended* property of the strategy. You probably can't compete generally on price anyway; offshore PHP shops are way too cheap. Standing up for technical details like language provides a concrete differentiator that you should be able to use to position yourself as the "high quality" choice.
Here's how I do it. I like passing them in as param=value so I can quickly make it into an options hash. desc "sample rake task with arguments" task :sample_task =&gt; :loadconfig do options = {} ARGV.each do |argv| if argv =~ /(.+)\=(.+)/ options[$1] = $2 end end # now you have an options[] hash to play with. end (edited to bring code into post instead of pastie.org)
http://stackoverflow.com/questions/825748/how-do-i-pass-command-line-arguments-to-a-rake-task or you could google rake task arguments and click the first link
I'm a bit oldschool - I use shell/environment variables for that, so lets say you have a task: `rake stuff:do WITH_FILE=your.txt` in your code you simply get the file name using `ENV['WITH_FILE']`. Rake's variable syntax is ugly IMHO
agreed
You might also consider [Thor](https://github.com/wycats/thor), which makes option passing easier.
Check out the rake tasks from the Sunspot gem: https://github.com/outoftime/sunspot/blob/master/sunspot_rails/lib/sunspot/rails/tasks.rb#L27 From the command line you would do &gt; rake sunspot:reindex[Model,100] "Model" and "100" are arguments to the rake task.
I use ocra (on github) to make win exes for my ruby games 
[Here](https://gist.github.com/736721) for the code rather than a retarded twitter message.
I thought the "retarded twitter message" was worth including for context and attribution of source.
Free screencasts to walk you through the process - OSX/Linux: http://railstutorial.org/samples?file=rails_installation_mac_os_x_linux.zip Windows: http://railstutorial.org/samples?file=rails_installation_windows.zip
Thank you! Where did you find this video/are there any others like it for free?
Links to a gist on there github account, isn't that enough attribution?
http://railstutorial.org/ has a free book but you have to pay for the video series. It's worth it though, the series is very good. Another good, free resource is http://www.buildingwebapps.com/learningrails which are done in a screencast format. Lastly you can check out railsforzombies.org
I would look into this too http://docs.engineyard.com/appcloud/tutorials/setup-environment
Same here (hi ippa), it's really easy for bundling Ruby programs on Windows.
http://railscasts.com
Very useful article, thank you!
"their" or "that there" if you want to sound rustic :)
As others here have mentioned, screencasts are a great resource. Also, in the future, you might want to go into a bit more detail about your problem when asking for help online. "I can't get the gem to download" is very vague. If you could, for example, describe what you've tried already, what error message you get, and what you were doing just before the error, you'll be more likely to get specific solutions to your problem.
I'd suggest you get a virtual machine and install linux on it. Development will be much easier if you're working in a *nix based system.
&gt; PHP is .. increasingly outdated technology that is still being supported only as a matter of legacy That would be lying :/ &gt; convincing the customer to do what is right There is no *right* in this context, there is *better* and a good argument would be that Ruby will be cheaper (less development time or smaller maintenance costs).
Big ups. Ruby has had a sordid history on windows, between performance, gem incompatibilities, and lack or difference of features. If anything, jRuby might be the exception, although I haven't heard any recent updates on the state of ruby on windows. I'm especially skeptical of windows with Nginx + unicorn + RACK, as far as compatibility, stability, and performance.
One of the best descriptions and examples of rake task arguments might be from the [rake 0.8.3 release notes](http://rubyforge.org/frs/shownotes.php?release_id=26437), in the "Task Argument Examples" section.
[railsforzombies.org](http://railsforzombies.org/)
Interesting. Are `factory` methods really how Ruby typically works, though?
Yo Ruby, I'm really happy for you. I'm gonna let you finish, but Django has one of the best Geospaital libraries of all time. ---- Just kidding, this looks awesomes.
RubyOnRails.org actually now maintains a list. most are free, but some are not (i think they are labeled). http://rubyonrails.org/screencasts
On windows, you may want to start with JRuby rather than the standard versions. http://jruby.org/getting-started 
Ruby developers are less common and more expensive are they not?
you'll never run a production app in windows, so why bother developing there. Learn linux.
Something like RGeo::Geography::Spherical::Point(x,y) might be more idiomical. (dunno if Geography is needed, depends on what other modules are available) 
[How to report a bug in Ruby](http://redmine.ruby-lang.org/wiki/ruby/HowtoReport)
I remember when [Joyent announced something similar](http://joyeur.com/2007/03/22/joyent-slingshot/) years ago. Seemed to die off pretty quick.
&gt; I am also running on a machine with Windows Vista as the operating system. (In Adam Savage's voice) Well there's your problem!
Yes and "it depends" :) IMO the choice of tools should be left to the developer (unless there are specific requirements), because he's usually the most able person to determine what is most appropriate.
Oh wow.. this is really great. I'd toyed with making IF in Ruby some time ago, but never got far. A Ruby DSL and Yaml is a pretty good fit for IF though.
How do you know this?
Thanks! Yeah, it ended up taking longer than I thought it would. ^_^ One thing that would be cool to add at some point is some kind of game repository... would be cool to be able to easily install games from the command-line. If anyone is interested in hacking something like that, let me know!
Games could just be gems, have you program set up a custom gem directory, stick on a frontend and you're done.
I am liking the sound of that! I'll try that out...
Ask your client, what is their maintenance strategy. Well maintained, well written code has good longevity. Productive language attracts good developers who will most likely writes maintanable code which means stable and reliable software. Surely your customer understand that.
It's mainly corporates that are still on it nowadays, either because they have systems that will only run on IE6 and can't be bothered to upgrade or the IT dept is too lazy to upgrade to the latest systems. The British Government recently refused to upgrade despite a lot of pressure. Basically it's still hear for a while, although personally I'd charge extra for IE6 support that normally stops customers. :)
You do get name clashes with other gems that way, though.
I have vague plans to extract the Shoes packager out into its own thing. I have a repo with basically nothing up: https://github.com/steveklabnik/furoshiki It might be vaporware for a few more months, though.
That's easily avoided. Just name the gems like ifgame-myawesomegame. You won't pollute the gem namespace that way. Or, if the project is serious enough, use your own gem server.
That just made me feel stupid for some reason ... how did I not know this?
Great article ... just wish he had gone into more detail about how to actually write a gem, there is surprisingly little information on the net about how to do this.
Although this is great, I think I'll probably stick with EventMachine after I try it out. I'll edit it this if I change my mind and find out this is better.
Truth. Just make sure that people know that should be the convention. :)
Not nearly as useful as [42](http://rubyquicktips.tumblr.com/post/2129961562/42)
What do you mean? What do you want to know?
arghdammit. I've done that the ugly way in SO MUCH CODE. \*twitch\* \*twitch\* Now I'm going to have to go refactor it all, aren't I? \*twitch\*
This is exactly what I was going to try to write next week. Looks like those satellites are really pointed to my house.
Documentation. Better documentation. Up to date documentation. Amazing documentation. Seriously, PHP is kicking Ruby's ass in this department. 
omgwtf ponies!
* Ruby needs to clean up the stdlib. Ala rip out some parts that really should live as their own gems, and clean up the api on other parts. * Need work done on embedding ruby as easy as lua. Not just for the JVM. I think Matz is doing work on that. * More language research. I think people are doing stuff on that, but it's not really main stream. E.g. - static typing using ruby; weird but it's there. 
An IDE that rocks. Single step debugging in text mode is oh-so-70's, and I don't see why we can't have state of the art tools with such a beautiful language. Look at what MS has done with C# and it's reflection capabilities. The intellisense is amazing...
Check out Redcar. It's not completely there yet, but it's a Ruby editor built with Ruby running in JRuby. Looks very very cool. http://redcareditor.com Edit: added url
upboat for sunspot
i'm going to go similar to flyfishr64 and say... a non-java based IDE that is awesome (for mac)
1.8 vs 1.9. More gems are targeting 1.9 everyday, but majority of production code still runs on 1.8. Distros are largely still providing 1.8.7. It seems like whenever you explain something to a new user, you have to give caveats for 1.8 vs. 1.9.
Netbeans, rubymine, aptana.
+1 to this! It seems that in the Ruby culture, people think blog posts are an acceptable substitute for good documentation.
+1
TextMate, editor of the year right there for ruby
What about people not on Macs? It didn't look like it had a Windows / Linux version and I don't think everyone developing on Ruby is a Mac user.
I've heard science libraries suck. There is nothing like SciPy, and most attempts have fizzled out.
E-texteditor is supposed to be like TextMate, but runs on Windows. I don't know how good it actually is, though, since I'm on a Mac and just use TextMate.
&gt; (for mac) I'm not sure about Linux. It's really more of a case of where the majority of developers are, and right now, that's a Mac (for Rails, at least). You wouldn't really expect to find a C# GUI as full-featured as Visual Studio for Mac, either. 
Although newer stuff seems to be very nicely documented (think rails, bundler, nokogiri, etc.). The standard library is an example of documentation nightmare (isn't it weird to have a standard library that isn't fully documented?), but at least things seem to be trending in the right direction.
I just recently started using 1.9 for everything (Debian/Ubuntu both package it). I use a bunch of gems in my webapps, so I expected mass breakage. It turns out that the only code that didn't work in 1.9 was my own, and it was simple fixes (deprecated case syntax, no relative requires, etc.). So I think this is more perceived than real at this point.
I think ruby-core should also focus on **correctness** in APIs. Mistakes like [this](http://www.rubyinside.com/how-to-cure-nethttps-risky-default-https-behavior-4010.html) and [this](http://redmine.ruby-lang.org/issues/show/3953) make Ruby look pathetic.
There is still much to be desired when it comes the the Ruby VM(s). The time is fast approaching where we will be having every user connected to our web applications via web sockets and be constantly be pushing data to them. NodeJS is a good example of a runtime that makes these sort of systems possible.
The single most important thing that Ruby lacks is speed. Ruby is still one of the slowest language in the speed test. It becomes difficult to write stuff that should run fast. I think if V8 can make JS run fast then Ruby can run fast too. May be it is just matter of time but it is a big pain point for me
Textmate is for those lacking the motivation or competence to learn emacs. It's a mini-emacs clone for noobs.
1.9.2 is decently fast, but GC and memory-bloat is still holding Ruby back.
I use Vim, but boot up RubyMine sometimes to run some sanity inspections and big refactors. RubyMine is seriously pretty awesome: http://www.jetbrains.com/ruby/
We need a [listing of actively maintained game frameworks](http://stackoverflow.com/questions/4446508/ruby-game-frameworks-that-are-still-actively-maintained).
Here's how we can fix the docs: * Make it clear which web site is the 'official' or canonical documentation site. The real one (ruby-lang.org maybe?) comes up on Google after a competitor (ruby-doc.org ... which seems to have some outdated info). * The web site needs to be organized like [Apache's](http://httpd.apache.org/docs/): first by version, and *then* by topic. The current organization we have is unnecessarily tedious. * The site needs three docs listed prominently, like [docs.python.org](http://docs.python.org) does it: **Tutorial**, **Library Reference**, and **Language Reference**. Boom, boom, boom. The years I programmed in Python, I answered 90% of my questions from those docs: so easy to find and get the info I needed. The ruby doc site gets this about 50% right at the moment. * The API docs need to be in a more helpful format like [Javadoc](http://download.oracle.com/javase/6/docs/api/) does. Ruby is a 100% object-oriented language, but the standard API format obscures this: Files are the most prominently listed, although they're purely an implementation artifact. Many many classes are simply empty documents that provide no help. The way Modules are listed could be much more helpful, etc. Take a look at [Javadoc](http://download.oracle.com/javase/6/docs/api/) format, and how easy it is to find out the essentials a working programmer needs: Modules and class names. Descriptions for each. Method names, parameters and return values. Etc. EDIT: * Include crowd-sourced comments in the docs like PHP. tl;dr Let's learn from others' successes. 
&gt; We have GitHub, most awesomest social network on the internet. *Contributing to Ruby documentation involves working directly on the Ruby source code. . . . But to work with the Ruby source, you'll need to use Subversion.* [http://ruby-doc.org/documentation-guidelines.html](http://ruby-doc.org/documentation-guidelines.html) :-p I suppose it could have been worse, and been in CVS. 
/me laughs. You could not have picked a better way of unintentionally illustrating the point. You've *heard* that ruby's sci-computing is weak? Imagine that. If there's no interest in them, and no discussion of the subject, then yeah, they're gonna continue to suck. Ruby is heavily based in the software craftsmanship movement particularly focusing around web tools. I think that's to it's detriment long-term, and if we want to keep Ruby healthy, this is really the goal we should seek to achieve (and that may require other intermediary goals first, like improvements to Ruby's internals). But unless people are interested and willing to innovate with Ruby, then what future does it have? (The answer to the rhetorical question is still that Ruby lets us write ruthlessly minimalist code, but that's something that other ruthlessly minimal languages like scala can also achieve) edit: to be clear, i &lt;3 the software craftsmanship movement. It's great, we need it. I just don't think we should confine ourselves to a single community in this regard.
Be conservative in what you send; be liberal in what you accept.
textmate?
Loren Segal of [YARD](http://yardoc.org/) fame (which also powers [rubydoc.info](http://rubydoc.info/)) has tried to drum up support to re-doc Ruby stdlib. I think it would be awesome if stdlib had YARD tags on every method.
I'd like to see some optional typing. It'd solve a few problems I have with ruby, and could probably be done as a bolt-on gem, if you were crazy enough.
also ruby koans. It's a test based tutorial where you have to change the source to pass tests.
CAUSE I BEEN BLASTIN AND LAUGHIN SO LONG DAT EVEN MY MOMMA THINK DAT MY MIND IS GONE
sure, getting started with heroku is great. getting ass fucked by their rates for the entire life of your application...not quite as great.
I use both rubymine and netbeans (and textmate) on my Mac, but at work I have to use Windows. Today will be day 3 trying to get ruby-debug-ide to install....
Sorry but nobody who chooses to develop on windows has my sympathy. 
Oh that's beautiful. Just what I had mind for the API.
Although personally I'd prefer to have blog posts than flame wars in the official documentation, like PHP has. I find that http://gotapi.com/ goes a hell of a long way to making up for Ruby's general lack of documentation online.
Vim is my go-to editor of choice when in Rubyland. Tim Pope's rails.vim makes it practically *magical* for editing Rails code.
I use Ruby on Windows at work too. I tell you truthfully that it is not my choice nor would having your sympathy make me feel any better. The Ruby community could stand to have more constructive feedback no matter the OS of choice.
You can submit pull requests to Ruby on GitHub, and they will accept documentation improvements. http://www.mikeperham.com/2010/12/08/contributing-to-ruby/ https://github.com/ruby/ruby
I think the OP's question was, "what is Ruby missing," and scientific libraries is a good example. Regardless of why they are missing. Bonus personal anecdote: I was starting to write a small scientific project in Ruby a few days ago. Ruby seems irritating to use for science libraries because of the way it duplicates arrays and hashes. I don't know if there's a better method than Marshal.load(Marshal.dump(x)), but that was the best I found before I gave up on matrices altogether. I'm sure it's possible, but doing it clashed so hard with the usual ease and eloquence of Ruby--so I figured, why not just use C and make a DLL?
So what. Only a small minority of people actually need or care about those. And if you do, then go ahead and use the tool that's good for what you need.
I think it is more than that. Ruby MRI needs improvements and optimizations overall. Plus we need JIT and probably even type hints.
Thanks! I had no idea.
I'd have to say that Ruby, as a whole, really is centered around developing for web frameworks. This isn't bad in itself, but it can be used for so much more. The prevalence of ruby application frameworks drastically lower than that of Java or .NET languages (yes, I know this is obvious). The reason I bring this up is because of many of the other points that people are making -- no SciPy like Ruby library, no speed, etc., these are symptoms of a language that isn't used outside of its one core area -- the web. I think that a rise in the popularity of using ruby for desktop applications would contribute far more to the sustainability of ruby as a language and it would help fix the side-effects of a language that is really only used popularly for web frameworks.
Did you try to use [the matrix library](http://ruby-doc.org/stdlib/libdoc/matrix/rdoc/classes/Matrix.html) before giving up?
They won't even let you install Linux instead of windows?
This. This needs to be fixed. The elitism of the ruby community. flyfish64 clearly stated he had to use Windows and you replied with a elitist putdown of his situation. ala "Let them eat cake"
&gt; But unless people are interested and willing to innovate with Ruby, then what future does it have? Okay, I do understand your point, but I'll speak very personally here... Ruby (and the surrounding communities springing up around its libraries) innovates so fucking fast that I can barely keep up with it.
Not an IDE, but a badass editor.
So, at work my team prefers to use OS X for development. But when I need to do anything with our AD system, I have to install and use a Windows VM. And that seems perfectly acceptable. Is it not acceptable for you to have to do the same? Or is it just a common thing with the Windows community that they MUST have everything run natively on THEIR OS, and everyone else can fuck off?
I saw that, but it's still lacking stuff from the big math libraries, right? I'll definitely use the matrix library once I get back into this project, though, I don't need the math libraries, it would just be more convenient.
How does Rubygame compare to, say, Pygame? I've used Pygame in one of my university courses, and despite concurrently learning Python along with the library itself (and how sprites work, etc), I had a great time developing some smallish 2D games with it.
Yea it's pretty much limited to simple matrix arithmetic. I'm not sure what your needs are but if you're needing a lot functionality outside of matrix math then this library will only take you a small step in the right direction. I'm not sure what other options are other there that could compete with the feature set of a math rich environment like matlab but judging by what folks are saying about Ruby lacking tools to compete with scipy I'm going to guess they are pretty much non-existent.
We're not talking about the same sort of innovation then. It's particularly telling that large platform services do things like switch to alternative JVM languages when they become large. Twitter and LinkedIn are good examples of this. The cool things they do are written in other languages, and they rely upon Rails and Ruby as middle-tier development languages. That's the point at which Ruby risks becoming a niche language, and not capturing any of the market for genuinely new tech coming out. It's certainly true that there seems to be a new Ruby web server every other week, and there are tons of polyglot Rubyists (which is one of the reasons i love the community), but the world of MVC web frameworks is pretty locked down at this point. And, again, when you ask the question, "what's next for Ruby?" I haven't heard very many answers. **tl;dr**, it doesn't *really* count as innovation if we're just reinventing/refactoring the same tools over and over again. alternative **tl;dr** we're definitely making the Ruby world more awesome every day, it's just that we're not taking it to new places particularly.
I'd like to look into the options for calling C libraries from Ruby, pretty much all of what I need would be in there.
You could write a ruby extension wrapper that makes calls into the C library.
Apologies to the OP, my scorn is perhaps misdirected, but this is an issue that's been a long lingering one. It's just that lack of scientific computing in Ruby is always brought up, and this is particularly illustrative of why it's mentioned and then never addressed. Nobody seems to care about scientific computing, or large scale computing with Ruby. And trying to shoehorn Ruby into platforms designed for large scale computing (like Google AppEngine) is challenging for a variety of reasons (although some have done it). And you can look at things like Tim Bray's widefinder project, in which Ruby qualifies as an "also ran".
I think most people get into Ruby to do webapps (very probably via Rails), and so scientific computing isn't a high priority for Rubists. I can see where your ire comes from, and it is indeed lame to complain about it and then do nothing. I guess people don't want to use Ruby for large-scale computing because they have options like Python? It's either build the scientific computing gem yourself, or learn Python for a few days. I wonder what portion of Rubists would have use for a SciComp library?
Netbeans was unusably slow. I'm currently using RubyMine but with the feature bloat in 3.0 it is now unusably slow as well. I'm falling back to TextMate wondering why there is no good IDE.
It is. I like it and it offers lots of good stuff. I've been using it for a year and recently switched to 3.0. Unfortunately we're working on a large project and even editing the .plist file to up the Java memory limit to 1gb it crawls to a halt and runs out of memory at least once a day. I'm waiting _several seconds_ for something as simple as a keystroke, even with auto-complete turned off. I'm at a loss again and am having to abandon it.
Holy crap I can not upvote this enough. It frustrates me to no end that I will use a site like railsapi.com and search for something like "resources" and click on the function, and there is NO DOCUMENTATION there. Even showing the source code doesn't help because most of the functions facing the developer are just "parse the options, then do the actual thing" - so then you're on a journey through the API trying to figure out what actually happens, and you need to start flexing your metaprogramming muscle a lot when you are diving in. I need to magically know to look in a different place to know what I can do with the function. This was for a simple question like "can I use :only or :except with the new rails 3 router". It should have been answered right there. It's the same with many of the new "split out" functions that originally were on ActiveRecord::Base and are now in ActiveModel or something - there is no documentation there, you need to know where to look.
lib/date/format.rb is a true work of art.
**Framework authors and their ideological constraints** are holding the Ruby community back. That said, most of the other comments here are totally legit, too. I completely agree with the top several... documentation, speed, IDE, etc.
I’d add to this by saying that we need better _interactive_ documentation. In a language as dynamic as Ruby, RDoc is an abomination. We desperately need something like docstrings.
Graphical User Interface. Seriously. Most Ruby developers I know don't even bother to look at GUI programming, even saying thinks like "the Web is the future", "but games can run on HTML5 too", and such. Sure, there is QT4, GTK and Shoes, but: 1) Shoes is not cross-platform as GTK and QT4 (which run even on nokia's maemo) 2) Every new version of QT4 is a pain to install or to use, and Windows version of QT4 is outdated. 3) GTK have probably the least ruby-like syntax I saw in a library Furthermore, neither of then is packaged as a GEM (with the exception of QT4 for windows only)... and none of then supports threads (neither on Ruby 1.8 nor 1.9, because of the GIL) Well, we can use Java GUI libraries like Swing, but it will only run on JRuby...
And put a date, and the version it applies-to, on every piece of documentation.
You'd have to get YARD added to core Ruby stdlib before that's likely. And that probably won't happen until YARD works properly on C files. I also think it would be awesome if YARD's live auto-reload feature actually worked.
&gt; The real one (ruby-lang.org maybe?) comes up on Google after a competitor (ruby-doc.org ... which seems to have some outdated info). ruby-lang.org links to ruby-doc.org for the actual documentation.
Yup. The biggest problem I had switching to 1.9 was getting a working 1.9 on RHEL and Ubuntu. The solution, sadly, was to build from source. But that's not Ruby's fault, it's the distros' fault.
I use bzr-svn. I assume Git has something similar?
Yeah, git-svn exists.
I dunno, a lot of that 'innovation' seems to be wheel-reinvention. HTTP servers: Webrick, Mongrel, ServerSide, Thin, Unicorn. Web frameworks: Rails, Merb, Camping, Sinatra, Ramaze, Vintage, Swiftiply. XML parsers: Rexml, Hpricot, Nokogiri, libxml-ruby. RSS/Atom parsers: feedtools, simple-rss, syndication, feedzirra, ruby-feedparser, feed-normalizer, and the crappy built-in RSS. It wouldn't be so bad, but most of these reinvented wheels are maintained for a year or so and then left to die, leading someone to reimplement again, and the cycle continues.
I used it at work for awhile. It's close, but I kept running into problems with the unix utilities being installed and it not knowing where to find them. It just thought they weren't there. This basically stripped all the functionality away. I tried various methods to fix it, but in the end I ended up ditching it.
I've used it for couple of weeks, but it doesn't really fit in the Windows model. TextMate is great because it is on unix based system, where you can jump down to bash, but on Windows, I find using IDE like RubyMine much less painful, since cmd isn't really replacement for bash, neither is Cygwin.
I wouldn't worry about it, it's going to replaced as soon as Matz can get agreement on which replacement implementation everyone likes.
I have to agree with you on this one, but fortunately there is a way around it ... and that is JRuby. 
MacRuby is very strong on the GUI dev for OS X at least. Nearly all cross platform GUI systems look horrid and Rubyists tend to be more aesthetically focused than most.
Cool.io and Eventmachine both provide node.js event driven functionality in Ruby. See Ruby Inside for a write up of cool.io just today even.
True, I see your point.
Did you have a specific c lib you are interested in? I have some experience extending ruby with c and can look into it for you.
QT4 on a mac is a gem. Shoes 4 will be distributed as a gem. (Though you're right, I don't think we'll ever make Shoes work for mobile)
I think a lot of people find the installation process too difficult. It should be much more straightforward and simple. Of course ,as others have mentioned, the documentation needs some help.
Talk to bobindashadows. He's doing his senior thesis on static analysis of ruby programs.
Thats being worked on- it is called Rubinius :)
I think a lot of this comes back to speed- Ruby is inefficient, so number crunchers go elsewhere.
YARV is sure way faster than MRI, but it is still far behind something like V8. (Just not to mention LuaJIT which is the fastest JIT for a dynamic language. I know it is unfair to compare a Lua runtime to a Ruby runtime, because Lua is much simpler.)
&gt;The Ruby community could stand to have more constructive feedback no matter the OS of choice. I don't see why. Why does the community need to bend over backwards and do fifty times more work to design and test their libraries in windows? Why do windows users have such a tremendous sense of entitlement? It's easy for you to install linux and it's free. Why should every person who writes a gem pay for a copy of windows so they can make sure their gem works with windows? 
&gt;This. This needs to be fixed. The elitism of the ruby community. No it doesn't need to be fixed. Why does the windows community have such a sense of entitlement? Why should every person who writes a gem be forced to pay for windows and test their code to make sure it works with windows? Why don't you do it? Why put the entire onus the "ruby community". The fact that you see the "ruby community" as "them" and the windows users as "us" shows how little regard you have for the ruby community. Linux is free. You can download it and install it and use it. You are welcome. Forcing every ruby developer to install windows and test their code against this OS which doesn't have any decent build tools is irrational. &gt;ala "Let them eat cake" Let them eat visual studio.
Textmate is not an IDE. If you just going to use an editor why don't you use Vim or Emacs.
It's a shot in the dark since I can't test it right now, but try to add @property.images.build before rendering 'new' in the else clause of your _create_ controller action.
That's exactly my point. I'm falling back to TextMate because all the IDEs have been virtually unusable. I am currently reading [this](http://blog.danielfischer.com/2010/11/19/a-starting-guide-to-vim-from-textmate/).
Whoa. What's a "large" project? Maybe it's time to start breaking that out into multiple projects with a service oriented architecture?
It's large. Very large. Talking 250 controllers and 400 models large. Yes breaking it up is what should be done. Yes we know. But that's never as important as new features. Realistically the app works. It runs our entire business. Two app servers and one DB server and no load or scale problems. It's fast and it's stable. A continuous integration server runs our 6000+ tests and it's effective. That's what makes it so hard to convince the people who pay the bills to let us split it out. IDEs aside it's alright to work in. The frustrating bit is the 30 seconds it takes to load server or console.
Especially pre-rails, ruby was a very "RTFS" culture. There are some good parts and bad parts to that, which I will not waste time arguing.
FFI is a simple but effective way to bind to libraries. It's a gem and is decently documented. The ruby dist's README.EXT is the 800lb gorilla which lets you do what you want. You'll want to look at headers and mkmf as well if you go this route.
 ree-1.8.7-2010.02 &gt; DateTime.parse("Funday, Dectober 18rd") =&gt; Sat, 18 Dec 2010 00:00:00 0000 
Apparently this only works on systems where SIGINFO is supported, and unfortunately Linux is not one of those systems.
What do you mean "virtually unusable". Just about everybody I know uses either netbeans, rubymine or aptana.
Sadly I can only upvote this once.
Snippets of conversation, while valuable from a historical perspective, are no substitute, it's true. I feel like a lot of the IRC and Twitter-based development culture where everything is edge and the past doesn't matter contributes to this.
Memo to developers: "View Source" is not an acceptable form of documentation.
Attitude got the Ruby community to where it is today, but attitude can be corrosive over time. You've got to know when to keep it in check and get down to business.
Maybe if you could embed FORTRAN people would be happy.
If Reddit was based on EMACS, I would have just hit ^C ^X ^E -1 to down-vote you.
Functional programming support. I switched to Clojure a couple years ago, and it kills me when I need to come back to Ruby. Sure lambdas are technically "first class", but that usage is very un-idiomatic. You have to deal with the block/proc/Proc/lambda mess, and they just don't compose neatly like you have in languages designed for FP. [Hamster](https://github.com/harukizaemon/hamster) looks like a step in the right direction on the avoiding side-effects side, but without cleaning up the story around actual function objects it's going to be awkward.
cool.io == async I/O. Good luck having 20,000 simultaneous users connected under a single process.
Thanks for submitting this. :) I'll be a regular contributor to the changelog now, so keep me posted on your library developments, everyone!
Wow, 400 models? The cognitive load alone must be unbearable. I have a hard enough time fitting 16 in my head. But luckily, you have tests! Shouldn't it be relatively straight forward to start breaking off pieces? You don't need to split it all up at once into 25 services. You could find 3 related models that are pretty stable and independent, pull them out and make a new service. Get those 30 seconds down to 3 seconds and improve iteration times considerably for that small component. Do this a few times and you'll be surprised by just how much you hated life waiting for 6000 tests to run :-)
I develop on a Mac, but I get *paid* to develop on Windows. Boss knows it's suboptimal, but there you have it.
on one hand I personally agree, but on the other hand Ruby is accessible to the masses- any attempts at integrating functional aspects would need to retain that.
Does the same in 1.8.7. Some weird shit. And people bitch about PHP's unpredictability :|
Only 3 upvotes? The Ruby community should be more enthusiastic and encouraging of articles like this. It is this lack of interest in deep, technical articles that gives Ruby programmers the reputation for being little web-programmer weenies afraid of real programming. Ruby is actually a very deep language with a wonderful C API - it's a real shame the community is populated by hair-gel, "i only know webdev" hipsters. 
Slow. Waiting several seconds for keystrokes slow. Rebuilding indexes that lock my machine slow. Having to wait for the window to catch up with my scroll wheel slow.
The integration server is good for tests. Having to wait for those to take their 30 minutes to run on my machine was horrible. It's the startup time for console and server that's the pain. And you're right, there are entire sections of the app I've never looked at because it's just too big. But all things considered it works very well. There's about a dozen developers working on it full time. It runs our entire (complex) business and it does it quickly and smoothly.
Node.js uses async I/O under a single process too, no?
Huh. I'm skeptical. Strong suggestions w/out sources for assertions (e.g. about how many unit tests to write). Sounds like a very process-heavy software engineering mantra that might not really make sense. No bio of the author besides he works for AT&amp;T. Urk.
Actually, we'd only need YARD to properly handle parsing the documentation in the C files, and for RDoc to not chock on YARD tags. This would allow normal RDoc documentation to be generated and installed, and full YARD documentation to be shown on [rubydoc.info](http://rubydoc.info/).
**BSD RULZ! LINUX DROOLZ!**
Every now and then someone leaves a comment I wish I could save. I guess I'll email myself what you wrote :)
&gt;Slow. Waiting several seconds for keystrokes slow Hang on a second. Let me try it... OK I am back. You are lying. It did not take several seconds for every keyword. 
My condolences. Your boss sounds like a very bad manager.
I know it's a Fortran library, but what I'd most like to use is the [SVD](http://www.netlib.org/lapack/lug/node53.html) algorithm from LAPACK (or CLAPACK, I guess?)
I don't know why you're arguing with me. I use RubyMine. I have for a year. I recently upgraded to 3. Even with auto-complete turned off I often wait several seconds for a keypress to appear on screen. I have a new-ish MBP with 4gb of ram. Our project is probably just bigger than yours. When I use it at home for my smaller personal projects it works well.
The author is [drbrain, aka Eric Hodel](http://redmine.ruby-lang.org/wiki/ruby/Contributors#label-56), current maintainer of rdoc and rubygems.
The original line for it is, &lt;div id="error_explanation"&gt; Check your CSS and check how the styling is affecting it. View source, inspect with firebug, all the usual stuff.
&gt;I don't know why you're arguing with me. Because you are lying. I fired up rubymine and started typing. It didn't take seveal seconds for every keystroke. 
I *love* rails.vim. I map &lt;leader&gt;a to :AV since I use that shortcut so commonly.
If there were a reddit mode for emacs you wouldn't have had to downvote him because the AI elisp auto-modder you wrote would have done it for you.
Actually, not at all. He's good to work for. He doesn't require crazy schedules, or insane hours per week of work. The reality is what it is. I *am* however, setting up a VM to develop in. BTW, I installed ruby-debug-ide 0.4.4 without a problem on Windows and now I can use the NB debugger.
Haha. Lying? What's the point of lying? And you have no way of knowing that. You are not using my machine. That is how the last several versions of RubyMine have run with a large-ish project. It is unfortunate and has caused me to abandon it. [I don't know why I'm arguing with you](http://i.imgur.com/LwCXh.jpg).
[http://www.reddit.com/r/rails](http://www.reddit.com/r/rails)
Please note: This is nothing fancy, it simply utilizes `Method#source_location` in Ruby 1.9
Link?
go try working for a big corporation (don't even get me started on banks). you use what they tell you (that's why i no longer work for a big corporation)
you are new in the workplace, aren't you? big corps have all sorts of fun rules
I am disappoint... was expecting some AST magic.
No, AFAIK. But there is a great IDE for Ruby and/or Rails http://www.jetbrains.com/ruby/features/ruby_debugger.html
Browse the ruby-core mailing list archive. Lots of discussion.
I've never had the need to debug ruby to be honest.
Agreed. Though I think it's more reflective of the reddit ruby community. No interest for this article but 20 upvotes for a paragraph about using an Array method is an indication, http://www.reddit.com/r/ruby/comments/elrgl/arrayfirst_and_arraylast_parameters/
Sure. Run your code and Sinatra at the same time and it will show you nice tracebacks.
I'm a long time rubyist (10+ years now) and I've run the ruby debugger approximately 3 times. I ran some other ruby debugger gem exactly once. Debuggers are great when you really need one, but like antibiotics, people prescribe them far too often. I find much more long lasting productivity via unit tests. Not only do you figure out the problem, you can do something that debuggers simply can't do: prevent future regressions. 
I'm not sure if Python can do this, but one awesome feature of Ruby is invoking IRB in your code @a = "hello" require 'irb' ARGV.clear # otherwise all script parameters get passed to IRB IRB.start # now you can interact with your code directly, # when you close IRB, it will just continue &gt;&gt; @a =&gt; "hello" This way you can inspect interactively. One downside is that you can only access global and instance variables. [There is a way around this problem though](http://stackoverflow.com/questions/4189818/how-to-run-irb-start-in-context-of-current-class). 
I think that's essentially what the web-debugger is doing. Something like this: import IPython shell = IPython.Shell.IPShell() shell.mainloop() But what I was looking for is a web debugger for Ruby so if an error occurs on the site during development, I get a traceback and can interact with anypoint on the traceback--looking at the variables and stack. This is something that RubyMine does (someone else pointed that out), but RubyMine isn't free nor open source.
Well I come out of the Smalltalk world so I'm used to unit tests, but when a test fails I like being able to re-run it under debugging then jump into the stack so I can see *why* it failed, and rewrite the code right there to make the test pass. I can get the first part of that equation in the Python debugger, but not the last. I'm hoping Ruby offers something similar which is either full featured or open source so I can hack away to get it right.
I guess you could also load for example RSpec and do some interactive testing, like set mock expectations and stubs directly in place, instead of writing a test. Or you could just rewrite a method on the fly and see what happens. Ruby metaprogramming provides many hackish features that might be useful from time to time when you need them. This probably isn't possible in Python, since it doesn't support monkey patching.
Explains your username! :P Hrm... I doubt it'd be that hard to provide an extension to minitest that ran under the debugger and dropped to a debugger prompt on failure. Maybe I'll poke at that idea later today.
Seriously? I must use the debugger at least once a week. Nothing beats troubleshooting when you can examine what the hell is going on.
something like [this](http://i.imgur.com/UC14d.png) maybe? 
import pdb; pdb.set_trace()
Try the ruby-debug gem. I don't use it often, but it's a lifesaver when I do. Disclaimer: I've only used it in the context of rails, never standalone. http://bashdb.sourceforge.net/ruby-debug.html
Love it!
If I need to play around with some piece of code, I use `rake console` (available in jeweler 1.5.0 and ore-tasks). If some piece of code is behaving unexpectedly, I will write tests to isolate it's different behaviours and nail down where the problem is. 
Have you not given [homebrew](http://github.com/mxcl/homebrew) a go (instead of macports)?
yes, please.
&gt;go try working for a big corporation (don't even get me started on banks). I choose not to do that. &gt;you use what they tell you (that's why i no longer work for a big corporation) That's just one tiny reason not to work for a large corporation. There are thousands of others.
&gt;Haha. Lying? What's the point of lying? And you have no way of knowing that. I don't know what the point of lying is. All I know is that I have it open right now and it does not take several seconds per keystroke like you claimed it does.
&gt;Actually, not at all. He's good to work for. He doesn't require crazy schedules, or insane hours per week of work. That is not the criterea for a good manager. It doesn't matter if he does all that. When you get to work he dictates to you what tools you have to use even when they are inferior. 
OK. It is a bit gross, but I did it. Simply requiring "minitest/debugger" at the top of your test will drop you into the debugger on a failed assertion. Check it: http://www.youtube.com/watch?v=k42aKM3jDZw Granted... Ruby will never have the productivity of working in an image based environment, but we can get close®. ETA: I'd love feedback http://www.reddit.com/r/ruby/comments/en3od/minitestdebugger_drop_into_the_ruby_debugger_on_a/
Lemme know what you guys think!
I like it, but perhaps it makes Ruby look like hard work
Then it would probably send you a self-congratulatory email and post something on Twitter about how awesome you are.
perhaps the reddit alien should be shitting candy and rainbows. 
No actually I've worked for IBM for 5 years. We're allowed to develop using whatever OS we want. We're typically given a Lenovo laptop and the 1st I do is wipe it and install Linux.
So I started looking into writing a CLAPACK wrapper when I ran across http://linalg.rubyforge.org.
&gt; it does not take several seconds per keystroke like you claimed it does. *For you!* Your project on your machine. For me, it does. For my project on my machines.
Classes are the important part of object-oriented programming, learn how they work and why they are good i.e. data encapsulation, polymorphism, modularity, etc. Read the wiki page and then go from there - http://en.wikipedia.org/wiki/Object-oriented_programming 
Thanks, I needed a good place to start. To be honest, I knew that ruby was object oriented, but never really knew what that _meant_. So this will be great! 
Classes are blueprints. Objects are implementations. All classes are objects of class 'Class', just as all blueprints are implementations of the blueprints for blueprints.
How long have you been in the business? Managers rarely have the ability to approve the OS that is used. Like it or not, Windows rules the desktop / domain space. While it may be changing, it is slow change. A good engineer works with the tools available and gets the job done, within the constraints set by the business.
&gt;For you! Your project on your machine. As I said before just about everybody I know uses one of those IDEs and it doesn't happen to anybody. &gt;For me, it does. For my project on my machines. Maybe that's an indication that you don't know what you are doing.
&gt;How long have you been in the business? Decades. &gt;Managers rarely have the ability to approve the OS that is used. Not rarely. They frequently have the ability to approve OS that is used. Take for example any art department on any corporation. There is a 80%+ chance that the art department is running macs. That's because the manager approved it. &gt;Windows rules the desktop / domain space. That's why it's good for the drone bees. The paper shufflers, the people who spend their time on the phone etc. You are a developer. You are not one of them. Your boss makes you use the same tool as them then you boss is not very smart. &gt;A good engineer works with the tools available and gets the job done, within the constraints set by the business. A good manager doesn't make it harder for his engineers to get work done. 
That one doesn't look too bad, in my opinion.
Very nice. 1+
You're a machine banister, keep writing this crazy shit.
Here's an example in code: class Person def say(text) puts text end def run puts "Running!" end end Person is a class that contains "actions" that can be executed on an "instance" of the class, or "object". In the class, you define what a Person can do. The actions (methods) defined in the class can only be performed on an "instance" of the class (object). For example, if I do: p = Person.new p becomes an instance of Person. I can then perform actions on 'p' with methods. Ex: p.say("Hello World!") &gt; Hello World! p.run &gt; Running I hope this helps. You should read up on object-oriented programming, it'll really help you get the grasp of it. It's very simple. 
So class Human is a blueprint, and Josh is an Object of class Human.
So basically, classes encapsulate "methods", in this case a Person can speak and run. This is a great idea, because you don't pollute the "global namespace" with unnecessary functions (like PHP).
agreed. i'd suggest the alien extending a hand and a ruby floating in the air above his palm
Something like [this](http://i.imgur.com/9qRIy.png), perhaps?
In ruby classes are also objects. Class.is_a? Object =&gt; true Note that Class is an object too! Class.class =&gt; Class Class has a class called Class! Class.methods =&gt; ["private_class_method", "inspect", "name", "tap", "clone", "public_methods", "__send__", "object_id", "method_defined?", "instance_variable_defined?", "equal?", "freeze", "extend", "send", "const_defined?", "methods", "instance_method", "ancestors", "module_eval", "hash", "autoload?", "dup", "instance_methods", "to_enum", "public_method_defined?", "instance_variables", "class_variable_defined?", "eql?", "constants", "instance_eval", "id", "singleton_methods", "module_exec", "const_missing", "taint", "instance_variable_get", "frozen?", "enum_for", "private_method_defined?", "public_instance_methods", "display", "instance_of?", "superclass", "method", "to_a", "included_modules", "const_get", "instance_exec", "type", "&lt;", "protected_methods", "&lt;=&gt;", "class_eval", "==", "class_variables", "&gt;", "===", "instance_variable_set", "protected_instance_methods", "protected_method_defined?", "respond_to?", "kind_of?", "&gt;=", "public_class_method", "to_s", "&lt;=", "const_set", "allocate", "class", "new", "private_methods", "=~", "tainted?", "__id__", "class_exec", "autoload", "untaint", "nil?", "private_instance_methods", "nesting", "include?", "is_a?"] Ruby is fun isn't it?
Yea. You can ask objects what class they are by saying josh.class. You can also ask them if they are particular class like josh.is_a? Human or josh.is_a? Ape. An object can be two things. 1.is_a? Integer =&gt; true 1.is_a? Fixnum =&gt; True oh yea and just about everyting is_a? Object.
Only, 0 = 1 = true is weird.
&gt; Only, 0 = 1 = true is weird. What? 
You can also use modules if your only interest is not polluting namespace. BTW classes can also have methods which you can call without instantiating them. For example. class Person def self.think "Thinking" end end Now you can call Person.think you don't need to do Person.new().think 
That looks awesome, it certainly saves some time when things are unexpectedly red.
While you're at it, can you explain the unary operator in Ruby? As in HTTP::something() vs def hello ::CONST end
No. Try it in IRB 0 == true =&gt; false and 1 doesn't equal true either. In ruby numbers are numbers and booleans are booleans they are not equivalents of each other. Some things evaluate as false though like nil. But that doesn't mean nil == false. 
That's not a unary operator. That's just a namespace marker. When you call HTTP::something() you are calling a class method in the HTTP class. When you use ::CONST you are accessing a constant in the global (top level) namespace. Constants normally live in the namespace they are declared (classes are constants by the way). Take this for example. BAR = "BAR in global" class Foo BAR = "Bar in Foo" end Here you can refer to BAR and Foo::BAR they point to different things. What if you wanted to refer to global bar when you were in Foo? You do it like this. let's reopen the class class Foo def say_bars BAR ::BAR end end The first BAR refers to the constant defined in the class. The second one access the one from the global namespace. Is that explain it for you?
Thanks! So, what's the difference between self.method_name and HTTP::something() ? It looks the same (not creating a new instance) to me.
Correction: ...that Ruby was...
You use self.method_name when you are creating a class method, you use HTTP::something when you are calling that method. class Foo def self.bar 'bar' end end Foo::bar 
I fancy `rspec -d` does like this...
Very cool!
I think the line you're referring to is this: if 0 puts "0 is true" end &gt;&gt; 0 is true When you make an "if [expression]" call in ruby, it returns false only for an instance of FalseClass or NilClass. When you make a "if 0 == nil" call in ruby, it's actually calling the ==(other) method on the Fixnum object. This is the same as saying 0.==(nil) which will return false because 0 does not equal nil, numerically. 
if you need something with attributes and make actions...well...do you must beginning think in use class.... class is something similar to hash..if you've a person hash...it would has person1={:name =&gt; "Flando", :ask =&gt; "Classes in Ruby}... as you can see person1 only has attributes about you...but what do u do if you wanna have actions too?...like ...programming...eating...asking....etc...etc... you need create a class...class is a way for encapsulate something.....but it has more benefits...you have inherherence and polymorfis.... if you wanna do a game...will you have a "board game"...this board has (colors..size...refresh rendering...etc..)=attributes....but it will have too (refreshing, show_grid, show_score, etc, etc)=are actions (look the names...all corresponding to actions).... now if you wanna 3 car's types...like a hummer...a sport car...or a bus...there are similar atributes in all they...like (color, max_speed, potency, etc)...and you've similar actions too (:turn_power_on, turn_power_of, turn_right, turn_left...etc..etc..etc)....you don't need repeat all these eery time you create a new car...with help your new friend...inherence..you can create a father class like... class Car (atributes and actions) end and now you can create a bus (it's a son) for Car...this automatically has all atributes from your father...Car class Bus&lt; Car (use the &lt; for inherence) (now you can create new attributes and actions for the bus specifically..like attribute: school_name actions (pick passengers) end this is almost all you can need for now sorry for my poor english 
python __suck__ lol
Flip the Ruby and I think we're on to something.
You just saved me a buttload of time, thanks!
Excellent, thanks!
Seriously! I'm excited to give it a whirl.
Yea he does look like he's having a rough time with it. Maybe some more simple? [Like this?](http://i.imgur.com/mOZwW.png)
I'd recommend picking up a copy of David Black's [The Well Grounded Rubyist](http://www.powells.com/biblio/1-9781933988658-0).
Great things about this gem: * Uses information from Git to only package files that have been modified (often saving your users another download of something they already have) * The source code is small and hackable * Very easy to migrate from AssetPackager * Framework agnostic (Rails 2, Rails 3, Sinatra support baked in) * Google Closure Compiler for Javascript compression * YUI Compressor for CSS compression I am the author, so I welcome any comments or questions.
But nothing fancy is a good thing when it comes to understanding code.
already almost 900 watchers on the repo. whoa
Petrus was much more usable a couple months ago. I hope rails_admin continues to improve.
what are the difference between this and jammit ?
Expensive, but it looks great. I'll definitely see if I can pick it up!
This was a really helpful example :) It clears up one of the bigger things I was confused about - that is the purpose of classes/objects/OOP. I think I understand better now.
Ah, useful tip, thanks :D
Thanks for the in-depth example, I'll be reffering back to ALL these comments!
Nice. IMHO it would be nicer if hands of the alien are visible.
I don't know how familiar you are with OO (Object Orientation) but the basic principles are as follows: * Data and functionality should be logically grouped. For instance, the data stored in a linked list should be logically grouped with the code to manipulate that list * All interactions should be encapsulated, to keep concerns separated. For instance, not only should your linked list object "know" how to manipualte it, no one else should know or care. * The method for doing a certain thing should be determined dynamically, at run time, by whatever object you're talking about. This is called polymorphism. * A hierarchy of classes should model the problem domain. The general idea of OO is that you define classes. Classes are like templates for creating objects that live in the same "group". For instance, you could *classify* all animals as belonging to the same group. To model this in your program, you'd make an Animal class. This is like a template off of which you can create animals. Each individual animal you've created is an Object, or an instance of a class. Now, to illustrate the first point, animals have attributes. Maybe a colour, and a number of limbs. So they have two instance variables (per-object variables) to store this information. They also have actions they can do. These are functions defined per-object. For instance, maybe "Walk" is a function, or "method" as they're called in OO contexts. Now, say you want to make your animal walk. You can create a new animal by typing "**ani = Animal.new**" and then instruct it to walk by going "**ani.walk**". No other code knows how to make it walk, it just knows that if I want it to walk, I tell it to and it takes care of it. This is the encapsulation. Now, say you want to make specific types of animals. You can define a Dog class, which is a subclass of animal. This is (mostly) like saying "Every dog is also an animal". In this way, you can define a dog class but it *inherits* everything within animal. So you don't have to go rewriting the code to track its colour, for instance. Finally, lets say you make a Snake subclass. Now, snakes don't walk the same way normal animals do, so you'll have to override the normal walk method with one on snake. Now, Snake has two walk methods: the animal one and the snake one. Since snake is a subclass of animal, you know you can call walk on it. But, when you call it, it magickally knows to use Snake#walk instead of Animal#walk. Polymorphism! There's way too much to say in a comment post butI hope this is a useful primer
An excellent cross post from hacker news. Edit: Two requests; What about an alternate rake spec task for Webrat/Selenium/Firefox? What about Front-end extendability or an example, similar to ActiveScaffold embeddable-ity;
[agreed](http://imgur.com/o8tS1.png)
Actually, admin done right would be integrating it into the main site.
Mainly, the fact that it only re-generates packages for files that have been modified if you are using Git for version control. It also supports Sinatra out of the box and can easily be applied to other frameworks. Jammit has a lot of awesome features, and if you need those features, by all means use Jammit. For my project, I only need basic asset compression, and need it to be done as efficiently as possible. Its also pretty tiny (~240 lines), so its easily hackable.
But at a serious cost. rspec is _huge_ and _slow_.
This was an _excellent_ primer. Well done, it cleared up a LOT of the things I was confused about. Thanks a ton!
I vote for this! But bad news is none of the two moderators have had any activity in last 8 months! Now who's going to change the logo?
Wow it seems so complicated. I much prefer something more straighforward. Why can't it work purely on results? For example. @invoices = current_user.pending_invoices then in the view &lt;%= display_grid @invoices do some settings and options here end %&gt; This is kind of approach taken by https://github.com/wice/wice_grid but it hasn't been touched in over a year. 
This is just what I remember from my OO class. There is quite a bit more to look in to. For example, the "Subclass IS A Class" is a simplistic way of looking at class heirarchies, and isn't always accurate. Plus ruby has an alternative form of quazi-inheritance, which is the module system. But this is a good starting point. Glad it helped
The biggest problem is that we keep looking for problems?
http://stackoverflow.com/
Ok I had this exact same problem at work the other day. Try running rake db:test:prepare before you run the test individually and see if it fails then. In my case, running the tests individually failed after testing the database. I was trying to access some data in my database before it had been loaded.
[Agile Web Development with Rails](http://pragprog.com/titles/rails4/agile-web-development-with-rails) was a great book to start learning Rails with. I linked to the 4th edition because it deals with Rails 3, I used the Beta of the 3rd edition and Rails 2 and it worked out great. The nice thing is, they will send you updates of the ebook and then when the book is out you get that as well. The [Ruby Cookbook](http://oreilly.com/catalog/9780596523695) was also helpful when I would get stuck trying to solve a problem, but it was more of a reference than anything else.
Just do it. Don't get distracted and don't get upset when things don't work. I never could get started with Why's guide but I did have success with the pickaxe book which does have a version that covers 1.9.
Thanks. I know I need to quit talking about it and just do it. I'm doing the tutorial on tryruby.org right now while waiting on more responses to this thread. Are there any resources you recommend?
http://pragprog.com/titles/ltp2/learn-to-program then, http://pragprog.com/titles/rails4/agile-web-development-with-rails
[Stack Overflow](http://stackoverflow.com/) is your best friend. If you have any questions feel free to send me a message and ask. On the web front there is [Rails casts](http://railscasts.com/) and another awesome contender is [Sinatra](http://www.sinatrarb.com/). If you want to parse XML, HTML, or SAX check out [Nokogiri](http://nokogiri.org/). If you want a more awesome version of Net::HTTP check out [HTTParty](https://github.com/jnunemaker/httparty). For Event-processing libs check out [Eventmachine](http://rubyeventmachine.com/) and [Cool.io](http://coolio.github.com/). For Rack based projects (rails, sinatra, etc) check out using [Heroku](http://heroku.com/). That's all I can think of now so if anyone else can add to the list feel free.
That's all a little over my head at the moment, but I'll keep it all in mind. Apparently I have an account on there from when I first started reading Why's guide.
http://rvm.beginrescueend.com/ http://www.reddit.com/r/ruby/comments/endm/rails_admin_done_right/ http://activescaffold.com/ http://www.activemerchant.org/ 
http://tryruby.org/ gives a decent interface for learning the basics by doing them. 
The most hands on Ruby exercises I have come across are : "Ruby Koans" http://www.rubykoans.com/ Try working through these exercises. 
I would recommend not starting with Rails, but instead with [Sinatra](http://www.sinatrarb.com). Rails is great, and you can do some amazing things with it, but for learning I found that it was more a hinderance than a help. Better to learn the core language first, then move to a framework such as Rails. Sinatra gets out of the way and lets you write Ruby, allowing you to have a site up and running with about 5 lines of code. It's a terrific introduction to developing sites, and I found it a great way to play around with Gems and their capabilities. As for books, I have both the [PickAxe](http://pragprog.com/titles/ruby3/programming-ruby-1-9) book, as well as [Beginning Ruby](http://www.amazon.com/Beginning-Ruby-Novice-Professional/dp/1590597664). Both are very helpful. 
Absolutely start with Learn to Program! I recommend it a lot. You can google for it and get a sample online. Another good resource is IRC. There are a lot of smart folk on there at all hours of the day (some more than others, obviously).
Once you've done some of the super-beginner stuff, like TryRuby, Why's Poignant Guide, and RubyKoans, start reading all of the methods in the Enumerable library. Start to feel the essence of functional programming and blocks. That's where you'll begin your appreciation of the power of Ruby. :-)
I was going through that (again) earlier and I got stuck on lesson 2. For some reason even after reseting and then refreshing the page the poem item keeps disappearing from memory. That's the best way I can explain it right now at least.
C is _icky_!
hadn't seen this before. Thanks!
Not directly adding to the list, but [ruby toolbox](http://ruby-toolbox.com/) will probably come in handy for knowing what tools you have available to you. 
http://jamesgolick.com/ http://danielharan.com/
I can't recommend [RubyKoans](http://rubykoans.com/) enough, really good for hands-on learning.
TryRuby has been really buggy lately: it's probably not you. Check out Ruby Koans: https://github.com/edgecase/ruby_koans
If you choose 1.9, please use 1.9.2 and not 1.9.1. There were some weird bugs in 1.9.1.
Keep the distinction between Ruby and Rails crystal clear. Learn to program using Ruby—and then learn Rails. I'd suggest it, anyway. Ruby is a great general-purpose programming language, but I think Rails is overhyped and probably too bloated for many people's needs. After you have a firm grip on Ruby, you can learn any framework you like. See other people's comments for some good guides to pure Ruby. I also wouldn't worry about syntax being outdated—the changes in 1.9 are easy to pick up, and Why's guide is as relevant now as it ever was.
also note that Sinatra and Rails are both based on the Rack framework, so many Rails plugins work well in Sinatra. It's a great framework, both for learning, and for the sort of applications that don't fit the Rails golden hammer..
http://en.wikipedia.org/wiki/Syntax_%28programming_languages%29
[This is so fun.](http://imgur.com/4Q3ma)
It could be that you're not cleaning up your database between tests. Make sure you're destroying your old models and stuff before you move on to the next test.
[Ruby by Example](http://www.amazon.com/Ruby-Example-Concepts-Kevin-Baird/dp/1593271484/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1292658320&amp;sr=1-1) [Design Patterns](http://www.amazon.com/Design-Patterns-Ruby-Russ-Olsen/dp/0321490452) [Well Grounded Rubyist](http://www.amazon.com/Well-Grounded-Rubyist-David-Black/dp/1933988657/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1292658260&amp;sr=1-1) by the time you finish those three.. you will know what you want to move to.
Not "about everything"—**everything**.
I'm inclined to agree. I use OCaml more-or-less exclusively now, and I don't deal very well going back to the wreck that Ruby makes of so-called "first-order functions." Hamster looks interesting, but doesn't solve the essential issues. Most of the features it gives come for free in real functional programming languages.
Nit-picking here, but RoR ≠ Ruby. If you mean Rails (as you clarify in the body), then say it.
I think I remember some things not being objects. Certainly keywords are not objects. There are other exceptions too.
This looks like exactly what I need, thanks so much :) ...I should stop complaining about math/science libraries for a while, I suppose.
A friend recently took to learning Ruby/Rails and I suggested he try [Rails for Zombies](http://railsforzombies.org), he's found it pretty good so far! I stressed to him when learning rails that he should learn what's rails and what's core ruby; rails adds a lot of enhancements to core classes which aren't there when you venture outside of the rails world.
I disagree, the only way Sinatra let's you get a site up faster is if it doesn't do anything. Want to talk to a database? In Sinatra you will have to roll that on your own. Want to write tests? In Sinatra you'll have to roll that on your own. The list goes on, but you get the point. I think someone new will benefit from seeing things organized well like rails setup, rather than fumbling around on their own and getting it mostly wrong. 
Rails is the best framework out there. I've never found it bloated. What I have found is that when I use Sinatra or some other framework that in the end I always end up wishing I'd started with rails because I end up reinventing it poorly in my Sinatra app. 
I loved Rails for Zombies and it's great as a first look at the language, but oh how little they cover. If they wanted to really expand the lesson plan, it could be the best site ever.
No, unfortunately that doesn't solve it.
[SOLVED] sort of... I'm using Double Ruby (RR) https://github.com/btakita/rr in many tests. Turns out in a few of them, I'm mocking some ActionMailer behavior, and for whatever reason the RR framework refuses to acknowledge that a method was called on the mailer... even though the SAME TEST CODE has been working properly for over a year now... My "solution" was to remove these few failing mocks and test the outcome a different way. Now the whole suite passes again as expected. 
I agree. I think it's good to keep the distinction strong, but there's nothing wrong with using a framework that helps you develop faster. That's really what it boils down to. Use the framework that helps you write better code, for me that's been Rails.
This is definitely a little too advanced for a beginner. He should fully understand OOP before diving into class methods and variables. It's more complex than it seems, especially if you want to use them properly. Just my 2 cents. Flandoo: focus on the basics to start, that's the best way not to get confused.
sent jamesgolick an e-mail. Should prolly add another mod or two while he's at it if he isn't going to be active around here anymore. 
I found that going to camping after spending a little time in Rails really helped me solidify what the idea behind MVC was.. Not denying that Rails is very powerful, or suggesting in any way that Camping is a (complete) replacement for it but sometimes a playground to hack about it can really bring things to light. Also, the "fun" nature of it is kind of built in.
I added this one, but it's a little too big. Feel like resizing it?
Thanks, this made me try out ripl. It looks neat, and I'll definitely use it next time I need a custom REPL.
Wow, ripl-color_result, ripl-auto_indent, ripl-short_errors are great. Tab-completion is solid. The code is very organized and readable, as well. Many of my Ronin users have asked for these features in the past, but IRB and the various IRB plugins were kind of heavy/complex. I just converted the [Ronin console](https://github.com/ronin-ruby/ronin/blob/ripl/lib/ronin/ui/console.rb) from IRB to Ripl, works perfectly.
Keywords aren't objects, but they aren't.. well, anything. You can't say *keyword*.is_a? anything. (but I guess maybe that's what you meant. We're probably distinguishing what a "thing" is differently here.) I'll reform my statement: anything that you can say "x.is_a? Object" about (and not get a syntax error), the answer is always **true**. There are no exceptions to this rule. The important thing to remember is that everything (everything!) valid in Ruby *evaluates to an object* (and thus an instance of a (sub)class of Object). That means that this: if rand &gt; 0.5 then false else "Whatever." end That evaluates to an object. It's not an object *itself*, but then again, neither's this: 42 They're both 'code' until you evaluate them, so marking the distinction between the former and latter (*But one is an object literal!* So? Literals eval to objects. Everything's an expr.) doesn't make sense. (I realise I'm way off-topic here, but I can't help but elucidate.) So everything *in the Ruby world* is indeed an object. You can never get a hold of an object in terms of Ruby itself and say "ha! It's not an object." If you took the idea that keywords weren't objects, well.. neither's whitespace. EDIT: And I don't know who down-voted you, but it wasn't me—while I don't agree with your conjecture, that doesn't mean it's not up for talking about.
&gt;The important thing to remember is that everything (everything!) valid in Ruby evaluates to an object (and thus an instance of a (sub)class of Object). That means that this: Actually constants aren't objects either. You can't even refer to a constant although they are listed in constants if you ever try to refer to them you get their value instead. It's not like there is a THIS.value 
&gt; You can't even refer to a constant ... if you ever try to refer to them you get their value instead. That's like saying "if you ever try to refer to a local variable, you get its value instead!" The same holds of all (types of) variables. A constant is just a specialisation of a variable, in that its value shouldn't be modified, but otherwise they're the same. When you refer to either, you get their value, which is an object. &gt; It's not like there is a THIS.value Wait, what?
Classes are constants so are modules. They are also objects. "proper" constants are not objects. I am simply pointing that out. class User end ruby-1.8.7-p249 &gt; Object.const_defined? "User" =&gt; true ruby-1.8.7-p249 &gt; o = Object.const_get("User") =&gt; User ruby-1.8.7-p249 &gt; o.name =&gt; "User" ruby-1.8.7-p249 &gt; THIS=1 =&gt; 1 ruby-1.8.7-p249 &gt; o = Object.const_get("THIS") =&gt; 1 See the subtle difference. 
I would add that if you're going to use Test::Unit please do yourself a favor and get version 2. It's available as a gem. It adds several handy assertions, startup and shutdown, and a host of other goodies.
Scary (and at the same awesome) stuff - while I'm ok with meta programming, aliasing, method missing and all that stuff, but overloading +, i and such can make any code unreadable.
Sinatra uses haml, which is reason enough to avoid it in my view. (Replace a standard markup language that can be processed with any number of tools in just about every language, with language-specific executable code? Worst idea ever.)
Having switched from 1.8 to 1.9, there's really very little code syntax that's outdated. The main cause of breakage is the i18n stuff added in 1.9. Assuming you're not Japanese, just put # encoding: UTF-8 under the #! line at the top of your script and continue as if you're using 1.8, and you're unlikely to notice any problems. Also, don't start on Rails until you're comfortable writing sizeable programs in Ruby.
It would have been enough to just test how big the working set of a ruby process running your favorite framework is.
Sinatra uses erb as default, not haml
I disagree about Sinatra not doing anything. I've written several web apps using it and think it's great. As for having to roll your own, this is exactly why it's good for a beginner. When I was learning, (and still am now) the fact that Rails does everything for you scares the crap out of me. I think it's much better to understand what is happing in the background before using such a framework. Trying go get your head around Rails' built in methods and features when you're _just_ starting out with programming is a recipe for frustration and disheartenment. Especially if something breaks and you have no idea what's wrong or how to fix it. Sinatra may be bare bones, but in the learning sense, this is the best way to go about beginning with a new language, especially one as expressive as ruby. It means that you can start small and grow your code with your knowledge. The mere folder structure of a Rails app would be daunting to a noob, I know it was for me. 
A lot of the stuff that rails does for you isn't important from a learning perspective. Wiring together different modes like dev and production isn't something someone should spend hours doing. Wiring in a testing framework is another thing not worth doing. I also don't buy into the idea that someone learning needs to learn low level details from the get go. It's the same argument that was common a decade ago when people argued that someone learning to program should learn C and assembly first. Rails doesn't make it harder to learn the important stuff. It doesn't make it harder to learn http. It doesn't make it harder to learn about cookies and sessions. It doesn't make it harder to learn HTML, CSS, or JavaScript. I think the best learning environment is one that let's you execute your ideas and worry about the details when you need to. 
Just curious @jshen, how did you start out? I'm only saying it's better to come at learning to program from a base level with a language rather than a framework as I've been in both positions, and doing it all again, know where I'd rather start. I initially started learning to program when I was playing with Wordpress. At this point I knew next to nothing, and _constantly_ got myself into trouble not knowing programming basics. I knew a little, but not enough to problem solve, and as a result couldn't work anything out for myself. It was stressful and frustrating. You get yourself into bad habits such as copying and pasting code from forums without actually knowing what is going on in the code. A couple of years ago I decided to go back to uni and learn how to program properly, as I was sick of just fruitlessly hacking at frameworks. Coming back to Wordpress, Sinatra and Rails after a year of building Java apps from scratch was the best feeling ever, as I could actually see what was going on, and not only that, but I had learnt how to problem solve with programming. I'm still a learner in many aspects of programming, but after that experience, I would always recommend getting a grounding in programming basics and concepts first before ever thinking of touching a framework. &gt; &gt;I think the best learning environment is one that let's you execute your ideas and worry about the details when you need to. Just a note on this, my primary school teacher said the same thing about spelling. The policy at the time was to let kids get their ideas out and worry about the spelling later. 20 years later and I am embarrassed at how terrible my spelling is. Bad habits are hard to break. 
Hmm.... not really. Compare with this: irb&gt; class MySpecialObjectJustLikeAConstant irb&gt; def initialize(magic_name) irb&gt; @magic_name = magic_name irb&gt; end irb&gt; def inspect; @magic_name; end irb&gt; def to_s; @magic_name; end irb&gt; def name; @magic_name; end irb&gt; end =&gt; nil irb&gt; THIS = MySpecialObjectJustLikeAConstant.new "THIS" =&gt; THIS irb&gt; Object.const_defined? "THIS" =&gt; true irb&gt; o = Object.const_get "THIS" =&gt; THIS irb&gt; o.name =&gt; "THIS" irb&gt; "Proper" constants totally are objects. *User* in your example is there is an object (of type Class). It has a constant reference called *Object::User*. These are objects. I still don't see where you're drawing a distinction. EDIT: Using a less bitchy tone from me. I'm not trying to be inflammatory.
This looks awesome. 
I'd been programming for a while before I ever touched ruby or rails. I learned C first but that's because I started programming in the early 90s before java was popular and the web was still fairly new. I agree about getting a grounding in programming basics first before touching a framework. I have to point out that Sinatra is a framework too, and it hides a lot of complexity as well. Rails simply picks a bunch of defaults for you on things you'll have to do anyway for any serious project. One of the holy trails of software is code reuse. Since you can assume how a rails app works you get a lot more code reuse which is the biggest productivity gain to be had. 
I suppose it's most likely application is to create a DSL in Ruby.
Haha, I love this.
That's not the same thing at all. Look the point is this. Classes are objects. Modules are objects. They are also constants. not all constants are objects. That's the whole point. Some things in ruby are not objects and "ordinary" constants are one of them.
stfu. DSL yourself upside the head,DSL DSL DSL, shut the fuck up about DSLs you little weenie faggot.
&gt; I think Haml is such a superior choice over ERb i agree &gt; that this edition does not cover ERb at all. that's just retarded for a book called "the rails way"
How does it compare to typus? Typus has been my favorite quick-n-easy admin, though I haven't used it in awhile. The Rails 3 features look pretty strong though: https://github.com/fesplugas/typus
Hey everyone, this is my first guest post for Ruby Learning. Feedback welcome.
Holy fucking goddamn. This isn't a quine. This is *way* more impressive. This prints out a program that has an ASCII-art rendition of the earth slightly rotated. And when you run that, it outputs a program with an ASCII-art rendition of the earth slightly-more rotated, which, when you run, outputs a program with an ASCII-art rendition of the earth rotated a bit more. And so forth. I'm *very* impressed.
Wow... this is awesome
Origin: http://mamememo.blogspot.com/2010/09/qlobe.html
You can't always rely on being able to use haml either. If you have code provided by a third party source such as the analytic or adsense code then it's not really worth trying to convert that into haml, giving yourself more more work and the risk of introducing errors for code you'll never refactor yourself.
Thanks :)
If there are any questions, don't hesitate to ask :)
 # gem dependency sinatra --remote | sed -n '/^Gem sinatra-/,$p' | head Gem sinatra-1.1.0 RedCloth (&gt;= 0, development) builder (&gt;= 0, development) coffee-script (&gt;= 0, development) erubis (&gt;= 0, development) haml (&gt;= 3.0, development) less (&gt;= 0, development) liquid (&gt;= 0, development) markaby (&gt;= 0, development) nokogiri (&gt;= 0, development) 
http://tryruby.org/
You could use [web-based SSH tools](http://en.wikipedia.org/wiki/Web-based_SSH) to get command-line access to an outside server which already has Ruby installed.
Try this: ruby quine.rb ruby quine.rb | ruby ruby quine.rb | ruby | ruby ruby quine.rb | ruby | ruby | ruby ...
This is what I'd use myself. It only works for Linux based systems. If you need a Windows Ruby version manager then try this out: https://github.com/vertiginous/pik/
What's more interesting is the speed at which gems are being published (27/day).
I don't care too much for haml. If I liked significant whitespace I would be using python. Somebody needs to make a haml clone what doesn't have significant whitespace. Like builder but a little more convenient syntax. for divs
That it's not an option, because, sadly, the company blocked that port too... :(
I've already seen this one, but it's super simple... you can't make anything advanced... it's just to see how ruby works... :(
This one looks interesting... i really don't know what it does... yet... but i'll keep an eye on this one. Thanks!
I didn't noticed it was for Linux, we run Windows here, thanks anyway T_T
WTF? They blocked github too... i'm running out of options... (this one looked promising)