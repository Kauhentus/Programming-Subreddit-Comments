I suppose they also help each other to fight obvious biases in the work place. Most minorities get that. 
If this is not love, I do not know what love is!
BTW: C.S. stands for Computer Science
&gt;It might be a bit sexist because it’s slanted towards girls. The lack of women in programming is a real issue. Thats I believe the reason they were formed - to encourage women who might feel, not by their intellect but by the norms they were seeing that women don;t normally program. when you see a group of all women as opposed to group with only one or two its sends a subliminal message that can be important . Plus theres been some misrepresentation in this thread. Men come to quite few of their meetings. Years ago I just found their ruby on rails training just as good as anything I found out there male or female and more accessible. I suggested it not even knowing your gender ( gay couples call their husbands the same term) because you expressed an interest on a secondary basis because of someone else's interests so accessibility is more of an issue - different set of primary interests affects learning. 
Can you explain what this is?
https://www.codecademy.com/learn/learn-ruby
It was touched on by /u/obviousoctopus down below, but the guiding principle behind Ruby's community is "MINASWAN" -- "Matz (Ruby's creator) is nice and so we are nice." Good luck in your journey, and definitely don't hesitate to drop back in and ask questions or let us know how it's going!
Plain Old Ruby Object Lines Of Kode ?
I just throw random characters in http://refiddle.com until I get something close. 
Try my book [http://i-love-ruby.gitlab.io/](http://i-love-ruby.gitlab.io/) 
Maybe you want to try small challenges which become progressively harder. https://exercism.io/tracks/ruby was working for me.
It also matches `...@...` (which is clearly not a valid email format), and doesn't match `hello@test.XN--11B4C3D` (which IS a valid email format). Correctly matching emails with regex is *very* difficult. And the pattern may need to keep being updated as new TLDs are released/RFCs are updated. My advice when it comes to this is to simply make the pattern "very fuzzy" (e.g. `/[^@]+@[^@]+/`) to be sure it always matches valid emails. If you really want to be sure that a given email is correct, then you must *send a verification email with a link*, to that address. 
Method is not an object... 
I don't understand the title. I don't know what a "liquid democracy contract" is. Why is it "famous"? I also don't understand the code, or its significance... This is a test file, which defines a bunch of methods (that look like they belong inside a class?), and doesn't actually test anything? How do I use this code? What is it for? 
Not a good book if you seriously need to learn Ruby. But the best if you just want to know what makes Ruby fun and cool. Great suggestion.
I think you could take a look at a different programming language which has a syntax very similar to Ruby but typed, compiled and very fast, Crystal: https://crystal-lang.org.
You can learn more about liquid (delegative) democracy @ &lt;https://en.wikipedia.org/wiki/Delegative_democracy&gt; It was made "famous" by pirate parties and later by the blockchain and decentralized autonomous organizations (DAOs). Anyways, what's the ballot contract for? For voting on proposal "liquid (delegative) democracy"-style. How do you use the code? You run it with ruby (and the universum blockchain runtime, for example).
You can run the ballot contract script it on the blockchain like: ## genesis - create a new ballot contract tx = Uni.send_transaction( from: '0x1111', data: [Ballot, 2] ) pp tx pp tx.receipt ballot = tx.receipt.contract pp ballot Uni.send_transaction( from: '0x1111', to: ballot, data: [:give_right_to_vote, '0xaaaa'] ) Uni.send_transaction( from: '0x1111', to: ballot, data: [:give_right_to_vote, '0xbbbb'] ) Uni.send_transaction( from: '0x1111', to: ballot, data: [:give_right_to_vote, '0xcccc'] ) Uni.send_transaction( from: '0x1111', to: ballot, data: [:give_right_to_vote, '0xdddd'] ) pp ballot Uni.send_transaction( from: '0xaaaa', to: ballot, data: [:vote, 1] ) Uni.send_transaction( from: '0xbbbb', to: ballot, data: [:delegate, '0xaaaa'] ) Uni.send_transaction( from: '0xcccc', to: ballot, data: [:vote, 0] ) Uni.send_transaction( from: '0xdddd', to: ballot, data: [:delegate, '0xbbbb'] ) pp ballot ## todo/fix: get return value from sent_transaction assert_equal 1, ballot.winning_proposal 
Crystal is not even 0.6 ready for used. the op ask for production and you tell him about a not even beta ready language. what kind of issues do you think you will fix? Did to many years of java, and we have same ratio os bugs as doing ruby :) compiler check does not mean that you can pas Object in java to any method or interface in go :)
Can you wait? Stripe is going to open source theirs eventually. For contracts across systems, I can't recommend protobufs enough
I plan on using Sorbet if it’s ever released. I have different concerns about the others: I prefer compile time checkers over runtime, I worry about the long term maintenance guarantees, I worry that the type systems aren’t expressive enough to be worth the extra work. IMO, if you are dealing with financial transactions and want a guarantee of safety, you would be better off writing a private API or an extension that compiles to C in a statically typed language and leaning on that. I very very briefly worked for a fintech company who had a gigantic Ruby app and it was utterly terrifying.
Protobuf has very real weaknesses that only really become visible once you start working with it. Maintaining backwards compatibility is a nightmare. 
That is pretty cool! I looked through the `Qo` README now for the first time, and was impressed with how many different matching you can do with it. I haven't been familiar with pattern matching up until now (I never used Elixir or Rust), but I can totally see `Qo` simplifying our code at work. Thank you for all your hard work on this gem!
&gt; Stripe is going to open source theirs eventually well the issue is outsiders have no clue when "eventually" will happen, it may be a long time away (2019 was mentioned as the year it'd be open sourced, but who knows..)
This is the real answer to this thread. For types to matter, you have to have a compiler that is attempting to prove some level of correctness for you. If your type system only matters at runtime, all you’re doing is converting one runtime exception to another. Crystal really is a reimagination if Ruby with types added to the language. And if you’re thinking of types in the Java sense, we’ll, they aren’t nearly as limiting and they have some useful concepts not available in Java. The last 10-15 minutes of this talk cover those concepts. The first 10-15 minutes are about explaining a nontrivial algorithmically complex problem, and converting a Ruby program to crystal, and the second half conver making it idiomatic with Crystal’s type System: https://youtu.be/VgNN8iokc54
was that company in Berlin, Germany? :)
&gt; I worry that the type systems aren’t expressive enough to be worth the extra work. Honestly if you want to be able to do 99% of what you can do in Ruby with static typing you should just learn Scala. As much as people talking about Crystal as a 'statically typed Ruby', that is really not the case, Crystal bears only a very superficial resemblance to Ruby. Scala on the other hand shares most of the 'heart' of Ruby with static typing. But be forewarned - a type system capable of stuff like this is very complex. 
I _really_ don't understand why people keep saying this. Crystal's resemblance to Ruby is _extremely_ superficial. If you don't actually care about the core of the language, and only if it uses `do` / `end` instead of `{` / `}` then sure, go for Crystal I guess. If you actually care about the core capabilities of the language, then Crystal and Ruby are barely related. 
The article sucks because while having the chapter 'Why the name is `tally`?' it does not answer at all. I suppose the real reason is that it's called `Tally[]` in Mathematica: http://reference.wolfram.com/language/ref/Tally.html I've implemented it in my gem that I sometimes use: https://github.com/Nakilon/mll/blob/dece915f19017b4f6ddf477a5a49a5578dd5a74b/lib/mll.rb#L23-L34
We began using RDL on a (non-Rails) greenfield project in 2017 but ultimately ripped it out because there were too many bugs in RDL. The “release” version is almost two years old now despite decent activity since then. We opened a few P.R.s but it seems somewhat haphazard whether a P.R. will get any attention even if it fixes an obvious error. I had high hopes but RDL is just not really there yet. I don’t have a lot of faith that Stripe will actually open-source Sorbet. It’s not the first time one of their talks has ended with “we hope to, but we have to remove the Stripe-specific parts”. I also think that not using some sort of structural typing in Sorbet is probably a mistake. I have no experience with either Steep or contracts.ruby, sorry. Type-checking any code that interacts with Rails will likely be quite challenging due to Rails’s heavy reliance on dynamically-generated methods. I hate to say it (as I love Ruby), but if you want static type checking, using a language that’s not Ruby is probably the way to go.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [Ruby 2.7 — Enumerable#tally](https://www.reddit.com/r/RubyLang/comments/arowxm/ruby_27_enumerabletally/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
How is it different from https://github.com/seattlerb/ruby2ruby ?
I've used Contracts gem on some of our smaller projects to both get the method\_overloading feature and to catch bugs in development/test , i.e. no need for model specs with proper contracts and integration tests. But I also use the NO\_CONTRACTS variable to disable them in production which still keeps the method\_overloading intact. If you have good exception tracking YMMV but I wasn't willing to take the chance TBH. Sadly I've discontinued using it on newer projects because the developer has had life stop his [development on the project](https://github.com/egonSchiele/contracts.ruby/issues/249)... it happens but I was really liking where the project was headed. While I do ruby professionally and still like the language, my mental energy is now focused on Elixir. You get the FP goodness, it's (mostly) compiled, it's concurrent, it scales, it has a factor of 10 speed improvement, a very direct path coming from Rails via Phoenix, immutability, and a rock solid battle tested core in the erlang VM. While it's still technically dynamic typing, I'm willing to accept that because of the immutability. Not saying it's the end all be all for everyone but it's a good jump point for someone who is a Rails developer since so many of it's developers come directly from ruby/Rails development, it feels very familiar. &amp;#x200B;
Well, as far as I remember, Crystal started as a "statically typed Ruby" (what minimal changes could be made to language to make it statically typed), its motto is still "Fast as C, slick as Ruby". They are gradually diverging since than, but of all statically typed languages Crystal is definitely the mostly _resembling_ Ruby to say the least, in syntax, core class and method names and general look-and-feel. Just the random example from a random page of the docs: module CaesarCipher def self.encrypt(string : String) string.chars.map{ |char| ((char.upcase.ord - 52) % 26 + 65).chr }.join end end Does it look "barely related to Ruby" to you?..
I'd avoid anything that you couldn't easily turn around and run on RVM without have to deannotate your source code. 
That was actually pretty well the story. We were all talking about the name `count_by` getting rejected and kept spitballing name ideas until David mentioned Tally, so we suggested it and they took it. Neither of us are really Mathematica programmers, so it would be inaccurate to say that's the real reason.
Your example is what I'm talking about. It's purely superficial. Crystal is a language with _syntax_ inspired by Ruby, but lacks all the things that make Ruby what it is, e.g. smalltalk style OO. 
Thankfully no. And thankfully I would not recommend any of this. Ironically, though, I do think it might be worth exploring having two variants of ruby - the default one that is there is right now; and then a variant that would be similar to what crystal is doing. The syntax used would then have to be different of course but it would have better coupling to main ruby than crystal has (which strayed away from ruby quite a lot already and this will continue in the future).
Scala is very far away from ruby though. Crystal makes a lot more sense, but even crystal is not ruby either. People who like ruby want to use ruby, not some other random language, no matter what it is. In all cases, though, type systems make a language uglier and more verbose. I have not found any language that has not become more complex and uglier as a result.
ARE YOU GUYS STILL LETTING JAVA CODE PLAN HOW TO BUILD THAT AIRPLANE TERMINAL!!!
It is not ruby, though. It's very close, but it is not ruby.
&gt; not even beta ready language. While I do not necessarily disagree with you, I think it is weird to mark this towards any arbitrary random "version string" number. Some languages stay below 1.0 for many many years. Is that any true measure of stability?
Not sure. They are different languages, but I would not go to claim this: "If you actually care about the core capabilities of the language, then Crystal and Ruby are barely related." (I did not upvote or downvote you since it is just an opinion as such either way.)
What does Crystal share with Ruby other than syntax similarity? 
&gt; its motto is still "Fast as C, slick as Ruby". Mottos are not a great way to go about designing or building something. Remember Google's don't do evil motto which they abandoned eventually. Crystal is similar to Ruby but it is not Ruby. Feature parity and compatibility are not a main goal. IMO it would be more fair to point out that crystal is not ruby and ruby is not crystal. They are very close still but it's not quite the same; neither syntax-wise for all parts. &gt; They are gradually diverging since than Precisely! You showed one example but we can show counter-examples, such as the method .stringify and other parts that were mentioned such as: class Object def has_instance_var?(name) : Bool {{ @type.instance_vars.map &amp;.name.stringify }}.includes? name end end
That seems to go way overboard. I agree with the basic statement though.
&gt; I hate to say it (as I love Ruby), but if you want static type checking, using a language &gt; that’s not Ruby is probably the way to go. Or we convince matz to design a static-type ruby. :&gt; He said several times that he does not like type systems for various reasons - one is being repetition (no DRY principle) and I think there are some more. My major reason for not liking type systems is super-trivial - they always add verbosity to a language. Java is the biggest criminal offender - no wonder Kotlin became popular.
&gt; Stripe is going to open source theirs eventually. As others have pointed out - as long as this has not happened, don't believe it. I'll state the opposite - Stripe will never open source the code.
Could be a typo. They meant 2109.
What goes overboard?
&gt; Scala is very far away from ruby though. Is it? Its syntax is different but its capabilities and core design are much closer to Ruby than Crystal's are. 
Whenever I start explaining a typed language to someone I lead with “Do you know Java? Well, worry not, this type system is nothing like Java’s” :P Type-systems add upfront verbosity (though inference limits most of it to class/function definitions). But, in my experience, the time saved later trying to figure out what something accepts/returns, and running tests only to discover you used an API slightly wrong, is worth it.
Back when I was still working on ruby-lint (https://github.com/yorickpeterse/ruby-lint / https://gitlab.com/yorickpeterse/ruby-lint) I tried to get it to be used in production. Unfortunately, there are three problems any static analysis tool/type checker will run into in Ruby: 1. Ruby's dynamic nature makes it _really_ hard to support gradual or static typing in a useful way. 2. Handling third-party libraries, especially C extensions, is _really_ hard. 3. Getting people to use a gradually or statically typed version of Ruby is _really_ hard. Those who like dynamic typing may claim static/gradual typing has nothing to offer and will stay away from it. Those who like static/gradual typing may claim the tools enforcing this for Ruby are lacking. ruby-lint tried to deal with dependencies by shipping "definitions". These were Ruby files that define the signatures of types and methods, sort of like C headers. While this worked somewhat, you had to generate them for every version of every library, and ruby-lint was not able to determine which version it had to load (e.g. Rails 2 and 3 have pretty different APIs, but ruby-lint had no way of figuring this out). As a result, it didn't work too well. In short, I think the first step to make all of this happen would be for Ruby to add syntax support for type signatures. It's only a tiny step, but it would at least make it easier to annotate types; without having to rely on YARD comments and the likes (something ruby-lint supported to a limited extent).
Isn't Crystal is more mature than any available Ruby type add-ons? I would not choose it and I certainly wouldn't choose any of these Ruby type libraries. 
It was in Manhattan.
Also been using them for a year now but I don't understand your point about compatibility, it's baked into the model.
you can also use \`Sidekiq::Testing.inline!\` in dev and it will allow you to use regular pry! It also continues to work with Rails automatic reloading which is super sweet!
I don’t understand your question- that’s an entirely different project? What is it you think you’re asking?
That thing can do the same -- recreate the Ruby code with indentation, etc., i.e. appling some codestyle.
Because I didn’t? I wanted to extend prettier to support ruby. If you don’t want to use it, don’t.
I’d probably go Kotlin over Scalia if I was trying to move to the JVM and didn’t want to just use Java.
Oh I didn't realise the Prettier wasn't for Ruby in the first place.
Did you read the README or just start criticizing? Because it’s the first link on the page that says it’s a plugin.
_And I felt a great disturbance, as if millions of ducks quacked in terror and were suddenly silenced_ No-one yet knows what a truly Rubyish type system looks like, but I'm pretty sure it won't be any system where object class is conflated with type - which rules out almost everything proposed to date. I am hoping that Matz or Nobu will have some kind of Kekulé's dream only with ducks. 
I see a few issues. One, your `Procfile` contains two definitions of `web`, but that’s not valid. Two, why are you running `rackup DefaultRackup` in your `config.ru`? Your Rails `config.ru` should look like this: require_relative 'config/environment' run Rails.application It seems like you changed your config file and mixed it with a default Rack config and are now seeing errors, understandably.
Threads and Fibers are hard to figure out with TracePoint, will definitely need to do more reading on those to write about them.
&gt;I hate to say it (as I love Ruby), but if you want static type checking, using a language that’s not Ruby is probably the way to go. And there is frankly nothing wrong with this. Languages give us tools to think about problems, some are better in certain contexts than others. I am tired of languages that bolt on every feature. They all end up looking like the same language. For example, you and others have pointed out that it's incredibly difficult to add static typing within the confines of Ruby's dynamicism and ability to generate methods. Well, we could just discard Ruby's existing Smalltalk-style object model (blasphemy to me, but hear me out). Then to replace it, we could add the canonical list of features statically typed languages have to recreate that level of dynamicism: type classes, and implicits, and parametric polymorphism, and... crap, we've just invented Scala with "do/end" syntax. Sorry this doesn't help OP at all.
&gt; I worry that the type systems aren’t expressive enough to be worth the extra work. Well, when "type checking" at runtime you can make your "type system" as expressive as you want: You can write any predicate (`a -&gt; Bool`) to type check the arguments/return value. Types verified by a compiler are of course way more useful because they check _all_ code paths not just the ones you test for.
Thanks a bunch, that is way easier and simpler!
Oh, sorry, my bad. I sometimes assume that somebody saying "I don't understand why people do X" means "I am interested in reasons why people do X", and then I start to explain. But what they typically mean "I want you to know everybody doing X is wrong", so, yeah, your statement didn't need any answer.
Stripe. Check this =&gt; ["Gradual typing of Ruby at Scale"](https://www.youtube.com/watch?v=uFFJyp8vXQI)
Can you please point at some design decisions that are closer to Ruby in Scala than in Crystal? (Without generic statements like "Smalltalk-alike", some particular decisions on a particular language)
&gt; https://en.wikipedia.org/wiki/Delegative_democracy OK, that's a good starting point. Perhaps you could have begun with this. "Here is a ruby implementation of a delegative democracy (aka liquid democracy) voting system. You can read more about it here: ..." &gt; How do you use the code? You run it with ruby (and the universum blockchain runtime, for example). I've never heard of the universum blockchain until now. When linking to code samples like this, it's always a good idea to provide some more context... Like, maybe actually showing how to run this code in the universum runtime? --- I find your post really confusing for several reasons, and I suspect that's why you've not been upvoted. Firstly, the language (English) you use (lots of "brackets") with interspaced words (phrases) in between "other" (different) words is "confusing". Secondly, your post is some standalone code. Most people will need significantly more context to make sense of this. Thirdly, the code itself is confusing! After digging a little, I did manage to make sense of it.. But it's using weird stuff like [`Map = Hash`](https://github.com/s6ruby/universum/blob/e5753d47ff96d90353e2aad327365f1972514987/lib/universum.rb#L16), and non-obviously including [other files that work in weird ways](https://github.com/s6ruby/universum/blob/c2e2aef965e686fe2aed1e7053d6f85e3537f23b/lib/universum/address.rb#L5). Plus, the code seems to define a class... Outside of a class definition?! And there's no demo of how to actually run the code. I would have shared this work as a blog post, with a clear contextual explanation of what's been built, and a code sample of it in action. Linking directly to some confusing source code isn't very helpful to most people.
Good point. Thanks for taking the time. The post is part of the "sruby - Small, Smart, Secure, Safe, Solid &amp; Sound (S6) Ruby - The Ruby Programming Language for Contract / Transaction Scripts on the Blockchain World Computer" series. You can read more about secure blockchain programming in the "Red Paper" @ https://github.com/s6ruby/redpaper Cheers. Prost.
Stackoverflow is my rubber duck. 90% of the time I start writing a question, and solve the issue before finishing, because I have to explain the issue and also try to anticipate the questions people might have, which helps a lot.
Implementing criminal software with the intent to defraud users is really gross.
I like doing this in the same Dockerfile with temporary containers. You get the same effect, but it's all maintained in one Dockerfile. Basically, like this: ``` FROM ruby:2.5.3-alpine as base; // install system dependencies FROM base as gem\_deps // install gem dependencies, make sure to COPY Gemfile here. FROM gem\_deps // do the rest of what you need to do, EXPOSE/ENTRYPOINT/COPY etc. ``` Another benefit of doing it this way is you have more levels of layer caching going on, so you will only have to do a "full rebuild" if a gem adds a system dependency. You could get crazy with it and also use a system where additional system dependencies are per-line after the first declaration, but that can get a little verbose and goes against Dockerfile conventions w/ apt-get and the like. 
Not sure if you get the irony - this exercise is about **educating people about fraud**. For some more education about ICOs, see my [Awesome Initial Coin Offerings (ICO) Truths - The Art of the Steal - The Scammers' Big Lies](https://github.com/openblockchains/awesome-ico-truths) page. PS: If you read the PonzICO White Paper it was (and still is) also the intention of the original author (Josh Cincinnati). 
First - I would recommend against advertisement here. 50% of your post is advertisement to links - normal people don't do that. At any rate, from the options listed, in general I dislike having a proliferation of too many instance variables. I found that after a certain amount, it gets easier and cleaner to just store them in a hash and handle that; e. g. @configuration. Even better, to have a hash-like configuration object, e. g. "foo.use_colours?" to determine whether to use colours or not (just as an example). And making use of reader methods to query. This is a tiny bit slower than just directly using queries on the hash, or using instance variable, but I found that it is MUCH more readable in the long run and less error-prone too (since I can simply use aliases if I forgot the name ... which helps me immensely).
try posting here
There are many gems that can help with this. Rubocop will help enforce a consistent coding style and it might be considered good manners to rectify any issues it finds before asking others to read your code. Brakeman will scan your code for security vulnerabilities Rubycritic will scan your code for code smells and provide useful metrics. But, other coders are generally more than happy to browse the work of others and either pick holes in it or, more often, learn some techniques they weren't aware of. You can post here, or, in r/rails where there is a thread to post your projects for criticism/assistance every Wednesday.
Cool! Thanks for the advice :) By posting do you mean posting a link to the github repo?
Generally, a link to your repo and, if possible, a link to a running demo.
Meh. I just create a gemfile.ref and add a step to copy it as Gemfile then run bundle install. That way I have control over when the bulk of the gems get updated and I don't need multiple images.
StatsD comes to mind. It’s written in node, but has Ruby client libraries, including one by GitHub https://github.com/statsd/statsd https://github.com/github/statsd-ruby
Buy how? From an as a service provider? Do you know of any in the space? Thank you!
Prometheus is open source I believe. DataDog is an off the shelf provider. And I think AWS has an offering, though is half baked. 
It’s especially helpful for long multistage builds. I have some parent images and that are node stage, composer stage, php stage, nginx stage. Parent builds take 10 minutes. Developers can build children in 10-30 seconds.
The website Learn How To Program has a Ruby track . It’s the curriculum used for a big code school in Portland. It’s free and designed for people with no knowledge of ruby.
Drop by the #ruby IRC channel on Freenode.net and we'd be happy to review. Or like [olddang45](https://reddit.com/u/olddang45) suggests, post a link to the code here.
Thanks for taking the time to explain it to me! I greatly appreciate it!
Thanks for explaining the (!). I noticed when I had .capitalize! my code wouldn't work and when I accidentally forgot the (!) when I redid it from scratch it would work. The when statement does seem like it would simplify things. Patience young grass hopper. lol
So a joke scam on top of a real scam. That makes it worse, not better.
I guess somebody needs a hug. You are awesome!
There's a lot of magic to the way Ruby is written. When you get how it works, you feel like Albus Fucking Dumbledore. :)
&gt; We do have a macro definition so you can detect that you're compiling on TruffleRuby, so it might be possible to disable compilation of some aspects of Iodine... Is there a C extension guide for TruffleRuby, allowing developers to know which features might be supported and which aren't? &gt; Iodine is an interesting case as I would class many of the things it does as almost an anti-pattern for us. We don't support forking at this time, and it's probably not a sensible thing to do in TruffleRuby's case, and we do not currently support some of the pthread functions you use. I'm not sure which `pthread` functions are unsupported. Iodine uses Ruby threads rather than directly calling `pthread` functions... the thread creation `pthread` functions are "weak" functions offered by the facil.io library and they are replaced by iodine.
I would think that if your code has a bug in it (calling the wrong method), you'd rather get the exception immediately than getting a nil value that you will have to deal with later. Finding the error later will mean you will spend time trying to figure out the problem. Seeing the exception with the line identified tells you immediately the problem and where it is located. 
You might like to use http://rubyonjets.com. I just started a small project with it. Works pretty well so far.
You would think that, but you would still never fix all of The NoMethodError bugs. Having nil in a language is just a stupid idea at this point. There’s no excuse.
https://railseventstore.org is also a viable alternative. Disclaimer: I am a contributor.
A long very detailed article on the ruby performance research Vladimir Makarov has been doing to improve Ruby. If you are interested in language internals, you might also want to check his previous articles [Towards the Ruby 3X3 Performance Goal](https://developers.redhat.com/blog/2018/03/22/ruby-3x3-performance-goal/) and [Towards Faster Ruby Hash Tables](https://developers.redhat.com/blog/2017/02/27/towards-faster-ruby-hash-tables/)
Thanks paneq! Added it to my list [https://tefter.io/zorbash/lists/ruby-rails](https://tefter.io/zorbash/lists/ruby-rails)
What's the alternative for a dynamic language? In other languages, you still have to check the value in some way before using it if it has the possibility of being "nothing", it's just their compilers will often warn you if you forget a check. 
First recommendation: Install [rubocop](https://rubocop.readthedocs.io/en/latest/) 
Cool. Have posted in r/ruby now :)
`doc/compatibility.md` should contain all you need. At the moment I think no `pthread` functions are supported, but I'll check with the Sulong team. I did give a very quick try of running Iodine and saw a linking problem with pthread functions, which was why I mentioned them as one current barrier to running the library.
Is it effective? I'm interested as someone who should have a new req to fill come June.
We're still looking for a part-time full-stack Rails developer: https://www.reddit.com/r/railsjobs/comments/alc86w/hiringptcontractremote_small_rails_consultancy/
Sounds like it's a great idea as long as job adverts/applications are confined to those (infrequent) threads. Letting random jobseekers or thoughtless asshole recruiters spam job adverts in an uncontrolled way is a quick way to kill any good online technical community.
And have a read of both of bbatsov’s [ruby](https://github.com/rubocop-hq/ruby-style-guide/blob/master/README.md) and [rails](https://github.com/rubocop-hq/rails-style-guide/blob/master/README.md) guides, they set some good standards
I am rather against this. There are much better places to post and find job ads and chances are that eventually this forum suffers.
The README is the first place anyone will see your project, so spend some time making it look really good. Here are some questions to answer: 1. what does the application do? 2. what's the problem this app is solving? 3. how do your models fit together? 4. what does the Geolocation service do? 4. can i see a gif or image of what it looks like to use the app 5. do you have a link to a live prototype? 6. how do i clone the app down and run it? 7. how do i run the spec suite? To start, It looks like the "Add Order" button is broken - I can see the URL change but it immediately redirects me to my orders page. Line 20 of `orders_controller.rb` should be removed... In your specs, try to avoid magic numbers... for instance this test: it "should return sum of distances" do expect(order.total_distance).to eq 23203.526708347956 end What does 23203.etc mean? Try and spell it out in the code. If it's a distance, then spell out how you calculate it. It looks like the Geolocation service does the bulk of the work here, so maybe something like this makes more sense: it "should return sum of distances" do distance = Geolocation.new.distance(...) expect(order.total_distance).to equal(distance) end Your model doesn't (and shouldn't) know how to calculate distances, it only knows that it needs to find out from the Geolocation service. I would refactor the Geolocation service to have an `initialize` method that takes two distances: class Geolocation def initialize(loc1, loc2) @loc1 = loc1 @loc2 = loc2 end def calculate mathy stuff using @loc1 and @loc2 end end I would also extract the CSV stuff into a new service - that's a job that is external to the order, the order itself should just represent the domain space and not any externals. Definitely agree with /u/edgarortega - please install some sort of formatter. Since this is a portfolio project, you don't want to overburden those looking at it. 
Sounds good to me 
Thanks so much for your feedback! I really appreciate it :) I've fixed the add button so you can probably get a better idea of how the app works now. Users aren't meant to know the coords, they simply hit the \`+\` button in the order/new page and their geolocation is used to populate the form field with their current coords. Hope that makes sense... I'll get working on these changes and will start using rubocop to as suggested by someone else. Thanks again!
spam. 
In normal code I would agree with you on magic values. In my opinion rspec is slightly different. When you say &gt; What does 23203.etc mean? have you read that it "should return sum of distances". Arbitrarily or skilfully chosen chosen random values (for edge cases) in rspec are fine, we don't have to run circles around them transfering them into variables or constants or lets if it's evident what's being tested.. What's important is having good description in desrcibe/context/it. The description should reflect what the magic value is. 
That's fair. I don't disagree.
Don't create classes when there is no instance state. Geolocation is a perfect candidate for a Module. see [module_function](https://ruby-doc.org/core-2.6.1/Module.html#method-i-module_function)
&gt; I would refactor the Geolocation service to have an initialize method that takes two distances: Why? You waste an allocation every time you want to calculate the distance between two locations: `Geolocation.new(l1, l2).calculate` Constructors are best reserved for dependency injection or to build a record. `Geolocation.distance(l1, l2)` is perfectly fine in this case.
I agree with this. I don't think posts for seekers/recruiters should be allowed outside those threads because no one wants that, but I can't see it hurting if it's kept in quarantine.
Use bundler inline :) https://bundler.io/v2.0/guides/bundler_in_a_single_file_ruby_script.html
Was going to comment this myself. Make the distance method static and call it directly. There's no need to keep any state around for this.
So, this is non-standard for Rails, but it's something I think more people should do. Specifically: ViewModels. Normally, I see one of two things happen in Rails projects when functionality is needed only in a view: 1) The model ends up with that functionality or 2) the helpers end up with that functionality. While 2 is certainly better than 1, there are lots of cases where using helpers doesn't really fit well with the code. A great example is your order show page. For example, instead of all the stuff you have in the view now (and even some of the methods you have in the model), you could have a view model that looks like this: class OrderShowView attr_reader :start_to_restaurant_distance, :restaurant_to_customer_distance, :total_distance, :start_point, :restaurant_location, :customer_location delegate :restaurant, :fee, :user_id, to: @order def initialize(order) @order = order @start_to_restaurant_distance = distance_between(order.start_point, order.restaurant_location) @restaurant_to_customer_distance = distance_between(order.restaurant_location, order.customer_location) @total_distance = @start_to_restaurant_distance + @restaurant_to_customer_distance @start_point = format_point_for_display(order.start_point) @restaurant_location = format_point_for_display(order.restaurant_location) @customer_location = format_point_for_display(order.customer_location) end # This stuff makes route helpers work with your view models class_attribute :model_name self.model_name = 'Order'.freeze def to_model @order end delegate :to_params, to: @order private def distance_between(point1, point2) Geolocation.new.distance( convert_point_to_float_array(point1), convert_point_to_float_array(point2) ).round(0) end def convert_point_to_float_array(point) point.split(', ').map { |e| e.to_f } end def format_point_for_display(point) point.split(', ').map { |e| e.to_f.round(5) }.join(', ') end end And now your model doesn't need to know anything about distances at all and your view doesn't need to deal with the complexity of your data. It's all already packaged up in the way you need it for display. I prefer this method over helpers for 2 reasons: 1) It separates your model from the view and allows both to change independently of the other and 2) it keeps logic for how to display something centralized in one place. IMO, 1 is _way_ more important than anything else. It can drastically lower the amount of work you need to do to change how your models work without having to spend a bunch of time re-writing your views and vice versa. This means that you can store all the data in the way that makes the most sense and then use your view model to convert that into the format that makes the most sense for display. In my experience, this happens extremely often, especially as your application grows and evolves.
I don't get it. Isn't this a static page?
You can do this with Net::SFTP, look at the limit/offset options on `read` and there is an example of concurrent streams right in the Session docs: http://net-ssh.github.io/net-sftp/
Brilliant, thank you! I guess I didn't spend enough time RTFM. -\_-'
Thank you :) 
If we can make an European thread as well that would be awesome
This sounds interesting, if you are making it OS let me know where you are keeping the repo and I will try it out/contribute. 
hey! yay! :)
Mailhog is great! I used it extensively when writing email templates at my previous job
Just a word of caution, I had huge problems with transfer speed when using anything that relies on net/ssh (sftp, scp) and the culprit being OpenSSL ciphers implementation apparently. It was on Mac though so maybe you are more lucky but I had initial speeds of 2MB/s and it gradually went slower reaching down to 300kb/s for larger files (~1GB). See how the download speed suddenly drops and never goes up again (that happens consistently): https://youtu.be/jdhyQzJOIkE?t=50 
This is also super helpful: You can have multiline regexes if you use the \\X modifier. that way you can add comments to parts of your regexes so that its way more maintainable: ```ruby password_regex = Regexp.new(/^ (?=.*[a-z]) # should contain at least one lower case letter (?=.*[A-Z]) # should contain at least one upper case letter (?=.*\d) # should contain at least one digit .{6,50} # should be between 6 and 50 characters long $/x) ```
It sure is! Spread the word :D
This looks interesting. I have mail features on the roadmap and I will surelly consider using this when the time comes. Cheers
V. good to know, thanks for the heads up!
Definitely open-sourcing it. To be more explicit though, the goal is to create an all-in-one CLI utility that works like this: 1. search for a torrent, 2. select one from a list of results from some pre-configured trackers, 3. it adds the torrent to your seedbox, 4. it checks the seedbox every 60s for the download status of the given torrent, 5. once the torrent is complete on the seedbox, it initiates a D/L onto the local machine If you just need a segmented ftp client (or one you can use in your own scripts), I highly recommend lftp; it's highly configurable and very flexible/powerful.
Also worth mentioning [email-spec](https://github.com/email-spec/email-spec) for testing and [active mailer previews](https://guides.rubyonrails.org/action_mailer_basics.html#previewing-emails). 
I love anything solnic makes, have used his libraries in production. Though when doing SQL I've always stuck to ActiveRecord, just can't beat the comfort of it. I've no doubt rom.rb is production ready, it's probably been so for years. I feel with code that clean you can't go wrong. Worst case you'll have to fix something in their codebase which would be a joy I guarantee it.
I also remember you that if you’re using hanami-model you’re already using ROM, as Hanami is based on it.
used it almost 2 years ago (it was at version 2.x back then) in an app that still runs in production today. loved it and how easy it made everything. it was over sql so using rom-sql. the powerlifting was done by the sequel gem underneath. 
I will be using it in production very soon. Just set up a micro service that uses it. The learning curve was annoying because I was also integration dry-system but now that it's running I like it. Don't see how it would speed up or slow my workflow down. It's just a different way of doing things. Much lighter than activerecord.
Your orders controller assumes there will only every be one web server and one user.
I've been using it since 0.9 IIRC, those were tough times :) Now I'm really happy with how it evolved, solid performance, no n+1 queries, no storage logic leaking into domain parts, 0 SQL strings in my projects, except for migrations but I don't think it counts.
There is also the mailcatcher gem
Normally you invoke a .rb file from the commandline. Within that file you can store user input in like: user_input = gets.chomp And then work with the user_input variable or whatever name you give it. I don't know Atom to know why it does not work but you should try on the commandline first - when it works there then you know it should work and does work. Perhaps there is some setting or some terminal you could use in atom - geany has such a terminal (vte-based, works on linux but may work on WSL in windows too).
You need to give more information than that. Have you installed the C library? What does your code look like? How have you used gets.chomp? I’m on a coding bootcamp as well, learnt to use stackoverflow as a nifty resource for any coding queries. Goodluck bud
What are you using to run the code from Atom? Out of the box it doesn't have a run configuration tool. Based on your experience here, the plugin you have picked for this purpose likely does not support interactive scripts (those which take input from the user), but it's hard to say. https://atom.io/packages/script-runner might be one which would support your use case better. 
I don't understand what you mean by this...
I downloaded script runner and it worked! Thank you so much
Thanks to everyone else who answered too, I appreciate the help.
Installed the C library? What do you mean?
At Icelab we’ve been using rom-rb as our preferred database toolkit for over 3 years now. Not only is it production-stable, it’s now very easy to use for straightforward CRUD behavior, while still allowing for complex queries to sit right alongside. It’s probably the best thing we’ve ever done for the architectural clarity and maintainability of our Ruby apps. 
True, **but** Hanami &lt; 2.0 uses a rather long-in-the-tooth version of ROM (3.3.3, and 4.2.1 is current as I type this). Newer ROM support is just one of the things I'm looking forward to in Hanami 2, which is [in preview now](https://hanamirb.org/blog/2019/01/30/announcing-hanami-200alpha1.html) and should be released (along with ROM 5 and dry-rb 2). It's a great time to be a Rubyist!
Have you been able to use it without buying into dry-rb? That's the primary deterrent for me. 
Unfortunately I won’t be able to give you a satisfying answer from my personal experience, because we help develop the dry-rb gems, and they form a key part of our application stack along with rom. We’re very happy with it. That said, since rom is a standalone system, I don’t see why it couldn’t be used as part of any kind of application stack. There’s nothing in there that _forces_ you to use dry-rb gems alongside it, and the only 2 dry-rb dependencies that it really surfaces are dry-types for the relation schema attribute types, along with dry-struct, which it uses as the basis for its auto-generated struct classes. But neither of those would force you to use them beyond those 2 cases, and in the case of structs, you can always turn off the auto-struct feature and/or explicitly map results to your own classes. If you have the time, I’d be interested to hear more detail of why these things are feeling like deterrents to you. It would be useful to consider as we further develop rom :) Cheers!
I've been playing around with various ways to build fast syncing, I started implementing my own protocol on top of UDP but this might be simpler. I'm guessing you already know this but most of what you want can be achieved by using various other tools: Radarr/Sonarr with a torrent client with after download execute script or Syncthing on a specific folder. 
For me it's a bit difficult to talk about buying into dry-rb as a whole. Each `dry-*` gem is in charge of something completely different (validation, views, auto-loading, transactions, inflection), so personally I will like some `dry-*` gems but some others won't suit me. Yes, there is a cohesion between the gems, they use each other under the hood. But still they are separate, and I would encourage you to view them as such. For example, recently I was looking at `dry-view`, and it doesn't appear to force any kind of paradigm of programming, it just gives you a framework for writing your views (as opposed to no framework, which is what Rails gives you). 
You should! Cheers
Don't want to be that guy, but in the section entitled The State Pattern, there's a typo in the second sentence: "sate" should be "state". Otherwise, thumbs up :)
I disagree with the post on so many points. Ruby is not easy. Ruby is hard. But Ruby is also great once you learnt it and it becomes very rewarding. I don't understand why a programming language should be easy for people who haven't learnt it. Shouldn't it be focusing on people who have spent considerable amount of time with it already? To make them as productive as possible? Learning anything is not easy. &gt; **An easy to learn language has an excellent community.** This is probably the only statement I fully agree with. &gt; **An easy to learn language isn’t mangled by rules and syntactic nuances.** however ruby has a few nasty syntactic gotchas. The thing about them though is that they trip you up only once. Then you learn them. &gt; What scares many people off is seeing strings of curly braces and semicolons and thinking, well, how am I ever going to be able to read that, more or less write it? How's seeing \`end\`s and \`do\`s different. In fact what makes lisp so easy to learn is that it has 1 syntactic rule which can be explained in a minute. That doesn't make it easy to use btw in the long run. &gt; Some languages make learning functions simple because the way in which you write these functions rarely changes. Other programming languages have circus functions that differ according to context. Funny you think Ruby excels here. method. lambda. proc. block. &gt; While others might have to learn a bit of SQL to query a database, you simply need to learn Ruby’s much easier plug-and-play version called Active Record. For someone who knows SQL well active record helps eliminating tons of code they would have written themselves. I'm not saying that you have to remember the syntactic details of the SQL language, I'm saying you have to understand the semantics of DB operations and objects well, and how active record translates to them. You have to deal with indices. joins. all the nitty-gritty. You can just be short and concise about it, rather than spelling out 100 lines of boilerplate.
Hey, we use contracts for our video orchestration platform built on sinatra/resque. They are an integral part of our system validating resque job input/output. let me know if you want to know more
It's not very busy but there's https://codereview.stackexchange.com/questions/tagged/ruby
No content here. These kind of pleas have an air of desperation. 
Here's some of the code from your controller: &amp;#x200B; `def new` `@order = current_user.orders.build` `redirect_to new_user_session_path` `end` &amp;#x200B; `def update` `if @order.update(order_params)` `redirect_to root_path` `else` `render 'edit'` `end` `end` &amp;#x200B; So... If you visit the page an create a new order @order gets set. Now if I come in right after you @order gets set again. Then when you call update, you're updating MY order not yours. &amp;#x200B;
Thanks for your comment EvilInky, I will fix that! :)
As a coding n00b I have no point of reference as to how relatively "easy" ruby is, but I certainly found it intuitive and was able to guess how to do things after learning some basics and getting a "feel" for it.
Yet another Ruby vs. Elixir post? What is the point of this? Comparing any two programming languages could be considered "apples vs. oranges". You're buying into philosophies, tooling, and community when you choose a language. Just pick one and do good work
&gt; An easy to learn language isn’t mangled by rules and syntactic nuances. The more I work with Ruby and review PR's from juniors (which I can forgive) and so called "senior" freelance developers, the more I wish our app had a more stringent programming language. Linters do help, but some of the stuf which isn't caught automatically is obscene. For example: ``` class &lt;&lt; self def total_amount(currency = "EUR") some_variable_name = amount currency some_variable_name end end def self.foobar(currency = DEFAULT_CURRENCY) currency = amount(currency).currency same_currency = currency == DEFAULT_CURRENCY if same_currency return true if same_currency else false end end ```
But this kind of nasty code could be written in any language. 
I enjoyed this article, and I definitely agree that Ruby is a great language to start with as a programmer. I'm a father of young children right now, and I'm looking forward to teaching my oldest some basic programming concepts in the next year or so. Which language do I plan to teach her? Well it sure as hell ain't Javascript. 😉 I've actually grown pretty fond of Swift in recent times, so that would probably be my second choice. It's an easy language to do simple things in, but the learning curve gets steep much faster than with Ruby.
yeah that looks pretty bad. I'm not sure if having a stricter language would help. [Matz quote](https://www.quotetab.com/quote/by-yukihiro-matsumoto/smart-people-underestimate-the-ordinarity-of-ordinary-people#4JjHpOgmmyKh8lv1.97) The thing is we are living in times where programming is becoming a profession that people failed in other fields pick up, after doing a bunch of weeks in bootcamps and such. I believe people can find innovative ways to screw up in any language. The way out would be higher standards in the industry as far as code quality goes. But unfortunately quickest time to market, paying low salaries, outsourcing cheaply is becoming the standard. Nobody cares about code quality or technical debt any more.
&gt; The debate over Ruby's possible decline There are several problems with this, but here I want to focus on only one. Let's for sake of argument assume that ruby declined, in the last 5 years. This of course depends on WHAT you measure and HOW, but let's just for the moment assume that it were true. HOW would this equate to ANY alternative becoming more widely used merely because ruby were to decline? For example, do you see a gazillion new people in crystal or elixir? I don't. I don't think this happens either. There aren't that many people flowing in to languages that aren't in the mainstream. Or worded differently, many other languages have a hard time too. You only have to look at Nim as well here where Araq said that it is hard to grow. You have more and more languages but how many of these can ATTRACT and subsequently RETAIN users? Not that many. &gt; ‘Comparing Ruby to Elixir is like comparing apples and oranges. This can &gt; be deceptive because Elixir's authors have been and still are major contributors &gt; to Ruby's ecosystem, and Ruby has definitely served as a syntactical &gt; inspiration for it. And a vast number of Ruby developers have followed &gt; suit, turning to Elixir - but in truth, its similarity to Ruby is only superficial’- &gt; says developer Michał Buszkiewicz, who writes code in both Ruby and Elixir See. I don't necessarily disagree with it. Crystal has a syntax that is very similar to ruby, much more so than Elixir. Ruby is superior to both, syntax-wise. :) But the primary point is that Elixir improved on ERLANG, since erlang really has a shitty syntax. I could see myself writing elixir code, but there is no way that I waste time with erlang's syntax. &gt; A breakthrough came in 2004, with the invention of the Ruby on &gt; Rails framework. Omg ... a breakthrough-worshipping article ... I hate these articles. I hated them in Rust, I hate them in ruby just as well even more so when I was already using ruby well before rails even existed. What was the "breakthrough"? From my point of view what happened was HYPE. Hype has this problem to disappear at a later point again. And then it is replaced with "omg omg omg now there is no hype so something must be dead omg omg omg". It's like people have become chickens chasing for seeds. &gt; it was a real gamechanger in the way we write web applications in &gt; Ruby nowadays. Not really. I also write web-related stuff perfectly fine without rails. I have no problem with rails and it is fine that it exists. I just get tired of this worship-of-hype in general. &gt; Good Ruby code rarely needs comments Ok. I stopped reading right there and happily dowvoted this joke of an article. I am sorry but if you are one of those lazy ass folks who thinks that comments are a waste of time, then please - do the world a favour and use another language. People who don't document and comment are just lazy bums in general. Keep them away from your language. Or move then into python in order to cause damage. :P Nobody wants these "hahahaha ruby is so great we don't need comments and documentation hahaha". No. Such people must be kept away from any language, really. Don't let them sabotage languages by being lazy bums and teaching younger people idiocies like this article tried.
I agree. The author must be some crazy lunatic - look at what he wrote: Good Ruby code rarely needs comments You need to keep such people far away from sane code bases. Even more so because while ruby is awesome, there is also a LOT of shitty code written in it. With people claiming how "awesome" it is, thus not needing any ... comments or documentation. Keep these people away from programming!
Do you mind me asking which bootcamp you go to/ are you happy with the quality of it? DO you think it's worth the money you are paying? 
It's hard to eyeball from the broken formatting, but the issues with this code seem to be bad naming and circuitous logic, and redundant logical tests? There's no stricter programming language that will save you from any of that. It's trivially recreatable in Scala, Rust, and every more strict, typesafe language out there.
I think Arkency have the same mentality, I think they described it in their book "Rails refactoring", they will rather search through commit messages instead of be putting in comments, because comments might go stale.
`@order` in the `#update` action is getting set in a callback: before_action :find_order, only: [:edit, :destroy, :update, :show] def find_order @order = Order.find(params[:id]) end This is why some developers dislike callbacks. But, this is what a generated scaffold will look like and hence why it remains popular.
re last point about SQL: yes!! saying ActiveRecord absolves you of knowing SQL is like saying CoffeeScript absolves you of knowing Javascript. 
As a programmer with over 7 years of experience mainly in C++ - I can say, that Ruby is SUPER easy. 
I genuinely love Ruby as a language, but come on. Not even thinking about this too deeply, Standard ML is way easier to learn. It's very consistent all the way down and doesn't have the edge cases of most languages that start to make things tricky.
Ruby IS easy to pick up as your first language. Bur it is in fact a phenomenally hard language to write well. More often than not, even senior programmers end up writing a tangled mess of tightly coupled Ruby code. I almost feel like beginners should start with a language like Go - it’s small, opinionated, and shouts at you every time you make a silly mistake. 
 class &lt;&lt; self def total_amount(currency = "EUR") some_variable_name = amount currency some_variable_name end end def self.foobar(currency = DEFAULT_CURRENCY) currency = amount(currency).currency same_currency = currency == DEFAULT_CURRENCY if same_currency return true if same_currency else false end end 
&gt; Ruby’s much easier plug-and-play version called Active Record. If you don't know the difference between Ruby and Rails, you probably shouldn't be writing articles like this.
Ah yes, creating macros for `if err != nil`, great lesson to teach new programmers!
I program it into my keyboard firmware, that way it’s portable and not tied to my system :p In all seriousness, thinking about error cases IS an important and often overlooked aspect of writing code. And Ruby makes this super easy, which is why in older codebases you see a lot of `unless thing == Nil` and the good old `&amp;.`
It a lot like Python, but there’s no IDLE. (Shrugs)
What resources will you use to ELI5 to your oldest? I'm having a tough time picking Ruby up.
I would love to, I've run into many situations in my current Rails monolith where ActiveRecord was an active hindrance. It really sucks at orchestrating multiple tables, and offers no help or guides.
The real answer is always in the comments! Ruby is as easy as any other language to write a hello world in, but it’s much harder to be good at ruby than it is to be good at Python, Javascript, Go or any other popular language like those. 
ActiveRecord isn't tied to Rails. Rails isn't tied to ActiveRecord.
What is Ruby if not consistent?
I'm with you. Ruby follows really sensible conventions. Does it take a little bit to learn to write idiomatic Ruby? Sure. Still, I find there is a massive reduction in mental overhead when writing Ruby as opposed to something like Java.
ActiveRecord is just a library like any other. Funny enough, it seems like you're the one who doesn't know where Rails starts and ends.
Fintech startup. I wouldn’t say everything is written in Ruby, but an awful lot is.
I run a Ruby on Rails company. My blog is powered by Ruby too.
I do automated testing in Ruby.
Easiest, best community, best package manager, responsible for twitter and Github, etc. ;)
Hospitality startup. Rails running our website and api.
I like Ruby because it makes you think at a very high level about what you are trying to design.
Sports tech startup. Ruby (Rails + Grape) powers our web API, which mostly does basic data CRUD to power our React SPA and interface with internal analysis services. I also use Capistrano to deploy a Python (Flask) app. Before this, I was at a music ticket sales startup that also used Ruby + Grape for its API. Before that, fintech startup that had two outrageously huge, awful Rails engines and were building a bunch of new Rails microservices. Never use Ruby for fintech. ☠️☠️☠️ And prior to that, I was at a “New Media” company that used Sinatra to build an API for their internal content creation and social media content distribution SPA.
Former rails developer, now devops.
Overwhelming majority of ruby jobs are all rails. Some companies are also using ruby code as backends for serverless frameworks, like chunks of code that subscribe to Rabbit MQ queues to do something or AWS lambdas. There are lots of companies that need “tooling” to do something that doesn’t require any kind of web or user interface (command line tools, utilities to quickly parse spreadsheets or something) and they’ll use ruby for that if they’re already a ruby shop because why not, but in my experience that’s less common it’s mostly rails.
I _may_ prefer this over the wave of Ruby type annotations posts... 
Work for a software consultancy company doing web development, my main language is Ruby, but also know others. I use Ruby for client work, web development and data processing.
Sysadmin/Devops. I use Ruby because it feels less restrictive than Python and easier to read/use than Perl. 
Ruby isn't my primary language at work anymore, but it was for many years. First for scripting and build automation, then with Rails, then with Sinatra. I still reach for Ruby as my default choice for scripting and CLI tools when I need to get something working quickly. It's a beautiful language.
I work at an ecommerce startup and I'm on the Core Team of the Solidus project. Like a lot of Ruby developers (not all), 80-90% of my Ruby code is for Rails stuff. 
tldnr article is just an assertion there is no evidence presented
I'm a sysadmin, I use Ruby (and Python) for scripting and configuration management!
I use Rails and sometimes Sinatra for the backend of React apps, and Middleman to generate static sites.
Hey you can do Ruby on traditional infrastructure too. I've setup local Chef and Prometheus!
Sports tech startup. Ruby (Rails) runs our main service, which is a bunch of state machines for the various phases of competition management. Deployed by Chef (also Ruby) to EC2 + RDS. Before that, I was managing a team for AWS. Before that: thirty years of dev, ops, systems engineering for a wide variety of environments, but one consulting gig in particular at Qantas for a team full of Ruby hitters that brought me on to get their booking system into production, and I thought their code was beautiful, which is why I learned Ruby and why I chose it for my current startup. 
I work for an ISP and primarily use Ruby. Occasionally that means using rails, but more often it's sinatra or just ruby scripts.
Startup. I would say 90% of our applications are written in Ruby. We have an old Rails system(it was our monolith), but we also have close to one hundred micro services running in Ruby(From Sinatra to grape to rack).
I have been working for libraries (like, university libraries. that have the books) building Rails apps for various things, such as managing and providing access to digitized content. 
I'm assuming nothing to do with trading? 
Rails for my sports news aggregator which went from hobby to full time job.
what's your primary language at work now?
Chef! I'm actually teaching Chef next week. I work for a large (&gt;50k employees) company distributing widgets. I'm not super passionate about the product, but I get to teach, which I love (and with that many employees, there's no shortage of students :) ). We own and run our own datacenters, so a way to manage them is a must. Aaaand... I do some Sinatra/Rails on the side.
Elixir
Rails. No kidding, Ruby is a great web server language. Just run it locally and do some things normal webapps couldn't like investigate the local filesystem.
IOT developer. Our cloud is written (mostly) in Rails.
You’re assuming correctly but I’m not sure I see the connection. Why wouldn’t you want to use Ruby?
Too slow. When you're doing trading stuff every micro second could matter 
[The Odin Project](https://www.theodinproject.com) Skip the HTML/CSS course if you already know that but do all of the projects in the Ruby track. You will put a lot of that logic on a server and serve up pages using Sinatra. And eventually Rails. 
I run a company that primarily makes saas apps for Shopify’s platform. It’s really great, we use react for the front end but Ruby and rails for api are great. Easy to test, easy to get an mvp product up and going, great community. Love me some ruby. 
Bunch of CLI stuff, mostly. I use Rails and Sinatra in side projects, but my day job is mainly C# (our main application). I'm our professional services guy, and if I need to stand up a web connector or clean up/organize/mutate a bunch of data, Ruby is the first thing I reach for. 
Hmmm. Not a bad idea, I am already familiar with Rails
Yup exactly this
Ah, totally true. But then I think if you’re going down that “milliseconds matter” road, the least of your problems are your selection of language and look more like how far you are from a data center in New Jersey. :) There’s (I imagine) also lots of ancillary systems a company needs to build, like admin dashboards, that don’t need to be engineered to the same speed standards as the trading part of your stack.
B2B SaaS company with two monolithic Rails apps. I think the majority of Ruby work is still with Rails and don't see that changing for quite some time.
sweet thank you
Ruby on Rails for Ed-tech platform web-app [https://www.pobble.com/](https://www.pobble.com/) But there is also lot of plain Ruby DevOps around it (so Ruby CLI too)
&gt;But then I think if you’re going down that “microseconds matter” road, the least of your problems are your selection of language and look more like how far you are from a data center in New Jersey. Hahaha, true 
The type of speed your taking about is one specific type of trading. Tons of FinTech runs on "slow" languages.
Huh, TIL 
&gt; one consulting gig in particular at Qantas for a team full of Ruby hitters that brought me on to get their booking system into production, and I thought their code was beautiful Care to elaborate on this? You don't hear this sentiment often.
I do test automation development with Ruby and Cucumber. If you're interested in QA-type work, it's pretty enjoyable! My company gives us a lot of free reign with framework design, not sure if that's standard but it is pretty nice.
Book store. We have about 30 Rails web apps. About 19 of those are JSON APIs of varying size and scope. We use Ruby with Chef for deploys to AWS. We’ve created a handful of gems to reduce duplication of business logic across a few apps. Most apps are internal things like a point of sale system, inventory management system, marketing platform, sales reporting but we also have our few main customer facing e-commerce platforms. 
Pry is the closest solution 
I’m a software engineer at Airbnb. The main Airbnb web app is a large Rails monolith from when the company was started in 2008. But now the company is moving to SOA and breaking up the monolith into services, some Ruby and some Java. I’ve worked on the main app, also on another internal Rails app that was the UI for customer support reps, also on a Ruby CLI tool that does code coverage post processing and reporting. For 3 years I’ve taught a 1h30m Ruby and Rails class to all new Airbnb employees. But the class is outdated because it is all about the old way when everything was a monolith so now I’m rewriting it to be focused on writing Ruby services.
Startup founder, built our web app on Rails.
Yeah I should have mentioned chef is a big thing. It’s a great example of companies using ruby every day.
They wrote a rich OO domain model that was nicely refactored without getting bogged down by Too Much Framework. Sophisticated use of the frameworks that it did import. Plenty of well-named, loosely-coupled POROs extracted to implement logic that other objects/models could pull in as necessary. Most concepts represented by domain-specific objects not primitive types. Good use of declarative scopes and secondary associations for composable queries and relations. Null objects for many attributes, dependency injection for behavioural composition. Tests that focused on integration &amp; function, not units. They favoured short lines and short methods, the flipside of which is class names &amp; method names were long and descriptive. Overall a clear style of code that was easy to follow and readily open for extension. The only part I remember thinking "oh dear" was the routes.rb file which was a byzantine epic of accumulated cruft and special cases. They were pretty high powered. One of the members of that team was the author of a widely used and well-known gem, others were simply very experienced developers. The kind of people who would read Design Patterns and write code that followed a pattern, rather than looking for a gem that implemented an abstract framework of that pattern. The (very minimal) management had an attitude, mostly, of "hire smart people; give them goals; give them the tools &amp; resources they ask for, and get out of their way". I really liked them and it was a great experience. I helped stand up the CI/CD pipeline and get the service into production shape for launch. The service they built still operates today. 
That’s so cool to hear. Thanks for sharing. This is the state of the art we should all aspire to.
Shipping logistics - Rails backend, Vue frontend
I used this many years ago and it was decent back then http://shoesrb.com
To be fair ancient Aramaic is easier than Perl ;)
Working with PHP. I use Ruby for my side projects. 
This. I worked for a cryptotrading fintech in the past. They were busy rewriting the trading software in Java because they needed to focus on speed to remain competitive.
&gt; Active Record Are there languages that don't have ORM libraries? Seems like an odd thing to highlight.
We have been using Hanami in our production app for almost two years now, and hanami-model (which uses rom-rb under the hood) has been good for us most of the time. I really appreciate the separation of concerns that hanami incentives. The only real problem I ever had with it is that hanami-model and rom make it a bit difficult to perform more complex queries effectively (for example, fetching data from multiple tables in one query). In the few cases where we needed good performance with more complex queries, we used Sequel directly (still inside repository calls).
Quality Engineering writing tests in Ruby within the rspec framework for a financial technology company.
I’m developing in ruby in couple of contexts : - Rails for reservation websites in tourism industry, including large APIs for some of our frontends or other clients. - Rails as API for mobile &amp; react projects for educational projects (with addition of python code with our Machine learning models) - in all projects, there are also pure ruby code for some tasks, sometimes involving system/binary calls, like pdf extraction, ffmpeg transformations or complex images manipulations 
Thanks.
People keep on sleeping on [Ruby-GTK](https://ruby-gnome2.osdn.jp/) despite the fact it is under active development
I am doing DevOps (more dev than ops) and I use Ruby to develop for Puppet and create scripts for other automation tasks.
Web agency as a backend dev. Did PHP for years at other companies and came to this agency t do Symfony, but instead the whole team decided to transition to Ruby and Rails. 
Never seen one for Bash
I have a design and web studio with my wife. I try to ship projects as much as possible in rails, but also work a lot with nodejs/react (nextjs is the bomb btw) and started learning elixir/phoenix!
Social network / dating app with a very large user base. Backend is mostly a Rails monolith.
you can use jruby, and: https://github.com/jruby/jrubyfx is a nice wrapper on top of javafx :)
Not all that surprising as it's a procedural scripting language. Hard to have an ORM when you don't support OOP.
Software testing evangelist. I have worked with ruby on and off for the last 10 years right from WATIR, selenium-webdriver, BDD using cucumber, RSPEC, capybara.. The ease of using ruby helps me focus more of my effort on QA. At the moment I am learning rails to help create an app that will help me and my team create test data used for our Manual testing scenarios and save us some time. &amp;#x200B; &amp;#x200B;
That's a bad comparison; Sure, it's easier to implement prime factorization in [ruby](http://rosettacode.org/wiki/Prime_decomposition#Ruby) than in [C](http://rosettacode.org/wiki/Prime_decomposition#C), but how easy is it to implement it with the same performance? It only really makes sense to compare ruby to other scripting languages with at least similar performance goals, and even then I'd say you're already comparing apples to... pears, maybe?
The two are conflated almost everywhere these days, and I don't understand why. FFS there seems to be a stronger association between ruby and rails than javascript and browsers!
While the core platform should be written in a high speed language, it is not uncommon to choose a scripting language for "everything else". Ruby is great for this since it is relatively easy to learn and very easy to read. If Ruby is even in consideration for high performance market platforms where microseconds DO matter, I’d say you are already doomed and choosing Ruby over Python or vice-versa is irrelevant. You'd be better off writing a check to 1 Wall St. and save yourself some time. 
I work for a company that uses Ruby and rails for medical billing, Gene sequencing, and stock market analysis
I Love Ruby, its been like 4 years of joy developing personal projects. I work as a PHP dev. Couldn't find a job with Ruby in S.F., Argentina.
Crypto is a different breed within the FinTech market - I would not consider their practices to be the norm. Jane Street's matching engine was originally Java but they rewrote it in Ocaml and are now the largest contributor to Ocaml so it's not unheard of. Here's a link to a lecture a Jane St. employee gave if you're interested [Youtube](https://youtu.be/b1e4t2k2KJY)
&gt; Are there languages that don't have ORM libraries? Seems like an odd thing to highlight. Assembly, bash, brainfuck, etc.
&gt; Easiest, best community, best package manager, responsible for twitter and Github, etc. ;) - Easiest to get started, maybe. - The community is also filled with people who have no clue about anything, so it really depends on where you look. - RubyGems is great, but many other languages have copied it by now. I personally prefer luarocks, because it pulls the cod directly from git instead of packing it along with the package. - Any larger Language is responsible for *something*, and Ruby has gotten big largely due to rails, so this is neither surprising nor something that sets it apart from other major languages.
I both like and hate that about ruby. It makes so many high-level things incredibly easy, but that often makes very complex things seem computationally trivial, even when it's really not. This leads to easy to understand but sometimes very slow code.
I've defended Lua as one of the best languages for teaching people to code for a long time now, and Ruby is probably one of the only languages I'd consider a very good alternative. The fact that you can use ruby itself to interact with its VM, (I believe you can even inspect the bytecode from within the irb repl) makes it a great long-term option that's hard to outgrow unless you want to learn the very advanced low-level things like pointers.
Tonsser. Sports tech startup. Our whole backend is Rails. 
&gt;Crypto is a different breed within the FinTech market - I would not consider their practices to be the norm Crypto trading is still trading, and when you're dealing with professional traders, speed is still king. A lot of crypto trading firms have gotten away with using slower languages like Python and Ruby because there hasn't been a lot of (serious) competition, but with the biggest trading firms experimenting with cryptotrading you are seeing more and more professional traders starting to trade, and thus standards and expectations are rising. So you either start the speed race to retain your edge or you lose out. It's that simple.
You hire freelancers?
Couldn't agree more. I know it's not possible, but I would love to look through the codebase of a project this well written in Ruby and just be in awe of it.
Yes we do. But am not sure weather I will get banned if I share my contact details here. So PM me.
Ok, but saying ruby is easier than assembly is a bit tautological. I'm thinking about something more of its contemporaries like Python, JavaScript, etc.
Yes that is true, novices write all sorts of weird code.
&gt; The only real problem I ever had with it is that hanami-model and rom make it a bit difficult to perform more complex queries effectivel I'd like to clarify this a bit - rom-rb *standalone* provides features that typically make it easier to construct complex queries than when you use plain Sequel. If it's not the case - report an issue and we'll make it better. Now, when you use hanami-model, you actually use old rom (3.x) and there are lots of missing features and various limitations because of this. I would recommend using rom-rb standalone in hanami apps w/o hanami-model *for now*. In hanami 2.0 we'll upgrade everything and make the model part much better than it is now, so stay tuned.
Hey, it was your question, I just gave an answer ;)
&gt;novices I really wish that was the case some times...
Legal startup that has what I will call 'legal process hardcoding hell' (each model needs a state specific customization.....occasionally) so code reuse doesnt happen
Sports tech company, stadstech.com , building a marketplace for selling soccer clubs in stadium during games, ad spaces. The actual app is on stads.io , using latest rails version, and I must say it saved me a shit load of time to go with rails.
Working for a small team at a unicorn that recently went public. We run Rails but we primarily do batch computation which drives advertising automation/adaptive bidding. I've been using Ruby in the context of batch computing for the past 6 years or so. I do the occasional web thing, but I'm mostly working with distributed processing usually backed by a work queue I also use Ruby for my own general scripting
And if you're a total masochist you can `require java` and call swing (or any other JVM UI library for that matter) directly without a wrapper.
Sorry if I ended up not being clear about that. I have never used rom-rb as a standalone. I'll take a closer look at the docs for the 4.x version of ROM. Looking forward to hanami 2.0! 
Hey, at our company we've been using dry-web + rom stack and hanami in our app for over 2 years now. &amp;#x200B; I think the general problem here - teach other developers to use it and explain that it's not an AR. About workflow: first 2-4 month it was slow. But now I think I can build something with rom/hanami-model faster than with rails and don't think about a lot of problems.
remind* (I stared a few seconds before I understood this response) btw, thanks for Hanami!
Webapps seem like the best way to go there if you are not into Java/Swing/etc. A great Ruby GUI project is [Ruby2D](https://www.ruby2d.com/) but it is intended for games and it doesn't have UI components like a spreadsheet that you might need.
https://www.railstutorial.org/
Freelancer here... RoR sites and intranet apps out there over the years. Also have some Ruby/R machine learning integrations and RoR/R data mining integrations running at a several client's. &amp;#x200B;
Tk is still a good option that I feel usually gets ignored unfairly. It's easy to make a cross-platform UI with native look and feel if you use Tk::Tile. There's a pretty good beginner's tutorial at https://tkdocs.com.
Thank you guys for contributing, I'll start with a PoC and then probably adopt the gem entirely. 
Did not know about this podcast, sounds cool, thanks man!
Not really. [Ecto](https://hexdocs.pm/ecto/Ecto.html) does just fine
That looks cool. Have you done it before? Just wondering how long it takes.
Once you are past the beginner stage, [Upcase](https://thoughtbot.com/upcase/rails) is great.
I did it from beginning to end and it took about 9 months. If you read and watched all of the additional resources it’s probably about a year of solid work, but at the end I had 10 - 15 solid projects to show at interviews. Odin is tough. It doesn’t hold your hand. It gives you a project and hands you the docs and has you figure it out. I struggled a lot, but those eureka moments were very rewarding. 
We've not done a great job of sharing it around yet. Trying to be better about that. :)
Great podcast. It’s been great to see Jason’s skills as an interviewer improve so much each week! Good up the great work!
I guess the answer depends on how much time you want to invest yourself. If you have lots of time I would recommend doing everything by yourself. :) It may not be realistic so you may possibly have to use a base written by others. Rails may be an obvious choice but you could actually try sinatra first, then padrino, if only to understand the concepts and start from a simpler system. It may also be worthwhile to actually forget the web-related aspect for the moment, and just focus on ruby for some time (dunno... 2-4 weeks or so); and use a bit of cgi or cgi-wrappers just to keep it simple. And go from there. I think the most important thing is, no matter what you do, is to write a LOT of code in ruby yourself. It is in my opinion the only way to really learn ruby. For basics, you can work through some tutorials, such as learn to program and the sinatra base tutorials and so on. It's trivial to setup so you should get things running quickly.
Depends on what you mean with "killer". I use ruby-gnome and it works very well for my use cases. There are not that much to choose from ... :( With java+jruby you can use swing but ruby-gtk actually looks prettier. We used to have ruby-qt bindings but all the qt folks gave up due to qt constantly changing like idiots. The last ruby-qt release actually looked nicer than ruby-gtk, but I stuck with ruby-gtk mostly because it's maintained and easy and quite well documented (I collected snippets since many years). Shoes used to be good back when _why is around but it has been morphed into some useless java shit. It was much better when it was based on C.
I use it! I think it's fine.
Problem with tk is that it is ugly.
Never used it myself, but [https://github.com/vaiorabbit/ruby-imgui](https://github.com/vaiorabbit/ruby-imgui) 
&gt; I am sorry but if you are one of those lazy ass folks who thinks that comments are a waste of time, then please - do the world a favour and use another language. Are you one of those lazy ass folks who is satisfied with using a comment to clear up confusion, instead of doing the boring, tedious design work that would eliminate the confusion in the first place?
Not with Tile. Unless you consider native look and feel ugly?
Nobody talks about performance / language features / safety / paradigms etc. - just a learning curve is a waaaaay stepper in languages from for example C family than in Ruby. 
Ouch, I just noticed the typo.. 😁
I’m software engineer in UK company which automates tenants/landlords providers switching like gas and electricity on move in/out
Do you have a website I can check out? I teach Rails testing as well so this is interesting to me.
I use it in production for almost 2 years now. What can I say? It just works and never got in my way. I tend to prefer it over hanami-model at the moment, but hopefully Hanami 2 will change that.
I don't think "wasting an allocation" is anything you need to be worried about in modern ruby. I think either of those implementations is fine. 
Nope. `@order` is an instance method, and Rails instantiates a new Controller instance for every request, so `@order` doesn't stick around. It can never be shared between users/requests. From just the code you pasted, that would mean the code wouldn't really do _anything_, so... something else must be going on. Like `before_action` like 44201 points out. 
Serious question, is Cucumber a pain in the ass? What's the point of it besides making the tests easier to read? IME tests are easy to read using Capybara.
Fuck, now I want to work there.
This seems to the best for me. Thanks for the response. Much appreciated.
I remember the analogy you are referring to. I’m fairly certain it was Yehuda Katz some time in the last year or two but I don’t remember where he said it. 
Was your class specific to Airbnb domain knowledge or do you have resources you’d feel okay sharing?
Was it easier building out the backend since Shopify is built on Ruby*? I’m trying to flesh out my own Shopify app at home but just starting and was going to do React with Node/Express on the backend but I’m not sure if the latter was a feasible decision *I believe 
When iterating over thousands of location pairs it absolutely makes a difference. It has other drawbacks besides non-injectabity and performance: Documentation is split across two methods (input types in `new`, return types in `calculate`); it’s stateful so you can’t be sure other methods don’t mess with your instance methods before you call `calculate`; and `.new.` is just unnecessary noise you have to skip over when reading.
Final interview for a startup internship next Thursday but it sounds as though there is a very good chance I land it. Ruby is their go to so here I am trying to take it all in.
Don't underestimate Perl's influence on Ruby. Perl, for me, was always a joy to work with - the first expressive mainstream language. Clojure, I would argue, is now the most expressive.
&gt; It makes a difference when iterating over thousands of location pairs. I doubt there will be a case where the time it takes to actually make the calculation isn't at _least_ an order of magnitude more than the time it takes to create an object, meaning it won't make a performance distance even with thousands of location pairs. I could be wrong, one can always profile. On my macbook, it looks like an object instantiation takes about .000001 seconds, that is .0001ms. Premature optimization and all... 
I don’t think it’s necessarily easier due to that reason, but for the sake of their support wrappers for their api I would and do use ruby in a heartbeat. Their client lib is pretty great (shopify_api gem) and they have another gem that tries to build out the basics for a full app (shopify_app gem). I think they have officially supported client wrappers in node too, so you should probably use what you are most comfortable with. 
Protip: Reddit doesn't support code fencing. You have to indent 4 spaces.
Cool stuff! I haven't really heard about about these three ruby methods that you brought up! :) I'll see if I can refactor my code to makes use of these three instead of what I did which was to make use of \`prepend\` on the \`Module\` class. I'll try to understand the methods you've mentioned first :) Great suggestion about the styling! Yeah now that I think about it i should have also supported that block syntax. Although I think I'll still support this current styling as well, so that it conforms closely to how \`def self.included\`, \`def self.extended\`, and \`def self.prepended\` looks like :) Maybe support for both is ok. P.S. Yeah I was also a bit worrisome prepending methods (\`include\`, \`extend\`, \`prepend\`) to the \`Module\` class, because I was still not sure (though I understand the \`ancestors\` hierarchy) if it might produce unwanted side-effects, though so far in my tests in a rails application, nothing seemed to have break (yet) hahaha Thanks for the suggestions!!
Oh no worries, just wanted to explain things for you and other readers :)
&gt; one can always profile. I did: For a simple Euclidian distance calculation the class method is about twice as fast as the instance version (the iteration count doesn't seem to matter). My computer isn't the most powerful, though. I believe the `.new` version also requires two additional method invocations (`new` + `initialize`?) and two ivar assignments. require 'benchmark' class Geolocation def initialize(loc1, loc2) @loc1 = loc1 @loc2 = loc2 end def calculate Math::sqrt((@loc1.fetch(:x) - @loc2.fetch(:x)) ** 2 + (@loc1.fetch(:y) - @loc2.fetch(:y)) ** 2) end def self.calculate(a, b) Math::sqrt((a.fetch(:x) - b.fetch(:x)) ** 2 + (a.fetch(:y) - b.fetch(:y)) ** 2) end end A = {x: 2.0, y: 4.0} B = {x: 3.0, y: 4.0} def measure_instance_method(n) n.times do |i| Geolocation.new(A, B).calculate end end def measure_class_method(n) n.times do |i| Geolocation.calculate(A, B) end end Benchmark.bmbm do |x| x.report("instance method") { measure_instance_method(10000) } x.report("class method") { measure_class_method(10000) } end 
Me too. Dogs are out though. Rails is not for you! Cats can stay.
I have literally no idea why this matters.
Our insane societal state is why. Shame tech puts its appendages in areas such as this since it's breaking things further.
Maybe you try thinking about it.
Please educate me.
Educate yourself.
That is not helping the cause you are fighting for. You do realize some of us are not americans and live in very homogenous societies ? You do realize that “acts of inclusion” like this are a very alien concept to many of us ?
So based on this response it sounds like you already understand why it might matter to some people, and you’re just arguing in bad faith.
Lots of different things can matter to lots of different groups of people that does not mean they necessarily universally matter at all. I never looked at a korean ad for samsung phone and thought it needs more diversity also the same way I never really bothered wondering why do so many american ads have so many different races in them. It just never crossed my mind to even have a reasoning about it. That’s why i cant get the concept of diversity == good or even better than no diversity at all. To me it is totally an alien and weird concept as I dont understand the need for it. 
The image depicts people on Planet Earth. Do you _really_ think it would make more sense for the image to depict people living in a particular homogeneous society? Of course, not! Because you haven't considered the image. I don't even think you've fired a single synapse towards any effort to understand the image at all. Instead, as soon as you saw the headline, you immediately set the whole story against the larger backdrop of your trite, uninformed political narratives. And now you presume -- because you're projecting -- that _I'm_ here fighting for a cause. I'm not fighting for a cause. In fact, I'm actually giving you free advice. And I can't seem to figure out why it matters to _you_ so much, which is funny considering your original comment. 
Rails isn’t a nation weirdo 
Oh it does not matter to me at all. I was just wondering why it matter to people in such a thing like a software. I would not have noticed the meaning of the picture if it would not have been pointed out in the first place. I did not even think about it any more than a mere illustration. The picture could have been trains on rails or what not. I am sure this matters to some I was just surprised it is a thing for eh illustration. 
Pretty much the point is to make the tests human readable so even a non-technical person can understand what's being tested. I haven't worked with Capybara so I don't know if Cucumber is more or less painful to work with, but my experience with Cucumber is that the ease of use depends on how the step definitions are written. Since step definitions for us are just Ruby code, all the standard Ruby code quality assurance tools can be used.
I am a person of color and I am with you. I don't give a fig newton about coloring in a welcome image and putting a turban on one figures head. It doesn't do a thing to include anyone of color and frankly the people who think its such a big deal and so important are people who have never been called a word or experienced real racism like I have. Not fighting against it. Its fine but not important enough for me to be really loving it especially since every developer in ruby in a heartbeat after install deep sixes the image without looking at it closely. &amp;#x200B; Tehres much bigger fish to fry in "inclusion" 
It’s a tiny thing that’s just kinda cool. Not earth shattering at all, but then again, I’m a cheap upvote 😅
&gt; Oh it does not matter to me at all. Your participation proves otherwise.
It's not a huge deal - I'll give you that - but small gestures help. If anyone who sees this image as a student feels more welcomed as a result, that's a net win. 
&gt;If anyone who sees this image as a student feels more welcomed as a result, that's a net win. Okay first let me say your heart is in the right place so no harm no foul but let me give you another perspective. Don't you think that its just a little bit condescending and unappreciative of what people who actually experience isolation and prejudice go through to think that merely coloring in an image on a black and white cartoon of a throwaway page alleviates those issues they face and makes them feel more welcomed? Honestly as an african American I never thought a thing of the old one. to me it was a back and white drawing. No one had any shade even pink. when I draw a stick figure , go figure, I don't color in the face of the stick figure. Now here's the thing. I do know people so race conscious that they see it everywhere - but the problem is those are the people who simply filling in colors on a welcome page aren't going to feel comfortable just for that. anyway the change is fine. I have nothing against it but yeah I can see the person s point asking why is this a big deal Its nice but it really isn't one. Its even less so with ruby on rails. Matz is Asian . I never felt Ruby lacked inclusion. 
&gt; To me it is totally an alien and weird concept as I dont understand the need for it. Well that's entirely on you, because there is so much literature on this subject that you wouldn't even be able to read it all in your lifetime without dedicating your life to it. So, given that you _don't_ understand, why not do the honorable thing and decide _not_ to weigh in? Oh, right, you're not here telling everyone that you don't understand something. You're here to tell everyone that you think it's bullshit. Just be honest. Alls I'm trying to say is that if you want to call it bullshit, do your homework first.
Should we not do anything except fry the biggest fish? I mean this didn't take much effort so I doubt it took any work away from frying the biggest fish nor do I think the same people who did this were going to fry that big fish anyway. I hate this "we have bigger fish to fry" mentality. Do what you can, even small things matter. Do the little things every day. That's how progress is made.
&gt;Okay first let me say your heart is in the right place so no harm no foul but let me give you another perspective. Don't you think that its just a little bit condescending (wrong word but I can't think of the right one - maybe short sighted?) of what people who actually experience isolation and prejudice go through to think that merely coloring in an image on a black and white cartoon of a throwaway page alleviates those issues they face and makes them feel more welcomed? Maybe a little. Even if it doesn't does it hurt them? Does it make the situation worse? &gt; I never felt Ruby lacked inclusion. Many people do. Not just ruby the entire tech community. Of course everybody has their own notion of who should be included. Maybe one person thinks there are not enough African Americans and another thinks there are not enough homosexuals and another thinks there are not enough Jews and another thinks there are not enough Muslims. I don't think we will ever agree on how much to include what kinds of people but I am glad that people are talking and doing the little things instead of pretending everything is OK.
As fully expected, this comments section devolved quickly. 
The sentiment is good. But such efforts always feel a little forced. And it always still reveals preferences of the creator, it can never be made fair. Why is the white girl in the middle? Why the guy in the wheel chair on the side? Do we want white girls more than wheel chair guys? I could go on, but you get the idea. I can’t do it better. Just saying. 
I think the problem is small things like this satisfy the need to be fair and nothing else will be done. This is like hacktivism.
\&gt; I hate this "we have bigger fish to fry" mentality. well I been nice about it but if you insist let me put it more direct who give a royal fig what you hate? this is nothing. it stops no racism. It reverses no injustice. It doesn't do the first thing to include anyone because most ruby gatherings are still about 90% white in my country (and I don't think thats even anyones fault except perhaps in the hiring room). I have already said it was okay even said it was fine but that wasn't enough for you you had to take issue with the truth and called it in a derogatory manner some kind of "mentality"- yep there ARE much larger issues. That not a mentality you poor soul . Thats just fact. So tell me what this does do besides put some color on my screen. Whats the little TANGIBLE thing that supposedly does? Is your idea of people of color that they are so dumb or intimidated that black and white drawing on a welcome screen put them off ruby or rails to do their development and now some brown pigment and a turban now means - oh wait I can use ruby on rails now? Seriously? Are you even a person that can talk to non inclusion that you can even dare to talk about bigger fish to fry "mentality" you hate? I applaud the person who thought to do it. It shows where there heart is and my bet is THAT person wouldn't take issue with me saying there are bigger fish to [f](https://fry.So)ry. &amp;#x200B; So yep this person of color says its fine but this person of color can also agree with the guy I commented on. Does it matter? In the greater scope of what we can do that make people feel really included ? no not a whole lot. The recruiter that takes the next interview that doesn't see color does 10,000 times more do what you can no matter how small it is - is just a cop out. everyone can do much more than symbolism. We all can do something real in someone s life that matters far more. So again good for Rails and the new splash of color . Noting against it but can agree to put it into perspective Demerits for anyone that thinks saying we have bigger fish to fry as a bad mentality. You got far more to learn tht the person who asked if it really mattered. 
 Many people do. Not just ruby the entire tech community. &amp;#x200B; the entire tech community yes. Ruby with Matz as lead. I've never heard anyone single out ruby as non inclusive on the basis of color or race. &gt; I don't think we will ever agree on how much to include what kinds of people but I am glad that people are talking and doing the little things instead of pretending everything is OK. false set of choices
Oh god why
Currently I work over at Square in SF. I'm working on the Frameworks team, which is essentially Ruby infrastructure for the company. We use quite a bit of Ruby for all types of different things: * Rails - Some of our main applications are running Rails, publicly facing * Sinatra - Some lighter-weight internal APIs are using Sinatra * CLI - We have tons of CLI tools for building things written in Ruby * Data Flow - There are teams that use Ruby to work like an ETL pipeline * Logging and Monitoring - A lot of the internal logging and monitoring tools are using it * Manager code - Most of the promotion and other manager type code are Ruby scripts * SDK documentation and generation - Most of our external APIs documentation is generated in Ruby A good portion of these are publicly viewable as well. Now as far as fun projects my team is working on directly, there's some fun around automatically upgrading Ruby code.
I would have agreed with you up until the day the Toronto Maple Leafs drafted Nazem Kadri and I realized for the first time that Arabs could be professional hockey players. It wasn't that I actively thought that Arabs couldn't be hockey players, it was just that I had never seen one. The image was novel. I can't imagine what Nazem Kadri went through to get there. How many Arabs before him failed. But there I was, an Arab Canadian for the first time realizing 'oh yeah we could actually play hockey'.
&gt;false set of choices How. People here are whining that they changed the picture a bit, they want to pretend everything is OK and nothing should be done. Not even a tiny thing like changing a picture a little.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [Writing Ruby extensions in Rust](https://www.reddit.com/r/RubyLang/comments/au4x84/writing_ruby_extensions_in_rust/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
&gt;who give a royal fig what you hate? this is nothing I give a shit and this is clearly something because it has triggered a lot of people. &gt;yep there ARE much larger issues. Thats not a mentality you poor soul . Thats just fact. The mentality of saying "don't do little things because there is still racism" is bullshit. &gt;So tell me what this does do besides put some color on my screen? It sends a signal to people contemplating learning rails. Apparently it has also severely triggered a bunch of (probably white) people who all of a sudden don't like that everybody in the picture isn't white and european. 
&gt;I think the problem is small things like this satisfy the need to be fair and nothing else will be done. Why do you think that? Where did you get the notion that nothing else will be done? 
&gt; I don't give a fig newton I have nothing to really add to this conversation right now other than I absolutely love this phrase. 
oh geez. If you don't think it matters, why are you so invested in complaining about it? Let the people who think it matters think it matters, move on. 
It's not always the case, but it's typically the case. People get upset about an issue and want to change it. But they don't have unlimited attention span or resources to do so. If they can satisfy their disturbed state of mind with some superficial thing, they typically won't make an effort to do meaningful things beyond it. This is why shady NGOs keep receiving donations. It's easy to donate $10. Nobody cares to actually search up a meaningful way to help those in need. For most people, it's not about actually helping, it's about shutting up that inner voice that tells you: "dude, you have to help or you're a bad person, and karma will get you..." Portraying reality and acting inclusively is more honest. Ruby devs are 90% asian or white males. Why not show reality if we absolutely have to represent our global community with a picture. Nothing wrong with the current state of things, as long as we're providing equality of opportunity, which I'm 100% for.
&gt; Don't you think that its just a little bit condescending Precisely.
You wouldn’t give even a single fig newton if the image was all mid 30s white males?
\#AllDogsMatter
You dont seem to get what I was trying to explain earlier. If you are dealing with local problems on a global platform you get all sorts of surprised faces. By forced inclusion you alienate all sorts of other people. The gap between your average person of color in the USA or an average ukrainian is just as big and you dont care because you dont deal with such group of people. 
Since when were frameworks exclusive to begin with?
What the actual fudge? Besides - how would you even come to reach this "conclusion" to begin with? It would assume that the image before would be less "inclusive", whatever that even implies. I don't see how or why. I actually find the new one insulting. IF you'd really want to, the best would have been to simply create a new image altogether. Then again I think this is all just useless PR. It is the software and the usability that matters, not any random graphics drawn by a three years old.
I am a cat person so I am all in favour of empowering cats. I think we can agree, though, that the mythical Arche Noah was not using rails to power ferrying the animals though.
Precisely! I had a similar question. I think tosbourn is trolling us.
Garbage in, Garbage out. So in other words - the link + title is total crap. What do you expect for people to work with if the original statement is so terrible? They can't turn low quality into a high quality. That filter does not work that way.
But it is not even about "colour". I understand the claim by the one who linked in the comparison but I am not even REACHING that point because I think this is all random rubbish that can not even be evaluated at ALL for anything that tosbourn would want to claim.
This is not a "small gesture". It is also your BRAIN that ASSUMES this to be a gesture to begin with. For a similar problem these CoCs do not work either - unless of course as means of punishment and excluding people (all these CoCs come with punishment clauses).
&gt; Now here's the thing. I do know people so race &gt; conscious that they see it everywhere But this has nothing to do with "race". The pigmentation of the skin does not change the "race" by biological criteria. It's just some enzymes being more active, e. g. in melanocytes. You need to avoid terminology that comes from racists who are clueless about science or who try to use fake-science. There is only one race criterium which is the biological one (aka viable offspring) and this is fulfilled (we have it harder for e. g. bacteria and so forth due to horizontal transmission of genes, but for metazoa this definition holds true; you can also see non-viable hybrid offsprings; these by definition are NOT a race, even though dubbed so like a "liger" and so forth).
&gt; I realized for the first time that Arabs could be &gt; professional hockey players. Possibly your upbringing was a bad one since you would think that the origin determines who can do what and who can't do something. Good training is literally the major component for adaptation. 
&gt; Many people do Nope, not really. Perhaps a few fake-social warriors or CoC-writers. But these are psychopaths by nature. &gt; another thinks there are not enough Jews and another &gt; thinks there are not enough Muslims. And that has what exactly to do with PROGRAMMING? How is that important? I don't understand your failed attempt at "logic" here.
The reasons were explained. You only have to read them. Colourizing a picture to imply meaning is rubbish. It would have been much better to create a new image altogether. Even then this does not mean anything either. Why would you equate inclusion through a picture? This is just PR values that you are worshipping here. 
Why would the image be important? I think the image is terrible to begin with. They should have instead used _why cats - that would have been better. And nobody would question cats ability for inclusion, unless you are a mouse.
What do you mean "do anything" - you mean whacking a bit more colours onto a random black-white picture stands for ANYTHING meaningful???
&gt; I give a shit and this is clearly something because it &gt; has triggered a lot of people. Because the "argument" is total garbage. If you want to "trigger" people, try it with quality.
It would help if you could state what is cool about it precisely. That way I can understand why this picture would be so massively important.
Leftish sjw trying to be relatable.
So they went from generic looking cartoons to adding colour and creating differences — great 
I don't understand how a picture representing more types of people than one without can be seen as anything but more inclusive. My only "claim" beyond that is that I love it.
An image with more representations of people is surely more inclusive than an image with less? In what way would it not be?
I'm a freelancer/consultant. I've been freelance on and off since 2011. I do coding for clients and teach onsite classes. For about the last six months I've been working with a client to write an application to help manage a medical clinic.
&gt; I would have agreed with you up until the day the Toronto Maple Leafs drafted Nazem Kadri and I realized for the first time that Arabs could be professional hockey players. Then we have no disagreement because you missed the point entirely. The HIRING of a "person of color" (always a bit weird because i have never met anyone who lacked any color) IS tangible and not symbolic. Your other observation illustrates my point exactly &gt; I never felt like hockey lacked inclusion until Nazem Kadri was drafted. What you feel isn't always reality. You didn't feel that way because you weren't in Nazem Kadri's reality. I guarantee Nazem was aware of it long before you. So heres the question - Would it matter if in the team magazine on page 12 there was a back and white picture colored in if He was not drafted? how much do you think it would matter to Nazem if he wasn't drafted and the cartoon was not there? The point you missed is the cartoon is symbolic not real life. The drafting of Nazem isn't symbolic. An actual person of color was actually included Plus its off for you to tell me what I feel in regard to ruby is not reality - It sure is mine. I am a ruby developer and a person of color. Even beyond me a higher level of inclusion is obvious in ruby. Speaking straight when people talk about inclusion are they talking about white people? That would be nonsense in the tech field (perhaps in except India). So they are talking about non whites. Ruby doesn't have a white lead. Just on that basis alone it would be nonsensical for alt least one set of people of color to feel not included. That doesn't mean in a geographic area you can't be unincluded but it sure mean in regard to the global reach language and anything to with it its instantly more inclusive than a white led language. That's not feeling. That's fact
I think we all know what is meant by race and we all know that in a dictionary words have various meaning based on usage. I don't need to avoid terminology because you are off in some imaginary world where the way people refer to words doesn't determine their meaning in usage. What are we supposed to do - claim people have no problems regard to race because you see only one definition of the term in your dictionary and all the rest of us can see the others? Using your reasoning here we should then just deny there is any issue of race in this world which is nonsensical. we are all aware of the science. That helps us to address racism but pretending theres one only meaning of a word in a dictionary doesn't help us address anything. P.S. its not just - some enzymes being more active, e. g. in melanocytes. My heritage and genetic makeup is different. Not enough to justify racism but its enough for me to have different risk factors for diseases (both better and worse). 
\&gt; The mentality of saying "don't do little things because there is still racism" is bullshit. NO what you just said is "bullshit" because You responded to me and I never said don't do little things. You just made that up in your head. Closer to what I said would be "this is symbolic so doesn't mean much" &gt; It sends a signal to people contemplating learning rails. LOL....Now thats some REAL "BS". Utter garbage and its not even debatable. this thread is about the welcome page. Please tell us all how the person who is only contemplating learning rails knows to install it, create a new application and fire up the server? Seriously I await your explanation for that contradiction. Its really now into a full insult that you think there are sets of people so weak and stupid they can only get the signal to learn rails because of a cartoon - even after they have already begun to learn it. I figure you just didn't think but I know some people would say - thats racism right there. If anything you just demonstrated how little thought you have put into inclusiveness and you demonstrated a potential downside to heralding this as something momentous (which no one at rails has done) . People who don't think will say - okay this is a great message sent so no one can ever say we aren't inclusive. 
Honestly I might not even notice since thats precisely what I get from most pictures of ruby conferences. Now attract more "people of color" to them and take the picture and I would notice and in that case the actual person at the conference beats the socks off a cartoon drawing. How could it not? 
So, where did all the white people go? Don't see any here https://tosbourn.com/img/rails-6.0.0.beta.png
My grandparents used to say this, and I never really thought about it. But now that you mention it, it's a pretty odd phrase, isn't it?
[bundle gem gemname](https://bundler.io/v1.17/guides/creating_gem.html) 
Did you consider google?
if you’re interested in actually how to create it, I’ve had good experiences with Ore in the past: https://github.com/ruby-ore/ore/blob/master/README.md It basically helps you create the scaffolding and puts everything in place so that you don’t have to know/think about things needed for a gem. You can also look at what it generates and learn about gems. 
This is probably the best source. Ever since bundler started to scaffold a gem for you it's been pretty simple. Other things you'll need to brush up on are how to properly require files along directory paths and using namespaces in ruby. These are the key concepts in a gem. Also if it's specifically to expand a Rails app, check out writing Rails' engines books, e.g. Crafting Rails 4 Applications, it's a little dated but should still be mostly relevant. 
[https://guides.rubygems.org/make-your-own-gem/](https://guides.rubygems.org/make-your-own-gem/)
Did you consider that this reply is not helpful? 
In addition to `bundle gem gemname`, before you even start, you need to be aware of what you're working with. Want to build a generic gem that will work with just ruby? Remember that certain syntax does not work with certain versions of Ruby. You need to consider whether or not you want to support different (and even past their EOL) versions, or go with what's new. Want to build something that works with Rails? Great. There are a lot of differences in different versions of Rails - even between 5.0 and 5.1 - that you need to adapt your code to work for. Yes, that means writing the same thing twice, thrice, or more times just to achieve the same thing in different versions of Rails. Also consider maintenance. If you're making a gem for use in your own app, that's all great and good, but you, and anyone you work with, will be liable for working with that in addition to your codebase. If you're making something you want to publicly promote, you need to consider things like pull requests, issues, and keeping things up to date. That also includes doing some sort of test suite that tests out issues. Then it's really a simple matter of organizing and structuring. Every gem is basically the following files (replace "mygem" with the name of your gem): - `mygem.gemspec`, which contains your gem's information and its dependencies (and development-specific dependencies) - `Gemfile` is generally out, as the gemspec handles most of it, but can be useful depending on what you're trying to build - a `lib` folder, required (yes, edge cases exist, but generally, it's required) - a `lib/mygem.rb` file, which is the base of your gem. Everything stems off of. this file. This is where you include other files (nothing is automatically required/included), set up any configuration, monkey-patch/extend anything, whatever. Whether you set up a `Mygem` class or module in that file is up to you. - a `lib/mygem` folder, which is where you would put any of your code that actually does what your gem does. Each file should be namespaced - `class Mygem::Macros` or `module Mygem::Widgets`, for example. `bundle gem gemname` will create other files for you, but, to get started, this is what you need to know. In short - it's just Ruby. If you can program Ruby, it's fairly easy. And, my best recommendation for learning *how* to do what you want to do: read the code of other gems. Find out what they're doing. Just because one gem uses a config setup that you like doesn't mean there aren't other great approaches as well. There's no right or wrong way to build it (unless, of course, it doesn't work). Once you get through with that, publishing can be a simple push to your GitHub repo and use `gem 'mygem', github: 'myrepo/mygem.git'`. If you want to publish it on Rubygems, that's an entirely separate process, but one that isn't hard to do, as long as you don't name your gem the same as someone else's.
Without any doubt i did it, @difficult\_fact mentioned the exact resource I knew of but he also pointed out the concerns I have ,i.e. configuration patterns, while creating gem as an internal service. I even found a book by Brandon Hilkert "Build a Ruby Gem" but its too costly for me. Anyhow, thanks for your suggestion. 
Thanks a lot, i ll definitely look into it. 
Really a great help. I ll definitely look into the book you mentioned, I hope it gona be a good resource in learning about packaging an internal feature as an internal service. 
Someone comes here asking questions answerable by google demonstrating that they're not even willing to the basics to help themselves and I point out that Google has the answers they're looking for but somehow *I'm* the one that's an asshole? I don't think so.
https://www.wikihow.com/Ask-a-Question-on-the-Internet-and-Get-It-Answered It's the first fucking rule for fucks sake. It's been the first fucking rule since there was an internet.
Man, i truly appreciate your suggestion and I keep it. I am not the one who is here to judge anyone skills or willingness or anything else as I dont have Godly skills. I apologize if my naive question pissed you off. But that wasn't the intention.Hope you wont mind.
apologies if i offended you. i like to have a chill attitude and give people the benefit of the doubt. don’t assume everyone has the same background as you or is as good as doing this ‘internet’ thing. if you can point people in the right direction, engage in conversation or at the end of the day just have a positive attitude it’s all good. 
I appreciate the time you took for the detailed information, truly. I was a bit confused in adopting the style or pattern before actually jumping into the implementation. Since you have mentioned there is no hard and fast rule for adopting the methodology so looking into code of other gems is really appealing and can give me a broad overview. Thanks once again :) &amp;#x200B;
 It’s just like the Dragon Prince (on Netflix). 
Without seeing you whole program I can't tell what the exact thing is that's causing that output. But I can give you some pointers what I would have done differently: - representation of the board is awkward. The reason why it's so difficult to work with it is because it's too close to the rendered output. In fact the representation is it's rendered output. How about representing the board with an array where each cell stores either: empty / X / O ( chosing a representation of these 3 is also not obvious, you might want to think about it too ) - you made Board a module. To me board is some\_thing\_ you can create, pass around, a thing. Don't be afraid of creating objects. Event if you need a single instance. Nobody said object are only for the case where you have many. - this is actually a mismatch on your APIs which can turn into unexpected behaviours and it's related to the second point. You are storing the board data in an object pointed by a single constant Board::BOARD. Then you include this in the Game class. Given that there is only one constant you have only one board. Event after creating many games they still use a common board, potentially corrupting each others. If you link your code we can figure out the exact reason of that output...
/r/AsABlackMan
Here's a sneak peek of /r/AsABlackMan using the [top posts](https://np.reddit.com/r/AsABlackMan/top/?sort=top&amp;t=year) of the year! \#1: [As a strong Black woman](https://i.redd.it/lbb8n7mhq8v01.png) | [35 comments](https://np.reddit.com/r/AsABlackMan/comments/8g86th/as_a_strong_black_woman/) \#2: [As a Socialist, I love to prohibit my workers from unionizing!](https://i.redd.it/tkiphy5zmh411.png) | [175 comments](https://np.reddit.com/r/AsABlackMan/comments/8roqlz/as_a_socialist_i_love_to_prohibit_my_workers_from/) \#3: [We Blacks have woken up and are understanding just how the #DNC did all they could to keep us in Ghettos and embrace a "loser mentality" .NO MORE! #BlacksForTrump](https://i.imgur.com/VhDO7ZU.png) | [90 comments](https://np.reddit.com/r/AsABlackMan/comments/80akxj/we_blacks_have_woken_up_and_are_understanding/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/afd0dd/blacklist/)
Updated post with a Gist of the complete code.
The exact reason for that issue is that your code doesn't play along with the colorize gem. To achieve terminal colours colorize has to insert [ansi escape sequences](https://bluesock.org/\~willkg/dev/ansi.html) into your BOARD string. The inserted sequences might include numbers like 3. When they do you replace the 3 under the assumption that you are replacing your | 3 | . But sub will find the number 3 in the coloured string sequence from either cell 1 or 2 and replace that instead. What you see after in that corrupted cell is the result of replacing 3 with for instance X.
I'll take that as a cry for help for directions back to your KKK meeting. Here /r/The_Donald/ Happy to be of assistance!
&gt; My grandparents used to say this, actually thats where I got it from too!
To expand on the first point made here, manipulating a constant is a huge no-no. Albeit, doing it here is rather benign, it is something that you shouldn't be practicing.
The guy with a posting history of arguing for creationism on Christian subreddits is now telling a bunch of programmers that racial diversity unneeded. Might want to take your own advice there. 
Excellent point!
Very interesting. Thanks for taking a look! A lot to work on here.
There are many use-cases where good comment clears up confusion or remove any headaches and where it cannot be replaced with "tedious design work". You can rarely propagate context. I use comments from time to time and wish people use them more (that said, in an intelligent way). 
Protip: mentions on Reddit use `/u/`. For example: /u/Valaramech.
&gt; now telling a bunch of programmers that racial diversity unneeded. Lol...You are like a gift (of stupidity). A very old saying goes &amp;#x200B; "Better to be thought a fool and close your mouth than to open to open it and to remove all doubt. " any intelligent person reading this thread knows I am telling no one diversity is not needed but the opposite - that cartoons don't make diversity a reality. You opened your mouth and remove all doubt what a fool you are. &amp;#x200B; What happened any way? - they wouldn't let you in over there? Not to worry. Your mom called. She has your white sheets with the eyes cutout bleached. Its in the dryer. put that on and say the N word a couple time like you did last week and they'll let you right in cant figure the way back? - got ya covered. [/r/The\_Donald](https://www.reddit.com/r/The_Donald)/ 
I followed the official rubygem .gemspec creation and adapted it lateron. I use ruby to generate .gemspec files too. :) require 'foobar/version/version.rb' Gem::Specification.new { |s| # Gemspec for the foobar-Project. s.name = 'foobar' s.version = foobar.version? s.date = Time.now.strftime('%Y-%m-%d') DESCRIPTION = &lt;&lt;-EOF This gem is called foobar. It does bla bla bla. EOF s.summary = DESCRIPTION s.description = DESCRIPTION # =============================================================== # # Show this when a user installs the Project. # =============================================================== # s.post_install_message = &lt;&lt;-EOF There be dragons. EOF s.extra_rdoc_files = %w() s.authors = ['your name'] s.email = 'your@email.com' s.files = Dir['**/*'] # I am lazy ... # This one is for my larger gems mostly, which may have # lots of entries under bin/* s.executables = foobar.will_install_which_binaries? s.license = 'GPL-2.0' # whatever licence s.homepage = 'https://www.rubydoc.info/gems/foobar/' # use some homepage # Next three lines are for very lazy people s.required_ruby_version = '&gt;= '+RUBY_VERSION s.required_rubygems_version = '&gt;= '+Gem::VERSION s.rubygems_version = '&gt;= '+Gem::VERSION _ = '/path/to/project_dependencies.md' # I like to define this so that it is available outside of the .gemspec file too # And add the deps dataset = File.readlines(_).select {|entries| entries.strip.start_with? '-' } dataset.each {|entry| s.add_dependency( entry.delete('-').strip ) } } By the way, you should not worry too much. Just keep on pushing gem after gem. You can always yank gems again if you made a mistake. I learned as I went. Practice makes better!
The problem is that even if your comment may be valid, it still is useless. He can Google on his own - he does not need you being a parrot. If you don't want to help him that is fine, but consider whether it may not be better for everyone involved if you would not make a suggestion that is totally useless to him and others. Keep in mind that others can read the replies by others here and learn from that. With your "use Google" comment, you don't help, you point out the obvious that is also useless. 
Totally irrelevant. Please don't waste our time in the future.
The irony of that statement is staggering 
You're not ending the first fonction correctly, I guess ? You start the triangle method before ending rectangle.
I've tried that and it still doesn't want to work
I've got caps lock bound to escape, so I didn't really mind when they removed the actual button. In fact, it was nice since they started natively supported that re-binding.
Second that. Also good for vim keys. 
This has nothing to do with Rails or Ruby for that matter...
I use an external keyboard 90% of the time so I don't notice.
You've inadvertently set up the triangle method as a dynamic method inside of the rectangle method. When your writing the code make sure you are consistently indenting lines otherwise it can get confusing. Here is a working version of the code: def rectangle(height, width, outside_letter, inside_letter) 1.upto(height) do |row| if row == 1 puts outside_letter * width elsif row == height puts outside_letter * width else middle = inside_letter * (width - 2) puts "#{outside_letter}#{middle}#{outside_letter}" end end end def triangle(height, outside_letter, inside_letter) 1.upto(height) do |row| print ' ' * (height - row) if row == 1 puts "#{outside_letter * 2}" elsif row == height puts outside_letter * height * 2 else middle = inside_letter * (row - 2) print "#{outside_letter}#{middle}#{inside_letter}" puts "#{outside_letter}#{middle}#{inside_letter}" end end end puts "Welcome to Shapes" print "How big do you want your shape? " shape_size = gets shape_size = shape_size.chomp print "Outside letter: " outside_letter = gets outside_letter = outside_letter.chomp print "Inside letter: " inside_letter = gets inside_letter = inside_letter.chomp # Acknowledgement code puts "About to draw a shape #{shape_size} big" puts "using #{outside_letter} for the edge" puts "and #{inside_letter} for the inside" height = shape_size.to_i width = shape_size.to_i triangle(height, outside_letter, inside_letter) rectangle(height, width, outside_letter, inside_letter)
Youre defining the triangle method INSIDE the rectangle method. You need to add an 'end' on line 12 and remove the one on line 28
Thanks, fixed the warnings. Just need to find out how to fix the error that happens when 45 and 46 are swapped (triangle coming first in the fall)
&gt;LOL....Now thats some REAL "BS". Utter garbage and its not even debatable. Really? It doesn't send a signal? It did send a signal and it triggered the fuck out of you and a bunch of other white people. &gt;Please tell us all how the person who is only contemplating learning rails knows to install it, create a new application and fire up the server? They don't. This takes place before that step. When they are evaluating what technology and framework to choose. 
Same here I think the 2018 MBP's keyboard is absolute garbage and makes my hands ache just using it. An external keyboard is an absolute necessity.
&gt;And that has what exactly to do with PROGRAMMING? How is that important? I don't understand your failed attempt at "logic" here. It has to do with a community. Not all programmers live in their mother's basements and never go outside. Some of us actually talk to other human beings.
Jelkya is correct. In fact, you're defining the `triangle` method inside of the `1.upto` block. You're essentially running `def triangle` multiple times hence the method redefined warning.
There are both people of color and ukranians in the ruby and rails communities. Both are equally welcome. That's what this image is trying to communicate. The previous image was only welcoming towards white people.
I’ve fixed the method redefined issue, I just need to fix the method *undefined* issue that happens when I call triangle first instead of rectangle.
method undefined is also caused by that. If you remove everything else, what you have there is basically this: def rectangle def triangle end end Until you call rectangle, triangle is not defined. To fix it, you just need to move the triangle definition outside: def rectangle end def triangle end Unless you set it up like that on purpose?
Oh snap, I'd heard about sonarr/radarr, but didn't look up what they were for until you mentioned them! The other snag for me is that I share a seedbox with a group of friends (so the per-person cost falls to like £20/year), but that means that none of us wants to mirror the entire contents of the seedbox locally. Some of us def. need sonarr/radarr, but others only need to grab an album or comic book on a one-off basis every once in a while. Thanks for the push in the right direction though!
Fuck yes. Remapped Esc to the Caps Lock key, but it's still a major pain in the ass.
Mostly developing on an iMac Pro so the fullsize keyboard has a Esc key. My current laptop is a MacBook which also has an Esc key. My next laptop will be an Air... because it has an Esc key. I tried a MBP with the capslock rebinding trick but never took to it. Rejected with dismay. "Dear Tim", I wrote, "it's just not Pro to omit this". 
Had a touch bar for a bit, got used to having caps lock mapped to escape, now I have a 13inch without a touch bar, and I still use caps lock for escape even though I have my escape key back I do get confused on other computers when caps lock is actually caps lock though 
&gt; Really? It doesn't send a signal? Nope and certainly not what you said &gt; It sends a signal **to people contemplating learning rails**. &amp;#x200B; You've yet to explain (rationally) how a message page that you get only after you have installed Ruby, then Rails then created a new app and start the server sends a signal to those contemplating learning rails. TOTALLY idiotic. Everyone here knows you have already begun learning Rails in order to get to that welcome page &gt; iand it triggered the fuck out of you and a bunch of other white people. Rofl "other white people" he said to the African American poster. Nope didn't trigger me in the least. You know what triggered this thread? because one guy said &gt; I have literally no idea why this matters. In other words whats the big deal and then all the rest of you who I'd put down stacks of Benjamins most of which have never had a N word hurled at you or experienced any discrimination went crazy and you in particular because a person of color said - "We have bigger fish to fry" &gt; They don't. This takes place before that step. Do tell! so you don't have to learn anything about rails to create an app and start the server eh? You jut have to contemplate learning it and a rails app just goes live. Why is no one talking about this spectacular new feature in Rails 6.0! ITS REVOLUTIONARY! By Rails 8.0 you just have to imagine your app and it will setup active record, run the migrations and wire up all controllers and models, forms and API &gt; When they are evaluating what technology and framework to choose. And you know us "people of color" if we see colored characters on a cartoon at the welcome page thats how we determine our stack. Condescending gibberish. Kudos to the people at rails who I bet to a man has no problem with anyone saying there are bigger fish to fry
It mentions Rails in the summary...
I’m glad that broader topics are being crammed down the throats of rails devs. 
This is true to some extent, I was really wondering if this is the best place to put it, there is only a one paragraph mentioning Rails so far, but since this is a series and the next articles will be focused on Ruby/Rails, this introduction will be way more related as a part of a bigger picture.
White people are not a single homogenous group of people.
I read like none of that. You need a better hobby. 
I still have a 2015 MacBook without a touchbar, if I eventually switch to one without an escape key, I predict I'll be annoyed. 
This is truly a life hack. I find using normal computers so inconvenient when the caps lock key isn’t remapped. I use it so much now. 
have lots of hobbies just not moderating reddits no one reads /r/pizzacirclejerk lol
Apple is on a relentless push to make me stop using their products. This was simply #4,867 on the list. Have been working on using the "Windows for Linux Subsystem", and have found it almost ready for prime time. By the time I'm ready to buy another dev laptop, I expect to buy two Windows laptops for the price of one shiny, annoying, super-expensive pro-user-hating MBP. 
Exactly how is this related to /r/ruby?
A significant amount of Rubyists use Macs. A significant amount of Rubyists use Vim. Vim use, out of the box, relies heavily on the 'ESC' key. It would appear, from this thread, that Apple have slimmed down on production of 'ESC' keys. Don't ask me why. I use Atom on GNU/Linux. I am insignificant. 
Or just come to use systemd-free Linux.
I don't think the first two points are valid though. Many use Windows. Many use Linux. h0rst_ sort of has a point. While I myself don't mind, whether a crappy Apple product has an ESC key or not is not really related to ruby.
Not really - In fact I don't think I ever use the escape key.
Well they kind of are. They are treated as one by the society at large. When you look at a white person you don't know if they are greek or italian or french or whatever so you treat them just like you would treat any other white person. When you see an Indian or a Mexican you don't treat them like you treat a white person.
Surely you are not so dumb as to think the only people who will ever see this image are the ones that have already installed rails. I mean nobody is that dumb. 
I mostly use escape in vim. I've got key \`jj\` bound to escape so yeah its not that annonying. 
That's just like your opinion ? Maybe that's the norm in the USA but it's not in the rest of the world. If you got to Korea you will be perceived as an american with all the cons and pros attached. Also xenophobic behavior towards poorer europeans is pretty much the norm in Europe. Also you seem to forget that for non americans the americans are just that.. americans. We dont really distinguish among races (for americans) so we dont say afro-american or chinese american. The analogy is pretty much similar to that of duck typing. If it walks like a duck and it quacks like a duck then it must be a duck. And dont be mistaken americans have a very distinct way of behaving and we just dont even think about a chinese american to be a chinese person. &gt;When you see an Indian or a Mexican you don't treat them like you treat a white person. I treat them in the right context ? If I meet an indian I dont immediately suggest going for a steak but if I meet an american-indian i treat him like an american. 
&gt;Maybe that's the norm in the USA Yes it's the norm in the USA but white people also get treated differently. A korean won't know if I am an American or a Canadian or Italian by just looking at me. That's the whole point. &gt;Also you seem to forget that for non americans the americans are just that.. americans. We dont really distinguish among races (for americans) so we dont say afro-american or chinese american. Of course not. You probably think a Chinese American is Chinese. &gt;I treat them in the right context ? I seriously doubt that. There have been countless studies done on the subject. People treat people differently based on their skin color. This is a well established fact. 
&gt;Yes it's the norm in the USA but white people also get treated differently. A korean won't know if I am an American or a Canadian or Italian by just looking at me. That's the whole point. Korean wont but a european will try to find out as soon as possible that's the whole point. &gt;Of course not. You probably think a Chinese American is Chinese. Nope? A chinese American is american. &gt;I seriously doubt that. There have been countless studies done on the subject. People treat people differently based on their skin color. This is a well established fact. And that's absolutely normal. You treat people based on the context. Do you think it would be racist to suggest a japanese person visiting to go to an asian restaurant ? 
https://buttercms.com/blog/launching-your-own-ruby-gem-build-it
Not sure if this ticks every box, but Shrine and Dropzone.js should cover nearly everything. 
Thanks for sharing this great blog. 
Just drop-in Dropzone and use ActiveSupport.
In that case a significant amount of Rubyists might want tot get used to Ctrl-[ to get out of edit mode. Less movement for your hands as well. Of course somebody will tell me that there is no control-key either.
I have never met a serious VIM user that doesn't remap caps-lock to esc regardless of the keyboard being used. 
It's occasionally annoying but I don't use the esc key very much, maybe a couple times a week. All heavy VI users I know (whom use a normal keyboard anyway) map caps-lock to esc regardless of the keyboard being used. Personally I map it to ctrl. 
&gt; I mean nobody is that dumb. I use to think so then I met you. thats when the majority of developers who according to you &gt; When they are evaluating what technology and framework to choose. will first interact with that page. The vast amount of others when someone is training them on it. Sorry you can't dig yourself out of that hole your lack of logic has dug you in.
/r/mentorsec
&gt; * Integrates with Rails 5 &gt; * ActiveStorage support &gt; * Multiple file upload Already covered by Active Storage itself :) &gt; * Ability to add more files after initial upload &gt; * Ability to delete individual files &gt; * Ability to reorder files This functionality is not specific to file uploads, but to any type of nested resource (e.g. list of questions inside a quiz). See AR's `accepts_nested_attributes_for` for that. You can write your own custom JS for that. &gt; Preview files in the upload form `URL.createObjectURL(file)` gives you a URL which you can put into an `&lt;img&gt;` tag. Active Storage also has previews of uploaded files built in. I would also recommend looking into [Uppy](https://uppy.io/). It has very advanced UI components that can make your life a lot easier. I'm not sure how easy it is to integrate with Active Storage, though.
&gt; I don't think the first two points are valid though. Of 7911 Ruby developers surveyed, 4032 (51%) stated that MacOS was the primary operating system with which they work. Of those, 1893 (47%) regularly use Vim as their development environment. 24% of Rubyists use Vim on Mac source: [2018 Stack Overflow Annual Developer Survey](https://insights.stackoverflow.com/survey)
rails ecommerce
Using \*SpaceVIM\* as a Ruby IDE.
This all seems incredibly heavy-handed. With vanilla Vim, a few plugins makes working in ruby and/or rails easy: tpope/vim-rails scrooloose/nerdtree vim-ruby/vim-ruby vim-utils/vim-ruby-fold vim-scripts/rainbow-end the last one is more eyecandy. 
Nah...
I don't think people who use vim are looking for IDEs
Very nice, thanks for your continued work on this project. Sooooo, what on earth happened in Nov 2012?
But why use a hammer when you can use an entire construction team?
My belief is that Vim IS an IDE. I can't think of anything I've seen someone do with a regular IDE that I can't do with Vim.
I expect an IDE to compile and run my code, or execute it line by line, or have IDE debugging built in. I don't need any of stuff, so I prefer a simple text editor like vim/atom. Obviously they all get extended with packages.
&gt;will first interact with that page. They will be exposed to that image in many other ways you moron. Holy shit you are dumb. &gt;Your insinuation is down right condescendingly racist. That's hilarious coming from a guy who is severely triggered because brown people are depicted in a fucking picture.
&gt;Korean wont but a european will try to find out as soon as possible that's the whole point. No that's not the point. The point is that you will get treated differently depending on your skin color. &gt;And that's absolutely normal. And it's racist. &gt;You treat people based on the context. Skin color is a valid context to treat people differently. &gt;. Do you think it would be racist to suggest a japanese person visiting to go to an asian restaurant ? Depends on the situation. Yes it can be racist. Expecially if you think all asians are alike which you seem to. 
\&gt; Holy shit you are dumb. You have words for accusations. I have demonstrated your moron status. I'll take that over mere words any day. The discussions was about the welcome page and yes you poor no thought soul its as I have said - most people encounter that page after beginning to learn about Rails either themselves or through a demo training and that was the point of reference in the OPs link Thats obvious to those who can read Of course you can't think or read with comprehensions so alas - you missed that bus (along with others). Proving once again the old adage - you just cant teach stupid &amp;#x200B; Meanwhile you are a closet racist. People of color don't need you on their side. You are a detriment Anyone who thinks developers just by the color of their skin or nationality are going make decisions on their open source stack differently because a cartoon drawing has a color in them is a PROVEN NITWIT. On no...no colors - not even pink shades of white people - my goodness theres no message I have been sent that can use ruby on rails for my project or client. I guess I will have to use Meteor because when not burning in the atmosphere those appear to be black in nature . ROFL. I guess only white people are smart enough or professional enough to use the best tech for their clients and projects. Colored people have to look for cartoon colors to get that message. and you have the nerve to call others moron when making the most moronic argument probably ever made in tech in the 21 century. Make somebody find the door for you when you leave the room. If not you might walk right into it. 
Stop. Vim is only for people who are so unfunfortunate that they have to work on the commandline.
My general thought is that comments should never explain "how" ... if the code isn't clear "how", it needs to be fixed. A "why" comment, however, can be helpful to explain a design choice. Even better, is a git commit log on the code that references a work ticket that further documents the context. Why comments are still somewhat rare - not every method or line needs a comment! 
Jump to source of a method? Otherwise just a text editor, not an Integrated Development Environment
What dat? More info?
So, that error seems to be suggesting specifically that it can't install the 'sqlite3' gem. It's not necessarily a problem with gems in general, or even with "updating" gems, but with installing the sqlite3 gem. It's probably because in order to install the sqlite3 gem, you need to have a general sqlite3 package installed on your system first. How you do that depends on what OS you are using. Mac? Windows? Other? If you specify, some may be able to give you advice, or you could try asking for help on StackOverflow, or the [sqlite3-ruby google group](https://groups.google.com/forum/#!forum/sqlite3-ruby) mentioned in the [sqlite3-ruby gem README](https://github.com/sparklemotion/sqlite3-ruby). 
Jeez, I'm dumb, I didn't consider the OS. Thanks. Windows 10. I'll update it.
 I wrote rainbow-end as a project to learn ruby six years ago and completely forgot about it sense then. I had no idea anyone actually used it! That makes my night :) 
Nobody seems to know :D Not sure if you saw it but I also put up a note on the corresponding docs page, looking for info on that subject, see https://www.ruby-toolbox.com/pages/docs/features/historical_rubygem_download_data I got in touch with current and past rubygems.org maintainers, nobody seems to remember what happened. I cross-checked my dataset against archive.org pages, the bump is there as well. Since it affects projects pre-rubygems-rubyforge migration, and the impact depends on the popularity of the gem (for rails it's much higher than for rake for example) I have a strong suspicion that rubyforge-download-counts got added at that point, but without confirmation I am reluctant to just take that assumption and re-calculate the stats before it with the difference added on top as a baseline. From what I could find in archive.org, rubyforge listed rails at around 1.5 million downloads in early 2013, so that does not explain the +7 million downloads in november 2012. It's a mystery :D
&gt;You have words for accusations. I have demonstrated your moron status. I'll take that over mere words any day. How very Trump of you. 
Yep, big difference. 
It's generally not recommended to use Ruby on Rails directly on Windows. The problems you're experience are common with using Ruby on Windows. Luckily there are viable alternatives which makes developing Ruby on Rails on a Windows host quite enjoyable. I've recorded a few different screencasts on the subject. The easiest way to get Ruby on Rails going on Windows if you're not too tech savvy is through Docker. https://www.driftingruby.com/episodes/intro-to-docker-on-windows If you have a bit of experience on Linux, another great alternative is Windows Subsystem for Linux (WSL). https://www.driftingruby.com/episodes/ruby-on-rails-development-with-microsoft-windows-10
Are you asking? Vanilla Vim can already do that with ctags. 
Sure, I agree with this sentiment. And it's why we have comments. Having as much details in source control is great, but cannot substitute comments.
Thanks I didn't know it was so easy
Interesting reading. I'm not used to see articles that go into the details of the Ruby source. It helps to better understand imho. I have a question though.. Where the mapping between, eg. `id_init_dup` and its implementation `rb_obj_init_dup_clone` is done?
I have learnt ruby and rails several years ago, but now I use ruby as a shell language, processing texts mainly.
Yeah, in general Vim is very smart but it's hard to find out about its features. That said, adding 100 plugins is never the answer.
IIRC one is for shallow copy and the other one is for deep copy.
There is no native deep copy in ruby, and that's not what the article is about anyway.
Your implementation looks clean to me, nice work! I like the `def self.before_included` signature - the ActiveSupport version is implemented slightly differently anyways Note that `prepend` is not available on older Rubies (not that I think we have to keep supporting them at this point). I'm a little curious if it can even be done without `prepend` (and without aliasing) The only possible issue I can think of is: what happens in cases with inheritance? I noticed that you call `singleton_class.instance_methods`. I'm not positive if this returns methods from superclasses. In addition, it would fail in cases where dynamic dispatch is used via `method_missing`. Using `responds_to?` might be a good solution to cover each of those cases. I know I'm getting into the realm of obscurity here though :)
You could try the instructions here: http://www.sqlitetutorial.net/download-install-sqlite/ Or you could just ask on the sqlite-ruby listserv! I don't use Windows, so am not sure how to get the proper sqlite3 libraries on it, in such a way that the sqlite-ruby gem can find them and install. But I believe that's the task in front of you, hopefully with the knowledge of what specifically you are trying to do you can have an easier time finding some info, even by googling etc. 
[Imgur album](https://imgur.com/a/XNfZzj5) with the same graphic for other programming languages - for comparison! | If you want more information on how these were created, it can be found [here](https://www.globalapptesting.com/blog/picking-apart-stackoverflow-what-bugs-developers-the-most)
##r/DataArt --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/9wy10w/ignore_list/)
"duplicate", "closed", never change StackOverflow.
Yes, ruby just calls them "hash" referring to the core class implementing them (Hash). Wider industry usage a "hash" is the algorithm that a "hash table" data structure would be built upon. 
The simple answer is yes, a ruby hash key is what is used by the hashing function to determine where the value is stored. [Here’s a more in depth guide on how Ruby hashes work](https://launchschool.com/blog/how-the-hash-works-in-ruby)
Different languages call them different things. Python calls them dictionaries, Java calls them HashMaps, JavaScript calls them objects, Ruby calls them hashes. They're all pretty much them same, hash tables.
I was using ruby on windows + WSL without a problem. I compiled everything from source there too. Then realized that I would not even have to compile anything - I could just transfer the files from another computer (I use a versioned AppDir approach for programs, which makes it a lot easier to keep track where something resides).
Can I use this image on my website?
Ruby's name convention in this area is a bit confusing. A hash is actually the integer digest of a value, normally of register width (e.g. 32-bits or 64-bits) used for computing an offset in a hash table where to store the value. Calling it a `Hash` is confusing, because it's really a `Table` of `hash` index =&gt; value mappings. Hence the names `HashMap` (more specific) or `Dictionary` (more abstract).
Move to VS Code. Just like you have switched from Python to Ruby, you will move to some other language in the future. VS Code will move with you. Get yourself familiarised with VS Code. It is light weight, it has huge huge extensions marketplace, regularly updated, VS Code team actually cares about the developer input. Microsoft has made a thing of beauty.
It's even more confusing because Ruby provides a `#hash` instance method, which, when called, returns the integer you mentioned, rather than an instance of a `Hash`, for which you'd need to call `#to_h`.
Oh boy. just at the start. You realize: current_campaign = Campaign.find(1) new_campaign = current_campaign new_campaign.id = nil new_campaign.created_at = nil new_campaign.updated_at = nil new_campaign.title = "Campaign 2019" new_campaign.save! The line `new_campaign = current_campaign` did nothing, you might as well have left that line off and just done things on `current_campaign`, because both variables are pointing at the exact same object. That was _not_ in fact "copied that by hand", it copied nothing. When you _saved_ the object (the same one you fetched), it (I assume) saved a different row in the db, if it did, because you set the `id` to nil, but I wasn't even sure ActiveRecord would work like that. Definitely not the right way to do it! Which I realize is the point of the article, but I don't think it even realized how wrong that was. 
pretty much. 
ok.
Remember though that Java’s HashMap is a newfangled thing. Originally there was Hashtable. And JavaScript now has Map that cleRs up some issues with using objects. And it would be a ceime to forget Lua and its tables from the list. It’s like Ruby and Lua both inherited Hashtable but had to split the inheritance in half. Hash is also a mathematical function that makes hashtables possible, as well as probably the most popular name for octothorpe (or at least was, till Twitter horde misunderstood what it referred to and started calling _the symbol_ “hashtag”). Also, a minced meat dish. 
Also the resin of the cannabis plant. And where do you sit while you're cutting up your cannabis resin to put in a joint while you code? At a hash table.
What kind of share? NFS? Samba?
I’m willing to bet it has nothing to do with rails. Probably just a hardware failure that happened to coincide with the timing of you installing rails. 
Yes you need to send the email via an add-on or define your own SMTP server in the application config. 
If you're going through the problems of the book please remember that in Ruby hashes are iterated by the order of insertion and that might make some problems easier. Solve them as if this didn't happen
Thank you, stranger. Indentation is everything, huh?
[mp4 link](https://external-preview.redd.it/mp4/t7VKULYtXgIy3e9jqhnpl1hXrT2zR0GaKgIRrXj8DNE-source.mp4?s=04649163e995c5237b663d500b59ca224f2baad3) --- This mp4 version is 90.09% smaller than the gif (362.04 KB vs 3.57 MB). --- *Beep, I'm a bot.* [FAQ](https://np.reddit.com/r/anti_gif_bot/wiki/index) | [author](https://np.reddit.com/message/compose?to=MrWasdennnoch) | [source](https://github.com/wasdennnoch/reddit-anti-gif-bot) | v1.1.2
Full details [here](https://twitter.com/amirrajan/status/1100634434066362368).
Does the file need a un/pw to open? or the network share needs a un/pw to connect?
Now THIS I like to see!
Have you written about it anywhere?
i have defined the smpt configuration in my production.rb file. will that make any difference? ``` # smtp mail setup config.action_mailer.delivery_method = :smtp config.action_mailer.default_url_options = { host: 'abc.herokuapp.com' } config.action_mailer.smtp_settings = { address: ENV['SMTP_ADDRESS'], port: ENV['SMTP_PORT'], domain: ENV['SMTP_DOMAIN'], user_name: ENV['SMTP_USER_NAME'], password: ENV['SMTP_PASSWORD'], authentication: 'plain', enable_starttls_auto: true } config.action_mailer.perform_deliveries = true config.action_mailer.raise_delivery_errors = true config.action_mailer.default_options = { from: 'contact@domain.com' } ```
Nice work 
This is really cool. Really glad to see stuff like this being made! &amp;#x200B; I was browsing your twitch channel and saw you also did some game dev with mruby. Do you know any good resources for figuring out how to get started with that? For example, how do you connect SDL and mruby? (then, are there any tutorials or books or resources on mruby?? how did you learn this stuff and get started?) &amp;#x200B;
GitHub repository? The details link seems to have no details, except for the screen of code on the Twitch recording.
&gt; Wider industry usage a "hash" is the algorithm that a "hash table" data structure would be built upon. ... or even the result of that algorithm applied to something (also called "hash code"). If I think about it I have less frequently seen "hash" for the algorithm than "hash algorithm" or even "hashing algorithm". Usually this gets resolved pretty good via the context of the word usage.
I would *love* to see the source code on this! Can you link a GitHub repo, please?
No useful source to show yet. The last 10 min of the twitch stream gives you a full review of it. 
Replace `ENV['SMTP_PORT']` with `Integer(ENV['SMTP_PORT'])`
It’s kind of a PITA and took a good two years of work to make everything line up. I’m making this game engine as part of RubyMotion’s offering to ease the pain for everyone else. The big reveal will happen at Ruby Kaigi. With regards to what I went through: get really really good with C, SDL, SDL_Mixer, SDL_TTF, Chipmunk2D, Ruby FFI, ripper gem/dependency graph construction, LLVM/clang xplat compilation, xcodebuild CLI, Android JNI/NDK, Butler by itch.io, Steam Direct, and Apple BridgeSupport. You’ll want to also brush up on high school Trig too. Don’t let this course load dissuade you. It’s an absolute blast!
Thanks. Using Integer() gave me an error during compile so I used \`.to\_i\`. 
Nice, but it's amazing how when I was a kid we used to have this game in 64kb, and now it's 7mb. Computers these days are so wasteful!
I can get away with looking at a fit repo at work. Not so much with twitch streams... 😁
Yes a unique username and password. Haven't been able to find anything in my searches
I'm not sure, let me check
Doesn’t really answer. Is it the file, the share or both?
Ah, misunderstood. It's both I believe. If I go to the share I need to enter it, if I go directly to the fine I also need to enter it. But I'd only need to enter it once per session it appears
num1 isn't declared or assigned
Very cool indeed... could u share the link to this? 
Did you try perfomance with jruby?
Read up on variable scope. `num1` and `num2` are not defined within the scope of the method `mul` etc. You are looking for something like: def mul(num1, num2) puts num1*num2 end Also, when posting an "it's giving me an error" query, it is helpful to include the error message you are receiving. 
The lack of functionality and preserved information on errors has been a thorn in my side for some time, I'm glad this work is going on, and hope it can make it in! 
I think this is the program that does what you want it to do: def mul puts @num1 * @num2 end def add puts @num1 + @num2 end def sub puts @num1 - @num2 end def div puts @num1 / @num2 end @num1 = gets.chomp.to_f puts "Multiplication=mul", "Addition=add", "Substraction=sub", "Division=div" @op = gets.chomp @num2 = gets.chomp.to_f puts "This is your result: #{@num1.to_s} #{@op} #{@num2.to_s}" eval @op I declared all variables as instance variables so that they could be accesed by the methods, and used eval to execute the correct method based on the input. Note that using eval to process user input in the way this program does could be insecure.
Ya'll. It's quiet in here.
The problem is the PR has been sitting there for so long and everyone got tired of waiting. ( It started nearly 12 months ago ) So I just post this here hoping to bring some attention.
watched last night, was dank, can you link to the object allocation tracer?
I don't believe that approach is going to be _easier_ for a newbie than any of the alternatives, but it is an approach! 
Which one are you talking about? I use these two: - https://github.com/SamSaffron/memory_profiler - https://github.com/ko1/allocation_tracer
Atom is commonly used by Ruby developers. Herei is a [Quora thread](https://www.quora.com/Whats-the-best-free-Ruby-IDE) with several answers, including one that says RubyMine is worth the money. :) I like ruby mine, my subscription is expired though. :( &amp;#x200B;
Thank for you the reply! Good stuff. I am excited to get started :)
I’m always available via DM, email, Twitter, or in the RubyMotion Slack channel. So feel free to ping me if you get stuck!!
https://www.udemy.com/learn-to-code-with-ruby-lang/ the course is usually on sale for around 10 dollars 
&gt;learn-to-code-with-ruby Senior engineer already knows how to code. &amp;#x200B;
"Learn Game Programming with Ruby" from PragProg has a _very_ similar example in it to this one. Highly recommend picking up that book https://pragprog.com/book/msgpkids/learn-game-programming-with-ruby
No, i dont watch your x hour long twitch video to get an idea of the source code.
Fast scrub to the last two minutes. 
[removed]
I wrote this recently for some coworkers to replace some old wiki recommendations. It mostly covers core Ruby: https://github.com/jbodah/ruby_for_experienced_developers/ I would recommend to learn Enumerable, learn how Modules work, learn about singleton classes, and learn about blocks/Procs/lambdas. Then you have all of the weird stuff There's not much in terms of data structures and the important types are few Things get a bit trickier when you get into concurrency/parallelism Ruby ships with a bit dated but complete standard library which does most of what you want (e.g. gzip, http, socket programming, etc)
I hear you. Not sure anything I can do other than add an emoji to the PR, but maybe a Rails committer will see this and be inspired. :)
this is great
Sweet, just what I was looking for! Thank you
If `ENV['SMTP_PORT']` is not set, `Integer(ENV['SMTP_PORT'])` will raise, but `ENV['SMTP_PORT'].to_i` will return 0. Only taking a guess that's what's going on, there are other non-actual-numbers that will also make `Integer()` raise. But is that really what you want? Your SMTP port is unlikely to be port 0. 
&gt; A block is not an Object but exists as an abstraction inside the VM. You can "capture" a block into a Proc. Thank you for recognising this distinction! It might be worth dwelling a little more on OO style in Ruby, particularly the Smalltalk heritage and the Alan Kay view of OOP, because many people coming to Ruby at first tend to write very procedural code - as I did after twenty+ years of systems programming in C/Assembler/Shell/Perl and functional programming in ML/Scheme, and which leads some folks into stylistic dead ends like "service objects". And all my OOP design instincts were wrong from working in Java, where duck typing is unheard of and structure is more important than message-passing. I had to unlearn old habits to write good Ruby. 
4 hours to code a shitty asteroids clone? Doesn't even have any asteroids and it only runs at 60 fps lol why is this a good thing?
&gt;4 hours to code a shitty asteroids clone? It's a Twitch stream, the time spanned a number of topics and wasn't just coding. Hope you find the time to watch it, you may find it pretty entertaining. &gt;shitty asteroids clone? Doesn't even have any asteroids It's actually based off of a game called SubSpace. It has nothing to do with Asteroids, though the ship movement is similar. &gt;and it only runs at 60 fps lol why is this a good thing Mobile devices have a fixed update rate of 60 hertz, or 30 hertz double buffered. The Nintendo Switch and PS4 have similar fixed render frequencies. Pinning the game to exactly 60 fps ensures the largest "net" for deployment targets. It also simplifies the game code because you never have to deal with variable frame rates (which is usually provided as `deltaTime` in other game engines). Sure, having a "fast as possible" frame rate is pretty great for 3D games, but the pros of variable framerates for 2D games aren't enough to justify the cognitive overhead between calc and render loops. All this is covered in the video btw.
Created a gist with the game code.
Created a gist with the game code.
Here's a gist: https://gist.github.com/amirrajan/0508016bd1d165138b708a9abc9a7b4e
Nice! Thank you!
sensible answers! thks!
I have my version of this. It's probably close enough [https://github.com/jwoertink/gosu-example](https://github.com/jwoertink/gosu-example) This is from a LONG time ago though, so not sure if it boots still or not lol 
Nope. This is right against the metal. Native, LLVM optimized bitcode.
You're welcome. Hope you get a chance to watch the full stream. Would love to hear your thoughts if you do.
You'll probably find this amazing. An FPS that's ~90k: https://www.youtube.com/watch?v=2NBG-sKFaB0
I like Bulma a lot, and I am using it in an app. However their decision to not include spacers (or any means to control vertical spacing) baffles me. Virtually everyone seems to be creating their own. Why, Bulma?
Nice. I did a similar thing in Python once. What game library, if any, are you using? Gosu?
Dang! Ruby 1.8.7!? That *is* from a while ago!
Check out https://github.com/JoshCheek/ruby-kickstart Popular CS puzzles with increasing complexity gradually introducing you to the language's features. Tests and solutions included. Addictive and fun. 
It’s hand rolled from scratch. 
Indentation is your friend, buddy! 
I started to use bulma, it's fantastic! Really easy to extend. 
I am using a third party service called Elastic email to send the mails. 
That's my one beef with it as well. Otherwise, coming from experience with both bootstrap and foundation, I'm really liking it!
Is there something that prevents using customized CSS rules as a last file included? Bulma does its thing, then you add margin or padding at the end? Bourbon/Neat used to get a little hinky if you stepped on their rules too much, but vertical additions always seemed to work fine for me.
The issue is with Bulma not including them. So everyone needs to build their own and apply them one way or another, including the method you suggested. Bootstrap has these built in. 
Hah, OK. I don't often use BS and I'm certainly not a power-user, so I guess I'm used to rolling my own!
It was specific to Airbnb. 
On large project building your own may be better in the long run especially if you use BEM and semantic markup. Grids, flex box and a few mixing make things easy. Edge cases is where it gets tough and frameworks often have these covered. 
Oh yeah. Those were some good times. 
What’s the error
*Wooo* It's your **7th Cakeday** __main__! ^(hug)
Eloquent Ruby hands down. If you’re an experienced developer it will resonate well with you. 
Looking for a DevOps at the moment. This is perfect to explain to my CTO what exactly I need :)
Hi, good to hear you like the article :) The mapping is done here: https://github.com/ruby/ruby/blob/7fa16fd9624ca38f2d82c121a9af5f22c87e2697/object.c#L4130
https://rubyreferences.github.io/rubyref/ is an easy-to-navigate reference through the language and standard library.
Good points about threads. I'll add those. My Ruby knowledge gets murky once we get into how the VM works Regarding Enumerators, 90% of what I do is ETL or working with third-party API's. I don't use them that often by virtue of how the codebases I work on usually work, but I think they are perfect for the domain. It's amazing how many problems can be cleanly described as streams. I do love the `return to_enum unless block_given?` pattern though for most anything that takes a yield (and is roughly a collection). It's much nicer to do `each_user.select(&amp;:active?)` than to force a block
I think `r+` is only for reading and *appending*. Since you need to read all lines into memory anyway, you can separate reading from writing: ARGV.each do |filename| lines = File.readlines(filename) File.write(filename, lines.uniq.join) end
I've switched from Rails to dry-rb + rom-rb + roda combo in the recent months. This combo allows you to follow the Clean architectural pattern proposed by Uncle Bob. ROM.rb allows a clear separation between entity model and database relations. Simple queries are easy. You can also write complex ones. Rom-sql uses Sequel underneath and Sequel is nothing but awesome.
Thanks, it works. But I just could not convince myself that I can't do it with the same file handle. There must be a method. XD
Hm, I wrote a similar gem too. Makes some different choices about how to do things. https://github.com/jrochkind/attr_json 
Where does the 7mb binary come from? Being able to export it as a binary in the first place is great, but that's a *huge* bloat for such a tiny bit of code; I'd expect something this tiny could be ~2kb if written in a low level language.
Truncate seems to work + $ echo -ne "foo\nfoo\nbar\n" &gt; file + $ cat process.rb #!/usr/bin/env ruby # frozen_string_literal: true $-v = true ARGV.each do |filename| File.open(filename, "a+") do |f| res = f.readlines.uniq.join f.truncate(0) f.write(res) end end + $ ruby process.rb file + $ cat file foo bar 
Not really. There’s still an escape key on the Touch Bar right where the physical key would be. It’s easy to tap it without thinking about it for me.
``` fout = File.open(FNameOut, "w") File.foreach(FNameIn).with_index { |s,i| # read s, then write with fout.puts(string_to_write) } fout.close ```
Your work and demos with RubyMotion have made me more and more tempted to purchase a license. I only wish it wasn't a yearly subscription model. 200$ for a forever license would be a braindead immediate buy for me.
There is unfortunately a non-trival amount of upkeep with making sure RubyMotion works with the latest versions iOS, Android, and consoles.
I like Ruby a lot, I also like VueJs, but it seems like PHP is still the 'popular' language. 
I like it and I think representation is important! I'm not sure about taking the old image and adding a turban and dark tones onto existing characters though.. it would have been a good opportunity to come up with a fresh, diverse image from scratch, but it's better than nothing and I can't draw.. :-D
It's an interesting idea. I don't think any of the existing web frameworks in ruby that assume a deployment architecture more or less Rails will ever unseat Rails -- there's too much maturity to catch up with. But something focused on serverless deployment might be attractive, and be a useful complement. Are there (yet?) platforms/frameworks in other non-ruby languages focused on or more suitable for serverless deployment? Is there anything about _ruby_ that makes it less suitable for serverless deployment than solutions in other _languages_?
I think most solutions (in almost any language) based on standard filesystems don't do this easily. There are some tricks to it. I'd consider not doing this, and instead writing to an additional temporary file, and then when you are done, doing a filesystem-atomic replacement of the original with your new file. See File#rename. That also means no other processes will ever be able to see the original file with changes "partially" applied, they'll either see the original file or (after File#rename replacement) the complete new file. Which is often good. This does mean you will have to write all the bytes again. If it's a really huge file you are only changing a few bytes of, you are still paying the cost of writing _all_ the bytes, and hypothetically there could be a solution that doesn't do this. But I don't think any of the other solutions in this thread avoid this either. They still write all the bytes, they just try to do it in-place. I don't think there are any advantages of that, it's a lot safer to write to a temp file and use File#rename. File#rename should be very quick, so long as both files are on the same volume. 
Web Assembly will surely be a nice welcome change. The good thing about Ruby is that it has Rails, and the community will most likely take care of that for you. Although the door is also open for completely new solutions to be born.
I like Rails and Vue. Based on my experience, JS front end is hard to maintain compare to standard erb with minimal js (jquery). I started with vue v0.12 app. I spent too much time migrated to v1 and v2 from v0.12. Jesus. Just too much time wasted looking for solutions and bug fixing. Maybe erb is not fancy like Js but it doesn't require much time to maintain in the long run(~ 3 to 5 years old views).
&gt; Why would you use Ruby for a backend when you could just standardize on Javascript for both backend and frontend? Because JavaScript is a shitty language for backend development. Or anything really. We use it on the frontend because it's all we have, not because it's better than the alternatives.
Nope. I'm on a MacBook Air now for other reasons so I have Esc again but I was on a TouchBar MBP for a year and it had *no impact at all* on my usage of it. I don't need to have a button actually depress for it to work and.. well, it worked fine.
The docs kinda show all options possible: https://ruby-doc.org/stdlib-2.6.1/libdoc/fileutils/rdoc/FileUtils.html#method-c-cp_r (sometimes there are something missing, but it is pretty rare). The `:force` option in that example is passed to another method: FileUtils.rm_r site_ruby + '/mylib', :force ...and it is documented for that method: https://ruby-doc.org/stdlib-2.6.1/libdoc/fileutils/rdoc/FileUtils.html#method-c-rm_r Though, funny enough for this case, example of using `:force` is wrong :) It should be FileUtils.rm_r site_ruby + '/mylib', force: true I'll fix it. What options mean, is (somewhat scarcely) documented here: https://ruby-doc.org/stdlib-2.6.1/libdoc/fileutils/rdoc/FileUtils.html#module-FileUtils-label-Module+Functions &gt; The options parameter is a hash of options, taken from the list `:force`, `:noop`, `:preserve`, and `:verbose`. `:noop` means that no changes are made. The other three are obvious. Each method documents the options that it honours.
Couldn't have said it better! Especially if you stick to the standards; simple_form, bootstrap, devise - very few lines of code, very easy to maintain. Rails apps tend to grow into monoliths which are hard to maintain because of sheer size. However, try breaking it up into 30 microservices and see what happens.
I think Rails is still amazing, best tool for the job if it doesn't require too much fancy frontend stuff.
It's popular because of wordpress and magento. These are the two areas where (open source) Rails failed to make a dent. 
&gt; JavaScript is a shitty language for backend development. Amen.
PHP is a mess IMO. It's been coasting on early success for a long time. I don't want to dig at people who use it, but the tooling/deployment/hosting situation in PHP-land is a nightmare, imo. Sure there are plenty of PHP jobs, but I don't think you could pay me enough to work in that ecosystem. 
Most people don't need microservices, they need a well thought out monolith.
Hey, thanks for the comments. I just want to say that I love Rails! I don't think Rails is going away or anything like that. I was just thinking about where it seems the industry is moving to, and how we can help to push Ruby along for the ride. I also don't mean that Ruby is dying or something like that, but is up to the community to keep it going forward and a move to serverless plus a browser runtime would really give it a push IMHO.
I agree, but it is growing.
People say using the same language for front and backend is a good thing because you don't need to know 2 languages. I think it's a moot point and prefer using vuejs + rails though.
People say using the same language for front and backend is a good thing because you don't need to know 2 languages. I think it's a moot point and prefer using vuejs + rails though.
I think the same language argument is less technical and more business. Companies that develop web products will eventually stumble upon a lot of javascript as the product moves forward, and having the same language across the stack makes it easier to shuffle resources around, providing you can hire that many JS devs. I've seen also some places that started to write services in Golang instead of Ruby because of performance. This is debatable as a business argument, and I don't mean to get into this right now. What I wanted to say is: in my opinion, that's how Ruby and Crystal can be a killer team. Imagine if you could run Ruby in the browser, write your backend in Ruby and use Crystal for the endpoints that require high performance?
I couldn't agree more! I've done a lot of Rails dev, and man... did I love to respond with JS
I think we can push Ruby by making more apps. I see a lot of tutorials, but for very small apps. I'd love to read the source code of (a bit) more complicated apps.
This is one of the things I hope FaaStRuby will help solving, but without making it a framework.
Wordpress and Magento cause a lot of users to require PHP, but I also see a lot of opensource apps written in PHP, OrangeHRM, OpenERP, SugerCRM, and don't forget the otherother CMS like Joomla, Drupal
Do you mean Ruby in general or FaaStRuby?
I am curious - would it still matter if it is a monolith or not if developing the app felt like writing a monolith?
&gt; having the same language across the stack makes it easier to shuffle resources around, providing you can hire that many JS devs Is this really true though? Any developer that's worth their salt should be able to pick up a new language fairly easily, it's switching problem domains that's the tricky part. You wouldn't hire an NLP programmer to write a 3D graphics engine and say "Hey, it's just Java, you know Java, right?" Like NLP and 3D graphics, frontend dev and webdev are different beasts. Frontend JS development requires knowledge of things like DOM, shadow DOM, the CSS box model, and state management in reactive JS frameworks. Backend development requires knowledge of things like SQL and/or NoSQL, servers and app servers, caching, and so on. &gt; write your backend in Ruby and use Crystal for the endpoints that require high performance It's an interesting idea assuming that porting existing Ruby code to Crystal takes less effort than porting existing Ruby code to C/C++. I've never written a Crystal program so I wouldn't know.
haha oh weird. okay , i guess i just thought for some reason there were more options for this method.
I'm well aware, it's wistful whining :) Not a true complaint, I think I've said it before. Chances are you're getting my money anyways.
That's a really good point. I guess I would add geographical restrictions to that mix. I know a lot of people hire remote, but a lot of companies still do it the "local" way. I am from Halifax, NS, Canada, and here the competition for talent is huge. Some companies are struggling to hire for other languages, but here it's not as hard to find JS devs as it is for PHP, for example. At the end of the day, you gotta make it work with what you have. &gt;It's an interesting idea assuming that porting existing Ruby code to Crystal takes less effort than porting existing Ruby code to C/C++. I've never written a Crystal program so I wouldn't know. It would probably be hard to port a big app, but I don't think it would be C/C++ kind of hard hahaha. Jokes aside, it shouldn't be hard in the context of serverless functions. I've ported small gems and only had to modify a few things around types. Ah, and the single quotes...
Great read, I'm about to start a Web development course at General Assembly and it is taught in Ruby. So this gave me some nice optimism about the future. I hope your suggestions are listened to! 
I’ve mentioned this elsewhere but it’s worth saying again: Take your hourly wage and multiply that number by 8. If that number is less than $199, I’ll set you up with a coupon code to cover the difference (if you’re unemployed, I’ll cover the entire license). Over a year’s time, if RubyMotion hasn’t brought you 8 hours of joy, I failed as a product developer.
I completely agree. Lately I've been replacing the JS frontend from a personal project I've been stuck on. I went from VueJS to .erb + StimulusJS + Turbolinks and I feel like a fish in the water.
&gt; Any developer that's worth their salt should be able to pick up a new language fairly easily Eh, I don't know how true that is, depending on what "pick up" means. Get a basic familiarity, sure. Get enough familiarity with not only the language, but it's toolchains (oh JS toolchains), and ecosystem (which dependencies are solid which aren't), and which kinds of architecture make sense for that language and ecosystem, to be really effective? I think it takes a while, you aren't gonna get it in days or even weeks. Maybe months if you're good. But you're going to keep getting better for years. If there's someone else to tell you exactly what tools and libraries/dependencies to use, and to spec out the architecture, sure, you can do what they tell you. But I think the interchangeability of developers is often overrated, and the value of long-term familiarity with a platform underrated. 
Not to be confrontational, but the only people I hear saying that JavaScript is bad are people who don't write much JavaScript. It's not a perfect language, but neither is Ruby. It has quirks of design, but so does Ruby. The thing that really screws JavaScript is backwards compatibility; mad shit from the early days (e.g. implicit type coercion) has to be maintained because you can't just break the way the web works overnight. But with ES6 you have a pretty neat little dynamic language, which which you can build really powerful things. But I've defended JavaScript before and I'll bet you've had this argument before, so let's not repeat ourselves. Since you ask though, the advantages of JavaScript in the back end are simultaneous connections, speed and scalability. With Rails the number of simultaneous connections is limited by the number of threads you make available. With Node, concurrency is exactly 1, but the Node runtime doesn't hang around and wait for one task to finish before moving on to the next one. Asynchronous programming is perfect for the web too. There's no good reason for a server to block a whole thread while it reads from a database. So Node outperforms Rails? Oh my heavens yes. It also scales better, because there is theoretically no limit to the number of concurrent actions taking place. But raw speed is absolutely not a design goal of Rails, in the same way that providing an opinionated MVC framework is not the goal of Node/Express. We're comparing apples and oranges here. A fairer comparison might be made between Sinatra and Node/Express; both are designed in a way that makes microservices an obvious use case. But again, Node kills Ruby for speed and scalability. This isn't a religious argument; performance isn't everything. Shit, if performance _is_ everything, don't use Node. Use Go or Rust or even Python/Flask if all you need is raw speed, all three leave Node and Ruby in their dust. But chances are that you don't already have a Go/Rust/Python programmer in your team. And chances are that you _do_ have a JavaScript developer. So if you need a performance boost over Ruby and you're limited by your access to people, Node makes a ton of sense.
if by 'felt like writing a monolith' had the same ease of debugging/backtracing/deploying/operating as a rails monolith then no!
I really feel like Erlang/Elixir figured this part out right. In Erlang you build lots of small processes (actors/"services" but more like "classes" in a lot of ways) and package those into "apps". The "apps" run on VM instances (a single OS process) called "nodes". Nodes can be networked easily and you can distribute apps across nodes The point is you can develop in a monolith (i.e. one OS process) but it feels like you're creating microservices (you are creating self-contained apps that run their own set of Erlang processes; comparable to threads in other languages). You also get the ease of distribution when you need it
I’ve been working on some exciting stuff for the next release (0.5) that addresses this problem. I’d love to give you guys a demo over hangouts or something before I release, just to get some feedback and maybe correct a few things. Basically 0.5 introduces FaaStRuby Local and the concept of projects, allowing you to create a full web app or API with functions, and the goal is to give it a monolith feeling. You can mix Ruby and Crystal in the same app and develop locally, with live compilation of Crystal functions. To create functions, all you do is add folders to the project. When you create a file “handler.rb” inside a folder in the project, Local will detect you are creating a function, write the config file and initialize the handler for you, with automatic language detection (Crystal or Ruby). You can then deploy the whole thing as distributed functions with a single command: faastruby deploy. Or you can start the server in live sync mode, and all changes you make get instantly deployed to the cloud, so you can see in real time how it would behave in production. But I want to stress one thing - this is not a framework. Not at all. 
What happens if it crashes mid way through? I'd rather do the two file approach because of this. You can use gzip if you are working with something large, and if it's really big then Hadoop (via AWS EMR or something) is really good at this
I would love to work on a serverless rails solution. 
I couldn't agree more, but TypeScript takes most of that shittyness away, to the point where it's a viable for both front-end and back-end.
\&gt; I don't want to dig at people who use it, but the tooling/deployment/hosting situation in PHP-land is a nightmare, imo. I am curious to know what you are talking about in regard to deployment and hosting as that seems other wordly. deployment is so easy in PHP in many case you can use FTP and hosting? Seriously? what easier and more affordable to find hosting for? we no do quite a bit of Laravel these days and are not even close to experiencing this night mare you are talking about.
&gt;Not to be confrontational, but the only people I hear saying that JavaScript is bad are people who don't write much JavaScript. It's not a perfect language, but neither is Ruby. It has quirks of design, but so does Ruby. The thing that really screws JavaScript is backwards compatibility; mad shit from the early days (e.g. implicit type coercion) has to be maintained because you can't just break the way the web works overnight. But with ES6 well you got one upvote at least. I went kicking and screaming but as of Es6 realized I was just fussing because I was accustomed to fussing. 
&gt;People say using the same language for front and backend is a good thing because you don't need to know 2 languages. When someone says that, it tells me they don't know where the hard part of development is. Having to know more than 1 language isn't it.
&gt;but that's a huge bloat for such a tiny bit of code Well, that's just the code for the game. The underlying engine still needs to be packaged with the game to avoid external dependencies (specifically sdl, chipmunk2d, custom audio stuff, and a specialized ruby runtime).
I’ve been writing non-blocking code since before any of these languages existed. It is not a paradigm unique to Node, and you do not require threads to achieve it in Ruby either. The only speed that really matters in most cases is developer productivity. 
Could you give an example of a non-blocking HTTP request in Ruby without threads? I don't doubt that it's possible, I've just never seen it before. Your second statement goes both ways. Ruby is designed with developer productivity in mind, but if my boss needs something weird bashed out quickly within a sprint or two, doesn't care what language I use, and only cares that I get it done quick, then I'm going to reach for JavaScript first every time. Why? NPM. Most of the work is probably done for me in a library already. Don't get me wrong, Ruby has a great ecosystem, but NPM dwarfs RubyGems by a long, long way. "But what about technical debt? Are you really going to just interface a dozen dependencies and call it done?" Sure I am. The only performance measure that really matters in most cases is developer productivity. "But what about security? Do you want another left-pad incident?" Doesn't matter. The only performance measure that really matters in most cases is developer productivity.
Ruby is on the map because of rails.
Ruby is not going to survive because of Crystal. That doesn't make sense.
CRM and eCommerce? Shopify would like a word.
In my opinion, Ruby is waaaaay more approachable than Crystal. Crystal's syntax is similar enough to Ruby that a intermediate Ruby developer can play with it. Ruby's freedom makes it really easy for beginners. Typed languages require a bit more time for a new developer to master. And I am not talking about the comp sci grad, but really anyone that wants to learn how to code.
Just curious, what would be a non-safe enumeration type?
But like why are you even talking about it here?
I have to go and get some sleep, but I have this open in a tab of my browser to comment in some more detail after I got some sleep. There are a lot of crap statements (typically) but I also admit that there are a few good observations too, in particular in regards to momentum (even though this actually is not completely mapped 1:1 to rails; but anyway more on that in a few hours from me).
Thanks，you are right, that sounds like transaction . 
You can put a pig in a dress, but it's still a pig. 
Is it true that Python/Flask is that performant (outperforming Node)? I have some familiarity with Django, and none with Flask. I don't see how it could be so performant, I thought the runtime was the bottleneck.
to me it boils down to performance: would I be able to get the same response times as I have on a pre-booted app? what if I have literally thousands of objects? &amp;#x200B; rails boot time has been a pain for me for a while, which makes me wonder how could a serverless "vm" work decently enough for ruby. &amp;#x200B; what's the actual price that i'm paying for going "serverless"?
It's clean and easy to read, so props for that. This is great for allowing other people to take a look and you will thank yourself if you ever decide to come back to it later (adding input validations, for example). I think you have an opportunity to clean up/refactor line 32 of `Account.rb` a little bit. If you were to read it out loud, as written, in plain English, you'd say something like: "Unless a given file existing is not true, do...." You wouldn't say that out loud and I don't think you need to code it here and it sounds like a double negative because it is a double negative. Technically, there are three things here that all are working towards returning a single boolean- unless, .exists? and the != comparison. You can trim down some fat here and keep this line as clean as the rest of your app. There are many ways to get there, but I bet you could cut that line in half by turning it into a regular `if` statement. 
&gt; Could you give an example of a non-blocking HTTP request in Ruby without threads? The same way node does it. Offload IO to OS kernel. Did you think it did something out of the left field there?
Thanks for the input. As for line 32 Account.rb, I 100% agree. I was actually just looking into the "unless" keyword at the time, and forgot that I had left that in there. I'll take another look real quick, and comment what I replace it with. 
You should use [rvm](https://rvm.io/), my guy. You can install any version &amp; gems independent from your system. Also easily switch ruby versions. 
I know that... however that does not answer my question
I have to agree with thebetterbrother that it is clean and easy to read! One thing I have found helped with my learning of ruby was using a linter (rubocop). I found the interface you made aesthetically pleasing as well. I wish you the best of luck on your learning!
Short answer: you don't. You could remove the gender you installed, but they're likely not hurting anything. As the other poster said, use rvm and make sure your env is properly set up in your bashrc.
You can download the update installer from the App Store &amp; pull out the ruby files with the `pkgutil` command. Or do an OS reinstall but choose the option that keeps your data so it only reinstalls system files. 
JS is not shitty at all for backends. JS was shitty indeed back to the time before 2015. ES6+ (2015+) is totally a different language. If you are still writing jQuery, yes no wonder you feel JS sucks. The way we did for UI before reactive frameworks is totally wrong. But most of recent techs had been done in JS community. Rails 5 and 6 are not much more than just hugging JS world. I admit ActiveRecord is a really outstanding ORM and no one else can compare with it at all. But that's all. I can write JS with my hand to get WebSocket services working with existing Express/Koa server maybe in 30 lines. Can you do that to Rails without a gem? It's not easy to write async functions in Ruby which is pretty native in JS. I don't want to write ruby for browser at all. The web world is moving more and more stuff to frontend. Just saying JS is shitty does not help.
This isn't what I mean by "developer productivity", except for those whose job is farting out one-shot MVPs that can be thrown away unmaintained after three months because the startup either rewrote it or ran out of runway. I mean sure, if your job is writing disposable software, use whatever you like to work fastest in, but let's not hold it up as some kind of ideal solution for people making something worth keeping around. NPM has a ton of stuff because the JS standard library is a horrifying dumpster fire, and the result of pulling in stuff from NPM is always fragmented dependency hell. I've never been anything but ashamed by the contents of a node_modules directory. 
but now it's in a dress tho
Is there a reason you consider it shitty for backend?
If you dont mind there isnt tutorial creating the app, gitlab is rails app (it's pretty good inspiration source)
&gt;but that's a huge bloat for such a tiny bit of code &gt; external dependencies (specifically sdl, chipmunk2d, custom audio stuff, and a specialized ruby runtime). Ah, so there's actually much more to it than that gist then. If be very interested in seeing the whole thing... But still, I stand by the claim that 7Mb is a *huge* bloat... Modern software is extremely wasteful. 
&gt; and have wondered if there's still a place for DRb somewhere I do all my text editing in a text editor I wrote in Ruby where the buffers are stored in a Drb server. I started dog-fooding the editor within a few weeks of writing it, and that was largely thanks to the ease of getting Drb to effectively provide crash-resistance - Drb will rescue and pass exceptions in methods you call back to the calling process rather, so since the buffers only ever accessed via Drb, and lives in a different process than almost all the code (the Buffer class only has a handful of methods to mutate lines of text and handle basic undo/redo), whenever I manage to crash an editor instance, I just restart it, and it reconnects right where I left off. The server process also checkpoints all the open buffers to a JSON file every 5 seconds and on TERM and automatically reloads it on startup, so unless I make some really catastrophic changes on the tiny little server piece, even if I do for some reason have to fix a problem in the tiny server side piece, I can just kill it and restart it after applying a fix and all my open buffers are still there. This also means I get multiple frames/views of the same files "for free", as I can just spawn multiple copies of the editor and have them connect to the same server via Drb (I use a tiling wm, which saves a lot of hassle there, as I don't need to deal with any window placement shit; whenever I get around to pushing an updated version somewhere public I'll probably need to do something *slightly* smarter there, but for bspwm this is literally 2-3 lines of code for the full multi frame support). On the downside, it's harder to reason about what happens server vs. client side and what actually passes over the wire with Drb. You have to explicitly mark classes that you want passed as ids/handles to the server rather than serialized to avoid accidentally sending over your entire state if objects reference each other, and it's easy to expose a broader API than you intend. Partially as a result of that I'm considering rewriting the API for my editor buffers to drop the Drb dependency. But Drb was fantastically useful to get started without having to worry about that part, and it's been rock stable for that kind of use. I'd be vary about using it for something that need to scale up to lots of connections etc. though, without spending more time ensuring I had full visibility into what passes over the wire. 
Do you have recommendations for a ruby epoll library/wrapper? recently took a job at a company with a large existing ruby code base and still figuring out the lay of the land. generally my preference is explicit event loops, manually handling state, etc. thanks for any help you can provide!
Here’s my take too. https://gist.github.com/inopinatus/f454241886866562f7b39b9b41267a4c You’re nobody in this town if you haven’t written a json attribute object representation 
Well of course not. But Net::HTTP is absolutely not asynchronous, non-blocking. I asked to see code because I want to learn how it’s done, not how it works behind the scenes. 
TypeScript is a clusterfuck of things and nobody wants to use CoffeeScript. Pick your own poison.
I think it will keep going as it's going now: It will still be very relevant in startups / smb's (yet perhaps somewhat decline further), but not so relevant for big corps. Of course there are exceptions like Shopify/Stripe etc but most ruby jobs I see are small to medium businesses. Banks, governments, insurance companies etc will stay with their "enterprise" stacks such as java/c#. Overall you can have a very nice career in Ruby in most major cities in the world but I would try to pick up a more mainstream tool along the way. The two things keeping Ruby alive are Rails and devops and they aren't going anywhere.
Just take a look at the example in the README: https://github.com/socketry/async-http
You have baked in support for websockets in Rails (btw what's wrong if it was in a gem? as if javascript isn't a collection of npm packages). If you ever get to serious scale issues (that's a big if, most companies never do) you will have a big devops team to deal with scaling issues. Those issues may arise no matter what language you're using...even java can get memory bloat and leaks. At the end of the day anything can be used to write anything, I don't think there's a clear advantage to anyone. Rails is quite nice for backoffice crud apps or for grinding through an MVP but that's just my opinion, you could also do it with java.
&gt; NPM dwarfs RubyGems by a long, long way. About a year ago, I had to render a 3D animation to an mp4 video server-side in a Node-based project. All I needed was an easy way to interface some sort of 3D rendering library (e.g. Three.JS) with ffmpeg, but no such 3D rendering library existed. (Three.JS needs several browser features that do not exist in a Node instance.) I ended up having to write the entire thing in C++ and call out to that program using `ChildProcess`. It was hands down one of the most painful programs I've ever written. This would not have been any issue in Ruby, Python, or most other popular scripting languages.
Ah ok, we've misunderstood each other. Node has async functionality _built in_, it's kind of the language's whole reason for being. Comparing gems and libraries isn't fair or worthwhile. Any feature you can think of in Language X can be implemented can a library for Language Y, given that both languages are reasonably mature.
So... some comments finally. First, I will start with the parts I agree with or which at the least seem to make some sense. I'll then reply to this with the points I see quite differently. (1) Loss of Momentum Now ... let's ignore for a moment as to how people use ruby, because a lot of the article is about rails. I have been using ruby before rails, I am still using it and I have no problem. It would not make a difference to me whether 5 people or 5000000 people would use ruby. I also think it is a problem if a language is only used because e. g. of rails. But let's put that aside for the moment. For the most part, this is correct in general to say that ruby lost momentum. This has many reasons but keep in mind that other languages are struggling too. Perl. PHP even more than ruby AND perl combined. This has, again, many reasons. Python becoming more popular; the awful joke that is JavaScript becoming more important. More languages rising. Things like that. Of course we also have to ask HOW to define momentum? Objectively speaking? Hard to define that. There are some absolute criteria though such as how many people are using a language. If you have 50.000 users at point X, and 10 years later you have 10.000 users, then evidently this is not good. In these cases I think momentum will be lost too, along with users. It may not be exactly that way, all the time, since momentum is hard to define; but even if you have an active team evolving a language, without people USING a language, there is no point really. Ruby is far away from being irrelevant; but ruby is also somewhat far away from being in a position where python is RIGHT NOW. That may change in the future, but right now I think we'll have to live with the present status quo. Change does not automatically come easy. So, I sort of agree with that statement. I think speaking from rails, the biggest contender is ... JavaScript. Which brings me to: (2) Ruby rather than JavaScript. I agree too; not necessarily for the same reason but simply because JavaScript is a terrible clown language joke. I used to think that PHP is an unbearable spaghetti mess, which it is, but JavaScript is in many ways worse since there is no way around it. So I agree to the "Ruby needs to run in the browser". There are some partial workarounds such as opal but ... I never fully figured out how to use it; and it seems to only be a ruby-to-javascript compiler. In reality we really need to free the www from the slavery-addiction towards javascript. So if Web Assembly can help here, that is GREAT. The www is a bit fudged up right now, with Google being the monopoly that it is, diversity dead on the road and in general way too much unnecessary crap coming from the W3C lobby group (DRM part of an "open" standard? That's a real knee slapper, that one). Next part will be where I disagree with, but I want to end this stating that I think ruby is still in a really great shape. People love to focus on drama (see the people who would point at the rants from linus - these people happily take the rants and construe a story, and IGNORE THE OTHER EMAILS BECAUSE THEY ARE NOT AS FUNNY TO THEM, and then they state they have a real picture of the whole situation ... yeah ...). The ruby ecosystem is in a pretty good shape, IMO. As I showed elsehwere, you HAVE new gems, you HAVE new users on rubygems and the general ruby ecosystem is in a good shape. Compare this to perl's cpan. Sure, cpan is still active, but how much momentum does perl have? Python has more activity/numbers on pypi https://pypi.org/ but the difference is not that much; last time I checked it was at around +20% compared to ruby or so. Considering that python has significantly more users than ruby has (I'd say x3 easily), a difference of only ~20% in the gem/eggs, is really a small one, give or take (the full percentage values don't matter that much really; whether it is 15% or 25%, the point here is that the difference HERE is not that large).
&gt; Comparing gems and libraries isn't fair or worthwhile. &gt; Comparing gems and libraries isn't fair or worthwhile. That's seems rather arbitrary. &gt; Node has async functionality built in, it's kind of the language's whole reason for being. Node isn't a language. And although JavaScript has language level support for promises (via the async and await keywords), it doesn't not have language level support for Async IO. That's a library feature of the core Node modules.
Alright now the points I disagree with. Some of which are problematic to state by the author. Others are minor points, but anyway: (1) "We think it had a lot to do with the with the introduction of Ruby on Rails in 2005." I used ruby before rails even existed. I actually think the first popularity OUTSIDE of japan happened with e. g. the pickaxe. The documentation of ruby in regards to english was always not really great, whereas ruby itself is a really well-designed language. (You only have to look at the "offspring" you have had, syntax-wise, alone.) Rails brought in some new users; and a lot of hype. The problem with hype is that it will eventually fade; and many of these users were renegade-ronins who had no interest in ruby to begin with. In the past, I never understood why Haskell was so elitistic and the haskell folks openly stating that haskell is not for everyone and they don't even want to have everyone use Haskell. These days I can understand that a LOT better. Not only because of those users who have no real interest in a language but also because some of them make TERRIBLE suggestions (only have a look at the ruby issue tracker, in particular from the "functional" crowd that have no understanding why syntax matters). So, well - it's great if people come to ruby and use it, but I also have to say that I agree with some points of the Haskell folks. Ruby is not for everyone. And if you don't like a language, it really really really would be much better if you would not use it altogether. Leave a language up to the people who like using it and find something else to do with your time. It's a win-win for everyone really. Not every functional programming person is terrible at designing languages, mind you; but there are also many who are. If there are 100 issues on the bug tracker and 99 are terrible, matz has a hard time selecting good additions to ruby. And several additions/changes are ... hmm ... not that great. (It's strange, but something as simple as making require 'pp' no longer mandatory, is a MUCH better improvement than various other changes that came from the functional crowd.) (2) "Rails was a perfect compliment, as it provided a solid framework to bootstrap full featured applications really quickly." I think he meant to write complement. I don't think rails was a "perfect" addition/complement; but I have no qualms with rails as such. My biggest gripe was that rails indeed was too large in regards to ruby. People would use ruby because of rails, not because of ruby. And that is not good. Most of the hype was also terrible. It's artificial. "Pair that with Ruby’s simplicity and ease to learn" Ok. This is the first shitty statement. Now - ruby is VERY well designed. It's great. Anyone having done PHP before can appreciate that. I wouldn't be able to go back to PHP - my brain just refuses. It would not be worth my time either. Ruby is, however had, NOT necessarily simple. Matz actually said that too. Ruby is more consistent and the "ruby way" makes sense, can fit into your thinking too. But ... simple? Hmmmm. Lots of things in ruby are not necessarily simple. Syntax wise, flexibility is great but not always simple. With other changes such as foo&amp;.bar&amp;.foo (I probably got the &amp; wrong?) and various other changes there ... well. I don't think ruby is necessarily the SIMPLEST language. I am sure you could design a ruby that is simpler. Ruby does not necessarily AIM to be the simplest language either. The stronger philosophy-part is what matz said in 2003 and before and lateron - ruby tries to solve problems that (some) people may have. If you look at the addition of the safe navigation operator, that is precisely one such use case. Someone explained it, reasons etc.. and it was added. I don't use it myself, but that sort of is a good example of the philosophy of work. Also the fact that the ruby core team often said that they focus on real use cases rather than abstract theoretical ones. (Sometimes there is a blur, but often if you start from a real use case, it is more likely that change may happen. I can give many more examples of that - you only have to look at approved changes there) Is ruby simple to learn? Hmm. I think ruby at core is quite simple. Going to publish gems that are of a medium size and used by other people ... now that is a bit harder. It took me quite a long while to be able to understand what has to be done in order to get ruby gems to work reliably. For example, I did not have the scripts under bin/ of that gem registered appropriately in .gemspec; or I did not know how to find out the project base directory for a long time either, so that did not work for other people (it always worked on my home system of course). These things are not easy to figure out really ... and ruby's documentation is still just average really. It's not terrible but it is not great either. Some snippets you find on blogs or on stackoverflow and I think this is actually a problem. Documentation should be in ONE central place really. And of high quality. It should not be unnecessarily long, but the current documentation is in many ways not really that great. Ironically enough I have heard people say that about python, that it is too verbose (the official docs). That may be too, I have no idea. Documentation is difficult. Curiously enough, PHP has a really good online documentation. Considering how terrible that language is from a design point of view, it's really a testimony to the new jersey model ("worse is better" ). https://www.jwz.org/doc/worse-is-better.html &gt; The framework was a great fit for rapid prototyping and MVP, and &gt; so it became a favorite amongst growing startups and web scale &gt; companies like Netflix, Shopify, AirBnB, &amp; Github Well. I do not disagree with this per se but ... Github? Being sold to what ... +7 billion to Microsoft? 10 years lateron? That was a good decision for the founders of course. A typical startup success story. But here is the thing - you should have said so from the beginning that you planned to sell it after that period of time anyway. Because that was EXACTLY what has happened. And now the Microsoft empire controls it - and we all know that Microsoft has no real interest in ruby either. There even were talks to move away from Rails too - not sure how well that has progressed but I would not be surprised to see this in the future. Again, it's still a success story, but it's sort of ... strange. People who would have used Github 10 years ago knowing that Microsoft would assimilate it? You even have these strange moves by others, Red Hat mysteriously becoming a part of the IBM empire. Hmmmmmmmmm. I think it is very bad to treat everything from a business-aspect first. These clowns are often why inertia is prolonged. COBOL? Still not completely dead yet? (3) "Over the past ten years the industry has shifted towards distributed systems that can be developed faster, and scaled more gracefully. " I doubt that slightly. That seems to be very one sided aka "agile is AWESOME" or "microservices are the only future" or "the cloud rescues babies every day". "These trends also contributed to loss in Ruby popularity." Not really. JavaScript alone contributed more to losing momentum than the "cloud". "Rails, arguably the reason for Ruby’s popularity as a web development language in the first place," That pisses me off. I was using ruby before rails and I did back then, and still use ruby for everything related to the www as well. In fact - I literally use ruby for everything. I would not know why I should not do so. Why would I not want to do so? The only argument one could possibly use against that would be speed. But that still would not be worth my time to do microperfection wasting my life into that. It's great that some people can do, but it's not my style of thinking. The future is not in some new verbose shit language but in a language that could unite elegance, beauty and consistency with a good syntax. And most languages already fail syntax wise. Look at Rust and tell me how it is a massive "improvement" over C++ please. "Additionally, companies were already employing JS developers to build rich web apps, so there wasn’t a need to retrain or hire new talent." That has less to do with node and more with JS becoming important. 50% of that article feels like a web-promo ... and it is not even hosted on medium, which would instantly mark it as terrible. :\ "This also created a problem for Ruby in the web industry." Yes, JavaScript is a problem. But not just for ruby. For the whole www stack. "Why would you use Ruby for a backend when you could just standardize on Javascript for both backend and frontend?" I can answer that! Because JavaScript is a terrible utter garbage joke. Props to the poor worker slaves who have to use it, but, boy - wow. Insane madness. And I don't want to contribute to this madness. A 3 weeks "designed" language that is still clowning and trolling us all here. 
 (3) "Ruby’s Comeback" "Despite this history, we are optimistic on the future of Ruby." See, it depends on what you mean with "future". Now first, ruby is the way it is because matz is in charge. One day this may not be the way and then ruby would have changed (most definitely). But for now you have matz in charge. And matz is still motivated. You can see it with mruby for example. Contrast this to guido who lost a lot of his enthusiasm after the burn-out stage with the := operator (which is terrible but it is even worse when language designers stop having fun). So keeping matz interested and motivated is important. I don't think you can come to the conclusion that, because ruby lost momentum, it is dead. If that were the case, why would rubygems still show MORE gems AND more users? This is something that people can not answer. And I actually manually (!) gathered the stats there. Sure, old people often become inactive but that happens in every language. And yes, one account may add lots of gems, I understand that, it is not fully representative. But you had the same situation in the past too, say 10 years ago, yet the gems ecosystem still grew. So from this alone, I highly doubt you can reach that conclusion. Which leaves us with ... momentum. This is harder to define. And what do you mean with momentum? Do you mean something like rails, a single application mostly that would show to the world how mega-awesome ruby is? I don't get that part either. Do I need an application or framework to come to the conclusion that a language is good or bad? Take PHP. A terrible joke. But there are awesome applications - mediawiki, phpbb, wordpress (yes, it is awesome, even if everyone hates it - you only have to look at people USING something, which DOES define success even if you disagree with the usage of something), drupal etc... etc... No matter how many great applications there are, PHP is a terrible joke. I can not stand writing PHP code anymore. When I compare it to ruby code, I wonder why I should write any more line of code in PHP. Because, really - it feels as if we are in a different universe. I rather much write something I need in ruby, than downgrade myself into using PHP. I am sure many python folks feel the same when it comes to PHP. So ... no. I don't think you need ONE KILLER FRAMEWORK TO RULE THEM ALL AND GENERATE HYPE. That is just hype-addiction. I do, however had, agree that applications, stacks etc... used by lots of people IS something that is very important. Writing something that is used by many people is hard. It is very hard for a hobbyist to do so too. Just the amount of time that may get into it ... &gt; Here’s what Ruby has going for it: &gt; It is simple to learn and easy to read so it allows teams to work fast No, sorry. Total and UTTER bullshit. Ruby CAN be super-clean and elegant. It's a great language. That does not mean all of ruby is great. Or elegant. Or simple. And ... nope, easy to read? Not necessarily so ALL of the time. In fact, most code that I see is crap. Some of this is due to personal style, so that's ok; but there is also code that really IS crap. People who say "hey my code is self-explanatory so I don't need to comment it". Wow. These clowns are terrible and they suck. Whenever you hear that, you know the person is just lazy AND sucks. Out with these people. It's the wrong mindset. I am lazy too but I always said that documentation, comments etc... IS hugely important. You provide people with a way to use something. You teach them too. That is important. If you can not do so, why even distribute something? You could keep it all local to yourself and the world would be better off than to publish undocumented, uncommented code that is terrible. Just because ruby is a great language does not mean that everyone using it will become a perfect uber hacker. Of course the better language can help you more - you only have to compare ruby to PHP here. But even the better language can't do much if you have the wrong "reasoning". So ... no. Easy to read code written by others? Nope, not necessarily so. It depends a lot on the individual who wrote it, even well aside from style. "It is mature &amp; feature rich – well maintained by a community of an estimated 74,000 developers globally and it is the language-of-choice at many large and growing web-scale companies like Shopify who contribute to the community regularly. " I have no idea how he comes to the number of 74.000. Why not 74.521? Where is the difference? How is that estimation done? I was not using gems in my first ~10 years or so, so are gem statistics indicative of anything? Not really. And shopify? Well, it's fine that they contribute too (mruby), but ... what would I care about whether shopify exists or not? It's nice that they do assist in the ruby ecosystem, don't get me wrong. But to me it is so totally irrelevant. I am sure most of their code in use sucks too. Most of rails code is totally alien as well - horrible. I don't want any of this in any of my code bases. I also find it awkward that AGAIN (!) everything is viewed through the www. Don't get me wrong - the www is the single most important part today. I said this too. Ruby should be used and usable in the www. But isn't it sort of strange how everyone views only the www? I mean that's crazy. it is as if people don't use ruby for anything else anymore. I know that this is not the case so - these articles are heavily biased. People who are web-savvy write more of these articles. But still ... it annoys me. "Crystal – a language growing in popularity with syntax [...]" First, crystal is not ruby and ruby is not crystal. It's great that crystal exists, but it is not ruby. I myself actually suggested to have something of a meta-rubocop to translate between crystal and ruby. So we could autogenerate code in the respective languages ... :P But the projects are different, even if they re-use matz' ideas. I find it awkward to assume that ruby (???) becomes more widely used if people ... use crystal? How is that logical??? Actually. I think that ruby should also have a component like crystal that can be compiled. It may not have to be 100% identical; the syntax will be worse due to mandatory types which ALWAYS make a language worse, syntax-wise. But if the improvement is in regards to speed, then people could decide what they want to use. Prototype via default "scripting" ruby; or the more verbose compiled variants. But I am not sure if that is likely to happen. matz already has time constraints, so it would be a bit crazy to assume that yet another ruby-like variant could be run by the core team as-is. It is, however had, good that crystal can explore that area. They also need more users, so go use it! "Ruby needs an elegant solution for serverless, that brings the simplicity and joy once provided by Rails, while producing web apps that run in a distributed fashion. The solution must incorporate DevOps best practices and provide tools that enhance the developer experience – in tandem with a platform to orchestrate the underlying cloud components, completely abstracting infrastructure away from developers." WHAT THE ACTUAL FUDGE? Orchestrate the underlying cloud ... what does this buzzword bingo even mean? Why is the "cloud" important? We used to do FTP uploads in the oldschool days. That was not "cloud"? Because we had no fancy javascript interface? Sure, for average joe it is nice that the interface becomes simpler to use. But I automate all ftp-uploads and downloads through ruby already as-is. What do I need the "cloud" for? I don't even use the "cloud". I would not want to trust any important data to any random company out there - that would be really stupid to want to do. I don't even see how this is "THE THING THAT WILL RESCUE RUBY". Does the guy have a crystal ball? Does it work? Judging momentum is hard. Everyone has an opinion but even the best idea can turn out to simply not work, if only due to momentum. If 99 people use python because others already do so, out of 100, and the last one uses ruby, then ... even if ruby would improve by 300%, however you measure it, you won't see a huge massive change to such a distorted number. "Ruby is the easiest language out there, and has an amazing ecosystem of libraries (gems). Once it hits the browser, the tides will turn again." Eh - crystal ball prophets. And I don't think ruby is one of the easiest language. I think it is by far the prettiest though and a lot of fun. But easiest? Not sure. I also don't see the "logical" correlation of the "how the tide will turn". In my opinion, right now you can not do much other than constantly improve ruby, keep it in a great shape, add to it, improve it, improve the documentation, improve the ecosystem and so forth. People will use what helps them in the long run.
Come to Linux. Use versioned AppDirs (like GoboLinux; or any variant). Don't ever need anything such as rvm or something like that because you already have whatever version you will ever need.
I do that for every application already as-is - see variants such as GoboLinux. 
Just kill macosx default ruby and install a new ruby into a versioned appdir. On my linux system I have it at /Programs/Ruby/2.6.1/ right now. Versioned directories beat the FHS joke.
I pity the poor souls using macosx. It would annoy me to no ends to not be in control of my system.
Why would he want to keep the system ruby if he does not use/need it???
Because real apps are not simple as hello world, which you can always upgrade the framework in a few minutes without break anything, I guess? I think that's why LTS versions exist on the planet. Just because don't want reinvent the wheel so must spent half day to read documentation and install several gems including one seems already unmaintained for 3 years? Or spent a month to upgrade Rails and be prepared to face angry boss and customers?
Have no idea what you're talking about honestly, let everyone use whatever they like. If you think Node.JS will make your "angry boss and customers" happier than so be it.
Hey, thanks a lot for taking the time and writing such detailed answer. I will fix the typo you have found too. English is not my first language, so I always make a few mistakes! I just want to clarify that the point of the article is ruby for web development only. It seems like I failed to explain that properly, because more than half of your objections are about things I didn’t say, or didn’t mean to say, like for example that Ruby is dying as a programming language. That just tells me I need to do a better job explaining what I want to say - and that’s expected since blogging is a new thing to me. I will update the article to make it a bit more clear about that. Also, I don’t get how the fact that the post is not on Medium affects its content. I am writing about things that are relevant to my project, so I will write on the projects blog. What’s wrong with that? I will reflect upon your objections, reevaluate my opinions and come back here with some comments. 
I knew about this one already, it's quite priceless! 
exactly, I've just googled it out while searching how to do something, really well done :) 
WebSocket itself is pretty simple. But Ruby lacks asynchronous functionality so you must run another HTTP service on top of it which is thin. Because it's based on eventmachine that is the only way to achieve async tasks. Then you will be able to install websocket gem, which haven't been updated since 2016. You know what is wrong with it now you summer boy?
Your English could use some work, you know that right?
Because the system depends on it being there for system things. Just leave it alone, adjust your path, and use rvm.
&gt;Could you give an example of a non-blocking HTTP request in Ruby without threads? I don't doubt that it's possible, I've just never seen it before. \&gt; Could you give an example of a non-blocking HTTP request in Ruby without threads? I don't doubt that it's possible, I've just never seen it before. [https://github.com/postrank-labs/goliath](https://github.com/postrank-labs/goliath) No OS threads. Just async HTTP and Ruby Fibers to avoid async callback hell.
Thanks for this!
No worries, reach out to me if you find any difficulties.
I have a similar problem and the lack of documentation on how to debug ruby applications using VSCode is surprising. Any luck on your problem? It is easy to find a debugging example on a "hello world" application but how to debug an application which is called through `bundle exec rake server` by `bundle exec rake resque:workers` is completely non-evident. Any ideas on how to set up the debugger to debug this? &amp;#x200B;
This is great, thanks!
This needs a small update since static attributes are deprecated: https://thoughtbot.com/blog/deprecating-static-attributes-in-factory_bot-4-11 So rather than first_name 'John' it should be first_name { 'John' }
fraid i never spent more time on it. 
You might want to leverage the [puts vs print](https://matt.berther.io/2009/02/11/puts-vs-print-in-ruby/) command. You then don't need the newlines. There are also some sync issues it helps with in console. TBH most ruby uses puts. Also in ruby, we have something called a [HERE doc](https://ruby-doc.org/core-2.2.0/doc/syntax/literals_rdoc.html#label-Here+Documents). It's for large blocks of text like your print statement. &amp;#x200B; &lt;&lt;-HERE text text text HERE &amp;#x200B; The recent 2.3 addition of the [squiggly operator](https://infinum.co/the-capsized-eight/multiline-strings-ruby-2-3-0-the-squiggly-heredoc) makes it even more convenient too as it addresses indentation. Note you can also interpolate within a HERE doc. &amp;#x200B; &lt;&lt;\~HERE text text \#{some\_variable} HERE &amp;#x200B; One gotcha of the HERE doc is chaining methods is funky &lt;&lt;-HERE.chained\_method text text \#{some\_variable} HERE &amp;#x200B; Also, when you start to nest logic like this &amp;#x200B; if something if something\_else It's a code smell that it can/should be broken up into methods that handle the logic blocks OR flattened &amp;#x200B; if something &amp;&amp; something\_else &amp;#x200B; It's generally a good idea to not to nest logic when possible as the code becomes much more difficult to test and debugging for future you is a nightmare. You can test the boolean in the flattened code. In fact, you can even factor it out into a boolean method that can be mocked in testing really easily. &amp;#x200B; if has\_something? ... \# this logic's conditions can now be tested via a test mock def has\_something? something &amp;&amp; something\_else end &amp;#x200B; When you graduate from having to do it in an online IDE. You might want to leverage SQLite, JSON, or XML for simple data storage. It'll give you exposure to persisting data for portability. Keep coding and have fun! :) &amp;#x200B;
It looks like you're executing something inside a snap which probably doesn't have write access. This is more of a snap issue than a ruby issue. i'd suggest using rvm or something similar as you won't be dealing with the issue of learning both ruby and ruby executing within a snap. 
I actually had a version of this using JSON on that IDE, but the parsing and what not got a little confusing, so i took a step back and wrote it with just plain text. I actually would’ve preferred SQL, but yeah limited! Ill definitely take a look at this tomorrow at work (6 day work week baby!) , and then follow up. Appreciate the insight! 
So? English is not my mother language even not my first foreign language. I know my English is bad. Does it matter to whether js is shitty or how many gems have to be installed to get ws work?
I don't really know how to answer that to be honest with you. "Microservices" as an architecture seems to be just as much a mode of thinking as it is an actual pattern, and I guess the cynic in me says it's just as easy to write shit code whether you do it in a monolith or as a SOA.
This may be a file that does not allow modifications, read only - perhaps fuse-fs or unionfs/aufs? I know too little about snap. You can probably try to go there and see if you can touch (create) any directory/file there at that path. Perhaps there exists a way in snap to mount as non read-only. That seems to be a common operation so I almost assume that there may be a trivial way how to solve this in snap. But I am not sure there are many ruby users who use snap.
Not sure what you can/can't do in the online IDE but yeah you'd just need a writer method that writes your state variable out to JSON i.e. to_json, and reads it back in as a hash JSON.parse using the json library. On the ruby side you'd want it to be a hash. Probably doesn't give you much in an online IDE tbh. feel free to pm me if you ever need any help. glhf!
1. I don't like that syntax because I think it makes things less readable, and I don't think it's (only) because it's "new" syntax 2. It would be nice to have _something_ that makes it more pleasant to the same thing 3. I don't have a suggestion for what that is 
seems okay, but we've already got _so_ much syntax. 
Wow it’s been a while since I’ve used this. All I could grumble about was that they stole the name from FactoryGirl. And then I found out this is the new name for FG! ❤️
wut?
all the food ate since first grade is alive in your body
Rawr!
Thanks! I guess I'll go ahead with a normal installation without snap.
Thanks! I'll check out these options too. 
I’ve been trying to get this to work for me. Ours is a heavy rails app with a lot of components where the content is complex HTML. ` &lt;div class=‘something’&gt; &lt;div class=something_a&gt; Complex HTML generated by rails &lt;/div&gt; &lt;div class=something_b&gt; Complex HTML generated by rails &lt;/div&gt; &lt;/div&gt;` I’m not sure how the react component for it would look like. I’m starting React and I’m not sure how to proceed from here. Do you have any ideas?
Exciting times ahead hopefully. I’ve avoided Ruby Motion a few time since it seemed dead. I’m not sure on the new logo though it’s “cool” but the old logo looks more professional in my opinion. Looking forward to what’s next.
Undoubtedly yes. If you're motivated to find it, you should pull up other metrics and see what correlates. For example, project LOC, # of contributors, and project age could all strongly contribute.
I like the new logo. Is there a tutorial that explains how to do a simple iOS app using RM?
I really like \`foo.method(:"bar\_#{baz}")\` better even if it is longer. Sure, other languages have a special operator for this syntax but it is not nice (in the same sense as \`callable.(args, ...)\` is not nice) and I wouldn't introduce an operator for this just for convenience' sake.
Any rumor about it going to support Windows too, at some point?
please post a 60 fps vid.
Bundler is the best package manager I've used. It never stands in your way, like npm/yarn sometimes does.
I don't know how the other projects are managed, but if Memory serves bundler does have financial backing. On the one hand [Ruby Together](https://rubytogether.org) sponsors (at least?) some of bundler's development. Additionally, I for example think Samuel Giddins gets (got?) corporate sponsorship to work on Bundler and CocoaPods. It's definitely not purely community maintained. 
Interesting, thanks. What's really odd is that the worst performer is Pipenv, which should have access to [Python Software Foundation funding](https://s3.dualstack.us-east-2.amazonaws.com/pythondotorg-assets/media/files/financials_2017_website.pdf). (It's now owned by the Python Packaging Authority.)
Can I rephrase your question as "I calculated two random metrics for some projects and now running through all language subreddits with a shadow promotion of my service, can you please say WOW IT IS COOL"? Saving some time for others: "effectiveness" here is merged as normalized closed/open PRs and closed/open features ratio—which, I believe, __could__ correlate with some "project management effectiveness", but also with a metric shitload of other things. Also, normalization to 0-10 scale of, say, GitHub issues (which could be as well a question, a future plan tracking post and so on) of Bundler's 33 closed/21 new, Cargo's 51/72, yarn's 75/160 does help even more in "comparing effectiveness".
I do like and think the future of Web Development will involve FaaS, the problem is most people don't like FaaS lock in, and there still isn't a good enough FaaS out there that felt like Rails. It should be utterly dead simple. 
&gt;shadow promotion of my service Dude, chill. It's [an open source SPA](https://github.com/dogweather/repo-health-check) hosted as a static GitHub page. No ads, no nothing. Not making any money from this. My biggest crime was [coding it in Coffeescript](https://github.com/dogweather/repo-health-check/tree/master/src).
What are you measuring in this post?
This. Compared to Python or other languages where there is only one way or a few ways of writing this, Ruby have many, and way too many ways. 
I am chill af, honestly. I am not accusing you of an attempt of "making money" on this question (and, generally, I am not "accusing" you of anything). The only thing I am trying to say those numbers mean not what I implying they are meaning (if they mean anything at all), so the whole point of initial question is misleading. Probably, it is unrelated to the fact that you are the author of the tool (I was just slightly surprised for an attempt to post it to both /r/ruby and /r/python, in both cases rephrasing it to appeal to corresponding community, but let's pretend it was a honest attempt for a discussion)
Here is my general issue with what has happened with RubyMotion. Since the Hipbyte disolved, the following items have been major concerns: * The bits that were open source, no longer are. It was brought up that would may be open sourced again (the parts that were), but nothing has happened. * Still no support for dynamic frameworks in iOS, meaning no support for Swift based libraries. * Flow, cross platform UI is dead? This was a massive rejoice and provided hope for RubyMotion. * Writing Android apps has been a brittle process. Community Android library BlueMotion (i.e ProMotion for iOS) is dead. &amp;#x200B; Bottom line, RubyMotion has been in maintenance mode. It existed in a time where writing an iOS only app in Objective-C versus RubyMotion was a no brainer. But now we have better options like Swift, C# (Xamarin), JavaScript (React Native, NativeScript, Titanium/Alloy), and now Flutter. All of those technologies are open sourced, and developed by many people. &amp;#x200B; I think the biggest reason its been in maintenance mode is that this crap is hard and one person is doing everything. To be honest, beside runtime bugs (mostly Android), and support for iOS dynamic libraries (swift). There isn't much else needed. The majority of the issues I have with RubyMotion is that the majority of its community has left. Unless work continues on Flow, or getting ProMotion's features (iOS only) fully working on BlueMotion (for Android), then much of RubyMotion is still iOS/Mac bound. &amp;#x200B; Here is my advice to DragonRuby... Get the hell out of maintenance mode and provide a real road map. Deeply consider dropping Android support unless someone puts efforts into making some of the awesome community iOS libraries available on Android such as ProMotion. The community is too small itself to push Android into the position it needs to be. Hipbyte was doing this with Flow, Amir continued this to some extent, but this is all too much for one person. The last bit is social presence, posting on forum posts, and Github issues is not noticeable. Last year I remember there were online meetups to just talk about RubyMotion by some community member. There have been videos on YouTube that should be highlighted on the website. Embrace the work the community has done, and simply provide a way to highlight their efforts. &amp;#x200B;
💩
Ruby, slowly marching back towards Perl: * `[1,2,3].map(&amp;2.:*)` * `a&amp;.b&amp;.c` * `[3, 30, 300].map(&amp;SQUARE &gt;&gt; HALF)` * uri.yield_self(&amp;Net::HTTP.method(:get)).yield_self(&amp;JSON.method(:parse)) 
Where: SQUARE = -&gt;(x) { x ** 2 } HALF = -&gt;(x) { x / 2 } 
 `[1,2,3].map(&amp;2.:*)` &amp;#x200B; Hate it. There's zero reason to write such terse code. 
agree on microservices. disagree on wasm. we need less things running in V8 not more. 
Developing Node applications is not a great experience. 
&gt; It is simple to learn and easy to read so it allows teams to work fast Well, the tread seems to be to add features that make it _less_ easy to read. 
Agreed.
Why not just use a case statement? num1 = gets.to_f op = gets.chomp num2 = gets.to_f puts "Multiplication=mul\n Addition=add\n Subtract=sub\n Division=div" puts "This is your answer: " + case op when "add" num1 + num2 when "sub" num1 - num2 when "mul" num1 * num2 when "div" num1 / num2 end
Surprised there was no mention of the built-in [`YAML.safe_load`](https://ruby-doc.org/stdlib-2.6.1/libdoc/psych/rdoc/Psych.html#method-c-safe_load), as it will prevent this sort of vulnerability (with the example YAML in the article, it raises `Psych::DisallowedClass`).
So it looks like the numbers are measuring are limited to issue and PRs, ratio of opened to closed in a recent month? I think those are fine and interesting numbers, but you should put them up front, what we're talking about. They may or may not be the sum total measure of "effectiveness". I do think bundler is pretty good. But some of the contextual things that could effect those opened/closed ratio numbers include: that bundler is _one_ of the _oldest_ pieces of software on the list. (not _the_ oldest, but one of them); that the ruby community is probably smaller than some of those other communities (fewer people in the pool of potential issue filers). I think it's also true that bundler was originally written by some geniuses who designed it really well. 
pipenv is probably _the_ oldest piece of software on the list, _maybe_ the only one _older_ than bundler? Many of the others are heavily influenced by bundler, trying to do what bundler is doing (which is more/different than what pipenv at least originally intended to do). bundler might be the second-oldest on the list after pipenv?
Can I give you a demo of the stuff I am going to release soon (FaaStRuby 0.5)? I am trying to achieve that "feel", and I was wondering if you could provide some feedback before I release it!
Some ratio out of reactions to issues and pull requests. A possibly meaningful value, but not one I would describe as "efficiency".
http://www.rubymotion.com/developers/guides/manuals/cocoa/getting-started/
We'd like to expand to support more platforms but we have some other things to take care of first. One major issue is that you can't really support iOS development outside of Mac. That means OSX is still the most versatile platform to build on for mobile applications.
&gt; Here is my advice to DragonRuby... Get the hell out of maintenance mode and provide a real road map. I agree. Right now we're working on building out that roadmap. We're looking to update our Ruby support, strengthen the Android side, and either update or replace Flow. I don't want to say more than that or give timelines at the moment because I don't want to make promises right now that I can't keep. Thanks for the feedback!
There are _wayyyyy_ too many words that I would have had to write to respond to this comment. So I've recorded a video response: https://www.twitch.tv/videos/389247538 If you don't want to sit through a 55-minute video, I completely understand. Aaron (one of my partners), will distill everything down and put it into a news entry for easier consumption. I appreciate you taking the time to voice your thoughts.
I found these articles very informative in learning how Enumerable works: &amp;#x200B; [https://mauricio.github.io/2015/01/12/implementing-enumerable-in-ruby.html](https://mauricio.github.io/2015/01/12/implementing-enumerable-in-ruby.html) &amp;#x200B; [https://medium.com/@amliving/recreating-rubys-enumerable-7a8b898b8482](https://medium.com/@amliving/recreating-rubys-enumerable-7a8b898b8482) &amp;#x200B;
I’ll take a look and see. Thanks for the links.
I'm not very technical because I don't believe it would help understanding, more like the motivation why and bit about the how, but here's my attempt on an explanation. given that they are happy with javascript, let's start there: this is valid ruby and it works and it's as close as you can get to a "javascript" or C or pascal loops in ruby. ``` array = [1, 2, 3] i = 0 while i &lt; array.length puts array[i] i = i + 1 end # output: # &gt;&gt; 1 # &gt;&gt; 2 # &gt;&gt; 3 ``` Now if we want to save all items into a file instead of outputting, we would repeat most of the code from above: ``` file_io = File.open(...) i = 0 while i &lt; array.length file_io.puts array[i] i = i + 1 end ``` We would like to factor out most of that code into a common method we can call for all iterations like that. Only leaving what's unique about that code: namely `puts`, or `file_io.puts` The rest is exactly the same for all iterations why repeat it all the time. Before we get there first we introduce blocks. Block is a bit of code , like doing "puts" above that can express a chunk of ruby source that we can pass to methods. First look at a simple non iteration related example: - 1. open file - 2. do something with opened file - 3. close file Now let's say you want to give a method for these 3 steps, but step #2 is not fixed. doing something with the opened file could be anything. Blocks is a way to give the caller of the method the control on step 2. here's how: ``` def with_opened_file(&amp;block) io = File.open('filename') # step 1 block.call(io) # step 2 io.close # step 3 end ``` then we can call this method but also need to tell how step #2 is executed ``` with_opened_file { |file_io| file_io &lt;&lt; 'hello' } # write 'hello' into the file ``` So that's what block is. A bit of ruby, almost like a function, that the caller gives to the method and the method decides when and how many times it executes it. The above is enough to do the refactoring of the loop we started with: ``` class Array def each i = 0 while i &lt; length yield(array[i]) # instead of putsing we give the caller the control # on what should happen i = i + 1 end end end ``` now the loops we started with don't repeat any code just the call ``` array.each { |e| puts e } array.each { |e| file_io.puts e } ``` ```
The description of the internal dynamics between u/amirrajan and u/AaronLasseigne and Ryan in the video response to the leading comment here itself is extremely helpful, speaking to the "dead" claim but more so into the *tangible* evidence of future claims and promised growth. Really exciting to see such "hands on" involvement from the r/DragonRuby leadership. The "oh by the way" comments triggered alongside responding to the great post by u/sutabi are way better than a tl;dr.
It's helpful to realize that Ruby enumerators are effectively just objects with a #next method which continually yield values. Enumerable objects have methods like #each which produce an Enumerator, which then can be called continually. You can enumerate infinite collections this way, because you don't have to know the whole collection to enumerate it, you just have to be able to produce the next value (or to raise StopIteration).
This actually helps a lot. Thank you
I think it's worth pointing out here that &gt; Enumerable objects have methods like #each which produce an Enumerator, is half the picture. They can produce an Enumerator. The normal case though is when they don't that is if a block was given to them, then they just call the block. I think one has to build a mental model of block passing and normal Enumerable mixin methods first, the Enumerator objects are the step that builds on them.
Wait, is there a connection possible between Enumerable and the linked list questions we sometimes see in interviews?
Certainly - in the cases that you pass a block, though, you can consider the operation to be the building of the Enumerator, then continually calling it with the passed block as the block given to the Enumerator. Understanding the construction and use of the underlying Enumerator helped me understand the model for iteration in general.
That's a good point, I wonder if Enumerable is implemented as a linked list at the C level
This seems to be much closer to what I’m looking for. Could I trouble you to provide an example of how the process would work for iterating over some array with the values 1-5? The notion of blocks, yields, and how blocks apparently can be passed to any method is still unclear to me. 
I want to thank you for so much insightful information. I also really appropriate the passionate, no BS response. Specially to see that this is open source still, just not under anything HipByte related. Coming from PHP landing and having worked on compiled c-extensions I know the pains of jumping into a large c code because there is just little to no documentation, no examples to reference, and the very few people that work on the run-time have the time to help you. &amp;#x200B; One item I want to point out in your video, is that later on, Flow was normalized as some type of cross platform UI library, but its really a foundation of basic things like HTTP, storage, etc. You know that, but I don't want others to think that Flow was designed to do. From want I watched it looks like that is very much going to happen, it just might not be done with Flow. &amp;#x200B; &amp;#x200B;
You could consider it that. I don't see why you would though. It's not true. I would say that Enumerator are a nice extension on ruby iteration, but they are not necessary and not what makes them work.
I’m open to multiple opinions, how would you explain it?
my explanation is the long one :) don't know how to permalink here but the one it starts with "I'm not very tech..." and it's at top level
Ahh okay. I’ll take a second look at that. Thanks.
Not directly, but there is similarity in abstract. A linked list returns a value and the pointer to the next entry in the list. An Enumerator wraps the list traversal so the caller doesn't have to know about any underlying data structure - it just keeps returning values. They're related in that they enable you to access data structures of arbitrary size without having to know or care about the full extent of the data, and they're traversed stepwise. The linked list is particularly notable in that it doesn't require reallocation of the whole list in order to change capacity; that doesn't really apply to Enumerators.
I'm at the gym, but I'll write up an example when I'm done.
I really appreciate it. Thank you.
I think you're thinking of [pip](https://pypi.org/project/pip/) which actually has good stats. Pipenv, on the other hand, is a newcomer, with some controversy. Python is still trying to solve the package management story.
Sure. Blocks and yield are probably going to be the most foreign concept here, but really, just think of a block as an anonymous optional callback function. You can pass a block to any method; it's up to the method whether or not it will use it. A method can check if it was passed a block with the `block_given?` method. `yield` just invokes the block with any parameters given. def foo yield("foo") if block_given? end # Ruby has two ways to pass blocks, either `{|arglist| ... }` or `do |arglist| ... end`. Conventionally, curly braces # are used for one-liners, while do...end is for multi-liners. They are functionally identical. foo() {|arg| puts arg } =&gt; "foo" foo() # =&gt; nil You can also explicitly invoke an explicitly-declared block (rather than calling yield): def foo(&amp;block) # &amp;block is used to assign a passed block to a Proc object; it is always the last argument in the method signature. block.call("foo") end foo() {|arg| puts arg } =&gt; "foo" foo() =&gt; # NoMethodError: undefined method `call' for nil:NilClass # (because we're trying to invoke #call on a nil block without checking block_given?) Ruby has traditional looping constructs like `for` and `while`, which we can us if we want, Java-style: arr = ["a", "b", "c"] for i in 0...arr.length puts arr[i] end # prints "a", "b", "c" But, everything in Ruby is an object! We like using OO. That means that if an object is iterable, we can make it iterable by implementing an `#each` method, which returns the next entry in the iterator each time it's called: class MyArray def initialize(*values) # We'll use an Array for data storage here, but we won't use any of its functionality # other than length and subscribe, like you would in Java or Javascript @values = values end def each for i in 0...@values.length yield @values[i] end return self end end MyArray.new("a", "b", "c").each do |value| puts value end # prints "a", "b", "c" Once we implement #each, we can mix in the [Enumerable](https://ruby-doc.org/core-2.6.1/Enumerable.html) module, which makes all kinds of things possible: class MyEnumerableArray &lt; MyArray include Enumerable end MyEnumerableArray.new("a", "b", "c").select {|value| value != "a" } # =&gt; ["b", "c"] All we have to do is make sure the object implements #each, which keeps yielding values until it runs out, and we get all the Enumerable functionality for free! There's one more piece to the puzzle. If we try to call #each _without_ a block, we get an error: MyEnumerableArray.new("a", "b", "c").each # =&gt; LocalJumpError: no block given (yield) This just means "you tried to yield to a block, but you didn't give me a block to yield to". This is where Enumerator comes in. Enumerator is an object which implements #each and gives you all the Enumerable functionality. Conventionally, in Ruby, if you call an enumerable methods without a block, you will get an Enumerator back, which you can then pass around (or do other things with, like chaining into other enumators). Remember how we said that we can test if a block was passed to a method with `block_given?`? We'll use that here: class MyEnumerableArray &lt; MyArray def each if !block_given? return Enumerator.new do |yielder| for i in 0...@values.length yielder &lt;&lt; @values[i] end end end for i in 0...@values.length yield @values[i] end end end Now we can get up to all kinds of shenanigans: &gt; chain = MyEnumerableArray.new("a", "b", "c").each.with_index.reverse_each =&gt; #&lt;Enumerator: #&lt;Enumerator: #&lt;Enumerator: #&lt;Enumerator::Generator:0x000055848d3ad1a0&gt;:each&gt;:with_index&gt;:reverse_each&gt; &gt; chain.to_a =&gt; [["c", 2], ["b", 1], ["a", 0]] Now, this is useful because now we can do things with unbounded data producers: class RandomGenerator include Enumerable def each while true do yield rand end end end RandomGenerator.new.take(3) # =&gt; [0.7747096191165307, 0.24991758862499325, 0.34391715038937487] RandomGenerator.new.take(5).group_by {|val| val &gt;= 0.5 } # =&gt; { # false=&gt;[0.08196263174203056, 0.3374767435369247], # true=&gt;[0.7408703567871117, 0.6450156951073609, 0.5983644799992138] # } You can see how this might apply to things like file handles, remote APIs, or unbounded data streams! `#each` just keeps producing the next record in the sequence, and all the functionality we use for iteration and dealing with lists of data Just Works. Now, under the hood, Array#each is implemented in C. But if you [look at its implementation](https://github.com/ruby/ruby/blob/trunk/array.c#L2080-L2090) you'll see that it's pretty similar to what we did above! VALUE rb_ary_each(VALUE ary) { long i; ary_verify(ary); RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length); for (i=0; i&lt;RARRAY_LEN(ary); i++) { rb_yield(RARRAY_AREF(ary, i)); } return ary; } And `RETURN_SIZED_ENUMERATOR` is just a macro that, if no block is given, creates an enumerator and returns it: #define RETURN_SIZED_ENUMERATOR(obj, argc, argv, size_fn) do { \ if (!rb_block_given_p()) \ return SIZED_ENUMERATOR(obj, argc, argv, size_fn); \ } while (0) That's just what we did in MyEnumerableArray#each! By building on this pattern, where enumerables implement #each, which either yields values sequentially or returns an Enumerator that does the sample, we can use _any_ enumerable Ruby object with the same enumeration infrastructure. All we have to do is worry about how many arguments are yielded. Hopefully this helps. Let me know if I haven't sufficiently answered the question.
Ruby iteration is based on passing a lambda (anonymous function), in the form of a Ruby block, into a method on the container which calls that lambda on each of it's items. By convention this method is called "each" but it doesn't have to be. String for example has several methods like each_char and each_line depending on what you want to iterate over. There's nothing special about Enumerable, it's just a bunch of common container algorithm methods that are mixed into the core container classes.
This has been one of the most useful explanations I’ve come across during all of mu research of this topic. I’ll pass this info along to my friend and I’ll let you know if there’s any follow up questions. Thank you.
And way to both dish it out *and* take a firm reaction. Great launch point for important content in the process of responding to your well-delivered remarks that do represent what a lot of people ( unfortunately ) thought.
The other important piece is that Fibers are used internally by Enumerable to pause execution in chain. 
This is the first time I’ve heard any mention of Fibers. Is that something that’s fairly straightforward to Google, or do you have to do some digging?
They are just green threads basically and are pretty well documented. Here is a long description on how they are used in Enumerable: https://blog.appsignal.com/2018/11/27/ruby-magic-fibers-and-enumerators-in-ruby.html
Specifically, they're cooperative threads; once you're executing in a Fiber, there's no scheduler that will yield control to other waiting Fibers. You have to explicitly yield control back to the calling Fiber.
Thanks for the clarification and links
Might take longer than reading here, but I recommend the book Ruby Under a Microscope. It goes deep
Thanks for the book idea. I’ll be sure to go take a look.
There is also my RubyMotion school, with the RubyMotion Jumpstart course and all the MotionInMotion content. https://wndx.school/p/rubymotion-jumpstart And if you sign up for RubyMotionWeekly.com newsletter, exclusive discounts go out monthly to subscribers.
It makes sense they don't know it coming from JavaScript as it only recently got similar functionality in core ES via the map function. So that might be part of the issue. I know jumping into JS and not having map for me always meant instantly adding lodash to get \_.map while the JS devs just shrugged their shoulders. Maybe if you present [JS's map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) or lodash's to them it would help as it's in a language they already know? 
Got a source for that?
https://github.com/ruby/ruby/blob/trunk/enumerator.c 
Coming from other languages with no REPL this good, I wish I could upvote you twice. The closest thing to this in C++ is GDB and the closest thing in Node.js pryjs or the console in the browser and both are terrible compared to the amazingness of pry.
Fair enough.
By far my favorite aspect of Pry is that you can treat the Ruby memory space like a file system: [1] pry(Object):1&gt; class Dog [1] pry(Object):1* def woof; puts 'woof';end [1] pry(Object):1* end =&gt; :woof [2] pry(Object):1&gt; cd Dog [3] pry(Dog):2&gt; ls Dog#methods: woof locals: _ __ _dir_ _ex_ _file_ _in_ _out_ _pry_
pry is awesome
We are beyond that momentum where only iOS dev mattered.Sure it would be really nice to have the option to do iOS/Android on any platform but I think it is not a necessity. Also do not forget that iOS/OSX became too expensive even for your average middle class in the rich western world. I understand that it is one of the most profitable platforma but I doubt we will see it grow any further. The next revolution will happen in emerging markets with low perf phones and slow connections. Heck even china is not that well covered with high perf phones and fast network. 
The only thing I wish pry had is multi-line functions/classes editing like ipython.
I haven't used ipython so I'm not 100% sure what the feature you're referencing looks like, but I think you can [sorta already do this](https://github.com/pry/pry/wiki/Editor-integration#Edit_command) in pry.
I guess it's ok syntax for code golf
Heh, especially the syntax for unary methods: ``` 42.:-@.call # =&gt; -42 ``` cool.. I guess?
Nice! I didn't know this. How is this useful? 
Have you tried using ndb?
Use it with [byebug](https://github.com/deivid-rodriguez/byebug) for the ideal debugging experience.
You can look up an object's methods, variables, etc. all at a glance. Don't know a gem's API? Just ask Pry. Another really useful pry tip: `$` or `show-source` will show you the source for a given object or method: &gt; fido = Dog.new =&gt; #&lt;Dog:0x00007fce5aa3ddf8&gt; &gt; def fido.woof * puts "woof I'm Fido!" * end =&gt; :woof &gt; show-source fido.woof From: (pry) @ line 6: Owner: #&lt;Class:#&lt;Dog:0x00007fce5aa3ddf8&gt;&gt; Visibility: public Number of lines: 3 def fido.woof puts "woof I'm Fido!" end
&gt; You can look up an object's methods, variables, etc. all at a glance. What's the advantage to this, rather than `fido.methods.sort - Object.methods`? (The latter is obviously more typing, but I have a wrapper for that in my .pryrc) &gt; Another really useful pry tip: $ or show-source will show you the source for a given object or method Oh wow, thanks, I didn't know `$` was an alias for `show-source` Show-source is probably the #1 most indispensible tool that not a lot of people seem to know about. It's essential in large projects (particularly ones you didn't write from scratch yourself) such as Rails projects where there are *tons* of gems and there's no other easy way of knowing where the heck any particular method came from.
Well. I didn't know about edit command. It seems to be better in many ways. THANKS for making my life easier. I was living blind the whole time :O :O
&gt; What's the advantage to this, rather than `fido.methods.sort - Object.methods?` I'd say you get instance variables, class variables, constants, methods, the whole shebang. Basically anything you could want to see about an object. And it's less typing to boot.
Nice. I'm going to use that!
Just checked that out and wow, I was really missing out. I like how the inherited methods are organized by ancestor, so you can see what's coming from ActiveRecord, what's coming from Paperclip, etc etc etc. Thanks again.
I have problems with special accents in pry, completely shuts down the console.
No, I haven't, I'll Google it later.
Just wanted to say: Kinda looks like an IPython for Ruby (which is nice!)
Oof, it looks like you're running Ruby on Windows. That's going to be VERY difficult for a newbie to get done, even for a small school project. Also, you're definitely correct; RubyMine will hold your hand too much for a Ruby beginner and will obfuscate everything you're trying really to do and learn. I recommend installing Linux into a VM and running Ruby on there; you will have far, far fewer headaches. I don't think the community will be able to help too much on getting through your issues on Windows, unfortunately. Once you have Ruby going on your VM, you can just type `gem install sqlite3` in the terminal to install it.
I have a macbook as well that I can use as well. I usually dont do too much on it because I prefer working on my windows desktop. If I use a mac environment will it be comparable to my experience in linux?
I suggest you checkout [Michael Hartl’s Rails tutorial](https://www.railstutorial.org/). Depending on your programming background it will take you a week or two, but it covers all you need to know(and much more) to build your project
Yes - macOS is very popular among rubyists. Even has an (old) Ruby installed out of the box.
Is this a known bug? Maybe it's worth reporting [https://github.com/pry/pry/issues/new](https://github.com/pry/pry/issues/new)
Only thing I've been bitten by is the filenames. On Mac the filenames are case insensitive but on Linux it's case sensitive. This could be a potential problem for the deployment.
TIL. Thank you!
&gt; gem install sqlite3 Just out of curiosity, why is SQLite used? 
If you must use Windows, is there any possibility of using the Linux subsystem? At the very least you'll end up with something resembling the likely target environment if you ever deploy. I know *nothing* about modern Windows (haven't touched it in a decade) but my teen sons both use the Linux subsystem for Python and Ruby development, so it must be possible. A quick search came up with this, but as I say... I know nothing: https://srienievas.blogspot.com/2017/03/setup-ruby-on-rails-on-windows-10-linux.html
Excuse me, wtf
i know this isnt the best way to do things but pry is my lifeblood as a developer, I have `pry`ed my way out of so many challenges I thought were not possible for me. my coworkers seem to pride themselves on not using a repl and it irks me to no end when they are explaining a bug to me and are putting a ton of time into figuring out (or even guessing at) things we could solve by just putting a `binding.pry` in there and poking around for 10 seconds. for any rails developers, I HIGHLY recommend [pry-rescue](https://github.com/ConradIrwin/pry-rescue) which will automatically open a pry session when an unhandled exception occurs if you prepend `rescue` to your command. 
Maybe it's just me, but I came at it as a relative beginner and the Hartl tutorial took me _months_ of to get through, and I'd spend hours a day on it before putting it down and having to come back to it after a period of rest. I found it valuable in its own way, but it (necessarily) covers a lot of ground and doesn't do a good job of helping you retain the things you've learned.
best I can do [https://blog.eq8.eu/article/ruby-enumerable-enumerator-lazy-and-domain-specific-collections.html](https://blog.eq8.eu/article/ruby-enumerable-enumerator-lazy-and-domain-specific-collections.html)
funny thing is developer folks on Stack Overflow these days are still referring to Factory Bot problems as "Hi I'm trying to do xyz with Factory Girl" ....quite confusing for Junior Devlopers I work with. lesson learned: never change a name if is something popular ! :)
&lt;3
Hence "open source". Shopify is awesome.
Poor: * conventions * reliability * scalability * maintainability * security
It's important to think about the kind of application you're building! If it's a a large backend application with a lot of forms and very little fancy animations, why introduce vuejs?
From your post I think you have a missing library called ldl. I suggest linux too. You will run into many problems on windows. And for the project I think you need to have a solid grasp of Ruby to be able to do what you want in rails. Rails is huge and takes time to learn .
It's definitely a bit strange, but this behaviour is not new, it goes back to at least 1.8.6-p420
That seems odd, but maybe not in the way you expect. hsh.shift # =&gt; [1, 2, 3] # what ? This is the correct result. Docs: &gt; Removes a key-value pair from hsh and returns it as the two-item array [ key, value ], **or the hash's default value** if the hash is empty. Emphasis mine. Note that it doesn't promise to return the default value _along with a key_, only the default value itself. But this is certainly unexpected: hsh.shift # =&gt; [nil, [1, 2, 3]] It seems like after calling `shift` on an empty hash with default value, it's in some sense "adding" `{ nil =&gt; [1, 2, 3] }` as a new key-value pair.
&gt; It seems like after calling shift on an empty hash with default value, it's in some sense "adding" { nil =&gt; [1, 2, 3] } as a new key-value pair. And that is because the default value is computed each time it's required (which is necessary when you want to avoid sharing a single array as default value), and when it's computed it also sets the value on the key for which it was required (in this case `nil`, because shift doesn't have a key that it can pass to the block)
Hey, thanks for the response, when I called shift, I haven't checked the hash object when I called Hash#shift on empty hash and now I got the answer :) Tysm :)
I use WSL for Ruby dev. It's ok, I've found that disabling anti-virus protection and using webrick instead of puma where possible really helps speed things up. 
The document say it will return default value in case of that the hash is empty. The problem is you set \`hash\[key\]\` inside your default block. &amp;#x200B; So your hash alternate from hash being empty and not empty. If you log it, you will see: &amp;#x200B; hsh # =&gt; {} hsh.shift # =&gt; [1, 2, 3] hsh # =&gt; { nil =&gt; [1, 2, 3] } hsh.shift # =&gt; [nil, [1, 2, 3]] hsh # =&gt; {} hsh.shift # =&gt; [1, 2, 3] hsh # =&gt; { nil =&gt; [1, 2, 3] } ... The problem is in your default block where you do `hash[key] = [1,2,3]`. You should just do `hsh =` [`Hash.new`](https://Hash.new) `{ |hash, key| [1,2,3] }`. If the default block is really expensive. Check that the key isn't null before you save the value to the hash.
Yes, the source of confusion was mainly because I didn't check the hash object if it had any elements after I called the Hash#shift on the empty hash and If I had checked it, It would've made correct sense to me. I didn't know that If the block is called, nil would be set as the default key along with the default value as well, this was totally new behavior that I never faced earlier. Thanks so much for your response :)
hey, what you've said is exactly right, I haven't inspected my hash after calling Hash#shift before calling it second time or else, I would've understood the reason for this behavior. However, I didn't know that, when default block is called by Hash#shift, nil would be set as the default key along with the default value as well, this was totally new behavior that I never seen earlier. Thanks so much for your response :) &amp;#x200B;
So it means that if you don't need to modify key it's better to initialize hash as `hsh = Hash.new {|hash, key| [1, 2, 3]}` 
It’s set only because your code set it :D Once you change the code to not have the assignment, you can see that you hash table remains empty after you call `hash[:foo]`. 
It wouldn't make any sense to keep the key as nil and then have a default value.. what I would think is, I have to make the block throw an exception if key is nil. Also, I think default block is always invoked when someone tries to access a key which doesn't have any entry in the hash, but in this case this block is invoked by Hash#shift and this invokes the block without passing any key at all and this is a bit strange.. Finally, what we have to do is, if we are giving a default block, we have to check if key is not nil before adding it as an entry on receiver hash
Yes, exactly, I need to be more strict with the default block from now onwards.. because, I used to think default block will be invoked only when a key is accessed that is not in the hash and then default block is invoked by yielding key as second block argument to default block and here, Hash#shift invoked default block without any key at all and this is something new to me.
It is because the behavior of `shift` that it returns default value on empty hash. It can’t return the default value without invoking default value block. It looks more like Ruby has weird API semantic in this case. 
Well.. the problem is that sometimes you need to have `nil` key in a hash
&gt; Is it useful? YES! [1,2,3].map { |n| 2 * n } # =&gt; [2, 4, 6] [1,2,3].map(&amp;2.:*) # =&gt; [2, 4, 6] ["NG"].any? { |word| "COPYING".include?(word) } # =&gt; true ["NG"].any?(&amp;"COPYING".:include?) # =&gt; true require "prime" (1..10).select { |n| Prime.prime?(n) } # =&gt; [2, 3, 5, 7] (1..10).select(&amp;Prime.:prime?) # =&gt; [2, 3, 5, 7] 🤮 Sorry, but all of those examples look hideous compared to the original. Ruby is all about making the code elegant to read and write; not bastardising the syntax for the sole purpose of shaving off a few characters.
I would actually like to have this feature, *if we can find nice syntax for it*. But I don't know what that syntax should be, because I've never yet seen it.
It's a known issue that sqlite3 v1.4 ["broke"](https://github.com/sparklemotion/sqlite3-ruby/issues/247) Rails which is not `sqlite3-ruby`'s fault. Lock sqlite3 version in your Gemfile `gem sqlite3, '~&gt; 1.3.0'`
Rack::Reducer maps URL params to data filters in any Rack app. Version 1.0 supports two very different usage styles, which I regret. I'd be grateful for feedback on this to unify the two APIs into one that (I hope) will provide the best parts of both.
Thank you for your time in replying to me so quickly yesterday. I discussed with my project group what you had said and what else I was able to find on the internet and we think it would be best to not use Ruby for the time being. I will likely tinker with it on a Linux VM as you suggested when I've got some free time. 
- If you are a begginer i recommend using an editor as VS Code or Atom, with will be simpler. - Did you install Sqlite on you PC? [Here is the installation instructions] (https://www.tutorialspoint.com/sqlite/sqlite_installation.htm)
Im probably going to use a different language now and pick up learning Ruby a couple months from now when I've graduated and have more free time.
My guess would be that, since it's a small school project, there's no need (or desire from the instructor) for running full-on databases; so text-based data will do
[mp4 link](https://external-preview.redd.it/mp4/ldVKihsGP5ek_lAZ44gbj27QPtfhjqB3QgLm8aLLLls-source.mp4?s=edc1554ad519f09b21ffc2902aa64f5274a84ef9) --- This mp4 version is 93.41% smaller than the gif (240.93 KB vs 3.57 MB). --- *Beep, I'm a bot.* [FAQ](https://np.reddit.com/r/anti_gif_bot/wiki/index) | [author](https://np.reddit.com/message/compose?to=MrWasdennnoch) | [source](https://github.com/wasdennnoch/reddit-anti-gif-bot) | v1.1.2
I knew I was going to need to manipulate a SQL database of some kind but didnt even know which one to select so I had initially done different ones without really knowing the difference.
hey that's really cool! Great to see ruby creeping into DIY hw stuff. all the adafruit / maker crowd revolve around python; not bad, but prefer ruby! &amp;#x200B; &amp;#x200B;
From [https://github.com/nsarno/knock](https://github.com/nsarno/knock): #Modify the token payload By default the token payload contains the entity's id inside the subject (`sub`) claim. If you want to modify this behaviour, implement within your entity model an instance method `to_token_payload` that returns a hash representing the payload. E.g. class User &lt; ActiveRecord::Base def to_token_payload # Returns the payload as a hash end end
From [https://github.com/nsarno/knock](https://github.com/nsarno/knock): #Modify the token payload By default the token payload contains the entity's id inside the subject (`sub`) claim. If you want to modify this behaviour, implement within your entity model an instance method `to_token_payload` that returns a hash representing the payload. E.g. class User &lt; ActiveRecord::Base def to_token_payload # Returns the payload as a hash end end
I'm not used to see ruby associated to raspberry and it's cool!
This is an excellent series of posts. I hope you continue.
I think the existing syntax is fine: `[1,2,3].map(&amp;2.method(:*))` It's much more obvious what you're dealing with - a method on the two object.
Just make sure you have an `end` at the end of every method and an `end` at the end of every class. ``` class Vehicle attr_accessor :odometer attr_accessor :gas_used def accelerate puts "Floor it!" end def sound_horn puts "Beep Beep!" end def steer puts "Turn front 2 wheels." end def mileage return @odometer/@gas_used end end class Car &lt; Vehicle end class Truck &lt; Vehicle end class Motorcycle &lt; Vehicle end motorcycle = Motorcycle.new motorcycle.accelerate motorcycle.steer motorcycle.odometer = 8942 motorcycle.gas_used = 76 ```
https://www.reddit.com/wiki/commenting
That's the trick, though; as far as I can tell, I do.
Thank you
Works fine for me when I paste the above into a file or irb and run it.
&gt; class Vehicle attr_accessor :odometer attr_accessor :gas_used &gt; &gt; def accelerate puts "Floor it!" end &gt; &gt; def sound_horn puts "Beep Beep!" end &gt; &gt; def steer puts "Turn front 2 wheels." end &gt; &gt; def mileage return @odometer/@gas_used end end &gt; &gt; class Car &lt; Vehicle end &gt; &gt; class Truck &lt; Vehicle end &gt; &gt; class Motorcycle &lt; Vehicle end &gt; &gt; motorcycle = Motorcycle.new motorcycle.accelerate motorcycle.steer motorcycle.odometer = 8942 motorcycle.gas_used = 76 Wonder of wonders! Now I need to pick out the difference between our code snippets. &amp;nbsp; Thank you!
Wonder of wonders! Now I just need to pick out the difference between our code snippets. &amp;nbsp; Thank you!
```rb Class Vehicle attr_accessor :odometer, :gas_used def accelerate puts "Floor it!" end def sound_horn puts "Beep Beep!" end def steer puts "Turn front 2 wheels." end def mileage return @odometer/@gas_used end end class Car &lt; Vehicle end class Truck &lt; Vehicle end class Motorcycle &lt; Vehicle end motorcycle = Motorcycle.new motorcycle.accelerate motorcycle.steer motorcycle.odometer = 8942 motorcycle.gas_used = 76 ``` you capitalized class for your `Vehicle` class
I had noticed that but was unsure if it was the issue. Thank you!
Those are the kinds of errors that are easy to miss. Personally, I misspell initialize all the time.
I would in general use end on a new line. This may not be as "efficient" but it is so much more readable. By the way you can get a tiny bit of ... well, simpler structure here on reddit too if you indent with four spaces ' ' Example: class Motorcycle &lt; Vehicle end motorcycle = Motorcycle.new motorcycle.accelerate motorcycle.steer motorcycle.odometer = 8942 motorcycle.gas_used = 76 Ruby allows you to get away with a lot, but I recommend being conservative and not to fancy for most of the code. Reason is simple - you can always easily go fancy at a later time, but from experience, once people get fancy and loose, they also become incredibly sloppy. I see that a LOT in ruby code bases out there. Ruby is great but personally I like a certain level of discipline. (I don't recommend any particular style per se, that is always up to you; but I still recommend to be conservative in general and ideally to write really simple code that should be readable. Ruby makes it easy to fancy-dance at any moment in time, to the point where people write unmaintainable, complicated code.)
You might just have had a missing end somewhere. This is where making sure your spacing / tabs are all correct become very useful. You can usually find the missing `end` with a quick glance then. 👍 
I appreciate your evaluation. In the program the statements are separated by line, I'm just a newb at commenting here. Your philosophy is also appreciated.
to work your one liners would need to be rewritten as such to work def something; puts "the thing"; end of course I'm sure you know that this isn't idiomatic ruby by now. 
it's because the method definition is being done all on one line w/o semi colons so the AST parser never picks up the end 
once you get the SQLite issue sorted out, since you're building a dashboard style app you might want to check out the [administrate gem](https://github.com/thoughtbot/administrate). It might do most of the heavy lifting of the backend data display for you, and you can just tweak the dashboards via their configs. good luck! 
IME the copy/paste into the WSL is wonky too but yeah it works fine for ruby development IME
FWIW (not being a troll here) but you can stop recommending this as "the" de facto approach on Windows. The WSL, e.g. Ubuntu, on Windows makes this a pretty dated approach. You can do pretty much all the VM stuff through WSL now on WIndows 10. 
Yeah, that would do it. I just assumed it was failed formmatting on Reddit and things were on new lines. 
Ah I use ConEmu to get around that. 
Pretty sure I illustrated that I was not a super expert on Windows Ruby, and that this was one approach for a beginner, not "the" approach, so FWIW, shut the fuck up
*OwO, what's this? * It's your **9th Cakeday** solnic! ^(hug)
Looks really cool. I would like to ask a question. Can you package your game made with Ruby for Windows? Basically to be able to run your game from .exe and no need to install Ruby in order to run it. Is there some Cx\_freeze equivalent for Ruby?
really high minded of you to tell me to STFU while you completely gloss right over the ... "Hey I'm typing this without any emotion whatsoever so please don't read it in any context your brain is operating in right now, nor am I implying any trigger words yet I'm sure you'll read it as such which is why I'm specifically telling you I'm not being a troll" so thanks for telling me off on a Monday. Hope it made you feel better. 
Thank you bot, thanks to MP4 I can pause to read and go back and forth in time if I missed something.
It is a single exe with now outside dependencies 🎉
using what framework/toolkit/whatever?
It’s proprietary/I’m still building it :-) But the underpinnings are libSDL and LLVM. Planning to release the toll chain in April. 
ahh. nice. 
Once you do create it you may want to checkout [bump](https://github.com/gregorym/bump). 
Yes. A lot of people use a 'z' instead of an 's'. 😁
Thanks Jason. Looking forward to this one. 
This is pretty sweet if you use repl.it. This was possible before with bundler/inline but this saves a bit of typing. A welcome addition.
The announcement ought to explain how to upgrade rubygems, it's not something most people do much. 
Yeah, I was going to explore PyGame initially, since that's popular on these systems. But I do love Ruby, so I'm glad I was able to write my application in Ruby! 
Exactly, it's usually Python that's popular in this space. Hopefully I can do my part in expanding the available options.
Thanks so much! I got one more post in the pipeline related to this project, but I'm looking forward to posting content outside of this series after that. Stay tuned!
Microservices are indeed used too much and overrated.
Run `gem update --system`; I first learned that from each of the first three tutorials I went through for RubyGems, almost 10 years ago now. Even for the Kool Kids running everything in containers, `gem update --system &amp;&amp; gem update` is usually one of the first commands *their* tuts advise running.
Run `gem update --system`; I first learned that from each of the first three tutorials I went through for RubyGems, almost 10 years ago now. Even for the Kool Kids running everything in containers, `gem update --system &amp;&amp; gem update` is usually one of the first commands *their* tuts advise running.
Run `gem update --system`; I first learned that from each of the first three tutorials I went through for RubyGems, almost 10 years ago now. Even for the Kool Kids running everything in containers, `gem update --system &amp;&amp; gem update` is usually one of the first commands *their* tuts advise running.
Run `gem update --system`; I first learned that from each of the first three tutorials I went through for RubyGems, almost 10 years ago now. Even for the Kool Kids running everything in containers, `gem update --system &amp;&amp; gem update` is usually one of the first commands *their* tuts advise running.
When Reddit throws 503s, things can get pretty messed up. Glad they were only down 20 minutes this time.
Nah, you’ll be fine. I don’t think it’s trending downwards in a meaningful way. Moreover, knowing Rails makes other frameworks easier to understand. If I ran a Django or Node.js shop, I’d hire a good rails developer before I hired an okay Django dev. Source: I maintain packages for both frameworks.
Lol. Reading this cracks me up. People still code in lots of languages. Become a developer. Learn how to learn other languages. That’s the trick. 
I understand that aspect of it. Ruby will not be my first or even second or third language. I have switched stacks before too. I am mainly concerned with the fact that in a few years if I change jobs, I will be looking for a senior role, and not every company realizes that a dev is a dev is a dev, regardless of language used. I think companies really do discriminate based on what languages you are experienced with, otherwise why do they list it on the job postings, etc?
Is this your first job? If you're good at what you do you can often help the organization use whatever framework or language you want to use and put on your resume for your next job. 
I agree they can just add a link to https://rubygems.org/pages/download on update release blog posts Although I already remember how to update rubygems (since I use it in Dockerfile)
I make a lot of money writing ruby for a living. It’s definitely not dead. 
Hmm rails is one of the most mature and most productive framework out there. It’s no way a sinking ship.
I might be misunderstanding you, but if you want a full-fledged ruby app that does screen sharing, as far as I know there's nothing like that. Ruby has libraries for some of the components that you'd use in video conferencing and screen sharing (in particular several SIP / RTP / RTSP implementations), but it wouldn't be very practical to try to write the entire solution in ruby as you'd end up using FFI *a lot*. I've gotta ask, why are you looking for this?
Same here and my work is actively expanding and promoting rails devs. I've also noticed alot of government contracts popping up around here wanting Rails devs as well. A big part of the "rails is dieing" is tenders jumping on the JS train, but rails is still very active and will be around for years to come.
More likely than not if this company grows its user base beyond some threshold it will begins porting computational intensive components out of rail and into independent micro services written in something more performant. This would outstanding experience! In any case, I would focus more on the caliber and attitude of the the people you will be working with. That’s the real indicator of what you’ll take away from this job.
If I understand correctly you want the same probability of a guess with max of 100 and max of 1 million? Something tells me that let's say hitting same number 2 times is much more probable with 100 numbers than 1 million numbers if we guess 10k times.
Hmmm, let me see if i remember the math on this stuff. 10,000 guesses at a 1/1,000,000 chance. There's a 999,999/1,000,000 chance of a wrong guess. So the chance of no right guesses in 10,000 would be (999,999/1,000,000)\^10,000. So the chance of a correct guess is 1 - (999,999/1,000,000)\^10,000, which is 0.0099501712 and of course 1/100 is 0.01. So, the 10,000 guesses has less of a chance than 1/100.
so true
Replied in the [issue](https://github.com/DmitryTsepelev/store_model/issues/1)
If you have options, choose your jobs based on liking the team &amp; the environment and the work. Over the course of my career I’ve lost count of how many programming languages I’ve worked in, but it’s at least thirty. Some of them are dead now, and it doesn’t matter. The skills you learn will generalise, and if someone doesn’t recognise that, you didn’t want to work for them anyway. 
The second semi-colon isn't required: `def something; puts "the thing" end` works as well, but it's still not nice.
ooooooo_q killing it!
&gt; not every company realizes that a dev is a dev is a dev, regardless of language used Then, that's not the right company :)
I’m taking a full stack development boot camp and I’m working on my capstone project and I wanted to see if that was possible so I could implement it in my project. But thank you for your response.
I've barely started using webpacker, but definitely don't have my head thoroughly wrapped around it (and webpack itself etc). Where do I find a guide to upgrading? Like, _can_ I even upgrade to webpacker 4.0 in a rails 5.2 app? If so, how? And what do I need to be worried about backwards compat, if anything?
Ah see, glad you said that. If a browser is involved you let it do all of the heavy lifting involving the screen capture and encoding with WebRTC. Take a look [here](https://github.com/muaz-khan/WebRTC-Experiment) for some examples. I still don't think remote control is possible in standard WebRTC (but maybe is in chromeapps and electron?). You could get pretty close though, or reformulate your project slightly to do a conferencing / screensharing thing instead.
Heroku Rubies are patches. Please Re-deploy to get the updates https://devcenter.heroku.com/changelog-items/1569
\&gt; I know it is trending down as far as popularity, &amp;#x200B; Where does everyone get this impression? It's been pretty much stable in the TIOBE index since like, 2012. It's still the #6 most active language on GitHub. [https://www.tiobe.com/tiobe-index/ruby/](https://www.tiobe.com/tiobe-index/ruby/) &amp;#x200B; \&gt; but I can't say I see a lot of Ruby jobs being posted. The massive irony here is that I hear hiring managers saying they "can't hire" for Ruby anymore. Which one is it!
Stick with raw webpack...
It's both. It's a symptom of companies not hiring junior devs. juniors can't find jobs, and seniors are all well employed.
Thanks, I'll look into how that is written.
I haven't done it yet, but here is what I would do: 1. Upgrade the gem. 2. Re-run the gem's install generator. This should give you some diffs of changes to its auto-generated files that you can review. 3. You may need to manually twiddle with yarn and your package.json to get webpack itself updated. The main issues you can expect to encounter would have to do with webpack loader compatibility (any loaders you are using may need to be updated if you haven't already), and any changes to the webpack configuration schema. If you haven't customized it too much, the generator should help you sort out the latter easily.
The nice thing about webpacker is it integrates with \`rails assets:precompile\`. You don't need to change anything about your asset pipeline deployment and web server config.
It's trending downward for hype/shiny/novelty, but it is still popular.
Also all the javascript_pack_tag stuff -- without that getting your Rails views to render the correct assets being served by the webpack-dev-server in development is going to be a huge pain. It's a bit annoying how webpacker obfuscates the webpack config a bit, but I don't see any other benefits to just using raw webpack instead of webpacker.
Is the actual right number important? And are the actual guessed values not important? Because then you could simulate/approximate the same code as above with correct_number = rand(1000000) guessed_correctly = rand() =&lt; 0.01 &amp;#x200B;
*OwO, what's this? * It's your **2nd Cakeday** fuckthesysten! ^(hug)
Two things to consider: Is your algorithm "intelligent", in that it wont guess the same number twice? Your pseudo code is not, but that might just have been to keep things simpler. If you consider that the algorithm shouldn't guess the same number twice, then yes, you can simply simplify the math the way you suggest: 50 guesses out of 100 means you can just say the first 50 or the last 50 choices, effectively turning it into a 1/2 chance.
What's the main benefit of using webpacker? Is it for using Node modules in your rails app?
Thanks. Yeah, looks like you need to upgrade the gem (bundler) _and_ the npm package (yarn). And need to keep them in sync (same version of webpacker gem and npm package) yourself. webpacker really needs some upgrade instructions. 
This is an awesome write up, thanks! 
Like I said, what you're trying to do isn't idiomatic ruby. You would get shredded mercilessly in a code review for doing this as it's code golf. You gain nothing at runtime by making it a one liner and are only making your code harder to read. 
I'm in the process of upgrading a project from Webpacker 3 to 4. Fortunately there is a guide for that: [https://github.com/rails/webpacker/blob/master/docs/v4-upgrade.md](https://github.com/rails/webpacker/blob/master/docs/v4-upgrade.md) &amp;#x200B; One of the things I've noticed is that build time for my project has become 40% faster. 
Definitely not a sinking ship, I am also a current Ruby dev. It has an active community with a lot of support. There are still major companies using Rails. 
[mp4 mirror](https://gfycat.com/SpicyEdibleAustraliansilkyterrier) --- This mp4 version is 97.09% smaller than the gif (146.5 KB vs 4.92 MB). The webm version is even 79.11% smaller (1.03 MB). --- *Beep, I'm a bot.* [FAQ](https://np.reddit.com/r/anti_gif_bot/wiki/index) | [author](https://np.reddit.com/message/compose?to=MrWasdennnoch) | [source](https://github.com/wasdennnoch/reddit-anti-gif-bot) | v1.1.2
Not quite what you asked, but check out http://lrug.org, there’s a pretty active mailing list for ruby jobs in London, and I think most are based there as well. 
I like the work you put into the visual design! It looks quite polished already! What informed the choice to build it in Ruby?
Good bot!
Unfortunately, it isn't intelligent, so it wouldn't be able to be simplified. If I had 100 chances to pick a number between 1 in 100, I know that I would get it right by just picking one of each number. But it would work how the code I put in the post works where it would be 100 random numbers, so in that example, even with 100 random numbers, there's a small chance the number wouldn't be guessed.
Pretty much, yea. Especially if you are running a JS view lib like react or vue. Though it’s just as good for regular JS/jquery. Some people replace entire asset pipeline (sprockets) w/ webpacker. I’ve tried that and found that it’s messy for images. I keep sprockets for css and images. 
Hey thanks! I recently tried building a React/Rails app and it was a nightmare to even get started. I think I prefer the separation of concerns: Rails in API only mode, paired with a React front end.
Ruby is just a beautiful language. Contextual to game development, Ruby makes it pleasant to explore a concept without upfront friction that statically typed languages force on you. Generally speaking, games are interesting because they have novel concepts. Abstract constructs (at least in the games I've built) are rare by definition of them being novel. So having I language that lets me easily "violate" OO is so great because that's exactly what games are: novel one off experiences over and over again. 
This kind of task is notionally common in games, but generating random numbers is relatively computationally expensive. Most of the time it is instead handled as follows. From the above the player is supposed to have "10000" chances out of 1,000,000. So you can do: rand(1000000) &lt;= 10000 ? #code for win : #code for loss Only one random number required - you tune the probability of success with the threshold instead of repeating the rand call. As you mused, this does indeed simplify so you could just as well do: rand &lt;= .001 ? #code for win : #code for loss This also generalizes for probability ranges. For example, a loot drop in a game where it has a 5% chance of being legendary, 15% chance of being rare, 80% chance of being common. You still only need one random number. drop = rand if drop &gt;= 0.95 # legendary else if drop &gt;= 0.80 # rare else # common end
Really? I am making a gem to combine @vue/cli with Rails. I decided to use \`vue:compile\` with an option to call \`assets:precompile\` rather than a before hook. Do you prefer to do it in \`assets:precompile\`?
There's two that posted they were hiring on the \[[https://news.ycombinator.com/item?id=19281834](https://news.ycombinator.com/item?id=19281834)\](monthly jobs thread) on Hacker News. \[searchable feed says Mixlr and INTERCOM\]([https://hnjobs.emilburzo.com/#london%20+%20rails](https://hnjobs.emilburzo.com/#london%20+%20rails))
You can simplify this particular problem pretty easily with an understanding of statistics. The trick is to think of it not in terms of your odds of winning any of your guesses, but rather your odds of *losing* all of your guesses. For any guess, you have a 999,999/1,000,000 chance of losing. For two guesses, your odds of losing are the single guess odds squared. For three guesses, it's cubed, and so on. So the following method can determine your odds of losing every single guess for an arbitrary number of guesses: def lose_odds( guesses, max_num = 1_000_000 ) one_guess_odds = (max_num - 1).to_f / max_num one_guess_odds ** guesses end Note that no matter how many guesses you get, your odds of winning never quite reach zero. In fact, for 1,000,000 random guesses, you still only have about a 37% chance of winning. So finally, you can put this all together and simply generate a single random number between 0 and 1 using `rand`. If it is greater than `lose_odds(n)`, then you win.
It is up to you, but I would say a different command is trivial. I just mean that it is almost a drop-in replacement for sprockets in terms of my web server configuration, and the "javascript\_pack\_tag" helper makes it totally painless to use webpack-dev-server in development.
awesome thanks!
you need to also include word boundaries in your regex, or alternatively split the string in words, filter through a map where you replace and join the words
Can you please give an example of including word boundaries in regex? That doesn't sound too tough just not sure how to go about it.
What do you guys think about SSR if you are using React or Vue with Rails? Will it be acceptable that needs Node and dependencies? How about running another web service like Express with Rails?
thanks
yup. \b is what you’re looking for
Nice work. Value Objects don't get enough credence in Ruby land, IMHO. Just an aside, I've been thinking a lot lately about setting up Value Objects in Rails using `composed_of`. I know it's been talked about before, but it doesn't seem to be a consistently applied pattern. Indeed, at one stage there was talk about removing `composed_of`, which I'm glad didn't happen. Anyone else used `composed_of` much? Any pitfalls, traps for young (or old) players? Especially in terms of Value Objects. Where do you put your models for instance? Just in `app/models/` or is it worth qualifying them as different kinds of models?
I do the same Webpacker is good for JS, esp. when you need code splitting and other webpacker features But I found it difficult to move CSS &amp; images to webpack too 
Oh wow, I just realised you're the Dark Room / Ruby Motion guy :D Nice work :D
thanks! i subscribed
And if you want a safe space to play with regex: https://rubular.com/
 cat Gemfile
Methods are not first class in Ruby, meaning they are not objects. This allows for function calls without parentheses, but disallows methods from being referred by a variable. See the `Method` class to learn how to get access to first class method like features. Anonymous functions are a major part of most programming languages and `Proc`s are just that. See also `lamda` for sorry different semantics regarding how `return` is treated.
The short answer is "because that's how it is". Having procs as a separate entity is language's conscious design decision from the very beginning (inherited from Smalltalk, for what I can tell), and it shapes language, its look/feel/understanding a lot. &amp;#x200B; Yes, grasping procs could be a bit confusing for the beginners (though, as a long-time mentor for the beginners, I can assure you it is not that hard -- it is sometimes harder for language-switchers, who are like "In JS we don't have it and it was OK, I don't get it and I don't want to get it!"). You just start from Enumerable usage examples, and move from &amp;#x200B; I believe, that the core reasoning for blocks/proc is having "functional" loops (aka \`Enumerable\`) feeling natural. This: &amp;#x200B; \[1, 2, 3\].each { |x| puts x } &amp;#x200B; ...reads (and performs) as "1, 2, 3 — each — do something". While this: &amp;#x200B; \[1, 2, 3\].each(function(x) { puts x }) &amp;#x200B; ...reads (and performs, and explains) as "define a function object, which does something and pass that object to \`each\`, which than will call that object..." (You \*\*can\* bend your head to read it the same way, especially coming from Ruby, but it is still "less atomic"). &amp;#x200B; In Python, for example, while having lambdas, they took a completely different approach to "Python-idiomatic cycles", inventing "generators" -- which are also not methods, neither lambdas (and not very extendable concept, if you ask me, they are just "fancy Pythonic cycles"). &amp;#x200B; Eventually the approach of "arbitrary block of code attached to method" led to a lot of new approaches, like block-based DSLs, things like \`&amp;:methodname\` and other approaches. Including \`\[1, 2, 3\].each(&amp;method(:puts))\` where the method is stored in the variable and passed around ;) &amp;#x200B; So, summarizing, any attempt to imagine Ruby without blocks/procs will create absolutely different language (and I will boldly imagine that it will direct the entire modern languages evolution into a different course, I believe that a lot of modern ES, for example, is subconsciously shaped by desire of repeat Ruby's expresiveness.) &amp;#x200B; PS: And from just syntactical point of view -- note also that at the Ruby's early years \`-&gt;(args) { code }\` syntax haven't been invented and widespread in any mainstream languages, so passing around on-the-fly defined functional objects was typically as elegant as \`map(function(arg) { return arg \* 2})\` comparing to \`map { |arg| arg \* 2}\`
Is it me or do you also get a feel that Ruby community overall doesn't know good OOP practices?