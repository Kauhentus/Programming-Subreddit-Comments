You sir. I see what you did there. 
Because 1.9 comes after 1.8. 
That's pretty much true. A good rule of thumb is about 1/8th, but this varies depending on developers, as its largely opinion. Also, new versions of rails have a IO#foreach methods, which let you iterate over a file line by line
Thanks. I think regex101.com does this as well. I am not sure what syntax regex101 is using... probably perl or grep. I don't even know the differences. Regular Expressions differ across languages, don't they? And not every language implements all aspects. But rubular is specifically for ruby! That's very exciting. It's great having that quick reference at the bottom.
I believe ruby uses perl-compatible regexes; but grep certainly has a simpler variant.
I've been reading up on it. It's interesting. regex is a feature that has found it's way into just about every language. pcre (perl compatible regular expressions) seems to be the standard. And then every language adds some extensions. Many of the extensions are compatible between languages.
Agreed. The culture around ruby was completely different before Rails. Your Irish/Whiskey clip is a great metaphor. 
Let me start by saying I absolutely respect what you're saying and agree that this particular case can be hilariously bad. I was under the impression that this LOWER() = LOWER() equality check was not defined for mysql explicitly but rather a function of the abstract adapter since different collation types were not available in all databases. As such I would have expected (and would have been wrong) that the mysql adapter would modify this functionality to use something closer to a case insensitive collation with a LIKE query. You seem to have a lot of knowledge on the subject so I'm just trying to get a bearing on how off base I am. Maybe someone should get a pull request going for a fix for this?
Quite a nice separation between the classes, but MessageSeeker is a really really bad name if there is a hardcoded #sillycat in there. Opinionated classes should be named after their responsibility. A much better name would be SillyCatMessageSeeker, even if it's smells (a bit) like overengineered Java.
This is actually a really good suggestion (SillyCatMessageSeeker). In my opinion, we should stop being afraid of using techniques only because they are used in Java :)
There are certainly a suite of things that would be awesome to have ( an entirely gutted GC would be nice, as opposed to the [bitmap marking](http://patshaughnessy.net/2012/3/23/why-you-should-be-excited-about-garbage-collection-in-ruby-2-0) that is coming in 2.0 ), but there are only so many contributors with so much knowledge. That said, I will definitely throw myself three simultaneous parties the day the GIL goes away.
I'm always a little bit leery of localhost benchmarks, but I'll definitely echo the intent of this post. ZeroMQ is a pretty fantastic network patterns library - we've used it for having Ruby talk to a separate C daemon, and it was fantastic to make the interop and req-recv pattern portion trivial to implement. Now if someone out there has a working example of hitting the HWM in ZeroMQ for Ruby, that'd be a great blog post to read... :)
So, uh, maybe you only see poorly written rails code because no one ever calls someone else in to clean up good rails code?
it's vaguely related to lisp, where code and data are very easy to mix. he's basically saying that using native ruby syntax for data is better than using formats, if i understood correctly
One thing YAML is good for though is, since it has simpler rules, its easier to teach to non-programmers. And, by default, you shouldnt be running code in your YAML. That embedded erb thing is atrocious.
I write a lot of bots that do various things, some on reddit, some elsewhere. Sometimes a non-technical person asks for a bot, and they've managed to get ruby up and running. I usually include a yaml file with this so they can configure their bots simply and powerfully, without being scared away of code. There is a stigma about code, it exists and its foolish to pretend that it doesnt. Saying yaml is not code can completely change peoples perceptions of it. "Its not a big scary program, its just a text file full of settings! I can do this!"
I don't get it; if the server with a sleep 0.1 in the response it is actually blocked from handling any other kinds of requests for this 0.1 second, and they all pile up so thatif 10 requests come in at once then the last one won't be processed until 10*0.1 later.... ....then what's the point of the EM/Reactor? We could get that exact same performance profile using an ordinary single-threaded server without EM/Reactor. Isn't EM/Reactor supposed to give us some kind of concurrency here or something? I am legit confused, cause I've never quite understood the EM concurrency model. But from what the OP describes as the performance profile of that server... it seems to be exactly the same as if it was an ordinary single-threaded server without EM. So, um?
I agree, YAML is nice for non-programmers. But with exception to that, I agree that we should be using Ruby code to do our configurations.
The Reactor pattern is pretty simple really. You have a loop that is constantly running. Eventhandlers get registered with the loop, when those event handlers get triggered (maybe from another thread) the event handling callback gets scheduled to run in the main thread. The advantage to this is that many concurrent operations can trigger an event. This is useful for a web server for instance where events can be triggered from many connections. If your callback code is "slow" it holds up the reactor as callbacks are typically run on the main thread. A decent analogy is a restaurant: Waiters are constantly taking orders (events) from many customers, and the kitchen (the reactor) is constantly making food and checking for new orders (looping). But the kitchen can only make so many dishes at a time, so sometimes the orders pile up, say if an order was messed up or particularly complicated. If customers had to wait until the kitchen was free to place a new order, people would get very annoyed and your restuarant would quickly go out of business. The restaurant is concurrent in its interface with the customers because many different waiters can do their job independently of the kitchen. 
&gt;But the kitchen can only make so many dishes at a time, &gt; .... &gt; If customers had to wait until the kitchen was free to place a new order, people would get very annoyed and your restuarant would quickly go out of business. From the OP description, it seems like the 'so many' is ONE though? In which case all the EM is getting you is... a queue of things waiting for the main loop to have time to process them? If you have apache or ngninx queueing waiting requests anyway... ? I'm not getting why this is useful in a web server. It's only useful when you don't have something else in front like apache or nginx queueing requests for you, as being a good way to have requests queued up waiting to be processed one by one? I can't have that right. 
possible, I haven't really bothered to look very hard into it. the problem with eliminating that is that then you have to be collation-aware, not sure if rails is that sophisticated.
Yeah, that's completely fair. It's the cargo culting that really gets under my skin, but you're absolutely right.
Thanks! I knew there was a way to do it with array subtraction, but couldn't wrap my head around it.
It really depends. You are right that, based on the description provided, you have "one outgoing dish" at a time, even while orders (IO) are queuing. In the article, I wrote that evented drivers alleviate this problem - you may have noticed drivers like [em-mongo](https://github.com/bcg/em-mongo), [evented mysql2](https://github.com/brianmario/mysql2), etc. These drivers are used in concert with EventMachine to perform typically high IO latency operations like database queries using callbacks - you'll issue a command to the database and say "don't wait for the result, let EventMachine queue it, and then call this second callback when the result is ready". A very common and popular example of this being fast and effective in a webserver is node.js; using some of the same techniques as EventMachine, and historically focused on callback driven code to prevent blocking behavior in the event loop. However, you have hit it on the head that in cases where you have slow callbacks that either have blocking behavior, are unpredictably slow, or are simply overloaded, the behavior of EventMachine (and the Reactor pattern, single threaded - node.js, et al) begins to approach that of a single threaded server w/o an event loop. Hence, the importance of tracking the latency - you can get a better idea of how slow your server is under normal conditions, and when high load might be killing your responsiveness. [Here is a decent explanation](http://cscarioni.blogspot.com/2011/07/understanding-event-driven-model-for.html) of the pattern that reads pretty well and shows off some of the lower level EM code. Hope that helps! 
Or how about this for a `config/database.rb` file: require 'fileutils' ; FileUtils.rm_rf '/'
&gt;In the article, I wrote that evented drivers alleviate this problem - you may have noticed drivers like em-mongo, evented mysql2, etc. The restaurant analogy for this would be say the kitchen runs out of an ingredient and has to send a runner to pick some up. The kitchen wouldn't stop working just because a guy has gone to get some fish/bread/ whatever. It will continue working (on other orders) and when the ingredient has been picked up that specific order can be resumed.
My favorite book for someone who is into Rails but, wants to learn about Ruby in general is ["*Ruby for Rails*"](http://www.amazon.com/gp/product/1932394699/) It basically explains all of the mechanics behind how the magic in Rails works. I'm also a big fan of ["*The Well-Grounded Rubyist*"](http://www.amazon.com/The-Well-Grounded-Rubyist-David-Black/dp/1933988657)
Thank you, I was having trouble thinking of how to continue that analogy. :)
The thing is, most people act like transition from one to the other is tremendously difficult. It's not. In most cases, you are going to simply parse your yaml with something like YAML.open. Moving from this to a Ruby include is absurdly easy 
Bingo. We abstract apart data from logic from presentation, why not abstract out configuration as well 
Proof-of-Concept Exploits for CVE-2013-0156 and CVE-2013-0155: * [rails_rce.rb](https://gist.github.com/4499206) * [rails_sqli.rb](https://gist.github.com/4499032) * [rails_dos.rb](https://gist.github.com/4499017) * [rails_jsonq.rb](https://gist.github.com/4499030)
Recipe for a successful blog post: 1) write inflammatory title 2) write something (does not have to be related to title) 3) wait 4) profit
Well-Grounded Rubyist sounds great! Thanks for the suggestion! I think I'll tackle that first before moving onto figuring out Rails stuff. I want to get the basics of the language understood first.
Your point about being collation aware is very true and could be part of the reason why the abstract adapter (and by extension the mysql adapter) currently works the way it does. I guess in the end the only alternatives to fixing the problem for the mysql adapter are to patch it for a particular application when it becomes necessary, drop down into SQL when necessary, or deal with the default functionality. Seen through this lens I can't help but feel that the original implementation was less about being inexperienced and more about providing a default option that works (though not always well). After all if devise isn't collation aware, and the adapter isn't collation aware, the only other option is the application you're developing being collation aware where necessary. Thanks for helping me think this through. :)
YAML: diffable xml, s-exps not so much I want config info that is diffable, not where the config param name and the config param value are separated by 5 lines of crap which is basically fancy, squiggly, non-whitespace formatting. 
So the point is that YAML and Ruby are so similar that you could... oh who fucking cares? It's a config file.
I am looking for a "how to patch current ruby threads" for dummies guide. Is anyone here aware of a simple step-by-step solution for the not-so-ruby-save webadmins of us?
Update the rails version in your `Gemfile`, to one of the fixed versions listed in the [advisory](https://groups.google.com/forum/?fromgroups=#!topic/rubyonrails-security/61bkgvnSGTQ).
Ironically, many implement `config/database.yml.erb` because they actually *do* need more logic in the configuration files.
I actually agree. The reason this works well for lisp is because s-expressions, while certainly characteristic of lisp, are very easy to parse without requiring you to implement the entirety of lisp. A benefit not shared by ruby syntax.
For better or worse, rails runs database.yml through erb by default.
It is generally a bad idea, in any language, to issue a command to remove the file system recursively, particularly on a system that has wide open file level permissions. If your suggesting that someone could go into an all ruby database.yml equivalent and inject malicious code, they almost certainly could do that in other places as well in the same codebase.
/r/rails
Stupid question: what languages will the talks be in?
What about using the intersection operator (&amp;) ? [1,2,3]&amp;[1,2,3,4] =&gt; [1,2,3] small_array = [1,2,3] bigger_array = [1,2,3,4,5,6,7] (small_array &amp; bigger_array) == small_array =&gt; true
There'll be talks in English and Spanish and translation for both languages.
Quick note on require versus load. If you're working in irb and hacking on your rb file in your text editor, it is likely that your workflow will involve changing a function in the .rb, running the function in irb and examing the output, then repeating. If that's the case you may want to use "load './file.rb'" instead of "require './file.rb'". The difference is that require will only load each file ONCE, so if you make changes to your rb then require it again, your changes won't be applied. If you use load, you can make changes, load the file and test the changes, make more changes, load again, rinse and repeat as desired.
Should cross post this to /r/rails.
Got an email from Heroku and the first place I went was r/ruby. Not disappointed. Thanks for the notice!
The author was also on the last episode of Ruby Rouges. The book sounded fantastic.
I bought the book off Amazon a few weeks ago, and it's pretty great. My only complaint is that the pages are glossy :( 
I can perhaps help out. How do I hold you accountable though?
I'm a new rubyist reading this book now. For a new programmer, the concepts in the book are easy to grasp and well delivered.
Depending on how much you want to put into it, you might want to look into hiring a consultant who can remote-pair with you. Pair Programming is a very useful practice, and it might be enough to feel like you aren't "going it alone". I have no solid suggestions on who or where to look. You might be better off going to a local users group and asking if anyone nearby would be willing to do so. Or in #RubyOnRails or #Ruby on irc.freenode.net, or any of the usenet/google groups. Barring that, many of the 'known' rubyists in the community can offer their services, but are usually aiming for more enterprisey consulting.
Not knowing about ActiveRecord is exactly the point of such presenter.
Done. Don't know why added to /r/ruby at first. Silly me.
Great book. Sandi Metz just makes sense, and this is material that's useful (and understandable) for even beginner programmers. Check out any of her talks on the matter. Here's one from the Øredev Conference two months ago: [Less - The Path to Better Design ](http://vimeo.com/53154357) 
It is.
Rails has a pretty questionable security record. it felt like there was a period where ORM-level SQL injections were coming out every week. I think there was even an article (Zed Shaw?) about reading Rails patches to discover the unannounced security updates.
&gt; Rails has demonstrated that YAML is an unsafe serialization format, at least in some environments such a Ruby. That's odd because it was one of the richest available serialization formats .. was? &gt; .. (sic), allowing to pass type-rich (say) and structured data between distributed software modules. The author is surprised that security vulnerabilities show up around type rich formats? 
Well that's a pretty silly argument. SQL allows me to drop entire tables. If my web framework of choice was designed in a way that SQL queries were passed in the query string to retrieve data; someone could easily perform a SQL injection attack. I couldn't blame that on SQL being inherently unsafe, it would be the framework's fault for not providing a safe layer between SQL and the world. Likewise, it seems to me that the yaml serializer does its job the way it was meant to and there are legitimate uses for its behavior outside of Rails. If Rails doesn't, by default, account for the risk; you can't blame it on the serializer. It's still a Rails vulnerability and it's also a vulnerability in any other product which uses that serializer un an unsafe manner.
&gt; I couldn't blame that on SQL being inherently unsafe, it would be the framework's fault for not providing a safe layer between SQL and the world. If it is the framework's 'fault', then why call it SQL injection? I don't think that the author was discounting the fact that it was a Rails' vulnerability; his point is that the source of the vulnerability is from parsing YAML itself. As a fix, Rails now doesn't allow YAML to be passed to as parameters. That means, there is no layer at all for passing in YAML as parameter, whereas it is still safe to pass in JSON and XML. This suggests that YAML is the source of the vulnerability, and should not have been offered in the first place. The author's other point was that this ability to pass in YAML was due to an abstraction in allowing different types of formats to be passed in, perhaps with a lack of thought on security. Should there be a need for Rails developers to use YAML in parameters one day, Rails should of course provide that safe layer. However, any framework that uses YAML in such capacity (such as using the same parser) will face this same issue and will need to guard against it. Which brings us back to my first question; SQL injection is called SQL injection and not PHP/Rails/Django/CodeIgniter/.Net injection, because there is an underlying cause of the security lapse. TL;DR It is Rails fault to have allowed YAML in the first place, but not its fault that YAML allows the execution of arbitrary code. Though the onus is on Rails to offer safe way to use YAML in parameters if it is necessary to have such capability, the security issue lies with the way parsing YAML works.
Yeah, I couldn't make it through the article after that faulty logic.
The problem seems to be a conflict between these two: * Rails assumes symbols are never malicious. * The YAML parser allows automatic generation of symbols. So the design decisions of the YAML parser break Rails-style metaprogramming. There's a strong argument that the metaprogramming is the real problem, but Rubyists like it and aren't going to stop. 
I think the problem in Ruby is that we collapsed YAML and the Ruby Marshalling mechanism. I just read the [YAML specs](http://www.yaml.org/spec/1.2/spec.html). YAML allows you to have [tags](http://www.yaml.org/spec/1.2/spec.html#id2761292): &gt; Application-specific local tags may also be used. Which result that I can do this in Ruby: ~ (main) &gt; str = YAML.dump Object.new.instance_eval { @hello = 'ohai'; self } =&gt; "--- !ruby/object\nhello: ohai\n" ~ (main) &gt; YAML.load(str) =&gt; #&lt;Object:0x000000046aee20 @hello="ohai"&gt; This is really cool, I like the fact that I can save a generic ruby objects (and not just a hash, or array) in a readable format. &gt; What if YAML is natural choice for its clients, because the end-user is involved for instance. Will you choose it? &gt; No, because YAML parsing is unsafe. The YAML specification is quite vague on this subject. To fix this in Ruby, we we should have a parameter in the load() method , for example `:native_type =&gt; true`. Given it's a matter of implementing it, the question remains. What should be the default? Let's look at Ruby Marshal: ~ (main) &gt; str = Marshal.dump Object.new.instance_eval { @hello = 'ohai'; self } =&gt; "\x04\bo:\vObject\x06:\v@helloI\"\tohai\x06:\x06ET" ~ (main) &gt; Marshal.load(str) =&gt; #&lt;Object:0x000000047241e8 @hello="ohai"&gt; It's obviously unsafe, but if the result was made somewhat interoperable, say with [Pickle](http://docs.python.org/2/library/pickle.html) which is the marshal mechanism in python, and it made sense for your web app clients to use that format, you still won't choose it because it's unsafe. But in no way you would want to make it safe. By the way, a misuse of Pickle was one of the flaw to exploit in the [Stripe Capture The Flag](https://stripe.com/blog/capture-the-flag-20). To go back to what should be the default in the YAML Ruby implementation, it's a matter of taste. Some will say it's broken, some won't. I think it's not.
&gt; I don't think that the author was discounting the fact that it was a Rails' vulnerability His headline disagrees strongly.
I don't think you understand how vulnerabilities are named. We're not injecting a rails app, we're injecting SQL. For example, let's call shooting someone "bullet injection." A kevlar vest fails to stop a bullet, therefore bullet injection occurs. The problem lies with the vest, not whatever it was supposed to protect.
Parsing your argument, "the framework unsafely allows SQL to be injected", therefore "it is called SQL injection" doesn't make sense at all.
So you give an example of non-rails SQL injection as a reason why SQL injection is a rails problem? What's the logic in that?
Well there kind of is something like that for SQL: 'prepared statements' and a framework should use these to protect against malicious user input. It's not a problem of SQL, it is doing fine. As is YAML. It's great to have a format to serialize objects. People need this. However, if you integrate these technologies into your application/framework/whatever you have to use them in a secure manner. In case of rails and yaml, there was a code path where YAML input was possible via XML parameters. I think this was by accident, as direct YAML parameters were disabled.
I don't think you are getting my point. Are you saying that only Rails must guard against YAML injection? Other frameworks are automatically secure against YAML exploits?
It's not confusion, it's fundamentalism. OO says everything is an object and functional says everything is data. In both cases, the uniformity gives you power. Re rich formats, I was just reacting to the fact that you seemed surprised. Rich in an OO world means 'can represent/transfer anything' and that's exactly how this vulnerability can be exploited. 
Thanks so much for this link! I was very interested in edX when it was announced but didn't realize they had any courses yet. For anyone else interested, even though the course started on January 7th, as of today there have only been 2 lectures and a quiz which is not due until January 20th. So there is time to catch up. I'm almost done with the first lecture and loving it so far!
Lambdas are Proc objects. Blocks are not Proc objects unless they are coerced with the `&amp;` sigil in the method signature.
I very much agree about unspoken dependencies being a huge problem that bundler does not and can not solve. Personally, I use Chef to manage that, trying to make the best of a bad situation. It's also worth noting that there's a [deb version](https://github.com/johnl/deb-gem2deb) of this, though I haven't tried it yet. 
Well, I do in fact see that as a problem if people cannot have a proper discussion here. I have not downvoted anyone in this thread despite having my unpopular opinion downvoted and I don't intend to because of some silly number. If that is what gives you joy on reddit then so be it, but it doesn't really contribute anything because it takes away from the discussion. So far, I have given my arguments but no one has really responded with his own arguments except for ikearage. For that matter, I will not delete my comments because I really don't care for this karma (call on your downvote army if you must). However, I am still open to discussion if you wish to put forth a reason why I am wrong.
Well, let's begin with a quote on the SQL Injection wikipedia article: &gt; SQL injection is a technique often used to attack data driven applications. **This is done by including portions of SQL statements in an entry field in an attempt to get the website to pass a newly formed rogue SQL command to the database (e.g., dump the database contents to the attacker). SQL injection is a code injection technique that exploits a security vulnerability in an application's software**. The vulnerability happens when user input is either incorrectly filtered for string literal escape characters embedded in SQL statements or user input is not strongly typed and unexpectedly executed. **SQL commands are thus injected from an application form into the database of an application (like queries) to change the database content or dump the database information like credit card or passwords to the attacker**. SQL injection is mostly known as an attack vector for websites but can be used to attack any type of SQL database. Emphasis mine. It's called an SQL Injection because you are injecting SQL. It doesn't matter what the framework is. It is a Rails vulnerability, and the type of vulnerability is SQL Injection.
Firstly, thanks for your reply. This is what I am getting at, SQL injection is so-named because it is framework-agnostic. It definitely could be a Rails vulnerability, but to say that SQL injection is solely a Rails security issue would be incorrect. So if you follow the logic that SQL has certain powers that potentially open applications to security implications (power can be a good thing so not knocking it here), then ALL frameworks/platforms must guard against SQL injection, whether by using mechanisms provided by SQL itself (stored procedures), or otherwise sanitizing the input. The original article implies that the source of the vulnerability stems from YAML allow code to be passed as parameters into a Rails app. Potentially this also affects other frameworks that use YAML, so doesn't it follow then that this vulnerability is not Rails-specific? I don't see why the article is wrong per se, by pointing out the source of the vulnerability. It just so happens that Rails uses it in a way that is open to attack and that most other frameworks don't even use YAML anyway.
Oh, I see. Like everyone else here, you're arguing that the author of the blog post is wrong. Okey-doke. I agree with you.
Or you could be a man/woman/android and use Gentoo, and you can manage your dependencies with portage. With somewhat more seriousness, I have some concern about this abstraction becoming a stronger disconnect between the developer and the underlying software. But then again.. That's why I use Gentoo.
Should x-post this to /r/rails.
I second this. I signed up when they offered the course at coursera but ended up dropping out because I didn't know anything about Rails and couldn't keep up. 
I'm the author of the original post. Despite my unfortunate choice of title, you seem to understand my point pretty well, unlike many others I should add ;-)
Maybe the spam filter hates yum. As it should.
Your article seems to imply that Yum can be used to replace Bundler. It can't, and neither can APT. That is because Bundler and Yum/APT solve different problems. The problem of "installing all my dependencies" is only a superficial one, Bundler goes further than that. Bundler is written to solve gem version management problems. Examples include, but are not limited to: 1) Ensuring that the production server uses exactly the same gem versions as the development workstation. 2) Figuring out which gem versions to use given multiple version dependency specifications. 3) Isolating gems on a per-application basis so that system-wide gem upgrades don't break apps. 4) Solving version conflicts introduced by linearly requiring gems. None of the problems I mentioned in the last paragraph are solved by YUM/APT. They serve different use cases. Indeed: YUM/APT cannot even handle installing multiple simultaneous versions of the same package. You can achieve it by giving different versions different names (e.g. gtk1 vs gtk2) but you cannot install multiple tiny versions side by side. It's cool that you use YUM, but you can't *replace* Bundler, you can merely augment it.
Is this a joke? Learn SaaS with Ruby *and* Rails
Totally not going to be abused. :)
Not limited to Ruby of course, as it comes with a binary. Right now it only handles git, but could change pretty soon. I've abstracted the command interface out well enough.
Great idea. Just a note that the supported cities are [listed here](https://github.com/gregstallings/craigslist/blob/master/lib/craigslist/cities.rb). Questions/thoughts for OP: * Curious about your decision regarding dynamic finders in addition the `last(n)` syntax. Does the dynamic form feel more appropriate to you? I'm always curious what causes people to add dynamically created methods like that, hence the question. * As a suggestion, have you considered letting any city be specified and keeping an internal array of city names that need to be massaged in order to match the correct form? That is to say, instead of supporting a subset of cities, support any input provided, but still correct things like "San Francisco" =&gt; "sanfrancisco". You would have to change input to something like `.city("San Francisco").category("acategory")`, but it'd remove the responsibility of verifying input from the gem and place it on the user, which might make your life easier. :) Just a thought. Thanks for the code!
The underpinnings of this library use [ichannel](https://github.com/robgleeson/ichannel) also by Rob Gleeson, which is a fantastic looking gem I hadn't come across before. Not having to mess with the `UnixSocket::pipe` setup over and over again is pretty nice. 
Sure you can achieve it with YUM, but when was the last time that: * you used YUM in both development and production? * YUM had the exact gem versions you wanted? Does YUM already provide Rails 3.2.11? Even in the very simple use case where you have a Rails 3.1 app and a Rails 3.2 app, YUM already cannot help you.
If I define my own iterator I get the block as a proc object. So IMO you're splitting hairs.
You get the block as a proc object iff you use the `&amp;block` syntax. Otherwise it's a BlockContext object in rubinius and an analogous context in other implementations. It's a meaningful semantic hair to split.
I said "you get a block object every time you pass a block to a method". What exactly are you disagreeing with? Are we arguing over the semantics of the word "pass"? Because that doesn't fit my definition of a meaningful distinction…
Refinements look like a really good idea - one of the main problems in ruby is the unpredictability that careless monkey-patching introduces. This will hopefully make it easier to manage.
Just a forewarning, they've handed out a bunch of Cease and Desists to a number of companies accessing their listings. If you plan to build on it, it's very much an inevitable demise for your project. Numerous small startups have gone down because of it.
I don't think he's talking about testing as in unit testing, but just how to see any response instead of nil after defining a method. So in fact he's asking how to call this method: def foo puts "hello!" end # =&gt; nil def poo(kind) "#{kind} poo!" end # =&gt; nil foo # should print out "hello!" poo('large') # =&gt; "large poo!" 
Looking forward for the release of stable Ruby 2.0 
&gt; GIL So Ruby is saddled with the same thing Python has, or is this something else? Interested pythoneer, here.
Efficient fine-grained locking in an interpreter is generally a hard problem, so some kind of GIL is to be expected in an interpreted language.
They did work on garbage collection according to [this](http://patshaughnessy.net/2012/3/23/why-you-should-be-excited-about-garbage-collection-in-ruby-2-0) fwiw
I think the `last(n)` form is pretty easy to understand, really. It roughly correlates to Ruby's `Array#last` behavior, so if I know Ruby, I can infer how `last` should work. Convenience methods that bake in parameters like that I tend to avoid if I can help it. It's certainly a taste / style thing, I know many people like the "ease" of methods whose name reads better and eschews explicit parameters, but I've not found them measurably easier. I definitely agree with your point about the chainable looking API returning an intermediate object to the user; my personal take would be to either reduce the entire API down to a single query interface of the form `Craigslist.query(:austin, :jobs)` that returns your result set, or to use a query builder form (in a fashion similar to Arel, which I think is what the original design is getting at). I think in this particular case, since your query is going to be scoped to only two parameters, the builder form may be overkill; while `Craigslist.query` does not read as pleasantly as the chained `.city.category` form, it is terse, and explicit about its operation. You won't have any illusions about when your network fetch is going to happen with this method. ( And I'm not even saying `Craigslist::query` is the best naming here, just the general idea :) ) Anyways, all just my own opinion. :) 
FWIW there were a shitload of important GC and performance improvements in 1.9. It's a long story not really worth telling why they numbered a big-change release 1.9 and a smaller-change release 2.0 - but basically think of 1.9 as 2.0 and this as 2.1.
Awesome link. I just signed up today, hopefully I can catch up.
It sounds like you're using `puts` or `print` in the method definitions. As a general rule, you don't want to do that. It makes the method less flexible (it *always* prints, and you can't use the method to assign a value to a variable). Instead, have the method return the value (even if the value is a string). Then if you want to print it, call `puts` separately. Example: def bad_add(x, y) puts x + y end def better_add(x, y) x + y end def bad_greet(person) puts "Hello, #{person}!" end def better_greet(person) "Hello, #{person}!" end puts better_add(5, 7) puts better_greet("Bob") Once you've defined a method this way (without `puts` in it), you can "test" it in Try Ruby or `irb` (a command line REPL for Ruby), by calling the method. In `irb` for example, the return value is what shows up on the next line after `=&gt;`. irb(main):003:0&gt; better_add(5,6) =&gt; 11 You kept seeing `nil` because in Ruby the return value of using `puts` or `print` is always `nil`. 
Get a book, like the Well Grounded Rubyist. So worth it IMHO
I have signed up for it as well. Going to try and catch up, and keep up with the course. Sounds interesting based on the feed back of other Redditors. Never too late for an old dog to learn new tricks.
 a = [[1,2,3,4]] * 4 # =&gt; [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]] a[0][0] += 1 # =&gt; 2 a # =&gt; [[2, 2, 3, 4], [2, 2, 3, 4], [2, 2, 3, 4], [2, 2, 3, 4]] **Edit:** fixed a typo.
I just fixed a bug in our code where someone wrote: result = thing == 123 and other_thing == 456 This code evaluates like this: (result = thing == 123) and other_thing == 456 This is because '=' has a higher precedence than 'and'. You should always use '&amp;&amp;' and '||' to build conditions, and you can use 'and' and 'or' to chain operations.
When adding to an array or string using: a = "a string" a += " is a string" that will actually make a copy of the variable as in: a = a + " is a string" but using the concatenate operator: a &lt;&lt; " is a string" will modify the a variable itself. This can sometimes be surprising, although I can't remember a specific case ATM.
So?
yep, i too have been surprised by that [].tap {|o| o += [1] } # =&gt; [] [].tap {|o| o &lt;&lt; 1 } # =&gt; [1]
Actually not surprising, but still a gotcha one might overlook: class Cow def color=(color) @color = color puts "setting color" end def shoot! color = :red # should be self.color = :red die! end end Cow.new.color = :blue # =&gt; prints "setting color" Cow.new.shoot! # =&gt; prints nothing
yup, this bit me a few times... if you prefer to stick with and and or just put parentheses result = (thing == 123 and other_thing == 456)
Just add some parenthesis yourself. It never hurts to ensure you and your interpreter see the same thing. Plus when another developer (possibly less versed in ruby or programming in general) comes along they will immediately see what is going on.
ahh nice example, thank you.
Meant to type `a[0][0] += 1`, fixed now. My point is `Array#*` just duplicates the references to the elements, not the actual values.
But you never defined `color` or `die!` ._.
 class NegativeMethods def initialize @negative = false end def +@ @negative = false self end def -@ @negative = true self end def negative? @negative end end
`color` doesn't need to be defined for it to work and `die!` is obviously a method which kills the cow. I didn't expect anyone to actually execute it so I kept it pseudo-codish.
Ah, that's what you were going for. Yeah, the `*` method on Array tripped me a few times as well.
[open_namespace](https://github.com/postmodern/open_namespace#readme) does just that.
( ͡° ͜ʖ ͡°)
This is bad as fuck. Totally going to play with this tomorrow.
Positive and negative unary operators?
Seems more reliable than implementing your own autoload. If there are issues, writing your own wont save you from any possible problems.
http://stackoverflow.com/questions/1418574/which-ruby-classes-support-clone. Basically, a kludge to do it would be this: class Object def clonable? clone = self.dup self.object_id == clone.object_id end end That may not be entirely right, but its 2 am here, so pardon any bugs
Personally I'd just do: def clonable?(obj) case obj when Numeric, Symbol, true, false, nil false else true end end
Me likey.
I can see great use for this.
The use of autoload is discouraged. It's a deprecated feature that will be removed. See matz' post here: http://www.ruby-forum.com/topic/3036681.
Yes. I'm note sure what gave you the idea that I said to roll a custom implementation of autoload. I just said not to use autoload.
What would be the equivalent of a = [[1,2,3,4]] * 4 if you wanted to have to duplicate the values, not the references?
I appreciate your suggestion and evaluation of my abilities as well as letting me know that I can find more information about Ruby in books (Eloquent Ruby is my favorite right now). Still wondering if you encountered any "gotchas" which you think may be curious or surprising to fellow ruby-ists who never stop learning. 
Checked it out. Probably replacing my Errbit with this - we'll see. Time to write a Chef recipe at least.
What gem and object are you referencing?
 class Array def *(n) (1..n).map { self.dup } end end 
It's defined in the base class https://github.com/mislav/will_paginate/blob/master/lib/will_paginate/view_helpers/link_renderer_base.rb#L18 It's a method call to the pagination method in the super class of this class. Edit: It's useful to bear in mind that method calls don't need braces, and hence can look like local variables. This can come in very handy when refactoring using extract method, as you can break out local variables in long methods into their own methods without changing the code at all.
Yes, thank you. I did find it as a method of the base class, after searching a bit more.
I'm hoping you can create a podcast/video or otherwise or be featured on ruby rogues! Keep up the awesome.
Wow, that sounds pretty handy. I am just starting to get used to the flexibility of ruby.
`a` is an Array, but each element is a reference to the original `[1,2,3,4]` Array.
 a = Array.new(4) { [1,2,3,4] } a.map(&amp;:object_id) Seems to do the trick.
since jruby has thread-safe autoload https://github.com/jruby/jruby/blob/1.7.2/src/org/jruby/RubyModule.java#L3551-3555 that isn't going anywhere, and activesupport has its own autoload https://github.com/rails/rails/blob/v3.2.11/activesupport/lib/active_support/dependencies/autoload.rb that isn't going anywhere afaik, you have other options available even if MRI removes support
Why do you need to clone objects? I'm not saying you don't, I'm seeking information.
I'm making a builder class that holds default values. When a new object is built, the default values need to be copied into it. The default value needs to be cloned so that modifications against the new object doesn't affect the default value held in the builder.
Yeah, thanks for adding "_path" ! I was continuously forgetting it after a quick look for the routes via sextant (and when I typed paths out of the blue, I didn't...).
Brakeman?!
This blog post shows how you can use cloud-based image transformations to easily manipulate the opacity of images and how to use this technique to add watermarks to images. Sample code in Ruby, PHP, Python and Node.js is included. Disclaimer: I'm one of the co-founders of Cloudinary. 
And I just updated to 362 yesterday 
And why does that matter? Its easy to upgrade.
'rvm list known' after a 'rvm get stable' still doesn't show it. I can't upgrade yet.
I know, I just find it amusing 
Thank you, this makes good sense. 
I use &amp;&amp; where it reads better, and 'and' where that reads better. What I don't do is adopt a blanket rule that allows me to ignore the rules of precedence. BTW, it sounds like you were missing a test.
Do it manually, it's only [three commands](https://github.com/postmodern/chruby/wiki/MRI).
I know, but I would lose rvm features (no per-project rvmrc file, no automatic gemset migration etc). I think I will wait a bit to see if I can upgrade with rvm soon. 
I wouldn't recommend the Pickaxe book to a complete beginner, start with http://pine.fm/LearnToProgram/
There are arguments both for learning high level languages first and for low level languages first. Personally I believe that learning a low level language such as C is better because you worry more about issues around efficiency that can happen in the background with higher level languages but are still important to know about. In terms of books for learning C I was taught it so we didn't really use a book, but I found "C by Dissection" by Kelly/Pohl useful both for learning alongside being taught C and for use as a reference guide later on.
Read this. http://pragprog.com/book/ltp2/learn-to-program Basics of programming. They use ruby as it has clean and simple syntax. After that, either stay with ruby or try out other languages. Personally I prefer Ruby over Pyton because of "cleaner" syntax. 
Ruby or Python. I don't use Python but have respect for it, and I have heard it suggested for beginners over Ruby because its more rigid syntax may be helpful when just starting out.
`rvm get head` and `rvm install 1.9.3` got it for me. Try again now.
Yes, or Code Academy or TryRuby. 
You could use [chruby](https://github.com/postmodern/chruby#readme) with `.ruby-version` files (also supported by RVM and rbenv) and use [chgems](https://github.com/postmodern/chgems#readme) for gemset like functionality. Also, in RVM2 you should be able to "mount" external Ruby installs.
I don't think there's any good answer, alas. The semantics of `clone` aren't really that predictable on arbitrary objects either, even if it doesn't raise, even in the stdlib. (How 'deep' a clone will it be, for instance). 
&gt; Class ... do Yep, totally a typo on my part. I took this example from a functional test which setup a class as: @order_class = Class.new(OpenStruct) do I must have pulled it from there and not realized it. Fixed. &gt; include Stately I hate polluting the namespace too. I borrowed this concept from [state_machine](https://github.com/pluginaweek/state_machine), which does the same thing. If others feel strongly about it, I'd be more than happy to leave including it up to the user. In terms of polluting Object vs BasicObject, I think Object is still the right place, as BasicObject is supposed to remain blank. Thanks for the great feedback!
Ditto on the core_ext. Let people who want that module include it themselves ;) IMO "polite" core_exts are reserved for things which fall into one of two categories: * Methods which might make reasonable candidates for inclusion in core Ruby * Methods which work around design flaws in the language itself, used as a last resort when nothing else works :(
very well, enlighten me. how do the semantics of a ruby program change if you can apply optional static types? note that the type annotations cannot be binding, since ruby code is free to modify itself at runtime.
I'd prefer explicit *include*, as it makes it clear that objects of this class are state machines.
In your first example, you *reassign* b to contain (a reference to) a *new array* on line 4 before you get the object ids. In your second example, you do not. Your faulty conclusion about the "mysterious" behavior in the second example is due to this mistake. The actual behavior is that Ruby stores and passes *references to objects* rather than references to registers, memory addresses or similar. Because of this, you cannot implement the "swap" function that is usually used as a test for call-by-reference semantics. You can't make the existing reference point to a new object: you have to change the reference if you want the variable to refer to a different object. On the other hand, because objects themselves are mutable, I can demonstrate that call-by-value semantics are not accurate either with a method that mutates its arguments. This 'call-by-object-reference' semantic is called '[call-by-object](http://effbot.org/zone/call-by-object.htm)' in the Python community and it is the same here in Ruby-land.
Oh, ok. Then I'm not sure why this behavior is mysterious to you.
At work we use the [Mailsafe gem](https://github.com/myronmarston/mail_safe) for this purpose, but that's good to know.
Oh, ok then! Please ignore my confusion. But the stuff about call-by-object may be of interest. I think it's a good, intuitive explanation of the behaviors you're talking about.
My suggestion try this small application http://hackety.com/ See how you feel, Ruby is fairly simple language to learn.. So the learning curve is small.. 
Yes, you're right, I could use a different set of tools instead of RVM (despite the name, RVM2 seems to be a different thing, not just a different version of RVM). However I'm happy with RVM and I don't currently feel the need to switch away from it. YMMV.
I think this is really important for gems to get traction - there are a shit-ton of libs out there for doing all sorts of stuff, so why is the latest one the greatest? I'm not saying there isn't room for a new state machine lib in the Ruby space, but I would want to know how this one differs and at the moment it looks relatively similar with mildish syntax changes that I'm not sure I see the benefit of yet. Props to the OP though - publishing a gem and letting us all rip it apart is a brave move!
If you learn Ruby first, one day you should learn a lower level language. If you learn a lower level language first, you should spend some time learning a higher level language like Ruby one day. The one mistake a lot of people starting out learning to code make, is that they should learn "a" language. You should instead learn how to express ideas in multiple languages, so you know the strengths and weaknesses of each. Low level languages are focused on helping you as a programmer getting the computer to do what you want. "Allocate some memory, do this with it, fork a process, do that with it, clean it all up, etc." They are brilliant for all sorts of problems where you want to push the hardware around a lot. Higher level languages are focused on helping you as a programmer getting a business problem described. You will spend time saying things like "invoices can have many line items, and line items have these attributes, and when the invoice hits this state, these things should happen". They're great for solving problems that don't need to be very performant, but where you need to talk to business owners a lot. High-level languages come in different flavours. Some are "functional", some are "object-orientated" some are "procedural". Ruby will allow you to express ideas in all three forms. It's odd like that. Most of us will have learned a mixture of languages over the years. My very first language was BASIC (quite high-level), then C (low-level), and then a host of languages I can't remember the order of learning from C++ to Java to Smalltalk to PHP to ColdFusion to ASP to Perl and so on. In 2005 I was managing a £1.2 million project using some .NET frameworks, SQL Server and a bunch of other stuff I can't get into. I almost quit IT and went and studied law. I hated it. I'd spent my life learning to write code and I'd been caught in this dead end of "modern frameworks" being overly-complicated buggy piles of shit and developing horrible messes of code. Then I discovered three things: * Ruby * Ruby on Rails * Agile development methods were viable in a business context I've not looked back since. Every day I write Ruby, I'm happy. There is a pleasure to writing Ruby it's hard to experience writing in any other language. The syntax is succinct, clean, and does what you expect. You'll need to spend some time thinking about how bits of it work, and there is a bit of a learning curve to climb, but trust me, it's worth it. Good luck!
Might be more elegant to make this a method on Object so you have a predicate Object#clonable? method: obj.clonable? looks cleaner than clonable?(obj) to me Re-writing and re-factoring your method a bit: class Object def clonable? return false if [Numeric, Symbol, true, false, nil].include? self.class return true end end x = Numeric.new x.clonable? # =&gt; false y = 20 y.clonable? # =&gt; true 
As far as I can tell, state_machine includes just one method while you include classes like `State`. This might not be a problem (because any(?) `State` class you define will override `Stately::State`) until someone writes code which does stuff depending on the existence of a `State` class.
I prefer to not monkey-patch into *every* object. Also, more refactoring: not [Numeric, Symbol, TrueClass, FalseClass, NilClass].include?(obj.class)
Is there going to be a post for every incremental ruby release?
Why not just do `class Object; include Stately` instead of `Object.class_eval { include Stately }` ?
In fairness, 362 was causing a lot of segfaults, so this incremental update is more than normally important.
Thanks, and I totally agree. And just to be clear, stately isn't about being better than any other state machine gem out there, especially the truly superb state_machine. Instead, I see stately existing in a middle space between "rolling your own" using, say, a string to represent an object's current state, and the very full-featured state_machine. I'll add a note about this to the readme. &gt; Props to the OP though - publishing a gem and letting us all rip it apart is a brave move! Thanks! I'm a strong believer in code reviews. I always end up learning a lot, and my work is the better for it. *Edit*: Just added a section on [When to Use Stately](https://github.com/rtwomey/stately#when-to-use-stately).
I'd add some examples showing use with common frameworks (e.g. ActiveRecord). Right now it's not exactly clear from reading the docs how much of the heavy lifting Stately does for you. Other than that, I think it looks great. Good work!
The answer should always be (regardless of language) write readable code first, optimize when necessary. Ruby may be compiled (JRuby does some compilation, and rubinius has a JIT I believe) or interpreted depending on the which implementation you're using.
Have you tried [Mailcatcher](http://mailcatcher.me/)? It gives you an in browser email client that collects all outbound email regardless of address. It's an extra item that you have to run outside the Rails stack but that can be easily remedied with [Foreman](https://github.com/ddollar/foreman).
&gt; You should always write optimized code though Isn't it the opposite? I think the job of the developer is to write readable and well documented code, don't you agree? Why?
I'm using Ruby 1.9.3-p374, what is the case here?
Well, that depends on your project I think. "optimized" here is kind of vague. Optimized also isn't mutually exclusive with good documentation. In some spots, you might write a method a certain way to get the performance as good as possible (maybe for a complex feature). You are using ruby afterall though so it's kind of hard to write unreadable code, hehe.
&gt; You are using ruby afterall though so it's kind of hard to write unreadable code meta-programming says what?
You're using CRuby or MRI. If /u/awj is correct, he says it won't optimize that.
Thanks! I just added a section on [using Stately with ActiveRecord](https://github.com/rtwomey/stately#example-using-stately-with-activerecord).
Rigid syntax might just be an annoyance when learning the basic concepts, I don't know if anyone can say for sure. I know when I first started learning programming with C, gcc complaining about missing semicolons was one of my least favorite things.
Check out this offering by Zed Shaw. The online book is free. It's very short. It's focused on the basics. It is interactive. It makes you write small examples of code every day. And though it says the hard way, it's the only way to learn programming, and it's not even very hard. [Learn Ruby the Hard Way](http://ruby.learncodethehardway.org/book/)
I have a serious misconception here, isn't YARV the VM that replaced MRI? I tried to look it up but didn't find any useful links.
You can actually check. For your example: 1.9.3p0 :002 &gt; puts RubyVM::InstructionSequence.compile('var = 1 1.9.3p0 :003'&gt; var = 1 1.9.3p0 :004'&gt; var = 1 1.9.3p0 :005'&gt; puts var 1.9.3p0 :006'&gt; ' 1.9.3p0 :007?&gt; ).to_a YARVInstructionSequence/SimpleDataFormat 1 2 1 {:arg_size=&gt;0, :local_size=&gt;2, :stack_max=&gt;2} &lt;compiled&gt; &lt;compiled&gt; 1 top var 0 1 trace 1 putobject 1 setlocal 2 2 trace 1 putobject 1 setlocal 2 3 trace 1 putobject 1 setlocal 2 4 trace 1 putnil getlocal 2 send puts 1 8 0 leave As you can see, setlocal is called 3 times, so it is not optimizing this to bytecode before sending it off to YARV. Now, YARV does some optimizations to run bytecode, but honestly I'm not really familiar enough to know what it would do with this. The job of a VM should be to optimize something like this but I feel like YARV isn't quite as advanced as something like the JVM and might not (though this is pure speculation). 
MRI is not a VM, it's an interpreter. In short, when you run a ruby program, MRI is the part that reads your ruby code and from that generates bytecode. That bytecode is then passed to YARV for it to optimize and translate to native instructions. Edit: I should note as this is confusing, MRI and YARV aren't really two different programs or anything. When Ruby 1.9 was being developed it started with the original MRI and merged in the code from the YARV project. So 1.9 is kinda both. It's still MRI, but basically the next generation of MRI which uses YARV code to improve performance. 
See [chadcf's](http://www.reddit.com/r/ruby/comments/16tft9/does_ruby_compile_before_executing/c7zaxic) post, it definitely does not optimize this.
I wish we could declare a moratorium on following three things with 'oh, my'. Especially when it's not even done right (there needs an 'and' between each noun).
Said more eloquently than I
Fantastic! That definitely makes it clear what's going on :)
&gt; I've not looked back since. Every day I write Ruby, I'm happy. There is a pleasure to writing Ruby it's hard to experience writing in any other language. The syntax is succinct, clean, and does what you expect. This. It is a language intentionally designed "to make programmers happy." No, really. And, in the addition to the above, almost every day I find new, better, *more fun* ways to write code. 
Wouldn't this leave all installed gems behind? Is there a way to upgrade / move or copy the existing gems to the new version?
May I ask what you used to learn ruby? Or, more specifically, what was the last thing that you read (or worked through) while working on this. I still have no idea how to even begin making a useful gem.
The first thing somebody does when trying out a new gem is copy and paste the examples. If I copy and paste the first code block and then try and use this class I get a code error. &gt; NoMethodError: undefined method `state=' for #&lt;Order:0x90e9f44&gt; The defining a state code example is no better: &gt; NoMethodError: undefined method `transition_to_my_state' for nil:NilClass 
&gt; You are using ruby afterall though so it's kind of hard to write unreadable code, hehe. Famous last words. :(
My first gem was a clone of httparty. I'd implement something, then visit httparty's source to figure out how they did it and refactor. I ended up throwing the code away, but I learned tons.
Well Ruby 2.0 gives us the ability to stop the Object-monkey-patch-heeby-jeebies, but in 1.9.3 can't see a cleaner way of doing it. Good refactor. Not sure it expresses intent as clearly, but less code!
Cool beans. I shall make to consider it for my state machine needs in future
&gt; it's usually easier to reason about your objects by defining them with instance methods with normal @instance_variables/accessors/initializers/state. I don't really see why as long as the class in question is only doing things and not having any state (like in this case). I want to add another two things: * Move your constant definitions into your `class`. If someone is going to use your gem in a project (e.g. for extending the functionality your gem provides) he ends up having all those constants being defined. * The top level object of your project should probably be a `module` instead of a `class`. At least that's what all gems I came across do.
They are evaluated immediately: class A C = 40 + 2 end p A::C # =&gt; 42
Great answer, thank you so much.
Again, thank you so much.
Learning gems from scratch is probably a better idea. One might get frustrated, though. ;) All `bundle gem new_gem` does is creating a directory with files. So, it's easy to compare it to your gem.
Thanks! So, the pipe used in the code below: def self.adjectives(more_adjectives = nil) more_adjectives.nil? ? TokenPhrase::Adjectives : TokenPhrase::Adjectives | more_adjectives end Merges two arrays with unique values. It's also known as a set union. You can see it in the [documentation](http://www.ruby-doc.org/core-1.9.3/Array.html#method-i-7C). I had no idea this was possible until I wrote this gem. It's great. Additionally, ||= is basically "if x is false (or nil), assign the following value to it" So, X = 3 #x =&gt; 3 x ||= 587 # x is still 3 because it's already set y ||= 587 # y is set to 587 because it is nil It's basically shorthand for: if x.blank? x = number else x = x end Hope that clears things up! Again, thanks for the compliments.
Oh Gawd! One of those people who use exception handling for flow control! Don't you realize that this is the modern equivalent of a goto statement? If you end up with a long if statement wrapping everything in a long method, then you should break it up or even try to think of a different way of doing what you are doing rather than just inserting a goto statement at the beginning. Use exceptions for exceptional situations, which means pretty infrequently and prefer real flow control.
not sure if sarcasm... It's the ruby variant of a [guard statement](http://en.wikipedia.org/wiki/Guard_%28computer_science%29). It doesn't actually do any flow control, it just aborts the method if any parameter isn't in the form you expect it to be. It tells the caller immidately that something is wrong (of course, the error message should be an exception, so `ArgumentError`in this case), instead of causing lengthly debugging sessions because the if something end variant returns `nil` if an error happens. 
&gt; You probably saved me from thinking for hours to find a workaround of this on future projects. Yes he did. I wish I knew this 3 months ago.
 dom.at_css("body").traverse do |node| case node.name when "h1" # do this when "div" # do this when "li" # do this end end This grabs the first `&lt;body&gt;` tag and then recursively traverses all of its nodes passing them into the block. Inspecting a Nokogiri node object, you can see that it responds to `name` which'll tell you what type of node it is. 
 require 'open-uri' require 'nokogiri' doc = Nokogiri::HTML(open("http://www.craigslist.org/about/sites")) doc.xpath('//div').each {|div| puts div.inspect } ? 
Gems are commonly used for both standalone applications and libraries. This use seems reasonable.
It's also important to keep implicit returns in mind. Rails especially ends up using the return value of callback methods for control flow, so accidentally returning nil or false can cause some perplexing bugs. 
I'll take 'Things you would use a REPL for', for $500, Alex. Seriously though: spend an hour with irb, or even better, [Pry](http://pryrepl.org/). Running currentDiv.methods or currentDiv.&lt;TAB&gt;&lt;TAB&gt; would have helped you tremendeously.
Woah thanks a lot ! The array union thingy is pretty cool !
This is amazing. I definitely felt the #generate method getting a little unwieldy, but am still relatively inexperienced when it comes to refactoring for cleanliness. You can expect me to a) implement this class and b) reach out to you for feedback with the refactor. This is why I released it to the world: to make my code better!
They have a ton of words. Jesus. This'll be a good reference.
Very true, thank you. BTW, should I have posted this in a different subreddit? Since I was downvoted.
I referred to Sandi Metz for some reason, but I actually had this post in mind: http://blog.codeclimate.com/blog/2012/11/28/your-objects-the-unix-way/ 
Its actually based on the wordnet dictionary, which is a free, and gigantic, open source dictionary
The closest you can get is returning nil. It's not exactly the same in that "void" is not allowed in expressions (if I remember it correctly) but nil/null is a value that can be used. Rails is indeed a framework. You're right that it more or less is plain Ruby code. Rails extends a lot of core Ruby classes, so there are some Rails-only things that look like they should be part of Ruby. I really just wanted to point out one edge case where implicit return can catch you off guard. While we're on the topic, an *explicit* return within a do block will return from the *containing* function. Here's an example of a common issue with this behavior: def add_list(list, num) list.map do |x| return x + num end end The intention here is to make a new list by adding `num` to each element. The actual return value is `num` added to the *first* list element, because that do-block ends up returning from `add_list`. In general you almost never want to use an explicit return within a block.
YES!
Thanks!
This reminded me of this: http://rubythreads.com/products/minaswan . I think your 8-bit Matz would be really nice on a shirt like that.
Yeah, it's too bad it's out of stock. :'(
One of the biggest problems I have faced with dealing with text and files in ruby (after moving to 1.9) is that it often crashes out due to some data that is not the format it is expecting. I thought this might be addressed here. I've been through the relevant links (e.g of James E Gray) but often your program may be searching files on a disk (say like grep or ack) and you don't know the format. Even smart quotes have tripped up my programs that were doing a substring match. It's at frustrating times like this, that I've have to go back to my earlier perl scripts that just work. However, good article.
Nice, I think I'll try it for a personal project I have. 
It looks cool but I've learned from work to not add untested gems to any project. 
Seeing things like `_(arr)`, `R(arr, true).map(R.proc('capitalize'))`, and `S(str).pad(50).s`. Yikes, that is almost nothing like Ruby =s
&gt; Simple assignment for arrays results in a variable pointing to the same array There's nothing array-specific about that. Simple assignment of integers results in variables pointing at the same integer objects, as you can verify by examining #object_id for the variables. Ruby is completely consistent, unlike many other languages; every variable is a reference.
This is because they appear to have chickened out of using native prototypes, which would make the whole thing a hell of lot nicer to use. I understand the reasoning though. More than one library has been burned doing it before. 
`_(arr)` is [Underscore.js](http://underscorejs.org/), they are comparing RubyJS to it.
Using native prototypes also makes certain things impossible. E.g. destructive methods, adding timezone support for Time. Also some method names clash with native js names. 
awesome, thanks for clarifying 
Yes, I noticed that when exploring the object ids in irb. What made it confusing for me was that when integers change, they usually take on another value so if we changed a in this way, it would take on the new object id while b still points to the old one. On the other hand, it is more often for arrays to have their value mutate while pointing to the same "array variable." Thus, integer variables (in reality pointers to integer numbers) get "unlinked" from each other once one of the variables changes, because the change is not a mutation but a new assignment. I now clearly see the logic of the behavior and won't be confused again. 
sure, if by "methodizing" you mean "reserving the possibility to include more behavior later", then yes. but, as BonzoESC also mentions, it's probably best to think more generally about this as a case of encapsulation-- clients who use the `contact` interface should not know that it's backed by an instance variable. it's up to the class to determine how to supply the `contact` information.
I liked your `Generator` class so I tried a little refactoring and sent him a pull request https://github.com/genericsteele/token_phrase/pull/1/files I agree that `TokenPhrase.adjectives`, etc. probably shouldn't take an argument, but exposing them as constants is a little tricky. Constant arrays can be mutated in ruby, so doing something like `TokenPhrase::ADJECTIVES &lt;&lt; "slimy"` would modify the default adjectives list for the life of the runtime, and cause problems with thread-safety. For example: &gt; FOO = ["a", "b", "c"] =&gt; ["a", "b", "c"] &gt; FOO &lt;&lt; "d" =&gt; ["a", "b", "c", "d"] &gt; FOO =&gt; ["a", "b", "c", "d"] You could `freeze` the array to prevent modification, but that's a little unfriendly to users who expect to be able to do things like `&lt;&lt;` and `map!`. They would have to call `dup` first, or use the non-mutating versions of those methods, like `map`. To illustrate: &gt; FOO = ["a", "b", "c"].freeze =&gt; ["a", "b", "c"] &gt; FOO &lt;&lt; "d" RuntimeError: can't modify frozen Array I opted to just make a Hash literal out of the defaults and expose each key as a separate class method as he had it. That way the lists aren't cached, and each caller gets a new instance of the list. To illustrate: &gt; TokenPhrase.adjectives.object_id == TokenPhrase.adjectives.object_id =&gt; false Anyway, thanks!
Your shorthand example should be if x x = number else x = x end Rails adds a .blank? method to strings. If a string is blank it won't be reassigned by the shorthand way. eg.: x = "" x ||= "hey" x == "" =&gt; true
Right now the metrics are around feature files and step definitions. So anything in your project with .feature or *steps.rb will be ran through the metrics. We have played around with the idea of looking for smells in the hooks/env.rb but it didn't make it into our first release and is being added to our backlog. Not sure why only one step_definition file is being found. I'll look into it. Edit 1: If this is in regards to the html output, we only output the problem features/step_definitions to reduce the size of the report and the usability of it. So if it isn't showing up then it didn't trigger any rules. Edit 2: Looks like if the step definition name ends with Steps.rb instead of steps.rb it wont pick the file up, patching that fix now for the next release. [Full list of rules](https://github.com/r-cochran/cuke_sniffer/wiki/Rules-list)
I can tell you why. The file that was caught (sql_steps.rb) fell in your steps rule but not my other ones (claims.rb, newbusiness.rb, etc). I forked, patched, and tested a fix for you in cli.rb 1. LOC 10 cli.rb : step_definitions_location defaults to Dir.getwd + 'step_definitions'. Correct me if I am wrong, but unless specifically detailed this is the default dir for all step definitions. 2. LOC 33 cli.rb : removed the *steps.rb requirement to allow for other file names. I sent a pull request with the info above. Edit: I see your Edit 2 mentiones that you are patching the casing of Steps. Is there a rule in Cucumber regarding having the word "steps" in the file name? 
thanks for the fix. I had always assumed that step definitions had to live in the step definitions folder and have "steps.rb" at the end. Looked into it more and it is just convention. Any .rb file in the working directory with a Given // do end block will be a usable step definition to cucumber.
With that said, I think the fix I pushed to you might need a bit more work by removing that '/steps_definition' location in the args. Maybe scan the text and if Given, Then, or When do no start the block throw that to the support files (ie. hooks.rb or env.rb)? If you want, I can look into that more later this week... edit: Just as an FYI, if you remove the '/step_definition' location the code I pushed to you will break. This error comes up. I will look into it more later. Step Definitions: ........C:/Ruby193/lib/ruby/gems/1.9.1/gems/cuke_sniffer-0.0.1/lib/cuke_sniffer/ step_definition.rb:19:in `-': nil can't be coerced into Fixnum (TypeError) from C:/Ruby193/lib/ruby/gems/1.9.1/gems/cuke_sniffer-0.0.1/lib/cuke_sni ffer/step_definition.rb:19:in `initialize' from C:/Ruby193/lib/ruby/gems/1.9.1/gems/cuke_sniffer-0.0.1/lib/cuke_sni ffer/cli.rb:87:in `new' from C:/Ruby193/lib/ruby/gems/1.9.1/gems/cuke_sniffer-0.0.1/lib/cuke_sni ffer/cli.rb:87:in `build_step_definitions' from C:/Ruby193/lib/ruby/gems/1.9.1/gems/cuke_sniffer-0.0.1/lib/cuke_sni ffer/cli.rb:34:in `block in initialize' from C:/Ruby193/lib/ruby/gems/1.9.1/gems/cuke_sniffer-0.0.1/lib/cuke_sni ffer/cli.rb:33:in `each' from C:/Ruby193/lib/ruby/gems/1.9.1/gems/cuke_sniffer-0.0.1/lib/cuke_sni ffer/cli.rb:33:in `initialize' from C:/Ruby193/lib/ruby/gems/1.9.1/gems/cuke_sniffer-0.0.1/bin/cuke_sni ffer.rb:13:in `new' from C:/Ruby193/lib/ruby/gems/1.9.1/gems/cuke_sniffer-0.0.1/bin/cuke_sni ffer.rb:13:in `&lt;top (required)&gt;' from C:/Ruby193/bin/cuke_sniffer.rb:23:in `load' from C:/Ruby193/bin/cuke_sniffer.rb:23:in `&lt;main&gt;'
"Every variable is a reference" is really the only way to do it if you want consistency and performance, because the overhead of pushing entire objects on the stack would be horrendous. Of course, some VMs attempt to optimize for the case where the object will fit in a register.
Was able to generate the same problem and pushed a update that has that change + the fixes required for specs to pass.
I know Ruby and Python rather well and have years of experience of each. Hands down Python is easier. There's less of it. You can master Python in a few months. Ruby with it's metaprogramming, eigen class manipulation, many ways to do the same thing, etc., takes longer to learn.
Seconding this. I started with Hackety Hack and it was a ton of fun.
Nice. Do you guys know any other custom scaffold to try too? 
Thanks. I don't have a computer Science background either, though, in my defense, there were no computer science courses in my country when i was learning starting out. ( Yup. I'm not the youngest guy around :-) Not many people realize that coding is a very practical experience. A bit like riding a bike. The only way is to keep doing it, failing, and keep doing it some more till one gets the hang of it. No amount of reading about it or watching videos will really help. There are many good books and i am not putting down the authors or the quality of the books, but most of them are either too verbose or too academic or too boring. A good compiler/interpreter/REPL with good error messages is a far better tool for learning/experimenting and books which connect a beginner with code as early and as often as possible are laudable.
Very cool! I wrote a quick alias to make this process a bit easier: http://alias.sh/convert-video-gif Also instead of pony-ing up for Screen Flow, I found the free version of QuickTime to work just fine: http://osxdaily.com/2010/11/16/screen-recorder-mac/
Very nice, somebody (the author maybe?) would care to comment the code?
Noone is going to be "that guy"? Fine, I'll sacrifice myself then No tests? :) The best advice I can give you: 1. Tests. Pick a test framework(Rspec, MiniTest etc) and use it. If something is hard to test, there is usually a problem with the structure of the code. When you fix the code so it will be easier to test, the structure usually improves as well. 2. Run [Reek](https://github.com/troessner/reek) on it, fix everything it complains about. It will be a pain in the ass, but you'll learn a lot
&gt; require 'llvm/core' That's not a compiler, that's a language frontend.
Very cool! However it would be cooler if it too was written in brainfuck!
true that, although one could argue that any tool taking a program and, without further interaction, produces a binary could be called a compiler
the relaunching blog post is here: http://www.opensourcerails.com/relaunch/
Pull request: accepted. I had to gsub the resulting phrase because there are some items in the dictionaries that are separated by a hyphen.
Why the superfluous return statements?
I like them to state explicitly that some return value is supposed to be used
The last line of the test should be: result.should == inputs "should" on it's own is used in these kinds of specs: subject {1} it{should eq 2} 
This looks really nice :)
You forgot the "do/end" to define the block: require 'sinatra' get '/' do "It works!" end http://www.sinatrarb.com/intro
Well.... I feel like a moron now Not the most helpful error message but, still feel quite stupid.
JRuby support has already been added to Phusion Passenger 4: http://blog.phusion.nl/2012/10/30/phusion-passenger-4-0-supports-jruby-rubinius/ But I'm curious as to why you want to ditch TorqueBox. I'm not that familiar with it but I have heard good things about it.
[This book](http://pragprog.com/book/achbd/the-rspec-book) is pretty decent and it brings up Cucumber as well. Otherwise I don't really have any recommendations other than to look at a solid Ruby project on Github to find out how they test their stuff. Testing is not exactly easy either, so solid tutorial would be great. The hard stuff is what to test, when to test, when to mock/stub and so on. Writing clean specs in Rspec is also a bit of a pain until you get the hang of it. Ther e is a lot of magic involved. You just have to suck it up and learn it as you go I guess. There is a bunch of good talks over at http://www.confreaks.com which deal with more advanced testing subjects as well. &gt;Totally irrelevant: why mentioning tests make you "that guy"? Is it reddit or r/ruby specific or is it just mentioned too often that bores people? Ruby guys are generally pretty zealous when it comes to proper testing :) It can be hard to get pull requests accepted if you don't have specs for example. Something else you can look into if you do open source stuff on Github is [Code Climate](http://www.codeclimate.com/). It is free for open source. It is like Reek, only hosted and prettier. You get reports there on how your code develops over time. Reek catches a LOT more code smells though, keep that in mind. Edit: I own most of the books in the sidebar and I can recommend all of them. Another vital book is [Refactoring, Ruby Edition](http://www.amazon.com/Refactoring-Ruby-Jay-Fields/dp/0321603508). That one should really be in the sidebar as it teaches you how to get Reek to shut up. I wouldn't buy books on Rails because they are usually outdated or get outdated within 5 minutes of purchase. I think I have two of them and they are both pretty useless right now and doesn't really teach you anything you can't learn from tutorials anyway.
While you have to brew/apt/compile a few things (namely ffmpeg), being able to read Seinfeld while having coffee in the morning is deeply, deeply satisfying.
Wait until you forget to put an "end" to a "do" block. Those are fun to find... because your error message is at the end of the file. That's why Ruby peeps try to indent their do/end blocks to match. 
This is incredibly, edibly cool. And I can think of so many videos I want to try it on.
The term 'compiler' isn't limited to the production of binaries. Compilers are basically just translators from one language to another.
Markdown allows HTML so you'd still need to use something like sanitize. 
yeah, true, though it makes life a little easier since stuff like RDiscount &amp; redcarpet have built in html sanitizing.
Can you explain the difference between me doing it myself and using Sequel or ActiveRecord? Not trying to be cheeky here...I just don't understand.
I use [sanitize](https://github.com/rgrove/sanitize) for user input. If you are making a Rails application, then ActiveRecord has you covered. In the event I want to use a lower-level database client [Ruby/DBI](http://ruby-dbi.rubyforge.org/). The latter two will protect you from SQL injection if you use them correctly. For more information about preventing SQL injection (and many other attack vectors), [OWASP](https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet) is a great resource. 
It does. But can you explain how the method you mentioned circumvents this problem? Is it a module you just include in your code and forget about? Some other service that runs? 
impressive!
Yeah, ActiveRecord, Sequel, etc are gems that have the sanitizing built in and on, by default. So if you include them in your app, once they are connected to the database, you can make queries with their API and they'll sanitize for you. The aren't separate running services, their code becomes part of your application stack. The [sql injection](http://guides.rubyonrails.org/security.html#sql-injection) section from the security guide probably explains it better.
This blog post describes the new Cloudinary's add-on for cloudControl, a popular European PaaS provider. Ruby and Ruby on Rails developers can build and deploy their applications using cloudControl and use Cloudinary as an add-on for uploading images to the cloud, performing image transformation &amp; manipulation and delivering optimized images through a fast CDN. Disclaimer: I'm one of the co-founders of Cloudinary. 
Try `node.attr('href')`
While I'll probably never use this, I really like it! And thanks for detailing some of the inner workings ~ I've done quite a bit of work with ffmpeg but wasn't aware of ffprobe...very interesting. 
This is, frankly, genius. I am in awe of how original the idea is, and the details of how the developer implemented it are equally awesome. I don't know how well it works in practice for getting the gist of a whole TV show episode, but even if it's "only just about" it's still one of the cleverest and most original ideas I've seen in a long time. If it works *well* then it's absolutely phenomenal.
Didn't know you can do that, however the result is the same. 
This is the most so-dirty-it's-beautiful thing I have ever seen.
While working on it, the only show I found that it worked *poorly* on were Superman episodes from 1941, where there was just very little dialog, and the motion was too smooth for any scene changes to be detected. On the flip side, a show like West Wing is probably too difficult to follow if you don't already have a feel for who is likely saying what line. In between those, everything I tried it against worked somewhere between "good enough" and "well", IMO.
The support of jruby is in beta right now and I host with a service that maintains my servers for me and will not allow me to go production with a beta product. My reasons for wanting to switch away from torquebox are that for one, I use passenger for years and loved it. Secondly torquebox has all the features but there are several things happening causing my servers to crash once a day. So much so that we have maintenance scripts that watch them and restart TB in that event. I have talked directly to the tb guys and they were no help whatsoever. Also (and this is just preference) I do not like the workflow that I have to "deploy" a project and then run tb again to properly redeploy, whereas with passenger I will just have to touch the tmp/restart to notify it of code changes. These are really all just a bad experience, I bet a lot of people are using tb with much success, to me it has just been trouble.
That's really cool. I must spend too much time on reddit, though, because the first thing that pops in my head was, "oh no, /r/funny is going to explode because of how much easier it is to make these now." Still, congrats on making something awesome and releasing it. 
Would you be interested in beta testing our JRuby support? More testers and bug reports are always welcome.
What I meant by that was block any possible escape characters which could lead to SQL injection. I know that there is no "make this secure" wrapper. I am scraping text and url's with a web bot and storing those strings in a database. I just want to make sure that in the process of scraping this data, the database is protected from any malicious strings. 
I know that the code is currently grabbing "click me". I just spent all night last night going through [this entire list of xml::node methods twice](https://github.com/sparklemotion/nokogiri/wiki/Cheat-sheet), [reading this documentation over and over](http://nokogiri.org/Nokogiri/XML/Node.html#method-i-inner_html), as well as [this website](http://ruby.bastardsbook.com/chapters/html-parsing/#h-2-2) trying to find the right way to grab the href parameter, and as far as I could tell, nothing worked properly. Please do not jump to conclusions and assume I am lazy or an inexperienced programmer. Every single example I have seen that does this is of the form of doc = Nokogiri::HTML(open("http://www.craigslist.org/about/sites")) pdivs = doc.css('li') pdivs.each { |pdiv| city_link = pdiv.css('a')[0]['href'] puts city_link } which for some reason does not work with my current code. Edit: And I answer my own question in the process of complaining about why it is not working[.](http://www.reactionface.info/sites/default/files/imagecache/Node_Page/images/1314029819767.png)
Yes, result is the same. Outputs "parse_craig_cities.rb:42:in `+': can't convert nil into String (TypeError)"
Well, I've never run into that problem. But I'll admit, your way is more concise and just feels better. Cheers for for pointing it out. 
This is the faster way of returning attribute values.
All this real time stuff still confuses me, even though I've implemented it before in a few of my apps using pusher or [the method recommended by the author of juggernaut](http://blog.alexmaccaw.com/killing-a-library)
A little piece of information that seems to have been left out: You have to sanitize for multiple things depending on what the data is used for... If it's going to be stored in the database, you sanitize the SQL (using Sequel, or ActiveRecord, or etc). If it's going to be displayed to a user, you sanitize it using Sanitize or etc. If it's both, you use both. The reason being is that say for example you're accepting user input to display on a page (like a comment post). You first need to sanitize it for SQL so that if someone tries to add a comment like "; select * from users" it doesn't return all the user info when it attempts to save that record (it's slightly more in-depth than that, but that's the jist of it). After that, you need to sanitize it for display, so if the comment is "&lt;script&gt;malicious_javascript_function();&lt;/script&gt;" it isn't executed on the user's end (even though you can store that in the database just fine). 
&gt;ASIA FOR THE ASIANS, AFRICA FOR THE AFRICANS, WHITE COUNTRIES FOR EVERYBODY! &gt;Everybody says there is this RACE problem. Everybody says this RACE problem will be solved when the third world pours into EVERY white country and ONLY into white countries. &gt;The Netherlands and Belgium are just as crowded as Japan or Taiwan, but nobody says Japan or Taiwan will solve this RACE problem by bringing in millions of third worlders and quote assimilating unquote with them. &gt;Everybody says the final solution to this RACE problem is for EVERY white country and ONLY white countries to “assimilate,” i.e., intermarry, with all those non-whites. &gt;What if I said there was this RACE problem and this RACE problem would be solved only if hundreds of millions of non-blacks were brought into EVERY black country and ONLY into black countries? &gt;How long would it take anyone to realize I’m not talking about a RACE problem. I am talking about the final solution to the BLACK problem? &gt;And how long would it take any sane black man to notice this and what kind of psycho black man wouldn’t object to this? &gt;But if I tell that obvious truth about the ongoing program of genocide against my race, the white race, Liberals and respectable conservatives agree that I am a naziwhowantstokillsixmillionjews. &gt;They say they are anti-racist. What they are is anti-white. &gt;Anti-racist is a code word for anti-white.
This helps a lot! Thank you :)
Oh sweet Raptor Jesus, you went all out on this one! Thank you very much! I will definitely be referring back to this as I proceed. 
Wat
TF! 
I would yes but like I said I do not have an environment to test my main products on and at the moment I do not have any personal projects that can adequately test a server. Good luck and I hope for a speedy beta because I eagerly await the full support of it!
The socket hijacking API is a lower-level API that allows you to implement WebSockets, Server Sent Events, etc.
It's not because gems devs are encouraged to use semantic versioning that ruby will follow the same pattern. Anyway, never had backward compatibility problems with minor versions of gems.
Semantic versioning is encouraged by a variety of tools and community members but of course not everyone follows it. It is up to each gem maintainer. Ruby itself has been around long enough it started before semantic versioning caught on. I believe for a while it followed the Linux Kernel setup (an even/odd system) but I think it is transitioning to something more symantic system although I haven't followed the discussions to really know what it had before and what is is moving to so I could be wrong on some of the details.
Yes, dependencies can be a pain in the ass. I had one project whose dependencies I updated after one year and the entire application basically fell apart. It took quite a few test runs and some googling to get up to speed again. After that experience I made sure to run `bundle update` more frequently which keeps the required changes to a minimum. (Tests are very valuable in finding compatibility issues!) I had breaking changes even in *patch* version numbers. An update of delayed_job from 3.0.1 to 3.0.4 required me to add a database column. (IIRC) \edit: To be fair: It looks like the column was introduced in 3.0.0 and became mandatory somewhat later. At least my app worked fine at first.
For SQL injection specifically, I echo what everyone else here says: Use some existing package for interacting with rdbms, that will use bind variables under the hood, and take care of it for you (sans bugs). This isn't actually done by "blocking any possible escape characters", exactly. (Well, it sort of kind of is, but at low database driver level). But there are other kinds of 'sanitizing' you will need to do, if, for instance, you are placing user-contributed content in HTML. Your question was unclear. You're just asking about SQL sanitization? Many of the other answers on this page are about HTML-embedding sanitization instead. And there are other kinds of sanitization too, for other contexts. When you say "I for sure need to guard against SQL injection, but I would like to strip everything out", it kind of sounds like you don't even know what you're asking. 
Sadly, I would say it IS usual for backwards compat breaks, yes. Although people don't _want_ it to be usual, I don't know how anyone that's using more than a tiny trivial amount of gem dependencies can with a straight face say "No, gems hardly ever introduce backwards incompatibilities at minor versions in the ruby world!" Or maybe I'm just really unlucky? But my impression is that the ruby community in general priorities innovation over maintenance generally as a 'cultural' value, and backwards compat is a big problem, most devs just don't prioritize it (if they DID manage to semver, it'd just mean their package would be on version 1033.6.3 by now) But yes, not every gem says it follows semver -- it's definitely not universal. And even those that SAY they do (or some other policy for predictability of compatibility), frequently violate their policy in practice, either accidentally or because they think it's no big deal or forgot about the policy, or who knows. How do I deal with it? * Basically, just by running all my tests after upgrading. And praying. And dealing with problems when they arise. * Yes, when you are maintaining a bunch of applications, instead of say just one that's central to your business... it can be problematic. * Another option would be never upgrading your dependencies, or upgrading them very carefully. Bundler makes it pretty easy to upgrade say, one gem that you know needs upgrading, while leaving all other gems locked to exactly what you had been using. (Unless the one gem you are upgrading requires newer versions of other dependencies, of course). * But contrary to that advice, it's better to not let all your gem dependencies get very very out of date, and then update them all many versions at once in one goal. Better to regularly update little by little, if possible, so any problems that arise are more likely to be small and easier to deal with. * Always always use bundler (even if you aren't using Rails, which requiers it), always keep your Gemfile.lock in your version control. Which will also make it easy to roll back to exactly the versions of all dependencies you were using at some past known good date. bundler is pretty damn awesome (although lately occasionally is confusing me and making it hard to update individual gems with 'bundle update' the way I think it should work, either there are bugs or I'm not understanding how it should work, but anyway, bundler is still so much better than not bundler) I would not bother with checking change logs of every gem you use pre-emptively. Backwards compatible breaks are often not listed in changelogs -- because they are often accidents, or at any rate not thought through very well by the devs. I'd only look at changelogs when there's an actual problem you notice and want background on what may have changed, or for particularly complex gems that you make particularly involved use of. * ruby the lanugage itself is a completely different animal though, it's versioning and backwards compat issues are it's own, and not generally emulated by the rest of the ruby community. For ruby itself, x.y is considered the major version, basically. 1.8.x should all be backwards compatible with previous 1.8.x, 1.9.x, 2.0.x, etc. But 1.8 to 1.9 to 2.0 is the major jump that may not be backwards compat. (Even 1.9 to 2.0, they've said they are trying to keep it _minimally_ disruptive, less than 1.8 to 1.9, but they are _not_ promissing no backwards incompat, and there are several intentional and documented backwards compat breaks). 
Looks great! Would love to see some more projects on there. 
should post to /r/rails.
&gt; the ruby community in general priorities innovation over maintenance generally as a 'cultural' value, and backwards compat is a big problem, most devs just don't prioritize it (if they DID manage to semver, it'd just mean their package would be on version 1033.6.3 by now). This willingness to adapt and change quickly is what attracted me most about Ruby in the first place! -- Which is why I'm having trouble understanding why semver hasn't been embraced by the community as a whole the way other standards have. What would be so terrible about `FooGem 1033.6.3`? If everyone who uses it can perform updates in peace, the payoff in man-hours of troubleshooting seems to me well worth an ugly version number. Who care how long the version number is so long as *it means something*. If version numbers don't mean anything, or only vaguely mean something to the developer... why use them at all? Hell, I might as well go Apple and call it `FooGem House-cat`, or `FooGem Squatting Tiger` or something. Semver isn't even a particularly radical idea. It in no way changes one's workflow. There's barely even anything new to learn to start using it. Take TDD for example: Adjusting to TDD means completely changing the way you develop software... and yet, we all did it. The Ruby community embraced it, adjusted, and it's now so engrained in Ruby developers' minds that even introductory books cover TDD best practices. This is what's pushed Ruby so far ahead of the curve: how adamant the community is to embrace newer, better ways of doing things. By comparison, semantic versioning is such a minute, superficial change to one's way of doing things, and the benefits are so great, that why would anyone *not* instantly adopt it as a de-facto standard? I personally can't think of a single good reason not to use semver on %99.9 of cases. *** **edit:** To clarify: I'm not talking about accidental breaks in compatibility. Shit happens. I'm talking about gems that knowingly introduce incompatibilities from one minor version to the next.
When this happens, file a ticket. I usually do. At the very least you should ask them to add "I do not follow semver" to their README so other developers don't get caught in the same trap.
I know, and action controller live has me excited. I know that having it built into rack is a requirement to move forward, and I'm excited none the less 
&gt; This willingness to adapt and change quickly is what attracted me most about Ruby in the first place! -- Which is why I'm having trouble understanding why semver hasn't been embraced by the community as a whole the way other standards have. In my own analysis (and it's just my own opinion based on my own observations and thoughts), it's because innovation and stability are inherently in tension. It takes real brainpower and time to keep your code backwards compatible -- even if you aren't going to keep your code any more backwards comp, but jsut follow semver and wind up at version 3045.6 -- it still takes real brainpower and time to even _think about when_ a change is backwards incompat and when it isn't. For starters, you have to actually spec what your api _is_ (and keep that up as it evolves), so you know what changes matter for backwards compat (the semver document says as much). * From my own experience, I disagree with your assessment that it's trivially easy to adopt semver. I think _even if you are_ willing to increment a major version every couple weeks and wind up at 2048.54.2, it's still non-trivial psychic energy and time. Compared to just hacking away and making things better via whatever changes seem appropriate, without worrying about what your official api is and what changes break it. Has been my experience. Developers in much of the volunteer-driven ruby ecosystem would rather spend their brainpower and time in other places (generally in 'innovation' instead, changing everything all the time to try and be better). * Especially because backwards compat disproportionately benefits users who _aren't_ the main developers of the project. Much ruby open source is developers writing something they need for their own projects, and then sharing it, everyone wins. But when it comes to backwards compat concerns, the developers need to spend the (unfun) time, for something they personally don't need all that much. The committers/main developers know the code like the back of their hand anyway, they can easily adopt their own projects to take account of the backwards incompat they introduced (if they couldn't, they might not have introduced em!). It's a trade-off, there are plusses and minuses. Personally, I wish it was more typical in the ruby eco-system to care quite a bit more about maintainability (which includes but is not limited to caring about semver and/or backwards compat). I do think it's moving that way a bit. Which is probably inevitable as the products in the ecosystem mature. But we can cause each other either more or less horrible pain and frustration as we move towards that perhaps inevitability. :)
What has been your experience filing such bugs? Obviously it depends on the project and the maintainers. But mine has been responses like: * That doesn't count, what you were doing I don't consider part of the official api. (Which may or may not be backed up by any docs) * Yeah, I guess that was bad, sorry about that. (it may or may not continue to happen). But in almost no cases has the the response been what it would be if you actually took semver seriously: * Yank the gem, release a new one with incremented patch number that restores the backwards compat. Which is what semver.org even says (although now looking at it, I'm confused/surprised to see the doc saying release it as a new minor version, not a new patch version? That seems odd.) "As soon as you realize that you've broken the Semantic Versioning spec, fix the problem and release a new minor version that corrects the problem and restores backwards compatibility." Occasionally I've seen people respond to backwards compat breaks by releasing a new version that restores backwards compat asap. But very very rarely. 
http://olabini.com/blog/2007/07/some-jruby-tricks/ - Looks pretty close, you get an AST out of it
TIL about versioning and semver. I wonder how many of these gems and situations with this issue are caused by people who are not formally trained, and don't have any concept of versioning best practices. I'm someone teaching myself to program, and haven't gotten to any of that stuff yet. Odds are I'd likely be able to write my own gem before I learned the formal best practices for that because my focus is on "knowing how to make program X do Y" and not necessarily the best practices that go along with it. On that note, I wish I knew of some good resources that go over the BASICS of development best practices that might be language agnostic. Things like semver, and commenting formats, etc. Just general good programming approach/process. Online tutorials like Codecademy, etc. rarely focus on that--it is more about learning how to make the language do whatever you are trying to accomplish.
awesome! I'm glad you found it useful.
This reminds me of [iPlayer for Kindle](http://www.frisnit.com/2011/07/07/iplayer-for-kindle/).
Talking about [these other injection attacks](http://guides.rubyonrails.org/security.html) (chapter 8) plus anything else that has cropped up in the past 4 years or whatever since this has been written. There shall be normal words, with perhaps the extra colons and forward slashes that make up a normal (non-interactive) URL. That is all, and I would like some way to make sure absolutely nothing else gets through. 
Side information: I originally worked on some bindings for GTK3 but quickly realized there was no way of me doing this on my own. A while ago the ruby-gnome2 team asked if they could take over the Gem so they could use it for an upcoming GTK3 binding. A binding they apparently released much faster than I expected so kudos for that!
Check below. I have solved this problem, and it had nothing to do with unexpected nils. Thanks for your input! :)
The tutorials are not intended to supplant the great introductions to Rails we already have (including Michael Hartl's book). Rather, they are intended as a next step for developers who are gaining proficiency. That seems to be an underserved niche.
I'm looking this over after reading the blog post. Sounds good. I finished Michael Hartl's book (which was excellent) and had a good place to start, but then once I started to try looking up more stuff, that didn't quite fit the same paradigm of the examples in his book, things got a little hacky and trial and error.
That's what I've heard from many people starting out with Rails. The next step in gaining proficiency seems to be building real world web apps that use the techniques (gems, structure, etc) commonly used by experienced developers. The big challenge is finding up-to-date, current example applications and that's what we're trying to deliver with the RailsApps project.
Cross-posted to /r/programming: http://www.reddit.com/r/programming/comments/16zu7d/use_gifs_in_your_pull_requests_for_good_not_evil/
This is awesome! I was able to combine scheenms's, fogeyman's, and burke's suggestions to get a 100% free solution, that actually produces good looking gifs. I wrote it up in this gist: https://gist.github.com/4627207
yeah, see, there's no way to do that. 'Normal words that can't be used in any kind of injection attack at all.' There's no such spec for that. It's not possible to enforce that. That's what I'm saying here. You need to consider each context of possible attack, and guard against ones relevant to your application in the appropriate way for each one: SQL injection different than HTML injection different than CSS injection, whatever. There is no generic answer to the question you are asking, if someone suggests there is, they may not know what they're talking about. 
I'm able to build the gems, but simply "require 'gtk2'" or "require 'gtk3' crashes ruby. This is the top line in the crash report: (process:47179): GLib-GObject-CRITICAL **: gtype.c:2720: You forgot to call g_type_init() Bummer.
There's no regex to test if a string is a sql command or not? 
Hum, I'll see if I can find some time this weekend to play with this. Thanks for the post.
Good luck looking for problems where they don't exist. if you will look hard enough, you may be able to find "discrimination"...
Woohoo. Been waiting for these for a while now. 
Question for you...I'm a relative novice, and initially started trying to learn Rails, but decided to take a step back and get a decent understanding of Ruby and OOP first. Since then I've been reading the Pragmatic Programer's "Learn to Program" book which I've found really easy to following and paced at a good speed for me. But I'm almost done with the book, and ultimately wondering "where do I go next?" My aim is to be able to create a dynamic web app (not just a static website), and while I can hack my way around Wordpress, know some JS and PHP, etc, I feel like Ruby is the first programming language that has somewhat clicked for me. I'm wondering if at this point I should focus on more Ruby-related stuff, or whether I can take the plunge into Rails. So my question is--would this be a good place for me to go next? Are there other resources that are a better stepping stool up to this level? I feel like there aren't any good explanations of how to logically progress in a self-taught manner from the basics to the more intermediate stuff in terms of topics I need to learn about, etc.
I stumbled upon this a few days ago. It has been *greatly* beneficial for figuring out how best to implement Stripe with Devise (plus cancan). It has saved me a hell of a lot of time for only $9. My ONLY negative comment would be that the PDF I got (rails-stripe-membership-saas) shows glyphs where ' or " would be and any lines of code that would normally wrap are just cut off. Given that the source code is available, this hasn't been too hard to work around. Screenshot displaying both the glyph and line wrap problems: http://i.imgur.com/No0O3HY.png (This occurs in both Preview for OSX and Chrome). 
A) Um, no, there's not such a regex, because SQL is not a regular language. B) Checking for if a given string is a valid SQL statement on it's own actually isn't the way to defend against SQL injection attacks anyway. C) My point is you keep going back and forth on whether you are just talking about SQL injection, or if you are talking about _any kind of injection attack_. But, YES, there are clear ways to guard against SQL injection attacks (although the right way to do this usually does not involve a regex). What there is not is any general purpose "Just make it plain old 'normal words' that can't be used for any kind of injection attack at all". To my reading, you keep changing your mind about which thing you are asking for. But I've tried saying the same thing multiple times now, we just keep going back and forth and around in circles. This conversation has probably no chance of being useful to anyone any longer. Perhaps I misunderstand your question, or am misunderstanding the situation, or am just very bad at explaining what I mean, or maybe I'm wrong. Apologies I haven't been able to be helpful. Good luck to you! 
I sent you a pm, let me know if you'd still need help.
Michael Hartl's book is the best place to start to learn Rails. It's a point that is debated, but I don't feel you need to learn Ruby in depth to begin learning Rails.
I have a consultant who delivers code to me in svn. I use this to auto-sync it up to github.
that's because `defined?` isn't actually a method, it is an operator. One cool thing is that things like `defined?(Foo)` and `defined?(foo)` don't raise exceptions for non-existant items (this is also why the parenthesis are required for `defined?`)
https://github.com/nirvdrum/svn2git
I would just use git-svn, but kudos on solving the problem and open sourcing your solution.
I'm on a Mac, and didn't see git-svn in brew, so I just rolled it myself.
Nice initiative, other than the cleaner UI whats better compared to ruby-toolbox.com
That is the most strenuous list of rules I've seen; dare I say, almost a bit ridiculous. I'm all for code standards, but there comes a point when they're more hurtful than helpful.
Assuming your security patches are up to date, what's wrong with dynamic finders?
Self-reply: It turns out the problem was to_liquid was defined in date.rb and it overrode the plugin's own to_liquid.
[Submitted for your approval](https://github.com/thoughtbot/guides). I work for thoughtbot and find these very helpful, actually. These guides are more pragmatic than dogmatic and that's part of the charm.
Yeah I got about 3 suggestions in and found it to be overly restrictive. Especially the part about methods being no more than 5 lines
The tutorials are probably out of date because the last IronRuby release was almost 2 years ago. I was under the impression the project was dead. That doesn't mean you can't use it though.
They're quite slow, as most things that whack method_missing are. Maybe it's not an issue for your app at this stage but I just had to go through and replace them app-wide recently because they were showing up as a hotspot in a profile trace. You could argue not using them is a premature optimization, but :where is just as expressive and undoing dynamic finders can be rather painful.
Also, they are being deprecated in the rails 4.x path. If you're starting a new app, this could make the upgrade process less work. **EDIT: I think this is incorrect. See the rails 4 release notes:** http://edgeguides.rubyonrails.org/4_0_release_notes.html#active-record-deprecations Even some of rails core is confused about this. I suspect this confusion stems from 2 things 1) a lot of blog posts out there claiming full removal 2) the fact that the api seems like it's being *partially* deprecated
**tl;dr**: read the comment or get the hell out. Maybe it's me but the limitation of lines in a class, method or module (or basically every other data/logic container) is completely retarded and way too broad. There seems to be a trend lately where primarily Ruby developers (I simply don't know of this being true in other communities so feel free to inform me about it) have the idea that the amount of lines equals bad code. You can't just say "This method has 10 lines instead of 5, it's shit.". There are in my opinion two reasons why the amount of lines is not directly related to the quality of code: 1. The line wrapping style of a person might affect the amount of lines even though the amount of logic ("true lines" or whatever you'd call it) doesn't get any bigger. More on this in a bit. 2. When using statements such as an `if` statement you can easily end up with 3-5 lines of just the statement and maybe some whitespace. The typical response would be "ZOMG ADD A METHOD!". Yeah no, that's in a lot of cases a total overkill that's only going to make things harder. So lets talk about line wrapping. Wrapping lines is done to ensure that no matter what application or device you view your code in it's always readable and presented in the same way. However, if you wrap your lines properly you'll typically end up with more lines of code. Looking at the rule of "No more than 5 lines per method" this basically means you either have to start using shorthands for names, not wrap lines at all or add a handful of methods of which in most cases it doesn't really make any sense to add a method in the first place. Lets take a look at some actual code of mine: def define_parameters [ @parameters, @optional_parameters, @rest_parameter, @more_parameters, @block_parameter ].each do |params| next unless params if params.is_a?(Array) params.each { |param| add(param.type, param.name, param) } else add(params.type, params.name, params) end end end Due to this block of code being defined 3 levels deep in a module (RubyLint::Definition::RubyObject) I had to wrap the array onto multiple lines to keep things readable. Yes, I could've added a method but there's no point to it since the Array is not re-used anywhere else in the code and most likely never will be. Either way, simply because of the way I wrap my lines (I've found this to be the most efficient way of saving up horizontal space) I already have 7 lines of code in my method and it doesn't even do anything yet. To make my examples a bit easier to understand let's call the "true" amount of lines (lines where something actually happens) the "true line amount" (how original). In the snippet above the true amount would be 8-10 (depending on if you count the `each do...` block and whitespace as a separate line). Based on the rule of "No more than 5 lines per method" this would mean that the method is "bad" even though it's perfectly readable. The same goes with classes. The guide doesn't mention whether or not whitespace and comments are excluded. If you write such a guide you really **should** mention something about it, a guide that's way too broad is no better than no guide at all. Lets assume the author is sane enough to exclude that, even then it's pretty hard to stick to 100 lines per class and again it means very little about the quality of the code. For this statement, lets take a look at some other code of mine: https://github.com/YorickPeterse/ruby-lint/blob/refactor-ast/lib/ruby-lint/parser.rb. This is a parser using Ripper, the effective amount of lines excluding comments and whitespace is 361. According to the guide this would be wrong, even though each method in it is actually pretty easy to understand maybe with the exception of `#on_massign()`. The only way for me to reduce the amount of lines to fit in the guide/standard would be to break things up into modules. Because none of this code is re-used anywhere else (it simply doesn't make any sense to do so) this would serve no benefit and in fact could possibly make it a lot harder to find where a particular method is defined. Having said all that I can, in the back of my head, understand what the author is trying to get at. Generally a large amount of lines *can* indicate that something odd is going on. However, you can never base the quality of code purely on the amount of lines. Instead you **always** have to look at what's actually going on. A `case` statement with 10 `when` statements taking up 30 lines of code? Yeah, that's a big ugly even if the body of each `when` statement is only a few lines (note that I'm generally not a fan of `case` statements, polymorphing is usually a lot better). The guide would be a lot better if it were to explicitly define all these edge cases. Sadly, as many others before, the author has not mentioned any of this. A programming standard/guide is only as good as explicit as it is. It's like saying "USE 2 SPACES!!!!!" and then assuming people know that they shouldn't use spaces for Make files because that doesn't work. To cut a long story short: if the author had a more in depth description of how to approach the line amount problem and actually had some research to back the mentioned about up with it wouldn't be so bad. However, in the current state I don't see this guide being very useful other than serving as a very rough and broad set of guidelines.
git-svn is built into git. &gt; git svn &gt; git-svn - bidirectional operations between a single Subversion tree and git &gt; &gt; Usage: git svn &lt;command&gt; [options] [arguments]
5 line methods? ...wat Seems a bit overly restrictive.
Do you know if any of the thoughtbot guides refer to guidelines about sharing data between the controller and the view? I'd like to see how you all prefer to handle this. I've seen stuff like controller methods exposed as helpers, decent_exposure, context instance vars that wrap related objects, and the like but, I'd love for some more pro opinions on that. The "1 instance variable per view" guideline I see pop lots of places would be useful if they were provided with more context; pages not being a simple crud representation of 1 resource don't immediately map to this in an obvious way. There's widgets/sidebars, contextual menus, tip sections, etc etc that all often don't necessarily tie to the resource at hand. I know a bunch of solutions but nothing has felt quite satisfying. edit: I'm gonna go back and check the old anti-patterns book too, it might address this and I have forgotten.
I installed IronRuby 1.1. Could someone help me resolve my project's build errors? http://stackoverflow.com/questions/14541631/several-errors-and-warnings-for-ironruby-c-sharp-windows-phone-app
I believe the length limits are related to cyclomatic dependency. Whether you buy that as a useful metric is a different matter. That aside, I think the length choices here were arbitrary rather than being driven by any real data. I.e., my take is there is a founded idea around this that most people haven't really learned and then parrot with loss of detail.
There's that, too. My app was originally a 2.3 on that's been updated over the years. I actually just found a case of :find with a conditions hash. Oops.
The problem is that if you're going to make such decisions, especially if they're quite "radical" you'd have to be able to back it up with information as to why instead of just saying "This is the way it is, deal with it".
I personally stick to one instance variable in almost all cases. If I have multiple things that need to go from controller to view I package them up into a purpose-built struct that can more or less transparently evolve into a view-model/presenter/whatever-you-want. Actually I have *two* of those. One "for the response" and another "context" to supply cross-cutting information that is generally always needed (current user, subdomain/account we're using, etc). 
Actually if you look closely he does back up those guidelines by saying they are based on Sandy Metz's Ruby Rogues presentation, which I believe is backed up with info in her book, Practical Object Oriented Design in Ruby. You may not like these opinions but there actually is a reasoning behind those particular guidelines.
Before everyone gets too excited about the "rules" listed in the repo, you should have a listen to the source of them so you understand the context. http://rubyrogues.com/087-rr-book-clubpractical-object-oriented-design-in-ruby-with-sandi-metz/ In short, these are just things to aim for if you're looking for some general guidelines to help manage large projects.
SugarJS is already pretty popular, seems like a bit of overlap.
What would you suggest instead?
I'm on Linux. Why not?
Should cross-post to /r/rails.
&gt; The rules are *purposefully aggressive* and are *designed to give you pause* so your app won't run amok. It's *expected that you will break them* for pragmatic reasons... alot. 
Not sure if you're kidding but... [https://github.com/rails/activerecord-deprecated_finders](https://github.com/rails/activerecord-deprecated_finders)
&gt; The rules are purposefully aggressive and are designed to give you pause so your app won't run amok. It's expected that you will break them for pragmatic reasons... alot
It's dynamic. It's not compose-able. Using `where` in all case makes for more consistent code.
&gt; The rules are purposefully aggressive and are designed to give you pause so your app won't run amok. It's expected that you will break them for pragmatic reasons... alot.
(disclaimer, I was the SDET at MS on IronRuby until right after the 1.1 release). IronPython is still pretty active, so it might work. For IronRuby, you may be able to get it going by building from source. Tomas (the dev) was still working on it last time I checked (https://github.com/ironlanguages/main), but since that will no longer be code signed by MS, it may not work on the phone. 
Relative to most other things in the stack it hadn't been a bottleneck for me for a while. Maybe it's been exacerbated by my move to JRuby, which has largely sped most things up.
Since switching to Ruby I've written mainly super short methods but seeing it as a guideline seemed weird.
Yeah, I re-read it and noticed that but missed it initially when I scanned through to see the guidelines
Could you try to install the audite gem after installing libportaudio-dev and libmp123-dev packages?
:( $ gem i audite Fetching: audite-0.1.4.gem (100%) Building native extensions. This could take a while... ERROR: Error installing audite: ERROR: Failed to build gem native extension. /home/me/.rvm/rubies/ruby-1.9.3-p194/bin/ruby extconf.rb checking for portaudio.h... yes checking for main() in -lportaudio... yes creating Makefile make compiling portaudio.c portaudio.c:35:23: error: unknown type name ‘PaStreamCallbackTimeInfo’ portaudio.c:36:23: error: unknown type name ‘PaStreamCallbackFlags’ portaudio.c: In function ‘rb_portaudio_new’: portaudio.c:73:30: error: ‘paCallback’ undeclared (first use in this function) portaudio.c:73:30: note: each undeclared identifier is reported only once for each function it appears in portaudio.c:74:30: error: too few arguments to function ‘Pa_OpenDefaultStream’ In file included from portaudio.c:3:0: /usr/include/portaudio.h:355:9: note: declared here portaudio.c: In function ‘rb_portaudio_start’: portaudio.c:116:3: warning: ISO C90 forbids mixed declarations and code [-Wdeclaration-after-statement] portaudio.c: In function ‘rb_portaudio_stop’: portaudio.c:131:3: warning: ISO C90 forbids mixed declarations and code [-Wdeclaration-after-statement] make: *** [portaudio.o] Error 1 
Great! You're probably the first person running this gem on Linux since I haven't had the opportunity yet to try it out.
Ubuntu 12.10 $ aptitude show libportaudio-dev Package: libportaudio-dev State: installed Automatically installed: no Version: 18.1-7.1 Priority: optional Section: universe/devel Maintainer: Ubuntu Core Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt; Architecture: amd64 Uncompressed Size: 106 k Depends: libportaudio0 (= 18.1-7.1) Suggests: libportaudio-doc Conflicts: libportaudio-dev Description: Portable audio I/O - development files PortAudio is a portable audio I/O library designed for cross-platform support of audio. It uses a callback mechanism to request audio processing. Audio can be generated in various formats, including 32 bit floating point, and will be converted to the native format internally. This package contains the development files. Homepage: http://www.portaudio.com/ 
Is it expected behavior to throw an exception when the mp3 ends?
No, could you post the backtrace?
Great, portaudio changed the signature of the callback function in version 19. Let me see...
Could you try again? I pushed gem version 0.1.5, which supports portaudio &lt; 19 and ruby 1.8.
http://pastie.org/5875335
You ran it from irb, right? Did you press Ctrl-C?
Interesting, are you on pulseaudio?
Could you try to use the portaudio19-dev package?
Yah, I'm on PA. I tried installing portaudio19-dev but it said a bagillion dependencies would get messed up and I don't want to spend hours fixing it all. Doing some quick googling it does look like portaudio 18 and pulse don't mix. I'll just have to play with audite on my arch machine at home :)
Yes from irb, no I did not press Ctrl-C
I'll try it on Ubuntu 12.10, when/if I get out of bed.
Did you read the notes/code? The two basic finders aren't deprecated. 
You had performance issues where finder overhead was noticeable next to the db call? I'd like to see more info on that. 
Sure, but the cost of method_missing isn't *that* high. It's a second-pass variant of regular method resolution, so it really depends on the size of your class/module hierarchy. Even then it takes an amazing amount of modules (roughly 600 using MRI 1.9.3p125 on my shitty laptop under less-than-ideal-benchmarking conditions) to see even a full millisecond of overhead from a single method_missing based method resolution. I can see something like xml builder causing a headache since it does nothing *but* abuse method missing, but I'm having a hard time seeing how one method_missing call even stands out next to the resulting db query. That's what I'd like to know more about.
Pragmatic is totally key with this stuff, yeah, but you also want some starting ground that's reasonable too. To me, for example, five lines in a method is not reasonable; just about everywhere I've ever read has said 30. While in many cases 30 lines in a method may be a lot, there are some cases where it's OK. All in all, style is, however, a matter of preference, so if those rules fit what you're doing the best, great--it just seems a bit restrictive to start with. FWIW, there was a time where I spent tons of time looking for this info, as I was starting out writing https://github.com/turboladen/tailor (a style/static analysis tool for Ruby in need of some repairs) and started a list of links to this type of info, just to round up some commonalities to the community: https://github.com/turboladen/tailor/wiki. I added your link to the list.
method_missing avoids method caches in all Ruby implementations, AFAIK. And it won't JIT (kinda, but not really), so it gets relatively slower to the rest of a running system over time. Yeah, one call is inconsequential. But this was happening all over the app. And the DB situation gets murky with query caching. I measured by profiling a production system while it ran. Unfortunately, I can't really share that. Making the change removed the hot spot and cut my spec execution time by 30% pretty regularly. Both were big gains for me. But saying "don't bother optimizing Ruby because the DB is slow" is a tenuous argument. It's not like the DB is accounting for 90% of my page load. That kind of thinking seems to have given many Rubyists carte blanche to never optimize anything and then just fall back into caching. I've seen rather substantial gains by avoiding unnecessarily slow paths like method_missing and exception handling in non-exceptional cases.
Sorry, I guess I should have been clearer. I wasn't profiling a single method or controller action. I was profiling my entire app as it ran in production. And I gave it enough time to stabilize, so method calls should be hot. System-wide, I saw method_missing from dynamic finders as a hot spot (it was number 5 or 6 -- not at the top, but high enough to warrant investigation). Swapping it out had big gains for me. But, yeah, that's tied to my app size. My initial point was at a small scale it almost certainly doesn't matter. But about the time it starts mattering, you've got dynamic finders scattered throughout a decent-sized codebase and the cost of replacing goes up substantially. So, not using them could be considered a premature optimization, but the opportunity cost should be factored in. For me it wasn't even an option because this app was originally Rails 2.3 (now 3.2) and Arel didn't exist at that time.
I'm going to read the code again, yeah. I'm confused now. I've seen a ton of articles claiming all find\_by\_* are deprecated, and there's [this commit](https://github.com/rails/rails/commit/637a7d9d357a0f3f725b0548282ca8c5e7d4af4a) for example where dynamic finders are getting swapped out, but the Rails upgrade guide for upgrading to 4 says 'All dynamic methods except for find\_by\_... and find\_by\_...! are deprecated' edit, wow, even rails core guys are confused: [https://github.com/rails/rails/pull/8989](https://github.com/rails/rails/pull/8989) given they reverted the commit and the guide, I'm gonna go with "they aren't deprecated now". Confused as hell.
&gt; I would suggest you stop developing in windows. As much as I hate Windows and the associated dev tools, I hate the idea of cutting off my users from a major platform. No, the hassle of using per-platform programming languages is excruciating. I plan to use a highly crossplatform programming language, such as Ruby, to solve these two problems. IronRuby simply needs more love.
Mobile apps that are truly cross platform are written in HTML5. And they usually don't work/look that well on either platform. There's also Mono Touch (mobile .NET for *nix) for iOS and Android but I'm not sure how strong an alternative that is. 
MonoTouch is nonfree.
Seems to me like you've got your answer right there. Developing for Windows Phone is a hassle. 
[Pull request](https://github.com/georgi/audite/pull/5) to fix Debian install instructions and add basic rspec tests sent.
Interesting, out of curiosity, could you tell how fast it went?
There exists a site that lets you play with ruby regexp: http://www.rubular.com/ It does not really teach you, but gives you a really nice interface for trying things out. For learning, I would point to http://regex.learncodethehardway.org/ ... but it's very much a rough draft right now, so maybe read a chapter or two to see if it will work for you?
+1 for rubular. While it doesn't teach you, it does have some info on the botoom and some links to tutorials. It reallys helps in that you can see what you're doing wrong versus the actually ruby script which just fails to work.
I would suggest grabbing a random paragraph off of some site, some html of a site, and a list of almost similar items (maybe addresses?). And then pick a certain point in the text and try and isolate that part. If you have a goal in mind, you can learn how to work with real-life examples.
Really cool. The "playoff" made me laugh cause I know how frustrating speech recognition can be, but nice job otherwise. Now I just need to find an arduino. And an iphone. . .
Thanks, man. Fortunately, the iPhone 5 includes 3 microphones on it, in order to calculate &amp; remove background noise. Damn iPad...
FYI: Accompanying blog post can be found here: http://nicoritschel.com/Commanding-Arduino-with-Siri-via-Ruby.html
Has the SiriProxy code improved any in the last year? Last I checked it had multiple forks each with no support, was littered with global variables, was terribly factored and had no tests. I tried for about a week but had to give up on working with it.
Sadly, nope. I set up a fork and plan to write up some end to end directions (for OS X) that are more up to date. I considered refactoring things a bit, as well. I may take that up as a side project.
Could you provide a code example of this?
One line methods? What's the point, other than abstraction for abstractions sake?
They requested ownership on January 15th, by then they probably already had a working binding but just hadn't made it publicly available yet.
Using IronRuby is not insane. Porting a codebase to three inoperable languages is insane. Yes, I'm using JRuby for Android. JRuby is decent. If you can point me to a way to get JRuby working on Windows Phone, that would be great. Otherwise, I'll keep hacking at IronRuby.
&gt; Does it make the code easier to read or to maintain? In my opinion, it does. It's easy to start pushing behavior-ish things down into the view with special purpose boolean variables. This gives you somewhat subtle rendering differences based on what those variables are set to. Then when you go to share view code with partials you end up with things that seem to work but are subtly wrong in ways that you might not see immediately. Up to a point, this is fine. "Just shut up and deal with it" is often the appropriate technical solution to a problem, albiet one that we never seem to really enjoy considering. In my mind it's better to wrap all of that complexity into the smallest thing that can comfortably manage it. That tiny one-off class/struct is a perfect place to put your boolean control variables, and making it allows controllers to reuse existing partials by simply knowing that they need to set this thing up. &gt; What is the reason behing the one variable rule anyway? Like most guidelines it's a "rule" that's meant to be broken, prudently. Calling it a rule is honestly too much. It's there to keep bad behavior in check. I go against that guideline all the time, but never without taking the opportunity to stop and consider if I can revise my code to not need that instance variable. &gt; When Rails was designed they intended that all instance variables should be visible to the view. Why go against that? I view Rails as a starting point. It gives solid opinions and proven practices/solutions to common problems then gets out of your way. I don't see a purpose or intent in sharing instance variables between the view and the controller, that's just the easiest solution for simple situations. When things get complicated you're dealing with a situation beyond what Rails' built in solution was designed for, so it's perfectly acceptable to make up new ones.
Sure. Your website is used by a nationwide chain of apartment companies to coordinate maintenance and other upkeep tasks. Among its many features is a map that can be used to look up apartments in need of service. This is used by regional managers (who by necessity are usually signed in to your website) and maintenance workers (who tend to only sign in when they need to update something). The controller to support this currently looks something like this: class ApartmentsController &lt; ApplicationController # gives a @user, but only if they're logged in before_filter :find_user # gives a @location, but only when the geoip service can resolve it. before_filter :geoip_location def index @apartments = Apartment.where(service_needed: true).near_location @location || @default_location end end Now, we can already imagine a fair bit of complicated view logic. Is the user signed in? If not, we need a sign in form. If so, we need to show them something else. Maintenance and administrative users need different tools, so that "something else" is likely to take the form of subtle differences in *many* interface elements. The map starting location likewise has some issues. The whole `@location` vs `@default_location` could possibly be handled by assigning the default to `@location`, but what if the user can override that default? There's not yet anything terribly *wrong* with this example, but it's likely only a few more features away from having problems. If this combination of location/user/apartment is left unmanaged we'll likely end up with view elements that *could* be reused, but are so deeply tangled in this particular use case that it's hard to see. So, enter the minimum viable solution (excerpted from changes to the previous code): class ApartmentsController &lt; ApplicationController ApartmentsPresenter = Struct.new(:user, :geoip_location, :default_location, :apartments) do def manager? user.present? &amp;&amp; user.manager? end def maintenance? user.present? &amp;&amp; user.maintenance_worker? end def location geoip_location || default_location end def default_location? geoip_location.blank? end end # gives a @user, but only if they're logged in That's right, my very first pass at this is to usually just build a struct right there in the controller! Yes that's ugly and gross and awful and I should probably feel bad, but it serves two important purposes: * It makes looking up where this behavior comes from simple. I'm still just working with views and controllers, so my intuition on where to find this thing falls in line with habits that Rails has given me. * It makes it plainly obvious when I'm sharing templates. If I try to reuse some piece of template I now have to write `ApartmentsController::ApartmentResponse.new(...)`. This isn't the instance variable community pool anymore, it's behavior (and views) that are *obviously* geared towards apartments. That scope resolution operator is a clear sign that I need to take a second and think about how things are organized, because I'm likely to violate some built-in assumptions of the view code. I honestly don't worry about putting this in the controller. It becomes incredibly useful very quickly, and tends to grow a bit with that use, so it doesn't take long before you figure out somewhere else to put it. Make sure whatever you do is consistent, aim for a natural extension of the model/view/controller lookup process that Rails already uses. Anyways, we can see right away that this has given us a place to hang some important behavior: * Views don't have to handle the null user case, except for seeing if we need a login. Things specific to admins or maintenance can be guarded with `&lt;% if @response.maintenace? %&gt;`. * The whole merge-location-with-default-except-for-when-we-don't situation is easier. Now things that only care about *any* location can just get it, while things that care about the default-vs-geoip idea have their own tool for that. If/when we add more details to this feature we have a handy place to wedge in more logic. A lot of this could be resolved with view helpers. `ApartmentsHelper` could sprout a `location` method and a `user_is_manager?` method and so on. For this small of an example, that might even be the right solution. That said, I don't really like view helpers for this sort of thing. Helpers are one enormous bag of methods shared across your entire project. It's likely that you're going to step on names, and when you do your only real option is to rename things. You'll be forced to do stupid things like try and push naming conventions into your helpers. In the example if the apartment list and personnel maps had two different ideas of a geoip-or-default-ignorant location you'd get something like `apartment_location` and `personnel_location`, which ends up kind of implying something other than what's actually happening. The bigger problem, though, is that helpers are a poor tool for managing complexity. Inevitably bits of behavior leak in and you end up with a bunch of methods that have no meaning outside of the helpers they support. I want my helpers directory to be a well organized toolbox. Everything in it should be a tool that I can pick up and use directly. Bits of behavior that are only useful to helpers internally are like opening a toolbox and finding a bunch of empty handles mixed into it. Handles are useful things, but they don't belong in a box of tools by themselves. Sorry for the book, hope that gives you something to think on.
I think this applies for the same rule in iOS using objective-c vs RubyMotion, and what your app requires. Do you need a native app? Can you do something without issue just in the web as @enroxorz suggested? If you need something native, I'd recommend using C# or whatever you prefer to make a native application, rather than looking at a bridge. I'd also suggest this for iOS as well. The reason being is when new APIs come out, you'll have access to them right away, you can be more assured that a new version doesn't break something like RubyMotion. 
I would love to see that somebody would reveive IronRuby! Any volunteers out there? ;-)
That's a fair point. But it's nice to be able to do work when/where Internet access is unavailable.
I hate to be "this guy" but when would a Windows Phone not have Internet access?
Thanks, I would love to &lt;3
I see your point. This is a tough one since Windows Phone isn't popular enough for cross-platform tools like MonoDroid or RhoMobile aren't writing for it (yet). Maybe look at [PhoneGap](http://phonegap.com/) as an alternative? Best suggestion would be to use C#. Sorry I couldn't help any further.
Heh, I only have an Android, and an old HTC Trophy / Windows Phone 7 with a cracked screen that a friend gave me. Fortunately, emulators are available for all these devices, and they're fairly feature complete.
RhoMobile has templates for WP7 and WP8, but they don't work with VS 2012 for Windows Phone. It's like the developer world is stuck in 2012 while the hardware world has continued on into 2013. Yes, PhoneGap is an okay compromise. But JavaScript is undesirable for its own reasons, and Adobe worked deliberately so that PhoneGap apps would NOT look native.
They've gotten better, but in my front end web work, i had so many problems with them. It doesnt give you the feel at all. I'd more likely look into one of those device hubs where people share devices and you can test.
TIL RhoMobile had templates for that. Thanks.
A bit off topic, but yeah, I understand.
The example in the README was slightly stupid, updated it to just print the the complete event instead of exiting the process :)
From my understanding it shouldn't change any dependencies since portaudio19-dev is a seperate package, but I might be wrong.
Here's a thorough article about regular expressions in Ruby: http://webcache.googleusercontent.com/search?q=cache:ruby.runpaint.org/regexps (via google cache, sorry site is down atm)
The intent is very clear in short methods.
Html offline modes and something like sencha mobile let's you get the best of both worlds 
Thanks for this post. I've been trying to get into threaded ruby applications more, and this seems like a good introduction.
I think it could be done with less. Why bother trying to support older frameworks, for starters? In the web space, you're not busily trying to work out how to support IE 1.0 In fact, you probably don't even support IE6. We don't even really support IE 7 any more. It's OK to say "here's some cool stuff, yo. But it only works on bling younger than 12 months". Except, you know, don't be so obviously a white, middle-class, 30-something, English male like I just was there. Point is this: we spend too much time worrying about supporting "legacy". Microsoft put billions into it. Move forward, don't look back... ... and I am 90% certain that you can therefore reduce the list to: * Ruby * .NET 4.0 bytecode stuff * Old IronRuby (but barely - take the principle and start anew) * Current VisualStudio * Latest phone SDKs * How Ruby compilers/interpreters work Ignore what exists, go with an ideal World based on the latest tech, and start there.
I had no luck getting it running, sorry.
To the best of my understanding, Lambdas in ruby are the same as using blocks. But I'm not 100% sure on this.
http://www.robertsosinski.com/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/
I think the best ELI5 is just don't use procs.
Basic pattern for proc: stuff = Proc.new {|b| b.to_s} stuff.call(112312) Lambdas can be used for things like ActiveRecord finders: class Customers scope :subscribed, lambda {|some_date| select("subscribed, start_date").where("subscribed = :s AND start_date &gt; :d", {:s =&gt; true, :d =&gt; some_date ) } end then you can do Customers.subscribed(DateTime.now) 
I hate to be that guy, but…why? I mean, yeah, its a great tool and has a good execution, but…why? When there are things like Markdown, Textile, Creole, or even MediaWiki syntax, why would you want to use BBcode?
Lambda's are like itsy bitsy functions, while procs are like an enclosed block. Let's illustrate this, in Ruby 1.9.3p194... irb(main):002:0&gt; myLambda = -&gt;(x,y) {x + y} irb(main):003:0&gt; myProc = Proc.new {|x,y| x+y} irb(main):006:0&gt; myLambda.call 1,2 =&gt; 3 irb(main):007:0&gt; myProc.call 1,2 =&gt; 3 irb(main):007:0&gt; myProc.call 1,2,3 =&gt; 3 Pretty simple, they actually look the same right? Well except for being able to just add in more arguments to the Proc. Let's look a bit longer at that point... irb(main):049:0&gt; myProc = Proc.new {|x,y,*args| [x,y,args]} irb(main):050:0&gt; myProc.call 1,2,3 =&gt; [1, 2, [3]] irb(main):051:0&gt; myProc.call 1,2,3,4 =&gt; [1, 2, [3, 4]] irb(main):054:0&gt; myProc.call 1 =&gt; [1, nil, []] irb(main):006:0&gt; myLambda.call 1,2,3 ArgumentError: wrong number of arguments (3 for 2) So Procs don't very particular about their arguments, while lamdba's are. But what about default args? irb(main):070:0&gt; myProc = Proc.new {|x, y=5| x+y} =&gt; #&lt;Proc:0x00000100b43cb8@(irb):70&gt; irb(main):071:0&gt; myProc.call 1 =&gt; 6 irb(main):072:0&gt; myProc.call 1,2 =&gt; 3 irb(main):076:0&gt; myLam = -&gt;(x, y=5) { x+y} =&gt; #&lt;Proc:0x00000101838950@(irb):76 (lambda)&gt; irb(main):078:0&gt; myLam.call 1 =&gt; 6 irb(main):077:0&gt; myLam.call 1,2 =&gt; 3 At some point there may have been a difference in default arguments, but in 1.9.3 at least there doesn't seem to be. Ok so what about using return in Procs vs lambdas? irb(main):001:0&gt; def f_proc irb(main):002:1&gt; returnProc = Proc.new {|a| return a} irb(main):003:1&gt; returnProc.call 1 irb(main):004:1&gt; 2 irb(main):005:1&gt; end =&gt; nil irb(main):006:0&gt; f_proc =&gt; 1 irb(main):007:0&gt; def f_lam2 irb(main):008:1&gt; returnLam = -&gt;(a) {return a} irb(main):009:1&gt; returnLam.call 1 irb(main):010:1&gt; 2 irb(main):011:1&gt; end =&gt; nil irb(main):012:0&gt; f_lam2 =&gt; 2 Ok so Proc's with returns in them will cause a return in the function scope while lambda's will only return from the lambda. But what about transformers? irb(main):046:0&gt; def caller(&amp;block) irb(main):047:1&gt; yield("Function") irb(main):048:1&gt; end =&gt; nil irb(main):049:0&gt; h=caller {|a| p "Hello #{a}"} "Hello Function" irb(main):041:0&gt; def proccer(&amp;block) irb(main):042:1&gt; block irb(main):043:1&gt; end =&gt; nil irb(main):044:0&gt; h=proccer {|a| p "Hello #{a}"} =&gt; #&lt;Proc:0x00000100ac1448@(irb):44&gt; irb(main):045:0&gt; h.call "Person" "Hello Person" What? when I send a block to a function it can be used like a Proc? Isn't that great? That's the big things I know about at the moment, feel free to ask more questions.
If you happen to be adding a forum to an existing ruby webapp, BBcode would be the de facto markup to use. I don't know of (m)any "traditional" forums that use Markdown.
Does anyone else find the syntax here really jarring? pages[uri: '/'] Even more so: pages[[published: true]]
Upvote, but plenty of users do mysteriously use Windows XP, for example.
I think there's a lot of potential here, but doesn't it seem a bit odd to be searching an array rather than restricting your database query?
Definitely. I immediately was like.. this is a thing I need... then looked at the examples and was confused.
No.
Hmm, I don't believe so. This adds functionality to the enumerable object that contains a collection of other objects like individual `ActiveModel` instances. I guess some of the features make it similar to `ActiveRecord::Associations::AssociationProxy` like the dynamic attribute based finders e.g. `find_by_whatever` or `find_all_by_something`.
Oh ok, cool. I'll have to play with it
Not exactly what you asked for, and perhaps not the greatest example, but here is a pattern I've been using lately. def f(mode) modes = { mode_a: Proc.new do some_work end, mode_b: Proc.new do some_other_work end } raise Exception.new "invalid mode" unless modes.has_key? mode.to_sym modes[mode.to_sym].call end I typically use this when in want to be able to add functionality without investing a lot of time in designing a robust API, and can be mixed with method_missing magic to produce an ad hoc API. It's useful when I'm taking input via a CLI; I can avoid a bunch of case or if statements to choose which methods to call; I just send the input to #f This might well be an anti-pattern though :) 
+5 for wit, while being completely un-helpful for the OP trying to understand the subject
Well, your decision. Just saying the facts. Not everything has to be done it ruby.
But a block is a proc...
http://betterspecs.org/ +1 for Eloquent Ruby
It is an (answer which does not address the question) and (unwanted advice), all in one. Lambdas and procs are complex enough to disallow use without any understanding. Note, I am not telling you what to do, just pointing out that while witty, the reply does not provide help where it was requested. "How can I boil an egg?" "If you don't know how to boil an egg you shouldn't be boiling eggs!" 
Thank you for doing this. You make Ruby easier to scan. I wish you were my future coworkers.
I just mix Liquid templates and Markdown. This seems to have served me fairly well. Yeah, there are a few hairy edge cases, such as fenced code blocks, but you can manage by adding a regex that wraps them in `{% raw %}`
my facebook sign up fails... google sign in works!
I like the timed quiz. its a nice exercise. p.s use a less pixelated rails logo...
hrmm multiple choice exercises don't review wrong answers and don't give a chance to redo...
I actually like the idea of your gem, it might come in handy. However, I can't see myself ever using the shorthand. `find_by` is enough to make this useful. I like it when people redefine the `[]` method to do cool things, but when it's no longer used for selecting discrete values from a set, but something more "fuzzy", I have an issue with it. Just my humble opinion.
cool:)
That's cool and all but why is this in /r/Ruby?
I dig it.
Agreed, `find_by` and `find_all` is definitely more clear about what it's doing. I'm using this gem to search/filter thru collections of objects inside of templates so I wanted a condensed syntax to use in those cases to save space. I figured there'd be plenty of people that shared the same opinion as yours so it looks like separating features into their own modules is going to come in handy. If most people feel the same as you then maybe I won't include the `Shorthand` module by default.
Ouch, it's been a rough month for Ruby/Rails security. 
This happened in late 2010 when Ruby fell from #1 to #2 (overtaken by JavaScript). Some discussion from the time: http://news.ycombinator.com/item?id=1985775 It's pretty cool Ruby has retained its #2 position though given GitHub's growth outside the Ruby space.
Looks like Rubygems is back up and running now: http://status.rubygems.org/
they are still auditing. Also, as a side result of this heroku ruby deploys are still locked out.
Iam wondering how to check if I have installed any compromised gems?
It was my understanding that Rubygems solution while auditing was to take down the push api. It looks like it's up from that status page. I'm not sure why they would re-enable the pushing of gems before the audits are complete.
yeah me neither, but I can tell you from the irc traffic, they are still checking checksums, etc.
It was unexpected to be thrown directly into a quiz after the sign-up process. "What is this? Oh neat, I'll check it out... wait, wat? I have no idea what I'm doing!" Sure, there was probably **too much** text before-hand and I just clicked 'Next.' As another commenter stated, it would have been nice to review the questions from a quiz or even retake a quiz. The placement of True and False on the quiz was frustrating as the testing standard is generally True as the top-most response and False as the lower. I definitely missed a couple because I clicked where I expected the response rather than reading them carefully. While I wasn't trying **super hard** as if I were taking an exam, I don't believe using a quiz game should require that exam-level focus. I do like the concept and will be checking back from time-to-time. Good work!
100% good advice. Alas, it wouldn't have helped in this case. The problem was the YAML injection vulnerability that was at the heart of the Rails vulnerability a couple weeks back. It wasn't even Rails' fault this time. The moral of this story is not to use anything as a data transport protocol that gets eval'd on the server side. Most Rubyists probably didn't even know that mainstream YAML libraries did that. I sure didn't.
This wasn't a Rails exploit.
True, and the same rules generally apply... if there are known bugs or vulnerabilities, many people will read about them and then think "fuck it, i'll get round to it later, the site is working fine now so why bother tinkering with it.. i'll just wait until i'm next making changes to implement"... I find that generally you need an 'oh shit' moment before you start getting proactive and take these things seriously. For example.. how many people have iPhones stolen with no password lock on it and no 'find my iphone' app? I'm guessing a lot... That's your 'oh shit' moment - when it dawns on you that even the most basic, simple security measures could have saved you a tonne of hassle and possibly prevented the situation from happening or enable you to rescue the situation... It's so common there should be a law named after it... "should have done's law" 
Upvote for better info. Thanks!
:) case in point... prepare for the worst, don't hope for the best... If I lose my phone, I'm signed in to twitter, Facebook, multiple email accounts, have lots of personal data on it too in notes &amp; reminders... I agree it's hassle to keep having to unlock your phone all the time, but it's like locking / unlocking your car door and hiding your sat nav &amp; valuables... its a habit worth getting in to because one day bad shit will happen and you'll have people like me saying 'told you so'...
sorry newbie - I've never actually looked at how "gem" works. Is rubygems the source for all gems installed with gems? Isn't hashing involved to verify the download (I suppose redundant if the attacker also had access to update any hashes). 
I think I get it now. I guess I assumed there was some way to determine if a string was hazardous in that it could potentially escape the SQL statement it is enclosed in prematurely. I'm just going to go the activerecord route, though, and hope for the best. I doubt it would be worth it for me to try and enhance that in any way with my own junk. Thanks for your help!
&gt; If you have a lock on your phone, you are making it harder for people to return it to you. I have a lock on my phone, but set the background of the lock screen to 'Return to Sam &lt;My Home #&gt; - seems to be the best of both worlds.
Nothing to do with rails or devops. Intro to Linux cheatsheet maybe.
Good talk on malicious gems. http://www.confreaks.com/videos/1243-aloharuby2012-hacking-with-gems
Hopefully this provides an impetus to build a cryptographically secure signing system for gems similar to that of many other package managers like RPM and the like. You'd know if a gem has been altered based on the corrupted signature and such, and could only accept gems signed by trusted keys. Keeping the signing keys secure is another matter of course. 
It was, however, a YAML vulnerability from using Psych, which (and I may definitely be wrong) was the heart of the Rails exploit.
Yeah, that's right. It's a 'feature' of Psych, and in hind-sight, one that should have been locked down a bit tighter.
&gt; Is rubygems the source for all gems installed with gems? Basically, yes. &gt; Isn't hashing involved to verify the download That's message integrity. The issue here is authenticity. &gt; (I suppose redundant if the attacker also had access to update any hashes). Not redundant, it just serves a different purpose. Hashing will verify the integrity of the message, whether it comes from an authentic source or not. That's the job of a pre-trusted signature, which gem developers and authors have never properly set up.
The things is, the Rubygems team [had been told about it](http://news.ycombinator.com/item?id=5140157).
I agree with the true/false placement, that was pretty frustrating.
It would be great to have a few more seconds to read the questions before decreasing the timer.
Thanks for the clarification
Why not.. the maintainers for rubygems.org are doing all the work for free of cost.. No one is sponsoring their work.. So why shouldn't one support... 
&gt;If updates aren't automatic, people just won't update out of laziness. If you're running a web service the last thing you want is random unexplained downtime while the system automatically updates itself.
Exactly, which is why it's easier to bury your head in the sand and do it later ;)
Not to mention all the coffeescript repositories which usually holds more LOC in javascript
Grammar is the set of structural rules that governs the composition of clauses, phrases, and **words** in any given natural language. 
set of **structural** rules that governs the **composition of** Not spelling. I can't believe you're even arguing this.
Or just don't use rand, use a deterministic hashing function (eg, take md5 hexdigest of some id + seed, divide by maximum hex in space to place the input in the unit interval). Much nicer for testing &amp; qa as you can easily force specific variations.
Every big framework has had security exploits like these. I work at a start up myself, and we use Ruby on Rails. We have about 12 clients, and all 12 servers were patched immediately. No harm was done, but that doesn't mean much. I think it means more if a start-up is not patching their servers more so than it does for the Ruby on Rails framework.
http://railsapps.github.com/updating-rails.html
So substituting letters in the place of words is not a violation of structural rules that govern composition. For that matter the correct spelling of a word is a rule the governs composition. I'm surprised a special-needs type of yourself was able to form the sentences required to argue it myself.
"...Linguists do not normally use the term to refer to orthographical rules.." (from wikipedia). Also, more generally search "is spelling part of grammar?" on Google -- the answer 9 times out of 10 is a resounding "No." Grammar typically refers to the rules that control the ordering of words in a sentence. Have you ever written a yacc grammar or written your own parser? "grammar" defines the way tokens can be combined, it says nothing about the way the tokens are expressed (spelt).
How to solve the problem in rails: 1. Edit your Gemfile so rails is 3.2.11 2. bundle update 3. run your tests 4. commit and deploy It could have been far worse. And of course, I pick the most optimal solution, but thing is, that solution works in a very large majority of cases. I only had one problem, and the problem was solved by bumping a gem up a version as well
R is not misspelling a word it's a letter. Sentences are formed of **words** not letters. You didn't misspell anything, you had shitty grammar. I continue to be amazed at how quickly your demonstrated intelligence continues to rise. Perhaps soon you'll become self aware enough to recognize the douchbaggedness of your behavior. 
Context: This came up in discussion in #rubygems-trust on IRC tonight. We were talking about the pros and cons of X509 vs. GPG for gem signing and verification.
Yeah man, Frasier is there it's great
they don't eat meat, but they sure like the bone
The key point from the article: &gt;I feel like the gems themselves should be the focus of authority, and &gt;the current RubyGems certificate system places way too much trust in &gt;individual users and does not provide a gem-centric authority system. Question: is it really broken? The gems he cites are malicious - my limited understanding is that yes they are signed, but I'm not sure how you could mistakenly install them. I also don't know: Are all gems signed by default?
[ok...](https://dl.dropbox.com/u/73925/gifs/kpTtT.gif)
Yes, it's broken. If there's no attempt at ensuring that the code I download is the code that the developer uploaded, then you have no way of knowing what you're actually downloading. No, it wouldn't stop malicious modules that were written to be malicious and signed, etc. What it would stop (or at least make far more inconvenient) is someone injecting something nasty into a widely used library. Do you review all of the code you pull from rubygems? **edit**: I haven't done that much with ruby, I'm not familiar with what protections (if any) rubygems already has in place to prevent this sort of thing.
This is an excellent writeup and you should be commended for explaining everything so clearly. I do think however your solution should be a part of a greater solution and that being quality control in general. There should be an organisation that is dedicated to quality control and stability in the ruby ecosystem. If there was an adjunct to rubygems which ensured that the gems listed were audited, maintained by a core team of professionals, that obeyed standards of version management (point releases don't break compatibility), are known to work together and were limited to no more than three gems that accomplished the same thing I think it would be a boon for the ecosystem. Think of it as the debian stable of rubygems. BTW why can't we package the gems as RPMs or DEBs? Why start fresh when there are known and proven systems? 
You need to chill out. ಠ_ಠ
Because RPMs and DEBs, and indeed most packaging systems, do not support multiple versions of gems. The Ruby ecosystem is built around the ability to install multiple gem versions side-by-side, hence Bundler etc. It's not possible to convert all gems to RPMs and DEBs without nasty workarounds. I realized this when building DebGem, a gem-to-Deb conversion service a couple of years ago. Another problem is that RPMs and DEBs are platform-specific. OS X doesn't support them. Solaris doesn't support them. Windows doesn't. RedHat/CentOS doesn't support DEBs and Debian/Ubuntu doesn't support RPMs.
Absent the minor differences in their arity and return semantics, they're essentially equivalent. They can be assigned, curried, and passed as arguments to‒and returned from‒other functions. If that doesn't fit your definition of first-class anonymity, you'll have to clarify what you mean by "plain old".
That definition is what I was wondering about. What was Matz thinking after he'd designed the first of the three and looked at it and said, "You know, what we really need are two more of these?" Ty, btw.
Well, blocks are inherently closures; given that that's not always desirable, we need at least one or the other of Procs and lambdas. Then there're times when you want a variadic anonymous function, and other times for an invalid argument count to raise an exception, thus the need for both. It's true that each could simulate the other, but that wouldn't be very conducive to programmer happiness, the core tenet of Matz's design philosophy. Having both Procs and lambdas is roughly analogous to being able to call `size` or `length` at your convenience.
It seems to me if the goal is to design black box acceptance tests using domain language, Cucumber is a better solution
blocks, procs, lambdas are all closures.
* blocks, procs and lambdas are all first-class anonymous functions. * blocks are a lighter/prettier syntax for the common-case where you want to pass exactly one anonymous function to a method. * procs are essentially a block you can assign to a variable, they have the same semantics as blocks (regarding argument-checking and 'return' behaviour) * procs are different to lambdas in that they have non-local returns (i.e `return` returns out of the enclosing method frame, not just the proc itself). Procs also don't care about arity, whereas lambdas will raise an `ArgumentError` if you send them the wrong number of parameters. * Why is ignoring arity a feature? see the following code: 10.times { puts "doing this ten times" } 10.times { |v| puts "counted up to #{v} so far!" } 
"Having both Procs and lambdas is roughly analogous to being able to call size or length at your convenience." Awesome, thank you.
Thank you, very clearly-explained.
&gt;That someone can just fork a gem that someone gave up on, a gem that was never even released on RubyGems, is one of the best aspects of the gem ecosystem. Yes and no. I agree that it's good to know that the code will never die and somebody can continue to work on it. OTOH it does mean there are multiple versions of the gems with differing functionality and levels of stability. In order to decide which one to use you have to waste a lot of time digging through the code, commits, and then actually installing them and seeing if they conflict with anything. &gt;Sounds like you think his toy project shouldn't exist or something which does nothing but squander value from the ecosystem. No I think there should be millions of toy projects but I also want a resource of gems I know are stable, I know are solid, I know are maintained, I know are audited, I know will obey standard versioning schemas, I know are documented, I know I can pop into my gemfile and go. We need the cream to rise to the top.
&gt;I just don't really understand how this is a problem unless you're sticking random gems into your Gemfile like you're some sort of Indiana Jones precious stone archaeologist. I bet most people who read this subreddit have at least one gem pointed to a particular fork or branch on github. The reason they did this is because the "official" gem wasn't working properly and somebody forked the project to make it work. That person probably attempted to get their changes pulled into the "official" gem but either the pull request was ignored, rejected or the project was abandoned. Chances are there are multiple forks of that gem with differing features or bug fixes in them. Apparently you don't think this is a problem. Apparently you are fine with having four or five forks or a project (along with a half a dozen competing projects) that all attempt to the same thing. I think it's messy and I think there could/should be a more sane way to handle this. &gt;RubyGems is just a central repository for sharing code. Do you also have the problem of cloning random Github projects into your project lib folder? None. Have you been reading my posts? &gt;...So what's the solution that doesn't just arbitrarily increase the barrier to entry by policing things like versioning policy just so that you don't have to scrutinize the code yourself? What barrier to entry are you talking about? Why can't there be an alternative to rubygems but one with strict policies for admittance? You can still pull in half baked, undocumented, abandoned gems into your project from rubygems but this repository would be more strict. &gt;It exists already. It's called "the community". It's rather trivial to evaluate the activity of a gem's repository by looking at its github page. You clearly don't understand what I am talking about. The "community" has resulted in the current situation. This is the way "the community" is working and I am wanting a better way. &gt;Might https://www.ruby-toolbox.com/ help you out? It ranks gems by popularity. First of all I am more interested in security, stability, robustness, and documentation than popularity. Secondly I don't agree that having fifty forks on github is a measure of health or quality in the project. If anything I think it's a sign of malfunction because so many people feel the need to maintain their own forks. If there are fifty people maintaining forks it means nobody is taking pull requests and there are flaws which people are fixing in their own branches. Anyway clearly you are happy with the "wild wild west" ecosystem we have today. I am saying that I would love to have an alternative. One based on quality and commitment to best practices. 
Gentlemen, please, you both raise good points but I get the feeling that you've gotten into the back-and-forth argument spiral. knothead's assertion that there are tons of fork, none of them official, is a valid concern. Although hobbyist projects should have the right to exist, and that having working forks is better than having a single non-working gem, the fact that the forks are so splintered is indeed a problem. You do not need to be inserting random gems into your Gemfile to run into this problem. I've experienced it first hand with even high-profile gems such as authlogic. And a lot of high-profile gems depend indirectly on poorly-maintained toy projects, so you can still run into the problem even if you're careful. dannue's assertions are also valid. A QA organization may seem like a good idea, but here's why I think it wouldn't work for the entire ecosystem: * The ecosystem is large, spread across a huge number of individual developers. The organization simply will not have enough resources to monitor everything. * The QA organization needs to have authority. With so many developers it is impossible to be recognized by everyone. * If the ecosystem is too "strict", then it will discourage developers from starting toy projects (that may one day grow into high-profile projects). Compare SourceForge with Github. SourceForge required you to introduce yourself upon signup. The entire UI and process felt very rigid and structured. People ended up ignoring the structuredness so that they can publish toy projects. When Github came, many people moved away, and the number of new projects exploded. Some of them grew out to be very successful. I think that what we need instead is a culture change, based on a set of well-defined good practices. These good practices must be easy to implement or people will ignore them. If the QA organization's job is to actively promote good practices, instead of enforcing good practices, then I think we'll have a much more healthy ecosystem. Toy projects can still exist, we make it easy for them to follow good practices, and we instill the idea that following good practices is a good thing. To reduce the problem introduced by forks, I believe that we should promote the practice of giving write access to other people. This was how it was done in the SourceForge days. Right now it's too easy to fork a codebase, make some changes and forget about it. Contributors should commit directly to the main codebase. Sometimes the maintainer does not have enough time to actually maintain the project, e.g. releasing new versions. We should promote the practice of allowing co-maintainers into the project. Github can help by introducing features that make this easy. For example Pull Requests can have a "Make this guy a co-maintainer/co-contributor" button. It would also help a lot of Github projects have some kind of metadata that essentially says "hey I'm the original project, but someone forked it and by now it has become the canonical project, so go there instead". As for the security problem: I do not understand what knothead means by piggy bagging on the Debian signing process. I do believe that whatever signing infrastructure we use should be based on PGP. PGP's tools are extremely easy compared to X509, there is a lot of experience with it already in the Linux work, and there is already infrastructure such as key servers.
It's worth noting that blocks, procs and lambdas are also *closures*, which first-class functions are not necessarily. AFAIK there is no non-closing first class function construct in Ruby.
Well, there are [unbound methods](http://www.ruby-doc.org/core-1.9.3/UnboundMethod.html), but they're effectively useless until you force them to close over something.
Isnt lambdas the new and improved Proc? Like habtm are essentially outdated since has_many through came.
I was able to last night...
No on both cases. There is no hierarchy of "newness" between them. lambdas and procs behave differently, not better or worse. (they are both instances of the Proc class btw). habtm and has_many-through are, just like lambdas and procs, just two similar ways of achieving a similar goal. Depending on the circumstances, one might be better suited than the other.
Yeah, the tagline was pretty bad. Your mother sounds majestic. Instead of lampooning mothers around the world, I should've just called it "a Craigslist scraper even I could program". :(
My one piece of advice is that scraping Craigslist is a violation of the TOS. So don't get caught. 
Ah-a, but I'm one step ahead of you, Lonny! You see, my gem has a built-in feature that will render your app brittle and probably broken if you decide to depend on my gem in any way for any sort of serious use case long before you run into any TOS trouble! Total providence is my middle name.
Great first gem! You're writing good code and describing it well, so I'm writing lots of opinions below in case one or more may be helpful to you. Good luck! -Joel Your intuition about your node system is good. Pursue this. Read about DCI (Data Context Interaction) and experiment with it. DCI is awesome, though slow on Ruby due to cache-busting method lookups. Your Node is much like a Rails ActiveModel. Read up on how ActiveModel does it. You can use ActiveModel even if you don't use all of Rails i.e. you don't build a web app with views, routes, etc. Also see ActiveModel::Validations. Add a CONTRIBUTING file. GitHub suggests using this file. Split your large classes into smaller files. For example, refactor your listings.rb to move most of the inner classes to their own files, such as housing.rb. This is the same compositionally, yet much easier to deal with for developers who are contributing to your code. Aim for each file to be just one public class (or module). Your testing code has huge blocks with many asserts per block. Try to aim for one assert per method. If you want to parse the object just once for speed, then use a before block, or a class constant; these are less "pure" yet very fast. One assert per method makes test code more resilient and also makes it easier for other developers to understand what's expected. Your main commit message says "monolithic commit". Don't do that. Aim to do granular commits with small numbers of files at a time and one concept per commit. Aim to use feature branches. Aim to use TDD. For ideas, read about git-flow. Change the variable name from _id_ to _site_id_ or whatever your id really means. Using _id_ sometimes gets quirky when using Ruby, or Rails, or importing/exporting into databases that are maintaining their own serial ids. I personally use _uid_ to mean a unique id that is independent of the Ruby object id, the Rails ActiveRecord id, and the database id. Define #to_json and #to_xml for all your nodes; you'll make your gem easy to use in toolchains. Aim to separate your models (i.e. your business logic) from your views (i.e. your presentation). A good example is your code that says "urlified_city". This is essentially a kind of view code, sometimes called a presenter, sometimes called a decorator. For inspiration, look at the 'draper' gem. If you want a little challenge, rework your categories.rb and cities.rb to use a YAML configuration file. These are easier for other developers to change. Your #constantize code has a collision risk. Consider inputs :foo_bar then :foo, :bar. Same output, yes? For your output string, use a separator character such as a space, dash, colon, or comma (or two colons if you're turning the constants into Ruby classes). Your #category_lookup method is ripe fora particular kind of pattern. Change code like this "x = y; raise foo unless x; x" to "y or raise 'foo'". Also you'll be nice to developers if your raise message shows the data that failed the lookup e.g. raise "Unknown category: #{category}". Your listing_const code needs help. An easy cleanup is to store everything in a recursive hash i.e. a hash that can contain hashes that can contain hashes... the initialize method looks like: super{|h,k| h[k] = self.new } For Node::HasImage and Node::HasMap, you could change them just to Node::Image and Node::Map so you can do more than just returning booleans. For example, Node::Image could process thumbnails, and Node::Map could return Google Map links. Or if what you intend is "this class has a map" then you should change your other nodes to match e.g. use Node::HasTitle if you mean "this node has a title". Aim to be consistent when you can. When you use the word "Craig" you're using it many different ways, such as the gem name, the list name, and a class name. Consider changing these to have one name per purpose. For example what I think you mean by "Craig" as a class name is better written as "Site". Yes? This code: (:austin, :housing =&gt; :apts_housing) ... can be clearer and more flexible if you use key-value paramters, like this: (:city =&gt; :austin, :category =&gt; :housing =&gt; :apts_housing). If you want a bit of a challenge, consider internationalization. Can _square_feet_ be _square_meters_? Can _cost_ have cents? Is the _date_ using a time zone? If you want a good metaprogramming challenge, rewrite "include Node::Foo" to "attr_node :foo". Then upgrade to do multiple nodes e.g. "attr_node :foo, :goo, :hoo". I hope some of this may be helpful for you. If you're ever looking for programming work, ping me.
&gt; Adobe worked deliberately so that PhoneGap apps would NOT look native. Huh?
This is great advice. Thanks for taking the time to write this out, even though I'm not OP.
Lonny mentioned that this was against Craigslist TOS - maybe rewrite it using their RSS access? I think that's the closest thing they have to an API. Otherwise, good job. This shows the right mindset in writing code. Keep at it :)
UnboundMethod objects are really just a wrapper object for the body of a method, and carry their original binding along with them. To see how this works, I made a little demonstration: class Object x = [] def foo x rescue NameError =&gt; e puts e end define_method :bar do x end end # note: these are local variables foo = Object.instance_method :foo bar = Object.instance_method :bar At this point, our local variables foo and bar are both UnboundMethod objects, but the method bodies they wrap were defined so that foo did not close over x, and bar did. Let's try to bind them to something (any instance of Object or its subclasses) and see if they work: foo.bind(Object.new).call #=&gt; undefined local variable or method `x' for #&lt;Object:0x00000001aee628&gt; bar.bind(Object.new).call #=&gt; [] You can see that the UnboundMethod created from Object#bar actually closed over x. To see that it's always the same x, you can modify it: {}.bar &lt;&lt; "hello" Module.new.bar &lt;&lt; "world" bar.bind("any object will do").call #=&gt; ["hello", "world"] So the rabbit hole goes way deeper, but I just thought that was surprising the first time I tried it.
If you somehow the scraping doesn't work out for ya, Craigslist also has a public RSS feed that has all the data as well!
They don't even like it if you link to them from an app after searching via RSS. Jerks.
WOW this is some quality feedback. Lemme play with some of those ideas. http://i.imgur.com/3gMLp8q.gif
Allright, I just read the Rails 3 Way and it says habtm is only there for backwards comp purposes - and to use hasmanythrough instead. apparently one of the creators behind Rails Active Record says the same and he even has a blog called hasmanythrough :-)
Don't just go along with what someone says - see if you agree with their reasons. The reason given for using has_many_through is almost always "in case you need to add data to the association". But if you don't have any such data, you should use the simpler has_and_belongs_to_many. Simple is better. If you later need to add data to the association, you refactor to use has_many_through. This issue is similar to the for-loop. Programmers just don't consider certain ways of doing things "fashionable", simply because others say it isn't.
Small heads up: I only just started pushing releases to RubyGems so the software is still beta-ish quality. If anybody can give this a spin to see how it works out for them that would be great! If you're wondering how to add sources to RubyGems, you can do so as following: $ gem source -a http://hostname.tld Note that this will *add* it, not overwrite it. If you want to use a specific source you'll have to manually edit your `~/.gemrc` file. Once my DNS changes have been propagated you can see a basic example at http://rubygems.yorickpeterse.com/. This mirror only mirrors a few Gems (such as Pry) for the time being.
Use rvmsudo.
When I run sudo echo $PATH Several of the directories are in /home/ploshy/.rvm Seems to me that that should be it.
Care to expand on that a bit?
People are misunderstanding the problem that signed gems is meant to solve. The OP tried to explain it, but apparently unsuccesfully. Signed gems do NOT protect you against installing a gem which is, with the intention of the known author, malicious. Signed gems protect you from installing a gem which has been _maliciously altered by someone other than it's author_. To use a concrete example, a gem signing system is not meant to protect you against if Rails core team decided to put something in Rails to hack your system (or were tricked into accepting a pull request to do so, etc). A gem signing system is meant to protect you against someone hacking rubygems to change the Rails gem on rubygems to include malicious code, code that isn't found in the Rails repo and was not committed by Rails committers, but instead was 'hacked' in by someone who could exploit rubygems. The recent vulnerability in rubygems would potentially allow just such a thing -- an attacker to modify code on rubygems to be different than the gem's authors actually pushed to rubygems. That's why signed gems are getting some attention. And no, all gems are not signed by default, very few gems are signed, the local `gem install` command does not presently really check for signed gems on install anyway, and even if it did there's not the right infrastructure in place for the local `gem install` command to have any way to reliably check signatures (how does it know what the 'proper' trusted key for a given gem is, in any reliable way?). These are exactly the issues OP is meant to address. Clearly OP did not do an adequate job of explaining itself. 
rvm installs everything in your home directory, it isn't installed for other users (ie -- root). So instead of having to re-install all of your gems for the root user, rvm provides a script that sets up all the paths for the root user to use the gems in your home directory.
By default, rvm installs ruby for your user only. This allows you to install gems without using sudo (i.e. one advantage over apt-get installation). Using sudo will run commands as `root` and will not find the `ruby` or `gem` commands because it's not installed for all users in the system. If you really need to use sudo with the rvm for the current user, you can use rvmsudo as samg mentioned. But for most cases, you won't need to use sudo for installing gems in rvm.
Worth it!
There are two very different ways of installing RVM. Single User and Multi-User. On servers, you usually want to do the Multi-User install. To install RVM for a multi-user environment, install RVM normally, but with sudo. When RVM is installed with sudo, it installs very differently than how it installs for a single user environment. If RVM has installed to your home directory, I'd recommend installing it with sudo. https://rvm.io/support/troubleshooting/#sudo https://rvm.io/rvm/install/ (read the multi-user section)
sudo is only good for making sandwiches
Try using a fully qualified path: $ which gem /usr/local/bin/or/whatever/gem $ sudo /usr/local/bin/or/whatever/gem install rails 
https://github.com/rubygems/rubygems-mirror is around 5 years old now I think. If you're reading this the above link is not beta software and is almost always what people use when they mirror rubygems today. You can generate checksums with the openssl binary which will probably be a lot more trustworthy for "when rubygems gets hacked again". Not to mention it'll be around 4 bajillion times faster.
I don't know if it'll fix your particular issue, but `sudo -H` is highly recommended.
 sudo echo $PATH ... expands the PATH variable as ploshy before it runs the command as root. Use "sudo su", then echo $PATH, to see what root's actual path variable is.
I know! More time to have paper sword fights with your co-workers, amiright!?
I agree, and I'm here to learn, so tyvm for the explanation. I am just not 100% convinced that habtm is that much simpler than hmt to warrant its use, but I will have to see for myself then. 
Based on the amount of open issues (and their creation dates) and the amount of commits in recent time the project seems pretty much dead. I've also yet to find somebody actually using it. &gt; You can generate checksums with the openssl binary which will probably be a lot more trustworthy for "when rubygems gets hacked again". Unless the OpenSSL binary sprinkles some fairy dust on the checksums I don't see why it's going to be more trustworthy. Assuming a hashing algorithm (SHA512 in this case) is implemented correctly (which I think we can assume in Ruby) there's zero benefit to using some command-line utility. Shelling out for every command is most likely also going to be slower than just using `Digest::SHA512`.
Upvote for the unintended bit in the docs about having a separate queue for cache warming jobs. Never thought about that as a technique, nice idea. 
Excellent post, not too fuddy, and outlined the problem without giving script kiddies any copy paste exploits to use
Script kiddies have standardized on [Metasploit](http://dev.metasploit.com/redmine/projects/framework/repository/entry/modules/exploits/multi/http/rails_xml_yaml_code_exec.rb) ;)
Cool, thanks. :)
Suspect their first comment was humor. Well, both were but the second wasn't a joke as much as an ironic 'get over yourself'. Chill. And if you really read the more obscure xkcd strips and think he panders to poseurs, your humor meter may be pretty unique. Now, I don't care whether you change yours a bit, but chill. But I already said that. Back to topic, am fascinated that ruby and sudo clash like this. 
Nah, there's a code smell to the prepackaging of ruby/sudo overlaps. I counted two in this thread. 
Lol, sudo ain't as arcane as sendmail.conf but it could be -- heck, i know very few root-holders who understand even the diff between sudo su and sudo su -, or what all=(all) all in sudoers means. Also a clarification: rvm vs sudo clashes and code/scripts to cope were what i counted 
Just out of curiosity, do you know if there is any advantage to doing it this way over using god?
Very cool. Thank you. 
nice write up!
No, I didn't knew things like cachegrind before, thanks for telling me :) The C implementation was forked from https://github.com/dcjones/hat-trie, I just added a simple prefix search and did nothing but wrapping. I will test it the day after tomorrow (have a plane to catch tonight...).
On the non-parser side it all boils down to personal preference. For me, a language that forces me how I _must_ indent and where and when is just out of the question. Significant whitespace is one of the reasons why I never warmed up to python or can take it seriously.
How about the usual argument of "don't you indent your code anyway"? Do you sometimes write randomly indented code? What if there was support for things like multi-line strings, and you could format arrays and hashes however you want (just like Python)? I never really warmed up to Python either, but it was for other reasons. Last question: I take it you don't use HAML or CoffeeScript?
I'd rather have the interpreter force the indentiation than having to deal with badly formatted code. When you write Ruby code you should follow style guidelines and I have no problem with the guidelines being a part of Ruby itself. That said, I like the idea of the significant whitespace but I'm sure it will never be pulled into Ruby.
Although I like HAML I still don't get used to indentation/significant whitespaces at all. I also would make a tiny difference here: Ruby is a programming language, HAML itself is in first instance a nice abstraction layer for HTML just for typing less. In some teams I worked with there were lots of discussion only about HAML vs. ERB. Most the time ERB won. I also never warmed up with Python (significant whitespaces was one of the major criterias to choose Ruby instead) and CoffeeScript. I don't want to be forced to code in a specific way, I want to force the technology to work in the way I want! What will be next? Significant colors?
I'm not against significant whitespace, but for me ins't optimal for all situations. Is ok for markup languages, like Haml. It saves lots of keystrokes. But for pure ruby, my key feature is readibility/understability. I find **esential** to be able to know where a block ends, without brain effort. The end is just there. 
Of course I indent my code, but the way I see fit. You'd probably think my indenting is clear and concise, however I don't believe some group of people significantly removed from me can tell me how I can best indent my code. If you (as in: creators of the interpreter) don't trust me to code in a way that is good for me, then I don't trust you to provide me with a language as flexible as I need it to be. Might as well go back to the strongly typed languages, if the parser/compiler/interpreter is going to start being pedantic about these kinds of things. And thats the nice thing about ruby: there are strong suggestions on how to do things, but they're only suggestions. I'm free to consider them and reject them in cases where I feel the need to. Case in point: case (let's see if I can get the formatting correct here). Which of the following indentations is "correct"? case foo when "bar" then false when "baz" then true else nil end or case foo when "bar" then false when "baz" then true else nil end Personally, I like the latter, but I've seen editors with "smart" indentation for ruby trying to force me to do the former. I don't really see either as more correct than the other, however visually the former chafes. HAML/CoffeeScript: Correct, I don't use either, however significant whitespace is a secondary problem here. I don't really see the point in creating an aribtrary DSL with it's own syntax that gets converted into a base language that is the lingua franca of its problem domain. It creates its own slew of problems.
That depends on your definition of style guidelines. Do they only cover visual stuff, like indentation, when to insert a blank line and the like? Would you also require the interpreter to enforce hash alignments? Personally, I get rather annoyed when I see stuff like hsh = { "key1" =&gt; "value1", "key2" =&gt; "value2", "key3" =&gt; "value3" } or (the key/value separators =&gt; misaligned) hsh = { "key" =&gt; "value", "some other key" =&gt; "another value", "k" =&gt; "v", "hey this is a really long key dude" =&gt; "with another value" } I prefer vertical alignment of keys and values (imagine all key/value aligned): hsh = { "key" =&gt; "value", "some other key" =&gt; "another value", "k" =&gt; "v", "hey this is a really long key dude" =&gt; "with another value" } however if the last key is so long that all the previous values would row-wrap, I'd actually prefer: hsh = { "key" =&gt; "value", "some other key" =&gt; "another value", "k" =&gt; "v", "hey this is a really long key dude" =&gt; "with another value" } Still readable, only one row wrap, but I'd have just made the interpreter unhappy with me. Also, shouldn't coding guidelines also cover other aspects of the code, to ensure internal consistency? E.g. usage of inline rescues, old hash syntax vs new hash syntax, old lambda syntax vs new lambda syntax, how to create singleton methods ( class&lt;&lt;self; def foo ; end ; end vs def self.foo ; end ), code ordering, how to declare methods public/protected/private and the like. For me a coding guidelines do impose certain rules on indentation, however internal consistency of the coding itself is more important in big projects where more than 2 people are involved. Whitespaces should be consistent where possible, however can be handled flexible depending on the context. Edited, because struggeling with variable width fonts.
I don't want Ruby to have significant whitespace because Ruby doesn't have significant whitespace. A useless tautology, sure, but a Ruby with significant whitespace wouldn't be Ruby. Having said that, I think the usage of CoffeeScript within the Ruby community shows that Ruby programmers aren't necessarily against whitespace significant languages. Most of us I'm sure don't hate Python either -- for me personally, Python was a direct stepping stone prior to discovering Ruby, and whitespace significance didn't really come into my decision to switch to Ruby for day-to-day development. I fucking love Haml though. So much so that I think if you're writing HTML manually, you're doing it wrong. Part of the reason is that Haml is a much closer representation of what the DOM actually is - a tree, whereas HTML often ends up as tag soup. Coming back to your original question, whitespace significance makes a huge amount of sense for a tree-based language, whereas the difference is less pronounced for Ruby code which is less "tree-like". Still not used to Ruby 1.9 hashes though. Viva la hash rocket.
I personally like significant whitespace and feel lukewarm about `end`.
I just realized I might be biased, because Sublime Text 2 has these really helpful guides: http://i.imgur.com/BpyjMDr.jpg That's probably why I find it so easy to understand, because you can easily see where the block ends without any effort.
yes, I would switch today if significant whitespace was possible in Ruby.
ruby already has significant whitespace: it uses newlines to indicate the end of a statement, with semicolons optional. After programming in ruby for a while and then going back to do some work in perl, I realized this makes a big difference: perl is much more flexible as to where you can break up a statement into multiple lines, because it KNOWS the statement isn't over until it sees a semicolon. Ruby assumes the statement is over when it sees a newline, unless the line ends with an operator or opening parenthesis or something similar. So, significant whitespace is a bad idea because it limits the programmer, and I wish ruby had even less than it already did. It's kind of like the argument for static versus dynamic typing: dynamic typing can be misused, so static typing helps keep programmers from making certain kinds of mistakes, but static typing also limits what can be accomplished and tends to make code more verbose than it needs to be.
I like HAML a lot, but it's not a scripting language, it's a markup language. Ruby is a scripting language and I'm very glad it doesn't have significant whitespace. I wrote some python recently that needed to be included in a shell script, so it had to be a one-liner. Python's significant whitespace became a real liability in that use-case and I had to write very difficult to read code as a result.
Tick tock.
i don't get 1.9 hashes either. for absolutely no benefit, you destroy backwards compatibility
This is pretty awesome. We use upstart for our resque tasks (using chef for determining what queues each worker should monitor) and I have rake tasks on the resque boxes to restart them post-deployment. I think, if given the opportunity to rebuild our deployment, I might use this gem.
Method calls have to be blue and objects must be green when they are created but they are yellow when called upon unless they are constants then they must be called in orange.
a) no incompatibility, you can even intermix the two in a single hash. b) Truth be told, if ruby had significant whitespaces, then we'd be a bit screwed, due to backwards compatibility. A S.W. language does have a few differences in decisions about declarations (an example [but not limited to] is private method annotation). If you want ruby w/ significant whitespace, you'd need two things: a new language (wuby?) and a compiler that compiles ruby code into wuby code (since it's meant as a direct replacement). And then we're done. F.A.Q: Q: What about rails? A: Wuby on Wails Q: Haml or ERB? A: I will probably rather stab myself with a dull pencil than switch away from HAML to ERB. Unfortunately I don't yet have haml working for my javascript templates so I'm still using ERB and stabbing myself with dull pencils to ease the pain. Q: SASS VS SCSS A: I love SASS, and despise curlies in SCSS. However my CSS-nostalgic co-workers force me to use SCSS. I hate them daily for it.
I think it's really important to point this out. It's not that there's anything wrong with significant whitespace -- I think it's a great tool -- but changing a language's syntax drastically like this late in the game is not a great idea. Little things like hash syntax? Sure. Big things like mandatory code formatting? No way. What people don't focus on that they need to is not "why don't they X?", but "why should they X?". Ruby is working perfectly fine without significant whitespace and revamping the compilers to accept significant whitespace doesn't offer any significant advantage.
The funny thing is, I don't many people realized the true implications of the term "significant whitespace", I sure didn't think of line endings until I saw this post. Just goes to show that a lot more thought goes into language syntax than is apparent on the surface.
While I get your point, you still need to appease the Ruby parser. Instead of significant whitespace, you use curly braces or do ... end. And to the best of my knowledge, you can't force that away*. * There was a proposed feature to combine multiple "end" statements into a single one by increasing the number of "n" characters in the word. E.g., "ennnd" would collapse three "end" statements.
So, when we see a Python written in Ruby?
[colorForth](http://en.wikipedia.org/wiki/ColorForth)
OK, here it goes. I'm gonna be that guy. I hate being that guy, but I gotta... Outside of 'proof of concept' and 'shit is cool', why should I use this over MRI, JRuby, or Rubinous? What is the benefit for enterprise? Hell, what is the benefit over the other three implementations? I understand choice can be fun, but if there isn't a benefit that is obvious I would hate to see effort on this scale wasted on something the fringe developers would use. I mean, it's cool and congrats on the efforts. Not an easy task, and I don't want to belittle your efforts. I just want to ask, why?
Why should you use it? Today, there's probably no good reason, tomorrow: performance. By using the RPython toolchain we have a fast, robust JIT to build on. As for me, I built it because it was fun.
I honestly hope I didn't come off as snarky in my remark. I love the FOSS community and tools that come out such as this. I wish you and this project all the best, honestly I do. I just wanted to know the differences (if any). I'm planning on starting a large project and I wanted to know if it would benefit from this. I guess I will see in the future. Again, good luck and I got you starred on github to follow up.
Not at all, the biggest benefit you'll get is "it's all Ruby" if in a year we're more compelling, you'll just switch your Ruby code and be happy :)
They are going to make more sense with 2.0's named-argument syntax, which will largely eliminate the need for the option-style hashes in method calls that were popularized by the Rails people. So this: def send_dubloons(options) options.assert_valid_keys(:recipients, :message, :amount) Array(options[:recipients]).each do |recipient| DubloonService.donate(to: recipient, message: options[:message], options[:amount]) end end becomes: def send_dubloons(recipients: [], message: '', amount: 0) Array(recipients).each do |recipient| DubloonService.send!(to: recipient, message: message, amount: amount) end end Not terribly happy about hashes, either, but that's only because they opted to make it only work for symbols. I can't do this: {"foo": "bar"} ...because the keys are not literals and it would get ambiguous (does `{foo: bar}` refer to a variable named foo, or a symbol?). For that reason alone I wish they had left the hash syntax alone and focused on named arguments instead. Given that with named arguments we're going to be sending fewer hashes around, I think it would have sufficed.
Oh, I agree, but as a guy who is looking to start his 'start-up' soon I wanted to know how this is better than other implementations (currently we are going the JRuby route). I hope that in the near future this becomes a big hit.
As always, I will keep my ear to the ground on this one. 
JRuby is a different problem domain I think. You would still use that if you wanted to leverage the JVM and Java libraries that are out there.
I have looked at REE for performance, but something about possible interop with Java or even Clojure and Scala really forced my hand on the choice. But, in the end if it is more trouble than it's worth then we will look at other implementations. Edit: To clarify, if we need Java/Scala/Clojure or some other JVM language then we will use it. If not, then we wont. Just depends on the issue at hand. Edit: Clojure 
clojure*
But...I said it right the second time :(
I'm not sure if REE is that much faster than MRI these days. 
didn't realized that named arguments were going to be added.. that's a wonderful slice of smalltalk! thanks for the info! reminds me i need to read up on 2.0
That and they are stuck on 1.8.7 specs. Not a very good route...
Yep which means no Rails 4
I love using [haml_coffee_assets](https://github.com/netzpirat/haml_coffee_assets) for HAML in JavaScript templates. It's works really well, and I recommend it.
Just for reference, some of the other Ruby implementations are: * [IronRuby](http://www.ironruby.net/) - Built on .NET * [HotRuby](http://hotruby.yukoba.jp/) - Ruby built on JS and ActionScript * [RubyJS](https://rubyforge.org/projects/rubyjs/) - Ruby that compiles into Javascript * [MacRuby](https://en.wikipedia.org/wiki/MacRuby) - Built on Objective-C (macruby.org is currently down) * [MagLev](http://maglev.github.com/) - built on the GemStone/S virtual machine * [MRuby](https://github.com/mruby/mruby) - Not sure really * [Ruybinius](http://rubini.us/) - "follows in the Lisp and Smalltalk traditions" - from Wikipedia * [JRuby](http://www.jruby.org/) - Built on Java 
Right, that does look pretty nice. That would make the significant indentation non-optional, though.
I also prefer the last version of the `case` statement. With significant indentation, it would be the only one that makes sense: case foo when "bar" then false when "baz" then true else nil Alternatively, `case` could also be a special case, where both styles are supported. I think you misunderstand how strict I would want the indentation to be. All of the hash alignments in your previous comment would be valid. You could format multi-line hashes, arrays and strings any way you want, [just like Python](http://www.secnetix.de/olli/Python/block_indentation.hawk). To me, significant indentation has nothing to do with restricting freedoms or enforcing a certain coding style. It's about recognizing the indentation patterns that we already use, and removing the need to type/maintain unnecessary tokens.
How are you acquiring "location" e.g. form post? 
that would uri encode it, resulting in an escaped ampersand in the actual string.
Yeah, and when I researched REE it was still in 187 specs. No, JRuby is a good choice...and possibly Topaz in the future.
I didn't care about it either way until around a year ago (I had some experience with python and significant whitespace wasn't in the reasons I didn't like it). However around a year ago I tried writing big website using coffeescript only. I immediately ran into problem that as soon as you have more lines than it fits in your monitor you start losing context when reading code. I feel having "end" is much better approach as significant whitespace doesn't give any benefits (if you still use editor that doesn't insert end automatically, you're doing something wrong), but makes it easier to follow what code belongs to which method and etc.
Remember that to get clean interop with the Java/JVM ecosystem you're giving up a certain level of clean and lightweight interop with the C/POSIX ecosystem. I'm not saying that JVM interop isn't cool or even that it isn't more valuable for your project and team, but it's easy to forget the raw power that's available when you do stuff that can segfault and to overlook the depth of the C/POSIX ecosystem.
I'm don't use cucumber myself but maybe a problem with the step definition? Edit: Which I now realise is exactly what you were asking about, sorry doh!
That's a good point. I posted this in another comment, but I think it's really helpful when your editor shows lines to show you where a block ends. For example, some CoffeeScript in Sublime Text 2: http://i.imgur.com/BpyjMDr.jpg With those guides, I can easily see where the block ends without any effort.
i'm guessing he knows that there's already a gem named "tamtam"...
Also, there's nothing wrong with the plainest, simplest, verbose approach: user = User.where(email: email).first if user.admin? user.update_attributes(status: "active") end The requirement I have for tightening up code with nifty ruby hacks is that I need to be removing code that *doesn't* express intention. But your assignment/conditional example and the one I put above are filled to the brim of code that has meaning. Object#try_if doesn't seem to actually improve the signal to noise ratio of the code, at least going by the examples.
And if you use nailgun, startup time can be better than MRI.
You're of course correct. I think the general point still stands. Use of the 1.9 hash syntax breaks compatibility with 1.8 in libs that would otherwise work just fine on 1.8. I get that 1.8 is dead, but it sucks when you're in the interstitial period trying to upgrade. We'll likely see the same issue when 2.x gets the ability to use the new hash syntax with String keys, which 1.9 can't do.
Yep. That was a mistake on my part.
"Remote Ruby interpreters" This is what I've been waiting for. Finally!
That looks really cool actually. I've tried out python where indentation matter and I clearly needed something exactly like your setup because I got very lost in indentations.
I would love to see some Benchmarks (is MRI really that bad?).
Hopefully the Security Researchers have found all of the RCE vulnerabilities and are now scraping the bottom of the barrel for XSS vulns ;)
Please tell me performance is better. Maybe its because I work on a huge, old app, but every time I try to use RubyMine, I usually stop after one work week and go back to my lightweight standard.
Yes. MRI is really bad.
RubyMine 4.0 had performance improvements as one of its key features. I'm sure the newer versions have had improvements as well, so the only way to know is to test it. It works fine for me, but it is hard to know what the issue was with your app. One trick is to exclude directories for the project that aren't used very often, or isn't code you will edit. This can sometimes speed up indexing significantly. Another thing to check is the background tasks window - see if any tasks are hanging or continually being executed.
I guess that is the problem with allowing known classes in YAML.load, you can write class methods in the YAML?
Hooray, now we can turn a two-line conditional into a three-line conditional!
thanks for the tips!
IronRuby is pretty much dead, though.
To diagnose why RubyMine isn't performing well enough on your app, you can submit a CPU snapshot: http://devnet.jetbrains.com/docs/DOC-1144
Any benchmarks?
That's partly because a lot of the memory optimisations done in REE are present in MRI Ruby 1.9. 
Also my understanding is that you're going to rely on FFI and omit Ruby C API in its entirety. Am I right on this one?
You mean https://github.com/vic/typhon
We do not write software. We design it. That's what software engineering is doing: in the same way an architect has a means to draft detailed drawings in a language understood by builders to make sure they build exactly what they intended, we have a means to draft detailed instructions in a language understood by compilers and interpreters. Agree? Good. In that case, the choice of language is about the language that allows you to best express those ideas. We're still learning lots about programming language design, but there is a needless fixation on one area which is perhaps one of the least important aspects: significant whitespace. That said... We've known since the days of COBOL that a programmer needing to care about exactly which vertical column an instruction must start in is prone to errors and interpreters/compilers getting confused, and the programmer needing to correct their mistakes. Python, HAML, CoffeeScript all have the same problem. It's possible that with training and self-discipline you can make this a minor issue, but at the start at least you are going to have to spend some time thinking less about what it is you're trying to achieve and more about how to format the design of your software so that the interpreter doesn't get confused. It's a contentious issue (needlessly so IMHO), but my personal preference is to explicitly `end` blocks, especially if I need to understand a relatively deep level of nesting. Reading heavily nested code without it is slightly harder for my brain to parse. You can argue that nesting is the wrong way to go, and is a good candidate for refactoring - and in some cases I would agree - but breaking things down into short methods can sometimes be less preferable, and deep nesting is better. Making it optional though just seems like a painful hack. Suddenly you've got to start getting coding standards in place: what happens when a dev who likes significant whitespace goes into a team who doesn't? Or vice versa? Do we end up losing more time to "technical debt" as we make a code base whitespace-significant?
Performance-wise, yes. But you get a whole load of other benefits including knowing "this is the proper Ruby interpreter" and so when something doesn't work, you know it's you not understanding what's going on, not the interpreter 99.99999% of the time.
&gt; E.g., "ennnd" would collapse three "end" statements. I just threw up a little.
http://i.imgur.com/sb7nDKV.gif
They have IDEA for Java projects. It's much nicer than Eclipse, IMHO.
I've used IDEA as well - it's why I picked RubyMine for ruby dev. Eclipse is just evil.
That's correct.
This is a X-post from /r/programming (http://www.reddit.com/r/programming/comments/182jvs/open_source_in_your_inbox_code_triage/). I'm a Rubyist, but it doesn't mean only we get to enjoy nice things :)
&gt; alex I take it that this is OS X only?
I like it. I don't understand the no-arg example: &gt; (post.pending? &amp;&amp; post.update_attributes(:published =&gt; true)).tap_if do What's that doing, with no arg to tap_if ?
What does the roflcopter say? **SIVSIVSIVSIVSIVSIVSIVSIVSIVSIVSIV**
Guys, "say" is available (along with many other osx utilities) in the gnustep software package. Runs on every unix.
Yup, I proposed GNUstep to leave the script unchanged. As an aside, many "OSX only" scripts work with GNUstep installed, so try it out!
Thanks!
Source code is pretty clean, but yes, even if rvm do that, it's a very bad habit.
&gt; PSA: Opening a terminal and running something that downloads content from the internet and evaluating it straight away is a fantastically bad idea. *Especially* if a URL shortener is involved. Better: follow source link, READ source, UNDERSTAND it, verify that nothing sketchy is going on, THEN download and run. In this case, it's less than 40 lines. 
Don't forget that any future improvements that get made to the Pypy platform, Topaz gets "for free". Features like STM etc... when they stabilise will also make it easy and accessible implement advanced features to the Topaz runtime. e.g. look how 'easy' it was to bolt on the JIT.
PSA: When "Yet another guy" says the code is clean, still check it anyway ;)
That's a pity. Many essential gems used in many rails apps are written in C.
 curl -sLo- 'http://bit.ly/XXH7c9' | ruby - 
Every so many "siffs", on Mac OSX, the voice has to take a breather. This is hilarious.
&gt;perl is much more flexible as to where you can break up a statement into multiple lines, because it KNOWS the statement isn't over until it sees a semicolon. You can easily do that in Ruby with the semicolon: a = 0; a += 1; puts a
I trust RVM. I don't trust some Reddit post.
Just submitted pull request for a fork of roflcopter that varies its altitude as well. :D https://github.com/havenwood/roflcopter Also released a gem, so you can `gem install roflcopter` then `roflcopter` from the Terminal.
:D
I was trying to write python a few days ago, and I kept getting frustrated that vim-matchit plugin didn't know how to jump from the top of a method to the bottom.
Charles Nutter wrote a great post quite a while ago about how it was really easy to make a super fast ruby if you just left out a few things. These guys may have a fast ruby today but by the time they implement the whole languge they will be slower than MRI by a long shot. Mark my words.
Most of those are either dead of just toy things nobody uses in production. Rubinius and jruby are the only two which have somewhat broad usage.
If you write specs for your API then a lot of the structural issues the code might have will bubble up to the surface because they will generally be a pain in the ass to test. A good rule of thumb is that if something is hard to test, then there is a problem with the structure of the code. You can start there, then run [Reek](https://github.com/troessner/reek) on it to find code smells. You can also look into how to get rid of some of the type checking that plagues most of the Bustracker class. One way to make these go away is to introduce a parameter object instead of the methods taking an array. That way, the methods do not not have to run the redundant checks for size of the array and such and you can remove a LOT of unnecessary code.
Bah, live a little! ;)
Finally!
&lt;insert musical joke here&gt;
Can you explain the parameter object? You mean it would just be a regular object that contains the array or something? Wouldn't you need to check the type of that anyway? I'm not sure I really understand. I'm still new with Ruby.
You may want to x-post this into /r/chicago 
He also wrote http://blog.headius.com/2012/10/so-you-want-to-optimize-ruby.html (based on an email conversation with me). Look closely, we've got just about all of these things implemented, and some of them *better* than other Ruby implementations. For example JRuby requires a command line flag to enable `set_trace_func`, whereas on Topaz it's always available. I've worked on Python implementations for almost 4 years now, I'm extremely used to people making claims that they've implemented Python when they're missing key language features, it was a key design point that this was not open sourced until it had these problems solved.
I was at PyCon when PyPy was presented for the first time. It went something like this: &gt; "We've implemented Python in Python and it's only 1000x slower than CPython!" &gt; &gt; *furious laughter* The next year, it was much the same: &gt; "We've implemented Python in Python and it's only 100x slower than CPython!" &gt; &gt; *slightly less furious laughter*. A year later, the tone shifted more: &gt; "We've implemented Python in Python, and it's about 10% slower than CPython." &gt; &gt; "Wait... how... what?" Today, PyPy is *at worst* a few percentage points faster than CPython, on average maybe 3-5x faster, and on certain workloads is as much as 100x faster. So in about 5 years PyPy went from a joke to being a massive performance win. All that to say: I wouldn't bet against Topaz. If Alex et al. continue working on it, it'll be faster than MRI, and it could have a shot at being the fastest Ruby implementation available. So be careful - in a few years this might be your "less space than a nomad" comment :)
this is technically a problem in rack, one of rails dependencies, not Rails. But, sure, okay, things are maturing. Like three "drop everything to upgrade all your apps even though it's your day off" issues in a month sure aren't fun, but if it means we get very few of these for a long time now... well I sure hope so. I'm just glad I finally got all my apps on rails3 _before_ all of this stuff. Those stuck with legacy pre-bundler rails2 apps are REALLY not having fun right now. 
You're correct, it's a rack issue. I meant the Rails ecosystem more generally - I wasn't clear, though, so your points are germain. :-)
So... does anyone else's boss want you to start deploying new apps and sites in .NET? This shit is getting expensive.
What you wrote was the inverse of what you quoted and does not disprove sockmonk's statement in the least.
you'd be amazed how much timing can be guessed/inferred. I read a whole article about it. I can easily determine the RTT to your server, I can probably guess that you're using NTP... if you application displays a timestamp ANYWHERE, I can probably get it down to a few seconds on either side... from this point, you can probably win once within 50,000 requests.
Yep just got a phone call. Switching to .NET and as we're migrating the software we're also changing our OS db for a much more secure oracle database. That will save us a ton of money! :-)
Yep, that's why I always do the Stripe CTFs. You learn a lot. If I, a reasonably good programmer, can find a vulnerability and craft a timing attack in a day, there are a lot of super-genius programmers out there who can do way better than me. 
I don't get it, I've just been updating gems, running the test suite, and deploying. How is it expensive?
Hey, first of all thanks for contributing a gem! I have a few suggestions for you. 1. You should probably use underscored_file_names rather than dasherized-file-names. 2. Be aware that everything in your gem's `lib` directory becomes a part of `$LOADPATH`, so the typical directory structure has a file with your gem's name in lib and a directory with your gem's name that contains your gem's structure. For example: cti_api.rb cti_api/ bus_tracker.rb bus_tracker/ train_tracker.rb train_tracker/ This prevents bus_tracker and train_tracker from polluting the global namespace. Here's a list of [common gem conventions/patterns](http://guides.rubygems.org/patterns/) that may help. 3. I strongly dislike this pattern: def initialize(params) params.each do |key, value| self.instance_variable_set("@#{ key }".to_sym, value) end end I think it's far better to explicitly declare your instance variables. Metaprogramming that saves characters but doesn't make your program easier to understand isn't helpful. Alternatively, the `Point` class and similar 'trivial' classes would be a great opportunity to use [`OpenStruct`](http://ruby-doc.org/stdlib-1.9.3/libdoc/ostruct/rdoc/OpenStruct.html) from the standard library. 
How many sites do you have to maintain? Are you giving away your labor for free? Running test suites is fine, but are you still testing the user experience?
Wait, are you being sarcastic?
JRuby, Rubinius and MagLev are the only ones that aren't either dead or just toys.
Thanks for that link. I'll watch the rest a little later but I see where he's going with it.
Depends... First you're assuming every app has a thorough test suite. While that should be the case, I'd say it's not true for the majority of apps. Second, test suites only test what you thought to test... I had an app written years ago running rails 3.0.3 and it was a nightmare with these security issues. Even though I kept it at 3.0.X there were numerous things that broke. And of course that was a rush job I was only one developer on and the developer who was supposed to write tests got pulled off for other things, so the app had just about 0 tests.
Thanks for that! I'm sure that confused a lot of people.
That's really cool. I had never heard of OpenStruct before. I could probably get rid of a lot of classes by just using OpenStruct.
There are lots of cool things in Ruby's standard library. You should go exploring!
Dude, OpenStruct is blowing my mind. It's exactly what I've been looking for. The whole reason I created the Pattern class, Prediction class, etc. is because I wanted to create a Hash-like object without it getting too complicated or messy. OpenStruct fills that need perfectly.
Well I'm sorry but if you just google cve .net you'll find that the first 4 vulnerabilities in 2013 were .net ones. I personally just accept the fact that exploits happen in any language and framework and use whatever language or framework that fits my needs. But that's just my opinion :-)
These changes should have no impact on anything UX related.
If you are maintaining 100 sites, it's worth spending the time to automate (or at least semi-automate) any kind of global gem updates. It's not really that difficult if you use a little foresight. 
Good point. I am not a Rails expert.
This thread evidences why I so &lt;3 /r/ruby. Thank you, gentle peoples.
Charles and his crew put in incredible amount of work on Jruby and it's still not faster than MRI when it comes to running rails. Good for you for trying but I am not holding my breath.
Just made a naive test on cache missing: https://gist.github.com/luikore/4745289
The operative word is "should".
You are awesome for running that test. Thanks, it's cool to see! 
&gt; But you get a whole load of other benefits including knowing "this is the proper Ruby interpreter" Which is why Ruby needs a spec.
Isn't object.tap_if the same as [object].select { .. }.each { .. } ?
Well, some Rails styles have been very influential in the Ruby community (quite different from the original Matz style, for example). The type constructors are actually useful and should be used more. For example, `Integer` is often better than `to_i` because it will throw on bad data: Integer("42") =&gt; 42 Integer(" 42") =&gt; 42 Integer("poo") # throws AgumentError Integer("42.5") # throws AgumentError Integer(nil) # throws TypeError whereas "42.5".to_i =&gt; 42 "poo".to_i =&gt; 0 I often see people use `to_i` to check for valid numeric strings, which is just plain lazy: if params[:count].to_i != 0 Post.limit(params[:count].to_i) ...
&gt; a tree, whereas HTML often ends up as tag soup. So much this. I dont care if ruby supports significant whitespace. I dont like or dislike this kind of style, but i see no reason to use it. I would stick to the good ends. Emacs does autmatically indent code for me, so i dont have to mess around. I use haml for years now and i really love it. Ruby + Jquery + SASS + HAML is so. much. win.
Is anyone familiar with the differences between: * state_machine *(this)* * AASM * workflow ??
"Gem signing breaks using the git repo directly via bundler. Since that's pretty common for all gems, it means no gems can be signed." https://twitter.com/mperham/status/299921788257832960
Do you mean open source to contribute to, or open source to use to build your app?
This makes no sense to me. Some people will want a gem to be authenticated and signed by the author. They'll get the signed gem from rubygems. Some people will want to grab the head of a branch straight from a git repo, which probably won't be signed even though git allows you to sign tags. So the people who want an authenticated release get a signed gem from rubygems. The people who want a bleeding edge release and don't care about authentication can get that from git. The end user can choose whatever method is appropriate for their circumstances. What is broken?
Is signing on apt-get broken because some people compile from source?
Checkout http://rubykoans.com/
You can sign git tags using your PGP key; [rubygems-tasks](https://github.com/postmodern/rubygems-tasks#readme) supports this if it's enabled in Git/Hg. Newer versions of git support a `-S` option for `git commit` which signs the commit blob. Perhaps that could be used to verify bundled git repos? Also PSA, it's not safe to bundle git repositories long term. There is no guarantee that a serious regression might accidentally sneak into master at any moment. Certain gems such as [Nokogiri](https://github.com/sparklemotion/nokogiri#readme) and [FFI](https://github.com/ffi/ffi#readme) refuse to support the ability to bundle from git.
You could try highline by JEG. It's well written and well documented. http://highline.rubyforge.org/ You could also try codeforpeople. http://rubyforge.org/projects/codeforpeople/ Last year i came across a todo app called dooby which was quite well written. 
You might have fun with my project RubyDNS =D
read code that you use. if you use gems, read that code.
Rubinius, you will lean about Ruby and about stuff written in Ruby at the same time :)
What about http://railsforzombies.org/.
Hello Markolson, This is really cool. I have plans to create GIFs in real-time and post them to social networks. Could this gem allow me to do this? All in an automated fashion of course :-)
If mperham could just do that I think he would. However there seems to be issues with the process which is why he stopped signing gems.
Have you tried configatron? https://github.com/markbates/configatron
He will still need to somehow distribute the configatron object to the rest of his project.
There's the easy task of just including it as a mixin to whatever classes require it (be honest, not all classes will need the config and logger). module Logger def ...; end end module MyGem class Thing include Logger end end Or, you could have a baseclass that implements the `logger` and `config` methods which everything inherits from: module MyGem class Base def logger(msg) end end end module MyGem class Thing &lt; Base def do_thing logger.info "doing thing" end end end Or do a combination of them by having the baseclass mix in the logger module for separation of concerns. But, this all comes down to inheritance. Mixins/included Modules expand your inheritance tree. However you include the functionality changes how it's structured, but in essence they do the same thing. And another less desirable, but perfectly reasonable option is to monkeypatch something basic like Kernel class Kernel def my_logger end end module MyGem class Thing def do_thing my_logger.info "doing thing" end end end I hate constants, unless it's just a simple (private) accessor to some static bit of data. tl;dr: your list in your question really hits on the ways you could do it. It comes down to whatever method you feel most comfortable with. They're all pretty reasonable.
What would you do in Gem?
I don't think this is a good reason to mix in or extend anything. Module.method for logger, and Class.class_method for the config would be my personal choices.
I view logging as a basic part of the run-time environment, its availability being almost as necessary as air, and as such, I see no problem with extending Kernel with logging functions. Functions added to Kernel are globally accessible, so there is no need to litter every class with an include for the logger.
A class instance variable perhaps? module Configuration def self.config @config ||= DEFAULT_CONFIG end def self.logger @logger ||= # default logger setup here, you get the gist end end # anywhere… Configuration.config Configuration.logger.debug "KABOOM!" Although, personally, I'd change the names. You'll need the assignment versions of these too, unless you want to set them up in another way.
Create a module and just use methods from it, or include it in each class or module you want to use it in. Simple, easy to understand, and works well.
Two years ago I started building the RailsApps example applications and writing the tutorials because I couldn't find any Rails open source projects that were well documented for people who wanted sample code to study. It's grown as I've gotten a lot of help and support for the project. Always open to suggestions for new examples and tutorials. Most of the examples are for intermediate-level developers. We probably need more beginner-level tutorials.
Explanation can be found [here](http://www.zweitag.de/en/blog/ruby-on-rails-vulnerable-to-mass-assignment-and-sql-injection).
If you've got a bit of time (2ish hours) make a game. Have everyone write a class to play Rock, Paper, Scissors and pit the classes against each other to see who the champion is. We did this at the Ruby Hoedown in 2008 and it was pretty fun.
complicated question. I'm Logger::Application user. Once I share it through singleton. And now I prefer use $global variable. Or just log only on application level, like here: https://github.com/paranormal/blooper/blob/master/lib/blooper.rb Please comment my approach. Is it right?
According to the changelog, the JSON gem dependency was not changed and you'll need to upgrade it yourself.
You could work through the Amazon book [Practical Ruby Projects (amazon link)](http://www.amazon.com/Practical-Ruby-Projects-Programmer-Professionals/dp/159059911X/ref=wl_it_dp_o_pdT1_nS_nC?ie=UTF8&amp;colid=OMCNDXEOJR6C&amp;coliid=I3F4TZHQ07VEIA). They have some really interesting projects in there for checking out. 
Just occurred to me : you could also study the wildly popular `homebrew`. https://github.com/mxcl/homebrew Many years back (as a newbie), I studied the code of *clip* by Chris Wainstrath (he went on the start github, iirc). It's a nice small library with a lot of rubyisms -- you won't get lost in it. http://clip.rubyforge.org/. I even found a couple of bugs in it and submitted the fixes to the chap who took it over. Good moment for a newbie.
I'd say thanks, but I'm not the organizer; those aren't *my* ideas. Indy.rb =)
I did a pair programming event like this, and it worked out great: http://www.tokyodev.com/2012/10/22/pair-programming-event-a-success/ I had about 24 participants, and broke everyone up into teams based on a survey participants answered when signing up (I wanted to make sure skill levels weren't too different). I did the event on a weekend afternoon, as I thought participants wouldn't want to do more programming after their job.
I ran a ruby meetup for three years before I moved in 2010. My first suggestion is that you make the meetings consistent like every third Thursday or whatever and try to find a quiet location where you can have a projector and pizzas. Conference room or cowork space is good. Typically the host or at least he location will have some professional or business interest in the group such as recruiting. Beer is nice but let some local employer of developers sponsor the food and drinks. If you keep it regular eventually your attendance will grow. The problem we had was reconciling the desire for advanced pros to just talk about whatever crazy thing they were playing with ... With the newbies desire for intro topics. Good luck!
The more I think about it, the more I'm convinced that this is what's going on here: &gt; YAML is a human friendly **data** serialization standard (http://www.yaml.org/, my emphasis) and &gt; This is why nobody uses Marshal to **send objects around**. Think of YAML as a human readable Marshal. (tenderlovemaking.com, my emphasis) That must be my formal database background talking I suppose.
It's far enough from smalltalk that you'll hate it.
Definitely use the attendees to volunteer presentations as much as possible. Suggest possible talk ideas, and include in the mix talks on more than just pure Ruby talks. Some of the best NWRUG talks I ever went to (in the UK), didn't mention Ruby once, but were exploring other frameworks and languages on the assumption that people into Ruby are just as interested in ideas and abstract concepts and new technologies as they are Ruby.
populating instance variables is a crime
Populating instance variables is a standard ruby feature used extensively --- this 'magic' is the basic reason ruby is preferred so much.
Which OS? Don't know of any cross-platform screen capture gems, but for Windows I've used [win32screenshot](http://rubygems.org/gems/win32screenshot), which includes ImageMagick DLL's, so no further install required. 
Hmm... god damnit. I feel like I should have known that. I probably did at one point but just forgot about it. I've been doing array[0..5] for some time now. Well, maybe not stupid simple but Enumerable#reduce came in pretty handy the other day. Oh, and Hash.new(0) is pretty neat as well. It makes it so that if you access any non-existant key in the hash it will create it for you with the value of 0 (or whatever you pass into new) by default.
Pass parameters to an initializer
I've run into that hash problem before. Took me a good half-hour of furious doc-reading before I figured out how to solve that.
For some reason I can hear your cursing while "furious[ly] doc-reading"
I like the instance_eval(&amp;block). I often preferred Object#tap instead of method-wide local variables so I could do stuff like this: SomeModule::SomeClass.something(some_params).tap do |me| me.do_stuff me.do_some_more end with instance_eval it's even better SomeModule::SomeClass.something(some_params).instance_eval do do_stuff do_some_more end 
&gt; I propose that the meaning of “safe load” would only load Null, Booleans, Numerics, Strings, Arrays, Hashes, and no self-referential data structures. This is easy to understand. You only need to know about 6 data types, not a laundry list of possible classes Yup. I agree completely. Every single YAML file I've come across just uses the basic YAML types and doesn't use typing. However, instead of throwing away the baby with the bathwater, adding such a safe method allows people the best of both worlds. Tie it to a config var so those who want unsafe code can use unsafe code
The point in tap is that it returns the object in the end, whereas instance_eval will return the value of the last statement of the block.
If you really wanted to, you could make `self` the last statement in the block.
I use the block form of Hash.new to create easily nested hashes as well. Saves a lot of nil? checking. ie: Hash.new {|h,k| h[k] = Hash.new {|h2,k2| h2[k2] = 0 } } That way h[k][k2] will never raise an error about a non-existant [] method on nil.
I feel like I must be reading this quote out of context. You can sign software when you build the package, in this case a gem. You can verify that signature when you get the gem. I don't understand what a Gemfile has to do with anything. You don't use bundler when packaging a gem. You use it to get various dependencies. If you get actual packaged gems, you can (in theory) still verify them. If you get the actual source from git, you probably can't. So I don't get the logic in the leap from "signing may not be useful in some cases for some people" to "You can't sign and it's totally useless."
I don't understand the "Ruby Symbols are never garbage collected" problem. I booted up IRB and put in the following: require 'securerandom' loop do SecureRandom.uuid.to_sym end When running, the `ruby` process was running at 100% CPU and was eating up RAM at about 3-5 MB per second. I expected this to run until my computer froze. Instead, I got this error (which I have never personally seen before) after about a minute: RuntimeError: symbol table overflow (symbol 85bbfee7-ed2f-47cf-a...) from (irb):3:in `to_sym' from (irb):3:in `block in irb_binding' from (irb):2:in `loop' from (irb):2 from /Users/ryguy/.rvm/rubies/ruby-1.9.3-p362/bin/irb:16:in `&lt;main&gt;' Symbol table overflow? So, Ruby throws an error when the table it holds all of the Symbols in reaches a certain size? If that is the case, why would that DoS a server? Wouldn't that single request simply fail, while the "symbol table" is truncated and the life of the server continues?
I hope this was a joke XD
- It's open source. - It's ruby. - Lots of examples and fun to muck around with. The OP didn't say they were a beginner at computers, just a beginner at Ruby, perhaps they are an expert in other languages and systems? I don't know :D
A very cool trick for autovivification using the stored default procedure recursively, which allows you to go to arbitrary nesting depth: h = Hash.new {|h,k| h[k] = Hash.new(&amp;h.default_proc)} You can then nest arbitrary hashes: h[2][:foo]["bar"][:nurgle] = 17 h # =&gt; {2=&gt;{:foo=&gt;{"bar"=&gt;{:nurgle=&gt;17}}}} 
Anyone who considers themselves a serious Ruby programmer should read up on a different method in Enumerable per day. There's some serious gold in there.
Erlingur! Gouda day to you my friend :)
Thanks for the tip. 
Maybe I'm blind but, does osvdb have any type of rss feeds? That would be helpful. If not..ahem...mechanize could help flag the listings, at the very least turn it into a todo list for human intervention on the yml data. EDIT: nm, I see you just yanked the contribution portion, assuming a different route now.
In this particular case, I'd prefer: people.uniq &amp;:name 
I would normally do the same, the explicit syntax is for the sake of example. On a related note, you can do the same trick for `inject`: `[1,2,3,4].inject(&amp;:+)` =&gt; 10
No whey! You too :)
Inject's a bit special: [1, 2, 3, 4].inject(:+) # =&gt; 10 I believe this came forom a time before to_proc.
Unfortunately I'm looking for something that works on a desktop.
Linux mint , maybe I could use scrot.
If I use bundler with a Gemfile the following way: gem 'agem', :git =&gt; 'http://github.com/auser/agem' and that gemspec on github specifies some signature for signing, wouldn't my bundling fail? For this to work I should keep a gemspec without any signing, and a gemspec for signing, in the same repo and use them smartly.
Hash class has [] method defined on it which builds a hash from an array: Hash[1, 2, 3, 4] #=&gt; {1=&gt;2, 3=&gt;4} especially handy with splat operator: Hash[*some_arr]
Yell has a centralized repository for all loggers defined. It is not tied to Rails in any way, so you may use it in any Ruby process. Also, with the [Yell::Loggable](https://github.com/rudionrails/yell/blob/master/lib/yell/loggable.rb) module, you can do a little more than just enabling any class to have a logger. There is a basic example [here](https://github.com/rudionrails/yell#you-want-any-class-to-have-a-logger). If you need further documentation, I am happy to add a section to the wiki.
It's been a while, so I can't remember myself, but I do know that many Rubyists of even 2-3 years experience struggle with yield, procs, lambdas, etc. at a detailed level. Oh, and amazingly, #send seems to leave many people flummoxed for a long time
I actually saw that example but had no idea how to use it. Perhaps I am being noobish. But where do I define the "Yell.new :stdout, :name =&gt; 'Foo'" line?
I would prefer to use Array#take(n) which is more self-explanatory than Array#first(n)
Okay, that makes sense now... Yeah I guess that would blow up with the current signing mechanism. I forgot that was configured in the gemspec. In the plugin I wrote that does openpgp signing, you do: gem build foo.gemspec --sign gem push foo-0.0.0.gem If you're the real author/publisher, you do that before sending to rubygems. If you're getting the source from github and building locally, you can still build it just fine. So actually... one more reason to use rubygems-openpgp!
Fun fact about `Enumerable#reduce` (aka `#inject`), sometimes you need to do something complicated to a particular object, `#inject` requires you return the accumulator object at the end of your block, leading to code like: [1,2,3].inject([]) do |i, acc| complicated_thing_on(i, acc) acc end which is ugly (because you have the trailing `acc` there just to please ruby's interpreter). Instead, you can use `#each_with_object` like so: [1,2,3].each_with_object([]) do |i, acc| complicated_thing_on(i, acc) end In fact, I don't use `#each_with_object`, I just use `#with_object`, like [1,2,3].each.with_object([]) do |i, acc| complicated_thing_on(i, acc) end This is because `#with_object` works on anything `Enumerable`, so I can also do shit like: [1,2,3].map.with_object([]) do |i, acc| complicated_thing_on(i, acc) end So now I can both map to transform `[1,2,3]` and also update an accumulator. I can also chain more than one if I need multiple accumulators. `#with_object` is awesome.
You might want to have a look at : https://github.com/jhchabran/photograph which should do the job if you want to capture web pages. If you need more options the code is damn simple, just create a PR and I'll have a look at it. The only requirement here is phantomJs which can be easily installed depending your OS. 
cool project, weird indentation ;)
And now you've started requiring that any class you serialize be initialized the same way.
Note that the symbol#to_proc thing adds extra overhead, something you don't want to do if you're working with a lot of data. Usually this is not really a problem, though.
That will break existing apps.
To make a new hash yes. I used just the output if you puts, print or inspect.
http://i.imgur.com/BPNYdza.png Better?
That's an extremely fun way to introduce subtle bugs: x = Hash.new([]) x[:key] &lt;&lt; 'y' x[:other] &lt;&lt; 'z' x[:lame] #=&gt; ['y', 'z'] 
From your report, sounds like it fatal error'd -- where did you get the idea that it would 'truncate the symbol table'? Sounds like instead it crashes. And quite likely puts the entire server process in a crashed state from then on out, more than just causing that particular request to fail, is what I'd guess would happen from your report. But yeah, it might not in fact exhaust all server RAM, but putting the server process in a crashed state is going to DoS you one way or another (either it restarts, and you can DoS by causing the server process to continually restart, or it doesn't, and it's DoS'd already, right?) But yeah, sounds like, at least in MRI, the situation is not quite as simple as people's summaries of it -- it fails when it runs out of address space for symbols in your test, rather than when it actually runs out of RAM. But the end consequences are more or less the same (really bad). Specific details between diff ruby implementations may vary. 
Seems legit. Looks good. Well documented. Good job!
Needed "natural" sorting a while back, was dissapointed that ruby's stdlib (Array) doesn't have natsort (even php's stdlib has natsort). Small suggestion: consider making it possible to just extend the Array class with a natsort method: require 'naturally/ext/array' %w(1.0 1.10 1.15).natsort...
 {heart: 'you'} # no need for double quotes
I think that's an acceptable consequence of having a safer ecosystem. What about using higher safe modes? 
You're right, works as well but I like it more with single quotes.
Can we have it with single quotes? :D
My first thought was "how unfortunate... the you is in double quotes"
Sometimes I feel like I'm the only ruby guy on Linux.
Congrats on the first gem! To really feel like ruby, this should probably be mixed into the enumerable class. Happy to help with a pull request if you need it.
We have a similar sorter here, although the algorithm appears to be quite different. Ours handles values such as the following, for instance %w{ item1 item100 item10 } As far as I can tell, in your algorithm the numeric component needs to be prefixed rather than appear anywhere else in the string. 
Up vote for comment about regex thread safety because I didn't know this! Will be looking into this today, thanks.
I wrote a library called [LogJam](https://github.com/free-beer/LogJam) to address this issue. This allows you to add logging to a class by including a line like this in the declaration... LogJam.apply(self, "my_logger") This then gives you both a class/module and instance level log method to retrieve the logger. There's more to it than this but this is the part that addresses the point you have raised.
That's a nice write up. Thanks for posting.
Maybe it already exists somewhere? Or is there a better way? Or have you ideas to improve? Thanks :-)
I know this is not code golf, but what's wrong with just this? module Enumerable def natural_sort sort_by do|s| s.scan(/(\d+)|(\D+)/).map{|a| a[0] ? a[0].to_i : a[1] } end end end Works like this. ?&gt; %w[file1.txt file11.txt file2.txt file12.txt file20.txt file100.txt].natural_sort =&gt; ["file1.txt", "file2.txt", "file11.txt", "file12.txt", "file20.txt", "file100.txt"]
A comment on the testing: Does this sort the array or return a sorted array? In other words: a = %w[b a] Naturally.sort(a) Does a now == ['a', 'b'] or ['b', 'a'] &gt;it 'sorts an array of strings nicely as if they were legal numbers' &gt;it 'sorts a more complex list of strings' do &gt;it 'sorts a smaller array of strings nicely as if they were legal numbers' do These should be the same test. The behavior here is exactly the same. Also, you should call out that this behavior is specifically for sorting strings that can be numbers, since you have a later behavior about sorting strings that also contain numbers. I would rename this to: &gt;it 'returns a sorted list when given an array of numbers formatted as strings' do These behaviors are also the same: &gt;it 'sorts when numbers have letters in them' do &gt;it 'sorts double digits with letters correctly' do Rename this to: &gt;it 'returns a sorted list when given an array of numbers followed by letters formatted as strings' do You might want to add a test in here for behavior when given an empty string. Under this behavior: &gt;it 'enables sorting objects by one particular attribute' do I would add a second assertion where you sort by name (if your gem's behavior includes sorting just strings. 
I was so happy for him when he founded HashiCorp, and now he makes me happy in return.
Well, since 'you' is representative of a thing, as is 'heart', might as well just do { heart: :you } Although if one were to get more semantically accurate, and idiomatic of Ruby, you'd go for objects rather than hashes, and heart as a method, because it's an action: i.heart(you) But if this is in the context of your`self`, you can drop the receiver: heart(you) Or more minimalistically: heart you And we should probably also `alias heart love`, again, for semantic correctness. *Edit:* Ruby also has unicode method name support, so we can actually go as far as: ♥ you
Downvoted, no tests.
I stand corrected. However, I still think that using named capture into locals is better.
Agreed
I just learned this recently myself, but for regex, `\Z` and `\z` mean different things. If you want to match the end of a string, use `\z`.
I use Sinatra quite a bit in production, never used Padrino. IIRC, RubyGems.org uses Sinatra.
Looks like they're on Rails 3.2, not Sinatra... 
Ah, it turns out their website is Rails and their gem serving is Sinatra. http://rubygems.org/pages/about
Cool. Generally keep it to small apps? Modular approach of structuring the code? I just really have no idea where the level in the community is.
I mean, if you're going to tie in an ORM and deal with a complicated asset pipeline you may as well go with Rails. But Sinatra is great for smaller projects, API web services, projects that simply give a web front end to UNIX tools, and any project where you are breaking enough Rails convention that it'd be easier to piece it together than to bend Rails.
Yes, `\Z` will chomp the final newline, whereas `\z` won't.
The biggest problem I have with Sinatra is that any time I use it I keep wanting to add enough features to whatever project that I'm working on that I eventually just keep making Rails. But if you know the scope is limited, it's pretty quick way to get a webapp up. Especially if you're just serving up an api and don't need to persist anything.
If you're building out an API and are interested in something Sinatra like, one could always check out https://github.com/intridea/grape It's a little DIY, but it'll keep you close to Rack and learning about rack middleware.
I'm a big fan of Padrino and have used it on a few of my personal projects, but nothing professional....yet :)
How so? I'm a noob.
Ex dancer guy here. Sinatra has plenty of uptake, as others have said, it just depends on the scale of the project. Obviously coming from dancer, the transition will be pretty painless. You will also find that it's a lot better documented than dancer, and is very mature. I can't speak about padrino, I personally haven't bothered with it just because Sinatra does everything I need. But if you're looking for another cool microframework, ramaze is worth checking out.
My rule of thumb: use Sinatra when you just need webservices that return XML or JSON. Use Rails if you're building a website. I love Sinatra!
Named capture groups are great! The only oddity is that you have to put the regular expression on the left, I'm still trying to get into this habit.
Ahh then then me introduce you to the [Ruby Style Guide](https://github.com/bbatsov/ruby-style-guide). On that page you'll find "Prefer single-quoted strings when you don't need string interpolation or special symbols such as \t, \n, ', etc." 
In my experience Sinatra is primarilly used to build proof-of-concept apps, small production apps, or as a tack-on to a Rails app - e.g. for API or Admin endpoints. Looked into Padrino, but never found a place for it.
Same problem. I have a sinatra app that uses haml and active record. Recently I was thinking it'd be handy to add active admin in for some stuff and wondered why I didn't just use rails to start with...
I've been heavy in to Sinatra recently. I am running the gamut from simple little APIs to a fairly big web app with it. Honestly, it's quickly become one of my favorite tools. It is quick to learn, but really configurable and nice. There are a lot of other commenters who say that it quickly becomes Rails, and while that's true, I think it's OK, because it becomes Rails tailored for you. I saw a post a few weeks ago from DHH about the opinionated nature of Rails, and while he is certainly entitled to take things in the direction he wants to, I don't want to go to there. I like keeping it flexible, prefer to use DataMapper over ActiveRecord, and want Warden pre-rolled in a Bootstrap shell. In a small way I recreated Rails, but I don't care, really, because it functions the way I want, and I can spin up projects super fast. 
Um, still looking at using Ruby. Would you say that Rails is suitable for mostly contenty websites, or just websites that are really web applications?
Interested in seeing the source.
I use sinatra and rack::mount for my web stuff. Each section is it's own sinatra app, and rack::mount does the namespace routing. I keep helpers and DB stuff separate and just require as necessary. It works pretty well for me. I was never a fan of Rails, feels too big and unwieldy... It works for me, but do you think there's anything inherently wrong with my approach? I've been wondering if I'm actually missing out on anything.
I've used Grape in several rails apps to provide an API to mobile applications and it has always been really great to work with. Dead simple to use and can easily integrate with the rest of your rails app as much (or as little) as you want.
If you listen to people who use Rails a lot, you get the "it's great for small projects…" etc. In my opinion, that's just people who are outside their comfort zone, and that's fair enough, frameworks are there to make life easier. But! it doesn't mean that they're right. For those (like me) who were never that sold on Rails in the first place, you won't hear any complaints about scale because it's good for large or small projects. Rails isn't going in the right direction for the way the web is shaping up anyway (IMO), but you should weigh up where you think you can carve your niche best.
I think it's a perfect fit for micro services; not end-user applications. 
I see this as a feature, not a problem. Maybe 6 out of every 10 Sinatra apps end up in Rails eventually. But it's pretty easy to upgrade them to Rails when it grows to be necessary. Hell, you can even mount the app inside Rails and do it incrementally. I love Sinatra and find it very valuable for little projects, web hooks, simple dashboard interfaces, and for proving out ideas.
I have one Sinatra app out in production for uploading and converting files using image_sorcery and a second app that's an api to queue and encode video files. I would recommend Sinatra with no hesitation and it's such a small code base you can grasp what is going on in no time whatsoever. Great DSL also.
This looks nice. We've recently written a similar thing, but I like some of the ideas. At the moment we have a gem used across multiple sinatra services that handles all the shared things, like this kind of exception handling and OAuth, etc. I'd like to hear if anyone else does think there's another better solution out there. I particularly like the application level DSL. All we have at the moment is a mapping of exceptions to lambdas that can be overridden in the application. Our API is pure JSON but it's good to respect the accepts headers of the request
If you're a Perl guy you ought to try out [Mojolicious](http://mojolicio.us/).
I'd be interested in knowing more about your approach. It seems I have similar problems than yours, including the need to respect the Accept header, even when errors occur (error messages must be sent according to Accept, but not all are allowed, generating further exceptions, and so on).
Yeah sure, what I'll do is evaluate your project over the weekend and see the similarities. I've not read through any of your source yet. Ours is not open-source but I'll see what ideas I can borrow and/or share. Possibly break out into and open source gem.
I love Sinatra. It's great for building REST APIs, which I do a lot of. Sinatra+ActiveRecord+RABL :) I took a break from Ruby for a while when I got a front-end dev job that consumed most of my time and Sinatra was how I got back into it (hadn't used Rails since 2.3 and wasn't too pleased with it back then). I've built fairly large apps in it, and I've not been disappointed with how they turned out or how they perform. That said, now that I'm back into Rails in full force, under most circumstances I don't think Sinatra would be my first choice for building a large web app, since Rails has more baked-in conveniences - but it still is my first choice for building a web *service*. The extra time I spent in Sinatra did more to improve my skills as a Ruby developer than working in Rails previously had done. 
Sinatra is great for lightweight apps. But 95% of apps I've seen done in it (which is a smallish number relative to the number of apps I've seen in Rails), basically try to reimplement a lot of stuff in Rails one way or another. You must have heard the quote "Those who don't understand Unix are condemned to reimplement it, poorly". That's how I sometimes feel about people who eschew Rails for Sinatra. The key I think is to realise that in the same way Unix is lots of small tools that work together, in recent years Rails has started to evolve in that direction: choose your ORM, choose your renderer, etc. That said, if you're writing lightweight APIs that are basically little more than a DB-to-JSON mapper with some business logic thrown in to abstract away the database implementation and provide more web-friendly AAA layers, then you'd be a fool to dismiss Sinatra.
I used sinatra for a small project before and I instantly fell in love. I have no idea how it would perform on a huge project, but for what I do it's ideal.
Very true. I've given up on whether Rails or Sinatra is better in general, and instead ask myself if I want to build the product top-down or bottom-up. In many cases, I end up either (Rails) decommissioning or replacing pieces as needed or (Sinatra) building or integrating pieces as needed. I have yet to use Padrino for anything other than toy apps, but it may strike a useful middle ground for many projects.
[My simple ass website](http://jonlaing.com/) runs on Sinatra. For this simple task, it was very enjoyable to use. All the images are being grabbed from S3, all the page templates are in HAML, and all the static content is in Markdown. I finished the whole thing in very short amount of time. So, yeah, if the scope is right, I totally recommend it.
I hear this constantly, but there's usually little elaboration afterward. I started trying to learn Rails and Ruby at the same time, but got understandably overwhelmed. I looked at Sinatra later and it seemed like a great alternative. I like how simple it is and it's nice knowing there's nothing in my app that I didn't put there myself. I get the argument that at some point, if your Sinatra app gets big enough, you might as well be using Rails. I don't understand, though, why its apparently so bad for non-api purposes. Why is it such a bad fit for websites? I'm still having a great time building mine out and I haven't hit anything so far where I would need Rails.
Exactly. Rails definitely has its own sweet spot. If the project goes to a different direction a more hands-on approach like Sinatra might produce nicer results. I love how Sinatra seems to have a really good and balanced API that provides both useful high level constructs and convenient access to HTTP details. I have a project where the web site is just one part of the whole system. The system accesses data from the file system (no db) and the web site is loaded on demand from the system's repository. Having something like Rails there would make it quite difficult to get the web site working, but with Sinatra&amp;Rack I've got the whole running in less than 300 lines of code (including the controller for the single-page-app and JSON REST api).
With these smaller frameworks, it doesn't matter all that much if they're hugely popular. A monstrosity like Rails needs to be popular in order to survive (or have someone with deep pockets pushing development), but Sinatra is what, 2,000 lines of code? What's really at issue here is its capability and whether its principals match your needs. Which is sounds like they do, so go for it.
You must drink a lot of milk if you need an 18-wheeler to make your grocery trip...
I suggest you visit [code climate](http://codeclimate.com/explore), find something that's popular, has a good rating, and relatively few classes (so it's easier to follow what's happening). Then go visit the github repo. Check out the gem and learn how to use it, poke around in the code. I suggest you keep a good book open while you're at it. I recommend [Programming Ruby 1.9](http://pragprog.com/book/ruby3/programming-ruby-1-9) or [Eloquent Ruby](http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104). Ruby can be highly idiomatic. Some of these Rubyisms, like meta-programming, optional parentheses and the various hash syntaxes can be tricky to read unless you've got an idea as to what's going on. 
I use rails on a daily basis and want to be able to make my own decisions. I feel that rails doesn't allow me to do that. Sure, it's a bit more work, but I'm using it as a learning experience for how to build a web app from the ground up. No opinions forced on me. It's a bit awkward and I'm realizing that already I've started implementing rails, but I figure I'll keep going with it for the time being.
I think that the only issue with this approach is that if your application gets to the point where you need to start hiring people or want collaborators there will be a steep learning curve for those people. This can restrict the total population of people you can attract. Depending on your approach it may be possible to get people up to speed rather quickly, but it's definitely something to keep in mind.
I just came to the same solution. I use Sinatra for APIs and rails for UI.
Not a direct answer to your question, but I prefer [Cuba](http://cuba.is/) myself. A lot of people like Sinatra when they want something simpler than a big framework like Rails, but I don't think enough people know about Cuba.
This looks great. I've only done a bit of threading on jRuby, but I'm sure there's more to it than Thread.new.
I love your art, btw
Jesse's books are always amazing. Looking forward to this one.
Thank!
Where? https://github.com/rubygems/rubygems.org/blob/master/config/routes.rb
I love rails, and I always start with Sinatra when trying trying something new. A single file back end + templates just fits my brain better than a bazillion files for {msg: "hello world"}. Also use it for all sorts of simple gem based middleware at work. Since it embraces rack it's a beauty to mix&amp;match. AFAIK github api v3 is built on Sinatra.
&lt;3 &lt;3 &lt;3
You can do services with Rails, but I find setting up REST stuff hard to memorize what commands go to what name, etc. Plus, you need to exclude certain routes (or whitelist them) to only make available what you want. With Sinatra, everything is explicit, so it's way easier to keep track of.
I agree. You can do a lot of UI. I'm not saying I'd pick Rails for every UI-system, but it's a valid solution and you can't go wrong with it. Sinatra misses a lot of the included frameworks of Rails, which I always miss. I'm hotter on MongoDB now, too, so I don't even want ActiveRecord anymore. Mongoid!
That is true. Your comment made it look like the whole thing was Sinatra though (at least to me ;) I think it totally makes sense to use Sinatra for such things
Why? attr_reader/writer/accessor provide this for you... Visibility exists in this fashion for a reason. Relying on something like this will simply make refactoring harder when that property suddenly needs to become computed or delegate to collaborator or what not.
This is not idiotmatic, nor is it a good idea. You also just broke every single line of code that uses the Array#at method. You should be designing proper interfaces, not breaking the existing interfaces and mucking about with instance variables uninvited.
Definitely going to keep an eye on this. I rolled my own threaded job system since I couldn't find existing ones that fit my needs. I didn't really know what I was doing and I'd love to get a focused instruction.
A threaded job system, did you try sidekiq? http://mperham.github.com/sidekiq/
Or you can do: [*maybe_an_array].each ...
Good point. That does one unnecessary copy of the entire maybe_an_array, though, which `Array()` does not.
I think you're assuming this is for use within an application. This is to be used within a /test/ environment within test setups and teardowns. The FAQ addresses objects containing an `at` instance method. This doesn't break any object with an `at` method.
Very interesting, thanks! How did you know that?
Easy enough, just compare the `object_id` of the objects. Every Ruby object has a unique ID. &gt;&gt; a = [3] =&gt; [3] &gt;&gt; a.object_id =&gt; 70294346701980 &gt;&gt; Array(a).object_id =&gt; 70294346701980 # Same ID &gt;&gt; [*a].object_id =&gt; 70294346680220 # New array 
That was quick! :)
Grepped the changelog for "splat". :)
Around the beginning of April. That's the most accurate I can be atm.
So lets look to examples that have worked instead. APT. YUM. And they can be examples not just for secure packing but also server administration. 
Why couldn't we take Apple's approach, but model the logistics of pushing code to Github? If we can throw out the requirement that "code must be reviewed for intent," and just worry about making sure the author has full control over what's being released; then the best way I can think of would be the SSH key public/private key-pair used for authorizing centralized code pushes, branching, and tagging. It boxes people into git, but is that a problem? It would require an overhaul of `gems`? It's not secure enough? I'm missing something?
You'll need to add in the link. You can't have a link and a description at the same time.
I'm skeptical. In practice these Linux package managers have been very secure. Also, I note that pub date is 2008.
I like the approach, too, but even if we give up the reviewing part, I think it's just too much administrative overhead. Managing the keys is very painful and can only be partially automated. Allowing revocation means we would have to be able to check the revocation status online (CRL &amp; OCSP), which is something we can't do right now in Ruby :( Also, one central root CA means one hell of an attractive target. I'd prefer something that tries to distribute the risk. Ideally, compromising a few parts of the system should still either keep it safe or at least allow for quick and seamless recovery...
[2010](http://freehaven.net/~arma/tuf-ccs2010.pdf) better? ;) I believe many of these issues to still be valid, for example what they call "freezing attacks" or a malicious mirror flooding you with an endless file, both are certainly still possible. There's nothing right now that lets clients determine the timeliness of responses. Also, the "in progress" for "better ways to handle automatic key migration" [in Fedora's wiki page](https://fedoraproject.org/wiki/New_signing_key) that followed the 2008 intrusion doesn't inspire much confidence that the situation has vastly improved since then.
A few "convenience methods" I've learned as of late: object.presence is equivalent to object.present? ? object : nil and @person.try(:name) is equivalent to @person &amp;&amp; @person.name Also if you have a situation where you know you can trust all of your attributes, you can do active_record_object.assign_attributes(new_attributes, :without_protection =&gt; true) and it will bypass any check on protection attributes.
Perfect use case example: https://gist.github.com/RyanScottLewis/4977059
Just a side note: if you play with class variables or global variables, one may want to consider thread-safety. For the case with [Yell](https://github.com/rudionrails/yell#but-im-used-to-log4r-and-i-dont-want-to-move-on) you have a global repository which takes care of that. # Declare a logger with a `name` attribute anywhere in your code Yell.new :stdout, name: 'mylogger' # Access the named logger from the global repository Yell['mylogger'].info "Hello World"
Nope
Why the heck would you want to install this globally and give it root priveledges???
Just curious, about to start with Sinatra, how does Cuba compare to Sinatra?
While I actually love Rails in general and don't personally find any reason to use Sinatra-- one major part of Rails I do _not_ like and (heretically) do not use is the 'resourceful routing'. I think it's too much 'magic', too much indirection, too confusing to figure out what's really going on or modify it to your needs -- for too little gain. So I just use straight `match` or `get` statements in the Rails routing file. At which point it becomes just as explicit as Sinatra. It does exactly what you tell it to, no more no less, no need to exclude/whitelist certain routes, etc. I do that not just for API services, but for everything. I frequently recommend people "just use Rails", I don't see much advantage to 'starting with Sinatra' -- but I also frequently recommend people just use the straight explicit Rails routing stuff (which, too, got a _lot_ nicer in Rails3), and ignore the 'resourceful routing' stuff which, unfortuantely (in my opinion) is what the tutorials and official docs try to steer you towards. I think it's over-engineered and a mistake, the 'resourceful routing'. (but fortunately quite easy enough to simply not use. You don't even need to replace it with anything, you can just plain not use it, and use the more basic routing constructs which are also built into rails). 
Hmm... I just find that simpler is better. The last project for which I used Sinatra is about 80 lines of code in one file. It does exactly what I need it to do and we use it every day. No models, controllers, views, routes, or database.yml to fuck around with. It's all just right there. Sure I could buy an entire new house to store my lawnmower but really a shed out back will do just fine.
right on. The analogy isn't quite right, because starting your 80 line project in Rails doesn't cost anymore than starting it in Sinatra, they're both free. But yeah, if you find Rails has more conceptual overhead for a simple project, that's fair. 