Suresure, I felt a little bad about publishing a gem with such a limited focus, but I think it's a good set of defaults for most projects to use, and provides some nice helper functions. I highly recommend people using it, or something like it.
sorry it looks like I mixed up two different repositories... :-/ 
Excellent :) Let me know when that code needs further explaining! I went kind of crazy in [ef634: "tore everything apart and restructured it more logically"](https://github.com/christiangenco/hangman/commit/ef634eee589641151f7fe0f31880160d8263fdc3#hangman.rb).
&gt;which assign captured groups directly to local variables And then, of course, refactor those by extract to method ;)
&gt;easier for a casual reader to understand what's going The casual reader doesn't even know how regular expressions work, and if they do, then they know what $5 means.
Ooo, the second method is much more elegant. [Added!](https://github.com/christiangenco/hangman/commit/ab74dd618aa453ad73076896ba1f2d2225f4ae4a#hangman.rb) The third method is extremely clever, but sacrifices too much readability for the compactness.
This won't work on Windows, but grabbing a word from the system dictionary would be another fun way to set the word on other platforms. `cat /usr/share/dict/words`.lines.sample.strip
If they don't know how regular expressions work obviously we should remove those too.
Thank you. For some reason a lot of rubyists are developing this snooty "objected oriented programming is the only way" mentality. Yes, OOP is a great way to build a large application, but it's not the only way to solve problems using a programming language.
Also, continuations (which, as far as I'm concerned, is magic).
Well done, you've taken a single line of code and "refactored" it to a dozen lines of code! You should be a Java coder.
From the woman who brought us catnet, a social networking site for cats!
Updated to include these constructors!
Replace Temp with Query is a well-known Design Pattern. You don't have to ridicule me just because you aren't up on best practices.
Kudos, cool idea, great presentation, and thanks for building it! I will say this though...your audience may be a bit niche for this...I think that once anyone puts some time into creating and using regexes, they will recognize their usefulness and will probably become proficient enough that they won't need your library. However, for people who have never used regexes regularly (which is a distressing number of programmers, too, unfortunately), maybe this will be a gateway drug :)
It's not a regex learner library, it's for allowing composable regular expressions.
haha, also definitely still in development.
What is `$1â€˜? As you said below, globals are too hard to understand.
And threads. Multi-threaded programs are very hard to debug, so we should remove threading too.
I have to disagree with a fair few of the points: ## Globals Why are globals bad? They have a number of attributes that make programming more difficult: * It makes testing harder, as each method may depend on a global variable * For the same reason, it can make using a library harder, as you may need a global variable in the right state before using a method. Eg compare: - Payments.processor = PaypalProcessor.new some_payment.process To: some_payment.process(PaypalProcessor.new) The first is very fragile, as if you forget the first line it won't work, or use the wrong processor. The explicit nature of the second version is much safer, and easier to use (as you know from the method that it needs a processor to work). * It makes reasoning about behaviour harder, as global state is harder to track * They normally aren't thread safe * They are difficult to refactor, as if an inner method needs a global, to refactor it you may need to pass an object, which will then change the caller method. THis can propagate to large changes. They do have some benefits though: * The quickest way to create global state * Lets you add functionality that needs global state quickly (great for prototyping) if you look at the pros and cons, there is little semantic difference between a module accessor and a global variable. Both should be avoided in large programs. In small or throwaway programs, there is nothing wrong with using globals (since the cons don't matter very much), however dollar sign globals are shorter and easier to use. ## Special global variables Agree with this one, these aren't used enough to memorize. Many of them should never be used anyway (ie the input/output field separators...) ## Regex Special variables Part of knowing a language is knowing the common idioms of it. The use of `$1` and so on is one of them. I would find it hard to believe any ruby programmer would not know what they do after a few weeks of using the language. So again, there isn't any benefit to `Regexp.last_match`, but it takes longer to type. It isn't "object oriented" either. Object orientated programming isn't just using dots, but programming with regards to classes, objects and inheritance. `Regexp.last_match` is just a method namespaced by the Regexp class. ## Begin/end blocks Yeah, can't think of anything, even with scripting where this would help enough to warrant the language feature. ## Flip flops On the fence with this one. It probably isn't used enough to warrant the feature, but it is nice sometimes when writing a script for text processing. 
thanks for the tips :] also, what would be an alternative to my fake global variables? would I just use variables instead of instance variables?
&gt;As you said below, globals are too hard to understand. I did? Where?
&gt; They're basically just a short way of doing if/else statements. They're more than that. An if/else can't be used in an expression. A ternary can.
Exactly. I don't know if I am being too pedantic, but I get really frustrated when "structs with methods" is classed as object orientated programming. 
`t` is `@turns`, or the number of turns the player has left. `#{t&lt;7 ? '|':' '}` will output a `|` if the player has less than 7 turns left, else a space. Not the most elegant way to do it, but it got the job done :p
Yup! And restructuring your code so you don't need the global variables anymore. For example, my rewritten code doesn't have a `@game_over` global variable anymore because I just check in the main loop if the game is over (if turns run out) or won (if `won?()` is true).
Tic Tac Toe is a good one at your level. Once you program the game, you can program an AI to play against too!
BEGIN and END go hand in hand with ruby -n. Here's a shell utility that sums numbers from each line of input: #!/usr/bin/env ruby -wn BEGIN { $total = 0 } case $_ when /\d\.\d/ then $total += $_.to_f else $total += $_.to_i end END { puts $total }
Wow, I didn't know about this feature and I don't think I like it at all. Not only does it reach outside the expected role of an operator and mess with local variables, but it's a hack at the parser level that only works with regexp literals? http://www.youtube.com/watch?v=8JNuqEz_GCQ
I didn't know this. The things you learn 
Calling [`SomeClass.new`](http://www.ruby-doc.org/core-2.0.0/Class.html#method-i-new) (which is a class method) calls [`allocate`](http://www.ruby-doc.org/core-2.0.0/Class.html#method-i-allocate), which actually allocates memory for the object, and then runs `initialize` (which is an instance method) on the resulting object to finish instantiating it.
checkers is more fun, and still pretty basic.
Ah that makes sense. I still don't see much use for it though, due to the crappy way most linux variants handle parameters passed to the shebang line. Ie running it on Ubuntu results in the error: /usr/bin/env: ruby -wn: No such file or directory It collapses the arguments into one, ie running `/usr/bin/env "ruby -wn"` rather than the more logical `/usr/bin/env ruby -wn`. THe latter behaviour is what is done on OSX (and bsd in general I think).
which wouldn't work anyway as `self` in context of method `new` is a class, not a new instance of that class 
Since ruby doesn't really have a memory concern, it separates the true concern of instantiation and memory allocation. IE: you make the object instance, we'll take care of the memory. Also since you care about the instance more (instance variables for example) then you definitely don't want to handle that inside of a .new class method. There are some times that you'd WANT to make a .new however. For example: on a module. The Bunny gem does this on the Bunny module and returns a Bunny::Session instance. Why? Nicer interface. /drunkcomment
Absolutely; I was sending that in response to your broadcast for testimonials. Great work, again!
"Looking to initialize for parameters" isn't really the right way to think of it. What happens isn't that `new` somehow reflects on the arity of `initialize` and then makes sure that it takes the same number of arguments. Instead `new` simply takes arbitrarily many arguments and forwards its arguments to `initialize`. So if the number of arguments given to `new` doesn't match the number of arguments that `initialize` expects, `new` will call `initialize` with the wrong number of arguments, which will cause an exception to that effect.
Now lets hope that it comes with the latest version of the GNU compilation tool chain. Nice to see the step to 2.0 though. 
I'm pretty sure that none of the vanilla software makes use of it by default, but lots of 3rd party software does. 
I never bothered upgrading past 10.7. Too much functionality transitioned to the new iOS style. That, and I use RVM to manage my ruby installations anyway.
I actually did this while my Cucumber features were running
&gt; Just curious though, does anything in OS X actually use Ruby? Not that I personally know of, but colleagues of mine at Apple inform me that these sorts of things are included because they're used with internal projects which are hosted by OS X.
No more gcc at all. Only clang. Apple is very reluctant (i.e won't at all) to ship GPL3 software. Either the license still has not been vetted by their legal department, or, more likely, they are afraid the patent clauses in the GPLv3 will make them lose the right to enforce any of their patents.
&gt; Just curious though, does anything in OS X actually use Ruby? Nah, just silly stuff such as Homebrew. Which may actually hugely benefit from being able to some day build on 2.0 rather than 1.8.
Haven't thought this all the way through but isn't that kind of silly? What if an external process updates the core Ruby? Then the stability of the OS is threatened. The OS should have its own copy of Ruby if that's the case.
Beta is under NDA, so people can't post evidence without breaking it. It's not like it's unfeasible tho.
The OS _does_ have its own copy of Ruby. That's what we're discussing.
I'm saying it should have one that's more private than the one in /usr/bin. One that isn't so easily accessible by default install upgrades.
The profile manager in OSX server is a Rails 2.3 app that relies on the system ruby and system postgres. I had RVM installed on one of my OSX Directory Management server, and it caused the profile manager to completely break irreparably. The rails app source itself is pretty horrendous too.
Upgrading from 10.8 to 10.9 is a major upgrade, and it's safe to assume that there will be breaking changes, including to system utilities.
I think some of the server administration tools, and maybe the Cups Web ui do
My favorite utility-belt gem is utility_belt.. https://rubygems.org/gems/utility_belt Just trying to be funny.. Actually I have a few apps where I 'require "utility_belt/string_to_proc"' or something else from that gem I need.
My cukes take something like 450 hours but I spread them over 50ish machines.
funny story, i worked at a place that used 100 24core machines to get the build running in a "reasonable" time.
All those pesky command line things that them hackers are using nowadays to twitter about their linkedins.
to be fair, i'm sure those teams could have engineered something horrible in any language
What functionality has "transitioned to the new iOS style", exactly? The only thing I can think of is Launchpad, and that's 100% optional. 
Given that I've moved to using [vagrant VMs](http://www.vagrantup.com/) for everything, the version of ruby OS X ships with has become largely irrelevant. In fact, the host operating system has become largely irrelevant too, which is great from the perspective that it doesn't matter what platform I'm on, I can always have the same development environment. Mac, Linux, Windows ... it doesn't matter. I can just use whatever is available now.
We use a bunch of VMs here. Our main suite is roughly 4.5k tests, with subsets of that suite used for smoke tests. There's an additional 2k or so additional tests in our regression suite.
Watir-webdriver with Chrome or Firefox is pretty speedy at least compared to IE (under watir-classic or watir-webdriver). But because you're driving your web UI it's going to be kind slow. That's why we parallelize the tests here. Something we've done recently that's showing a lot of promise is to create a web API that our pages work through. That way when we're writing tests that need to test a page deep in the app, we can use the same API to blast in the data instead of filling out pages that aren't under test. Huuuuuuuge speed gains.
Out of curiosity, do you just run cucumber or do you use a runner of some sort?
I sometimes use Spork or [parallel_tests](https://github.com/grosser/parallel_tests), which make our features run a lot faster. But when I work on a feature I rather not to use those gems so debugging the code while cucumber is running would be easier. 
Trust me, I would love to get into this, but I'm a tools developer/SDET at a .NET shop so we can't use the cool tools that you guys are using. Heck, the site only works on IE and Watir-Webdriver just doesnt mesh well with our current sites...
Why wouldn't you replace the swords with giant cucumbers?!? 
We're a .Net shop as well so I feel your pain. We've been lucky enough to use the best tool for the job as long as it doesn't cause issues. For example our automators all use git with git-tfs providing a bridge back to the main TFS repository that the application developers use.
Does anyone actually use the system install? I figured pretty much everyone would be using rbenv or rvm.
We use [Turnip](https://github.com/jnicklas/turnip) in some projects and it runs pretty fast (granted the amount of Turnip tests is pretty small). Might be worth looking into.
Try out spin, it's less intrusive than spork and is essentially made for exactly this - quick reruns of isolated test bits. Combine with guard or rerun for even faster turnaround.
Interesting. I've noticed the huge integration between the two. 
Most OS X's came with the latest stable^* version of Ruby at the time of their release. ^* Edit
Ah, cool, never knew there was a middle man involved. Thank you!
`RVM`!? `rbenv` brah.
Sorry this is flat wrong. OSX has shipped with 1.8.7 for at least the last 3 versions, and no alternatively named system versions are included.
Don't hold it like that. 
Arguably 1.8.7 was the last stable version for quite a while, and 1.9.x versions were unstable.
where can we find that? I'm interested to take a look.
1.9.0, 1.9.1 and 1.9.2 were indeed unstable. 1.9.3 is very stabe however.
This looks pretty cool. I've been thinking of implementing circleci but was too cheap.
I think the purpose of them were just to smooth out the transition to 2.0, just like 1.7.x's did for the 1.6 to 1.8 transition.
Never used it, but [RubyMine](http://www.jetbrains.com/ruby/download/index.html).
&gt; I've tried googling several variations on development kit but nothing I'm finding is really what I'm looking for. Visual Studio is what's called an "IDE" (Integrated Development Environment). If you search for "ruby IDE" or "ruby development environment for [windows / OSX / Linux / etc]" you should see results closer to what you're looking for. Edit: and if you just want to run code and see what it does, similar to the codecademy site, try the command-line "irb" command (ruby has to be installed for this to work, but you linked to a ruby installer, so you probably have this already). It lets you type commands and displays the output: uname@shell $ irb irb(main):001:0&gt; (2 + 3) * 10 =&gt; 50 irb(main):002:0&gt; 
`irb` is probably the easiest way to test code. You can also just run `$ ruby filename.rb`
&gt; downloaded Yarrrr?
It has a trial
Install OSX Server from the App Store (it's $20, I think), and: /Applications/Server.app/Contents/ServerRoot/usr/share/collabd/coreclient/config/database.yml /Applications/Server.app/Contents/ServerRoot/usr/share/collabd/webauthd/config/database.yml /Applications/Server.app/Contents/ServerRoot/usr/share/devicemgr/backend/config/database.yml 
Thanks this is very helpful!
SublimeText is my go-to application for editing any plaintext file.
*Is there a development platform kind of like MS Visual Studio for Ruby?* RubyMine is great, but if you're actually on Windows and want something in Visual Studio, then check out [Ruby in Steel](http://www.sapphiresteel.com/Products/Ruby-In-Steel/Ruby-In-Steel-Developer-Overview).
new() returns the return value from allocate() and the return value of initialize() is ignored, so you don't have to return "self" in initialize because new does it for you, you're right.
Sublime text is the best. If you spend some time to customize autofill and such it is perfect for ruby
While there will always be someone +1ing Sublime (which I use), it isn't what you asked for. Check out RubyMine. 
This might be slightly to the side of your question, but I think I'm about to give you good advice. I taught myself ruby, and I took way too long to start using IRB as a "go to" for exploring ruby. I suggest having it open all the time, and using it as much as possible, until you have specific needs that it can't satisfy. 
Have you tried using [Codecademy Labs](http://labs.codecademy.com/)?
Try [Pry](http://pryrepl.org/)
You don't need a devkit. All you need is the ruby interpreter, a text editor, and a command line. IRB really helps too.
&gt; RubyMine includes bundled evaluation license key for a free 30-day trial. 
Is that a decent IDE? Their website makes it difficult for me to take them seriously. 
'way too complicated' certainly meets your MS Visual Studio for Ruby criteria though :D
If you take the time to learn Vim and you use it with Tmux you can have an awesome test setup. You keep two panes open, one with your code and one with a command line, and you can hit "\t" to automatically run the tests for whatever file you are in. Additionally, you can open up the test file, move the cursor to the specific test you want to run, then hit "\T" to run only that test. You can get this kind of functionality using these dotfiles http://github.com/hashrocket/dotmatrix If you don't know Vim and don't want to take the time to learn, then I recommend Sublime Text or Text Mate, then open a console and use something like dirty (https://github.com/rbxbx/dirty) to run your tests.
I usually don't dev in Ruby like I do in C#; my tools and workflow are very different. Part of this is the culture: VS has always been an all-in-one tool, while the Ruby community is more "unix-y", and you use a collection of small tools to get the job done. So let's say you want to: * Run the application: `rails server` (or equivalent) in a separate terminal. Changes are usually dynamically loaded, so I just set it and forget it. * Run tests: [RSpec](http://rspec.info/) is my hands-down favorite. * Manage Ruby Env: [RVM](https://rvm.io/). Sometimes you need Ruby 1.8.7, sometimes you don't. * Deploy: you don't need to package binaries like you would for ASP.NET or J2EE, so just copying would work for simple setups. As you get more complicated, you can look into run Capistrano or Phusion Passenger on your server. Also, [Heroku](https://www.heroku.com/) is cheap and easy to start out with. Features like Intellisense and project browsing would be found in your text editor of choice. [Sublime Text](http://www.sublimetext.com/) is honey-roasted goodness as far as text editors go (though I'm a die-hard Vim guy). I've never had a Ruby project that consisted of many small projects, so I've never missed Visual Studio's idea of a "Solution" with "Projects". That covers the basic stuff (I could go on, there is no such thing as a good Git GUI). While it can be daunting for a first-time Ruby user, I would highly recommend doing things "the unix way". You'll get a better understanding of what is going on, most documentation assumes you're not using an IDE, and it will keep your dev workflow much closer to how production will work. I hope that helps you connect the dots. Happy coding! **EDIT:** I forgot debugging! I don't debug my Ruby. I'm sure there are some really nice debuggers out there, but I've never needed them. If there is a problem, first I read the log and see what happens. If I can't divine the answer from a quick look, I fire up IRB and recreate the problem right there. While Visual Studio's ability to rewind the stack is nice, I've never missed it. I can't tell you how many times I've been debugging .NET and just wanted a C# REPL. 
A trie is an interesting, similar data structure [(Ruby implementation)](https://gist.github.com/Sirupsen/6479740), but is always O(m), for m being the number of characters in the string you're searching for. Whereas the worst-case of segment search will be O(n), visiting everything, with n being the number of strings in the data structure. Tries are often used for things like spelling checkers and are useful in many string algorithms in e.g. bioinformatics. I wrote a [letter press cheater in Ruby](https://gist.github.com/Sirupsen/4182223) with a trie a couple of months ago. However, for the problem of simply telling whether a string exists which seems to be the author's goal, use a set, which has a much better worst case complexity (O(log(n))) and is built into Ruby. [Ruby implementation](https://gist.github.com/Sirupsen/0a84dd397018cd639d20).
I was going to read it, but the site is too wide for my screen and zoom is disabled. Google Chrome on Nexus 4.
Thanks for the heads up. Looks like responsive design is next on my plate.
can you add a Set bench to the gist with the same data as the other benchmarks? thanks man!
or a bench that demonstrates worst-case. i'm very interested to see and understand it.
Not exactly sure what you're asking for. The [bench linked to in my previous comment](https://gist.github.com/Sirupsen/0a84dd397018cd639d20) is using the same data as yours. With worst-case, I'm not sure if you're referring to a set's worst case?
1) Your comment is awesome; thank you! 2) I probably shouldn't have gotten into performance - my needs for the capability generally revolve around small data sets. it's just that using inject yielded such horrifically slow performance I had to at least pay lip service to speed :) I'll make sure to tackle statistics more rigorously in future posts. Thank's again for the study in your comment.
sorry, i missed the gist benchmark in the first comment. cheers, I updated the original gist(https://gist.github.com/robgleeson/6477971) with the set benchmark and some notes!
i use textmate 2, but rubymine and sublime text are also popular.
You can make the first version of `hmap` about as fast as the `Hash[...]` version by replacing `merge` (which is a functional method that constructs and returns a new hash) with `merge!` (which statefully operates on one hash and is far more appropriate in this case). *I only mention it because I personally find the `Hash[]` syntax pretty ugly and I thought you might appreciate a way to continue using `inject` to map over hashes (as you should).
I added support for partial matching (all partial matches or the first). It's not only for exact matches anymore. updated benchmarks too.
Since we're playing [the performance game](https://gist.github.com/Sirupsen/6481061).
I highly recommend [Aptana Studio](http://www.aptana.com/) It's free and as full featured an IDE as I've ever found for Ruby. It also has great support for Ruby on Rails when you get to that point.
awesome, my man :) thanks for taking the time to collect those numbers! I updated the original gist again.
thanks!
I highly recommend "Metaprogramming Ruby". It's fantastic. I got it for $20 on amazon a few days ago :(
... Have you considered #each_with_object ?
Plain ol' SciTe is good enough for me
Seems a bit overzealous to monkeypatch Hash just because you don't like the syntax of Enumerable#inject.
Yep that's definitely the way to go. An example for others: hash.each_with_object({}) do |(k,v), h| h.merge! k.to_sym =&gt; v.upcase end 
Looks like they're only on Ruby 1.8.7 in Codecademy Labs.
Not sure why you need the case statement. A simple raise "GTFO" unless Rails.env.development? at the top of the file would suffice.
It is possible to use Passenger Enterprise on Heroku, and Enterprise does indeed have a Standalone mode too. The current licensing allows it to be run on Heroku, with one dyno counting as a server (so 1 Pro license allows two dynos). We're also working on a more cloud-friendly licensing model for the future. There's just one caveat: rolling restart doesn't work. Neither do Puma's and Unicorn's. This is because every time you git push heroku master, Heroku restarts your dynos. Heroku has an experimental "preboot" feature in Heroku Labs that allows rolling restarting at the dyno level, and which works with all app servers, including the open source Phusion Passenger. However it requires at least two dynos. During the weekend we put together a proof of concept that allows rolling restarting in Passenger Enterprise on Heroku. Our version of rolling restarting works even on a single dyno, without Heroku preboot. We're still exploring the best way to make this available in a polished form for Heroku customers.
The easiest example is when you want to associate keys with lists of things. So let's imagine that what we want is a list of books written by redditors. So if you haven't written any books, we want an empty list, not `nil`. The naÃ¯ve way looks like this: books_by_redditor = Hash.new # ... books_by_redditor['homoiconic'] = [ 'JavaScript AllongÃ©', 'CoffeeScript Rsitretto', 'Kestrels, Quirky Birds, and Hopeless Egocentricity'] When we want to look them up, we do this: books_by_dunnowins = books_by_redditor['dunnowins'] || Array.new But now we have to repeat that idiom everywhere we access our hash. For example: def wrote_a_book redditor, book books_by_redditor[redditor] = (books_by_redditor[redditor] || Array.new) &lt;&lt; book end Yecch. Let's use the `default_proc` instead: books_by_redditor = Hash.new { |hash, key| hash[key] = Array.new } Now we can write: books_by_dunnowins = books_by_redditor['dunnowins'] If you haven't written any books, we'll get an empty array back just as we wanted. We can also write: def wrote_a_book redditor, book books_by_redditor[redditor] &lt;&lt; book end Doesn't this look cleaner? (*updated to use* `&lt;&lt;`)
Like homoiconic said, also useful for when you are counting things into a hash. counts = Hash.new(0) "count the letters in this sentence".each_char do |char| counts[char] += 1 end Is slightly nicer than counts = Hash.new() "count the letters in this sentence".each_char do |char| counts[char] ||= 0 counts[char] += 1 end
you can use default_proc for some hash autovivification. [i got a quick example on my blog](http://aberant.tumblr.com/post/4639094626/ruby-drive-by-autovivification)
This is a neat trick, not with #default, but with #default_proc: irb(main):001:0&gt; nested = Hash.new(&amp;(r = Proc.new{|h,k| h[k] = Hash.new(&amp;r) })) =&gt; {} irb(main):002:0&gt; nested[:a][:b] = 42 =&gt; 42 irb(main):003:0&gt; nested =&gt; {:a=&gt;{:b=&gt;42}} EDIT: Ah, I see aberant beat me to it.
You realize that you had no answer to his question right? He asked "Why should I care about your degree?" and you replied "What?". I realize you were surprised by the question, but don't you think you should have answered him? I mean, you earned the degree, shouldn't you know exactly why he should care and why it is important? You spent years earning it, yet when asked why it was important, you have no respectable reason other than you thought it was relevant? You should have replied with something like "You should care about my degree because..." The days of earning a degree and having it speak for itself are over. From his perspective, you earned a degree and have no idea how it makes you a better programmer. If you don't know why it matters, then why should he consider it a good thing you have it?
A Ruby conference in Boston, great! * TICKET TYPE: Attendee * SALES END: Oct 12, 2013 * PRICE: $350.00 * FEE: $20.24 NOPE 
Bad ass. This is a great explanation. Thank you!
Since the enterprise version looks for your license key in `/etc/passenger-enterprise-license`, how do you tell an instance of Passenger Enterprise installed on a Heroku where to look for the key?
It makes for a fun way to memoize the Fibonacci sequence. f = Hash.new{ |h,k| h[k] = k &lt; 2 ? k : h[k-1] + h[k-2] } If k &lt; 2, we return k, so f[0] and f[1] return 0 and 1 respectively. Everything else is computed via the recursive method. Of course, since a hash default only applies the first time its calculated, you don't run into the usual problems with a recursive explosion. 
Thanks for the correction on nil vs failing. Perhaps I'm not clever enough but I dont understand how this generates data. Would you mind explaining? Thanks.
Yes, this is how I implement MultiMaps. And that was a great explanation. 
The price is comparable to other Ruby conferences of its size. Its the cost of putting on a conference in an expensive city. I'm sorry if you're insulted by the price.
Oh I should also mention that I agree about the fee price. But our margins are what they are and we couldn't swallow that. However, if people want to get around the fee we are doing purchase orders for tickets that we invoice outside of Eventbrite then send a special 100% discount code upon payment.
Not insulted, just broke.
Are you planning on having a live stream?
Pretty much. In the first example, a hash is created with a default item value of zero then the characters in a sentence are iterated over, incrementing the value in the hash for each character in the sentence. In the second example, a hash is created then the characters in a sentence are iterated over. Each character in the sentence is looked up in the hash. If the value is null, it is set to 0. Then the value is incremented. Neither of the above are a great way to count characters in anything but a very short string without a couple of optimisations but that's getting off topic and they do still do a good job of illustrating default hash values. 
Thanks for the informative clarification.
...and if one wanted more info on that program, where would they go? 
The purchase orders? You can email me: brian@dockyard.com If you're asking more generally about the conference all information is at http://wickedgoodruby.com
no :(
So you're installing arbitrary code on your computer, and are worried that checking the version number will be really slow?
&gt; I forgot debugging! Just use pry.
But it can... &gt;&gt; "#{if true then 'OK' else 'NOPE' end}" =&gt; "OK" &gt;&gt; if (if true then 'OK' else 'NOPE' end) == 'OK' then 'OKOK' else 'NOPENOPE' end =&gt; "OKOK" 
Package manager for ruby the programming language. Maven for java, npm for nodejs are similar examples (though, maven does a lot more than either).
Could you ELI5 what a package manager is? It's my "cake day". (I've been studying programming for a few months and I really like Ruby and Javascript, but I just have no idea what the hell all these other things are.)
As a Ruby user, you can write some code that does something useful. (We call that a "library," generally.) If all you want to do is use that code for your own things, that's cool. If you want to distribute it, then you can send the file to other people, and they can put it in their own projects. If you need to _update_ that file, things get difficult â€” you need to send all those people a new file. Not much fun. So you create a "package" out of your library: you include some metadata that gives it a name, a description, and a version number (say, 1.0). And you tell some sort of central authority about it. Now people can find your package and get your code. If you need to update it, you can bump your version to 1.1 and tell the central authority, and then people know when they need to upgrade. Better, packages can _depend on_ other packages. You can write something that depends on [Nokogiri](http://nokogiri.org), and then when someone installs your package, the package manager will know that that person also needs Nokogiri. Package managers try to eliminate the situation where you need to be aware of all of a package's prerequisites. Anyway, that's what package managers are in general. Ruby's package manager is called RubyGems. Individual packages are called "gems." [Wikipedia can tell you more.](http://en.wikipedia.org/wiki/RubyGems)
Well played. That `if X then Y else Z` is Ruby's alternate syntax for the ternary operator.
Have you considered the context? Of course I can explain why he should care about my degree. My degree is not a no value object. I said "what?" because his tone conveyed that he was very offended at the fact that I mentioned my degree. It caught me off guard. He immediately went into his rant and walked away. I definitely don't think a degree is a requirement of a good programmer, but remember that talking about your educational background is pretty freaking common when asking about a job. But you're right, I really wish I could have gotten a word in about my degree.
This looks pretty cool, I'll try it out
https://github.com/tekknolagi/glug It's made with Ruby and Sinatra.
Yeah I'm not sure why that happens. It appears as though on small screen sizes the content overlaps the input. I'm looking into it.
Looks like none of the inputs are sanitized for scripting attacks. That's the easy one to notice though.
They should be. I thought I was escaping HTML. Looking into that now. Database is completely sanitized, though.
[Looks good now!](http://glug.bernsteinbear.com/p/28de61eeca136980e0d35d262cce3f40)
Fantastic! I'm glad. What's the site look like on the Mini?
The [`?:`](http://rxr.whitequark.org/mri/source/parse.y#2308) is actually sugar for [`keyword_if`](http://rxr.whitequark.org/mri/source/parse.y#2753) in the ruby parser. Using the `if` form, you can elide the [`then`](http://rxr.whitequark.org/mri/source/parse.y#3110) with a semicolon or newline (so the parser knows how to separate the clauses). You can also have multiple expressions in the body of a clause, separated by semicolon or newline, and you can of course have multiple [`else` and `else_if` clauses](http://rxr.whitequark.org/mri/source/parse.y#3131) as well. So these are all parsed identically: if A then X else Y end if A ; X else Y end if A X else Y end And they are all "expressions" (vs "statements"), because in ruby everything evaluates to a value and can be used anywhere a value is expected (though you might have to wrap the expression in parens to make the parser happy). Ps. Sorry for the info dump; been a while since I looked up how the ternary operator and if keyword are parsed, and I figure someone here might find it useful.
I think he was being sarcastic. If you click the link it's a 500 error message.
This took forever to create, but it's finally done!
Much appreciated! Do we need to uninstall previous versions prior to using these for apache?
~~What about packages for the Enterprise version?~~ EDIT: Reading helps
If you previously installed using the gem, then uninstalling the gem first is recommended.
Yep, I see that now. Thanks
[http://i.imgur.com/EFm8IQZ.jpg](http://i.imgur.com/EFm8IQZ.jpg) [http://i.imgur.com/MkCvE0v.jpg](http://i.imgur.com/MkCvE0v.jpg) [http://i.imgur.com/KKjy2AD.jpg](http://i.imgur.com/KKjy2AD.jpg)
 * It automatically installs all system dependencies like Ruby, Apache, OpenSSL, etc. * You don't need to compile anything. Especially important for small VPSes (because the C++ compiler can use 1 GB of memory) or environments where fast deployment is desirable. * We provide Nginx packages too. Normally if you recompile Nginx with Phusion Passenger support, the resulting Nginx is installed to a different location than the one you get from `apt-get install nginx`, and you won't be able to use the distribution-provided Nginx init script. By using our Nginx package, all of these disadvantages are gone.
thanks. You said it automatically installs system dependencies like Ruby. So if my Ubuntu VPS box doesn't have Ruby installed it will just grab official one from their apt-get repos? (at this moment 1.9.3 or something?)
Yes. It will grab whatever the default Ruby is for your distribution.
I would give it another try. You mentioned in your post about wanting an IDE like Visual Studio and RubyMine is the best there is for Rubyists IMO. If you have questions don't be afraid to post them here. Otherwise, you can always go with something lightweight like Sublime Text. I actually switch between the two.
Oh it might have gone away or something D: Shoot I wonder why it errors. Checking logs. EDIT: Fixed!
Sounds like he is insecure about his lack of degree. In a community where lots of people are self-taught, you might find it a bit more than you would in the Java/C community for instance. That said, it's a fair question and although I can understand being thrown off by his abrasiveness, you might want to think about what kind of value-add your degree is so you can articulate it to potential employers. If his tone was as dismissive as you portrayed it, I probably wouldn't want to work with him anyway. Edit: just realized this is an old post and already has comments in a similar vein. Oh well
What kind of code should I reuse? "posts"?
Interesting stuff. It looks very declarative, reminds me a lot of QML. It uses JRuby though... I wonder how much abstraction is going on.
Awesome :)
I did a project for college way back in 08 with rails and shoes. It was meant to make a Web application and a desktop interface using the same back end. Every other student went with pure Java. People made fun of me because chose ruby. I rembeber I was the only one able to finish in time. It was pretty easy to do, integrated well with my rails app and I found help online. And that was 5 years ago. I recommend shoes a lot. 
&gt;It uses JRuby though... I wonder how much abstraction is going on. Yeah, it's because they're relying on [SWT](http://www.eclipse.org/swt/) as a cross-platform GUI backend. Though [they say](https://github.com/shoes/shoes4/wiki#so-what-is-different-about-shoes-4) they want to eventually support others: &gt;The reference implementation for Shoes 4 is SWT(Standard Widget Toolkit), which runs on JRuby. However, we want there to be multiple backends for shoes -- maybe Qt, maybe GTK -- you name it! There have been different flavors of shoes before, but Shoes 4 aims to establish a shared DSL and a shared spec suite, so that the implementations can be more or less interchangeable.
Right. SWT, Qt and Gtk are already abstractions. So I'm a bit dubious when we have layers upon layers like that.
Oh I apologize, when I clicked the link it led to a page with a 500 error message.
makes me wonder why it wasn't named slippers
All of those "choose your own language" projects in College... the person/teams that choose Java *never* finish on time, ever. I did one once and the PHP group (my group) beat out everyone else, who chose Java. Their code didn't even reach the first goal!
I did a little UI for a backup application as a project while just starting out with Ruby. I tried Shoes and seem to recall having issues (something with my build environment I think) hence ended up using QT instead. Its VERY easy to use and has QT Designer for putting together the front end rather than having to construct them pragmatically. Basically don't be scared of QT, its a pussy-cat.
Right! Now let's use it to track IP addresses across the 'net
That's probably because students who have taken the time to learn a language like Ruby or PHP are better programmers than the students who *only* know Java from school. 
That's a butt-ugly and non-compliant demo app, unfortunately. 
&gt; the person/teams that choose Java *never* finish on time, ever. Good preparation for real-world work experience!
That's an interesting take in it. Good thinking.
The alternative would be to use RestClient to make the requests on the live server, but I'd rather test locally than on our live servers.
This is written by Reginald Braithwaite, who wrote the excellent [Kestrels, Quirky Birds, and Hopeless Egocentricity](https://leanpub.com/combinators). I strongly suggest you checkout that book as well. I know the link is right there on the blog, but don't ignore it! It's an awesome book. Edit: Typo
Too bad they haven't gemified it yet... But it's one of the simpliest GUIs I've ever seen. And it's fairly good for its simplicity.
Make sure to check out [Green Shoes](http://ashbb.github.io/green_shoes/) as well. It's a normal rubygem, but I'm not entirely sure if it implements all of Shoes' features yet.
 $ git checkout "Kestrels, Quirky Birds, and Hopeless Egocentricity" error: pathspec 'Kestrels, Quirky Birds, and Hopeless Egocentricity' did not match any file(s) known to git. :(
Fun fact: this is a monoidal fold that can also be written: str.each_char.reduce(Hash.new 0) { |counts, char| counts[char] += 1; counts } `#each_char` returns an enumerable!
There is (unfortunately) no official BNF syntax specification or similar. The closest you're going to get is the YACC syntax file (parse.y in the Ruby source).
The syntax is broken into the files on the left hand side. such as * http://www.ruby-doc.org/core-2.0.0/doc/syntax/literals_rdoc.html * http://www.ruby-doc.org/core-2.0.0/doc/syntax/calling_methods_rdoc.html * http://www.ruby-doc.org/core-2.0.0/doc/syntax/modules_and_classes_rdoc.html * http://www.ruby-doc.org/core-2.0.0/doc/globals_rdoc.html
I heard VB is the best language for this.
Thanks - I hadn't realized these were down there. I saw the release notes for old versions of rake, and thought this file listing wasn't relevant.
Whoa. Interesting how much that is.
Hope you don't rely on an assembly, or compiler, or operating system
The real-life programmers who choose java for those projects never finish *those* projects on time, either. (And those that do finish on time will get an F due to incompleteness or bugs.) 
Well each level of abstraction requires something of a cost/benefit analysis. Example: when I request some memory I couldn't care less about how that is managed or if my pointer is an offset to real physical memory or not. I don't care if the OS even allocates the memory when it says it does, just that I can put stuff there when I want to. But for instance there are cases in embedded programming (think car sensor with tight QA requirements) where they don't use anything resembling an OS in part because things like virtual memory just make their life more complicated then is needed. In this case you have pretty high-level abstractions like SWT, Gtk and Qt that are already user-facing UI toolkits. All three already are abstract enough to run on multiple platforms. You add an abstraction on top of that you are going to lose some fidelity. You won't be able to control it as finely, that's just inherent to any abstraction. And unlike my virtual memory example, it's not so unlikely that you will care about the things that get glossed over. Of course if your goals match the intended goals of the abstraction's designer it might work out fine.
/u/bozhidarb wrote a fairly good elements of style guide, https://github.com/bbatsov/ruby-style-guide
Just a bad joke :) Thanks though. I think this is the only book of yours that I do not own yet, though the sample was very interesting. I should save the web version to Instapaper.
I'm generally leary of doing dynamic extends like that. Back when DCI was the new hotness and everyone was talking about it, I recall -- I think Tony Arcieri -- noting how dynamically extending modules blows away method caching and can have some nasty performance concerns. I'll see if I can dig up a link. That said, so long as you can isolate most of this dynamic stuff to a known, finite amount of time, ideally early in your program's lifecycle, it's a wonderful way to define really flexible classes. I guess I would get a little nervous around the extend-in-initialize pattern, preferring perhaps to use a different trick, like defining `#new` on a module to manage the subclass distinction, ie: module BankAccount def new(opts = {}) if opts.delete(frozen) Frozen.new(opts) else Thawed.new(opts) end end end class FrozenAccount def frozen? ; true ; end end class ThawedAccount def frozen? ; true ; end end This skirts the dynamic-extension-eats-JIT problem, since we're defining every class exactly once and never changing it's methods. Shared behavior can be done w/ modules or subclassing or whatever. I'm unaware of any particular performance downsides to the idea of defining `#new` on a module, but there is the problem of communicating that BankAccount is only playing the role of class, and isn't *really* one. This also makes `FrozenAccount` and `ThawedAccount` have no common ancestry, so `#kind_of?` and the like might work in an unusual way, but I would say that you probably will end up skirting a lot of the issues you'd need `#kind_of?` for w/ this technique. I cribbed the idea from another comment here recently about `bunny`, a RabbitMQ binding for ruby, they use this pattern when establishing a connection to the service. They want you to be able to have the remarkably convenient API of `#new`ing up something, but also need to cause a lot of relatively unrelated things to happen at the same time, so using a module w/ `#new` lets you quack like a class, but act like something else. Making for a really slick factory method. 
Why would a style guide be a good alternative to a syntax specification?
In my factories, I generally just do something like FactoryFactory.build(factory: :cars) FactoryFactory.build(factory: :factories) so as to delineate between something that spawns an instance of itself and something that builds a different class. However, I've had a number of places where I've wanted a construct just like this. Thank you for pointing it out :) One thing though--doesn't it break this expectation? BankAccount.new(opts).class == BankAccount It mightn't be a huge deal. Good duck typing can circumvent much need for ancestry concerns, but one never knows what might come up in a huge Rails app. Now that I'm thinking about it, is there a reason this shouldn't be done? class Foo def self.new(opts) if blah Bar.new(opts) elsif blahblah Baz.new(opts) else super end end end class Bar &lt; Foo def lurhmann? ; false ; end end class Baz &lt; Foo def lurhmann? ; true ; end end My gut reaction tells me that on a limited scale, the differences are few. The first big disadvantage I see being that we lose re-usability because we're using classes instead of Modules. The first advantage(?) that comes to mind is that if you dabble in dark arts like Single Table Inheritance, this construct lets you pull it off. What are your thoughts?
Whoa, thanks! :)
Well I read like 4 books, but It was until I start to use rails, that I can learn something 
Good point with the delegation and the call chain. As a rule, I don't fudge with ::new. I forgot it was something that you could even *do* until this discussion. It had never even occurred to me to define a ::new method in a module until you pointed out that you can. It's a much cleaner method of getting a constant with a ::new method that might construct different classes. I like it quite a lot for libraries and such, where you are explictly interacting with something that has this behavior. But I probably wouldn't use it anywhere near Rails models. There's enough magic going on there already. On a semi-related note, see this video http://www.rubytapas.com/episodes/7-Constructors It doesn't go directly into this specific topic, but it does explain Ruby constructors very succinctly.
Thanks for the suggestions. I really like these kinds of challenges. As a novice programmer it really forces me to explore different methods and bits of the language that I'm unfamiliar with.
Fully agreed, that block has become one of the handiest thing's I've encountered in my short time programming in ruby. It's especially handy with the reduce method like this totally contrived example: categorized = (1..10).reduce( Hash.new { |h, k| h[k] = [] } ) do |h, number| case number when &gt;5 h[:over_five].push number when &lt; 5 h[:less_than_five].push number else h[:equals_five].push number end h end
This is an older talk (2008) but it's a good one. http://confreaks.com/videos/825-mwrc2008-ruby-internals
Hadn't heard of it till now. Thanks!
According to people I know who have been interviewing potential Jr. Rails Developers, App Academy tends to produce smarter graduates. They haven't interviewed a lot of people from each bootcamp so that's just an early observation. It seems to be that you get out of a bootcamp what you put in as far as job placement, it wont matter too much which one you do. I believe App Academy is the only one in which you pay nothing up front. So if I was you, I would do App Academy. My second choice would be General Assembly, then maybe Dev Bootcamp.
Thanks!
Thanks mCseq! I got through the entire process for App Academy but was not able to get a final interview do to capacity. All their classes were completely filled. I am looking for the next best bootcamp to start my career in Ruby Development.
Hey people, This project was created, designed, and built by my RailsGirls team (two of the best students ever). The original functionality was burried in Discourse and we were tasked with both extracting and refactoring the functionality: Taking a web resource link and turning it into a little snippet of HTML. We've just released 1.0.0, as it meets the desired MUL (minimum usable library) standards! There's defintely work to be done, but it's absolutely usable right now. Let us know if there's anything we're missing, broken, or just plain wrong!
I'm sorry to hear that, I know how that goes. I was in that same position 3 months ago. I was accepted for the sept 23rd WDI course at General Assembly and I would recommend applying there. Unfortunately, like I said before, I don't think there are any other bootcamps that do not require payment upfront.
www.gschool.it is one of the only bootcamps that consistently puts out people I'd like to work with. I highly recommend it. Jeff and Katrina are frequently extremely helpful with my own teaching woes.
I'll add that to the list, thanks!
Thanks Rabid Ferret! I have not heard of that school. i'm glad you brought it to my attention. Thanks!
No worries. I work just down the hall from it at the thoughtbot Denver office, so come say hi if you join. :)
Will Do Buddy!
I use it.
I use it. Some think it's [Ruby Golf](http://www.sitepoint.com/ruby-golf/), but to me it's pretty standard programming syntax. I guess once you start doing nested ternaries, it's less of a gray area and you should change it to a `case` statement. Ex.: a&lt;0?"no negatives":(a&gt;10?"too big":"fine") can be confusing, and it's logically the same as: if a &lt; 0 "no negatives" else if a &gt; 10 "too big" else "fine" end end but it's not the 'ruby way' to nest `if` statements, so with a `case` statement, you get this: case when a &lt; 0 "no negatives" when (1...10).include? a "fine" when a &gt; 10 "too big" end which is much more modular and changeable. That is, if you need to add a condition for when a is between 10 and 20, the `case` statement is easiest to modify.
If you have any math chops, you could try [Project Euler](http://projecteuler.net/).
Never thought about nested if statements being difficult to maintain, but now that you mention it the case statement is way better! Thanks!
Just remember that it's using `===` and not `==` to compare values if you use the implicit form. [This is worth a quick read.](http://www.skorks.com/2009/08/how-a-ruby-case-statement-works-and-what-you-can-do-with-it/)
I love them, but only for easy to understand and read situations.
Yes, I use it, and not a single shit is given when I do. Just don't use them to write slop.
Typically I've been trending away from ternary towards multi-line if statements. myvar = coolmode ? "bro" : "dude" to myvar = if coolmode "bro" else "dude" end If it's as simple as a quick bool check I'd probably use a ternary, but if the test gets complex I like to have the multiline if. Nested ternaries I'd never use.
I have used other languages (screw you php, http://en.wikipedia.org/wiki/%3F:#PHP ) where nesting ?: failed in odd ways even for simple cases, when parenthesis aren't used, but Ruby works just fine. Leave out your parens while golfing: [2] pry(main)&gt; a=3 =&gt; 3 [3] pry(main)&gt; a&lt;0?"no negatives":(a&gt;10?"too big":"fine") =&gt; "fine" [4] pry(main)&gt; a&lt;0?"no negatives":a&gt;10?"too big":"fine" =&gt; "fine" [5] pry(main)&gt; a=-1 =&gt; -1 [6] pry(main)&gt; a&lt;0?"no negatives":(a&gt;10?"too big":"fine") =&gt; "no negatives" [7] pry(main)&gt; a&lt;0?"no negatives":a&gt;10?"too big":"fine" =&gt; "no negatives" [8] pry(main)&gt; a=29 =&gt; 29 [9] pry(main)&gt; a&lt;0?"no negatives":(a&gt;10?"too big":"fine") =&gt; "too big" [10] pry(main)&gt; a&lt;0?"no negatives":a&gt;10?"too big":"fine" =&gt; "too big" edit - formatting
the only problem I have with Euler (and I don't have math chops) is once you figure out the mathematical formula, the programming is hardly ever interesting or difficult. it's just reading, calculating and sitting back out. i realize this is what most programming is, but still...
Interesting. I think I'd probably try to stay away from chaining them together like that. However, if I came across a time where i felt appropriate I think I'd stick with the parens. Makes it a little easier to read.
I was going to say that I use them often but I just did a grep in my current project and found only 0.2% of my (lo) code are using ternary operators. I recall working with some pretty glorious pieces of logic using ternaries hence I *suspect* that I use them frequently when writing code and then refactor them out as the logic improves - e.g. the ternary ends up becoming part of a method with return statements or exceptions. P.S. Interestingly about 70% of the cases where I have used and kept ternaries are nil checks where I supply some default value e.g x ? x : [] 
It's pretty in a certain way, but I would argue that it isn't as readable, but that might depend on the person. I guess I prefer the pertinent information (the comparison) to be consistently structured, instead of all over the place on the end of a statement. It may start to look silly if the lines aren't close to the same in length: def foo a return "You are not allowed to use negative numbers" if a &lt; 0 return "cool" if (1...10).include? a return "That number is too big. Choose a smaller number" if a &gt; 10 "fine" end Also, what if you need to add functionality for a given condition? def foo a return -&gt;{log_error(user.username, :range_error); return "The number cannot be negative"}.call if a &lt; 0 return "cool" if (1...10).include? a return "That number is too big. Choose a smaller number" if a &gt; 10 "fine" end vs def foo a case when a &lt; 0 log_error(user.username, :range_error) "The number cannot be negative" when (1...10).include? a "cool" when a &gt; 10 "That number is too big. Choose a smaller number" else "fine" end end It may seem a bit 'bulkier', but you can't deny that having to change this would be a breeze compared to the other code.
Out of curiosity, wouldn't you be able to replace nil checks like this with x || [] Seems like it might be a little simpler.
It is called guard conditions and they are perfectly fine, although they make more sense when you have a large function body following the guards.
I think nil checks are probably the best place for them in Ruby. It is clear what's happening and concise.
My two dislikes with the ternary operator in Ruby are that it often comes with double question marks: a = b.nil? ? one_thing : another_thing and that it can't be wrapped the way I prefer in other languages with strong end of expression designators: a = NULL == b ? one_thing : another_thing;
&gt; if a &lt; 0 &gt; "no negatives" &gt; else &gt; if a &gt; 10 &gt; "too big" &gt; else &gt; "fine" &gt; end &gt; end This collapses to something more readable (I would say possibly more readable then the `case` statement): if a &lt; 0 "no negatives" elsif a &gt; 10 "too big" else "fine" end
Awesome.
I'd honestly much rather read the first, but I guess it's brass tacks :)
not all nil checks, for example def do_stuff(foo = nil) bar = foo.nil? ? foo : true # bar = foo || true would get true even if foo was false instead of nil end 
Pity Ruby doesn't support multi-line statements. a &lt; 0 ? "no negatives" : a &gt; 10 ? "too big" : "fine"
I do too, but it's a bad habit. Better to use a helper (or better yet, a decorator) in those cases. 
Oh boy! Another HTTP client. There are so many of them it's hard to decide which one is approrpriate, but they all have their ups and downs. See: [Massive spreadsheet and presentation](http://www.slideshare.net/HiroshiNakamura/rubyhttp-clients-comparison)
I really like the `HTTP.accept(:json)` syntax. My only other experience with http in Ruby is with [Faraday](https://github.com/lostisland/faraday), which makes you set up middleware to handle JSON. I prefer Faraday's approach for bigger projects, but if I'm throwing a script together, I might start using this gem!
How is this in terms of performance compared to nethttp and httpparty?
Off-topic: it's stylistically correct to name your classes GameMap, not Game_Map
I do like the AREL-style chaining. It's kind of funny that the reason there are so many HTTP clients is that Ruby's built-in Net::HTTP is so goddamned awful.
httpparty is based on net/http. Here's a good performance comparison from last year: http://bibwild.wordpress.com/2012/04/30/ruby-http-performance-shootout-redux/
it looks like "Scene_Map" is not in scope when you try to create a subclass from it. The NameError that ends up being raised as an exception is telling you that it couldn't find any class by that name. You might want to check what files you're requiring or you might want to define the classes in a different order like ViralInfection has said.
you can create the Map_Script &lt; Scene_Map &lt; Game_Map hierarchy you want once that's fixed.
Wouldn't you prefer log_error(user.username, :range_error) and return "The number cannot be negative" if a &lt; 0 instead of return -&gt;{log_error(user.username, :range_error); return "The number cannot be negative"}.call if a &lt; 0 right? I know it's off-topic, but the example was too complex...
I knew that, but wasn't sure if this new one was considered faster.
Thats where the problem was. I had all my 'require' automated and in alphabetical order, making Map_Script being imported before Scene_Map. Thanks a lot! 
I guess, but now I'd have to change it in over 40 different files, and I'm a bit too lazy to do that. Besides, it works, so there's no harm in naming it that way, is it? :) 
You should be able to do it with one command: sed -i 's/_Map/Map/g' *.rb Don't be that lazy ;-)
The last part of your post asks the question about public/private difference in adding methods to self. IRB defaults to public, but you can add the private state for storing methods. &gt;&gt; self =&gt; main &gt;&gt; private =&gt; Object &gt;&gt; def title &gt;&gt; "mr" &gt;&gt; end =&gt; nil &gt;&gt; Object.private_instance_methods(false).include? :title =&gt; true &gt;&gt; Object.public_instance_methods(false).include? :title =&gt; false &gt;&gt; public =&gt; Object &gt;&gt; def title &gt;&gt; 'mr' &gt;&gt; end =&gt; nil &gt;&gt; Object.public_instance_methods(false).include? :title =&gt; true
Actually that code works perfectly fine on my system using 1.8, 1.9 and 2.0.
Oh great, how embarrassing. I put it into tryruby.org instead of firing up IRB. I'm relatively new to Ruby in case you can't tell.
yup, not a problem. IRC/freenode #ruby &amp; #ruby-lang channels might be useful for these type of questions too (i donno why so many people downvoted it).
I'm on the list waiting to get into Dev Bootcamp. Every story I've seen in regards to that makes it very obvious that almost everyone who gets through it gets a job or starts their own company. Not having been through it, take that with a grain of salt, but they only take 16 people for every cohort, making the experience ideal for me, with a smaller, more intimate group. This is important for my learning process, but not everyone's.
can you make it use typhoeus instead of net/http? i remember seeing HUGE performance differences, I believe with GETs, when using faraday with the default adapter vs typhoeus. I'd have to look through some old commits to see exactly what the issue was, and my daughter is in dire need of my help getting some stickers off of their backings so it's not going to happen right now. ps sup OP, we (I) miss you at the office! 
Clearly I am missing the point. why was this down voted?
Damn what a cool solution 
i really dunno. i'm in. Thanks! 
I'd love to learn this language. 
Big +1 to you for doing this. Putting together video instructional series can't be an easy task!
Sounds cool. I'll try to check it out. I write a lot of RSpec and Cucumber tests, but could be better with stubs.
It looks good - I intend to work through it this week. Is there an area for feedback on udemy or do you want it here?
there is a way to send messages to the instructor through the udemy panels. or you can simple email me roy at osherove com
np
This is exactly what I was looking for! Thanks!
Most likely the reddit algo doing its thing, or just someone who hates TDD or something along those lines. Regardless, I am in! I always wanted to learn how to do TDD and use Rspec and Cucumber and whatnot with rails, but found most online explanations "alright". Hopefully this will kick butt!
Thanks for the info, I'll check it out :)
Thanks for this. I'm just getting started with Ruby, so having a nice overview of testing from the Ruby perspective, and the full toolchain is helpful. I find the hardest part of getting started with any new technology is figuring out the toolchain as there are usually competing projects at different points in the stack and choosing a toolchain that makes sense and works well together is often harder than it sounds.
No problem! :) I think this is the best start since, well, it holds your hands very well. http://tryruby.org/levels/1/challenges/0 Once you learn ruby well enough, you can start learning rails using the rails for zombies thing. Though I quickly gave up with the screencast and instead just fumbled around by myself and learning in the process. It is more difficult and error prone than doing that screencast, but I learn tons on the side and get a lot of "why"'s answered.
I've went to school for JavaScript/Java/CSS &amp; VB. So I've got an idea, sort of at least. I'm checking it out right now. Should be interesting.
So much unknown here...first step: where is ask defined?
[scores are fuzzed as an anti-spam measure](http://www.reddit.com/wiki/faq#wiki_how_is_a_submission.27s_score_determined.3F)
i'm sure this is a probably a good class, i'm just cautious about all the focus on stubs and mocks. These devices are supposed to be used at the boundaries of your domain where where you aren't interested in testing beyond. ( network, file system, etc. ). Everything in your domain should have loose enough coupling so that it's easy to pass in test services/classes without having to resort to stubs or mocks. 
I'm really looking forward to getting started with this. Thanks man!
Cool. I really appreciate the time that it takes to teach/put together this kind of content. I'll let you know what I think!
Recently I've started stubbing anything not directly tested by the spec I'm writing. Then looking at what's been stubbed makes it easier to see how to implement that stuff in a loosely coupled way. I'm liking it so far.
This is helpful when you don't have control over the data structure, but I would almost always prefer creating a class.
It's great you are giving this away for free. Limited to 1000 users means you will charge for it at some point. Before you do that, I would hope that you take the time to convert this class to an online class. I'm only 15 minutes into it, but this obviously was a recording of a classroom and there was no editing done at all. You have conversations with people in the class that we cannot hear (10 minutes in), you ask questions, etc. You stutter, cough, have questions, etc. All of that should be fixed. If you want an example of a real online class, look at pragmatic studio. Their online classes are top notch. If I had paid for your class, so far I would have been disappointed. 
the biggest danger with that is if you aren't careful, you could be writing tests that are only testing a specific implementation and not the behaviour of the system. You notice this when you try to refactor. You try to change the implementation, but not the output of the system and have to fix a ton of broken tests.
It looks like you might be using a gem called `highline`. Make sure it's installed with `gem install highline` then put `require 'highline/import'` at the top of your file/script.
Thank for this Roy. I saw your earlier TDD kata video, and it was very good viewing. One comment on the new course. On the right-hand side of the screen, beside the mp4 filename, is a download button, but it doesn't work. Getting an http 403 error. Thanks again, Richard
That's a good point. I haven't done any really heavy refactoring of code I've written this way yet but I could see coupling tests to implementation creeping in if I implement the stubbed behavior before writing separate tests for that behavior. As long as I'm strict about that, using stubs to isolate the behavior I'm testing in each spec actually seems to help decouple the test and implementation code. That's my current thinking anyway. I've only been doing it this way for a few weeks so it might turn out to be a bad idea once I start revisiting code but so far things don't appear to be any less maintainable.
Will someone that actually has experience in TDD and BDD actually take the course and tell if its worth $35 or is actually buying the rspec book. I watched a few videos and would not advocate it.
Thanks for the feedback. People do need to know what mocks and stubs are if they are ever to treat them with a level of refrain. I do agree that very little of your tests shoudl have mock objects.
which file name specificaly?
good idea.
Thanks for the feedback.
The entire point of mocking is to isolate the behaviour you are testing. Thus if you change behaviour only ONE test will break. Secondly if you are using TDD you will change that test FIRST. If you are breaking many tests when you refactor, I would suggest you revisit your understanding of mocks and of TDD, because if you are doing them well their effect should be the exact opposite. EDIT: last sentence comes across patronising. Sorry. Just trying to say take another look cos something isn't right.
&gt; a = NULL == b ? one_thing : another_thing; The [parser](http://rxr.whitequark.org/mri/source/parse.y#2308) only allows an optional newline before the ':', so to make that work you'd have to escape the first line. a = b.nil? \ ? one_thing : another_thing 
I prefer to spell it out even in one-liners: a = if x then y else z end
Hi Roy, the file is (or at least the button is labelled) rubytdd.day1.part1.intro.mp4 Thanks again!
True in theory, but I've never seen a working example in the wild that stand the test of time. Most of the time people mock and stub themselves into oblivion.
So Homebrew is broken on the new OSX?
not sure what`s up. can you try again now?
In addition to the others: It appears you're looking for the user to answer with the word "military". In order for that comparison to work you the first line should have quotes around the word military like this: military_time = 'military'
&gt;&gt; "In fact ruby even allows you to nest splitting" Oh wow! Thats cool! :-)
Is it? I don't know. It's updated every day, so I assume the team is active and will make it work with 2.0 just fine. As for my post, I was making a joke, I love Homebrew, I use it every day. :)
The correct terminology for this (afaik) is *destructuring* :)
Right, thanks! I knew it, but couldn't remember it when writing the post for some reason...
There used to be a term called "over engineering" for when programmers would create solutions far too elaborate than what the problem called for. Unfortunately, that term seems to have fallen out of fashion in favor of grossly abusing the term "object oriented programming."
Hi! I hadn't thought that IRB might explicitly mark top level methods methods as private/public as we usually do in classes, by default. Makes perfect sense, thanks :)
That philosophy makes a lot of sense for unit-level tests in languages like Java, where problems with things like method signatures can be caught at compile time. In Ruby, it can be very dangerous. It's very easy to end up in a situation where you change the signature of, or even outright delete a method that you're calling from an external class and still see your entire test suite pass. Something needs to test the connections between classes. IMHO, that should be the most thorough sort of test, because there's no compiler to tell you that you're calling something incorrectly.
Ah. Thanks for the honestly. a) any link is reddit is advertising the site it goes to. I do not see the problem, if it is useful to others, and it is free. b) The course this was recorded in took five days. Every course ever takes a specific amount of time. Also, for the nitpicker in me, I did not write "learn tdd and BDD in five days" I wrote "TDD and BDD in ruby in five days" . c) no. much of this is patterns of making things not suck, after you have done one you could from the free sites etc.. it is not about the frameworks, but about the patterns that make the tests more readable, maintainable and trustworthy. 
&gt; even outright delete a method that you're calling from an external class and still see your entire test suite pass if i had a nickel for every time i've come across that...
1002 users, you gotta be kidding me :(
In case you're interested, [Pry](http://pryrepl.org) makes top-level methods private by default, mirroring the top-level behaviour of a Ruby program. IMO the fact IRB does not do this is a bug in IRB.
Now that you have set the price at $9, it may be worth that. I'm wondering though, did you use test driven development to make the class? There is a link to the video for the first segment, but it doesn't work. There are segments where there is no download link. I would encourage you to look at other online training like lynda.com, pragmatic studio, codeschool.com. They produce quality online training. Your course isn't online training, it is just a recording from a class you gave. I have considered training from udemy.com in the past. If your course is an indication of the quality, I'm glad I chose the other alternatives. They were much easier to listen to and had supporting materials. Thanks for the free course though. 
[Changes](https://github.com/smartinez87/exception_notification/blob/master/CHANGELOG.rdoc): * Add HipChat notifier (by @j15e) * Log backtrace when notification fails * Send more info in Webhook notifier * Add HTTP method to request section
Thanks for the classes. Been looking for TDD/BDD material. I think most of my feedback may have already been mentioned: I'm halfway through the first lecture and the most prominent (and distracting) is the quality of the sound - at one point it even goes really quiet. The second thing is the length - they're a bit too long for me. I think the absolute maximum should be around 20mins. Check out the edX courses (more specifically I have the SaaS courses in mind). I think if you broke it up into smaller parts where each part covers a certain topic/aspect it would not only be easier to consume, but it makes it a lot easier to go back and find a particular piece of information when you need it. Also small quizzes are sometimes helpful (but only if the questions are good - sometimes quizzes seem to have pointless questions just for the sake of havering them). Either way, I'm gonna try work through them and let you know if I have any more comments. Thanks for the work :) 
It looks like that URL is a private URL generated for a paying Practicing Ruby customer. :-\ Was that done on purpose?
I've got a couple secret weapons I break out every now and again when the situation calls for it. Whether it's defining `#new` on a Module, or defining a class that subclasses Module (like the `equalizer` gem does). Sometimes it's a gem I wrote, like `katuv` -- which helps me write embedded dsl's in ruby, or something like that `equalizer` gem, which defines `#==` and related methods without the boilerplate. But by far, my most powerful secret weapons are `Forwardable` and `SimpleDelegator`. The former gives you the class methods `delegate` and `def_delegator` which allow you to pass methods along to other classes with ease. The latter even lets you alias them to other methods. It makes writing rich wrapper classes easy. The latter is more powerful -- it builds an object with is a full-strength proxy to another object. Simply by subclassing `SimpleDelegator(SomeClass)` (or by doing some magic in the `#initialize`), you can wrap up a whole class and override methods cleanly without having to resort to ripping things apart into modules or doing dirty, liskov-violating subclassing. 
Yes, for paying customers, it says it wants you to share that link, and not just with friends, but everywhere...the user ID helps them track who has been sharing, I suppose. Anyway, I just became a paying subscriber...I wish others had shared samples on reddit, would've loved to have this material years ago :)
made it 9$ as a thank you , for a few days.
Good feedback! Thanks.
Thanks for the feedback! I am still checking why that download is not working...
"What is this place?" probably shouldn't ask you to login through GitHub.
Just because many people do something badly doesn't mean it's inherently flawed ;) FWIW I've been using mocking heavily for over 10 years and for me it's worked well.
whoops, thanks it's been fixed :)
Thanks Roy, but I'm still getting a "403 Forbidden" error on the lecture file (rubytdd.day1.part1.intro.mp4). The associated "Downloadable Materials" file (1-team-agile-intro-tdd-ruby.pptx) downloads fine. I should also have mentioned that I can view the lecture ok, so it doesn't seem to be a simple permissions issue. Looking in Chrome dev tools, the faliing download request is for "https://knowbucket-a.akamaihd.net/2013-09-13_14-37-45-b66a3fe1de354b87a05754c1e49f0c46/WebHD_720p.mp4?response-content-disposition=attachment;filename=rubytddday1part1intromp4.mp4&amp;AWSAccessKeyId=AKIAI2IO2M4ZTATFBSTA&amp;Expires=1379401200&amp;Signature=spAW70DKXddY53j33tm4yz3Fc%2FY%3D". (Sorry for the delayed reply BTW - I'm in Australia, so there's the time zone issue :-)
When developing a Gem for a project, extracting a Rails lib into a Gem, or version bumping I setup this trick my Gemfile. This way the team can use the latest stable version of the gem by doing $ bundle Those of use that are using the edge branch of a Gem can so this to load the local Gem repo $ TEST_GEM=true bundle Here is my implementation #Gemfile module ::Kernel def test_gem? !!ENV["TEST_GEM"] end end if test_gem? [ "~/src/test_gem" ].each do |lib| if File.exists?( lib ) gem "test_gem", :path =&gt; lib end end else gem 'test_gem', '0.2.0' end
hey. for now just get it (with fixed audio) at https://www.dropbox.com/s/ccupwy1adtk9cho/tddruby.day1.part1.audio.mp4 
a. baiting? wtf are you talking about? please explain. b. Please do not buy anything. Killjoy. Yes, I think I am offering a different take than railcasts. for the tenth time. no, it is not five days of footage, it is footage from a class that takes five days with 80% drills. including the drill docs. c. Is my approach good, troll? you could have taken the coupon code and found out I guess. My approach is NOT talking crap about someone before studying what they have to offer, I can tell you that. and it has been documented. I wrote a book about it. But it is relatively unknown in the ruby world, since I come from more of a microsoft background. Damn internet trolls.
`array.tap(&amp;:pop)`
Cool concept, still a little rough around the edges though. For instance, clicking "submit something" shouldn't trigger a JS alert, it should either redirect you to the login page or open a login modal. Rails makes this really easy, so I was kind of surprised it wasn't implemented that way. 
Yeah, that part is definitely rough. I'm using omniauth-github, which doesn't have an alternative authentication method AFAIK, and I don't want to redirect them to Github without warning. I suppose I could open a modal that gives them a choice to redirect or not. Thanks for the suggestion.
My comment made a lot less sense once I realized github was the only login method for your site. I'd still go with something other than an alert box, but it makes much more sense now. I hope you can get a nice community going on there, I'd definitely use something like that. 
Bundler has a similar functionality built in. http://bundler.io/v1.3/git.html#local
Want to split a hash into two hashes? Hash.partition will do that, based on a block you pass it. 
Until we see some benchmark comparisons we wont know.
I'd always prefer to write bar = true if foo.nil? instead. Assuming that your example is meant to say bar = foo.nil? ? true : foo. *shrugs*
It's the same as that :) 
it is not . it is audio and video. just name should have been fixedaudio..
Thanks Roy, all good now!
Whatever happened to evolving architecture? Once (if and in my experience that's often not the case) it reaches a point where having a proper data structure makes sense, then you refactor. Besides as my post mentioned this is also extremely useful with Array#zip.
Rubinius, with its concurrent garbage collector, should fit the bill nicely for a game scripting language. 
I agree on the alert box; I think the new implementation feels much cleaner, thanks! My hope is that in the beginning, people can use it by submitting something and then sharing/tweeting the submission to bring in nitpickers. Eventually, enough people would know about it to achieve critical mass. We'll see what happens :)
How the fuck is that clearer?
You may know this already but [`#partition`](http://ruby-doc.org/core-2.0.0/Enumerable.html#method-i-partition) is an Enumerable method which is why it works with Hash; anything Enumerable will respond to it and it's super useful with Arrays and Sets as well!
Coupon code disabled :( I'm sure it was a good course
True, I just want to find a good place without the wait list. Also one that has good job placement.
When the tests get a little more involved, it's easier for me to spot what is actually returned. sufficiently_contrived_ternary = (this || that) &amp;&amp; some_other_test &gt; 10 ? do(something) : (use_nested_ternary?? :yuck : :phew)
Have you reached capacity? I Just saw this today, and I'd love to try it.
Personally, that's when I'd break it up into return unless some_other_test &gt; 10 return unless sufficiently_contrived_ternary == whatever do_the_rest That isn't ideal, but it normally paves the way for refactoring nicely.
Totally off-topic, but great username =) And i just noticed it's my cake day... awww too late for karma grabbing posts =(
Not really "for a few days" as it is only a day later and it's back to $35. Or, did I miss something? Sorry, but I'm strapped for cash these days :-(
Pro-er tip: rolling back transactions is quicker (because you're cleaning up after a single test not cleaning the whole db/table after each single test) and requires no extra dependecies/gems: $ cat spec/support/capybara.rb require 'capybara/rspec' require 'capybara/rails' require 'capybara/poltergeist' Capybara.javascript_driver = :poltergeist # NOTE Capybara (selenium/webkit) use several db connections, here we force # them to share one so that transactional fixtures continue to work. # see comments in http://www.opinionatedprogrammer.com/2011/02/capybara-and-selenium-with-rspec-and-rails-3 ActiveRecord::ConnectionAdapters::ConnectionPool.class_eval do def current_connection_id Thread.main.object_id end end
That's the general way most platforms succeed. It's a fake it til you make it approach. Honestly, the big thing for me is I think I'd really love it, but, my knowledge isn't very grand in scope yet so the current project there I don't feel like I know enough to contribute to it. I'm hoping to see more submissions in the future though, 
I do not at the moment. Since this is a side project, I was going to no plan on supporting private projects on the site. That being said you can still use churn, I have set that up as a post commit hook for many projects. I am planning to add a feature to the churn gem that can upload it stats to churn site, at which point private projects could choose to upload just their churn stats to the site to browse them, obviously they would be publicly available. Also, at that point the churn-site should be easy enough to run as a standalone app on your infrastructure or on a private heroku instance over https so you could keep all the churn stats private.
The problem with that is you're looking for one that is in either lower demand or processes more students. I can speak from experience, waiting sucks really bad. But at the same time, that high of demand is (hopefully) the result of, well, good results. I'd say worry less about the wait and more about the caliber of the program. That is of course my subjective opinion. I don't know your circumstances and why you are looking to not wait.
Thank you for the response. The .parse_file part is the part I hadn't found before. I will give that a try today. Thanks again.
I believe http://nokogiri.org/ is what you are looking for.
two and a half days. or just use code ruby52 :)
nokogiri + mechanize is a good combo
In addition to nokogiri/mechanize already mentioned, check if the sites have an API. If they have one, you really want to go through that (probably with an http client)
Search for Nokogiri, Mechanize and SMTP.
a site like indeed aggregates many other job sites and listings on many other websites, and features email alerts if that would be enough coverage for you. http://www.indeed.com/tools/jobseeker/
Use this http://anemone.rubyforge.org/ 
Hash.fetch is one of my current favorites. Simple, but hey, it's at least elegant :) http://www.ruby-doc.org/core-1.9.3/Hash.html#method-i-fetch Instead of hash[:foo], you can do hash.fetch(:foo, :bar) and :bar will be returned if no key :foo exists. You can also give it a block to run if no key is found instead of a default value. So many nil checks removed!
I can certainly help explain constructors, getters and setters to you. Before I start I highly recommend you read up on object oriented programming before you start to get serious in any OO language. This is a good quick introduction - https://www.clear.rice.edu/mech517/Books/oop3.pdf With all that out of the way, let's start the analogy :) I'm a Human. I have many properties like my name, hair color, size weight etc... etc... In ruby you would create a human class and give it all of these properties but they have no value yet (For the purpose of the explanation), so they need to be set. When you create an instance of the Human class you can then set the values, this is done via a setter method. To retrieve the values of the Human you would use a getter method. A constructer method let's you perform some tasks when you create the new Human, perhaps you want to give the Human a default name. This can be done at the same time as creating the instance by using a constructor. 
Factory methods are used to encapsulate the instantiation of an object. Two common uses of factory methods are to hide the instantiation because you think it will change or you want to give the user of the class an easier interface. A good example in ruby is the .new method on a class. This method hides the process of instantiating an object of that class. IMO factory methods should emerge over time out of a need to encapsulate the process rather than be decided on upfront. Almost every time I've started out with a factory method in mind, I've come to find out that my factory doesn't "produce" much. If you could give me a domain that you have a good understanding of, I could probably come up with a much more applicable example.
Nokogiri is a great too, but also look at [Watir](http://watir.com/) or [Watir-WebDriver](http://watirwebdriver.com/). They will open up an instance of your browser (or if you want, you can go headless) and automate your actions. browser = Watir::Browser.new browser.goto(site) browser.text_field(:id =&gt; 'txtUserID').set("User") browser.text_field(:id =&gt; 'txtPassword').set("Password") browser.button(:value =&gt; 'Login').click etc... That is using watir-classic
As a ruby beginner - thank you! I already have a question after playing with it for a few minutes (it might be super basic). You have a couple slides about which "binds more tightly". Can you expand on when that would be important or relevant while coding? Thanks!
This is a pretty good gem and I've had success with it in a production environment. Watch out for the minutely gotcha at the bottom of the docs.
I know this is not exactly what you're looking for, but some of them probably have RSS feeds, in which case you can use blogtrottr.com
You can use Nokogiri, but you can also do crawling with Capybara, which might appeal to you if you're already familiar with it.
Yep. Some implementation notes: - I wouldn't do email. The e-mail integration is going to be the most annoying part of the project. Just figure out something else that will be a sufficient notification. - Getting job results is easy with Nokogiri, assuming there's a single search or set of searches that can be encoded as a URL. Basically, you'd just get something like http://jobsearchengine.com/findjobs.php?title=Software%20Engineer and then use Nokogiri to select out jobs that match whatever criteria you want. If it were up to me, I might do something like use the Google Docs API to add rows to a spreadsheet when a new job is found, and then have Docs notify you whenever the spreadsheet is changed. Then you get e-mails, a spreadsheet containing all jobs found, etc. You're also going to have to create something to make sure jobs that you've already found don't get added. That isn't too complicated, but it's another moving piece.
That's really a spider, not super good for this task. It sounds like he basically wants to grab *new* jobs and apply for them. So he'd use nokogiri. Anemone is great, though.
&gt;You're also going to have to create something to make sure jobs that you've already found don't get added. That isn't too complicated, but it's another moving piece. These job listings should be accessible by a unique URL, no? The script could keep track of the URLs that it sent to Google Docs with a list or a hash. Then when it exits it writes out the contents of the hash to a file. When it starts, it reads the contents of the file into the hash, and checks the job search results against the hash to determine what to do with them.
Yep, I would imagine they would have unique URLs. I, too, would just store in a hash and persist them somehow, but it adds another wrinkle to an otherwise totally straightforward problem. 
I'm trying to learn ruby, so I figured this would be a good way to do so.
Noted. Thanks.
Very cool! This is actually what my long-term plan is. I figured I'd make the crawler my first ruby project, and the website my first rails project.
Noted. I'll start with something less complicated, but down the line I'd like email integration. Thanks for the heads up. I'm set on ruby as I'm trying to learn the language (I'm new to back-end stuff in general, actually) and thought this would make a good first project.
This seems to be the consensus. Thanks!
Nice! Good luck. Let me know if you have any implementation questions. I've done some rather large projects with Nokogiri, so I'm pretty familiar with its ins and outs. I do think the Google Docs API is a good way to end-around and do e-mail integration. With Google Docs you can create a spreadsheet, add rows to it, and then set it to e-mail you every time a row is added. (Nifty feature!) Ruby's not really known as a back-end tool, but it's an awesome all-purpose knife. For something like this, it's way more than you need.
I love it - I use it to consolidate my torrent feeds, filter it, and produce a new torrent rss feed that I can consume in uTorrent so I get what I want. 
This has already started to help me understand these things. I have some other questions now, though :D, if you wouldn't mind. First: In the example you linked (github example code) the setter method is eyecolor(eye color). Why is there a "=" there. When I was doing some of my coding work (I am currently doing Test-First coding) I came across an answer that I somewhat understand. My understanding, and please correct me, is that to manipulate any argument, you need a method= (aka now what i know as a setter). Second: Why do you even need a getter method? Can you not manipulate the argument or instance variable (or whatever) within only the setter and then call it. OR why not just cut the setter method out and only have the getter method. example: why can't the code look like this class Human def initialize (name) @name = name end def eyecolor (eyecolor) @eyecolor = eyecolor &lt;manipulate the variable here&gt; puts @eyecolor puts @eyecolor.reverse.method.method.etc. end end Thank you for identifying them for me, now I have to work through the issue of why every piece is needed. Bonus!: what happened to attr_accessor? (my understanding of attr_accessor so far) : attr_accessor is if you want to have a type of method or something that you can call on the class. from the example above: class Human attr_accessor :name :eyecolor :age end panzerpanduh = Human.new panzerpanduh.name = Panzer panzerpanduh.eyecolor = brown panzerpanduh.age = 2000000 Last word: I am soooo sorry about how long this is. I also want to apologize for how much I am asking, I know it is a lot. I've been trying to read everything about class constructs within ruby and I am struggling a bit. If this is too much or you feel hassled please feel free not to respond :D. Thanks for the previous responses.
I wish i could give you any domain =( I've just started and every day has been a struggle. I'm pretty good with arrays and common things that aren't nested (strings fixnum etc). My flow control is ok, but when it comes to classes I'm starting to have trouble. It's just with getting the proper structure (constructors, getters, setters). Afterwards I'm usually able to figure out whatever problem I'm working on. 
I started doing a bunch of scraping with Watir, selenium, and other browser objects, using headless to bury the activity. So slow and needlessly resource intensive. I've been able to refactor all those calls using rest-client and mechanize, using nokogiri for the document scraping. So much cleaner and more dependable. Don't forget to set timeouts and bury your calls in begin/rescue/end blocks - saves a lot of headaches later on. 
This doesn't seem to be much better than the clockwork gem working with sidekiq if you want very often recurring jobs, like every minute or few minutes. Though, its integration with sidekiq is a big plus. Can sidetiq support such often recurring jobs as I am doing here? https://github.com/hak8or/cryptos/blob/master/app/clock.rb
codewars.com is pretty cool
ok - thought you were looking for a job.
Httparty ( https://github.com/jnunemaker/httparty) has been very useful in addition to Watir. Easy to use too. 
I started programming junior year of high school and didn't really have a solid grasp of object oriented programming until beginning of junior year. That's not meant to discourage you but rather to illustrate that it's not something easy to grasp. The catalyst for my understanding of OO was a 3 month internship and a research position. The most helpful part if both of these was using practical technologies and having a mentor. Most of my previous experience was with classroom projects and small things on m own. During the co-op, I learned about web development and databases for the first time. I continued to learn about these throughout the research position and only then was I able to see the benefit of OO and design patterns. It really helped seeing systems that were poorly implemented vs systems that were well thought out. My advice would be to try not to get discouraged and try to find a job in the programming field. Even if its just a volunteer position. Try to find someone who can mentor you. And to finally get to factory methods... They really aren't that important. At least not for a beginner. When I was finally taught about them, I realized that I had already discovered them on my own. I would just get a book or find a good tutorial on object oriented programming. Do whatever they say even if it doesn't make sense to you. Eventually you will figure it out. If not, you will know enough to get a job and you can learn while in the job.
If you want to do email, look at using mandrill. With https://rubygems.org/gems/mandrill-api To send an email, you essentially just need this: Mandrill::API.new(Settings.mandrill.apikey).messages.send({ :html =&gt; "&lt;p&gt;HTML Body&lt;/p&gt;", :text =&gt; "Text body", :subject =&gt; "More jobs!", :from_email =&gt; "lumbkreto@awesomerubyscript.me", :to =&gt; [ { "email" =&gt; "your_email_here" } ] }) You can get the mandrill api key once you sign up. It's a free account, and you can send quite a bit in a given time frame for free.
Yes, it can. However the biggest difference from that implementation and how I use sidetiq is that sidetiqs methods are called in the class of the worker it is scheduling. These are all in one module. I don't think either way is right or wrong, but for the work I do, I like having them on the class level rather than project level. Especially since not all workers are scheduled. This allows me to get an idea of the purpose of the worker without a lot of documentation or having to look at another file.
That's what I was going to say. Just take the URL, normalize it, md5 it. Easy.
But your new solution can't execute JS, correct?
Most of those sites have rss feeds. You can do it with rss feeds plus yahoo pipes and catch them in your ras reader. Took me about half an hour,
The questions you are asking are actually less related to ruby and more related to Object Oriented Programming. Getters and setters are available in most OO languages, as are constructors and class methods (self.method). Once you understand OOP learning ruby will become much easier. I can link you to a few resources, but really it's up to you to find an explanation of OOP that makes sense to you. Good luck :) Here's a few resources. http://www.codeproject.com/Articles/22769/Introduction-to-Object-Oriented-Programming-Concep http://en.wikipedia.org/wiki/Object-oriented_programming http://www.youtube.com/watch?v=lbXsrHGhBAU (Better if your a visual learner, like myself.)
I slept on it and it makes sense now. a setter is where you manipulate the value of the instance variable, a getter is where you call the variable. i think thats right and ILU thanks dude
Thanks that's great advice. I'm currently applying for a coding program that is a 2 month course on OOP. I feel better about everything now :D
Not too nip pick, but cucumber is BDD. Anyhow, it's still great when you work in QA and have no control over the application you're testing. 
I was using cucumber for my own projects, mainly to get my toes in both major frameworks. One can use rspec quite well for integration testing. Personally, I kind of liked the way I wrote tests using cucumber once i got the hang of it. But I agree it is extra overhead. These days i'd rather just do rspec for integration tests.
"My day-to-day work doesn't benefit from it, therefore it does not have value" A typical consultants short-term client work probably isn't going to need cukes, except in the very rare case when the client is extremely hands on. But for a large complicated application that you are going to continue to iterate on, add features to, refactor and improve, then automated integration tests are essential. Cucumbers role is to describe business value with those test, not a magic tool to make testing fast or simple (which is rarely the case anyway). But when your product owner wants to be assured that the feature your about to put in hasn't destroyed the parts of the app that make money, you are going to be very glad you have cucumber.
These are really common arguments, nothing new to see here... And I'll give the common answer, which I agree with: People who use Cucumber do not use it because it is faster, or can be shared with management, or makes better tests, or or or whatever. They use it because it allows you to start developing by sitting down and outlining in plain english the steps a user will take to use this feature, which you can then implement one step at a time. To me this is a huge advantage, before even having to think about code you outline the process a user takes, and thus the process you will take in developing it. Yes you can do this in rspec, but I find doing it in plain english to be more helpful in preparing to code. This may not be the case for everyone, so as always, do what works best for you. 
If you have [Pry](http://pryrepl.org) set up as your rails console, the [show-source](https://github.com/pry/pry/wiki/Source-browsing) command will do all this for you ;)
Using tools like pry our brain degrades
Back to assembler!
learn IRB and stdlib
I tried the entire BDD stack and discovered it wasn't for me. I find the cucumber syntax as silly as Rspec's syntax, nice to look at but wholly unnecessary. Glad to see I'm not alone. Minitest for the win. Also I prefer inside out to outside in.
Yeah, can't you...just write it down? [Readme Driven Development](http://tom.preston-werner.com/2010/08/23/readme-driven-development.html)
You clearly haven't read much about Pry or its plugin ecosytem. I suggest you watch [this video](http://www.youtube.com/watch?v=jDXsEzOHb2M). But in summary, the things it offers over IRB: * [source code browsing](https://github.com/pry/pry/wiki/Source-browsing) (view source for methods and classes in the repl), including viewing of the various monkey-patches applied to a class. * [editing of methods and classes](https://github.com/pry/pry/wiki/Editor-integration), with changes immediately reloaded. * [Runtime invocation](https://github.com/pry/pry/wiki/Runtime-invocation) * ability to [navigate around your program](https://github.com/pry/pry/wiki/State-navigation) using a file system metaphor, i.e `cd` and `ls` commands * You can [drop into the context of exceptions](https://github.com/conradirwin/pry-rescue) when they occur and the exact place they occur (this also works with test failures in rspec) * [Shell integration](https://github.com/pry/pry/wiki/Shell-Integration), easily run shell commands from a session (e.g run git or rake tasks) * Gist integration * [Remote sessions](https://github.com/pry/pry/wiki/Remote-sessions) * Live help system, and [live documentation](https://github.com/pry/pry/wiki/Documentation-browsing) * Integration with the [debugger gem](https://github.com/nixme/pry-debugger) * And yes, syntax highlighting, with a [multitude of themes](https://github.com/kyrylo/pry-theme) and even ['live highlighting' as you type](https://github.com/pry/pry-coolline) ;) But these are really just the tip of the iceberg, the true power is how the various functionalities work together to support some very effective workflows :) 
Absolutely true. Cucumber allows you to do it and instantly have that translate to failing tests. Like I said, maybe not for everyone. I resisted it for a long while, didn't see the point. Why bother with the overhead of *another* parser when I can just write the tests in code, especially since no non-technical person is ever going to look at my tests. Then I gave it a shot on a project just to have the full experience and I found it really helped my development workflow. For others, planning on paper and then writing tests in rspec or whatever might work better. To each their own. I enjoy the process with cucumber over other processed I've tried.
&gt; Cucumber allows you to do it and instantly have that translate to failing tests. But you have to accept the limitations of gherkin, which often reads like an English speaker suffering from aphasia. Besides, you always need *another* parser -- only with Cucumber, you're often having to parse through step definitions and regexes to figure out if the test is *actually* doing what the English claims it is doing. That being said, the bad gherkin I've been exposed to is not actually a fault of the tool.
all problems can be solved using stdlib and debugger. probably for people using macos pry seems like useful
As someone who studies software engineering at a university and is actually writing his Master's thesis on test-driven and behavior-driven development, I'm really *tired* of opinionated, badly informed blog posts [[1]](http://xkcd.com/386/). Cucumber and BDD in general are **not a substitute** for unit tests. In fact, they're not even a substitute for testing. If you only think about *tests,* you're probably doing it wrong or don't need BDD anyway. The original concept behind BDD is called Specification by Example [[2]](http://specificationbyexample.com/key_ideas.html). The gist of it is that we need to find a way to **build the right product** not to build the product right (that's what unit tests are for). Go read Gojko Adzic's book, it's pretty decent. How do we build the **right** product? By capturing our **business intent** in a way that helps us to ensure that our software exhibits the **correct behavior.** The solution suggested by Adzic is to write a living, continuously updated and **executable** specification. Now, while the executable specification is really important, it is **only the tooling part** of the solution. Cucumber is such a tool, RSpec, JBehave, Fitnesse, etc., are others. The other part is a set of **process patterns,** a practice of development that involves all the parties who are interested in the software. The customer, the project manager, the developers. It's kind of like what XP or Scrum are on the programming level, but on the *system* level. The approach is a continuous process that involves finding out what the customer wants, illustrating the requirements with examples and writing an executable specification. There are two ends of per-functionality testing [[3]](http://books.google.at/books?id=y4JuQgAACAAJ): 1. Through specifying our software by example we support the development of business-facing functionality. We test if we have reproduced the **business intent** correctly. 2. By using unit tests we test if our system has the correct technology-facing properties. This is the **developer's intent**. In the middle, between those two, would be **component testing**. RSpec is actually supposed to be used for that. If you use Cucumber and RSpec, you work **from the outside in**. That is to first specify the *business intent,* or general behavior on the *system level,* and then to specify and test the *architect intent* on the *object level.* Finally, you use unit tests for developer intent only (e.g., to prevent regression after a bug fix). * Ok, so non-technical people don't read code? That is why you use **ubiquitous language** to specify what those people want. They don't have to read it personally. * Does Cucumber add another layer of abstraction and create an overhead? *Of course* it does. The reason you use it is to prevent **cost- and time-overruns** later on when you find out you've built something your customer doesn't want. * Can you use something else to **test** your views and UI? Sure, but you want to use BDD to **specify** that stuff first. If you think this is overcomplicating things, adding too much overhead and preventing people from [programming, motherfucker](http://programming-motherfucker.com/), then you might not need BDD. You may also not need Scrum or unit testing for that matter. Maybe you're writing Applescript. I don't know. **TL;DR;** Cucumber and BDD are **not for testing** but for **specifying** a software system and to ensure that specifications are met by making the specification **machine exectuable.** 1. http://xkcd.com/386/ 2. http://specificationbyexample.com/key_ideas.html 3. http://books.google.at/books?id=y4JuQgAACAAJ 
It might not be for you, *which is fine*, the syntax should be the selling point. Try python instead.
Have you tried http://rubykoans.com/ and http://rubymonk.com/?
I hated Ruby a bit at first too (coming from Python/ObjC background) and when I read *The Ruby Programming Language* and started understanding that everything truly is an object, the lack of parentheses on methods stopped bothering me because I realized I was just talking to objects. And Ruby is also cool in that I define operator methods in a more straightforward way, instead of having to do something like `def __add__` in Python. Instead, I use `def +` in Ruby. Lots of other languages are super explicit about everything and Ruby is super implicit about things. If you prefer the former you'll probably be happier in another language but if you think you could grow to love a language where you can express a lot with minimal boilerplate then Ruby could very well be for you.
Can you give specific examples of confusing syntax? Maybe you just need a solid explanation of how it all fits together :)
I agree, the syntax should be a major selling point. Here's my story... I'm in the atmospheric science field, but have a major interest in programming. We have large datasets and usually write our code in FORTRAN/C. We also use MATLAB, which although i don't like it, it is pretty good at doing what it does (i analyzed data from a field project in matlab this summer). I decided to try and make a weather related website and began learning Ruby/Rails. The change was amazing. The way that Ruby code looks is very pleasing to me and the designers of the language knew what they were doing. In particular, you'll find that the looping structures are just beautiful and compact. Maybe it is the object oriented ness of the language that is throwing you off?
&gt; everything truly is an object except methods.
I don't know too many people who have product owners write Cucumber code - but that isn't why you use it at all. I've used Cucumber (and gotten it adopted) on numerous occasions, and it's always QA that we try for. There are loads of places with QAs who are semi-technical (aren't afraid of reading the DB, used to seeing stack traces, don't write code but might like to) but still doing manual QA work can - and do - benefit enormously from Cucumber. So we (devs) usually write the initial Ruby code, and we sit with the QAs if and when they need additional Ruby guts, and show them what we did. If you write the Ruby bits well, you can reuse code quite a bit. I'd like to read an automation engineer's reaction to this post lol. So yeah, don't ask the CEO or something to write acceptance tests - big deal, that person isn't doing any acceptance testing. Cucumber for your QA staff is an enormous win, and the tone of this article leaves a lot to be desired.
Which languages were the first ones you learned or spend the most time in? I ask because I think that our first languages play a big part in how we view other languages that we learn later. I'm wondering what kind of mindset makes Ruby hard to get used to.
True, though you can obtain a method from a class and treat it as an object and send messages to it to invoke it.
I already use Python extensively. While it has some aspects that annoy me, it is a pretty powerful language with great features.
I'll look into them. Thanks.
I started by teaching myself Java and C# when I first started programming (at least ten years ago). After getting acquainted with the fundamental programming concepts, got involved with C/C++, Delphi, Python, Javascript, PHP, x86 and MIPS assembly. I would say I feel at home the most with C/C++, Java and C#.
Looking for an example. Will update when I do.
Just curious, have you applied any of this stuff in the real world? It sounds like you're reading excerpts out of a textbook. In practice, Cucumber is very much touted for the mistaken reasons that the author mentions. Since you so smugly and authoritatively dismissed the article, I'd like to point out that much of what you wrote is just absolute bullshit: &gt; Ok, so non-technical people don't read code? That is why you use ubiquitous language to specify what those people want. They don't have to read it personally. Ubiquitous language is great. Using ubiquitous language to describe how your software works to non technical people is also great. Gherkin is not necessary for this. Those non technical people will *never* read your gherkin. *Ever*. **EVAR**. &gt; Does Cucumber add another layer of abstraction and create an overhead? Of course it does. The reason you use it is to prevent cost- and time-overruns later on when you find out you've built something your customer doesn't want. Outside in is *slow*. And not in terms of getting something working initially -- although that part is painful with Cucumber as well. Outside in is slow because it adds a tremendous amount of latency to the back and forth between you and your product owner. And you're eating that slowness *before you have even proven that what you're building has any value.* When you aren't sure a feature or application has value, then you ought to *hack the shit out of it*. When you've determined that it *does* have value, then you need to pay down that technical debt you just accrued. My experience writing software has taught me that the more software you deliver, the less technical debt you accrued initially, and the quicker you'll pay it down with a solid specification. The outside in approach has value when used appropriately, but IMO it takes even great engineers many years (and a lot of practice) to learn when to apply it.
Agreed. Different strokes for different folks. I suggest you just move along. There are are a ton of new languages emerging these days: Go, Scala, Elixer, and (cough) Coffeescript. Don't stress it. The most important thing is to find a language that resonates with you, and that makes you happy. 
[Are you sure about that?](http://www.ruby-doc.org/core-2.0.0/Method.html)
The only things that aren't methods in ruby as of 1.9 are arguments. They consist of objects, but aren't objects themselves.
&gt; Since you so smugly and authoritatively dismissed the article, I'd like to point out that much of what you wrote is just absolute bullshit I felt that the tone was appropriate in response to the rather presumptuous style of the blog post. &gt; Those non technical people will never read your gherkin. Ever. EVAR. They do, as long as it presented nicely. But they don't have to. The idea of customers themselves writing Gherkin is obviously wrong. Yes, Gherkin is not necessary. Cucumber is only one of many BDD tools. The central idea still is to make the written specification executable, and Gherkin is a very direct approach to that. &gt; When you've determined that it does have value, then you need to pay down that technical debt you just accrued. My experience writing software has taught me that the more software you deliver, the less technical debt you accrued initially, and the quicker you'll pay it down with a solid specification. The reason Agile, TDD and BDD have even been invented, is to make the software development process more efficient. Almost every project ever had cost- and time-overruns if it didn't fail completely. This is why the practices only really make sense on a larger scale and when they're used in concert. BDD without Agile won't work very well. If you're a one person web developer then you probably should focus more on coding than anything else. So yes, it takes years of practice and discipline. Also great leadership and foresight of a project manager. I think software engineering as an *engineering* discipline still has a lot to learn in order to be more professional and organized on larger scales. 
I have been a scrum master and have actually [TB]DD in practice many times over the years. I understand all the theory you're conveying. But the real world doesn't always jive with it. &gt; I think software engineering as an engineering discipline still has a lot to learn in order to be more professional and organized on larger scales. I agree, it's a hard problem to solve. That's why I don't believe you can hand wave it away with a magic BDD pixie dust wand.
[In 1.9.3 and lower, `1.0.object_id != 1.0.object_id`.](http://stackoverflow.com/questions/2602340/methods-in-ruby-objects-or-not)
I think you will find the fact that many of the traditional hints for syntax being optional/implied the most mind boggling. def foo(bar) return bar + 1 end can be expressed as def foo bar foo + 1 end ... just as easily. {:key =&gt; "Value", :other_key =&gt; "other value"} Can be expressed as {key: "Value", other_key: "Value"} (ruby 1.9? 2? I forget, but it's a newish hing) Or key: "Value", other_key: "Value" ... in *some* scenarios - where the compiler can figure out you implied {} will work. Symbols wierded me out: :foo.to_s == "foo" Why not use "foo" then! The answer is more around immutability than anything else - "foo" can be .split, changed, etc; :foo is a constant/immutable string that cannot be changed - it's a constant who's value is its name. Once you get over those wierdnesses, it tends to smooth out the experience. Unfortunately you do get huge, weird chains of function calls; or blocks/procs/etc being used randomly IE: [1, 2, 3, 4].select {|a| a &gt; 2 }.pop is really data = [1, 2, 3, 4] data = data.select({|a| return a &gt; 2 }) data.pop which is really data = [1, 2, 3, 4] new_data = [] for (i = 0; i &lt; data.length; i++) { if (data[i] &gt; 2) { new_data &lt;&lt; data[i] } } data = new_data data.pop 
I'm going to have to agree with realnatl. As hard a pill as it may be to swallow, he's right, in real life, no one gives a shit about your cukes. Product people just want the product to work. They don't care how you achieve it. You could write your executable specification in Aramaic if you wanted to, it's all the same to them. Product, in practice, is like a soccer mom bringing her car in for a service. She'll utter something like "when I do this, it makes that noise..." and the rest is up to you. All she wants to know is how long does it take and how much does it cost. All she cares about is that you get it working within reasonable limits of the estimates you gave her. She doesn't even care if you use Ruby, LISP, PHP, or Brainfuck. She also doesn't give two hoots about your test framework. If you need to make a sacrificial offering to the Gods of Code to get it done in time, so be it (just don't mess up the office). Really. 
Sure, but in the case of literals like `1.0` and strings like `"hello"` a new object (`struct`) is being created each time, so it makes sense they have different object ids. In the case of methods however, it's the same *method* each time but a new `Method` object is being created. If every method was really an Object in and of itself it would be the *same* `Method` object each time, but it's not. 
Why does it make sense for string literals but not for methods?
Gee I guess all the value we've gotten out of it the past few years has been a waste of time. Cucumber doesn't add hassle it removes it. It allows you to have a small number of developers writing step-defs while BAs and manual testers write features. Much like agile development, it only works if you do it right.
RubyMine is awesome, our entire automation staf use it.
 one_more = 1 one_more.times do puts "try to learn ruby" puts "if you think stuff like this might be useful" end
Gherkin can be (and will be the first time through) written horribly. With a proper framework behind you and the discipline to use it correctly it can be clean and concise. Automated testing is still a young field. Very few places get it right but when they do it pays for itself in spades. 
I am a big fan of automated testing. If there is great Gherkin out there in the wild, I'd love to see it. It may inspire me to change my mind.
Give Metaprogramming with Ruby a read. It really helped me understand some of the things in Ruby that I struggled with originally. Things like ActiveRecord feeling extremely magical caused a lot of problems when I was trying to debug but after that book I felt extremely excited about Ruby. I had previously been a hardcore Python guy and was really unsure Ruby for a long time. Things aren't as direct as they are in Python, but it really affords you some freedom that Python can't.
Hrm, I'll take a slightly different view point on answering this than some of the other answers. I don't really think languages are 'for' or 'not for' someone. It typically has more to do with the tasks you're facing and the problems you're trying to solve. It may be that ruby isn't the hammer you're looking for in the project you're working on. 
Don't *ever* use http://ruby-doc.org It is terribly designed, functions horribly. Please use http://rubydoc.org instead
They're using the Google Site Search iframe thing, which has ads. Search is a difficult/costly service to provide, so they're letting Google do the work for them. Otherwise they'd have two options: 1. Crappy SQL search that doesn't find what you want half the time. 2. Running a full-blown search server like Sphinx.
I'm skeptical: Python, PHP, and JQuery have figured out how to have awesome API sites.
Not sure how to search the Ruby API on http://rubydoc.org. It's only obvious how to search third party gems.
Please fix that blog theme. I thought that disqus thing was another post. It's really unreadable.
Use Google: rubydoc ClassOrGemOrWhatever 
Unlike Strings, there are no mutators for Methods, so the case where you construct two Methods for the same method and then modify one can't happen. I agree that it's strange and silly for #method to create a new instance each time but it doesn't seem to have any practical consequences.
Ruby deserves better API documentation.
I've always been a fan of the "bad advice and flame wars" sections at the bottom of every page on the PHP documentation.
Use Adblock Plus? Crisis averted.
array.shift In other words, b = a.shift Edit: oh, I didn't read clearly enough. You want to move a[0] to a[a.count]. I'm on my phone and can't type that well, but you could use some combination of the shift method and a.count to achieve this. 
&gt; PHP &gt; awesome API sites lol
The discussion on literals actually sidetracked the argument, it's not analogous, and just confuses things. The primary point is this: if methods really are objects then the job of `Kernel#method` would be to simply return that method object. However, `Kernel#method` does not do this because **there is no** underlying method object - instead an object which wraps the method metadata (a `Method`) is created and returned on demand. I understand what you're saying. You argue that there are no practical consequences and you 'may as well' just view the `Method` object returned as *the* method object and conclude that methods are objects. But I disagree. In languages where methods truly are objects (such as Python and Javascript) it is a fairly common trick to actually store attributes ON the method object itself; this trick is impossible to pull off in Ruby since a fresh `Method` object is returned each time with any attributes you set on it cleared out. Both points of view are still arguable: I argue that methods are not themselves objects, but a `Method` object that wraps method metadata can still be created and returned on demand. You argue that methods are objects and that it's simply a quirk that a different object is returned each time you call `Kernel#method`. I have to perform more mental contortions to find your perspective acceptable ;) YMMV
`a &lt;&lt; a.shift`
That's one query out of 20 that don't work. How about the api for named parameters, or minitest?
&gt; a fairly common trick to actually store attributes ON the method object itself This is by far the most interesting assertion in this thread. Can you suggest further reading on why one would want to modify a method at runtime?
 b = a.drop(1) + a.take(1)
a.rotate #=&gt; ['b', 'c', 'd', 'a']
It's in the r/ruby sidebar too. 
1. Go to [core rdoc syntax documentation](http://www.ruby-doc.org/core-2.0.0/doc/syntax_rdoc.html) 2. [Click methods](http://www.ruby-doc.org/core-2.0.0/doc/syntax/methods_rdoc.html) 3. [Scroll a bit](http://www.ruby-doc.org/core-2.0.0/doc/syntax/methods_rdoc.html#label-Keyword+Arguments) 4. Presto, keyword arguments ---- 1. Google "rubygems minitest" 2. https://rubygems.org/gems/minitest 3. Click "Documentation" 4. http://rubydoc.info/gems/minitest/5.0.8/frames 5. ??? 6. Profit
['day', 'happy', 'cake'].rotate
b = a[1..-1] &lt;&lt; a[0]
Good to know, thanks!
I use emacs, which has great find and replace support. But how can I differentiate one instance of "[:name]" from another that isn't related to the data structure. I could probably go a file at a time but that would still waste time and if this data structure is a part of a library in public use, then there is nothing I can do.
I love you
This always reminds me how Haskell-y ruby is.
.join(" ")
Amazing that you get downvoted for this. It's a sad commentary on the kind of thinking going on.
If I took the time to point out why I believe you're are incorrect, are you open to changing your mind?
When would it be preferable to choose a frozen string over a symbol? For example, :'My fake frozen string'
a.rotate
If you need to compare it to another string I guess
These are the same. Take the one thats easier to read a &lt;&lt; a.shift Or a.push(a.shift)
Oh yeah... and there's that ;-)
Also: http://stackoverflow.com/questions/5270098/arrayrotate-equivalent-in-ruby-1-8-7
Thanks for the feedback!
If you find that you're using this structure in more than one method/proc it's a good indicator that it deserves it's own data structure.
A symbol needs to be converted to a string in order to be concatenated with another string. In cases where the same string is used multiple times (as an example, `"SELECT"` in Arel), that overhead can quickly add up. Using a symbol does not solve the problem in any way if you actually need a string.
Where does the string that a symbol is converted to come from? Isn't it stored in memory, in exactly the way that a frozen string would be stored in memory? In that case, why not add the appropriate optimized methods to symbol to let its string representation be concatenated? In other words, why not add the String interface to symbol, with no need for additional syntax.
A few reasons -- - Plenty of people use Symbol#to_s when they need to modify the resulting string. Returning a frozen String would break backwards compatibility in a pretty big way - Storing an object in memory that will never be GC'd should require the programmer to be explicit. - It'd be a pain to have to do `:'foo bar'.to_s` Every time someone wants a frozen string.
I'm not saying :'foo bar'.to_s should be a frozen string, I'm saying :'foo bar' + "fizz buzz" should be implemented. :'foo bar' should be a frozen string, since, as far as I know, it is the same data as a frozen string.
Calling bash using a mechanism which allows you to specify the path directly will save you the over head of starting an additional, unneeded process. 
http://rubydoc.org/stdlib/core/frames
Instead of passing a string to the `system` method, you could use a list of arguments and spare yourself the need to fork a `sh` process that will fork the `bash` process which will then execute the program you wanted to execute in the first place. Even better, if your real need is to send strings to the input of an external program, you could just use `popen` (or any version of it in `Open3`) to have direct access to those pipes.
http://www.bennadel.com/blog/1522-Storing-Property-Data-In-Javascript-Function-Objects.htm
Great photos! Wow, lol, Avdi is looking even more Jesus-like than usual.
I find [ActiveModel](https://github.com/rails/rails/tree/master/activemodel) very well written. Indeed most of the more popular gems are well written (one of the benefits of open source). So, I would just start looking at libraries you've been using. Maybe try to first think about how the library implements feature X (e.g. how would you implement ActiveModel's `validates :name, presence: true`?) and then compare your solution/idea with their actual implementation.
As a web programmer I can recommend looking at the code of microframeworks like camping.io, or sinatra.
You can look at [prawn](https://github.com/prawnpdf/prawn), and [what Advi Grimm wrote](http://devblog.avdi.org/) is also a very good source for improving your ruby code.
Yeap. In my project I really used popen3 to get error output to raise it in exception)
Maybe this one? https://github.com/jisaacks/ruby-tic-tac-toe/blob/master/lib/ruby-tic-tac-toe.rb
sidekiq is nice to read, and foreman
Uh, I don't think so. It doesn't seem to make "a clever use of blocks and yields".
but :'foo bar' is already a symbol..
WHAT ? Redmine code is fugly as hell. REALLY.
I learned a tremendous amount about evented programming and eventloops while reading the source of [celluloid-io](http://celluloid.io/). I'd previously dabbled with eventmachine, but didn't have a good grasp on what it was doing, but this made it all clear
Fine, I said as much. What's your suggestion?
this is how I actually got a lot better at programming. I simply wrote my own validation implementation just to see if it would work. I was pleasantly surprised and learned a ton in the process. 
I think [Minitest](https://github.com/seattlerb/minitest/) is exceptionally well-written and understandable.
Gtihub is the best ruby program I have seen.
[Discourse](http://github.com/discourse/discourse) is a great example of a large, modern Rails (and Ember) app.
Try harder. Ruby is easy.
I once saw a ruby gem that could kill a bear with its bare hands.... 
Did this behavior change in some recent-ish version of Ruby? How would I check whether a method was redefined from an initial state?
Everything is an object. All method calls are actually messages and they implicitly go to "self" (the context determines what "self" is). All method calls return something (even if it's nil). The *class* method "new" calls the *instance* method "initialize" before it's done. Which is why those are different. Only 2 things evaluate to false- nil and false. Not empty string, not zero, not empty array etc. This actually simplifies things greatly. Names of things that start with a capital letter are constants. (Yes, classes are also constants.) Symbols are created once (when they are first mentioned) and never destroyed and always refer to the same symbol object in memory. This makes them ideal for hash keys. A block is a nameless chunk of code that can take arguments. The most powerful class in all of Ruby is probably Enumerable. And pretty much everything that is Enumerable, like arrays and hashes and IO objects, can take blocks, which is why you don't have to worry about iterating through them with an "i" index variable and can just call .each on them with a block. Which also prevents many classes of off-by-one errors and allows some of Ruby's conciseness. That's mostly it actually, core-concept-wise. Perhaps you're overthinking things because other languages have far more underlying complexity.
Frozen strings and symbols are both immutable; however immutability is not the only sigificant property of symbols. Symbols are internalized, and not instantiated as a new object each time they are encountered. When freezing, a string needs to be first instantiated, and then frozen, which has memory and performance implications: require 'benchmark' n = 1000000 Benchmark.bm do |x| x.report("ordinary string:") { n.times{ "asdf" } } x.report("frozen string: ") { n.times{ "asdf".freeze } } x.report("symbol: ") { n.times{ :asdf } } x.report("symbol to_s: ") { n.times{ :asdf.to_s } } end Using ruby 2.0 I get: user system total real ordinary string: 0.150000 0.000000 0.150000 ( 0.145614) frozen string: 0.160000 0.000000 0.160000 ( 0.164509) symbol: 0.060000 0.000000 0.060000 ( 0.052690) symbol to_s: 0.160000 0.000000 0.160000 ( 0.165856) Symbols are also much more performant when being compared, as only the object_id has to be compared, not the value: require 'benchmark' n = 1000000 Benchmark.bm do |x| x.report("equal strings: ") { n.times{ "asdf".freeze == "asdf".freeze } } x.report("equal symbols: ") { n.times{ :"asdf" == :"asdf" } } x.report("different strings:") { n.times{ "asdfg".freeze == "asdf".freeze } } x.report("different symbols:") { n.times{ :"asdfg" == :"asdf" } } end My results: user system total real equal strings: 0.350000 0.000000 0.350000 ( 0.346866) equal symbols: 0.080000 0.000000 0.080000 ( 0.084746) different strings: 0.310000 0.000000 0.310000 ( 0.312560) different symbols: 0.090000 0.000000 0.090000 ( 0.083912) As to _when_ to use frozen strings vs. symbols, I'd say those are actually 2 questions: 1. When to use strings vs. symbols? Strings should be used for data to be displayed to the user, and symbols only internally (e.g. hash keys) 2. When to use frozen strings vs. "ordinary" strings? Whenever you need immutable data which you'll also need to present to user (e.g. concatenating fixed and variable parts of text - but please don't construct your SQL in that way). String#freeze and Symbol#to_s have basically the same performance, but freezing a string much better conveys the programmer's intention, which may very well be more important than raw performance (especially in ruby :) ) &gt;:'foo bar' + "fizz buzz" should be implemented. Return type being symbol or string? What about "fizz buzz" + :'foo bar'? &gt;:'foo bar' should be a frozen string, since, as far as I know, it is the same data as a frozen string. The same data yes, but behaviour is _quite_ different internally :)
The reason is simple. Ability to define the dependencies isn't a feature I'd exchange for even more performance. With cat you have the files in lexicographical order (or the order returned by the shell, or a system call or whatever), which in most cases, is not something you want. The other way would be to to manually tell cat the order of the files. If I could use cat to do this, then I'd parallelize compilation of each file, and then cat them together. Then running `make -j N` (where N is number of cpu cores you have) would be even faster! EDIT: fixed some typos.
Is there a review of what each of those changes mean? I fiddled a bit w/ the def-return-value change, but it would be nice to see some article/document detailing what each change means.
I thought people generally didn't like refinements.
+1 for Rubymine. It is an awesome IDE.
[Adhearsion](https://github.com/adhearsion/adhearsion) is built on celluloid, and a great bit of nice Ruby code to look at.
Can you please give an example of what you're saying?
[Method definitions return symbol](http://franck.verrot.fr/blog/2013/08/21/method-definitions-in-ruby-2-1-0-will-not-be-void-anymore/). [Frozen string literals](https://groups.google.com/forum/#!topic/ruby-core-google/uiKw9uE3Hc0). [New generational GC](http://www.infoq.com/news/2013/09/ruby-2-1-gc-revamp). The refinements change, afaik, is putting back the original refinements stuff that were hobbled in 2.0. Edit: [Hacker News discussion](https://news.ycombinator.com/item?id=6429316) has more stuff.
I only called out 1.9.3 above because in 2.0.0 floats literals no longer create a new object for multiple float literals with the same value, which is how integer literals behaved already.
Opinions are very mixed in general but from what I remember MRI has no intention of removing refinements because of that.
Wow, thats cool as shit. If i did much with phone stuff, I'd use that
I'm nervous about that AR monkey patch. The AR connection pooling stuff is wacky/fragile enough already, without hacking it to do something it's not intended to do. And it's especially wacky/fragile under multi-threaded concurrency -- which is exactly the situation you are trying to handle for capybara ordinarily using different db connections in different threads. 
Stuff like that is usually built in into IDEs and such, try one of them.
They liked the idea, but didn't like the performance impact they had, and maintainers of other interpreters (jRuby, Rubinius), had concerns about its implementation. I suspect that they have given significant input as of 2.1 and the problems will be resolved
I posted some examples of the new literals: http://justincampbell.me/til/ruby-2-1-0-language-changes I might try to make a more in-depth post on all of the changes when 2.1.0 is released.
Ruby static analysis tools: [Reek](https://github.com/troessner/reek) Reek is a tool that examines Ruby classes, modules and methods and reports any code smells it finds. [Flay](https://github.com/seattlerb/flay) Flay analyzes code for structural similarities. Differences in literal values, variable, class, method names, whitespace, programming style, braces vs do/end, etc are all ignored. [Flog](https://github.com/seattlerb/flog) Flog reports the most tortured code in an easy to read pain report. The higher the score, the more pain the code is in. [Cane](http://github.com/square/cane) Code quality threshold checking as part of your build [Churn](http://github.com/danmayer/churn) A Project to give the churn file, class, and method for a project for a given checkin. [Roodi](https://github.com/roodi/roodi) Ruby Object Oriented Design Inferometer [Saikuro](https://github.com/metricfu/Saikuro) When given Ruby source code Saikuro will generate a report listing the cyclomatic complexity of each method found. In addition, Saikuro counts the number of lines per method and can generate a listing of the number of tokens on each line of code. And you can get all these tests plus an cool report output with Metric Fu: [Metric Fu](https://github.com/metricfu/metric_fu/) A fist full of code metrics
I was on board with you until you said that having comments would throw an error. I always write my code to be readable without comments. However, I am completely biased when it comes to determining whether or not the code is readable, since I am the one who wrote it. I can't count the number of times I've 1) commented up a method 2) realized the code explains itself 3) deleted the comments because they were redundant 4) come back to my code and wished I had left the comments in there. I can't possibly know how readable my code is to someone else (or my future self) without asking them and I'd rather leave some comments and move on to the next task. I sometimes go a little overboard with comments, but I would rather look at code that is heavily commented than code that has no comments. Most text editors do a pretty good job of differentiating code and comments anyway so it's not a problem to avoid looking at them. I can always go back later and remove them if it turns out the code reads well.
PMD, Checkstyle, and Fndbugs are fairly standard in the Java world http://pmd.sourceforge.net/ http://checkstyle.sourceforge.net/ http://findbugs.sourceforge.net/ 
You should share this with /r/RubyMotion as well.
Codeclimate is nice. They also have a new module to score test coverage for your project.
Is RubyMotion really worth it? First you have to pay a few hundred bucks for a license, and then, since Apple doesn't support RubyMotion, you have zero guarantee that they won't come to you and delete your app from the App Store.
You're right there is a cost, (200 USD on top of 100 USD for the apple developer licence). I don't think there's any reason to believe Apple will reject an app because it uses RubyMotion. Using RubyMotion isn't against Apples guidelines and as far as I know they have never rejected RubyMotion apps in the past for this reason. HipByte also offer refunds if your not happy. As with any app store submission Apple may reject apps for other reasons if they contravene their guidelines. Any iOS programmer should keep up to date with the guidelines and look at past rejections. It is most certainly a personal decision- is the extra cost worth it? Or even do you want to be coding for a closed operating system at all? For me it is, but I can see why it might not be. 
http://www.sonarqube.org/ combines them in a "metric-fu" (better) equivalent. Sonar also offer an eclipse plugin that will use the same rules for all the developpers.
for a show case of the rules and the typical solution : http://mestachs.wordpress.com/category/sonar/
Yes, there is also an intellij plugin for sonar
Yes, I am familiar. I'm looking for equivalents for analyzing Java code.
I'm kind of getting tired of these hyperbolic [svbtle](https://svbtle.com/) blogs. Its not a /r/ruby problem, its a reddit problem. Sure, they host some decent blogs, and their bloggers have done some cool things, such as the guy who wrote juggernaut or whatever, but for the most part their blogs just come across as pissant whining, espousing a technical elite, and bemoaning the decline of the technological priesthood. As for the article, I would hardly say ruby is fading into history. Ember, Angular, etc. all have strong ruby+rails support (ember shares a fucking core dev, for finagle's sake), rails 4 has turbolinks which gives traditional sites a bit of javascript speed magic, and jbuilder is now first class, instead of having to be added as a gem.
Procs and Lambdas are perhaps one of the most underused features of ruby. They can clean up your code dramatically. I've come across codebases full of singleton methods and other such nonsense that is used only once, and is so usage specific that it doesn't need DRYing. A simple lambda can dramatically improve readability, and also prevents issues such as the `Hash.new([])` problems that i've seen seasoned developers fall prey to
More complete list, with explanations: http://rkh.im/ruby-2.1.
The hype machine has died down, and now it's just "one of the boys" - this is really what they're seeing. Still has plenty of people writing good software for it.
&gt; Hash.new([]) problems which problems exactly? 
Every key in the hash will reference the same object, the same instance of Array. So if you use things like `&lt;&lt;`, you're appending to the *same* object, not a new one for each time. I was wrong about the lambda part, hash accepts a block. But I've seen lambdas used for similar problems before, I just can't for the life of me find an example Here's another iteration of what I'm trying to say: https://www.ruby-forum.com/topic/4409379
This is what makes me think how to improve this solution. I am aware that "comments throwing an error" are a no go for some users :)
Great, if Twitter was using Java. Most of their stuff is Scala, and they only occasionally drop back down to Java. Scala is a completely different beast than Java 
Maybe this will be helpful. I have not used it for anything, I don't know if it can meet your needs. It is not Ruby/Rails, it is Node.js https://github.com/sylvinus/node-crawler
I've seen a considerable boost in switching from thin to passenger, but websockets were still an issue. I can finally make the jump to passenger now! Also, could you make a gem out of this? That would make it really simple to pop it into an existing app.
&gt; The release notes â€¦ didnâ€™t go too much into detail. To find out more, you are pretty much left with diving through the Ruby issue tracker. Of course we are. Why do we put up with using a language that's "open" in name only? I'm realizing that I started using ruby only because of rails.
It's not a gem because it's not a library. This demo just shows that WebSockets do work in Phusion Passenger, and shows how a minimal WebSocket example might look like. You can use any WebSocket library you want, provided that it supports the right protocol version. Although I haven't used it a lot, it seems that faye-websockets is a decent higher-level WebSockets library. We contributed to it to make it work nicely with Phusion Passenger.
&gt; People like to generalize things. Like "Twitter says they get more performance with Java, so, Ruby sucks", which is not correct. If it was, **maybe you could also use PHP, since Facebook uses it and it works for them.** Just for you to know...Facebook doesn't use PHP. They use C++, to which they compile all their PHP code. For this reason it's fast. Having only PHP would be crazily impossible.
Are you sure? I thought that they were using PHP quite extensively in Facebook. You say that they compile all their PHP code to C++. I guess that you're referring to the HipHop project (https://github.com/facebook/hiphop-php). But this is not actually true anymore. The compiler from PHP to C++ is deprecated, and now the HipHop project is not a compiler but a full-fledged JIT virtual machine. That's a huge effort, so I'm guessing that PHP is still a big part of their codebase. Therefore, I guess it's too "risky" to say that they don't use PHP ;-)
Are you indexing the results of search engines or actually indexing sites?
What was the syntax for freezing strings that the author would have preferred?
Wait, what?
We should write something better so the Ruby devs don't have to endure continuing to use it as their bug trackng system. /s
Important point! You could accomplish the former with Mechanize and maybe a dozen lines of code.
either I'm having a stroke right now or this guy doesn't words
&gt; private def foo &gt; end What? Is Ruby trying to become Java?
Not sure but I remember a suggestion for %f( ) Link: https://www.ruby-forum.com/topic/4415171
I don't know what I meant anymore :) I guess I meant the one you suggested. 
I've used that monkey patch in JRuby projects (worked great - fast &amp; simple). I think the main idea is to share a single connection between all the consumers (threads), which probably actually isolates you from certain concurrency issues. In my experience, AR concurrency issues only happen in production and are very hard to reproduce or isolate. I think AR has fixed most issues, because I haven't seen an AR concurrency issue in quite a while.
No, I went to a career fair in a banana suit. It actually worked pretty well. Recruiters would pull me in for pictures and have me cut the line. You got a call??? Lucky bastard.
It is a preview, not a release.
Well, the private keyword already exists. You can currently choose between doing private :foo (after defining the method foo) and doing private (without parameters) and defining foo after it. The first method is slightly annoying because you need to type the method name twice, the second can get easily messed up in merges when methods are added/moved/...
Awesome. V2 needs to also force all units to metric. But otherwise this kicks ass.
http://gmplib.org/ Is this the GMP in question?
http://www.youtube.com/watch?v=1KvcQNeI53g
http://www.hhvm.com
Does it allow you to blame Canada if something goes wrong, eh?
This also opens the door to some fun hacking opportunities. you could have a class macro that offers an API like: Logger.watch def foo puts "bar" end which hooks the `#foo` method and logs when it's called. Or you could use it to re-implement the `async` keyword from C#, with an implementation something like: def self.async(method_name) alias "_old_#{method_name}" method_name define_method(:method_name) do Future.new { send("_old_#{method_name}" } end return method_name end And now you call that method and receive a promise for a future result. Implement `Future` however you like. It even preserves the contract that the new `def` institutes, so you could do: private async def foo #snip end The possibilities are pretty much endless. 
Except when measuring short distances, weights, and alcohol.
https://github.com/Aaronneyer/network_scanner/blob/master/lib/network_scanner.rb#L154 You should rescue more than Timeout::Error, e.g. Errno::ECONNREFUSED if port_open? is just supposed to return true/false and not blow up.
try /r/forhire
If you have to ask, you might not be senior... You could flip it around like I do... my title is "SeÃ±or Developer".
This _really_ looks like homework...
flay theoretically can work on java... it just needs a plugin that parses java to sexps. I haven't bothered because... java.
I thought you were joking when you mentioned it. Good stuff! &gt; We hand-tuned the gem's performance to keep it in line with everything else in Canada. Just perfect. 
&gt; Our client is a growing, creative, innovative digital agency looking to bring on a **PHP developer** From your job posting...
[Metasploit](http://www.metasploit.com/) is also a ruby network scanner. :P [GitHub](https://github.com/rapid7/metasploit-framework)
it's not...i'm out of school. Also i have a really good attempt on it...its not like im trying to get people to do my work for me. I even identified where i think the problem is and how i could solve it, but I dont know the ruby syntax to do so. 
I'd be more interested with how you approach problem solving than how much of the ruby manual you can remember off the top of your head.
Any specific problems you might throw at me?
Oh right good call, I'll add that in. Most of this code is still fairly lax in error handling. It's just something I hacked together for some personal use cases.
Hey thanks for responding! I don't really have much and I'm about to do a 40 minute commute home but this is the prompt and I'm currently going through Learn Ruby The Hard Way on my own so I can start understanding the concepts. It's due tomorrow, so any help you could give me would be awesome. Here's the prompt: https://github.com/ryanpah/ga-mtba-array-hash-homework
&gt; Hey thanks for responding! I don't really have much and I'm about to do a 40 minute commute home but this is the prompt and I'm currently going through Learn Ruby The Hard Way on my own so I can start understanding the concepts. It's due tomorrow, so any help you could give me would be awesome. Here's the prompt: https://github.com/ryanpah/ga-mtba-array-hash-homework Well, a few things I see: * You're going to need to grab input to get the line&amp;station line&amp;station from the user, so you'll need something like gets from [this](http://stackoverflow.com/questions/6556280/read-input-from-console-in-ruby): * The ruby documentation is pretty good, and since the instructions say to use a [hash](http://www.ruby-doc.org/core-2.0.0/Hash.html) and an [array](http://ruby-doc.org/core-2.0.0/Array.html) the docs for both of those would probably help. * Since you're not suppose to use a while loop for the whole program and you're not suppose to do anything with classes the flow of your program doesn't seem too hard. * If it was me I'd define your hash of arrays first, since it is your data. * Gather your input, if you see yourself doing something multiple times break it down into methods. * Break the problem into small steps, try not to repeat yourself, that's what methods are for. If you get stuck here, think about how you would do this by hand. * Your output is suppose to be a list of stops, so I would either print out a stop as you come to it, or have another array to store your stops so you can print them at the end. * The person who wrote this is strongly hinting at 'intersection' so I'd search for 'intersection' in the ruby array class documentation. Hopefully this helps, let me know if this is dramatically off from what you need.
Is the program to be run at the command prompt/terminal?
So how much are you going to pay us to do your homework?
Why would you expect the @value to be reset? I don't see anything that would cause @value to be reset. I don't know where you got this from, but perhaps there shouldn't be a separate @value variable. Just store the answer on the top of the stack instead of a separate variable. You can implement value by calling array.pop. That will give you the right answer and reset value. In terms of improving the code. Add, subtract, multiply, and divide are all the same code, the only difference is the operation that is performed. There are a couple different ways to refactor it. You could pass a symbol into a method which would call that operation. Num1.send(operation, num2) You could pass a block that performs the calculation. Perform_operation do |num1, num2| num1+ nun2 End I like the second method better because you can easily handle calling to_f in the case if division.
Yes I'm using the terminal to test it and coding it in Sublime
If you want to have a look: https://github.com/ryanpah/ga-mtba-array-hash-homework
It sounds like your professor gave you a word problem involving "single-source shortest path." Start by searching for that.
alright thanks for the response and advice! 
Awesome. I'll keep watching this thread just in case.
Hi there, do you have any idea of what kind of algorithm you would be using? I took a quick look at the github page and thought up a solution that could work. I'd rather not just tell you right away but if you figure it out let us know! Or we could offer some more hints most likely.
Maybe OP is a girl though
Mmm, [brine](http://en.wikipedia.org/wiki/Brine).
RSpec 30% faster ruby 2.0.0p195 rspec foo_spec.rb Finished in 26.15 seconds ruby 2.1.0dev rspec foo_spec.rb Finished in 17.52 seconds 
Ability to code and think other languages, too. We have a *very* large Ruby/Rails system. We often hire developers who know little or nothing about Ruby. We look for developers with general breadth and specific depth in more than one language -- they tend to be more productive in the long run. In fact, we do not hire Ruby-only programmers. Depends on the company and job, of course. 
 LINES = { :red =&gt; [:southstation,:parkst,:kendall,:central,:harvard,:porter,:davis,:alewife], :green =&gt; [:haymarket,:governmentcenter,:parkst,:bolyston,:arlington,:copley], :orange =&gt; [:northstation,:haymarket,:parkst,:state,:downtowncrossing,:chinatown,:backbay,:foresthills] } COMMONSTOP = (LINES[:red] &amp; LINES[:green] &amp; LINES[:orange]).first def stop_index(line, stop) LINES[line].index(stop) end def stop_distance(line, enter_stop, exit_stop) stop_index(line, enter_stop) - stop_index(line, exit_stop) end def distance(entry, exit) line_entry, stop_entry = entry line_exit, stop_exit = exit if line_entry == line_exit dist = stop_distance(line_entry,stop_entry,stop_exit) else dist = stop_distance(line_entry,stop_entry,COMMONSTOP) - stop_distance(line_exit,stop_exit,COMMONSTOP) end dist.abs end puts distance([:orange,:northstation],[:orange,:state]) puts distance([:orange,:parkst],[:green,:bolyston]) Â¯\(ãƒ„)/Â¯
The number one reason I have always hated css. 
I'm having a hard time understanding what the point of coerce is. As far as I can tell it's there to handle nil when you are trying to convert to integer, but ruby already coerces nil to 0? nil.to_i =&gt; 0 Are you using your coerce for this: nil.to_i =&gt; nil If so, why? 
This is similar to, but less convenient than Object.try in Rails.
BTW, anyone looking to hire a ruby developer? Im australian happy to work remote.
Implement Enumerable#inject. Implement a method that returns the number of quarters, dimes, nickles, and pennies for a given amount of cents. Implement Array#flatten. Implement a method that returns pretty output of a hierarchical directory structure that is specified by rows with attributes of id, parent_id, and name. Send us some sample ruby code that you have written. 
lol
What a stupid metric. This (like the Law of Demeter) will hurt you more if applied blindly without understanding go the underplaying problem. No set of such a simple rules can produce universally good code. A simple analogy: a good car has four wheels. Now go build a good economically viable long distance transportation vehicle with that rule.
is this clojure?
http://www.reddit.com/r/ruby/comments/1n52qn/new_ruby_student_looking_for_someone_to_help_me/ccfmo9w
I didn't mean the code, but more the idea for the approach. Also, rspec tests are supposed to be independent from each other. So you wouldn't want two tests in the same "it" unless you were specifically testing the resetting of value. If the purpose of this test is to test the resetting, then you might want to have a much simpler calculation before and after. Something like (pseudo code): push(1) value.should == 1 push(1) value.should == 1 This will be easier to debug, and if it passes then add another test that is slightly more complicated.
No Assert's? 
My "this is pretty damn cool" comment was a PM to you about your comment. Also, I was legitimately asking if this was clojure. I'm unfamiliar with the language and thought it was lisp at first.
Sorry i am crap at reddit.
in the test/ directory :)
Hi, We know it is a limitation but it kept our integration needs low, which helped a lot to start off. This is something we would be glad to extend in the future. Are you using another service (BitBucket?) or more looking for something you could run/install yourself (if you are self hosted)? Thanks! Martin
Does this work with private github repos?
Hi, Yes it does. We use deploy keys for this. Martin
Sure seems like homework. Either way, you have a theory that `@value` is not being reset between the two tests in the spec (really shouldn't have multiple tests in one spec as /u/kcdragon mentioned), but you're not sure how to do that in ruby. So look at what you do know: looks like `@value` is being mutated as a side effect of calls to `plus` and `times`, right? (Does `@value` change if you just call `push` without calling `plus`? Try it and see.) So maybe you could define a method to set `@value` back to it's initial state, and call that before the second test? Maybe you could define a method to capture the value of `@value`, reset `@value`, and return the captured result, instead of just returning `@value`?
Hi, coOP here. For the moment, it reviews only ruby code (some special rules are applied if it's a RoR project). Which language do you have in mind?
Were you the guy who announced this in the middle of Baruco? Did Sandi ever comment on it?
I personally prefer something along the lines of your third option presented, as it gives you great flexibility. If module M has broad applicability, you may have several families of shared examples that are only relevant to certain problem domains. As your specs grow in number, you may want to split the shared examples into their own categorical files, keeping the universal model specs in the original file. Also, you should probably change your gist to read "module M" instead of "class M". 
As useful as this looks, I can't help but to read this as some sort of Ruby MadLib :-P 
Why not use yaml since that already exists and requires no debugging? fish_and_chips: condiments: - vinegar - ketchup vegan: false price: "$14.99" 
No worries. I am too. If you check your inbox the message will be there.
Why should someone use this over [Code Climate](https://codeclimate.com/)?
You might want to try a module here. module A; def condiments(args); @condiments = args; end; end class InheritedNonsense; extend A; end
Mistake is a strong word. More like a multi-character typo ;) Thanks for posting your question, BTW. Testing modules/mixins is a great piece of Ruby-fu and you're certainly helping the community by fostering the discussion.
haha.
I've been learning ruby for the last year or so and have been interested in starting on another language. Do you think clojure would be a logical choice?
use instance_eval, see my example here: https://github.com/shvets/design_patterns_in_ruby/blob/master/meta_tricks/simple_dsl.rb
I have a couple things which might be of interest to you. The first thing is a little class I wrote for a project I'm working on, [Configuration](https://github.com/jfredett/ramsey/blob/master/lib/ramsey/configuration.rb) is a class from which you derive, then you define, using `config_attr` in the class definition, a series of configs you want to set. Then you can `new` up your subclass, and pass it a block which calls each of those methods, ie if you have: # https://github.com/jfredett/ramsey/blob/master/lib/ramsey/backend/configuration.rb module Ramsey class Backend class Configuration &lt; Ramsey::Configuration config_attr :marshal config_attr :repo end end end then you would do: Ramsey::Backend::Configuration.new do marshal SomeMarshaller.new repo SomeRepo.new end This returns an object such that if you call `#marshal` or `#repo`, you get back the value set on creation. You can also over-write that value after the `#new` by calling it with an argument. The objects you set are whatever you like, including other `Configuration` subclasses, so you can nest these a bit if you need to. It's nice for providing that sort of API, but it is a pretty basic implementation. One important thing to note is that it makes configuration an _instance_ of something, not a _class_ of something. That makes sense from a domain perspective, you have one "kind" of configuration, but many individual instances of that kind. You don't want to hardcode those values like you put in your motivating example. It makes them hard to deal with if you need to run multiple configs. If you need something a little more industrial-grade. I have a gem called [katuv](https://github.com/jfredett/katuv), it's undergoing a re-write right now to use the [ast](https://github.com/whitequark/ast) gem, but it's relatively usable (if not particularly pleasant) in it's current state. Essentially it offers an API which lets you define language elements and their relationships, and then gives you a function for turning that into a sort of 'parser' which returns a tree of objects represented by your defined classes. An example is worth a thousand words: class Foo include Katuv::Node terminal! end class Bar include Katuv::Node nonterminal Bar multiple Foo end def bar(name, opts = {parent: nil}, &amp;block) Bar.new(name, opts, &amp;block) end which would define a parser (invoked by `#bar`) for: bar 'some name' do foo '1' foo '2' bar 'nested' do foo 3 #no checking on types here. end end and so on. The new version is going to have a DSL which abstracts this all a bit, and also helps make processing the resulting parse tree easier, but it's still early in the rewrite process. You can see some nontrivial usage of it in my project [dugout](https://github.com/jfredett/dugout) in the various `ast` directories south of `lib`.
Thank you! this is exactly the kind of advice I was looking for! I'll read through your code but this is definitely helpful! Curious to look into katuv! 
F'sure. I hang out on freenode in #lpmc (and elsewhere), feel free to stop by and ask questions. Katuv is still pretty nascent, but I've got high hopes.
I'd dig through some of the more popular and aged ruby Gems as those typically have more tests and are more mature, here's a few that come to mind: https://github.com/mikel/mail https://github.com/rack/rack https://github.com/bundler/bundler https://github.com/rails/rails 
I agree about the rspec code. Unfortunately I am unable to change it =(. it is given for me to write code.
This is a little over my head at the moment.
It seems like [the eigenclass](http://madebydna.com/all/code/2011/06/24/eigenclasses-demystified.html) is what is messing with you.
oh.. the eigenclass.. the lurking singleton.. yeah, that's just years of beating your head against the wall before you get it
yes, that's how this cheatsheet came about.
I think I need to augment it with instance_eval and class_eval at some point so that doesn't start to mess with me too.
re: typing 'self' It happens *all the time* to create 'singleton' or 'class methods' `def self.my_method` is very very common. so is `class &lt;&lt; self`
hah, anymore my brain just clumps the "class &lt;&lt; self" as one thing to open up the eigenclass... i forgot it actually has the word self in it even tho i've typed it a million times
Step 1: [do this and stop wasting peoples f**** time with links to sets of links] (http://digitalunite.com/guides/using-a-computer/how-turn-off-computer)
What about custom linters? For example, we have one that checks that each file has a copyright statement in it... Also: Will it work for my Javascript and CSS too? 
I've used the [blockenspiel](https://github.com/dazuma/blockenspiel) gem and it was really easy to get up and running.
wow, this looks like a great read! Thank you!
 class MyMetaClass def self.set(config, &amp;block) settings[config] = OptionsDSL.new(&amp;block).options end def self.settings @settings ||= {} end class OptionsDSL attr_reader :options def initialize(&amp;block) @options = {} # Here's the trick to build any DSL, `instance_eval`. # It will eval the block as if it was inside an instance method of this class, thus the name. instance_eval(&amp;block) end # Catches call to `option_name value` and add it to `@options`. def method_missing(name, value, *) @options[name] = value end end end class InheritedNonsense &lt; MyMetaClass set :fish_and_chips do condiments ["vinegar", "ketchup" ] vegan false price "$14.99" end end I also changed your code to not store settings in a class variable but an instance variable of the class. This will make sure the settings are not shared accross sub-classes.
Holy crap I know Brian Hogan! That guy is ridiculously brilliant. He created some of the greatest Web Developers at my school not as a professor but as a supervisor in IT.
what languages do you recommend besides Ruby , Rails, jQuery?
You've done some work doing on something that's been an interest of mine lately which is dealing with nil as an input value, and I've gained some insight into my own feelings about how to deal with nil by considering the merits of coerce, so I thank you for that. I'm not in love with rail's Object#try there is something about it that makes me stay away from it, although I don't have the smoking gun reason for it. Coerce, I'm regretting to say I like even less and has primarily to do with reason 1 that you listed above. Ruby doesn't often have built-in functions that you can just call a la "coerce(value)", it's preferable to do Object#coerce so you can call it as a method on something. In my opinion a stand alone function like that need to make a pretty convincing argument as to why it should be stand alone. Now let's consider your statement "...it doesn't chain easily, which is an anti-pattern...". If I understand you correctly it's because chaining leads to Law of Demeter problems. Chaining may indeed lead to Law of Demeter problems but chaining itself is not an antipattern. Recall that Law of Demeter is about reaching far inside an object to _it's collaborators_. Let me illustrate an example: _not a violation of law of demeter_ "string".reverse.gsub(/g/, 'h').upcase.swapcase.prepend("new").bytes _violation of law of demeter_ bicycle.chain.size See the difference? The first example is calling multiple methods which act on the same object the second is reaching across collaborators. This is why Rails can rewrite ActiveRecord to use method chaining Person.where(:id =&gt; 1).order("name Desc").first and not violate Law of Demeter. In this context I think you would be better off to put coerce in Object as Object#coerce, since it can't be used to reach over to a collaborator and then effectively you've rewritten Object#try for use outside of Rails. However, I concede that perhaps you are trying to bring a more Haskell like functional programming style into your ruby and as they say with ruby there is "more than one way to do it" and so it may be perfectly fine for you to have coerce as it is. There is no book that says I'm right and you're wrong. I will mention though that I'm reading Avdi Grimm's 'Confident Ruby' and I haven't processed all the examples but I believe he's done some work both on type conversion and nil handling that you might find insightful. My two cents anyways... Oh, and tell Vince the internet says hello....
Thank you :) I hope it was worth it, because I think thath rules need a tool.
I thought it was because it has Perl as its *Spiritual Liege*?
&gt;why on Earth would one want to filter uniqueness based on some criteria other than an exact match Uh... because you have a complex object with specific "uniqueness" semantics (checksum, database ID attribute, etc), that a naive "is this object the same one as this other object" test would fail to handle?
I would be worried that a single connection is not in fact thread-safe to share between threads -- that's the point of AR's ConnectionPool locking in the first place, to make sure that a connection doesn't end up shared between threads. What reason do you have to believe that an AR Connection object is threadsafe for concurrent use in multiple threads at once? But yeah I agree AR has gotten a _lot_ better with concurrency. But that doesn't make me confident that monkey patching AR to work differently will still be safe with concurrency! And the fact that concurrency issues are indeed very hard to reproduce or isolate makes me even more nervous about monkeying about with AR's concurrency contract -- which has taken years for it to get right! 
The answer to how #uniq works lies in Hash's assignment semantics, because that is what uniq uses to find unique elements. That means that #hash and #eql? are used to compute the difference between elements and why 2 Hash objects with the same contents are the the same but to raw Object instances are not. (check the behavior of Hash#eql? and Object#eql? for your answer).
Sorry if I didn't make it clear, that AR patch is used only in the test environment. I may be wrong, but I think that usually no two threads are using (reading/writing) the db connection at the same time (concurrently) when tests are run. That's why it's not a problem (in my experience) if all threads share the connection (in test env). I can imagine an acceptance test where a background job fires, potentially causing concurrency issues, but I'd consider that test very smelly since generally bg jobs should either be synchronous (so you can check the result) or stubbed out (when you don't care about the result).
Thanks for pointing that out. @@ should also be added to the example! However, @@ is not a class instance variable but a superclass variable. From what I understand (mainly from reading [this](http://www.railstips.org/blog/archives/2006/11/18/class-and-instance-variables-in-ruby/)) it's not a good idea to us @@ if you plan to override the variable in subclasses.
I am interested. I'm on Chapter 6 of the book right now, and it's just starting to get gritty.
Awesome! I'd be glad to have you. 
Count me in. I'm on ch 11 now. 
Sweet! I'll be PMing everyone that's interested, but can you register to my website http://www.milesftp.com and then after I get everyone ready to go we will start in the next couple days. Thanks! 
Is there a forum, or a subreddit that we will be using for communication?
Yes I'll be using my programming forum that I created the link is http://www.milesftp.com I created a Ruby on Rails subforum where I'll be all the communication will happen. 
I AM TOTALLY INTERESTED!
Sweet glad to have you! I'll PM you some information. 
This has already just been started. http://www.reddit.com/r/LearnRubyonRails/comments/1mycqo/study_group_learn_ruby_on_rails_week_1/
There is a /r/rubynoobs subreddit and irc chan on freenode. #rubynoobs
[super should work fine for modules too](https://gist.github.com/banister/4bd40af060bc86b86a45)
Yes I saw that, but I wanted to create my own. No harm intended against the people part of that group.
Yeah, it really makes no difference whether you're including the modules into a class or extending the modules into another module. Modules are just stacked in the ancestor chain so `super` should always work fine :)
Glad to have you! Welcome. Ill PM you some details.
Well thanks! That simplifies things :)
A more interesting problem is invoking a method from an arbitrary module/class higher up the chain (`super` wont work as it only invokes the immediate ancestor) i.e module M1; def a; end; end module M2; def a; end; end module M3; def a; end; end class C include M1, M2, M3 end How to invoke `M3#a` ? :) 
It'd be easy to modify my pastie code to take an ancestor index, or even an index of valid ancestors so that it would ignore any ancestors that don't contain the method. The former being roughly... def sup(index, *args) ... self.ancestors[index].send(method, *args) end Edit: the latter would just include something like ancestors_who_have_what_it_takes = self.ancestors.select {|x| x.respond_to?(method)}
Yeah I sent PMs to everyone so I'm hoping that they read the messages soon and hopefully they get on there soon. Its just a matter of time right now.
Just what iv'e been looking for, im interested as well
Im glad! I hope you find some use out of this, I'll PM you some additional information.
Interested in joining up with this as well. Novice rails/ruby dev here.
Sweet, I'm glad to have you! I'll PM you some details if you haven't joined the site yet.
Exactly &gt; I try to use modules rather than classes unless I actually need the stateliness that classes provide. &gt; classes are only initialized when state is needed I prefer to use "extend self" and mark all my private methods private. module Foo extend self def something_public ... end private def something_private ... end end This accomplishes the same thing as module_function, and forces me to keep my functions organized into public and private (top and bottom) on the screen. I also find it to be cleaner, without any decreased readability. Personal preference. **Edit:** Upon further research, module_function can be used in a similar way to private, where if used without any args then all following functions are made module functions. This would eliminate the need to use extend self. That said, I'm used to using private and having my public functions listed at the top of classes and modules (plus it's consistent between both classes and modules) so I think I'll stick with the above approach.
 [:first_name, :last_name, :gender].each do |method| attr_accessor method end Made me sad. Just use `attr_accessor *myarray`
Count me in as well. 
I'd love to join! 
I would like to join you fellas as well. I attempted to register on your forum, but there seemed to have been an error in the registration link. I will try again another time. *edit*: And its fixed, thanks for starting this!
I'm sorry about the delay I was trying to install a captcha that would filter out the spammers because I have had to delete many spammers in the last couple weeks. Also no problem, thanks for joining! 
I'll be interested, maybe we can make a project on Github?
Hahaha that's funny, but you're definitely welcomed! I don't mind who joins anyone with any kind if experienced is welcomed. Ill PM you some details.
Awesome, glad to have you! Ill pm you some details.
Would love to join. Count me in.
Could it be gets.chomp? This asks a user to input a certain value
Shit cray.
Interested!
Definitely interested. I am finally just understanding the magic of rails a bit more after going through the railstutorial for the second time, (I did rails 3.2 and then again when 4 came out). I have been using ruby passively for over a year as well. Further, I have experience with C. Please let me know more details!
Awesome! It would be great to have your experience, hopefully this would help expand on your skill with Rails. Ill PM you some details right now.
Not the first post about this same subject from this user.
Cool, I'm a senior in cyber school so I may not be very active but I'd definitely check out your project, I started reading that book, pretty cool stuff by the sounds of it. Now I'll just have to figure out how to do it on the Chromebook haha
I get an error of raw_vector_with: undefined method `alloc' for GSL::Vector:Class (NoMethodError) in reclassifier-0.4.11/lib/reclassifier/content_node.rb:33 when using Reclassifier::LSI from https://github.com/saveup/reclassifier Reclassifier::Bayes works fine, but it would be nice to have Reclassifier::LSI working too. This is useful for dealing with spam, reclassifying miscategorized content, and analyzing huge amounts of text. I have installed Ubuntu packages gsl-bin and libgsl0-dev and have installed version 1.15.3 of the gsl gem.
Well, that's way out of my comfort zone, but I'll take a look!
So, I'm quite confused: $GSL = true is at the top of lib/reclassifier/lsi.rb; but I see no other places it gets defined. That drives the invoking of those particular methods - perhaps it would be better if it was a test of some description. At least then, it would fail over to ruby code to execute... 
After reading through [the issues list for the original parent (or grandparent) project](https://github.com/cardmagic/classifier/issues), I concluded that the best solution is to use https://github.com/bmuller/ankusa instead of https://github.com/saveup/reclassifier Are you up for another one? This is a feature request rather than a bug fix, but I'll describe the problem anyway in case you're interested in looking at it. How about changing [ib-ruby](https://github.com/ib-ruby/ib-ruby) so that it doesn't conflict with Rails 4.0? It currently depends on activemodel 3.2, activesupport 3.2, etc. One way to do this would be to add a branch for Rails 4.0 support. However, not everyone using ib-ruby needs database storage. It would be convenient to have a version of ib-ruby that doesn't depend on activemodel, etc. at all. See https://github.com/ib-ruby/ib-ruby/issues/81 
Is there a reason you can't just use Ruby's sort algorithm?
Divide and conquer algorithms have the potential to be [multi-threaded](http://en.wikipedia.org/wiki/Quicksort#Parallelization). Edit: Ruby (MRI) isn't suited for multi-threaded environments. 
Your goals of learning and performance may be at odds, at least for now. It's great to know the quicksort algorithm, but Ruby is built so you don't have to.
thanks! this was helpful!
updated today!
MRI, the default Ruby interpreter, will not run threads in parallele (because of the GIL) making perf worst in the case. Use processes or switch to JRuby/Rubinius.
This is really bad advice. For one thing, MRI (the version of Ruby OP is almost certainly using) has a global interpreter lock, meaning that using multiple threads for CPU-bound work will give you no benefit. For another, Ruby's default `Array#sort` is implemented in C and pretty freaking fast. Surely faster than anything you can implement yourself in Ruby, which isn't exactly the fastest language in the world. Finally, writing your own algorithms in a language that has them built-in as part of its standard library is a very common source of bugs, even if you could somehow squeeze out a tiny bit of additional performance.
Apart from echo'ing the general rule never write a sort or an editor (as existing ones are always better)..... Looks to me if you can set i=p initially, you may scrape an occasional saving. def partition(a, p, r) x = a[r] i = p p.upto(r-1) do |j| if a[j] &lt;= x a[i], a[j] = a[j],a[i] i = i+1 end end a[i],a[r] = a[r],a[i] return i end I know earlier versions of ruby _didn't_ have tail call optimization but there certainly was a plan to have it eventually. Maybe they have it in ruby 2 latest... Either way this is more rubyish to me... class Array def qsort( lower=0, upper=size) return self if lower &gt;= upper mid = partition(a, lower, upper) qsort( lower, mid-1) qsort(a, mid+1, upper) end end ps: I haven't tested any of the above. Expect bugs.
ialso checked out rubyist.net and all I was able to do is confirm that ruby was installed. 
http://www.catb.org/esr/faqs/smart-questions.html
have you installed ruby yet? there's http://rubyinstaller.org/ for windows. you can check out their website and click on a download link. ruby is often started from a console or shell. the windows console on XP isn't that great and its use is rarely encouraged, so it isn't always familiar to windows users. you also have to change something called an environment variable that's named as %PATH% so that the shell is able to find ruby and start it. the ruby installer should take of care that for you(&amp; other common pain points you find on windows with ruby). i think it also lets you save .rb files on your desktop and double-click them to start or execute them with ruby. the documentation on rubyinstaller.org might help you as well. 
&gt;it never works Please elaborate. What input are you giving the computer, and what is the expected output?
1. go on a command line or terminal, type in &gt; ruby -v and hit enter. When it says "ruby 1.9.3" everything is good and proceed to step 2. 2. type in &gt; ruby -e"puts 'hello world'" if it prints "hello world" you have run your first Ruby code. Proceed to step 3 3. create a file `hello.rb` with an editor or by typing &gt; echo "puts 'hello world'" &gt; hello.rb in your command prompt and hit enter. you should be able to see this file when running &gt; type hello.rb now run the file with your Ruby interpreter and it should work &gt; ruby hello.rb If you still have problems try to make sense out of that given error message and google for that or ask here again and make sure to include that message.
There's also: * [Codecademy](http://www.codecademy.com/tracks/ruby) * [TryRuby.org](http://tryruby.org/levels/1/challenges/0) * And a number of similar sites which can be found in search engines (with terms like "learn ruby online" or "interactive ruby tutorial") Edit: TryRuby.org is also in the sidebar.
i saved it in rb and the path thing is covered. look at the imgur image I posted.
thank you for the link! I will try to be more clear next time.
yes I downloaded it from that website.
Why are you opening ruby with "rubyprogram&gt;". Just call ruby p001ruby.rb
I was trying to follow step by step to make it clear incase there were any mistakes.
That estate link appears to be empty. 
You're missing the closing ' after hello world.
http://www.rubyinside.com/a-minitestspec-tutorial-elegant-spec-style-testing-that-comes-with-ruby-5354.html This guide is pretty good. I would start with minitest (built-in to newer versions of Ruby) instead of something like rspec to minimize the number of external tools that you have to grok.
Codecademy may be frowned on by a lot of people in the Ruby community, but IMO it's a pretty decent place to start out. It covers a lot of the basics and throws you right into the code. Rather than reading 50 pages of instructions and personal summarization before you even see a line of code.
I usually prefer something like the 3rd, test all behaviors in the module, and then test the other constants include it, like in https://gist.github.com/rodrigues/9abc87ef86970c3d81b3
I am very impressed by your can-do attitude and I believe you have outlined (in your GitHub comments) a good way to refactor the code. Please let me know if you need any help testing your changes.
Whoops, sorry about that. Should work now.
&gt; Apart from echo'ing the general rule never write a sort or an editor (as existing ones are always better)..... Existing ones are always better, but new editors get the "10x hackers" over at Paul's place all wet and ready.
&gt; Ruby is built so you don't have to. No. You moron. Ruby is built so that you have to understand how it implements quicksort.
Sigh! I keep trying and trying new editors.... I keep going back to Emacs.
Question for you, Oren: I have an RESTful api that is dependent on a lot of SQL. How do I write effective, fast tests that test this external REST API?
Not a problem. If you are just learning to write algorithms and want to play around with different algorithms to learn how they work, then I'd suggest using JRuby and writing some of your own sorting classes. [This](http://www.sorting-algorithms.com/) is a good place to start.
Thank you so much! I saw `t.verbose = true` there. What does `verbose` do?
&gt;MiniTest provides a verbose output format with the --verbose (or -v) option. This will print each example with it's name and how long it took to run.
Hi Nitrodist, what do you mean when you say this REST API is "external"? 
I'd say 1) Move all your SQL into their own methods 2) Stub out these methods in your unit tests and fake their responses. Those tests will be fast. And should only test your non-SQL code. 3) To test your SQL, have a separate test (integration test) which ONLY tests those SQL methods and asserts the right data coming back from the DB. This test won't be as fast but hopefully you won't have to run it often unless you touch your SQL statements.
I use an in-memory instance of SQLite for some testing. Obviously this only works for the common subset of SQLite's SQL and the production DB's SQL. It is quite fast though. If the API is based on http/s you probably want to use vcr.
What I mean to say is that I maintain the external API. I don't directly consume the API, the clients do.
I was at the rails user group (or maybe it was agile methods - whatever) and there were half a dozen companies looking to hire ruby on rails people. The problem (IMO) is that they're looking to hire people with lots of experience in a fairly niche technology but don't want to pay what they're worth. I'll drop my job in an instant if somebody says "you don't have to deploy your software on Windows any more and you can write Ruby all day" (half my day is C), but not for a 50% pay-cut. The thing about people with a few years of ruby experience is that they were writing it 3 or 4 years ago -- possibly early enough that Rails hadn't made Ruby into the latest fad. Very few people picked up ruby in 2005 as a first language. Most people starting out, especially those looking to get a programming job pick one of the popular 'corporate' languages: java/php/c#. If you've got somebody who's experienced with ruby then there's a good chance they were already experienced with a few languages before they even started Ruby; certainly more so than a college grad with "3-years of java". They're not just programmers with 3 years of ruby experience, you're looking at programmers with 5 or 10 years experience, some of which happen to be ruby others are C, Pascal, Visual Basic, Haskelâ€¦ That's different from the recent college grad who may only be proficient in a couple of languages and so their 3 years of experience is just about all they've got. If you're trying to hire Ruby programmers with 5-10 years of experience but want to pay them like college-grads you're going to have a bad time. Combine that with a great contractor market and the problem is even worse. Why would I take a 9-5 job making $30/hr when I could contract for $75/hr and work pantsless in my livingroom? Maybe the market isn't so hot in other cities but here (calgary) I'd argue it's almost foolish to take a full time RoR job unless you're just getting started in your career. 
Who said anything about trying to hire Ruby devs with 5-10 years of experience? Your points are all valid, but this it about companies looking for juniors, and I'm pretty sure they'd learn more in a year on the job than during a comp sci degree (if programming for the web is what interests them).
I feel your pain in Southern California.
I know people making $75/hr as a full time rails dev. It's definitely on the high end, but not unheard of. I don't know anyone who is making $30/hr as a full time rails dev -- not even junior people.
The before/after picture isn't an improvement, IMO. The code is needlessly complicated. The dependency injection and implicit use of `.()` to invoke `#call` is confusing. I'd rather start with a controller test. If you're using fixtures then your data setup/teardown is already taken care of for you. The test speed is gated by how fast your database can rollback the transaction. Hint: it's pretty fast. Now you don't need to mock/double, which is a huge win for anyone reading or maintaining the test. You can have your controller assert the business objectives that you expect the controller method to carry out -- in this case, delivering an email and updating some attributes. Extracting service or command objects is a great pattern when you've got a complex operation you have to model. In your case, you've completely over designed the example code, and took a step back in terms of maintainability, value, and conciseness. When I build command objects, my world of objects built out by fixtures end up coming in really handy; I can test "outside only" instead of "outside in." If you really want to shave time off your tests, minitest can fire up much faster than rspec (last time I measured it was hundreds of milliseconds).
Please let me know how I could make things more clear or anything you'd like to see in following parts. Thanks!
I love ruby syntax but mri is ungodly slow, threads still don't have copy-on-write, etc. Use a lot more java/scala/jruby because of this. 
So by Ruby you're referring to MRI, right? All Ruby implementations offer the same concurrency models as the languages you mentioned, some just better/different than others. Ruby/MRI has async covered with EventMachine, among other reactor libs like Celluloid::IO. Ruby (Rubinius &amp; JRuby, specifically) have Celluloid, which gives a lot of the same niceties of Erlang. Go is fast and readable, but verbose beyond what I care to look at. All that error checking? Ruby has a great future because of implementations like Rubinius and JRuby. We live in a multi-core era, so implementations with real threading (read no GIL) will end up being the go-to implementations for the kinds of applications that need real threads. For client/server sharing code, check out Opal: http://opalrb.org/ Not exactly js on the client &amp; server, but neither is js on the client &amp; server.
Copy-on-write is a concern of processes, not threads. Ruby 2.0 has a (supposedly) CoW-friendly gc that you can read more about from Pat shaughnessy http://patshaughnessy.net/2012/3/23/why-you-should-be-excited-about-garbage-collection-in-ruby-2-0 Saying a language or implementation is "ungodly slow" is not saying much. Slow at what? MRI boots up faster than the JVM, so in that respect it's faster than all the JVM-hosted languages. Gotta be specific when speaking about speed.
Nope. Current RoR toolchain works just fine for us, and it's a pleasure to work in. Ruby the language is never going to be our bottleneck.
Ruby does have some big and ugly warts. Memory consumption, garbage collection, speed, startup time etc. Unless they address some of these things I think a lot of people will move on. 
... cough cough ... global interpreter lock .. cough...
This definitely works. I have done this at the last two companies (both RoR) I was at. Yes, it takes a bit more time in the short run but you can also develop much better talent in the long run. Plus, you don't lie to yourself about hiring a great software engineer off of the street (right now, this isn't possible unless you are paying way above market or you have a pre-existing relationship with them) There is still a bit of a hiring challenge, as you need to be able to find people who have no/little programming experience who are going to be good developers. If you can do this, and you have an approach to training people, you can get jr. developers that are able to solve bugs pretty quickly. You can train them in exactly your methodology. On exactly your technology. Plus, and this is key, you can hire people that fit in and complement your other team members. Plus, you end up with a some-what repeatable process for hiring software people (not just cross your fingers and pray). 
But then I'd have to use Rails, no?
Ruby is a great language with a great web ecosystem and innovation but with crap implementations, besides MRI, you have Rubinius forever and Jruby, which was humiliated by an intern from Oracle. As soon as developers can build web applications as fast as in Ruby, they will migrate, and fast! If you can build an app as fast as in Ruby but with much better performance, what route will you take? You are already seeing this happen with Go, nodejs, clojure, scala as their communities keep growing, Elixir is going in good direction, the Elixir team is already creating a sinatra like lib and DB drivers to attract developers faster. And yes, there's RoR, which is not that important as it used to be because of client side web applications, for writing web services you can throw out more than half of what RoR offers. But don't be to concern about languages, Ruby and JS (you already need to know JS) is a great combo, just create great things.
Yep, definitely Sinatra. The way you're trying now definitely isn't a 'first project'. In PHP I imagine you're used to just using GET and POST, sometimes interchangeably. In most Ruby-based frameworks, they use the four HTTP verbs GET, POST, PUT and DELETE to represent the four CRUD actions. Meaning in Sinatra you could define methods for the same page that recognise which action you're performing. You can also forget about Apache for now - Sinatra takes care of that too. It has a local testing server, and if you want to see it online you can just push to Heroku and use their free tier. You won't really do anything OOP in this case, I'd encourage learning plain Ruby, and not even worrying about how it fits into web development, at the same time. PM me if you have any questions, happy to help.
I've used mostly PHP for a big part of my dev. career, I know where you're coming from. One thing you have to keep in mind right now is that PHP was made from the ground-up with building web pages in mind, while ruby is a general-purpose language. Where PHP will gladly hide away some details of what's going on in an HTTP request, in Ruby you either do it manually (and by manually I mean actually getting the request, parsing it, then building a response and sending it), or you use one of the many available tools and frameworks (Sinatra, for example) that do the boring parts for you. While I really recommend Sinatra for this project of yours, if you want to get a bit lower level without totally reinventing the wheel, you can build a Rack app - Rack is a minimal interface for building web applications in ruby that takes care of the bare minimums. You can learn more about it here: http://rubylearning.com/blog/a-quick-introduction-to-rack/
Gotta say, Elixir's `Enum.each(["Joe", "Matz", "Jose"], fn (name) -&gt; IO.puts(name) end)` when compared to Ruby's `["Joe", "Matz", "jose"].each { |v| puts v }` is kind of verbose and nasty. Even in Haskell, it's much, much nicer: `forM_ ["Joe", "Matz", "Jose"] putStrLn`
I always choose a programming language based on popularity, not suitability to the problem domain.
I'll preface this by saying I don't know much about the languages you've listed. I started out as a java developer and know I am a Ruby on Rails developer. While Ruby is a much more pleasurable coding experience than Java, it is not the reason I prefer Ruby on rails to Java. Ruby has far more useful tools and libraries out there than Java or any other language that I've seen. I cant remember the last time I started to do an API integration and didn't find a Ruby gem that was usable or at least helped me get on the right path. I like Ruby on Rails because of all the code that is already written for it. Though avoiding all that XML and annotation nonsense is pretty nice. I'm sure the languages you listed are nice (the most fun I've ever had is with Lisp) but is rather work with proven and widely used stack than something that has yet to emerge as a contender.
I'll be looking into those languages to maybe, *maybe* consider for some future projects. But I'm certainly not planning on migrating any of my current (live, large) projects over - [migrating a project to a new technology is a bad idea](http://www.joelonsoftware.com/articles/fog0000000069.html); a sentiment that's as true today as it was 13 years ago, when that article was written.
Some of these are quite young as well. I didn't really start learning rails or ruby for that matter until 2.3 was out. It wasn't that I waited or anything, it was when I discovered it. But trying to use one of these languages without a strong toolchain can be kinda tricky. Many of our team members have been investigating Go-lang because we're using http://www.packer.io/ which is written in it. I dont know if we'll use Go for any client projects or not, but I guess time will tell. I still really like ruby, but again it all comes down to the problem you have to solve. For the smaller sized web apps we're building, ruby works great. I myself though have been using more javascript lately for making small games. I've been looking at C++ a bit as well, and have done them using Java as well.
That the obvious way of doing things would often be the best. 9 times out of 10 I find that when I'm trying to crack a problem just hashing out what I intuit will be the solution just works. It's only afterwards I get why, after thinking it through. Many language try to be clever - Ruby tries to be nice.
The Ruby community seems to have always been happy to test. Maybe it grew up in the light of TDD / BDD (when both were becoming popular). Or maybe tools like RSpec, Cucumber and the like just made it so damn easier to write test code. In any case, writing tests seems to be part of the Ruby / Rails DNA.
I am moving my new project over to Node.js (coding hasnt started yet). The "one language to rule them all" for Node.js makes future maintenance easier.
Ruby solves a lot of problems for me. I know it well enough that I can sit and whip out a quick script to handle some tasks that need handling without too much searching or reference manual digging. No, I am not migrating from Ruby. Would I love to learn Go or Node? Sure. They are probably the right tools for some problems I don't have now, and I have made a happy career of being a generalist instead of a specialist. But no, I don't feel a need to go learn them with urgency and start using them where I may use Ruby today. 
Ahhh nothing like a novice developer rant filled with logical fallacies to start your day.
&gt; but new alternatives are more and more popular you are doing it wrong.
$75/hr is not high end Rails, $125 - $150 is high end and yes Experienced Rails devs make that.
No-one mentioned Why's Poignant Guide to Ruby? Surely a must-read for newbie Ruby coders and surrealists everywhere :) http://mislav.uniqpath.com/poignant-guide/
Yup! Lot of familiar syntax. There are a couple little gotchas with parens though. See https://github.com/drumsrgr8forn8/elixir_style_guide#syntax
Good stuff, thanks for sharing! Nice touches with turbolinks fixes and using PATCH. 
Elixir is definitely an exciting language. I tried getting my head around Erlang, but it often feels like the language has been written to be obtuse. Elixir is a order of magnitude more readable - plus all the Erlang OTP goodness. Woot! Thanks for the post - will be following the series.
Misspoke sorry. So the issue ive had with mri (and it wasn't fixed in 2.0) is the os won't reclaim memory from threads (the interpreter process will just continue to grow, though it will reuse thread local memory after the tread is done) but because of copy on write for processes they are very heavy weight when you have a largish app (or data in memory, etc). Jruby fixes the first issue, not sure about the second. Again i love ruby syntax and use it now where i would have used bash and/or perl in the past. I also wrote a lightweight ruby framework for doing distributed computing on aws simple workflow ( http://change.github.io/aws-swf/) but there it's a controller/workflow language that then calls out to python/c/r to do some number crunching. 
Edit to clarify ungodly slow is with e.g. array mapping over large in memory data sets, MRI is significantly outperformed by cpython, pypy, and stuff on the jvm. And cow was not fixed in mri 2.
Go for long running backend services. Ruby-RoR still for the web and for the foreseeable future.
Prefer to build up command queues ([command pattern](http://en.wikipedia.org/wiki/Command_pattern)). This is pretty close, the major difference being instead of just passing in the object reference to a command stack, you also give some indication of the method you want to call on the object and any additional messages you want to pass. This gives you an extra measure of control over what occurs in your composites. 
You are in the wrong directory. use the command `cd` to change the directory to the path from the first screenshot where your file is actually located
Ruby 2.0 *is* copy on write friendly.
Your are correct, but out of context. The parent was claiming that full time (e.g. salaried) rails devs are making $30/hr. That comes out to ~$60,000/year. What I was saying is that an experienced full time rails developer is making over twice that. Freelancers are rarely in the market for gigs that are supplying 2000 hours in a given year. Likewise, only a very, very experienced freelancer, with a well known personal branding (or agency), is going to be able to book anywhere close to 2,000 hours per year.
I love the [Rspec Book](http://pragprog.com/book/achbd/the-rspec-book) it's not free, but it's fantastic.
 [1] pry(main)&gt; method(:puts).class =&gt; Method it's a little round-about compared to something like JavaScript, since you're passing a symbol to get a reference, but there is a built-in class for them at least.
The thing I wonder most about when doing a javascript front-end is how to handle nested attributes, rails expects them to be in a `foo_params` field while most clients just have a `foo: {}` attribute. I know that in most cases you'd just update that particular `foo` object on you `FoosController`, but there might be some valid cases where you'd want to use nested attributes.
I evangelized Ruby back in 2005 when Rails came out because it was unknown, but now that it's crossed the chasm, I don't bother to care about what other people use and I leave each to their own to figure out what language they like. I know what works for me.
Be warned: I think multiple calls to [angular.bootstrap](http://docs.angularjs.org/api/angular.bootstrap) is a bad idea (as it's an initialization call). More over using turbolinks with AngularJS is weird, if anything there should be a service inside angular to deal with such functionality.
[methods are not objects](http://www.reddit.com/r/ruby/comments/1mqngh/is_ruby_just_not_for_me/ccbzfi9) :)
Point them to this: [Why is configuration management software written in Ruby?](http://rcrowley.org/talks/ruby-on-ales-2011/#1) You could also mention Ruby on Rails. It's possible that node.js-based frameworks like Sails.js might supersede Rails in the future, but my personal belief is that while this might happen to some extent, node.js-based frameworks probably won't completely supplant Rails because 1) while the asynchronous model offers performance advantages, the "callback hell" problem can slow down development and make it more difficult to find developers who are proficient with the technology stack and 2) the node.js ecosystem currently lags far behind the Ruby ecosystem, though it might catch up someday. For an example of this, see http://stackoverflow.com/questions/17683015/how-to-perform-sql-joins-in-sails-js-waterline I think GitHub has the right idea: build the main site with Ruby on Rails, then [use node.js to address particular issues](https://github.com/blog/678-meet-nodeload-the-new-download-server), just as one might rewrite performance-critical modules in C.
Yes
This code can be written as Enum.each [..], &amp;IO.puts(&amp;1) which I definitely prefer :) I wrote another blog post some weeks ago with similar content: http://victorarias.com.br/2013/09/15/starting-with-elixir.html I think it's also a good source for "newbie Elixir programmers" :) (I'm also a rubyist, so my vision is obviously similar)
Does elixir provide nice syntax for partial application?
[And why some are moving to erlang ;)](http://www.opscode.com/blog/2013/02/15/the-making-of-erchef-the-chef-11-server/)
&gt; Now I just use Ruby by itself for web sites Like this? http://stackoverflow.com/questions/5664553/making-a-web-page-with-ruby-without-rails I can understand the appeal of this approach. Sometimes, I just want a simple webpage that executes a few database queries and I want to write raw SQL instead of using an ORM. Actually, I normally use PHP for this.
This is really just about how to stop people from annoying you with their superiority complexes. All you have to do is tell them you don't value their uninformed and unsolicited opinions. It's the only response you need. Every retort they make relies upon the notion that you give a fuck.
I see. Loads of things to learn but w/e, I got the time. Thanks! Will PM sooner or later ;)
2.0.0 has a better garbage collector and improved startup times. Additionally, there's some new syntax which new gems are starting to expect. 2.1 will be out soon, so you're a little behind the curve in adopting 2.0.
This is the correct answer. OP, you need to learn to just not give a fuck.
You say that like it's a bad thing
This is the brief version of the errata to Ruby's slogan, "Everything in Ruby is an object." There is other stuff in Ruby that isn't an object, but these are the most interesting/important ones. Every expression or statement evaluates to an object, though. `def` returns `nil`, but in 2.1 it will return a `Symbol` named after the method that was defined.
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: http://www.reddit.com/r/Serendipity/comments/1nk038/coffee_and_the_composite_pattern_xpost_from_rruby/
what advantage is gained by using classes rather then functions here? Seems like using a hash or module as namespace would be cleaner?
I will really never understand the compulsion to build DSLs for Regex. Essentially you're abstracting it out to the point where you actually lose a whole lot of functionality. How can I do assertions with this? How about lookbehind matching? How do I assign capture groups? How about non-capturing grouping? "Write once, read never" only applies to writing sloppy Regex. A good programmer will treat a complicated Regex like any other programming problem - he'll break it down in to smaller parts, build them individually and then string them together as required. If it's still unclear, you can even put comments in to your Regex. Regex really isn't that hard to understand if you're willing to spend a little time reading the documentation.
I was talking about nested json resources and their serialization specifically, rails handles this differently from angular from what I've seen. Edit to clarify: When POSTing or PUTting some object that has a nested resource, angular would do this: POST /foo foo { fizz: 1, buzz: "buzzzzzz", bar: { id: 234, baz: "bazzz" } } while rails expects this to be: POST /foo foo { fizz: 1, buzz: "buzzzzzz", bar_attributes: { id: 234, baz: "bazzz" } } in order to let you set that `foo's` `bar` by using `accepts_nested_attributes_for`
Yes, you can always disable turbolinks. But if you want to make it work (like in a situation that you have many small SPAs, each on a different page) manually calling bootstrap is the way to go. That of course means you have to take extra care to avoid memory leaks, as in all cases where turbolinks are used.
As someone just getting started with Ruby, why would the community frown upon Code Academy?
It's a hard call to make. Depending on what libraries you end up using you may be stuck with an older version. There's so much goodness coming in the 2.x line it's hard not to say just go with 2.0, but I have seen projects stuck on older versions because the gems they relied on also required older Ruby. But generally, yes.. go with 2.0 
What was up with the last slide in the Tmux presentation?
&gt; Jruby, which was humiliated by an intern from Oracle Not sure what you're referring to here?
Thanks for sharing. Wish I could double upvote this.
Isn't that kind of like saying why have a real language for programming when you can just use hex?
Why?
No. It's not.
Why not? I get it if this particular DSL does not handle full regex functionality, but if this were complete would it not be a better alternative? It would document the rules of the regex with readable code which is always better than writing out the perfect regex and then explaining what it does in text since the two are not linked to each other.
[http://medianetwork.oracle.com/video/player/2623645003001](http://medianetwork.oracle.com/video/player/2623645003001)
In &lt;=2.0, `fire` evaluates to `nil` because the last statement in it evaluates to `nil`, not because `def` returns `nil`. `def` isn't re-evaluated every time a method is called. # 2.0 def fire :smoke end #=&gt;nil fire #=&gt;:smoke # 2.1 def fire :smoke end #=&gt;:fire fire #=&gt;:smoke 
Please don't monkeypatch base classes, ever.
I didn't mean to; I would love that.
Because Rails throws this exception anyway it is a nice way of handling the notfound errors. Of course you can do a find_by_id and checking for nil too. Maybe you meant a site like http://rails-bestpractices.com/ ?
Or use gems that do? Like shoulda? 
In regards to that tmux slide - i DO map to ctrl-a - granted I also swap caps lock and control on my keyboard for convenience - doing this has only made me 10 times more productive - granted it sucks going to a computer without those keys swapped but it isn't that bad really - and obviously most people don't have tmux installed and your exact tmux conf file so you are going to feel lost regardless
Not sure how "void" applies to Ruby. The only method that will return `nil` implicitly is an empty method. Any other method which doesn't reach an explicit return will use as its return value the value of the last statement. You used a statement like `if false` ... `end`, which evaluates to `nil`, so that's what your method returns.
if the libraries are designed to be used in testing/development only, it's not so bad if they monkeypatch.
So it's "Please don't monkeypatch base classes, ever, unless your library is designed to be used in testing/development only"? What about 10.days.from_now in Rails? 
Pretty much what @afreida1 said in their comment!
My personal issue is that I'm not writing complicated pattern matching every day. I retain the basics (using it in Vim finds) but I literally always have to grab regex documentation to understand what something mildly complicated is really doing. Then I go 3 months without touching a complicated regex again and forgot anything I learned. A comprehensive DSL would make revisiting code a whole lot easier. 
Topical for me, I was looking at ways to do this yesterday(you can also do an around_filter with a yield, though that seems utterly pointless to me. Typo in the article, you have rescue_from ActiveRecord::RecordNot**f**ound, with: not_found in the code. The f needs to be capitalized. I like catching the errors more than checking for nil, since it feels like it more clearly reflects what's going on in the code. It also keeps the Show action nice and small. 
Thanks! I corrected it.
It's true that the DSL doesn't include those features (yet!). However, Regularity objects can be converted into regular regexes, so it's all stil there. I think something like this shines for simpler use cases where you don't want to mentally break it apart and piece it together or pore over documentation, especially if you're inexperienced with regexes, or just want a quick input validation, etc.
 wow please quite dont wow so much monkeypatch master base wow so classes such ever 
DRY. `rescue_from` gives you one place to define what happens when records are missing, rather than having to handle it every time you do a find. Of course, you can also do something like record = Model.find_by_id(params[:id]) return not_found unless record But that gets tedious doing it in every finder. Just throw rescue_from in your ApplicationController and call it a day. I do something like this: rescues = { :missing =&gt; [ MongoMapper::DocumentNotFound, AbstractController::ActionNotFound, ActionController::RoutingError, ActionController::MethodNotAllowed, ActionController::UnknownHttpMethod ], :denied =&gt; [ Canable::Transgression, Authentication::AccessDeniedException, ActionController::InvalidAuthenticityToken ], :bad_request =&gt; [ MissingParameterException, BadParameterEncodingException, ActionController::UnknownHttpMethod ] } rescue_from *rescues[:missing] do |exception| # Setup and render my 404 page in HTML and JSON formats end rescue_from *rescues[:denied] do |exception| # Setup and render my 401 page in HTML and JSON formats end rescue_from *rescues[:bad_request] do |exception| # Setup and render my 400 page in HTML and JSON formats end This gives me a one-stop shop for handling what happens when something unexpected happens that would otherwise result in a 500 error message for my users. Works great. Using this technique doesn't prevent you from handling things on a case-by-case basis in your actions; you can still use your find_by_id, or find and rescue in your controller if you want. This just gives you a catch-all for the things that get through the cracks (the vast majority of which originate from security scanners throwing malformed data at your site to try to break it, IME.)
What do people think about verbose regular expressions? like those in "Dive Into Python", http://www.diveinto.org/python3/regular-expressions.html.
That's slick. Adding to my toolbelt.
thought so, same boat!
My guess would be that the implicit parameter braces isn't quite working here: If passlength.is_a? Integer == false Integer == false is probably being passed in as an expression, which is evaluating to false, and false is not a class or module, which it wants. Try If passlength.is_a?(Integer) == false Or unless passlength.is_a?(Integer)
This line: if passlength.is_a? Integer == false Is interpreted by Ruby as: if passlength.is_a?(Integer == false) The `Integer == false` is pretty nonsensical, comparing a class to a boolean. It returns `false`. So in effect your code ends up doing: if passlength.is_a?(false) That's why you get an error from `is_a?` complaining because it didn't receive a class or module argument (it got `false` instead). So, what you need to write instead is this: if passlength.is_a?(Integer) == false Always be careful about ambiguous syntax like that. Further, there's a better way to write this without using `== false`: if not passlength.is_a? Integer Ruby has a special keyword for `if not`... you'll see this more often in my experience: unless passlength.is_a? Integer And note that in these last two, parentheses aren't a problem any more, since `== false` is gone.
Wow I feel really stupid. I remember working with unless all the time, thanks for letting me know. Baby steps at its finest. 
proc is `Kernel#proc`.
Or: `if ! passlength.is_a?(Integer)` Better would be to use the coercive method `Integer()` instead. It raises an `ArgumentError` if the value is not an integer. e.g. `"t3"` is not accepted, unlike `.to_i` which would return `3`. Yes, it's a weird name (it starts with a capital letter but is a method, not a constant). Your code would be like: password_length = nil while password_length.nil? puts "How long would you like your password to be? " begin password_length = Integer(gets.chomp) rescue ArgumentError =&gt; err puts "Please try again with a number. #{err}" end end There are several of these coercive methods: `String`, `Array`, etc. They are useful when you want to be sure what you're using can really be of that type. Ciao!
The way I usually do this in Ruby is via composition. Make partial regexes then combine them together. type_1 = /\d{3}[+-]\d{4}/ type_2 = /[a-zA-Z]{5}/ identifier = /#{type_1}|#{type_2}/ It lets you give meaningful names to each part of a potentially complicated regex.
Isn't the problem 3 lines from the bottom? You are calling a method that as far as I know, doesn't exist: I'm assuming you meant to call: `is_a?` on your password_a array instead of `to_a?`, right?
That "I feel stupid" feeling never goes away. I do this stuff professionally, and still feel that way constantly. Learn to embrace that feeling and understand that it's really the feeling of learning, and finding better ways to solve things. You're not stupid, you asked a question here which lead to you finding a better solution. Nice work.
Ps it's called predicate methods
I haven't lived anywhere else to compare, but it is pretty healthy, plenty of open jobs most of the time and the community is a friendly one.
Comments like this make me feel better about humanity.
Just a small way to make charecterchooser a bit shorter: def charecterchooser(n) return (n+64).chr if (1..26).cover? n return n - 26 if (1..35).cover? n nil end Edit: Maybe this is more clear: def charecterchooser(n) case n when (1..26) then (n+64).chr when (1..35) then n - 26 else nil end end The logic is exactly the same but it uses the case-statement instead of 2 if-statements.
Could you please explain how this works? I'm really new to ruby and I like the idea, I would just like to understand it. 
Thank you. 
 def charecterchooser(n) This defines a function (a method) called charecterchooser which expects a parameter which will be assigned to n return (n+64).chr if (1..26).cover? n 1..26 creates an array that contains 1,2,3,4 through to 26 .cover? is a method on that array what will return true or false if the number n passes to it is within that array so return (1..26).cover? 10 would return true return (n+64).chr the chr method works on a number and returns an character for that number - ascii encoding. seeL http://ruby-doc.org/core-2.0.0/Integer.html#method-i-chr That encoding starts with 65 as A and 66 as B etc so it will return A if n=1 in the above so return (n+64).chr if (1..26).cover? n means it will return a char for your number n if the number is between 1 and 26. if n is not between 1 and 26 then it will return false and goto the next line. It could have been written like this: if (1..26).cover? n return (n+26).chr end puts "this will not get printed if n is between 1 and 26" the next line is return n - 26 if (1..35).cover? n this is much the same as the line before but checking for a number between 1 and 35 (really only should check from 27-35, because the before would have returned if it was less than 27) and returning the number represented by the number passed n the final line is nil which is the same as if you wrote return nil but ruby returns the result of the last statement without needing the return keyword. it would only return nil if the 2 lines above did not meet their if conditions and did not return from the function earlier. a long winded but clearer way to write this example could have been: def characterchooser(n) if n &lt;= 26 &amp;&amp; n &gt;= 1 return (n+26).chr end if n &lt;= 35 &amp;&amp; n &gt;= 1 return n - 26 end return nil end 
Thank you, very good explanation. Just to get thing correct (1..26) is not an array but a range.
I am really bored at work so i wrote the same program the way I would do it. You know what it does so I hope you should be able to figure it out. puts "How long would you like your password to be?" passlength = gets.chomp while passlength[/\D/] # (Regexp that says: while passlength contains a non-digit) puts "Please only input a number for this to work!" passlength = gets.chomp end # easy way to se what chr-method maps to: # puts (1..200).map{|num| "#{num}: #{num.chr}"} numbers, lower, upper = [*48..57], [*65..90], [*100..122] characters_in_password = numbers + lower + upper password = '' passlength.to_i.times do password &lt;&lt; characters_in_password.sample.chr end puts "Your new random password is #{password}" 
Your definition of "humiliated" is very different to mine.
ahh yes a range!
&gt; Would conferences benefit Novices/Intermediates? You will be exposed to a ton of ideas. Maybe, 1% will be useful to you. You will have to be an extravert for a few hours. Meaning you will have to initiate conversations, and meet people. Try to eat lunch with a group, ask people about their experiences, projects, hobbies, work, etc. Everyone likes talking about themselves, few like to listen. be the one that listens and you will build your network. If you are invited somewhere with a group, go. If they want to play cards, play. Doesn't matter. If you are looking to find mentors, you have to be around them. You have leave the conference and have left an impression on the people. Oh.. it is going to sound cruel and mean, but don't waste time with people who are not helping you succeed. Be polite and walk away. &gt; What kind of expectations should one have? Honestly. None. If you have a expectation you will be looking to full fill that expectation and ignore the rest. &gt; Is it worth taking time off + paying for it on my own dime? Sometimes. You won't know until you go and come back. I &gt; Are there any thoughts/concerns I should have? Have a goal. "I want to find a mentor who knows database design" or "I want to just go and absorb everything" &gt; How could I make the most of it? Participate. If they have a lighting talk session, give one. That's all i got to say about that...
What's with the name?
It's like FTP with RoundRects and monthly subscriptions. I don't get it.
Ruby conferences come in a variety of shapes, colors, and sizes. Some focus heavily on technical ("hard") aspects and others feature many interpersonal ("soft") talks. If you want to see how amazing (yeah, a little biased here) the Ruby community is, find a conf that features soft talks. If you want to immerse yourself in code, find one that steers towards hard talks. Reading the talk abstracts should give you clues. Some conferences are huge. RailsConf, for example, has gotten as big as 2,000 people. Other, usually regional, conferences stay around the 75â€“250 mark. If you want to find a mentor, it tends to be easier at the smaller ones, I think. The big thing is to make sure you proactively try to meet people. It's a very friendly environment. Like any community, however, it might be good to observe the norms amongst your co-conference-goers before jumping in and making a splash. Whether it's "worth it or not" is entirely up to your financial situation. If you're strapped for cash, you'd be putting a lot of money on an unfamiliar thing. I mean, depending on the conference, it doesn't have to cost a lot... frequently the biggest cost is either opportunity cost (taking vacation, etc) or lodging/travel. Honestly, the first thing I'd do is jump onto twitter and start asking people in the Ruby community. You'll get lots of opinions there. :)
Regarding 4, DSLs... Does this mean you're anti-RSpec?
&gt;do not make "magic" You mean, like rails?
while I agree in general, I find Sinatra (and rspec to a lesser extent) very nice DSLs to work with edit: to clarify... I agree with not creating DSLs when ruby alone will be sufficiently clear
&gt; remember: ruby is not rails, ruby is much more than rails true. &gt; remember: rails is not ruby, ruby is much better than rails one is a web framework, the other is a language. Saying one is better or worse than the other doesn't make sense, since they are two different things. &gt; do not make "magic", it may look awesome to you, but no one else will understand, and it will cause confusion and frustration blanket statement. Where does magic start? Is having modules of functionality and including it in a class magic? Is auto resolution of names (ie. I have a `rowset` xml tag, is it magic to find a class with that name and instantiate it?) magic? Yes, meta programming can be confusing, but only if you do it because you want to do meta programming. &gt; do not make DSL, your domain specific language will suck, ruby is expressive enough, try to stick with it Is the following already too much for you? How would you do it without having something dsl-like: get '/' do render :text =&gt; 'hello' end Together with 3, it's just personal opinion. &gt; do not modify $LOAD_PATH ($:), it is cluttered enough by rubygems bundler, rvm and rubyenv, do not make things worse &gt; do not use eval, eval is evil Agreed. &gt; if you publish a gem, do not modify your API, if you absolutely must, then increment major version number http://semver.org/
To be honest i was a bit harsh, of course DSL-s can help, no sinatra developer will read my post and rewrite all code without DSL. But if you are in doubt, just do not do it.
I disagree with #3 completely. Metaprogramming is an important tool for every serious programmer's belt. You should obviously only use it when it makes sense, and you should go out of your way to make it readable.
&gt; Is the following already too much for you? How would you do it &gt; without having something dsl-like: get '/' do render :text =&gt; 'hello' end &gt; sinatra.add_path :get, '/' do render :text =&gt; 'hello' end 
I feel like the definition of DSL has been stretched to include any library that defines class methods. Sinatra isn't a DSL. It's a micro framework. Back in the day, DSLs in ruby were made using tools like treetop. You actually define real syntax. They were cool. The ones that just liberally contort ruby's syntax to appear like english are the problem.
agreed. an example that comes to mind is rspec's should operators. I always forget that while should == thing is valid should != thing is not valid, as rspec demands should_not == thing I dislike this a lot and would prefer to always use standard ruby operators for test assertions
Rails isn't really "magic" once you've used it for long enough.
Learning Ruby outside of Rails has made me a better Rails programmer. I built a popular RubyMotion gem (ProMotion) and went through a few stages of frustration, enlightenment, and eventually enjoyment. Switching back to Rails, I now find myself doing things in a more "Ruby" way and not leaning on the ActiveSupport crutch. Don't get me wrong: I love well-written DSLs (ProMotion is a joy to work with, in my opinion). But, as with anything, the truth is somewhere in the middle -- you need to understand the underlying language and APIs before DSLs will truly be helpful. 
So what do you achieve here? Now you have to remember more things (add_path, and that the 2nd argument is the method of the request and 3rd is the path).
I've used Rails long enough and it stills feels like a "magical" box of over-abstractions.
That's cute. I know of http://exercism.io but it's not timed. Building this in Ruby would be interesting, given that you have to evaluate user-entered code.
While not the same concept, I did enjoy http://railsforzombies.org/ for its uniqueness in delivery. 
Awesome, thanks 
Awesome, deffo, always interested to learn as much as I can. 
What is MUD?
Awesome, I'll add this to my to do list :)
[Setting up Rakefile for TDD](http://www.pilanites.com/?p=320). :)
Oh.. Something like Ruby Warrior for console. Or probably Ruby Warrior was MUD played by writing code.
Just my 2c. I just went to GoGaRuco weekend before last. This was my first Ruby conference and it was amazing. I went to Google I/O the first two years. I enjoyed I/O in general, but having 4000 (give or take) developers in one spot wasn't very enjoyable to me. I never got to see the same person twice, so the chance of me actually getting to follow up with the people I met wasn't as high as when I went to GoGaRuco. At GoGaRuco I got to meet a lot of great people that I look up to in the Ruby scene. My company will pay for conferences, but my boss was out on vacation when I got my tickets. I paid for everything out of pocket and I can tell you it was 100% worth it. Every night including the pre-party night I was getting drunk with fellow developers and it was fucking awesome. I walked away with at least 10 new friendships that I can honestly say I'll stay in touch with. This is compared to the 0 from Google I/O. Big conferences are still fun, I just think the smaller ones are much better to meet people at. I would recommend the smaller conferences over the larger ones to meet people. Be very outgoing and interactive. Most talks are all recorded and put up on Confreaks or their own sites. You go for the networking, for sure.
Thanks, I've just set myself the challenge of 100 blog posts in 100 days for my website so I may think of creating something which would speed up this process. 
You could try making a static site generator. Big ones in the ruby world are [jekyll](http://jekyllrb.com) and [nanoc](http://nanoc.ws/). You could try creating one that makes your workflow the fastest.
that's disgusting!
and then invite your friends to hack/subvert your service. Not only will it be fun, but will also provide useful programming lessons.
Ahh.. awesome. Haven't played with this yet, but the amount of times I have to dummy up client code to test APIs (just to throw it away again). This could be a huge boon. 
I've been using codewars.io recently
I can't tell you how excited I am for this.
Yes! I'm fairly new to Ruby. Is there a significant performance difference between MRI and Rubinius? Most of the info I've seen is very dated, comparing MRI 1.8 to Rubinius.
I would like to know too, please.
Can anyone briefly explain what Rubinius to a Ruby novice?
It's an alternate implementation of Ruby with a focus on threading processes across multiple cores. 
It's an implementation of Ruby. Key differences with MRI: * Uses a JIT compiler to convert Ruby to machine code on-the-fly. MRI uses a simpler bytecode interpreter with less scope for high performance. * Has an accurate, generational (objects split into smaller groups by age, each GC'd independently), partially concurrent garbage collector. MRI has a more naive conservative garbage collector that has to make educated guesses as to what objects are still alive and has to scan everything each run (2.1's improving this a bit). * Has much of the core written in pure Ruby, as opposed to C, using the JIT to help offset the performance difference. * Uses fine-grained locking that allows for multiple Ruby threads to run concurrently on multiple CPUs - MRI has a big giant lock around the interpreter preventing this.
The article details a lot of the differences about 2/3rds the way down, but the highlights are these: # Rubinius _is_ ruby The Standard library is written in ruby, the core library is ruby, basically everything but the VM is ruby, and ruby is used to compile ruby to the VM's bytecode. That makes Rubinius supremely hackable. You don't need to know anything about C, the VM, or compilers to know how to hack Rubinius. If you find a problem, _you_ can look at the code that causes it, _you_ can write tests to replicate it, _you_ can fix it, and _it's all ruby, all the way_. # Rubinius is tested. Brian Shirai is the maintainer and founder of the RubySpec project, which aims to spec ruby in ruby, using an Rspec-like syntax with some additional tweaks to make testing across versions a bit easier. This gives two big benefits. Firstly, you can know the Rubinius is doing what it claims to -- because it passes the RubySpec. Secondly, you can know what Rubinius claims to do, because you have it's spec right there, and it's executable. AFAIK, virtually every alternative distribution uses rubyspec heavily to drive their development. MRI does not, but by virtue of it being the system-from-which-the-semantics-are-derived, it should also pass the RubySpec, but because they don't drive their development with it, it's less useful (ie, it doesn't provide those same benefits). # Rubinius is Fast Rubinius uses a modern, generational, concurrent GC. It uses a JIT compiler for your code. It has no GIL (which allows for 'true' parallelism). It will probably not show up as being faster when running, eg, your test suites (neither will JRuby), but that has to do with the fact that test-suites don't give time for the JIT to get warmed up. On long-running apps, the performance/memory gains will be noticeable. # Rubinius is friendly Not only does it have (IMO) nicer error traces, but it also has some of the most awesome people working on it. Brian Shirai and Dirkjan Bussink (brixen and dbussink, resp. on IRC and Twitter), are the main developers you'll run into day-to-day, and they're absolutely some of the most helpful, hardworking folks I've talked to. Seriously, go hang out on IRC with them, you'll learn stuff (if only by proximity). -------------------------------- So, basically, Use Rubinius. If you're wondering how, it's pretty easy to install with rvm, ruby-build, ruby-install, whatever. One of the simplest things you can do to help is just add Rubinius to your CI runs, and report inconsistencies that pop up between MRI and Rubinius. Though, as of this article, Rubinius isn't aiming to maintain feature parity (eg, no refinements, more concurrency stuff), it still (afaik) tries to maintain semantic parity (eg, weird semantic corners of the language should still work basically the same way). Just _using_ rubinius will help make it better, the barrier to entry is basically nonexistent, and stepping through means you can start playing with really cool things -- like [Celluloid](http://celluloid.io) or [Artoo](http://artoo.io) [1] -- in an environment that can bring out their full potential. Whenever I start a new project, or come back to an old one, I start by making sure it runs on Rubinius. I've made it my default ruby, and I think more people should, because it's a ruby that I know I can understand if I need to, and can help fix if I have to. You should use Rubinius as your default too, you should try it, then tell your friends and coworkers to try it, you should tell your mom to try it, you should try it in your house, you should try it with a mouse. Use Rubinius, use Ruby. &lt;/elevatorpitch&gt; [1] Both bascule/tarcieri and deadprogram hang out in IRC, I know bascule haunts these hallowed halls, they're the authors (resp) of Celluloid and Artoo, which are two of the coolest projects around.
[I did up here](http://www.reddit.com/r/ruby/comments/1nrsow/rubinius_20_released/cclkev6), and Freeky below covered it, though more concisely.
I don't swap caps with ctrl, and I still don't see the problem. \^A's easier to reach than \^B either way.
Mad props, thank you. I'm in the beginning stages of learning Ruby and anything visual helps a great deal!
Nice, but you're not including singleton classes (these complicate things quite significantly) :)
I'll defer to /u/jfredett's [elevator pitch](http://www.reddit.com/r/ruby/comments/1nrsow/rubinius_20_released/cclkev6) as to what Rubinius is. What really excites me about this release is its MRI compatibility version (2.0/2.1) and its new release process (towards the top of the link). I loved the features and architecture of rbx (Rubinius) when I first discovered it several years ago, but I was using MRI 1.9 (6 years old now) and rbx didn't have a comparable release. Indeed, as /u/redwall_hp [notes](http://www.reddit.com/r/ruby/comments/1nrsow/rubinius_20_released/ccliean), there aren't many recent benchmarks of rbx against MRI because rbx never had a 1.9-compatible release. rbx2.0.0-dev could be built into 1.8 or 1.9, but that's not exactly a promise to support 1.9. JRuby only released 1.9 support a year ago, and since it's gotten a lot of attention and press largely because of its benchmarks. When I moved over to MRI 2.0, I was saddened at my ability to use alternative implementations being deferred even further. Now I have options! Beyond the version number, though, the release process is particularly promising. These alternative implementations have played a huge role recently in revitalizing, optimizing, standardizing, and maturing the Ruby project. In an breathtakingly short span they've evolved from experimental, to influential, to viable, and now to maintained. They herald a brave new world in the Ruby programming language, with new applications and new frontiers. They may not be wholesale the future of the language, but they are essential to keeping the language relevant and evolving. The last 5 years of being a Ruby developer may have been heady, but the next 5-year-era will be exhilarating! tldr; So yeah, pretty excited I guess.
Glad you enjoyed it, what were the fallacies exactly? :D
Something like this? i = 0 while i &lt; 5 do puts i i = i + 1 break if Random.rand &gt; 0.95 redo end 
Sort of. I want to do something with no more than 10 iterations like I've done with my other examples.
The article points out DOM selectors as a reason to use page objects. In my opinion, both approaches have their place.
`redo` is very rarely used in Ruby, in my experience. And in block context, `redo`, `break`, `next` and so on are actually very very strange keywords :)
I'd say give it a shot and see what you find. rubinius can be faster sometimes and it has better support for multicore programming via threads. my impression (maybe wrong) is that MRI has better performance (in time) on a lot of the benchmarks you'll find out there. rubinius has benchmarks where it is faster. as a new comer i'd focus on playing around with ruby and learning about the language a bit. rubinius is cool for that because you don't need to read C to see how the common methods you might start using work. they're written in ruby.
So as I understand, Ruby is a language that requires an interpreter which converts the Ruby code to actual assembly, and there are many different interpreters out there such as JRuby and the most popular currently being MRI. JRuby converts ruby to Javascript which then runs on a Java Virtual Machine (JVM). Rubinius is another Ruby interpreter which has some cool features that MRI does not have. The Ruby language itself contains gems, one of which is rails. So to install rails you install Ruby by choosing an interpreter and then install the rails gem. So if I want to run rails on Rubinius then I first install Rubinius and then the rails gem?
There's a great video from Patrick Farley on [Ruby Internals](http://www.confreaks.com/videos/825-mwrc2008-ruby-internals), which is an in-depth look at the object model (including eigenclasses, etc).
Unfortunately you have not understood topological sort. A simple if else statement resolves dependency of one vertex. How do you find the next vertex to visit ? You cannot supply it everytime externally. Just pushing those dependencies to before the vertex cannot work. You need to first find the dependencies of dependencies. Only when there are no dependencies left, can you proceed back and add the original vertex back. Your algorithm also needs to be stateless. Ruby's tsort uses Tarjan's algorithm for strongly connected components. You should read it up. Topological sort in wikipedia has a nice explanation (http://en.wikipedia.org/wiki/Topological_sorting) 
 require 'tsort' class Hash include TSort alias tsort_each_node each_key def tsort_each_child(node, &amp;block) fetch(node).each(&amp;block) end def other_tsort res = [] each do |item, dependencies_array| if index = res.index(item) res.insert(index, dependencies_array) res.flatten! else res.concat(dependencies_array) res &lt;&lt; item end res.uniq! end res end end ex = {4=&gt;[1], 3=&gt;[], 2=&gt;[3], 1=&gt;[2, 3]} p ex.tsort p ex.other_tsort Result: [3, 2, 1, 4] [2, 3, 1, 4]
There was absolutely no way for you to use a word that would be acceptable in a professional environment, huh? "Toothbrush" ? "Toothpaste" ? I'll tell you what, I would also have accepted "osx-notifier".
So.. You defined 2 methods that call `terminal-notifier`, and give it an offensive name?
You, sir, are my hero. :)
Is there some equivalent of "Rule 34" for "dumb things to do" ? Well .. Maybe that's Murphy's Law. If it's dumb and it hasn't been done, somebody's thinking about doing it.
Essentially (yes, I know I'm trivializing it), all it needs to do is for text input (the code that people enter) be submitted to a server side handler which runs the (ruby) tests against it. Its not "difficult" but as with all things, doing it "well" would take a few days.... Well it would for me at least given I took 12 minutes to work out that typeof cant handle 'array'. ***** JavaScript. Oh and of course, check out http://koans.heroku.com/en
Thanks, knowing about these internals consolidated my understanding of the method lookup path.
curses/ncurses support what are called [Windows](http://rubydoc.org/stdlib/curses/Curses/Window), which allow you to have separate text areas.
Hmmm... Okay, first of all, two important resources if you want to dig deeper into Ruby: "Confident Ruby" and "Practical Object-Oriented Design in Ruby". Ruby inherits from Smalltalk, among others, and chief amongst that inheritance is the idea of message-passing. Ruby is big on duck-typing and role-based interfaces. It is generally considered poor form to ask an object what its class is. Instead, figure out what the role is supposed to be and go with that. Instead of asking "is_a?", you can instead ask "respond_to?" which is a way of checking if a method exists, but that's not very good either, since you're still ... Asking. Anyway, to start answering your question very directly, in this situation, the "case" statement is a little more Rubyish. In addition, you can pass an argument to a case statement. case name when String puts "HAHA!" else puts "HOHO" end I'd also let your code drive the behavior. I see you have two arguments, "name" and "greeting", but if you pass in a hash, "greeting" gets ignored completely. Looks like an odd mismatch, and I would consider redesigning the API to examine what the purpose of all those inputs are. Anyway, again, on a Hello World app, a lot of what I'm saying is like using a cannonball to kill a fly. One last thing: the Ruby world likes classes. The old adage remains true: "sometimes, all you need is a function". And for a simple HelloWorld.. maybe that's true. Still, instead of building a recursive HelloWorld app, I would probably consider creating a HelloWorld class that takes this open-ended input in the initializer and then "does the right thing" in another method. Ruby people don't like recursion all that much. Hope that helps :)
&gt; Ruby people don't like recursion all that much. #1 ruby comment NA
A more canonical version of `greet2` uses the implicit `===` method via `case`: def greet(name = "You", greeting = "Hey") case name when String puts "#{greeting} #{name.capitalize}! What's up?" when Array name.each { |name| greet name } when Hash name.each { | person, greeting | greet(person, greeting) } else puts "Hmmmmm... I don't know you." end end Note that both the `Array` and `Hash` use `each` to pass the iterated items onto `greet`, so we could collapse those cases: def greet(name = "You", greeting = "Hey") case name when String puts "#{greeting} #{name.capitalize}! What's up?" when Array, Hash name.each { |args| greet *args } else puts "Hmmmmm... I don't know you." end end Now we can duck-type it up and work over all container classes by just checking for `each`: def greet(name = "You", greeting = "Hey") case name when String puts "#{greeting} #{name.capitalize}! What's up?" when -&gt; name { name.respond_to? :each } name.each { |args| greet *args } else puts "Hmmmmm... I don't know you." end end And we can accept more names if they support a `to_s` method, so let's do that: def greet(name = "You", greeting = "Hey") case name when -&gt; name { name.respond_to? :each } name.each { |args| greet *args } when -&gt; name { name.respond_to? :to_s } puts "#{greeting} #{name.to_s.capitalize}! What's up?" else puts "Hmmmmm... I don't know you." end end But now we're repeating ourself, so let's clean that up: def responds_to sym -&gt; name { name.respond_to? sym } end def greet(name = "You", greeting = "Hey") case name when responds_to :each name.each { |args| greet *args } when responds_to :to_s puts "#{greeting} #{name.to_s.capitalize}! What's up?" else puts "Hmmmmm... I don't know you." end end 
This doesn't have to do specifically with Ruby, but as a general practice. You're expecting your method to act on all types of data; you should decide what form you want the data in, and work around that. So let's say I want to only pass an 'arguments hash' to the method: def greet(args={}) puts "#{ args[:greeting] } #{ args[:name].capitalize }! What's up?" end called by: greet name: "Mom", greeting: "Hey" or by: ["Mom", "Dad", "Pari", "Mike"].each { |n| greet name: n, greeting: "Hey" }
&gt; name.each { |args| greet *args } Nice 
I actually have been tooling around with curses tonight with a little success. I'm actually having the same problem I had without curses. I created to Windows and one is `win`. I use `win.scroll` to scroll it up one line at a time but each time it does that it also scrolls the chatbox. The lack of documentation for this library is a serious pain in the ass.
Well...other options? (we use cap heavily) Maybe it's time to start looking at the [deploy resource](http://docs.opscode.com/resource_deploy.html) from chef.
You want to create two separate windows, one for input the other for output.
Yes, I chuckled
Mina is another good deploy option. https://github.com/nadarei/mina
I did. Do you have any examples of this? I have one window, for chat output called win and one for userinput called tlk. I only called scroll as `win.scroll` but it seems to have affected the `tlk` window as well. Edit: Some code: class Display def self.show chat @win.scroll @win.setpos(32,1) @win.addstr chat @win.refresh @tlk.setpos(2,1) end def self.initialize @win = Window.new(33,120,0,0) @win.scrollok(true) @tlk = Window.new(3,120,0,0) init_screen end end Prints great. Cant handle user input well.
I use [deployml](https://github.com/postmodern/deployml#readme), but am tempted to rewrite it in bash (I've seen people do `cat deploy.sh | ssh deploy@example.com`). There's also [mina](https://github.com/nadarei/mina) and [inploy](https://github.com/dcrec1/inploy#readme).
That's really unfortunate. We use capistrano all the time where I work (for both ruby and non-ruby projects), and it has served us very well.
I completely agree with you. I think it's hard to overstate what this means for the ruby community.
&gt; JRuby converts ruby to Javascript s/Javascript/java byte code/ Javascript != Java.
Deploying via git is great. Just keep a local repository so your deploy process doesn't go to shit when someone decides to DDOS Github :P
Capistrano should be slimmed down. Any rails related stuff should be plugins or other gems. It sucks that he had to deal with rails bullshit.
I think he has already done that ? I'd suggest that people pitch in if you have a stake in Cap. 
I don't like the fact that cap is necessary. But it's necessary because rails is so complicated as he points out. It's not enough to just ftp your files someplace like you can with most other languages.
Knife solo + artifact deploy, that is all.
me too! I've been waiting for what seems like years! Unfortunately in the process of upgrading rbenv on my mac, (during a reinstall of xcode command line tools) i've borked my installation and i don't have a working gcc anymore :( 
I like RVM because to me it's like putting each of my apps in their own bottles with only the gems they need. Is that wrong?
In development, no. In production, I don't see a reason to use it.
&gt; Knife solo + artifact deploy, that is all. That works :-) 
What's artifact deploy? 
Bundler indeed replaces gemsets, which is why I think people should not use gemsets. Bundler not only solves the problem that gemsets solve, but also solves that problem better, namely by removing the need to manually switch between gemsets, by automating the installation of gems, and by encouraging the storage of version specifiers in version control (Gemfile.lock). However, Bundler does not manage and isolate Ruby versions. *That* is a valid reason to use RVM (in combination with Bundler).
What does NA mean?
&gt; name.each { |args| greet *args } &gt; ... Does that actually do what we want it to do?
https://github.com/RiotGames/artifact-cookbook
It's a league of legends reference to "North America"
You can turn the cases into one-liners: def greet(name = "You", greeting = "Hey") case name when responds_to :each then name.each { |args| greet *args } when responds_to :to_s then puts "#{greeting} #{name.to_s.capitalize}! What's up?" else puts "Hmmmmm... I don't know you." end end
With a little help from /u/herminator's example, I cam up with something a little more practical. I think a good way to keep a `redo` statement in check is to include an outside data structure to regulate it. Initially I was thinking of something like an `Array`, but then I realized, that I could use just a `Fixnum`. srand j = 0 loop{ i = rand(100) redo if i % 3 == 0 j += 1 printf("[%d] %d ",j,i) break if j == 10 } printf("\n") Sticking a `redo` at the end of a `while`, `until`, or `loop` statement is redundant, especially a `loop` since a `loop` will go on forever unless or until `break` is called. However, using `redo` on its own will trigger the infinite loop within the block. One thing I have noticed is that often we use `break`, `next`, and `redo` in conjunction with some condtional statement (generally `if` or `unless`). I'm also surprised that `case/when` blocks do not use `break` at the end of each `when` block to prevent executing the next `when` statement like in C/C++/Java's `switch/case`. Sometimes it is useful to execute the next case without a `break`. In Ruby, `case/when` does not appear to have this cascade effect. Perhaps something else can be used.
Thanks. So what does your entire comment mean?
&gt; Ruby people don't like recursion all that much. As a Ruby dev myself, I can't remember the last time I used recursion. Simply reenforcing the fact by agreeing with you.
This reminds me of why the lucky stiff and how he withdrew from the community because of what is believed to be similar fears. I hope Lee finds a balance that will work for him and that he can stop with the endless grind. 
I am somewhat disappointed over the lack of support for Ruby 2.0 named arguments (further extended to optional named args in 2.1) for rubinius 2.0. From the press announcement it sounded like the project was on par with Ruby 2.0 and aiming at staying in sync with 2.1, slated for release later this year. In reality Rubinius isn't syntax compatible with Ruby 2.0 (and not 2.1 either obviously). 