I use my RubyMine license on Mac and Linux and I really love it. To each their own I guess.
devastating ... I've been using and blogging about Ruby on Rails in Netbeans since they started supporting it.
Everyone will tell you to go all out, disable your arrow keys, throw your mouse in the bin, and start wearing socks and sandals, but you'll probably be a lot happier if you bind some conventional commands, such as ctrl-c and ctrl-v, so you feel a bit more at home. Nothing wrong with learning it slowly: it's a lot more fun that way.
Do you need to read/write from/to Excel? Use the spreadsheet gem, it's much easier to use! http://spreadsheet.rubyforge.org/
Heh. Slowly. I've been using vi since college, 20 years ago, because that's what we had. So, yeah. Slowly is the name of the game. I've tried fiddling a little with the setup, and the people who put the plugin collection together had, indeed, killed the arrow keys. It's been awhile, but I can re-learn them. My *real* problem is probably the Bard's Tale series on the C64. You walked around with JKL and I for forward. Sometimes, that memory muscle still kicks in. ;-)
Aptana's definitely got to be the best I've used.
Eclipse with the ruby and radrails addon will do just fine for the rest of us. I quite liked Netbeans support for ruby and rails, and I've also used Netbeans with their ruby support, and quite honestly... Fuck Oracle...
FTA: &gt; Second: Although our Ruby support has historically been well received, based on existing low usage trends we are unable to justify the continued allocation of resources to support the feature. That's because your implementation blows. Fucking Oracle, blame the users.
http://www.reddit.com/r/programming/comments/f8aaq/forrester_oracle_confining_java_future_to/
I'm surprised no one has mentioned macvim with [janus](https://github.com/carlhuda/janus).
Chuckle. I think [APL](http://en.wikipedia.org/wiki/APL_\(programming_language\)) started this. Now we just need the right keyboard layouts. 
Redcar is a ruby editor, written in ruby that lets you make your own plugins, also in ruby. It is already very good and making big strides fast. http://redcareditor.com/
Ok may VIM be good but... c'mon, sometimes I wonder why everywhere VIM guys are the loudest and think that they are the coolest (because they are using VIM, and not (face of disgrace)... IDE). I am not telling that you are, but here... I think that best point was made by Rober C. Martin (author of Clean Code) on Railsconf: http://www.youtube.com/watch?v=mslMLp5bQD0 (the interesting part is about after 35:10). Agree with or not, but has the right to say so (an in fact - if you saw entire cast, you know that it is not only about VIM, but also about IDE's.... and everything else).
Yep, learning vim was good experience, eventually I got back to NB, because it done most of the job (and much more) without any plugins. But vim teach me some tricks, and I could improve NB configuration even more.
Check the VBA API that comes with Excel.
If you're using vim you might want to look at: https://github.com/carlhuda/janus as a nice starting point for setting up your vim env for rails development. The command-t plugin is worth it alone.
NetBeans is actually a pretty sweet IDE (or at least it was about 6 months ago). 
I don't want to defend them, but I think it needs to be said that paying a developer to work on NetBeans while seeing no returns on that investment isn't really sustainable. I wish Sun would've been bought out by a company with closer ties to university research programs that would see the value of investing in all of these projects instead of just seeing the bottom line.
Purely from a fiscal perspective, yes. But Oracle has sooooo much money that it wouldn't be but a drop in the bucket to pay a small team to work on Netbeans, and it would likely bring huge returns in favor from the open source community.
I disagree about `BEGIN` and `END`. Sometimes if I'm just writing a utility I want to keep everything in one file. I'd rather have the program logic at the top of the file than various helper methods. I use `BEGIN` at the end of the file so that I can define all the helper methods there. 
&gt;Wirble bugs You're making that up!
Looking on Google: http://www.arachnoid.com/ruby/rbeautify.rb.html 
I wouldn't extrapolate that far. More languages on the JVM is good for Oracle.
It's in Ruby's standard library obj = Object.new obj.instance_eval { @foo = "foo" @long_instance_variable = [ "some", "long", "value", 123, {:bar =&gt; :baz, :hello =&gt; :world} ] } require 'pp' pp obj
I was mostly looking on how to load an xla file, I found a tutorial online, but I notice the lack of clear documentation on that library
Note that the OP asked for a source-code pretty printer.
How'd you find it? I figured 'pretty print' was a sort of jargon term - I've seen it for at least two languages.
Because how your text is formatted is not a function of the content of the text, it's a function of the text editor.
Yup. I used NetBeans for a day. Noticed that it was shitting all over my svn properties. No thanks. Back to Vim. I tried Eclipse with the Ruby bits. I kind of like Eclipse of Java, but I cannot stand it for Ruby. Back to Vim. I realize that I should be more patient with these IDEs. They have some cool features... but really, nothing's blown me away yet (Eclipse does have that neato "refactor" button, I kinda want that in Vim now... hmm...)
You know, NetBeans is fully open source and you can just grab the Ruby module and keep developing it, if it's really that important to anyone.
I'm very conscious that I am that guy, and I'm aware that it's annoying, but here's why I think Vi and emacs are the right tools for the job. Text editing is not mysterious. It's not changing. There is some scope for opinion on how you work through a problem in code, but in general, the same steps are always going to occur, and the same problems will befoul everybody. Vi is old. Sure. So are lathes, so are saws, so are drills. Good tools last - they get updated, and they get tweaked, but they essentially stay the same, because they work. Everyone's seen those horrible cheap adverts for new exciting power tools that will change your world - those tools don't last. You might buy them, and maybe you'll even use them, but eventually they'll rot in the back of your shed and you'll go back to doing it with your dad's old toolbox, because the kinds of things you have to do with tools have not changed significantly for a long, long time. Vi is that basic toolbox. The tools have been refined through years and years of use, by programmers far greater than me. To use anything else would be like a carpenter deciding that saws are nice, but he's going to skip them in favour of breaking the wood with his bare hands. Saws work, and every carpenter likes saws. In Robert Martin's own words: 'Don't depend on things that are volatile'. **tl;dr** I need to stop thinking about text editors, Vi is good, buy a saw.
Pretty printing is ruby jargon for easy readable string representation of ruby objects. A more general term for searches is "code beautifier".
Nice and honest answer... But I think that tools staying the same is not always great thing? You would like to be treated with penicillin or with a saw (one of old medical tools). The point of Uncle Bob is that even in face of such great hardware evolution, we did not evolved our software much (that includes also IDE's). Here's one tiny example - I switched to Colemak layout to type faster (again - qwerty still lasts, but is it the best tool for the job?), and suddenly most of VI commands became nonsense. Smallish thing you can say, but made using vi impossible. I just agree that VIM or Emacs are great tools, I am just asking for being more open...
http://rubyonwindows.blogspot.com/ has some hints
Vim is great for text editing, and I've been using Vim for years. Netbeans, though, provides me with a lot more things outside the realm of text editing that either aren't directly available inside vim, or present their functionality in an ugly, archaic format. Perhaps I'm just getting too old or have too many things on my plate, but I find myself growing more and more weary of trying to keep cryptic command mode key sequences memorized. If I'm spending an inordinate amount of time trying to train myself in an editing environment then my time is probably better spent actually developing the code. I'm actually going to give vim another shot for larger projects (including ruby), so I'm certainly not anti-vim. **tl;dr** Use what works for you.
APL is for math nerds. New super compact ruby is funny.
TIL...
I was never a big IDE fan (Textmate FTW), but it's sad to see such a great piece of software removing support for what has become one of the best frameworks for agile development.
That was exactly my point. The problem is that oracle doesnt see the value in that investment
this is what you need to do because everything after getting the instance of Excel is handled by Excel. The win32ole library is just facilitating the communication.
Good description of mixins. Pretty simple concept, but for some reason it seems a lot of documentation overcomplicates them author explaining what they should be used for. 
Not surprising. Seems like it was just about the least popular editor/IDE choice in the community.
Nobody notices.
Nice! Thanks for posting this. I like RubyMine, but the price point was always a little much for me.
Best comment "IDE's are like cages for your brain"
I use godaddy.
You could have mysite.com/blog redirect to some wordpress site, but unless it is also hosted on heroku, mysite.com/blog can't actually be the blog's real location. Also, Wordpress is not rails blogging software.
If you don't need all of the features of rails (and just want a blog, comments, spam filtering) and want it to fit your existing layout files, you could use: https://github.com/ryanstout/blog_kit (* disclaimer, I wrote it)
thanks, so long as it is invisible from an SEO perspective I'm indifferent to where the files themselves live. wordpress != rails; yeah I know was just putting that out there as I would like to use WP if I can get it seamlessly integrated into my sites structure. 
sweet! checking this out now. 
There's always [jekyll](https://github.com/mojombo/jekyll). I use it for pretty much every site I build now. To me, it's kind of "the hackers" blog/cms.
Good to know, thanks. I use TextMate but for that price it may be worth trying it out.
I wish NetBeans dropped Ruby support a month ago went I bought my license.
IMHO adding specs for migrations is a waste of time because if feels to me like you are testing the framework and not your code, and also because as others have said I can just migrate/rollback or redo. This has always been more than enough to check that the structure and perhaps the data change as expected, at least from my experience. I often "test" migrations with the test database first... e.g. rake db:migrate RAILS_ENV=test just in case; then I reload the schema if needed. rake db:schema:load RAILS_ENV=test Then if I am working with small databases, depending on the application, I usually use a rake task to pull the database from production (or with a subset of data - together with the backups I usually script the creation of an export with smaller datasets, e.g. 10000 rows or so if the dbs are large). Then I "test" migrations with production data. Other considerations: -for data changes (not structure), if it's something I may have to run more than once I'd create a Rake task. -since structure/data changes affect the behaviour of models etc, if I am sleeping and forget to check if the db changes as expected following a migration, chances are that the problem will be caught by specs for the models etc. So, I may be wrong, but I do think that adding specs for migrations is overkill. If there's something that annoys me about migrations, is that you can't have transactional migrations with MySQL as you can with PostgresSQL because of the lack of support for transactional database definition changes... that would make things easier in a number of cases. 
I don't think many Ruby devs care about NetBeans. It definitely doesn't mean anything.
Perhaps I am missing something, but why not just POST directly to the action of the form, for example with RestClient?
Uhm since you can't host PHP apps on Heroku there isn't much choice AFAIK. However, this is what I think you could do: * Add a route /blog/:slug to your RoR app, that simply renders a full page frame loading the original page with same slug at the original Wordpress location e.g. http://blog.yoursite/slug * Add a rel=canonical to both the Rails parent page, and the framed article page. This should work in that * users can visit pages at http://yoursite/blog/post-title * you can still access the Wordpress administration from the original URL (blog.yoursite.x) * you won't have SEO issues since by specifying the rel=canonical you will be transferring PageRank juice to the newer pages under yoursite/blog. Actually you will be strengthening the ranking of your main domain. * because of the previous point, when search engines update their indexes they will be starting to show the new URLs. The only problem you may have is comments, since users will have to submit forms that make POST requests, so it gets more complicated. But you can avoid this issue altogether by replacing Wordpress comments with Disqus or IntenseDebate (which I would recommend anyway), unless you already use any of these.
Nice! Thanks a ton!
What do seasoned RubyMine users think of it? I'm on Windows and use Komodo, which is free. What about it makes it worth the $29 bucks? 
It's worth 29 dollars.
&gt; What about it makes it worth the $29 bucks? Check out the feature list on the [RubyMine](http://www.jetbrains.com/ruby/) page and see how well that aligns with how you use your existing toolset. Try the demo and load up your codebase, configuring any additional services you utilize. You'll likely be amazed at just how much RubyMine knows about your project and how you can interact with it.
I don't know a single experienced RoR dev that used NetBeans, that change really meant nothing to the rails community. Currently there is a huge ruby job shortage, and the market is very healthy for ruby developers. This author needs to get a clue.
Thanks! I was contemplating picking up a license today and luckily forgot about it until I saw this. In for one.
I would do this in conjunction with a simple sinatra app that serves the jekyll site. Just have the route /blog match to the sinatra app that would look something like this: [gist](http://gist.github.com/801599) I forget where I ran across this, but it makes deploying jekyll sites (or anything static) to heroku dead simple. Edited also to agree with you about using jekyll everywhere. I haven't **loved** a piece of software like jekyll since, I don't know, running across sinatra for the first time. 
no no, don't do this. no frame shenanigans. 
Ruby code with tabs instead of spaces? Madness! word[21, word.length] can be written as word[21..-1] **fixed, thanks to zenspider** Also, I would rewrite this part new_word = "" name.split(" ").each do |n| n.downcase!.capitalize! new_word &lt;&lt; n+" " end result = new_word to result = name.split(" ").map{ |n| n.capitalize }.join(" ") or you might even be able to just use straight up regex with \\b checking. The best I could do was: result = name.gsub(/\b\w/){ |letter| letter.capitalize } but there might be more elegant/faster ways to do this.
I personally find [nanoc](http://nanoc.stoneship.org/) much more flexible and powerful than Jekyll. I [moved to nanoc](http://www.h3rald.com/articles/take-back-your-site-with-nanoc/) from Typo for my [site](http://www.h3rald.com) over a year ago, and never looked back! 
Interesting. I always just run Jekyll from the shell then rsync it. I set it up once to run on the post-commit hook on a remote git repo so it generated on push. It's great that it just outputs static HTML because it works on every host anywhere. And yes, I'm not sure if I've loved a piece of software more when it comes to authoring websites.
You were thinking of: word[21..-1] the original is also wrong, but it just happens to work by virtue of String#slice. I prefer your split/map/join. It is much faster than the original and easier to read and maintain. Better on memory too.
I hate frames too, let me be clear - perhaps I should have stated that. But I don't see what else he could do if he wants to use Wordpress and that app hosted on Heroku, at the same time, with the blog under site/blog. I don't know whether he would switch to another (likely less featured) blogging engines as suggested by others - it may be time consuming and it also depends on taste (one engine vs others). Another option would be of course to host both apps on a own server with both Ruby and PHP support, so that Wordpress can easily stay in the sub directory...
and even less care about Oracle
The tabs were a result of pasting into the gist.
As said earlier, I don’t see the need to use Mechanize to fill in the form etc. You can just post directly with RestClient or similar. Also - with Xpath it’s a bit easier - you can skip the first n characters of a string with s[n..-1], no need to specify s.length - I like more regex to capitalize each word, as also suggested by hc5duke, it looks cleaner %w(sinatra nokogiri rest_client).each{|x| require x} get "/:psuid" do response = RestClient.post "http://www.psu.edu/cgi-bin/ldap/ldap_query.cgi", :uid =&gt; params[:psuid] ((Nokogiri::HTML.parse(response).xpath("//body/form/table/tr/td/b").first.text[21..-1]) \ rescue "Not found").gsub(/\b\w/){|w|w.capitalize} end 
just for clarification. I don't need both on Heroku. I just need the url to be site.com/blog
i used it from when it was the ruby plugin for intellij up until about 2 months ago. it runs slow as shit. it has some really compelling features. don't buy it.
I'm on Windows, but my Rails environment runs on a Linux box on my LAN, and I have it mapped via a Samba share. This means I don't get access to some features, like test integration, but it's still excellent. Some of my favorite features: * Quick code lookup - ctrl-click a method and you go straight to its definition * Localization interpolation. Shows you your default locale's localization in place of translation helpers. * Syntax checking, highlighting, and automatic reformatting are all excellent. * Lighthouse integration is nice. I can pull up my issue list straight from the IDE. * Gutter shows what's changed since last commit in a file. Can easily revert a piece of code back to HEAD with a couple of clicks I'd say it's easily worth $29. I bought a full-price license a few months back and don't regret it at all, and I typically hate IDEs. RubyMine provides enough extra functionality that it's worth the increased size over Notepad++ though.
Brilliant timing this with the NetBeans decision. Got NetBeans losers who knew no better like myself to switch over. 
Maybe Phuby on Phails can help: http://www.youtube.com/watch?v=lsWKjS6Vufw
OK! Then it's pretty easy actually. If you can set up or already have a server, you can mix Rails and PHP in the same virtual host. I use Nginx, and had this kind of requirements in a couple occasions. In my case, in the Nginx virtual host I have all dynamic requests proxied by default to a cluster of Thin servers, for the main Rails app. Then I have a Regex rule that forwards all the .PHP requests to PHP with FastCGI (I use PHP-FPM for this). Let me know if you want to know more.
the sad thing is I understand exactly what needs to happen but could never for the life of me actually implement this. May need to hire someone to do this for me :)
How soon do you need it? Are you in rush? I am planning on writing a post on how I set linux boxes for the hosting of Ruby and PHP apps, so that will basically tell you step by step how to set up everything from scratch.
It's filed under 'nice to have' for now. Though, I need to find a nice solution for our FAQ and tips as well which I was going to roll into the blog structure. Looking forward to your article! btw. the site is [hangwith.me](http://hangwith.me) and the blog is [blog.hangwith.me](http://blog.hangwith.me)
me too ;) and github for hosting: http://knoopx.net
"Beautifier" is another term for want you looking for. I'm the developer of Php Beutifier, so one of the first thing I was looking on ruby was something to fix unreadable code.
The SNR was way too low, you mean.
The nanoc site crushes firefox.
how can you have a blog without comments?
I hate comments on blogs. I find most authors who use jekyll go for [Disqus](http://disqus.com).
The tabs were more likely a result of you not configuring your Ruby editor to use 2 spaces and soft tabs for indentation. Like you should. :)
The SCM integration(into the editor itself, not just for committing) is something I haven't seen elsewhere. It's amazingly useful. The other nice on is the stack trace parser, you just past in a stack trace and you can click on it like you would in the test result(hey, sometimes I'm lazy)
RubyMine has one built in for Ruby, Javascript, ERb/HTML, CSS, etc. It also lets you format just a selection instead of a whole file. RubyMine is a killer IDE. I highly, highly recommend it.
How about tags?
[Previous comments](http://www.reddit.com/r/ruby/comments/crjyo/camping_vs_sinatra/)
This is a Pragmatic Programmers book: http://www.pragprog.com/titles/jruby/using-jruby
Jekyll does tags. It is pretty easily extendable too so if you are good with Ruby you can work your own magic.
How is this different than Exceptional and HopToad?
I've been slogging along trying to make my usual editor, Emacs, work with all of the various Rails-enabling plugins. After several weeks of failed attempts, I am glad to plonk down $29 for something with far more extensive Ruby and Rails support that works out of the box. I've spent most of today evaluating RubyMine, and just placed my order. Thanks for the heads up.
I'm looking for a web framework for my next project, so I'm very happy that you posted this, but I have a few thoughts. I've done a bit with Sinatra and while I really like the syntax, there are some things missing. Camping addresses a lot of those problems and I completely agree with every point in the article. But I get the impression that Sinatra just acts as the controller in MVC and gives you the freedom to do everything else your own way in true micro-framework style. While I like Camping's routing procedure (except for the ugly R syntax), I don't agree with the way models and views are handled. I'm basing this all off of the book, and I have no idea how modular Camping really is, but I don't want to have to subscribe to a mindset when there are other options out there. The fix would be to make the project modular and drop the model and view components (allow the usage of DataMapper/ActiveRecord/etc and Haml/Markaby/etc), but then you see the flexibility of Sinatra even if the routing syntax isn't the best. Anyway, just some of my thoughts, but it's really late right now and I'm half-asleep. Please don't take this too seriously, but I thought you'd like some feedback from an outsider.
The model component is just a module (`App::Models`); you can place whatever you want there. We provide some glue around ActiveRecord, but you don't have to use it. As long as the controller returns a string, Camping is satisfied. Camping includes a #render method, which either uses Markaby or Tilt. So given `render :index`, this will either render this method (if it exists): module App::Views def index h1 "Hello World!" end end Or it will render a file called `index.*` (supports Haml, ERB, Slim etc by using Tilt). Of course, you don't have to use #render, just make sure your controller returns a string. Hm, if you could decide, which features of Camping/Sinatra would you have in *Your Perfect Framework*?
If I were you I would ditch ultraviolet and use something javascript based. It's too much of a pain to handle all the dependencies.
The problem I have with this article is that it only covers one use case of Sinatra. It completely ignores the more flexible (and arguably more sane) "subclass style" applications. These inherit from Sinatra::Base, and wrap your app in a class. It allows you to include modules, use multiple subclasses, etc. Combine Sinatra subclass apps with Rack.map, and it's a highly effective way to make several independent apps look and work together as a single cohesive application. I use Sinatra for a wide variety of purposes, and generally find that it handles the web portion of an app, while staying out of the way of the business logic. You can see an old (but still functional) example of this here: http://tannerburson.com/2009/01/multiple-sinatra-90-applications-in-one.html
I tried to read the page but I only see a login form??
I like the article, however I still prefer Sinatra :) For example I don't like to attach routing stuff to a model. Also, as sgarissta says Sinatra allows a lot more than shown and is a lot more flexible than that, plus there are several nice extensions. Anyway I have only played with Camping not too recently, so I may play with it a little more when I have time. However I have built nice things with Sinatra, especially a large API (I don't agree with who always only associates Sinatra with "small apps"!!) for a lead generation company that handles data collection / cleansing / validation and delivery, and just love it.
From the article: &gt; In Sinatra it's a norm (whether you use Sinatra::Base or not), in Camping it's the law. I'm fully aware of that you can subclass Sinatra::Base, but I don't quite see how Camping is any worse? It's a little hacky if you don't want them on top-level namespace, but this works fine: module Sample end Camping.goes "Sample::Blog" Camping.goes "Sample::Main"
The application may be good, but I'd suggest you add some more information on how it works and how to integrate it, with some screenshots. Also, you say it's free and there are no rate limit. But is the hosting sized to support this? I mean, could I use ErrorApp with an app that has got around a couple million page views per day? It would be useful if you wrote a blog post / presentation etc with these details as well, and also explaining whether you are planning to keep it free or if there will be priced plans etc.
I see the author has fixed the link or something, since I could now read the page. 
I think there's a little mistake / thing missing in the code shown, in that Rspec is also required in the development environment for the generators to work properly - not only in testing.
You make a good point about testing the behaviour and not the implementation, and how the different syntax can express this. However I like both and I think that not always a "business friendly" DSL is need. Sometimes it is not and some coders may find it easier and quicker to just use plain Ruby with Steak, so I think both have their place and I'd use either of them depending on the case/needs.
Agreed.. it would have been nicer to link to their store since they are the editors and also sell the books directly.
Yeah... my bad. Not too good at this blogging thing.
I figured things would be modular, so it really is a comparison of Sinatra and Camping's controller syntax. module Blog::Controllers class Index def get @posts = Post.all render :index end end end Versus: class BlogController &lt; Sinatra::Base get '/blogs' do @posts = Post.all render :index end end When you look at it, the only real difference is that Sinatra combines the routing into one line while Camping requires two lines. Sinatra takes in the route as a string while Camping magically figures it out, or else is supplied a string in addition. It's really hard to argue either way, although you may have some notions on which is more rubyish than the other. I mean, it's hard to like Camping when the arguments for it seem so, as you put it, unimpressive. While Camping might prevail if all things were reset, the fact that Sinatra has the community on it's side really helps its case far more than any amount of picking at syntax. The number of extensions is remarkable and really promotes the "pick-and-choose" lifestyle, and I'm sure there is an extension for every point you've brought up in this article. I really do like the controller syntax and would like to see something like it in Sinatra. But switching completely to Camping for a slight syntax change is just unreasonable when Sinatra can offer a lot more in other areas.
I bet you'll be more careful next time :D 
I have to say, these names are getting out of hand.
I'm all for the proper implementation but I just saw [cloudmailin](http://docs.cloudmailin.com/post_format) as a private beta heroku addon, they handle incoming emails via http posting. I still think using ActionMailer is the proper implementation
I'll just leave this [here](http://www.igvita.com/2011/01/14/handlersocket-the-nosql-mysql-ruby/)
That didn't seem very easy to me.
Brutally honest: your site will never need to "scale up". 95% of the sites in the world do just fine with a RDBMS. However to answer your question, nosql generally acts as a cache to the RDBMS.
look into friendlyorm
Of the three worst codebases I've seen, two have been in Ruby, and the other in C. Of the three best codebases I've ever seen, two have been in Ruby, and the other in C. I've seen good java, but, mostly I've seen just barely adequate java. The language can help keep things clean, but it's still up to the developer. 
&gt; Of the three worst codebases I've seen, two have been in Ruby, and the other in C. &gt; Of the three best codebases I've ever seen, two have been in Ruby, and the other in C. have you only seen 3 codebases? ;)
I have some NoSQL uses that I decided to include alongside my ActiveRecord usage. Stuff like hit tracking and what not I am using MongoDB.
java libraries drive me insane most of the time. Here's a piece of code I ran into today. EnglishStemmer s = new EnglishStemmer(); s.setCurrentWord("words"); s.stem(); // this returns a boolean s.getCurrent(); // returns the stemmed form 
I've done it, and it's trivial in Rails once you realize that models don't have to inherit from AR. That said, I've only done it because of data model constraints (wanted to store hashes and arrays without the mental overhead of a bunch of tables and joins), and not because I believed that [mongodb was web scale](http://www.youtube.com/watch?v=b2F-DItXtZs).
That's quite misleadingly-titled.
An app I'm working on uses MySQL for most things and MongoDB for a one specific part where we need revisions and diffing of a tree structure, which just seemed pain in the ass difficult to implement without totally screwing up performance in MySQL (the trees are quite large). Some models in the app are remote services. Pretty much everything is indexed with Solr. In effect we have four different data storage solutions working together. It works surprisingly well, actually.
I have several projects using both Redis and Postgres and it works out nicely.
I've used both in the same app, and I would recommend it if something makes sense for a NOSQL. My use case, aside from caching, was user tracking (Who was online etc) and activity streams with multiple layers of security. * Activity streams were rendered per user, and all the app had to do was pull out an array of strings and output it. * User tracking would just log every minute when someone did something, then it was trivial to do set intersections to find useful data.
Here is a nice article from Lunar Logic Polska about such thing: http://www.lunarlogicpolska.com/blog/2010/02/15/mysql-and-mongodb-working-together-in-kanbanery.html
Michael Bleigh of Intridea has a great [demo app](https://github.com/mbleigh/persistence-smoothie) that uses NoSQL (Mongo, Redis) and a RDBMS (MySQL).
I prefer: if model.ID and not Model.find(model.ID) # foo end Less typing and reading...
Agreed and interesting. I didn't know that Ruby has `and` and `not` operators too.
+1 I like the and/or/nots when you can use them, reads a lot like english. Just be careful because they carry different precedence than &amp;&amp;/||/!
&gt; but I also would like to make the rest of the application run as quickly as possible in the backend (avoiding joins). Don't do this. Rough ideas we have about performance — like the idea that "joins are slow" — are highly situational and lose all meaning once they're robbed of their context. The reason why "premature optimization is the root of all evil" is that humans are _awful_ at predicting what will eventually need optimizing. Build your application with an RDBMS, _then_ see what the slow parts are.
I agree with the article that Backend (aka async) processing is an easy way to scale an application. Basically, take your long/hard work out of the web request and do it in the background. There are a bunch of great message queue systems that you can use depending on your exact needs- Resque, DelayedJob, Kestrel, etc. [Distributed Programming for Ruby](http://www.amazon.com/gp/product/0321638360?ie=UTF8&amp;tag=twittercomste-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0321638360) touches on a couple- Starling, RabbitMQ, DJob, etc. Pretty good book for scaling ruby apps.
[http://avdi.org/devblog/2010/08/02/using-and-and-or-in-ruby/](http://avdi.org/devblog/2010/08/02/using-and-and-or-in-ruby/)
 if model.ID &amp;&amp; Model.find(model.ID).nil? #foo end 
Don't do this. You'll introduce a heisenbug eventually.
 id = model.ID unless Model.find(id) # foo end 
I prefer the 3rd option. Testing comparisons on "null" isn't a valid comparison but even if it was .nil? is a better method for testing.
&gt; I still think using ActionMailer is the proper implementation For very low volumes of incoming mail, yes. Otherwise you can take down the machine with a mail bomb as it tries to spawn a new Rails process to handle each mail. Better to use a good 'ol mail program to accept mail, then have your app IMAP it out at will. Edit: Better yet, [have Google host your domain's mail](http://www.google.com/apps/intl/en/group/index.html) and IMAP it out of there. Now you don't have to worry about maintaining mail servers. 
if model.ID.present? &amp;&amp; Model.find(model.ID).nil? then # .present? == !.empty? 
None of them. I'd define a new instance method on Model to describe what you are actually testing. If this were active record, the equivalent might be something like: if model.id? and model.new_record? # foo end Though new_record might use the presence of an `id` value to determine if it's saved, but I don't think so because I've had to manually set ids before and it properly did an INSERT instead of an UPDATE.
The style I like here is if model.ID &amp;&amp; !Model.find(model.ID) # foo end Keeps it in one condition, without dealing with those messy explicit nil checks.
This isn't really what `and` was designed to do :/
I thought this was /r/food for a second, I was like "what kind of a dumb question is that?"
This is easier: http://railscasts.com/episodes/82-http-basic-authentication
I'd do if model.ID &amp;&amp; !model.persisted? # foo end
 if Model.find_by_id(model.ID) # foo if you found a model end unless Model.find_by_id(model.ID) # foo if you didn't find a model, which I think is what you wanted to do in the first place end In this case, find_by_id returns nil instead of raising an ActiveRecord::RecordNotFound exception; in Ruby, nil evaluates to false.
the worst I've seen so far are Visual Basic related stuff. * ASP 3.0 (back then, the view and the controller is on the same page) * Excel with VBA * Some VB6 code that I had to take over back in 2004 edit: changed to bullet point
If `s.stem()` is performing the actual stemming, and returns `true` on success for example, that is alright IMHO (`run` and `execute` were better choice though). However a better name for `s.getCurrent()` could have been chosen, e.g. `s.getCurrentStemmedForm()` or maybe even `s.getStemmedForm()`.
It's only ok if you just use a sprinkle of RDBMS or a sprinkle of NOSQL. Don't have large portions of your app using both, as it will make things hard for you (especially relations between mongoid and activerecord). I'd say use nosql where it makes sense for your small particular case, and use a relational database for the rest. Sounds like redis would actually be a good fit to your application, as it supports transactions, and most likely can store your data structure natively.
There's no "null" object, unless I'm terribly mistaken. You may be thinking of nil.
Well that didn't.. explain much..
Yes, that was a typo.
Aha. Well, at any rate, several othe rpeople have suggested (what I feel) is the best style (just "if x and !y", no .nil? checks or so). Hope you're having fun!
And if you do "scale up", [MySQL can do NoSQL](https://github.com/ahiguti/HandlerSocket-Plugin-for-MySQL) too ;)
Some nice tips on scalability and good design, with a few caveats: I think he means "memoization" not "memorization." Also, mixing in modules into Array isn't what I'd consider an example of how "Rails modified the Ruby language." The vast majority of the code in these modules are just convenience methods added to a Array, a stdlib class. The Ruby standard library is distinct from Ruby the language (syntax, object model, etc). Of course I agree that an application changing the language itself is generally a bad idea, but mixing modules into Array is hardly changing the language. If you don't like adding this stuff in the Array class, Rails is probably not a good fit for the task at hand. At least not Rails in its entirety, though I've read that the merge of merb into Rails 3 has really improved Rails modularity, so you can pick and chose a more stripped-down feature-set that still meets your needs. Sure, metaprogramming for the sake of being "one of the cool kids" is stupid, but this is really not the only case in which metaprogramming is used, so can we please stop the FUD and go back to real arguments? I submit that sometimes the extra level of abstraction and added expressiveness afforded by metaprogramming simplifies the implementation, provided of course that you possess a fundamental understanding of the techniques being used. It's like recursion. Often you can solve a problem iteratively, but if it's cleaner using the "black art" of recursion, maybe it's worth a second look. Don't be too big a weenie to exploit the language to its full potential.
Rule of thumb is not to use NoSQL just because its cool! Use it when you have a need and its fits into your app. I use MySQL and MongoDB in [Codaset](http://codaset.com). Mongo is used for the events/logging and now the commenting system, as it is perfect for those cases.
I've got an application that uses MongoDB as a primary data store, and it's backed by a legacy MySQL database. I've got both AR models and MongoMapper models in it, and it works okay, though obviously associations don't work directly.
Link goes to wrong place. Correct URL: http://www.techrepublic.com/blog/programming-and-development/let-isaac-help-you-build-irc-bots/3784
 if model.ID and not Model.find(model.ID) #foo end Beware operator precedence: http://blog.jayfields.com/2007/08/ruby-operator-precedence-of-and-which.html
Six *awesome* reasons ! Very nice post
this makes more sense to me EnglishStemmer.stem("words"); // returns the stemmed form There is no reason to instantiate an object here. Throw an exception if there is an exceptional condition. 
Source: http://rubygems.org/
What do do you mean?
Care to explain?
yay now every one can have thier own url shortener so they can all be not maintained and break the internet more!!!! /sarcasm
`and` doesn't mean the same thing as `&amp;&amp;`, nor does `or` mean `||`. They're designed primarily as control flow operators, e.g. connect_to_database or throw_an_error connect_to_database and run_this_query As such, they have different precedence, which can easily cause unexpected issues: sky_is_blue = true grass_is_blue = false grass_is_blue &amp;&amp; sky_is_blue ? "Both the grass and sky are blue." : "The grass and sky are not both blue." # =&gt; "The grass and sky are not both blue." grass_is_blue and sky_is_blue ? "Both the grass and sky are blue." : "The grass and sky are not both blue." # =&gt; false
`and` means _exactly_ the same thing as `&amp;&amp;`. `or` means _exactly_ the same thing as `||`. They _just_ have higher precedence.
Ahh, true. It depends on one's definition of "mean." I was referring to purpose rather than strict function. So, they mean the same thing in the sense that "strong-willed" and "stubborn" do: same definition, but they're used differently.
fixed link URI
tenderlove's [commit](https://github.com/rails/rails/commit/5b42e9660201fc721075d2bfbe13edb0014dbde2) to the Rails source tree
You should also check out Cinch, as it is an extension of Isaac's syntax with a lot more features. https://github.com/cinchrb/cinch
exactly. clearly cucumber is better.
Was just about to point out that Cinch is far cooler.
Also, what is the Cinco framework DHH is talking about. I would like to know more about that. *edit* [This guy totally posted it first over in proggit, do mind showing him some love?](http://www.reddit.com/tb/fdeve)
Just to point out that this isn't a new problem. We've been forced to do client side validation for ages and ages. The combination of the old &lt;form onsubmit="return checkForm()" is something I recall having to do in 2001 - it's not really all that new of a revelation. You actually have three sets of checks and balances if you're good. 1) The front end. 2) the post handler, and 3) the db itself should be enforcing keys and constraints too. You can't rely on programmers writing good checks and balances in the POST handlers - they often fuck that part up and you end up with a shit database down the road. And then you have to handle those errors three times too and always account for them on your front end.
A nice tutorial, but it's not finished yet. Which I didn't notice until I had worked through part 1. Disappointed I didn't get to do the whole thing.
I've been happy with VIM and all the rails, ruby, rpsec, rdoc, etc plugins for awhile. figured 30 bucks was a night of drinking so I bought rubymine. within the first 30minutes I found my 30 bucks well spent.
Excellent. Thanks.
 class Model def persisted? id and Model.find(id) end end unless m.persisted? #foo end This code fixes two things: 1. Ruby indentation standard is two spaces 2. logic should be inside your models with a name that expressed the intention, not spread around outside in whatever code happens to use the model 
It does have the problem of only being useful for Ruby 1.9+, where Isaac works on 1.8.x as well.
Flippin' sweet. I've been trying all of the non-free options like 3rd Rail and RubyMine, and they just don't cut it.
Part two is out now!
Part 1: [Getting Started with Rails 3: Part 1](http://blogs.sitepoint.com/2011/02/01/getting-started-with-rails-3-part-1/)
i like this more than i like the silhouette of a female standing naked in the distance her buttocks slightly open so i know in my heart that the air around her rear is being perfumed by a delicate and subtle odor
[Getting Started with Rails 3 - Part 2](http://blogs.sitepoint.com/2011/02/02/getting-started-with-rails-3-part-2/)
okaaayyyy... i'll just be quietly stepping back now...
I love RubyMine, but to each their own.
Gamedev can be a hard nut to crack. You can quickly get bogged down in OO design and quickly get lost. The problem is, it's so hard knowing what's going to be necessary without first making a game. Games are not quite like other programs, they're not tools to solve a certain problem and they can take radically different directions than what you intended when you started. So just write a game. It might be utter crap and you realize you did it completely wrong halfway through, but just "finish" it. And if you're not disgusted by your own code, something is probably wrong. My point is, don't plan meticulously, just jump in. Do it wrong a few times so you at least know what doing it right looks like. And don't get carried away, sketch out a game on paper and make that game, don't get too carried away with "what if" or you'll be coding forever.
I hear [GoSu](http://code.google.com/p/gosu/wiki/RubyTutorial) is a good place to start, once you have a good OO design flushed out.
What is wrong with RubyMine?
Try making different games as well. Keep programming one game until you feel like it's actually playable, then keep going. Also, don't worry about making clean code from the beginning. Do whatever you have to do (global variables, huge classes, all of the code in the same file, whatever) to make games. Then after you've made a few and understand the concepts a bit better, start cleaning it up.
Going to make my life much easier. We'll see if it's widely adopted or not.
Zed Shaw has a good progression for a simple game design in [Learn Python the Hard Way](http://learnpythonthehardway.org/index). You can easily reuse his problems for Ruby if you like. He definitely helps you pick out the simplest pieces first and then iterate through successively more impressive versions of your own design.
I don't like the default layout and there doesn't seem to be any way to fix it. In netbeans I have my left pane full-height, split halfway with the project browser view on top and the outline view on bottom. The bottom pane stretches from where the left pane ends. Like so: +-----------------------+ | | | | | | | | | | | | | | | | | | | |-----------------| | | | | | | +-----------------------+ RubyMine can't seem to do this - it's stuck like so: +-----------------------+ | | | | | | | | | | | | | | | | | | |-----------------------| | | | | +-----------------------+ This just bugs me. I need that extra vertical space to show the outline, and RubyMine eats it needlessly for log output and whatever is in the bottom pane. 
it's not always about scaling up, mongoid for example has nice things such as embeds rather than has_many. every document can reference any other without join tables everywhere.
And just when I thought I had something valuable to add, someone has already said it. 
I would try to look into some tutorials on OOD specifically in regards to games. If you can't find anything helpful, I would try and post this in [r/gamedev](http://reddit.com/r/gamedev), it seems to be a fairly active community and may have a little more insight into this specific question than r/ruby would. I do also agree with uzimonkey and try to hack your way through it. Theres not a more rewarding way to learn something new.
PyCharm does as well. I opened a bug/feature request for a more flexible layout. Maybe they will change it. Edit: I just looked and it got re-assigned to the IDEA team which PyCharm and RubyMine flow out of. So somebody is looking into it.
Play with gosu, there are plenty of examples of games on github. Here is my playing around with it: https://github.com/tjbladez/gosu-rpg-concepts I have implemented following: * Animated sprites * Map scrolling and dynamic loading * Game's protagonist with sets of RPG characteristics (hp, mana, exp etc) * Simple level modification / construction / object spawning * Protagonist collision detection * Multi layer static map building * Sample enemy * Static monster with line of sight detection and spell construction * Spell reloading time * Spell collision detection * Sample items (potions etc) * Song loading Code is not in the most clean state as this was done 1.5+ years ago since when I learned a lot (it is a continuous process)
you can't learn from your mistakes until you make them. My suggestion: just plow ahead adding features, keeping a laser focus on *improving the game*, not on jerking around with the design. Once you figure out that you screwed the pooch somewhere, go back and fix it *as simply as possible*. DO NOT FIX EVERYTHING: fix only what you need to to get the next feature running. Rinse and repeat until you have a game reasonably close to the features you wanted. Then go back and write another, with the experience you gained the first time.
[Chingu](http://ippa.se/chingu) is a fun engine that builds on Gosu, if you'd like to try something like that.
I'm not arguing with you - I just want to clarify. They mean exactly the same thing, but their intended useage is in control flow, not boolean operations. Using the word versions because they make things pretty and easy to read is a great way to make confusing bugs for yourself later on down the road. I hate diving into some newb's code that has them used in random places without really understanding what they were doing. Think of it this way: if you_have_bacon &amp;&amp; you_have_bread # I'm a boolean! make_a_sandwich and eat_it # I'm some ordered actions! end Throwing `and` and `or` around randomly is going to lead to pain and suffering later in your maintenance cycle.
My RubyConf 2010 session was on writing games using Gosu. It wasn't on the features of Gosu, but rather on the process of writing a game from start to finish. Here is my repo: https://github.com/blowmage/ZOMG_GAMES Unfortunately, the video hasn't been released by Confreaks, and the minimal slides I used are not useful by themselves. IMO the best way to read the code is to look at the commits chronologically. They show the progression of my presentation. https://github.com/blowmage/ZOMG_GAMES/commits/master Hopefully the video will be posted soon. Or maybe I'll create a screencast out of it.
So write better tests. I still prefer `and/or`. Your code would work fine either way. The only place it bites me is in assignments because `and/or` binds higher than `=`. 
Nope, sorry. Not gonna help you on this one. My first programming project was a MUD. And you know what? I did it on my own. And you know what? It FAILED. It was a COMPLETE and UTTER failure. It never got anywhere. Shit didn't work. It was overly complex. It was SLOW. It took forever to learn to do anything. I asked the mailing list for help when I could (like using ActiveRecord outside of Rails). I learned untold amounts from it, which is why I think you should build it on your own and expect failure.
so what exactly is the goal here?
Personally I'm a little bit torn. I like Netbeans for larger projects, and somewhat liked the ruby/jruby support. I'm in the middle of seeing if I can wrap my head around the gargantuan that is Eclipse, in part because just how I'm increasingly skeptical of Oracle in general (e.g., the Hudson/Jenkins debacle). This announcement is nice, at least for the short term for me.
To have your tests running your code within the environment they are expected to run within.
how is it better than authlogic, devise and the likes?
You're doing Conway's Game of Life? Do you really need a two dimensional array of objects? Couldn't they be linked lists of some kind, holding references to each other, thus defining an infinite grid. In a two dimensional array you could get the index of the current object, and do (x-1)..(x+1) and (y-1)..(y+1).
keeping in mind that this is only 0.1.1 version of the gem, I think it offers all the basics while still offering some options that I didn't find in any of the others. Authlogic looks abandoned by the list of open issues, and Devise seemed too big &amp; complex for my needs. I hope I've made something that is both useful and easy to hack. All the beyond basic stuff will come later so the goal is to give all the extra features without losing simplicity.
&gt; I’ve got many plans which include: &gt; &gt;Basic HTTP Authentication ಠ_ಠ
heh, you're right, that is funny... it's the next feature on the todo list.
Here's a full features list by module: Core: * login/logout, optional redirect on login to where the user tried to reach before, configurable redirect for non-logged-in users. * password encryption, algorithms: bcrypt(default), md5, sha1, sha256, sha512, aes256, custom(yours!), none. Configurable stretches and salt. * configurable attribute names for username, password and email. User Activation: * User activation by email with optional success email. * configurable attribute names. * configurable mailer. * Optionally prevent active users to login. Password Reset: * Reset password with email verification. * configurable mailer, method name, and attribute name. Remember Me: * Remember me with configurable expiration. * configurable attribute names. Session Timeout: * Configurable session timeout. * Optionally session timeout will be calculated from last user action. Brute Force Protection: * Brute force login hammering protection. * configurable logins before ban, logins within time period before ban, ban time and ban action. Other: * Modular design, load only the modules you need. * 100% TDD'd code, 100% test coverage.
Sorcery code looks qualitative indeed. Anyway I really regret authlogic is abandoned. It seems that sorcery has similar concepts. I don't want to discourage you but don't you feel it would be better if someone (maybe you) started maintaining authlogic again? Even fork it and release under different name but with the same codebase and tests. It's proven, stable and well-opinionated. So why waste time and reinvent the wheel? 
I get your point completely. However, I took the decision to reinvent the wheel because I either didn't like the existing wheels (some key design choices) or felt the code was too difficult for me to read/understand. It (sorcery) was also (or mainly) a way for me to challenge myself. 
Free conference, great weather and all in the happiest place on earth! I'm currently watching a presentation on Cucumber, looking forward to the geo presentation coming up next.
I really think you should be using Devise no matter what. But kudos on your open source contribution, much appreciated.
There are two reasons, actually. One, as Rudy said, is to make sure your tests are executing the same code path that your app does. This gives you the best possible coverage, and therefore the best possible confidence that your code is solid. Two, there are some EM drivers that don't automatically fallback to a non-EM code path. I think em_postgresql is like this. Definitely the support for EM within the Thrift gem is like this. In those cases, you either can't run tests (not an option), or you have to individually wrap each test in an EM reactor (not very pretty).
Looks a lot like the feature set of Devise.
I wish I could be there! Sunshine AND Ruby! But alas, I'm wading through mountains of snow in the frigid north. 
http://rubygems.org/gems/uri-query_params
&gt; with a strong interest in performance, scalability, security and search engine optimisation. Really? Search engine optimisation? At the end of that list, this just looks soo wrong. &gt; I love boxing, martial arts No offense. 
LOL, you're right. Not exactly the best keywords given the topics :D
This has me itching to rewrite my Resume.
You my friend are a geek and awesome. Thanks for sharing!
You spelled initialize wrong :o
Clearly, you are a liar. EDIT: In case it wasn't obvious, we know each other and that was a joke :p
Good sir I would never lie to you. 
Just an upvote for... oh not lying.
 update_to ruby1_9: :hash_syntax :-)
*Obviously* the CV is Sinatra app.
Honesty Pays! Sometimes.
I wrote a similar geeky resume awhile back, http://tagaholic.me/resume.html inspired by http://macournoyer.com/blog/2010/02/23/how-to-apply-to-a-job/
&gt; Whether or not you can get away with using super instead of alias_method_chain depends on where the method you’re trying to modify was originally defined. Was it defined In the class itself, or in a module that was included into the class? I think this translates to: &gt; Whether or not you can use super depends on if the method you're trying to modify was implemented in a sensible way or if the class was attacked by architecture astronauts. I haven't seen a good reason to break a class's implementation up across so many modules the way rails has in the past. The modules are never used separately so I don't know why the classes aren't reopened instead. This would remove any need for super or alias_method_chain in rails in most instances.
Submit this shit to stackoverflow, not the ruby reddit. Next time you do this i'll ban you from this subreddit. The ruby reddit is not noob question time, thanks.
First and foremost, you're not even a moderator. Good luck with that. Secondly, after looking into the other "questions" in this subreddit, it seems I was wrong in thinking asking questions was common place here. I'll take r/Programming's advice and go to r/learnprogramming instead of posting these here. 
Trailing whitespace, ugh. Doesn't run on 1.9.2-p136: &gt; resumé.rb:86: invalid multibyte char (US-ASCII) &gt; resumé.rb:83: syntax error, unexpected $end, expecting tSTRING_CONTENT or tSTRING_DBEG or tSTRING_DVAR or tSTRING_END Adding # coding: utf-8 fixes that bug but gives: &gt; [...] Unknown key(s): through (ArgumentError) &gt; [...] &gt; from [...] in `has_and_belongs_to_many' &gt; from resumé.rb:57 You're probably looking to use a join model instead. ::included with class &lt;&lt; base? ugh. Just use #extend and ::extended to do the same thing. I'm not sure why Skills is extended atop VitoBotta twice. You don't need begin/end as the first thing in a method. Use the default one, def m() ...; rescue; ... end rescuing Exception looks like a bad thing to do here, especially since returning and Array.new and push don't raise exceptions (unless you're out of memory which means rescue Exception probably won't save you). returning? completely unnecessary. Never use it, it's always more typing and slower due to the extra method and block activation. Array.new? Just ["Further develop ...", "Have fun ..."] will suffice. ::inspect gives a warning: &gt; resumé.rb:82: warning: assigned but unused variable - who &lt;&lt;-ME would probably be more clear method_missing without super? method_missing without respond_to? not good. It would be better to define references? and questions? instead. 
Please revise the word "spam".
That'd do it!
banned.
What do you mean, exactly? Can you give some code? 'cause I'm not sure exactly what you mean by "translating the array's two parameters into variables within an object."
I figured it out, in a sense. What I needed was to determine the indices of objects within a double scripted array (or 2 dimensional, as seems to be the more common way of referring to them) and it wasn't even an hour after posting this question that I realized that all I was going to do was scan across the arrays for occupying objects no matter what methods I was going to use. In other words, I was always going to default to doing a straight-forward search ([0][0], [0][1], [0][2], etc...) anyway, so over-complicating things by trying to store the indexes of the array into each occupying object itself would be pointless at the moment. 
Basic HTTP Authentication is now in 0.1.3
Ohh, I see! I mean, if you wanted to, you could always just store the coordinates in the objects themselves, then store the objects in a flat array, if you're only searching them linearly. That way, your run-time is linear with the number of stored objects, and not constant with the size of the array. (of course, the trade-off is in speed for looking up a particular subelement, so if you do ever need to do that, don't use my suggestion!)
I think it fits the definition of blog-spam. It doesn't actually say anything useful and just link to the actual project. Maybe if this was a cool use-case or good tutorial, but not just a few paragraphs and then a link to the actual code and docs.
For example, in Rails, 3 breaking ActionController functionality into modules mean you can create your customized version of ActionController that is more lightweight and only have your desired functions. 
This would be awesome as a git repo; imagine, a versioned CV. I think every programmer should do this?
Where are the tests?
hello mate, don't look strictly at the code, I wrote it just for fun in a few minutes and you may have noticed that I have also used the older Rails 2.x's AR syntax as it sounded better :D ("validates_presence_of" ...) So, as it is, the code does work with Ruby 1.8.x and Rails 2.x gems. Maybe I could add Ruby version detection and change stuff.. LOL It was just to joke between Ruby and the natural, English language. See the "include Experience", "extend Skills", etc. The same for the "objs.push" with the returning block. It was just a joke with the words. I will try to "push" those objectives and if I fail (the "rescue"), "TODO: " is "retry harder" :D So of course I wouldn't use that kind of syntax for a real application. About the method_missing thing, LOL. I think you kind of missed the point here :D BTW I will update the code when I have a min so it works with Ruby 1.9.x and AR 3 too :D 
hey cldwalker, I jumped to look at yours curious as I am but I got a "page not found"? @jaryl, @bcardarella: lol For the versioning sounds reasonable, for the tests... Uhm I have first to find out how to test myself! 
You can use super in the case of a module, but not in the case of a class having the method defined on itself (at least until we see Module#prepend implemented). Reopening the classes as you suggest would mean that unless I wanted to define a completely alternate implementation of a method, and in the meantime, trample over anyone else's customizations with no fallback, I'd be resorting to a_m_c.
I bet you're fun at parties! :P
I understand that it's cute and clever and enjoy that. If I were looking at this as someone interviewing you I'd point out all these things in an interview in order to gauge your responses. Having a CV in ruby gives me an indication of your coding style, habits and understanding of ruby. I think that you would do well.
Most of rails has been broken into modules the entire time, so this should be possible with rails 2 also. Still, you could do this by dividing the functionality by file not module for the same effect.
I wrote ruby for years before rails and didn't need alias_method_chain. Rails uses modules to dump functionality into a class to create a giant class that can only be extended by alias_method_chain. With better architecture super would suffice.
We're not going to a party though, we're hiring rubyists! Based on Vto's response above I think Vito would do fine in an interview where I would note all these problems.
Rails 3 is presented by the Rails team to be the first version to really modularize each functionality, though. Previously it looked like it was modularize but you could not really mix and match features. Look at features `Enumerable` module provides. How would you do it with just class reopening?
I think it's a cool idea and well-executed. Be prepared to have it analyzed ad nauseum, as drbrain points out. 
updated, the comma after it was messing it up
If I were you I would see if the folks at omniauth will let you contribute your code to their project. Right now omniauth is good but doesn't handle password authentication (what? Really? are you fucking serious?). It handles everything else but not passwords. Integrating it with devise or what have you is a royal pain in the ass too. 
looks cool :D
I'm actually going to see if I can integrate omniauth into sorcery in a way that will not be a PITA for the user.
I don't mean to be disagreeable, but I think you're misunderstanding how modules work. If all the functionality were included into the class by modules, then alias_method_chain wouldn't be needed, and super would work. It's precisely classes like ActiveRecord::Base have certain methods defined inside the class instead of via modules that including a new module via a plugin is unable to "get out in front" of the method call and catch it before the class itself responds -- this is the whole subject of the article -- explaining precisely this behavior. It's not a Rails thing, but a Ruby thing.
That would give your library an edge over others such as devise. I would also like to make one feature request. Create a task called "sourcery:nomagic" which would dump every view, controller, lib, model etc into the app so I can know what the code is doing and modify it if I want. better yet sourcery:reveal_views sourcery:reveal_controllers etc. 
There are no views, controllers, models, migrations etc in sorcery :) It's more like Authlogic than Devise in that sense. My gem aims to give you an easy API to write authentication code in your own controllers and models, with the least code as possible. For example to login in a controller, you use: login(username,password). To define session timeout of 30 minutes you would add this to config/application.rb: config.sorcery.session_timeout 30.minutes Also you can give the gem your mailer object, and it will call it automatically when a user registers or activates. etc etc... edit: there is an example app linked from the main repo, where you can see how I'm using it in a 'real' app.
In that case I suggest you write some generators to create those controllers for you. I know that's lazy and that I should probably do that so take a mere suggestion. Anyway if you get it integrated with omniauth I'll probably try it on my next app.
How is this working out for you so far?
No, I've been writing ruby for quite a while now. I assure you I know how modules work and why doing things the way Rails chose is wrong and why alias_method_chain was created as a band-aid to fix their bad idea. Rails has a history of poor engineering patched over by band-aids instead of proper solutions. This is one of those situations.
http://en.wikipedia.org/wiki/R-tree See peano for simple 2d indexing http://people.csail.mit.edu/jaffer/Geometry/PSFC Indexing the surface of a sphere is a little trickier, but still pretty simple. Used a lot in GIS, see PostGIS for example. 
You don't need to write your CV in Ruby to keep it in a git repo. My resume is in LaTeX, and I've been keeping it in a git repo for a couple years now.
I never said to use Ruby, I think my statement would be language agnostic. Good on ya for using LaTeX and git!
So you want reddit to do a code review for you? Well, I'll say this: your gut is right, this is pretty damn ugly. It looks to me like this was coded by someone just learned about lambdas and blocks, and they can't wait to use them everywhere. First off: the method name, `help_with_node`. Right away this is a code smell. If you can't come up with a name that is descriptive and concise, that's a sign your method is trying to do too much. It looks like you tried to make the method generic enough to be used for parsing almost any xml document, but then you've got some overly specific shit in there, specifically `if node.first['state'] == "ok"`. I would recommend breaking this into two methods, something like:`get_node` and `parse_node`, each method taking only one block. `get_node` will make an http request to the specified url, parse it with nokogiri, and yield the document. `parse_node` will take a node as its argument, perhaps check the 'state' if that's critical, and then yield the node that is passed in. Honestly though, you probably don't even need the `parse_node` method, just work with the node directly once you've called `get_node`. It would basically be one line of code to replicate your example: node.present? &amp;&amp; node.first['state'] == "ok" ? node.children.collect(&amp;:inner_html) : false This also keep your specific application logic (checking if node.first['state'] == 'ok') out of your helpers. I don't want to sound like a jerk, but this is just really ugly. Imagine yourself looking at this code in 2 months and trying to figure out what the hell it's doing - you want to make your future self's life as easy as possible. That said, I'm glad you're trying to get better, and it's a good sign that you recognized it could be cleaner.
&gt; But more importantly, it's also just a great way to relax and let out our creative sides – and relaxed, creative programmers means more great Shopify features for you. Fucking A
Well, the story is a little less fail than that. 9AM in the morning, pretty sure it smelled but too zoned to figure it out. Replaced it like this: def get_node(url, method = :get) response = Net::HTTP.public_send(method) document = Nokogiri::XML(response) yield document end Helpers.get_node(url) do |document| node = document.search("search") node['state'] &amp;&amp; node.present? ? some stuff :false end Thanks for the reply!
If you are of the opinion that including functionality to a class via modules forces you to wrap methods using a_m_c instead of super, then you don't understand how modules (or the ruby inheritance model) work. I'm not sure why I'm debating this. Just try the example code in the article for yourself. See how including a method via a module instead of coding it in the class itself allows future modules to easily modify the method's behavior. 
Holy crap. I wish I had *friends* that would build such a cool minecraft world with me, much less *coworkers*. That would be nifty. Must have taken a lot of time and planning though. 
No, adding functionality to classes through modules in a way that requires the use of alias_method_chain is wrong. It's bad engineering. Don't do it. Ever. There's a reason alias_method_chain didn't exist before rails. There's a reason alias_method_chain hasn't been added to ruby itself. There's a reason I've never used it in over 80 gems I've released or made major contributions to. There's a reason Carl and Yehuda don't want you to use it. It's because someone has done something wrong and it needs to be fixed the right way. If you think you need alias_method_chain you probably don't understand object-oriented design as well as you should. Look at the way modules are used in ruby itself, they add functionality to a class by calling a predetermined method on the class such as #each for Enumerable and #&lt;=&gt; for Comparable. It's unfortunate that the damage has spread so far in Rails that it's become a named pattern. With properly factored classes and APIs providing good hooks for extensibility and customization alias_method_chain wouldn't exist.
AFAIK, there's been very little planning going on. Everyone pretty much builds what they want, where they want, and respects other people's creations. I imagine there's a lot of informal "hey, build some stuff in my town" teamwork, and people will often extend or improve someone else's work, but it's all pretty ad hoc. (It does help that one of our guys has his roommates building stuff, so they can coordinate a little there.)
Well, we know about this for five days. http://www.reddit.com/r/ruby/comments/fdvlc/jruby_team_going_to_adopt_netbeans_ruby_plugin/
I give up. I'm not advocating for the use of a_m_c. I'm telling you that your explanation of how to avoid using it is backwards. If you define methods on the class, you can't wrap with super. If you include them into a class via a module (the same way Rails does for many methods) then they can be subsequently wrapped via super, because they're one notch up on the inheritance hierarchy.
Keep in mind, this is only necessary if your deploying user doesn't have the rights to restart God. If your deploying user has the right to restart God, this is introducing unnecessary complexity. Instead you can just define an after_deploy method: namespace :god do desc 'Restart the mongrel cluster' task :restart, :roles =&gt; :app do invoke_command "sudo god restart mongrels" end end And then to your deploy script add: after 'deploy:restart', 'god:restart' 
Perhaps I am missing something... why in the "Ruby" reddit?
Breaking!
Does god still have issues with bad memory leaks etc or has it improved? 
"Sorry, the page you're looking for couldn't be found" edit: it's working now
I was just thinking about this stuff today, thanks
I prefer Nokogiri. And Selector Gadget is a must: http://www.selectorgadget.com/ It's a bookmarklet that lets you select website elements (or pick elements to exclude), and it'll generate xpath/css selectors for you. 
This is certainly insteresting and it looks like there are going to be breaking changes in 3.1 which probably is going to effect things but... The article should also go into writing generators so the end user can override the views. While I am at it the rails team needs to take a hard look at apotomo/cells. They make a lot of sense and it would be great to be able to download widgets like you can download engines.
Firebug does this too, at least for XPath - just select an element and (I think) right-click, get XPath. I'm using chrome right now, so I don't know exactly.
Eat your hearts out
&gt; The key difference is that Parslet does not generate code to represent the parsing grammars you create as Treetop does - it works directly from rules defined using standard Ruby syntax (Treetop has its own Ruby-esque grammar language). Parslet's error messages are also significantly nicer than Treetop's when you inevitably run into trouble with your grammar as they're generated by Parslet itself and don't spring from Treetop's internally generated code. None of those comparisons are made on Parslet's site. I spoke to the author on IRC to dig into these points at the time and they were considered important because Treetop is the entrenched leader in this field. The graphic (which is not on the page you linked) was also chosen to illustrate the concept quickly. The word "spam" is wrong for the situation. It implies a malicious or overtly commercial intent and a lack of any original content - neither of which are true here. */r/ruby* doesn't say anything useful and just links to other sites but it isn't "spam." Thankfully we won't have to worry too much about these semantics in future. I'm quitting posting pure news to Ruby Inside because, well, nonsense like this for the last 5 years. Original content all the way from here out, baby!
Because it's by a company that uses Ruby. Coming tomorrow, a post about DHH's car collection.
This. I like this response. 
The problem is that you misunderstand how Rails uses modules, at least in the 2 series. Example: AR::Base defines #save. But AR::Base then goes on to include many modules to include new functionality. Those modules, such as the Validation module, then uses a_m_c to wrap #save with new functionality. How do you think it does that? By normal module inheritance? Of course not, that's impossible. It uses #included hooks. module Validations VALIDATIONS = %w( validate validate_on_create validate_on_update ) def self.included(base) # :nodoc: base.extend ClassMethods base.class_eval do alias_method_chain :save, :validation alias_method_chain :save!, :validation end base.send :include, ActiveSupport::Callbacks base.define_callbacks *VALIDATIONS end ... end That's straight out of the 2.3.5 source. activrecord/lib/active_record/validations.rb . If you hadn't been so dismissive, and actually read what incredibly knowledgable Rubyists like Eric Hodel had to say, you wouldn't have made such a fool of yourself. It would be polite of you to apologize for your harassment of someone who actually knew what they were talking about.
A few interesting tidbits, but what was with the ladies' "advices" ? They were pretty weak in comparison to the other bits IMO. IRB, RVM, Sinatra and Homebrew? That doesn't seem like advanced advice to me -- that seems like pretty common knowledge stuff. (granted, the IRB tips link was somewhat worthwhile). And the other female advice was to check out ruby-built apps and that it's unfair that ruby gets a bad wrap for being slow? *head scratch* Not even sure what to say there.
The nice thing about Selector Gadget is that it shows you everything else on the page that shares the xpath/css selector, so you know exactly what you're getting. When I was just using Firebug/Chrome Inspector, I'd sometimes find that I'm scraping some extra rogue ass element that I didn't see before.
Here, let me help you with this one: class Foo def some_method raise "not implemented" end end There. I just saved everyone else about 100 lines of code.
jruby++ I have used this on windows x64 and it(vagrant) was pretty cool.
Shut up and look at their boobs.
actually, the one aint too shabby
Oh, I see
Have an upboat.
RVM is integral to any system I provision, and Homebrew is my golden goose egg for Macs. People don't use Homebrew, but they really should. It's just phenomenal how easy it is to use and how much stuff it has. **edit**: But yeah, their advice was pretty weak. Same with Katz's "Refactor" advice. Nice reminder, but really, that's sorta like "No duh".
Good idea about the generators. I'll do a follow up about it. I haven't gotten around to cells yet. Have you used them a lot in your projects?
The internet cops won't be going away any time soon. Thanks for producing a great site Peter.
I thought and still believe that duck typing saves us from the building of such long winded nonsense? I do think that def some_method; raise "Not implemented"; end Is useful for communication purposes for when you havn't finsihed some piece of work somewhere in the green red cycle perhaps. Java should be written in a Java style, Ruby should be written in a ruby style, C++ should be written in a C++, etc, etc
i misread the title and thought that they were pro-tips. one person recommends IRB, srsly? here's my tip: aberant couldn't live without the puts method. he says, "it allows me to quickly inspect the state of objects and saves me time from implementing a full logging system"
This is exactly what I do when I need to build an interface for whatever reason. Why get all fancy with your abstract class when you're just going to muscle over it anyway?
Remember, Mashable is not a developer's blog. This was likely some very high level stuff with some code thrown in to whet appetites. The majority of people reading Mashable are likely not developers.
&gt;I haven't gotten around to cells yet. Have you used them a lot in your projects? No :( I keep meaning to "on my next project" but haven't gotten around to it. Somebody needs to combine erector with cells make something awesome though :)
[Here's](http://weblog.rubyonrails.org/2011/2/8/new-releases-2-3-11-and-3-0-4) a summary of what was fixed in this release.
Thanks! I was looking for something like that. Have an upvote!
"extra rogue ass element" is a great way to describe it. You are a cowboy indeed.
Related: http://macournoyer.com/blog/2010/02/23/how-to-apply-to-a-job/
This guy needs an editor. Granted there's some interesting stuff here --- but by god does the author need to learn how to be more concise. This post could be 1/3 the size and still communicate all the salient information. Good info --- just too verbose.
This snarky comment notwithstanding, Eric and I had a separate discussion via twitter a couple days ago where i believe we cleared up the misunderstanding (if he feels otherwise I'd be happy to respond here as well). For the record, I greatly appreciate Eric's contributions to the Ruby community. For those who come across this thread later, to summarize: we were discussing different things. Eric's comments were related primarily to historical use of modules in Rails (mostly 2.x versions, as a_m_c is used relatively sparingly in 3.x). &gt; I haven't seen a good reason to break a class's implementation up across so many modules the way rails has **in the past**. The modules are never used separately so I don't know why the classes aren't reopened instead. &gt; This would remove any need for super or alias_method_chain in rails in most instances. Had I seen the emphasis I added above, I'd have agreed. When I saw the mention of reopening classes instead, I thought he was discussing the article's topic, which was wrapping functionality, and suggesting it was better served by reopening classes. My comments, on the other hand, were regarding the topic addressed in the original article, a pragmatic look at when a_m_c might be necessitated (when a class's definition is out of your control) and why that is the case -- as well as how to use modules as they were originally intended in your own code to avoid the situation. When Rails was mentioned I was discussing it in its current state, not the 2.x branch. In short, we agree -- the perceived disagreement was a misunderstanding that we ironed out via Twitter, and one that should be abundantly clear to anyone who now reads back over the thread with this context in mind. For bobindashadows, if you read the above you'll hopefully see that your statement: &gt; The problem is that you misunderstand how Rails uses modules, at least in the 2 series. was similarly dismissive of me, and that we both "knew what [we] were talking about." Misunderstandings happen. I'm sorry that they happened, in this case. If the above comment thread has made a fool of me, then it's only done so in the eyes of those who can't see an honest misunderstanding for what it was.
I must admit that when I posted the link to that CV I thought of course that it would make some coders smile, but I was surprised to see literally thousands of visits already in the first few hours, backlinks from other sites, people sharing it on social networks and so on. I received several connect requests via Linkedin, quite many nice comments via the blog, with many of them also from recruiters or CTOs about job opportunities also in the US and other countries! 
That's so cool - the link had already been posted though :)
Why isn't your Rails app already RESTful? It should just be a matter of adding response formats for json and xml.
This. You're going to overcomplicate things by adding another app. Hopefully your controllers are already based on resources so all you should need to do is add some additional formats to your respond_to blocks and maybe add token based authentication to your user system.
Use your exiting controllers within your rails app to provide the appropriate response type (json, xml, whatever).
Is this a trick question? Rails does REST out of the box.
I'm puzzled by how many people create other *apps* or namespaces. Wasn't the whole idea of RESTful APIs to code the API as you code the app. But then, maybe the API has to be different and needs to be more stable.
I suspect they may want to separate the public API, using developer api_keys etc to authenticate. The fact that your controllers are RESTful doesn't mean that your application can/should be the API. For example, a hypothetical imgur-like web application: the API interface (I know I'm being redundant) is not necessarily how the site itself is used.
We've used Rails itself, but made a separate namespace and controllers for the API itself. This has allowed us to plan for versioning and a translation layer from another service.
This! Often the way you want to structure your API doesn't match with the way you've structured your pages. I would stay in the Rails world and namespace a bunch of new controllers with an API version in the route and build a new set from scratch there. That way the site and the API are independent, you can release new versions without affecting the old ones, and you still get all the goodness of Rails and ActiveRecord which I think you might miss if you went anywhere else. Grape and Apiary are interesting but totally unproven and brand spanking new technologies. I would stay away unless this is just a pet project, simply because you don't know if anyone will be using them in 6 months. You might get stuck trying to do something the library doesn't support and maintaining it on your own after everyone else has moved on to the new latest and greatest turn-any-object-into-an-api plugin. Stick with Rails or Sinatra which you know people will be using 6 months from now and will be well maintained.
I'd just use Rails itself. Reason being - if you have multiple apps touching the database and their logic gets out of sync you run the risk of different application behaviors affecting your data in different ways. For example, say you have a model that is shared between the two applications. You add a callback on one of the applications that will convert text in a given field to lowercase. In your API application, it doesn't do this. Now you have a problem because the data coming in/out of your database is being treated differently between the applications. In the real world, there are times where your application is going to need to break away from REST in order to accomplish your business requirements. You gotta do what you gotta do. You could also use a Sinatra, Grape, etc application that is inside of your Rails application. That mostly comes down to personal preference and style. You don't save any memory by doing that. At best you'd save some processing time since you no longer need to hit the Rails stack to fulfill the request.
I don't understand why this isn't at the top. This is the way you should do APIs that people actually use.
Explicit block parameters are less than ideal - use implicit blocks and Proc.new with no argument if you want to retrieve the block. def foo(&amp;block) some_method(&amp;block) end becomes def foo some_method(&amp;Proc.new) end Also I'm not such a huge fan of method missing, though you are doing it correctly with 'respond_to'.
Try out [grape](https://github.com/intridea/grape). For the API, you don't always want to load the full stack. C'mon, guys.
You mean Postgres, not Postgre. You can machine document with OPTIONS and hypermedia.
But there's often not a 1:1 correlation between restful "pages" of your app and restful API needed. I strongly prefer having an api/ directory under controllers with the correct api related logic. (token auth, right structure, etc). 
Whatever option you choose, be sure only one app actually talks to the database. Theoretically, you *could* have multiple apps speak directly to the database, but the reality is that you'll quickly run into situations where your business logic was slightly different in one app than the other, and unwanted/invalid data will sneak into the DB. Practically, its just more headache than its worth. A common approach is to have a lightweight sinatra API, and use activeresource or somesuch to hit that API from a Rails app. You could do so on Heroku without much fuss, assuming your app is not abnormally high-traffic. This has the added benefit of forcing you to dogfood your API, so you'll be mighty confident you like the way it is set up if it is the only way you can reach your DB. One note: Be sure you mind your caching headers when returning data from the API when behind a reverse proxy, like on Heroku.
I've always been under the impression that if there _isn't_ a 1:1 correlation, you've design poorly. What would be a scenario where this isn't the case?
One scenario might be when you want to expose a unique view of data that doesn't correlate to any normal use of the application.
I like the explicit block param. It tells me a block is required. I think it's a perfectly good thing to do when the desired behavior is to require a block. edit: I just noticed [blocks in ruby without block](http://mudge.github.com/2011/01/26/passing-blocks-in-ruby-without-block.html), and it seems a little too idiomatic to use Proc.new this way.
Why wouldn't just just create a new controller for that with the corresponding xml formats?
&gt; say you have a model that is shared between the two applications A little unrelated to the OP, but I've successfully managed to get around this, by wrapping my regular models up under a module, and putting these in a `/shared` directory, which get `require`d in an initializer. /shared/models/person_shared.rb: module Shared class Person &lt; ActiveRecord::Base # regular model code ... Then, I have a corresponding model in the regular directory, with the only difference you inherit from `Shared::Person` instead of `ActiveRecord::Base`: /app/models/person.rb: class Person &lt; Shared::Person # any application-specific code here end `/shared` is then checked into my version control, so any changes can be easily updated across applications. This works for shared config, helpers and tests too (in sometimes slightly different ways, though).
With a quick glance at lib/thwart.rb and lib/thwart/dsl.rb, I would probably do a few things differently. * In the configure method I don't like the evaluate, which eventually becomes an instance_eval; rather, call the block with the context of self. * I see lots of things named what they are, not how they're used, e.g. dsl. What exactly does "dsl.all" mean? It means nothing to me. Another example is "extra_methods". * I see lots of attributes set to false or nil after instance initialization. This is a code smell and should probably be done at initialization. * Constants probably shouldn't be set to initialized classes, e.g. "Roles = RoleRegistry.new" The general convention is to make constants all upcase as well, assuming a constant was the goal. You should probably use an extend for attributes included in the Thwart module for: Actions, Actionables, Roles. * I don't like how you rewrote respond_to? Big no-no here. * You don't have to explicitly prefix everything for self, use it only to disambiguate local scope variable assignments from instance method calls. Start by removing "self" from all method calls which don't have a suffix of "=" or have a reserved name, like "class". Overall, you're doing a good job. Refinement and peer review are things everyone should do. You're on your way to ruby master sergeant master first class. Level up! edit: if you're going to redef respond_to?, you should alias the original before replacing it.
I wouldn't namespace models, given your reasoning. If trying to share models, I'd add another .rb in /models which requires certain models as a group (e.g. models/_shared.rb), only i'd use a more meaningful name than "shared". If you're worried about name conflicts then consider namespacing all your models per application (yes total PITA).
I suspect your bug is in the part where you call Node.new(), not in the Node class that you show here.
You can, of course, I was answering your question about how a 1:1 situation can come around.
I call node.new while iterating through an array of Flight objects using an each block. Just before I call Node.new, i did puts new_flight.class (the parameter i use to call Node.new), and it prints "Flight". 
In my situation, the shared code needs to be in a separate directory in order for them to be linked in with svn as an external. 
show us the block of code where you are iterating and calling Node.new
I disagree. The only time I'd use Proc.new this way is if the method didn't use the block every call and after benchmarking to make sure the explicit block actually caused a performance hit.
 curr_level.each{ |node| flights_out[node.name].each{ |flight| new_name = flight.get_dst new_flight = flight.clone new_one = Node.new(new_name, new_flight) if (node.is_valid_child(new_one) &amp;&amp; ( (node.name != dst) || (level == num_conn) )) then node.add_child(new_one) next_level.push(new_one) end } }
I posted it. I think the problem might be in having an instance variable of the Node class being something I declared. When I "puts" the class of all the instance variables of a instance of Node inside one of the methods, ones such as "String, Fixnum, etc" show up, but anything I've defined shows up as Nilclass. I guess I just havent run into any other problems using these instance variables
It shouldn't matter. I do that all the time - having instance variables be types I defined. I can't see anything wrong with the code above. Try it in a debugger or line by line in irb.
you should look into the common ruby community code styles. Seriously no offence intended, but instead to help you if you wish to learn more about ruby: the code you posted is some of the most un-rubyish looking ruby I've seen in a while. Some tips, if you don't mind me offering them: * For multi-line blocks, using `do`/`end` is considered cleaner and more beautiful (and like-wise using `{}` for single-line blocks) * `node.is_valid_child` will usually be written as `node.valid_child?` as `valid_child?` is a valid ruby method name. * Putting `then` at the end of an if statement is not-necessary and I can't remember the last time I ever saw someone use it. * Rubyists prefer more explicit variable and method names that are clear and self-documenting in their purpose. e.g. `get_dst` -&gt; `get_destination` (though in reality, we don't like get/set at front of names either so just `destination` is better), `curr_level` -&gt; `current_level`, `new_one` -&gt; new what? `node`? ... etc. * `next_level.push(new_one)` usually looks nicer as `next_level &lt;&lt; new_one`, but that's a pretty minor point as either could be used As to your actual problem, try calling `flight.dup` instead of `flight.clone`. If your `new_flight` is `nil`, I suspect that the object is somehow uncloneable. EDIT: code formatting
Thanks for all the advice. I appreciate anyone who's willing to help. And as for the "then" thing, you can blame my professor for that. I was told Ruby forces the then on all if statements. As you can probably tell, I'm coming to Ruby from C/C++ so a lot of the style I developed from that carried over.
Thanks guys. It would up being a bug that's completely unrelated. I was just creating a Node with a nil Flight as the root, and forgot to check for whether the node i was calling a Flight method on was the root or not XD.
He doesn't use the block every iteration. He's using block_given? to detect and invoke a special case to pass through - so I would say the explicit block is less useful.
The block in the methods I was looking at was not required. It was detected and invoked with block_given? as an option. So no, I don't think it was the right choice in this case.
Yeah when you first pasted it, I thought it *was* C code, and you were showing what you were trying to port to Ruby. Then I read it again. Your professor is simply wrong about the 'then' component, maybe he was thinking of something else. The only time then is useful is if you put the if statement on one line such as: `if foo? then do.something!` but no one does that anyway. If you want one line, this looks much nicer and is more-used by Rubyists: `do.something! if foo?`
Your example lacks this. I figured you would have appended "if block_given?" if that's what you meant. Regardless, the &amp;Proc.new deal is a bit too idiomatic for my liking, and Ruby is my primary language. In the case you describe, the best solution would simply be for him to remove the &amp;block param and leave the rest of the code as is, e.g.: def foo some_method {yield} if block_given? end 
Yeah, that's really interesting. It sounds really nice because it's now super easy to make blocks optional (assuming Proc.new will default to Proc.new {} if no block is supplied).
That doesn't work. The block may have block parameters, which would be ignored by your example. Trust me, I've tried a bunch of different ways. Example code: ree-1.8.7-2010.02 :001 &gt; def foo ree-1.8.7-2010.02 :002?&gt; bar { yield } ree-1.8.7-2010.02 :003?&gt; end =&gt; nil ree-1.8.7-2010.02 :004 &gt; def bar ree-1.8.7-2010.02 :005?&gt; yield(1, 2) ree-1.8.7-2010.02 :006?&gt; end =&gt; nil ree-1.8.7-2010.02 :007 &gt; foo {|x, y| puts x; puts y; } nil nil =&gt; nil ree-1.8.7-2010.02 :008 &gt; bar {|x, y| puts x; puts y; } 1 2 =&gt; nil ree-1.8.7-2010.02 :010 &gt; def foo ree-1.8.7-2010.02 :011?&gt; bar(&amp;Proc.new) ree-1.8.7-2010.02 :012?&gt; end =&gt; nil ree-1.8.7-2010.02 :013 &gt; foo {|x, y| puts x; puts y; } 1 2 =&gt; nil 
Nope, it raises an ArgumentError. You should only use a blockless Proc.new inside an 'if block_given?' statement.
Well then... that's just stupid.
I prefer explicitness, generally. I would use the explicit block all the time if it were not much, MUCH slower and more memory intensive.
I already live here, so I'll probably see you!
Looks like there's an [Object#respond_to_missing?](http://www.ruby-doc.org/core/classes/Object.html#M001006) method now
I believe the convention is to only use &amp;block when you need to pass it along to another method, otherwise use block_given? and yield.
Exactly this! 
&gt;I see lots of attributes set to false or nil after instance initialization. This is a code smell and should probably be done at initialization. Code smell? [Ok looked that up](http://en.wikipedia.org/wiki/Code_smell). Still would like to hear more. Is it just that it's clearer to read if you have all the necessary vars set in #initialize? Or does it signal something else is being done poorly?
Do they mean plane tickets or just the conference ticket?
I think conference tickets.
awesome! I'll be there hustling for my startup [HangWith.me](http://hangwith.me). See you there!
Whatever except ActiveRecord's default XML serialization. It's buggy as fuck.
Miami this time of year is so worth it, though. I ran the air conditioning on Monday, but since then I have had the windows open on account od how beautiful it is. 
See I would have done it the other way around... I'd have put the same model in both apps with a shared directory that has the meat and potatos. Then I'd just include the module in both places. Unfortunately, under high traffic, you still have situations where if your apps reboot out of sync there might be blips of inconsistent data.
The thing I miss most when using textmate is VCS integration. RubyMine will show you which lines have been added, deleted, or modified with colors in the gutter next to the line numbers. I can very quickly and easily get a diff and what not from head, etc. 
Trading off safety for speed seems foolish to me. Why not switch to something like rabbitmq? 
You shouldn't rely on your messaging queue to maintain state of jobs. You should only rely on your messaging queue for sending and receiving messages. If something explodes in the middle, your application should be able to recover. Suggesting rabbitmq when you don't know their system requirements is silly. Rabbitmq falls over with enormous amounts of jobs in queue and I've yet to see that happen with Redis.
That would work; but I was hoping for a way that wouldn't require changing any config files (like, I could just run this server, and then ssh on port 8888 to this program, but I could still ssh as normal on port 22). Right now the only solution I can think to do this is to run a program client side, rather than being able to do everything server side (which was my goal)
Thank you for that. Very nice little guide.
&gt;You shouldn't rely on your messaging queue to maintain state of jobs. OK. &gt;You should only rely on your messaging queue for sending and receiving messages. OK. &gt;Suggesting rabbitmq when you don't know their system requirements is silly. What could their system requirements be such that redis is suitable but not rabbitmq? &gt;Rabbitmq falls over with enormous amounts of jobs in queue and I've yet to see that happen with Redis. citation needed.
This is fucking stupid.
does the "Why would you ever want to use this?" example in the README not make sense?
No. This reminds me of one of those stupid 'abstract base class' implementations you see in ruby from time to time, or 'pure virtual function' which raise exceptions unless they're overidden. All of this shit is by people just migrating from java and clumsilytrying to reimplement java in ruby. EDIT: loll clicking on his github shows he actually HAS done an abtract_class implemention for ruby! hahahahahahahahahahaahahahahahhaha
Yea I was just about to post "well then you're definitely not gonna like this" hahaha. I think they serve their small purposes well. Never used java - I made that interface lib out of necessity while working on [https://github.com/shuber/nestable](https://github.com/shuber/nestable)
fascinating if true
ok sorry to be so harsh, i really do love you and wish you all the best
ah the source just hardcodes all the github workers' handles.. I was hoping for something more clever
appropriate username
though more clever would have been fun... I only had an hour :-)
You mean, like a shell? I'd suggest bash. Others would likely suggest zsh.
ask on stackoverflow.com
Someone should have installed wp-cache.
Check out hobo field
It depends on the ORM you use. with activerecord it's just the validation and relations that you specify in the model so that's not really going to push many migration changes. but with something like mongoid there are no migrations but the fields are specified in the model. if i am correct.
[Datamapper](http://datamapper.org/) allows you to define your fields in the model, and automatically generates the migrations when you modify them. However, it replaces ActiveRecord and may give you issues with non ORM-agnostic gems
If you're asking about Rails ActiveRecord, then no. ActiveRecord works vice-a-versa to what you're describing in that it determines it's attributes/properties by querying the database schema so the only way to add/remove a table column backed property is to modify the database in some way, preferably through migrations.
https://github.com/pjhyett/auto_migrations
Yes, after discussing this with a friend I see that I had things a bit backwards. It seems a bit odd to me to have the fields not listed in the models but do include the model relationships.
best job ad ever
note to self: capybara is awesome
That's a technical term.
http://www.unlimitednovelty.com/2009/04/twitter-blaming-ruby-for-their-mistakes.html scroll down to the comment from Nick about it. So the situation where you have large amounts of items in your queue and not enough workers to pick them off rapidly (peak times) is a situation redis can handle (in my experience) but it appears rabbit cannot. Having previously crushed a MySQL cluster using DelayedJob with a few workers and a ton of jobs in queue, that comment really hit home.
No matter how great it is I don't see it replacing will paginate any time soon. It's just supported by every other plugin out there.
&gt;http://www.unlimitednovelty.com/2009/04/twitter-blaming-ruby-for-their-mistakes.html scroll down to the comment from Nick about it. I did. Here is what he said. &gt;ActiveMQ, in persistent mode, was very slow. An order of magnitude slower than Kestrel. RabbitMQ was speedy but if you put in more messages than you had memory, it would run out of memory and crash. Since redis keeps the entire queue in memory it too would crash if you ran out of memory. In fact I can't think of too many programs that would not crash IF YOU RAN OUT OF MEMORY!!!!! &gt;So the situation where you have large amounts of items in your queue and not enough workers to pick them off rapidly (peak times) is a situation redis can handle (in my experience) but it appears rabbit cannot. IF YOU RUN OUT OF MEMORY. Why don't you try putting things into redit UNTIL YOU RUN OUT OF MEMORY and see what happens. &gt;Having previously crushed a MySQL cluster using DelayedJob with a few workers and a ton of jobs in queue, that comment really hit home. Actually mysql is your best bet http://yoshinorimatsunobu.blogspot.com/2010/10/using-mysql-as-nosql-story-for.html
It is nice, yes, but depending on the application your using it in, you can run into minor problems. In the docs, they say to "include Capybara" for your testing. However, both the application I was working on and Capybara shared a class named 'Node'. That caused some odd debugging sessions. After fixing the namespaces, all was good in the world again.
I created an interface library a long time ago as a proof of concept: gem install interface I've never used it in production, though. I don't think interfaces serve any useful function in a dynamic language with modules and mixins.
Good point, I find when setting up a test environment it's hell on earth, generally as soon as you pick up more and more libraries you get into odd and odder cases.
hobofields
Which OS? Probably makes a big difference. I know of win32screenshot for Windows but have no idea about other OSes.
If a developer did that on my team, I'd be pissed. That kind of monkeypatching just leads to misunderstandings. 
You could use jruby and access the java Robot class. checkout http://www.roseindia.net/tutorials/jruby/Swing-JRuby-Hello.shtml and http://download.oracle.com/javase/1.4.2/docs/api/java/awt/Robot.html
That's one hell of a sweet rollercoaster!
I warned that one have to be very careful when using that kind of tricks. I only encourage to open your mind and look beyond set patterns.
I dunno, I think it's pretty clear what the code is doing (at least, his final Kernel#is solution).
Typically, if you run out of memory, you swap to disk. Sure things bog down and run poorly and that is a problem... but it shouldn't flat out crash because its environment is hurting. I've actually had instances where the box Redis was on ran out of memory. It copes with it just fine. That plugin lets you use MySQL as a keyvalue store in that pkey lookups skip SQL parsing. It's nice and fast but it's not a redis substitute.
I really don't think I like that. You get a nice case statement, but at what cost? You horribly mangled your Symbol class, who knows what effect that will have on other code? Ruby can do all kinds of cool stuff like that, but should you actually do them for the sake of a slightly cleaner case statement?
If by "very careful" you mean, "don't ever do that in production code," we can agree. This is far too trivial a benefit to risk globally changing the behavior of a well known standard object. 
&gt;Since redis keeps the entire queue in memory it too would crash if you ran out of memory. &gt;In fact I can't think of too many programs that would not crash IF YOU RAN OUT OF MEMORY!!!!! I'm pretty sure this is basically saying that RabbitMQ uses ONLY memory for storage, and thus the queue size is bound by the available memory. I know for a fact that Redis is easily configurable (not sure about defaults) to flush to disk often (this is how it handles persistence) and so isn't upper bound by available memory. I've used redis in a production system for a while now (with queues hitting up to several hundred thousand at peak times daily), and if there's one thing it does well, it's holding large queues of data providing quick access with tiny memory/cpu usage. edit: actually read linked article now. I'm inclined to agree that persistence here is a little more important than to just increase the amount of data to lose in the event of a crash as a solution. It's not as bad as it could be given that this is a work queue, and not the application database, but personally I'd still much prefer if redis were able to write to disk and still accept additions to the queue (with new additions not being flushed to disk). Surely this is possible, even if it might take up a little more memory (essentially duplicating/freezing a snapshot of what's in the queue at a given point, and flushing the duplicate, while the original accepts new additions)
I've addressed your concerns [here](http://mlomnicki.com/ruby/tricks-and-quirks/2011/02/10/ruby-tricks2.html#comment-145338184) 
Cool as an example of what's possible, but a better way to do it would be to move the case statement into the context of the order, perhaps. Ideally in a method in the Order class, but you can also do: order.instance_eval do case when available? # ... end end Or, even better, have a method on Order that returns the state as a symbol: case order.state when :available then ... ... end
It's a shame wil isn't updated as often 
i chose radiant mostly because the community is very approachable and, to me (a noob), extending radiant is straight forward. 
I'm shortly switching to OSX. Maybe MacRuby has an answer.
https://github.com/svenfuchs/adva-cms2 looks promising.
Radiant is pretty straight forward and very extendable. You should try running it on Heroku.
Django? :) Not trolling just joking :) The truth is I started with Django and I couldn't get it, then I worked on 3-4 projects with Rails and Radiant and when I retried Django later, this experience made me understand it much easier. I am stuck to Django since then, for about 30 projects although now I am re-checking rails 3.0.
I'm curious -- in your experience, how much does Radiant end up informing your app design. That is to say, how do you find it hard to extend into new models and integrate them into Radiant? Do you often have to plan ahead in terms of how the rest of your models will integrate into Radiant or do you find the process to be pretty automatic? Traditionally, I've always just created a content controller, defined a few content pages, and given my client some textiled textfields to edit the page content. I have a new client project started soon and I'm considering Radient, but the client has some pretty big goals in terms of extra site functionality (tournament bracket type stuff) and I'm concerned it'll be more trouble than it's worth.
Curious to get your thoughts on this: http://www.reddit.com/r/ruby/comments/fk74p/a_good_ruby_rails_cms_anybody_care_to_share_their/c1gjlx9
+1 for Radiant, simple, extendable, powerful
I wonder, does it still make sense to carry on with 1.8.7 these days given the speed improvements of 1.9.2?
This one looks nice, I like it
have a look to http://locomotivecms.com/ (rails3 + mongoid)
I'm in the same boat you are in, needing to pick a CMS. My 5 minute play with Refinery gave me the initial impression it's too simplistic for what I want. I also tried searching for downloadable templates and couldn't find any reference to them, which is a shame.
Upvote for a Rails Engine that uses Devise
Looking at Refinery, it seems more about following Rails conventions. Their themes are just like Rails themes. But you're right, I can't find a gallery of themes. It seems you are expected to roll your own. But that's ok for me. I already have a common php theme that is already modular enough to port to any CMS. I'm more interested in the ease of extensibility and available modules (like blogging, galleries, user authentication).
https://copycopter.com/ looks like an interesting solution to the problem, let's you avoid running a CMS all together.
Speed isn't the only thing that matters. Lots of people are still on 1.8 for compatibility.
Zena CMS (http://zenadmin.org/en) looks promising and has just reached its first release candidate. I've yet to try it though but good feature set including image resizing/cropping, caching, user groups. I have given Refinery a go and was quite impressed. Currently I'm using my own CMS though, I find this the best way to add bespoke functionality. I'll have to check out Radiant at some time.
Pretty sure [netbeans](http://www.netbeans.org) does ruby... other more ruby-specific IDEs I've seen mentioned are [Arcadia](http://arcadia.rubyforge.org), [RubyMine](http://www.jetbrains.com/ruby), and [Aptana](http://www.aptana.com).
Netbeans is dropping ruby support. Also, OP, you may want to check out redcar.
Eclipse has dynamic language toolkit support for Ruby. If you like Eclipse, I suggest starting with it. NetBeans is great, free, and has community support to make up for Oracle. It's my preferred IDE for most Ruby projects. I like NetBeans because in my opinion it's good at "staying out of the way" and basic refactoring works quite well. RubyMine is the best commercial IDE in my opinion, especially for more significant refactoring, completions, and code exploration. It's my preferred IDE larger projects. 
I would look at Aptana. It is based on the Eclipse platform and the current Beta release adds support for Rails 3.
Pretty sure Netbeans is just dropping Rails support. 
Thank you. I'm going to try Aptana.
reminds me of http://get.harmonyapp.com/ (also in rails, but not open source) since they use mongodb too, and you can also create your own data types. Locomotive is very interesting.
Two books not mentioned: http://www.humblelittlerubybook.com/ http://beginningruby.org/
Radiant is pretty solid but I've been rocking RefineryCMS and I like it :)
Yes, but you may find that you do not need an IDE and a debugger.
There is Komodo IDE among others.
RubyMine, but if you're on a Mac, give TextMate and an open terminal window a shot first. 
ruby-debug
I second this, I find that irb and a set of unit tests gets me the quickest development in ruby.
I developed a tournament extension for Radiant for a fishing tournament and used it successfully. Very easy. The CMS handles the static text and images (and a blog) and my code responds to various routes like "/leaderboard," "/boats/new" and "/boats/top-boats." The code was a breeze to write. Successfully served 10,000 concurrent visitors on a 2048MB Slicehost VPS for one week a year.
The JRuby team has adopted the Ruby support for Netbeans. http://www.reddit.com/r/ruby/comments/fdvlc/jruby_team_going_to_adopt_netbeans_ruby_plugin/ http://markmail.org/message/r7fliknkieg7fnwq 
[See here](http://www.reddit.com/r/ruby/comments/fkbpt/is_there_a_ruby_ide_and_debugger/c1gks6m)
It was all of Ruby, but [the JRuby team will be continuing development for NetBeans support](http://markmail.org/message/r7fliknkieg7fnwq).
The latest version of Aptana has been in beta for a long time.
[RefineryCMS](http://github.com/resolve/refinerycms) is kicking right now. Community-wise they are fantastic too. Very active and approachable core developers. They go out of their way to help you...and RefineryCMS just surpasses Radiant as the most forked Ruby CMS.
We started using Radiant for a project at work but dumped it after looked like it could not handle some of the more complicated database backed content we have to deal with. We ended up going with http://www.browsercms.org/ and we've been happy with it so far.
Apparently, you're not so comfortable with Google.
They all suck. I hate to say this but it's true. They all suck. Not just CMS systems either. All rails blog engines suck. All rails ERP systems suck. All rails community software sucks. I have no real explanation for this. Maybe it's because PHP has a bigger community, maybe it's because rails makes it easier to roll your own than to contribute to something else, maybe it's because there are so many options for every category. If somebody has a theory as why there in nothing written in rails that comes even close to wordpress, drupal, joomla, sugarcrm, plone, modx etc please share because I'd love to know. How hard could be? Why hasn't ti been done? Is typo or radiant really the best we could do as a community? As for CMSs I have tried all of them. All the blog engines, all the CMS ones, all the "community ones". There are the ones I installed, tried to make work, and rejected for various reasons. refinery, skyline, zena, adva-cms, seed, browsercms, typo, ansuz, nesta, locomotive, webwiva. So if you want a decent CMS you are going to have to go with a java or a PHP based one. Plone is a behemoth so I am leaving that out of the mix too. 
zena is a very interesting project but it's probably aimed at developers. The interface is very confusing and I don't think your average power user can cope with it. I haven't tried the new release candidate yet but the old one was obtuse to say the least. 
using mongo is a double edged sword. On one had it's great that you can define your content types via the web interface and not worry about migrations. OTOH it requires a later version of mongodb which is not in the repositories so you have to install it by hand. It's also not quite finished and they don't have a mailing list. I am always wary of using anything that doesn't at least have a mailing list for support.
&gt;I'm pretty sure this is basically saying that RabbitMQ uses ONLY memory for storage, and thus the queue size is bound by the available memory. Same goes for redis. &gt;I know for a fact that Redis is easily configurable (not sure about defaults) to flush to disk often (this is how it handles persistence) and so isn't upper bound by available memory. Flushing to disk is only for persistance purposes. The queue is still kept in memory. 
&gt;That plugin lets you use MySQL as a keyvalue store in that pkey lookups skip SQL parsing. It's nice and fast but it's not a redis substitute Redis is a key value store. Why is this not a substitute?
You're going to have to make a worldview adjustment. Test coverage &gt; Debugger Textmate &gt; IDE Other than that, have a blast :)
-1 -1 -1 -1 -1 -1 -1 -1 This is totally totally completely fucking hopelessly retarded!! This is exactly the kind of gratuitous monkey patching that makes me agree with pythonistas criticisms of the ruby community! I am a rubyist, but this shit makes me ashamed to hell!! don't do this, it's fucking retarded. Thankyou.
I choose notepad++ it offers many of the features of a heavyweight ide. I ruby is most friendly to program in a unix based os notepad ++ is native to windows but works wonderful under wine.
VimMate was a thing of beauty and a joy forever, however it broke with rails 3 :( I've been trying to replicate it with gvim, NERDTree and a terminal, but NT is horrible in comparison to having a file browser in a separate window. If anyone's got a decent solution - a simple one-pane file tree with NO other bells and whistles, be it curses or gtk, that can sit in a window and launch $customcommand $filename on enter/doubleclick, I'll be eternally grateful. 
If you're comfortable with Eclipse, there's no reason not to use it for Ruby. If you want to learn a new editor, I suggest learning to use the most mature integrated development environment available: Emacs on *nix. I find that the only languages that really *need* a debugger are C and C++. I do most of my work in Perl, which has an excellent debugger, and I don't use it frequently enough to not forget how it works. For the projects I've done in Ruby, I've never reached for a debugger. Looking now, it turns out that there is a [ruby debugger](http://bashdb.sourceforge.net/ruby-debug.html) (with emacs integration!), but it should be safe to ignore it.
Perhaps the Python library [twisted](http://twistedmatrix.com/documents/current/conch/examples/) would be of use? No idea how much work it'd be.. Might be easier to run a second OpenSSH sshd instance and configure that
I liked Pry too - http://banisterfiend.wordpress.com/2011/01/27/turning-irb-on-its-head-with-pry/
http://en.wikipedia.org/wiki/Duck_typing
I'm on a mac and very happy with RubyMine.
cells are a pretty neat idea. It would be interesting to see if they could be combined with erector which has a concept of a widget and nice emitters. How portable are cells? Can I copy a cell from one project to another and have it work? 
If you are working in Linux you should read this: http://ubuntuforums.org/showthread.php?t=893323 and learn how to make screenshots from command line. Then you choose one of the methods described there and just call them up with backtick operators or system() or exec() etc in Ruby (compare http://www.ruby-doc.org/core/classes/Kernel.html). Now you made a screenshot from your Ruby code - what now? Look into one of these Gems (https://rubygems.org/gems/gd2 or https://rubygems.org/gems/rmagick or similar) for loading and working with the image you just created. This is probably not the best way to do it since a native C extension that combines the necessary steps would surely be faster, but it's a quick and easy way to get you started. TIP: Most of the overhead would come from the process of saving the image to your hard disc and reading it again a second later. This could be minimized by creating a small partition in your memory and mounting it as a hard disc (see here http://www.vanemery.com/Linux/Ramdisk/ramdisk.html) Hope that gives you a kick start. Happy hacking :D
I would recommend [Textmate 2](http://textmate2.org/).
+1 Pry rocks
It meshes very intuitively to how I think when there is more than one resource to display on a page.
Never heard of this, thank you. Before Rails I used to work with Symfony, where components were a very useful feature that now I regularly end up missing. This looks exactly like components!
Read the article once again. Thank you.
Very clever, +1
Sure order.state is usually the best choice. But there are some cases when you have a method which have to be invoked. The question is how to invoke such a method.
I agree with this. This is why I don't like the CMSs in general: CMSs usually contain to much. More stuff that needs to be maintained and god forbid: modified! I don't want to be implementing a product, I want to BUILD it. I am okay with putting together the pieces, but I don't want to spend too much time figuring out yet another API. I absolutely hate to be entering HTML in a text-area in the browser. It might be okay for the customer, but I will not leave my own editor to make a website. So, give me the building blocks of a CMS, and I will put them together, but I don't like a finished product in which I have to hack and monkey patch to make it work like I want/need. Maybe with Rails Engines getting more mature it will one day be a decent solution to "hook up" a CMS to an existing application and integrate it properly. Maybe.
Cells appear to be a great idea. I took a look at them three years ago. However, the rails community usually grabs onto great ideas and I see no evidence that Cells has caught on at all. The apparent lack of adoption is why I haven't investigated further. Please correct me if there is a community of people using it.
I found some using Google but I was interested in the opinions of Ruby programmers. I've learned my lesson. I need to be careful how I phrase my post.
I used it at an old job, thought it was awesome. My current job hasn't had a reason to use it. But I thought it was pretty sweet
Cells are components. Rails don't support component-oriented programming out of the box and here is where cells come. Each webpage has some components. Newsletter box, login box, menus, TOP10 list and the likes. Usually components are made using partials and helpers. It's wrong. Cells encapsulate logic and view which leads to cleaner design. Think about testing, caching and reusability. Cells are very actively developed and still improving. For instance action-args have been added recently which works excellent in cells environment. It's definitely worth giving cells a shot. Install it and try it. I assure you won't regret.
Cells has 600 watchers and 36 forks on github. here are the stats from rubygems.org http://rubygems.org/gems/cells
I was using notepad++ before making this post. Perhaps these features exist in notepad++ but these are some features I liked about developing Java in Eclipse. * Auto code formatting * Jump to the line of code by clicking on the error or warning message. * Always building so compile errors are noticed immediately (this I can easily live without and can understand why it's not available in a scripting language). * Debugger with breakpoints * Code completion (probably not available in a dynamically typed scripting language)
Sweet! That's the data that I wanted but was too lazy to look for. : )
I regret mentioning Eclipse in my post. I should have listed the features I wanted instead suggesting I want something I'm familiar and comfortable with. I guess that made me look close minded and averse to change. I was interested in hearing about the IDE/text editors experienced Ruby programmers like and use. 
Wow. 
Haha that's hilarious. I tried Vim and Emacs and I just couldn't scale the learning curves.
This. Redcar is ballin.
Can you provide a general example of what Radiant can't handle? It would be much appreciated.
malcontent- as long as you don't do nasty stuff in your cell (like @controller.helpers.method_only_available_in_project_one) your cells will work in any other project (even rails 2.3 -&gt; 3.x may be possible).
I am using Cells and they are pretty awesome. I use cells when I show anything often in my web and it has a complex logic behind. And Nick, the owner, take care of the gem very well. I reported a problem a few days ago, and after a coupe of mails, he found and fixed the problem in a couple of hours. Try cells.
looks pretty damn interesting. if i ever do a rails project again, i'll give it a serious look. (i thought from the name it would be a port of kenny tilton's [cells](http://smuglispweeny.blogspot.com/2008/02/cells-manifesto.html) project, but it seems not)
I like it. I wish I had been using it for my latest project from the get-go. Not sure I can muster up the energy to move to a new system mid-project, but I'll keep in mind for the next one.
I created a rails3 project with everything stripped out except for all the necessary components for migrations. One benefit of this approach is that you get to keep using the rails generators for creating the migrations. https://github.com/tc/database_migrations 
It's a great idea — partials usually need data from models, and it's tedious to repeat the same data calls in every controller action for which you're going to use the partial. But I think it's the sort of solution that not every project needs. I could imagine integrating this into an ordinary Rails app and having the app be more complex than when I started. I disagree with some of the points in the second article: * It subtly changes the "no business logic in views" maxim to "no _decider_ logic in views," seeming to say that you shouldn't have anything conditional in a partial. Why on earth? It's stated, without explanation, that this is a violation of MVC. I'm skeptical. * "What are helpers?" They're macros for views. What's hard about that? Also, they're not untestable. Write integration tests if you're that serious about testing every single component. Again, an idea is trashed because the author claims (without evidence) that it's against the rules. Still, it does solve problems, and I might use it in the future if it fits.
There are dozens of blog posts and forum discussions exactly like this one. Read them. Try out the four or five viable alternatives. Make up your own mind. Blog the results.
We've had a pretty good experience with Radiant. Like all CMSs there are things to like and things to dislike, but Radiant is has excellent extensibility and the community is awesome.
Apotomo is the project you should be thinking about. It builds on cells.
A similar project using the same (I assume) APIs: https://github.com/tenderlove/playpen
I thought enough of Cells to have Nick fly to the US and give a talk with me about it for the '08 Ruby conference. :) http://rubyconf2008.confreaks.com/components-are-not-a-dirty-word.html
Rubymine is great and gets better all the time.
That works for you the developer. OTOH something like plone or drupal could be used by a "power user". 
&gt;Cells has 600 watchers and 36 forks on github. Is that a good thing? I see 36 forks as a symptom that people are not accepting patches.
It depends if these forks have commits of their own or not. It seems like often, when people like a project, they clone it on their github account, not sure exactly why, though. I'd say, if, among these 36 forks, most of them have 0 commits, that's a good sign, it means people like it and want to make sure they have easy access to the project files, but if these forks have commits or their own, then yes, I suppose it's a bad thing. 
&gt;It depends if these forks have commits of their own or not. It seems like often, when people like a project, they clone it on their github account, not sure exactly why, though. My experience is that most forks do have commits. I don't know about this particular project but in general that's the case on github. 
&gt;It subtly changes the "no business logic in views" maxim to "no decider logic in views," seeming to say that you shouldn't have anything conditional in a partial. Of course, this is very provocative - intentionally ;-) I clarify that I do use helpers and logic in views myself, and that this is nothing bad if you're not overusing it: http://nicksda.apotomo.de/2010/11/rails-misapprehensions-cells-dont-break-mvc/ &gt;"What are helpers?" They're macros for views. What's hard about that? Also, they're not untestable. I absolutely agree with you! My problem is that people pack helpers with controller logic and beside that I don't like the way helpers are working in Rails, have you seen how Sinatra and other frameworks do this? Will blog about it! Thanks for the feedback!!!
Yeah, I give Playpen a mention in the README. There is also the Sandbox class in MacRuby as well, using the same API as Playpen &amp; Dia. I explain the differences between the two in the README :) Thanks! 
I haven't tried this in a project yet but it looks very promising. Similar-ish to the ideas behind Symphony CMS (not Ruby) which is the best CMS system I've used. 
i wish someone would have told me that i really didn't need any libs like jeweler to make the gem creation process easier. it's already really easy! i would also mention rolling your own core_ext folders for that one String or Array extension that you need, rather then listing ActiveSupport as a dependency.
Many of these may or may not fit your concept of a beginner level talk, so take anything you like. I'm just throwing out ideas that I would've appreciated hearing about. I'm definitely in favor of the topics you've already listed in the OP. * If you cover any of the gem skeleton tools like Jeweler, please be sure to point out the caveats, and if possible, cover simpler alternatives like `bundle gem` or simply doing it by hand. * One topic that tripped me up early on was the concept of load paths and `require`. Perhaps touching on that would be helpful, and mention 1.9.2's `require_relative` while you're at it. * Brief mention of 1.9.2-only code in general as it relates to gem publishing might also be a good topic. How to specify that your gem requires 1.9.2 in the .gemspec, for example. * RVM and/or Bundler for simplifying gem development/testing. Using RVM to test against multiple ruby versions, for example, or Bundler (and maybe gemsets) to allow collaborators to get up to speed on your gem quickly and easily. * The recently unveiled [Gem Testers](http://gem-testers.org/) service from EngineYard. [[Announcement blog post]](http://www.engineyard.com/blog/2011/introducing-gem-testers/) * The (*spooky hands*) eviiiiiiils of monkey-patching and `alias_method_chain`, clarifying when they're appropriate and when they're a symptom of code smell or programmer laziness. I realize this topic may be a bit beyond the basics of gem development, but they're very important considerations for sharing re-usable code, imho.
And where will this talk take place?
what is the best way to handle gem dependencies? i've seen a lot of conflicting opinions on this
Since you didn't mention it, and it's quite new, you might have a look at http://rubygems.org/gems/rubygems-test This is endorsed by drbrain (rubygems developer / maintainer) and seems like an emerging best practice for gem development.
Don't commit your gemspec. It's bad software engineering. You don't want to use unreleased software and you don't want to support unreleased software.
An IDE is like morphine. Curing root pain is often better.
How does committing the gemspec file cause people to use unreleased gems? I used to never commit it, but now I have been limiting the number of 3rd party tools required to generate the spec and build the gem. Now I lean more toward using a rubygems directly. I have to give Yehuda credit for [pushing me in that direction](http://yehudakatz.com/2010/04/02/using-gemspecs-as-intended/).
It used to be a problem back when github did gems. Any changes to versions would kick off gems built/released. Not as much an issue, short of people doing checkouts, gem build, and gem installed of versions that haven't been released yet.
Gem naming conventions: http://blog.segment7.net/2010/11/15/how-to-name-gems
Since you are already familiar with eclipse: [RadRails from Apatana](https://aptana.com/products/radrails) 
Are you referring to within your .gemspec for development purposes or at runtime for end users? In either case, I've been reasonably happy with Bundler for both purposes. It's not suitable for every edge case out there, but for my own hobby work it's been more than sufficient.
You could mostly avoid these issues by not bumping your version numbers and such until you're actually releasing the new version, couldn't you? Edit: No, that wouldn't totally alleviate your example of someone doing a checkout/build/install themselves, but it would clear up most of the confusion pertaining to unreleased version numbers, at least.
I upgraded this morning and it shaved 30 seconds off of my 8 minute test suite. Pretty awesome.
I too would like to know what the 'best' way of setting up ruby programs(gem) for use with rspec and TDD. How to do this using something like newgem or bones with rake is what ive been looking for today.
[Ruby Packaging Specification](http://chneukirchen.github.com/rps/). Covers gem/directory naming conventions and how to package static data with your gems. I tend to put all of my monkey-patching code in a directory named `extensions` (other's may prefer `core_ext`). I also tend to define Exception classes individually in a directory called `exceptions` (other's may prefer defining them all in a single `exceptions.rb` file). [Semantic Versioning](http://semver.org/) Another thing that I have recently learned: Bundler is not the end-all be-all solution for generating/building/packaging rubygems. However, it is very useful for managing complex dependencies. I've used [Hoe](http://blog.zenspider.com/hoe/) in the past, then [Jeweler](https://github.com/technicalpickles/jeweler#readme), then Jeweler with [Bundler](http://gembundler.com) and now I'm using [Ore](http://github.com/ruby-ore/ore#readme) to generate/release all of my gems. A few of my heavier gems use Bundler (to manage edge dependencies) with [Ore::Tasks](http://github.com/ruby-ore/ore-tasks#readme). Better to show students the work-flows of the various gem development tools, and let them decide on their own.
Upvote for educating on many available options rather than endorsing one exclusively.
Can you post a video of your talk? I'm interested in this topic.
bundler can install gems from github which is why Yehuda wants you to check it in separately.
or using bundler to install from git.
Sure, it's super easy if you have just one gem. You add a test task to your Rakefile and hook it up to run before release so you know you're running a good version. You add a task to tag your release in your VCS system as well so you don't have to remember to do that. Then you publish a second gem and you find yourself copying tasks back and forth between your rakefiles as you try to make maintaining your software easy. Hoe was written to make your life easier by providing a library of tasks you can use to automate your entire release process including building and uploading the gem, publishing documentation and making release announcements through blog and email. New features are an upgrade (or plugin install) away and require minimal (usually zero) change to your software.
If you extend any -- *any* -- of the core classes, unless it is a **documented feature of the gem**, I will hunt you down and take away your chunky bacon. Don't give me any of that "but it's such a *small* addition", or "it'll never conflict with anything", or "everyone *else* is doing it" crap. Don't crap up my objects with extensions you only added for your gem's own internal use. They *will* conflict with something else some day.
Also: understand the gem dependency types, especially the squiggly arrow. Don't unnecessarily lock your users into using versions of gems that conflict with other gems. Make your gem dependencies as specific as they need to be, and no more so.
[RubyNation](http://www.rubynation.org/), in Reston VA, in April.
I can't concentrate on reading with that dude staring at me.
Somebody make this work please http://copiousfreetime.rubyforge.org/crate/ 
Yep, and that's why jeweler generates the gemspec the way it does :)
I'd extend this to other libraries as well.
Why shouldn't you require 'rubygems'? I know it's deprecated in 1.9, but I thought it was needed in 1.8.
Libraries for making libraries. Related: I also love that there is a web framework for making web frameworks.
Good post. I've always used Gemsets and I never really liked the fact that things installed into them were, for the most part, invisible and hard to get at. I think that I will be giving 'bundle install --path vendor' my business from now on. We are just laying down the rules on RoR development at work so I plan on adding some of this post to the internal wiki. Hopefully, it will make working together that much easier and better. :)
What should it do?
Maybe be more specific. You mention that you need an experienced programmer but the task is simple, short, and you can't pay much, so, right there..
Rentacoder? Craigslist? Not here, to say the least. But I guess you can edit your post to include a rough idea of what you want and maybe you'll get someone interested.
I'll do it, pm me.
Fuck it, man, just tell us the guidelines and someone will do it. It can benefit you by having the program written, and it can benefit some newbie by giving them a practical, real-world project to work on.
If you just need some quick scripts written, probably anyone reading this (myself included) could probably do it for you for $25 or whatever, just for fun really. However, based on your description, there's more than a little chance you're asking for someone to write a homework assignment for you. In general, people frown upon that. I certainly wouldn't do your homework for you, for any amount of money.
I've actually been thinking about extracting the packager from Shoes, which does something similar to this.
http://tomayko.com/writings/require-rubygems-antipattern
I gave a talk about this at my local Ruby Brigade recently. Video: http://www.vimeo.com/19677690 Slides: http://teachmehowtomakearubygem.heroku.com/ Timeless article: http://timeless.judofyr.net/making-ruby-gems
If you are so bad at programming, how can you be confident it will only take a good programmer about an hour?
Both Bundler is great and perhaps I'm missing something but it seems redundant unless you're dealing with an application that has no gemspec. You can specify runtime dependencies and versions in a regular gemspec file...
Well, if you want to send me a PM, I'm a competent Ruby dev. Most of my experience is with Rails, but I've done some server scripting with vanilla Ruby as well. Would appreciate some explanation of the purpose, even if it's broad.
things like rvm and bundler are useful for syncing dev environments, but honestly it does not seem like the tool for production. IMO your configuration management and deployment tool should be the source of truth for what dependencies need to be installed on your servers. (i.e. chef, puppet, etc)
Shoes is a ruby distribution.
Aye; or here. Professional Ruby dev here with a spare hour or three.
Thanks for sharing the source on github Florian. Good rack, haml and picky example https://github.com/floere/gemsearch
Tell me about it. My boner kept throbbing the whole time too.
I am fully aware, I'm on Team Shoes. It's also sort of what Crate does: &gt; Crate is a developer tool to help package up your application as a custom static build of the ruby interpreter plus all dependent binary extensions.
What the fuck. 24 months ago everyone said you were an idiot if you DIDN'T store your sessions in the database!
you can find someone who can do it for free on the irc ;)
I'd like to hear the rationale behind the down vote. Sometimes Reddit just baffles me... 
That sounds right. I guess I misunderstood what sort of project you were referring to when you said managing dependencies. Managing dependencies for a gem's code is definitely viable through just the gemspec. I was thinking of a more free-form application that was *using* gems, but not distributed as a gem itself, i.e. a Rails or Sinatra app.
Yeah... the issue is that I've seen so many conflicting opinions as to whether, for instance, you should manage non-dev dependencies at all or whether you should specify versions at all. I'm not saying I espouse these views, I just wish there were more of a solid convention
btw, there are people who recommend using bundler for managing dependencies in gems
comparing memcached session storage to mysql session storage is apples/oranges edit:clarity
For collaborative gem development, I'd say using Bundler for your dev dependencies is a godsend. Or even by yourself if you use multiple machines often.
4. Using MySQL
24 months ago you also weren't supposed to store sessions in the database. Maybe you're talking about 4*12 months ago, when memcached usage wasn't as widespread and when the cookie session store didn't exist.
You generally want your production environment to match your dev environment as much as possible, otherwise you may run into all sorts of problems after deployment.
what point are you trying to make? obviously you need to have the same versions of the same gems in each environment. my point is that bundler is an incomplete solution since gems are only one type of dependency.
I know, right? SQL Server is at least 1000% better!!!
Disregard creepy dude, acquire Readability extension.
Very cool, thanks for sharing that.
No problem. I still have a few revisions I want to make, but that's my take on the subject.
As an ACID database with modern features you expect in a SQL server it is at least 1000% better.
I'd have to agree with Browser CMS being good to work with. The page editing interface shows your content mostly as it will actually appear on the site, and you can insert a wide variety of content blocks into different parts of a page. Once you've got a site set up, you can hand it off to a less technical group of editors and content creators, and they can run with it. As a ruby dev, the best part about Browser CMS is that it's just an extension of Rails itself. If you need to define a new kind of content block, you write a model class. There are a few gotchas, but for the most part, I've found it highly extensible. And if you need something complicated and data-driven on the site, you can just whip up some regular Rails models and controllers and then pipe the data into a content block however you need it. 
So I guess you'd have to move your data to redis in order to use it and do it on a periodic basis for it to be useful. 
I almost forgot. You almost **never** need to write Ruby C extensions. **Use [FFI](http://github.com/ffi/ffi#readme) instead**. This way your gems which use native libraries can be installed without having to compile anything, or needing C header files to be installed on a users system. I see way too many trivial C extensions that could easily be ported to pure Ruby using FFI (example: [ruby-libemu](https://github.com/testpurposes/ruby-libemu/blob/master/ext/environment.c))
awesome, ignorant misogynistic shitty commentary on languages by no-named nobodies, this is clearly what reddit is for.
Old, but way funnier: http://maradydd.livejournal.com/293666.html &gt; Java: You try to be loving, but you were raised by a commune of 60 nervous women who have told you that everything you do is loving, even when it isn't. Your unhelpful behaviors have never been corrected and everything you do is subtly wrong and destructive. &gt; JSP: You are Java's younger sister, working in a strip club to pay for your women's studies degree. &gt; C#: Your wealthy parents always told you that the other kids were just jealous of how smart you are. They were lying. &gt; Smalltalk: Smalltalk won't meet you outside Smalltalk's apartment. Smalltalk says that if you really loved it, you wouldn't leave. [edit] Comments also have some gems: &gt; I don't think C gets enough credit. Sure, C doesn't love you. C isn't about love--C is about thrills. C hangs around in the bad part of town. C knows all the gang signs. C has a motorcycle, and wears the leathers everywhere, and never wears a helmet, because that would mess up C's punked-out hair. C likes to give cops the finger and grin and speed away. Mention that you'd like something, and C will pretend to ignore you; the next day, C will bring you one, no questions asked, and toss it to you with a you-know-you-want-me smirk that makes your heart race. Where did C get it? "It fell off a truck," C says, putting away the boltcutters. You start to feel like C doesn't know the meaning of "private" or "protected": what C wants, C takes. This excites you. C knows how to get you anything but safety. C will give you anything but commitment &gt; In the end, you'll leave C, not because you want something better, but because you can't handle the intensity. C says "I'm gonna live fast, die young, and leave a good-looking corpse," but you know that C can never die, not so long as C is still the fastest thing on the road.
On linux it's at least 1000% worse. 
I guess I didn't get the memo that the whole world switched to linux. ☺
I guess you didn't get the memo that most servers in the world are running linux.
The trick is to store them in another database. That takes care of the problem. So you have two databases on the same box. Stick everything in MySQL except the sessions, which go in Postgres.
How about a link then, listing you as a member? Otherwise, I call bullshit on your claim.
Try Command-T, I find it better than a file pane.
If every server were running Linux mysql would still be lacking in features a modern SQL server should have like ACID. Fortunately there's postgres, SQL Server and Oracle (among others) if you care about your data.
You should look at OCRA (One-Click Ruby Application). http://ocra.rubyforge.org/
Cookies existed in the 1990's (so much earlier than 48 months ago). Anyway, cookies are client-side so what's the relevance to server-side storage? 
So, making irreverent metaphors to your dating life is misogynistic now? Oh what a fun world we live in.
Only the autocomplete data needs to live in Redis, not your whole database.
&gt; Cookies existed in the 1990's (so much earlier than 48 months ago). But ActionController::CookieSessionStore did not. &gt; Anyway, cookies are client-side so what's the relevance to server-side storage? The relevance is to that you don't have to, and in many cases shouldn't, store sessions on the server.
damn, that c comment nails it
do symphony components have their own seperate mvc pattern?
Most often the autocomplete date lives in your database and is relatively dynamic. 
&gt;If every server were running Linux mysql would still be lacking in features a modern SQL server should have like ACID. Is this tea bagger logic or something? 
windows only. If it's anything like rubyscript2exe it also does a full extraction at every invocation which makes it slow as hell to launch. 
I was expecting some sort of code-completion backend for Ruby (which would've been awesome). Then again I never heard of Redis before so I guess it's just me.
I'm not sure what you mean by "separate MVC pattern". They're pretty much like Cells - a small, reusable action/view pair that can be invoked more or less like a partial.
https://github.com/shoes &lt;- https://github.com/shoes/shoes/commits/develop &lt;- Also, I didn't know malcontent was disliked enough for someone to make an alternate account that's trying to make him look like _even more_ of a troll. (I probably wouldn't have noticed, except I have him friended, and your name isn't in red.)
I would go with my fellow scotsman here.
Assuming one is using InnoDB, I don't see why MySQL isn't a viable option. I categorize MyISAM in the same vein as NoSQL...it's fine for unimportant or read-only data, not much else.
Ha, I wish that I had dated a girl that awesome back in high school. As a language, Perl already does more than most women, except maybe making me a sandwich. Perl won't do that for me :/ EDIT: `my $comment = "Joke"`
I would totally blow that guy, though.
You take the upvote an' I'll take the downvote and I'll get an orangered afore ye! Edit: in other news, ah dinnae ken until right now that there's an /r/scotland subreddit.
This is me on my home computer. Sorry I doubted you. I have to be careful because there are a lot of fakes on here.
That comment was amazing.
So it would be better if you use PostgreSQL instead of MySQL.
I've yet to run across a customer that cares about being a part of Cucumber stories. I don't like Cucumber, because it adds a layer of complication to the whole setup. Ruby is english-like enough already. If the test doesn't match the "should" description, then it's a bad test. Writing tests first certainly makes you think about what your code should do, but I don't think that's unique to Cucumber. If anything, Cucumber gets in the way, because I end up having to write my features, then I have to write a bunch of code to say what my features mean, when I could just write the features and then write a bunch of code to actually test those features.
http://cukes.info/ if anyone's curious: I hadn't heard of this before today. Kinda hard to wrap my head around...
Cucumber is simultaneously the most interesting and most useless thing I've seen from the Ruby community in a while. The idea that you can, and should, write tests in plain English is ridiculous at the outset and from there it devolves into a series of perversions simply to express what you're trying to get done. Once you've invested time in this house of horrors, you'll be under the impression you have actual test coverage, that you've got software that works, yet nothing could be further from the truth. What you have is a bunch of tests that pass, nothing more. There's a lot to be said for proper test-driven development, but this sort of quasi-business, pseudo-English test methodology is for people who prefer to be writing tests instead of shipping apps. It's for project managers to make charts about *code coverage* and *use cases* which ends up being as absurd as measuring a project's progress by lines of code generated. You know your app works because you use it. You know your app works because you beat the hell out of it with everything that you've got and it's still standing. You know your app works because you write your tests to cover the basics, to exercise modules in the most ways you practically can, but never, ever delude yourself into thinking you can test everything. There's nothing you can't do in Cucumber that you can't do by simply writing better tests and focusing on better software development practices. Tests are a way to save time and still ship reliable software, and if they are not saving time, stop doing them. Some things are very easy to write tests for, so write those. Some things are tricky, but still worth it. Some things are very, very hard to test automatically so unless you're going to be testing a lot, or if the cost of a failure is going to be more than the cost of testing, don't bother with automatic tests. Do it by hand. If you're testing automatically you're ignoring a lot of things. If I have to register a hundred test accounts on my system, you'll bet the registration system will be stupidly simple. If I have to run through a use case two hundred times to capture all the permutations, I'll make it better and better until it's almost effortless. When you test you think of ways to make it better. You don't just look for logical defects. 
This means that you didn't get how to test software when using other testing frameworks. There's nothing wrong with your brain working differently, it just does.
I still don't get it, honestly.
One thing that Cucumber introduced me to was the importance of integration tests. It's not the only way to do integration tests, but I do have to give it credit for that. It's a severe misunderstanding to think that Cucumber exists to give you code coverage. Use your unit-testing framework of choice for that. Integration tests are the skeleton, not the skin. If "You know your app works because you use it," then you're still designing your code with a use case - but the use case is defined by how *you* use the app, not by how any of your users might. For simpler applications, this may suffice, but it doesn't take that much complexity for there to be different ways for users to approach your app. Why not codify these approaches into testable items? The whole point of TDD and BDD is that you should be testing all the time. It's not the only approach to coding, but it's one that works for me. I think automating all my tests is a good thing because the difficulty of me running a test shouldn't affect how important the tested aspect is to the final product. Looking for how to improve code is great, but a lot of time testing is just there to make sure you didn't break anything. And how many times are you going to go "well, that was just a one-line change, I shouldn't need to rerun all 200 permutations, just a dozen or so should do it." A passing test shouldn't be mistaken for awesome code. That's why the BDD cycle is red-green-refactor. Refactor being the bit where you go back and make passing code awesome.
Cucumber is the best tool I know of to write tests for views and controllers. It's also among the easiest testing tools I've used. The value of its 'english like' syntax isn't that it can be written in english, it's that it encourages BDD behaviors in testing design and development. 
Do you happen to know of a good cuke walk-through that I could look at? I typically just do some rspec/shoulda tests as I develop and leave it at that. I've yet to get into the mindset that BDD is mo' betta.... maybe this will help. 
IMO Cucumber's English tests aren't just great for creating tests but also for determining what feature is broken when things don't pass. This is specially true if you're hitting the codebase some time after writing it. If you want ruby syntax for writing your tests then look at Steak.
And this comment means you're one of the reasons more people don't become part of the Ruby community. Thanks for assuming my argument for why Cucumber is cool automatically means I don't "get" everything else.
I will not work with a customer unless they agree to user stories. I never run into "one more thing" problems with customers when we've both agreed to how certain things should behave.
What are you going to do about the databases?
databases always suck.
Can you clarify what exactly you want to know about the databases? The current design is similar to Heroku, one unique DB/user per application, only its moved to a sliding scale pricing model. I am more than open to changing the model though! hence why I posted this :)
I'm pretty sure I *get* how testing without cucumber works, I've written a couple of applications that used plain RSpec or Steak or whatever. I still prefer cucumber.
Will you be supporting SSL?
I love the idea of Heroku, but the pricing always put me off. I understand that its pretty decent for profit-generating sites, but for hobbyist sites its just too much - I'm talking the kind of site that you can run two off quite nicely on a $25/mo VPS. I don't have enough first hand experience with Heroku to tell you much about what I would like to see from your service, but I wish you the best of luck with it and hope it goes well for you. 
Good question. Next question... anyone? Save me from answering this? :aaa: I do not have a massive amount of experience with SSL, but you are right in bringing it up because 1) it currently is not in the design, and 2) it is required functionality. It may not have SSL support on initial launch, but support will be available eventually. It will require an additional fee (that will increase as the availability of IPv4 addresses decreases, sadly), but it will not be anywhere near the $100/month that EC2/Heroku charge. 
Thanks for the comments! The small sites you speak of are exactly what caused me to write this in the first place. I have a ton of clients from local businesses that do not exactly generate a lot of traffic, so could easily be hosted on a single VPS, but it seemed incredibly wasteful to leave the thin instances running 24/7. Using Heroku wasn't possible, as a lot of sites required &gt;5mb databases, and I didn't want to increase costs ($15/month is cheap, but over a few dozen sites, it adds up). $25/mo could (potentially, hypothetically -- I need to stop acting as if prices were final!) get you 5 sites on this platform, so I hope to see people take the grid route over VPS :).
You represent all that is wrong with programmers today. Too stupid to understand databases. 
so, is it ready to try out?
No :( this is just a request for information. Specifically, interest check and features/functionality that people want. I want to give users a rich, feature packed experience from day #1, so I don't feel that it is ready yet for public demonstration (plus, at the moment it is basically just Heroku).
Above all, zero configuration and quick and easy deploys are IMO the killer feature - never mind the tech specs, time to market is the most important factor for me.
Heroku also has a useful ecosystem of third-party tools that are important for running any site of significant complexity. To what extent can you support these tools?
So the database is a single point of failure? 
I second this.
Offer a way to use it without a credit card :)
And none of those allow one to easily scale write traffic by adding more servers, unlike e.g. MongoDB which is not ACID.
The summary says it best: &gt; When I use your library, deploy your app, or run your tests I may not want to use rubygems. When you require 'rubygems' in your code, you remove my ability to make that decision. I cannot unrequire rubygems, but you can not require it in the first place.
The Rspec book is really good.
Agreed. OP: Any info on what deployment will be like?
I've been working on something similar to Heroku also. I like the flow of working with Heroku, and want to set up a tiny tailored environment to my own specification. Care to explain the how you implemented routing mesh and dynos? *ANY* explanantion of what you implemented how I'd be interested in hearing.
Word.
Yeah, what steveklabnik said. I started with the RSpec book, and it was a very good introduction.
Two questions from a Heroku enthusiast with similar pain points to yours: * Will you offer a free tier? * If so, will you offer something like cron jobs or workers for free at an interval that is smaller than a day (what Heroku currently offers)?
You can use Nginx SNI support for multiple SSL certificates on a single IP address. This only supports newer browsers (IE7+) but you could offer it as a cheaper alternative for those that don't care about IE6 whining about a general SSL certificate.
I love heroku, but I think what you're doing is great. I always thought that there had to be something between a bare linode box and a heroku package that still allowed easy GIT deployment, and other niceties of heroku. I'm not sure I'd leave heroku for large commercial applications until another system was VERY well tested. You're basically trying to offer something between heroku free and heroku paid, so this will be production level applications. I think you'll need to find a way to build up trust, security, and reliability in order to start getting paying customers. One point I'd like you to focus on is backups and deployment history/rollback. Heroku has this but it's a bit expensive for the complete package.
Do dynos have a defined speed/size ?... I've got the same problem with Heroku that you do, so I couldn't be bothered to learn their terminology.
UCC SSL certs are available, and pretty easy to set up. You can serve up to 100 domains through one cert, on one IP. You can also serve more than one cert through a single IP if you engage in a little computery. We have a couple certs running on a single server. Takes a little effort, but once it's set up, it isn't that big of a deal. adding domains to a cert would need to be automated, and that would be annoying, but the cost would be pretty minimal once implemented.
what a weird thing to say
How are you able to price it so cheaply?
simmer down there... i think he's referencing how cucumber isn't ideal for *all* testing situations. i'm specifically thinking of unit tests. 
&gt; I've yet to run across a customer that cares about being a part of Cucumber stories. i agree. in an agile(ish) workflow, the goal donor is very involved in the story creation/refinement/prioritization processes. these are typically represented in ways they can easily access like index cards, mingle, pivotal tracker, etc. I've not seen them so involved with stories after they are played. features expressed with cucumber implies either an on-site customer, or a business person that has access to the code base and knows how to navigate to these tests. in my experience, its not common for business people to have access to the code base, and i've never seen reports generated from the cucumber tests. Without the active involvement of business people, cucumber becomes just another programming language. if this programming language works for you and helps you think more clearly about the problems you are trying to solve, then great! however, i wonder if we are missing out on some awesomeness by not involving the business side and developing a common language. I think cucumber offers a real advantage when you couple it with selenium. if you write them correctly, you have an easy, reusable way to protect your money path. i'm still figuring out how to write them correctly ;)
Are you talking about [this book](http://www.pragprog.com/titles/achbd/the-rspec-book)? 
Can someone, anyone, give me an idea about the costs of Heroku? I know "it all depends" but seriously, take a very simple web app with AT MOST 100 hits/day. Say something like a blog. What would that cost? Or maybe a url shortener, todo list, whatever. Something pretty basic.
Not weird. Stunningly accurate.
IE7 on XP still doesn't support SNI. If you want SNI, you require at least Vista.
Sorry for being so stupid, but you have obviously never tried to manage a database layer for a grid environment. What I should have said was, scaling databases suck. &amp;#3232;\_&amp;#3232; 
Yep. Don't be fooled, it should be called "Behavior Driven Development." It goes over Cucumber just as much as it does RSpec, and also talks about how they work together.
Ah, you're right. I think it's still a viable option if you don't care about lesser browsers. Targetted audiences where you know the browser environment would work fine with this as an inexpensive solution. Interestingly enough, SNI works in Chrome and Firefox on XP but Internet Explorer and Safari still use the OS's SSL support.
Actually now, databases are starting to more and more support active clustering. DB2 9.8 with Purescale is going to have it, and as I understand SQL Server also supports active clustering. So the old paradigm of growing a db server up instead of out - it's now obsolete. After 10 years - I'm just a bit jaded when it comes to incompetent programmers who haven't a clue about databases. Orphans? Why should I care - my application works... Fuck foreign keys. And forget lookup tables I'll just use an array constant in my code and expect the rest of you to figure out what transactiontype 72 means when I add it to my code... I'm very jaded :)
A blog with 100 hits per day is most likely free on heroku. The first dyno is free, you get 5mb of database for free, and you won't need to do any background jobs. You'll need to host the images somewhere if you put much photography in it, and the db will go up to $15/month when you cross 5mb, but heroku is very cheap on the low end.
Do you have a recommendation on the "somewhere" for images? Amazon S3?
Do it. Seriously, do it, do it now and do it good. I would love to see a cheaper Heroku alternative with a more fluid pricing system. As for what features I want to see—I don't care much for anything other than the prospect of having my app out there that would need very minimal intervention from me. Everything will simply be 'gravy' after that.
Not sure how you get that from what he wrote, but if so, mea culpa.
What type of datastores would you be offering? Would it just be something alongs the lines of mySQL or Postgres? I think a killer feature, at least for me, would be the ability to use like Redis or MongoDB. It makes it really easy to deploy simple Sinatra apps.
[](http://www.reddit.com)
Maybe I used the wrong word, but if you're running off on tangents with everything else except cucumber there's something about cucumber that works for you that doesn't work for the other testing libraries you've used. I don't use cucumber or rspec because I don't get it. I use MiniTest::Unit.
oh, right, because programmers today... don't understand databases? wtf are you talking about
somebody is going to need to provide some evidence that programmers today don't understand databases. You're calling me an idiot, but have no grounds to support the premise.
I'm saying that many programmers today do not understand databases. Is there a way I can be more clear? Are you still confused?
I am not unclear as to what you are saying, I am unclear as to the evidence you have to support such a nonsense assertion.
Excellent. Thanks for the reference. :) 
I have none. My anecdotal evidence doesn't count.
I wish someone would have told me that you can install it so that you never need to use sudo. Granted, you should be using rvm which also eliminates the issue.
Lexical refinements will save us.
you're right. it doesn't.
We also don't have any evidence that you're not an idiot. So, I'll make the statement that I think you could very well be a fucking dumbass.
The original premise. My idiocy is not up for debate here. but, right back at you.
Neither is mine. Your point? Get back to work.
you make baseless assertions, insult me, and then act indignant when I respond? your idiocy may not be up for debate, but the evidence is certainly mounting.
I didn't insult you. Quote me where I did. Now who's making baseless assertions?
&gt; I think you could very well be a fucking dumbass. sounds like an insult to me.
Did I say that out of the blue? And was it an opinion, or did I assert that as a fact?
yeah, that doesn't really have anything to do with whether or not it was an insult.
I agree with you that Heroku's ease of deployment certainly is a killer feature. The current deployment system is exactly the same as Heroku -- build your .gems file, init the git repository, then push it. I have some neat tricks that I wish to try with git to get extra functionality from it, but they require a bit more research.
I looked into SNI before writing that comment, and although it is a decent solution, I'm afraid that not supporting XP/IE6 is going to lose a lot of interest. For a cheaper alternative, it will definitely be considered.
What did you have in mind for payment system? I considered Monopoly money at one point, but got concerned over a Parker Brothers lawsuit. Joking aside, I do not want to deal with your credit cards any more than you want to give them to me. I have nothing but negative experiences with PayPal, but it will likely end up being PayPal or AlertPay based.
It was rather simple. Heroku uses Erlang for their routing mesh, and for good reason -- it's fast and it scales like a boss. I decided to use Ruby and EventMachine because I was more familiar with it. All of the nodes (servers) are connected together using this EM mesh, and they all share information like CPU loads, number of running dynos, amount of free RAM, etc amongst themselves. When a request comes into nginx, it is proxied randomly into the mesh. The node that receives the request checks to see if there is a running dyno, and if there is and it's not under severe load, it sends the request to it. If there is no dyno, or it is under load, that specific node will iterate through all of the nodes to find the best node to launch a new dyno on, then it tells the least-stressed node to launch a dyno. After it does, it connects the new dyno to the frontend and serves the request. It sounds really complex, but if you are trying to do a small scale setup for personal use, it is drop dead easy. Just use a single "router server" with a ton of "router clients" connected to it. Just do some logic checking when you get an HTTP request, and use EM::enable_proxy to pass information between. I think my original version was under 100 lines of code, and could handle up to 2,000 requests/sec on a 2.4 GHz Q6600 -- although it does have a single point of failure (hence why I have moved away from it).
* I am still unsure of how to get a free tier available. It is critical to allow people to test the system and to run low traffic applications, but I do not have a massive amount of capital and running a free tier is certainly not free to me. It will have bandwidth and storage caps, but there should be a free tier available. * Workers are already in the design, but I have made note of the cronjobs. I believe I can make cronjobs free at intervals smaller than a day, but I may need to limit the amount of CPU time they can use.
A dyno is literally a thin instance. 4 dynos is the equivalent of one modern CPU core. It is impossible to answer speed/size of them, because it will differ for every single application. A very simplistic Rack application can respond to 12k requests/sec on a single thin instance, while a super heavy Rails app may only get 50 requests/second (or even slower). You actually have brought up a very good point. I have noted down new functionality for the service: localized Apache Bench tool for stress benching the services. 
As I said before, pricing is not set in stone. If my current deal falls through then pricing will increase, but it is not difficult at all to get a dyno running at cheaper than $36/month. Even if I were to run this on one of the competing Cloud services, prices would still drop to at least $10/dyno/month, which is under a third of Heroku.
100 hits/day is capable of running on Heroku for free. You will either need to use S3 to store your images, or you can throw them in your applications "public" folder and serve them from Heroku (but they will probably hate you for it, as long as you retain a tiny website they should not mind). You are limited to 100mb total application size (that includes custom gems!) and 5mb of database storage.
Oh, so you have a deal with some hoster?
At launch, I assume basically none of the third party tools will be available. Hopefully over time as the project grows and gains interest, we could add third party functionality as people demand it. It would certainly have the basics, such as memcache/redis/etc, but the more complicated addons such as video rendering would simply not be possible without third party support.
The current plans are for only Postgres. MongoDB and Redis are certainly options that will be available, but would most likely require a bit of work to get functioning properly. 
Thanks. I know Duostack offers MongoDB (I'm currently part of their beta tests) but I'm not sure what their pricing will be when they publicly launch. It's always good to have a few options (especially at competitive prices). 
I know many europeans who don't want to have a creditcard or a paypal (or similar) account. But I guess transfer via wire is not really an option for americans due to high cost. Maybe bitcoins ;) Really, I guess at least paypal is a start.
I would be more than happy to accept wire transfers, but the issue is that gets really really expensive. My current business account has a $10 fee for any international wire transfer, which would mean you'd either have to purchase a helluva lot of dynos or pay yearly in order to cover the costs of the wire transfer. And when you consider how unused dyno hrs are prorated towards the next month, this gets kinda nasty when the customer purchases a year in advanced (if they only use 50% of the hours, a payment for one year will last two years, and who knows if they will still be using the service in 2 years -- I would hope they would! but still).
No problem. While I'm at it, I should tell you that I actually prefer Steak to Cucumber nowadays. I think that Cucumber is a good way to learn about BDD, though. And [I've also written](http://timeless.judofyr.net/bdd-with-rspec-and-steak) a real world example of doing bdd with rspec and steak, if that interests you.
That's what I'm using, and it's been pretty easy to deal with.
Ah! I saw this page a while back and have been looking for it. Thanks for writing this and reminding me of the URL. 
Any time. Feel free to PM or email me with questions.
Ok, harden the fuck up already. Is that better?
how about... fuck off
I just one one thing from my testing framework. Speed. I don't care if it doesn't have a nice DSL. I just want it to run thousands of tests really fast.
Paypal as the only option? Count me out. You won't have many serious clients going that route, look into something like recurly with a payment gateway set up.. 
How you been!
Still at it? Let it go. Get some sleep. And move the fuck on already. There's more to life than being a dick on the Internet. Good night. 
Can you write to disk? The biggest pain point for me on Heroku is asset packaging (see my [recent blog post](http://jimmycuadra.com/posts/the-challenge-of-asset-packaging-on-heroku)) and I'm very interested in how you plan to address this on your platform.
Heroku's tiering does a poor job segmenting the market, especially when it comes to database pricing.
Just use netbeans or rubymine or aptana
Once again, back at you. I didn't start this, you did. I wasn't a dick, you were. Nice use of projection, though. Dumbass. 
don't you get tired of making up new user names just to stalk me?
Well is Heroku pricing out of their ass or are they charging us triple cost?
Why troll, dude?
A bit of both. There's no mid-range price if you want a 1GB database - you go straight from free to $180/year. For someone who uses heroku primarily for the ease of deployment, that's ridiculous. Part of it is, that $15/mo for a 20 GB DB is expensive. The other part is there's no $30-$40/year price point. I mean really: a 5 MB DB? 3 floppies is what you get for free?
I just don't see it. You have to learn vi. you have to learn which plugsins make vi useful. You have to learn all of those plugings because they all have their own commands. All for what? So you can save a couple of microseconds? All those IDEs do everthing vim does and so much more and are much easier to learn and use. For example rubymine let's you jump to the definition of any method even if it's in a gem. You can easily jump around files, search directories, run rake tasks, run generators etc. I just don't get it. Use a proper IDE. It's much more productive.
Shit son I'd love three floppies.
I second that. + http://www.youtube.com/watch?v=mslMLp5bQD0#t=35m22s
Two words that silence your criticism and pretty much most other arguments of this nature browser, text editor, OS, etc etc: personal choice. What is more important is that you give differents techs a serious try, you may not actually like the new technology that you are learning but you may pick up on some tidbit that you do like and want replicated on your preffered choice.
&gt; For example rubymine let's you jump to the definition of any method even if it's in a gem. You can easily jump around files, search directories, run rake tasks, run generators etc. I can do all of those things easily in vim. &gt; Use a proper IDE. It's much more productive. This may be true for you, but it is not true in general. 
So this guy recommended FuzzyFileFinderTextMate (which I use), but I more commonly see references to the CommandT plugin (some guy in the comments of the blog post recommends it). If anyone has tried both, what are the differences between the two?
Except for the last line, but let's not bicker.
$ sudo make sandwich?
Keep watching to the end. I promise all of your concerns are addressed :-)
Excellent. Can't wait to incorporate it into all my projects.
After putting gem 'nonesuch', '~&gt; 1000000' in my Gemfile and running bundle install, the rest of the bugs in my application just went away. This quick tutorial truly made me a nonesuch master. You haven't tried them all until you've tried nonesuch.
[Here's a diff of the changes between 1.9.2-p136 and 1.9.2-p180](https://gist.github.com/834434).
You should submit that, it's brilliant. 
&gt;I can do all of those things easily in vim. Really? How do you jump to the definition of a function in a gem? Does VIM highlight the variables that you have created (assigned to) and never used again? What's the refactor support like in VIM? Does VIM highlight the classes you have misspelled? Does VIM know about the fields in your model (the database fields) and offer them up as code completion? The list goes on and on. It's just a primitive tool compared to modern IDEs. 
http://www.youtube.com/watch?v=mslMLp5bQD0#t=35m22s
I like blueprint but I don't see the purpose of compass really. Sass is good enough.
I decided to recompile all of my production ruby runtimes with 'nonesuch' as part of the standard library. All scaling bottlenecks have vanished.
responds_to?(:sarcasm) =&gt; false
NoneSuch monkeypatches object to make sarcasm return true 
For someone actually looking for some code checkout my [heroku-sinatra-pony-gmail-template](https://github.com/RobertLowe/heroku-sinatra-pony-gmail-template)
Yes, NoneSuch is web-scale.
Nonesuch is by far the best gem that I've ever used. I so anticipate my next Ruby app that I'm starting one right now even while I type this blog. It will create whirled peas and in record breaking time all thanks to Nonesuch! Kudos, Avdi! Next time, we eat a Godzilla
rvm to the rescue!
No real crits constructive or otherwise, just a suggestion that you slap an open license on the project (then pursue global domination as planned). I would love to set up one of my servers to act like Heroku, since I loads of small apps (blogs and the like) which I have made for clients. I love/hate Heroku for the same reasons you do, so something like this would be really awesome.
When can we expect this to be rolled into the core? I am, of course, using ruby 1.8.2 in my production environment, so I assume that when nonesuch is introduced to core ruby that it will be backported to 1.8.2 which is currently the widest used and most popular version of ruby.
 Object.class_eval { def sarcastically() !self end } false.sarcastically #=&gt; true (added to .irbrc)
? I have been in Europe so what in the hell are you talking about? Did you fall off the wagon again?
I am sick and tired of this obsession with the latest and greatest in Ruby. Ruby 1.6.7 is the *standard*; everything after that is strictly experimental.
I'd like to conduct an $800-a-head training session in advanced NoneSuch techniques at the next Ruby DCamp. That's cool, right? I'll give you a $5 discount.
Oh certainly! Especially because I sell out the values of Ruby DCamp at the first hint of a dollar to be made! And there are several million to be had in NoneSuch training! In fact, Avdi, I want to be the first Certified NoneSuch Master. Can you make that happen?!!?!?! I'll pay THOUSANDS for it!!!!11!!!!!
Clearly I should add this to my projects
That doesn't look like a diff to me.
Thanks. My coding skills are really entry level, but I will play with EM a bit. I haven't set up a proper development environment yet (excuses, excuses), but I was toying with [Beehive](http://getbeehive.com/) at [http://getbeehive.com/](http://getbeehive.com/). I know next nothing about Erlang, and this is relatively easy to work with.
railstutorial.org remains the #1 place i refer rails-newbies. the only resource i know of that walks you through git, heroku, rspec, and a solid amount of gems and shows you how to use them all.
YARV/KRI, because I've had no reason to use anything else.
I've been using MRI, but I really like where Rubinius is heading. Had some difficulty getting it to work with rails, though; there isn't a lot of information on trying to use it with existing gems. Course, it'd probably be a lot easier if I was using RVM.
Mostly YARV (Ruby 1.9.2) and MRI (Ruby 1.8.7). When my shit doesn't work, I want to be sure that it's my fault. ;)
Sorta stuck on MRI 1.8.7 at work. I don't use any other interpreters much. I don't do Rails (or web at all) and I've found the farther away from Rails you are, the less likely it is an non-std interpreter variant will actually be compatible. 
1.9.2 YARV and JRUBY
MRI, purely because it's what I'm used to using.
Yeah I've tried RVM for mucking around with different Ruby environments. What I'm trying to get at, is that I'm fascinated by the variation in the Ruby ecosystem. Does anyone really use Rubinius/IronRuby/XRuby etc.. ?
Have you run in to any funny compatability problems on 1.9.2 vs 1.8.7?
If you're interested in a more general poll, these are the results from 4355 last year: http://survey.hamptoncatlin.com/survey/stats#question_13
I believe EngineYard uses Rubinius, yes. They have a team dedicated to working on it, though a while back the team size was cut down some.
yarv
1.9.2 only for me. I'm lucky enough that I mainly work on fresh Ruby projects free of dependencies, so I don't have compatibility problems. As such, no reason not to blaze ahead!
JRuby, also for no real reason. It just "feels" rock solid for whatever reason.
yarv (1.9.2). it's pretty good.
`a = *[]`
MacRuby is really nice if you use it with XCode.
REE because it's what I use on the servers.
 b = [:x, :y =&gt; :z] works in 1.9.2 needs some moustaches in 1.8.7 b = [:x, { :y =&gt; :z }]
REE for 1.8 code. Performs well and there's really no reason not to run it locally especially with how easy RVM is.
Before replying to or believing anything [malcontent](http://www.reddit.com/user/malcontent) says, first read his posting history, to find out what kind of a person he is, and how he conducts himself. 
Not really — the biggest compatibility problems were ironed out between 1.8.6 and 1.8.7. The only thing I've noticed, is that 1.9.2 crashes quite a bit more often, especially in the presence of C gems and threads.
You should measure the startup times with and without nailgun. It is designed to help jruby in this regard, after all.
You should do a writeup about nailgun.
Mostly Ree/MRI 1.8.7 - can't move to 1.9.2 just yet.
he is saying that any/all testing frameworks force you to think about the code you are going to write, not just cucumber. you could take your original post, and s/cucumber/anytestingframework and it will hold true. the idea is to understand why the idea of testing is good, not why X testing framework is better than Y. 
I mainly use MRI 1.9.2, unless I'm doing anything with heavy threads like Zeromq. Then, via RVM, I switch to jruby. But on my system (OS X), I have nearly ALL of the main Ruby implementations installed. I've become fascinated with rubinius having just upgraded to the latest rubinius 1.2.1. Also have maglev, and ree installed which I sometimes use for compatibility reasons. 
We really do need your help... feedback and bug reports are crucial.
Awesome post. Saves a lot of the RSpec pain.
jruby
Still waiting for gems aren't shit. I'm not holding my breath though.
&gt; Still waiting for gems aren't shit. Care to elaborate?
MRI 1.9.2. Perhaps I might relapse into my old Java days and tinker with JRuby more. Unfortunately the JVM startup time is dog slow on x86-64 machines, due to no Client VM Profile that tailors the JVM for Desktop usage. Maybe Oracle will get around to finally adding a Client VM Profile for us 64bit Desktop users. [Rubinius](http://rubini.us/) is also another contender for my day-to-day Ruby implementation. They do need to fix their FFI API ([got out of sync from upstream](https://github.com/ffi/ffi/issues#issue/76)), but other than that it's pretty solid.
 a = nil foo(*a)
Perhaps you meant, poorly written C extensions crash 1.9.2. :)
You should measure all startup times on 32bit vs. 64bit.
Probably true, though I don't really care… :) If it crashes in 1.9.2, and doesn't in 1.8.7, either the gem or Ruby 1.9.2 is unusable.
You should always label your axes.
No.
http://xkcd.com/833/
I don't blog.
Do it here.
MRI 1.9.2 for almost everything. Unfortunately it consumes more battery power than it should (you should all checkout this patch: [ruby-core:33456]!). I would be using RBX for more things if the base memory consumption was lower.
I'd like an answer to this one too...
Use your rails app and a web browser: * write code to select an available TCP port on the local machine * write code to launch an appropriate browser. You could ask these to be configured at installation - or hunt them down dynamically. The biggest issue is how to communicate with the user when this isn't working. You might need to write a small amount of actual GUI code (wxWidgets?) to manage this (or use JRuby and some basic Java/Swing dialogs if the "conversation" with the user is simple enough).
[Shoooooooes!](http://shoesrb.com/)
I'd say its mostly roll your own for now. That said, it should only require a few commands in a bat file to set everything up. The first issue you would face would be installing a ruby interpreter. The best way to do this would be with the [ruby installer for windows](http://rubyinstaller.org/). It also supports [silent installs](https://github.com/oneclick/rubyinstaller/wiki/faq#silent_install), so you can automate it though shell scripts on windows. After this, you should be able to do everything else in ruby. The next step is to get your application. If it's hosted on github, then you can just download it directly from there (They can create archives on demand of any commit). The next step I would say you have two options. Find a database that will let you do a silent install like the ruby installer or create an application on heroku to act as a remote database and use Active::Resource to connect to the remote application. The first approach has the benefit that everything is local and no internet connection would be needed. The second has the benefit that no database needs to be installed on the local machine. Next you'll need to get the gems your application depends on. You'll have to be careful which dependencies you use because some gems don't support windows and some gems have to compile natively which may be iffy (though, ruby installer has done a lot of work on this). After that, its the basic things you do to get a rails app up and running (rake db:create, rake db:migrate, rails s). There may be a way to make the server a service so that its always running or you could have something to start and stop it such as a bat file.
&gt; write code to launch an appropriate browser. Might want to use something like [Launchy](http://copiousfreetime.rubyforge.org/launchy/) for that.
I haven't seen it posted on reddit, so I want to ask the community, what do you think about? What have you used it for? What have you used in place of it? 
why is this prefixed by "ruby metaprogramming", bitch? it's just a wrapper for an api. 
[Bowline](http://bowlineapp.com/), no?
Stay far far away my friend, that road leads to dark things.
Oh dear god. We used it for a project at work, thinking "Oh hey, this should be easy." WRONG. As soon as you want to stray the slightest bit away from the most menial of tasks, it becomes horrendously difficult. Also, the documentation sucks.
Care to elaborate?
I've had some good experiences but i found I really need to hit the code over docs
just go for formtastic ,nifty scaffolds 
Sure. For one, it seems to be unsupported. Two, the latest version is incompatible with Rails 3. Three, it's really really hard to debug where things go wrong, as there is so much metaprogramming involved. Finally, it allows you to essentially hang yourself by building an interface in ActiveScaffold. It's just customizable enough to get started, but when you need something more than it can provide, hello rewrite! If all you want is boilderplate admin interfaces, try the new Rails Admin Engine: https://github.com/sferik/rails_admin We just finished ripping out ActiveScaffold from a large application. We went from 20k LOC to 10k LOC, with essentially the same functionality. That's not even including all the custom views you have to write if you want custom looks or functionality.
Your best options. Jruby with monkeybars or glimmer. Shoes With jruby you Can deploy a jar. 
Waste of time. 
There should be something that acts on simple recordsets. I don't know why all of these projects insist on making their own activerecord calls. I ought to be able to just pass in @people along with a config that describes the output 
why don't we all just get along..and make a programming language called Pupy? The mixture of PHP and Ruby. Downvotes here I come.
"Php is better because I like to practice my typing ... Ruby makes me type less" - Thats a new argument ...
It took me way to long to realize this was sarcasm. :(
I'm upvoting this.
Poopy - please do this!
This is a really interesting article and I hope the guy redoes his benchmarks in production mode to see how much of a difference it makes.
ohh I got it, you are indian.
&gt;I want my keyboard smoking after typing out a class definition. Clearly the writer does not know how bad typing is for their hands. Furthermore I think the coder is inexperienced with PHP, I've been using it for a while (I'm learn Ruby now) and the code examples they have used are awful. For example, they could just use: class Address { public $name; } $address = new Address(); $address-&gt;name = "Your Name"; Instead of that setName(); jazz. 
[Phuby on Phails](http://www.youtube.com/watch?v=lsWKjS6Vufw) sort of allows you to mix them.
This tipped me off in the first paragraph: &gt;We celebrate our diversity. Is it hayatack, needle or needle, haystack (former php developer now working in a ruby shop)
First of all his blog post was sarcasm :) Secondly, the reason for using that setName(); "crap" is to provided proper encapsulation and is considered good practice to do. I'll copy/paste the answer the author gave for this since it's 100% spot on. &gt;The whole point of having public getters/setters is that you're telling client code 'call this method to get this data, don't worry about how I get the data to you'. There's a host of things the object could do internally to generate a given value. It could get it from a database, get it over the internet, cache it the first time blah blah blah, the point is that client code shouldn't care, now or ever. The fact that there are private members that represent the values internally is entirely coincidental. I'm sorry but it looks like you are the inexperienced coder.
Say what? ... Oh, that's good.
I'm a rubyist and don't particularly like PHP but it has nothing to do with the syntax or language. I simply think Ruby lends it self better to rapid development. In the end the language really doesn't matter. It is a tool set we use to help other people. Our customers. They really didn't care that FB is written in PHP (now some version based on a C++ derivative with the same syntax (ouch)) or that Twitter was a mix of Ruby, Scala and Java. It really doesn't matter except for the individual programmer. It should be invisibile. Mind you, Hume's missing blue probably suggests that there is a rapid PHP developer out there. But then that is apriori knowledge. I'm sure I will never meet her. 
So there I was, thinking that we're over this. A language is as much of a tool as the post author.
There was a notable PHP framework called [PHP on Trax](http://www.phpontrax.com/) which had poor and underwhelming documentation (a taboo in the world of PHP third-party libraries), and one of our developers had nicknamed it "Phails." Somehow the name seems appropriate for any framework attempting to advertise as a RoR-like framework.
Having set* and get* methods is good for lazy-loading where resources are not loaded at instantiation, but if it's just `return $this-&gt;name;` and `$this-&gt;name = $value;` then that is simply ludicrous.
Ludicrous indeed... until the underlying implementation changes and things break. 
&gt; Instead of that setName(); crap. Except then you are directly modifying instance data, which is (theoretically at least) a no-no. In ruby: class Address; attr_accessor :name; end causes two methods to be added to the Address class, "name" and "name=". "name" is a getter that returns the "@name" instance variable and "name=" a setter that modifies the "@name" instance variable.
Ya, this is a very legitimate argument for doing things "the right way" from the beginning. Sure, it may just be simple access/setting *now*, but what happens when someone decides that the name on the address has to be all caps? Or &lt; n characters? Or any number of other stupid things that if you did things "the right way" require relatively localized changes to the code base. The alternative is not nearly as neat and tidy.
Python dev here, curious about one thing that cropped up in this article: How sandboxed is the monkey-patching that you can do to the core language? In the example he turned addition into subtraction. Would that only affect whatever package that line of code is in, or would it change Ruby for all other packages loaded alongside it. So for example, if I include modules A, B, and C, and B monkey-patches some stuff around, is that going to change how A and C run, as well as my own code?
The monkey-patching is global, and yes, it has been a problem in the past in the Ruby community. A major reason it's been a problem is that Rails has an important support library called ActiveSupport which, while providing lots of good helper classes, also does tons of monkeypatching on the standard library. A potential solution to this, tentatively called *refinements*, has been proposed for Ruby 2, with a patch written for it. Unfortunately, it currently means an across-the-board performance decrease and the JRuby guy has said it would kill a lot of optimizations he does in JRuby. [Here's a proper writeup about refinements](http://timeless.judofyr.net/refinements-in-ruby)
Honest answer here from a Ruby dev. It's a problem in the language, but not as big as you'd think due to culture. Monkey patching is rarely used in day-to-day code in the sense of overwriting core libraries. Even ActiveSupport mostly does adding to the stdlib, not changing existing behaviors. What is useful though is being able to reopen a class later on to add more to it. A real example - There's a library I use called spawner. It is a way to generate 'fake' instances of a class for use in testing. # In my_thing.rb class MyThing ...... end # In test/spawners/my_thing_spawner class MyThing spawn do |s| .... end end The idea is that I am reopening and defining additional behavior on the class, but only when I want to (when I load the test env, and the test/* source tree. 
Formtastic: have an upvote.
I did not know about rails_admin. Thank you for showing me something new!
Except you can do all that in PHP without pages and pages of setter/getter methods. Something an experienced PHP coder would know.
Care to share an example of how you would do that?
So taking the address example above. Later down the line you want to make a getter to convert name to uppercase. class Address { private $name; function getName() { return strtoupper($this-&gt;name); } function __set($k, $v) { method_exists($this, 'set'.$k)?$this-&gt;{'set'.$k}($v):$this-&gt;{$k}=$v; } function __get($k) { return method_exists($this, 'get'.$k)?$this-&gt;{'get'.$k}():$this-&gt;{$k}; } } $address = new Address(); $address-&gt;name = "Your Name"; echo $address-&gt;name; // YOUR NAME [Property overloading](http://www.php.net/manual/en/language.oop5.overloading.php#language.oop5.overloading.members). I realize the set/get methods in that example look ugly, but I wrote it quickly and to save space rather than look pretty. I personally like this approach as you can use if you need it on a per property basis, rather than having to use it for everything or nothing. I can understand it looking odd to someone used to something like C#'s properties implementation, however. There is also a small overhead, but nothing significant I've encountered in real world scenarios.
Not so; the master branch from activescaffold is not Rails 3 compatible However, vhochstein's fork works great with Rails 3 https://github.com/vhochstein/active_scaffold I saw rails_admin too, but I found that it didn't provide as much power or flexibility as activescaffold. Thanks for the LOC count that's interesting. As for custom views; I think that's a route you want to avoid by just mitigating with css. If a controller/view requires more than expected of activescaffold it should just be done however preferred. Support seems to be importing but there are still a lot of todos
For a frontend or where an embeddable scaffold can't be used; Absolutely.
Realized it at about the time I saw attr_accessor vs PHP's class definition. Though, reading some of the comments in the link, it's rather clear a lot of them still don't realize it is satire (likely the same people that have never used ruby).
Yeah, that would work. I would still feel uncomfortable knowing that I am accessing the class vars directly (that they are declared public). But that may be an unfounded fear.
Well, it also encourages fat controllers (an antipattern), or at least did based on how the people that originally wrote the app I work on did it. Also, when we were upgrading our rails 2 app to rails 3, we tried the vhochstein's fork, but it didn't work for us. Looking at the code and commit history, it really seems as if they diverged LONG ago, before Rails 3, and his fork just seems to work with rails 3. Either way, it was too incompatible with the other one and we decided to rewrite instead of upgrade/debug the fork. You'll be saving yourself a lot of stress if you avoid it, I've been fighting with it for over a year now.
I'm replying to this.
Sort of?
The author misses a much cleaner (and more performant) solution: if r == P #do_something ... elsif r * 2 &lt; Q #do_something ... elsif some_test(r) #do_something ... else raise "unpossible" end can be: case when r == P #do_something ... when r * 2 &lt; Q #do_something ... when some_test(r) #do_something ... else raise "unpossible" end While I understand his wanting to pass in r via the case statement, that smells too much like a typing requirement to me.
Saw this coming... The rest of the talk can be found here: http://confreaks.net/videos/198-rubyconf2009-worst-ideas-ever Worth the watch, it's absolutely hilarious.
Fair enough, but I don't think it encourages fat controllers, you don't need to def as much for starters. I think the issue some devs get into is they don't select the right use case. thanks for the notes 
http://philosophistry.com/scans/2010/lol-face.jpg
I only understood when I got to the typing part.
I would like to add, I think this applies here: "with great power, comes great responsibility"
I got tipped off by the love for curly braces, but just to point out that Ruby doesn't mind that syntax if PHP developers need it to feel better. And you can actually write your own getter and setter methods if you prefer :)
:needle =&gt; needle, :haystack =&gt; haystack
C++ derivative same syntax what? Are you referring to HipHop? It translates PHP, sans eval(), into C, which is then compiled with gcc. It's still PHP. This is a pretty great thing IMO. I imagine PHP people must benefit from it considerably. 
My first favorite thing is passing blocks and yield, my second favorite is that hashes are standard as arguments
Why would you subtract that? It's relevant.
I especially like that if your hash has all-symbol keys, in 1.9 you can pass it like this: some_method(option1: 'this', option2: 'that')
The fact that you can do things that have massive side effects is counterbalanced by the extreme emphasis on test coverage as a community standard. If any broad negative side effect happens, your tests will show it immediately. And I think this is really, really good. Because you not only cover crazy predictable side effects with tests, you also cover crazy unpredictable ones. And this has saved my ass *countless* times. It's simply impossible to work on a programming team and not bump into each others' (wrong) assumptions about the code, because a point gets reached where it's impossible for any 1 coder to model the entire codebase in his/her head. Adequate test coverage prevents that. The tools are out there, they are mature, and they are nice.
I think this post would work better if you asked specific questions.
Every morning starts with `terminitor start`
I would like to note that if you are only concerned that monkey patching is not-sandboxed then you should also be aware there's nothing in Python to prevent one from modifying third party library either. Sure, you can't modify primitive type like `int` or `float`, but what portion of your code relies on nothing but primitive data type? 
why that's absolutely delightful
Ruby is fast and stable enough for me. Why do you want others *opinions* on that? Decide yourself. Search some benchmarks if you don't want to make them yourself.
Proggit consists mostly of windows programmers. To them programming means drawing forms with visual studio.
Oh I agree. In Python we have a mantra that goes something like "We're all adults here" in relation to there being no notion of public/private variables, etc. It was just mere intellectual curiosity, I don't know that much about Ruby. Adequate test suites will certainly identify that problem immediately.
Yep, quite aware of that. I was just curious :)
What you hear about Ruby's performance relative to other popular languages is not a myth. It is generally slower. The myth is that it matters all the time. Web development is naturally high latency (&gt;50ms), and most people aren't servicing 1k requests per second all day. You'll likely see IO limitations before your app becomes CPU limited. That said, the C extension API is wonderful. I like to (ideally) prototype in Ruby and replace problem areas with C as needed.
I'm sure it qualifies for "use with", but I don't remember if it qualifies for "mix with", which in my mind has ruby and php on the same page.
omg rumors!
Same here. My productivity in Ruby is better than any other language I've used (C, C++, FORTRAN, tcl/tk, perl, python, etc). I can quickly come to the best design and then I can code the bits that need more speed in C. The Ruby C API is the best I've encountered in scripting languages. I've never had an issue with stability. Occasionally you'll come across a Gem that is abandon-ware, so it is important to make sure anything you use is being actively developed. The greatest benefit of Ruby to me is getting more done with less lines of code. That means it takes less time to write and it costs less to maintain. And well written Ruby code reads almost like a subset of English. I could never go back to a language that didn't support features like coroutines, closures, open classes, etc. 
Programming languages generally come from one of two schools of thought; provide functionality to keep the programmer from hurting himself, or give complete freedom and assume the programmer knows what he is doing. Ruby falls in the latter category. Languages like Java and C++ more in the former. Typing and const-ness either seem to be restrictions to improve correctness, or training wheels that get in the way. 
thank you!!!
excellent post
The point is establishing a predicate on r, not saving typing. In that way, it's more intention-revealing. I would also never use performance as a criterion for coding style unless a certain piece of code had actual performance problems. However, the author doesn't provide a real-world example, and that's always suspicious. I would probably code it just like you.
It's just a fancy while loop right?
review the code before comment please https://github.com/potomak/thounds/blob/master/lib/thounds/client.rb
Pretty much, it just runs the check every 1/10th of a second rather than the continuous check from a while loop..
This was how i imagined Ruby -- as a young japanese female -- not as the unattractive white chick in that link. http://demo.wpgpl.com/wp-content/uploads/2008/10/japan-girls.jpg
Someone apparently doesn't know what satire is.
Yeah, because using a picture like that would have reduced all of the "sexism" complaints I would have gotten ;-)
Looks like the site was using PHP and broke?
Go watch our talk [Worst. Ideas. Ever.](http://confreaks.net/videos/198-rubyconf2009-worst-ideas-ever).
Is there any reason to use REE if you are using 1.9.2? Just curious.
I heard Rails 3.1 was running with Lindsay Lohan, shooting heroin and wearing hot pants. For realz.
Yes ... its designed to use less memory.
I did! When it first came out! And I was reciting from memory! Which isn't all that good! Your nick didn't click at first, either. Anyhow, it's great fun as far as atrocities go, which is why I mentioned it :)
So none of the patches from REE have been applied to 1.9.2? That seems odd.
So you're a sexist prat both in _and_ out of IRC? 
This was your perfect chance to start some new crazy rumors!
This whole post boils down to "Ruby does things different than I expect and challenges my core assumptions about programming, so its must bad".
I'm sick and tired of hearing about "Monkey Patching". There's two things people shit talk ruby with: "performance", and "monkey patching". Coming from PHP they're both bullshit arguments. First, let's talk performance for a minute. When you use a real OOP web framework in PHP, it consistently under-performs Rails. I've seen benchmarks where Zend doesn't even get a THIRD of Rails' performance.. and that's not getting into Sinatra and straight up Rack. Rack hello world can deliver over two thousand hits a second on my low-end macbook pro. If you're getting more hits than that, spawn a couple new processes.. you can do that for free because you're making a web site and it's stateless. If that's not enough, then honestly, you're doing something crazy and probably shouldn't be writing it in PHP or Ruby (or you should utilize caching.. and your DB will probably be the bigger bottleneck anyways). Now, about "Monkey Patching". It's almost never used. It's used in very rare cases where it is absolutely required to do something. Ruby developers do not causally overload the addition method on Fixnum for shits and giggles. They recognize they would be chastised for going overboard, and that there's probably a better solution to whatever they're trying to solve. That said, let's say I need to do some crazy tracking to figure out how many times I add on the system. Now I have the power to actually do that. There is nothing wrong with intrinsically having that ability, yet the PHP people flip their nuts when they see this. Do you guys only have butter knives in your kitchen? Further, for the rare few "monkey patches" that are almost never used, ruby developers write extensive tests. And then they test everything else in the system on top of that. Those tests will let you know very quickly if there's a fundamental problem with a "monkey patch". PHP is so lacking in basic, even primitive testing that their cohorts cannot even comprehend the concept of a test. I know, because I used to be a PHP programmer, and then switched to Ruby when I realized it was a significantly better language. Lastly, even this rare, almost never seen issue is going away, because Ruby 2.0 is going to support the ability to namespace system class extensions. So you'll be able to "monkey patch" within your own module, avoiding touching any other code in the system. Oh, and Ruby 1.9 almost doubled the performance of Ruby.. so even your incorrect critique of ruby performance is being progressively eliminated. Seriously, at what point do you run out of excuses and just realize your programming language is an anachronism that is in dire need of modernization? Why don't you join us instead of wallowing in your own ignorance and stupidity with a dinosaur programming language? Seriously, provide some evidence that this is actually a problem or shut the fuck up.
Seems to be gone
Whatever Rails wants, Rails gets....
Do you actually use any local documentation for gems, or do you just look at the github page and online documentation? I can't say I've ever seen anyone refer to RDoc locally, except becoming annoying with how much time it steals when doing a gem update.
Just wonder how often you have to update your gems and get that feeling.
As a developer I install gems all the time. By now I type --no-rdoc --no-ri as a reflex to shave off those few seconds.
Yeah, a pretty fair amount, but in addition to that I can also say that I never use the local documentation - it's just quicker to use the online documentation, since if the documentation is insufficient, looking at a gem's recent issues is a quick next step. 
+1 no one reads local documentation, and it takes 5 fucking minutes to install. This pull request should be re-opened.
Maybe you should try decaf.
If this change will encourage gem maintainers to actually put the fscking documentation online, I'm for it.
[http://rdoc.info](http://rdoc.info) usually serves me well.
Except that only shows gems stored on github.
/etc/gemrc is your friend
Yes, people do read the local documentation. And guess which gem takes 5 minutes to install? The rest are pretty quick. We could always work on making rdoc faster, too.
http://www.rubydoc.info provides you with access to the documentation of projects on GitHub and to the documentation of projects on http://www.rubygems.org as well.
I use the local docs when I don't have online access, which happens frequently when I'm travelling.
I suppose that would be a good reason for local RDoc :) still, it seems that as a default it just doesn't make a lot of sense. 
No it doesn't. Search for 'syndication', for example. It's on rubygems.org, but missing from rubydoc.info. Update: Looks like it's *supposed to* list docs for everything on rubygems.org, so I've entered a bug report.
Large gems with a full documentation take 5 minutes to install. Also would be nice if RDoc was faster.
you're searching in the wrong place: http://rdoc.info/find/gems?q=syndication your docs are there: http://rdoc.info/gems/syndication
According to his [profile page][1], he’s just 14 years old yet. (And [cross-submitted the link to HN][2] as well.) [1]: http://sorah.cosmio.net/ [2]: http://news.ycombinator.com/item?id=2263985
Nice to see some actual working code behind a rails app in production
Whenever you install a gem gem install whatever by default it will run it through rdoc, ri, and yard, which are 3 automatic documentation generators that will generate documentation for the gem and store it locally. This usually takes a while, anywhere from several seconds to a minute or more for gems with many dependencies. This is a request to merge a change to rubygems that would turn off the automatic documentation generation by default, and let people who want to have the local documentation explicitly say they do with flags like --with-ri. 
how many people read local documentatino? If you do a survey i bet it;s no more than 10%. I bet that 90% of people just do a google search for the docs. Should the default option really cater to the 10% rather than the 90%? 
When you install a Ruby gem using "gem install something" it installs RDoc and RI documentation by default. This can be a time consuming process, and is kind of annoying since most people don't look at the documentation locally for gems. Most everyone I know runs the command as "gem install something --no-ri --no-rdoc" to prevent the installation of the documentation. This change is to make "--no-ri --no-rdoc" the default when you run "gem install something"
[Fitting name.](http://en.wikipedia.org/wiki/Shotacon)
you got owned, bitch
for a php coder there is no reason to look into anything else since node.js is available.
I can't give you a definite answer since I don't know exactly what you are doing. But you should take a look at [mechanize](http://mechanize.rubyforge.org/mechanize/) it's written by they same guy who wrote Nokogiri. Pages are Nokogiri objects but the mechanize agent essentially functions as a browser. 
You could use Capybra (https://github.com/jnicklas/capybara) with either Culerity + Celerity for a headless html unit browser, or you could use Capybra with webdriver (selenium2) to open a real browser and scrape the data down. If your running this on your server, you can run xvfb to load the pages without a full desktop setup. I really like webdriver, it supports multiple browsers and seems to get the timing issues right. You can also use webdriver or directly since there is ruby bindings.
I'm no expert, and rarely define custom exceptions, so for me I get away with defining them in the file I use them, because I generally don't need to use a custom exception all over the place. I'd say if you need to use custom exceptions all over the place, on the module level would be the way to go. E.g. MyFooModule::FooModuleError
Not sure if this is what you're after, but I know a guy who uses this, perhaps it could be bent to fit your needs: http://watir.com/
And store the file in /lib or app/models/exception, etc?
code that is just code and not a model or whatever is typically placed in /lib. It really depends on your needs. There really is no standard place for putting exceptions. Sometimes you need to use one inside of a model, in which you could just define your exceptions right in there. I don't think you should worry too much about where things go just yet, I usually work those details out when I've at least got some kind of prototype.
Love it when hardcore programmers are also good writers. Good read in a long time - pragmatic, humorous with cult references.
[ZombieJS](http://zombie.labnotes.org/ ) - javascript in a simulated browser environment that downloads and runs all scripts. It's JS, so you can use selectors. Pretty cool: var zombie = require("zombie"); var assert = require("assert"); // Load the page from localhost zombie.visit("http://localhost:3000/", function (err, browser, status) { // Fill email, password and submit form browser. fill("email", "zombie@underworld.dead"). fill("password", "eat-the-living"). pressButton("Sign Me Up!", function(err, browser, status) { // Form submitted, new page loaded. assert.equal(browser.text("title"), "Welcome To Brains Depot"); }) }); 
This was a really fun *and* informative video to watch. Thanks!
Sounds like you need JS support. Best bet is Capybara with the Selenium driver.
I typically store those things in app/extras and add app/extras to config.autoload_paths. The problem with lib is that the code in there does not get reloaded in development mode.
[citation needed]
Quite possibly the greatest description of Ruby I have ever heard: &gt; Of course, you know Ruby is a late bound language, every message sent could conceivably fail to find a target, potentially resulting in an uncaught exception and program termination. There’s shared state, wild orgies of mutation that disallow any reasonable attempt at automated parallelization. Program proof is as oxymoronic a concept as military intelligence. It’s a very messy affair of programming and meta-programming and meta-meta-programming, which, for the love of Lisp, could be done so simply with macros. There’s all this eager evaluation and complete disregard for purity. Despite vast odds, somehow programs are written that actually run.
I love this whole article. It's all so well written. The only complain I have is that they advertise Ruby as being good for graphical applications. Not that it wouldn't be, but right now it just doesn't have the library support, and seeing as Python and native code have the main stage in that area, throwing one more dependency into the arena is a bad idea.
This was a fun discussion to watch. I'm a fan of the SOLID principles, but applying them in Ruby is not as straight forward as you might think. Many of the standard approaches and practices associated with the SOLID principles exist to overcome constraints in languages that assume a static type check at compile time. Here are some other presentations that talk about applying SOLID to Ruby: [SOLID Ruby by Jim Weirich (at RubyConf 2009)](http://confreaks.net/videos/185-rubyconf2009-solid-ruby) [SOLID Object-Oriented Design by Sandi Metz (at GoRuCo 2009)](http://confreaks.net/videos/240-goruco2009-solid-object-oriented-design)
Nice tool. Very useful. +1
Who's throwing these exceptions? Put their definitions in or close to that code.
Who needs enums when you have symbols? Understand symbols before trying to shoehorn your preconceptions into Ruby.
Symbols are certainly useful, and I would never suggest using c-style enums in most of the situations that one would use symbols. There are, however, a few scenarios in which enums provide a more elegant abstraction. As a toy example, imagine a calender event implementation: class CalendarEvent Priority = enum :low, :medium, :high attr_accessor :date, :priority def initialize(date, priority = Priority::Medium) @date = date @priority = priority end end The usage of an enum here allows the encapsulation of the possible priorities that an event can have in a single, lightweight type (CalendarEvent::Priority). As a side benefit, the automatic integer associations give us priority comparisons for free (CalendarEvent::Priority::Low &lt; CalendarEvent::Priority::High == true). Could this same thing be accomplished by just using ints? Or just symbols? Sure it could. But the additional abstraction provided by an inline type definition is something that I consider to be a real advantage, and the dual name/value nature of the enum here happens to give us the best of both int and symbol implementations. The advantage is increased in cases where a class has a number of members that each can take on any of a specific collection of symbolic values since associated enum types provide simple, executable documentation regarding what values are supported/expected. Symbols are great when you need keys into a dictionary, var-args emulation, etc, but when you have a finite set of symbolic values that something can take on, what you're really talking about is a **type**. Enums are simply lightweight, in-line type definitions. In fact, the implementation linked here is literally that: enum() metaprogrammatically constructs a new type for you on the fly. Your point is an important one, and I'm glad you made it - the difference between symbols and enums is very subtle, but very important. I'm going to try to distill this answer and add it to the readme for the project.
Very well said and well thought out. I look forward to reading more. I admit my original comment was a bit flippant (and driven by the evening's alcohol consumption ).
In your ass?
For your situations, I'd probably just do this: [:FOO,:BAR,:BAZ].each_with_index {|s,i| self.class.const_set(s,i) } Or, if you want it in a module or class: module Blah [:FOO,:BAR,:BAZ].each_with_index {|s,i| const_set(s,i) } end Yes, I realize your approach would allow for some additional type safety (e.g. return false if trying to compare the enum type with an int) depending on how much you want to add into your enum implementation, but I see few applications where I'd consider that worthwhile. 
Looks like a good way to do it. As for the module/library thing, in this case you're there's a library called URI that provides a module called URI (typical of the standard library and probably many others). So here you could really say either. But technically a library (which might also be called a package, or a gem if it is one) need not provide any modules or it may provide multiple modules.
http://www.simonecarletti.com/code/public_suffix_service/ 
A simple regexp ca take the domain out of the host. The domain is the TLD, a dot, and another name, possibly with another dot and more stuff on the left. I'm on my iPad here, so typing regexp is not really an option, I can't even type some of the characters need. 
Yeah, that wasn't clear from the site. They've changed it now so that the modality of the search box is indicated on the default page, i.e. it indicates that by default it only searches Github projects, and you have to select Gems before it'll search those.
&gt; enum types provide simple, executable documentation regarding what values are supported/expected. Funny you should mention documentation, because one advantage of doing things the normal Ruby way... class CalendarEvent class Priority LOW = :low # Indicates event has low priority, is optional MEDIUM = :medium # Default priority for events if no value is supplied HIGH = :high # Events which must be attended end def initialize(date, priority = Priority::MEDIUM) @date = date @priority = priority end end ...is that you get usable documentation out of Rdoc.
figured this out... blog post coming soon.
No need for regular expressions. URI.parse("http://www.example.com/").host.split('.')[1,2].join('.') 
It wouldn't be hard at all to add a YARD plugin for his enums to generate docs for them. Given how much metaprogramming goes on in Ruby, that's really the only way to support the majority of common constructs besides `attr_{reader,writer,accessor}` anyway.
One thing I'd suggest: since you're trying to encapsulate this into a type, wouldn't it be important to provide some kind of assertion to guarantee that the `priority` argument actually be in the enum type? C++'s enums are safe in this way where C's aren't: you can't assign any old int value, or a different enum value, to a variable of type `enum priority` without a cast, which itself is frowned upon. Since we can't very well implement that level of type-safety in Ruby without serious changes (well, my thesis is working in that direction), perhaps the base Enum class should have an assertion method which takes a value, checks if it's one of the Enum values, and raises a custom exception class if it fails. That way, if your `initialize` method up there wanted to check, it could have a one-line call to `Priority.assert(priority)` to make sure it got a valid argument.
 URI.parse("http://www.example.com/").host.split('.')[1,2].join('.') # returns example.com URI.parse("http://www.bbc.co.uk/").host.split('.')[1,2].join('.') # returns bbc.co 
Nice. By the way, why did you choose the syntax `enum x, y, z` instead of the more-standard `Enum.new x, y, z`? There are 'class generators' that use that syntax already like `Struct.new` (which some people use as `class Employee &lt; Struct.new(:name, :record)`. :)
Oh yeah, sorry. Should be [-2, 2]. irb(main):010:0&gt; URI.parse("http://www.oops.i.failed.to.test.enough.example.com/").host.split('.')[-2,2].join('.') =&gt; "example.com" 
Right, but what's the benefit? The standard syntax is clear, it doesn't require significantly more typing, and it works without any YARD plugins or external dependencies.
I mean, I'm not saying I'll be rushing out to use this guy's enum code or that I'll ever touch it, but his solution *does* provide additional benefits if you want those additional features. For one, you can have an ordering on these constants. I doubt I'd find that too useful; more likely, he should provide assertions that are cleaner than possible otherwise: Priority.assert_member(priority) vs. unless [Priority::LOW, Priority::MEDIUM, Priority::HIGH].include?(priority) raise ArgumentError.new("Invalid priority #{priority}") end which you'd probably end up refactoring due to the duplication of the constants, which means even more code. Since duck-typing to ensure correctness doesn't make as much sense for enumerated symbols, checking that a given symbol argument is in an allowed set of values is pretty common (see the Rails source code).
Well, you can have an ordering the normal way too. Just use integers rather than symbols. As an aside, I think this is the first time I've ever seen someone wishing that Ruby was more like C.
Thanks, I'd never heard of this!
 URI.parse("http://www.bbc.co.uk/").host.split('.')[-2,2].join('.') # returns co.uk Btw, 'co.uk' is a TLD. The domain for the above is bbc.co.uk. Taking the last two elements isn't going to work for all websites. 
You kind of only responded to the point I said was weaker, and didn't respond at all the the point I said was strongest about his solution: verifying inclusion in the enum type. I even pointed to a very real-world project that does that verification a lot. As an aside, do you use `Struct.new()`? Because using that requires a special case in documentation tools, and it's only a little bit syntactically different from class A attr_accessor :member1, :member2, :member3 end And of course attr_accessor also has documentation special-cases, but we'll ignore it. So why use Struct? It seems like a terrible C-ism to me. Of course, people write plenty of struct-like classes, so plenty of people use `Struct`, and there's plenty of reason to use it. It can implement some speed improvements (which it does), and it provides some general-purpose methods like initialization and comparison. Is it a super enormous win? Perhaps not, but there is value to be seen in it. I don't deny that people use the enumerated-value pattern a lot, so I think that adding some metaprogramming to provide them might possibly see some value, and won't simply call it stupid because it's like C.
Just a sidenote, there's an excellent post by James Earl Grey that I can't find right now, but if you use the block form of Struct.new, you avoid the dreaded "superclass mismatch" error if the file is reloaded. class A &lt; Struct.new(:a, :b) def silly end end if Rails or something reloads that file, or you reload it in an IRB session, it'll bomb out, because it'll think that you changed the superclass of A. But if you write: A = Struct.new(:a, :b) do def silly end end You'll only get a constant reinitialization warning when the file is reloaded, which at least won't fail to execute.
The String class allows you to do this very easily. Simply set your string variable and call a range on it. For example: s = "testing"; s[1..3] would equal "est". The class reference is here http://www.ruby-doc.org/core/classes/String.html.
Good catch!
I actually wrote this because I found myself writing that same code in a few places. This is an attempt to encapsulate that implementation in one place and make my code a bit more readable. I find that: Things = enum :foo, :bar, :baz Takes less time for someone to read and grok then: module Things [:FOO, :BAR, :BAZ].each_with_index { | s, i | const_set ( s, i ) } end It's also slightly quicker to write. Just having an explicit name (enum) to go with the const_set-ing operation is a win for code readability in my mind. The added bonuses of having slightly increased type safety and some other additional helpers automagically defined just sweetens the deal.