So I've only recently had my first ever success at solving a complex problem using a programming language. It happens to be with Ruby but this applies to just about anything. What really helped me was to not program but write out a detailed list of "things that I need the program to do" and then reorganize and rewrite that into a program. Literally I had to translate and then refactor each bit of functionality into something that worked well and was robust for all my use cases. What I kept getting stuck with in the past was that translation problem and it sounds like you are hitting that wall. Break your problem into really small parts and solve each one. Then you start feeding each solution into the next part until what you have spits out what you need. First, what you are proposing you don't need rails or rubymine. Keep it simple. Use Ruby, gems, terminal, and a simple text editor until you find your way. Then you can add layers of abstraction and complexity. 
I love this post, because it gives me a chance to evangelize this new gem I'm working on, and maybe get some feedback on whether it's worth pouring more time into. The toughest part of writing tests in an application like this is figuring out what tests to write. If people are commenting code out, there's a good chance that much of the code in the application isn't actually ever used. So, it's important to not waste time by writing tests that don't provide good overall coverage for your application. My gem aims to solve that problem. It is really small (maybe 60 lines of code) and requires the "Sumo Logic" log monitoring service right now, (I plan on adding an internal log parser, but since Sumo Logic is providing me log monitoring for free at the moment, I'm leaving the gem as-is for the next month or so, as a way to thank them for providing a 'free' tier to smaller customers.) The gem uses their query language to create a list of urls, ranking them from most-visited to least-visited, and outputs basic tests for those urls, which gives a good starting point for tests that will cover the most-used parts of a Rails app. I want to find out if my gem is actually useful, so if you can spare the time, maybe check it out, and let me know if it actually works for you. [here's a link](https://rubygems.org/gems/testing_your_legacy) Now that I'm done trying to get free help from you, here's some advice: Legacy applications tend to get looked down on. But, usually, if they exist, and are messy, that's a sign that they have value, and that previous developers were asked to implement features 'fast' in the past, to make them even more useful. If this is the case for you, then you should try to change your thinking on this subject. Instead of thinking of this application as a legacy crapfest, picture it as an orphaned child, who has the potential to be Mozart, but has had to eat out of the dumpster for the last five years. That kid is rough, tough, and will bite the hand that feeds in the beginning, but if you manage to rein it in, you get the credit for unleashing its full potential. As others have mentioned, most software jobs involve exactly this kind of work. Moving on to a new job will likely put you back in this same position. Don't worry too much about bad habits. Any development you do on this system will involve compromising what you know is the 'ideal' way to do things, in favor of expedience. This is your chance to really think about the trade-offs between accumulating technical debt by slamming out new features with no tests, or paying that debt off, by writing tests against old code, or breaking up huge methods, while not delivering anything new to your customers. There's probably a middle road you will eventually settle on, as you gain experience. I took over managing an Rails 1.2.5 application, running Ruby 1.8.7 in August of last year. I did it as a consultant, and managed to convince the guy that I should bill him about 2,000 dollars to perform the upgrade, with the following steps: I started by knocking out some easy wins, and fixed several long-standing issues, to gain credibility with my client. This demonstrated to him that I cared about his priorities, and that I knew what I was doing. Once I felt my reputation would give me the political credibility to make my case, I put together a proposal in an email, where I made these points: 1. Right now, this application doesn't pass the bus test. If I get hit by a bus tomorrow, the application is stuck, as-is, and whoever you hire to replace me will take as long as I did to learn the application well enough to maintain it. If we can at least get through an upgrade, that eliminates a huge amount of technical debt, and anyone who replaces me will have a shorter learning curve. *Side note: I prefer to use aphorisms like "If I get hit by a bus", or "If I win the lottery", rather than "when I quit", even though we know that's the most likely scenario. It makes it possible to discuss this scenario, without putting ideas into their heads.* 2. Rails no longer supports this version, and a lot of the gems we're using are old, obsolete, no longer maintained. That makes me responsible for hundreds of thousands of lines of extra code. I can't promise that I can fix every issue that might crop up. We can save a lot of time now, by spending a month getting the upgrade out of the way. 3. I ran my upgrade plan by my mentor, and he said it was sound, and agrees that it is necessary. Since you don't have a mentor, maybe you should to to a local Ruby meetup, and ask one of the senior people there for advice on the upgrade, so you can make an argument from authority. If this doesn't work, ask if you can just branch the code on a test system, and spend a day walking through the upgrade, so that you can at least have some idea of how much work it would be.
I wouldn't expect much impact from that workload. 10M rows into that instance type is nothing. Postgres is better at dealing with UUIDs than MySQL or MSSQL since they use the PK as the cluster key by default, meaning it determines where the data lives on disk. Postgres doesn't have cluster indexes in this way. However random inserts into a btree are still nasty and once the index doesn't fit in ram you'll see massive slow down. If you're inserting at a sustained high rate you end up in this situation. If you don't it is not a concern.
&gt; It pulls in a million sub gems for various storage providers. I mean, c'mon: If you're that concerned with disk space then just use the API from the provider (directly or just the fog meta package) you plan to use, Fog is an abstraction over various storage (and other services) providers, supporting a ton of options is the entire point. More importantly why do you care? Everything you described is covered by AWS S3 (and probably the object storage systems offered by google, rackspace, azure, etc). 
Thanks for your reply. https://www.reddit.com/r/ruby/comments/4nbccw/need_advice_new_to_ruby/d42szeb I am at the next step now. I am still figuring out how to manipulate strings and compare them. This language is very different :)
You're missing the pcap.h header. Reading http://stackoverflow.com/questions/22996098/trouble-installing-pcapy-on-windows-7-cannot-open-include-file-pcap-h leads me to think this might help http://www.winpcap.org/devel.htm. I don't know off the top of my head how the gem tool handles extra build flags, but you may need to figure out how to hand make a specific build flag that'll tell it where pcap.h is. If you decide to go the linux route, as suggested by /u/edendark, bear in mind you may need to install your distribution's equivalent of libpcap-devel.
Ruby defaults to returning whatever value is returned by the last line in a method. So, doing something like this: def parse_file(file) parsed_hash = Hash.new ###file parsing code, that fills parsed_array with data parsed_hash end would return parsed_hash You can also explicitly call 'return', if you need to break out of a method before the last line. There's a trick to comparing strings; when in doubt, use the `.eql?` method, because the `==` method does some behind-the-scenes stuff that has to be taken into account. the `.match` method is for comparing a string to a regular expression, so it might not be as useful to you, but I don't think the problem description was specific enough to give a real answer on this.
I am using regex to match strings. I figured that about return values. Thanks. Using the "unless" operator is quite confusing to me. I haven't used lot of if else too. I am breaking my program into very small functions instead. 5 hours to deadline. No time to learn a lot :( Thanks for taking the time to help me and explaining things so clearly. I really appreciate it. One last question. What does this code snippet do? section_matcher = line.match(SECTION_REGEX) unless section_matcher return nil end
App server &lt;=&gt; storage. App servers are hosted at Rackspace in same region. (london) Reading works fine, but manipulation is relatively slow. For me, a loop that renames/moves files *should* have a throughput of at least 10 files per second (preferably beyond 100), but for Rackspace it would take 1-2 seconds per operation. Now whether this is due to Rackspace's API/backend, poor networking conditions (how can that be when the app servers are running at Rackspace) or a poor Ruby implementation is, from my perspective, not that interesting, because they are all external factors that cripple my application. If I compare it to files stored in Postgres (also running on a machine in the same datacenter) or on disk at the app server, the Cloudfiles approach enforces constraints on your strategies when batch processing files and may necessitate that you support a transitional state for your data, where some models are in the previous state and others are in the migrated state, which (again depending on the situation) means code complexity and growth conditions for bugs, since partial downtime while processing files is not an acceptable option if the window if larger than a couple of minutes.
Start by breaking down your task into smaller tasks. For example, given what you're trying to do, it sounds like you'll need to do a couple things to accomplish that: * Read an Excel spreadsheet * Look up a row based on the value of some column (like "email") * Present that row's other columns There are [lots of options](https://rubygems.org/search?query=excel) for that first and possibly second step (have a look at the [`excel_walker` gem](https://github.com/shadabahmed/excel_walker)). The third (and parts of the second) will depend on what data you're looking for. Rule of thumb in the Ruby world is that there's probably already a gem doing what you want to do (or at the very least getting you most of the way there).
&gt; Now whether this is due to Rackspace's API/backend, poor networking conditions (how can that be when the app servers are running at Rackspace) or a poor Ruby implementation is, from my perspective, not that interesting, because they are all external factors that cripple my application. You need to understand these things. Most importantly what you should be very aware of is that all these services are object stores, everything is a key &lt;-&gt; value. The concept of 'folders' is an illusion, `/path/to/my/thing` is just a key and the separators hold no significance other than using `/` for organization by convention. The most import impact of this is that listing files at some level of the path tends to be slow since under the covers you're usually doing some variant of a regex or prefix tree search. Before you make any choices here you need to figure out what your needs are and be able to profile your code to figure out why it's slow. Every storage system has trade offs and you need to be aware of what they are and how they impact your application. 
K, having a look now. Stand by!
&gt; Mostly because it demonstrates something we often forget about Ruby. It's really great at throwing together small scripts that can do cool stuff. Speak for yourself. Almost all of the Ruby I write falls into that category. Given that it was basically designed to be a better Perl than Perl, I hardly think that's something that is often forgotten.
Very carefully.
I usually send people to rubykoans.com
As moomaka said, I think AWS S3 is a great option. You can use the aws-sdk gem directly ([uploading tutorial](https://ruby.awsblog.com/post/Tx1K43Z7KXHM5D5/Uploading-Files-to-Amazon-S3)), or if you need to attach these files to records (store their identifier and other information in a database column so that you can find them later), all of the solutions like Shrine, CarrierWave and Paperclip support S3 storage.
Re: fog -- you do know that you can limit the gem/include to just the features you need no? There is no reason to pull in AWS or the others if you are just using rackspace targets. Don't store them on the web server unless you are planning on creating/maintaining a distributied filesystem that is accessable by every server you spawn. While it may seem like you are running one of servers for apps that is only usually done on in very low usage and naive deployments. One of the first things that is usually done to scale apps is to put them behind a loadbalancer and spawn N instances of the web app at which point you need to ensure that each server can present the same data. If you store on the server you are hit with a few things quickly: Can a random request from the lb serve the referenced file or does it only exist on another server even ms after it is stored on another server? If you do take the effort and cost to setup duplicated/distributed file stores on your web server then you need to deal with startup time/provisioning delay/costs on the server -- The availability of your site is going to rely on you being able to quickly launch and break down instances of your server. Re database store. No -- almost always a bad idea to store blobs in DB. Do not go down this route. It is a horrible newb concept. Your requirements are met by most of the providers listed in your fog rant -- you are just not using them properly for your use case if you are getting other results.
You are right. I like the abstraction that a tree-structured file system gives and has been giving for many decades. I don't understand why that beautiful abstraction needs to die in favor of flat keys. For instance, let's say I refactor a fat Rails model that keeps uploaded files. This model is split into two distinct models. If my old directory (or key) structure has been "user_uploads/my_old_model/7913/my_file_attribute/foobar.png", then this refactoring will necessitate that I move/rename my objects, so to match the new structure. Of course you could make the argument that I shouldn't be leaking my data model into my file containers and I should uuidify every filename and think of it as nothing but a meaningless key. But unless I'm setting up some sort of CDN proxy (and why would I do that, since the cloud is supposed to be the CDN in the first place), then these meaningless keys will be facing my users - both internally and externally. SEO people will complain (justified or not) and CMS users will see meaningless urls. Since I am working on projects with a data volume that is best measured in gigabytes and not terabytes, then I think it's reasonable to want to keep the file system abstraction and keep things organized, so you can not only track the connection from your models to your files, but also from your files to your models. This creates transparency and make file management more convenient ( I think?). The other day, I needed to compute how much space a particular model in the system was consuming and with file systems that's an easy property to compute for a model. If I had opted for a flat uuid key model, I would first need to extract all the relevant keys from the database and then devise some sort of API call to obtain file sizes for every key and finally sum the values. Alternatively, I would have to store meta data about the file directly in my file database, rather than relying on the cloud storage to provide me with that. Both hassles.
Cool! I actually kept trying at it last night (before I saw your answer) and think I got it to work! In the **config.rb** I changed: locals: { title: project_data[0], intro: project_data[1], description: project_data[2] to :locals =&gt; { :title =&gt; project_data[0], :intro =&gt; project_data[1], :description =&gt; project_data[2] } And in the **template.html.erb**, I changed: &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;&lt;%= intro %&gt;&lt;/p&gt; &lt;p&gt;&lt;%= description %&gt;&lt;/p&gt; to: &lt;h1&gt;&lt;%= :title %&gt;&lt;/h1&gt; &lt;p&gt;&lt;%= :intro %&gt;&lt;/p&gt; &lt;p&gt;&lt;%= :description %&gt;&lt;/p&gt; Also, removed the silly duplicate loop,.. and now it builds successfully! :-) Are there any pros / cons to doing it this way as opposed to the solution you suggested? Thanks a lot!
Ok your problem is doing reverse.reverse does not change the value of the reverse variable. So when you go to puts it its still the original value. You have two options, you can use: reverse = reverse.reverse or reverse.reverse! On a side note you should think about the naming of your variables, calling your string reverse and then doing reverse.reverse is a little bit confusing. Try message = gets.chomp message = message.reverse puts "#{message}"
Thank you 
I updated the stack overflow answer fwiw 
Firstly, I respect and appreciate the fact that you have given very little context, so that I don't end up writing your assignment for you :) I'll answer your question, but first, I need to give you some context and general advice :) Honestly, the less if/else you use, the better. Small methods are far more readable than lots of if/else statements. Keep doing that, forever. `unless` is equivalent to `if not`, and reveals Ruby's true heritage. Ruby was heavily influenced by Perl, which strives to act like natural language, and bring us the concept of one-liner truth tests. Whenever there is only one statement in an if/unless test, it can be reversed, as a one-liner. So, this: unless section_matcher return nil end can be rewritten as return nil unless section_matcher If I were in your place, I would rename `section_matcher` to reveal intentions more clearly. Something like `override`; `section_matcher` makes me wonder what 'section' we are talking about, and 'matcher' implies some action is taking place, so it makes me think it might be a method name. With these things in mind, I can answer your actual question: this line section_matcher = line.match(SECTION_REGEX) sets `section_matcher` equal to the string that matches your regex. If there is no match, it is set to `nil`, which is Ruby's way of saying 'no value' or 'null'. To understand the `unless section_matcher` line, you have to understand Ruby's concept of truthy/falsey values. Python treats a lot of things as false (1, 0.0, empty strings, etc), but Ruby is much more restrictive. You can still do an `if` test against any object in Ruby, and if it isn't a boolean true/false value, it will be evaluated for whether it is truthy/falsey, but the only things that evaluate to falsey are the boolean `false` and `nil`. Any other value will be considered `true`. so this statement: if nil returns true. also, there are a couple of ways to write that test, to get the same result. you can pick which one gives you the most clarity. Here are some examples: unless section_matcher #the way you did it if section_matcher == nil #explicitly saying what you are matching if !section_matcher #using !, which is the same as not if section_matcher.nil? #using the nil? method. My favorite, because it is really clear. And here's what it looks like, with what I think of as the most elegant answer, using `override` in place of `section_matcher`. return nil if override.nil? Keep in mind, there are probably much more elegant ways to do this, in the full context of your program. If `override` being nil means you are returning nil, there's probably a way to deal with this problem that doesn't require this test at all. 
I'm a bit surprised that works actually, since you're printing symbols (e.g. `:title` which has a string value of ":title") but maybe Middleman is doing some magic for you. Changing the hash syntax (from new style to the old "hash rocket" style) is just syntax, so it didn't do anything.
Fun fact, someone not knowing the difference between the two caused a major SQL injection vulnerability in Rails ~2 years ago
You can reference the class variables from within an instance: @@stock += stock There are some reasons to avoid class variables; they will be shared by subclasses, and they aren't local to the thread. If these don't matter, then you should be good to go.
Honestly, just create another class to store stock and pass an instance of this class along to the constructor. This approach will make a lot of things easier, especially when the complexity gets higher over time. 
Been a while since I've downloaded it myself, didn't realize that. Thanks!
Thanks for this! Last year I had to build my own bespoke PDF quote generator based on ERB, HTML and wkhtmltopdf. Ruby filled in the variables and used ERB to generate HTML, which was then converted to PDF with wkhtmltopdf and emailed as an attachment to the user. It works but I was shocked that there wasn't something easier.
Way too long blog post that basically reiterates parts of standard documentation.
Thanks for your feedback.
This has a great benefit of using just CSS to style the documents so you can usually offer more layouts without too much work. The trade-off is using an external system dependency which always _can_ introduce some troubles and probably higher memory consumption (although I should probably write some benchmark to see if that's really valid point). I am definitely not against wkhtmltopdf but since I was writing this for a Rails Engine that might be added to existing projects having only Ruby dependency is a win.
That makes sense. Thanks for explaining!
It would be interesting to know in detail some of these "very good reasons" that supposedly makes it impossible to build a reliable, speedy and scalable file system abstraction.
ignore him he's a meanie
This is great! I've used Prawn before but having something specific for this would be cool. I'll bookmark this and look to use it in a future project :)
I think that what you're trying to do is recreate Plug ? https://github.com/elixir-lang/plug Or at least, it's not clear why you think Plug isn't suitable. 
Maybe mean, but not wrong. Since OP covers from the absolute basics of iteration to some of the more advanced concepts, this post can't focus on a particular target audience. I'd break it into a series, maybe, so that readers don't have to wade through 50 sections to find what they need. An explanation of all of Ruby iteration in a single post... who is it for?
i don't get it.
FYI: I've started a new bookshelf (imprint) called Yuki &amp; Moto Press that collects great books in Markdown about Ruby n friends. Using the [Octobook Classics Book Theme](https://github.com/octobook/book-classics-theme) turns the pages into a single-page (online) book. The first book in the series include: - [Sinatra Intro](http://yukimotopress.github.io/sinatra-intro) by Chris Schneider, Zachary Scott, et al. Happy reading &amp; coding. Cheers.
I don't actually love the rack interface. There is a good deal of irreducible complexity inherent to HTTP. Rack's design goal is to appear simple by routing every request through a generic `call` method with just a few parameters. Unfortunately, all of that complexity ends up being munged together in elaborate primitive data structures, particularly the `env` Hash. I would prefer an interface that actually maps all of the headers and other HTTP elements to actual objects &amp; data structures.
Come on people. Can't we just agree to disagree? No need to fight over this.
Thank you, it means a lot.
That is an important consideration, but I doubt rack is a bottleneck for ruby web servers. And I doubt it would be all that slow, for instance, on jruby+truffle.
Consider how many objects would be created at every step of the middle ware layer for every request. This being said - I don't have perf benchmarks/ measurements on Rack itself but I wouldn't dismiss out-of-hand performance concerns.
That makes sense.
The most important thing when getting into TDD is not to worry too much about red, green, refactor too much. It's great in theory but sometimes you just don't know yet what the expected outcome of your code is. In those cases test your code in blocks. Just start by writing some logic and then write the tests for that logic. What I usually do in these cases is fake red, green, refactor. I write the logic, test that it works, comment out the logic, confirm that it fails and then uncomment and refactor. Another thing is to not get too detailed in your tests. For example in ActiveRecord you might have 'validates presence: :email'. It can be tempting to write a test that ensures that your model requires an email, but what's the point. Rails already has test coverage that validations work. Of you write a test for it then you are sort of saying that you don't trust Rails test coverage which in that case why use Rails on the first place. 
I found [this presentation by Sandi Metz](https://www.youtube.com/watch?v=URSWYvyc42M) helpful when getting the hang of testing
I think rails or active_support had the same idea already.
http://guides.rubyonrails.org/active_support_core_extensions.html#in-questionmark
[removed]
It can make sense to test the validations when test driving your code since the failing tests tell you what code to write. How else are the validations going to get on your models? The shoulda-matchers gem makes the tests easy and quick to write and read.
The fact that this functionality is included in ActiveSupport shouldn't necessarily be a deterrent from implementing something. Countless Ruby projects don't use ActiveSupport and could perhaps benefit from a simple library that does one thing well. That being said, if you want more specific feedback on your gem, here are a couple of thoughts: * Your code is not documented. There's a small README but there are no comments in the code itself. * Your code is not tested. * Your code is monkey patching `String`, `Integer` and `Float`. Why not just provide the `Inn` module and let the user pick when to include this piece of functionality? What if I wanted to see if a `Dog` is included in a list of animals? * This code is basically just one line of code within a method, so this gem can be useful as an academic exercise, but I don't think it solves a meaningful problem enough to warrant adding an extra dependency to a project. Don't get me wrong, I love minimal and simple tools, but this perhaps is just *too* minimal. * https://github.com/afxjzs/inn/blob/master/LICENSE#L3 &lt;- Use your full name. Always try to be as professional as possible in every single detail of every single line of every single file that you bother versioning in GitHub. Some day someone may look at this, and how is it useful to anyone to read that some "doug" guy has the copy right for this lib? * https://github.com/afxjzs/inn/blob/master/inn.gemspec#L11 &amp; https://github.com/afxjzs/inn/blob/master/inn.gemspec#L12 &lt;- Again, the details are important. Pay attention to aligning issues and leaving unnecessary newlines
In addition to others' comments, I'm curious why you picked those 3 classes to monkey patch? Why not Object since any object can be in a collection? Consider implementing this as a refinement, that way it won't conflict with other implementations (though hard to imagine). Refinements - while infrequently used - are the safe way to monkey patch. It would at least differentiate this from ActiveSupport
In this case, it is less about testing the functionality of the validator and more about verifying and documenting that your model has that functionality. I guess I just see the cost of them not being high enough to outweigh the documentation benefits.
well done. this is better for several different reasons and a solid base to expand upon. thanks for the feedback!
Already done, and yes, that's the most basic basic we can think of. One thing Rails did that made it so successful was to say "Here's a project directory and file structure; build on this". They left the impression that the canonical, generator-built structure was *complete and sufficient*. Whether that was intentional or not is irrelevant a decade on; the fact that it took (nearly) a decade for people to try and build consensus on additional architectural details when those were obviously useful is a design stench.
Ruby will always be reduced to a one-trick pony if we expect everyone to be using Rails all the time.
- Don't commit gem builds upload them to Rubygems - Use git-tagging when you make a new version - [Write better commit messages](https://github.com/afxjzs/inn/commits/master)
Congrats on building your first gem! I think you'll find it a nice, challenging, rewarding experience going forward. I will just second /u/ehqhvm 's comments 
Most gems provide a VERSION constant. A Changelog is nice also. Take a look at the template provided by bundled - bundle gem
The version constant is there to make bundler build the correct package, but that doesn't help if I want to hack on a specific version of the gem. I should be able to checkout the repo with the version-tag. E.g: $ git checkout tags/0.1.0
:) I had a revelation a little while ago, and now look at TDD as 'debugging features into existence'. It has really given me a much different perspective on these kinds of tests whose value is debated ¯\\\_(ツ)_/¯
Generally, test your seams. Test the bridges not the land. Any place where you would otherwise need documentation or expect others to use, when it isn't an internal implementation detail write a test. Avoid anything that suggests that you should test your tests or test that your code is what it is (shoulda marchers are terrible) as well as over use of mocks and stubs. Every stub or mock is tech debt because needing them means you have coupling, SRP violation, or other design problems. Always use real objects wherever possible. They wreck havoc on your suites reliability, as they generate false positive results en masse. A false positive is the worst possible outcome of a test, a test that passes despite there being a problem. Evaluating the value of tests is your best bet to guide the writing of good vs bad tests. Tests are not free, and should exist outside the code as much as possible, and be independent of the implementation.
Wonder how this stacks up to jruby+truffle performance wise.
I would strongly advise against using `Thread.current`. With the advent of multi-threaded servers, you can see ugly bugs crop up with thread-reuse. This is the best method if you within a rack request: https://github.com/steveklabnik/request_store
I don't think anybody is seriously gonna use rails because of this. I was merely pointing out that active_support already offers this. God forbid if this came across as criticism.
I use Nexmo for text messages. They have a nice ruby client and are slightly cheaper than Twilio in Denmark, but not free.
Really neat! Glad to see exploration around ruby-ish languages which are more performant. Jobs are often used for generating or processing data. It is my understanding that Sidekiq.cr won't have access to normal ruby classes (ActiveRecord models, etc). Are there any strategies established for getting the data out to the DB/redis/etc?
Thanks for your feedback. I have not ran into this happening because I was always re-initializing all thread local variables in rack middleware, but this it could happen and it would not be apparent why.
Who can't wake Ruby do whatever they want it to do?
what's the benefit of using this as a wrapper for RequestStore, instead of just using RequestStore?
Any time a new thread is spawned the thread variables will not be present. Thread inheritable attributes makes available what you set to it into any child spawned threads.
Why should the author have tests? It's their library.
I am glad I don't need this gem. But if I did need it, this seems like it would be a good implementation.
Ok thank you. I had also looked into digits by Twitter which also has web and looks great and is free but haven't got to work. If you know a solution to that or get it to work please let me know
https://www.amazon.com/Programming-Problems-Ruby-Technical-Interview/dp/1492141119 I've gone through this one. It's decent.
[removed]
I have since update the gem based on your input as well as other comments in this thread. still a very simple tool, but it now has a changelog and tests and all that other stuff you tend to skip over when making code for your own personal use. thanks so much! 
Basically what the OP said. I should have prefaced with "if you want others to use the library".
+1 Nexmo. Theres not much difference in outbound cost in my experience but incoming is free which is cool.
I bit the bullet and built the frontend for my company in vanilla JS, and tbh it's really annoying. CS, just the syntactic sugar, makes JS easier to read and write, especially for Rubyists. A former coworker essentially bet me I'd like it better and I don't. I'm not using any features that CS would interfere with, unless you consider parentheses, curly braces and semicolons to be features. If you're pushing the envelope, get modern if you want. You probably can't put CS into JSX templates, idk. For sprinkling some front-end magic in your Rails app, CS is still very useful. Why do we have to pronounce things "dead" when we mean "My friends and I don't do that anymore"? 
No jQuery? I applaud your effort to go all a Vanilla JS but jQuery certainly does have its place for ease of browser compatibility and DRY code. Anyway, just a thought.
In your personal experience, what reasons lead you to Flask? Just out of curiosity. I'm considering Flask vs Sinatra or Rails API to serve up a new API for a Javascript front-end.
I'm using Rails to serve an angular application. It was a pain to setup, there're a few *gotchas for sure, and the MVP architecture of my application is a little less structured. However, I'm having a nice development experience now that I'm up and running.
Coffee has arrows and classes (of course), we already had modules with node/webpack/browserify, and promises aren't that hard. Lots of things besides React have components; and, in general, I find refactoring in Coffee easier since the syntax is more consistent (sometimes it feels downright lispy). I'm not saying you're wrong, of course; I just wish we'd all be careful with our sweeping statements (e.g. X is dead) because we may be shitting on perfectly good technology that may still be the right tool for some jobs, depending on point of view. Do you go around town badmouthing your ex's? No, you just don't hang out with them anymore.
I was a daily jQ user for many years... and I didn't realize how good the regular ol' JS DOM API had gotten. jQ is pretty large and I was mostly just using `$`. It's pretty easy to grab a tiny lib for anything I'm too lazy to write (e.g. AJAX wrapper)... I don't miss it. The biggest surprise I'd say is discovering that pretty much every popular JS lib has a jQ dependency. It's sad; more people should be yelling about how jQuery is dead I guess.
Interesting. When did you find this pattern useful outside a Service Object (or something similar). Triggers perhaps? What do you currently use? Always on the look out for different methods/patterns that make life easier.
Awesome writeup. In most of the apps/projects I've personally used Interactors/POROs in the past but always had a shallow understanding on *why* its best practice. Ill look into the refactoring talks and reading material. Thanks!
&gt; Callbacks when used in moderation are fine but can bite you in the butt. Right now I can't think of a good case for when I would want to use observers over just a PORO, so it's hard for me to give your question a good solid answer. The idea is to reduce dependencies. Right now your `NewAccount` SO class has a dependency with `UserMailer`, which is pretty hard to avoid. But that is ok for 1 to 1 mapping. Imagine if after creating a `User` you also need to: * Send the user a gift via mail - SendGiftService * Contact a third party with the users credentials - ThirdPartyService * Send an email to an account manager - AccountManageEmailService * etc etc You don't really want to create dependencies with all of those objects and imaging if it grows over time, def send_welcome_email! UserMailer.welcome_email(email: @user.email) SendGiftService.send_gift(email: @user.email) ThirdPartyService.register_signup(email: @user.email) AccountManageEmailService.new_user(email: @user.email) end so you could use a observer pattern in this case. Also some of those object may not be required for each signup, say a user signs up for a free plan rather than premium and does not receive a free gift. In this case because you are coupled to the `SendGiftService` you might do something like SendGiftService.send_gift(user.id) if user.premium? Now your Service object knows to much about `SendGiftService` So instead def notifier! objects_to_be_notified.each do |o| o.notify(:new_user, :email) end end And the other side class SendGiftService def notify(action, email) user = User.find_by(email: email) send_gift if user.premium? end end 
You can easily convert them all back to floats: `"-2E-3".to_f #=&gt; -0.002`. I.e. [..., -0.003, "-2E-3", "-2E-3", "-2E-3", "-1E-3", 0.003, ...].map(&amp;:to_f)....
That's not the same as Action Cable. Since 5.0.0 RC 1, Action Cable spawns its own thread, separate from the app server's request processing thread pool, to handle WebSocket data in an evented manner. This is implemented through the Rack socket hijacking API. This is why Action Cable works on any app server except WEBrick: Action Cable works on Unicorn, Puma, Passenger, Thin. I wrote the documentation for this: https://github.com/rails/rails/tree/v5.0.0.rc1/actioncable#deployment http://edgeguides.rubyonrails.org/action_cable_overview.html#deployment
Damn, I never saw that he was in search of a replacement. It should be prominently placed in the README and on the website. I wish I was able to fulfill a role like that. Hopefully he finds someone that can take it over.
&gt; Is that it's ugly. I don't think what you're describing should be easy, or should be pretty. You can't avoid dependencies. Somewhere in your system needs to know about them. In the case of the observer you're trading NewAccount knowing too much about a bunch of dependencies in exchange for for a bunch of dependencies knowing about an object implementing the observer interface. The observer doesn't know much actually about the observerable, it just implements a standard interface for the notification. I could even use the same notification method for multiple observerable objects. &gt; By implementing that pattern we're not reducing the amount of dependency knowledge that has to be shared, we're normalizing it and spreading it all over our system making it hard to find and even harder to debug. We are reducing dependencies because the observer and observable are not dependant on each other. In fact the observerable dependencies are dynamic. I am not sure how it makes it hard to debug, when the state of the observerable changes the observer gets notified. That is no different from when the state of an object changes a method on a dependency is invoked. &gt; But the DI is kinda overkill unless you're using it for testing or writing a rubygem or library DI isn't really something which matches the use case here. In the observer pattern, the objects are not dependant on each other, you can pass no objects to the observable for example, or you can pass multiple. However in DI you are required to pass a reference, and with some exception to duck typing that object should implement the full interface. &gt; Exactly, that's why I want to be explicit about calling it and not group it into a meta method. I would want you to: I wont argue, this is common practice and make sense and in fact. That is the thing about patterns, they provide a standard way of dealing with common issues, but they are not the only way or sometimes the best. &gt; Maybe you'll realize someone else added a similar feature. With observers, you could have every employee in the company write and ship a "welcome" email without any other developer realizing it (assuming they're skipping code-reviews). Suddenly your customer got 10 emails on signup and now you have to figure out why. I am not sure how the observer pattern is responsible for bad coding practices, bad testing etc :) &gt; Also I want to say, thanks for the comment. I'm trying the best I can to make my thoughts on the matter as clear as possible. I'm not trying to come off as argumentative. No problems :), same from me. 
Depending on how complete Volt is, if it's even close to ready for prod apps the Volt community should either build a bunch of simple-ish Volt app tutorials (blogs, CRM's, etc.) to show what it can actually do. From the research I did I saw I think one TODO app that was only a year old, and a couple others a few years out of date? It's a long shot but maybe if it lives up to the hype someone will see the same vision. Or maybe you can create a franken-framework and make this a rails engine? IDK, I'm just spitballing at this point.
I don't mean to say that I write those tests to the exclusion of integration tests. If an integration test fails without a unit test also failing somewhere, I see that as a sign that there are missing unit tests. While this example is very simplistic, it also costs very little. The way I look at it is more that I want to spend fewer cycles determining whether a piece of functionality is complex enough to add a test, and just add the test. I would much rather spend the time of finding the optimization later, when optimizing my test suite becomes a problem, than find out that my guess of whether something was complex enough to test was wrong.
My problem is that if you create a test for something, you are communicating that the result of your test is important. If you overtest, adding a bunch of them that are not specifications/requirements than you have tests that are *binding your implementation* and you have defeated the entire point of testing. Now you have to spend hours weeding through tests trying to figure out which ones are important and which ones aren't in order to rearchitect anything. I think tests are a lot more expensive that you are giving them credit. If you don't want to spend the time evaluating the worthiness, then wrote a tests than ensures that it doesn't blow up (raise an exception) and be done with it. More than that and you are likely causing harm. In that case though, I make a sincere request on behalf of your team. Flag these non-spec tests as such and make sure everyone knows that they can be trashed if they stand in the way of refactoring. If I were on your team without such an instruction, I would be forced to consider all of the unit tests as binding and trashable and that is a very unfortunate place to be. This problem is why DHH said TDD is dead, because it defeats itself with numerous tests that do nothing but stand in the way of refactoring instead of enabling it - and why BDD won out. I have been completely paralyzed by tests in my own experience, fighting them just to make the most rudimentary changes, and they passed all the time even when the whole thing was busted because of mocks, aka completely useless, annoying, rage-inducing tests. It nearly ruined programming entirely for me as I dreaded every day I went into work. Here is some great advise: http://fredwu.me/post/59395419899/writing-sensible-tests-for-happiness
Try `x = gets.chomp.to_i` `gets.chomp` will get a string, and you're conditioning on an integer. However, keep in mind that `nil.to_i` and `"".to_i` will also return zero.
its stil gives me : syntax error, unexpected end-of-input, expecting keyword_end print "that is your salary xD" and there like an arrow in front of xD
you have a few ways. if i'm testing something out like this, i would create the file and call `load 'filename.rb'`. It will load and execute the file. It will pick up any changes as well.
Yeah, maybe I just haven't run into a code base where it has really become a hindrance yet. I have a hard time internalizing nuances around stuff like this until I have to deal with it first hand. I've had similar conversations to this in regards to cucumber as well. Most people I know despise it and tell horror stories of working with terribly slow and painful cucumber suites, while on the other hand most of my experience has been pleasant. Maybe I've just been lucky in the apps I've worked in, but thanks for pointing it out :) I'll definitely work on focusing more on seeing where they get in the way in the future.
what computer are you using?
If you're just practicing, http://repl.it is solid for quickly testing scripts. You can check it out here: https://repl.it/C3VJ -- I added `.to_i` to make it work.
you are missing the final `end` in your code (in the terminal), but your code in the post has the `end`
&gt; nal end in your code (in the terminal), but your code in t but actually it isnt missing :(
In the picture you just posted, it is missing.
I feel like you are trolling everybody now, but why are you doing that? In mac you can go open up the Terminal app, and type `irb` in console to test out ruby code. 
I doubt you'll find anything out of the box. If you don't need to deal with shipping, returns, sales tax (?), or discounts/promotions, you could probably just write it yourself without too much trouble. You could probably make Solidus (a fork of Spree) do it, with some combination of the store credit feature (in soon-to-be-released solidus 1.3) and somehow defining a custom currency for 'points'. But getting spree/solidus to do anything isn't trivial, it's complicated stuff, in part because the domain is complicated. Dealing with sales tax/VAT is surprisingly complicated in any e-commerce solution, I think it will become even more so in the 'points' idea, unless you decide you can just ignore it somehow. 
Does it do what you want it to do? If no, then you're not abusing it. I've had to do weird bootstrappy stuff like this for machine imaging. It feels gross, but it gets the job done.
Why not. Two maybe slightly offtopic remarks though: I suggest to build in a safeguard so that it only runs once and aborts when the LoadError occurs after the first retry, for whatever reason. And some informative output, like "'zip' gem not found, trying to install it", which would help everyone to understand what's going on, especially if something goes wrong.
You may be editing a different file than you are trying to load.
yup, seems likely. e-commerce is way more complicated than one would think before developing an e-commerce system. :) You've got experience writing such a thing, have you always done it entirely custom, or did you use an existing framework, app, cloud-hosted, etc? Is probably something the OP would be interested to hear about. 
I think you've followed the right path -- if you grasp the basics of how html and css work, I'm surprised you're finding Rails tutorials so overwhelming. I'm sorry, that's frustrating! Ah, do you also have the basics of how HTTP and the web works too? That might be good. And some people have said that starting with Sinatra instead of Rails is good for understanding the basics of how the web works, since Sinatra does less for you and exposes more about what's actually going on. You might try that. I can't explain why the tutorials don't seem to match up and seem like they're teaching different things. Can you be more specific about the ways in which this has been true? There are definitely a lot of rails tutorials out there, and some are a lot better than others. I know there are some that redditors recommend more than others, but I don't recall which ones. Also, you might want to know about the official [Rails Guides](http://guides.rubyonrails.org/) -- I think they are usually not too newcomer-friendly, for people who are pretty new to not just Rails (of course), but ruby, programming in general, and the technology of the web, they can assume too much knowledge. But since you say you like looking at multiple things at once anyway, you might find it a useful addition. They aren't tutorials exactly (although the 'getting started' one sort of kind of is, just not a very good one, especially for newcomers), more narrative explanations of all the parts of Rails and what they do with examples, which sounds like what you might be asking for in fact. Also, Rails is pretty huge, there _will_ be "important info holes" at first, you might just have to accept that, you might have to spend 6 months or more with it before there are no 'important info holes'. But it sounds to me like you really want to understand what's going on, not just 'paint by numbers', which I think is just right and is a heading that will serve you well -- but Rails is huge, you might have to accept that you can't really understand all of it, or even the major parts, until you've started using it a bit. Ooh, ooh, and another key piece of knowledge is relational databases and SQL. You might want to spend a bit of time learning about that too, apart from Rails. Yes, there _is_ a lot to learn, a lot that goes into developing for the web in 2016. 
I think that is a lot of the problem, the tutorials assume the student knows 'something' and teaches using jargon, or better, answers questions/explains using jargon. What is the model? Is it part of the database? Does it represent the objects in the database? How does it relate to the controller? 
No. But i will now. Thanks.
If you don't know of them, also check out http://codeschool.com
I helped design one for a very large CPG company. It was written from scratch and a wide integration against everything from 3rd party fulfillment / customer service / user contact acquisition etc. The only advice I have is that there should be no delusions that moving to a credit/point based system relieves any of the iceburg that is ecom dev (it actually makes it a little harder as it is an smaller slice of the market and has fewer off the shelf solutions). And that if it is a loyalty program ensure that you do not make assumptions that the token value remains stable forever -- most all of them generally have deflation and or expiration over time (for legal and other business reasons). 
I was going to suggest this book! Extremely clear and walks you through the steps! Don't get bogged down in the 'why' at first! Just follow along and as the tutorials get more complex then you'll learn some of the whys! Rails IS fun eventually! And once the light switch flips you'll feel better! Also try to find a local rails group in your area that holds meetups! The more advanced devs I've met there have all been super helpful and eager to teach! They often have a Slack channel too so you can ask questions if you're not comfortable with using StavkOverflow! But don't give up! It will make sense eventually! I had to make about ten apps (with varying levels of success) before I started to feel like I was getting a basic understanding of what was happening! Repetition, repetition, repetition! :) Edit: Oops I meant all of that for the OP! Sorry! 😔
You are the second person to say that. What did you use to learn Sinatra?
this is awesome, are you familiar with helix? http://blog.skylight.io/introducing-helix/ i am not much of a rust person (yet), can someone elaborate on the differences between helix and ruru? where should i pick one vs the other? 
I have an ok understanding... Its weird, Objects in js is fairly simple to grasp. Objects, and the classes in ruby I still struggle with wrapping my brain around sometimes. Not the syntax or problem solving aspect of it, but rather just having a firm grasp of what the difference between the two are. I still find myself thinking of classes as objects- and this might be leading to some confusion in rails. 
Cracking the Coding Interview should really be fine for your purposes... just do the problems in Ruby and then compare the Java solutions (how they work) to your code. The point isn't to be a language-focused book and it doesn't use a lot of advanced Java tricks.
so great to see these 2 languages coming together :)
Let's take a look. As far as I can understand, the idea is "take each pair of consecutive points and (do something)". So, here is the simplest thing you can do: poly.each_cons(2) do |(xi,yi), (xj,yj)| ...do something end There is one quirk, though: If I'm reading your code correctly, it also "does something" with `[last point, first point]` pair. Unfortunately, there is no ready construct to do it in one statement,but we can reuse `each_cons` with a small trick: [poly.last, *poly].each_cons(2) do |(xi,yi), (xj,yj)| ...do something end
I think both helix and ruru are going receive more attention during the foreseeable future. 
Yeah, I knew it was headed downhill. Still a cool project though.
I gave up on rails when I was a beginner and learned Django first - less magic and easier to understand. In Ruby you could try Sinatra. Rails is HUGE and has a lot of implicit behavior (or "magic") which is nice for building things quickly, but makes it really confusing and not concrete-feeling to be beginner. The worst thing you could do is try to learn it by scaffolding. That will just frustrate you and not teach you anything. Start by building up a model, controller, routes and views from scratch; only generate the migration to create the table. That will teach you the basics of every layer. Once you get that, you can try some magic and you will appreciate it more and not be confused.
ruru has instructions on how to use it, so I'd probably go with ruru.
What a gem.
Looks like homework.
Because new versions of JavaScript solve some of the same problems CoffeeScript did, so CoffeeScript is losing popularity. 
I don't know any BASIC, but, the way I see it is that symbols are basically **identifiers**. Unlike strings, their purpose is not to store text, but to specifically identify values -- like variable names, except that, unlike variable names, symbols are _values_. For example: symbols as keys of a hash are used to identify each field of the hash; the symbols returned by `methods` identify all methods an object responds to, etc.. I hope I made myself clear.
great explanation :+1:
Ruby strings work a lot like BASIC strings. 2.1.2 :001 &gt; a = "string" =&gt; "string" 2.1.2 :002 &gt; b = "string" =&gt; "string" 2.1.2 :003 &gt; a == b =&gt; true 2.1.2 :004 &gt; a = a + " extra letters" =&gt; "string extra letters" 2.1.2 :005 &gt; a == b =&gt; false None of this should be too surprising to a BASIC programmer, though the syntax is slightly different. 2.1.2 :001 &gt; a = :symbol =&gt; :symbol 2.1.2 :002 &gt; b = :symbol =&gt; :symbol 2.1.2 :003 &gt; a == b =&gt; true 2.1.2 :004 &gt; a = a + :extra_letters NoMethodError: undefined method `+' for :string:Symbol This `:symbol` is really just a constant value that is the same anywhere it's used in the program. `a` and `b` both refer to the very same Symbol object, and there's no way to change the value of that object to something other than `:symbol`. (Either of the variables `a` or `b` can be changed to refer to another value, of course, but `:symbol` itself remains constant; it just happens to be typed/represented with letters, similar to a string.)
It is a named constant, or simply a name, which maps to some number, where it is not important what number it actually is, so it plays no role if it is a big or a small number, the ordering plays no role as well, it is not related to any other number, it is just important that whatever number it is, it is distinct from all other numbers. It is a unique name, used for distinction, for identification The fact that the symbol itself is some alpha numeric string helps to give it a meaningful name. So far regarding the "named" in "named constant", the second property is that it is constant, once alive it does not change, it is immutable. Symbols exist in other programming languages as well, in Erlang they are called atoms. In C there are enums, but they have the additional property of being ordered.
&gt; The worst thing you could do is try to learn it by scaffolding. This. I didnt realize before, but this is my problem. There is a big difference between getting something done and knowing how to do it. I think rails often times is taught inside out, starting from where you want to end up and then going back and touching on each point. That is not how I learn. Sinatra it is! 
Well, there are reasons that bundler (the thing that uses `Gemfile` and `Gemfile.lock`) was invented, you're probably going to want a Gemfile in then end. One reason is to deal with multiple versions of gems that may be on your system, where one app will need one version and another another version. I'm not sure `Gem.refresh` will actually do what you want here, I've never actually seen `Gem.refresh`, so I can't say what it does. But there's nothing wrong with using rake tasks for installation/setup stuff. It's just that dependency management is complicated, and bundler already does a good job at it, why re-invent the wheel. You might be able to get away with it for simple cases, but as your simple cases turn not so simple, you can end up pouring a lot of time into solving your increasingly complex needs, when bundler already has been worked on to do so. 
Umm I never understand what people mean by this and I'm beginner too, if it's easy to understand then you should just make it yourself but a good open source software will be out of your league. Go look through a bunch of repos and see if you find any with issues you might know how to fix. Only do one issue at a time. 
I'm actually a PHP developer looking at trying out Ruby. And lots of these are things I've read .. I guess they are wrong and I should research further. I'm glad I read this :D
For anyone interested, I've expanded on her work (and a couple others) into a framework for using Crystal for native extensions. It's a lot more fleshed out, and it includes performance testing a Crystal version of ActiveSupport::Inflector against the actual Rails codebase. It's not quite ready for prime time but it's pretty good and still improving. https://github.com/phoffer/crystalized_ruby
Wow, that looks amazing, keep up the good work!
You should try sites like http://codetriage.com, it is search engine for open source and shows current issues which you can help with. 
Thanks for your help! This was so much harder than I thought. After endless googling, I managed to put this together. It creates an array of the lines nokogiri scrapes. I thought it would be easy, all I wanted was to scrape a website, but no. I used a tool called [Fminer](http://www.fminer.com/) to identify the "group" xpaths, which I couldn't figure out by using Firebug. offerdeadline = Nokogiri::HTML(open(url), nil, 'UTF-8') @fresharray = offerdeadline.xpath(offerdeadlinexpath).reduce([]) do |array,e1| puts e1.text offerdeadlinearray &lt;&lt; e1.text end # how large is the array now, and whats inside? puts offerdeadlinearray.size puts offerdeadlinearray[10..12] What I will do with the arrays later on, I'm not sure yet. Persist to csv and json, and maybe also beam to a google doc for instant gratification. 
What? All scripting languages let you fork processes. You can call anything from anything.
* Pathological gem names that have zero relation to their function. * The culture of never documenting anything. * The culture of millions of nano-functions and millions of stacked classes for every tiny thing.
Depends on the runtime / host. Lua, for example, doesn't do anything the host application doesn't allow; JavaScript, running in a browser, definitely doesn't allow you to spawn processes anywhere, because that'd be a huge security problem.
a plug conn has an included owner pid meaning that plug's are not pure functions mapping a request to a response, they are less simple because of this. I have also not yet seen how plug along (i.e. outside phoenix) is meant to make handling websocket communication etc easier
You can use the bundler inline feature to define your Gemfile inside your Rakefile. An example is here; https://gist.github.com/chrisroos/0ddf618ac711abe0f465 And the source is here. https://github.com/bundler/bundler/blob/master/lib/bundler/inline.rb I've used this in a couple of single file ruby scripts, it's super handy for an all in one file you can just drop in a `bin/` directory somewhere. 
I use GitBash for Windows, primarily because I chose to install it with Git, but also because it is a friendlier interface to work with than the plain old Windows command line interface. In all seriousness though I don't think it matters which one you use so long as you know how to use both.
Sinatra is basically just a concise way to define functions to handle web requests. It is good for a beginner because you will have to install almost anything you want to use such as HTML templating or database adapters, and you will appreciate what Rails does in a hurry. I'm not sure the documentation is good for Ruby beginners, but it was not hard for me to learn. You can start with Rails too as long as you write the code from scratch instead of generating everything like all of the brain-dead tutorials suggest. In the real world I think Sinatra is good for smaller applications with only a few URLs and either extremely simple or extremely custom behavior. Some might disagree with me.
There's a [good tutorial](https://golang.org/doc/articles/wiki/) on writing a quick wiki, [here's the reference docs](https://golang.org/pkg/net/http/), and [here's the change that added transparent HTTP/2 to HTTPS connections in Go 1.6](https://go-review.googlesource.com/#/c/15828/). There's a legacy x/http2 library, but you don't need to worry about it.
https://github.com/ffi/ffi/issues/368
Maybe watch codeschool's 10 Ruby videos first before you try to scrape them with a Ruby script?
While a lot of people can shrug this off as noob or too introductory, this kind of thing is remarkable at helping new Ruby developers not get frustrated with setup. I got frustrated with Rails setup and went with flask because of it.
PHP dev learning Ruby since last week; I can back this up. A lot of what I'm seeing wrong with Ruby tutorials is a lot of assumptions, especially when it comes to "Just run &lt;code&gt; before &lt;other code&gt; is loaded in your app" with absolutely no mention of where's a good place to put the code, assuming newbies know the load-order of a ruby app. Another issue I'm having with learning is the lack of troubleshooting steps. Almost every environment setup step-by-step I've followed has encountered some error that prevented me from continuing. I was saved only from my years of dealing with environments in PHP, but proper new devs will definitely give up at that point. Currently learning how to get DataMapper to work with rake, and havent found any guides on that. DataMapper page says "run DataMapper.finalize" and "run DataMapper.auto_update!"...WHERE!?!?!? Then I thought I finally found a good tutorial video, and the damn thing was in 320p...lol come on **EDIT:** also I'm struggling to find a reputable "best practices" site, if anyone can help? I like to follow popular standards for the sake of maintenance, but even RubyMine lacks a default template for Ruby
I like to compare a symbol with an integer. A simple 2 or 78 is what it is. So is a symbol. a = 78 b = :something If it was easy to us to identify numbers to use them as keys in dictionaries and stuff like that we would use it, but it is not. So there are symbols.
Sounds like it's time for OP to run a real operating system.
I can't lol enough at this 
&gt; Sounds like it's time for OP to run a real operating system. There is nothing unreal about Windows. It's just different. Which is why it's a bad fit for Ruby. No need to be smug. It doesn't convince any potential ruby developer to explore Linux or Unix.
In case anyone looks back at this post, the URL has changed slightly. It is now at: http://aserafin.pl/fast-csv-imports-with-rails-and-postgresql/
The video was published in 320p while it was processing, but it's now at full 1080p (has been 10 min after it was published). If you watch it in 1080p/full screen you'll have a much better experience. You're right about assumptions, but a lot of us doing tutorials assume that the newcomer has done their basic homework. I'll be doing more beginner tutorials and will start from scratch. The only issue is not everyone is going to have problems with setup and installation. On my machine it's nearly impossible to replicate problems that occur during setup since my setup just works. But if you run into any problems, I'd be glad to answer them for you or make a supplementary video.
Thanks for the feedback, I'll be doing a Rails installation tutorial in the very near future. It's not very difficult to setup but if you've never done it before it can be a little confusing. And yes, flask is super easy to get going. I also write apps in Python/Flask too and found the setup easier. But my main language/framework is Ruby/Rails.
Whaaah, someone made a joke mocking Windows. Guess what, I made it from my windows workstation. Cry about it.
nice! I missed that new feature, that's super helpful. Interesting. I'm curious how it handles new releases of dependencies -- my guess is if there's _some_ locally installed gem that meets the requirements, it will never upgrade to a newer released version, and there may no way to get it to but changing the requirements to require it. Hmm. 
 irb(main):001:0&gt; 'hello' === /ell/ =&gt; false irb(main):002:0&gt; /ell/ === 'hello' =&gt; true
Nice :) thanks for putting this together! Flask (or Sinatra for sticking in Ruby land) are great micro frameworks but it would be nice to know Rails. If when you make it you could include a little bit about an API-only setup that would be awesome!
What kind of database are you using?
Hi, Author here - thanks for noticing! I was changing blog scheme and somehow missed that url format changed ;) It's back to the old one now.
You're using Ruby on Windows. It can be done; don't let anybody tell you it can't. However, it's going to be harder. You're going to have to do more digging. There may not be ready answers for you. Many of us who would normally be able to pitch in won't be able to, because we're not on Windows. Good luck!
Good luck dude. I don't know why you'd do such a horrible thing though, I get you wanna get away from your crutch but the thing is Windows seems to be largely an after thought in the Ruby world. :/ A lot of gems won't work, even if you get them to compile they'll just bug out. I once spent like 3 days trying to setup a basic rails gem, I just quit and moved to Linux wherever thing worked straight out the box. If you ever ask for help on a forum most people will pretty much just tell you something like, "Just get a mac/linux box". Life is easier if you're on *nix if you're using Ruby.
Separating religion from technology can be hard - and a lot of the complaints listed aren't entirely true/untrue but more subjective to your perspective, experience, and use-case. Coming from PHP I'm pretty sure you'll find the ruby community to be awesome and warm and helpful though! :) 
 parameter_value = if condition_one &amp;&amp; condition_two something_1 else something_2 end 
This is not equivalent; in the OP, if condition _one is true and condition_two is false, the parameter_value isn't set. 
I am not sure that was actually intended behavior. OP, we aren't really sure what behavior you intend. KingLawnGnome, you don't care to supply the actually identical code? I suppose it would be: parameter_value = if condition_one &amp;&amp; condition_two something_1 elsif condition_one nil else something_2 end OP, I doubt that's what you really wanted, but that's what your original code did, as KingLawnGnome points out. 
With run times like 10s, aren't you mostly benchmarking the time it takes to load the runtime and the libraries? Benchmarking with a few hundred megabytes of mangas should increase the spread between language runtimes. 
 parameter_value = something if (condition_one &amp;&amp; condition_two) || !condition_one
This post reminds me of the pain I felt when I was an aspirering programmer venturing into Rails, Ruby and more importantly, out of Windows and into the perplexing mysterious world of Linux/Unix. I wrote a post about it back then: http://www.nielsbuus.dk/wordpress/?p=500 In retrospect, it looks a bit silly to me, but I do remember all the frustration I felt. That creeping feeling of inadequacy. Anyway, there's light at the end of the tunnel. Keep going. At the end of your journey, you will find a wonderful framework that massively boosts your productivity.
 parameter_value = condition_one &amp;&amp; condition_two ? something : something else
Didn't know about this. Awesome!
postgres. i got most of it to work the main thing now is the actual verification of the code once it has been sent and then saving the phone number and having it tell the computer that that is the logged in user
Thanks for the encouragement! 
parameter_value = (condition_one and condition_2) ? something : other_thing
Title is vague and a bit high on the "pretentious meter" ("A new way to X" usually is) But this is very cool. Definitely have a look
Advantages of this over concurrent-ruby?
It's kind of a weird question because while you work you just pick up different parts of a language that you use a lot. I might know all about regex in Ruby and not understand anything about how the class system works. Although I think there are some things most Ruby programmers should understand. So I don't think it's particularly helpful for people who might not be confident because they don't know certain things. Be that as it may I think there are certain ways that programmers code that may be indicative of their skill level. **Beginner** * Uses single large ruby files to write scripts * Doesn't write classes, uses global functions in their script * May or may not use iterators to iterate over a sequence * May or may not understand how to utilize blocks **Intermediate** * Splits up code into simple classes and multiple files * Might use inheritance in their classes * Understands what `self` means when used in a class * Understands the difference between a class method/variable and an instance method/variable. * Uses attribute reader/writer/accessors in classes * May or may not understand how to use `yield` and how it works * May or may not understand or use modules and mixins within their code * May or may not understand the difference between `include` and `extend` * Knows how to use RubyGems, Bundler, and IRB * Can read and understand the Ruby Docs to lookup language information * May or may not know to properly use logging or error handling code **Advanced** * Extracts useful code into separate gems when necessary, understands when to do this * Understands the ins and outs of how blocks, lambdas, and procs work * Can use modules, mixins, and class hierarchies effectively to achieve the desired outcome * Can use metaprogramming to make code more flexible * Knows when *not* to use metaprogramming Obviously these are just a few ideas I've had, I tried to make these about patterns or language features more than super specific Ruby things, which I think is less important. It's more of a continuum than a discrete beginner/intermediate line in the sand. Ruby has a lot of little quirks, idioms, and best practices that it takes a lot of time to get them all at any skill level. 
Looks like a function would be better at communicating the control flow you're attempting, since you're not doing control flow but are instead choosing between two values (`nil` or `something`). def parameter_value return nil if condition_one &amp;&amp; !condition_two something end If you intended to set `parameter_value` earlier in code and only change it in some circumstances, I'd do something like: def updated_value return nil if condition_one &amp;&amp; !condition_two something end parameter_value = updated_value || parameter_value I feel like this is splitting hairs, though. Needing to do something like this implies to me that you might want to extract some sort of object, perhaps with a `needs_updating?` method, or something of that sort: class MyThing def initialize @parameter_value = :foo @something = :bar end def do_stuff(condition_one, condition_two) parameter_value = something if needs_updating? # use parameter_value end attr_accessor :parameter_value, :something private def needs_updating? !condition_one || condition_two end end
A major inflection point (or points) for me was cultivating the practice of reading source code written by other people. At the beginner level this means examples and tutorials, at an intermediate level, real-world ruby source code, and at an advanced level, the lower-level language source code of extensions and of the interpreter itself. As was implied in the other thread, an "advanced" programmer might not have every skill at the "advanced" level, and I certainly wouldn't lose respect for someone for not studying parse.y.
[removed]
The more you know about ruby, the less you mess with metaprogramming in favor of explicit, succinct code. Google "less code ruby"
I'm new to Ruby, but I'm loving this kind of thing ..
TIL I'm teetering between beginner and advanced already... it's good news for me, I've only just begun! (I've got the concepts down, just need the practice.)
[1,2,3].product([4,5]) #=&gt; [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]] [1,2].product([1,2]) #=&gt; [[1,1],[1,2],[2,1],[2,2]] [1,2].product([3,4],[5,6]) #=&gt; [[1,3,5],[1,3,6],[1,4,5],[1,4,6], # [2,3,5],[2,3,6],[2,4,5],[2,4,6]] [1,2].product() #=&gt; [[1],[2]] [1,2].product([])
what do you mean by "finding the Opal version of Klipse"?
I often use the rdoc for rspec-core available here: http://rspec.info/documentation/3.4/rspec-core/ Links to similar documentation on Expectations and Mocks can be found here: http://rspec.info/documentation/
 parameter_value = if condition_one something if condition_two else something_else end
Isn't it just like the IPython (jupyter) notebook? You can plug in Ruby kernel.
To be honest, I expected a bit more :). Nevertheless, the article is pretty helpful as it is!
You expected more speedup, or different ways to speed up the asset pipeline? Because this is a huge speedup for compilation and for page reloads in development. Ruby Sass alone is a big bottleneck, since with SCSS it's more common to use Sass' `@import` directly instead of Sprockets directives (because of variables), so you always need to recompile the whole CSS.
Yes, I've had the same experience, I think the rspec docs are not great, and it may demonstrate that relish as an approach is not great. 
I know a lot of people have mentioned the single Integer class, but I'm really excited for the Unicode case mappings. 
Can we see your gem file? 
You might want to check out https://www.postgresql.org/docs/9.1/static/server-start.html. Not sure if that will help
I used to use Chronic https://github.com/mojombo/chronic It looks like it has not been updated in a while, but give it a whirl. 
The nicest date gem (in my opinion) is [time_math2](https://github.com/zverok/time_math2). It doesn't do exactly what you're asking, but it shouldn't be hard to get the last/first day of each month, and work forward/backwards to the nearest Friday/Monday. The [chronic](https://github.com/mojombo/chronic) gem will probably do exactly what you want, but it hasn't been updated in a couple of years.
You need to start the server, `psql` is a client. `sudo service postgresql start` should start the server. 
I've forked the repo on Github and it looks like I can make it work - thanks for the link!!
also relevant: https://www.devbridge.com/articles/increasing-sass-compiling-performance-or-when-every-second-counts/
Yeah, the title was probably chosen for sensationalism, more than usefulness. During the interview, he says something like "During interviews, I would say that I was probably the worst Rails programmer in the world, but I could make Ruby do whatever I want to". He was describing his experience of learning Ruby for fun, and then suddenly having it become a useful skill when Rails became popular, and comparing that with newer programmers, who sometimes know Rails, but don't have that deep Ruby knowledge.
Did I miss something in learning (the basics of) Javascript?.. because this sort of thing wasn't really mentioned. But I'm enjoying learning Ruby. (I guess maybe I'm drinking the kool-aid, so to speak. I like the so-called "culture" that surrounds it. It makes it easier to learn somehow. More "fun".) But I figure if it gets me programming and learning the stuff I'd like to know, then it'll do just fine. But that's good to know because I'm going to need to know Javascript too ...... aiming to eventually be a paid web developer soooo... I think it's the semi-colons I don't like in javascript. So many semi-colons. :P
How about having view templates with no logic instead? :) If you need mutation testing to verify if your views are working correctly then I feel like you've got a bigger problem to solve. I wouldn't want to add an additional abstraction just because I want to use mutant. In general view "templates" with embeddable ruby code is a code smell (yes, erb is a code smell) and shouldn't be used on a larger scale.
&gt; Hamster is about persistent data structures How do you define `persistent`? I don't see anything in the readme about serialization?
It's true, "logic-less templates" do technically contain logic (branching and looping), but that's just poor naming that we've somehow adopted. What the term actually refers to is templating that doesn't allow arbitrary code execution. For example, liquid templates are classified as logic-less despite containing looping and branching logic because they can't run arbitrary Ruby code.
[removed]
Here's some info on exporting and importing data to and from your heroku db: https://devcenter.heroku.com/articles/heroku-postgres-import-export
As a sidenote to this, I've found it extremely helpful to add anything you want for testing purposes both on your heroku app and your local app in the seeds file, so you can quickly generate a number of items.
did you try with `bundle exec` prepended?
This man knows what he's talking about. You can only manually update stuff after so many times of 'I gotta dump this db and do it again' (which happens a lot when you're just starting out).
I think the intent behind the question is "give me a list of things I can learn to 'move up' to intermediate or advanced." I don't think it works like that probably. 
Thanks. I wish the tutorial had made that clear. Then again, maybe it did. Silly question: Where do I find what I named my local db?
Check out config/database.yml - it will be logically separated into development, production, test, etc! Your DB should be setup in there.
I'm going to share this. I'm largely a Scala developer but I've been trying to get some of the Ruby guys at work to reign in their mutability as its created defects that wouldn't arise otherwise...
Looks like the packetfu gem might be worth looking into: https://github.com/packetfu/packetfu Here's a quick example I found using it: https://gist.github.com/KINGSABRI/2898001
Fantastic guide - mini_racer delivered a huge improvement right away. sassc-rails requires me to refactor a few older stylesheets, but if I omit those, it also runs super fast. Great guide. These gems should be part of the default Gemfile for Rails.
Why do you think it would not work? What other things factor in to transitioning into intermediate/advanced level?
Good for you! Can you list topics that you are comfortable with and those you are still struggling on? Also, what resources are you using to learn? And what is the purpose of learning ruby for you, is it just for fun, getting a job, building an web app?
I'm a relatively new programmer (approx 1 year) and I'm wondering: how do these changes not meet the criteria of "breaking changes" that generally constitutes a new first digit version number? I may be misinterpreting what"not fully backwards compatible" means here.
Not every project follows semantic versioning. Some projects use odd numbered releases as development and even as stable, others are moving closer and closer to pi, while for Ruby it will always increase with a MINOR version every Christmas and may contain ABI breaking changes. It's all personal preference for whoever is running the project.
Ruby claims to follow semantic versioning but doesn't. it's smart not to do so from a behavioral point of view: it's much easier for the ecosystem to adapt to small changes over time than a big change all at once. 
You keep doing that! :) I'm 100% sure this is the way to go *even in Ruby* despite various claims that "it's too slow" or "it's an OO lang so it's OK to rely on mutable state". From my experience a blend of FP/OO in Ruby gives you better results *even* when it comes to performance. With a proper separation between data/behavior you're actually allocating *less objects* since a) you can create and cache objects that have behavior b) you reduce the need to create intermediate objects as you focus purely on data transformations. I really hope this approach will be more widely adopted by our community. ps. I've been working with Scala for the last few weeks, it's a really interesting language, lots of inspiration for me there
Thanks!
I think it's because Hamster made the design decision that it's not going to cause side effects. Freezing is a kind of mutation, so I guess they didn't want to cause any nasty surprises – for example, you put a Rails model object into a `Hamster::Vector`, and then it crashes later when you try to update the model object.
Hi, So I went under there and was able to get it all to work except for a few things. 1) The user gets a phone call and text when they should only get a text, 2) I am having trouble with the code for when the user gets the code and types it in the form to verify, 3) From there, I need to take that and let the user log in/create an account with that. If you want to see more of the code, it is all available at [the GitHub repo](https://www.github.com/openinc/openinc) thanks!!
im learning ruby / ruby on rails now. if i read well grounded rubyist that is like ruby 2.1 or something how bad is that? are there any more up to date books i should be considering?
The README docs are a work in progress, and papering over the clunky API is a work in progress, but all of the Verify API functionality is there (I wrote and maintain nexmo-ruby). 1) You'll get a TTS call some time after the text message. You can stop the call using the "Verify Control" functionality (#control_verification_request method in Ruby). Test it to get the timing right, I think it can be up to 30 seconds from the verify request. 2) Call the #check_verification_request method with the code and the id of the verify request, example [here](https://github.com/Nexmo/nexmo-ruby/blob/master/README.md#checking-a-verification). Make sure to handle the unhappy path. Feel free to open an issue if you find any problems with the library, and you can email devrel@nexmo.com if you have any questions about the service. 
&gt; it's smart not to do so from a behavioral point of view: it's much easier for the ecosystem to adapt to small changes over time than a big change all at once. I don't get it: You can make small breaking changes and follow semantic versioning at the same time.
I find this notion of 'more semantic versioning' to be like 'somewhat pregnant'. if any breaking changes are possible, its not semantic. i'm not complaining of course because i like the way they manage version. but even mentioning semver causes confusion as OP and others face.
maybe i don't get it. how do you make a breaking change but not change major version number with semantic versioning? According to semver.org FAQ: **If even the tiniest backwards incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?** *This is a question of responsible development and foresight. Incompatible changes should not be introduced lightly to software that has a lot of dependent code. The cost that must be incurred to upgrade can be significant. Having to bump major versions to release incompatible changes means you’ll think through the impact of your changes, and evaluate the cost/benefit ratio involved.* The only time I believe you can make any breaking changes to without upping the major version number is when you are at major version 0.
The changes since 2.1 haven't been that large, so that shouldn't really be a problem.
Ok thanks for the help, will do!
What would the ID of the verification be? 
Not to mention [optional typing](https://bugs.ruby-lang.org/issues/5583)!
The id is returned in the #send_verification_request call when you start the verification process ([example](https://github.com/nexmo/nexmo-ruby#starting-a-verification)). In the tutorial it gets passed between actions in the URL, but you could also store it in the session or the database.
thanks for letting me know.
&gt; Every change breaks someones workflow i love it! surprised i haven't seen it before. &gt; In a lot of places the line between bugfix and breaking change becomes very blurred when talking about a programming language and not a library. agreed in principle. i have no problem with this practice for ruby. just wish they would remove the damn 'more semantic versioning' nonsense because that scheme simply does not apply to programming languages or consumer applications. ruby's policies are quite clear: major number signifies special event, and minor number is required to change every christmas. nothing 'semver' about this.
Ruby has always released potentially breaking changes in minor versions. They have, happily, released many _fewer_ lately than they used to. I'm not sure Ruby even had an official versioning policy back in, say, 1.8-1.9 days (when _major_ changes were being made), but the unofficial practice was that a minor release might as well as be a semver major release. As of ruby 2.1, there is an official versioning policy, but it's still not semver, and still allows breaking changes in 'minor' version increments. https://www.ruby-lang.org/en/news/2013/12/21/ruby-version-policy-changes-with-2-1-0/
Not a problem, changes are fairly minor and insignificant between 2.1 and the just released 2.4. You'll have no trouble. 
That issue is 4 years old, and has a closed/rejected status. 
I probably should have linked to [this discussion](https://bugs.ruby-lang.org/issues/9999) actually... It's been an ongoing debate for *years* now, and it looks like something will *probably* happen in `v3.0`
I'm having difficulty understanding your file format. If you have JSON, you can read it though: require 'json' hash = JSON.parse(File.read("myfile.json")) Keeping the data in a standard format like JSON will make transport much easier. Can you provide samples of the file in question? And show which data you want to extract from it?
The file isn't JSON...the hash I am trying to access and display was created from a knife search command into JSON. Here is one example of the JSON: { "company1": { "version": { "hotfix": [ "hotfix-1", "hotfix-2", "hotfix-6500", "hotfix-6570", "hotfix-6680", "hotfix-7055", "hotfix-7285", "hotfix-7432" ], "featurepack": [ "featurepack-6563" ] } }, "company2": { "version": { "hotfix": [ "hotfix-6446" ] } }, "company3": { "hotfix": [ "hotfix-8364" ] } } The file I am using to try and access is currently in this format: ['company1']['version']['hotfix']['hotfix-1'] ['company1']['version']['hotfix']['hotfix-2'] ['company1']['version']['hotfix']['hotfix-6500'] ['company1']['version']['hotfix']['hotfix-6570'] ['company1']['version']['hotfix']['hotfix-6680'] ['company1']['version']['hotfix']['hotfix-7055'] ['company1']['version']['hotfix']['hotfix-7285'] ['company1']['version']['hotfix']['hotfix-7432'] ['company1']['version']['featurepack']['featurepack-6563'] ['company2']['version']['hotfix']['hotfix-6446'] ['company3']['hotfix']['hotfix-8364'] I am needing to be able to add to the previous file and display keys/values from the hash that matches. Does that help clear anything up?
Thank you for being patient with me. So I am running a knife search command to obtain the previous json. hotfix_list = JSON.parse(`knife search -F json &lt;node1&gt; -a &lt;some_attribute&gt;`) Then I can access hotfix_list as a directly like for example: puts hotfix_list['company1']['version']['hotfix'].keys But I need to display the information using the external text file which can change if there are new companies or new hotfixes. If it helps I am working on a script that is auditing to make sure certain companies have the correct hotfixes installed.
It takes the characters from the line from index 2 to the end of the line - 3 characters. To demonstrate: "why hello there".slice(2...-3) =&gt; "y hello th" The effect is that it takes the part of the string between the opening `['` and the closing `']\n`.
What if I could format the external file in any way I want? Like: company1/version/hotfix/hotfix-name ?
I totally get the idea of what you are saying but that is the easy part. It has always been the construction of the syntax that is hard for me. As you can see there is subtle differences in the file I am reading in. Like one line is only 3 elements long instead of 4 and one other line is FEATUREPACK instead of HOTFIX. I am just not sure how to compensate for those differences.
Yes I addressed this in another comment. Sorry.
I saw that this was also on StackOverflow so I've posted an answer there: http://stackoverflow.com/questions/37913491/using-nexmo-verify-to-login-to-a-ruby-sinatra-app/38002033#38002033 The updated code for this can be found here: https://github.com/OpenInc/openinc/commit/69af5b11be2903097a155f520bf5768e2c5c53ec
"EU developers who are thinking of moving to the UK in the short to near future, now is the ideal time. " Sorry but if you were thinking of moving to the UK for a job -- now is the time where you should reconsider. The net of the vote yesterday means that over 40% of the economy in the UK is in jeopardy for the next 2-5 years (as it was reliant on trade in the EU zone. Even once the UK is able to get one-off trade agreements with the constituent states they will be at much worst terms than what exists today (because UK is now approaching the agreements in a state of weakness and the countries they are negotiating with all have much more advantage to have known pain for UK to deter future exists). By choosing to move to the UK for software development today you are choosing a depressed economy for your foreseeable future. 
Thank goodness all those Java and C++ jobs won't be affected
I am. Just by holding USD I am profiting by UK's decline.
My preference is to use a static facade: https://medium.com/@victorarias/use-static-facades-when-you-don-t-care-about-the-instance-33aa16c22ff0#.u61105umc
I would follow this pattern: x = MyService.new x.perform(args) Having an empty constructor means you can write helper code which easily builds services without having to know which arguments it takes. Useful in test suites if you want to inject or mock standard dependencies: def mock_service(klass) x = klass.new x.user_service = MockUserService.new x end I would avoid class methods completely. They lead to messy, global code, are hard to configure, are more difficult to make threadsafe, etc. Ruby is an OOP language - use objects.
In my opinion, services should be classes and should only have an `initialize` and a `call` (public) method. (you can have as many private methods as you like, of course) **Why classes?** Services usually deal with complex logic, therefore it would be highly impractical to pass data around, it would get quite confusing and redundant in the end. Sure, there are services that do something extremely simple and therefore wouldn't benefit from being a class. For these kinds of situations, I would recommend that you still implement the service as a class and create a class method that initializes the service and calls `call` on it. But again, in my experience, most services benefit from being a class / preserving state. **Why only a single public method called `call`?** First off, you can call it whatever you want :) The idea behind this approach is the reduction of 'surface area' between your application and the service. If some day you decide to extract that service to another application or micro-service it will be easy and painless. Basically, it scales better. **Why `call`?** Well, you don't have to call it `call` but it has some benefits as it becomes a 'callable object'. Basically, you can use it as a scope or in place of any object that implements `call`. (like procks and lambdas) 
Foreign trade with US is ~ 5%. Trade from UK -&gt; EU is 40%. I am talking facts while you are talking rage-crap-ola -- 500 billion population? Pound lost its value today (8-10%). USD gained today. I am familiar with the EU including its inception and construction. The decision process in fact does mean that UK has now switched from being a party able to act and steer to one that has no ability to do so. Its not hysteria at all it is a sane and realistic view of the state. The hysteria, if any, was the hyperbole around take back control that was based on getting people to vote in anger without understanding the ramifications. All of the pain points made by the take back control crowd are actually made worse by this action -- which I grant you may be non intuitive but is real. Good luck to you.
4% or 5% vs "most favorable trade partner" 500 *m*illion, of course. Sorry for the typo. The point about weakened voting power remains valid. From 1/64e6 to 1/500e6 for UK, 1/11e6 -&gt; 1/500e6 for Greece etc. Please don't do another nitpick as voting right has lesser amount but the ratio would be on par. But what caused the sudden loss of GBP after vote results ? Hysteria reaction and does not reflect real changes or trends in british economy. This is what am I talking about. It is virtual fear fed by media controlled by groups interested in this project of power. Same good luck to you.
When I am talking about most favorable trade partner I am talking UK-&gt;EU not US and that represents 40+% of the total UK exports. You keep on attaching to trade with the US for some reason -- in this matter it is basically irrelevant. I have not even gone into the fact that 8+% of UK's GDP is financial services and banking of which 50% is in jeopardy of moving out of the silo that has been created. Literally every expert in finance had gone very verbal about the huge negative ramifications for such an act, instead fear, anger and nationalism reigned over logic and sound decision making. It is a sad time where keep calm and carry on has converted to act with haste and ill formed thought. I truly hope that UK is able to eventually recover from this -- but I strongly suspect that this will prove to be one of the most substantial harms to happen to their stance in the world. I just hope the trend of acting irrationally on fear and anger ends soon -- this is ludicrous. 
We use [interactor](https://github.com/collectiveidea/interactor) and are very happy with it. IMO, the way you handle the context is more important than class vs instance, etc... 
It's flogging a dead horse here. Substantial part of foreign trade is constituted with geographically(transport costs) and cultural close countries(similar consumer preferences). What a surprise. There was EEC before, zone of a free trade, without need of centralized government and it did worked well. Relatively to current situation. Don't know if that's some hidden anticipation, but brexit need not affect quantity of mutual trade with EU at all. It may have some impact on speculative capital but not a normal business. Like so far products and services need comply to EU norms. But they already do. In addition there is a strong pressure from USA to conclude TTIP to slacken EU rules for import, besides other nasty things. This is a storm in a glass of water. &gt; *Literally* every expert in finance That's exactly kind of vague claims which prevent any further serious debate. See how we get lost and I just asked how you can be sure what you have originally wrote, about future depression of UK's economy.
How is a class with only `initialize` and `call` meaningfully different from a function? (other than forcing unnecessary object allocation)
That is literally the point. They are an object representation of a deferred function. Functionally equivalent to a proc. Why people don't just use procs? My guess is most people aren't very familiar or comfortable with them, and also they want the "namespace" aspect of the class/module hierarchy.
&gt; That is literally the point. They are an object representation of a deferred function What does 'deferred' have to do with this? Maybe you're using different terminology but I have no idea what you mean, nothing is async here. &gt; they want the "namespace" aspect of the class/module hierarchy. So put a function in a module? Again, why are you allocating objects for no purpose?
In object-oriented programming you're not calling an object. You're sending that object a message.
And your question is? Do you know what comparison methods are? Do you know what program flow is?
Logic.
[You can even directly call Send to be more explicit about it](http://ruby-doc.org/core-2.3.1/Object.html#method-i-send) though I think it's not considered good practice unless you need to. 
I wouldn't be that concerned with object allocation. In Ruby nearly everything is an object, and [that includes methods](http://ruby-doc.org/core-2.2.0/Method.html), [procks and lambdas](http://ruby-doc.org/core-2.2.0/Proc.html). Objects will be put on the stack either way, +-1 won't make that much of a difference. Therefore I usually focus on maintainability and scalability of my code. And optimize method calls and object allocation if it becomes a bottleneck.
&gt; A class gives you the ability to break down the theoretical monolith function into several smaller functions and encapsulate them. You can do this with modules, procs, etc. You don't need a class in order to encapsulate code. 
Nope. "sending a message" is what you think of as a "method call", that's it. some_obj.some_message That's sending a message. We can think of it as a message rather than a 'method call', because it doesn't _have_ to be handled by a method of the same name, it can also be handled by `method_missing` or other means. It's sending a message to an object. 
&gt; MRI doesn't allocate any objects on the stack. You are completely right. I meant to say 'heap', but it turns out that [even that isn't correct](http://www.theirishpenguin.com/2009/10/29/understanding-how-ruby-stores-objects-in-memory-the-ruby-heap.html). &gt;And that is how we get terribly performance. It's the #1 thing you should be worried about for fast code. Again, I have a feeling that for some reason you dismiss everything I wrote in the comment just to make that one point. **You are correct, more objects in memory equal to less performance.** Because of the nature of GC. **As I said in my initial comment.** If you experience low performance from a service object, for whichever reason, it's extremely easy to extract that logic to a separate application (or write a Ruby extension in C, C++, Rust, ...) that will do the job quicker and with less overhead. While nobody stops you from writing everything as 100+ line methods that take 10+ arguments and do all kinds of other stuff. **It's code that nobody except you will be able to maintain** (because only you fully understand what it does). It will be faster, though. You made the argument that you can encapsulate code in modules, procks, and lambdas. Again you are correct. **I'm trying to argue hat most service objects benefit from having their state preserved by using instance variables - being classes.** Modules are used as mixins - a multiple inheritance principle. You can misuse them as singleton classes, but then you are just writing to the eigenclass which is in term an object that gets allocated. While procks and lambdas can be viewed, for simplicities sake, as disembodied functions with their own quirks. They aren't a viable way to store and maintain complex logic as it gets out-of-hand quite fast - same as with a monolithic method (and they are also objects which you allocated). **I think you have a case of premature optimization**. Ruby's core paradigm is OOP. Objects are meant to be created, used and destroyed. If you handle object creation in a chaotical manner then you will suffer bad performance, but this is not the case here. Trying to shave off object creation in this manner leads nowhere. You don't know if it impacts your application's performance at all until you measure it. This is 'end game' optimization you are talking about. You do this only when you don't have anything else to optimize except for the odd PORO being created.
FWIW I would rather have the person "enter" the room :-P
You dont need to: http://www.rubydoc.info/gems
Unavailable on mobile. Why?
Absolutely... But I don't think these machines will be built by CodeSchool "programmers" ;-)
This method will return true if date1.end and date2.start are same. But it should return false. Also date.start and date.end are strings. Should I convert them to_datetime while doing the evaluation or there is any shortcut?
You showed datetime data, if date1.end and date2.start are the same it means the contiguous date block is date1.start date2.end -- the same means they are the same date and time which means they inherently overlap. If date2.start was 1 second later than date1.end they would not overlap. If you have bad data and the end time is actually meant to end at 3:59:59 instead of 4:00:00 then you could either modify the data on the check to (date1.end - 1.second) (date2.end - 1.second) or correct the data on import. Either convert to datetime object or to a integer representation of datetime. 
Works here. Straight into YouTube. 
Love the series so far. Thank you for overcoming the seemingly irresistible urge to teach classes by using a class full of classy people as an example!
It's a common problem for developers to predict their written code can be understood by themselves after a period of time (and that period is often quite long) So what I recommend writing code while thinking about "the future version of yourself"
Working here as well. Using AlienBlue and no problems. 
Interesting, but not sure how useful it is due to the complexity of calculating it in many countries. For instance, in UK there's a tax-free allowance - meaning the first 11K earned a year is income tax-free. Hence that effectively pushes each of the tax bands up by 11K, so the calculations currently given are inaccurate. This is further complicated by very high-income taxpayers having their tax-free allowance reduced as their income climbs (scaling down to zero). Then there's the additional complication of national insurance, which in UK has become *an additional income tax by another name*. The amount paid varies by amount earned, 12% (basic rate), 2% (higher rate). So, in reality, you need to consider: - Tax-free allowance - Income tax rate - National insurance rate. So, the real rate of tax in UK is more like 32% basic rate and 42% higher. TL;DR: The library understandably tries to avoid complexity, but it makes the returned number completely inaccurate. Helpful cross-reference: http://www.listentotaxman.com
Another thorough and well written article. Though I disagree with everything you said, and the blog you linked to, about duck typing. 
I'm glad you liked it. About the example, that's because I like cars better than people (kidding).
I'm enjoying the series. I am thinking a little differently. I love those aha moments, even though I know I will probably forget what I learned! But still I will hang on to some of it, so thank you for the series.
Similar in South Africa. There are various tax reduction factors, there's the difference between pension-fund and non-pension fund income, rebates for medical aid contributions (quite a complex calculation), etc. etc. etc.
Wow, this community is pathetic.
Awesome article. Please post any more articles you wrote, I would love to read them.
Also, while there is no direct effect right now, [the rates for the "UK" are different if you live in Scotland](https://www.gov.uk/scottish-rate-income-tax/how-it-works). I guess that's a pedantic point but it's likely worth allowing for.
Great talk
The context of this gem was to make TravisCI's salary calculator. (You will understand better if you check the talk given at RedDotRubyConf... also posted in this sub) If you watch it, you will understand that the main purpose is not to be **THE** gem to calculate these things, but rather have a rough idea on how to calculate how much you would win if you move to one country or another. Also, there's ofc room for improvement, so instead of just saying "this doesn't work", maybe commit something, help with the docs or contact the creator to improve it.
I always that when you write code for "others", one of those people is your future self.
Thanks for your feedback. I'm glad the post was useful to you. All of my previous posts are at the Zen Ruby blog (www.zenruby.info)
it is indexable: https://blog.codeship.com/unleash-the-power-of-storing-json-in-postgres/ scroll down about halfway to the sections on indexing. I ended up using this on a small project that was pulling data from an API that I didn't trust to stay stable, but also contained data I don't need to be fully pulled into a relational DB. Think a simple events calendar, all I really needed was a unique ID and a date - anything else they threw in could be used or not. This way I just store the JSON string and can parse it and manipulate it however I want for each event when I need it, all from one request.
Sup bacon cannon!
&gt; Write the best code possible today and be completely unattached to it and willing to delete it tomorrow. This is probably the most important. It isn't the code or the cleverness, it is the overall solution which is important. Ego has little place in a collaborative environment. Create Gists of your favorite code samples for reference and nostalgia.
hm, not ideal but not a terrible idea. It's going to be terrible performance under heavy contention (compared to actually using the appropriate postgres feature), but would work decently if conflicts are rare. 
isn't this lib obsolete in ruby 2.x versions?
Sorry, what?..
The reason that `"ac"` matches is because the regex is not anchored: 'ac'.match(/(a)?(?(1)b|c)/) =&gt; #&lt;MatchData "c" 1:nil&gt; 'ac'.match(/\A(a)?(?(1)b|c)\z/) =&gt; nil
[removed]
Thanks for the explaination.
I don't think you've seen a 'nil' related crash until you hit this bug in production code: require 'openssl' 2.to_bn.mod_exp(2, nil) 
you can probably do that with a custom AR `select`. I'm not sure what the best way to support that as a general pattern in AR is, but if you have an API in mind, it might be hackable without too much trouble, building off of custom AR select. 
Benchmarking this gives promising results too (ActiveSupport being ~1.3x slower in this specific case): https://gist.github.com/solnic/a7c917b15d953faf79a83f45d77462b2
I have had a few problems with the site but don't think its because of what you wrote, thank you for the commit!
I find it a little funny that the slides talk about some of the studies that show employees are many times more sensitive to mangers/work environment/etc vs salary for overall happiness right before they go into how they have automated salary negotiations to marginalize the ability for management to be flexible regarding salaries by automating them and turning employee (value) into a formula. Optimize one of the lower "happiness" items away by marginalizing the high value items on the list.
Any clue, why the [implementation](https://github.com/rails/rails/blob/f5d8dd6d8fc13bf931896f8435baf9779b3136ab/activerecord/lib/active_record/log_subscriber.rb#L56-L65) uses `/\s*\Ainsert/` instead of `/\Ainsert/`? AFAIK, `\A` already anchors at the beginning of a string, so the only value which matches `\s*` (0..*n* whitespace characters) is `""` (i.e. *n* = 0). What am I missing?
Just wanted to clean up the apparent confusion :) In this scenario, the capture group is empty (but still exists), and the string matches the regex. 
I like the concepts presented here. The deeply nested directory structure and classes being 3-4 modules deep is a bit of a turnoff to me, however. Referencing the very simple (yay!) Sitemaps class requires ~40 characters of namespace code (boo!) 
Absolutely nobody and nothing is forcing you to use namespaces :) Personally I prefer isolation and avoiding silly nameclashes; I also like the fact namespaces group concepts in a logical way so it's easier to see individual components of your system.
This is great. This is how I want to write my codes, I know oop concepts, how much practice do I need to write such code and what kind of problems should I start solving to get there? Generally, I solve such problems simply thinking how would I solved it in C, and start writing it in ruby by converting the C code mentally. In this case, I created a single method, just like C functions and did everything in there finally returning the resulting array.
Thanks for the explanation. I will look into the Practicing Ruby post and consider updating my post.
REPL Driven Development with Pry: https://www.youtube.com/watch?v=D9j_Mf91M0I
I agree and if there is a reason for that I wanna know... That seams so weird.
ruby sao tự nhiên, chất lượng và giá rất hợp lý
great star ruby.
Yes, Hanami solves a lot of these problems too. It's great to have choice! It's on our roadmap to offer a "dry-web-hanami" gem that integrates dry-component with hanami for routing/view rendering, etc.
any chances sinatra is on that roadmap too? :)
entire article can be found here http://www.eq8.eu/blogs/26-rendering-paperclip-url-via-elasticsearch-without-making-calls-to-activerecord-db
What exactly makes you feel this way?
&gt; statically type check method body when called at runtime That's not what statically means...
To be honest I don't really know how to help you. I would recommend practice and reading. With practice, you will get to know what building blocks are at your disposal (to build your application). With reading, you will learn even more oop and general Ruby concepts. Perhaps 'Learning Ruby', 'Ruby best practices' and 'Confident Ruby' are good books to get you started. Oh! And meetups! If you have a local Ruby meetup, that is. I learned Ruby so long ago that I forgot how I started and what helped me the most xD But I always start learning new languages with the 'reinvent the wheel' method - find something that already exists and recreate it.
Very nice, I think I'll stick with adopting gems from dry-rb over time, and put off wholesale adopting something like Hanami right now. It is seriously a lot to absorb for those of us just starting down this road away from either magical (CoC) or ad hoc ways of structuring projects.
&gt; we literally have almost 0 concepts that are the same as in Rails The most glaring example I think is dry-validation which looks like a subset of AM's features with a new DSL. ...but I don't know why you'd present that as a positive. Do you think Rails has nothing to offer? I think you torpedoed yourself, because logically a 1) collection of libraries designed to help implement web apps in Ruby that 2) is entirely dissimilar to Rails 3) must have reinvented some wheels. You "don't" have an ORM but you recommend ROM which is an anagram of ORM and which a cynic might say is similar to AR but with more indirection between the caller and the datastore. Fat persistence model... are you referring to the old "fat model / skinny controller" phrase? If so, I think many of us have been exposed to many patterns that help alleviate that issue without breaking out of the "Rails Way" No controllers... Roda's DSL looks a lot like Journey's but with words that don't make sense (is/on instead of scope/module) unless you get into their tree metaphor; and then Sinatra crammed inside it. No ERB... OK, I haven't used ERB in a Rails app in a decade. dry-view/dry-web have empty readmes and aren't listed on the dry-rb website, so I can't really say anything there. No view helpers... I didn't realize those were bad? They're just functions, right? Oh, I guess if you rely heavily in ivars in helpers you're gonna have a bad time. Whatever, I like being able to point the gun at my foot. Anyway, not much of a wheel here since view helpers are just modules. AssetPipeline I'll admit was/is awful, we have Webpack now. Code Reloading... again, this is bad why? Because all of a sudden Ruby devs are jealous of trendy new languages and want immutable state and pure functions? Maybe... IMO Ruby's dynamic nature is a terrific positive that, sure, can result in a stale runtime, but my apps all boot fast enough that I don't care. The bigger point- the Ruby community has a reputation for not being fragmented to shit like the JS community. You're obviously gunning for Rails users here, but I don't see any support for your claim that in large, complex apps, this is any better. Furthermore, I reject the premise that large Rails apps are difficult to maintain because of Rails' shortcomings. Large apps are difficult to maintain because of executives, managers, deadlines, bad team dynamics, and lazy developers; and I don't think your framework addresses those problems.
&gt; The most glaring example I think is dry-validation which looks like a subset of AM's features with a new DSL. It's not a sub-set, it's more powerful, more flexible and faster too; it's also a different philosophy so you basically came to conclusions with zero research on your side. &gt; You "don't" have an ORM but you recommend ROM which is an anagram of ORM and which a cynic might say is similar to AR but with more indirection between the caller and the datastore. Again, zero research on your side. rom-rb provides a functional way of working with the databases. &gt; No controllers... Roda's DSL looks a lot like Journey's but with words that don't make sense (is/on instead of scope/module) unless you get into their tree metaphor; and then Sinatra crammed inside it. Specifics of a routing DSL are less relevant here, the idea behind routing tree is what counts the most, it leads to much cleaner routing logic and it's simpler to understand what your http end-points are doing. &gt; No ERB... OK, I haven't used ERB in a Rails app in a decade. dry-view/dry-web have empty readmes and aren't listed on the dry-rb website, so I can't really say anything there. Right, we should finally add dry-view with docs to the website. Thanks for reminding me. &gt; No view helpers... I didn't realize those were bad? They are bad because of the way they work with state-sharing between controllers and helpers; furthermore, they are insanely complex and slow, what I've been trying to do is removing the need for helpers and focus purely on rendering templates + providing data for the templates (which is how dry-view works). From my experience helpers in rails apps have been one of the most horrible places. &gt; Code Reloading... again, this is bad why? Because all of a sudden Ruby devs are jealous of trendy new languages and want immutable state and pure functions? Maybe... IMO Ruby's dynamic nature is a terrific positive that, sure, can result in a stale runtime, but my apps all boot fast enough that I don't care. Not at all. Code reloading in Ruby is not reliable, thus shouldn't be used, Rails provides a hacky "solution" just because it's booting process is too slow. In addition to that - code reloading has been giving issues lib developers who want to make their gems work with Rails. &gt; You're obviously gunning for Rails users here, but I don't see any support for your claim that in large, complex apps, this is any better Time will tell, this stuff is based on years of experience with Ruby and Rails, and our experience so far has been very positive, so we started promoting these projects. I understand your skepticism though. &gt; Large apps are difficult to maintain because of executives, managers, deadlines, bad team dynamics, and lazy developers; and I don't think your framework addresses those problems. Partially agree with this. Large apps are difficult to maintain because of many design issues in the foundational tools that your systems are relying on (in case of rails it's mostly tight coupling between the framework and everything that your app is doing and encouraging really bad practices). We're trying to improve this situation, so far it's been successful *for us*.
I originally planned on keeping it at the original 151, but it would be relatively easy to add the rest into the script if there's interest in it.
&gt; JavaScript isn't versatile http://cdn0.vox-cdn.com/imported_assets/2193549/baelish-confused.gif
y?
A ruby core bug or a bug in openssl C extension?
I'm guessing that's the C extension: ext/openssl/ossl_bn.c You can paste those two lines into irb to replicate. 
From what I know, the fileicon bash script that I'm using was written for OSX. As I don't have a Linux environment to test things out in, I don't have a good way to dev it for Linux. Would you be interested in helping out with that?
disable SIP. its a stupid pile of crap. http://osxdaily.com/2015/10/05/disable-rootless-system-integrity-protection-mac-os-x/
Do you have latest version of xcode and did you run it once? 
If you can type check a method implementation without running that implementation, then it's static. It doesn't matter whether that happens at compile time or run time.
A standard install via rvm into a users .rvm folder hasnt had an issue on 2 rebuilds I did this month. Though I don't use the autolibs option. But lets go ahead and disable security features so the bar is a little lower for bad actors on developer machines.
The issue with SIP is that it actually removes the real root user's ability to inspect what is going on in the machine. At first glance it appears to be a great security hook, but when you look closer it actually makes it much harder to even detect if you have a breach. Most all of its value seems to be to limit normal users from gaining access to inspect executable that Apple does not wish you to inspect (DRM etc).
A screenshot would have been nice.
Heh, the problem is that once you have to do it, it's pretty much impossible if you're using a classic ORM, because you have to completely change your codebase inside out. So while the majority of us will never have to do it, for cases where one might need that they better use ROM upfront, otherwise they're screwed should that moment ever come :)
yeah i'm using xcode BETA atm.
Extremely interesting! I've been playing with statically inferring ruby types in my spare time lately and I had similar ideas for typechecking dsl-s. Do you plan on supporting more powerful type systems (e.g. checking purity etc)? Do you plan on doing something like that for Python? I'd also love to see it open sourced in order to be able to contribute
Isn't this essentially cancelling strong params? The point of strong params, from what I understand, is for you to be explicit in your code about what params you whitelist . This gem basically makes you oblivious to that and brings you back to the way it was before strong params. To me it would be idea if the gem simply cancelled the strong_params Rails behavior for peopel who don't want it .
&gt; Isn't this essentially cancelling strong params? How so? From the README it looks like it still uses some kind of protection, but records all allowed attributes during development.
That's a really nice idea, and I'm sure it will be useful for building simple, personal projects. However, I don't think I'd find it much use in larger, professional systems. * Your config file will soon become huge and difficult to read; much like the problems faced with implementing `CanCan` in complex systems. * Parameter whitelisting is often not this simple. You often need to make decisions about which parameters (or even, which *values*) are whitelisted, under various conditions - e.g. different user roles. * I wonder how this will cope with parameter re-naming, or editing the form work-flows... My suspicion is that it could get real ugly for big applications. (Will the config file get outdated? Will there be huge ugly merge conflicts?...) Nevertheless, it's a great concept to show off - as long as you're aware of its limitations.
&gt; I disagree. If you need layer upon layer of abstraction maybe it's because you architected your project wrong from the get go. That's not true. Both AR and Sequel has similar abstractions but they are not accessible (or less accessible) as public APIs. AR has Arel with its Relations, Sequel has its Datasets, both ORMs use db drivers. It's the same in rom-rb, but we expose it as public APIs. You *don't have to* use relations explicitly in rom-rb, you can just use repositories, but from the experience we've had so far it's extremely beneficial to have relations separated as they encapsulate query logic and are composable. Same thing with mappers, in ORMs they exist, but they are not explicit, and not accessible, in rom-rb it's a standalone component, and same like with relations, you don't have to use it (repos create mappers automatically), but you *can* use them if there's a need. Apart from that - we have no mutable model concept, and it's a whole abstraction that adds complexity that is not really needed, and in that sense rom-rb stack is *simpler* than AR/Sequel. Also this: https://twitter.com/_solnic_/status/748108916979032064 &gt; Yea again. You are telling me that I need to scatter my code over ten files where it used to be in one. I do not. You can use a single repo if that's your preference. &gt; Finally. What makes you think AR is not scalable? What makes you think Sequel is not scalable? Sorry, didn't make that point clear I guess. You can scale with any technology, it's just that sometimes it's harder than it should be.
&gt; https://twitter.com/_solnic_/status/748108916979032064 I would never use any ORM or even ruby to create 10K records. I would put them in a string and stream them into postgres using the COPY command. &gt;Apart from that - we have no mutable model concept, UGH.
&gt; I would never use any ORM or even ruby to create 10K records. I would put them in a string and stream them into postgres using the COPY command. The way things are tangled was the point of this comparison, not how many records are being created. My bad. 
And if you hit the wall disable it. This is a vanilla ruby installation via RVM with homebrew installed as part of the process. SIP is here to stay more than likely, like UAC on Windows. It can be bypassed in some cases but it's here and sticking. Most software should be able to operate without it being disabled. Worth noting is none of the tools I install via homebrew have recommended disabling SIP. The likelihood of that being the true root cause here is next to nil. Ultimately if SIP was a potential root cause, turning it off to test and filing a bug report with upstream would be the responsible approach, like you would if software wasn't able to run with antivirus. Yeah, I know there are exceptions, those should be explored carefully though. I've had to help too many folks with drained accounts to support disabling security features or software as an unverified default approach. This is a generic ruby install on OSX. I rebuilt my work Mac not long ago and got a new one at home last week. Both are still running SIP. On researching SIP a little more for this comment, checking logs for policy violations is like checking any other system event log and dynamic on/off with logging is viable. So you don't need to guess if SIP is causing someone an issue. If you are doing things and SIP is getting in your way, it's easier to turn it on and off. Of course if malware check for the kernel extension it can turn it off, but, you would still get the logs. https://reverse.put.as/2015/10/12/rootfool-a-small-tool-to-dynamically-disable-and-enable-sip-in-el-capitan/ :)
I actually think we should stop all defining controller actions. using https://github.com/NullVoxPopuli/skinny_controllers/ I only write strong parameter permits (unless I actually need some business logic, in which case, I write an operation or a policy) Example: https://github.com/NullVoxPopuli/aeonvera/blob/master/app/controllers/api/pricing_tiers_controller.rb
have you even looked at es6/es7? Javascript is now a great little language. Even has a lot of features I wish ruby had. Es6/7 features i love: Modules (import/export), destructuring, classes, fat-arrows, decorators, object spread, const/let, decent Enumerable-like collection methods (map/reduce/forEach, etc), string interpolation. And coming soon: async/await, function bind operator. Modern javascript (es6/es7/es8) is fantastic, almost as enjoyable as ruby development. I used to **hate** javascript but it's really, really come a long way.
Good idea! This is my first self-published code to really be consumed by this many people. [Here's the new readme.](https://github.com/eatspaint/pkdir/commit/5ec93f7eddbd3d520992a4418266142e9f7cd7b3)
Thanks! To be honest I don't think I even realized having an image in the readme was an option until now. [I added a screenshot of some on my desktop for reference!](https://github.com/eatspaint/pkdir/commit/5ec93f7eddbd3d520992a4418266142e9f7cd7b3)
I would feel Johto would be nice. As gen I and II are really close. (Most of gen II pokemon were already designed for gen I)
Why are they using Ruby anyway? If I want something explicit and safe I'd use Java, C#, Scala or Haskell. Like there are poor man's monads there, why not use the real thing?
Yes. I have. I tooled with ES7 and found that await/async would hang randomly for no apparent reason, and fail to resume the continuation. The problem is that you may use these new features but the existing features and problems will continue to exist, such as the infinite-pyramid-of-closure scope, type conversion, long running functions blocking concurrent functions due to it being single threaded (this potentially taking a server down), the fact that JS will never support true parallelism due to its design, built in race conditions (see prior point), incredibly poor error handling - even with promises, often swallowing them entirely with no notification - made even worse with modules from ES6. JavaScript literally consumes memory like it's going out of style and rarely if ever releases it due to problems with self-referencing making memory leaks insanely common. The work they are doing on ES6 is appreciated, but it will never fix what is fundamentally broken. Even Google admits that JavaScript cannot be fixed by adding to the language and has fundamental problems. I am happy you find it interesting, but I am sorry to say, it is a dead end. And thank god, because politically - everything from its name being ripped off purely for marketing reasons to its inventor being an asshole homophobe who supported prop 8, it needs to die. It and its proponents are an embarrassment to the computer science community.
what is `such as the infinite-pyramid-of-closure scope` and how is this not solved by chaining promises with `then` ? ? Also, though i've never had a problem with async/await myself, if you did have problems, it could be due to it still being in draft stage, it's not part of the standard yet and will probably be in es8. EDIT: Further, i've never experienced any of the deep issues you're talking about (broken promises, huge memory leaks) but those are implementation problems rather than language problems, and I think can be fixed. But like i said, i've never even experienced those issues so I can't speak to them. But you sound like an extremist with over-the-top views and you speak in hyperboles so it's honestly hard to take anything you say seriously.
Well then your emotional reaction and ad hominem (calling me an extremist) from the criticism came from.... Where?
At least you're not working with a VB.net Web Form application like I currently am... holy crap.
Polluting the namespace is a very different problem than what I am talking about. I am talking about memory, in Rust-Lang terms this is related to lifetimes. Have you studied lifetimes in Rust? Like I said, modules are no different than inlining the code. The variable still exists throughout the entire run of the program. Also, see my edit above about Ruby not having the same issues because of threads.
Ok, you don't know what 'global' means. Global means it's in global scope, i.e accessible everywhere. You're confusing scope and duration. A closure only closes over what is in scope. So if module B imports `library` but module A does not, then a closure defined in module A does not close over `library`. You seem confused, homie.
And now we reach another stage of emotional reaction. You need to chill with the insults dude, and recognize its you that is confused. You act as if the two are not directly connected to each other. And this is not true. function() { var library = require('library'); function bob() { har = eval('1+1'); } } library is now global (meaning it lives for the entire duration of har.). Are you understanding yet? This is just one argument from the huge list: Here is more information for you to read - http://www.ibm.com/developerworks/library/wa-memleak/index.html And we are referring to large projects as ones that involve multiple people across many skill levels and experience in which it outlives them such that "it can be fixed with design' is not an argument as we have an emergent design.
I've taken a lot of courses, from Lynda to a few on Udemy. But the best, by far, is from https://pragmaticstudio.com/ (beginner to intermediate). For more advanced stuff, www.rubytapas.com is the best.
Pretty neat, but it has its limits: * `ctags` doesn't pick up on the `Foo = Struct.new...` syntax * Two methods with the same name can't be easily distinguished at call site * with all the meta programming/dynamically invoked methods you better have a good test suite or you'll miss the call `send("bar_#{foo}")`
The Pragmatic Studio has two excellent Rails courses that I've taken. I have not taken their Ruby courses but I'm sure they're just as good. Lynda.com is a nice option too, I've gotten a lot out of their courses (haven't taken Ruby from them though).
[removed]
...where are the docs?
Whats new? I haven't been keeping up on rails.
This topic should be removed and the one linking to the blog (which is much more informative) be upvoted.
Congratulations to everyone involved. Great work, guys. And thanks for all the fish.
Take a look at [Hartl's Tutorial](https://www.railstutorial.org/book)
Passenger author here. Phusion is excited about the Rails 5.0 release! Rails is one of the most productive web frameworks out there, and 5.0 just makes it even better. We have released various Passenger updates to ensure that Passenger plays well with Rails 5, Action Cable etc: https://blog.phusion.nl/2016/02/18/passenger-5-0-25/ https://www.phusionpassenger.com/library/config/nginx/action_cable_integration/ However we found a bug in Action Cable yesterday which may cause issues with app servers such as Passenger and Puma. Unfortunately the fix didn't make it into 1.0. I recommend anybody who uses Action Cable to apply our patch locally for now: https://github.com/rails/rails/pull/25615
:) I'm glad you like it
There is a difference between printing something to the console (`puts`) and *returning* something :)
Ahh thanks. I feel kinda stupid now ._.
I love Ruby &amp; Rails, but I hate updating Rails. We just upgraded our stack at work and it took a week to get everything configured correctly. But I guess that's what happens when you use 90+ gems. 
www.codewars.com is a good place to do exercises (katas) and compare your code to others. As a beginner, and also learning Ruby, I find it a good way to learn and solidify the knowledge. It's also quite motivating when you solve a difficult exercise or when you see your rank go up. Edit: Typo.
Damn I hate minitest. assert_equal just doesn't flow in my brain. 
Yeah it would be really nice if Rails allowed you to upgrade its components individually, so that you can upgrade gradually instead of all at once.
Yep I have seen ZFS catch rot. I am kind of meh about EMC, and I am sure that rot happens on most all vendors products. One thing I will say about EMC is that I have experienced 3 different data loss scenarios with their products and each time when their support was contacted the first action that was taken was not to work towards fixing the issue and attempting recovery -- but instead to send in lawyers to try to secure NDA contracts to squelch anyone publicly communicating about the loss (which thankfully were not signed). 
No real project strictly follows "semantic versioning". It's a cute idea that just doesn't match reality well.
For example: exists(a, b) do c end or exists(a, b) { c } or, if you have a Proc called c exists(a, b, &amp;c) a and b have default values and so are optional. You can leave out both of them if you want to. Or you could just leave out b. You can't leave out just a. exists do c end As with all method calls, the block is also optional. exists
Thank you so much!! This is exactly what I needed! I'm still a bit confused though. The block is a parameter just like a and b, right? So why is it outside of the parenthesis while a and b are inside?
No, the block is not just a parameter like a and b. When the last parameter starts with an &amp;, it means that it isn't really a parameter, and instead it receives the block. You can't pass a value to it as normal by passing another argument. However, when you call a method and the last argument starts with an &amp;, then that argument is passed as the block, not as an argument. So these two special cases complement each other. When you write def foo(a, b, &amp;c) foo(x, y, &amp;z) You are calling foo with a block z, and that is being put into parameter z, but there is actually no third parameter. The block travels through the special 'pipe' for the block, and not the 'pipe' used for arguments.
Okay, this is making a lot more sense now. My problem was that I was getting errors by putting the block directly in the parenthesis. Again, thank you so much :)
!!!: Boolean cast negation
There are a few big reasons: At my agency, Ruby is what we have long used to develop applications for our customers. As a team, we know it well. Our customers pay us to deliver reliable work, and if there's a way to do that _better_ with Ruby, then we will go for it. Switching languages is a much longer-term play, and while we may do it in the future, it doesn't mean we shouldn't opt for better approaches with Ruby in the meantime. Doing so also means that we can start to familiarise ourselves with concepts (in Ruby) that also exist in these other languages/environments. As for those concepts, just because they haven't historically been a part of how people have worked with Ruby, it doesn't mean Ruby can't still do them well. As a language, Ruby has taken inspiration from both OOP and FP, which is why an FP-style Ruby can still be achieved quite naturally, and still bring benefits to your codebase. Finally, the Ruby community is fantastic. Personally, it has taught me so much, and I am honoured to try and give something back in the form of contributions to projects like dry-rb and rom-rb. &lt;3
Yes, I wrote this code a long time ago :) Most of it in 2009 when I was just getting in to Ruby. What is non-idiomatic indentation? Tabs? Let's not go there and just agree that each to their own preference. Believe it or not, `attr_accessor` is just a wrapper around `attr` (`rb_attr`). So, for several reasons, I prefer `attr` for read-only attributes. On the large methods, I agree, it could be refactored. It's been working reliably in production for several years so it's not a high priority.
Fair enough :) However, I tend to follow the conventions of indentation for a given language, same as i follow `snake_case` or `camelCase` conventions for that language community. Ruby uses two-space indents, and i follow it when writing Ruby. Rust on the other hand uses four-space indents and i follow that when writing Rust. :) Anyway, no big deal, nice project homie!
Yeah I'm with you... when/why would I want to use this? How is it better than passing arguments? (e.g. old people DI)
Without a doubt, you should have a subscription to http://thoughtbot.com/upcase
Yes, very much like a callback in JS, just with some special syntax support to pass a single callback because that's just a common case.
Reading a textbook is a good idea, as are piece-by-piece tutorials. It helps to have a personal project, though - without writing code, the reading isn't internalized as well. Once you feel like you have the basics down, maybe try exploring the gem ecosphere and put things together. Using other people's gems will give you exposure to new code constructs. 
The biggest benefit of debuggers like pry or byebug is the ability to place breakpoints in your code. Debugging will never be the same.
The post is pretty clear it was the developer's opinion on best talks. None of the speakers at the conference work for Grok, this was simply a list of the talks the developers found to be the best. Of course it is opinion.
Aren't all best/top/favorite posts opinionated? I think "Top Talks" already implies "Our favorites" ...
edited in
thank you. great reference.
You have quite an interesting understanding of DI. Does not make it the correct one though. There is no requirement for your dependencies to be registered centrally anywhere. Bringing your J2EE to Ruby? ;)
we've been using html-pipeline for a few months with [thredded](https://github.com/thredded/thredded) and it hasn't been any problem.
I get so tired when I see posts like these shared on Reddit. I feel they contribute to making fellow programmers dumber if they don't have their guard up. You come up with contrived and incorrect examples. First of all - why would you want to declare Tom in your application only to clone him and make him a year older? What is the practical application of this? Please explain this. I have worked almost 6 years in software and I'm yet to encounter this feature request. If Tom really is a *Person*, then he can only have one age. For the sake of argument let's, for a brief moment, assume that we want this. The recommended ruby way would be to marshal Tom into a binary string corpse and then resurrect his alter ego as a new object. Your supposedly bug-free functional implementation is broken, since you are merely creating a new object that reference the same variables(@name), as exemplified here: irb(main):013:0&gt; young_tom = Person.new("Tom", 29) =&gt; #&lt;Person:0x007fdabb81a9a0 @name="Tom", @age=29&gt; irb(main):014:0&gt; old_tom = young_tom.next_year =&gt; #&lt;Person:0x007fdabb805780 @name="Tom", @age=30&gt; irb(main):015:0&gt; young_tom.name.reverse! =&gt; "moT" irb(main):016:0&gt; old_tom.name =&gt; "moT" If you want to be an authority on the subject, you should consider checking these things before dispensing your wisdom on the internet. Of course you can argue that my example above proves your case, that mutation is so pervasive that even a functional evangelist like you miss it. I think you are trying to mold a car into a motorcycle. For your tally example, I do agree that the functional total calculation looks much cleaner, but if cleanliness were my primary agenda, I would require activesupport and invoke sum. [1,2,3].sum =&gt; 6 The purpose of an object or a reference for that matter is to share something across function boundaries. The fact that the SAME object can travel through many functions, which can query and/or command that object is a tremendous advantage. Something your post ignores. Instead you try to sell this inherent quality off as a design flaw. As stated above, Ruby comes with adequate support for xeroxing your objects, so if that's your thing, then go nuts. This whole problematization of shared state and variables being mutated reveals a self-contradiction. By presenting it as a (common) problem, you are acknowledging the need/use for it. You then present the solution that is "don't do it", but provide no alternative implementation, because the truth is that you don't have one. The object is being mutated at two different places because there are two distinct places in your application code that must change it. Maybe **that** is your real problem. If you have independent immutable copies, which one of them goes into the database and which one is just stale? Will you be writing code to merge them into a third immutable copy, and if so - why bother? Or maybe no changes are being made? Are you passing immutable copies down your stack trace due to a terrifying fear of mutation? In conclusion, we go from a situation where a particular feature, in a perfect storm, misbehaves, to a situation where a particular feature just does not work at all, by design. What have we accomplished? I have very seldomly encounted bugs in the wild that can be traced down to unintended state mutation. If something is mutating your objects down the control flow, it usually has a legitimate reason and if you believe it doesn't - please devise a better alternative. And in that case, please write a post on Reddit about it, because then we have something tangible to relate to. Until then, I'm siding with Magneto.
Now I'm genuinely curious. If you're not setting/registering/whatever your "PaymentProcessor" in one place, maybe as one thing in prod and another in staging/testing/dev, then injecting/passing it into anything that needs to process payments, what other thing are you calling DI?
Do you know about the edit command? https://github.com/pry/pry/wiki/Editor-integration
Have you heard of https://github.com/NullVoxPopuli/skinny_controllers Seems like similar goals, but a different approach 
Personally I write anything more than one line in a text editor and then just copy-paste it in. Optional challenge: Try to write everything in one line.
To respond to a few of your points: &gt; why would you want to declare Tom in your application only to clone him and make him a year older? &gt; If Tom really is a Person, then he can only have one age. It's just a demonstration to go along with the explanation, not a production application. It could just as easily have been `User` and `password`. &gt; you are merely creating a new object that reference the same variables That's kind of the point of the article (see the part about "pretending"). &gt; You then present the solution that is "don't do it", but provide no alternative implementation, because the truth is that you don't have one. I provided three example of alternative implementations. They are small because they're down at the implementation level, not at the system level, which is what you seem to be angry about. I have non-rails web apps in production with 100% immutable models, and I know other people that are doing the same thing. I'm sure I'll write about that higher-level design eventually, it's just not what I wanted to cover in this particular post. &gt; If something is mutating your objects [...] please devise a better alternative That's what the post is about. It's totally fine if you disagree, but I think you're being quite unkind about it.
**One solution:** puts 'Give me a number' number = gets.chomp.to_i better_number = number + 1 puts "Don't you think #{better_number} is better?"
Ah, I see why this is confusing. To be honest the tutorial is mostly being silly here. There's really no logical reason for this usage. It's kinda of like [Kristen Wiig's SNL character 'Penelope'](https://www.youtube.com/watch?v=sX9xNn2f1Go) where she's constantly trying to 'one-up' other people. You're basically just trying to one-up the user for the sake of fun. * You're asking for their favorite number. * Converting that answer to an integer. * Adding 1 * And returning that value, in the voice of Penelope, as "Yeah, well my favorite number is &lt;whatever they put + 1&gt;, soooo...."
About the reassigning variables part: I meant to mention how mutation is ok if the method is pure, but the article was getting too long, so I split it up. It'll be in the next one which is about side effects. Reassigning local variables isn't really that bad, but I still try to avoid it by default.
Ah, of course! That's excellent! Thank you so much. I wonder if you would be so kind as to explain to me the ".to_i" method. Is this necessary to include because I am getting the string? I'm sure that makes no sense; I suppose what I'm trying to say is, had I declared number = to an integer (i.e., without quotation marks) rather than "getting the input" from the program after it was run, need I have followed it with ".to_i". Again, that question is likely incredibly moronic and there's probably no distinction between getting strings or anything else. I cannot stress enough how clueless I am! Thank you for your time! xx
You're grasping it pretty well. I wouldn't be so hard on yourself. When I was first learning, I was like you in that I needed someone to explain certain things in layman's terms before I could really understand it (I still do, to be honest). And trust me, once you have a job doing this, developers are over-credited in salary.
Thank u for the vote of confidence. Feeling extremely dense :) xx 
What's an irb console? And is .to_i only used for input from console? or must I append it to all of my strings even if those strings are clearly numbers owing to their lack of quotation marks? xx
Presuming you're on a Mac, irb (interactive Ruby) can be run in your Terminal by simply entering the command "irb". It allows you to input Ruby code and instantly see the return to quickly play around and see what's possible.
Congrats &amp; welcome! Suggestion: in your path to learning ruby, don't go overboard in describing your lack of knowledge or apologizing for it. Everyone started somewhere. Even when you're asking people in person, or posting online. You probably don't have to give your level away at all, the question itself will be enough to describe to what you need to know. You'll find that the ruby community is the most supportive, friendly &amp; welcoming community to newcomers. There is someone at work who always comes up to me apologetic and says "really dumb question".... (and then asks). I said to them the same thing! No dumb questions!! Good luck and let us know how it went. Oh...check out the Code Newbie podcast, weekly chat, and web site, and anything else by Saron Yitbarek - she switched careers to development and realized how little support there were for new comers, after coming up she started all of that to help the next people after her. 
++ ... exactly my perspective. It is one thing to freeze/make immutable in ruby for performance reasons -- it is a delusion to think you can shoehorn ruby into being haskell or some other immutable/typed language by waving your hands around and spinning in a circle. 
Use `amend-line` See the gif file here: http://recordit.co/QFhm71IF5I Type `help amend-line` inside Pry to read more about it (you can also delete lines rather than replacing) development [5] pry(main)&gt; help amend-line Amend a line of input in multi-line mode. `amend-line N`, where the N represents line to replace. Can also specify a range of lines using `amend-line N..M` syntax. Passing "!" as replacement content deletes the line(s) instead. amend-line 1 puts 'new' # replace line 1 amend-line 1..4 ! # delete lines 1..4 amend-line 3 &gt;puts 'bye' # insert before line 3 amend-line puts 'appended' # no line number modifies immediately preceding line -h, --help Show this message. See more information on the [Pry wiki](https://github.com/pry/pry/wiki/User-Input#Amend_line) (Source: I wrote Pry :P)
Thanks for letting me know, much appreciated!
I think there is lots of ruby jobs and I do it myself but if I was going to pick something to learn I would learn node because it's getting popular and JavaScript knowledge is so useful for client side work as well. 
Are you based in the UK or US? I think that matters. At least in the UK the contracting market dried up around 2 years ago.
&gt; It's just a demonstration to go along with the explanation, not a production application. It could just as easily have been User and password. In that case, you should provide the use case and show how tangible qualities are obtained by creating immutable users. Does the immutability stretch into the database or are you still allowed to issue UPDATE's to the database? &gt; you are merely creating a new object that reference the same variables &gt; That's kind of the point of the article (see the part about "pretending"). No, you are presenting, to the whole internet, your implementation as immutable. That's what the section headline says. I have just given a trivial example of how your solution is not immutable, to which your answer should be apologetic. You are the one who is inadvertently misinforming. &gt; I provided three example of alternative implementations. They are small because they're down at the implementation level, not at the system level, which is what you seem to be angry about. Yes, I was angry. I don't design implementations. I design systems. Succesful systems are built from a combination of implementations that play *nicely* together. You cannot push seriously for better practices, without first enumerating the benefits of the existing practice and critically evaluate what you giving up and whether that sacrifice is acceptable, before changing your ways. &gt; I have non-rails web apps in production with 100% immutable models, and I know other people that are doing the same thing. I'm sure I'll write about that higher-level design eventually, it's just not what I wanted to cover in this particular post. I encourage you to open source such apps and refer them in your posts, so nay sayers like me get something more tangible presented within a larger frame. &gt; If something is mutating your objects [...] please devise a better alternative &gt; That's what the post is about. &gt; It's totally fine if you disagree, but I think you're being quite unkind about it. I know I may come off as frank, but consider reading your own post: &gt; In summary, avoiding mutation makes your code easier to read, easier to write, and less buggy. It gives you confidence, and reduces the need for frustrating debugging. This is a claim of universal truth. You are not writing *"avoiding mutation can, under some very certain circumstances, make your code easier to read ..."*. You are implying that the code I write is hard to read, hard to write and buggy. That can also be perceived as unkind. :-(
&gt; Did I make everything immutable? Of course not. I just made the part that made sense. However, I probably wouldn't come to that idea if I didn't hear about benefits of functional style This is something that people typically refer to as "Functional core and imperative shell" and it does wonders in every code base regardless of the language. I've been doing that for years, never looked back.
based on myself: * no matter what language/framework you choose to learn you will get it wrong first few years until you gain experience, so you may as well learn basics with language that you will no be beading from your eyes because of syntax or complexity (Ruby is super easy to learn with good community guiding you to good practices) and then if you decide you want to move to something else you will just transfer the knowledge * you will find job in Ruby, of course you will not be paid $100000 anual on your first role, ...that applies to any language * the salary in Ruby market (as well as any language) reflects how good you are, if you planing to constantly improve your skill set then you will earn good money, if you planing to just learn book or two and for next 5 years make a paycheck from that you may want to look into Java (just kidding :) ) ... **Being web-developer is a lifestyle not a profession**, you need to constantly learn new stuff no matter what language you choose otherwise you will not have a good time on market no matter what technology you choose. * last point and most important lot of time Laguages and Frameworks are Bubbles (similar to economy bubbles) they come and go, true value is popularity overtime. 5 years ago if you apply for RubyOnRails job in UK (and if you were good) everyone would throw money at you, now it's the same if you say you are Frontend developer doing Angualar JS and next few years it will be React JS... the point is market will eventually balance of after few years and you may find that maybe the technology you are in is not as popular =&gt; you are instead of 500 per day earning 400 per day ...big F..ing deal ! it's still loot of cache !!! so yes market is still OK for Ruby for next several years, and looks like it's growing (according to http://www.tiobe.com/tiobe_index) but truth is that amount of developers that code in it is as well. So you need to aim high and keep learning from now till ... well forever. ...and Personaly If I were you I would lern Ruby again because after 10 hours a day behind a screen (yes you will spend that much time a day or more) I don't want to commit suicide like from other languages
Oh yes! The first and only time where I came across this was in a Destroy All Software screencast, Gary Bernhardt was guiding us through his Twitter terminal client. This idea how he presented it was super interesting and mind-opening to me, thank you for reminding me of this name.
It's reached the point in its lifecycle where it's a stable, relatively conservative choice. Big companies are doing *lots* of rails work; much of it maintenance, but a fair amount of new projects as well. Nothing else has *quite* got the same speed to get a CRUD app working (although I'd put my money on Phoenix getting close in the future). If you go for Rails now, chances are that the jobs you'll get might not be the glamorous, fun ones, but they'll be reliable. 
&gt; you will find job in Ruby, of course you will not be paid $100000 anual on your first role, ...that applies to any language Pretty sure that's not impossible in the SF Bay Area. 
My no #1 for not using Ruby is the fact that almost every google search end with Rails results and not just Ruby
Hi! I'm a book pricing bot powered by [Textbookly](http://www.textbookly.com). |Name: Programming Ruby 1.9 &amp; 2.0: The Pragmatic Programmers' Guide (The Facets of Ruby) |ISBN-13: 9781937785499 Type|Retailer|Price| :--|:--|:--| New|AbeBooks.com|$27.78| Used|Half.com|$24.99| Rental|BookRenter|$24.70| [Link to pricing](http://www.textbookly.com/Search/?id=9781937785499) 
I think ruby is great for non-rails work. Just gotta be extra specific / add "-rails" to your search
I've never read it and I'm sure there's a lot of good stuff in there, but I would recommend getting something which covers features in ruby &gt;= 2.0. 
The [Range#include?](http://ruby-doc.org/core-2.2.0/Range.html#method-i-include-3F) question is misleading, since that method is defined by Ruby, just monkeypatched by Rails.
lgtm 
I was surprised that was wrong for that reason. I chose Ruby and knew `include?` was a Ruby method.
As others have said, there are newer editions. BUT. That's the book that I personally consider one of the best introductions/cover tutorials to Ruby. Even second edition may be outdated in some details, but not in the spirit and structure.
Seems like a setting you might what in production to avoid getting notified with a bunch of worthless errors - I've seen quite a few due to crawlers that don't respect robots.txt or just make up requests - but not in development. Is there a setting that can be toggled?
Could you give more details of the UK market please.
Could you expand on the SF market? I'll be job hunting soon and I'm in the region. How are things for junior developers and what are people looking for? 
There should be at least 100 questions. It's a stretch (wrong) to conclude someone's a Ruby expert because they got 9/10 right. I guessed on half of them but still had a 50% of getting the right answer. 
London is pretty much where it's at.
:shipit:
&gt; A lot of devs are small minded and think they can use one language to solve all problems. Ironically, JS is the closest you'll get to language that can do that.
Ah, the infamous culture fit. I usually get along with people, so hopefully that's not too much of an issue, though I do get nervous at interviews. I'm currently going through an online bootcamp and have about 4~ projects to showcase on Github that I've spent 30-50~ hours on each, give or take, committed frequently (pretty much any sort of change like adding a gem to creating a view page to adding a method to a model), implemented some testing, and so on. Hopefully my Github is alright. With regards to practical programming tests, I'm guessing algorithms and data structure questions? I've heard those aren't as frequent with Rails shops, but I've been doing a LeetCode question a day anyways. I do fine on the easy ones (hash, stack, queue, binary search, or sort seem to be the answer to all of those) but the medium ones can stump me or at least take a long time.
Then you miss a nontrivial number of search results that include "without rails" or even reference "ruby on rails" but only in passing. It's a real problem, sadly :(
 &gt;Also, if you want to really win in your software development career, look to solve the human problems too This. I've come to realize being good at cutting code isn't the main thing that levels me up. But dealing with expectations of others and knowing how to convey your proposal. 
The truth is there is more demand than supply for Ruby devs at the moment, and many new companies are choosing Ruby because it's tried and true and still productive. It's not as shiny as other tech, but it doesn't compete on the same field as them either. Rails is the tech you pick when you want to make a safe bet and develop an app quickly. In addition, the amount of experienced Ruby devs is shockingly low. As with any technology you have people who are there for their paycheck and people who love it. Rails is even harder to find experience in because the people who love it have had to go through a lot of self learning and tribulations to get there (I'd argue that other older technologies have a smoother transition from university). &gt; Java and JS are used in virtually every web application in the universe This is not true. Yes for JS because it's the only language the browser supports, but definitely not for Node or Java. I'd say Java and Rails have close to even market share (there are more Java devs though because Java is the better enterprise choice)
Just had a go with pronto, the difference is that BlissAI only finds diffs (new issues introduced in the PR), where as pronto spits back any issues that are in the code that was touched.
You set the comparison branch with pronto, see the readme. In practice on something like travis CI this info is available so you just have to tweak your invocation. 
That's all culture fit is. If you're a normal human and can eat food with other normal humans you'll be fine. Algorithms are not what I'd call practical. They're theoretical. You should have a basic knowledge of them and have an idea of what to look up when you've got to optimize a slow operation. Most of your job is going to be engineering, which is building bridges. Let the scientists work on algos in universities and at Microsoft/Google. When I've been asked to implement algorithms on a whiteboard, I decline and respectfully leave. Not just because I'd fail (which I absolutely would). Only happened twice. Unless you're applying to be a professor where you're going to be writing code on a whiteboard, it's not relevant. Those kinds of interviews are designed to enforce a power differential. The interviewer will be doing these tests several times a week. The candidates will do them maybe a few times in their lives. This type of exercise is just a bunch of fart sniffing. I don't have enough fucks left in my life for that. There might be some logic tests to see if you can think... Logically. Just be methodical and break things down into small pieces and you'll be fine. Most definitely expect some data structure and activity diagrams on the whiteboard... because....that's how we actually design those things. Be comfortable with spinning up a new app on your laptop and using api's. I'm clear in my interviews that stack overflow or whatever are absolutely permitted and encouraged. It's not a memorization test, and you're going to be hitting the docs during a normal workday anyway. Ask about that if it isn't made clear. "Why do you do such small commits? Don't you feel like that pollutes your history and makes it harder to search?" The above is an example of an interview question. There's not a right answer to it, (and I'm on your side with small commits) but be prepared to discuss your position and have something to say about it. Know what you're proud of and what you want to get better at. Generally they're going to be more interested in having a constructive discussion rather than an absolute dogma.
What kind of work exactly?
Aaron Pattersok has talked a lot about this issue. Rack, as it stands, is not well designed for streaming response bodies, or for handling the modern web including HTTP/2. https://tenderlovemaking.com/2011/03/03/rack-api-is-awkward.html You can do streaming output in Rails/Rack using body proxies and fibers, but it's super cumbersome. If you hunt around a little there are some examples.
Yup, I agree with you. There's nothing complex in DI, and yes...it's just passing things around to be more explicit. 
Totally agree, that's why the node community annoys me. JS for server side.... No stop it. Js is a great tool but most of the js community believes it to be the end all be all language.
I think you'll find there isn't a lot of interest because there aren't many applications. It's also open source, rather than spending time lining up the troops, perhaps contributions would be more appropriate.
I often find this kind of attitude, specially among the Ruby community (I don't find it that common in other communities). Just because something is open-source it doesn't mean discussions are not welcomed. I'd rather discuss something until the community could agree on what should be the direction before investing effort to make it happen and work on the contributions themselves. This is how I work in non open-source code as well, and I really think it's the most efficient approach. When something non trivial should be added to the application our company maintains we discuss our options first before writing any code. I don't see why it should be different with open-source. Open-source is about communication skills too, not just coding.
A CS degree?
Streaming support _has_ been discussed at length, there isn't much interest in it, if you feel differently, then write the code, or write an analysis on how it should work. This idea of "let's make enough noise that someone else will do my work" is rubbish.
Adding to this, it's important to note that regex is not just a Ruby thing... Most languages have support for it. Definitely a great thing to understand (at least the basics of) if you're doing any programming.
I have the 4th edition, and it's great. Probably heavier than a newbie necessarily needs, but I learned quite a bit about the internals of Ruby. If you find that the text is over your head right now (no shame if it is), consider Chris Pine's Ruby book. It's pretty inexpensive, and only a little outdated.
I know all of that about Aaron Patterson and I'm myself a big fan of him since I started learning Ruby and Rails in 2007. I read that article the day it was published and I was already looking for a solution for streaming in 2009 much before it has been introduced in Rails 4 (I started myself with Rails 1). What I'm trying to say is that I know Aaron Patterson's opinion on the subject and I've even mentioned him in the article. But he wrote about this 5 years ago (and he was not the first one to bring that subject to discussion) and nothing changed substantially except for the introduction of Rack hijacking, which was a great addition to Rack but unfortunately it seems it didn't "catch", as we don't see it being used to implement streaming support in Rails. I'm not disregarding Aaron's contribution to the Ruby and Rails community, and not only for streaming support. He's not only a core committer in both Ruby and Rails projects but also an important leader in Nokogiri and other important open-source projects and also author of great presentations and articles. I'm just saying that even someone like him had a hard time trying to push the support for proper streaming in Rack and Rails. So, maybe, we need more people involved to help make it work. My main motivation with bringing this subject back to discussion is to see if the interest on streamed responses has increased or not in the community and if there are many others like me that rely on such feature, maybe that would be a good chance to show themselves so that we could decide whether a better support for streaming is actually a priority or not. Maybe the Ruby community doesn't seem to require streaming as much as other communities and I should assume I'll be on my own implementing such solutions. But, in case there are many other people like me, then maybe we could start some real discussion on possible changes to Rack or web frameworks around current Rack, to see if we can make it easier to use by avoiding that everyone comes up with their own solution...
&gt; I can start working on some patches on my scarse free time. Otherwise it would be better used by practicing mandolim or spending more time with my kids. Open-source means respect on both sides, the project authors and their contributors. If you're working on this on your own free time then there are almost certainly better answers here, i.e. why do you think you need streaming in the first place? Open Source largely operates as a function of cooperation between companies, not individuals. While certainly there are folks that contribute their own side time to projects, the vast majority of code in large OS projects is contributed by people being paid to do so. As a result, if you don't have a viable use case that makes sense at a company scale, or is small enough to not have a negative influence, it's unlikely to get in. 
Considering the amount that book covers, the differences between Ruby 1.9 and the current (2.3) are slight. 
I somehow got websockets into my regular application a while ago. I wanted it to be dry. But the amount of shared code ended up to be far less than anticipated so I moved it out. Right now I don't feel the need for integrating websockets at all.... I just separate it
I've tried that, and as @realntl said - It's horrible. The Ruby community is so coupled with Rails that working without Rails is almost impossible if you want to keep your sanity.
I already got one..
well, my last non-rails ruby project was with event machine, and before that a terminal based GUI. What sort of things were you searching for? maybe mine were just edge cases.
Some people are on a Mac and prefer pow.CX, some run rails behind nginx, some prefer a different port due to several rails servers running for different set of projects. Sometimes you need sidekiq and you run foreman, sometimes you don't. No, we don't necessarily need a common way to run a server. There's just no such thing as a common way.
Nailed it. 
I think Foreman does an admirable job of standardizing project runtime. Seems like `Procfile` is `bin/start`.
I really like Foreman and I use it for some projects, but not all of them. That's why I like to use `bin/start`
I think this is a good idea, particularly if `bin/start` (by default) sets up your server exactly as it would be in production.
*That's* the job of your `Dockerfile`.
I don't use docker and, to be honest, using it as a means of enabling developers to control the production runtime environment has always struck me as the wrong way to solve the problem. I vastly prefer packaging my application or service and handing off a `.deb` or `.rpm` package to the operations team (even at small companies where I am the operations team). Docker used in this way seems like a way to cover up pain caused by inconsistency in deployment. It's far better in the long run to impose consistency (and packaging has done a good job of that in unix systems for decades).
If I understand what you're saying correctly (this doesn't support the way you like to set up your projects) then that's exactly why I don't think it's a good idea in the first place.
`bin/start` just makes sure to start the necessary services for the server/application to run. For setting up a local development environment, I like the idea of `bin/setup` -&gt; https://robots.thoughtbot.com/bin-setup
Yes, right on, I think we're on the same page. I said "server" when i mean "service" (or "application")
I just found this old discussion, so sorry if I lost timing :) I've particularly switched from sprockets to webpack due to client performance optimizations actually, since webpack allows me to easily load code lazily by reducing the download load size in my SPA, which makes it load faster specially for slow connections. The approach Sprockets uses for specifying dependencies does not allow such feature to ever be implemented. I've written 3 articles on the subject: http://rosenfeld.herokuapp.com/en/articles/2016-02-29-getting-an-spa-to-load-the-fastest-possible-way-and-how-webpack-can-help-you
Hi there! I've written a lot of stuff to address this problem, most notably [Reel](https://github.com/celluloid/reel), a fully pipelined web server with streaming support based on Celluloid::IO and http_parser.rb. See also the [HTTP gem](https://rubygems.org/gems/http), an HTTP client based on http_parser.rb which also includes full streaming support. If you're curious about Reel, check out [Angelo](https://github.com/kenichi/angelo) which adds a Sinatra-like DSL. Rack hijack is definitely the way to go for support streaming on most existing web servers and web frameworks. It enjoys widespread support both in web servers and frameworks. There aren't really any downsides to it IMO: it allows web servers to hand a raw socket up through the Rack abstraction layer for when you want to go into streaming mode. In other words: frameworks now have raw access to the socket, which is exactly what you want for streaming. I was also happy to see Rails 5 is now using another one of my projects for ActionCable: [nio4r](https://github.com/celluloid/nio4r). It provides a Ruby reimplementation of Java's NIO API on top of libev (and uses Java NIO natively on JRuby). Where other Ruby async I/O frameworks have been rather complex/heavyweight and opinionated (*cough*EventMachine*cough*), nio4r provides low-level portable async primitives.
I prefer a well written README with instructions on seeing up an environment. Easier to debug when things go wrong, and they will go wrong. 
It's called a ternary operator. You'll definitely be using it in your career, so you should check it out: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator Good luck with your career!
It was super-interesting to read your post! Finally some important discussions about future of Ruby web frameworks. First, I'm curious, *can* this Devise issue be fixed by moving authentication from the controller to the routes? I mean, of course that solution sucks, it's not nice to be in nowhere-land (for Cuba and Roda the routes *are* the "controllers"), but would it fix this particular problem? The reason why I'm asking is because I think in that case the problem is not in streaming capabilities, but in limitations of Devise's design. For example, [Rodauth](https://github.com/jeremyevans/rodauth) uses the same throw/catch, but all authentication happens in the *middleware* level, rather than on the controller level. If that works with ActionController::Live, maybe then the solution is to switch the authentication &amp; account management framework. Thank you for teaching me more about what is Rack hijack. However, I'm curious, what exactly are the downsides of using Rack's `#each` solution? You could just make a nicer API like Sinatra and Roda did (the same one which you showed in the post), which internally creates an object which responds to `#each`. This is what I'm using in Shrine's [download_endpoint plugin](https://github.com/janko-m/shrine/blob/9e64704c463a519dae59f3114673ea68d2b8f8e1/lib/shrine/plugins/download_endpoint.rb#L113-L123) for streaming a remote file to the user, by writing chunks of the remote file to the response as they're being downloaded. I know it's a probably a simple use case, but the `streamed` API that you suggested could be implemented with `#each` internally, just like Sinatra's streaming.
What are you missing when you work without Rails? Once I went "off Rails" and started exploring the general Ruby ecosystem, I found so many libraries that are amazing alternatives to Rails equivalents: * Rack's middlewares, [rack-contrib](https://github.com/rack/rack-contrib), [rack-cors](https://github.com/cyu/rack-cors) and others instead of Rails middlewares * [Sequel](https://github.com/jeremyevans/sequel) instead of ActiveRecord * [Rodauth](https://github.com/jeremyevans/rodauth) instead of Devise/Sorcery/Authlogic * [Shrine](https://github.com/janko-m/shrine) instead of Paperclip/CarrierWave * [Yaks](https://github.com/plexus/yaks) or [Roar](https://github.com/apotonick/roar) instead of active_model_serializers * ... However, it does get a bit boring sometimes on RubyFlow or r/ruby when 80% of posts/tools are Rails-specific.
Thanks, janko-m :) With regards to Devise (or Warden more specifically) approach, the problem is not using catch-throw but expecting the block to not spawn a new thread that could potentially throw the expected symbol. I don't know details about Rodauth implementation but if that's not the case with Rodauth (it doesn't call the next middleware or app inside the catch block) then it should be safe. For Rails apps using Devise it seems authenticating in the router does seem to work well for lots of users. But it's not only less flexible than doing it in the controller. For my particular case it wouldn't work since I have to override current_user in ApplicationController to work around what I do consider another bug in Devise in how it handles expired sessions in the timeoutable module. Sometimes I want current_user to simply return nil in that case rather than throwing :warden. Also, I handle a special "anonymous" user, which is sort of authenticated actually, but it doesn't have an id and I also do that in the overridden current_user implementation. What I mean is that authenticating in the Rails router is not always an option even for Rails users. Switching to another authentication framework is certainly something I've been considering lately, but mostly due to lack of built-in support for Sequel (or even orm_adapter). I don't understand why Devise depends on orm_adapter if it actually doesn't bother to respect it. However I'm more inclined to not using any authentication framework at all as they don't seem to add much value to my application. Currently all my Warden authentication strategies are custom ones and there's a lot of extra code to make Devise work with my application that I guess it would be much simpler to handle it with custom code. But I'm telling you this just in case you are curious as this is an orthogonal discussion to original mismatching between Devise/Warden and ActionController::Live. Anyway, this was just an important example to help us understand the current state of streaming chunked responses with Rails and why a better Rack API would be better in this case (or if hijacking was more largely addopted or required by most frameworks). But hijacking probably doesn't work well with evented I/O servers I guess. Maybe that's the reason why Rails doesn't rely on it? Responding to your question, yes, it's possible to build a nicer API around each and I guess all web frameworks do, including Rails. But they are implemented using different APIs. Rails preferred to not add a new API, like Sinatra and Roda do for example with the "stream" block. They tried to handle it transparently and simply include a module in controllers to enable streaming to happen when calling response.stream.write. The problem is that due to how Rails dispatches the request to the controller this module has to spawn a new thread and return and this way the expected catch-throw flow will not work. The way Sinatra dispatches the request, for example, doesn't require a new thread to be spawned, but even if Rails kept its dispatch implementation, if Rails had a "stream do" approach like Sinatra and Roda it wouldn't cause issues like the one involving Warden and Devise. Or if response.stream was built on top of rack['hijack_io'] the new API wouldn't be required as no threads would have to be spawned for that to work. If Rails didn't block the "app.call" method (which is the case of Sinatra I guess), then some existing middlewares would not work as expected. For example, they include by default Rack::Runtime, which will set an X-Runtime header in the response, but it expects "app.call" to block or it won't work correctly. I guess there are many other middlewares in use by Rails that expect this to block. Also, I'd like to point out that simulating an I/O object by using "each" has some limitations. For example, some server implementations might want to optimize network transfers by using a buffer before sending data over the wire and they would send it with "flush" for example. However, with "each" you don't have this control. Either the server will always flush on each "yield" or the user simply has no control on when the response is actually sent (flushed). Also, "each" can only be used for one-way streaming (I believe some call it chunked responses). But "rack['rack.hijack_io']" can actually respond to read too and most methods available to regular I/O objects, like read/write_nonblock, close, close_read, close_write and closed? So, you can provide a simple streaming API around "each", but it can't handle all streaming use cases.
No, this is the default behavior.
Could you show how posts &amp; comments are defined in `routes.rb`?
https://imgur.com/bAaVvgT Is this correct?
Change "resources :comment" to "resources :comments"
The problems are always the same, they're just handled differently depending of the environment. Specifically: * you want evented handling of long-lived connections * you want controlled concurrent-safe access to your internal services Although you want serve &gt;2000 clients with a long-lived connection, you don't want to create &gt;2000 sessions to your database, etc. So you always have to go hybrid. Java has some hybrid frameworks (you can use Netty for async-io, besides the other threaded servers); nodejs builds it into the environment, in that network is handled in an event loop and access to files/databases in an abstracted FIFO-like threaded pool; I don't know about others, but currently ruby doesn't provide such a solution. All existing application servers are either threaded or forked or evented. Reel seems to me the most ready to make the transition, if it hasn't already. 
Worked! Thanks.
That's bitten me once as well. Also, 2 space indents. And make the setting 'tab = 2 spaces'
Thanks for the feedback! If the `City` were within a larger application I wouldn't lump everything city related into that class. Using things like namespaces, refinements, etc can keep related functionality grouped together while still maintaining an OO-approach. Since this was just an example I think a more global/simpler definition wins out for simplicity. I.E. I don't think all objects should be flexible enough to be dropped into any application. Sometimes a simpler but less flexible object is a better choice for maintainability. All depends on the situation. I'm not against the command pattern. but I don't think it should be the method by which all behavior is implemented (as I have seen recent applications do). There are times in which actions take on object-like characteristics. For example the Transfer object mentioned at the start of the article may evolve to more than just a functional transformation. It may take on various actions (execute, revert, approve) as well as additional data (when it happened, who authorized it, etc). At that point we are still talking about an action but we think of it more as a noun. I'm not sure I agree with your assertion that OOP is not noun focused. That seems to me to be the general idea compared to functional or procedural code. We have an object (i.e. a thing) which stores state and can be sent messages to carry out actions.
Hey Nick, a co-worker of mine did something [real similar to this] (https://github.com/dfurber/ar_doc_store), and [even presented it at RailsConf 2015](https://www.youtube.com/watch?v=7cYjoguB-n0)! I'd love to know your thoughts on it. We use it a lot at work for exactly the same purpose and it works really well. 
Thanks. Receiving an error. 'Connect' : SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed (OpenSSL::SSL::SSLError) Any thoughts on how to fix it?
also op, this isn't scraping: it's just parsing API data output. scraping usually refers to parsing and picking out data from primarily human-readable documents like web pages. 
Got it to work. Can you explain the code to me, so I can tweak it to pull different fields?
You either need to fix your local SSL cert store (preferred) or connect and not care: http://stackoverflow.com/questions/982329/turn-off-ssl-certificate-verification-in-ruby
Why does the wedding have an entry fee?
I found http://www.codesdope.com/ as the best source for learning Ruby, specially if you are a beginner. You will find all the topics explained step by step and will enjoy learning.
truly loved it !
Ba-Bom Tsh
OOP is message-focused, not noun-focused. http://c2.com/cgi/wiki?AlanKayOnMessaging
You are indeed missing something. You can only yield a single time per method, but you can pass blocks and/or lambdas to methods to use multiple. Also you can re-use the same block if you keep a proc in a variable and call your method like so: yielder(&amp;my_proc)
Also: https://github.com/ggordan/mapquest
Any idea why this is not writing to a CSV file? require 'csv' require 'json' # csv_string = CSV.generate do |csv| # JSON.parse(File.open("sonc.json").read).each do |hash| # csv &lt;&lt; hash.values # end # end #puts csv_string CSV.open("sonic.csv" , "w") do |csv| JSON.parse(File.open("sonc.json").read).each do |hash| csv &lt;&lt; hash.values end end
Shemales? 
I'm speaking. You should buy this guy's ticket and come!
[removed]
Thanks, Bo! I'll keep on eye on Plezi and Iodine. I haven't used websockets in production yet since I always had to support old browsers (our application still has to support IE8 to these days, can you believe?). That's basically the reason why I never digged in understanding how websockets fully work. I get the idea, have read the protocol a few times, some articles, but I don't actually have practical experience with it yet. I feel the need however. There are several parts of our application that would be greatly simplified if we could use server-initiated responses to handle some page updates in specific parts. But I'm still trying to convince my client to drop support for old browsers, so this may still take a while... I think that a env['rack.websocket'] spec like you proposed should be feasible and welcomed. If that hasn't been considered by the Rack core team maybe you should propose it there. I won't propose myself because currently I wouldn't be able to respond to any questions or security concerns or whatever due to lack of practical experience with websocket. Particularly I've been always concerned about the lack of proper support for chunked responses specifically, which has always been supported by HTTP but that sadly has been historically badly supported by common Ruby frameworks. After reading a lot about other Ruby frameworks then Rails maybe you are right and this is mostly an issue with Rails rather than with Rack or other Ruby web frameworks in general. I'm already considering moving out of Rails for a few other reasons too and in that case I'll know better what is the current status of streaming for non Rails Ruby web apps. For my particular use case of chunked responses, it seems Rack hijacking is a good enough solution. Usually when sending chunked responses your request thread is not mostly idle but active, which is a different case when compared to websockets connections. Usually there's some I/O happening, like reading files from disk and then streaming them, and in that case an evented server would help with scaling the app if that is required. But for my particular case, scaling is not really an actual concern. We don't handle that much users and those streamed responses only happen for a few edge cases which are not used that often. After starting this discussion I noticed that my problem is actually very easily handled with current Rack by using hijacking and I could use that API even with Rails and ignore ActionController::Live. That means, lack of proper streaming in Rails shouldn't be a big enough issue for leaving Rails. I have other more interesting reasons however for trying other web frameworks actually, which are out of the scope of this discussion. Also, at some point I intend to make use of websockets and when the time comes I'd prefer to not be using Rails anymore and, specially, I don't intend using ActionCable even if I decided to implement websockets in my Rails app. I didn't understand this statement: &gt; Current Websock solutions hijack the IO and move it to a Ruby based IO reactor, forcing us to pay a performance penalty, as now we have (at least) two reactors and (often) a Ruby bound parser and formatter for Websocket data. I guess you are assuming only evented I/O based web servers can be considered for web apps. Otherwise, why would two reactors be required? If one is using an hybrid approach with Puma for example, by handling it request with a thread and then, eventually, while implementing websockets some framework hijacking the IO could handle it using a reactor loop and in that case we would only have one reactor, right? I mean, if your regular requests are fast then maybe the one thread per request may handle your load good enough and then you could use a reactor just for websockets if your application has to handle that many concurrent idle connections. A reactor also introduces some overhead, so in some cases handling regular requests with one the traditional one thread per request approach might be preferred. Did I miss something? Thanks for your insightful comment. I still have a lot to digest from all those comments and it seems like it's time I learned websockets :)
Awesome! I'll pass your comments on. David (the author) was inspired by Mongoid when he was writing it. We use it frequently at work. Our projects are mainly form based, and the data models often change really fast. The project it was written for ended up having over a thousand fields. It's really useful for that kind of thing because it minimizes database migration churn, so if you're working in a feature branch you don't have to worry that your database is out of sync with everyone else's. I wouldn't say I've run into any problems, and I would say it's painless to use now that it's stable. The big issue people have with the JSON column is querying it. While I haven't super pushed it regarding that, I have contributed to this gem and did a little performance testing while I was working on it. I wasn't able to find any appreciable difference between the JSON column and regular db columns as far as query speed when searching ~100k records, so there's that. Also I don't think anyone has tested what happens if someone uses the Rails 5 Attributes API with it at the same time as the syntax is almost identical. As a historical note, the first few iterations were tough because David was simultaneously working out the finer points of the gem and teaching us how to use it, all in the context of a project. But it's really painless to use now - add a JSON column and `include ArDocStore::Model` in your model and `attribute` your heart out. I'd highly recommend trying it out. Edit: reworded the problems paragraph
That's cool, thanks for the pointer!
Pretty quiet in here, that's pretty weird
Well done phusion. With everyone hacking on it, maybe we can whip ActionCable into shape. Also, the bug double write bug was one I think hit my from my old gem-version of ActionCable. Was sending lots of small-medium sized messages and at various points, the client would randomly disconnect and lose a whole bunch of updates. I switched it to sending a single very large message, and it became much more consistent. Time to upgrade to rails 5 it seems.
I'm glad to see that ActionCable is getting some performance testing. I haven't had the time myself to see what kind of performance could be expected of ActionCable. I highly doubt that ActionCable would be able to come close to scaling to [Phoenix's two million socket connections on a server](http://www.phoenixframework.org/blog/the-road-to-2-million-websocket-connections). Then again, not all apps need two million socket connections. Considering that ActionCable was released with a memory leak, my guess is that not a lot of heavy load testing has been done so far. Good work Phusion team.
Even apps that need two million socket connections still wouldn't need it on one server, right?
&gt; but long lived connection servers (Websockets and HTTP/2) will require a reactor pattern. &gt; As to web servers with a 1client-1thread model (not the hybrid model), well... it is, quite frankly, a terrible idea. While I do agree that a reactor is basically a requirement if you are handling several concurrent clients with websockets handled by your own Ruby application server, I'm not convinced this is a requirement for regular HTTP 2. Usually when using the single request per thread model one would handle HTTP 2 (and slow clients too) on nginx while the Ruby server and application would be running behind a proxy. That way, any reactor would be implemented in nginx, not in the Ruby application side. That's why I think it makes sense to separate things like websockets from regular requests and adopt some sort of hybrid approach. I haven't performed any benchmarks though. It's possible that I'm just wrong in thinking that an evented I/O approach might be slower than the traditional request per thread model for fast regular requests. Maybe it could perform just as good enough or even better. In that case I agree that it would make sense to simply use the reactor pattern for everything. I agree on your DoS concern, which would affect even my chunked responses (I currently deploy on Puma with a pool of threads). However, all users performed those are authenticated ones and we could take some action if some of them delibered decided to attack us with a DoS. But even without DoS, some of them are already slow enough and also the request could take a lot of time to read all pages from disk and stream them which means that if many users decided to use that feature at the same time, currently they would take our servers down for a while eventually. We never experienced this issue but I've thought about it already before implementing this action and decided that if that ever happen we'll use a separate worker just for dealing with such chunked slow responses. That way, regular requests should keep working and only those chunked responses would be affected if we can't add enough threads to handle all of our clients. Given we don't have that many clients, I'm not currently worried about this, but I agree that this is indeed an issue for several applications and that a reactor would be more suited to that scenario. &gt;&gt; For my particular use case of chunked responses, it seems Rack hijacking is a good enough solution. &gt; This is only true if you avoid servers with HTTP/2 support. I understand, but since HTTP/2 is handled by nginx I don't feel the need currently to use an HTTP/2 enabled Ruby web server. What you said about hijacked IO makes sense though. Maybe Rack specs should specify that HTTP/2 enabled IO shouldn't be made available through hijack_io. In that case maybe another env key would be more suitable. Those are different use cases and should be handled differently in my opinion. You make a great point about support for kqueue and epoll directly on Ruby without having to rely on C or Java extensions. It would be even better if Ruby could provide some standard interface that could be used transparently no matter we're using from MRI on Linux, Windows or from JRuby. I don't know enough about kqueue and epoll (or even select) to have an opinion on whether this should be possible or not to offer such an API, but it would be probably a good feature to have. As usual, great insights in your comment, thanks :)
note that none of devise/sorcery/authlogic or paperclip/carrierwave are bundled with Rails, and you can easily use alternatives even with Rails. 
Thank you for the discussion. This discussion and your approach definitely motivated me to open an issue on the Rack repo [requesting an update to the Rack Specification](https://github.com/rack/rack/issues/1093) to include an optional `env['rack.websocket?']` and `env['rack.websocket']` API interface. As for the nginx hybrid approach, I believe it to be a sensible solution, although it leaves some things unresolved. Avoiding HTTP/2 on the Ruby server is probably a must for now and having an HTTP/2 &lt;=&gt; Http/1.1 bridge using nginx is a great solution. &gt; While I do agree that a reactor is basically a requirement if you are handling several concurrent clients with websockets handled by your own Ruby application server, I'm not convinced this is a requirement for regular HTTP 2. I thought I might clarify why I believe that implementing HTTP/2 requires the same networking approach as the one used for Websocket connection handling. For this I would point out that HTTP/2 connections are meant to stay live until all the website references in the browser were closed. HTTP/2 connections are shared among all the tabs and windows of a single browser (imagine that) and the practice is to have a single connection for all the requests made from the browser to the web server (across different browser tabs or windows, not just in relation to a single page). This means HTTP/2 connection failure affects all open tabs and windows to the website and this also means that HTTP/2 connections are expected to experience long periods of inactivity between client requests. This seems to me, as far as implementation is concerned, very similar to websocket connections - although websocket connections are usually (but not always) a connection per page rather then a connection per browser.
'Cause _that's_ why my ruby apps aren't so exciting anymore :)
no idea why the downvote brigade in this thread, but this was a better explanation of what I also tried to explain (and was downvoted). I'll just assume its bots or something, because it's not like you're wrong or unhelpful. screw karma
&gt; I'm beginning to wonder if I should make up a reason to my wife that I'm obsessed? Can it just be a hobby? It absolutely can be a hobby. And maybe someday you'll decide you'd like for it to be more than a hobby. Or maybe you won't; both of these things are perfectly fine. I was a hobbyist for a few years before transitioning into being a full-time developer a few years ago (before this, I taught writing and poetry). Initially, it was because it was fun and challenging (and so satisfying once it gets working!). Now it's because it's a nice way to make a living. I get to work on fairly interesting problems with some pretty interesting coworkers. You get to do things because they're fun or satisfying or interesting. And if you want to, you get to drop it completely for whatever reason. Or if you decide you want to make it your favorite thing to do, for whatever reason and to whatever degree you want, that's also great.
I would suggest looking into Twillio to send texts. Once you have that working then implementing this form of authentication would be quite easy. I don't trust this package due to its FE-Consumer exposed code, but to implement it, you would download the JavaScript file to app/assets/javascripts, ensure it is included by a manifest in sprockets (like //=require digits-sdk.js in application.js) and then add the additional code to hook it up following their instructions. But like I said, Twillio would probably be more secure as its is server-side code and implementation is not publically visible and/or exploitable.
sadness**2 Ruby doesn't have -- or ++, but thanks for playing. :P
I had a couple of clients in Dublin a few years back but the Rails contract market in the British Isles has always been focused in London.
Uh-oh, another one bit by the programming bug. :)
Err..all self-starter programmers do what you do. So, no problem there :D No, there's no plan to this. Never.
Welcome. You caught the bug late, but at least you caught it, right?
Anything involving multi threading is heavily flawed in (MRI) ruby, due to the GIL. 
I was a music major, graduated in 2000. Ruby became my hobby in 2007, now I'm a lead Rails developer. I'd guess that's probably not a rare story either.
Coding is not professional football, you can pick it up later in life. You may find it enjoyable and enriching to go through josh cheek's ruby-kickstart exercises (find them on github). They'll take you through learning the language while solving popular and fun programming puzzles which will seamlessly make you a better programmer. Oh, and as with any obsession, please use in moderation. Your family needs attention, too, as you already know. 
Anyone found the weird cypher page yet? https://www.keeprubyweird.com/test.html You get to it by clicking Jean-Luc Picard on the home page. I think I almost found the decoder in the Google cache for a github repo that has been removed. I tried to crack it yesterday but couldn't.
You should do your own homework.
You might like [Why's (Poignant) Guide to Ruby](http://poignant.guide/), it's an artifact of the earlier years of ruby when everyone was just a hobbyist. Guaranteed it's like nothing else you'll come across in programming literature.
Nice try, OP's wife.
Well it's been around for a while and updated in the last four months, so it should be "complete". It's also properly pinned at a certain version of WiringPi, so being out of sync isn't an issue. It's certainly not well documented though, so it's entirely plausible the issue here is one of not knowing how to use it. 
Not in the way you're thinking. It'll look like you're sending the argument "+" to the "+" method. You could monkey patch it to work, but this inherently goes against how Ruby conceptualizes things. Fixnums are immutable. ++ Methods are inherently mutations on whatever is calling them. So you'd have to do something like x = x++ which at that point it's more readable to just write x += 1
&gt; You could monkey patch it to work How? `+` isn't a valid identifier AFAIK.
Could you monkeypatch fixnums to become mutable for this?
I'm sure you can. You probably shouldn't. It really goes against how ruby wants you to think about objects.
 ruby += 1 unless wife
This. Me right now! 
[removed]
I would say that this should not be done in ruby. To meet the letter of this assignment you would have to work against basic Ruby idioms. Meeting the requirements of this assignment requires writing stupid/bad Ruby code. Pseudocode for you: [Break string into individual characters](http://ruby-doc.org/core-2.3.1/String.html#method-i-each_char) [Get Ascii value of each character](http://ruby-doc.org/core-2.3.1/String.html#method-i-ord) Use math to get integer value (x - 48) then go back and handle all your exceptions Normally one would just call #to_i on a string to get the numeric values, but the assignment forbids this, hence why you should not do it in ruby.
Just share with her [this quote from the creator of Ruby](http://qr.ae/1MZxOO): &gt; I hope to see Ruby help every programmer in the world to be productive, and to enjoy programming, and to be happy. That is the primary purpose of Ruby language. You may not think of yourself as a programmer, but if you are programming and making something work and enjoying it, you are a programmer. :)
I consider programming my superpower. Here's a list of some things I've done with Ruby since i got similarly obsessed a few years ago. - figure out which train to work will have the fewest people on it - send myself an email with a map and pictures whenever a good apartment comes through craigslist - display a list of my upcoming TV shows - plot a graph of how much money I've spent each month - play through chess games - get reservations at popular restaurants - look up information about a book by isbn - grab a list of Japanese words from a given website - show a page with 100 random pictures from panoramio.com grouped by country - other stuff I won't list publicly You absolutely don't need to become a career programmer to find programming super useful! Glad you found it! 
You have caught the bug that every good coder catches. Welcome to coding fever :) May your world be forever changed for the better. 
&gt;Anyone else get obsessed like this??? Thanks! Yes. I am obsessed like this. At young age, I was very into computing. Started with a ZX81, had a Spectrum, C128, an Amiga a bunch of consoles. I was so into it, Iwanted to get a CS degree. That was until the age of 19 or so. Then my life suddenly changed. I was more into reading, fine arts, etc. I studied Philosophy but unfortunately did not finish. University was not my universe. After that, I became a professional bookseller in a famous local book store. After 3 years, I was layed off. From that on, I was mostly unemployed for about 7 years. Had some small jobs here and there, but it was hard. There were several financial crisis, recession and no chance getting a job with this qualification as a bookseller. Booksellers weren't needed. Ordinary shops told my I was over qualified. I worked as industrial cleaner, in a call center, in a warehouse. All the time, whenever I had a dime, I spent it on computer books. Read about C, C++, algorithms etc. My wife laughed at me; couldn't understand how anybody reads programming books in bed - others read novels or magazines. We had not much money at the time. After 7 years by pure chance, I was offered an apprenticeship in a medium sized local computer company. At first I didn't like the idea working for a Microsoft shop. But hey - should I say no after 7 years of unemployment? I got the job. I got more obsessed than ever before: watched conference talks on youtube, read blogs, read books, listened to podcasts etc. Now: My day job is being a programmer. We are better off than ever in our life. We bought a house, have a decent car. And my wife never laughed about my obsession again. 
You're defining a function **reverse**, but the way you're defining the method signature is wrong. Are you sure you want **"string"** there?
Don't capitalize "Def." Also what the other comment said. I think it should be def reverse(string) ETA: Also, when the loop starts, "a" is 3 (string.length == 3), but a[3] is undefined because the index starts at 0. "abc" is: string[0] == "a" string[1] == "b" string[2] == "c" So you should move the "a -= 1" line up before the print statement, otherwise the first character (string[0]) never gets printed.
Are you not supposed to define a methods argument with a string? I originally had it as Def reverse(string) - but they both return the same error regardless :( I guess I don't understand what "unexpected keyword_end, expecting end-of-input" means The method needs to have an end and the while loop needs to have an end - don't they? 
&gt; Don't capitalize "Def." Yup, im dumb - thanks. I think I understand the error message now, it was receiving an end keyword when it didn't recognize any definition for it to end. &gt;ETA: Also, when the loop starts, "a" is 3 (string.length == 3), but a[3] is undefined because the index starts at 0. "abc" is: That makes sense, very appreciated. 
Thanks again for the explanation. I fixed it and it does exactly what I want it to do. if you don't have time to answer the below, no worries - you were a great help! def reverse(input) a = input.length while a &gt; 0 a -= 1 print input[a] end end reverse("12345") == "54321" Is there some kind of functional difference between what I wrote and: def reverse(string) reversed_string = "" i = 0 while i &lt; string.length reversed_string = string[i] + reversed_string i += 1 end return reversed_string end reverse("abc") My code seems to work but returns false for all 3 cases the below whereas the above returns true puts("\nTests for #reverse") puts("===============================================") puts( 'reverse("abc") == "cba": ' + (reverse("abc") == "cba").to_s ) puts( 'reverse("a") == "a": ' + (reverse("a") == "a").to_s ) puts( 'reverse("") == "": ' + (reverse("") == "").to_s ) puts("===============================================") 
I'm not sure what you're using to write your code, but it helps a lot to use an editor with syntax highlighting. Sublime, Atom, and Brackets are popular cross-platform text editors, but there's probably a million of them. If you type, "def reverse(string)" it'll be colorful, and when you hit return it will indent the next line. If you type "Def reverse(string)" the entire line will be white and the next line won't indent. Syntax highlighting can sometimes be helpful to catch typos, or forgetting an "end" or something like that. If the editor isn't indenting to where you'd expect or all the text is a single color, you know something is wrong.
&gt; What I don't understand is why this function is very limited. Did you ever hear how "more is less"? &gt; Is there no way to call multiple blocks to the same method? You could with the explicit way or using `lambda`. But it will look much more ugly and confusing than with a single block. Just look at how elegant iterations look in Ruby. There is no logic needed for advancing a pointer etc. You just provide the block that handles each element. &gt; And is there no way for multiple methods to call the same block? Since the block we are talking about is anonymous there is no way for multiple methods referring to them. You need to give it a name, then you can do it: ruby &lt;&lt;CODE b = lambda {|x| printf "&lt;%p&gt;\n", x} (1..5).each &amp;b %w{foo bar baz}.each &amp;b CODE &lt;1&gt; &lt;2&gt; &lt;3&gt; &lt;4&gt; &lt;5&gt; &lt;"foo"&gt; &lt;"bar"&gt; &lt;"baz"&gt; &gt; Without those, it seems like the whole purpose of the function is to save a little bit of space in the rare cases where you repeat code within one method. Or am I missing something? The purpose is to provide an anonymous function which can be used as callback. This allows various things to do among them * repeated invocation with each element from a collection (iteration, graph traversal) * transactional behavior using `begin`...`ensure` under the hood * providing customized functionality elegantly which then is stored in a variable * you can even pass them on as I have done in the example above Basically you define a function without having to go through the hoops of using def.
Hey no problem. I'm actually about to leave and am still learning Ruby myself... but real quick I tried your second block of code and it doesn't print anything. I think you need to print reverse("abc") Rather than just call it.
This. Transitioned from a career in neuroscience to software engineering. One of the most exciting, fun transitions of my life. 
&gt; For some reason I'm just obsessed even though I'm not a programmer. Well, that sure sounds like you ARE a programmer.
I get that maybe you're doing this for the sake of learning, but it would probably be best to just use String#reverse. 2.2.0 :001 &gt; "abc".reverse =&gt; "cba"
I just finished most of the integration of a portable Z80 emulator written in C into MRuby (mini Ruby), and then implemented the CP/M BDOS functions in Ruby to make them work on the native file system. Why? Because I want to do a retrocomputing project and wanted to simulate the hardware first before trying to wire it on breadboard. Doing a CP/M emulator on top of it was just a little bonus because it was easy, that wasn't even in my original plans. All for hobby purposes.
Well, you're learning, and you're enjoying it. This is a natural state for humans (though many have forgotten that); no further explanation is necessary... (disclosure: I work for a company whose corporate motto is "Love Learning") The Ruby language was explicitly designed to maximise programmer happiness. OK, you don't consider yourself a programmer; maybe you're just not a programmer... *yet*. Sounds like your wife may be miffed that you're spending more time with your computer and less time with her. Comes with the territory of being married, I'm afraid :-) Maintain balance. Maybe shift some of your study / programming to times when she's not around, such as on your commute to/from work, or when she's doing things with her friends. What the eye doesn't see, the heart doesn't feel... And yes, programming can be a hobby (and you are entitled to have a hobby, hopefully your wife knows that); and it's better than being out drinking all night... It can also be a lucrative career: if you earn extra money by writing software, and spend some of it on her, you might find she objects less :-)
6/10
Thank you ruby. Have you used the SketchUp ruby API?
So, the main difference is that your first method prints the reversed string and returns nil, while your second method returns the reversed string. Generally speaking, you want to write methods that just return back strings. Then, you have the option of doing more stuff with that string (including printing). If your function only prints and doesn't return anything, you're not able to continue doing useful things with the result.
Thanks! Yeah this is for the purpose of understanding Big O notation, so I might focus on user time.
&gt; I think there's a much richer ecosystem of great web frameworks out there today as opposed to ten years ago but I don't think Rails is going to be dying out any time soon. The fact of the matter is that Rails lets you create more business value per hour of coding than any other framework out there. It's staggering. That's a pretty silly thing to say unless you're as proficient in every other web framework out there as you are with rails and thus actually qualified to make such a statement. 
I like benchmark-ips gem instead. Compare two examples and use the fastest.
I recall this being discussed since rails 3. Glad it finally made it into the framework. Even though it should be the default. Every new project using nested fields should use this. Most probably already do anyway :)
I don't mind giving it a shot, but curious why you're asking me specifically.
Oh, idk. You seemed interested in the SketchUp API. 
 def test_the_truth assert liberals == false end *snigger snigger*
This is a subreddit for the Ruby programming language even though I enjoyed the actress in Orange is the New Black season 3. 
/r/orangeisthenewblack
This talk by Evan Phoenix at RubyKaigi 2015 addresses exactly the same concerns, and proposes a potentially *revolutionary* solution... https://www.youtube.com/watch?v=QaLvtNpoc5o
&gt; "This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the Contributor Covenant code of conduct." wat
You could look for an [`ffmpeg` wrapper](https://github.com/streamio/streamio-ffmpeg#taking-screenshots) or call the system to do something like this [ffmpeg article](https://trac.ffmpeg.org/wiki/Create%20a%20thumbnail%20image%20every%20X%20seconds%20of%20the%20video)
Super excited to go this year! 
just use command line and wrap it ruby script `ffmpeg`
Just to link to myself: https://www.quora.com/Why-do-so-many-startups-use-Ruby-on-Rails/answer/Pete-Forde
I'm running specs in JRuby and MRI but I did not encounter any bugs yet, thanks for the heads up.
The `develop` branch is the default for this project, and is generally unstable. The stubs you're seeing are from the most recent merge to this branch. These changes have not been officially released, and the comments in the merge commit indicate that these changes are for the 3.0 release. In the diff, you can see actual implementations: https://github.com/jwhitehorn/pi_piper/commit/bf17c88c8d27f87baf04868482b8082b6a8390ea The most recent release is `v2.0.0` - On the "branch" dropdown, select this release from the "tags" tab, and then view the `lib/pi_piper/bcm2835.rb` file, which is what `driver.rb` replaces.
This is classic browser sniffing advice.
If an ActiveRecord model doesn't contain any custom code I don't test it at all. Why do I need to test that belongs_to works, or that built-in validators work? There are tests for that in rails core. 
Because if someone removes that functionality unintentionally, it's broken however it's implemented.
Yes, if they meant to remove that functionality, no if they didn't. Without the test they'll likely not find out that they broke some functionality.
It happens, even with small teams. Someone can incorrectly resolve a merge conflict, accidentally delete a line while learning Vim or get a little feisty with "find and replace". Thinking of tests as "preventing screw ups" just as much as "preventing bugs" seems pretty safe with minimal downside.
Because behavior testing isn't about making sure code works, it's about making sure that the code exhibits the intended behavior -- something that cannot be known by the tests in rails core. Testing isn't primarily concerned with preventing future regressions. If a test can concisely (in English) describe what the code is _supposed_ to do, and then demonstrate in its implementation that it can be done with minimal fuss, you've demonstrated a level of usability in the object interface that signals a low lifetime maintenance cost. When I see good behavior tests, I can learn what the code does quickly, and be pointed in the right direction for future elaborations.
Why does it seem that Python has alot more connectivity to C than ruby does. Am I just ignorant.
I get that, but isn't there a certain amount of self-documenting allowed here? If I write "belongs_to" in a model, what have I really gained by asserting that I've written "belongs_to" in a test? Whenever possible I like my code to communicate what my code is supposed to do, and my tests to confirm that it does what I think it does. When I get granular to the point of testing for the existence of belongs_to I feel like, as the article says, I'm testing configuration. When I test that @author.country= indeed assigns @author.country I feel like I'm testing ActiveRecord internals, which is not my business. 
I have always been of the impression that Ruby and C are a match made in heaven, almost as magical as Ruby and Rust. What do you think? (From Nokogiri, picked at random) static VALUE child(VALUE self) { xmlNodePtr node, child; Data_Get_Struct(self, xmlNode, node); child = node-&gt;children; if(!child) return Qnil; return Nokogiri_wrap_xml_node(Qnil, child); } Maybe something that shows off more C-&gt;Ruby integration: https://github.com/sparklemotion/nokogiri/blob/master/ext/nokogiri/nokogiri.c That said if Python abandoned indent-oriented syntax and double underscore obsession `__main__` - I would probably give it another chance, but it's just painful to code in and feels very inhuman, IMO. I'd rather Rust/C than Python. Also, Ruby has a faster memory model than Python and has taken the lead in performance in the benchmark game (not that they are all that reliable) [source](http://benchmarksgame.alioth.debian.org/u64q/ruby.html)
&gt; I get that, but isn't there a certain amount of self-documenting allowed here? If I write "belongs_to" in a model, what have I really gained by asserting that I've written "belongs_to" in a test? That's a general testing concern. The article advocates for testing behavior over configuration, as a principle, and I agree with it. Associations aren't behavior, they are simply ruby interfaces to code intending to interact with a particular relationship in a SQL database. &gt; Whenever possible I like my code to communicate what my code is supposed to do, and my tests to confirm that it does what I think it does. That is my chief problem with ORMs in general. What my code is supposed to do is inevitably something simple like "allow comments to be published to a blog post." My test is supposed to be phrased in similar terms -- no implementation details! When the object that manages the persistence is *also* the object that is supposed to represent the "business object," I'm left with a terrible situation where I can either test those persistence details, or abandon the whole testing endeavor altogether -- essentially, I'm robbed of the ability to write a unit test that doesn't rely heavily on assumptions about the underlying implementation.
&gt;I'm left with a terrible situation where I can either test those persistence details, or abandon the whole testing endeavor altogether -- essentially, I'm robbed of the ability to write a unit test that doesn't rely heavily on assumptions about the underlying implementation. That's well put. Personally, like I said, I've just abandoned writing unit tests for almost everything in app/models (I'm also pretty particular about avoiding business logic in my models). My models don't represent behaviour, they represent database configuration, and I don't feel like I need to test them any more than I need to test database.yml. 
Check this out: * [Computer Science Programming Basics in Ruby](http://shop.oreilly.com/product/0636920028192.do) * [Grokking algorithms](https://www.manning.com/books/grokking-algorithms) is a very good book, but code is in Python, although there're some people who have written the respective code in Ruby, for instance, check out this repo: [https://github.com/egonSchiele/grokking_algorithms](https://github.com/egonSchiele/grokking_algorithms), which also has a JS version. On the other hand, as others have mentioned, learning C is a must if you want to get serious on Computer Science, and believe me, it is not a hard language to learn, it's actually a very simple language, and it's rrrrreally worth it, check [this course](http://c.learncodethehardway.org/book/) out.
You should be comfortable reading different programming languages even if you aren't proficient in them. Just being able to read a new language and have a feel for what's being done is a critical skill for any software developer. To your question, though, while there is a lot of material out there in Java &amp; Python is becoming a common teaching language, all of those languages, as well as Ruby, are Turing-Complete which means you can write the same programs in any of those languages. The syntax will obviously be different, and performance profiles will vary (greatly), but you can implement the same algorithms and programs in each of those languages. If you want to learn the concepts, it's better for you to reimplement them in a language you are comfortable with so you aren't fighting on multiple fronts at once. You can't just copy/paste, but I would say that's for the best. Having to reimplement the concepts from scratch will force you to really learn what's going on.
I was lucky enough to catch this talk IRL – it was fantastic.
Can you explain what you mean by this?
&gt; I'm left with a terrible situation where I can either test those persistence details, or abandon the whole testing endeavor altogether -- essentially, I'm robbed of the ability to write a unit test that doesn't rely heavily on assumptions about the underlying implementation. In these cases I tend to write a different type of test – for your example I would probably write an integration test.
From your OP and what you write here I get the feeling that CS is not for you, or that you're not really interested in learning CS. JavaScript != CS, and CS is also a much broader topic than programming. Also, that Harvard course is one of the more superficial and easy intro to CS courses you can find, at least from a reputable source. Data structures and algorithms you can learn from anywhere. Google. A book. You don't need a course, certainly not a CS one. You don't learn programming languages in CS courses, any programming language used is a tool to teach you CS.
I somewhat disagree. I think the author is entirely correct that one should stay clear of complex meta-test-magic-suites like shoulda, and with the given example, I'd say the author is somewhat correct. However, when you test describe Address do it "has a country" do address = Address.new country = Country.new address.country = country expect(address.country).to eq(country) end end You are, in 90% of the cases, testing that rails internals work as they should. A better example, IMHO is a scope: class Address scope :within_eu, -&gt; { where(country: Country::EU_COUNTRIES) } end describe Address do it "Germany is within the EU" do german_address = Address.create(country: "DE") assert_includes Address.within_eu, german_address end it "UK is not in the EU" do uk_address = Address.create(country: "UK") refute_includes Address.within_eu, uk_address end end Now, this is still simple. But very soon, this test will aqcuire lint in the form of unrelated behaviour. That is because this test is *not a unit test* but an integration test: we are not testing *the unit of the scope* but instead the behaviour of a large part of our rails stack, including the (external!) database-server and its setup. This test, for example, will start failing when I add relatively unrelated change, such as removing "DE" from the Country::EU_COUNTRIES. Now, that would be fixed with proper dependency-injection. But this test will also start failing when I change Address a little: class Address scope :within_eu, -&gt; { where(country: Country::EU_COUNTRIES) } validates_presence_of :postal_code end And again when that changes: class Address scope :within_eu, -&gt; { where(country: Country::EU_COUNTRIES) } belongs_to :postal_code validates_presence_of :postal_code end Now our tests not only *have* to deal with an `Address` they have to ensure that there is a valid `PostalCode` in the database and that it is successfully associated with the Address-under-test. Horror! These are tests where you've painted yourself so far into a corner that refactoring is all but impossible: in order to change the `GeoCoder` you now have to add lines to the `PostalCodeTest`, and to all the tests that require "a valid PostalCode to exist in the database". I've been through refactorings of a simple `has_many` relation with changing validations where I had to change 40+ completely unrelated testfiles, over a thousand lines of code had to be changed. And no, factory-girl or fixtures are not a solution for this, merely a way to suppress the symptoms. The *real* solution would be to have AR-scopes as an actual external, nicely injected class, but this is Rails, so it lives inside your unit. So the other solution is to test configuration and assume that: &gt; If AR is configured correct, I can be sure it will work as expected. Then you'll just need to test configuration. Either: describe Address do it "Filters countries within the EU" do ActiveRecord::Base.expects(:where).with(country: Country::EU_COUNTRIES) Address.within_eu end end Or describe Address do it "Filters countries within the EU" do assert_includes({ country: Country::EU_COUNTRIES }, Address.within_eu.where_values_hash) end end Both test implementation and not so much behaviour. But both treat AR as an external library that is expected to do it's job. And both test the scope as an actual unit. We are now testing that we've told AR correctly to apply some configuration. And we tell the reader that we expect Rails to filter the results correctly, because we trust that Rails will do this, given the specced configuration. So, no. I think in a lot of cases where we are dealing with Rails' many violations of the SRP, testing configuration is by far the preferred way. 
Dave Jones has 3 courses (full lectures) on youtube. It's free, so check it out and see if it's what you're looking for. Ruby I: https://www.youtube.com/playlist?list=PLSXDqiI4sC5NinJXEoYH6FYQ7vtIO8IPF Ruby II: https://www.youtube.com/playlist?list=PLSXDqiI4sC5O3fI2XzlXCfKiKx9ELnH4Q Rails 4.0: https://www.youtube.com/playlist?list=PLSXDqiI4sC5PsASjJy7dBncALnhjud2fx
Thats sort of the thing, Ruby has implemented data structures for you. Arrays, hashes, even strings, these are all part of the Ruby standard library. In C, you'd have to do all of that yourself. That's why C is a CS learner's language. CS !== Software Development, CS is a science where people study how computers work and do research to do new and/or better things with them. Software development is a trade where people solve real world problems by writing software. It's as different as a mechanical engineer designing furnaces and an HVAC technician.
I thought this was interesting because the same pathological cases are still an issue with 2.3. They are a bit faster in 2.3 than in 2.2: $ time ruby -e "puts RUBY_DESCRIPTION ; str = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaa' ; p str.match(/a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaaa/)" ruby 2.2.3p173 (2015-08-18 revision 51636) [x86_64-darwin14] #&lt;MatchData "aaaaaaaaaaaaaaaaaaaaaaaaaaaaa"&gt; real 0m6.928s user 0m6.837s sys 0m0.085s $ time ruby -e "puts RUBY_DESCRIPTION ; str = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaa' ; p str.match(/a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaaa/)" ruby 2.3.1p112 (2016-04-26 revision 54768) [x86_64-darwin14] #&lt;MatchData "aaaaaaaaaaaaaaaaaaaaaaaaaaaaa"&gt; real 0m4.111s user 0m4.033s sys 0m0.074s But processing time still explodes when n gets large, where "large" &gt; 30 or so. 
Yes. Agree. But for certain use cases - imagine an authentication token being validated from a central customer owner service. Has to be a sync call - but can't overload the system if it's already failing.
Im interested in going more in depth in comp sci in the future but not right now. I need a job soon and a lot of web dev jobs test cs fundamentals. It would just be nice to learn how to implement a few other data structures and algorithms in ruby or javascript. There's some interview technical questions that require things like trees. 
A google search for "data structures and algorithms" comes up with more resources than you can shake a stick at. First result looks pretty good: http://www.tutorialspoint.com/data_structures_algorithms/
Paging /u/jamesgolick
If this is an allusion to Node.js, my previous Ruby async I/O library Cool.io (formerly Rev) was based on libev and predates it.
&gt; not that they are all that reliable Do you mean that you've measured those programs, with those Ruby and Python implementations, and your measurements show something very different?
So, wait; are you claiming that Node.js was a ripoff of your idea? I was just attempting humor.
Nobody is working on that solution, and as far as I know nobody has successfully implemented it for any language.
Yep!
Please see the comments immediately above it: # On newer Rubies check out the "exception: false" option # It avoids raising an exception if the operation fails This is not the fault of nio4r: it's how the Ruby standard library works. Earlier versions of Ruby's *_nonblock APIs used exceptions, while newer versions (2.1+) support an "exception: false" option which returns symbols in the event that operations would have to block.
Microsoft Windows again is treated as a poor cousin, and in an ideal world, could be ignored - if not for the so many clients being tied to them.
Why did you transition from neuro to SE? Curious.
The good news is this is a server-oriented library, so if your concerns are about clients, they're largely irrelevant. The scalability limits only impact Windows Servers. That said, Java NIO scales well on Windows, so if you'd like to support Windows servers with nio4r, consider JRuby.
I should get paid every time somebody makes a big deal out of a minor word choice.
Do you think it is unachievable? 
Ruby doesn't do fucking anything. You use Ruby to get something done. It's pretty versatile, so go have at it.
Start by making a Sinatra or Rails based data back-end to whatever site you wish to make. This back-end can collect data, store data, perform computations or transformations of the data, and so on. It can also hold user profiles. Then deliver user customized data to your front-end. That will teach you Ruby and Web server basics. From there, you will soon see that Ruby scripts can do plenty of other things: make scripts for tasks on your local machine (e.g., Rake tasks to give you hashes for external resources), write helpful one-off tasks (e.g., rename and add a suffix to all .doc files in a set of directories); do data extraction-loading-transformation tasks (e.g., kiba scripts); and so on.
Since you're a web designer, you might be interested in the web-related ruby. I highly recommend reading [the ruby on rails tutorial](https://www.railstutorial.org/book) free online book which will get you started creating visually appealing (your job) dynamic websites that range from informational websites to services to social networks (like twitter, instagram, etc). Good luck.
&gt; So what is Ruby capable of doing? The most important aspect of coding: Ruby makes you happy.
Do you think it would be better to learn Ruby first then jump on ROR?
So you can get info from IMDB website to organize files on your computer?
This project has the potential to make Ruby's performance comparable to compiled languages, and will keep Ruby competitive and relevant in an evolving technology ecosystem. Not only that but the techniques used to do this are super interesting and this talk is a great watch. Only thing I'm worried about is the startup time of the JVM and other components mentioned here.
Yes
Ok so i'll stick with ruby then work my way to ROR. Thanks 
I hate that heroku charges $20 to use any SSL.
That is no longer the only option. [Here's](https://devcenter.heroku.com/articles/ssl-beta) a free (beta) SSL option for heroku. And you can use LetsEncrypt for that extra free-ness!
And the memory bloat -- I am assuming all of the specializations/duplication do not come for free.
Looking forward to checking it out! 
It is true that we trade-off some memory for performance. There are two ways to look at this: Part of the performance we gain with these optimisations is removing runtime memory allocations. For example we can run code such as `[1, 2, 3].sort[1]` without actually allocating the array. So we may allocate more memory for the program, but less memory for the data the program generates. I don't yet know if that's actually a win or not in practice. The other thing is that if you want to improve per-request time, how can you do that? You can't add more processor power, as processors aren't getting faster like they used to and you can't really buy a significantly faster processor. You also generally can't use more than one processor or core for a single request, as we don't yet know how to write parallel programs well enough to do that in most cases. So what is the only thing you can do? Add some more RAM. So let's use that to gain the higher performance.
What problems are you having running it? This is my co-worker's code and I've used it many times.
as a computer security type person manipulating metasploit from ruby is really useful.
Hey espero, I'm the author of the heap viz. Let's get it working! Why don't you file an issue [here](https://github.com/mattbaker/ruby-heap-viz/issues) and we'll figure it out together.
That is a good point
Possibly you should check method chaining expectations https://relishapp.com/rspec/rspec-mocks/v/3-5/docs/working-with-legacy-code/message-chains
nio4r, aka the only ruby selector that matters. Matz has been talking about creating abstractions for safe-concurrency and an event loop for ruby 3 that will not just break compatibility everywhere, and has mentioned "actors" more than once. Everytime he does it, I can only think of how similar celluloid-io is to those goals. @bascule I thought that libuv would be the future for nio4r for covering some limitations of using libev (windows support, non-network io selection support). Is it because the main driver for this library was java nio compatibility and the API is not portable, or is there something I'm missing beyond that? And is the ByteBuffer implementation the beginning of support for File objects in the NIO::Selector? 
I'd say (as someone using Ruby at work since 2004) that Ruby is pretty versatile and a good general purpose language. Things I do on a regular basis with Ruby: - web development (the most obvious feature, but not the only one) - all sorts of data processing &amp; ETL work (e.g. http://thibautbarrere.com/2015/11/09/video-processing-data-with-kiba-etl/) - dev-ops (chef &amp; other types of sysadmin work) - reporting (PDF generation etc) - I also use it as my go-to scripting language (scraping, glueing stuff together etc) - (...)
Procs are a language feature and are ubiquitous in Ruby, so thinking about them in terms of a "killer app" is walking down the wrong path. Procs are blocks in object form, meaning you can pass them around just like any other variable. Since you're at Chapter 10, certainly you've seen [the method `each`](https://pine.fm/LearnToProgram/chap_07.html). `each` is a method that takes a block. [Because procs can be converted to block arguments](http://ruby-doc.org/core-2.3.1/doc/syntax/calling_methods_rdoc.html#label-Proc+to+Block+Conversion), the easiest way to see how they are similar is by example. Let's take the first example he provides for `each` and rewrite the block as a proc, then use that for our `each` method. languages = ['English', 'German', 'Ruby'] # The my_block variable now refers to a block my_block = Proc.new do |lang| puts 'I love ' + lang + '!' puts 'Don\'t you?' end # Instead of providing an implicit block, we can provide an explicit block argument languages.each(&amp;my_block) puts 'And let\'s hear it for C++!' puts '...' If you run that, you will see the output is identical to that of the exercise. Does that help?
This is about as close as you can get... procs unleashed!
Not sure what your code does, but you could also implement the validate method as a regular method, no?
Not if you want the caller to define it's own validation semantics. I could do: custom_validator = Proc.new { |obj| /* some custom validation logic not anticipated by the author of Thing */ } thing = Thing.new(custom_validator) thing.validate 
If you want your Thing to be validated by logic that wasn't anticipated when you defined the Thing object then you could make the validate method accept a Thing, so you could do validate(thing)
I suppose, but being able to change the indivudual state transition operations on-demand makes the code a lot more reusable. It's like saying "what do you want to happen here?". The bulk of the code is like a machine and the procs/lambdas are tiny input programs that the machine can run. Sometimes it makes sense to do this. I guess you could call it metaprogramming.
&gt; Maybe my head isn't screwed on straight but that to me looks like somewhere where the best programming tool is the array. The best programming tool is the brain. The best data structure to represent a two-dimensional board is two-dimensional array. The best way to hot-swap behavior is with a proc.
To every example of how to do things with procs, you're replying with the same "couldn't I do that with X?" reply. You're missing the point. Any Turing-complete language boils down to moving bits of memory and comparing them. You can always implement any given piece of code in a hundred ways using many different language features. The goal is to use the most appropriate/elegant language feature to solve each problem. Procs are used in Ruby the way anonymous functions are used in Javascript and PHP - to provide a small bit of logic to some larger algorithm or structure, that can be run and *re-run* without needing to know what's inside it. You've already seen the validation example and it didn't stick. How about formatting? I built a grid widget in Rails that maps a set of database rows to a set of columns in an HTML table (super-simplified here). I provided default formatting for integers, strings, etc, but when you're displaying a table you often want to have custom formatting, since an integer that represents a count of items ("500 foos") should render differently than an integer representing cents ("$5.00") for the same integer from the database (500). There are many ways to solve this problem, but the most flexible was to allow the person configuring the grid to define a formatting proc for each column, that could be as complex as needed when converting the underlying data into the most useful string representation. This is one of the "killer apps" of procs - my Grid classes involve thousands of lines of code to pull database records, render HTML, process javascript events, etc. I don't want to have my grid know what kinds of data it will display, and I certainly don't want to have to build a full class with standard methods to format each type of data. Procs hit the sweet spot that lets me write 2-3 lines of code to build a re-usable formatter while I'm configuring each grid. It's concise, elegant, zero-dependency, and relatively performant.
"Why are anonymous functions as first class citizens valuable??" "Why are closures valuable??"
You just answered your own question, then about why procs are valuable. And a closure is an anonymous function that captures references to any free variables in the scope of where it was defined. var i=0; var f = function() { i = i + 1; console.log(i) } var doSomething = function(fn) { fn() } doSomething(f) doSomething(f) What's the output? 
Thank you!
Sure, but that would violate encapsulation, and validate() wouldn't have access to thing's internal state.
I remember when you had just finished this.
Why are you calling an onclick event a "killer app"?
I always recommend to dabble with Sinatra first to understand the basics of web applications for Ruby. Sinatra uses the same underlying Rack framework that Rails uses, but hides precious little from you. After that, you'll appreciate the magic of Rails. Or perhaps, like me, you might discover you didn't need Rails all that much to begin with, and stick with Sinatra, Roda, or another simple web framework. 
Ruby doesn't have great tools to make highly complex GUI desktop apps. There are some decent frameworks for simple GUI apps at best. Strange thing IMDb hay it took me 2.x decades of coding to realize that no language does everything well. I use Ruby for server side coding and workstation scripts. I use R for serious data processing. I would likely pickup Swift for mobile if I had that need. 
You want to test output of units, not side effects. A better strategy is to test the inner method, then test the outer method with the inner method stubbed. 
Yes, I don't have a good way to support a libuv-like API on JRuby. It's a sort of pick your battles problem: what do I care about more... Windows or JRuby? Funny thing is it isn't a dichotomy: Java NIO performs well on Windows, so I can either support JRuby everywhere and, by virtue of the JVM, have good Windows performance on JRuby, or optimize specifically for Windows at the cost of JRuby. I think optimizing for JRuby and suggesting it as the path to good Windows performance covers the most bases. Please keep in mind libuv is going out of its way specifically to support Windows: it implements a Windows-like API on *IX systems. Java chose to implement a *IX selector-like API on Windows. Either system can implement the other, libuv is just natively optimized for Windows.
File.open(...) do |fh| # Do something with the file... end \# The file handle is guaranteed to be closed if execution reaches here. 
Nominating /u/jrochkind
Thank you.
To answer the question of "How to test this?", one approach that's compatible with what you have so far would be to assert only on the output generated by `puts`. It is inadvisable however to put expectations on global IO objects like `STDOUT`so I would suggest passing in an IO object into your constructor and call `puts` on that. In test mode you can substitute `STDOUT` with an instance of `StringIO` which will collect up all the output. At the end of the test you can assert on its contents.
This trick may be acceptable when there really is an actual reason for two separate models, though the only use case I can immediately think of is when multiple models all have a lot of the same attributes, so they get extracted to a separate model of their own which gets associated to all of the main models, and the associated table gets reused for all of them. Otherwise, having an object's data scattered across multiple 1:1 tables just complicates working with the data, by making the DB queries more complex, e.g. lookup by any of the related attributes now requires a join.
 welcome_user playing = true deal_cards(2) while playing do display_total deal_cards(1) if player_query == 'hit' playing = false if card_total &gt; 21 end puts "House always wins." 
Both var1 and var2 are created as local variables when you assign a value to them. attr_accessor is for exposing instance variables outside of your class and you shouldn't really use the setters internally - just refer to them with their internal names @var1 and @var2. If you really want to call your setter method, you have to prefix it with self.var1 = ? - this is an example of Ruby telling you that you are doing something wrong. The concern is that if you had a custom setter, you could accidentally create a stack overflow or an infinite loop, so Ruby makes it inconvenient.
Yeah, this makes sense, but what about this then: https://gist.github.com/anonymous/5607283 I can't find the discussion associated with that gist, but apparently others have had the same confusion before me. Is Sandy giving us baloney?
I want to make one file that executes those methods. Im just confused at how I would put those together to play a game of blackjack. * welcome_user * initial_round ?
I accept your nomination. [No spam shall pass...](http://i.imgur.com/2Q5mqUP.png)
Hopefully he set a strong password. Would be very weird if a spammer took over his account.
[/u/schneems](/u/schneems)
but, but, development is just finding the right killer apps to copy and paste into unique and exciting extreme killer apps. =)
This is awesome! I love efforts like these. 
Why does this have to be a web service? Is the algorithm that take the profile data and gives you the recommended GC settings really so valuable that it needs to be hidden offsite?
Don't pay for any of the packages that include teaching you how to learn 'react' --- you can learn react for free here https://egghead.io/courses/react-fundamentals and i guarantee it's much better content.
bar = foo.change Try to avoid unnecessary mutations
You can open any class basically, so for example class Fixnum def to_roman ...... end end Sometime it is practical, but you should never override and methods of the standard classes.
It is in the return value, for example the below will return 15 class Fixnum def to_roman 15 end end
okay..this gets pretty confusing but what if i want to multiply the given number by 2 instead? something like 3.times_two =&gt; 6 15.times_two =&gt; 30 i will not know what number is given, so I need to catch that value and multiply is by 2
but this one uses the rails rest api backend
Ha no I promise it isn't. No one knows about this gem. 
That is the best I found, and I used when I made mine. I don't feel so bad now, but I found it kind of anemic in a few places. &amp;nbsp; Mine (acts_as_bloomfilter) needs active_record for my tests and I had to search quite a bit for the little bit that I needed a dummy app, but I am more of a ruby guy than a rails guy. &amp;nbsp; Also, getting bundler working is kind of a pain, when running rake, it does not recognize my bundler file This is more of an issue with how gems are made I think, but still. &amp;nbsp; Not that ruby is much different than most other environments, I seem to remember CPAN being like that and the rust / go stuff is kinda like this. &amp;nbsp; Still beats the hell out of ./configure ; make ; make install ;)
No, this misses the point entirely! def to_roman self end That's what OP wants. 'self' refers to the instance that the method is being called on, which in the example is the Fixnum 15.
The React part here is just a bonus and not the center of the package by itself, because you know, the book is mostly dealing with Ruby APIs and how to write them well... It doesn't teach you all React's fundamentals from scratch (even if no prior experience is required) but it shows an interesting use case. Nothing prevent the reader to follow a free course after these screencasts or at the same time to learn more about how React works. Edit: Ok, just saw the kind of subreddits you are frequenting and your interventions there. Finally, I'm not surprised by how you've React'ed here. But imho it's pretty toxic to judge the content of what someone produced without taking the time to get the intention of the author here and what is the real content of such an educational product.
I always did imagine that creating object oriented systems with functional language would result in more code. I see now that is not necessarily the case. I am particularly intrigued on how he created data structures. He effectively created a hash using a function that tests the value of received attribute. I can already imagine creating a "class" using an array containing an attributes function, plus functions that perform work on said attributes. It would feel a bit off, but the fact that it is doable is very interesting. Thanks for sharing this article. 
Is Ruby the most un-functional programming-y language among the popular languages today?
No way! One of its main influences was Emacs Lisp. It's fairly FP-friendly compared to other mainstream OO languages.
The latter. I love the idea of foo.change!, but I can never seem to remember to/make myself use it.
That award probably goes to C
&gt; I can already imagine creating a "class" using an array containing an attributes function, plus functions that perform work on said attributes. I think using an array/list/tuple to represent a bag of functions would be considered very "OOP-like", since you've essentially created a flattened class-type structure, but I see what you're getting at. A cool thing about this concept is that it makes some more complex Ruby OOP concepts really explicit and apparent, e.g. duck typing, mixin modules, and even inheritance and polymorphism (overriding functions, etc.).
[resque-scheduler](https://github.com/resque/resque-scheduler) or [Sidekiq scheduled jobs](https://github.com/mperham/sidekiq/wiki/Scheduled-Jobs) might be helpful for you.
Sure, but a FP zealot would use a purely functional language. While FP languages became very popular lately, I think most people would still assume you are talking about C, PHP, Java etc when using 'popular'. Another gem of functional programming in Ruby: [Ruby Conf 12 - Y Not- Adventures in Functional Programming by Jim Weirich](https://www.youtube.com/watch?v=FITJMJjASUs)
I've stumbled upon this same fiber technique for stream processing. I want to run code for each event in the stream that gets processed (e.g. a single unit of work), but the stream processor itself is basically an Enumerable that loops forever. Fibers act like a clutch petal in that case. Good stuff!
Typically the data for schedules is stored in an in-memory key value store like redis, and there is a process that checks redis every minute to see if there's a job scheduled at that time. There are a couple of gems that will abstract away this logic into some easy to use wrapper, but under the hood that's generally how it works. 
There is nothing built into the ruby standard library that will do what you need, which is basically "execute this thing in X hours from now". But there are a variety of tools you can use that will do that. In addition to ones others have mentioned, I haven't seen anyone mention [clockwork](https://github.com/tomykaira/clockwork) yet. 
Ooh, what's a refinement?
You're gonna have to use some browser automation if you're dead set on pulling the data from that site since its using ajax to load the locations. I'd grab a list of US cities and towns and loop through each one while using the mechanize gem to input each town name into the view, and grabbing the text you need using nokogiri (which is already a mechanize dependency.) 
&gt; Module injection in Ruby is cool. It allows you to favor composition over inheritance Module mix-ins are not composition, they are inheritance. They definitely aren't a case of composition. Composition is a reference to another object; that's not what's going on in module mix-ins. Additionally, what's going on this example is just a "static" method, it isn't actually private at all. Anyone can access it by `MyFirstModule::PrivateMethods.private_method`. But it doesn't get mixed into the class that's including the module; and those static methods don't have access to a `self` (or rather `self` is their containing Module itself, not a particular instance). If all you need is a static utility method, then I agree it's better to make it a static utility method (nothing really private about it though) rather than a module instance method that will be mixed in. 
Relative noob here. Can you elaborate on hitting the end points on Ajax and how to do it?
They're using an API on there end (that seems to support JSON or XML) to get the locations within a particular radius. For example: https://services.wendys.com/LocationServices/rest/nearbyLocations?lang=en&amp;cntry=US&amp;sourceCode=WENDYS.COM&amp;version=4.2.0&amp;ts=1468882351199&amp;address=&amp;lat=30.269745900000004&amp;long=-97.7413042&amp;radius=20&amp;count=10&amp;silent=true&amp;onGetCurrentPositionError=undefined&amp;info%5Btype%5D=bygeo&amp;info%5Btime%5D=1468882342426 Use HTTParty or something to loop through each city you care about and store the results :)
Does it have to be off the website? It might be easier to scrape it from somewhere else, like here: https://www.menuism.com/restaurant-locations/wendys-138167/us or maybe here: http://www.mystore411.com/store/list_state/86/California/Wendys-store-locations
I've gotten in long arguments on reddit before about whether mixins are multiple inheritance. I think mixins in ruby are multiple inheritance. They work exactly like inheritance, they are a superclass that adds method implementations to the base class, which are inherited just like any other superclass. During one of these arguments, I happened to be watching a video presentation from Sandi Metz, where she also called mixins inheritance. It is clear to me mixins are inheritance, and since with mixins a base class can declare multiple superclasses to inherit from, they are a form of multiple inheritance. Other people disagree. I don't really understand their arguments. But at any rate, mixins definitely aren't composition. Ruby calls them "mixins", so that's a fine thing to call them. The methods in your example aren't private methods at all, they are class/module-level methods, as opposed to instance methods There's nothing private about them at all. I agree with you that they are preferable to module instance methods that will be mixed in, because they do not get mixed in. But what makes them so is that they are static/module methods, not that there's anything private about them. They'd really work just as well if you put them in an entirely different named class/module, say `MyFirstModuleUtilities.utility_method`. Or really even if you defined them on `MyFirstModule` itself directly, as static module methods: module MyFirstModule def self.utility_method I agree it's convenient in expressing intent to put them in a separate module namespaced under `MyFirstModule`, I'd call it maybe `MyFirstModule::UtilityMethods` instead of `PrivateMethods`, myself. What's pertinent about them is that they are class/module-level methods -- so they don't get mixed in when the module is included (good), and they also don't have access to a `self` that's an individual instance of the class doing the mixing in (which can be inconvenient, but you can always pass in the instance as the first arg, I suppose, which is kind of how you simulate OO when you don't really have it). 
This just in: doing programming makes you a better developer! 
I thought I was the only one still using Sinatra.
Personally I love it. But only because pretty much all "micro" frameworks (eg: Silex, Flask, Express, Sinatra, etc) look the same, and I like that.
I use it for a lot of stuff. Not everything needs a full blown rails stack. Sinatra is clean, plays nicely with Unicorn/Nginx and is easy to maintain for smaller projects. 
This is where I am at. The issue I am having is that I cannot find the name of the form. I am trying to use the form id but it does not seem to be working. require 'mechanize' agent = Mechanize.new page = agent.get('https://www.wendys.com/en-us/Location') wendy_form = page.form('find_loc') #name of the form wendy_form.altZip = '10013' #altZip is the input form name page = agent.submit(wendy_form) page.search('p.store_address').each do |li| puts li.content end
Great now `Rails` is defined and all gems that check that module to load the railties will crash.
You're taking the long way around by submitting the form. Think about what that form is doing: 1. User enters information 2. User submits form 3. Form method makes API request for XML data 4. XML is parsed/interpreted by JS/jQuery/etc.. The first two steps are completely unnecessary and are sort of a bad habit to get into in terms of web-scraping. Calling an API directly typically means fewer requests to the server and a smaller 'footprint' for your scraper. Get a list of zipcodes, save them to a file, and then call them like so: @zipcodes = File.open('filename.txt').read @zipcodes.each_line do |zipcode| #plug zipcode into API request #use xpath/css selectors to get data end 
https://github.com/lsegal/yard/issues/430 (2011, unknown if that changed)
I've looked at Padrino and it rocks - it has a lot of nice things built in. However, I prefer not having anything so that I can plug in anything at will (e.g., dry-types, ROM, Rodauth, Dynamoid, etc.) without ever worrying that there are chosen tools I am going against (ActiveRecord, built-in auth, etc.). I'm also surprised Padrino hasn't gotten as much traction as I thought it would have - I feel the Ruby community is quite bipolar between gimme-everything (Rails) or gimme-nothing (Sinatra/Roda). That said, I was pleasantly surprised to recently see that Middleman has switching to using Padrino as its local dev server. Did I mention I love Middleman?
Padrino is pretty flexible. They offer their own admin/auth stuff but I never use it. Usually roll my own with omniauth. ☺
[Image](http://imgs.xkcd.com/comics/ineffective_sorts.png) [Mobile](https://m.xkcd.com/1185/) **Title:** Ineffective Sorts **Title-text:** StackSort connects to StackOverflow, searches for 'sort a list', and downloads and runs code snippets until the list is sorted\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/1185#Explanation) **Stats:** This comic has been referenced 43 times, representing 0.0362% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d5jnyex)
You're missing the point. Yes, you improve as a programmer by writing as much software as you can. But you can *also* improve by having a better understanding of techniques and paradigms. The article makes this quite clear. Learn from the purest OO implementation. Learn about image-based persistence and "live" coding/debugging. See how DSLs differ between Ruby and Smalltalk.
I wrote the post, ask me performance or industrial engineering questions. 
Call me a fanboy... But I bought it. :p
I'd be interested in a book review from someone who has a strong grasp of OOP design. I bought POODR on recommendation, and while it seemed like a good primer on the subject, I felt it was aimed more at beginners.
I do it this way: https://github.com/molybdenum-99/infoboxer/blob/master/lib/infoboxer.rb#L96
For the apps I build it's not normally so separate as padrino wants to make it. Their admin interface / controller is a completely different sub-application. It would make sense if you were making something like a blog where there's public and private facing stuff. In my use cases it's almost all behind auth, so using the normal app + the admin app is just overkill. It's easier to just add my own auth layer (especially because I'm just using omniauth) and use one app instead of having sub applications.
Ah it escaped my attention :( thank you for leting me know!
Huh? If you know better books about *good* OOD I am all ears.
I don't, that's why I am interested in a review of this new one.
The regexp match might yield some performance benefits if done multiple times inside a large loop for example. Is it find/replaceable?
What exactly do you mean by "find/replaceable"?
What's the best type of wood to use for low-traffic residential flooring?
The sad life of a library maintainer is that you can't use cool new features until they've been out several years...
Oak is synonymous with "hardwood". It's grows everywhere that you find people. It's very durable and stains well. I have oak flooring. You could also go for a local wood, for example pecan is plentiful in texas, maple is common in canada etc. I like the idea of going for local especially if it drives down the cost. You can even say "local grown &lt;wood&gt;" later when/if you sell as a talking point. Some people care about sustainability. The downside to real wood floor though is they're expensive to install and they don't last forever, expect around ~$10 per SQft. for a bargain Compared to a laminate that might be closer to $4~6 per SQft for a bargain. The cost of the material in a wood floor is only part of it, installation is significantly difficult. Having installed hardwood floor, you should probably pay someone to do it, your back will thank you. Sanding and staining will cost even more. You'll eventually need to re-finish your floors which involves sanding. After enough sanding you have to replace your floors. Not sure of the lifespan for each of those. 
Great, looking forward to using it in ten years.
Excellent, TIL! Our new house has fir flooring, which I believe is a local but soft wood, that needs refinishing so this is a topic relevant to my interests right now.
Your blog seems to have interesting stuff, but it's a bit of a pain to navigate without an easily accessible index of all the posts. Am I dumb or is there no index?
Nice post again! The multiple assignment conditional looks so useful. Why do you caution against using it?
Awesome - they've covered nearly everything I wished was better :) - especially the report on error. That's great.
I found the performance improvements interesting. Personally I really liked that you hid the details by default but then had them available. I think the expanding worked well but if you don't like that I think anything that gave the ability to go lookup the benchmark code would be excellent. I hate people talking about benchmarks without being able to review the code. I would find the array allocation changes with min very interesting personally.
We're starting to see Ruby 2.1 support dropped from the major libraries though so the cool stuff is arriving slowly. We're always a few years behind, but better late then never.
We are planning to wait awhile between refinishings. We have a Rustic Modern thing going on, so a slightly banged up floor will work well with our motif. I see fir and even pine as flooring in home restoration shows. It looks great I think. While they are "soft" woods they can get pretty dang hard over time. Technically soft and hardwood doesn't refer to the durability but rather their seed type.
Why can't you have two versions: 1. Super stable works everywhere version. 2. Stable works with newest ruby version.
Good to point out Katrina Owen is the co-author, and awesome in her own right :) https://twitter.com/kytrinyx
I just wrote something that had to be backwards compatible with 1.8.7. :-\
You can get this functionality with ary.reduce(:+)
This is something thats driving me absolutely nuts. Why on gods green earth does rails require you to drop down to driver level if you want to use prepared statements/parameterized queries when doing straight SQL. Its 2016. Even PHP straight up refuses to support non parameterized mysql anymore. I've seen more unsafe SQL since I moved from django to rails than I ever saw even in the bad old days of PHP. String interpolation should *never* be used with SQL! Put on the butchers gloves and use the low level db drivers. And if the db driver doesnt do parameterized queries, file an urgent security request to change DBs.
Nice. Regexp#named_captures is one I've been wondering why it's not there for years. 
Such an unprofessional and aimless language. This is a great nudge for me to finally stop using Ruby. 
really old pine (made from old growth trees, that don't really exist anymore, because we cut them all down, now so only exist as floors installed a long time ago) can be very hard and durable, if you're lucky enough to have it keep it as long as you can! 
Totally, "Long Leaf Pine" isn't easily found these days. The big difference you'll see when looking at the pine is that the grain (all the stripes) are smallish and close together where as new pine from home depot has really wide stripes that are far apart. This means the tree was cut down at a much younger age. As a result it's not as strong.
That won't work. If you want to find the form by the id you need to use the #form_with method, like this: form = page.form_with(id: 'find_loc') Also you won't be able to set a value for the altZip field because the input doesn't have a name attribute. As others have suggested it might be better to automate using something that supports javascript (e.g. PhantomJS), or debug the ajax interaction and imitate those HTTP calls to the server directly.
I'd like too add skinny_controllers as a thin layer on top of rails for additional architecture
My understanding is that the grains closer together actually mean the tree grew _slower_, which makes sense as we know trees add one line each year. And also makes sense that a slower growing tree would have denser, harder, stronger wood. I can't explain why new growth pines would grow faster than the old growth hundreds of years old ones we don't have anymore though. 
Kind of ironic. Article says: &gt; Be aware! Don’t be Gems obsessed! and has 51 links to github. "The Other Way" seems to be to swap out widely popular, tested, and deployed libraries in favor of replacements because.... it's really unclear to me why. This seems to be the most concise answer: &gt; It simplifies the entry barrier, but also narrows knowledge range. I don't agree with this. Hanami? Vue? Webpack? Docker? Trailblazer? This is just substituting one stack for another without a clear value proposition. Rails is a great framework because it's incredibly popular and helps you get things done. It has mountains of documentation in the form of videos, tutorials, blogs, SO posts, guides, and more. When you run into issues, odds are that someone else has too. You can hire people who know how to work within Rails. There is excellent support for deploying Rails apps. Legions of gems are built to work well with Rails. None of this is true of the alternative stack. Either way you end up with some kind of narrow knowledge range. So what is the upside of this other way?
By the definition of the word Model, you have the destination for your Business Logic. Model does not mean ActiveRecord, correct - it means Business Logic - and a database is not a "persistence layer" but a core part of the computational power of your application. /lib does not auto reload so you have to restart your server on every change. Do not put things in this directory lightly unless you want to annoy everybody on your team, most likely what you are creating for /lib is a model, unless you are overriding a file from an external dependency (like a gem). You can disable global helpers by changing a config value - and you should, in which case they are identical to a presenter, but bound to a controller (rightfully) instead of the model. You will find that with a bit of work, you can create better code with Rails than with the mass of complexity introduced by the creation of so many disparate objects as is demonstrated in this article. In config/application.rb config.action_controller.include_all_helpers = false EDIT: with include_all_helpers off, explicitly declare dependencies using: module MyHelper include MyOtherHelper end Much better/composable than a presenter, IMO. SOURCE: "The model directly manages the data, logic and rules of the application." - [Wikipedia MVC](https://en.wikipedia.org/wiki/Model–view–controller)
&gt; config.action_controller.include_all_helpers = false TIL! Definitely will do that for future projects.
I think the biggest reason that people become frustrated with Rails is that when projects begin to grow and morph over time, patterns emerge that don't "fit" into Rails' definition of MVC. The developer concludes it must be Rails' fault that its architecture was wrong from the start. Rails does a lot out of the box, but it also leaves a lot up to the developer. We're all used to relying on popular gems like Devise, CanCan, will_paginate, and Paperclip to achieve specific functionality (authentication, authorization, pagination, and file attachments, respectively – I'm sure you have your own you rely on). But what about higher-level design? What if you need an OO abstraction that Rails does not provide? There's no clear guidance. Trailblazer, I think, is a step in the right direction. It acknowledges emergent patterns in a medium- to large-scale web app and locks you in to them early. For example, business logic is wrapped up in service objects ("operations" in Trailblazer parlance), and all query parameters are coerced into form objects that provide validation, encapsulation, and whitelisted parameters. These are all Good Things that we typically end implementing anyway. So while I like Trailblazer's ideas, I'm not sure most developers are ready to go whole-hog and use every one of its features. I refactored about a dozen controllers in my current app, and it went *okay*, but I didn't feel a huge gain in productivity or code structure. I guess what I'm getting at is: developers are striving for a shared language and knowledge about how to strengthen inherent weak points in Rails-like web apps. I don't think there's a clear consensus yet. **Edit:** [This book bundle](http://www.railsbookbundle.com/) just came across my inbox – what timing. *Growing Rails Applications in Practice* sounds intriguing...
&gt; CanCan Just curious? You still using CanCan instead of CanCanCan?
Actually I used declarative_auth before, but now find Pundit more enjoyable. Hence I didn't realize there was a CanCanCan.
I could do that. What are your thoughts regarding my cite? In MVC - business logic goes in the models. Controllers are part of the UI, managing flow, redirection - no business. Controllers are more closely related to the views than models (in fact, in my framework views are a module of controllers) - lots of people put code in controllers when SRP is clear that Controllers are purely responsible for managing and building HTTP responses. There is no such thing as a fat controller because of its fat, it's not a controller it's an abomination. Fat Models aren't models either, model a scenario, situation, representation or process, a SignUp and a Login - not a fat User (which could be little more than a value object) - it all goes back to the principles of normalization - lots of small tables, never big ones. ActiveRecord can be added to any of them at any time whenever you discover you have some data you want to save or log. Models are like scientific or financial models as much as they can be representations of objects. It all comes back to nouns and verbs, and to human language. Nouns are models - and when ever you use a noun to explain a process you are talking about a model, as a noun itself is a conduit for a mental model. To me, code is literature. To the author, it is a brick and mortar, as such I have never been victim of the problems presented. EDIT: added model explaination and formatting.
The article doesn't really explain the value proposition explicitly, but reading between the lines, it's about structuring a codebase to make it easier to extend and maintain. I mean, isn't that what everyone is aiming for? As counter point to picking Rails because it's popular, if we picked web frameworks based only on popularity, documentation, tooling, existing libraries, and hiring pool, realistically we'd all be using Java. The fact that we choose Ruby instead indicates that there are other factors. One of those factors is architecture/design, and how that affects the extensibility and maintainability of a codebase. In that respect, there is a place in Rubyland for unpopular frameworks to exist, if they have potential for creating better codebases in certain situations. 
The simplest way is: scope :email, -&gt;(email) {joins(:book).where("users.email ilike ?", "%#{email}%"} However, I'm a bit confused about your method naming/what you're trying to achieve here... With the above scope, you can call `User.email('tom')` and get a list of all users, who have books, and whose email contains the (case insensitive) string `"tom"`. That's not exactly what I'd expect a scope `:email` to be doing!...
Hey there. Opinion here to start - the old page is super and has always been crystal clear to me. So with that bias on the table, I'm worried the new mockup would cause more questions in a newbie's mind than the old one did, BECAUSE it exposes more of Passenger's internals. I've never had Passenger itself have a problem, so perhaps the new page would help in that scenario, but for a guy who has been doing Rails for almost a decade now, the goal of using Passenger is to ignore everything that happens before my app starts up. Turnkey hosting is the idea. This mockup pulls back the cover and reveals internal steps I frankly have no interest in, and buries the actual problem (99% of the time, I'd bet) on the right of the page. Do I really care that Passenger has to "Load OS Shell"? Is that ever the point of failure? TL;DR: Showing what Passenger is doing internally is only helpful if that's where the problem lies, and I assert it rarely is.
&gt; Do I really care that Passenger has to "Load OS Shell"? Is that ever the point of failure? Sometimes it happens yes. Some users have something like 'if ! tty -s; then exit; fi' in their bashrc. And then things break and they get utterly confused about what's going on and blame Passenger. I think it's safe to say that 90% of the problems are in the 'Executing app' part. 5% occur way before that, e.g. "cannot fork: out of memory", "file not found: some-important-OS-internal-tool-that-isn't-installed-for-some-reason". Another 5% are randomly scattered everywhere. Maybe what I can do is to simplify the design of the common case. If Passenger detects that the problem is in the app then it can hide a lot of details.
That would work. Alternately having a vertical layout with each layer represented, and expand only the one where the problem occurred? + Passenger Core + Subprocess - Application ... app log data here ...
In the interest of consistency, how about: https://imgur.com/a/b6epS Edit: Off to swim some laps. :-) I like the tree to show where the failure lies, and see why it would be helpful in cases where an odd issue cropped up. It would be great to keep the same data in the same place even if the Where's the Problem section changes content. Good luck, LOVE your product!
the tree has some nice information but I'm not sure it needs to be so prominent. Maybe only show that if something goes wrong in one of these kinda weird steps, like "load OS shell"? I would guess than 99% of the time the problem is with the rails app, and the tree would always look exactly the same.
I'm reading 99 bottles and it's excellent for oop + refactoring. 
missed what was said and no it's deleted. could you write it again?
oh hah! I bought the beta book full price already anyway :)
I've got a c extension that references rb_cFixnum and rb_cBignum because it injects a method into those classes (because $REASONS and performance) and that breaks in 2.4.0
You can do that? Sweet, that makes things a whole lot easier, thanks.
The expand/collapse benchmark source feature is so awesome! And the whole post in general, I didn't know there were so many interesting things in Ruby 2.4.
I'd highly recommend three books: [Programming Ruby](https://pragprog.com/book/ruby4/programming-ruby-1-9-2-0) by Dave Thomas This is the defacto printed reference for Ruby. [Metaprogramming Ruby 2](https://pragprog.com/book/ppmetr2/metaprogramming-ruby-2) by Paolo Perrotta Though the title might sound like this is a more advanced book, it's actually a good entry level introduction to the Ruby object model and standard patterns. [Practical Object-Oriented Design in Ruby](http://www.poodr.com) by Sandi Metz This is an *exellent* review of OOAD using Ruby. There's no better source for how to write *good* Ruby. It's a must.
I've found the documentation not very detailed, but sufficient for most cases. It is just on rubydoc.info, not on yardoc.org. For example, here is [@!method](http://www.rubydoc.info/gems/yard/file/docs/Tags.md#method)
Close, but actually it would quote the already parameterized value. Using sqlite3 as an example: &gt;&gt; db.execute('select 1 where "foo" like "%?%"', ["foo"]) SQLite3::RangeException: bind or column index out of range &gt;&gt; db.execute('select 1 where "foo" like ?', ["%foo%"]) =&gt; [[1]] 
I would say that Programming Ruby tends to be too swift at times. I personally prefer books where information is structured. For example, when the author is talking about control structures, he/she describes all the possible constructions (also not forgetting about best practices). And in Programming Ruby the author might occasionally shift from one construct to another which is OK for someone already familiar with Ruby but definitely less so for a novice Ruby user. 
So, like this ? words.each { |word| if word == redact print "REDACTED " else print word + " " end }
Thank you so much for the list I really appreciate it! I'll be sure to check these out!
what are SQL injections and how it targets millions of databases? see this, http://www.choozurmobile.com/2016/05/SQL-Injections-Most-Common-Database-Hacking-Method.html
Awesome, thanks!, that 'tags overview' section is what I was missing and needed. I don't think it's linked to in the README, maybe it should be, maybe I'll PR it. Although from those docs, I don't think I would ever have figured out the crazy cool example another commenter linked to, although I guess all the pieces are technically there... &gt; # @macro [attach] container.increment &gt; # @method $1() &gt; # Increment the $1 container.
not better but I think smalltalk patterns and refactoring by martin fowler are quite good
&gt; V547 Expression 's-&gt;sock_fd &lt; 0' is always false. Unsigned type value is never &lt; 0. socketmodule.c 655 It appears the static analyzer is not aware of compile time macros. In Python Fragment N1, for non-Windows OSes `SOCKET_T` is typedef'ed to an `int` (the defacto type for file/socket descriptors). Thus a `&lt; 0` error check is necessary, as the return value `-1` is used to denote that an error occurred. See the [socket(2)](http://linux.die.net/man/2/socket) man page.
Just read yours, nice writeup Mat!
I've come to the conclusion that the best way to learn a langauge is to learn one of its testing frameworks and build small programmes from that. But it's horses for courses. [RSpec](https://pragprog.com/book/achbd/the-rspec-book) [Cucumber](https://pragprog.com/book/hwcuc/the-cucumber-book) For a programming book, I would seriously recommend [Practical OO Design in Ruby](http://www.poodr.com/) And then of course, if you want a bible, [Programming Ruby](https://pragprog.com/book/ruby/programming-ruby) I copy/pasted my answer from another post about the same thing. There is some overlap with a previous suggestion for you. 
Let's not forget the ever-quirky [Poignant Guide](http://poignant.guide).
Is "Programming Ruby" aimed at those absolutely new to Ruby? Another question is whether it's a wise idea to learn Ruby first before jumping into Ruby on Rails. If yes, how competent should I be at Ruby to completely understand RoR? I don't want to just copy and paste code without knowing what exactly and why is going on. 
&gt; I really like [Hugo](https://gohugo.io/). Fixed the link for you. P. S. The only thing about Hugo that kinda unsettles me, is that I've never worked with Golang. Could it be a problem? 
I'm not 100% sure, but I would suspect this line: arguments-[-1] I'm guessing you want remove the last argument, and this probably won't do it for you. If that's what you wanna do, maybe take a look at [Array#pop](http://ruby-doc.org/core-2.2.0/Array.html#method-i-pop).
Seconded. I use it for almost everything, including prototyping web apps.
Oh sorry about the wrong url. Thanks for fixing. Not having worked with Go didn't slow me, but I really had no need to write any additional functionality for the two sites I subsequently built. It *was* a tremendous relief to simply download executables and not worry about installing gems - sometimes, in linux, a ruby development environment gets confusing and uncooperative (for me, at least). My strongest impression of Hugo was that - once over that initial few days of unfamiliarity - it simply felt easier. Pagination worked wonderfully, and you can more or less create any number of content types and sort them however you see fit. Taxonomies worked wonderfully and could be paginated easily (i seem to remember). Another thing I liked was the way the directory structure was laid out. If you take a look, it seems somewhat more sensible and tidier. I had been building Jekyll sites for university clients since about 2010ish? 2011? And I think it's now been a year since I used Jekyll. And then in October last year, I decided to mess with Hugo and I just kept feeling impressed, through the duration of the project. It *felt* easier. I'm sorry I can't be more specific why, but I'm taking a hiatus from webdevelopment this year. If you have any questions though, feel free to PM me. Best of luck. 
I don't know that book.
http://stackoverflow.com/questions/612189/why-are-exclamation-marks-used-in-ruby-methods
using an old version doesn't give me a lot of faith in the project going forward. Except maybe they'll realize they do need an out of the box asset compilation solution eventually. 
but that only explains what the ! is for in downcase!, not why this inconsistent behaviour occurs
The method _changes_input_ is correctly returning the modified output, but it's never being assigned to the variable x, so it's value remains unchanged. The method _downcase_, on the other hand, is using the destructive version of .downcase (denoted by the trailing '!'). This actually changes the object passed to it, (hence the 'destructive' part). In practice, you should indicate your new _downcase_ method is itself destructive by ending it with an exclamation point, or just using the non-destructive version of .downcase inside.
In the line input = input + 'ive changed the input' A new local variable named `input` is created within the `changes_input` function scope and all further operations take place on it rather than `x`. In your `downcase` method, the input variable itself has the `downcase!` method called on it, which mutates the variable `x`.
You should be able to get quite a bit of insight here: http://stackoverflow.com/questions/7688391/why-doesnt-this-work-if-in-ruby-everything-is-an-object
I also don't think you need to splat the args to add and subtract, as you're only passing one arg, which is an Array. 
&gt; Jekyll seems to be the most popular engine out there, but I don't quite like its pagination issues[2] (not being able to generate pages for tags, for instance). Generally Jekyll expects anything but the bare basics to be handled with plugins, some that may handle what you're looking for: https://github.com/pattex/jekyll-tagging https://github.com/midnightSuyama/jekyll-paginate-category
Okay I think I'm starting to get it.. But why then is a new variable named 'a' created, there already is one? edit: I think there is no new variable 'a' created, there were always two variables, one a in the function and one outside. Then by doing a = a.downcase you create a new object (with the value a.downcase), and you make the local a point to that object.
They intentionally removed it so you can use your own asset solution, for instance, if you want to use Ember.js or Angular instead of sprockets. I guess the tradeoff is configuring those types of projects with sprockets is too much work. If you google "middleman 4 sprockets" you get the [middleman-sprockets](https://github.com/middleman/middleman-sprockets) project which is basically the integration from the 3.x series. It's a line in the gemfile, bundle install, and activate :sprockets in your application file. They just don't want to shove the rails pipeline down your throat and make you disable it. Since it sounds like you don't know, middleman 4.0 was a huge rewrite to allow extension authors a lot more control and a better API so that gems that support middleman can be improved.
I'm new to ruby too, but from what I'm reading, adding a "!" In the return makes the parameter act like a pointer to the original value...ie passed by reference
It doesn't, actually. ! and ? are legal to use in method names, and are used as such by convention. They have no specific meaning to the interpreter. ! just means that the method it decorates modifies is place rather than copying, and ? indicates that the method it decorates is a Boolean query. They're just common practice though, not actual language operation.
&gt;Your changes_input functions instantiates a new object when you write "input + string" and then reassigns the variable to your new object Thanks for the explanation, I think that's the crux of the issue! I was having trouble because it's different from C#, if I do the equivalent of def changeArray(a) a = [1, 1, 1] end myArray = [5, 1, 6] changeArray(myArray) puts myArray in C#, then it'd display 1, 1, 1 because the default for the assignment operator is changing the object in place. Now in Ruby the assignment operater makes a new object and changes the reference of the variable to point to the new object. 
Just got home from a Pokemon Go trip, so, have an actual computer on which to do this `test.rb` contents: #!/usr/bin/env ruby test = "Hello" def demo_func param puts param.object_id test = "world" puts test.object_id end puts test.object_id demo_func test puts test.object_id `./test.rb` results: 70351187228040 # test = "Hello" 70351187228040 # param = test = "Hello" 70351187227600 # test (inside demo_func) = "world" 70351187228040 # test (outside demo_func) = "Hello" `demo_func` creates a new variable `test` inside the function scope, which does not have to point at the outer scope's `test` target even though there is a `test` variable in both scopes. When `demo_func` receives a parameter variable, `param` points at whatever the passed variable pointed to. Were I to manipulate `param` inside the function, it might alter the object pointed to by both outer `test` and inner `param`, or clone it, depending on the methods chosen. Assignation inside a scope does not modify the original variable, since there are two different variables that just have the same human name. How Ruby does this "idiomatically" is by having functions return new objects, and rebinding variables to those. So, to manipulate a string in this manner, you'd use this: def append_world param param + "world" end test_var = "hello " puts test_var.object_id # Yields some address puts test_var # Yields "hello " test_var = append_world test_var puts test_var.object_id # Yields some other address puts test_var # Yields "hello world" 
Technically the ! doesn't mean it always modifies an object in place, nor does a lack of ! imply it won't. The ! signifies a “dangerous” version of a method, and serves as a reminder to be careful when using it. It often means that the object will be modified, but it could mean something like “this version of the method silently fails instead of raising an exception”. 
I've only seen ! mean destructive, never unexceptional. Interesting. Thanks.
Actually, I think I was mistaken, and it's usually the other way around. The ActiveRecord `save` method returns false if it fails, but `save!` raises an exception, for example.
&gt;Finally, you're passing numbers as an array to add and subtract which is becoming a two-dimensional array because of your use of *numbers. Hope that points you down the correct path! This is the one that was generating the particular exception noted, I think. (That's what prompted my second comment.) All good comments, however, and I concur. 
I think the negative count is Ruby's hack to indicate that the method takes a block too, or that the last argument is a block.
Lots of good explanation, but I want to emphasize that you should strive to make your methods always *return the new value* and leave the input unchanged. This is a very common ruby idiom. Mutating the object you get as a parameter is reserved for special conditions where you might want extra performance. To Indicate that you're doing something dangerous and unexpected, you put ! in your method name. def ok(x) true end def ok!(x) x.make_ok! end
Assignment is not relevant - it only affects what the local variable points to. What is relevant is the objects themselves, not the variables. The first method create a new string using +, and downcase! modifies the string in place.
Great, thanks! I wrote a similar thingy for your terminal, see [tomate](https://github.com/tbuehlmann/tomate). :)
Very informative. Authorizing users to subscribe to a channel is a rather important topic. I'm experimenting with my own app using ActionCable, and I can already see that having a solid authentication system setup is usually a prerequisite for your channel subscriptions.
There is still a lot to experiment with, for sure. I'd like to, but am unsure of the performance implications, investigate with per message authorization for web sockets. I would think that for a data sensitive site, this would be a must.
If you don't like the idea of having a large, complex Rails app, an ounce of prevention is worth a pound of cure.
&gt; You don't even use idiomatic ruby indentation (2 spaces), If you look at the repo, you'll see that I do in fact use two spaces. The reason the code in the post is 4 space indented is because I found that it was otherwise difficult to follow. Maybe if I made spaces visible like they are in my editor, it would be easier, but this is a text-book case of "let's discuss syntax, because talking about semantics is hard". &gt; your DSL seems overcomplicated. Could you elaborate? It's a straight-forward translation from temporal logic, if there's a simpler way to express the same ideas, I'd like to hear about it.
No, just trying to learn more about oops concept.
I don't agree. Half of the messiness in large codebases comes from people adding stuff over time without cleaning things up. The other half comes from changing requirements and catching deadlines. In my experience, it's almost impossible to foresee how your codebase will evolve in the future. This makes prevention almost impossible. Although I do agree a different approach may make your codebase last longer, you will still hit a brick wall eventually. I think refactoring is a fact of life, and that people are deluding themselves by thinking that microservices or not using Rails somehow prevents your codebase from becoming complex or messy. There is no silver bullet.
No need to look forward, start using dry-validation already :) Example from the post translated to dry-v: SubmitArticleSchema = Dry::Validation.Form do required(:title).value(:str?, min_size?: 5) required(:content).filled(:str?) end Bench comparison for invalid input: Warming up -------------------------------------- ActiveModel::Validations 151.000 i/100ms dry-validation form schema 827.000 i/100ms Calculating ------------------------------------- ActiveModel::Validations 1.494k (± 5.3%) i/s - 7.550k in 5.068269s dry-validation form schema 8.180k (± 4.6%) i/s - 41.350k in 5.066266s Comparison: dry-validation form schema: 8180.0 i/s AM::Validations + Virtus: 1494.1 i/s - 5.47x slower Performance aside - notice that in AM::V, `length: { minimum: 5 }` will pass with anything that responds to `length` so ie `{ title: [1, 2, 3, 4, 5] }` will not cause a validation error. This lack of basic type checking is the reason why most of the Rails apps out there crash constantly due to malformed requests, not too mention potential security vulnerabilities. Params should be validated very strictly, there's no place for duck-typing at the HTTP boundary of our systems.
&gt; Half of the messiness in large codebases comes from people adding stuff over time without cleaning things up. The other half comes from changing requirements and catching deadlines. All of those considerations are certainly factors that determine what the growth of a technology stack looks like, but they can be improved. An organization can get better at understanding _how_ to arrive at requirements and set reasonable scheduling expectations. Programmers can stop neglecting the unsatisfying work of leaving the codebase better than they started. I don't think entropy is at all inevitable for teams that focus on improvement. But you are still mostly correct, in my view -- even for a good team, avoiding a large, complex app (Rails or not) is a very difficult thing to do. I did not intend to make it seem easy, just that prevention is far more valuable than cleanup efforts. Refactoring seldom enables anything more than small tactical improvements. I say that as someone who has refactored larger software systems.
Thank you so much. I really appreciate it.
From enumerable.find: &gt;Returns the first for which block is not false. Given that Ruby is strictly "pass by value", we'd then assume that what you see here is some spooky action at a distance that shouldn't make sense. However, according to [this StackOverflow answer](http://stackoverflow.com/questions/1872110/is-ruby-pass-by-reference-or-by-value)... &gt;Ruby doesn't have any concept of a pure, non-reference value, so you certainly can't pass one to a method. Variables are always references to objects. In order to get an object that won't change out from under you, you need to dup or clone the object you're passed, thus giving an object that nobody else has a reference to. This might explain how you appear to be grabbing a reference to laura within the people object. 
`find` is returning one of the four element arrays. `Array#[]=` is a mutating method, changing the array in-place. Since both `laura` and `people[1]` are references to the same object, you can see the effect from either name.
`laura` and `people` are two different variables, and they are also two different objects. However, `people[1]` and `laura` refer to the same Array object. The main thing here is arrays are mutable -- in other words, an Array object can be changed. So if you have an array of arrays, and you change one of those inner arrays, you can see the change from any variable that refers to that inner array. It can be a bit confusing to newcomers since other objects, like Fixnums, aren't mutable. But take this simpler case that shows the behavior: grades = [90, 80, 89] my_grades = grades grades[0] = 94 p my_grades # =&gt; [94, 80, 89] p grades # =&gt; [94, 80, 89] In the first line, a new array is created and then the variable `grades` is set to refer to that array. In the second line, the variable `my_grades` is set to refer to the very same array. When this array is changed, both variables show it, because they both point to the *same* array. In your example, `people[1]` and `laura` refer to the same array. There are of course some operations which don't mutate the Array but create a new one. Appending with `+=` is one such operation. Using the same variables as above... grades += [99] p grades # =&gt; [94, 80, 89, 99] p my_grades # =&gt; [94, 80, 89] This may seem confusing, but in time it will make sense. All variables in Ruby refer to objects. Some operations will leave the original objects alone and create new, separate objects (such as `+` on two arrays), while other operations will change the objects. When the object changes, all variables and other places that refer to that object will show the change. Another common mutable object type in Ruby is Hash. If you had an array of Hashes, making a variable to refer to one of those hashes and then using that variable to change it will result in both the variable and the outer array looking different. people = [{name: 'Bob', age: 20}, {name: 'Sally', age: 24}] sally = people.find{|p| p.name == "Sally"} # note, this is basically the same as writing `sally = people[1]` sally[:age] = 22 p people # =&gt; [{:name=&gt;"Bob", :age=&gt;20}, {:name=&gt;"Sally", :age=&gt;22}] p sally # =&gt; {:name=&gt;"Sally", :age=&gt;22}
Ruby Arrays are not Ruby's :) ...in order to improve some speed issues Ruby is delegating some features to C language. One of them is Arrays. Best way how to look at it is that when initialising new Array you only hold a reference to C array in Ruby (this happens in deep deep Ruby-C backend). Therefore: a = [1,2,3] b = a b &lt;&lt; 4 b == [1,2,3,4] a == [1,2,3,4] So you see both `a` and `b` are really the references to same C lang arrays. One way how to deal with this is to use `#dup` ( that will tell ruby not to use reference but rather clone to new array) c = a.dup c &lt;&lt; 8 c == [1,2,3,4,8] a == [1,2,3,4] b == [1,2,3,4]
You can password-protect your Redis instance: http://redis.io/topics/security Same with RabbitMQ and so on. You can implement an HTTP endpoint that will verify some sort of token and receive a message.
Thanks for the response. Sadly, the way this project works, we're going to have potentially hundreds of thousands of things doing a "push" to whatever this end-point service is, _and_ these origin processes are all dynamically provisioned, started, stopped and triggered. Each would be sending information that's totally unique and has to remain separate from all the other stuff, too. On the HTTP end point - I'm trying to avoid the need to do a full network round trip on HTTP/1.1 when pushing data out during this streaming phase. My hope is that there's some way to create a bi-directional stream of some kind, let the _client_ send out data whenever it wants, and maintain that TCP connection active somewhat indefinitely. If there's a good 5+ minutes between pushing data, it's fine to "resume" a "paused" TCP connection (if there is such a thing?) so it doesn't have to stay active at all times; but if I've got rapid-fire output happening, I'd like to have it stream back to the endpoint service as close to real time as possible. HTTP/2 was my first thought with this, but after doing a fair amount of review on what's out there in Ruby-land for HTTP/2, it doesn't look mature enough in terms of "battle tested-ness" and _definitely_ not in terms of documentation. And sadly I can't open a server on these origin locations because of constraints of the project, so I can't quite invert the client/server paradigm. I'll check out security options with redis, rabbitmq and/or zeromq though, see if I missed something. Thanks again!
Put four spaces in front of each line of code to format it as such.
Bang methods mutate an object in place.
I think what you're probably looking for is syslog. It's mature, reliable, and designed for high volumes of messages. 
Walk into the office like "What up? I got a big test suite."
It's not that relevant that the Arrays might be C under the hood in MRI, _any_ mutable object in ruby works this way, it's part of the ruby language (and any other object-oriented (or not) language with mutable data and references). 
Good explanation. It's also worth pointing out that if you want to know if two references are the same object or not, you have a few ways to do that in ruby: grades = [90, 80, 89] my_grades = grades # the `equal?` method tests if two references are the very # same object, it's called the 'object identity' or 'identity equality' # operation. `identity` means "the very same object". my_grades.equal?(grades) # =&gt; true, my_grades.object_id # =&gt; 70235609334320 grades.object_id # =&gt; 70235609334320 # the exact number will be different every time, but will # be the same for two references to the very same object other_grades = [90, 80, 89] # even though it's the same values, it's not the same object: other_grades.equal?(grades) # =&gt; false other_grades.object_id == grades.object_id # =&gt; false # but: other_grades == grades #=&gt; true # because Array implements `==` to be a value equality, # two arrays are `==` if they hold the same contents, even # if they are not the same object. But they aren't equal? 
Check out [spiped](http://www.tarsnap.com/spiped.html). It allows you to encrypt traffic between services on two machines, without those services having special support for encryption. Your services don't have to be accessible over the public internet this way, you don't need (unmaintainable) firewall rules. The encryption is symmetric, so all machines do need the same key. An alternative would be to use (auto)ssh to tunnel the traffic for you, or stunnel (which uses SSL for its encryption).
Way cool. Thanks!
Keep it up my boi. Let your curiosity carry you into ever deeper imaginations.
All really great answers! Thank you so much and I apologize for the terrible formatting.
It sounds like you are reinventing the wheel. If you have control of the code for both client and server just PKI encrypt the data (look at openssh). The other issues you bring up sound like the are infrastructure rather than code related.
Thank you so much for the awesome comment! This is really helpful! I haven't really had much of a chance to code with other people, so this is great, thank you! I'll start refactoring!
Thank you!
Thanks, I'll try and check it out!
I'm assuming you'd have an array of Medication objects. So you can write a function that sorts through these objects based on some criteria, and then formats text to output from the objects. Methods in the Enunerable and Array will be helpful.
If the frequency is daily, then the schedule is start_date + 1, start_date +2, etc until end_date.
You can try `ocra` gem. I've had luck with Ruby 2.0.0 x86 with it when I was writing some MS Services.
[Traveling Ruby](https://phusion.github.io/traveling-ruby/) is another option. Made by the Passenger guys who are pretty sharp.
yeah but you write about it as if it's the most natural thing in the world, but coming from C# it's quite confusing
@tiny_ninja Thanks you. what to do if the dosage should be taken before and after meal ?
@riddley It is interview question. 
I think you are missing the initial value for memo. I.e. pass an empty hash as the first argument of inject. In fact this is a perfect use-case for each_with_object instead of inject.
Any specific reason for converting the classes of values to their string representation?
I want to return schedule array which looks like this schedule = [[start_date+1, after-meal],[start_date+2, after-meal]........] I don't know if this is the right approach or not?
Note on Firefox you will have to manually install the certificate as it has a separate certificate store.
I use [json_expressions](https://github.com/chancancode/json_expressions) to match hashes and json alike. Sometimes I add a matcher like this: ``` matcher = JsonExpressions::Matcher.new(expected) matcher =~ actual ``` and display the error: ``` matcher.last_error ```
It's hard to critique something if you don't know what it's for.
Sorry. It's a program the stores car information like the make model, license, and owner. 
Ok, three things to start: first off, you need to tell people what the program is intended to do. Actually create a useable.README and upload it. That should be done for every project you do. Second - you need to learn what input validation is. ***Never*** take input from the user and save it directly to your database without some type of validation. Third - remove the functionality for creating the table. That's a step that should be done during initial setup of the program. After that setup, the program should assume that the table is there and throw an error if not. Those are probably the biggest things I saw so far, but you've got the basics down, and your code is fairly clean. Edit: fine became done.
tests :)
Not exactly, but you could do something like this: module Gender MALE = 1 FEMALE = 2 end And then reference it with `Gender::MALE` and `Gender::FEMALE`.
I found the Pickaxe book helpful.
Great explanation but I have a follow up question.... The most confusing part of this to me is knowing which methods do mutate the referenced object and which don't. You gave a few examples but is there some rule of thumb or do Ruby developers just develop this knowledge over time?
A couple of things to add: 1. I generally prefer using tools like `Timecop.travel` with a block, rather than `before` and `after` hooks - as it's easy to make mistakes like this. You can also enable [safe mode](https://github.com/travisjeffery/timecop#timecopsafe_mode) to **force** you to always use blocks. 2. If your test library is up to date, then you can [bisect](https://relishapp.com/rspec/rspec-core/docs/command-line/bisect) to find the cause of intermittent failures like this, caused by test ordering. (There is a [similar tool](https://github.com/seattlerb/minitest-bisect) in minitest too, for example).
Nope changes made in edit, thanks :)
each_with_object seems to be deprecated, I've stuck to .each for now http://apidock.com/rails/Enumerable/each_with_object
This looks a lot more interesting and extensible than my solution and what I will try to use from now on.
write some test, add readme, and try to read the ruby guidances because it's clear that the way how you write follows a different language habit. I would recommend you install the rubocop. It has build in fromatter ,and able to help you find what is wrong with the code aside from the functionality which will be covered with the tests. Or it's better to start of with a test and only after that start write code, and with each code chunk you write apply rubocop gem install rubocop https://github.com/bbatsov/rubocop
Nice to see other people organizing their rack apps into multiple smaller apps. We're doing exactly the same thing in [dry-web-roda](https://github.com/dry-rb/dry-web-roda) and the way individual parts of your system are separated has really nice benefits, like the fact you can load a whole component, with all its dependencies, in complete isolation from the rest of your system. This results in nice things like running a single test for a single component and the boot time is ~0.5-1s - *no need for spring, really!*. If you like Roda I encourage you to check out dry-web-roda (and [dry-component](https://github.com/dry-rb/dry-component) as it's based on it).
I use basic stuffs usualy is_expected.to include :expected =&gt; 'hash', :parts =&gt; 'for one test' and I write different test for validate the hash different levels expect(subject[:key]).to include :sub =&gt; 'hash', :content =&gt; 'here'
I usually go with: http://phusion.github.io/traveling-ruby/
Yep, logical separation between components makes a lot of sense for lots of different reasons :)
You can also just set a global after block with `Timecop.return`. e.g. `config.after { Timecop.return }` in an rspec configure block. 
I agree! `Timecop.return` doesn't seem too costly in terms of performance so calling `Timecop.return` after every test is definitely an option
which is exactly what the OP described and suggested. 
which the OP also investigated and pointed out. 
the answer is `nil` in every single case (since `# =&gt;` denotes return value in Ruby, not what's written to STDOUT...) :)
Nice catch! :-) But why the lookup rules change if the types are nested inside a module? Seems a bit inconsistent to me...
How one manages to say absolutely nothing other than ' believe me and give me your monet' in so many words is beyond me
&gt;I'm sorry, did my attempt to explain it offend you somehow? hah, no, sorry if I gave that impression. Your reply was certainly illuminating but it's just that these concepts took me longer to understand than I was planning to because I thought I already understood them.
How committed are you to the play on words (and imagery) of 'Rack' == women's breasts? Because its very off-putting for me and I can't help feeling this is just a hobby project by some kids. Also, a simple example on your front page would speak volumes more than the laundry list of generic features that don't help me distinguish it from Sinatra or anything else.
I imagine the videos for the rest of this course starts with him pulling a syllabus slowly from his briefcase.
As `Child3` inherits from `Parent3` it also has `Target3` visible at the same level of context. The lookup strategy prefers matches at the same level of context before ascending the tree. The search could be described as: children of myself, then children of my parent (aka siblings), then children of my parent's parent, etc, etc. If this isn't the desired behaviour you can be explicit and prefix the class with `::` which will force Ruby to begin the lookup at the highest context.
It's called: "marketing" :-)
Check them out at the top right, where is a "how-to" drop down link list, which contains examples! : ) The images was made by a friend of mine who is a girl, but if you say it's disturbing to you, it worth rethink the logo. :) Any idea what could be an awesome logo? Actually it's really a hobby project, this is why I would love some opinion on how it feel to use the framework by others. While it's a hobby project, it's production ready in the same time, and used for powering microservices. ^~^ So after you check out the examples if you have time, please tell me your opinion, I mean it! : )
It's not any more likely to make me use it, I honestly haven't evaluated it, yet. However, I do think some logo-reworking and rebranding would do a lot to present this a bit more professionally and would be a lot less likely to offend.
Nothing wrong with 2.1.5
it's been a long time since I've done ruby, but try: ``` while to_gmom = gets.chomp != "BYE" ... end ```
I done some modifications, but this is only a sketch for now. Is the direction good or you have some more in your mind? :)
Watir is awesome! Use it for test automation.
Just FYI, this subreddit is for the Ruby *programming language* :-) Maybe this would be better placed in [/r/boxing](https://www.reddit.com/r/boxing) or [/r/amateur_boxing](https://www.reddit.com/r/amateur_boxing) 
Thanks, I was very confused.
They are probably spamming whatever they can
to_gmom = '' while true to_gmom = gets.chomp if to_gmom=='BYE' break elsif to_gmom == to_gmom.upcase puts "NOT SINCE 1938" else puts "SPEAK UP SONNY" end end puts "HAVE A GOOD DAY NOW" 
Whats wrong with ssh tunnels and pubkey auth?
can someone explain the use case?
The package/OS-installed ruby is rarely recent enough to use. But I love ruby-install+chruby. 
The main argument here is that they are platforms where it is. Currently latest Ruby is 2.3.1. Latest Fedora 24 has 2.3.1. Older Fedora 23 still has 2.2.5 and Fedora 22 shipped with 2.2.4. There are many rolling distributions that also gets one of the latest versions. So for me it's more likely about having ruby-install to install *older* version.
I don't know what OP refers to, but if that's the article, then the purpose of writing it was *exactly* to point out people suggesting that packaged Ruby is not good for deployment.
I am *not* arguing against RVM (except for that I would not *personally* use it). I am only pointing out that the packaged Ruby version *might* be enough and that it brings some benefits to use it :).
Hey this guy is a Chutiya
Never not bundle the version of ruby your application needs with your application. That way you can always ensure you have the version of ruby you need, especially in large scale deployments. For a dev workstation, RVM is the way to be... though admittedly most of my Ruby work these days is Chef, so I just use the Ruby bundled with ChefDK.
Much better! One more thing: fix the indentation in the gists (run ruboop on it too?)
Even if it's "enough" you still need the ability to upgrade. What happens when there's a massive security vulnerability that is fixed in the next patch release? What happens when you have multiple projects and they run on drastically different versions? What happens when you become a library developer and need to test against many multiple versions of Ruby? Right now this is all the rubies I have installed on my local machine: ruby-2.0.0-p451 jruby-1.7.16 rbx-2.4.1 ruby-1.9.3-p545 ruby-2.1.7 ruby-2.2.2 ruby-2.2.3 ruby-2.2.4 ruby-2.3.0 ruby-2.3.1 * ruby-2.4.0-preview1 ruby-trunk I agree that a version manager can be overkill for production. However you should always match your development Ruby version with your production Ruby version. And if you hit any of my above mentioned criteria (you will if you develop Ruby for any length of time) then a ruby version switcher (in development) pays off big time. It was mentioned above, but chruby is a really light weight version switcher. Way easier to read through than RVM. 
Recorded a quick screencast for setting up puma-dev and a helper script to easily create the symlinks. https://www.driftingruby.com/episodes/puma-dev-replacement-for-pow-and-prax
Okey dokey and thank you! ^~^ If you have some free time please try out gem , and tell me your opinion :))
Add a .ruby-version file to the root of your repo
If they don't match "nicely packaged, tested and with security updates" then there is no argument. I can only speak for Fedora, RHEL and CentOS, and for them this is true. The whole point was to offer a *different* opinion than everybody else is spreading out, because I have seen people installing RVM on Fedora to *try out* Ruby. And then they complained "why is it so difficult to install Ruby?"
Thanks!
💩
I love rails, but I always felt like web sockets in rails was pushing its limits. Comparing it to other frameworks like node really illustrate this issue but I could never really articulate as nicely as you did. 
Has Ruby Rose commented on this situation yet?
I get it now. I'd recommend clarifying the article to make your point clearer. Especially the bit about production 
&gt; Why do you want to use a version manager – learn it and fight it when you don’t yet understand it – even before actually programming Ruby for a while? Largely this advice seems to be "go ahead and do something that is known to be dangerous and wait until it bites you in the ass". I don't think that is particularly good advice for 'newbies'. &gt; What is even worse is that our community actively discourage the use of packaged (system) Ruby. It's not like this choice was made for shits and giggles, system Rubys have historically caused problems. You mention only that the installed version may be 'good enough' but forget gem management. e.g. Try even running `gem install bundler` using system Ruby on OSX, you'll find you'd actually need to `sudo` that command, which is not a stellar idea. &gt; Getting security patches for free with system updates is nice. You also get the bugs for free too. Ruby doesn't have the best history when it comes to not introducing breaking changes in minor Ruby versions. You're choosing to live dangerously by not running exactly the same version in dev, test and production. &gt; In my mind I treat Ruby the same as Python, Perl or Node.js on my system. Well, so do I. I use `virtualenv`/`tox` for python, `nvm` for Node and don't use Perl. 
Yes, exactly! I wish I could have put the idea is such simple terms when I started... ...for me it was a question of "who does what best". The server seems to be the best place for network considerations (polling, parsing, non-blocking replies etc'). The application is the best place for application logic (not network code). Why should the application care how the messages are transported? The application should be allowed to focus on the message content and implementing the application logic. Thank you for reading the article and supporting [the GitHub issue](https://github.com/rack/rack/issues/1093).
Thank you for reading the article and for your kind review.
&gt; go ahead and do something that is known to be dangerous and wait until it bites you in the ass This. **This is the most exact reason I wrote the article** - because people like you are spreading the info that this is something dangerous. If this would be so dangerous corporations and banks would not be sticking with packaged and supported version of Ruby, would they? If you use a system where Ruby is *not* supported, I understand your point. Perhaps it's not a good system if they don't support what they ship. &gt; Try even running gem install bundler using system Ruby on OSX My post was about spending few minutes of finding whether I can use system Ruby or not. I don't use Mac OS so perhaps I would give up there as well. I agree that requiring sudo to install a gem is bad, but that say more about people maintaining Ruby for OS X then anything else. &gt; You also get the bugs for free too Not necessarily. Package maintainers just backport security patches to avoid this very thing (well, on enterprise grade system, not rolling distros of course). &gt; You're choosing to live dangerously by not running exactly the same version in dev, test and production. That's what I have tests for. And I do run the same version in development and production, where do I imply I don't? &gt; Well, so do I. I use virtualenv/tox for python, nvm for Node and don't use Perl. Fair enough. I use a Linux distribution for the packages, otherwise what's the point?
re: nokogiri, when was this -- in my experience that is an example of a gem that is never lagging behind. I can't think of even an alpha/pr ruby that it did not have a working version or branch for. 
Before POODR, I'd recommend looking through [Eloquent Ruby](https://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104) by Russ Olsen. I also came from C#/Java before Ruby, and that book totally helps set your head straight on how and why to grok the Ruby way.
I actually have that book on my wishlist. Maybe i should put that higher in the priority. Thanks at least i know I've chosen the right book to help me. 
Thanks for that awesome reply! I have to agree i tend to write more unit test in ruby than i would otherwise. 
&gt; It's not disinformation, it's experience Things get outdated you know? Perhaps some years ago the situation was really bad. Today you have a choice of systems with great Ruby packages. I am also writing out of experience. Also you forget how many people have problems with RVM and rbenv because they introduce functions in their bash terminals without understanding it. http://stackoverflow.com/search?q=rvm http://stackoverflow.com/search?q=rbenv https://www.google.cz/?gfe_rd=cr&amp;ei=jPqeV86AL6bs8we6qKC4Bg&amp;gws_rd=ssl#q=rvm+not+found &gt; not a single one uses distro provided Ruby I know that most companies don't. Does it prove that system Ruby is evil? I was just saying that big players do (that's my experience from working on Ruby platform team at Red Hat). Red Hat itself uses it for one of the biggest Ruby projects out there (OpenShift v2, Red Hat CloudForms, Red Hat Satellite). So pardon me for calling you out on saying that it is *dangerous*. &gt; Does Redhat still ship with 1.8? If you mean RHEL 6 then there is an old version of Ruby, yes. Also there are software collections to get new Ruby if you want to. And hey if it's old that does not mean it's abandon and not maintained (even if it is by upstream). &gt; How many pages of non-sensical documentation... Maybe I just think that learning how to install packages on your Linux distribution should be a skill you aim to have. Also that's what I implied in my post. That this is actually *easier* than dealing with version manager. If compiling a version managers/installers/switchers is easier then installing a few packages for you I can hardly argue about this. My experience is that installing system package is without issue, but compilation step might bring errors that newcomers won't know how to handle. &gt; You wouldn't use a particular linux distro if it doesn't ship some package you want? Of course not. For one it would be hard to find out one that has everything that I need. But first I always check if package from official repositories can help me, then I check other packages available (3rd parties) and then I would either make it myself or just compile depending on my needs.
Welcome to ruby! With the olympics getting started in Brazil, I wanted to mention a major misconception about Portuguese and Spanish. I learned how to speak Portuguese fluently and one thing I notice is that a lot of people make the mistake of noticing similarities in Spanish and Portuguese and assume that if you know one then you know the other, usually along the lines of "I know Spanish, Portuguese looks like Spanish therefore I also know Portuguese". This however is false as the two are actually distinct languages, but what might also fool a Spanish speaker into believing they also speak Portuguese is that generally a person speaking Spanish can be understood by a person who only speaks Portuguese but the converse is not true. A person who only speaks Portuguese will not as easily be understood by a person who speaks Spanish. now don't get me wrong the Spanish speaker will comprehend some things but pretty soon they will get lost in the distinct sounds and pronunciation of words in Portuguese. All of the sounds that exist in Spanish also exist in Portuguese, but Portuguese (especially Brazilian Portuguese) has many sounds that do not exist in Spanish. The same can be said about Java and Ruby. Ruby is a malleable enough language that a Java programmer could apply their Java way of programming in Ruby just fine. I don't think the converse is true where a Ruby programmer could apply their Ruby mindset to Java, (although they probably could with Clojure but that's not exactly the same Java is it?). Almost all Java programmers making the migration from Ruby write funny looking Ruby in the beginning because it will run and be syntactically correct, however it will not be the "Ruby way". That being said given a short amount of time, a java programmer will have an aha moment and see something very concise and succinct to do in Ruby that would take much more code in Java. You already are already on your way to this by just asking the right questions. Now the previous comment showed you how you can achieve Dependency Injection in Ruby using a DI framework. Here's the most important thing that needs to be said about DI frameworks in Ruby: You don't need them and you'll never use them. Why not? Ahh this is an important question and I'm leaving it up to you to figure it out because doing so will help free your mind from it's Java moorings. However [here's a breadcrumb](http://weblog.jamisbuck.org/2008/11/9/legos-play-doh-and-programming)
I am writing this gem https://github.com/adityagodbole/rubycube It is still a work in progress, but ready enough to start playing around with.
I suggest you post this on StackOverflow. Be sure to read [this guide](http://stackoverflow.com/help/how-to-ask) to asking a question first -- namely, your post should include *what you have tried so far* and *what errors you are getting*.
too complicated and creepy https://github.com/adityagodbole/rubycube/blob/master/lib/cube/interfaces.rb
Don't you want to wait till the last possible moment to make queries? Hence the widespread movement towards promises in front end development
It's been a long time since I've played with shy so take this with a grain of salt: I believe `shy` runs the executable within `AppData/temp` on windows, if you open a pstore like `PStore.new('my_store.pstore')` the file will end up in `AppData/temp/my_store.pstore` and I believe windows will clear this temp store out when the exe closes, deleting your stored data. You'll need to put your pstore file somewhere else to avoid this. As I vaguely remember, windows gives you the correct place to store per user data in `ENV['APPDATA']`. You'll want to use this (or track down the correct answer) to construct the path to where you put the pstore file. Should also note this same problem will exist on all systems; you shouldn't be placing the pstore in the same directory as the executable on linux/macos either. It should go in the User's data directory, whatever that may be on the given system. Probably somewhere in the user's home directory on linux and maybe in `~/Libarary/Application Support` on macOS. In all cases use a sub-directory named after your application. 
nah m8
It's kinda the same since OP in this case wrote the original case. In general I think it refers to the person who posted it, instead of the material. http://www.urbandictionary.com/define.php?term=op
*Here's the Urban Dictionary definition of* [***op***](http://www.urbandictionary.com/define.php?term=op) : --- &gt;Short for Original Poster. Used on online message boards and forums. --- _The the message the op posted is idiotic._ --- [^(about)](http://www.reddit.com/r/autourbanbot/wiki/index) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autourbanbot&amp;subject=bot%20glitch&amp;message=%0Acontext:https://www.reddit.com/r/ruby/comments/4vdnvc/on_managing_ruby_versions/d5zwbin) ^| ^(**Summon**: urbanbot, what is something?)
Not a single screenshot.
Games written in Ruby are rare. The majority are just text adventures and MUDs written for the joy and not intended for distribution. This probably leads you to the question of why not? Ruby is a great language. Is it too slow or ill-suited in some way? Na. It wouldn't be a great platform to write the next Far-Cry on but its certainly fast and verbose enough to write some smaller indie game on. The 'why not' reason is probably 99% to due with the Ruby community. Ruby was a great solution to the pretty obnoxious forms of web servers back in the early 2000's. Some developers picked it up and ran with it. Game devs probably weren't searching for a language-based solution to their woes at the time. So what should you do in the meantime? If you're heart is set on Ruby, check this guy out: https://github.com/RickCarlino/mud It's a pretty easy-reading MUD framework. There are a bunch others out there but unfortunately they just aren't a major factor of the ruby community. Otherwise, you're best bet for further game dev is to look into javascript or c#, language-wise, and maybe Phaser.io or Unity, depending on how big of a game you're imagining. 
Middleman!
They don't have to be saved to file or redis. Looks like you can implement your own Store and store them anywhere you want. According to this: https://github.com/google/google-api-ruby-client/blob/master/lib/google/api_client/auth/storages/file_store.rb FileStore is deprecated and this: https://github.com/google/google-auth-library-ruby should be used instead. They have kind of a interface for custom token store here: https://github.com/google/google-auth-library-ruby/blob/master/lib/googleauth/token_store.rb With that you need any class that have the same "interface". That means, `load(id)`, `store(id, token)` and `delete(id)`.
Here's Pong written in Gosu: https://github.com/subdigital/pong Here are two talks on writing games in Ruby: http://confreaks.tv/videos/larubyconf2014-writing-games-with-ruby http://confreaks.tv/videos/arrrrcamp2015-game-development-the-ruby-way And how about Wolfenstein 3D in Ruby? https://github.com/qwertyreddy/rubystein
In your description you didn't write that you needed transaction safety. I provided alternatives that you may or may not know. Besides, you don't load and dump a file with sqlite. You use an sqlite client to connect to the database on file. Sqlite also provides atomic transactions.
Taking your title literally, [Ruby Warrior](https://www.bloc.io/ruby-warrior).
I wrote a console game in Ruby https://github.com/jwoertink/dopewars and then a 3D FPS in JRuby https://github.com/jwoertink/maze_craze and then I have a 2D sidescroller in Ruby with Gosu https://github.com/jwoertink/pcotm Hope that gives you enough examples!
Here's a flappy bird clone in Gosu: https://github.com/tomdalling/fruity_bat There's also a link to the live stream video of it being made, in the README.
See the [Dr. Jekyll Themes Listing](http://drjekyllthemes.github.io) for screenshots. It's all just getting started. Cheers.
Right, so you're not answering the question of why what OP is trying to do won't work, just offering up some suggestions that are equally unlikely to work.
Why "equally unlikely to work"? From his description he didn't try to serialize the PStore and he wanted to change the exe, an option that won't work. SQLite from a desktop program works quite well and provides a more structured way for him to store the data.
Looks cool! Which versions of `ActiveRecord` has this been tested on? I don't see any in the gemspec, does this mean it works on both `ActiveRecord` 3.x and 4.x?
&gt; Unless you store the SQLite file outside of the executable Please, the file is compiled, how would you store any type of PStore or Sqlite file inside an executable? I'm providing alternatives to store the data outside the file. Windows' caching mechanism will lock the files on disk of any executable loaded. You can't change it at runtime.
A Dark Room for iOS was built with Ruby Motion. http://www.rubymotion.com/references/success-stories/a-dark-room/ Guy who code it even did AMA somewhere here.
This gist show how to do something similar and the problem with count. https://gist.github.com/ceritium/ff01f68591794339b899f4a845af0c9f
&gt; I didn't write anywhere that using PStore was the problem. You suggested that a solution was using an alternative to PStore. There was no reason to do so. &gt; SQLite client library for Node.js applications (SQlite3, ES6 Promise, ES7 async/await, Babel) and SQL-based migrations API https://github.com/kriasoft/node-sqlite *Sigh* That's not a client. They can call it whatever they want, it's just wrong. [SQLite is serverless](https://www.sqlite.org/serverless.html). A client connects to a server. There is no such thing as an SQLite server. Therefore, there is no such thing as an SQLite client, because SQLite *is not a client/server architecture*. It is a file format and a means of accessing that file directly. Same as a PStore. &gt; Please read above when I talked about File. I did. It made no sense. &gt; The discussion is over for me. I don't have the time to explain in detail every technology before I make a sentence. You aren't bringing anything new to the discussion, just creating wrong assumptions about any point I write. Look, this is very, very simple. I don't know why you are having so much trouble with it. 1) OP said he couldn't figure out how to get data in a PStore to persist across executions. 2) You suggested using SQLite or YAML instead of PStore. Please explain why 2) is a solution to 1), changing *nothing else*. You didn't say anything about moving the file out of the executable. You just said use an SQLite or YAML. What difference does it make if you use a PStore or SQLite or YAML? And if you say “the data file shouldn't live in the executable”, well, you didn't say that at the beginning, which was the whole point. And if you're going to move the data file out of the executable, there is *zero* reason to use SQLite or YAML instead of PStore. Honestly, this entire conversation has made it pretty clear that you're very, very confused. If you're just too stubborn to accept an explanation of why what you're saying doesn't make sense, then there's not much anyone can do for you.
I wouldn't recommend using implicit subjects. I used to write specs like that a lot and learned over time that people find them harder to understand. `subject(:some_meaningful_name)` and explicit descriptions of examples are better.
Maybe I should do a "pitfalls to avoid in RSpec" kind of post at some point. Edit: I've replaced it with `let` in the first code example, in case readers see it as an endorsement.
well yes and no, it's really hard to come up with core Ruby lib that is generic enough to cover everyone needs but lightweight enough to be core lib. it's definitely annoying and repetitive to implement Plain Ruby objects using Enumerators from scratch for every collection type, but I guess this is more a topic for a Ruby gem 
I've had the same experience with `subject`. Is `subject(:some_meaningful_name)` a synonym for `let(:some_meaningful_name)`? I just use `let`. 
Yep it's just `let`, but with some extra functionality like `it_expects` and having its value inferred from `described_class`.
Thank you! Haha.
Thank you!
Thank you! 
Interesting.
Thank you!
Thanks.
What are you talking about? [Gosu](https://github.com/gosu/gosu) game development is fairly popular and common, just not particularly well publicized/advertized.
The text in this "article" could replace lorem ipsum and be as meaningful...
&gt; I don't want to have to learn more about rspec This attitude drives me nuts. "Don't use 'and' and 'or'" or back in my C++ days "Don't use templates because the error messages are hard to read" You're a professional software developer, learn your goddam tools. If you're using something you don't understand you're just programming by coincidence. 
Yes, i see the same. If you look at the console, it says Failed to load resource: the server responded with a status of 503 (Service Unavailable: Back-end server is at capacity)
isup.me
I think you misunderstand me. I do in fact spend quite a bit of time learning my tools. I do indeed want to know all the ins and outs of the tools i'm using. Which is why I'd prefer simpler tools that take me less time to learn the ins and outs of. Testing is a means to an end, I want to spend my time coding my app, not learning testing tools. But yes, I still need to learn the testing tools. RSpec can be very painful to learn exhaustively, because there's so much there, so much of it is so 'magic', and the docs are so terrible -- and the two or three major sea changes in rspec api/best practices over it's version history don't help either. Which is why I experimented with just using MiniTest instead of Rspec. But there were some core things I really wanted from RSpec that weren't in MiniTest. So I went back to Rspec. But I have chosen to learn and use only the features I actually need to write good tests. And implied/inferred subjects weren't one of them. The additional 'magic' to learn regarding inferred subjects -- because I indeed do want to know all the ins and outs of exactly how it works if I'm going to use it -- is not worth whatever advantage it's supposed to give me, to test readability I guess. I find tests quite readable with `let` instead of `subject`. And I understand exactly how it works. The additional complexity of inferred subjects is not worth it to me precisely _because_ I'm not willing to just copy and paste coincidence without knowing exactly how it works, which raises the costs of using it. The more complex and 'magical' your tools, the more 'expensive' it is to truly learn them. I choose not to use complex features in rspec from which I don't see a commensurate benefit -- because I'd rather be spending my time on my actual apps than on learning complicated magical rspec features that I don't need. 
Clear, concise and I learnt something. Nice work.
Probably I could do it works for AR 3.x, are you really interested in use this gem for a Rails 3 app? 
In your processing of the doc, there should be a links.... you can do a host comparison to see if it's the same as the source URL. If so, then its local.. There's a TON of edge cases, but this will get you started. 
The second rule should be: don't do it, you can accomplish the same thing without magic.
Interestingly... nothing. They both assign `x` to `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`. The splat operator has an off-label use as an array coercion operator. https://endofline.wordpress.com/2011/01/21/the-strange-ruby-splat/ It looks like it calls `to_ary` internally, but I couldn't find the source for that, only a test. https://github.com/ruby/ruby/blob/134d1ce89255f94c42730c814dbf3efed1c557d2/test/ruby/test_assignment.rb
You're defining `y` inside the loop, so every time it gets reset to 1. Try this instead, and you can also use each_with_index and avoid having to use y at all. &lt;div&gt; &lt;h3&gt; &lt;%y=1%&gt; &lt;%mark.each do |x| %&gt; &lt;%=y%&gt;)&lt;%= link_to x.url%&gt; &lt;%y=y+1%&gt; &lt;% end %&gt; &lt;/h3&gt; &lt;div&gt; *or* &lt;% mark.each_with_index |x, y| %&gt; &lt;% y %&gt;) &lt;% link_to x.url %&gt; &lt;% end %&gt; should work also.
Yes, Gosu gets a bit of activity. Imagine a side-by-side comparison against the amount of games developed in C-based or JS languages, though. Relatively, Ruby games are very rare.
Nothing that I can see. However if you are not assigning to `x`, `*(0..9).map` throws a `SyntaxError` while `(0..9).to_a.map` returns the `Enumerator`.
Unfortunately it needs to be, so that things like https://github.com/adityagodbole/rubycube/blob/master/examples/demo.rb are simple
One is easily understandable to the next developer reading your code, and the other isn't. As other comments said functionally they're identical. But I always prioritize readability, and `.to_a` is much more straightforward. BTW a 3rd version is `Array(0..9)`.
That works because the first value of the splat is assigned to a lvalue before map is called.
Could it be this [line](https://github.com/ruby/ruby/blob/dba03c38c54835248766f28033b5aeddc5f052ef/vm_eval.c#L1055)? But that's for cases where `*` is called on an `Array`. Maybe at some point `Range` or `Enumerator` types get casted to an `Array`.
Sorry, erm.... What makes you say `UUID`s are not lexicographically sortable? They're not *chronologically* sortable, sure - but I'm confused by your choice of names.
Don't know if it helps, but I started a first person dungeon crawler a few months ago (and still has to return to it): https://github.com/mbuffa/ultima
I see, I am new to ruby, I'm aiming to tackle on rails next, sorry if it seemed a silly question I was just curious if it had any performance issue or something similar. Thanks for the 3rd version! ;)
The splat operator can cause a stack overflow when the range is large, but for the small range in this case there's no difference.
Try to simplify the problem to discover the error. Open your console, then use un array like [:a,:b,:c], iterate over it with an each and try to increase a variable.