^The linked tweet was tweeted by [@keystonelemur](https://twitter.com/keystonelemur) on Aug 27, 2018 18:03:48 UTC (0 Retweets | 2 Favorites) ------------------------------------------------- The lemurs have their next vacation in mind! They're headed to LA for RubyConf! [http://rubyconf.org/program](http://rubyconf.org/program) [Attached photo](https://pbs.twimg.com/media/DloASgZU8AU9KgC.jpg:orig) | [imgur Mirror](https://i.imgur.com/G3St2lV.jpg) ------------------------------------------------- ^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •
Alo alo! If you've been seeing lemurs cropping up every now and then from other posts and liked them, good news! They're all headed to RubyConf where we'll learn about Red the Lemur and his adventures in Reducing Enumerable! &amp;#x200B; This article will give you some insight into some of the madness that went into it: [https://medium.com/@baweaver/creating-reducing-enumerable-an-illustrated-adventure-c6adfcc30d5b](https://medium.com/@baweaver/creating-reducing-enumerable-an-illustrated-adventure-c6adfcc30d5b) &amp;#x200B; ...but the secret is, I'm not quite done yet. There are more tricks to come, and an even more grand adventure on the way :)
Hey everyone! Speaker here. Published the slide deck of Ducks and Monads [there](https://www.morozov.is/slides/euruko-2018). Feel free to use it (CC-BY-SA 4.0).
1. https://github.com/rubysec/bundler-audit 2. https://github.com/presidentbeef/brakeman
2 very good tools ! We don't use bundler Audit since github does pretty much the same. However I recently set up brakeman on our pull requests thanks to pronto-brakeman, so far nothing has come up 🤞
&gt; Cookies: they are 100% editable by the user With signed/encrypted cookies they are still technically editable but with no effect. Unless you really want to read a cookie via JS there's no reason to not at least sign them all. Also a recommended read for any Rails user: https://guides.rubyonrails.org/security.html
`globals = ['one', 'two', 'three']` `values = ['two']` `globals - (globals - values)` `['two']`
Ahh, so `x.foo` &amp; `y.foo` are not words, but phrases. I think other people (I too) were assuming that all arrays contain words. Anyway, given the new understanding I think something like this is what you want: return unless [x.foo, y.bar].any? do |element| global_variable.any? do |g| if element.to_s.downcase.include?(g) puts g true else false end end end 
Tesla is still in business..?
You can get the intersection of both the arrays and print the intersection, like so word = "two" puts global\_variable &amp; \[word\].flatten
This form returns a list of each state that a user has been to on their profile. So this is for them, and needs to show up as individual states. So an array wouldn't make sense. Not really sure what to do...
\[\] just gives me an array, but rather I want a checked state to appear individually in a list of states. This form is for the user, and they can add states to their list -- so I don't want an array back, I just want it to post more than one state at a time.
If you want cookies to be readable via JavaScript you should still sign them, only if you want them to be editable you should forgo signing.
I imagine a shrine-rails gem could provide an initial setup which would work and would make shrine accessible without the need for deep knowledge upfront... without sacrificing flexibility.
It sounds a bit like you're confusing the processing of POSTed data with the display of the form. Is that possible? These should be two separate actions/methods. So to use Rails terminology, you need an 'edit' action accessed via a GET route, and a separate 'update' action accessed via a POST route. Tell me if I've got they wrong by all means. It would really help to see the relevant bits of your code.
&gt; For me, I use `Any` Yeah ok, fair enough. But as I said, my original comment about "needing to use `instance_eval`" was based on the proposed syntax (`__`). And I also stand by my original comment that this syntax would be very helpful if it plays a major role in the code; I wouldn't add that dependency for the sake of a few lines.
I'm over at [@baweaver@ruby.social](https://ruby.social/web/accounts/6173)
This was really useful, thanks !
How does your meth get dirty in the first place? I’m assuming the person has already tried dish soap/laundry detergent. I’d be all out of ideas at that point too. Again, I’m so confused as to what this would have to do with OOP, or MVC. But I haven’t been programming that long, I don’t want to miss something obvious. 
Agreed Agreed This guy knows his stuff Why does this guy know this one
We use it at my startup so we can crush 100hr weeks. Pretty normal /s
quora
I just recently made the switch. There's some things that Rubymine does better (some of the standard IDEA features, git, perforce, etc integrations), but all-in-all, I think I prefer VSCode. It feels "lighter". I had issues with Rubymine where it seemed like active development had ceased long ago and things like Rubocop integration was more of a hindrance than a help. YMMV
I've used RubyMine daily for the last 8 months, and PyCharm on a weekly basis. I tried switching to VSCode for about a week due to RubyMine's quirks—slow indexing, unexpectedly changing Ruby versions—but switched back once the indexing issue was resolved. I don't care as much about the icons because I rarely use them. I imagine there is a theme you can download to revert them. VSCode feels "lighter" and faster, as another poster mentioned; however, I couldn't get past muscle memory developed over the past decade of using JetBrains IDEs. There is a plugin that tries to mimic the keyboard commands, but it isn't quite right. You might try the RubyMine EAP to see if that resolves your issues. Also, file bug tickets (https://www.jetbrains.com/youtrack/) to make sure JetBrains is aware of the issues.
The thing is that in the last 2 months, I've opened 11 tickets for breaking changes between 2017 version and 2018. Of course, they corrected most of it, but I really don't have the time to test and point out their errors for them, it affects considerably my productivity which should not happen with a paid product. If I could get most of the useful stuff from Rubymine (auto-completion, go to definition, the debugger, git) within VSCode, then I think this would be enough for me.
Sublime text is one love.
Well our startup makes meth
I’ve tried to make the switch a few times and always go right back to RubyMine. Maybe it’s just familiarity, but I prefer the test runner and debugger, DB tools, refactoring, find window, and click-to-source behavior. Most of my work has me writing TypeScript, so I’m usually in VS Code and very happy with that, but I prefer JetBrains IDEs for everything else.
Tried VSCode, not a fan, made the switch full time from Sublime Text to Atom a year and a half and haven’t looked back
I'm in the wrong Rubby-ing business. 
I actively use both. IMHO RubyMine is much more suitable for big projects development. Especially if you rely on a bunch of gems. "Go to definition" in VSCode doesn't allow you dive into gems (if you know how to do it — please share your knowledge) and RubyMine does. Also "go to test", run a single spec you focused on with a single shortcut, the debugger make difference for me. Thought for pet projects or fast prototyping I usually use VSCode.
Nice relevant memes
PragTob wrote about it [here](https://pragtob.wordpress.com/2017/12/12/surprises-with-nested-transactions-rollbacks-and-activerecord/), not sure it answers your question, though.
The most recent [weekly Rails update](https://weblog.rubyonrails.org/2018/8/26/this-week-in-rails-action-cable-testing-utilities-bugfixes-and-more/) happened to mention an improvement in Rails master to ["Omit BEGIN/COMMIT statements for empty transactions"](https://github.com/rails/rails/pull/32647), and the discussion of that PR happens to [include a comment](https://github.com/rails/rails/pull/32647#issuecomment-410760654) from @matthewd that touches upon the issue. Apparently the current implementation is partly there for performance reasons, but matthewd has some hopes that it can change in the future. I think everyone agrees it's confusing how it is, it's there for historical and somewhat complicated reasons. 
Great read, but unfortunately it doesn't answer my question. I believe in learning by understanding and I just don't understand why it was done like this. &amp;#x200B; Also: It looks like a good question for Mid/Senior interview
One more alias 😑 One more reason for code to be inconsistent. Enough with \`map\`/\`collect\` and \`find\`/\`detect\`, now I have to think which one suits better in context \`filter\` or \`select\`. Feel like too many aliases ain't a good thing.
I certainly hope they don't change the default. The way it is now is what I want most of the time: "these changes happen together or not at all". Having to write methods that are aware of whether their caller is inside a transaction to avoid accidental nesting seems very messy.
I guess there are two answers: 1) It's mostly a side effect of how `ActiveRecord::Rollback` is handled, it's the one exception that is swallowed by `transaction` blocks and this behavior is intentional. Basically, don't use `ActiveRecord::Rollback` unless this is what you want (and it almost never is). 2) There are two options for how a `transaction` block inside another `transaction` block could behave by default, one is to 'join' the existing transaction, they other is to create a sub transaction. The overwhelming majority of the time joining the existing transaction is what you want, so it's the default. There aren't many good use cases for 'real' nested transactions.
Yeah, I think it's mostly a historical accident, but such behaviours tend to embed themselves over time: nested \`transaction\` blocks are currently free, so people \[Rails internally, gems, and applications\] use them freely... just switching the default to \`requires\_new\` would make existing callers unhappy because of both the change of semantics (I'd argue it's much better, but that's still \_different\_) and the performance cost of adding a bunch of useless DB round-trips. &amp;#x200B; The specific interaction of nested \`transaction\` + \`AR::Rollback\` particularly seems accidental, and silly. But without a real transaction to act on, it's really an impossible situation: re-raising the \`Rollback\` would just give a different surprising behaviour, which isn't very appealing as an incompatible change. &amp;#x200B; But yeah, my plan is that we can now change all that: we can \[via a deprecation cycle\] flip the default on \`requires\_new\`, which should give much more intuitive behaviour -- it's still an incompatibility, but it's more justifiable because it brings a clearer improvement.
This is interesting.. could you expand on when you'd feel the need to avoid nesting?
I found the style guide that Rubocop uses, and it seems to suggest not using most of the "ect" methods in favor of using their less-rhyming counterparts. I'm not sure if that's the right choice, but it's some kind of guidance at least?
As a counter question, when would you _want_ true nested transactions? It's actually somewhat difficult to come up with a scenario when you want some subset of operations to commit / rollback but leave the rest of operations committing. To change the default to creating a true nested transaction would require adding error checking / handling in a lot of places to behave correctly.
There's always `class Array; def filter(other) raise "USE SELECT AND/OR REJECT JAVASCRIPT SCUM"; end; end`
I can imagine a person by the name of Ruby using meth...
I think the more fundamental issue is that there isn't a good terminology distinction between 'join existing transaction or create a new one' and 'create transaction'. I think the overwhelming majority of the time 'join existing transaction or create a new one' is what people want, and what the current default behavior of `transaction` provides. In an ideal world, the changes I'd like to see are `ActiveRecord::Rollback` propagating outside the `transaction` block if the block if part of another transaction block, i.e. when it's not a true nested transaction. This alone would remove the 'gotcha' and while it certainly requires depreciation I doubt _too_ many people are relying on current behavior since it's really weird. I'd also like to see a more descriptive alias for the `transaction requires_new: false` scenario that describes what it actually does, e.g. `join_transaction` or something along those lines, this much more of a 'nice to have'. 
This function is known widely as `filter` is about _every_ other PL. It’s not a bad name, just because you learned select and its complement first..
While I completely agree with you on the aliases, this case is a bit different IMO. When an alias is added to (finally) name something as it is known in about every other PL it is really a good thing.
This is definitely confusing behavior but if you look closely at the docs, the behavior is very specific to ActiveRecord::Rollback, because 'transaction' specifically swallows that exception - if you were to raise a separate exception, nothing would be persisted. Now, it's super weird that the models in the inner block are still persisted, but if you think about how a transaction works in the underlying SQL layer, it's a little bit less strange... Keep in mind, to create a transaction in SQL, you just write "BEGIN", followed by your sql statements, and then "COMMIT". The transaction isn't finalized until you send the word "COMMIT" through to your database. (You can try this out in your database console) So in rails, every time you run a '.create' or '.save' method, it's actually writing SQL to your database connection, and that is hanging out in an uncommitted state until Rails issues a "COMMIT" on the database layer to actually have that persisted. For example (assuming we're not inside of another txn block): User.transaction do # Sends BEGIN to db connection User.create(username: 'Kotori') # writes corresponding INSERT to db connection end # Sends COMMIT to db connection So then, given the behavior described in the docs, how nested transaction blocks join the parent, the underlying sql for the example provided above will look something like this: ``` User.transaction do # BEGIN User.create(username: 'Kotori') # INSERT User.transaction do # nested txns are essentially a no-op User.create(username: 'Nemu') # INSERT raise ActiveRecord::Rollback # This gets caught and swallowed - how could we reverse the one INSERT already written to the db conn? Savepoints is one solution, but since we're not using that here, the commit will insert both records. end end # COMMIT ``` That all explains how it works, but not why it works that way. For that, I'm guessing that the rails team decided to make nested transaction blocks join their parent transaction possibly because of historical reasons relating to db connection adapters not having support for savepoints or other nested transaction workarounds. The current syntax seems a bit like a leaky abstraction - using ruby blocks to represent transactions feels really nice for the non-nested case, but there's the edge case where you can nest ruby blocks inside one another, which doesn't really reflect the reality of transactions in RDBMSes themselves; so you have weird, unexpected behavior when you do that. Maybe savepoints is a great way to emulate what we're trying to do with nested transaction blocks all the time in rails, but now we have this legacy syntax that needs to be supported, and hence the complicated documentation? Also I don't know if you'd be adding a bunch of overhead as well. In any case, great question! Fun to dig through the code there and see some of the lesser visited parts of ActiveRecord :)
Don't forget that the `find_all` alias already existed too...
I am loving your participation on reddit explaining things, /u/matthewd. Thanks! 
Changing the default won't change the behavior you are talking about. In fact, it should _improve_ things from your perspective. Right now, code making a transaction needs to know if it's in a _nested_ transaction or not, as nested transactions behave differently. In matthewd's plan, that won't be the case anymore. The changes will still happen all together or not at all, but that will be true of each nested transaction as well, and it isn't quite now. 
That sure brings me back to my Rails 1.x days. https://www.rubydoc.info/gems/activerecord/1.10.1/ActiveRecord%2FBase.find_all
I used VSCode for a short amount of time on a Windows system where I installed the complete Ruby / Rails stack inside the Linux subsystem. It was probably the best choice, because I didn't install anything on the windows system, and therefore the great IntelliSense stuff of RubyMine would have been useless. But I really enjoyed coming back to RubyMine on a new Mac a few weeks ago, having the IntelliSense, the database explorer, starting the docker compose dev stack with one click and so on.
Cool hopefully they make Ruby 3 just a symlink to Python
&gt; With current defaults, everything works as you would expect here, as long as you ban use of ActiveRecord::Rollback .. and all (non-re-raising) use of `rescue` inside the outer `transaction`. I still don't see how nested actual-transactions would change the observed behaviour. &gt; looking at one app I have to makes a fair bit of use of transactions, out of ~50 use cases of `transaction` blocks and many instances of nesting similar to the example above, only one uses `requires_new`. Cool. And how many of those would change behaviour if we created additional savepoints? &gt; `requires_new` used indiscriminately can lead to hard to find bugs and unexpected behavior when accidentally composed Great, that's just what I was hoping to hear about. Only it's an unsupported statement, not an example.
Right now, `transaction` means "treat the database changes in this block atomically". It doesn't matter if I'm already in someone else's `transaction` block, or another `transaction` is enclosed, the things in this block will either all happen, or none of them. When we use `requires_new: true`, the above invariant no longer holds, since my block could contain a nested transaction which fails, while other code succeeds.
They'll have to maintain separate branches of Ruby 2 and 3 for decades
&gt;Generally, if an exception (other than Rollback) is raised, I want the the whole operation to back out, not just the most recent step. And it will, unless you rescue the exception. &amp;#x200B; The *only* time you'll see a behavioural change is inside a rescue like this: transaction do bob = User.create!(name: "bob") begin transaction do bob.posts.create!(title: "Hello world") raise "oh noes" end rescue puts "We gave up on the post, but bob survives" end end (where currently, the post would also end up in the DB, despite its transaction having hit an exception -- much like in the OP example)
&gt; Yeah, I think it's mostly a historical accident, but such behaviours tend to embed themselves over time: nested `transaction` blocks are currently free, so people [Rails internally, gems, and applications] use them freely... just switching the default to `requires_new` would make existing callers unhappy because of both the change of semantics (I'd argue it's much better, but that's still _different_) and the performance cost of adding a bunch of useless DB round-trips. The existing bahavior is a huge ergonomic win that I've been promoting to people as the Rails team designing for ease of composition. I'm disappointed to hear that one man's foresight is another's accident. &gt;But yeah, my plan is that we can now change all that: we can [via a deprecation cycle] flip the default on `requires_new`, which should give much more intuitive behaviour -- it's still an incompatibility, but it's more justifiable because it brings a clearer improvement. In my years of working with Rails apps, I've had to add `requires_new: true` once to make some logic correct, and remove it probably a dozen times. The existing default works in 95% of cases, across multiple companies and apps. Such a change is likely to just add boilerplate to apps and gems.
finally someone who like memes ([me right now](https://i.imgur.com/K3lihAC.gifv))
That's actually one nice thing I like about crystal. They have a no method alias policy (though, that rule gets broke from time to time like when renaming a method)
&gt; .. and all (non-re-raising) use of rescue inside the outer transaction. I don't understand this point, if you rescue exceptions inside any of the transactions you're changing the behavior of the transaction, regardless of it using savepoints or 'joining' an outer transaction. Though the consequences can be different (see below). &gt; I still don't see how nested actual-transactions would change the observed behaviour. I think you're only considering the code side. On the DB side if I'm inside a single transaction without savepoints and a constraint violation occurs, then entire transaction is left in an unusable state. If I have this mechanism creating savepoints and dutifully rolling back to savepoints on exceptions I'm left with a valid workable transaction with and any bug (e.g. exception handling mistakes) can now allow the transaction to continue and commit inconsistent data. &gt; Cool. And how many of those would change behaviour if we created additional savepoints? I'd have to see benchmarks to answer that, SAVEPOINT isn't free in PG but it may be faster than the last time I looked at it. If it drops my write qps 15% then I'd say 'all of them'. 
Love the article btw, good read.
Huh. Can this just be _fixed_? That's crazy that you can trigger a rollback by raising any exception _except_ the one called 'rollback' which seems intended for it. I totally don't understand what the heck is going on, so I'll just shut up. 
I’ve tried switching to VSC full time a few times, but there’s always something holding me back. The biggest win for JetBrains products is its diffing tools. It’s by far the superior choice when diffing and editing said diffs. But the most noticeable strength is the merge conflict resolution tool. It’s very clear to see where the diffs are on both ends (local vs from server) plus the “automerge” pane in the center. Then it’s extremely easy to pick and choose what you’d like the end result to be by either clicking on the arrows to move highlighted/conflicted code block or manually edit the center pane to your heart’s desire. If there’s a similar flow and view in VSC, I’d switch in a heartbeat. Given how actively the VSC team has been improving the tool, I think it’s only a matter of time before they finally get it right. But I’m not holding my breath. I’ll clinch to my RubyMine until then.
From Hash [docs](https://ruby-doc.org/core-2.5.0/Hash.html#method-c-new): &gt; If a block is specified, it will be called with the hash object and the key, and should return the default value. **It is the block's responsibility to store the value in the hash if required.** devs1 = Hash.new{ |h, k| h[k] = Set.new} devs1["non_existent_key"].add("new value") p devs1 # =&gt; {"non_existent_key"=&gt;#&lt;Set: {"new value"}&gt;}
@crazymykl hey stranger
I agree, see my comment here: https://www.reddit.com/r/ruby/comments/9b8gws/nested_transactions_in_ar/e51ctsi/
I like this particular change. It's almost always called `filter` in other active languages, and making things comfortable for new adopters is not a bad move for Ruby. Aliases are aliases are aliases. I don't mind them, if they achieve some positive value. If the question is about good documentation, that might be one thing, but eliminating them without regard to other factors and with only a hyper focus on some surface level notion of consistency doesn't make much sense.
I screw this up every time I write Ruby now. 
Yeah
Yeah
&gt; The only time you'll see a behavioural change The one I'm scared of is this: transaction do bob = User.create!(name: "bob") begin transaction do bob.posts.create!(title: "Hello world") raise "oh noes" end rescue bob.someting_else.create!(whatever: 'Hi') end end The only thing I changed is the code is the rescue block. Without SAVEPOINT calls to the DB, this will raise an exception telling you you've used a transaction that has failed. With SAVEPOINT / ROLLBACK SAVEPOINT calls, this saves inconsistent data to the DB. Now, both of our versions are contrived, in reality you may expect each of these lines to be spread across different classes, modules, abstractions, etc. I'd prefer that we default to the 'safe' case in this situation and commit nothing. 
Ya in this case the term 'filter' comes from math [https://www.encyclopediaofmath.org/index.php/Filter](https://www.encyclopediaofmath.org/index.php/Filter) &amp;#x200B; Good rule of them in a lot of programming concepts, look for the analog in mathmatics instead of English and hopefully that'll keep things straight in your head.
Good on you for figuring out what's important to you and making it happen. It's difficult to recognize the opportunity cost of doing things you love doing - what you're giving up in return. I hope these changes in your life bring you joy!
I totally agree that this is ambiguous. Not sure how people are arguing against that.
Oh yes the land of single letter variable and function names. I only see this when I open up mathematicians code. 
&gt; having bad lambda semantics (block/yield) Yeah, it'd be much better to have useless lambdas instead.
&gt;Without SAVEPOINT calls to the DB, this will raise an exception telling you you've used a transaction that has failed. .. no it won't. It'll happily commit all three rows. *Without* the outer `transaction` (or with inner `requires_new`), it would've left the \[IMO much more reasonable\] two rows. &amp;#x200B; The variant you *mean*, however, I also maintain we should change: if you rescue an exception, it stops propagating. If you don't raise from the rescue, then you are promising your caller that you've fulfilled your contract in some other way. Given that, it's none of their business that the first thing you tried had an issue (which you could've chosen to explicitly hide via `requires_new` anyway), and equally they have no business interfering with what you thought was a clean recovery (as in the above case, where it works predictably without an outer transaction, but gives blog-post-and-reddit-post-inspiring behaviour if some caller happens to need transactional semantics themselves).
&gt; .. no it won't. It'll happily commit all three rows. Without the outer transaction (or with inner requires_new), it would've left the [IMO much more reasonable] two rows. Yes m8, it will, as soon as an exception is raised in the DB layer, the transaction is FUBAR, end of game, you can not use it again...
Air filter = only air can pass through Water filter = only water can pass through `filter(&amp;even)` = only even number can pass through
Lol, agree with you there. People in academia, esp. research, tend not to code for clarify/communication as much as they should. That's why god created engineers.
I learned to code before I got a math degree, so I'm frequently in the long term support position after the PhD gun for hire long left. It's not bad code, sometimes, but it is harder to maintain. I've opened up files with 2k lines and no functions that weren't defined by the language spec.
Particulate filter = particles can't pass through Notch filter = everything but the specific band can pass through Color filter = all other colors of light can pass through Noise filter = removes noise from a signal 
Thank you :)
Thank you for sharing, it's very valuable to be able to learn from experiences of open source developers. I would be very curious to hear more about the improvements you've made to rom-rb (or dry-rb) to lower the barrier for new contributors, as I would like to do the same :)
Great article. Thank you son much.
I'm pretty sure you can get everything you need, but it will take a couple of extensions and some configuration, which can be kind of tedious. Out of the box you definitely won't. I've been hacking on and off on my VS Code config for months, but I enjoy that sort of thing. &amp;#x200B;
What I belive you app code structure maybe a part of that slow. You can not only blame Ruby on rails. By business side. You have 4.3 million requests per day. If you don't start making money from it, then what is your stand for? By cost side, I think you are pay less with Ruby On Rails. Server cost now is really cheap. Even other framework you pay less for the sever but the development cost is so high which multiply from the server cost a lot if you keep scaling the logic, improvement and features. By technical side, even if you switch to other framework it can be sure that you app serve request faster. As other framework don't provide help such as request query caching, eager load, etc... Except you got skillful on it. Some helper methods in Ruby even help with performance with loop, search, etc... Which you can ignore if you write from scratch. 
Yes code structure and logic plays a big part but 50rps is still a little embarrassing. ( but I guess it was on like a $5 DO droplet ) Like I said it is not possible to get 4.3 million request per day even if you have caching. If the product is an SaaS than yes, this wouldn’t matter as you would have more than enough revenue for servers. But if your product is not price per user model than it may be a problem. Rails is still the best at what it does, so many years in not a single framework even come close. I just hope TruffleRuby works with Rails soon. I think the best of Ruby Rails has yet to come.
I feel like this needs to be said... Rails is absolutely unbeatable in generic, boring backend applications. In terms of code cleanliness and development speed, it's just a joy to work with. You spend very little time worrying about the frontend. It's just not holding you back. However, I also see its limitations. I've worked with spree / solidus for a webshop in Rails. When going through a purchase-flow, looking at the Rails logs just makes you very uncomfortable. Every step is a new request with new queries for the tax zones and currencies, to name a few. The same is for [wrts](https://wrts.nl/), where you need to fetch a list of words and their translations once and practice their spelling for a while. Millions of users means that you really want to minimise the amount of requests. I also see that jQuery is on its way out, and I'm not yet sure what to replace it with. Vue seems nice but I don't want: * to run an extra node server * to duplicate business logic * to replace frontend functionality I never needed to worry about (awesomeness of simple_form) with vue 
Is there anything wrong with using Rails as an API backend and making the frontend a single-page app? I find all the non-ActionView parts of Rails still very valuable.
This is a great tutorial, thanks!
50RPS also might mean that your HTTP responses take a long time to arrive, which might affect your conversion rate. I like my HTTP responses to spit out in 100ms. At 50RPS this implies a concurrency of 5.
In many cases, it causes the codebase to duplicate. In backend applications, my views are super simple. And fast, due to turbolinks. This article describes it pretty well: https://medium.com/@jmanrubia/escaping-the-spa-rabbit-hole-with-turbolinks-903f942bf52c
We still use rails daily but with grapqhl and react. But we also have a lot of non react pages, so there action view falls into place there too. I usually start with super small rails framework (you can pick whats loaded in application.rb) and then gradually add more stuff. We wrap it all up in our containers up to our k8s cluster. It works like a charm.
Sorry to hear about all that burnout. When I read the bit about being tempted to write a static site generator to replace middleman, only to force yourself to just use wordpress... yeah I could, uh, relate to that, you might say. :)
Any reason to prefer `rb_str_new(x, strlen(x))` over `rb_str_new2(x)`? I don't think there is...
Anyone one knows why this is being rejected? I cant quite understand what is going on. I don't see any drawbacks, but offer lots more flexibility. Am I missing something?
Spoilers: They bypass ActiveRecord &gt; The idea was to bypass `ActiveRecord` and use the underlying MySQL client which was providing the [stream](https://github.com/brianmario/mysql2#streaming) option. I’m sure there are similar options for [other databases](https://deveiate.org/code/pg/PG/Result.html#method-i-stream_each_row). 
For something as simple as this example I'd suggest using [ffi](https://github.com/ffi/ffi). Quite a bit easier, and portable to alternative Ruby implementations like JRuby.
I can't find a gem, but you could make some shell calls to something like this: [https://github.com/beschulz/wav2png](https://github.com/beschulz/wav2png)
Thanks for the suggestion! I'll check it out.
Would love to hear more thoughts from you on Elixir. 
Love Ruby but this ignores two very common realities. 1. Apps where data processing is required - we had to temporarily Pass over to the dark side (node) for a csv processing app. 2. The many startups that rely on being free for the first few years. I use Ruby because few apps go viral but mass appeal apps that look to leverage userbases for future monetization need performance per server.
I would use [sequel](https://github.com/jeremyevans/sequel) for this (i use it for everything tbf)
I am equally shocked. There's a lot of really powerful and beautiful stuff with DHH/Rails but then there is the flip side of the really stubborn individuals (DHH, Basecamp, Rails team et all) who are stuck in their ways and have a difficult time seeing the big picture for others. It's a trivial thing to make this extensible and modular. Surprised at the push back. Left a comment on the issue but sounds like ActiveStorage is not a tool anyone should lean on for anything beyond hobby projects.
!"Ablah@blah@blahZ".chars.include?('@')
What's the `!` for? Why the .chars (String#include? is a thing) and why the hell doesn't this break? [6] pry(main)&gt; !"ablah" 37µs =&gt; false [7] pry(main)&gt; !"ablah".chars 56µs =&gt; false [8] pry(main)&gt; !"ablah".chars.include?("@") 45µs =&gt; true [9] pry(main)&gt; !"Ablah@blah@blahZ".chars.include?('@') 91µs =&gt; false
Is there a particular reason you detour over `#chars` and not just use `String#include?`?
 !string[1..-2].include?('@')
I assumed that the OP’s requirements of between the first and last char might require some array manipulation like removing first/last elements. But yea can do String#include? as well.
As a fun aside http://rubular.com is a great tool for messing with the perfect Regex
Looks like homework.
Thanks for sharing! Same as you, every time I need to do this I have to read and search a ton as I forget the steps.
https://i.imgur.com/rmzIxxP.jpg
I sympathise. This is frustrating. We just upgraded to 5.2 to have a look at AS and also decided not to jump in. Long story short, we got an issue with Paperclip saving files publicly to S3 even though our config said private. We’ll be implementing our own little service it seems.
Find or create by is your friend here
You can query the database for a record using find or where. So -- you could do the following: `if State.where(state_name =&gt; params[:state_name]) then &lt;error&gt; else state_name =&gt; params[:state_name]
@midasgoldentouch is correct, but I want to go a little further here for the sake of instruction: &amp;#x200B; Yes, definitely check out some of the helper methods in ActiveRecord (AR) for this kind of stuff: \`#find\_or\_create\_by\` is a good one to use allll the time. The other thing you're going to want to do is consider how you might perform the same kind of check before creation \_without\_ AR: what simpler queries could you string together in a method to do the same thing instead of just leveraging the helper?
&gt; !/^.[^#{target}]*.$/.match(string).nil? `^` and `$` mean start and end of *line*, and if you just want a bool out of a match, use `match?` /\A.[^#{target}]*.\z/.match?(string)
I tend to prefer Sequel too but we live in a world where ActiveRecord is everywhere ^^ I didn't know that streaming was so easy with Sequel through, thank you for the heads-up!
I added a small note on the article about Sequel, thank you.
/u/solnic it would be good to have email alerts for new posts, if you plan to write posts more regularly :) Thank you for all your hard work!
Whassamatta here, ain't nobody ever heard of look-ahead and look-behind? I swear, sometimes I wonder about you people. Anyway, the *correct* answer is: str.match? /(?&lt;=^.)[^\@]*(?=.$)/ Breaking this down: (?&lt;=^.) This is a look-behind, as indicated by the pseudo-capture group `(?&lt;=XXX)` at the beginning of the regex. It matches, but does not include, the string XXX. So the entire regex will only match if it occurs immediately following a substring that matches the look-behind. In this case, because the look-behind includes the anchor token `^` followed by a `.`, it only looks for matches starting at the second character of the string. [^\@]* This is pretty standard, we take the negated character class consisting of the single character `@` (which we have to escape using a backslash) and match it zero or more times. So any string will match true *unless* it has an `@` character somewhere in it. (?=.$) This is a look-ahead, the inverse complement of the look-behind. It appears at the end of the regex, and the entire regex matches only if the main part matches immediately before a look-ahead, but the resulting match does not include the look-ahead itself. And since we use a `.` to match any character and a `$` to anchor the look-ahead to the end of the string, we effectively only are examining the part of the string excluding the last character. So this regex will only match true if the characters in the second through second-to-last position do not contain an `@` character. Yes, there are plenty of other ways to do this with Ruby code, but if you want to do this with just a regex, this is how you go about that.
Are you saying they're stuck in... the rails way? (Drum roll)
thanks man :) are you talking about something like a newsletter? or just simple notifications whenever I publish something?
I should have something to write about in September!
I confirm this is dead easy &amp; very efficient with Sequel too. I've used this to implement large data migrations (full apps) with Kiba ETL successfully. If you used PG as the source you could optimise further with https://github.com/jeremyevans/sequel_pg (I don't know if something similar One thing to note is that you can definitely keep using AR (which is prevalent in apps), BUT use Sequel (side-by-side) for specific data intensive jobs. The connection will be separated (so you'll have more connections on the DB), but this can be done when useful without migrating anything else. Thanks for the great article otherwise!
This may be information overload, but this is roughly how I've got my system set-up. I hope this helps with the transition. I use the Ruby extension to set up automatic linting and auto-formatting via Rubocop. The Rubocop extension isn't needed. For Intellisense, I turn that setting off for the Ruby extension and use the Solargraph extension. I don't use the built-in debugger so I can't speak to that. I use a couple of other snippet plugins, and that is about it. Here are the quirks I have found workarounds for but would like fixed. The linter gets stuck sometimes, and it can be annoying. To fix this, I just reload VS Code. It seems to happen if you open a file that is rife with errors. Occasionally, It can't find the Solargraph gem for intellisense. If I open VS Code from the command line inside the project folder the issues is solved. `code .` works on Ubuntu, not sure about other OS.
Remove the `(` ? Depends on what you want it to match.
I am getting this error on the first line of the script &amp;#x200B; `require 'foo/bar'`
Did you write the `/^(https:\/` regex? It looks simple. That regex is invalid as either there is either a missing `)` or `(` shouldnt be there
I'm always pleased with its general utility. Recently I planted a binstub in one of my paths that essentially wraps the slack-notifier gem. Now I can pipe terminal output to push notifications on my phone for free, such as: `$ do_this_really_long_thing_like_a_scraping_task.sh &amp;&amp; slack "that thing is done"` Or to save a little snippet for later `$ cat the_thing | slack` It's not really an exotic example, but the simplicity and utility brings me much joy. I'm crafting "binaries" out of nothin' over here.
I did scraper that was pulling match results of my favorite esport team from some website. Then I wrote same script using NodeJS 
http://mapbeet.bibimapp.com/ 2.5 days to
I was thinking of creating an api and mobile app for devops push notifications that you can hook into anything. Would that be something you would use?
Oooh, I wonder if I can build something like that for the Overwatch League.
Post your code...
I know there is definitely room in this world for such a thing, but I personally would be unlikely to use it without a very compelling reason. I've already got a setup I like well enough. It's definitely something I would think is interesting though.
I built the game Talibri (r/https://talibri.com) in Rails. Started out as a side project to check out rails 5 and grew into something much larger/more enjoyable! I've arguably learned more building this than i have in college and my career combined (albeit my career is now .NET focused). 
Ive been building firehydrant.io with Rails 5.2 and I fell back in love with Rails because of it. 
Its uses rails for some of the web front end, but I have been working on (slowly) an open source app monitoring tool, similar to NewRelic or ScoutApp and others, [https://github.com/randy-girard/app\_perf](https://github.com/randy-girard/app_perf)
that sounds something like I'd be interested in recreating. I'm just getting started out with Ruby/ruby frameworks, but I have prior knowledge with other stuff so hopefully I can create something like this.
I made a tool with way too much threads and status displays (my first curses experiment) to selectively pull MySQL tables from a remote host, intended for development and debugging with production data but without the need to pull the whole database (well and with more status for the impatient like me). https://github.com/2called-chaos/db_sucker The intended functionality might be questionable (got some shit from mainly Postgresql users) but we love it in development. I made a few tools but this one made my brain hurt the most. I spend 90% of the time figuring out deadlocks and logical softlocks but a fun project nevertheless.
There's no reason whatsoever to use lookaround here, it simply makes it more complex, more confusing, and slower: /(?&lt;=^.)[^\@]*(?=.$)/ match 805.912k (± 0.8%) i/s - 4.061M in 5.039307s /\A.[^@]*.\z/ match 2.031M (± 1.3%) i/s - 10.228M in 5.036586s /\A.[^@]*.\z/ miss: 1843831.3 i/s /(?&lt;=^.)[^\@]*(?=.$)/ miss: 1681366.2 i/s - 1.10x slower &gt; In this case, because the look-behind includes the anchor token `^` followed by a `.` which matches any single character, it only looks for matches starting at the second character of the string No, it only looks for matches starting at the second character of *every line*. Likewise `$` anchors to the *end of line*. Hopefully you don't have and validation code floating about making this mistake, I imagine there's quite a lot in the world :( &gt; `@` (which we have to escape using a backslash) What? Why? What metacharacter is that?
irb is an interactive Ruby prompt, i.e. you write actual Ruby code in it, one line at a time. If you want to run a script that’s already in a file, just go to the regular Windows command line and do “ruby [path to .rb file]”.
As someone who just got his first C64 at a flea market, that is really friggin' cool!
http://rubyland.news
I read that as escort team at first, and thought - wow, there’s a hobby for everyone.
theclosingdocs.com makes me passive income every month
Thanks ;) More info: the emulator uses ncurses, requires an UTF-8 terminal, supports SSH, allows copying and pasting text, and on my PC it runs about as fast as an original C64, but as I've said, does not emulate all of the hardware registers and uses some dirty tricks for keyboard and screen emulation. I've still got to release it, however. The terminal window in the screenshots is the awesome \`cool-retro-term\` by Filippo Scognamiglio.
&gt;You would need to create the Greeter class first, which is shown near the bottom on Page 2 Emm, but at the beginning of chapter about MegaGreeter author tells to quit IRB and write the next sequence in file (I presume he means Notepad), I'm confused...
I am not an expert on this but DHH and rails maintainers have never imo had a high bar for provide features that follow any kind of logical progression towards advancing the framework (or what I would say is the prefessional standard). Updates are primarily sugar and many of the contributors are unwilling to adapt. Rails is nice to get webdev jump started but it seems like it won't keep up simple because of the attitude of those who write comits. Forking is probably the best long term solutions I suspect. Get someone who isn't fickle leading rails.
Prayer lexer-- recommends a Bible verse based on the context of a prayer. This fits nicely with praybook-- prayer tracking social network.
I always hated the default file layout. So I made my own, based off ember's new layout: https://github.com/NullVoxPopuli/drawers
Shrine seems to have done the best job at refusing to impose arbitrary constraints. In the unlikely event that I find myself needing to introduce a file uploader to a web server, I don't see myself ever using active storage at this point.
The public site is Rails + HAML, with a little react sprinkled in. The app itself is react talking to a rails API.
I was planning to make a website and everything, since all of the existing ones were crappy in one way or the other, but I never managed to finish. However, I tried to team up with the folks who make Droidippy, last time I checked they were working on a website as well. Not Ruby, but still fun 😁
that sounds like a cool project. how’d you go about making it?
It's incredibly boring actually. Major carriers and networks give you the ability to conditionally forward your phone number to another phone number depending on the action. Two of those actions are when your voicemail is reached. There are two ways to reach a voicemail — let's call one "no answer" and the other "busy no answer". I instruct users to conditionally forward these no-answer actions to a number I control (Twilio) and then do some stuff from there to act as a voicemail on the users behalf. Afterwards, I transcribe the voicemail (Twilio's transcriptions leave much to be desired, so I'm using Google Speech to Text) and fire off notifications based on a users preferences.
hey that's you. I used this a while ago for a project and loved it!
TIL about `bundler/inline`.
What API do you recommend for such screening? Asking out of mere curiosity.
The `Gemfile` does define dependencies for gems, the `gemspec` file does (https://guides.rubygems.org/specification-reference/). You also can't use git repos in `gemspec`. 
So inside gemspec its the same thing Apple has Banana inside it's gemspec as a dependency Same Banana has Cherry in it's gemspec as a dependency &amp;#x200B; I don't want to put Cherry inside the gemspec of apple because maybe someday banana won't use cherry, itll use dragon fruit gem
i’ve seen people use twilio for projects before (especially with messaging coupled with a raspberry pi, or something like that). that sounds really cool though haha, i might give something like this a shot one day ruby!
Can you post the relevant portion of the gemspecs / Gemfiles? As noted above, you can't depend on a git repo via `gemspec`, so unless you've published these to a gem repo `bundle install` run in 'Apple' isn't going to be able to figure out how to install 'Cherry'. 
A code generation utility. You describe graphs and transitions between the nodes in a .tex file. Then the ruby takes over by parsing that file and produces C code for you implementing your graph. It is usefull for implementing protocols. It can be found here: https://github.com/mashua/poc-fsm . I plan to add support for graphviz because .tex file can be a little messy and you don't have automatic layout of your graphs. 
Follow the advise given by the previous comments and try getting a book or a course. If you cannot spent money at this time, check this: https://mindaslab.github.io/I-Love-Ruby/ . It's a very decent effort to teach ruby.
https://github.com/sshaw?utf8=%E2%9C%93&amp;tab=repositories&amp;q=&amp;type=&amp;language=ruby
Good article, few things: * In practice, tests/specs should be made before writing the implementation. * Dependency injection is very common in Ruby (why wouldn't it be?) * The 'My Little Pony' references and gifs are cringe worthy. 
Yes, Bundler only downloads git dependencies in apple's `Gemfile`. It will not download git dependencies in apple's dependencies' `Gemfile`s. For this you'll to make gems: https://guides.rubygems.org/make-your-own-gem/ For hosting private gems, see https://github.com/zendesk/geminastrongbox
Good to know, thx!
[parsing with ruby and nokogiri](http://ruby.bastardsbook.com/chapters/html-parsing/)
Cheerio.js? ❤️ That library
I *kinda* thought of something along these lines. My idea is basically a URL shortener (instead of typing a url, you'd just give a keyword, or something like that). sounds like a cool project you made. How did you go about making it?
Pretty much any small web application I need I do with Sinatra or Cuba. I tend to make any of my slide decks with one of those and some Markdown js rendering. I also do a lot of shell scripting with Ruby, since it's the language I'm most comfortable in and the tooling around that stuff is really good. I also tend to reach for Chef for configuration management, and it's a Ruby DSL. I also wrote a bill tracker for my getting email updates on bills in my state legislature in Rails back when I was trying to get into the tech industry.
That's massivetadon ;) hoooo yeaaahhhh
I'm not personally a fan of `.call` style, but yeah it's idiomatic. It's not Rails though, just Ruby.
I have several projects with a React front end and a Rails API only back end. It works very well for me. 
&gt; • In practice, tests/specs “should” be made before writing the implementation.
Nokogiri and mechanize should be perfect fit for a job 
Yep, done it with cheerio. This library is gold!
Sound like you should get your input in a `while` loop.
I don't get interest-specific Mastodon instances. I have several different interests and I sure as hell don't want several different Mastodon accounts.
Great post! &amp;#x200B; I really like DI. Recently I have done good refractor using DI. Never to late :) By the way, Imho it's little not intuitive in Ruby that there is no protection from changing the value in the constant, without freeze. &amp;#x200B;
I hear you. Discussion on there via the peek inside thing looks indistinguishable from every other instance though. For better &amp; worse.
Definitely, I used it for some stock scraping discord bot 
&gt; if I should just submit the solution in a language &gt; that can accommodate their input requirements easier Sounds more as if Kattis is giving you some problem rather than ruby. I think the best way would be to design it through OOP, that is a proper class + methods. However had, leaving that aside, even without a class, I'd arrange through a method, and work on a per-line basis. You can design it so that your code handles both input via methods, and input via a loop properly, e. g.: def obtain_user_input loop { user_input = gets.chomp break if user_input == 'q' # Just to show one example for a break condition here puts shift_left(user_input) } end By the way, it's strange that your code has unit tests - but it does not work. :) I'd start with making the code work before even jumping to writing any tests. If Kattis is using weird file layout, you can always split a large line into newlines via: File.read('path_to_file_here').split("\n") and then feed that into the method. You can design the method in a way so that it either is fed with input; and if no input is given, default to using gets.chomp instead. That way you retain the flexibility to be able to handle this both via a method, and with user input. The problem is very simple, don't over-complicate it. Even everything in a single line should be dead-simple (but I do wonder why Kattis is making such a strange task ... perhaps it is an awful platform).
I'll confine to my ... top three or so, I think. (1) Cookbooks and RBT (ruby build tools). I am presently rewriting both and merging them together. The idea behind the code in these projects was (and still is) to compile/install programs, usually from source. Additionally to build up a LFS/BLFS system (Linux from scratch), and support for AppDirs (similar to GoboLinux). It also is supposed to be a "build tool" and thus should help with more things ... generating packages for distributions (similar to ruby fpm does), generating other files, snapcraft etc... etc... It's sort of a meta-project really. It also became fairly big which has the ... negative aspect that it takes too much time away. (2) BioRoebe - a project that focuses on bioinformatics, similar to "bio" (BioRuby) but still differently, coming more from a molecular biology point of view than a pure maths-driven bioinformatics point of view. (3) Roebe - this is mostly just for a different mixture of ruby files that I use a lot and have bundled together. Mostly for my own personal use but perhaps others may also want to use this or that code, so they can have a look. My biggest problem right now, by far, is lack of time. I can't easily invest more time into any of these projects (and there are many more) so I had to cut back on some of them.
A newsletter would be awesome but maybe over killing, mail notification for new posts would be quicker and good to have I think. This morning I was re-thinking about the tremendous work you did on dry-rb and Ron: really impressive. Also I think that the work you did on spreading the word and way of thinking behind dry-rb at conferences has been as valuable as well! Do you think you can continue to do it? Together with good documentation, having a strong and valuable "spoke person" like you it is really important for the project.
Even [DHH gave up on that years ago](http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html).
This is so cool. Joining in today
You will get better help in a chat room like #rails irc or [gitter.im/rails/rails](https://gitter.im/rails/rails) or the Ruby on Rails Slack.
I have tried a while loop every which way I can think of and Kattis still won’t accept it even though when I am testing it, I can enter multiple lines and get multiple lines out. The only thing I can think of is not having a real break condition for the input as in past Kattis problems I’ve done, they usually either tell you how many lines of input will follow in the first line, or run until they say “END” or something similar. I think the issue is really stemming from the input having to wait for a blank line of input before it will stop, which I’m wondering if Kattis is not giving it. 
Community over there really is super cool. Glad that it has taken off
You can see the local timeline for that instance. For a Ruby instance, this means the toots are far likelier to be very relevant to your interests. Agreed that maintaining separate accounts sucks. I wonder if Mastodon (or the next big distributed social platform) will allow federated identity so I could maintain a presence at ruby, golang, motorcycles, oss, etc instances while having one "home base".
You should just post the actual gems with what you’re actually trying to do and access.
yay! &lt;3
Yeah, at that point it’s just multiple forums. 
Wait, did I miss there being a motorcycle instance?
No, it was an example of facets of my identity,
Nice!
This platform is useless.
What about a client, that pulled timelines from all of your instances, and put it on one page? I don't know if that exists yet, but it seems feasible.
Yes! I raised an issue on GitHub 😀 https://github.com/tootsuite/mastodon/issues/8558
Thanks!
Modules are a way of having code that is to be reused be used in more than one class. They can be included into a class , the effect is that the code in the module is inserted into the class as if you'd typed it in, so any methods defined in the module become methods on the class. They're an alternative to using a base class. Ruby calls them Mixins but it's really a form of Composition (as opposed to Inheritance) [https://en.wikipedia.org/wiki/Composition\_over\_inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance) (note I didn't read this article, but it probably does a better job than I can). This seems to cover things well. [https://www.tutorialspoint.com/ruby/ruby\_modules.htm](https://www.tutorialspoint.com/ruby/ruby_modules.htm)
**Composition over inheritance** Composition over inheritance (or composite reuse principle) in object-oriented programming (OOP) is the principle that classes should achieve polymorphic behavior and code reuse by their composition (by containing instances of other classes that implement the desired functionality) rather than inheritance from a base or parent class. This is an often-stated principle of OOP, such as in the influential book Design Patterns. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
First, ruby 2.2.0 is pretty old. Use current docs: https://ruby-doc.org/core-2.5.0/Module.html (though in this case the difference is negligible) Second, you also need the supporting docs for class: https://ruby-doc.org/core-2.5.0/Class.html Third, this post really helped me understand the difference between classes and modules: https://stackoverflow.com/questions/151505/difference-between-a-class-and-a-module I particularly like the line "Classes are about objects; modules are about functions." So if I were creating an "animals" program, I might have a module with functions like "run", "play", "eat", and I would include that module in my Cat and Dog classes so when I instantiate Cat, I'll have those methods available. module AnimalThings def eat # eat food end end class Cat include AnimalThings end mr_whiskers = Cat.new() mr_whiskers.eat() Now, because you can't instantiate a module, you can't: AnimalThings.new But you could: AnimalThings.eat So to summarize, you have to call `.new()` on an object before you can use its class methods, you can't call `.new()` on a module and can call the methods just by including the module in your code. Does that help?
Thank you, gonna read through these.
Thank you, this clears things up. Your example helped a lot.
Any particular reason why you needed to go to node for CSV processing? I do some data processing in Ruby as part of my day job, and haven't noticed any particular issues. My input files (various CSV, TSV, fixed-width) are usually in the 10-40MB range (roughly a few hundred thousand records).
There's an excellent talk called [Ruby Internals](https://www.youtube.com/watch?v=NlPxvRSUVQI) by Patrick Farley that goes into the actual C data structures used in the ruby object model if you want a further peek under the hood.
Node is much faster. We had a client with much larger files but the size is not the main issue it's the kind of processing. What took an hour in Ruby takes about ten minutes in javaScript. most apps we still use Ruby but intensive processing (not just file size) Ruby is well known to be much slower.
Are you referring to `class Admin &lt; User`? This is just the syntax for inheritance in Ruby. The `&lt;` is not a "less than", it just denotes the `child &lt; parent` relationship.
The example is wrong.
Ah okay, thank you that clears things up.
Under the hood I will go, thanks!
True, it does depend on the kind of processing. When people mention something being slower in ruby I often wonder if it's ruby itself or if it was just the gems they were using. A lot of the gems surrounding Rails in particular are not necessarily as optimized for speed as they could be, and things need to be handled differently at scale anyway, hence why startups using rails often need to do some optimizing if their business takes off.
A lot of good information here about how modules are used for code reuse. Modules are also important for namespacing, allowing you to keep names and variables separate. This is a weird example, but here goes... module Golf Class Club end end module School class Club end end Class Student include Golf include School def initialize @academic_club = School::Club.new @golf_club = Golf::Club.new end end Without the namespacing provided by the modules you'd start running into some weird situations when trying to figure out exactly which thing you're trying to reference. 
Good point, what was I thinking?
Agreed - namespacing is a hugely important function of modules. E.g., when new classes and functions should be kept in namespaces to avoid conflicts. For example, a particular library which does "natural sorting" needs a `Segment` class. This class (and everything else the library uses) is in a `Naturally` namespace to reduce the possibility of conflicts: ``` module Naturally class Segment # ... end end ``` From [the source code](https://github.com/public-law/naturally/blob/master/lib/naturally/segment.rb#L1-L6) This is is the default style when creating reusable Ruby libraries ("gems"). Every language has some kind of namespace feature - except Objective C! In Java, people take it very seriously, and use namespaces guaranteed not to cause collisions: They use domain names in reverse order. E.g., A Java version of the above might be: ``` Package law.public.naturally; class Segment // ... ```
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [public-law/naturally/.../**segment.rb#L1-L6** (master → ef29888)](https://github.com/public-law/naturally/blob/ef298880bcca8afad794323d788510065e0a7791/lib/naturally/segment.rb#L1-L6) ---- 
No, it's not necessary to include the modules anywhere to access their constants.
&gt; Agreed - namespacing is a hugely important function of Ruby modules. It's probably worth devoting more time to when discussing Ruby modules. I just don't have a good, concise introduction to it. Code reuse makes pretty immediate sense, and discussing '-able' style modules is a good intro to that. Namespacing tends to lead into talking about constants and method look up. I don't have a good way to explain it without just saying "Okay, here's how constants, methods, and looking things up works in Ruby." 
thanks this was very in depth and helpful and helped me find my solution. 
It's a maintainability thing, because it makes the code self-documenting. E.g., instead of just seeing `Segment` and wondering where it comes from, seeing `Naturally::Segment` gives you something more to search for. Also, this helps ensure that my `Segment` won't get in trouble with someone else's `Segment` class. 
That depends on whether you want it to match if there is no middle substring or not. This regex will match on "@@", i.e., the empty substring. If you want it to fail, then change the * to a +.
Well, you kind of do need a lookaround, because the original question was: &gt; how do I refer to this example-only substring "blah@blah@blah" with a regex? For the purposes of `match?` it doesn't matter, but if you want to do something else with *just* the substring, this is the way to do it. &gt; No, it only looks for matches starting at the second character of every line. Likewise $ anchors to the end of line. Yeah, okay, but the \A and \z anchors are ugly, and the real solution is to just to be in the habit of never running a regex against a multiline string where you're trying to extract a substring, because that's probably not what you wanted to do in 99.9% of cases anyway. But I'll admit you're right. &gt; What? Why? What metacharacter is that? Yeah, I dunno what I was thinking with that. My original regex didn't parse, and it did after I escaped the `@` on a whim, but I must have made some other change at the same time because I dun goofed. Oh well. The point was to communicate to people about the use of lookarounds, which aren't very well known but incredibly useful once you know how to use them.
I’d get the book Eloquent Ruby and start there. 
Some of the beauty of Ruby is that you can learn it without having previously mastered any advanced topics. Ruby will scale to your degree of sophistication, and encourage you to develop.
Thanks you for response. love it i started read this book since three days. you thinks is good for advanced topic 
That's a nice primer on the sometimes-mysterious `Symbol` class, but I'm surprised the article didn't mention one of the main reasons to use Symbols -- because each Symbol is unique and has a consistent `object_id`, Ruby uses integer comparison to compare two Symbols, instead of the much-slower String.
Perhaps [metaprogramming](http://ruby-metaprogramming.rubylearning.com/), then?
The documentation can be confusing. I think code examples are best: module Foobar def self.hi puts 'hi!' end end Foobar.hi Here you invoke hi() on the toplevel module Foobar. Without the "self." part, it would be a method that would not be accessible within the toplevel module Foobar name, but you could include it into other classes and modules (or use .extend, too). I personally really "micro-manage" methods without much "magic". That means I usually define toplevel methods, if I want to call them like that: Foobar.hi and then I also may manually add a method that has the very same name but does not have the "self." part. For some reason I found this approach to be much easier (and I subclass quite a bit too; usually all classes I have in a given "namespace" I subclass from class Base defined in that project too).
He can if he uses e. g. "def self.", but I guess he isn't quite there yet in understanding it.
To be honest, I think the best way by far is to just write a lot of ruby code. Then you no longer have to think about "advanced" topics or "meta"-programming: you'll just use what works and reject what does not work.
&gt; rather than glossing over them because you do not understand them. It's not necessary to HAVE to know archaic terms written in dead languages, if he manages to explain the underlying concepts.
Interesting, I didn't know they weren't garbage collected. Seems like JSON.parse(body, symbolize_names: true) has some tradeoffs.
Absolutely - my own take on metaprogramming is "if you're tempted to use it, odds are you've been lazy in your domain modeling". That said, sometimes looking into the abyss makes other approaches seem more palatable. 
For further information, the `==` and `===` operator are effectively using a object-level comparison. But for all the other comparison's methods, it uses the string representation of the symbol for comparison. feel free to check this [C macro](https://github.com/ruby/ruby/blob/22444ae9b1a20e39b7278193f85e4d805bd1d54d/string.c#L10444) for further information
Definitely ;-)
Advanced topics can be considered the following ones: * multi thread applications * mutual exclusion * semaphores * interprocces communication * protocols implementations * socket or serial programming But for now don't turn your attention on somehow "formally" learning that stuff. Focus on picking a good book for your favorite programming language (ruby) and grasp a solid understanding of the language itself. As you build your experience as a programmer through time, you will unavoidably cope with them. Building strong foundations on programming and how programming languages works from a cpu perspective (thread states, preemption and context switches ) is also very important. 
Yeah, and if I recall, this has been a source of some security problems in for Rails in the past. I know for sure there was a heap exhaustion attack of some sort caused by pumping json/form data which had many many keys. Each key got symbolized and so allocated. It’s much safer to convert symbols to strings for lookups, which is how the form tools work now. 
These are not "archaic terms", these are the current industry-standard terms for discussing these features with your peers.
Well, yes, it would be somewhat surprising if `:a &lt; :b` was false because `:a` happened to have a lower object id then `:b`.
This is really interesting to learn. Thanks for sharing this.
Thanks for the clarification!
In Ruby below 2.2 version all the symbols created are not garbage collected.
As /r/world_on_wheels already mentioned, this was only true for older Ruby version. Ruby 2.2 (see https://www.ruby-lang.org/en/news/2014/12/25/ruby-2-2-0-released/) introduced garbage collection for Symbols, so nowadays this is not much of a problem anymore.
I'd file an issue in the github repo https://github.com/davetron5000/methadone/issues
It will give you a solid foundation to make your own determination on what is advanced. When you say advanced, what specifically do you mean?
Check out [shrine](https://github.com/shrinerb/shrine) before re-inventing the wheel! A "file attachment toolkit", flexible enough to do a lot of things (by writing code) without having to re-write the stuff that's already there. 
Rails takes a pretty enormous amount of maintenance to keep it running. I'd be cautious of forking it without a plan for developer hours for ongoing maintenance. I'm frustrated with some DHH/rails decisions too. But it is what it is. I _am_ sympathetic to being very careful about adding new features though. (honestly I think it would have been better to hold off on AS altogether, or to build it on top of something like shrine). 
Use single quotes around '\2 \1'. 
&gt; But the main difference between them relies on the fact that a new String object is created for each called string — even if they’re identical The other difference worth noting is that Strings are _mutable_, Symbols are not. (Which is in fact why there's a need for each String to be a new object, but symbols not, that's the reason for it). 
Definitely will. Thanks so much
I don't think using symbols in your lookup method (ex. `Symbol.all_symbols.include?(:dummy_symbol)` is a good way to exemplify the behavior you want. The moment you use a symbol it will get added to the table, so this example will return true in a fresh irb `Symbol.all_symbols.include?(:DummyClass) # =&gt; true` even if the class was not defined. I think the grep method would be better.
No worries, it's always good to make the implicit explicit. I am (and I suspect others would be as well) referring to [Domain Driven Design](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215). "Domain", in this case, can be defined as the problem space that the software you're writing addresses. The business entities, actors, processes, activities, etc. that your software manipulates.
Thanks for your feedback. But we see above that the resource is explicitly called. Anyway, thanks for the tips 
Thanks for the further information :-)
So in other words, from what I've read and understand, use this namespacing that you have shown me for Ruby modules to avoid conflicts. Is this a best practice or are there links to a Github repo with good documentation on this that you'd recommend? Thank you by the way, you made namespacing clearer and I now have a better understanding of it.
This is a great question, and I don't know of many offhand. TBH, reading the Rails source code is a good exercise: they follow many best practices like these. You can also read about creating a gem (using bundler) — it's not too hard, and will give you practice with this. 
i give it a week before the ruby SJWs join up and start raging on it.
In case if you need advanced level in performance, I would suggest Crystal when you may start to hit the limit or adventurous to write near raw performance, you can progress to Crystal with less code changes. In short, contribute if you think there are more performance you can get near Rust level.
From those for those who can't differ Ruby from Rails.
Alternative use double backslashes: s.gsub(/(\w+)\s(\w+)/, "\\2 \\1") &amp;#x200B;
Sensationalized headline 😐
&gt;GitHub is about a third of the way through an architectural change that began last year. The company is moving away from Ruby on Rails toward a more heterogeneous, composable infrastructure. &amp;#x200B; I say it is pretty sad and accurate. They will still use Ruby, but looks like Rails is no longer part of its future plans.
&gt; Founded in 2008, GitHub became a platform following the introduction of its Developer Program in 2014. The program, which is to say the associated API, allows developers to build applications that integrate with GitHub. It has turned GitHub, which now has something like 28 million users, into a lynchpin for automated code deployment. This sounds like someone fed 10,000 articles about GitHub into a machine learning algorithm and then had the machine write an article.
Unclear. &gt; Ruby still has a place at GitHub – Lambert referred to the company as a Ruby shop, but he said there's more Go, Java and even some Haskell being deployed for services. It's an interesting article either way though. 
I think you've discovered TheRegister's secret!
i like that they're showing presenters with a simple DIY ruby object approach, as opposed to the popular draper. Nothing wrong with draper, but good to know the simplest approach that could work. 
Their right to use a pen ought to be revoked. 
I'm hearing that `pg` and `mysql` now work, so that's great news. Roda may be possible now...
Do they actually work or is it just `bundle install` that doesn't fail now? The table seems to indicate it's unclear, has anyone ran the respective test suites?
I don't work for them, but they gave a talk about this at Kubecon 2017 (which I attended). IIRC their strategy was to bottle the monolith (the Rails app) and gradually roll out microservices--both for new features and for improvements to existing ones. Of course, the joy of microservices is that you can pick the best language/framework for each individual task. 
Also, the pain of microservices can be that each team picked a different language or framework for their tasks :)
Thanks! Lately I have become more and more gem resistant. That said, there are some mainstream gems which I will use without question (i.e., pundit, devise, etc). I've built some large applications which I maintain for lengthy periods of time and the ones that I found easiest to work with were well laid out (skinny controllers and skinny models) and few gems. It makes upgrading the Rails application much easier as well as writing tests. For presenters and service objects, some gems exist to do these kinds of things, but I find them not giving enough bang for the buck to justify adding them into a project. Especially with something like the presenters where it is almost easier to create your own implementation than learning the ins and outs of a gem's implementation.
Thanks for the follow up. I also know GirHub just spent a to of effort getting to Rails 5.2 and they plan on upgrading lock step with master and upstreaming more. I’m hoping they still keep Rails in the mix. I work for Heroku and we re very micro-servicey (though API is mostly in one codebase). The company moved away from Rails a few years for some of the services. The random assortment of Ruby frameworks and ad-hoc fixes makes me sad.
https://www.reddit.com/r/ruby/comments/9b66zw/vscode_versus_rubymine_2018/
Yep, already moved. These GitHub shenanigans are too much to stomach.
Has anyone tried Roda + Sequel yet atop this release?
Very exciting! Once it's released on rbenv I'll start testing it with my gems.
Sounds about how "modern" journalism is done - real journalists with a brain are too expensive for the big megacorporations these days. Plus they may write critical comments which the megacorporations just hate to see.
&gt; they gave a talk about this at Kubecon 2017 They can do promos but internally you can not know whether this is the case. By analogy you would claim that this was already decided in 2017 that ruby will be eliminated. And I am not sure you can infer that from a Kubecon talk that evidently caters to Kube-folks who want to hear success stories that cater to their point of view ...
What matters is the story you made up rather than what really happened or will happen? Why is that what matters to you? The article literally says they are still using ruby, btw. 
What is even more sad is that Microsoft claimed they won't change GitHub. Now that's the first sign that they do change GitHub - by killing ruby there. Well done Microsoft! I am looking forward for more empty promises.
Wait, what shenanigans? Are you calling architecting based on Go and Kubernetes "shenanigans"?
I also posted this two hours earlier at: https://www.driftingruby.com/episodes/rails-presenters reddit didn't notice it as a dup since you included all the utm stuff here. 
skinny controllers and skinny models and few gems -- where's the code then? :)
No one has killed ruby and no one will kill ruby. I don't know what empty promises you're referring to. This is a weird non thing to get emotional about. 
I hope this project does well, Ruby deserves a decently fast execution environment. It's such a nice language.
I don't need to claim anything; you can [watch the talk yourself](https://www.youtube.com/watch?v=OgRHIZt8Yy8). 
Typically, I will break them out into separate folders within the App folder. Service objects would go under `app/services`, presenters under `app/presenters`, etc. They're still classes, but it opens for better organization. Within each "idea" of an object, I try to namespace them and name the classes appropriately so that when you are using then within the codebase, it is clear to what they're referring to or at least which file. I'm okay with a project with a lot of folders, but I dislike having a lot of files within a folder.
*Ideally*, details like implementation language would be hidden/abstracted away from other teams interfacing with those microservices by API. (Though practically speaking, it rarely seems to pan out that way)
I'm not sure I follow. A microservice may or may not be horizontally scalable - microservice just means that its functionality is very narrow in scope. A service (micro or not) generally seeks to hide its implementation details - I guess I agree that's contingent on good design, but if you need to interact with a service like it were a library, then it's missing the point of being a service. I don't see why good design is harder with more fragmentation, but the lens that I'm looking through it is an appropriately scaled company with right-sized services (there are enough owners to thoughtfully own and design each service). The opposite is also very true; if you have a monolith service, it's difficult to improve on design with newer features (consistency and compatibility usually trump "better").
Hello everyone! I just wanted to let everyone know that Ruby and Rails isn't going anywhere anytime soon at GitHub. The "monolith" - as its referred to internally - is exactly what it sounds like: a massive Rails application that has barnacles and rust (the stuff that gives you tetanus, not the language) all over it. As you can imagine, any 10 year old codebase will accumulate. As such we're working hard to make sure we can continue to scale the platform for at least another 10 years. But, we also plan to upstream (almost?) all of the patches and hacks we've built over the years to scale our codebase to the bounds of which hopefully most of you use nearly every day. @eileencodes' and @tenderlove's talks at RailsConf this year were a glimpse of that direction. And while I can't say Ruby and Rail's future is secured (forever) here, I can say at the very least that we have plenty of years left of working with the community to help make Ruby and Rails scale to the size GitHub has become. Everything Sam is quoted saying in this article is accurate. I just wanted to add some clarity to any GitHub Ruby and Rails FUD that came up as a result. There's no way around it, we owe our success to the Ruby and Rails communities &lt;3
In the context of the conversation, I assume microservices to imply multiple computers, as where I monolith tends to imply one. If microservices just means small pieces of a larger single language program, then I do don't have a name for that, those tend to be candidates for libraries. My point was that distributing your service tends to make it harder to have good domain abstractions, as doing so introduces lots of complexity around networking. I'm just saying, if you can keep your app a single program, it's easier to see complexity in the overall system, microservices, at least the idea of distributed computation, solves issues relating to redundancy, scalability and latency all at the expense of understandably. Or at least, this is what I have seen. 
Does this have anything to do with Ruby's performance and type system ? Because if it does then we are just waiting for TruffleRuby/GraalVM,Ruby 3x3 and sorbet.rb to happen right ?
Are there any experiments or R&amp;D with stuff like TruffleRuby/Graal and/or Jruby ? Do you guys work with the Stripe folks on sorbet.rb ? With the decrease of Ruby/RoR popularity due to these issues I can tell why even a successful company might venture into other languages to attract new engineers. Maybe it's too late to get Ruby back on the rails (pun intended) but just hope with the new stuff coming into the game we will see the renaissance of Ruby. Did you guys try Crystal or any other Ruby's spiritual successors ?
plain is a method, and so is puts. They each take an argument and they’re both converting that argument before passing it. You’re passing a kind of “shorthand” version of a hash
params are nested structure and in your case params[:article] keeps hash of article’s attributes, like name etc. In second case, that would be puts { name: “reddit” } but as I remember braces can be omitted when it’s the last argument. Hope it helps, if no feel free to ask.
Looks interesting and it’s always good to have simple solutions to problems like this. Documentation wise, could be useful to have short paragraphs about the problem (even if it’s a quote from Wikipedia) and also a more detailed description of what the inputs are in your examples. I’ve got something that I’m going to try this out in, I’ll give you some more detailed feedback when I do!
Appreciate the feedback! Good suggestion, I can see how a background on those problems would be useful. I'm trying to strike the balance between providing enough detail but at the same time not cluttering up the README - I suppose there's an art to that :)
&gt; braces can be omitted when it’s the last argument. This helped me to understand what to Google, thanks. For any future visitors, heres a link: https://stackoverflow.com/a/35666821 
rvm also works.
If some gem is not working, provide them with an issue report - they are *very* welcoming to such issues. My gem "hexapdf" didn't work at all with RC5 but works quite fine now with RC6 :)
No TruffleRuby/Graal, Crystal or JRuby here (that I'm aware of). For the most part, new services are being built in either Go or Java. We have existing services in Ruby, Go, Java, C , C++ and even Haskell. There may be others but those are the languages I know of.
Why is that ? Due to immaturity of the mentioned technologies or a general move towards C like languages ?
Ruby Hashes basically. You’re passing a hash in, not sure what other behavior you’re expecting. Your function takes an argument, and you’re defining that as a hash 
&gt;4 comments To be honest..... I don't see much wrong with the writing, except for the terminology. 
I just learned that a Hash written like this is called a 'Bare Hash.' But, of course you're correct too.
My guess would be, they have grow out of Ruby's comfort zone. And they are going to need some help from other tools and ecosystem. &amp;#x200B; I was a little sad because I was hoping Github could leverage Microsoft to pour in some resources into Ruby MRI or testing TruffleRuby. If you look at TIOBE Index, which of the Top 10 / 12 programming languages does not have a major cooperate backing? Only Ruby. Everyone on top had Microsoft, Facebook, Google, Apple's backing. &amp;#x200B; And speaking of TIOBE Index, Python enters top 3 for the first time in history. &amp;#x200B;
[https://github.com/oracle/truffleruby/blob/master/doc/user/ruby-managers.md](https://github.com/oracle/truffleruby/blob/master/doc/user/ruby-managers.md)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [oracle/truffleruby/.../**ruby-managers.md** (master → 0c06f0b)](https://github.com/oracle/truffleruby/blob/0c06f0b6e378e2e40289fa85b1500a1aae9105e6/doc/user/ruby-managers.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e5d82gj.)
The success of Python is really good for Ruby because it shows you can create very complicated projects in dynamic languages. It's good to know whenever someone tells you YOU GOTS to have typing to write good code.
This hasn't been released yet… but the authors have said that getting `pg` and `mysql` working is what was needed to essentially get Sequel working.
These are release candidates for 1.0 — rc5 is the latest and rc6 (which this post refers to) is the next. I'm guessing they will shoot for Rails to work by the time 1.0 final comes out?
\&gt;btw didn't Facebook actually implement it's own PHP called Hack? Yes and they are moving a lot of those work back to PHP. &amp;#x200B; And cooperate backing is not only speed, but the ecosystem as a whole.
&gt; even Haskell. How long do you give it until we drown in blog spam about Github moving to Haskell like we did with Facebook a while back?
Oh it does make a lot of sense. I also work on a huge Rails monolith. Github is one of the most stable services Ive ever worked with on a daily basis. It is proof that it can be done. Take any stack, compiled, static and build and run it for 10 years. Then make conclusions. Btw I do like Go and Java and others. It just not true what you say. 
Looks pretty cool, this sounds like a [constraint satisfaction problem](https://en.wikipedia.org/wiki/Constraint_satisfaction_problem). I've sometimes wished for a Ruby library for solving them, but they're quite difficult. Dependency resolution is an example of a CSP, I think the problems you mentioned are also examples of CSPs.
**Constraint satisfaction problem** Constraint satisfaction problems (CSPs) are mathematical questions defined as a set of objects whose state must satisfy a number of constraints or limitations. CSPs represent the entities in a problem as a homogeneous collection of finite constraints over variables, which is solved by constraint satisfaction methods. CSPs are the subject of intense research in both artificial intelligence and operations research, since the regularity in their formulation provides a common basis to analyze and solve problems of many seemingly unrelated families. CSPs often exhibit high complexity, requiring a combination of heuristics and combinatorial search methods to be solved in a reasonable time. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I don't think the gem does any of the things you are needing. The syntax highlighting, while not quite as good for Ruby, is automatic in VS Code. As far as the other needs, do you have a tool in another editor/ IDE that does these things? If so, I'd continue to use it. I handle most of these activities from the command line. The actions the gem does perform linting, intellisense, etc. are reasonably reliable, but not perfect.
what?
My first thought is that rendering json response in params method is not the best idea. I believe that it should be controller’s action responsibility. Also this return in code looks tricky and makes code hard to follow. Honestly, I would stick to rails scaffold in that case, currently code is overcomplicated imho. If you really need params validation, maybe that would be good to introduce some separate class to take care about that and later use it in your controller action. It shouldn’t do anything with json response though, just single responsibility - validation.
You should validate the presence of attributes on the model [https://guides.rubyonrails.org/active\_record\_validations.html](https://guides.rubyonrails.org/active_record_validations.html) &amp;#x200B; Also, your movie params should look something like this. `def movie_params` `params.require(:movie).permit(:title, :other)` `end` &amp;#x200B; No need to permit id since that most likely isn't going to be updated.
i did that but still got rc5 today. is rc6 officially out?
Thanks, that makes sense. I guess it would be better for `movie_params()` to return true/false and the Controller can the handle the response itself, maybe something like ``` def create movie = movie_params # Params aren't valid if !movie params_error return end movie['image'] = TMDB.find_movie(movie[:tmdb_id])['poster_path'] @movie = Movie.create!(movie) json_response(@movie, :created) end ```
``` class A def method puts "!" end end class B end b = B.new(b.method) ``` Is this what your code is supposed to look like? `b` does not have a method to it -- it's an empty class. What are you trying to achieve?
ya, im just trying to be able to call the method from A from a new instance of B
so in Ruby, there are two types of methods when talking about classes There are `class methods` and `instance methods`. A `class method` can be called without creating a new instance of the class. You can define `class methods` like so class Foo def self.method puts "I'm a class method!" end end Foo.method # =&gt; "I'm a class method!" What you have is an instance method. It **requires** an instance of the class A to use. class Foo def method puts "!" end end bar = Foo.new bar.method # =&gt; "!"
I'd say a bit of both.
I used to work with some of these in college, and they are always a bit more difficult to implement yourself than you'd imagine. Sure there are known algorithms but handling every edge case while implementing them, data input validation, and performance are always a pain to do yourself. Glad OP started a library package that abstracts that away. 
TruffleRuby is part of a larger project called GraalVM. GraalVM is moving towards a 1.0, but some of the languages in GraalVM are at different stages of completeness. GraalVM is definitely 1.0 for Java and JavaScript, less so for R and Ruby, definitely less so for Python.
Just use rescue\_from on a controller level [https://api.rubyonrails.org/classes/ActiveSupport/Rescuable/ClassMethods.html](https://api.rubyonrails.org/classes/ActiveSupport/Rescuable/ClassMethods.html)
That's perfect, I didn't know that was possible. Thanks a lot!
Yeah, I had the same experience. I spent a long time building an implementation, even bought a book on the subject, and ended up throwing it away for a more naive approach that worked just a tiny bit slower. I have repeatedly found problems where I think "Oh man, this can be modeled as a CSP!" and wished there was a Ruby library. I agree it's great to see people like OP working on things like this.
Again very aware of whats behind truffleruby. Not a newb and have been following bit for quite some time. TR is however it's separate wing project. You don't normally give 1.0 status to one project because a sperate project is at 1.0. Guaranteed I am not the only one - an actual 1.0 without operability with a basic rails setup will be confusing. Perhaps that's to be added but then RCs don't usually get announced with needed features missing.
Thanks for your feedback. I've updated my article accordingly. :-)
Sinatra is a good place to start. 
I think there must be some confusion here... I initially thought that GraalVM was at 1.0 RC6, but then I did see that TruffleRuby may be labeled at 1.0 RC6... Maybe. The release page is curious in the way it's labeled: "TruffleRuby - GraalVM Community Edition 1.0 RC6"
Don't forget about [Grape](https://github.com/ruby-grape/grape)!
Rails is overkill IMO. I'd prefer Sinatra and Grape.
&gt; Rails is overkill IMO. When you say overkill, what do you mean exactly? Memory footprint? Response time? The benchmarks I've seen, do not show any difference that would be relevant except for systems with a really high load. Besides, OP did say nothing about the amount of business code their service will have. 
If you want B to have the same general behavior and state as A you can make it a *subclass* of A and then specialize it as needed. class A def methodA puts "Inherited from A" end end class B &lt; A def methodB puts "Defined in B" end end b = B.new b.methodA # =&gt; "Inherited from A" b.methodB # =&gt; "Defined in B"
For more complex regular expressions, I tend to split them into named parts, recompose them, and also use named captures instead of group indices: ``` CHAPTER_RX = /(?&lt;chapter&gt;\d+)/ ANCHOR_RX = /(?&lt;anchor&gt;s\d+(\.\d+|))/ LINKTEXT_RX = /(?&lt;linktext&gt;([.\w\-]+|))/ FORMAT_RX = /#{CHAPTER_RX}:#{ANCHOR_RX};#{LINKTEXT_RX}/ ``` and then: ``` line.gsub( FORMAT_RX ) do |_| chapter = ChapList[$~[:chapter]] anchor = $~[:anchor] linktext = $~[:linktext] %Q{a href="./#{chapter}##{anchor}"&gt;#{linktext}&lt;/a&gt;} end ``` 
If you mean REST then check out https://github.com/sammyhenningsson/shaf. But if you just mean an HTTP API (or want the implement the hypermedia part yourself) then I think roda is a good choice.
I am glad Ruby received so much love from you Chris. It definitely must have been a harder sell than to fully focus on Python due to disparities in popularity.
https://blog.eq8.eu/article/rspec-json-api-testing.html You don't need any gem. Just {id:123}.to_json Applies for Rails, Sinatra or for plain Ruby API
I'm not sure where in your stack the error is being hit but the problem appears to be the space in the path at "Rails Installer" - space is not a valid character in posix paths, which is why bash complained about "D:/Programming/Rails: bad interpreter: No such file". You can normally just escape the space like like "Rails\\ Installer" when calling something directly but I'm not sure where you would do that with your setup.
Note that block passing has been optimized in Ruby 2.5 (see https://talks.gettalong.org/2018-08-viennarb/talk.html#/5) and block invocation will be optimized with Ruby 2.6 (see https://talks.gettalong.org/2018-08-viennarb/talk.html#/10).
Not sure what you’re finding so difficult with Rails. The Rails documentation is very good and there are countless tutorials out there. Are you building something from scratch or trying to get to grips with an existing app built by someone else?
Slow down and read the documentation. The file structure of Rails is a well known entity. The sooner you stop fighting Rails and do things "The Rails Way", the easier it gets. Convention over configuration. If what you are doing is "hard", you're probably doing it wrong. Step back, rethink, read some docs, try a new approach. That's not to say that you won't tackle tough programming problems, but if it's Rails itself making it hard, your probably doing it wrong.
Depending on the scale of your application and whether you want to create a dynamic or static website, you might want to consider frameworks that are a bit more lightweight than Rails. &amp;#x200B; I suggest trying out Sinatra. It's probably one of the easier smaller frameworks to start with, cause it's pretty barebones and abstracts a lot away from the underlying Rack configurations. &amp;#x200B; Although Sinatra is a lot smaller and easier to start with, you'll have to set up and configure a lot of stuff yourself. You'll eventually find that a lot of this stuff is offered by Rails out of the box, and that's one of the big things that makes the bigger frameworks more useful. &amp;#x200B; You can find templates, skeletons and generators for Sinatra applications with a quick search though. Additionally, there are frameworks like Padrino that are built on top of Sinatra.
TL;DR: backreferences won't work. You can use something else, like block form as others suggested. I see where the confusion might come from, though, so I'll try to explain. It's kind of a timing issue: you can't manipulate the match values with the backreferences (like do math, or use them as array indices) because at the moment of calling `gsub`, they haven't been replaced by the matches yet, they are just the literal `'\1'`, `'\2'`... strings. Let's say you have this simplified version: `line.gsub(/(\d)/, "link to #{array['\1']}")` (By the way, your code was not actually trying to read the array, it was just writing its name inside the string. To interpolate a variable in a string you need the enclosing `#{}`.) Before actually calling `gsub`, Ruby needs to resolve the parameters, so it evaluates `array['\1']`. When evaluating this, this `'\1'` means nothing special to Ruby; it's just a normal string. Therefore, Ruby throws an error because you can't use a string as an array index. If you decide to turn it into an integer by doing something like `array['\1'.to_i]`, Ruby is first going to do the integer conversion. But again, at this point, `'\1'` is just a normal string, and is also not a number, so Ruby will return 0, and this is always going to result in the first element of the array. Even if you tried to use the globals `$1`, `$2`, etc, it wouldn't work, because at the moment that they are evaluated, the regular expression was not matched yet. That's why you need to use `gsub`'s block form or some other approach, for instance matching first and then building the result: ``` /(?&lt;a&gt;\d+):s(?&lt;b&gt;\d+\.\d+);(?&lt;c&gt;[.\w\-]+)/ =~ input '&lt;a href="./' + ChapList[a.to_i] + "##{b}\"&gt;#{c}&lt;/a&gt;" ```
You should also have a look to Hanami: r/http://hanamirb.org/
Think it’s related to this. https://stackoverflow.com/questions/35545361/rails-the-system-cannot-find-the-path-specified Had same issue with rails installer before. 
We moved to [Hanami](https://hanamirb.org/) months ago and haven't looked back. We've been Rails-free for almost two years now; before Hanami, we spent a year-plus doing [Roda](https://roda.jeremyevans.net/), which is still a viable choice for API apps and will be familiar to those coming from [Sinatra](http://sinatrarb.com/). Rails, to quote /u/apotonick in his (excellent) [Trailblazer book](https://www.reddit.com/user/apotonick) (which you should read as well), put it well: &gt; For every Rails project, there is exactly two outcomes. Either someone in the team’s an experienced architect and leads the software to an advanced design with service layer, view components, maybe forms, and so on. Or, and that’s the classic way, the project strictly follows the Rails Way and will end up as a code disaster. &gt; &gt; Explaining why a conventional Rails architecture fails is simple: There is no architecture. &gt; The fatal delusion that three abstraction layers, called “MVC”, are sufficient for implementing complex applications is failure by design. I _love_ Ruby; I've been using it as my primary language for nearly 8 years now. But for the last two of the five years we had Rails code in production, when people asked what I did for a living, I said I "mitigated Rails". That is as accurate a statement as I can think of. *¡Sal si puedes!*
i have some experience with Sinatra, but non in with rails. Going to try the option you mentioned, but i'm afraid of injecting to much dependencies into the project.
I wasn't aware of that. Will drop some effort in.
I would argue that Roda has _more_ features than Sinatra. Here is my view: If you want * if you want a framework that chooses the dependencies for you, use Rails * if you want the comfort of a popular alternative framework, use Sinatra * if you want the most flexibility in routing and many features, use Roda * if you want to have structure and conventions different than Rails, use Hanami * if you like DSLs and want to have features tailored for REST APIs, use Grape
I would say that one overkill is the separation of routes (`config/routes.rb`) and logic that handles those routes (`app/controllers/*`). # config/routes.rb root to: "home#index" # app/controllers/home_controller.rb class HomeController &lt; ApplicationController def index # this handles `GET /` requests render json: { docs: "https://my-app.com/link/to/docs" } end end What's nice about frameworks like Sinatra, Grape, Roda etc. is that routing and request handling are in the same place, and you don't need to invent controller action names or anything. With Roda they are even in the same execution context (the Roda instance), which I particularly like. get "/" do { docs: "https://my-app.com/link/to/docs" } end Another overkill for me is the complexity. Rails is significantly more complex than other popular Ruby web frameworks, and I think it's harder to justify it when you're building a JSON API (and you don't need all of that view logic). I don't believe that web framework speed – request handling specifically – plays a difference in the overall performance of your app. However, with Rails, ActiveRecord is also considered a part of the web framework, and [it's been shown](https://samsaffron.com/archive/2018/06/01/an-analysis-of-memory-bloat-in-active-record-5-2#comments) to have worse performance than the alternatives (Sequel, ROM), and often when you need speed you have to drop to raw SQL. And database interaction does play a big role in the performance of your application. Sure, Rails lets you swap ActiveRecord for Sequel, but (a) it will be difficult to convince your team, and (b) most Rails gems work only with ActiveRecord (e.g. ActiveStorage). So, at that point you might ask yourself if staying in Rails is still worth it.
I see exactly what you mean! This is a fantastic explanation. I need to read up on gsub's block form. Thank you!
Gotcha. The first block is setting up the patterns each capture group handles and assigning them to a handler/variable name. The second block is using those names to find and substitute the relevant data. Is that right?
I read that but didn't really understand it before. I guess that's what I get for trying to write something with a limited experience with the language. 😁 Thank you!
If your expectations are just simple console commands, calculations then yes stick with ruby. However there’s actually a lot of components to take care in a production web app. You might want to try to build all that stuff from scratch if you think rails is overwhelming. But soon enough you will just stumble upon problems that rails have already solved for years. And your own solution probably ended up giving more problem to you then it solves. If you’re ready to delve, I suggest you try with scaffold command and see what it generate for you. These are basic convention that rails provide for a quick start.
Yes. It isn't really necessary to split the regexp like in the first block, but I think it's more readable than a long regular expression. In the second block, the `$~[:some_symbol]` expressions refer to the named capture groups, but of course it's also possible to use `$1`, `$2`, instead. The important thing is that `ChapList[x]` is a lookup that cannot happen without a gsub block.
Check out dry-rb 
Aside from Rails, one frustration you're describing is gems. You use libraries in every language, so it's no different here. Fortunately Ruby allows you to see where a method is defined using `source_location`. For instance, the gem colorize allows you to easily output colored text to the console: &gt; require 'colorize' &gt; puts "1".red 1 # trust me, it's red on my machine :) &gt; method = "1".method(:red) =&gt; #&lt;Method: String#red&gt; &gt; method.source_location =&gt; ["/Users/fiveguy/.rbenv/versions/2.4.4/lib/ruby/gems/2.4.0/gems/colorize-0.8.1/lib/colorize/class_methods.rb", 97] And, no, you don't need to use gems, but a lot of times they do make life easier.
I give talks on this all the time - there are so many framework options that aren't Rails out there. My fave is Sinatra by far, but if you need something more fully fleshed out, go with Hanami.
This was on 2.5 and block passing wasn’t what was being evaluated. :-) Also, the 2.6 `Proc#call` optimization isn’t significant enough to make much of a dent in these benchmarks. The `call`able PORO is still faster.
Thanks. Following up: I use VSCode and not an IDE because that's what I prefer. I don't like RubyMine, have tried it again several times. I definitely don't want to learn emacs or Vim. I really like VSCode. **Let me dial back my question: I just want to execute a screen full of Ruby. What's the lightest weight plugin for VSCode that is reliable?** 
Your expectations were not properly established. Ruby is a language. Rails is a framework for building dynamic web servers. Those things are radically different.
How is the performane of hanami compare with rails?
Did you set the PATH properly?
You'll have to solve *different* architectural problems if you switch to Hanami. Rails is built on a lot of flawed ideas, and Hanami addresses some of them. Hanami teaches us to work with database, validations, enterprise domains and entities. Unlike Rails, Hanami doesn't teach us to be reckless about our data. That's a lot better
&gt; The ruby office is one guy, he's real nice, a gentlemen, his name's Nigel (always a good name) and he gives you one paper. "Once you read through that, I'll come back with another and your favorite tea. Also my secretary does the office-ly blowjobs if you're into Lewinskis. Was the edgy water cooler joke necessary?
I have an with issue taking rails in as one big thing and consuming it, understanding it, and feeling like I can take drag it from my brains "What I know &lt;i&gt;about&lt;/i&gt;" and "What I understand." I can do that with Ruby, it's just a big "RUBY" file in my B:/ (brain) drive. In the head directory are all the common classes - within them methods. And any time I run into something I don't know how to do, I know exactly how to find out - a method search in Ruby, a trip to the old ruby docs... Ultimately, it's like &lt;i&gt;I really didn't&lt;/I&gt;, NOT know how to do it, it was just in a larger, higher brain drive called W:/ (The WORLD) And I need special permissions to pull data from it. I had the Ruby directory created from the first file that went into it. The first Rails files moved to my brain drive was how to make a scaffold -- much bigger file, immediately I'm adding in 100 different relationship files on top of it (What order are inputs of the command, what git am I in, what directories does this effect, is it writing an existing file or creating a new one...) I've learned a lot, but I don't know how it all clicks. Yes, I get MVC, I understand things go to the routes, the routes gets the actions, all that stuff. There's gotta be something I'm missing. Here's my biggest issue, despite all that I've learned, I can still only monkey-see monkey-do to get things done. Maybe that's the nature of Rails? At least, for the first some months/years using it? I'm the type that likes to take a tool I learned how to to use and then use it for my own purposes - once I can do that, I get it, I'm confident with it. Maybe there's something I'm not getting, conceptually. I know that my own advice, for myself, would be to learn more. 
I had a very similar experience moving from non framework Ruby to Rails. I think a large portion of what you are experiencing is the complexity of web frameworks, but a small portion is related to Rails magic and convention. If you're learning Ruby for fun, you could consider starting with a micro framework. This lets you start small and see how the pieces fit together. When/If you move back to a full framework, you'll have a better idea of what is going on under the hood. If you want to stick with learning Rails, do some research on how it works internally and like others have stated, get intimate with the documentation. Once you get the hang of it, it feels more ruby-ish.
Yeah I'm working on a website, it's a special idea, I'm somewhat protective over it even though it's not a laser-guided diamond cut "new idea." It's one of those idea like... the toaster oven. The toaster existed, the over existed, the guy that created the toaster over wasn't exactly revolutionizing home appliances. But I know this: I have a toaster oven and I probably use it more than my non-toaster over. The reason I'm learning Rails is because I'd like to create this idea myself, at least a prototype of it, and then try and generate funding/build a time that can help me with it. It's a complex website, but it uses a mix of mostly solved problems. I just need to take the solutions and make them mesh. So here's a bit that you might get, or at least remember understanding when you were new - I don't know what the long term effects of what I'm doing are. If I create a new controller/model called user, and I set the whole thing up, will I have to recreate it everything I do with User if I end up deciding to go the Gem way and set up users with devise? I don't know where the application is going to go, in the nuts and bolts of it, I just know what needs to be output to the screen. It's just a bit overwhelming, a lot of the data I research is referencing other data I haven't researched. What documentation do you recommend? I haven't look much into the flat documentation, a lot of what I've done are these "monkey-see, monkey-do" tutorials. along with a bit of reading from source's like Hartl's guide. 
if you dont have `enterprise domains and entities` you cannot work with databases. Let's not go in some cargo cult about how to write code. Code is code, you can write code, bad code, you can have a good design or bad one.
office_boy, *Although Sinatra is a lot smaller and easier to start with, you'll have to set up and configure a lot of stuff yourself. * But wouldn't knowing how those things work help you in other areas that you will always have to customize? Or is it the type of info that you learn, put in your brain's "temp" file, (which deletes all unaccessed information in sleep mode after X amount of days.) 
Looking into it!
Relieving words. I didn't want to learn any entirely new language in hopes that their equivalent of rails might be more suited to how my brain does things. I'm a big concept guy, you can give me simple directions and I will mess up the execution easily, I might follow the directions too literally, or not understand something implied. As a 'big concept type' of person, my brain works by solving the problem on it's own and then delivering the steps (not quite so... computer-ey though). Then any step-by-step instruction are either obvious and the directions don't need to be well stated, or I can go right ahead move towards the goal without instruction. This applied strongly to my work in blue-collar contruction but is true in the land of 1's and 0's, and anywhere else you put me. I think a lot of people's brains work similarly.
I understood that. I've been told that programming is hard, for the most part, my whole life. Since I've been in the space, I was told Rails makes everything easy. However my experience was the reverse. Making things easy is rails is precisely the issue I have with it. Not understanding the roots of how things works means trouble when it comes to doing those things your way. I have a lot to learn before I can say anything more.
application design. That is a big word and quite generic. Rails, hanami, etc library or framework give you the tools IF you understand and use the library properly
I agree with you on the point about learning more about configurations and customisations on the different components as a web application. I actually started out Ruby web dev with Rails, but after spending a couple months working on a few Rails apps, I came across a few things that I didn't like. The main things I didn't like was that there were way too many configurations, yet it still felt like there was too much work being done behind the scenes that I didn't know about. So I tried Sinatra and liked it, because like you said, you feel like you understand how every single part of your application works (in more detail than you would with a Rails app), and this in turn makes it easier to customise your app. So I've stuck with Sinatra and never really touched Rails again. It's up to the individual to decide whether the Sinatra approach of having more control and understanding of your application, is better than Rails. But anyway, it doesn't hurt to try replicate an app you've previously built on Rails, as a Sinatra app. Just to see how it is.
Don’t let that bother you, we all are beginners at first. You just need to get the “ruby feel” and you will find yourself doing great stuff. You will enjoy it! 
Are there any other more in-depth articles on this subject someone could send me a link to? It would be much appreciated. (Book recommendations encourages as well)
Glad to be of service Nick. Yeah, There is no need to jump to another language. I learn similarly and had almost identical issues starting out. In the beginning phase of working with Rails, you may have to accept not fully understanding every detail of what is going on and roll with it. As you're building your project, if you hit a topic you can move forward without entirely understanding add it to a list. Bore into the list of topics one by one as time allows. The Rails Guides are an incredible resource for this, as is The Rails 5 Way book. If you haven't already completed a full tutorial on Rails, I highly recommend the Hartl tutorial. Keep at it!
This has been similar to my use case; although I don't hate rails. I am mostly neutral about it, there are pros and cons about that part. My biggest problem with rails is how boring it was - and is. I never managed to overcome that. I never had this problem with ruby. Ruby itself is awesome, though not 100% of ruby is great. You gotta pick what is great and ignore the rest. As for the other part: &gt; Can I set up a website with just Ruby and the HTML family? You can give things a try. Try out .cgi too, even if it is outdated - I don't mean the ruby-cgi part but to use dynamic generation of HTML. I do that still up today. I used PHP before I switched to ruby. When you feel fine with .cgi, just move to something like sinatra + padrino. I doubt you need the whole stack of rails really. I used ruby + www from day 0 when I switched to ruby and I haven't really used rails (aside from the intro-tutorial and building that webshop which was so boring that I stopped with rails).
THANK YOU SO MUCH! I have a sample application running now through Hanami. This is way simpler - can much more easily see what's going on. I like the split between abstracted stuff and what you customize. I wish I had known about this some time ago! Again thank you!!!
&gt; I think a large portion of what you are experiencing is the complexity of web frameworks I agree with your comment. But I think in general, there is a lot about the www + frameworks that really SUCK. Even without rails. JavaScript sucks immensely. I am surprised how people can write great things with it considering how it sucked. I can not even decide what sucks more - PHP or JavaScript (they are currently competing who is used by more, e. g. on TIOBE and Google Charts; it's interesting to me considering the fact that PHP was well above JavaScript a few years ago). 
As an aside, your lewinski remark is off-topic and unprofessional.
I wrote an [article](https://itnext.io/happy-users-uploading-files-with-rails-5-shrine-and-vue-js-bbcc470a327f) that covers Shrine pretty extensively. One of the problems with presigned URL tutorials is they fail to mention authenticating users before letting them upload whatever they please to your S3 bucket. There is the misconception that 'presigned = safe' but that isn't what it means at all. It only means the client uploads directly into S3 instead of your app server using just in time credentials. There are so many web apps out there today you can turn into a public storage bot because not enough discussion goes into securing presigned upload url requests.
it isn't rail's fault if you code it into a disaster.
Really no different for S3 than uploads anywhere else though, is it? Are you worried about the fact that S3 URLs can be directly accessible without going through your app? They can be, but you can turn that off and require signed URLs to GET too. Which is worth mentioning, but simple. Then it really turns it into exactly the same authentication/misuse issue as it would be with uploaded files regardless of S3, I think? S3 being involved doesn't really make things any different/worse. 
&gt; Really no different for S3 than uploads stored anywhere else though, is it? It is different in that it is partitioned from the rest of the app. That adds a layer of concerns that would probably happen automatically in most app frameworks. The article doesn't discuss S3 security policies and I feel that is really needed to complete it. &gt; Are you worried about the fact that S3 URLs can be directly accessible without going through your app? I know you can also send the client a JIT signed url for any request to an S3 bucket. That still requires your app server and two requests. The article doesn't discuss how you authorize even handing out those URL's to begin with, or even mention if one should do that. It's an important point that should get developers thinking about signed URL's. To summarize there are three key things to point out: 1) Use SSL/TLS on your app when requesting signed url's so that a man-in-the-middle and cross site scripting attacks are avoided. 2) Authorize uploads for users before handing out a signed URL. This should either be via authentication in the app server itself, role check, etc. But something in the app server should ask 'is this allowed?'. I see too many times people are adding a direct upload endpoint to their app without any authentication/authorization behind it. That's the core issue with these articles. 3) Use a solid S3 security policy that uses authenticated requests. Even better use Cloudfront and get granular control over what comes out of the bucket. Refs: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-signed-urls.html https://labs.detectify.com/2018/08/02/bypassing-exploiting-bucket-upload-policies-signed-urls/ https://www.fusionbox.com/blog/detail/security-in-layers-preventing-xss-attacks-with-aws-s3-direct-upload/638/
Lots of people don't like Rails. But try to build a web application with something _other_ than Rails and then come back before you set your opinion in stone. :)
If you do want to learn how Rails works, start with the [guides](https://guides.rubyonrails.org/) -- they are narrative overviews of the various parts of Rails, targetted at an audience which are experienced programmers, just not with Rails. There is indeed a lot of code in Rails. But that's because it does a lot. Some people don't like Rails, and you may be running into some of what they do -- but I also think you're just running into the fact that complicated software is complicated. Once software gets past a certain level of complexity, in my experience, looking at the source code isn't enough, you need some narrative overview documentation. Fortunately Rails has some pretty decent docs. 
as for ruby and rails? Yes, I have already created apps with rails - or are you referring to something else? &amp;#x200B; I'm not sure if i can use shopify\_app from 2.5.1 - i tried reverting to 2.3.3 didn't seem to work. &amp;#x200B; I put the D:\\Programming\\Rails Installer\\RailsInstaller\\Ruby2.3.3\\bin didn't work &amp;#x200B; tried: D:\\Programming\\Rails Installer\\RailsInstaller\\Ruby2.3.3 also didn't work.. &amp;#x200B; that's correct right? &amp;#x200B; As far as using the WSL - which is normally how i use ruby/rails.. I honestly don't know how it even operates because none of the files are in the PATH - but it works.
Dang. i still haven't found a fix for this. I was warned not to use ruby from windows. - though, there needs to be a fix for this. &amp;#x200B; All i'm trying to do is connect shopify\_app
I get you. The thing about rails is it hides a lot of things into the background. Which means as a beginner it will all seems like magic. However to expose the magic, there’s a bit more effort to do than to just follow convention. You either can open up the rails console or display the output in view. You can also learn a bit about classes &amp; class inheritance in rails. That’s where it all hides. One thing that’s useful to me while learning is this tool called Dash for mac, where you can just look up any classes or methods in rails with a keyboard shortcut. There might be similar one for other OS.
Also have look at Form Objects or how ActiveRecord #save works when you have validations in your model. Much easier approach!
Sounds a lot to me like you need to get yourself up to speed with the basic concepts of Rails. I suggest something like Code School, which tries to teach concepts as you essentially copy what they do. Other than this, the official Rails documentation is very good and has guides from the very basics to the more advanced features. https://guides.rubyonrails.org/ You will probably find yourself reaching for the Rails guide throughout your career/project. Even professional software developers can’t remember everything the framework provides and the exact API of using a feature, they still check the guides from time to time. As for your question about the User model. The answer is no, you don’t have to rebuild everything if you were to switch from your own authentication solution to something like Devise. You’d obviously have to change some of the authentication related code, but in terms of your model relationships and other features, there probably wouldn’t be that many, if any, changes to make. However that brings me on to a very important point. Testing! You should always be testing your code, preferably using a TDD approach, which stands for test driven development. Essentially, you write a test for a feature/behaviour you want that doesn’t exist yet. You watch that test fail, and then you make it pass by writing the code. Tests are important because when you do inevitably change things in the future, you want to make sure you’re not breaking existing functionality (you run all the tests whenever you’ve made changes to check this). I’m just scratching the surface but as you can see there is a hell of a lot of ‘stuff’ to be aware of and a lot to learn. I would suggest bringing somebody on board with at least some development experience, as making the wrong decision can cause pain further down the line, that’s called technical debt. Having said that, if doing it yourself allows you to eventually be successful enough to start feeling that tech debt pain, then go right ahead.
But Hanami and Roda don't *actively discourage* you from writing maintainable code. That's Nick's, and my, whole point.
Hanami and other modern frameworks make extensive use of dry-rb. In April, it was [announced](https://hanamirb.org/blog/2018/04/11/announcing-hanami-120.html#what-39-s-next-) that the releases of Hanami 2.0, [ROM](https://rom-rb.org/) 5.0, and dry-rb 1.0 are being coordinated. If this actually comes off, it'll be great news for people looking for modern, stable frameworks that promote and help teach good Ruby development practices. To be fair, it's great what Rails has been able to pull off in the 5.*x* releases given their installed base and legacy code. Ruby as a language, and community experience with it, have both improved *dramatically* since 2005, when some of the most fundamental design decisions were taken that live on today. But wouldn't you really be better off, when starting a brand-new project, utilising those advances and opting out of the decade-plus-old design?
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://rom-rb.org/) - Previous text "ROM" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
We've been Rails-free in production for almost two years now and *loving* it. If you have a massive Rails code base, incrementalism is your friend. (Check out [Trailblazer](http://trailblazer.to/) for one viable option there.) But after more than five years experience with Rails, I can confidently say it's as much a cult as a Web framework. Like any cult, once you're in, you're thrilled to be part of the group, and very defensive against "disbeliever" attacks, until something happens to force you to confront reality. That "something" isn't even likely to seem "that big a deal", until it starts unraveling how you see things.
Change my mind: If you really understand the architectural and design principles behind Hanami, perhaps you don't need Hanami. If you don't understand the principles behind Hanami, perhaps you shouldn't be using Hanami. I get the advantages of having someone scaffold things for you from the get-go, but I find it reinforces understanding to do it yourself.
Of course doing it yourself reinforces understanding. But a balance has to be found between geeking out 24/7 and actually shipping code. The initial selling point for Rails was/is that it's opinionated; there is *one* Rails Way blessed by DHH &amp; Crew. People with experience in software development outside Rails have been railing against the (real or perceived) flaws in that Way: the fact that every Rails test is an integration test because so many components depend on each other; that the whole "skinny controllers/fat models" vs "fat controllers/skinny models" flame war went on for a *decade* because people didn't allow themselves to say "hey, this is a great starting point but it needs more architecture". You started hearing about "vendor everything", then service objects, and then Clean Architecture which SOLIDly built on its precursors. (Read ["Uncle" Bob Martin's piece on it](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html) if you haven't already.) I spent *years* in a position where my job description was essentially "mitigating Rails"; I read everything I could lay my hands on about good architecture in Ruby; I read about [Trailblazer](https://leanpub.com/trailblazer) and [*GRAAP*](https://leanpub.com/growing-rails) and [*GOOST*](https://www.pearson.com/us/higher-education/program/Freeman-Growing-Object-Oriented-Software-Guided-by-Tests/PGM172052.html) and [*POODR*](https://www.poodr.com/) and dozens more, and evolved a service layer and Rails-as-the-least-obtrusive-possible-delivery-mechanism and fast tests and half a dozen other helpful bits...and *still* managed to get a project schedule blown when the customer, well after [the last responsible moment](https://blog.codinghorror.com/the-last-responsible-moment/), decided we just *had* to run on the newest-and-shiniest major version of Rails that had dropped the previous week. I'd been in too-similar situations before in my 39-year career, but those earlier instances had all had the plausible excuse of dealing with then-bleeding-edge tech and many moving parts; this was purportedly a mature, enterprise-ready platform that didn't require enterprise-scale battalions of developers to ship "hello, CRUD". Hanami gave me 90% of everything I'd spent years figuring out how to do _in spite of_ Rails; let me plug in the other 10% when I felt the need; explained most of what it did clearly enough that I could use it confidently even when I'd not done a particular thing that way before; and, *most importantly,* gave me a community and a set of resources that I (and my stakeholders) could be reassured wasn't a pile of custom code that would become an instant risk to the project and company were I to be bus-factored into unavailability. Sure, I'd learn more and understand more developing all-custom code. But if the point is to pursue business opportunity by developing the best feasible solution to a problem, then it would be *insane* for me to go that route, or for any competent company to allow me to. Hanami gets the drudge-work out of the way, in a way that feels sufficiently like code I'd write myself if I had the time that I'm not screaming at the monitor a dozen times a day. (Or three-score, as with Rails 4). Isn't that what we're all trying to accomplish?
A pLETHORA oF pERSonS eRrrOneOUsly cerEbrAte that utiLiZING eXTRaVAGAntLy InvolUTe SeNTeNCe StRuCTuRe maKeS thEm A StEllar IndITEr.
I don't actually see much defensiveness or cultishness on reddit discussions or other internet discussions I've seen. I have had good experiences with Rails, but everyone should use what works for them! 
&gt; (the stuff that gives you tetanus, not the language) because the language gives you tourettes
In short, gems are plugins. Additional functionalities you enhance an already existing product with. In Ruby, it's a single command you enter instead a bigger portion of code to add a functionality. Just because it's way more convenient to enter a single line instead of dozens. I have just published the blog post containing the most frequently used gems at the software house I work at, and describing the magic they actually are able to do. For details, please check: [Top 19 Ruby gems you can’t miss in 2018](https://prograils.com/posts/top-19-ruby-gems-you-cant-miss-2018). Enjoy!
I see what you’re saying now. 1.0 is a development branch so i get they haven’t finished critical things. But calling these RCs is strange for me too — i’d think that designation is for bugfixes only. 
yeah ..the good news is looks like its closing in and its not likely to be the naming disaster [asp.net](https://asp.net) core was where then went way deep into RC mode and then pulled the whole thing back to make sweeping changes. 
Lol what These are critical methods. to_h? Really?
This _is_ already listed in the [rubysec](https://rubysec.com/) advisory db, so it will be flagged by `bundle audit` -- if you remember to update your local advisory db with `bundle audit update` first! Hooray for rubysec. 
Can we make some sort of rule that all blog posts from now on are required to have mouth watering pastries as examples please 
&gt; and why is on rails in brackets? The last handful of methods are rails specific
Interesting examples, thanks for sharing.
ive only been doing ruby for 2 yrs and i knew all those
Just curious, what benefits does this provide over [delegate](https://apidock.com/rails/Module/delegate) ?
There's about a hundred times a day I have a question for a teacher/mentor/someone at least a few steps ahead of me that are a bit too specific for a stack overflow search, and also such a simple answer that translating everything to an online forum is a lot to go through for something that is more or less common knowledge for a Rails dev. Being outside of the city, it's difficult to find a tech community, much less for a specific language, in person. You'd have hit the lottery to have a friend that matches the criteria - the two buddies I have that work in this space have both flown out of state for jobs. I'm considering just biting the bullet and making the 45 minute commute to Philadelphia every day for a code bootcamp. The goal would be moreso to find fellow programmers, than to learn (not that this personal goal makes learning what I don't already know less of a priority) I'm not sure how else I can find the right people to develop a start-up with. I'd be willing to share whatever fruits of the labor become equitously with just about whoever, so long as they have the skills. I've been confident enough in my idea to have put months nearly a year of work and many, many months of learning programs (a lot of Abobe Creative Suite) in this passionate pursuit.
Hi. Thanks for the response! :) Yes I was aware of delegate and as you hava said code-wise using delegate would exactly look the same as say... from above: `employee.branch_company_name`. The main difference though is that using delegate, `employee.branch_company_name` will perform 3 SQL queries: one to fetch the employee record, next one is to get the branch record using the foreign_key branch_id, and last one is to get the company record through branch's foreign_key company_id, unlike if using Quickery it just cuts down to just 1: just simply fetching the employee record, because `branch_company_name` is a real attribute in Employee model, unlike if using delegate, `branch_company_name` is just a delegated method, and not a real attribute of Employee. The example above only goes down 3 levels deep: Employee -&gt; Branch -&gt; Company just to show to simplify the example, but... this gem works best for example say if you have 5+ levels of associations, which cuts down a lot of SQL. Here in our company, I'm discussing my gem to my colleagues and see if we can speed up the process of getting the `Agent` name which is the like root of all Models: that is every model say has a `belongs_to :agent`, And this gem would hopefully help us just removing our worries anymore to update all records if ever the agent has change in the future, because Quickery would automatically take care of that. Hope this helps in clarifying the differences :) And oh, by the way the use of respond_to_missing in my gem only has a slower overhead at initialization of the rails application. It won't slow down record attribute getters anymore at runtime. :))
Just remember to use "def self." for class methods.
BTW, i dont see myself using say: `branch.company.name == :branch_company_name` but only those that are defined with `id`s like `branch.company.id == :branch_company_id` because this is what's really what I am trying to solve: accessing the associated record further deep down the chain immediately. I added `:branch_company_name` just in case some users would want to do just that which is really copying the values from another table: i.e. this is still subjective but i can see some uses of copying over say first_name and last_name User attributes into say `Account` or `Profile` records because I have a feeling `Account` and `Profile` objects probably would access first_name and last_name from `User` lots of times
Indeed. I still think antbahascw correctly points out that, then, the others are standard methods in ruby core. The article could have made this distinction more clearly.
So I found it difficult to get to grips with Rails at first too. Once I got it, I came to really like it; your code knows if you add a field to a database without you doing a thing, whilst we have a Java project that would require editing code in four different places (and 2 xml files) for the exact same change. Now I've cooled on it somewhat, but it's still a valuable tool. &amp;#x200B; My advice: start off by watching [the demo that started it all](https://www.youtube.com/watch?v=Gzj723LkRJY). This is good for a high-level overview. It also gives you the context necessary to appreciate the following point: *Rails is designed to solve a particular problem, which is building CRUD web applications with a minimum of boilerplate.* Namely, it assumes that your users have data they want to store in your database, and they want to retrieve it and edit it when necessary. You can make a real-time chat app with it, [but I wouldn't](https://hashrocket.com/blog/posts/websocket-shootout). Everything in Rails is set up in service of this goal. &amp;#x200B; Then read the Rails [getting started guide](https://guides.rubyonrails.org/getting_started.html) that walks you through building essentially the same app. Nothing important lies outside the app/ folder. Try and focus on how 1. The Models implement the Active Record pattern (they're how your code talks to the database), 2. The controller actions relate to the CRUD concepts 3. Views are just html pages, but which you can fill with custom content through Rails magically setting @instance variables to be those found in the controller. Once you grok the basic pattern, it's downhill from there. To really understand Rails models, it's helpful if you know SQL and how relational databases work. Read the rest of the Rails introductory guides, then Hartl's tutorial as others have recommended. &amp;#x200B; &gt;Maybe there's something else I can use Ruby for, because like I said, it's so enjoyable. Ruby's flexibility lends itself well to writing DSL-based tools, so it's seen a lot of use for things like test or server configuration automation (see e.g. Chef, Capybara, Capistrano). Also, other web frameworks are available. &amp;#x200B; &gt;Can I set up a website with just Ruby and the HTML family? Or do I need these gems pretty badly to be checking for networks information and whatnot. At its most basic, you don't need Ruby at all to make a website, just a server and some HTML. Of course, this changes when you want dynamic page content. ERB (like Rails views) is part of Ruby's standard library, so the bare minimum you need is a **routing library** like [Sinatra](http://sinatrarb.com) or [Roda](http://roda.jeremyevans.net) which takes a takes a url and decides what code to run to build the final html which it returns. But at some point, you'll likely need a database to store information. And then you'll probably want to think about security. And then you'll find you have slow DB queries you want to spawn a background process for, and you'll need a way of doing that (like the one mperham wrote). And you'll gradually start to find you need the features that Rails offers.
Imagine what else is lurking out there in: *The Manual*. 
This seems useful. Denormalizing is a legitimate solution for performance issues. But I wonder, if you're still keeping *the normalized* column around, does it make sense for ActiveRecord to do/know about this instead of doing it at the DB level via triggers? `branch.company.name == :branch_company_name` is silly. I would prefer a less cutesy-blog-post-meta-bullshit-twitter-me API, especially for something that is not supposed to be a toy module. [These decisions can affect adaptation](https://www.reddit.com/r/node/comments/9ddpy9/sqorn_a_modern_javascript_sql_query_builder_that/). I would also change the name to something that developers can find and identify: denormalize, denormalize columns, denormalized columns, anti normalization, ... The current API is also redundant. `branch.company.name` can easily be converted to `:branch_company_name`. Why not do this: denormalize "branch.company.name", "branch.company.id" denormalize "branch.company.name", "branch.company.id" =&gt; "id_deeez" ? Also note that your dist is broken: /tmp &gt;gem install quickery Fetching: quickery-0.1.1.gem (100%) Successfully installed quickery-0.1.1 1 gem installed /tmp &gt;ruby -r quickery/active_record_extensions/dsl -e'1' /Users/sshaw/.rvm/rubies/ruby-2.3.7/lib/ruby/site_ruby/2.3.0/rubygems/core_ext/kernel_require.rb:120:in `require': cannot load such file -- byebug (LoadError) from /Users/sshaw/.rvm/rubies/ruby-2.3.7/lib/ruby/site_ruby/2.3.0/rubygems/core_ext/kernel_require.rb:120:in `require' from /Users/sshaw/.rvm/gems/ruby-2.3.7/gems/quickery-0.1.1/lib/quickery/active_record_extensions/dsl.rb:1:in `&lt;top (required)&gt;' from /Users/sshaw/.rvm/rubies/ruby-2.3.7/lib/ruby/site_ruby/2.3.0/rubygems/core_ext/kernel_require.rb:133:in `require' from /Users/sshaw/.rvm/rubies/ruby-2.3.7/lib/ruby/site_ruby/2.3.0/rubygems/core_ext/kernel_require.rb:133:in `rescue in require' from /Users/sshaw/.rvm/rubies/ruby-2.3.7/lib/ruby/site_ruby/2.3.0/rubygems/core_ext/kernel_require.rb:39:in `require' 
Most of the things presented are super basic knowledge probably all besides “wrap” because that one is close to being useless.
I knew something good would come out of my somewhat snarky comment. Thanks for the great insight! You key points on why to adopt a framework like Hanami stand out loud and clear: community, convenience, and credibility. Sorry, I went with all 'C's but I hope that captures the essence. However, on advising newcomers to Ruby, should we encourage them to hop on something like Hanami right away? There are sure to be ways to abuse it by not understanding what it is trying to fix. I might have a masochistic flair, but I'm actually glad that Rails confused the hell out of me, sending me on a journey of self-discovery through Sinatra and Roda where I had to implement basic patterns from scratch. I finally understand what Trailblazer and Hanami are setting out to achieve (and increasingly just adopt Trailblazer/Dry-rb gems over recreating patterns from scratch). So, gains came with pains. I'm still unconvinced there's a shortcut in terms of learning. I guess what I am proposing is: let newcomers get down and dirty with Rails (heck, even encourage them to); have materials to help them later understand the shortcomings once they've felt the pains; offer Hanami as a solution to more experienced devs.
For 5 level of association, wouldn't we use the association :though option to make access the object directly and benefit from AR cache and preloading with "include" ? Class Employee belongs_to :branch, inverse_of: :employees has_one :company, through: :branch delegate :name, to: :company, prefix: :branch_company, allow_nil: true end employee = Employee.include(:company).first # sql with 2 inner joins employee.branch_company_name #no sql query generated Without using the rails builtin caching and optimization possiblities, with the memoize pattern and delegate it seems possible to reproduce the gem feature for caching of deep accessed values. This would avoid adding data duplication in the database, external caching and agent concept complexities. About the DSL, I think it would be better to follow the existing syntax to define method with symbol, proposition: quickery do mount :"branch.company.name", on: :branch_company_name end 
Thanks for the feedback! I tought about writing a sub-headline "Rails methods" but Medium only offers one type of headline which would conflict with the methods headlines... I'll think of something better for the next articles. 
Good for you! In my experience not everybody's as thorough.
I'm a big fan of Shrine. It has made file uploading in ruby/rails a work of art.
some of these are actually ruby stdlib, others are methods ActiveSupport adds. It would be useful/educational to label them accordingly in the post. But I actually like posts like this, even if you've read a bazillion docs and even if you've seen many/most/all of these methods before, a refresher is still good. There are so many methods in ruby stdlib/ActiveSupport, nobody remembers all of them. Reading articles like this, even if I still don't remember the exact method name or signature, is often enough so I remember "wait, I think there's a method that does what I want here, let's look for it". 
Eloquent Ruby and http://www.poodr.com/ 
this previous discussion thread here had nice recommendations: https://www.reddit.com/r/ruby/comments/86yvcy/where_can_i_learn_actual_ruby_programming_not/
Regarding &gt; employee = Employee.include(:company).first # sql with 2 inner joins employee.branch_company_name #no sql query generated Yes, you're right that this is how I would also normally do this if I would want to also get the `company` attributes through `employee`, so that we avoid N+1 SQL. Although, it will still do a join (I think LEFT OUTER JOIN, no?), but yes this still impacts execution time. Though, I don't think I'll really need to use my gem, but only in specific instances where there are heavy demand to get "values" from associated records, all the time :) &gt; Without using the rails builtin caching and optimization possiblities, with the memoize pattern and delegate it seems possible to reproduce the gem feature for caching of deep accessed values ...yes, Rails works best in this regard because of memoization of already DB-loaded associated records, which is fantastic :) This however still requires an expensive join SQL clause which is really what I was hoping to speed up in my gem. So I guess I phrased it incorrectly in my description that this meant to solve caching, because currently, Rails does already better with associated-records memoization. Although, the type of caching this gem does I guess is intrinsic to the record itself, because it does not really on "includes()" nor "joins()". Regarding the DSL, yes I'm `sshaw_` also pointed this out in this post, and I like your idea too! :) I'll see what I can do with your proposition and `sshaw_`'s suggestion. But, yes currently I'm leaning towards something like: ``` class Branch &lt; ApplicationRecord denormalize to: 'branch.company.id', from: "branch.company.name" # or mount to: :branch_company_name, from: 'branch.company.name' end ``` ... the reason I start with `to:` is because if using "denormalize" or "mount", the verb means like "from" into "to", so if this is the verb to use, I feel like it's intuitive to instead put this block of code into the other model, instead of the Employee model, like the following? ``` class Branch &lt; ApplicationRecord has_many :employees denormalize :name, to: { employees: :name } # or mount :name, to: { employees: :name } end ``` ... however, I think I prefer to see this logic in the Employee model instead because the "mapped" attribute: "branch_name" is owned by `Employee`. Hence, I kinda leaning towards the `denormalize to: ...` above inside the `Employeee` model.
‘to_sentence’ was a new one for me. I’ve just always done ‘join(“, “)’.
I suggest the ruby koans. http://rubykoans.com. You learn ruby by fixing broken tests.
Just wondering what you like about this book? I have to say, I didn’t gel with it even though I felt like I wanted to.
I think it's a great into to Ruby in a non-textbook fashion. It's more whimsical than your standard programming book (go read the rust book for example, very very very dry, even if it is moral) which was a nice change from all the technical documentation I read every day. But what I think the real benefit from the whimsy is that by explaining things in "non programming language" it allowed me to grasp and understand abstract concepts in a different way. Besides, who doesn't like foxes?
I Love Ruby [https://mindaslab.github.io/I-Love-Ruby/](https://mindaslab.github.io/I-Love-Ruby/)
Ooh, this is really cool.
I really liked Design Patterns in Ruby https://www.amazon.com/Design-Patterns-Ruby-Russ-Olsen/dp/0321490452
I always enjoyed RubyMonk but I think it's been taken down.
Thank you so much too for the feedback! :)) Have a good day!
I think it’s still up, but different chapters are varying degrees of broken.
Right. Being an ex-blue collar guy, it seems similar to building a house. You can do a lot of work on the first floor, and end up with a stable living space. But if your foundation isn't solid, the second story might forever exist as a blueprint... Until you build that foundation again. And in programming, it's probably the second story, (or whatever story number you want to insert there that isn't the foundation) that the party happens on. That's the spot the guests go and interact with everyone at the dinner parties, the first story might just be where they enter the house, take off their shoes and hang up their coat. I guess the best philosophy is that you kind of have to accept that restarting at a lower level isn't necessarily going backwards, and that you couldn't have really understood what configuring step 1/10 should have been like until you're on step 10, and you have the higher "mountain peak" view... 20/20 hindsight. Alright this helps my long-term planning, I don't feel as scared taking steps forward that could bite me in the ass. Thank you. I think this could be applied to a few other things, too.
You just love watching the world burn don't you?
Yes. [dry-web-roda](https://github.com/dry-rb/dry-web-roda).
Especially for [dry-web-roda](https://github.com/dry-rb/dry-web-roda).
Eloquent Ruby and Confident Ruby are the two single books that will make you become the rubyist you wish to be.
&gt; Probably, something like below might be a good idea? (if lots of attributes to map) Yeah I can see that working too. 
If you want something fun that shows off the magic of ruby though might not totally be that useful in a day-to-day sense I recommend Metaprogramming Ruby. Other than that I recommend having a goal to build a thing or do a thing and finding a book that helps you accomplish that. Most devs come to ruby for rails. For that Agile Web Development With Rails or the Rails Tutorial (free on the web) is the best place to start. If you're looking to get ruby integrated with your other languages or company then testing is a great foot in the door. A book on rspec would be a good place to start. Good luck and welcome to the community!
Poking individual authors about their PR is potentially helpful -- but caution is needed, particularly when interacting with regular contributors, to avoid coming off as a self-appointed project manager who's trying to direct how others spend *their* scarce free time. &amp;#x200B; &gt;while still working full time at a job with no allotted "OSS-time" Any small contribution is absolutely valuable, and each individual has their own set of life circumstances and priorities, but given this phrasing, I do feel the need to note that even most of the heaviest contributors to the largest projects are also doing so *while still working full time at a job with no allotted "OSS-time"*.
I wouldn't say there's a shortcut in terms of learning. I _would_ say that the best way to learn sky-diving is unlikely to be being handed a packed parachute and immediately getting tossed out of a plane at 15,000 feet. Yes, danger wonderfully focuses the mind, as Twain said. But I prefer my new juniors comfortable and confidently able to ask teachable questions, rather than splattered over the metaphorical countryside with the survivors carrying around Level XVI PTSD. One of the perennial discussions on /r/rails historically has been, should new folks learn Rails first or focus on Ruby (without Rails)? The (correct, IME) implication being that Rails encourages you to form thought patterns, and thus code patterns, significantly different from "pure" Ruby or "improved Rails" as you get in TRB or *GRAAP*, and that those patterns *will* eventually bite off some part of your anatomy that doesn't grow back. I'd argue for (and am presently embarking on applying) using Hanami and its ecosystem (behind-the-scenes ROM and dry-rb) to teach good Ruby development. Granted, the student is unlikely to wind up grokking in fullness the entire object system as they would if they'd built it from scratch. They're also unlikely to develop the questionable habits and abject, persistent confusion from learning Rails+Ruby in one go. But the explicit organisation is going to lead to "how come?" questions with discoverable, non-dogmatic answers, and the underpinnings are sufficient that a new dev can write relatively simple code and see it do something noticeable _in a useful context_. (So _context_ would be your fourth C.) They'll be able to learn useful skills not primarily dependent on Hanami but, by using it as the scaffold, if you will, they'll be able to continue making progress and earning confidence in their ability to solve increasingly complex technical and domain problems. If I can leave a few folks like that behind when I get "bus-factored into unavailability", I'll call it a career well spent.
15,000.0 feet ≈ 4,572.0 metres ^(1 foot ≈ 0.3m) ^(I'm a bot. Downvote to remove.) _____ ^| ^[Info](https://www.reddit.com/user/Bot_Metric/comments/8lt7af/i_am_a_bot/) ^| ^[PM](https://www.reddit.com/message/compose?to=Ttime5) ^| ^[Stats](https://www.reddit.com/message/compose?to=Bot_Metric&amp;subject=stats&amp;message=Send%20this%20message%20to%20get%20some%20stats!) ^| ^[Opt-out](https://www.reddit.com/message/compose?to=Bot_Metric&amp;subject=Don't%20reply%20to%20me&amp;message=If%20you%20send%20this%20message,%20I%20will%20no%20longer%20reply%20to%20your%20comments%20and%20posts.) ^| ^[Patreon](https://www.patreon.com/MetricBot) ^| ^[v.4.4.4](https://www.reddit.com/user/Bot_Metric/comments/8o9vgz/updates/) ^|
I have thought that a dependency in the app is a cost to the business. It is adding technical debt of some level, and the higher quality maintenance that the dependencies receive the better the business runs.
&gt;the higher quality maintenance that the dependencies receive the better the business runs. &amp;#x200B; This hasn't reflected the view of any manager I've ever had.
Isn’t it like illegal or something?
Please provide me with feedback if there are any problems. :)
I'm more offended at the use of prepositions... but the disclaimer makes it (almost, better have your lawyers check that...) clear that this is for educational purposes only and any malicious use of the code is the responsibility of the runner...
Hi matthew! Thanks for your thoughts. You make very good points. I try very hard to keep hands-off when checking in on an Issue or PR- nine times out of ten it actually ends up in someone agreeing to close an issue that they filed 3-4 years ago that they actually no longer care about, so hopefully being helpful in bringing down issue loads for maintainers. But it is a very good observation that the 'human advocate' not become a harrasser of others. You are also right that most of what we rely on is maintained by people laboring hard with love with no appointed OSS-time as well. The reason I marketed the pitch this was is that __this is the biggest reason my friends give me for why they do not participate at all__. Hopefully I make a good case why any one of us can have a role to play... And why we should all participate (even if a little).
How does it work?
Where will it be called in your main thread? You can't just jump from wherever you happen to be in your main thread into this new method. Typically you'd call @workerthread.join in your main thread to wait on the background thread to finish executing, then continue executing wherever you want. The callback style of asynchronous programming requires an event reactor model, rather than a threaded approach.
Hey and thanks for the response. After thinking about it a bit more, I agree with you, and have no answer to your question. Though, I remember that in iOS programming with Objective C, there was a way for a mechod to check if it was called by a thread and it was able to “call itself” again in the main thread, for example for UI changes to take effect: https://developer.apple.com/documentation/objectivec/nsobject/1414900-performselectoronmainthread Wouldn’t this be a similar situation?
There's no builtin for this, but you can construct it from a Queue call_on_main = Queue.new t = Thread.new do sleep 1 # simulate background work call_on_main.enq [:puts, "call 1"] sleep 2 # simulate background work call_on_main.enq [:puts, "call 2"] end loop do if call = call_on_main.deq then send *call end sleep 0.1 # simulate other work from a main thread event loop break unless t.alive? # simulate shutdown end
Next project: collect weak wifi passwords in Ruby :)
I use and love both. However, Emacs has Magit, Org, and the packages seem to be more fleshed out and less buggy from my experience. I just wish the Ruby tooling in Emacs and available was better. 
I've spent the last two years with nothing more than `Assertion Failed` as my assertion failure message. Honestly, in my experience it's not really a big deal. If you need to see the values compared, just print them out. For me, assertion messaging offers no measurable impact on anything.
&gt; The key thing in the scaffolding is to name your attachment data with the _data suffix and that its type is string. I mistakenly set it as JSON at first and then Shrine was trying to parse a hash and throwing an exception. Hmm, it ought to work (and possibly work better) with json/jsonb. And it usually does. json/jsonb is probaby recommended, file an issue on shrine if it's not working?
Nothing strange about it
Point taken, jrochkind.
If you don’t know C Ruby is great for IO parallelism and terrible for CPU parallelism you could expect a speed up that can’t be realized Furthermore, how do you know the library you’re using is thread-safe?
And, watch out, there’s no error handling so you don’t get exceptions back from the threads when they raise exceptions, other than being printed to the console, just data loss
Most of the iOS programs you’ve worked on probably have the main thread running an event loop; consuming events in a queue. You usually aren’t even aware that it’s happening. In that case it’s easy for background threads to add an event to the main thread’s event loop if they want a block of code to run back on the main thread.
Out of curiosity, if you've never make a webapp before, how do you know if Rails is easier or harder than any other approach?
Thank you very much for your help, I'll have a look into this! (:
Thank you very much for the explanation! Having read that opened my eyes and gave me ideas on how to implement a similar behavior, nice!
Super calls the initialize method in the parent class in this example
It should be noted, as stated both in the header and footer of the article, that this is a translation of another article: https://medium.com/@roman01la/understanding-transducers-in-javascript-3500d3bd9624 @roman01la had given me permission to translate it into Ruby. This is the article which helped me start to grok what transducers did, so I figured it'd be nice to translate it into some more familiar parlance for the people here :) Enjoy!
[removed]
So, I learn best with examples: class Foo def talk puts 'foo' end end class Bar &lt; Foo def talk super puts 'bar' end end b = Bar.new b.talk # 'foo' -- from the puts in Foo # 'bar' -- from the puts in Bar #=&gt; nil -- return value of the function Like /u/trumant et al. said, `super` calls a method with the same name in a parent class. This can be used to add additional functionality without completely removing the original functionality. To give a slightly less contrived example: class Rectangle attr_reader :height, :width def initialize(height, width) @height = height @width = width end def area @height * @width end end class Square &lt; Rectangle def initialize(side) # since Square's initializer has a different number # of arguments, we have to specify the arguments # to super. If they were the same, we wouldn't have to! super(side, side) end end s = Square.new(2) s.area #=&gt; 4 s.height #=&gt; 2 s.width #=&gt; 2 Since a square is just a special case of a rectangle with all sides equal in length, we probably wouldn't need any special methods that aren't already on `Rectangle`. We just need a special initializer to get everything set up.
This was great, thanks! Now I’m trying to wrap my brain around how rambda works - in particular how the arity of the last argument can be anything - do you have any thoughts about transducing beyond “pushes”?
That's the trick :) If we took `pushes` and renamed it to something like `joins` and took the empty array and renamed it to something like `empty` or `identity` or `itself` we get some _really_ fun tricks to play with. Consider an empty array `[]` and the joining operation `concat` for merging two arrays. `[].concat [1] == [1].concat []` - That means that we can merge either right or left, and still get back the same array if we merge it with something that's empty. Let's use Integers and `+` to merge them, with an empty value (identity) of `0`. `0 + 1 == 1 + 0 == 1`. Huh, that looked a lot like the array above! An empty value, and a binary operation to join values. Just to be sure, let's say we have `1` and the binary operation `*` multiplication: `1 * 2 == 2 * 1 == 2`. 0 wouldn't make sense here as you'd get back 0! That means that there's a relationship between the operation and how you'd get back more values. Addition is summation, multiplication is getting a product, iterating through an array like that is effectively each (map if you throw a function onto it first). If something behaves like this, it's reducible. It also has a really scary name that's not well deserved in Category theory: Monoid. Now there are a few more rules to it than that, but noticing relationships between the way things behave can give you some real fun to play with. Anyways, spoilers, that's one of the next articles up is trying to find a good way to explain all of that with some extra illustrations and fun along with it. Extra extra spoilers, pay close attention to my RubyConf talk in November. See if anything looks eerily familiar.
Thank you! I though about the monoid nature of monads a while back and couldn't figure out what was the binary operator and identity for monads. Just after your comment I've realized: `bind` and `return` were out there all the time. It's really embarassing!
That's a great article, thank you! That makes me wonder: we have a `Transproc` gem which we could use to describe data transformations. I wonder if we could introduce transducers to the library without changing much of the DSL.
It is most likely not in standard ruby (library) by default because it is a very specialized gem.
It is not good to use Zed Shaw's ressource - he does not write in idiomatic ruby. As for super(), simply remember it by invoking the parent method in a class/subclass hierarchy - for the most part that is what it does.
Besides this being the canonical way to do transducers, why can't we do list.iter.lazy.map.filter.reduce ?
I liked *Metaprogramming Ruby 2* : [https://pragprog.com/book/ppmetr2/metaprogramming-ruby-2](https://pragprog.com/book/ppmetr2/metaprogramming-ruby-2) Smooth learning curve andit really helped me to actually understand the ruby object model 
I think there’s some similarity in how lazy would process an element all the way through the pipeline one at a time, but that doesn’t give you a way to share or compose transformations as values.
Laziness incurs a performance penalty that transducers don't. I'd take a look at Rich Hickey's original talk on the subject, but be warned it's in Clojure and can be a bit high level: https://youtu.be/6mTbuzafcII
Oh trust me, it took me what felt like an embarrassingly long time to come to some of this myself. I probably still don't entirely have all of it down. That's the thing about abstractions at this level, especially this far meta: they take a while to click, but once they do it feels almost insultingly obvious. Relatedly that's why everyone who learns tries to teach it right afterwards because it just feels so clear to them now. I'd say that's a good thing, because eventually a metaphor or example helps someone else click in too :) 
Yeah - sorry that I didn't make my background clear, I understand the concept, I can use Lisp and some Clojure (not up to date on the data types), and I dabble in Haskell. I was looking for a solution which, while not a transducer, might be a good enough substitute for Ruby. As for transducers not incurring a performance cost, you're reimplementing map and such in Ruby, and even though you're using reduce which is implemented in C, there's gonna be a performance hit of some sort there as well (although it's likely that the cost incurred by using lazy is higher).
If the main thread can just wait, you can use `Thread#join` to wait for the bg thread to finish. Otherwise you'll need to use a Mutex/Monitor/ConditionVariable as appropriate for your needs.
In my opinion, the "pretty" output is already good enough; I think a more verbose version would just add more noise and make the error unclear. (I'd expect to see the raw data in the error, not buried inside some extra hash.) But then, I'd say the exact same thing about your [`debug_helper`](https://github.com/BurdetteLamar/debug_helper) library -- ruby already has `pp` ("pretty print") in its standard library, which provides all the data I typically want to see (unless I'm being very explicit about "show my the size", "show my the encoding", etc). ...In fact, that's already precisely how [`make_my_diffs_pretty!`](https://stackoverflow.com/a/50677303/1954610) works: By utilising ruby's `pp` library. So if you want *super-verbose* output, you could even just try doing this: module MiniTest class Test &lt; Runnable def self.make_my_diffs_pretty! require 'debug_helper' define_method :mu_pp, DebugHelper.method(:show) end end end
Wow. Been programming in mainly Ruby for like 5-6 years and never even heard of this. Madness. Great to know now
I’m sorry you found the article unappealing to your individual taste. I’m sure the author would be willing to issue you a full refund on all the money you paid them to read it. Seriously, why do people feel the need to shit on the work of others just because they don’t personally gain value from it? It doesn’t have to have value for everyone in order to have value to many.
A few methods mentioned in the article are provided by ActiveSupport. The author tagged them with `[Rails]` in the article.
Maybe you don't realize how calling the author's work "super basic" and "close to being useless" comes across, but it's definitely not "stating the obvious" — many junior devs don't know many of those methods. This is worthwhile, non-basic content to many people who are not you. Also, negative criticism of a piece of content without saying a single positive thing about it counts as shitting on it. Sometimes it's warranted, but definitely not in this scenario. If you truly think the author's work is worthwhile enough for them to keep writing, spend more of your words on that so it comes across more positively.
I like the depth you've dove. Yet I should say that akin to /u/Trevoke I always like to not only review how other language ideas could be imitated in Ruby with DSL (they obviously could), but also what minimal changes / explorations of Ruby's lesser known feature can produce a closer result. I believe that "transducers" is rather a useful mental model / term that is useful in discussing things, than thing that should be reimplemented literally as close to other languages as humanly possible. In other words, I strongly believe that `Enumerable` IS an exact equivalent of "transducers", method chaining IS an exact equivalent of transducers combination, and `Enumerable#lazy` IS the exact equivalent of "applying transducers without producing intermediate collections". (In next series: same about monads :trollface:) 
I learn about Ruby everyday too ! The source code is mind blowing hehe !
http://mitrev.net/ruby/2015/11/13/the-operator-in-ruby/
Ruby hasn't changed too much. You could probably catch up fairly quickly by skimming the release notes for each point release, e.g. https://www.ruby-lang.org/en/news/2015/12/25/ruby-2-3-0-released/ https://www.ruby-lang.org/en/news/2016/12/25/ruby-2-4-0-released/ https://www.ruby-lang.org/en/news/2017/12/25/ruby-2-5-0-released/
But what about the Hashes!? Doesn't anyone think of the poor Hashes. Do remember this one is just a translation from another article. I intend to go into more depth on this topic later once I come up with some nifty visual metaphors to break it down more. This all builds up to my own grand monad tutorial some time in the future, or not, who knows.
Thanks you for response. i know your experience as a programmer through time but need updated continuously &amp;#x200B;
Doesn't the monad tutorial go "so here's the cool thing about Enumerable, oh, except for hashes, oops"? :D
it's nice word but when know more language help you improve code and your think.
Although I know this keyword a long time ago I find that it's rare to have a chance to use it &amp;#x200B;
It seems like the most practical use case I can think of for it is a sort of recursive block. Perform a operation, evaluate it; if you’ve got the desired answer, stop; otherwise redo. 
Redo is old-school Ruby. It's the kind of thing you'd see in Ruby code written in the late 90s or early 2000s.
I’m not an expert on Ruby but I can say that the Python behaviour is predictable. Memory is freed immediately on variable reference being freed and unless the allocator is weird it should be reused. Garbage collection is more subtle and implementation dependent.
Obviously, Ruby wasn't designed for this sort of use-case. You can manually call garbage collection if you feel like you absolutely have to: https://ruby-doc.org/core-2.2.0/GC.html
How are you measuring memory usage? I don't know of a tool that measures RAM usage in mebibyte... I _think_ it's because every `a+b` creates a new object and while assigning a new `b = a+ b` overwrites the pointer to the old `b` object, that object still exists in memory since the object is still technically in scope, thus it won't be garbage collected. I _think_... I just skimmed it, but [this post](https://blog.codeship.com/visualizing-garbage-collection-ruby-python/) I think explains why the Ref Count vs M&amp;S uses more memory... For most similar Rubyish way to count to the Nth number, I'd probably use an array: def fib(n) n.times.each_with_object([0,1]) do |num, acc| acc.push acc[-2] + acc[-1] end.last end fib(100) Again, not sure how you tested memory consumption, but looking at it, I _think_ it'll probably use the same amount of memory. (although, I have to admit you've piqued my interest) However, I feel like this is a really bad example because I'd never do that in the real world, if for some reason I actually needed the nth Fibonacci number, I'd use a matrix, which is much faster: require 'matrix' m = Matrix[[1,1],[1,0]] def fib(n) (m**(n-1))[0,0] end Because personally, I'm more concerned about speed than memory usage. Although, really, [just us magic numbers!](http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/phi.html#section5) def fib(n) PHI = 1.6180339887498959 TAU = 0.5004471413430931 (PHI**n + TAU).to_i end Neither of which are really Ruby specific (well, I know python supports Matrices, but I'm not sure how that would be implemented)... What is it that brought you to comparing the memory usage of the two languages for a fib function?
[removed]
Is there a drawback to manually calling GC?
Mostly just that with modern computing hardware, and in most Ruby use cases, you're more likely to run into a CPU bottleneck than a memory bottleneck. GC frees up memory, but uses CPU cycles to do it. Normally, Ruby waits until the CPU is free to run GC.
Ah, it's a tradeoff then. Thanks for explaining!
Probably just comes down to GC differences. Python has RC in addition to a 3-generation M&amp;S where Ruby only has a 2-generation M&amp;S. Both languages represent bignums as an array&lt;long&gt;. For `a+b`, the language internally allocates a new array&lt;long&gt; `z` onto the heap that's one `long` bigger than the larger of `a` and `b`, and a long `carry` on the stack. So for every loop, `a` becomes garbage and is replaced by `z`. Python's RC will notice that `a`'s ref count is 0 at the end of the loop at immediately GC it, which frees the memory for use in the next iteration of the loop. Ruby doesn't have a RC, so it waits for the M&amp;S to kick in. The default max size of the heap before GC is triggered is somewhere around 32MB (new generation) + 128MB (old generation). Playing around with Ruby's GC parameters, I got memory use down to 38.5MB just by turning off the generational GC (`RUBY_GC_HEAP_OLDOBJECT_LIMIT_FACTOR=0.9`). Smallest I got memory use down to was ~28MB by setting `RUBY_GC_MALLOC_LIMIT=8388608` (default/2) and `RUBY_GC_MALLOC_LIMIT_MAX=8388608` (default/4). 
Seems to be a pretty good use case.
Although you have asked for books, I personally recommend to look for many blogs in the last ~5 years. Several of them have a lot of great information. I was more following blogs than anything else. Also the ruby news entries are always useful: https://github.com/ruby/ruby/blob/trunk/NEWS Last but not least, just keep writing ruby; I am sure you'll find better idioms since there have been quite some improvements in general.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ruby/ruby/.../**NEWS** (trunk → 9024509)](https://github.com/ruby/ruby/blob/90245094103164ebd28d68fe6719ad14a883701e/NEWS) ---- 
Great answer. Confirmed my suspicion and the only solution would be tuning some GC settings. Thanks.
Yes. I can also confirm manual invoking of GC decreases runtime performance drastically. 
As I said, I liked the article :) Just used it as an excuse to express some of my latest concerns about ecosystem and those discussions.
&gt; Doesn't anyone think of the poor Hashes. [I do](https://github.com/zverok/hm), in fact :) And exactly as I explained above: trying to stay in "chains of simple transformations" Ruby-native paradigm.
Writing a new book about the Ruby object model is extremely courageous! This is the current definitive resources http://www.atalon.cz/rb-om/ruby-object-model/ and nobody I know is even entirely sure if some of that is a practical joke or not.
What are RC, and M&amp;S?
I like the fact you're testing the database rules/constraints. The only thing that confuses me is the acceptance tests where you're re-creating the functions? Aren't they already defined in the Rails migrations? Couldn't you just test like this: it { expect(ApplicationRecord.connection.execute("SELECT companies_subdomain_lowercase_on_insert('CamelCase')").column_values(0).first).to eq('camelcase') } 
Ruby is not a great language where memory consumption is a concern. Using the standard json library to decode a 36MB json file can consume of 2G of memory (Which sucks if your process gets killed if it goes over 2G, let me tell ya). There's a couple things going on here: By using "-&gt; #{ObjectSpace.count_objects[:T_OBJECT]}" you are interpolating strings and allocating new objects. Measuring the memory usage outside of Ruby, shows that removing the memory reporting has an impact of 10s of MB. It's still not great mind you, but there's a significant chunk eaten by the strings. As /u/three18ti mentioned, there are better ways to do this in ruby. However, due to the huge number used for "n" your options are limited. Recursion is out the window for example. His matrix version has flat memory usage and VASTLY outperforms your version. The magic number variant produces a value of "Infinity" given your value for "n".
M&amp;S is mark and sweep. I assume RC is ref count. 
Makes sense, thanks!
They got tons of negative energy and drama for one critical blog post. Now nothing positive. This is why non-profit/OSS work is so draining. Thank you, Andre and board, for doing the hard work to fix the problems over the last few months. This is why I'm happy to support RubyTogether.
I've backed this. I hope it gets funded.
Thanks a lot ! I hope so ! :-)
I've written a [benchmark-trend](https://github.com/piotrmurach/benchmark-trend) gem for testing the computational complexity of code and I've used different fib implementations for my tests. One thing I've discovered is that a lot of fib implementations will blow up Ruby VM. For example, the version with the 'magical numbers' will blow up if you try anything with `n &gt; 1500` you get a `FloatDomainError: Infinity` and with the matrix and array examples, you will get `SystemsStackError: stack level too deep` due to the data structures filling up the stack. The only viable solution is the actual iterative version in the profiling example! It takes `0.6 s` for `n = 100_000` using Ruby 2.5.0. So to me, this is not only quite a Rubish solution but the only that maintains linear computation complexity and actually produces results for arbitrarily sized n! 
It was more than one critical blog post, there really were problems that needed fixing, right? But yes, I think this is a GREAT way to re-org their structure, and am pleased see it. I think there unavoidable conflicts of interest before, and I'm hoping it will work more smoothly this way, and am optimistic. I do think we need something like Ruby Together. 
I came very close to making something similar earlier, so I know the itch :)
I was going to [extract this code](https://github.com/sshaw/class2/blob/46c2029fefc58a921277bd5ab6c3ad790a65bc5a/lib/class2.rb#L159) into a "to hash" gem. Maybe you can add it to yours? I'd love for someone to show me that turning something into a "usable" hash doesn't have to be that difficult...
Ruby doesn't enable tail-call optimization (TCO) by default, but you can enable it when you compile Ruby or with RubyVM. Matz has considered enabling it by default, but it would mean disabling trace instructions. An aside, but here's my little implementation of #require_relative with TCO: https://gist.github.com/havenwood/3c5a5e1476c811460992
For fun, [here's a Ruby fib(n) with Matrix](https://gist.github.com/havenwood/02cf291b809327d96a3f). As a one-liner: require 'matrix'; (Matrix[[0, 1], [1, 1]] ** n.pred)[1, 1].to_i
Absolutely, bugs happen in all types of systems. I agree that this is a very good step forward. Sounds like Andre won't touch code but rather triage and assign issues, so there's no incentive to "churn code" for money.
To EliteMind49: NEVER, EVER MOCK THE RUBY SUBREDDIT AGAIN OR YOU WILL SUFFER CONSEQUENCES THE LIKES OF WHICH FEW THROUGHOUT HISTORY HAVE EVER SUFFERED BEFORE. WE ARE NO LONGER A SUBREDDIT THAT WILL STAND FOR YOUR DEMENTED INSULTS ABOUT OUR LOW UPVOTES. BE CAUTIOUS!
I vote for deep symbolize/stringify keys functionality :)
I think it's difficult to give a definitive answer. A good sign for 'knowledge' in my opinion would be that you're able to create a moderately-sized application without much handholding while being aware of the advantages and trade-offs of the stack you're using (and choose it accordingly, if able). Looking at Ruby in particular I'd say you have good knowledge when you have a clear mental model of everything you're doing in regards to your code. Ruby has some of its famous magic hide away implementation details where it's extremely useful to know what's happening behind the scenes. If you can explain that, I'd say you're knowledgeable. 
Thats a great thing when you have pure sql functions, but thats too rare to build a system with this fact. I mean that if you can check a function with simple select, thats great, perhaps you should do that. But it's not enough, right? You also need to check constraints and conditions of rule (or trigger) creation. How you plan to check that `AFTER INSERT ON blah` is correct? Or `BEFORE UPDATE OF fieldname ON tablename FOR EACH ROW WHEN fieldname = 'blah'))`. In addition, rule is actually can't be called directly. Also to create separate functions for each test allow me to not care about visibility of variables (`company_name` in the last example).
This is a really good answer. What I want to reiterate is that this is not a binary thing to evaluate. For your own judgement, think more of what you want to (and is useful to) still learn instead of everything there is to know.
I think it depends on who we're talking about. If you're a senior developer, several months of getting your hands dirty are probably enough for any new language. Also, it's quite hard to separate the language from the platform. If you platform is the web, then you probably need to learn Rails and javascript as well. If you platform is Android, you need to learn Android... there's a whole bag of additional knowledge you need to actually be productive.
i was lucky and was paid to learn ruby. a few months to do some damage, 2 years now i feel pretty confident providing code review feedback
I'm definitely in the category of junior dev, probably the most 'professional' project of mine I could mention would be a discordrb bot that logs messages in an SQL database
I would say that somebody knows ruby pretty well if he can easily answer questions like what is \`main\` object and how it works? 
I think the key is knowing as many of the *concepts* of the language and ecosystem as possible but not necessarily the details. That is, you should have a good idea what the best tool or concept in a situation is but if you have to look up the particulars of how to actually do/use it, that's OK.
Would you have the time to give an idiot's guide to what this diagram is showing? [http://www.atalon.cz/rb-om/ruby-object-model/#s2-example](http://www.atalon.cz/rb-om/ruby-object-model/#s2-example) I have drawn somewhat similar things on whiteboards myself but never got this detailed.
Never, programming languages are never static.
Ahh I see, the functions created in the before each were designed specifically for the side affect tests, I understand now.
I usually tell people you know a language when you think in the language as you’re using it. Knowing a language is about being able to express yourself. This applies to way more than programming languages. This is a longer post than I might otherwise write but I’m home sick today so you benefit from my convalescing. I am bilingual and when I speak Spanish, I think in Spanish, not in English and then translate to Spanish. There are constructs in the way you express certain things in Spanish that absolutely do not translate syntactically from English. In an effort to reduce waste, we recently bought a couple of reusable to-go containers to take to the taqueria. When I explained to the guy, he said, “You want me to put them [the tacos] in here?” except in Spanish, where the closest literal translation to English would be “You want that I should put them in here?” If someone whose first language was not English made this translation, it wouldn’t be *wrong*, but it would be obvious that they weren’t thinking in English. Likewise, if I were in the same situation and I translated the same sentence to Spanish literally, word-by-word rather than understanding how to express the *concept*, it wouldn’t actually be all that correct even though the compiler/interpreter accepted the input as technically valid. In learning Spanish, this manifests as understanding what the subjunctive is as, when to use it, etc, but that’s all academic and it’s only when that thought process becomes more automatic and natural that you really *know* Spanish. Another example: I’m an amateur tuba player and I play in a community band. When I’m playing music, I’m thinking in the language of music (scales and key signature, harmony/chord structure, dynamics, my relation to the other members of the ensemble) and not in terms of trying to maintain some translation layer in between the music and my brain. Now, finally, back to programming. When I’m writing Ruby, I am pretty comfortable that I understand what makes for idiomatic Ruby and I think in terms of those things. I know where Ruby is more or less expressive and leverage those strengths. I don’t think in PHP or Perl or Python and try to translate the syntax to make the Ruby interpreter happy. Those languages have their own peculiar strengths and weaknesses and their own characteristics and trade offs that make for expressive code in their context that will read very much like a poor translation if used in Ruby or Go or wherever. Here are just a few examples of things that *I* like about Ruby that I think make it fairly uniquely expressive: (Others will disagree and I’m not here for a religious discussion about whether these are good or not. I use them. You might not. It’s OK.) * Blocks, Procs, and Lambdas! Other languages have callbacks and some have blocks but these are pretty core to how Ruby expresses itself. Code that uses blocks can be written without them of course but when your brain flips the switch to thinking about moving that code into a block construct, the Ruby-ness of your code increases. * Every expression has a result so you can use them to assign variables to the results of `case` statements and conditionals. ``` stringFoo = case foo when String foo else “#{foo}” end ``` * The `unless` keyword * `!` and `?` allowed in method names * Mixin modules such as Enumerable. Implement a small amount of functionality and mixin Enumerable and you get a host of methods “for free”. From here you can see how this would be useful for writing your own. * Conditional setting with `||=` So, that’s my super long-winded answer to say when you know a language. Sometimes you’ll have to look up syntax or delve into the intervals of which hashing algorithm Ruby Hashes use, but knowing those things alone would not bring you closer to actually expressing yourself and communicating effectively with other “speakers” of that language. Spending time reading and writing the language will make you more and more familiar with what makes it beautiful and will teach you how to effectively express yourself in your code. 
Funny, chatted to a random person in the library today about Ruby. He'd got it in his head that Ruby was "dying" and that he'd be better off trying to learn PHP. To which I retorted, "sure, you could try to get a job you hate...but if you want to actually enjoy what you do..." I took it as an important community service to set this straight. &amp;#x200B; But I digress. It's strange to think of "knowing" a programming language as a sort of destination. The best analogy I can think of - and one I used on this bloke in the library - is chess. You can learn all the rules in a short amount of time, but it's going to take you a lifetime to master. &amp;#x200B; Programming languages are best experienced in the moment, in the day-to-day practise of your craft. Even now, and I've been coding in Ruby for over a decade, the language throws up new little gems that delight and make me happy that I chose this path. Ruby is a pretty special language, optimised for programmer joy. And if you get that... if you grok what makes this language so pleasurable to code in... you'll be closer to really understanding Ruby. &amp;#x200B; I realise this doesn't answer your question, but one day you'll be coding and you'll know - in your heart - that you know Ruby.
I felt I knew Ruby when I was able to read the underlying source code and at least be able to mostly understand it (let's be real, there's probably parts that Matz doesn't grok fully), and also look at nearly any well written Ruby code and almost instantly understand what's happening. Also; when I was teaching Ruby professionally I actually learned Ruby. 
Imagine a blank sheet of paper. You know nothing about Ruby (or any other learnable thing). You start learning parts of Ruby, these become dots on the page. You now see a lot of dots, but you don’t know how they relate to each other. You’re also not sure why you would use one dot over another. As you keep learning, you discover how things relate to each other. Now there are lines drawn between some of the dots. You realize that some dots are better than others for solving a problem, and you make those dots bigger. You still see the smaller dots and they cloud your thinking, but you are getting better at choosing the bigger dots. Eventually you develop an intuition about how to solve a problem. Most of the less useful smaller dots fade away, and now you only really see the “good” solutions.
When you don't need docs for 99% of your work
When you feel comfortable working in it, and find yourself effective with it. Can you effectively work on a team with an &lt;language here&gt; codebase? Congrats, you know &lt;language here&gt;!
When you can go into an interview and answer their questions in said language. If you can't whiteboard solutions, or at least describe the verbally, then you will get a lot of push back on your programming skills. This isn't to say that you have to answer everyone correctly, it's just that you need to be able to demonstrate how you would use that language to solve the logical problems presented to you.
Probably after "hello world" and before contributing to the development of said language. No that's a bad joke. My take is when you can do whatever "job" you set out to do with the language. Think about natural languages. When do you know these languages? When you can go to Greece and order a meal on the street with Greek, or going dealing with German business partners? It's a personal question probably has a personal answer too. A strong follow up question might be asking when so I know how to do a particualr conceptual job rather then lexicography.
It would perhaps be helpful to look at the intermediate structure that is obtained by ignoring module inclusion. Such a structure is displayed on [http://www.atalon.cz/rb-om/ruby-object-model/rb-om-s1.pdf#page=8](page 8 of the pdf), except for the module named R. A "side-view" of a simple substructure (almost) is depicted on [https://en.wikipedia.org/wiki/File:Ruby-metaclass-sample.svg](wikipedia). Here are the corresponding codes: * https://eval.in/1056768 (Simple structure from a "side view", with just A,B, u,v) * https://eval.in/1056778 (The structure from the PDF) * https://eval.in/1056764 (The structure from the HTML - the main document, with module inclusion) There is a detail in the example chosen for module inclusion that might be slightly misleading: the two "parallel" inclusions of the M module. This might falsely suggest that there is some rule for such a parallelism. 
Welp, that writes me off. Better go remove Principal Software Engineer from my title. :P
I consider this to be when you personally feel comfortable saying you know it. You know you, and what you know, far better than anyone else. I don't care how you do your work, as long as you're getting it done in a timely manner and can communicate expectations about when and how it'll be done. I use Google for 90% of my work, even at the level of development I'm at. I've been in the industry for more than 15 years. Research and documentation is simply part of the job. I worry less about knowing a language than I do about optimizing my workflow and how I find information. Having documentation open, and writing documentation so that the next engineer doesn't have to think that much seems like the better way to do things than bother memorizing the everything. 
When you are using other languages and you miss something from that language. For me this is always a clear sign that I am familiar with that language.
Disagree with this 100%. If one is doing 99% of their work without consulting docs, I'd have to guess their work is very simplistic or their mental capacity of memorization is unfathomable. I reference documentation daily developing in ruby because I know something exists in the standard library but I don't necessarily remember exactly which order the parameters go in or what it's called. I also referenced documentation daily when using C++ and the C++ STL even after using the STL daily for half a decade. No way in hell I can remember the 10 overloaded constructors for an STL container &amp; which order each one takes parameters. All in all, how much one references documentation is a very poor indicator of if they know a language. I'd almost be alarmed if someone came in for an interview and told me they didn't need to reference documentation for 99% of their work; I'd have some serious doubts about what kind of work they've been doing.
There's a few distinctions here: knowing a programming language isn't about being a better programmer. If you can solve all sorts of problems in one language, you can likely express those same problem solving techniques in another. However, knowing one language does not, at all, mean you know another. For example, you might find that Ruby and Python are fairly similar and you find it easy to write Python due to your Ruby background. However, it's difficult to write good Python without knowing the idioms of the language and being comfortable enough to be able to think in it. Also, you might think you know a language really well today, but in 5 years you might assert that you didn't know the language at all today. I don't think your assessment is wrong in either case, though. You likely no longer feel comfortable in one language because you've become much more familiar with others even though you're just as comfortable in the first language. At the end of the day, knowing a programming language has everything to do with how you feel about it. Do you feel that you can express what you want to express in a way that makes good code to the best of your knowledge? On the other hand, if this is a career advice thing -- remember that there's almost always someone who's a weaker than you that's happy to claim they know X. However, do you really want to be doing X every day if you don't know it all that well?
I would expect a library that prioritized things to use a heap or one of its variants. 
Unless... we were using J2EE 😉
True enough. 30+ years into C++ and I *still* don't know it all. It doesn't help that it's a moving target.
The scope of this article was to introduce these OOP techniques. However, the application is waaaaay to small to make proper use of it ;)
LanguageClient neovim + solargraph gem + completion plugin (deoplete/ncm2) ALE for linting
Sounds like you are on the right track. If you are concerned about becoming senior , know that becoming "senior" is a very vague and controversial term. I wouldn't be too worried about it. Keep learning and having fun, you will gradually improve. Some companies name seniors as everyone who has 5+ years of work experience. In Google I imagine you can have 15 years experience and still be pretty mediocre in a room of Googlers. So senior is a relative term.
[https://hhvm.com/blog/2018/09/12/end-of-php-support-future-of-hack.html](https://hhvm.com/blog/2018/09/12/end-of-php-support-future-of-hack.html) I don't see Facebook involve itself with php at all actually, seems like they are on a different track altogether now.
That's why I'm not deleting it. I don't think the code itself is illegal per se, but using it in a certain way is. Since all code can, in some way or another, be used for illegal purposes, I don't think this example warrants being censored unless the code itself is illegal or immoral (e.g. if it contained hate speech, classified information, passwords, personal details, etc.)
In my opinion once you understand programming concepts, as long as the syntax isn't totally different (haskell was an interesting one to look at) then it's relatively easy to pick up a new language. Learning the *idioms* of a particular language can take a bit longer and knowing the pitfalls is important to being productive. Essentially though, you don't learn much 'new' stuff between them in my experience. I try to keep a few languages up to that standard, which I loosely define as "I can solve reasonable-difficulty problems without having to look up syntax" - I don't shy away from poring over stdlib docs though, they can be a minefield if you start guessing things in a dynamic language. It's fun to be a polyglot even if everyone just ends up wanting PHP because 'the hosting is cheap'
I now finished comparing the other gems to Quickery, and if you're interested here are some of my findings: https://github.com/jrpolidario/quickery/blob/master/other_similar_gems_comparison.md By the way, thanks for the great feedback! :)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [jrpolidario/quickery/.../**other_similar_gems_comparison.md** (master → afe2d2f)](https://github.com/jrpolidario/quickery/blob/afe2d2f7b19b589c79e1a2c2dce6f1e4e866d4e9/other_similar_gems_comparison.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e5whdcx.)
Hanami author here. Nope, Hanami doesn't use Rails gems.
 If one was willing to monkey-patch ruby (which really you shouldn't), then: class TrueClass def &lt;=&gt;(other) other ? 1 : -1 end end class FalseClass def &lt;=&gt;(other) other ? -1 : 1 end end class Post attr_reader :author, :like_count, :is_sponsored def initialize(author:, like_count:, is_sponsored:) @author = author @like_count = like_count @is_sponsored = is_sponsored end end low_like_count_sponsored = Post.new(author: 'Jay C.', like_count: 10, is_sponsored: true) high_like_count_unsponsored = Post.new(author: 'Aaron R.', like_count: 90, is_sponsored: false) high_like_count_sponsored = Post.new(author: 'Don Y.', like_count: 90, is_sponsored: true) unprioritized_array = [high_like_count_unsponsored, low_like_count_sponsored, high_like_count_sponsored] prioritized_array = [high_like_count_sponsored, high_like_count_unsponsored, low_like_count_sponsored] puts unprioritized_array.sort_by {|obj| [obj.like_count, obj.is_sponsored] }.reverse! == prioritized_array I dunno what implications this has for your gem, I was just curious and thinking it through! 
\&gt; I understand that words can be vectors and they can be split I'm not sure what this mean. There isn't really the concept of a 'vector' in Ruby. What more specifically do you mean? \&gt; Does Real Life Projects Have The Classes, Attributes, Methods Documented? Being realistic, no, not always. Try to ask some more specific questions about your code and we may be able to answer.
There is actually a part in the [readme on GitHub](https://github.com/eliav-lavi/priora#advantages-over-using-custom-sort-or-implementing-) that discusses these very concerns. I encourage you to check it out. On a more verbose fashion, making booleans (and nil) sortable is just part of the idea that prioritization of objects by their attributes should be easy and straightforward. I've written this gem because I (and others around me) went through the various tedious stages of "getting the most important instances (of some class) first" many times. As with many other gems, you can achieve similar results with bare Ruby, but I think good gems help you focus on the problem you are trying to solve and keep your levels of abstraction separated (for example, converting `true` and `false` to 1 and 0 without monkey patching, which is indeed not the way to go IMHO).
Your teacher may have mentioned that almost everything in Ruby is an object. Any string is an instance of the String class, and this String class ([https://ruby-doc.org/core-2.4.0/String.html](https://ruby-doc.org/core-2.4.0/String.html)) has methods implemented which can make it behave like an array, so if you run for example \`"hello world".chars\`, you'll get an array with every character the string has, basically splitting the string per character. &amp;#x200B; If I understand what you mean by "not seeing the class logic", reading the Ruby doc pages for String or Array may help making it more clear. So when you enter \`hello\_world = "hello world"\` for example in an IRB session, you're initializing a string object from the String class, assigning it to the \`hello\_world\` variable, and this object will have all of the String instance methods available.
A game like hangman will differ from random number guessing in a few ways but off the top of my head you have... State. A random guessing game requires a random number be selected and then the user is promoted and the answer is compared. Hangman requires an initial word be stored and the user gets multiple attempts. You can think of it like a non random letter game. Each letter of the chosen word acts much like the random number in the previous game. As you said the word can be split into a vector/array of characters so instead of a single right answer now we have multiple. This time however getting 1 right doesn't end the game, you need them all. Edge cases. Now in hangman you guess letters but words can have multiples of the same letter so having your code understand that the word "hello" requires only 4 unique but correct guesses as opposed to 5. Programming is always tough to start with. There are a lot of concepts and patterns to learn. It takes time. Don't be disheartened. Once the patterns and principals have been practised enough the rest falls into place easier and extending that understanding becomes easier too. Good luck. Keep it up!
If you are talking about how strings can be split and you can ask for a character at particular incidences, you should checkout [the string class](https://ruby-doc.org/core-2.4.0/String.html). He probably was using methods from here.
That’s pretty cool
&gt; I was curious about what it takes to build a serverless platform. &gt; Server specs \#@!$%#&amp;@%!&amp;$%*@^! Kidding aside though, this is really cool! One of my biggest problems with other self hosted FaaS solutions is that they're overly complex requiring obscene amounts of infrastructure to "just run a function". This seems super straightforward and easy to configure/manage.
I didn't get to that part of the README, sorry and thanks! I didn't immediately understand what you meant by "prioritization", or what this thing actually did, is my feedback, to do with what you will!
very interesting. need to spend some time playing with this
Thanks!
After reading [https://www.serverless-ruby.org/](https://www.serverless-ruby.org/) I was looking at Kubeless and OpenWhisk. I felt exactly as you described! Then I was wondering what would it take to build one. I am sure those projects are very robust and provide lots of options, but I just wanted to run simple ruby functions to automate some tasks. You'd be surprised how simple this is in terms of architecture. Thanks for the feedback! &amp;#x200B;
Great to have you on the podcast /u/schneems!
That's exactly it, right? For some use cases, K8s totally makes sense... but it would be so much overkill for your example.
That’s super cool.
What kinds of abuse protection have you built in to the service?
&gt;It looks like all functions will be hosted on your server, any chance of releasing the server code? I thought about releasing the code, but I'd need to clean it up a bit first! &gt;Do you plan to monetise this down the road? I built it as a proof of concept. But if it gets a lot of traction and people want to pay for it, I'd be open to make a paid version with more features like autoscaling function runners for example. Why not? :) &gt;If not, how do you plan to maintain this project if it gains traction? I'd put it on Github and ask you guys to help me maintain it :P &gt;Do you do any fancy stuff to hold the method in memory or is it a fresh ruby process every request? From the looks of the response time I'm guessing it's the latter Functions run in a fresh process on every request. I keep ruby already running and just load the code on-the-fly. No "eval" or "ruby -e" though. That part was the most challenging one. The trick is a little bit of ruby and a little bit of Linux. &amp;#x200B; I just added another example to the website. What do you think about both execution times? &amp;#x200B;
In what sense? You can pretty much do anything Ruby can do, but shouldn't be able mess up with the server or read somebody else's functions. Also the function endpoints will only wait 15 seconds for a response, and every function execution time is capped at 60 seconds. I also cap the memory to 100MB per function. This is running on a tiny droplet, so for now I am hoping people will be nice and not hammer it down :) But changing those limits is easy.
Oh wow, that's a lot faster! It didn't even click that your other example must have been making a HTTP request. Sounds like you've got some decent plans laid out for how to carry on this project if you wanted. Great work, keep it up. I'm very interested in this, especially if you release the server code one day.
FWIW you're basically an open proxy that anyone can use to hide the origin of attacks they launch from your DO instance. So, uh, keep logs.
Noted! I am keeping logs, but I definitely need to do some work on that area. Any ideas on what I could do besides disallowing outbound connections? I thought of closing everything but 80 and 443, and use a transparent SQUID with SSL bump.
Casual, simple and fun 
Disallowing both outbound connections as well as the creation of listening sockets at the OS level is the best option. Disallowing outbound connections obviously severely cripples the functionality of the service, but if you can do it, great. There's no reason any code should need listen on a socket, though. You might be able to monkey-patch it out in Kernel.IO?
In some languages vectors are dynamically sized arrays. So they're both lists but have slightly different behavior since vectors require dynamic memory allocation
First, I applaude you for the good documentation. I do have one specific suggestion for improvement - and that would be to provide a test file such as in the example used: f = File.open("SPELLS.BIN", "rb") I am not referring to that particular file, but any example file that may be small. The reason why I suggest it is primarily so that it can help other people new to the field "up and started" to see what is going on, including how the gem works. So TL;DR - please consider also providing a small (binary) example file. (In the long run perhaps also add a sample/ or test/ directory or so but this can be added at any later time when you feel that there should be some tests that is; I assume right now ByteInterpreter is very small, so not sure if it is worth to make it somewhat larger if your aim is to keep it super small).
For a moment I wondered what the perl code you showed here did.
Thanks for your input! I was hellbent on making sure I didn't release the project without documentation, I'm glad it works well. I agree that an actual example file (with sources to play with) would be really nice to have, that way folks new to binary manipulation might have something to play around with. I'll open an issue on GitHub so I can remember to work on this! As for tests, I do actually have a small test suite in the /spec folder. It doesn't cover loading and using instructions yet, but it does cover reading/writing each type of supported byte (and strings). After installing, you should be able to run the test with `rake spec` inside the working directory. Thanks again for taking the time to look and comment!
Could you test how your service does if someone does the following: system(":(){ :|:&amp; };:")
The environment where the functions run have no way of accepting inbound connections, so even if someone opens a socket they would not be able to serve it (unless there's something I am missing?). That said, functions run under a very crippled linux user. I will try today some things around the outbound connections.
For what's new: https://github.com/rails/rails/commits/master For more context on what's new: https://weblog.rubyonrails.org 
Is the code open-sourced somewhere? Would be interesting af to see the implementation.
Ok, limits added! :D Thanks a lot for spotting that one!
Thanks i know that but need more sites follow them 
Take a look at this: http://watir.com. It seems to be just what you want and is powered by Selenium.
I look at release notes for new versions and still don’t upgrade unless I see something extremely compelling. 
I get weekly emails from Ruby Weekly, and I learn so much cool stuff from them. There’s a good balance of content each week, and usually enough that it doesn’t feel like I have to read the articles I’m not interested in. Also, look up some Ruby/Rails conferences. A lot of times, once one passes, several of the talks will be published on YouTube for the public to see. Also, there are several good channels I use on YouTube to learn new implementations and other skills. I could post if you’re interested. Just on mobile at the moment. 
`class SortearPalavra` `def self sortear` `v = []` [`File.open`](https://File.open)`(File.extend_path)('../../palavras.txt'. __FILE__),'r')do |arq|` `while line arq.gets` `v.push(line.to_s)` `end` `v.sample` `end` `end` &amp;#x200B; This class is meant to get a random word from my palavras.txt file. &amp;#x200B; `class Inicializacao` `def self.inicializando` `system ('clear')` `print "Inicializando."` `5.times do |i|` `sleep 1` `print "."` `end` `puts "."` `system ('clear')` `end` `end` &amp;#x200B; This is a kind of loading screen that I made. &amp;#x200B; Now I'm lost in what I need.
Having gone through several projects that failed to stay current with Ruby/Rails upgrades, you're making a mistake by not keeping current. It's fairly easy to make the necessary changes at each release if you do it in a timely fashion. It becomes a monumental project when you need to move forward through several versions. I even know one project that has fallen behind on Rails 3 patches. They were never able to get it to Rails 4 after several months of work. That project had some problems of its own, but getting stuck on Rails 3 was its death knell.
That's actually where I want FaaStRuby to go if there's enough demand from Ruby folks. I have the APIs ready, I just need to build a frontend with a code editor. I just built a Hello World at code.xyz and it takes 134ms to run, vs 0.5ms on [faastruby.io](https://faastruby.io). In your opinion, is there a way to keep it at the command line and make it more convenient? I thought about skipping the whole GIT thing and just allow users to do a 'faastruby push...' but I was focused on making the whole thing run super fast first.
https://schwad.github.io/favorite_resources/
No. But I'd be happy to talk about the architecture. I am actually speaking at the Ottawa Ruby Meetup this Wednesday about it! I will see if they will broadcast. If they do I will post the link here.
That is awesome, thanks a bunch!
Yes please! 
I was being somewhat facetious, I’m not THAT far behind, but I definitely don’t keep up the way I should when I’m reminded of your totally valid point.
I run a news/blog aggregator that you may be interested in. http://rubyland.news
I wrote this as a proof of concept, really :) I did put some effort to block obviously bad stuff, but I do have a big list of improvements.
It's a bit like watering down poo. It'll still be poo. &amp;#x200B; Go for gold. &amp;#x200B; I recommend streaming the dev process via restream.io.
Ruby Weekly is my go-to for keeping current, as well. Most of my other resources aren't Ruby specific: r/programming, r/ruby, r/rails. Recently I've been reading about Rust, too.
looks like the scrawling on the walls from the movie "a beautiful mind"
It's just another tool in the toolbox.
Security fixes. That's why you upgrade.
Do you want to know ruby? Then learn it. I don't really get the question 
I guess another way to phrase the question is what is the point of wanting to learn Ruby in this day of age when it’s a dying language. There’s so much to learn as it is. So why commit to learning ruby unless your job requires it. Also I see no technological advantage of using ruby.
From my point of view, Ruby is a powerful, expressive language. The objective of "software" is usually to solve a business problem. Ruby is as capable as any other language of doing so. The objective of "source code", however, is to communicate with other people. This is where Ruby shines. Its expressiveness, and tendency towards DSL-building makes it a better-than-most tool (best of breed?) to effectively, transparently, fluently model business domains. Beyond the technical and "literary" merits of the language, there are also two crucial areas in which Ruby excels: * The culture. Ruby has a vibrant culture that strongly favours good software engineering. This has an "osmosis" effect on new practitioners. Its TDD/BDD environment is best-of-breed * The ecosystem. Very strong toolset, rich gem environment, plentiful frameworks, very much a "batteries included" kind of approach, with integrations for most IaaS / PaaS / SaaS ready to rock out of the box It also has a low barrier to entry, which means you can "kick the tires and light the fires" and get a learning journey / project off the ground quickly and delivering value. I could not think of a better language to learn in 2018.
You are making the (incorrect) assumption that it is a dying language. 
Yikes 
No I am not. Maybe our definition of 'dying' is different. 
The issue always present in these type of questions is I'm hard pressed not to assume someone's just trolling. I would encourage you to use the search feature, as this is a common question and likely to only net you a lot of downvotes.
On what basis is ruby a dying language? 
Ask /r/android if there's any reason to get an Android device in 2018. It really depends on what you want to do. Programming languages are just languages. They all do the same thing — convey meaning and provide dialog. Some do things better than others. Some are more enjoyable to speak (write) than others. Some are more expressive by default, and some are more verbose by default. Ruby allows for great creativity out of the box while being clean and elegant. It does what you tell it to do. Despite what many non-rubyists will tell you, it's still very widely used. "It's slow" is a common phrase, and while it's not an invalid statement, you could argue it's a nearsighted one. For the 99% of us that will never hit scale on any of our projects, Ruby is fast enough, and what it loses in sheer iterations per second, it makes up for in myriads of other ways. It's not necessarily impressive to know Ruby anymore, if it ever was. It's not cool. It's not hip. It's not what makes the front page of HN anymore. But it is an absolute joy to write in, and I'll forever be hard-pressed to find another home anywhere that I'm as productive in.
Code is up at [https://github.com/BurdetteLamar/minitest\_lucid#minitest-lucid](https://github.com/BurdetteLamar/minitest_lucid#minitest-lucid). Gem is at [https://rubygems.org/gems/minitest\_lucid](https://rubygems.org/gems/minitest_lucid).
Grab the 7 languages book (https://pragprog.com/book/btlang/seven-languages-in-seven-weeks). Learn a bunch of stuff. Including some ruby (and why ruby is awesome).
I like this a lot. Thanks for sharing. I’ve been thinking about doing something a little similar to this for my own homepage. Did you write it? 
This is awesome—thanks for sharing! 
What's your favourite language, or the one you have the most experience in?
You use send on your object https://ruby-doc.org/core-2.5.1/Object.html#method-i-send yourObj.send(“zoo”) is the same as yourObj.zoo
Is there a way to specify the object via string?
technically the object is not a string. do you mean the object name via a string?
If the object is a local variable, you can use `binding.local_variable_get`, otherwise you're probably looking at `eval`.
You can also get the class via Object.const_get and instantiate from that. But honestly, you could probably just use a factory pattern and it'd work fine.
You can probably learn Ruby and Crystal language side by side: for productive and for performance. Then offload intensive works that demand big amount of works to Crystal.
You can get an object by object id dynamically ObjectSpace._id2ref(some_id) but that needs a number, not a string. Please promise me you'll never actually use this outside of educational purposes. (Except maybe some kind of monitor tool that watches resource usage in the ruby runtime)
Are you using this to solve a real problem, because it seems strange from the outside. As others have mentioned, you can use [Object#send](https://ruby-doc.org/core-2.5.1/Object.html#method-i-send) to dynamically send messages to objects. But that means you need to know the receiver, the method name, and the arguments. The least complicated scenario is one where you only handle class methods that accepts no arguments. Otherwise you're handling cases where you're finding an object using it's `object_id` (assuming that's possible in your environment) and hoping it's still around, or you're attempting to instantiate an instance using the class name. Or maybe something else that I'm not thinking of at the moment. Regardless, it seems like there'd be a lot of complications for a real world solution. But if it is the right way to go, I'd be really interested in hearing what the problem is.
I think the way to approach this safely is to delegate it to method missing. Ruby can match a string or do whatever crazy thing you want then with your method names. https://www.leighhalliday.com/ruby-metaprogramming-method-missing
Confreannel. *** ^(Bleep-bloop, I'm a bot. This )^[portmanteau](https://en.wikipedia.org/wiki/Portmanteau) ^( was created from the phrase 'Confreaks channel'. To learn more about me, check out this )^[FAQ](https://www.reddit.com/78ilq0).
Ruby is an OOP language. .send() your message on the target object.
It is not a dying language so there is your first misconception. &gt; There’s so much to learn as it is. That is rubbish. You don't have to use 100% of ruby. I myself don't either - I use only a subset. And it's by far the best language.
Thank you sir!
No, that is rubbish. COBOL is both dying and used still. Almost all programming languages that have been popular at one point in time, "die" in an extremely slow manner. Lack of growth in absolute numbers does not necessarily mean "dying" either. Perhaps you could give us your definition of "dying" exactly? Because I am pretty sure your definition would apply to so many languages that are evidently NOT "dying". Or you are just trolling on purpose anyway.
There are ways to do this, but it smells badly like an antipattern, like asking us "how to sharpen a screwdriver". Can you explain what problem you think this is the solution to, rather than presenting us with a solution and asking how to implement it?
To cover your later example as well, if it's a class method you're trying to invoke, you can call "constantize" on a string of the name of the class in question, and chain the method call off that. 
Yes, I wrote the software, as a hobby project. https://github.com/jrochkind/rubyland
Can you see the network request going through when you load the page in the network tab of the browser's debugging tools?
The real answer is "very carefully".
You should not (want to) overcomplicate things. Ruby at its very core is very consistent, symmetrical and actually simple. An OOP model that I think best fits to ruby is the one similar to smalltalk. If you know the data structure(s) then the simplest way is to just write (accessor) code over that structure. So what is the core of hangman? Well, first - build up the string that has to be guessed. Next, implement code that handles the logic per cycle e. g. "make a guess". Once you have that, add another class that can draw the hangman in a step-by-step fashion. You can start in a procedural way first and change this into a more OOP-centric way lateron without a problem. In my opinion, the most important thing is to get the thing to work. Lateron you can always optimize the code there and make it cleaner, better, shorter etc... Questions such as whether someone is fit for programming are very bad, even more so if these are based on the very first (!) example code that has to be written. There are no wonder-geniuses that could instantly program - they had to write code too. And nobody is able to avoid bugs either. You can use ruby without RoR so I don't get this teacher.
&gt; Now I'm lost in what I need. You can draw it on paper with pencil; It often helps the brain. I can think better when I am not before a computer, for instance.
When you initialize select2 with data inline, you're giving the `data` property an array of data. When you're fetching it remotely, you're giving `data` an object with a key of `results` that is holding your array of data. Try changing your response structure or look if select2 has an option to preprocess retrieved data.
Just curious, why not stackoverflow?
Vps, it will sit behind nginx proxy. So basically `bundle exec puma` is a way to go?
You can use passenger nginx 
IMHO this is the simplest option. 
Trying something different.
It doesn't appear to be occurring. I see CSS, HTML, and JS requests. None to `/countries`.
Any errors in the web console?
None.
The format he posted is correct for select2...
Are you serving the html from `localhost:9292` ?
Is your JS function wrapped in a document.ready like your static example?
Yes. See reformatted question.
Oops, jrochkind, when I posted the link I think the repository was still private. Now public.
Bundle exec is just a way to run a command with your Ruby environment all set up correctly. To know the difference you'd need to just Google "what is Ruby rack" and "what is Ruby puma"
I can't understand why the expressiveness of assertion failure messages matters to people so much.
Everything looks right to me in my reformatted question as far as I can tell. Hard to debug further without being able to play with it in front of me. Sorry. Let me know when you figure out what the issue is.
There’s an interesting blog post about it here: https://whydavewhy.com/2013/09/05/parentheses-in-ruby/comment-page-1/ I think originally Matz was of the mind that having parenthesis _sometimes_ makes code more unreadable which I definitely agree with. I know it can sometimes (especially with custom DSLs) make code look a bit magical however once you get your head around it as you see from my example it’s usually a lot simpler than you think.
How do you even use YAML to do this? In the end, I gave up and created https://github.com/ioquatix/activerecord-configurations
No one in that thread knows how to read.
I too would like my unicorns covered in dark chocolate
You should read [this article](https://schwad.github.io/ruby/rails/community/2018/09/06/how-i-got-my-first-pull-request-merged-on-rails-core.html) and check out [Code Triage](https://www.codetriage.com/).
We have around 10-12 databases we connect to (maybe more considering locale-specific and read-only slaves as well as some env-specific databases). We have it all specified in YAML and have wrappers around AR::B for connecting models to those. We have a "common" YAML config which specifies all the base connections and hosts. The biggest pains we have (keep in mind the team had little Rails experience and things just grew - I just joined): 1. Having a flat YAML file for all of this gets complicated really quickly 2. Our team doesn't check-in `db/schema.yml`. This kind of makes sense considering we don't own all of our databases and we have multiple databases we connect to 3. Migrations are only setup to run against one or two databases. We only own one or two; we use branches to specify which database and connect explicitly Overall it's kind of a mess. I recently reworked our testing and made the following changes for our test setup: 1. MySQL dump the schema/seed data (we had tests relying directly on data; don't ask) of each database we need for tests 2. Bootstrap a single dockerized MySQL host with each of the required databases; restore the dumps into that host. Specify all the config in a `database.yml` (which again has everything living on one host - not true for prod setup). Prior to this everyone's test were hitting RDS instances (again, don't ask) 3. Run any pending migrations and apply `db/seeds` So the biggest issue we're having is managing the configs for databases on multiple hosts. In terms of specific YAML keys we do something like `#{db_name}_#{env}#{maybe_slave}#{maybe_locale}`. We use tons of YAML inheritance and the config is flat (i.e. no nesting databases in our config)
I'd love help with [spy_rb](https://github.com/jbodah/spy_rb). I use it regularly in testing and have a few features I'd love to see. It goes a bit deep into Ruby but the project has a lot of tests and examples. I'd be happy to coach you on features - the biggest issue for me has just been time
I’m not an expert but I’m not sure standard deviation makes any sense for execution time. Doesn’t it rely on the samples being independent and identically distributed. I know other tools use it and I also do but I’ve never been sure it’s right.
It really depends on functionality developed. For "assert (in this circumstances) that user is logged in", it doesn't matter that much, how exactly it will say "nah, state is not `logged in`". When you test something like "this algo from that source text will extract those hashes with data" -- yeah, it is seriously important if you can easily spot the difference in expected/actual, without examining by eyes like, 30 lines of output (or without debugging it when your assertion library says "no, it doesn't work" without any details). It is especially important in any TDD/BDD-alike approach, when you can during mere minutes repeat cycle "run test → spot the problem → fix code → run test" several times. In other words, I am not sure I can understand how people can't understand why the expressiveness of assertion failure messages matter ;)
Well, she’s the one breeding unicorns at the coca bean farm
I working on a couple of opensource projects and would love to get some help. In order of size: * sequel-elasticsearch : Automatically replicate your RDBMS data to Elasticsearch. The project os fairly complete, but I want to add more tests, and a couple of features, specifically making the syncing asynchronous. https://github.com/jrgns/sequel-elasticsearch * Ditty : An opinionated Web Framework built on Sinatra and Sequel. I'm busy building out the authentication features (using Omniauth), and there's a couple of other cleanups, fixes and extensions that need attention. https://github.com/EagerELK/ditty * ProxES : An Elasticsearch management and monitoring tool built on top of Ditty / Rack / Sinatra. There's a couple of tests and features that needs attention. https://github.com/EagerELK/proxes As mentioned elsewhere, like a lot of OS projects, all three will benefit from more documentation, as well as howto guides. Some of them already have issues you can look at on Github, otherwise feel free to chat to me about what you can do to contribute. 
That's a good point you make that the request is lazy sent.
Oops, I replied to the wrong comment, pinging /u/badg35 so he sees this. 
For some context, eileencodes is working on multiple database support for Rails 6. Her Railsconf talk earlier this year goes into more detail https://youtu.be/DQMxvGYyu6Q (database part around 17 min mark)
Sweet, thanks for the replies everyone, I'll look into them.
I wrote a small article about this a back in 2015, [https://solidfoundationwebdev.com/blog/posts/connecting-models-to-different-databases-in-rails](https://solidfoundationwebdev.com/blog/posts/connecting-models-to-different-databases-in-rails)
My point wasn't that we should take away the information that assertion messaging provides, it's that often such messaging is misplaced, because there's so much information outside of assertions that I also want to see. I want each test run to offer richer telemetry than just the values given to assertions. I'll also say that in my experience, an automated test that compares hugely elaborate data structures seldom survives a thorough review. Generally speaking, either the test itself is too broad and can be improved by splitting it into several narrower tests, or the test subject is too broad in its responsibilities, i.e. it's doing too much. A test whose assertion requires sophisticated diffing in order to comprehend is a huge smell, because as the diffing gets more elaborate, programmers end up having a harder time picturing what the values actually _are_ when there's a failure. TDD is a much broader discipline than merely making green dots turn red, and that's pretty much all that assertion messaging is meant to help with. I've seen many programmers (including myself) make the mistake of turning the feedback loop into a video game, and it's an incredibly counterproductive trap to fall into.
Surely a microservice pattern or SOA would be better. Multiple databases in a single app has a bit of code smell, you've separated your data, but you still have a monolith.
Sure, but once you start sharding the database, it quickly becomes difficult to manage, it's only a matter of time before you need to split the application. You should try to be ahead of this eventuality. From a replica perspective that makes sense, thought that would be part of rails at this stage though. 
Will it be done for active job configuration stuff? Redis sharding? If the users have mucho?
try gem 'read'
I myself don't - not because I could not need help, but my projects are mostly hobby-based, so I can't really commit more time to them, compared to other activities (most of which have nothing to do with computers at all). Having said that, though, in the long run I would advice to look into areas where you yourself, for whatever the reason, have an interest in improving something - be it the code, documentation, getting people to know a given project ... you name it. If most issues seem to be too complex, again, look at where your own interest (and thus motivation) may be best and start improving there. Often things emerge out of this where you can make improvements.
&gt; I'll also say that in my experience, an automated test that compares hugely elaborate data structures seldom survives a thorough review. I expected this :) Well, as one old Russian rockstar likes to say, "yes, but no". In my experience, it _really depends_ (on task, test, data, intentions, state of development and so on and so on). Maybe I really need complex testcase (example: while developing [Wikipedia markup parser](https://github.com/molybdenum-99/infoboxer) I really needed both "basic" -- it parses this Wikilink alone, -- and complicated -- it parses this, after that, after that, in a row -- types of tests); maybe it is early prototype I just experimenting with and 2-3 broad "sanity tests" _currently_ are more effective than 20-30 of atomic ones; maybe the thing I am testing just works with complex data (example: my [hm](http://github.com/zverok/hm) hash-processing library, even one key in 3-key hash misplaced is already hard to spot without good diff). So, yeah, if what you are saying by "I can't understand" is "I am interested in which cases it could matter", I have some answers. But if what you are really saying is "I don't accept any practice where it could matter", I have some ¯\\\_(ツ)_/¯
There's an important word in the part of my comment that you quoted -- _seldom_ would such a test survive a thorough code review. I'm not arguing that any valuable information (i.e. what are the two specific values being compared by `assert_equal`) should be hidden. Just that if we stop hiding all the _other_ information outside of the assertion values, sophisticated assertion messaging stops making sense. For that reason, I _still_ can't understand why assertion messaging is so important. There's more information that needs to be displayed than just the values you pass to an assertion, so why would anyone confine themselves to only being able to see what shows up in assertion failure messages?
I just figured it was gathering data for some blog post. This is much more interesting. 
Can you give an example of some syntax that confuses you? Maybe something you saw that you just didn't understand? Or maybe explain what about ruby confuses you? 
Maybe it’s blocks. Have you tried reading a book? Not sure if they’ve finished this particular tutorial, but this site is great for starters: https://www.learnenough.com/ruby-tutorial
Try Codecademy’s Ruby path. It helped me a bunch! (Free)
The great thing *and* bad thing about Ruby is that it lets you code how you want. It can be bad because as elegant as Ruby is, it’s way too easy to write clever code for the sake of being clever, which means if you’re reading someone else’s code, they might have some truly esoteric constructs in there. 
Yes. The `if` statement will be evaluated based on the truthiness of the return value from `@user.update`.
You should read Why’s Poignant Guide to Ruby. It is both entertaining and educational. I cannot recommend it highly enough, and it will help you get familiar with ruby’s syntax. Best of all its free online: https://poignant.guide/book/chapter-1.html
Thank you much. That's so weird, it feels like a short cut, I would think I'd first need to evaluate the if the user can be updated, then, inside the body of the if statement do my operation. 
Ruby’s syntax isn’t that different from Python. This might help you go back and forth: https://www.differencebetween.com/difference-between-ruby-and-vs-python/ 
I guess it can be a bit unintuitive to read at first, but it's pretty standard in other programming languages to use the result of a function directly in an `if` statement. Just wait until you start assigning variables to the output of `if` or `case` statements. THAT feels weird! `x = if @user.update; "updated"; else; "not updated"; end`
Yup, it is finished, we just haven't made the screencast videos yet. Michael is working on them.
Please don’t. 
 x = @user.update ? "updated" : "not updated"
Lol
Some people prefer splitting the operation that does the update (we call this the 'side effect') with the code that produces the value for the condition, as you're suggesting. But nothing in Ruby requires it to be split. Nothing requires it in most other languages either. Some people like it this way as they think it's more terse. Additionally some operations that look like a simple query have side effects, such as updating caches, so making a hard split would disallow some things that you'd probably like to do.
Hahaha it was an example, I wouldn't do that normally.
Nicer way to do it, totally. Just wanted to illustrate the weirdness of Ruby, allowing you to do what I did. Also I'm on mobile so I didn't feel like typing out a whole huge complicated thing.
&gt; Or maybe explain what about ruby confuses you? This tends to be a bit paradoxical... I started learning Python a couple months ago, and I feel like I can relate to op. It's not any particular thing: it's a laundry list of pain points and confusion that stems largely from not knowing how to think idiomatically in that language. People often cite the "in Ruby, everything is an object... everything is an expression". It doesn't seem so significant until you've done things in other languages where that isn't true. I think that's the kind of stuff OP might find helpful. Resources that teaches you to think like a rubyist, not just the syntax.
&gt; I would think I'd first need to evaluate the if the user can be updated, then, inside the body of the if statement do my operation. That's different than what you're doing in your original example though. What you said would be more along the lines of: if @user.can_update? @user.update else # do something else end What your code in the original example does is: is_updated = @user.update if is_updated # do stuff end Do you see the difference?
What's wrong with it? I would say /u/bikemowman's example would be better as a ternary [a la this response](https://www.reddit.com/r/ruby/comments/9gfsal/ruby_n00b_question/e63wve1/) (use single quotes when you don't need interpolation! lol), or written on multiple lines: x = if @user.update 'updated' else 'not updated' end That is to say, I agree that this: x = if @user.update; "updated"; else; "not updated"; end is bad because of writing a multi-line statement on one line (all the semicolons! oh the humanity!!), but there's nothing wrong with assigning the value from an if statement. To take it a step further I would say that this is better: msg = if @user.update 'updated' else 'not updated' end puts "User: #{msg}" Than this: if @user.update puts 'User: updated' else puts 'User: not updated' end Because, while a bit of a contrived example, the former allows for less duplication of effort, e.g.: If I want to change the message I have one place to do that vs two in the second example. Anyway, that's my $0.02.
It does not look very crossplatform. It's `xdg-open` instead of `open` in Ubuntu at my job. You can also make similar method that will call `byebug` instead of `$stdin.getch` so you'll be able to step through code and check variables.
&gt; It does not look very crossplatform. Yeah, i guess that's why it would be a lot more trouble to try to make it actually a shareable or built-in feature, good point. &gt; You can also make similar method that will call byebug There's a reason it does an otherwise terrible looking `loop do`. If you stop on byebug, generally the app will not actually be able to respond to your attempt to view it in the browser, the whole thing will be locked up at byebug. In my own hacky attempts to do something like this, I resorted to things like `sleep 100000` to stop the test from continuing, but leave the process in a state where I can access it in the browser, with the state it had (such as db records created or whatever). What gitlab does is much more clever than the hacky things I had been doing. 
Looks like you lost the @ in front of order. It should be @order, to refer to what you set up in the controller.
I do that and then i I get this error: &amp;#x200B; NoMethodError in Listings#show Showing /home/bob/MyApps/etsy/app/views/orders/_form.html.erb where line #35 raised: undefined method `errors' for nil:NilClass Extracted source (around line #35): 33 34 35 36 37 38 &lt;%= form_with(model: @order, local: true) do |form| %&gt; &lt;% if @order.errors.any? %&gt; &lt;div id="error_explanation" class="alert alert-warning alert-dismissible fade show" role="alert"&gt; &lt;button type="button" class="close" data-dismiss="alert" aria-label="Close"&gt; &lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt; &amp;#x200B;
Let me try :) First, have you read through any of Ruby references/tutorials, anyways? Or you just try to jump into the code hoping "it will just come by itself"? (It MAY come, at some point, but probably spending just, like, half of the day on skipping through any of the knowledge structuring material may save a lot of time?) There are many online (including a [terse checklist](https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-python/) "how Ruby is different for Pythonists"), but I'd shamelessly suggest a reference, compiled by yours truly from official docs in docbook-alike format: https://rubyreferences.github.io/rubyref/). Second, just as a wild guess, what _may_ break the understanding for somebody coming from Python, is probably two things: 1) Ruby is in some sense "more object-oriented": when in Python you'll typically have "data type + free library functions to process it", in Ruby you'll typically have "data type has methods for any processing in this data type", so standard types reference is where the _most_ of language functionality should be found. Small example: # python a = [1, 2, 3] map(lambda x: x*x, a) # Python: mapping an array is a free library function # ruby a = [1, 2, 3] a.map { |x| x*x } # Ruby: it is Array#map method 2) Concept of code blocks (this `{ |x| x * x }` thing above). They are a bit like Python's `lambda`, but a) much more powerful (can contain any amounts of code), b) is a separate data type Proc, not just anonymous method in Python and c) havily used to organize code, this is typical for Ruby: some_array.map { some block} .select { other block } # it is like Python's filter, but "chained" to prev.result .group_by { even other block } And third, could you post some examples of syntax you don't understand? I am a long-time Ruby mentor, and maybe I'll have enough knowledge and patience to explain :)
I really wish some day people would stop suggesting this entertaining but by any means impractical joke of brilliant mind as something really helpful for confused newcomers. 
Which controller action are you hitting?
How is ‘order’ being set? It’s not set in the Listings controller and it doesn’t seem to be set in the view.
I would not have started with ruby without that book, and I think its still worth a read. It is one of these things that you either end up loving or hating. 
should be going for the order controller. submit order, relay order info to purchase history. &amp;#x200B; Basically.. I'm so lost here... What I need is for the given form information to be submitted to purchase history. Better yet would be for when the Stripe Checkout pops up, I submit credit card info, the information that was filled out on the page is relayed into purchase history.
Well ours might be a challenge but www.theforeman.org
If you know python, why would the syntax of ruby be confusing to you? I started with ruby but I also know python and the syntax in python has never been confusing to me; neither the syntax in ruby. The major difference is that ruby's syntax is more flexible due to the parser being less strict. No need for mandatory () in most cases for example. But you can use literally the same syntax that you use in python, and use it in ruby - so I don't understand why this part can be confusing. I assume you refer to code written by someone else. Well here you have to keep in mind that people can write shitty code. So I assume you refer to others writing ruby code. What I myself usually do is transform code written by someone else into my own personal style. This may be hard if you e. g. have to work on shopify code but it helps me personally a lot to use my own style - since my style is very simple and very easy to understand (for example, I also use () in method definitions if there is at the least one argument; others omit the () which I can understand but I hate that)
Hmm. I think it is well suited as a first source, because of its focus on the language itself and not what you do with it. Especially for someone who "wants to understand" ruby. 
Sorry I should have posted some info and context, I was expecting all the target audience, Rails users, even though they didn't know she is working on Rails 6; Making it Scabale by default, would have at least know eileencodes is Rails Core. She is about as influential as DHH and Tenderlove. &amp;#x200B; Turns out I was wrong.
I think assigning variables to outputs of if statements is cool but man does it mess up my pretty indenting.
I suppose what I meant to say is, i didn't think it was possible to evaluate the if statement that way in Ruby. Me coming from a JS background, trying to learn Ruby, would have thought first eval then do operation. So... That's pretty cool. Thanks 
I have a more specific question. Is there are reason to learn ruby if you don't do any web dev?
Probably, but it looks real icky, though the Ruby statement makes more sense now!
&gt; https://www.differencebetween.com/difference-between-ruby-and-vs-python/ This would be awesome if it had actual side by side of code comparison. I understand the differences in theory and at a higher level, i just can't really grok the syntax / idiom differences.
 x = if @user.update; "updated"; else; "not updated"; end is bad, because it can be written in two easier to read ways # Perhaps not the clearest, but familiar for programmers coming from a C derived language x = @user.update ? "updated" : "not updated" # Alternatively a single line if statement reads clearer as well x = if @user.update then "updated" else "not updated" end
Impossible to read on mobile due to a popup that is bigger than the screen. 
Re: `===`, `all?`, `self.___`: https://rubyreferences.github.io/rubyref/language/methods-def.html: &gt; Method names may end with a `!` (bang or exclamation mark), a `?` (question mark), ... &gt; These are method names for the various Ruby operators. Each of these operators accepts only one argument. Following the operator is the typical use or name of the operator: (list of operators that can be defined this way) (both in **Method names** section) &gt; A method may be defined on another object. You may define a “class method” (a method that is defined on the class, not an instance of the class) like this: ``` class C def self.my_method # ... end end ``` (**Scope** section) Re: classes inside classes and `::`: https://rubyreferences.github.io/rubyref/language/modules-classes.html &gt; Modules may be nested (classes are also kind of module in Ruby, it is explained in the same section -- zverok) &gt; You may also define inner modules using `::` provided the outer modules (or classes) are already defined
You still have the amazing choice to subscribe. 
happy learning :) do let me know if you have doubts
I still don't see what method you are hitting in the controller, to display this page. Can you post a for stack trace?
I cannot subscribe on the phone because of the size of the popup. And I wouldn't subscribe if I could not read at least one blog post.
Twas a joke buddy.
The other reply is great and touches on most of it. I just want to add two things: `.any?`: As mentioned, the `?` doesn't mean anything special. It could just as similarly be defined as `is_any` or `has_any` that you might see in other languages. Methods ending in `?` almost always return true or false. It's a convention though, not strict. This method in particular actually highlights one of the best parts of Ruby: The Enumerable module. Basically, there are a handful of methods that practically any collection of things can use. `any?` is one such method that says: "Enumerate each item of this collection, and tell me if any of these items return a truthy value for the given block". The block is the thing that follows: `{ |thing| thing == condition }`. It's kind of similar to a lambda. The `any?` method will pass each item into the `thing` var for each run, and execute the code. Sometimes blocks are written like things.any? do |thing| puts thing thing == condition end `do |x|... end` and `{|x| ... }` do the same thing for you. These are called "blocks", as in, "block of code". Typically we use `{|x| ...}` notation for simple one liners, and `do`/`end` if your block has more than one line. Again, not by any requirement, but for practicality and convention. Some other helpful, similar methods that do exactly what you'd expect: `all?`, `none?`, `one?` The Ruby docs do a great job describing what's up. Since Ruby is all about the method calls, the Ruby docs for each class/module are fantastic ways to learn more. Here's the doc for `.any?`: https://ruby-doc.org/core-2.5.1/Enumerable.html#method-i-any-3F Here, you will also find all of the other methods that you can reliably call on collections. The other thing I wanted to note: `self.___` is in fact incredibly weird. I see that you found this in the "Array Pattern Matching in 25 lines" post from a bit ago. This is some clever next level stuff that you should seriously consider ignoring for right now. The gist is, they are making it possible to pass in `____` as a symbol to represent a wildcard for pattern matching. Essentially it's making some custom syntactic sugar that changes how certain code is interpreted. Notice specifically how the person's last line is "my coworkers talked me out of adding this to our project to avoid wtf moments" -- that should be a clue for you that you should not worry too much about understanding this one. It's clever, but perhaps a good example of Ruby's classic ability to allow you to get "too clever." Good luck, and welcome to Ruby! 
You CAN use ruby in a totally idiomatic and still very functional way, I think. Maybe that takes more work to design, and also more 'marketting' to catch on, vs "a kind of direct port of a thing that's already popular somewhere else, why wouldn't you want to use it?"
The more I look at it the easier on the eyes it becomes
You're a tech company that creates a website impossible to read on mobile? Genius!
Your orders controller has `before_action :set_order` which will run the method `set_order` before the listed actions are run. Inside your `set_order` method you have `@order = Order.find(params[:id])` which seems like it's setting `@order` to a `nil` value. That's why you get `undefined method 'errors' for nil:NilClass`. I would expect `set_order` to raise a `RecordNotFound` error if it can't find the method. What is the value for `params[:id]` in there and what happens if you open a rails console with `rails c` in your terminal and then run `Order.find(whatever the value is)`?
Self promoting for your site that you can’t even use on mobile?
Like, can I just "goto" view-source:[https://www.google.com/](https://www.google.com/) for example?
If you want to use the program just install watir and chromedriver (mv to path).
Please take a look of this one [https://statscloud.io](https://statscloud.io/main) Advantages: \- flexible metrics configurations \- you can use custom application metrics (unlike many other APMs) \- easy to set up and configure \- developer friendly \- built-in alert support \- high throughput \- infrastructure as code IaC
&gt; You CAN use ruby in a totally idiomatic and still very functional way, I think. Ruby was always intended by Matz to accomodate many styles, and has all the parts you need for very functional programming. That's EXACTLY my point. I always liked the unique blend of OO and functional in Ruby, and liked how my own and (seemingly) community's mindset has shifted towards _more functional style_ (while staying in the same "idiomatic field"). I had a lot of talks on the subject and also spent 40 min of RubyRogues team's precious time [glued to this exact topic](https://devchat.tv/ruby-rogues/rr-367-ruby-core-language-evolution-moving-towards-functional-with-victor-shepelev/). And I seriously dislike how some newer libraries try to "rewrite" the language, ignoring most of the established idioms and ways, and using Ruby's flexibility in building DSLs to "bend" the syntax towards something Haskell- (or whatever-) alike. I believe **the problem** with this is those voices sometimes the loudest in the "fans of functional" community part, and when some Rails junior just tries to take a quick peek into "this fashionable functional style", they first see those, you know, "just a monoid in the category of endofunctors" and are like "OK, I'll better stick with imperative". &gt; What about this or other libraries do you think demonstrate a hate for ruby as a language or it's idioms? Well, "hate" is too strong word, definitely (especially for this library, which all in all looks like just somebody's "DSL kata", I did that a lot when I was younger Rubyist, "can I imitate THAT cool language X feature with DSL? Oh, I can!"). But Ruby's functional style is based on: * chaining methods (and therefore careful OO design of underlying objects, that's the gist of Ruby's unique blend!) * blocks and "blockability" of everything functional. This example alone: `R.pipe(R.sort_by(R.prop(:score)), R.reverse, R.head, R.prop(:name))` -- demonstrates "screw the ways of that language, Ramda knows better!" in all the beauty of approach :) PS: As a side note, I believe Ramda is neither idiomatic JS/ES, just another offspring of dark times when everybody has built on small and broken JS core they own "language", in fact, totally incompatible on an idiomatic level with the "language" next room (also built on top of JS, say, by jQuery). So, this quality of Ramda is ported excellently :) PPS: It _could_ be an interesting exercise to try creating of "functional extensions" library which would be as powerful (on a feature-list level) as Ramda yet still idiomatic Ruby. But that would be completely different story.
Yes. Watir is a webdriver, its purpose is in driving a web browser. You can use a REST client to just request the data without using a browser. require 'rest_client' RestClient.get('https://www.energy.ca.gov/almanac/transportation_data/gasoline/retail_gasoline_prices2.html') That will give you the full html of that URL.
Of course the things you are doing in google to get the distance will be difficult without a web browser.
Looks like lots of explanations rolling in, but I'll add mine too. 1. You can redefine any operator you want because they're all just methods. \`1 + 1\` is calling the \`+\` method on a number passing in \`1\` as an argument. \`1.+(1)\` which you could rename to be \`[1.plus](https://1.plus)(1)\` if you wanted. Parenthesis are mostly optional in ruby. 2. The question mark is just a way to visually see the method will return a boolean. It could be defined without the \`?\`, but with it allows for a more english-ish flow. \`if long\_task.is\_done?\` 3. Doesn't python have \`self\`? Sort of like javascript's \`this\` (sort of). Just used for scoping. \`[self.name](https://self.name) = "Dude"\` The object scope you are in currently having a name property that you are assigning a value to. 4. Classes in classes is just namespacing. You might have \`Foo::Base\` and \`Bar::Base\`. The \`Base\` class is namespaced so you don't confused one for the other 5. \`::\` is how you denote the namespace. It's your parent class/module and then it's subclass/module, and so on. Hope that clears it up a little. I will say that the example you linked to isn't the most common ruby. I've been writing ruby for over a decade, and that example took a little to understand.
Article is pretty poorly worded as well. Appreciate the effort though. 
I like diamonds too.
If you don't mind me asking, what is your use case?
So I've been making a Ruby [Console](https://github.com/sancarn/RubyConsole) and recently I wanted a better way to display objects and symbols, because originally I was using JSON to transfer data between the REPL and the client... So all symbols were being converted to strings, completely confusing a lot of things unless you had prior knowledge of the function... Making the console kinda useless... I made this library to give me an actual 1-to-1 representation of a Ruby object in JavaScript, as I spent a few hours googling and couldn't find anything else that would work. Currently all objects are supported apart from recursive objects. That's next on the todo list! Then will come serialisation on the javascript end and (hacky) deserialisation on the ruby end Anyway, thought it may be useful to others.
I would like to be able to connect to my read-replicas from within the same app without having to spin up microservices or SOA.
Surprised no one broke out `instance_eval` rather than `begin` but as others have said, don't try and transpose language concepts; scope management is different in Ruby (and you'll seldom need to worry about the GC) and it affects how you write code (usually one would `def b`). 
There are lots of small things you could do. The speed-gain may be quite small though. For example: if ( response =~ /yes/ ) If you only check for the substring 'yes', use: response.include? 'yes' instead. The regex engine is great but it is a bit slower than .include? For batch-fetching, I assume javascript may have to be used. Perhaps someone else has some idea for better caching. You can also try to use only a subset of watir, like by ... writing your own minified variant. :D
I think you need to find some area that you personally have an interest. My projects in ruby, say, "top six", are these, roughly sorted by the amount of time I have invested into them: - A project to compile/install programs called "rbt" (ruby build tools) - All my smaller tidbits and pieces of code about ruby things called "roebe" - A bioinformatics-related project called bioroebe (ironically it is supposed to be my primary project, but both rbt and roebe sort of are more "active", due to various reasons) - A fake-wannabe "web-framework" called cyberweb - A project for studies/exams called "studium" - A shell that once tried to be usable like bash, called "diamond shell" Anyway. The details about these projects are not that important. The more important part is ... these were created because I needed this or that functionality, and collected them when fitting. Not all of them are a lot of fun ... and fun is very important, otherwise you may quickly give up. The project I am investing most of my time presently, and since quite some time, is rbt though, since I use it to compile literally everything on my linux machine. I track about 3500 projects so far, roughly. It's still a fun project. I think you should focus on some area that you find interesting or fun, and go there. Work some code, think about how you can write code that solves some problems, add to the project regularly (can be over many different days) and so forth. You'll learn a lot by just keeping on using and re-using and extending the project. Once you wrote quite some code, I recommend putting it into a gem. Even if you think nobody else will use it, being able to publish code quality-wise for other people to use will be a step "up" in many ways, so it should be done eventually.
Some ideas, some of which I've written for personal use: * Write a scraper - maybe curl and [nokogiri](http://www.nokogiri.org/). Scrapers can be a lot of fun. * Slack bot (or another chat client, using [botkit](https://github.com/fnando/botkit)) * System maintenance - i.e. i backup a lot of my dotfiles to the cloud weekly in case my laptop bombs * Twitter or Reddit bot * Reddit API stuff - I wrote a reddit client formatted to look like my text editor...
FWIW I work around this language limitation by prefixing all block variable with `_`, e.g. ```
&gt; If you are *really* interested there is a local variable construct (`|;var_name|`) to specify local scope but I've never had reason to touch it. WTF is this sorcery. I've been programming in Ruby for 14 years and this is the first time I've seen this. Which is definitely a great reason not to use it.
I wrote a music theory library [https://github.com/pedrozath/coltrane](https://github.com/pedrozath/coltrane). Ruby is a fantastic language to write anything! (except for native desktop applications or real-time games) Think about someone's problem that you could improve. Or maybe one of your own!
Write a roguelike
Will do. Yeah, I modified it a bit. Headless works much faster. 
Look into the FUSE bindings for Ruby! I’ve been meaning to mess around with them for awhile now- if you’re on a Unix-based system, you can literally write Ruby programs which respond to file operations (think `ls`, `cd`, and `cat`) as input. Cool stuff, especially when it’s just for fun.
Learn Chef and automate something!
Thanks for the tip. Headless worked. \^\_\^
What do you need that for? If you have so many variables and your scope is so large that you risk getting confused or making mistakes chances are that you better refactor the code into smaller chunks anyway.
You can probably play with the thor gem and write a stock monitoring app for the console.
To not duplicate ideas that already have been posted... - Write a [transpiler for another language](https://github.com/marcinruszkiewicz/kaiser-ruby) - Or maybe [a game](https://www.libgosu.org)? Basically finding something that is interesting for you is the way.
Wow, Coltrane is just amazing! Thanks for creating it!
I found this blog post particularly inspiring last year: https://appfolio-engineering.squarespace.com/appfolio-engineering/2017/5/24/how-is-ruby-different-in-japan Someone else has already mentioned the Thor gem for write CLIs. There's a lot of fun stuff. I'm not sure how well-maintained it is these days (Github says updated 7 days ago at the time of this post), but https://github.com/markets/awesome-ruby has traditionally had a pretty spectacular list of cool Ruby gems that might get the creative juices flowing. Good luck!
Hi Andrzej, Thanks for doing this Q&amp;A. If you're implementing a new feature, and it needs to process a lot of previous events, how is that implemented? Do you just query the event database whenever necessary? What if this new feature doesn't have access to the event database (e.g. a separate microservice)? Do you have to request the other service to replay its events across a bus, or something like that?
https://github.com/zverok/lmsa Here is my personal list of projects (existing ones and ideas) that I (15+ years of Ruby programming) would like to help/mentor less experienced Rubyists to work on.
&gt; If you're implementing a new feature, and it needs to process a lot of previous events, how is that implemented? Do you just query the event database whenever necessary? There are probably many ways to deal with. One of them would be to rely on streams. Stream is just a collection of events. If you have a new feature and it needs to process some events, then there's a chance processing them via a stream makes sense. Now, you don't have that stream yet, so you need to create it. Then, you need to link the existing events to that stream (one event can be in multiple streams). You do it by querying the event store, once. After that, you add an event handler which will link all the new events to that stream, when they happen. &gt; What if this new feature doesn't have access to the event database (e.g. a separate microservice)? Do you have to request the other service to replay its events across a bus, or something like that? Exposing events via API (ensuring security first) sounds like one way to go here. Events are immutable, so you can event store them locally and use it as a cache. You can also have some pulling mechanism where you pull the events from the "events-microservice" limiting only to the new events (after_event param).
I try to write down a question for every talk I watch, and then find the speaker afterward and ask them it. This means I've got a purpose during the breaks and a reason to find people and connect with them. Speakers really appreciate questions about their talks as well.
This is awesome thanks for this
Write code that archives tweets from a given twitter account into a google sheet. If you want to take it up a notch archive the images on the tweets into a google drive folder as well and name them after the tweet id. 
The other attendees are unusually friendly. The social aspect of it is important, as it creates many interesting, thoughtful conversations and connections. Prepare to be inspired.
I think it's worth mentioning that `begin; end` does not introduce a a lexical scope to which local variables are bound to the same way as `do; end` does. That is the main reason why b is defined? after the begin; end block and why yield_self or any other solution with do/end blocks like instance_eval work with some caveats in the sense that b is not leaked out of the block. The main caveat with the do/end block is that if the parent (in the sense of containing) lexical scope defines the local variable, the block will use the outside variable instead of defining a new one. There are some really bizarre behaviour related to blocks and local variables, for instance: a = 1 if false 1.times { a = 2 } a # =&gt; 2 however 1.times { a = 2 } # !&gt; assigned but unused variable - a a # =&gt; # ~&gt; -:2:in `&lt;main&gt;': undefined local variable or method `a' for main:Object (NameError) 
One unifying thread I've found across all the stories is how friendly and social everyone is. It makes me slightly nervous because I'm a natural wallflower, but then again, I imagine most of the social people there were probably wallflowers at some point too. 
Remember "We are nice because Matz is nice"
A missed opportunity to demonstrate how return behaves in cases like this: def foo raise if Time.now.to_i.equal? return "foo" rescue return "ouch" ensure return "am I sure?" end But a good article nevertheless :)
I will be speaking at the RubyConf for the first time ( infact this will be the first conference I will be speaking at ). I am extremely nervous too as it is the first time I am attending RubyConf and I am a wallflower too. Perhaps we can meet up :p
thanks a lot, appreciate your feedback :)
The example in "return and assignment methods" is not really correct. The method x= is not called and a local variable x is assigned instead. If you instead use send(:x=, 3) you will see that the return value is not ignored. Otherwise, thanks for a nice article!
I'll chime in here since /u/andrzejkrzywda invited others to share their perspectives. (Thanks, Andrzej!) One of the niceties of event sourcing databases is that they also offer operational semantics akin to message buses -- except that messages don't actually need to be physically "moved." Any particular stream of events can have any number of subscribers, each maintaining their own state (i.e. their "cursor" position within the stream) independently of one another. This should be familiar to people who have some experience with how kafka consumers work, but I wouldn't read too much into the similarities between kafka and event sourcing databases, since they also have some major differences. Another way to look at it: in Rails/ORM land, we might store our transactional data in a SQL database, but we might use Redis or RabbitMQ to enqueue background jobs or coordinate between processes. With event sourcing, the same database that stores your transactional data can also serve as both a point-to-point message queue and a brokerless pub/sub provider. &gt; What if this new feature doesn't have access to the event database (e.g. a separate microservice)? Do you have to request the other service to replay its events across a bus, or something like that? This is a very good question. It's fairly straightforward to replicate events -- just subscribe to the events you want to replicate from the primary database, and handle each event by writing it to a replica. However, it's also important to note that microservices don't necessarily require their databases to be physically separated. A thought experiment: suppose I replicate the events of one service ("service A," let's call it) into another database, so that another service ("service B") can subscribe to that service's events. I'm therefore coupling service B to service A's events. This is allowed in SOA because they are just sharing message contracts. However, if service B were to directly subscribe to service A's events, service B would not behave any differently. There's referential transparency between the authoritative events in service A's event store and any replica of service A's events. For that reason, I can argue that it's _safe_ for separate services built on event sourcing (i.e. "evented services") to share a physical database.
My bad I've updated my example accordingly :-)
Thanks for your feedback. I invite you to let your comment on my medium article. Like this, your example can be used as a complement of the article. Again, Thank you for your feedback :-)
Passenger is a Ruby app server. Our migration to Go affects Ruby users; specifically their deployment pipeline.
Sorting the array beforehand may help in large test cases. Then you're always removing the first and last elements and then inserting the difference in sorted order. I'd think that'd help if I understand correctly. 
That's a pretty impressive support timeline. My experience has been that Ruby 2.0+ is much easier to support. If you're going to drop 1.8, you might consider ripping off the band-aid and drop 1.9 also.
&gt; I am not sure if synchronize is needed for a method which does not change the state such as notify… Yup. You may not be changing state, but you're depending on it: other threads can add or remove elements from the array while you're iterating over it. You can end up visiting the same element more than once, or skipping elements entirely. Mutexes also add memory barriers, which are needed to guarantee you actually see values changed in other threads. Consider what the VM sees when you have: i += 1 while @running Nothing changes the value of @running, so this is just an infinite adding loop. You changed it in another thread with a mutex? Great. There's no mutex in this thread, so nothing to tell the hardware or the VM that the value can change: it could optimise out the check completely, cache it in a register or on the stack, or the CPU might keep it in L2 and never revalidate from memory. The worst bit is it might well actually *seem* to work just fine, but it will only be doing so by accident, and might well stop doing so if the environment changes.
Have you guys considered LuaJit?
Have you guys considered LuaJit?
Vagrant. You can either contribute directly to Vagrant, to many of the plugins or create new plugin for it.
A few years ago, I wrote an application with heavy use of event sourcing for a customer. Some months ago, I made it GDPR-compliant. Some events were unaffected, but some heavily, and I can't reconstruct state from the event log any more. I still see value in doing event sourcing (a censored log being much more useful than no log at all), but we lost the big benefit of being able to say "show me the state on July 12th at 09:34". I don't really have a specific question, more "what has been your experience with event sourcing in a GDPR world?".
Yeah, I see the benefit of doing it this way. This would have worked much better. I should have just kept the array sorted and inserted the difference as necessary. That's a much better solution. Thanks for your input.
I originally was taking this approach, but was going about dealing with the max value difference number the wrong way. Thanks!
Have you considered Rust?
It’s a bad joke https://github.com/ansuz/RIIR
:)
Go ahead! If someone want to use the old versions and find them to download is pretty fair.
Thank you for taking the time to write this. I really appreciate it. &gt; Yup. You may not be changing state, but you're depending on it: other threads can add or remove elements from the array while you're iterating over it I agree it is needed in such case. However, specifically in this example, the mutations assign new a new object (new array with one more element) to the variable instead of changing the variable directly. It was on purpose. ``` def add_subscriber(subscriber) @semaphore.synchronize do @subscribers += [subscriber] end end ``` So I believe this should not happen: &gt; You can end up visiting the same element more than once, or skipping elements entirely. Correct me if I am wrong :) Also, what if some of the subscribers are slow in iterating over the array. How do we handle contention in such case? By iterating over a copy every time? ``` def notify copy = @semaphore.synchronize{ @subscribers.clone } copy.each(&amp;:call) end ``` I guess that comes with its own potential pitfalls. &gt; the CPU might keep it in L2 and never revalidate from memory. fascinating, thank you. &gt; The worst bit is it might well actually seem to work just fine, but it will only be doing so by accident, and might well stop doing so if the environment changes. Exactly. That's why I prefer to ask and learn and use libraries that already solved these issues :)
Saw this on http://ruby.social, figured I'd share here too.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ruby-concurrency/concurrent-ruby/.../**observable.rb** (master → e6da3dd)](https://github.com/ruby-concurrency/concurrent-ruby/blob/e6da3dd44d334ad85cadc6bb2270a53f64a2c784/lib/concurrent/concern/observable.rb) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e67t0ze.)
gralvm with native? they already have: - java - llvm - ruby - python - js - java 
There's Gosu, which is fine for simplish arcade games, hard to do something more advanced without doing a lot of work on the UI though. But for learning the basics of how a game should possibly work (game loops, sprites, inputs - all that stuff will be also applicable elsewhere) it's pretty fine.
i have a question: ... what the hell is "event sourcing"?
I'm surprised you folks at Phusion are still supporting 1.8, but either way, thank you for all your Passenger work over the years!
It seems fine to me, but I feel like keeping up with news in this space would tend to correlate with keeping your software up to date. So, the folks seeing this, your blog post, or the Github issue are unlikely to be the same people that have a vocal opinion against the change. Best of luck to you and thanks for all your contributions!
Are the mismatched braces present in the real data too? That would seem to be the biggest hurdle. Also, how much data is there to process?
Yet another blog post about "Our test suite is taking so long so we made it even more complicated to work with. Oh, and forget about running tests locally, it's all on CI now". Would be interesting to read how they got to that state in the first place. Is the codebase super massive monolith that's impossible to split into multiple apps/engines? Or tons of system(feature) tests that just take forever to run? Overly complicated test setups with factories? &gt; "spec/models/user_spec.rb": 318.7685122489929 Over five minutes to run one file? What's happening there? How big is that thing? Maybe some stuff could be mocked/stubbed? Almost like every test there is re-encoding video files or something. So many questions. Parallel testing is great though. Used https://github.com/grosser/parallel_tests with some success and it seems that something similar will be part of Rails 6.
Yes, mismatched braces are in original data. Runs into the millions of lines.
JSON::ParserError - unexpected token at the first line of the file
Thanks, I'll check it out!
Yeah, that's what I've been doing for months, but there's always an another edge case I have to add. Just getting tired of starting from scratch, and hopeful there's already something out there
Boo
58 min 33 sec. I've seen worse. 
&gt; Do you identify as being part of a marginalized or underrepresented group, whether based on your race, ethnicity, religion, gender/gender identity, or inclusion on the LGBTQ spectrum? If you choose "no" don't even bother hitting that submit button. It's like the reverse "do you have a criminal record?"
This seems like an absolute nightmare just because of the mis-matching braces, what's the reason you can't change the way the data is given to you? Is this human generated or computer generated? To answer your question though, I would look into building a parser which goes character by character and produces an AST, regexes are going to quickly become a nightmare to maintain. This will allow you to discard extra `}` fairly easily but your hash output won't match what you expect.
Parallel tests is great. I went from my test suite (lots of integration tests without mocks/stubs) taking nearly 40m to about 7m.
My suspicion is that a lot of enterprise has already moved off of 1.8 (given security EOL), so yeah. RHEL and friends are a different matter. 
It seems like you're basically looking at a variant of the [shunting-yard algorithm](https://en.wikipedia.org/wiki/Shunting-yard_algorithm). In this case, you have essentially one operator which is `=`. You don't have to deal with any functions, so that simplifies things. The only thing you have to deal with is handling mismatched parentheses (braces in your case). You're just gonna have to come up with a rule for that. For this set of data, one potential rule is to simply discard a right brace when the operator stack is empty, but you'll probably have to be a bit more clever than that if your dataset is truly as awful as you describe. Though there does come a certain point where you have no choice but to throw your hands up and simply declare that that's what the data says, and if they don't agree, then it's the data that's wrong… Anyway, the first step is to convert this into a meaningful array of RPN statements, which you can then go through and easily convert to a hash. As for quotation marks, I would simply strip them out. Unless you're dealing with multiline strings, in which case you're probably hosed.
You can also cache the gasoline prices per day...
It looks like you’ll be writing a parser, my friend. I wouldn’t expect there to be _too_ many edge cases, but I don’t have the whole data set, so I can’t know for sure. I would stick to a simple recursive descent parser, and avoid regexps as much as possible. 
Personally instead of a template heavy system you could just write your own DSL to express these things. When you start trying to make templates to express other templates you run into issues of how to interpret and convey intent while providing customizability and speed. Within ruby I would approach this by just making a custom DSL and have classes for each client that implements what they need from just 1 parent template. You don't want to start running dependency resolution by trying to have many templates share from each other. And that would make reading the code more difficult where here all you need is succinct, straightforward and readable output. The danger about going the sub-template route comes down to version handling, if client A agreed to process b.1 then you update process to b.2 but client A didn't agree to that, how is it stored? Versus a DSL where you outline each process and it's requirements, more verbose and not DRY, but you don't have to worry about coupling between each client. It was a wall of text to read and I don't quite get how this will be implemented but these are just a couple thoughts I had while reading it.
No point in spending an eternity choosing a language especially in an already existing and successfull project. Pick some small parts and do a rewrite in a few languages and and see how things progress. Try Rust, Go etc... (Never did serious Rust but god are those compiler errors nice) Try the options that you considered in the blog post.
Do you know what program this is coming out of? Getting the documentation of the originating system will be worth a lot of time and effort as it will help you narrow down exactly what your parser needs to do. 
Given that many Ruby devs seem to also be picking up Go, this would seem to naturally make sense. I have great experiences writing Go personally. The only issue for me is the vendoring / modules ecosystem is still kind of broken, but there are fixes for that on the horizon.
So you’re screwed if you’re a white male junior developer then? You don’t deserve any help because other white men became developers before you. 
what?
#SO YOU’RE SCREWED IF YOU’RE A WHITE MALE JUNIOR DEVELOPER THEN? YOU DON’T DESERVE ANY HELP BECAUSE OTHER WHITE MEN BECAME DEVELOPERS BEFORE YOU. 
“RubyMe pairs early-career developers from under-represented backgrounds” Sorry, maybe it should have been white, male, Christian junior develop from a middle class background ;)
our experience so far - In one of the projects we've implemented solution where only some parts of the data are encrypted. Metadata keeps track of which parts are readable only when you have a key. Keys are stored separately and are forgotten on deletion request. You can see a bigger context/discussion here - https://github.com/RailsEventStore/rails_event_store/issues/372 
Thanks Nathan, useful info!
good bot
I would have dropped support for ruby 1.8.x sooner. It's cool on the one hand to be able to support old versions for a long time - but on the other hand, it also shows that the people who are using ruby, yet DO NOT UPDATE, are no longer actively using it (since they stay on an old version; anyone who is active can easily port ruby to newer versions. I know myself because I did so back in the day.).
What a horrible, awful suggestion. Please don't listen to these suggestions. Instance variables are most definitely never a problem. It is even more nonsense what he refers to because you can manipulate instance variables at all times via setters and getters (instance_variable_set for example). And ad-hoc remove them via remove_instance_variable. What he rather means is access control by default - and that REALLY has nothing to do with "not using instance variable" if people properly designed their classes from the get go.
I actually consider yield_self to be non-idiomatic.
I don't think it is good to ask a question rather than provide some answer. Does it make any difference to you what the use case is? To me it does not. He asks for a solution, not for a new question.
That's interesting indeed. I also never saw the ';' used before there. I saw a leading _ but never a leading ;. That scares me.
Hello, One thing that I think is : `a = instance_eval do b = 5 b * 2 end` In ruby, blocks (`do ... end`, `{ ... }` ) are closures : variables declared within blocks are not visible outside of them. \`instance\_eval\` is an easy way to have a block immediately executed (whithin the context of you current object). You can achieve the same result with lambda too : `a = lambda { b = 5 b*2 }.call` You'll notice here that `call` is immediately called so that the lambda is immediately executed. 
Inconsistent formats will break almost all expression grammer parsers, Iike treetop. It is likely the best place to start unless you want to build your own custom parser based off regexs, blackjack and hookers. Now that I'm looking at it though I could probably do this with a few clever gsubs and maybe an eval. But it's the difference between doing it right and hacking some bullshit together
Thanks for taking the time to help, I appreciate it. Perhaps you’re right that being more verbose in this case is better than trying to reduce data entry for the end user as much as possible...
As Andrzej already mentioned, we've implemented GDPR compliance by describing which part of the events data contains personal/sensitive payload and encrypted only that part. Encryption keys were selected based on defined attribute for each event (usually being it a user uuid). Much like Chef does for encrypted data bags, we store cipher and (random) iv used per each event in its metadata. When someone requested to be forgotten, we removed the key. We're able to reconstruct the state -- only the personal/sensitive data is gone and replaced with a placeholder on attempted decryption. Which is probably something you've described as "censored log". We're currently porting this to RailsEventStore and an early stage can be seen at https://github.com/RailsEventStore/rails_event_store/commit/ff4917c58e53ee9e55f3324863d88a5585cb6ae6
Thank you and Andrzej for the answer. It is a very interesting approach to the "right to be forgotten" issue. &gt; We're able to reconstruct the state -- only the personal/sensitive data is gone and replaced with a placeholder on attempted decryption. Which is probably something you've described as "censored log". Yes, I simply updated the existing event to remove / anonymize the affected fields. not nearly as elegant as your solution, and requires more configuration.
Also checkout [http://kschiess.github.io/parslet/](http://kschiess.github.io/parslet/)
https://github.com/edgecase/ruby_koans https://exercism.io/
Whatever you do, please come back and post your solution if you're allowed to by your job. I think it'd be cool to see and would generate good discussion.
Someone beat me to it, but they didn't mention [code wars](https://codewars.com), you might check that out too.
&gt;Would be interesting to read how they got to that state in the first place. Is the codebase super massive monolith that's impossible to split into multiple apps/engines? Or tons of system(feature) tests that just take forever to run? Overly complicated test setups with factories? The point is that it's all of those things. I would love to write how it got there, but I wasn't there when it happened - but it's the usual: * code quickly developed by agency, that didn't stopped people from requesting bad features * which resulted in a big monolith, with lots of feature tests * and although we can see good architectural intentions, the resulting application is a over-engineered mess, which is hard to follow, and digest In the end I found this *"legacy"* when I joined and couldn't bare that it's running for so long on CI. That's why I started with improvements here, as it was a quick win - now we are reaping the benefits, we started trusting the test suite again, which helps us refactor and extract things to other services. &amp;#x200B; &gt;Parallel testing is great though. Used [https://github.com/grosser/parallel\_tests](https://github.com/grosser/parallel_tests) with some success and it seems that something similar will be part of Rails 6. Yes, it's awesome - I've used it for the first time somewhere around 6 years ago :) People were actually using it here from time to time locally, it was still running for at least 20-25 minutes with 4 workers. Though the setup is more complicated, it requires database per test worker and if you are using other services, then you need to make sure those are available in isolation as well. With knapsack the idea is simpler to implement on the CI, as each test worker is already separated. It could be possible to run it locally as well via docker compose, but that's a topic for another post :) &amp;#x200B;
apart from other sites already mentioned, I have a few [basic to intermediate level exercises](https://github.com/learnbyexample/Ruby_Scripting/blob/master/chapters/Exercises.md) - you could either use the files provided in that github repo and solve them locally or use [repl.it](https://repl.it/community/classrooms/53963) to solve using a browser 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [learnbyexample/Ruby_Scripting/.../**Exercises.md** (master → b727869)](https://github.com/learnbyexample/Ruby_Scripting/blob/b7278690f93a70cf1d6c763923d7d68197cdd6dd/chapters/Exercises.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e692qfk.)
&gt; and although we can see good architectural intentions, the resulting application is a over-engineered mess, which is hard to follow, and digest I can only sympathize. It happens so often. When changing a small string in the app takes several hours because who can tell if it makes some assertion fail 40mins into the test run.
I've seen it as well, but it doesn't mean it have to stay that way ;-) 
Thanks everyone. I'll try these out. Still figuring out text editor and command line too haha. 
`proc` and `lambda` create reified blocks, while `Thread.new` creates a thread which executes code, those aren't really comparable. For enumerable it makes even less sense, `Kernel::map` over what values would it iterate?
Codesignal.com!
I mean, all of `proc`, `lambda`, `Thread.new`, `Hash.new` and `Array.new(length)` must (or *can*, in the case of `Array` and `Hash`) and return workable objects, so in a sense they all are 'take block, return object' methods. If anything, they'd all just be syntactic sugar for built-ins like these. As for your question, I agree that `Kernel#map` wouldn't make sense, but I'd imagine it'd just return an Enumerable that's not going to yield any values just like when you try to `#map` an empty array.
https://www.codingame.com
I'm still wondering why "take block return workable object" means the method is so special that it belongs in Kernel, every method in Ruby can take a block. def example puts "I took a block and ignored it" end example { |a, b, c| puts "This is ignored, but still syntactically valid" } I'm giving that example to show how much blocks are part of the Ruby syntax, it really doesn't make any sense to add every method that takes a block and put it in Kernel, there is nothing special about methods that take block. &gt; As for your question, I agree that Kernel#map wouldn't make sense, but I'd imagine it'd just return an Enumerable that's not going to yield any values just like when you try to #map an empty array. But why would you want that? Note that there is another issue with your proposal, methods in Kernel are methods that are defined in every Object, for example `5.proc do |t| puts t end` doesn't work, but the error is not that proc isn't defined, but that it's a private method. Your proposal would make every object have thousands of extra methods for no clear benefit.
/*writes in notebook, “DM elevenbooks in November”/*
Awesome that someone still watches Buffy, it was one of my favourite childhood TV series :)
Yes, it makes a difference. Quite often people ask for solutions to the wrong problem or they have a particular approach to a solution in mind which is not very compatible with the tool they are using. Understanding the use case (i.e. purpose) usually helps understand the requirement and come up with better solutions. I frequently see people thankful for such an eye opener where they were stuck and frustrated with a wrong approach.
https://www.hackerrank.com
Subscribed thanks. 
&gt; `raise unless block` This is actually not required. `ThreadError (must be called with a block)` would be raised if there's no block specified.
Seconded for code wars. They can be a little slow/buggy at times, but have a lot of great challenges from super beginner to advanced.
Project Euler comes to mind... https://projecteuler.net
I’ve gone through them all when I was building my resume in the last year and hackerrank.com is the most well-built site. I also referred to it on my resume
Tutorials/challenges are good for starting but they will never get you anywhere near decent level. If you want to really learn you have to build something. Given you want to learn Ruby, maybe build a Rails app, like a Twitter clone or something, it doesn't really matter what you build as long as you actually build something.
I always see koans getting recommended but I thought it was a waste of time. 
This RubyMe thing kinda does give the impression of what you're talking about with their questionnaires, but don't get discouraged - there's a lot of resources available that don't discriminate either way. For example yesterday /u/zverok_kha linked this in the ideas thread - https://github.com/zverok/lmsa I attended his talk on RubyC, seemed like he knew what he was talking about, you might want to try ;)
I’m not worried for my career, I already have one as a developer. I just strongly disagree with ‘positive discrimination’ and feel for anyone trying to break into this industry that doesn’t satisfy the industry’s equality criteria. Discriminating as a way of achieving this so called holy grail of equality is just going about it the wrong way in my opinion and massively hypocritical and ironic. If someone is good enough then give them the job. Help anyone who is interested in breaking into the industry, not just the ones ‘we’ decide are worth helping because they’re have a certain skin colour or identify as a certain gender.
Ouch. Sorry to hear!
I've had some lull days at work recently and was going through it. Only thing is that I wish they had more job opportunities. I'm slightly surprised they haven't hit that market yet.
It doesn't give you the muscle flexing, problem solving aspect that you get with hackerrank et al, but it does expose you to various fundamental concepts of the language which you might not encounter in your first years. So a little bland but not a complete waste of time to me.
Thank you :)
I don't get it either.
&gt; I never liked scripted languages as I highly appreciate the work done &gt; by a compiler to detect typos and data type errors Wait a moment ... so he hates "scripting" languages. And now he is using ... JavaScript. Am I missing some steps in between here????? &gt; Despite the great advantages of using Rails in a new project, there &gt; was an area where Ruby was not able to penetrate, and not even &gt; Rails was a good ambassador. I'm talking about the corporate world And so what? There are lots of shitty languages used in the corporate world. The people are zombies there - remove the brain and become a worker drone. Of course there is one reason I can not disagree with and that is speed. I am not referring to JavaScript, although I assume it is faster than Ruby; but I refer to C, C++, Java etc... &gt; And in my view, the JavaScript ecosystem is mature enough to &gt; deliver all the good things that Ruby and Rails have brought us Yeah ... JavaScript works perfectly well. I mean, there is like nobody to left pad a string ever and make that a popular add on ...... &gt; Our findings go in the direction that there is a replacement for &gt; almost every Rails feature or Ruby gem. Hardly. :) &gt; Unlike Ruby, JavaScript dominates the web front-end, and with &gt; Node.js it became famous on the back-end. It's easy to &gt; understand why JavaScript is more popular, No. It's not why JavaScript is more popular. Even PHP is now slightly below JavaScript. The reason why JavaScript got big is because it is a de-facto monopoly on the www. And the www is by far the biggest catalyst that we have. I actually wrote that years ago too where I suggested that core-ruby should focus on the www too, well aside from rails. But I think the problem is that there are not that many great and active C hackers that may decide to use ruby rather than ... python. Perl has it even worse now than Ruby. &gt; I also think that the community is going through a "cool" &gt; phase, similar to what happened to Rails in the early day There ever was a "cool" phase of rails??? &gt; But I also suspect that we will see some consolidation in &gt; the upcoming years with libraries and frameworks being &gt; left to die. Great! So people learn something, invest time and in 2 years it is all outdated. Poor JavaScript folks. &gt; Going back to what I said in the beginning of this article, my bet &gt; was that JavaScript would have a painful death. I couldn't be &gt; more wrong. We gotta remember that the next time you predict the future. &gt; I still think there are big problems with the language, but then again, &gt; Rails became famous and Ruby also suffers from some design flaws. &gt; I don't think anyone was able to highlight this better than Gary &gt; Bernhardt on his incredible lightning talk on CodeMash 2012. WHAT THE FUDGE? That talk makes fun of JavaScript. I think ruby is mentioned only once in the beginning before turning to JavaScript. Did you even watch the video?!?!?! It's a great video. But nope, it's not a "design flaw" in ruby. By the way - if you mention "design flaws" BUT ARE NOT SPECIFIC, how should anyone know what you are talking about? This dude is strange... &gt; The fact is, you can now release a complex web and mobile &gt; project without the need to use several languages Not using HTML? CSS? Never any of the SQL? Hmm. Guess the guy found ONE LANGUAGE TO RULE THEM ALL. I am so glad to not have to write JavaScript myself. &gt; All things considered, for us, JavaScript is fit for purpose and &gt; context. We've officially stopped recommending Ruby on &gt; Rails for new projects and will opt for a JavaScript based &gt; architecture by default. That's great. I officially recommend to find some other company than Imaginary Cloud since it is a company run by noobs. &gt; Nevertheless, we will support existing Rails projects, as I &gt; think that the technology is mature, ready for production &gt; and it won't die anytime soon because of its mature and &gt; stable community. Nah. You abandoned ruby already so don't try to wing it. Your future is now set to JavaScript - good luck riding that boat. Heroic worker drones will come to work for free soon enough. :)
Not too surprising 1.8 and 1.9.3 are still supported. Passenger came out in the 1.8 days when the app server options were limited and RHEL, Fedora, Debian are popular distros that ship or have shipped with old rubies. 
I'm kind of unclear why doing lots of this: let(:header) { "column1, column2, column3" } let(:row2) { "value1, value2, value3" } let(:row3) { "value1, value2, value3" } let(:rows) { [header, row2, row3] } ...is any better than fixtures?
Vim is a great editor and super powerful once you get used to it. It has a pretty steep learning curve, but https://vim-adventures.com is a great way to learn it. It is not free, but help gamify the learning process. Many people also use Atom and highly recommend it.
Yea using atom at the moment 
Great post but don’t be too aggressive about it. You don’t yell at the hammer because it doesn’t quite screw in a nail. 
I was using atom. I switched to vim, because Atom was using too many of my computer's limited resources. Now I'm kind of married to vim, and even use a vim plugin in firefox, that let's me use vim keyboard commands. That being said, You can keep using Atom, if your computer can handle it. There's nothing wrong with it.
You need to read the documentation of the gems you use before asking trivial questions here. I feel you haven’t even tried anything at all. 
damn. &amp;#x200B; I have read the gem and there's nothing to my knowledge that speaks about downloading the files once uploaded.
[https://github.com/carrierwaveuploader/carrierwave#activerecord](https://github.com/carrierwaveuploader/carrierwave#activerecord) It's full of examples. For instance &lt;%= image_tag(@user.avatar_url) if @user.avatar? %&gt;
Sololearn for sure
Ay thanks man. I'm new to this so i didn't understand what that was for. &amp;#x200B; Either way, I created a new uploader so Users can upload digital files for a separate User(separate user model) to then download... but having issues having them save into the public which i can't figure out why because the first uploader is saving fine. Regardless, I'm having someone who knows a lot more than I do help me figure this out when they're free. &amp;#x200B; Thanks for the help!
Concise and informative, good post 👍
Thank you for the feedback :-)
&gt; Instance variables are most definitely never a problem Instance variables are what keeps the object (used in multiple threads) internal state. And that needs to be protected from corruption. And if you delegate some work to them, they need to be thread-safe object as well. &gt; It is even more nonsense what he refers to because you can manipulate instance variables at all times via setters and getters (instance_variable_set for example). And ad-hoc remove them via remove_instance_variable. I have no idea what you are talking about now...
&gt; any of the available generators... Can you clarify?
I'm OP. Sometimes I want to keep all the other rows but see what happens when one row has bad data. I needed to do this because the feature itself was complicated, rows of data might actually be dependent on each other. For example, data in row2 might throw something off for data in row3.
This is very simplified sample data. For our use case, we had about 20 different "scenarios" of something going wrong in importing a CSV file. If we used fixtures we would have to build 20 different fixture files. If we needed to add a column we would have had to do it in all of those files, where in this example we just need to add it to the main `let`.
&gt; We've already written off Rust. It's not there yet for our purposes. And that's pretty much all. IMO that is not enough to justify dropping the Rust alternative.
Great podcast - Jason is extremely interesting to listen to. If you like him, you should also checkout his other stuff!
[Faker](https://github.com/stympy/faker)? [factory_bot](https://github.com/thoughtbot/factory_bot)? Those are the two I use but are far from the only ones.
I don't see that in your example code, but if it works! I still think something like [factory_bot](https://github.com/thoughtbot/factory_bot) is what I would have chosen, but I only have a small window into the problem so it's easy to armchair quarterback from here! :) Still an interesting approach even if it's not how I would have done it, So thanks for writing it up.
Aw shucks, thanks!
Yeah, thanks! I tried to keep the example code very simple and without business logic, mostly just focusing on the implementation of building up the CSV file.
If the client ever wants to update the version they are using they will need to update the entire project for all instances of the classes they use. I think instead you should have one single class for each endpoint that accepts an argument for the version to use. This can be set as a global during initialization. This way the code will be cleaner with all class names having nothing to do with the version being used.
I will leave it here: he never likes scripted languages, but he choose javascript.
Like a factory? Sounds reasonable. Would you mind sharing some code for this approach and how it would be used?
Pretty much. You could go two routes. First your client would use an inializer at the start of their app to set some global variable in yoir library thay tells the endpoints which version to use. For example `MyApi.version = '2017'`. The other option is make it a parameter that you pass to the endpoint `MyApi.endpoint.get(parameters, version: '2017')`. This could even be combined with the first option to override your previous global if needed. Them on your actual library for the endpoint you just use that version to point to the correct endpoint. I am guessing the only real difference is the url so you just change the url based on the version.
Usually, the pattern is like: client = MyApi::Client.new(version: '01-01-1990') rec = client.some_resource.retrieve('some-id') This is especially useful when you need to migrate from one version to another, but can't do it all at once (happened many times when you have downstream customers that would be impacted by the version change, e.g. payloads change, etc.), so you can create 2 separate `client` instances, one for each version.
Take a look at how the AWS S3 SDK works: https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html It's Javascript, but the idea holds. &gt; var s3 = new AWS.S3({apiVersion: '2006-03-01'}); 
I agree that the article can be improved, but I am sorry, what you wrote is wrong. An object's state is always the dangerous bit when it comes to access from multiple threads. And that state is stored in instance variables. It does not matter how they are accessed, they need to be protected properly (i.e. access synchronized) if an object is to be used from different threads. Some ways are described in the article but there are more.
Is there a typo? You write "subtracts the larger from the smaller" and then "If the difference is greater than 0". This can never happen if you subtract the larger from the smaller.
Please review my revised code that elaborates more on my current approach. I like the simplicity of your approach, but I have a couple of concerns: * Is there a way to use the `Client` to produces a `Bar` such that I can use `Bar`'s class and instance methods? `some_resource` is a instance, correct? * Assuming that the API that is use by `Bar` changed between v1990 and v2000, how would you structure its code? Two namespaces? Difference class names?
I'm a fan of building basic games in the terminal. blackjack or paper rock scissors are both fun and doable. I still do this when I'm picking up a new language.
I would try normalizing that a bit. If there's an additional method, a `raise UnsupportedError, "this method is only available from version v6789"` goes a long way if you're also providing an older version. It's a bit harder if they changed some of the calls, but if the method for example still returns the same thing just with different arguments, it's possible to normalize it.
Remember that `result` is a hash, and you can do two main actions with it, read and write. If the hash is `result = { "foo" =&gt; "bar" }`, you'd read the value for the `"foo"` key by doing `result["foo"]`. Similarly, to write a new value for the `"foo"` key, you'd do: `result["foo"] = "baz"`, which would turn your hash into `{ "foo" =&gt; "baz" }`. Hope this helps. 
Yes, it's a typo. I meant subtracts the smaller from the larger. 
Just a note: you don't have to push your gems to Rubygems.org -- you can bundle them from a git repo.
\&gt; Did Sparrow author know that? ..D Yes it did. &amp;#x200B; Bundler/git approach works well for distribution of SINGLE script. If I have many ones it becomes tedious, becuase you have to know all the git repos you install scripts from. Alternatively you're just have only \_one\_ repository server for ALL your scripts. IMHO using git for something rather than source control in long run is not good choice ...
result\[letter\] might be updated multiple times through all the integrations, e.g. for multiple occurences of a letter in a string. However this is a little unclear with the given solution. I would write the block like this `{ |letter| result[letter] = (result[letter] || 0) + 1 }`, meaning if the result doesn't contain the key for the current letter initialize it with 0(so hash now contains the pair letter =&gt; 0) otherwise use the current value, and then just increment it with one unit, since each iteration denotes one occurence of that letter.Hope i was clear
Your understanding is mostly correct. A few things that might help: `result` will return the entire hash - all keys and values `result[letter]` will return the _value_ assigned to `letter` within the hash. You can combine with with the assignment operator (`=`) to set or update the value of the hash --- Examples usually help me understand better. Here's an example of what you will get if you open an `irb` session in a terminal. My input is prefaced with `&gt;&gt;` and the output (return value) is prefaced with `=&gt;`: &gt;&gt; result = {} =&gt; {} &gt;&gt; result['A'] =&gt; nil &gt;&gt; result['A'] = 1 =&gt; 1 &gt;&gt; result['A'] =&gt; 1 &gt;&gt; result =&gt; {"A"=&gt;1} &gt;&gt; result['A'] = result['A'] + 1 =&gt; 2 &gt;&gt; result['A'] =&gt; 2 &gt;&gt; result =&gt; {"A"=&gt;2} Notice that if you query for a key that does not exist then you will get `nil`. After assigning a value, you will instead get whatever value is associated with the key that you pass into the hash accessor argument.
That makes a lot of sense. Thank you! I couldn't connect the dots between writing new key, value to a hash and *result\[letter\].* &amp;#x200B; Thank you for your quick reply as well!
Not enough to justify it to _you_ anyway. 
I'm not saying this is the easiest / best way to do this, but here is a one-liner solution: `"The Star Wars Movies Rock".split('').group_by(&amp;:itself).transform_values(&amp;:size)` The split converts the string into an array of individual characters, group_by(&amp;:itself) groups the characters by "itself" (e.g. `{"T"=&gt;["T"], "h"=&gt;["h"], "e"=&gt;["e", "e"]...`) and `transform_values(&amp;:size)` transforms the values based on the size (e.g. `"e"=&gt;["e", "e"] becomes "e" =&gt; 2).
What's everybody's verdict on OpenWhisk? If you're a serverless enthousiast, would you use it?
How about statement.chars.reduce(Hash.new(0)) { |memo, char| memo[char] += 1; memo }
As far as I know, eventmachine is your best bet, possibly combined with a background worker library like resque or sqewer to do the other work you mention.
Nope. `letters` is the letters of the alphabet, not the letters of the `statement` OP is scanning. 
The thing is this will be called from c code and when my function returns, all ruby threads stop (because of gil). Hm, but I guess I could just use c library and put data into some mutex protected queue end grab them from there... hmm, will try that :)
Clear and concise. OP could add `.gsub(‘ ‘,’’)` ahead of .split to remove whitespace.
https://github.com/socketry/async-websocket It doesn't seem really popular yet but look at his other projects https://github.com/socketry to get an idea of his pedigree.
&gt;you're right, i misread that. anyway the hash doesnt need to contains all alphabet letters count so i had in mind just the statement this is the whole snippet so i won't mess anything else up `result = {}` `statement.each { |letter| result[letter] = (result[letter] || 0) + 1 }` 
Since devs are opinionated on code style and paradigms and so i might like some metaprogramming code, but a more experienced dev would consider that an overhead and prefer the simple static self explainatory code. But codeclimate has a good metric for maintainable code, in terms of compexity, structure and style. Whenever i see a gem that has the codeclimate badge with A on github i start looking at the code and i see some really good examples there. One such gem is [https://github.com/rubocop-hq/rubocop-rspec](https://github.com/rubocop-hq/rubocop-rspec) , have a look if you're interested.
nice
 result = Hash.new(0) &amp;#x200B; Passing anything into the constructor of a hash will make it the default value. Then you can simply: &amp;#x200B; statement.each do |letter| result[letter] += 1 end &amp;#x200B; This should yield the correct result you need.
The Hash won't contain all alphabet letters. Assignment is has a conditional and will only be made `if letter_frequency &gt; 0`
So: 1. Some things happens in C code 1. C calls into ruby 1. Ruby does stuff with a websocket 1. Ruby returns to C code 1. C code does more things is roughly correct? If so, and if you're already using the Ruby C API it allows you to acquire the GVL when running ruby code and release the GVL when returning to C code so you can allow the ruby code to continue to run threads. See the documentation on `rb_thread_call_without_gvl` [thread.c](https://github.com/ruby/ruby/blob/trunk/thread.c#L1414) For examples see the functions called by [`rb_thread_call_without_gvl`](https://github.com/ruby/ruby/blob/19fe6552c456e41c0b85816806399ca1609255c0/ext/zlib/zlib.c#L1056-L1057) and [`rb_thread_call_with_gvl`](https://github.com/ruby/ruby/blob/19fe6552c456e41c0b85816806399ca1609255c0/ext/zlib/zlib.c#L995-L996) in zlib.c
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ruby/ruby/.../**thread.c#L1414** (trunk → 19fe655)](https://github.com/ruby/ruby/blob/19fe6552c456e41c0b85816806399ca1609255c0/thread.c#L1414) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e6cegvm.)
The Hash won't contain all alphabet letters. Assignment is has a conditional and will only be made `if letter_frequency &gt; 0`
Iterating over every letter of the alphabet and then scanning the statement each time isn't really efficient. This problem can instead be solved like this: result = Hash.new(0) Passing any object into the `new` method will make it the default value of the hash elements. Now you can simply: &amp;#x200B; statement.split('').each do |character| result[character] += 1 end `split('')` will create an array of individual characters, which we can iterate over. Then we `result[character] += 1` \- if result\[character\] hasn't been accessed yet, it will take on its default value which is 0, and then immediately get increased by one. `result` will include spaces. If you don't want them, you can do this: &amp;#x200B; statement.delete(' ').split('').each do |character| result[character] += 1 end &amp;#x200B; That `delete(' ')` will delete all spaces from the statement.
I think this encapsulates what Ruby is. It was designed to bring pleasure and achieves that aim by being all things to all coders. As /u/slendermann29 says, "devs are opinionated". Ruby allows each dev to have their own opinion and associated chills. Find a style that you appreciate the texture of and let your spirit free.
Here's the only flawless code ever written: ``` ```
That's probably a better fit for OP. I'd never heard of Parslet, so I appreciate your comment man.
I still need to catch up on all the fuss. I’ve seen it around in articles and Twitter, but I keep forgetting what it even is. Looks like it’s time to actually dive in for me, even if I don’t use it for a long time. 
this was exactly what i'm looking for
[https://github.com/camping/camping/blob/master/lib/camping.rb](https://github.com/camping/camping/blob/master/lib/camping.rb)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [camping/camping/.../**camping.rb** (master → f2820bb)](https://github.com/camping/camping/blob/f2820bbb103f9cfe225647339a4b939560314eec/lib/camping.rb) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e6csudr.)
I’ve been a Ruby/Rails developer for 13 years (since 0.11), and I’m still learning. Do you want to write your own personal blog? It’ll take a weekend if you already have programming experience. Working on a team with other developers on a large app with lots of customers and changing business requirements? I’ll let you know when I find out.
 rows = ["a,b,c"] rows.each do |row| csv &lt;&lt; row.split(",") end Better to just keep as rows as arrays: rows = [%w[a b c]] rows.each do |row| csv &lt;&lt; row end Or even better: rows = [%w[a b c]] File.write(file_path, rows.map(&amp;:to_csv).join("")) 
If you're writing a lot of classes like this: class Bar attr_accessor :name, :description # instance methods def initialize(params) @name = params[:name] @description = params[:description] end end # ... bars = JSON.parse(response.body) bars.map { |attributes| new(attributes) } I suggest you checkout [class2](https://github.com/sshaw/class2) (author here). It can save you some time by generating some of these classes from JSON and dealing with `camelCase`/underscore property names and serialization –amongst other things: require "class2/autoload" # builds classes from below JSON require "pp" commit = Commit.new(:author =&gt; { :name =&gt; "luser1" }) p commit.author.name pp commit.to_h __END__ { "response": { "sha": "f52f1ed9144e1f73346176ab79a61af78df1b6bd", "commit": { "author": { "name": "sshaw", "email": "skye.shaw@gmail.com", "date": "2016-06-30T03:51:00Z" } }, "comment_count": 0 } } Also see: https://github.com/ScreenStaring/recharge-api/blob/3eaf7723bf9c7d6689051e92cab5b572b009afcc/lib/recharge/classes.rb#L5
According to [this](https://vii5ard.github.io/whitespace/) your code produces the following error Unexpected EOF
I can't tell if this is a joke or not.
AAAA I've really wanted to avoid hacking on weechat's ruby plugin, but maybe it's avenue worth exploring..
good to hear, I love fibers, it's a great concept so will check this project out :)
That's because the code behind Whitelips IDE is imperfect, unlike my code, which is true perfection.
Glad I could help
Obviously it is, if you look at the lib directory there, there's also a normal version.
https://github.com/mame/trance-book/blob/8c97dbdfb996e52f4e166530c1c5844c71c92f40/1-4-2/tic-tac-toe.rb
i always feel funny feelings looking at code written by non-english speakers, especially japanese rubysts
How did you end up with that odd array in the first place? Let's fix the cause of the problem, not the symptom. Here is how you *could* convert that first array to the second -- but as I say, I think it's extremely likely that the "correct" answer lies further up in the code. array.first.split(',')
First access it via [0]; then apply .split(). array = ["foo,bar,bor"].first.split(',')
You gave the correct answer though. ;)
Thanks gents! End up with .first.split(',')
Yep! Or `.scan(/\w/)` instead of split. 
Learning ruby on rails is not hard if you have solid understanding of programming and the mvc pattern. Rails follows the mvc pattern very closely so if you already understand mvc then just doing the rails getting started tutorial was all I needed to learn ruby on rails at a basic level.
Yah, or in general do we know that it will always only be a comma seperated value in the first spot? You may be hiding another problem by superficially fixing this one...
Whenever I get to build a small Ruby project from scratch after long bouts of JavaScript front-end work, I feel like everything I do is the cleanest most perfect code ever.
Wow. I bet you're fun at parties. I love how you come in guns blazin "well _obviously_" because I commented something wasn't obvious to me. And because that thing wasn't obvious to me, I'm a lazy ass. Please. Please stay away from message boards until you learn how to act in public.
Maybe. But as someone with [lots of experience](https://stackoverflow.com/users/1954610/tom-lord?tab=answers) in answering random questions like this, I doubt it. It's far more likely that some input data was incorrectly stuck into that format in the first place.
&gt; And because that thing wasn't obvious to me, I'm a lazy ass. No, it's because you're a lazy ass that couldn't be bothered to spend 2 clicks - one to click on the 'lib' directory and other to click on the 'camping-unabridged.rb'. I bet you're really fun to work with.
There's a great mind map of the many competencies required to be a strong Rails programmer. https://www.codefellows.org/blog/this-is-why-learning-rails-is-hard/ This isn't limited to just Rails, I'm sure many other languages and frameworks have a similar density. You have a strong grasp on Javascript? Congrats, you can check off one little leaf node in that tree. I've had people ask me to each them how to do like I do. I can't figure out how people expect to learn in a few weeks what I have spent a decade mastering. Just keep working, keep learning. Be inquisitive, and persistent. Experience takes time.
It is bizarre data, but I like more abstract approaches... `array.collect{|stringed| stringed.split(',')}.flatten` then you could have ["a,b,c","d,e","f"] and get ["a","b","c","d","e","f"]