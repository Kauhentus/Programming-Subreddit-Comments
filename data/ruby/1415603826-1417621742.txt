Learning Ruby by itself will lay a great foundation, but is rarely what people are hired for. To find a job, look into learning Ruby on Rails (if you want to do web development) or Chef / Puppet (if you want to go into sysadmin). In my experience, the current job market for Ruby developers is about 80% Rails, 10% Chef / Puppet, 10% other. Note that you might get hired for your Ruby knowledge alone, and then learn Rails or whatever in your new job, but I wouldn't count on it. Four months should be easily enough time for learning Ruby, even if you have little to no programming experience.
I'm glad to hear that the you and /u/nilslandt both agree that my time span isn't unrealistic. Gives me some relief. I really appreciate you laying a rough list of points I should study. Thanks man!
Rails is not a separate language. I cannot express this enough: do not try to jump into Rails without fully understanding Ruby.
Don't forget you will also need to learn at least the basics of HTTP (REST) and HTML. They're not very complex, the theory could be down in just a few afternoons, but the way the backend interacts with them is something you've need to have seen a few times. Consider to read a Ruby on Rails book or going through Railscasts.com. Note that generating HTML from Ruby is no longer considered to be 'modern'. A modern Ruby web application would only be JSON API endpoints and perhaps websockets, at least in my opinion. (many people choose to use Grape or Sinatra for these instead of Rails, but that's more advanced in my opinion, as you'll have to think about setting up activerecord yourself etc.). If your position in 4 months is going to be maintaining an already existing Ruby app, it will be a piece of cake. Designing an app from scratch, or collaborating on an app that's being made from scratch is harder!
I'd like to add on to this and say: when you start using libraries, take some time to dive into the code. You may find some new techniques by doing this. This may also give you some different examples of how Ruby projects are structured... and being able to work with existing code is a great asset when marketing yourself for a job, especially before you've established yourself. Cheers! Good luck man.
Really? I've done some pretty awesome things in Rails without a full understanding of Ruby. A basic understanding of Ruby can get you pretty far in Rails. I'm doubling back right now and re-learning Ruby from the ground up but if I didn't get a few CRUD apps under my belt before hand, it would have been easy to lose motivation in learning Ruby. I bet the optimal route would be to get a basic understanding of Ruby &gt;&gt; Muck around in Rails for a bit and build a CRUD app or two &gt;&gt; double back and really dive into Ruby &gt;&gt; Dive back into Rails and start to appreciate and understand the stuff your wrote before and some. This keeps you motivated and gives you a sense of accomplishment throughout the process. 
Hey, I also have a degree in economics. I've never worked in the field though, got into software shortly after college. I had ruby thrust upon me and had to learn it fast. Took me about three months to get good enough to be very useful. Things that helped were upgrading rails apps, building modules and starting a bazillion apps that never did much. The tons of apps helped a lot. Tried a bunch of frameworks since I was mostly in rails land. I also read through the std lib for ruby and tried out almost every lib in it. Good luck!
http://en.wikipedia.org/wiki/Overengineering: &gt; Overengineering (or over-engineering) is the designing of a product to be more robust or complicated than is necessary.
I think s/he meant the project is already written in Objective-C.
Add the following: class Car attr_accessor :car # This automagically creates a getter/setter def initialize @car = [] end ... end Then you can get rid of your `new_car` method. Also delete all of the `return car` lines. Ruby automatically returns the result of the last statement in a method if there's no return. So... car &lt;&lt; "radio" Will return: ["radio"]
Thanks. I will give it a try.
Regardless of the wordyness, the overall thing I'm keen to know is if people split data and algorithm apart like this routinely.
Excellent point! Ruby is as much a philosophy as it is a collection of APIs, and hanging with other Rubyists is a great way to learn via osmosis how to approach coding. I'll also add that each small project you do, try to elevate your coding overall, ie start just getting things to work, add in better commenting, then unit testing, etc - stretch yourself to make cleaner and better organized projects. And then, and here's the kicker, KEEP those projects to show when you're interviewing. Good luck!
Yes. It's a standard lisp-style map + filter, common in functional programming. 
Sort of, but not really. putting all of my code into a gem will only slow down the development of the iOS application since I will have to pull down the latest resources in the gem to see changes in the iOS application. Instead, I use helpers for a lot of the logic. I'll basically use `include DashboardHelper` in my ViewController to access the methods and necessary calls to my business logic. This way, other than a few changes (i.e. Rakefile and AppDelegate to MainActivity), the only parts of my application that will have to be altered is the helper files.
I completely agree. I spent two years at my first real programming job being badly underpaid (no insurance, and I was a 1099 employee, so taxes were brutal). I started attending meet ups, and I impressed a few people. Once the discussion turned to work, they were horrified to find out how little I was making. The other developers pushed me to get out of there and put me in touch with companies looking to hire. Within a few weeks I accepted a job that tripled my salary. That was a number of years ago, and things have been awesome ever since.
Another nice thing about RubyMotion is that they do try to help you see what methods are available to an object. For example, if I have a MapView loaded in the simulator, I can hold the Command key and hover over this. The item will turn red and you'll notice that the console is now referencing that object. From there, you can type `self.&lt;TAB&gt;&lt;TAB&gt;` in the console and see a list of all of the available methods on that object. This has been a lifesaver in the iOS API understandings of my RubyMotion experience. One thing to note, if the method has a : next to it, then it functions as a method whereas no : will function as an attribute. For example `UILabel` has a `text` attribute and a `setTextAlignment:` method. label = UILabel.new #UILabel.alloc.init label.frame = [[0,0],[300,20]] label.text = "Some text" label.setTextAlignment(1) view.addSubview label
Rails for Zombies and other Ruby / Rails courses really helped me when I was learning too. Codeschool.com
I do not know if it has a formal name, but we use this pattern a lot where I work. This is the first step in the pattern; a more DRY version that is also more readable -- because people seem to handle 2D tables of info with more ease than this vertical approach -- is: [ # key data map_to [ :known_issue_ids, Something::KnownIssue, :known_issues ], [ :depth_of_market_ids, Something::DepthOfMarket, :depth_of_market ], [ :developer_history_ids, Something::DeveloperHistory, :developer_histories ], ] The downside of doing this directly is that we switched from named entries to positional, but one upside to consider is not duplicating identifiers everywhere (imagine if you decided to change a key name!). Encoding the zip with the header in this starts to make it look ugly, so a more elegant solution for this general pattern is to abstract it: class TableMap attr_reader :header def self.[](*table) TableMap.new(*table) end def initialize(header = [:value], *rows) @header = header @data = rows end include Enumerable def each @data.each do |row| yield Hash[@header.zip(row)] end end end Example of use: TableMap[ [ :key, :data, :map_to, ], # ----------------------- ---------------------------- -------------------- # [ :known_issue_ids, Something::KnownIssue, :known_issues ], [ :depth_of_market_ids, Something::DepthOfMarket, :depth_of_market ], [ :developer_history_ids, Something::DeveloperHistory, :developer_histories ], ].each do |param_value| ... If you want to reduce []s, you can toy with notions like only passing two arrays instead of one array for the header and an array per row; you'd use partitions by the number of header elements. You can also add to this class notions of adding more rows to @data. Disclaimer: I'm programming in Perl professional, but I have an interest with next to no experience in Ruby, so I am open to help on how to improve my usage patterns.
This is the error that I am getting -- no matter the gem I run. I thought that it my tmp folder was the issue but permissions are fine for it and its never had an issue in the past: /usr/local/lib/ruby/2.1.0/tmpdir.rb:85:in `mkdir': ERROR: Failed to build gem native extension. (Gem::Ext::BuildError) Permission denied @ dir_s_mkdir - ./.gem.20141110-30852-2ltpc9 Gem files will remain installed in /usr/local/lib/ruby/gems/2.1.0/gems/ffi-1.9.6 for inspection. Results logged to /usr/local/lib/ruby/gems/2.1.0/extensions/x86_64-linux/2.1.0-static/ffi-1.9.6/gem_make.out from /usr/local/lib/ruby/2.1.0/tmpdir.rb:85:in `block in mktmpdir' from /usr/local/lib/ruby/2.1.0/tmpdir.rb:142:in `create' from /usr/local/lib/ruby/2.1.0/tmpdir.rb:85:in `mktmpdir' from /usr/local/lib/ruby/2.1.0/rubygems/ext/ext_conf_builder.rb:14:in `build' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:161:in `block (2 levels) in build_extension' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:160:in `chdir' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:160:in `block in build_extension' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:159:in `synchronize' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:159:in `build_extension' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:198:in `block in build_extensions' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:195:in `each' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:195:in `build_extensions' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:1436:in `block in build_extensions' from /usr/local/lib/ruby/2.1.0/rubygems/user_interaction.rb:45:in `use_ui' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:1434:in `build_extensions' from /usr/local/lib/ruby/2.1.0/rubygems/basic_specification.rb:56:in `contains_requirable_file?' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:951:in `block (2 levels) in find_in_unresolved_tree' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:2397:in `[]' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:2397:in `block (2 levels) in traverse' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:2396:in `each' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:2396:in `block in traverse' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:2395:in `each' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:2395:in `traverse' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:949:in `block in find_in_unresolved_tree' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:947:in `reverse_each' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:947:in `find_in_unresolved_tree' from /usr/local/lib/ruby/2.1.0/rubygems/core_ext/kernel_require.rb:93:in `require' from /usr/local/lib/ruby/gems/2.1.0/gems/jekyll-2.0.0.alpha.1/lib/jekyll.rb:16:in `&lt;top (required)&gt;' from /usr/local/lib/ruby/2.1.0/rubygems/core_ext/kernel_require.rb:73:in `require' from /usr/local/lib/ruby/2.1.0/rubygems/core_ext/kernel_require.rb:73:in `require' from /usr/local/lib/ruby/gems/2.1.0/gems/jekyll-2.0.0.alpha.1/bin/jekyll:6:in `&lt;top (required)&gt;' from /usr/local/bin/jekyll:23:in `load' from /usr/local/bin/jekyll:23:in `&lt;main&gt;' 
This is the error that I am getting -- no matter the gem I run. I thought that it my tmp folder was the issue but permissions are fine for it and its never had an issue in the past: /usr/local/lib/ruby/2.1.0/tmpdir.rb:85:in `mkdir': ERROR: Failed to build gem native extension. (Gem::Ext::BuildError) Permission denied @ dir_s_mkdir - ./.gem.20141110-30852-2ltpc9 Gem files will remain installed in /usr/local/lib/ruby/gems/2.1.0/gems/ffi-1.9.6 for inspection. Results logged to /usr/local/lib/ruby/gems/2.1.0/extensions/x86_64-linux/2.1.0-static/ffi-1.9.6/gem_make.out from /usr/local/lib/ruby/2.1.0/tmpdir.rb:85:in `block in mktmpdir' from /usr/local/lib/ruby/2.1.0/tmpdir.rb:142:in `create' from /usr/local/lib/ruby/2.1.0/tmpdir.rb:85:in `mktmpdir' from /usr/local/lib/ruby/2.1.0/rubygems/ext/ext_conf_builder.rb:14:in `build' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:161:in `block (2 levels) in build_extension' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:160:in `chdir' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:160:in `block in build_extension' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:159:in `synchronize' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:159:in `build_extension' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:198:in `block in build_extensions' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:195:in `each' from /usr/local/lib/ruby/2.1.0/rubygems/ext/builder.rb:195:in `build_extensions' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:1436:in `block in build_extensions' from /usr/local/lib/ruby/2.1.0/rubygems/user_interaction.rb:45:in `use_ui' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:1434:in `build_extensions' from /usr/local/lib/ruby/2.1.0/rubygems/basic_specification.rb:56:in `contains_requirable_file?' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:951:in `block (2 levels) in find_in_unresolved_tree' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:2397:in `[]' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:2397:in `block (2 levels) in traverse' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:2396:in `each' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:2396:in `block in traverse' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:2395:in `each' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:2395:in `traverse' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:949:in `block in find_in_unresolved_tree' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:947:in `reverse_each' from /usr/local/lib/ruby/2.1.0/rubygems/specification.rb:947:in `find_in_unresolved_tree' from /usr/local/lib/ruby/2.1.0/rubygems/core_ext/kernel_require.rb:93:in `require' from /usr/local/lib/ruby/gems/2.1.0/gems/jekyll-2.0.0.alpha.1/lib/jekyll.rb:16:in `&lt;top (required)&gt;' from /usr/local/lib/ruby/2.1.0/rubygems/core_ext/kernel_require.rb:73:in `require' from /usr/local/lib/ruby/2.1.0/rubygems/core_ext/kernel_require.rb:73:in `require' from /usr/local/lib/ruby/gems/2.1.0/gems/jekyll-2.0.0.alpha.1/bin/jekyll:6:in `&lt;top (required)&gt;' from /usr/local/bin/jekyll:23:in `load' from /usr/local/bin/jekyll:23:in `&lt;main&gt;' 
For what it's worth, if you go through Learn Ruby the Hard Way, you'll spend some time with Sinatra, which is a great way to get familiar with some of the concepts of web applications before you launch into Rails proper. When you do make the jump into Rails, consider starting with Daniel Kehoe's [*Learn Rails*](http://learn-rails.com/) before you start Michael Hartl's [*Rails Tutorial*](https://www.railstutorial.org/book). Learn-Rails doesn't use a database (or models), and so will be sort of similar to the Sinatra applications you'll write. After that, when you add on models (and thus the database), the jump will be pretty manageable.
i took your article seriously up until you referenced the 'obesity epidemic'. edit: bring on the downvotes, morons, maybe you should stop listening to fox and cnn and actually learn something. THE WAR ON CHRISTMAS AND MIDDLE AGED WHITE MEN RAGES ON
&gt;After that, when you add on models (and thus the database), the jump will be pretty manageable. ActiveRecord backed models. That's not necessarily true for models in general. 
I'll spoil the end for you. Bump up your Mail gem to version 2.6.3 or above for massive memory savings. Profile your app for more. **TL;DR** Rails apps have a fever, and the only cure, is more benchmarking. &lt;/christopher walken voice&gt; 
&gt; If you want a job in that time span you really need to start attending the local ruby meetup and meet real life programmers in person. That is advice I give to every aspiring programmer. Probably should etch it into a plaque and hang it above my desk. (SHAMELESS: I also interview people in tech community http://www.ugtastic.com and created User-Group List https://ugl.st)
Do you have `libffi-devel` installed?
+1 Gregg Pollack and his team at Envy Labs &amp; CodeSchool do an excellent job of teaching different programming disciplines.
I generally like codeschool for web related technologies. But I didn't care for their Objective-C and iOS courses. They have a style which lends itself to receiving a superficial sampling... it's an insufficient strategy on dense topics.
"How would I print out every 10th number using the same syntax, if it is possible" x % 10 == 0 does not tell you if it's the 10th position in the array, it tells you if the number is evenly divisible by 10. You will need to reference the index position in the array. You can do this with #each_with_index: @numbers.each_with_index { |x, i| puts x if (i + 1) % 10 == 0 } x is the element in the array, i is the index
Aye, good point. One correction would be that there is a need to add 1 to the index before doing the modulo. I had luck with: @numbers.select.with_index { |x, i| (i + 1) % 10 == 0 } EDIT: found out what I was doing wrong. 
TLDR: update the mail gem to 2.6.3 gem 'mail', '&gt;= 2.6.3'
Took this course in May and can confirm as one of the best mentor led course out there. Will answer any queries if needed.
Yes I am using nokogiri to parse html, but would one nokogiri app work for different sites. So it is possible to make one for any site.
Also use [derailed_benchmarks](https://github.com/schneems/derailed_benchmarks)
why? do you want to make some money, or just because you are good people? :)
I don't get it. Do you expect proprietary, closed source code to be put on Github?
Thanks for the sources guys. Much appreciated. 
Gives me hope. Thanks man. It doesn't sound impossible anymore. Did you learn from shadowing or did they just throw you in the deep end?
I'm just getting into RubyMotion with several years of Ruby and Ruby on Rails coding, and I wanted to let you know that this post is incredibly useful. Thanks!
There are also models which have no repository backing. The term model is synonymous with business object, not database. 
theres a plethora of metadata to look for. HTTP Headers, head/meta-tags in HTML, possibly alternate MIME types such as RDF or JSON , possibly mentionining their existence via Accept variant-enumerating Headers or link-tags (or link headers). metadata added to the HTML in data- tags, RDFa, Microformats, MF2, Microdata. metadata inferred from CSS classnames and the overall DOM tree structure. metadata extracted via NLP from plaintext. it would help if you could narrow down what you're looking for...
Ah, I didn't realize your launch date meant, "we're pushing the code to github."
I recommend that you check out [Mechanize](https://github.com/sparklemotion/mechanize). I used it recently to do a simple [scraper script](https://github.com/redconfetti/stat_scraper/blob/master/main.rb). It does a great job for a tool that almost emulates a web browser. 
Showed up for what I thought was a beginner php job and got handed a ruby book.
I am new to programming and am currently loving the intro course to ruby on code academy. I would like to take this course but am I to inexperienced? 
We are in the throws of moving to Torquebox. So this is very interesting. Some transparency on how you arrived at the benchmarks would be useful. 
If you are inexperienced, I would say this is one of the best course for you in terms of learning proper way to code, test your code. Victor is patient enough and helps you think and learn right way. Getting a mentor at such low cost for 7 weeks is what I would say pays for the course itself. You'll have to study on your own and do exercises, but if you get stuck others would be there to help you out always.
 @numbers.each_slice(10).map(&amp;:first).each { |x| puts x } But I think this is much less obtuse: @numbers.values_at(*(0..@numbers.length).step(10)).each { |x| puts x } Or, since we're just doing side effects: (0..@numbers.length).step(10) { |i| puts @numbers[i] }
Given the Raptor site is hosted by Phusion, I'm a little more likely to lend the benchmarks some credence. (At least insofar as how it compares against Passenger.) That does, however, make the completely tone deaf masturbation/vaporware campaign all the more confusing.
Because it's Phusion behind it. Why would they ruin sales of their own product by showing how slow it is compared to open source solutions?
I am mostly looking for text on DOM, but the problem is that the scraper should not be limited to work only for one site. So I am not sure if something like that could be build that's what I am asking. Thanks.
Awesome. I'm still looking for a good set of techniques to remove recursion. 
Too bad rails 3.2.x doesn't want to work with 2.6.x series of mail gem.
Are these benchmarks ran against the incoming free software or the impending closed source version?
Huh, somehow I read over it, and thus that reveals the catch and reason they need to build all the hype for the product before launch.
Against the open source version. There is no performance difference between the open source and the paid version, nor difference in stability. Only available features.
It's not ruby. It's treetop, a PEG implementation. The code on the page is further confusing because they use "if" as a rule name and it gets syntax highlighted like a keyword (it's not though). 
Ran into an error with `APP.initialized?`, so FYI to anyone trying this: The currently published `derailed_benchmarks` gem only works with Rails 4.x while the current code in Github repo will work in 3.2. 
The `method_source` gem is really just a utility gem written for [Pry](http://pryrepl.org) which provides all that and more, through a prettier interface, it can even show the source for C-backed methods: [17] pry(main)&gt; show-source puts From: io.c (C Method): Owner: Kernel Visibility: private Number of lines: 8 static VALUE rb_f_puts(int argc, VALUE *argv, VALUE recv) { if (recv == rb_stdout) { return rb_io_puts(argc, argv, recv); } return rb_funcall2(rb_stdout, rb_intern("puts"), argc, argv); } [18] pry(main)&gt; show-doc pp From: /Users/john/.rvm/rubies/ruby-2.1.2/lib/ruby/2.1.0/pp.rb @ line 16: Owner: Kernel Visibility: private Signature: pp(*objs) Number of lines: 3 prints arguments in pretty form. pp returns argument(s). [19] pry(main)&gt; show-source pp From: /Users/john/.rvm/rubies/ruby-2.1.2/lib/ruby/2.1.0/pp.rb @ line 19: Owner: Kernel Visibility: private Number of lines: 6 def pp(*objs) # :nodoc: objs.each {|obj| PP.pp(obj) } objs.size &lt;= 1 ? objs.first : objs end [20] pry(main)&gt; 
Does this just optimize recursion call performance compared to Python, or does it also allow 'unlimited' recursive stack (within allocated memory limits) as a true tail recursion functional language would? Python recursive stack is limited to 1000 recursive calls by design. Is Ruby limited in recursive stack depth as well per default? Does tail call optimization remove any limit if one exists?
only wish i could use it on private repos :)
That's not too bad. The memory regression was introduced in 2.6.0 so you're still good. When you do update to a modern version of Rails make sure you're using mail 2.6.3 or above or you'll be in for a world of hurt on memory consumption.
Thanks, Rafael added support for 3.2 apps but I haven't cut a release yet. Appreciate you mentioning it.
Looks great! Just tried it out on a couple of my open source projects and it's pretty sweet. I think you can do a lot more with your visualizations, maybe spruce up the css to be a little more web 2.0. Just my opinion.
Awesome! Rubymine has a similar feature, you might want to take a peek, for inspiration :)
Nice. I wonder if a tool like that could be used by beginners to help them *create* rails apps. I.e. they would use such a tool to generate the Rails code. It wouldn't be useful for maintaining big projects, but maybe could help people get started. 
looks pretty cool! i'd suggest linking to the examples so it's a bit easier for the user to see. also, are you generating a diagram each time? if so, you may finding caching helpful and fun to learn/implement if you haven't gotten a chance to play around with it yet
&lt;3 Excellent but, on Redmine (https://github.com/redmine/redmine) Application error appears
Yes, here is the [github](https://github.com/Dan-Burnette/ModelScraper) I think there are some gems out there that would do a better job for your own repos, maybe this https://github.com/preston/railroady? My angle was to make it do-able from the web.
Uhoh... Thanks for the heads up.
ERD may also give some inspiration for your project.
have you seen [rails-erd](https://github.com/voormedia/rails-erd)? It appears to do the same thing (with graphviz), minus a web server.
Multithreading affects *I/O concurrency* (amount of clients you can handle concurrently), not performance (req/sec). It can indirectly affect performance because if your I/O concurrency is smaller than the amount of benchmark concurrency then the performance also drops, but they're two different things, like "performance" vs "scalability" -- the two are related but are not the same. But point taken: if your definition of "performance" is a broad, then yes.
You already mentioned railroady, also checkout: https://github.com/voormedia/rails-erd
yap, [binding_of_caller](https://github.com/banister/binding_of_caller) was actually written for Pry as well :)
Any benchmarks? Why would we use this over the others?
This should work in a constant space, ie. unlimited recursive calls count. Don't like the hack with method_source, doubt its necessity however need to investigate further. AFAIK Ruby compiled with TCO enabled does not need such workarounds. 
Are you aware that there are people in this world who came from the exact same background as you? I for instance am one of those people. I finished an Econ undergrad in 2013, decided it wasn't for me. Dabbled into webdev for a bit before really taking the plunge. For 5 months I did self-study, I had no other responsibilities and my family was fortunately very supportive. Spent the summer interviewing and then landed the job of my dreams. What got my foot in the door to the interviews was having projects I could talk about, code I could show off on github that wasn't from a tutorial. Beyond that, if you match their culture and do well on the code tests then it's smooth sailing. Honestly brah it's definitely achievable, I'm over in NYC but I hear the market in La is quite good also. Pm me for any more questions. Mirin dedication btw
Okay, I see what you mean. I was thinking multi-threading would effect req/sec under concurrency -- like, under a concurrent load, being able to handle that load concurrently will increase your req/sec. But now that I think about it... I just get confused. Either way, yeah, I see what you mean. 
Repped. Got a good chuckle while eating my breakfast. If that's a srs story You did it mane. But what you said is what I plan on doing. Your post gives me reassurance that if you work hard, you're eventually going to make it. What else did you self study besides Ruby and Ruby on Rails?
Chef support. Yessssssss.
Can I develop gems without having to run it as administrator? Edit: Why the downvote? It's a legitimate issue I have with Rubymine under MacOS
&gt; Don't like the hack with method_source, doubt its necessity however need to investigate further. As the author of the post, I can confirm that it's totally unnecessary. :) My previous post was about method decorators, and I played around with the idea just for fun. Once the compile option is set, TCO is enabled for all methods after that, so this trick is pretty much useless.
&gt; Until you get a bug because it turns out the thing you returned it to also expects it to fly like a duck too, but since that wasn't enforced by the language/compiler, you had to just know it from documentation (or much better, automated tests -- tests become very very important), but the documentation was unclear or you didn't notice it. But then your unit tests caught it and you're all good.
A MUCH nicer way is to use pry: ls MyClass
Yeah actually a true story. I didn't really focus on anything besides ruby and rails. By the time you build a few deployed apps you will have encountered so many different parts of the stack and you just learn by doing. I started off with the rails tutorial, went thru it copy and pasting everything. Went back to just learning ruby. Got pretty comfortable and built a few command line apps to get a feel for it. Built a pretty simple app with Sinatra. Then finally back to rails tutorial and by then I really appreciated the framework. If you really set your mind to it you can do it. I had a friend doing the same thing with me, we helped each other out when we got stuck and continued helping each other when it came time to interviews and negotiation and stuff like that. It helps if you have a mentor or someone you can talk to when something just isn't working and you've been googling for 5 hours. 
Das it mane. Which tutorials are you referring to if you don't mind me asking? Also if you have the time, could you recommend me any resources online? I'm trying to gather as much as I can. Cool story bro. SRS. Glad to see brahs make it. 
no Ansible support? :|
I've been at RubyConfs twice. Baruco 2013 and RubyConfPT 2014: - rubyists are friendly, talk with them about your job/work, ask about theirs, etc..confs are all about meeting people - ruby confs have a lot of talks about other programming languages - speakers are people too! Meet them! - #rubyKaraoke Btw, which conf?
There's a good list of resources here http://www.learnrubyandrails.com I was talking about the notorious Hartl Rails Tutorial. It's a really great resource and it was just recently updated as well. There's honestly so many great resources out there. Chris Pine's "learn to program" is an excellent start. I highly recommend it. As long as you try to complete the exercises at the end of each chapter, you would have a really solid ruby base. Eloquent ruby was a nice step up from that and was more useful to me after I had some rails experience. The book kinda makes you realize that rails is just ruby. I didn't find much use from code school. I ended my subscription fairly quick as I started off doing database lookups with no context and I had no idea what I was doing. Building a working app from top to bottom was the best learning experience because you realize how all the parts work together. 
There is an algorithm which cuts down running time by up-to 50%, depending the difference between the size of the list and n. 1. Start pointer 1 at head of list and increment until you have n elements. 2. Start pointer 2, and increment both pointers to their corresponding next element, until pointer 1 hits the end of the list. 3. Pointer 2 now points to the nth to last element.
Why would a ruby ide support python? That seems like a feature for PyCharm.
Why do you need to run it as administrator to develop gems? I haven't had that problem on OSX.
The only reason you'd need to run gem install as root (administrator) is if you're using the System installed Ruby. It's best to install a local Ruby for yourself/user using rvm, rbenv or chruby/ruby-install. While you're at it, setup Homebrew.
I've never really used rvm. I started ruby 6 months ago complerelt self-taught How do I configure rvm with rubymine?
This will be my second so I don't have much insight to to offer. You'll be surrounded by very bright people. It's a great opportunity to talk about your *hard* problems with people that might be able to help you solve them. Hit me up if you want grab a beer! BTW: /u/pr0misc is right rubyists *are* friendly. Try to attend at least one of the parties.
&gt; is if you're using the System installed Ruby You can load gems from your user-specific gem folder from system Ruby. You just need to run `gem` with the `--user-install` parameter.
If its a multi-day technology conference be sure to apply the 3-2-1 rule. 3 hours of sleep a day, minimum 2 meals a day 1 shower a day (do not disregard this) Also be sure to brush your teeth, use deodorant, and change your clothes. You would be surprised how many people don't follow the 321 rule at tech conferences, and you would also be surprised how much more people will like you if you follow this rule at tech conferences, and in your every day life!
thanks. i took at the java solution at the back of the book, and this was the algorithm they used to solve.
My first time as well. We should all meet up
At the end of a talk go up to the front and tell the speaker you enjoyed it, maybe ask them a question. There will be other people there asking questions and saying "hi". At the end introduce yourself to someone from the chatting group and ask about where they work/etc. Great way to meet speakers and make new friends.
Talk to everyone. No shit, there is a lot of knowledge going around. Absorb everything, talk to everyone. Do not be shy.
i have a friend (F) who frequently attends tech conferences. you guys have no idea how much shit she goes through being a female developer. "you're a pretty good developer for a woman", people hitting on her, "my wife" jokes on the presentations... an overlooked recommendation i guess is try to be mindful to sexism with jokes and comments, make it a more inclusive environment for everyone. another recommendation: when talking to people, ask them about their problems. that's where the interesting stuff comes from :)
There's always one dipshit who has to play a white knight and put women on a pedestal. Enough of this shit already.
Ruby is a really good language to learn, but it can be tough to do on Windows. You can set up a virtual machine that runs Ubuntu and you'll have a really great time. Alternatively you could buy an extra hard drive and install Ubuntu there. But that can be daunting, I understand. Try this: http://docs.railsbridge.org/installfest/windows?back=choose_your_operating_system It'll get most everything installed that you'd need to make a Rails app on Windows. This includes the things you've been having trouble installing. Following its directions as exactly as possible, because successful deviation will only come with understanding. As was mentioned, Windows and Ruby don't play nicely together. Eventually something will have to change. Either Ruby gets better in Windows, or you get familiar with Linux.
you are probably being downvoted because you are incorrectly blaming the editor for something it is not responsible for (as other comments have indicated.)
Don't talk about boobs! I was kicked out of Nickel City Ruby because someone overheard the mention of boobs in conversation and reported me for sexual harassment.
One question. What's your financial situation like? Can you really afford to quit to learn Ruby for a few months? If you can't, don't quit. Entirely possible to do it on the side. As another commenter already mentioned, it's highly unlikely you will get a gig in web development knowing only Ruby. You will need to learn (with varying levels of detail) about databases (which you probably know plenty about already), web servers, http requests, html/css/js, etc. You will also need to learn about version control systems, such as git to develop in a team. It's a wide area of knowledge. Learning a lot of Ruby is never a bad thing, but often you won't have to delve into the more esoteric parts of Ruby to produce something useful. Once you've got most of the basics in Ruby, I would suggest you dive straight into Rails and do a small project. Maybe a blog, a to-do-list, a weather app, or just copy your favourite website. Put it all on github, doesn't matter if it's crap. Then find a good open source project to contribute. Then as you do more stuff you can learn as you go on the harder parts of Ruby. So tl;dr, focusing all 4 months into Ruby alone is probably not a wise strategy, and you should really be trying to learn the basics of other parts of web development. 
How am I incorrectly blaming it? I followed their guide: http://confluence.jetbrains.com/display/RUBYDEV/Gem+Development+with+RubyMine And couldn't install the gem without sudo, and then it was a pain to develop. I had no idea about RVM and is not mentioned in their tutorial.
Looks solid man. Gonna dive deeper gradually and once Jan comes around, I'll go all in. Mind if I PM you if I need further assistance? 
They have assumed you know X about ruby before reading that tutorial (To be honest, if you are doing gem development you really should know about RVM and testing against different versions of ruby). There is a hint that they are expecting you to know this where they have the image of choosing the SDK (Second image). You can see in the screenshot they are using RVM. The fact they never mention sudo in the tutorial but you had to to it is another hint that something was not quite right with your setup. To be honest, almost no one uses the ruby that ships with Operating Systems because they are out of date, their rubygems are usually FUBAR'd as you have discovered. Get RVM / rbenv / chruby and use that instead. The system ruby should almost never be touched by a serious developer. And remember a very important rule for developers: &gt; If doing something is a real pain all the time, chances are someone has already fixed it or you are doing things wrong. Get Googling / asking on mailing list / / asking on forum / asking on IRC. Dont assume "It sucks, but that is just the way it is" I hope you don't take any of this this as an insult, it is not my intention. Self-taught is very good but it always runs the risks like this where you might miss something people consider basic. Which is why it is important to try and read as much as you can about the surrounding ecosystem for things you might have missed. Joining IRC / mailing lists is very good for this. Self-taught doesn't have to mean "in isolation". If you had said in IRC "Why do I need to sudo when installing gems!" someone probably would have told you what I did almost immediately. 
I cannot really speak for them but they probably assumed that you knew about RFM / rbenv / chruby but were unable to use it (company policies or something) so thought this was the only option you had. 
It looks like I also edited my post after you read it, sorry, have another read for some extra advice.
Both Obj-C and Ruby are heavily Smalltalk influenced. I know the mother tongue and I find it extremely easy to switch back and forth between Ruby and Obj-C. The hardest thing about Obj-C is the places where it tries to help you out by making you draw lines around an interface and select things from a drop down.
It's patronizing bullshit, just like the idiot that pops up in an earlier comment to teach us about the value of personal hygiene. Thanks guys, these are issues *we don't need your help with*.
You should definitely stick with Node.js, learn the basics (especially asking the [right questions](http://matt.aimonetti.net/posts/2013/08/27/what-technology-should-my-startup-use/)).
Hasn't Rush been around for a long time? I remember looking at it in 2012 and thinking it had some cool ideas but had a bad execution. The repo for this is only a week old though. And looks nothing like what the original Rush does. Still, its pretty cool, and I'd love to see it take off
I actually got to a new job, fully rails development, based on conversations I had on a RubyCont!
Like the great "Millions of Apps" talk in BaRuCo ;)
It depends on your problem. RoR is hard to beat for CRUD backends and Node doesn't have a mature **framework** to compete - the flip side being that you have of flexibility of choice with Node.js. Scalability and speed are separate issues - given the right architecture anything can be scaled; with the right optimizations even Ruby can be fast. If you are talking prototyping though, these shouldn't be even be considerations for the most part. Honestly for prototyping I don't think it matters what language you use as long as it provides the tools to deal with the problems in your domain - go with what you enjoy the most.
&gt; However, I sometimes feel like it might be unwise to even bother learning Ruby since it seems like Node.js is going to replace it and JavaScript needs to be learned anyways for front end stuff. No, it won't. Ruby/Ruby on Rails, Python/Django, and Node.js have and will always happily coexist. Along with other frameworks such as Pylons, Flask, Sinatra, Yesod, Snap, Play, Spark, etc. Why? Because they fill different niches, because they use different stacks. People have different preferences and that's why they use different frameworks. Apart from that, Node.js is not a web framework. It is a javascript platform. If you want to do stuff with web sockets, polling, evented i/o, then it will be easier to get up and running using node. If you're building a CRUD app, Rails will probably be a lot faster for getting out a prototype. Saying node will replace rails or that [rails can't scale](http://canrailsscale.com) means you have no idea what you are talking about.
ri is not included in ruby installer because of its size. You can download [offline chm](http://rubyinstaller.org/downloads) file, it's the same thing. Also you have online documentation. If you really want ri, if I remember correctly, I think [this page](http://stackoverflow.com/questions/1575373/why-does-my-ruby-ri-tool-not-return-results-in-command-prompt) helped me few years ago when I was wondering same question as you.
It sounds like being decent to other people _is_, in fact, an issue you need help with, according to your comment history: &gt; There's always one dipshit who has to play a white knight and put women on a pedestal. -- &gt; Possibly if you're 12, and slightly retarded. -- &gt; Are you so worthless and stupid that this is it? -- &gt; Do you ever get tired of being a diaper stain? Seems like your full-time job. -- &gt; God this reddit is such a shithole of worthless fanboys.
Well.. you have some generators for server side javascript apps with Yeoman: http://yeoman.io
Shelly Cloud settings: https://gist.github.com/bkzl/4f4080ee87f177e87607
Updated the text. Pasted direct link to shelly config in separate comment.
If you debug the project (A bug icon) you'll get access to the debugger for breakpoints and whatnot. If you just Run it (start icon), you shouldn't. Is this what you're looking for or am I totally off?
No problem I'd be happy to help a brah out
This is what we roll with for our background processing applications: export RUBY_GC_MALLOC_LIMIT=8388608 export RUBY_GC_MALLOC_LIMIT_MAX=16777216 export RUBY_GC_MALLOC_LIMIT_GROWTH_FACTOR=0.9 export RUBY_GC_OLDMALLOC_LIMIT=8388608 export RUBY_GC_OLDMALLOC_LIMIT_MAX=67108864 export RUBY_GC_HEAP_OLDOBJECT_LIMIT_FACTOR=1.3 Note that these settings were based on fairly extensive measuring of the applications' memory usage and heap growth. Don't just copy-paste these without making sure they're actually working for you.
I was referring to this, which is mentioned on their "What's New" page for 7.0. &gt; For those who prefer the console for evaluating and executing while debugging, RubyMine now provides the ability to run the console in the context of a debugging session. Previously, you could evaluate and execute expressions in the context of your debugging session by using the expression evaluator popup. The above quote sounds like we can use the console instead of the popup, but I haven't been able to figure out how to do that.
Some tips: 1) Don't be a wallflower - participate! Even if it's just standing around while other's have a conversation, you might learn a lot. 2) Follow the #rubykaraoke hashtag on twitter, because that shit is happening. 3) Try to look at the schedule and pick talks you would prefer to see live vs. those you could handle on video. Everything will be recorded, so there is no loss. 4) Make sure you schedule times to not be in talks. Hangout in the hallway a bit. Too many talks and your brain will explode. 5) Look for me - I'll be wearing Engine Yard gear and a hat (most likely green). We can hang out.
Use map, something like: cities = [ 'New York', 'Berlin', ... ] city_objects = cities.map {|c| City.new(c) }
Maps were never intuitive to me. :S That certainly works, but going back into it in a month I'd have a harder time figuring out what I did. I'd do the same thing, but with a normal .each, for my own clarity. cities = [ 'New York', 'Berlin', ... ] city_objects = [] cities.each {|c| city_objects &lt;&lt; City.new(c) }
&gt;"my wife" jokes on the presentations How is that an example of something your friend "goes through"? After all, everyone else attending the talk has to "go through" that. Are you saying she experiences those jokes differently because of her sex? I would think her sex has nothing to do with experiencing a non-directed joke while a member of an audience.
Think of a map as a correspondence, as a "mapping". Consider a mapping of the numbers 1 through 10 to their doubles. 1 -&gt; 2 2 -&gt; 4 3 -&gt; 6 4 -&gt; 8 5 -&gt; 10 6 -&gt; 12 7 -&gt; 14 8 -&gt; 16 9 -&gt; 18 10 -&gt; 20 Now think of that in Ruby code [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map {|i| i*2} \#=&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] That is, "take each element and 'map' it to its double". Maps are a description of a correspondence between two collections. Here is a correspondence between an array of three strings and those string capitalized ["apple", "banana", "orange"].map {|str| str.upcase } \#=&gt; ["APPLE", "BANANA", "ORANGE"] Or, in my previous vertical visualization: "apple" -&gt; "APPLE" "banana" -&gt; "BANANA" "orange" -&gt; "ORANGE" It helps to say out loud: "apple" maps to "APPLE", "banana" maps to "BANANA", and "orange" maps to "ORANGE"!
I'd argue that in this case, `map` is actually more intuitive (even though they're identical functionally). I'm by no means an expert, but this is my reasoning: * I use `map` when I am transforming one set into another set. I am transforming each value in the set - I am *mapping* the values to other values. e.g. `[1,2,3].map { |n| n * 2 }` * I use `collect` specifically when I am not transforming the values, but picking "sub values" from the items in a set. e.g. `[#&lt;User&gt;, #&lt;User&gt;, #&lt;User&gt;].collect { |u| u.name }` To me, the difference is small, yet important enough to have an opinion on.
Arrays are objects, but to do what you want, I'd either use #map or #each_with_object.
Shopify App Servers https://gist.github.com/csfrancis/ae59547804aedb82016d
An array is an object BTW. If you want to make your own class you can include enumerable in your object. Be careful subclassing arrays. There's some weirdness that may happen.
Lol you linked us to CanRailsScale.com which just says "NO"...
I'm having problems with the configure step while trying to install from source. I see the following error message (where "..." is a path that's not relevant to the error): configure: error: something wrong with LDFLAGS="..." Googling for this error message points to an issue with rbenv-build, but I don't use that. Just in case, I tried installing it and using it to build Ruby 2.1.5, and I see the same error. As far as I know, I have the proper version of gcc installed (command line tools for Yosemite). Any suggestions?
&gt; Don't talk about boobs! Doesn't that go without saying, at a conference? Among professionals?
&gt; I'll be wearing Engine Yard gear and a hat (most likely green). Can confirm: he will be wearing a hat.
Top one. The bottom one illustrates an incomplete understanding of both Ruby strings and Ruby iterators. Many people (myself included) would also consider it bad style to use a ternary operator in that situation. A string is *already* effectively an array of characters *and* an iteratable—abusing `split` to break it up into an array of characters is both weird and unnecessary. If you ever find yourself wondering if you're reinventing the wheel, it's good to read through the relevant docs another time. A quick peek at [the String docs](http://ruby-doc.org/core-2.1.4/String.html), for example, would give you the four `each_*` methods available. Props on the `has_key`, though. While generally less idiomatic today than `include?`, it shows a good awareness of hashes. The actual counting boils down to preference; both your solution of setting or incrementing and the sample code's solution of initializing and incrementing are valid and common. 
How about def letter_count(str) counts = Hash.new(0) str.each_char do |letter| counts[letter] += 1 unless letter == ' ' end counts end
Can you grab your config.log or something and paste here. I am sure we are missing some important error messages here.
Whoosh went the point over your head. ;)
Did have a ton of people who told me "I didn't know about &lt;blank&gt;, thanks!" - especially the environment variables. It's easy but not super obvious. Got to hang out with Perrotta Paolo and Avdi after, I had a super fun time. Also that food!!! Btw Heroku has Safe Harbor now if that info hasn't trickled your way ;)
Sounds like a good bit of that is against the Rubyconf code of conduct: http://rubyconf.org/policies Report and call out people who are doing bad stuff or they won't learn.
They are both not very good, both have a few weak spots. But your solution is nicer, except for the slightly hackish .split('').each, which is nonsense if you then run each on it while you already have .each_char doing exactly this and also stating it in its name. With this exception, you use .has_key, which is hash specific and so a bit clearer, also using ?: to keep stuff in one line is something I prefer (though that's a matter of discussions) A better (or at least more interesting) solution (IMHO): str.delete(' ').chars.inject(Hash.new(0)){|h, c| h[c]+=1;h} This uses inject, what is the right function to do something like this to begin with (collecting the content of an array into a single object with some initial value like 0). Normally you would use inject more to do things like calculating sums of numeric arrays (there is a sum method too of course, using inject this would look like this: `[1,2,3,4,5].inject(0){|x,y| x+y}`). But nothing keeps you from hijacking it to create a single, slightly more complex object (as a hash). Also it uses a nice feature of Hashes, using Hash.new instead of {}, because that way we can give the Hash a value to use when unknown keys are requested. so for `foo=Hash.new(0)` any call like `foo[:x]` will return 0. So we get rid of checking if we already have a counter, we always have a counter the moment we request it, conveniently initialized with 0. The block then gets passed the accumulator value (our special hash) and the element (the character) which we than can combine to count without further checks. I use `.delete(' ')` to remove the spaces, that's a bit cleaner than explicitly checking for a space within the loop. Though it may be a bit slower in which case we would need to add a check inside the loop instead if performance is relevant. 
Ruby strings and iterators are some of the "themes" for these practice problems. The ternary operators have been confusing me quite a bit actually because in every situation I try and use them, it feels like it makes the code less readable. I guess I'll look into how to use them properly a bit more. Up until now I've been using split as a way to take advantage of array methods I'm familiar with and apply them to strings. I guess I'll have to look into it a bit more and see how split is meant to be used. Thanks for your input! 
The #1 way to prevent MySQL deadlocks is to switch to PostgreSQL. Seriously, MySQL is not a good RDBMS.
I don't think you can really generalize. But (now I'm going to generalize), the Ruby community's unofficial motto is [MINASWAN](http://en.wikipedia.org/wiki/MINASWAN). The Ruby community also often espouses the joy of programming. I'm sure this is true in any community, but Ruby has a large number of very well-respected public figures (someone less charitable might call them cults of personality), and even people who don't know them personally are very emotionally invested in them. When Jim Weirich died earlier this year, everyone was devastated. When _why disappeared off the face of the planet, people worried about how he was doing for years and years. People ask about how Ryan Bates is doing all the time, and you get the feeling it's not even just because they want RailsCasts to come back, but just because this is a guy we've listened to for something like 8 years now and they care about him. Of course every community has its exceptions. Maybe what I wrote above isn't even a fair generalization at all. Like a lot of software communities, Ruby has its dark sides. In recent months, more and more of these skeletons in the closet have been coming out, especially related to sexual harassment, but that might be a problem common to software in general. The JS community feels kind of like how the Ruby community felt 10 years ago? Super excited to solve old problems in 20 different ways and claim their solutions are the coolest thing in the world. And sometimes they are. Sometimes they're not. But they're very competitive and defensive in a way Ruby isn't so much anymore. But these feelings could be totally off base. I'm not sure if it even makes sense to talk about "the" Ruby/JS persona.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**MINASWAN**](https://en.wikipedia.org/wiki/MINASWAN): [](#sfw) --- &gt; &gt;"__[Matz](https://en.wikipedia.org/wiki/Yukihiro_Matsumoto) is Nice And So We Are Nice__" (MINASWAN or MINSWAN) is a [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language\)) programming motto designed to promote positivity and goodwill among community members. &gt; --- ^Interesting: [^Yukihiro ^Matsumoto](https://en.wikipedia.org/wiki/Yukihiro_Matsumoto) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cm1n8o2) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cm1n8o2)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
The Ruby community has a fond saying [MINSWAN](http://blog.steveklabnik.com/posts/2011-08-19-matz-is-nice-so-we-are-nice) (Matz Is Nice So We Are Nice). It's an affectionate homage to Ruby's creator Yukihiro Matsumoto. And in my experience, going to conferences and meet ups, yea Ruby devs are typically very nice and open. 
Methods like inject, map, select etc are really important to know and understand. You most likely already noticed that Ruby doesn't use the more classical loops like for and even while. It has while loops of course and there is some for construct, but as a guide Ruby prefers constructs from the functional programming world instead. Looking at some pure functional language like Haskell or Scheme will give you some important insights here. The basic idea is I think that there are a few "loop patterns" you encounter over and over again. One is to create an array by applying some function on each element of another array. For this you use `map`. Another pattern is to combine all values of an array into a single value, for which `inject` is the right tool. Then there is filtering some elements out of an array, for this use select. There are many more interesting methods. Another interesting thing to use are methods that can merge arrays or convert arrays to hashes. For example using `zip` or `transpose` to merge two arrays, the first with the keys, the second with the values and then transform the result into a hash: Hash[[:a, :b, :c].zip([1,2,3])] =&gt; {:a=&gt;1, :b=&gt;2, :c=&gt;3} Really nice if you get data in list form and want it in some easy to use sttructure.
Here's what looks like the relevant part. I have LDFLAGS set to '-L/opt/local/lib', which has worked for me in the past when compiling Ruby. I use MacPorts, thus the LDFLAGS value. I'm not sure why it's looking for /opt/local/lib/mysql56/lib in this check. /opt/local/lib/mysql56 exists, but there is no lib directory under that one. configure:7102: checking whether LDFLAGS is valid configure:7115: clang -o conftest -g -O2 -L/opt/local/lib conftest.c &gt;&amp;5 ld: warning: directory not found for option '-L/opt/local/lib/mysql56/lib' ld: warning: directory not found for option '-L/opt/local/lib/mysql56/lib' ld: warning: directory not found for option '-L/opt/local/lib/mysql56/lib' ld: warning: directory not found for option '-L/opt/local/lib/mysql56/lib' ld: warning: directory not found for option '-L/opt/local/lib/mysql56/lib' ld: warning: directory not found for option '-L/opt/local/lib/mysql56/lib' ld: warning: directory not found for option '-L/opt/local/lib/mysql56/lib' configure:7115: $? = 0 configure: failed program was: | /* confdefs.h */ | #define PACKAGE_NAME "" | #define PACKAGE_TARNAME "" | #define PACKAGE_VERSION "" | #define PACKAGE_STRING "" | #define PACKAGE_BUGREPORT "" | #define PACKAGE_URL "" | #define CANONICALIZATION_FOR_MATHN 1 | #define STDC_HEADERS 1 | #define HAVE_SYS_TYPES_H 1 | #define HAVE_SYS_STAT_H 1 | #define HAVE_STDLIB_H 1 | #define HAVE_STRING_H 1 | #define HAVE_MEMORY_H 1 | #define HAVE_STRINGS_H 1 | #define HAVE_INTTYPES_H 1 | #define HAVE_STDINT_H 1 | #define HAVE_UNISTD_H 1 | #define __EXTENSIONS__ 1 | #define _ALL_SOURCE 1 | #define _GNU_SOURCE 1 | #define _POSIX_PTHREAD_SEMANTICS 1 | #define _TANDEM_SOURCE 1 | /* end confdefs.h. */ | | int | main () | { | | ; | return 0; | } configure:7120: result: no configure:7122: error: something wrong with LDFLAGS="-L/opt/local/lib" 
A usual day at a conference for me goes like this. 7 am, shower get ready to head out. 8 am find food and as much coffee as I can find. 9 am go to the first talk. 12 pm find a snack. 6 pm talks end, go to a company sponsored event / mixer thing 11 pm mixer ends, go to a hotel room party. 3 am party runs out of booze, already feeling hung over. Need sleep. Crap forgot about dinner. repeat 3 times, add a hangover.
Moving forward in learning the language I'm definitely going to look for those types of patterns when I need to use loops with lists of any kind. zip and transpose also look potentially really useful so I'll be sure t keep that in mind. Thanks for the help! 
Walk to the sponsor tables and ask to be hired.
Is ruby webscale ?
Depending on your editor, you can add snippets functionality. In vim you can do someting like bm&lt;tab&gt; and it will expand to a benchmark template. TESTS = ${1:10_000} Benchmark.bmbm do |results| ${0} end where ${0} is the place where the cursor lands after expanding bm.
[This one](https://github.com/threeifbywhiskey/pwnbs/blob/master/app.rb) is a pretty extensive demonstration of precisely how *not* to write a Sinatra app. Extrapolate as necessary.
Yes, I agree that this is good general advice about deadlocks, although with PostgreSQL you can add "Maybe you don't need locking because of MVCC" to the list. Also, PG has first-class advisory locks (rather than letting you implement your own poorly with `GET_LOCK()`), which applications can use in some cases instead of row- or table-level locks.
Thanks so much for the suggestion --- it worked!
That and `map` is the de-facto name for the function in most contexts: http://en.wikipedia.org/wiki/Map_(higher-order_function) I don't know of any other language that has `map`, aliased to `collect` actually, though I'm sure someone could chime in. It looks like Oracle RDBS uses `collect` for a function similar to what's typically referred to as `reduce` in other languages(which btw Ruby has aliased as `inject`).
Very interesting that you use different settings for your background workers, but I guess it makes sense, different settings for different work.
Good start! Some pointers of varying helpfulness: 1) Brackets are optional in Ruby, I'd omit them where possible and where it does not affect readability. Also use single quotes unless you're interpolating strings. :) puts() puts("Welcome to the Towers of Hanoi") puts puts 'Welcome to the Towers of Hanoi' Have a look at ranges: 0..5 # or disks = 5 0..disks Have a look at the enumerable module, there are many more elegant ways to accomplish what you're doing with `while`. Post conditions (guard clauses) can be useful to save lines j += 1 if stacks[2] == stack_0 Should be a start, good job though!
Can you give us some idea of what you are looking for? Do you want a small functional example of Sinatra you can use as a starter template? Do you want a more extensive one that uses a database or other features? Do you want a popularly used example?
I just want to say that we got this man! Class of 2013 from U of A and I've hammering out as much programming as I can possibly do! It motivates me to hear that there are other "brahs" doing the same. I'm gonna hammer out eloquent ruby after hartl's masterpiece. That dude is the tits. 
A [list of Sinatra applications](http://www.sinatrarb.com/wild.html) "in the wild". Many link to their github repos. Or [this Github search](https://github.com/search?utf8=%E2%9C%93&amp;q=Sinatra+file%3Aconfig.ru&amp;type=Code&amp;ref=searchresults) has 15k results for a common usage case for Sinatra.
Looked at that and could have *sworn* it was test input for [this puppy](https://github.com/txus/brainfuck). Essentially all software has defects. *Your* challenge is to find three in *that* without going completely brainfox crazy. Good luck.
Thanks, that was useful.
We actually had a similar problem on my previous job, we had to keep a file not tracked and after your talk we actually moved it to env variables! It was my first conf and I actually manage to talk with Avdi Grimm on the beach, going with him to the sea as well (which was crazy because as a RubyTapas subscriber) and on the farewell party I ended up drinking a whiskey and talking about Portugal and Brazil, music.. with David Chelimsky the guy responsible for me to start working with Ruby in the first place! Ruby conferences are great!! 
Different professions have different standards of professionalism. For example, at an adult film conference, talking about boobs is probably expected. Or perhaps at Vidcon, it's probably okay to make any joke you want. Tech culture tends to be much less censored than, say, the Senate floor, or a surgeon conference. In short, calling something professional doesn't necessarily impose a restriction on low brow humor.
If you think MVCC means no locking, then you don't understand MVCC. Not to mention that MySQL/Innodb is MVCC. PostgreSQL's advisory locking is indeed better than MySQL's though (can't do transaction advisory locks in MySQL).
This is what I'm planning to use: [hashids](http://hashids.org/javascript/) Have you considered this tool? If so, what is the reason you rejected it?
thanks, i found a similar snippet for sublime text.
That is a good gem. I'll consider integrating it with mine :)
I just released this several minutes ago! I would love to get some feedback :-)
Unless you really need the job tomorrow don't do the walk up thing. You'd do that to get a free shirt or a free ice cream, not a job. Simply put : the more you look into the people you are going to work with and work for the more chances you have to be happy to sign the contract or just walk away. Don't ask to be hired : just have a chat. Chat with the people on the stand like you would at a meetup : it's a good way to assess what kind of people they are, what kind of people are in the company. If that part is ok, ask if there is any person of the teams that are hiring at the conference, arrange to have coffee or a simple 5 min chat. It's a double way thing : you get to know possible future colleagues and they get to know you. So go have a chat and see where it goes from there. Conferences usually have a job board too, there is no risk to leave a card there with a way to contact you ... All the best,
That sounds like a good plan. I'll try that, thanks!
The second half of the book Programming Ruby 1.9 and 2.0 by Dave Thomas &amp; crew is a reference. That might be what you are looking for. The first half covers basic programming and some of the ruby ways of doing things and then you can checkout the reference section to try and find commonly used methods. It's known as the pickaxe book.
I'd be interested in a small functional example of a Sinatra app usable as a started template.
[Hazel](https://c7.github.io/hazel/) is a Sinatra application generator which you might find of use. I did.
I tried this on my linux machine with rubinius and the output document was just identical to the template. It did not replace the `&lt;&lt;=title&gt;&gt;` or the technologies. So then I tried in on Windows (and has Word 2013) with jruby and it created an output document that was corrupted and unreadable. Here is the program: #!/usr/bin/env ruby require 'rubygems' require 'bundler/setup' require 'sablon' template = Sablon.template(File.expand_path("./template.docx")) context = { title: "Fabulous Document", technologies: ["Ruby", "Markdown", "ODF"] } template.render_to_file File.expand_path("./output.docx"), context And here is the template.docx, which is basically a new Word 2013 document with this pasted in it and some formatting done to it: &lt;&lt;=title&gt;&gt; Technologies: 1. &lt;&lt;technologies:each(technology)&gt;&gt; 2. &lt;&lt;=technology&gt;&gt; 3. &lt;&lt;technologies:endEach&gt;&gt; The end. Has anybody gotten this to work with a simple example?
If this works, then it would be amazingly useful. I've previously worked on a project where we would manually replace XML nodes based on entries in an actual .docx file which has been a pain that is hard to describe.
Don't think it'll be backported, as 2.2 wil be out by X-mas with a bunch of other improvements, such as symbol garbage collection. Since 2.1.0 the Ruby team is following SemVer-like versioning scheme, so 2.2 should be a simple upgrade.
I personally wouldn't worry about it. I use Google/documentation multiple times per day while I work. It's very difficult to remember everything now a days with all the tech developers integrate with. Just keep practicing and you will use it less and less.
How much does it cost? I'm currently using The Odin Project which has been great so far, but I could definitely use a mentor. The worst part of self learning is lack of personal help.
I've worked at places that had hugely complex workflows built around Word documents. I'm glad I don't work at those places anymore.
Hi williamtbash. It costs US$ 44.95. Chech this page for more details: http://rubylearning.com/blog/2014/10/26/learn-ruby-programming-57th-batch/
Your way of launching resque is now out of date... for me ... #lib/tasks/resque.rake require 'resque/tasks' namespace :resque do task :setup do require 'resque' end end is all that's needed. Your current method is broken on edge rails.
&gt; If you think MVCC means no locking, then you don't understand MVCC. That's not what I said. &gt; Not to mention that MySQL/Innodb is MVCC. True, although InnoDB provides isolation levels which allow client configurations where improper transaction commits can lead to inconsistent data views.
This is excellent.
 loop do @splines.reticulate break if false end This will loop forever... &gt; The only difference is that the loop code is much less likely to confuse. \^\^ apparently not EDIT: After re-reading what I wrote, I sound like a jerk (I removed the fail comment, it doesn't help anybody), my apologies. Thanks to the author for contributing to the world :D
Good point, I think it's just supposed to be: break if true I'll let the author know.
Nice catch, I'll go fix it. :) 
"standard websites people use for a glossary" http://ruby-doc.org/core-2.1.5/ (your version may vary) https://www.omniref.com/ 
this is a cool way of doing it. im sure it could be a little smaller though http://rosettacode.org/wiki/Towers_of_Hanoi#Ruby. This problem lends itself very well to recursion
socialinvestigator net page http://google.com /Library/Ruby/Gems/2.0.0/gems/dnsruby-1.55/lib/dnsruby.rb:562:in `getname': no name for 173.194.116.105 (Dnsruby::ResolvError)
I relocated from rural Tennessee to Northern Virginia for a Ruby on Rails position a little over a year ago. It has been great and we love it so much that we are thinking about buying a house in the area. Living in Fairfax County puts you between Washington, D.C. and Loudoun County, which features some of the best wine country in the nation: http://www.visitloudoun.org/ Plus, you always get to enjoy all of the monuments, museums, and other attractions available in Washington, D.C. and they're all completely free of admission fees. Generally you'll have to pay for parking, but if you live in Northern Virginia you can take a cab or a bus to the Silver Line and ride the metro all the way downtown. 
Because sometimes, you want job security. /s
Thanks, will go through it.
The SF Bay area definitely has much higher salaries for Rubyists than anywhere else. A starting Rails dev here (no prior experience) will make around 100k on average, which is like 15k more than the average in the next best market (NYC).
&gt; This is a too~~k~~l to help track down who is linking to your site.
zing!
This is a bit funnier if you know the origin of [reticulating splines](http://sims.wikia.com/wiki/Reticulating_splines).
If I may promote [myself](https://github.com/noidedmedia/WavHead). 
Ah newrelic... Just another marketing tactic
&gt; gem install lights If God was a Ruby dev.
Hey brazen The current release is very much in "alpha" still. We have it working on some production projects but I am aware that it still contains flaws that I need to work out. Would you mind reporting the issue on GitHub and make the template and script available to me? I'll be happy to debug the issue.
 2.1.5 :005 &gt; "\x2a" =&gt; "*"
day = Lights.new
Usually in libraries things like this are handled with dup (and freeze for constants). But you can go too far with this, and pay for it with both performance and your mental health. Before you do, just ask yourself who are "they" anyway, and is this really adding value. Then learn to let go and trust your collaborators (both in the sense of the people you are working with and in the sense of objects that collaborate with each other to accomplish tasks in your design). **EDIT** On learning to trust collaborators in your design, check out Sandi Metz's book [Practical Object-Oriented Design in Ruby](http://www.poodr.com)
One note: why not to use --to-csv instead of ferry --to_csv? The underscore is weird and not really used anywhere in this sense...
Template and script are here: https://github.com/Brazenx/docx_test
thanks for the feedback. I don't know why we put an underscore there. I'm just used to naming methods with underscores, so I suppose that translated to the command line functions. Are there any documents online with command line naming standards or something?
I don't think I need to know that the page has gotten x amount of shares. Especially not when the notification box floats in the bottom left corner, taking up 25% of the width and a sizeable chunk of the height. I'm on mobile, obviously. :P
PS if a Ducati is up for sale for $50, it's most likely a scam. Keep in mind that the output of a program like this would probably be a while lot of noise. 
I don't know the community's design preferences. That was basically the question. The answer, which amounts to "this isn't considered a problem in Ruby," is fine with me; I just want to make sure I don't have some glaring design flaw in what I'm writing.
Dashed options tend to separate words with dashes. Bare keywords (subcommands) tend more towards underscore separators.
I think it's very context sensitive. My favorite episodes have all been about subjects I was just starting to tackle at the time. Recently I've liked the SOA client one, and the API design one. I'd give links, but the new website is having some availability issues right now. 
The two I keep coming back to are How To Learn, ep... er... I think it's 131, but the site's broken for me at the moment so I can't check, and POODR with Sandi Metz, ep 87. 
This makes me want to buy some of these. I looked at Hue and LIFX but they seem rather expensive, and just short of being cool enough to justify the money. I love the idea of being able to script around the lighting of my home.
Depending on the Web site or the specific listing, scraping the price could be wildly different. Good luck! 
EDIT: meh, you're right, that's not the responsibility of the API
I like to think of it as _"Ruby: you can, but don't."_
Why do I have to import colorz as well? Can't you mark it as a dependency so I don't have to do it myself?
The one they recently had about APIs is good. I can't get their website to work right now, their javascript crap won't work. Oh the irony of having a Ruby website, only to have it destroyed by the sugar-layer sprinkled on top with Javascript. All my requests to api.devchat.tv is failing. 
I'll put that in the next version, how do you like it, it's my first gem. I do ruby since 2 days.
Their site is broken right now, but check out the latest episode with Luis Lavena of rubyinstaller for a fresh perspective on the state of Ruby on Windows. I hear the 'just use a vm' argument too often in this forum, it pushes people away from Ruby, and it is simply not true - Ruby is doing just fine on Windows. Give it a listen and maybe try it out for yourself if you think otherwise.
Yes, I go back and pick and choose the episodes I find interesting. On a scale of one to ten I would give the podcast a nine. Some really good info.
Why is this a /r/ruby thing?
I really like the episode about trends in the community. Also, the recent episode on diversity was great. I'm proud of the way the show promotes diversity.
All of your questions are things you'll just have to think through, as they relate directly to your specific problem. For me, these kinds of questions fall into the response category of consulting, since it's clear you need more than a paragraph or even rant on Reddit.
&gt; What is the typical solution to this? Expect consumers of your library to not do that.
What you've got there is an XY problem. If you want to define `Example#foo` at a distance, just reopen the class. If you wish to define `Example.bar`, either `def Example.bar`, or reopen the eigenclass (`class &lt;&lt; self`) and define the singleton there. If you're wanting to add singleton methods to a single instance, `foo = Example.new; def foo.bar ...`.
I want them in just the new instance, not in all instances. The issue is, I want all this logic in other.rb. Right now my solution is this ... class Example def initialize require_relative('other.rb') self.extend(Other) end end Example.new other.rb module Other def method puts "URHMERGERRRD" end end The issue is, `Example.new` will actually be taking arguments that determine which file.rb to load, which means multiple `Example.new` calls will load multiple `module Other` and I will end up with some monster `module Other` I didn't intend
This is probably the worst system architecture I've ever heard. 
LOL, you Ruby people seem very sensitive.
Do you tell that to a carpenter when you detail your plan to build a house out of concrete and wood screws and they tell you you're a moron? 
I asked if passing arbitrary information to a required script was possible. Apparently it is not. You seem to have shat your pants at the very thought of such a question. I'm thinking you're a bit sensitive.
what kind of diversity: ideas, age, sex, racial? 
Donny, you're out of your element.
Can't answer all of your questions but you might want to take a look at [ActiveResource](https://github.com/rails/activeresource). If this is an established service with their own Ruby gem, you may be able to find sample apps or blog posts demonstrating how others are using it. It might also be worthwhile to reach out to the provider and see if they can point you to any resources. They may even offer you some names of people you could talk to for advice.
Perhaps I've worded my post poorly. These questions are things ill be exploring. I'm looking for generalized resources, best practices and patterns for working with external APIs. A rant on Reddit would be exactly what I'm looking for. Definitely nothing that would require consulting.
ActiveResource looks interesting, thanks for that. I think I've worded my post poorly. I'm an experienced developer and have worked with APIs plenty. However, I haven't before created an application so deeply integrated with a single API, so my post was asking for others' patterns.
Cool! I've been trying off and on to make the switch from RSpec, but get deterred by all the annoyances of getting the add-ons that I want. I could never get minitest set up the way I wanted, thus would ditch it. Looking forward to giving this a go.
Here is a solution, by the way... class Example def initialize $example = self require_relative('other.rb') $example = nil end end Example.new other.rb class &lt;&lt; $example def method puts "method" end end 
Global variables is almost never the solution.
I would love to hear the Sandi Metz one. POODR changed my life. edit: here it is: https://instacastcloud.com/shared/episode/653
Everyone knows "global variables bad," but you should probably know why they are bad, then you could see that this solution doesn't cause any of the headaches that gave global variables their reputation.
What I'd really like, for setting up expensive state (e.g., a db or solr index), is a `before_all` and `after_all`. I know how to fake it (with class variables or singleton classes or whatnot) but it'd be nice if it were explicitly supported.
I have done it in Ruby with this http://msdn.microsoft.com/en-us/library/bb608618.aspx It is not as powerful as merge fields, but a lot easier than manipulating the Word XML directly. They have this system to change values via your own XML file.
No headaches? You've written yourself a nice little race condition for one.
Great book and still relevant. It's not too much of a pain to catch up on the changes.
Clearly, this code isn't intended for a multithreaded use, but add a mutex and suddenly it's fine. Hopefully this subreddit isn't a reflection of the ruby community, because everyone around here seems to have a huge dick in their ass.
Web sockets is the kind of thing you're looking for. They are continuous async events in the client side. I've never usd them on Rails, I've used them with other things, but this gem seems to make support for them pretty easy. https://github.com/websocket-rails/websocket-rails
Asdf
Serious question: why not just use rspec at this point, aside from improving legacy test suites?
I had the same question. The bulk of the gem seems to concern itself with adding to the `minitest/spec` DSL. As a `Test::Unit` user, I don't really see much benefit at all.
Huh?
Do you attend DBC?
It would help immensely if you just tell us which API you are using. If it has a ruby gem then I doubt it is a super-secret squirrel API that is NDA'd etc.
Love it, keep pumping out awesome gems. :-)
came to say exactly this. the only feature really 'missing' for me.
There are a bunch of options to generate Word documents. My goal with "sablon" is to make it easy to format your document inside of Word and reuse that formatting when replacing the values. Mail Merge fields are not strictly required, it's just the first way I've implemented the instruction set. Basically anything that generates somewhat predictable markup around a custom string would work. The library does not make use of the fields but simply replaces them with the actual content.
Details about the issue can be found here https://github.com/senny/sablon/issues/1
You can also check her presentation at BaRuCo last year:https://www.youtube.com/watch?v=npOGOmkxuio
It is NDA'd until official release in a couple months.
Hah. One of my instructors is the author, thought it was interesting a non-DBC student found it. 
Hey, sorry for the late answer. I'm taking it in Hong Kong, quite good, just some of the content in the first few weeks was quite slow for me as most of the people there had never programmed before. However now we are getting into rails and that, so it's quite good fun. Also learning alot.
~120
~ 150$ for insane showoffs producing tons of Java-like code (factories, factoryfactories, factorypresenters etc.)
Abstraction without purpose is just indirection. You may be paying too much for your contractor.
Out source it offshore if money is an issue. Your money will ger more in the Philippines or India. This is the same with any code not just Ruby.
Depending on the project, if you choose your offshore firm poorly it could cost you the whole project. Often it's better to pay the premium rates up front as those costs will likely be less than the repair/redo cost. Good developers get premium rates for a reason... With that said, I hire offshore for small, non-critical targeted projects myself.
This looks very useful. I'm going to be going through a legacy database -&gt; new schema migration some time in the (hopefully near) future. This should streamline the process. Is it possible (both with this tool and in general) to ensure that data moved from one table with auto incrementing IDs to another maintains the same ID sequence?
Ahh, I weirdly wish this was available in paperback. 
Which country? Which currency? Remote work? How complex is your project? What's your budget? etc. etc. etc.
Never offshore something you care about.
I wouldn't consider myself "senior" but I can charge $200 an hour without blinking an eye here in the states. The catch is that I also lend myself as an entrepreneur so I can consult on the overall idea rather than just the code itself.
I would only offshore simple and repetitive tasks like data entry. Personally I can't afford the current rates to hire a good developer so I am trying to learn myself. Next best option to off shoring I guess.
Why is that necessary? I find that when I have a slow setup shared across tests, that's exactly the right time my tests are telling me to extract a repository. Then I have one test that ensures that the repo operates correctly "against the metal," and I simply inject the *results* extracted from the repo into the rest of my logic. class Post &lt; AR::Base scope :search, -&gt;{ |term| where(fulltextiness) } end into class Post::Search def self.query(term) User.where(fulltextiness) end end Suddenly this test: describe Post do describe ".search" do let(:post1) { FactoryGirl.create :post, title: 'My first post' } let(:post2) { FactoryGirl.create :post, title: 'My second post' } before(:all) { Solr.reindex } it "matches terms" do Post.search("first").must_equal [post1] end it "fuzzy matches" do Post.search("frist").must_equal [post1] end # etc. end end Becomes two: describe Post do # ordinary Post test end describe Post::Search do it "hits solr index" do # etc. from above end end Maybe I'm making the issue too simplistic, but I have never needed to share slow setup across multiple tests. Once you prove that you can path through the fulltext index, all of the nuance in your code should be extracted separately from the DB/solr.
Oh man! Is there something it in particular that makes you prefer the paperback? Or do you generally always prefer them over ebooks?
At least hire an experienced dev to review your code. You can't afford to base a business on newbie code.
I would definitely do that. Right now it's more of a hobby and I'm looking to start off with real simple ideas and sites. Not looking to create the next big start up :)
I just generally prefer them, as having it on my desk reminds of me to review it when I have time or to reference it when needed. If I have a pdf in my email/on my computer, it's easy to forget its there.
I hear you. I'm the same way. Thanks for the feedback.
I believe what you are looking for is [#each_slice](http://ruby-doc.org/core-2.1.4/Enumerable.html#method-i-each_slice), which will give you groups of 3. You can also replace #split("") with [#chars](http://ruby-doc.org/core-2.0/String.html#method-i-chars) which will split on the empty string. def seperate_comma(integer) integer.to_s.chars.reverse.each_slice(3).map(&amp;:join).join(',').reverse end 2.1.1 :004 &gt; seperate_comma(1234567890) =&gt; "1,234,567,890" Hope that helps!
thank you very much! is there any way you can explain what each part of that does? 
 integer.to_s # convert integer to string .chars # convert to an array of characters .reverse # reverse the array .each_slice(3) # create an enumerator for each group of 3 elements .map(&amp;:join) # for each group of 3 we were given, join them all .join(',') # join the groups of 3 characters with commas .reverse # reverse the string
While perhaps not as obvious to some, the ability for Enumerator objects to be used as input is actually pretty cool. It allows you to do things such as streaming and parsing XML documents at the same time. This removes the need to first download the document to a file. Note that this particular release does not yet handle missing element tags very well. For example, this is valid HTML but won't be parsed just yet: &lt;ul&gt; &lt;li&gt;Foo &lt;/ul&gt; This instead will be included in the next release.
I will be there :)
This is implicit typing and was introduced into C# some time ago thus instead of typing ... ANamespace.AClass aClass = new ANamespace.AClass(); you can do ... var aClass = new ANamespace.AClass(); which makes for much more readable code but you still have the benefits of type checking :-)
I was there for the keynote, I have yet to read the Fagan paper he referenced but I will probably eventually pony up the $15 for the ACM to buy it. But from what it sounds like he's exploring the idea of optional type annotations, which Elixir &amp; Erlang have via dialyzer. I love this idea, but I'm worried that we'll see the same lack of uptake in Ruby that those communities have around their (IMO quite good) static type checking tool. And yet I agree that I don't think making static typing non-optional is a good idea because it destroys part of what makes Ruby what it is in the first place. I love the idea, but I think it will take more than simple static type support in Ruby to make people actually use it, it will take a bit of a cultural change to explain why people should care.
Thank!
That page was generated with Docco, and [there's a Ruby port](https://github.com/rtomayko/rocco/).
The article refers to Fagan's dissertation, which you can download for free at: http://scholarship.rice.edu/handle/1911/16439
Well, yes and no. There is an aspect of "implicit typing" (or as Scala, Haskell, etc. call it, "type inference"); but in contrast to C# and Scala (and similar to Haskell), it sounds like Matz is proposing duck-typing rather than nominal typing. Specifically, when you write in C#: var aClass = new ANamespace.AClass(); your variable `aClass` has the type `ANamespace.AClass` (by name), whereas Matz seems to be porposing that writing aClass = ANamespace.AClass.new() would cause aClass to have an anonymous type which is defined by the methods that it provides.
Yeah, i looked at docco and rocco. The part that doesn't exactly match up is that it takes comments in the source code and puts them on the side. I'd like to be able to add the annotations after the fact. Along with the external comments/discussion.
I will!
Isn't this some sort of facilitated assertion mechanism, enforceing that certain methods exist?
oh, thanks alot!
No prob! Rubyists don't like while.
haha good to keep in mind. im still learning all of the basics :P
Can anyone who's read the paper (or otherwise understands 'soft typing') elaborate on how this system would offer significant advantages over the 'type checking' we already have in ruby? As in, at runtime, if you call a method on an object that doesn't have said method defined, you get a NoMethodError. From the description in OP's link and the paper's abstract, I don't see how this proposed system would give ruby any of the significant advantages that usually come with well-designed static type systems.
The "whenever" gem can schedule Ruby tasks with cron jobs. If you need something in-process then I recommend Rufus Scheduler. Sorry for no links as I'm on my phone, but they should be easy to find on Rubygems.
&gt; Matz described the envisioned system as one where a “type” is defined by a set of methods and the names / types of their arguments That is in fact what a 'type' is, conceptually, in traditional OO thought, for instance the "gang of four" design patterns: &gt;It's important to understnad the difference between an object's _class_ and it's _type_. &gt; An object's class defines how the object is implemented. The class defines the object's internal state and the implementation of its operations. In constrast, an object's type only refers to it's interface -- the set of requests to which it can respond. An object can have many types, and objects of different classes can have the same type… &gt; ...It's also important to understand the difference between class inheritance and interface inheritance (or subtyping). Class inheritance defines an object's implementation in terms of another object's implementation. In short, it's a mechanism for code and representation sharing. In contrast, interface inheritance (or subtyping) describes when an object can be used in place of another…. &gt; …Programming to an Interface, not an Implementation... I would welcome some kind of better built-in language support for formalizing interface-based types (in terms of 'duck-typing', some kind of more explicit way to specify what kind of duck you're looking for exactly, and if the animal in front of you does have the behaviors you want from that duck). But I'm unenthused about the idea of taking away method_missing dynamic dispatch. 
Back when I was freelancing (earlier this year), my hourly rate was $160 US. 
Way cool. Will be adding this to the toolbox. Thanks!
Honestly, I mostly work around $70/hr, and I get lots of work because it's like an ongoing relationship -- even when I'm no longer under contract, I stay in clients' system and can basically take ownership of whole properties for them/be available for all manner of fixes; I've been in south america many a time, and done minor maintenance/fixes sometimes within hours or even minutes (including one time over an iphone3 with a phone card plan, an EDGE connection and a ssh app, connecting to a screen session with emacs on the server, from a dusty road overlooking Puquio, a small silver-mining town in Peru). There are contractors and then there are contractors. Many clients know that there are contractors who they can develop relationships with that are as long-lasting, and every bit as valuable as many of their FT-employee relationships. Rate goes higher for jobs I perceive as riskier/briefer engagements, and lower only if very convenient or if I'm helping someone out. And occasionally I've quoted some of the rates mentioned in this thread because it was for a job that was necessarily extremely few hours (like $150/hr -- for a job that would only last a day or two). 
I skimmed the paper a bit and got the impression that it's a static analysis with the ability to fill undecidable 'holes' by inserting run time checks into the program. I'm sure it's much more than that, though, and I could be totally wrong. But, just from that impression, I can't decide if I think it'd be the best of both worlds or the *worst* of them. I wonder if any other languages have already implemented a type system based on this paper...
some tests just need class-level setup, abusing class-variables for this is not fun and looks ugly, also makes them initialize on test require and not on test execution.
No. I was there. There are a couple errors in this article. First of all the ratio of big ideas Matz has talked about in the past that made into Ruby is 70/30 not 30/70. Ruby will not become statically typed because then it will not be Ruby. Matz made that clear. Thank goodness. Lots of developers want training wheels. To each their own. I don't need that B&amp;D. I've seen a lot of big systems that are basically big balls of mud. The developers who programmed themselves into a corner would have done so with static typing just as well as without. Those who don't program themselves into a corner they can't get out of easily enough, don't need static typing to keep them out of trouble but for a rare edge case that is hardly a reason to change up such a fundamental aspect. It might be nice in some rare cases but you already have go to languages for that. Matz the wise philosopher has proposed a middle way. Let's think about it for a few years.
Your "solution" fails for any input with more than twelve digits.
&gt; Ruby will not become statically typed because then it will not be Ruby. Matz made that clear. Thank goodness. Lots of developers want training wheels. To each their own. I don't need that B&amp;D. I wouldn't say it's "training wheels", static typing is more about making sure that simple mistakes don't just slide through. Think about something like, say, Civilization 5, where Ghandi goes from being a pacifist to hyper-aggressive; it was due to subtracting 1 from 0 in an unsigned int. Having said that...meh. How often do you lose track of your code so badly that you try to, say, add 50 to "Kilroy Was Here"? I prefer Ruby's way, where it hoists 50 to a string.
We are near the entrance on the right near the "built for rails" banner. Stop by and say hi!
The drift I got from the talk was: "People came to Ruby because it was exciting. If we don't keep it exciting by changing stuff, people will leave to go to other, cooler languages. So here's some stuff. Don't worry if it doesn't make sense, cuz probably most of it will never happen."
[Vibe.d is here for whenever you get a spare weekend with naught to do.](http://vibed.org)
I didn't test it, but I think this should be possible. data-import is basically just a wrapper over sequel, which means that you can do anything that sequel and your database library allow. In data-import you would just define a mapping for the primary key to achieve your goal.
this post is worth a read: http://blog.moertel.com/posts/2006-10-18-a-type-based-solution-to-the-strings-problem.html
Omniref does support personal repositories now. Connect with Github, and we'll pull in your public Ruby projects and index them like any other Gem. We haven't made a lot of noise over this (yet), because we've been working out the kinks and wanted to grow it slowly. If you need something more, get in touch with us and we'll try to make it happen: support@omniref.com
You could use the resque scheduler gem and enqueue job for the event as soon as its published/updated, then in the job you can pass in an argument to recheck and requeue itself if its a recurring event. 
Thx and where/how u learned programming?
This is really strange for me. There are other languages. Dynamic nature of Ruby is what defines it. It will not be Ruby anymore. There are so many statically typed languages, no need to make Ruby another one.
When I was a kid, my parents got me an Apple LC II with 13MHz processor, 8MB RAM and 75MB HDD. It had no modem and a huge 15" 1024x768 CRT monitor. This was an awesome computer since it had a FPU. I started programming with BASIC on this computer and loved it. When I wasn't programming, I was playing Scrufy (a platform based game where you were a dog collecting bones). I came about programming when I picked up an Apple-based magazine and it had an article on SquirrelBASIC and some sample codes. I was intrigued. So I inserted the floppy disk that came with the magazine and loaded the SquirrelBASIC onto my Apple. That's where it started. A few years later, my parents got me an 80286 IBM Thinkpad Laptop. It was amazing. From there I continued BASIC programming in QBASIC since it was what I knew already, but eventually found out about C++. I started taking the existing programs that I had written in BASIC and started converting them over to C++. It was pretty awesome because I could now distribute my programs without having people look at my code! (keep in mind that I was still a preteens kid). This pattern continued on through Visual Basic. Once the internet became a bit more popular, I got AOL and discovered the internet. From here I started to design HTML 1.0 sites with very basic content and data. I made a website for my mom who was an artist, made a website for myself and so on. This continued until ASP hit the scenes and I was able to do some cool forms and more interactive stuff. I started making little blog style sites and junk. From there I found out about apache and php which I started with the open source route. I continued PHP until I found ruby. I have been professionally developing Ruby applications since. (including Ruby on Rails and so forth).
Yep. This was mostly the generation I grew up in. Something didn't exist, make it. Need to learn something, learn it. Today, kids have it really easy. Even my kids, I see them 'googling' something to figure out how it works instead of thinking of how it works. 
Oke and can u recommend amy sides or programms or anything else to learn it?
Oke and can u recommend amy sides or programms or anything else to learn it?
Optional static typing is great, dart does this incredibly. I've always been confused about the ruby communities love for TDD but not static typing. Having static type checking in development and dynamic in production would be incredible.
&gt; I'm limited to 250,000 API calls a month. How should I manage the limit when I don't know the total number of users at any given time? I would store as much data as possible in your local database to avoid API calls. Can you live with some stale data? You could cache some of the responses. Do you need every request to be instant? Can you batch them? &gt; What about encapsulation? How much or how little should my models and controllers know about the API, respectively? Anything to keep in mind? I would not build a facade until i wanted to add support for another API provider or the current gem has major problems. It is ok to be coupled to another API as long as the application is not expected to change in a different direction. &gt; What about certain API calls that require a rather immediate response? Are there polling libraries available to make updating the view with AJAX a simple process? You should have a look at the [sync gem](https://github.com/chrismccord/sync). Their github page describes it as: "Real-time partials with Rails." Alternatively you could build something around [faye](http://faye.jcoglan.com/) 
What are you trying to accomplish? What is your ultimate goal?
&gt; There's lots of calls to Ruby's kind_of? method, which asks, "Is this a kind of User object? Because that's what we're expecting. If we don't get that, this is going to explode." I certainly don't think I'm smarter than Alex Payne, but this part of what he said sounds to me like he doesn't entirely grok the philosophy behind Ruby. With Ruby's loose typing, the idea is that *as long as the object responds to the same methods, the type shouldn't matter.* In other words, the code in the Twitter API that's expecting a `User` probably doesn't need to expect a `User`, it just needs to expect some object that responds to a few relevant methods in particular. If you have code to print out a User's name, say, and you write def print_the_name( user ) puts "#{user.first_name} #{user.last_name}" end ... then that code is perfectly usable by any object where `respond_to?( :first_name )` and `respond_to?(:last_name)` are true. Most importantly, notice that *nothing's going to explode* if this method gets something other than a `User`, so there's nothing unsafe about leaving the type un-checked. And adding an explicit `raise "Bah Humbug!" unless user.is_a? User` would reduce the flexibility, and thus the reusability, of this code. The number of times that it's *actually true* that "If we don't get [the object we're expecting], this is going to explode" in a Ruby app is very small.
Could you push a jruby version out?
I'd like to programm something with games
I'd love to see an example of this. I think different rubyists approach this kind of problem in different ways, and what has always drawn me to Minitest is that the *lack* of features, particularly in the mocking system and the spec DSL -- which I only use at work, since it's hard to get folks to agree to use `test/unit` syntax -- has been useful constraints that led to better designed code. But I'm open to see other approaches, tbh.
Nice! Thanks for this link, you are a hero
Ruby communities love TDD. You might have a different opinion but why not let Ruby guys do what they love? Its working very well. If Dart is your thing, just do Dart! This is the beauty of it. If we put more and more stuff we'll end up with gigantic language like C++. We already have C++. I prefer languages that do their stuff well. Let Ruby by dynamic.
Medium.com?
I love JRuby! One time we had to build a small gem to do some work with a partner's API and that API was in the form of a Java SDK. JRuby worked flawelessly and amazingly!!
Has anybody read this book? If so, how is it?
Some ruby people (why use the word guys? females use ruby too) want to do what they love, which is work with ruby, but also use static typing. I know of one friend, who really likes ruby, but will not use it, because its not statically typed. I want him to be able to use it. And if static is the option, and dynamic is the default, what's it to you?
&gt;why use the word guys? I'm not a native speaker and I do this all the time ;( I need to try harder and use 'folks' instead. &gt;And if static is the option, and dynamic is the default, what's it to you? It would require massive focus from ruby core team that is needed elsewhere. Even if they start today it will take them probably years to ship anything prod ready and it will delay other work. MRI is not Clojure where you can just write a lib and boom, optional typing. I'm happy with current situation. I use Haskell when I want to have state of art type system, Ruby for not-performance focused backend and Clojure for performance. I hope that each language will continue their focus on its main features.
I have been helping my clients to develop their projects by remote work. I'm from Cambodia, but it shouldn't be a problem with that because if you can help them to archive what needs, who's care where are you on earth. I charge $100/h for my current projects.
You can replace Alex Payne's bit about `kind_of?` with your improved Ruby semantics regarding `respond_to?`, but his main point still stands. In order to ensure a large code base of Ruby works correctly, you must build up your own (large) suite of unit tests that exercise the code by actually running it in the manner you expect it to be executed. His point is that for every large system written this way, you expend a lot of labor recreating what is essentially a fascimile of a type system, when other languages already have this feature built-in. I would add to his point that even after expending this labor, the dynamically typed language still comes up short as they are unable to perform certain optimizations that a statically typed language can. For example, the Haskell compiler performs *type erasure*, which completely removes the notion of types from the runtime, so you no longer have that type-checking overhead when the code is executed. A dynamically typed language can never make that kind of optimization. &gt; The number of times that it's actually true that "If we don't get [the object we're expecting], this is going to explode" in a Ruby app is very small. That has not been my experience. How many times would you say you've seen `NoMethodError: undefined method 'foo' for nil:NilClass`?
I'm not testing my application's behavior against (in this case) Solr; I'm testing the actual behavior of Solr combined with my indexing logic (which is at least partially embedded in the Solr analysis chain), etc. Under what search conditions does Doc1 appear before Doc2? What's the effect of tweaking a few parameters here and there? Factories don't help in this case; they're replacing the actual thing whose behavior I want to test. Setting up the solr index with a handful of documents is orders of magnitude more expensive than running the tests against that solr index. There are plenty of systems complex enough that testing under various configurations is a useful thing to do, and where changing config is much, much cheaper than tearing down and setting up a whole new instance. Right now I define singleton classes and set a variable in a `begin` block, but that's ugly and it doesn't help with teardown (which can also be expensive).
Who's laughing now?
Ahh. I see. You want to test against a working Solr index that you can modify and observe changes on. I'd have to see an example of the test to figure out what my approach would be (suffice it to say, my goal would be to isolate my indexing logic from Solr's behavior).
He said statically typed Ruby would not be Ruby. I take him at his word.
&gt; In order to ensure a large code base of Ruby works correctly, you must build up your own (large) suite of unit tests that exercise the code by actually running it in the manner you expect it to be executed. Sure, but you can say that about every language, even statically-typed ones. Unit and integration testing are necessary on any code base, regardless of size or language. Anyone who thinks that static typing is going to reduce the amount of time you spend on testing by any dramatic amount is (IMHO) fooling themselves. (Note, I know this isn't what you or he are arguing, I just wanted to start by pointing it out.) &gt; His point is that for every large system written this way, you expend a lot of labor recreating what is essentially a fascimile of a type system... Here's where I'm not sure I agree with him. I respect his experience and I'm sure he has some reason for what he's saying, but let's think about this. If your developers are recreating a "facsimile of a type system" -- i.e. they're writing everything that static typing would have given you -- then that means you're manually checking the types of *every argument and every return value of every method in your code.* That would, indeed, be a massive waste of effort, but nobody *actually does that.* (Except maybe Alex and his team, I guess.) Instead, we usually check only the critical places. If you have a method that returns an ActiveRecord::Relation, it's almost-always sufficient to check that your method's result is `.present?`, rather than iterating over every element in the relation and checking to be sure that it is `.instance_of? SomeModel`. If he's paying his developers to do that, that's his own decision to waste that time and money, not Ruby's. &gt; ... the dynamically typed language still comes up short as they are unable to perform certain optimizations... This is certainly true, but I wonder how much of a real-world impact that actually has. The trend over the past 25 years has been that, as processor cycles and RAM get cheaper and cheaper, code efficiency matters less and less. I see no reason to think that that trend would suddenly stop or reverse, so it stands to reason that even if some dynamically-typed code runs 500ms slower than equivalent statically-typed code *today,* 24 months from now the same code might only be 250ms slower. 18 months after that it might be only 150ms slower. Eventually you pass the point where any of your users can notice a difference, and other effects (network latency, for example) start affecting your performance to a much greater degree than the type system of your language. &gt;&gt;The number of times that it's actually true that "If we don't get [the object we're expecting], this is going to explode" in a Ruby app is very small. &gt;That has not been my experience. How many times would you say you've seen `NoMethodError: undefined method 'foo' for nil:NilClass`? During testing? Pretty frequently. That's what testing is for -- shaking out the glitches. But in production? I've seen a `NoMethodError` on `nil` maybe once every few years. Not frequently at all. But I'm still not convinced that that experience represents a weakness of dynamic typing. Simply checking to see if my methods return `nil` doesn't really count as "recreating a facsimile of a type system," it's just good practice. Certainly, if you pass `nil` in to my example method above you will get an exception, but in order to guard against that, I just need to check that the input is sane; I don't need to *prevent* people from passing in, say, a `Student` or a `CartoonCharacter` or a `Patient` model or anything else that would make sense in context, like a static typing system would. If *that's* what the developers at Twitter are spending their time doing, that illustrates a misunderstanding of the intent of the language.
Hmm. I wonder if he meant "would not be Ruby" in the sense of "will not be allowed to become Ruby" or in the sense of "would be extremely different from what we think of as Ruby." Thanks for reporting back.
you ever try using spaced repetition software like Ankisrs.net?
Basic rehash of these, arguably more insightful, articles: http://yugui.jp/articles/846 http://yehudakatz.com/2009/11/15/metaprogramming-in-ruby-its-all-about-the-self/
I agree here. I actually replaced all my Perl usage with Ruby a good few years back.
Argh fuck, I totally forgot that. Just pushed it, sorry for the troubles.
Right. The speed difference between dynamically-typed code and statically-typed code (or for that matter, interpreted code and fully-compiled code) can be very application-specific. I picked some numbers to illustrate my point; I don't know that they're necessarily totally accurate, and how good of an illustration they are would depend a lot on what you're doing. But my broader point is that, as history marches onward, more and more we find that these speed differences *don't matter.* 1.9MB of text in 30ms is damn impressive, I must admit. If I had to guess, I would expect to see a Rails app take closer to 3000ms to spit out the same 60K items. But whether that 100x difference *matters* depends on what's consuming that JSON. If that data is being sent to a JS front-end on a client browser and rendered for human consumption, the rendering process and the user's consumption of the rendered data are going to be the bottlenecks, not the creation of the JSON. If it takes the user's browser four seconds to process the data and update the screen, then it doesn't matter whether your app rendered that JSON in 30ms or 3000ms (as long as you don't do something dumb like buffering the output until it's complete). Even if it takes 3000ms to send all the JSON, the client is still going to be working on rendering a previous data item when the next data item arrives. And even if the JS on the client could render the data as fast as it receives it -- all 60K items in just 30ms -- the human in front of the client *can't read the screen* that fast, and will never be able to tell the difference. (The screen hardware would also start to become a limiting factor here; even a refresh rate of 100Hz would mean that the fastest anything could be put on the screen would be 10ms. So the 20,000 items that the client receives during that 10ms refresh cycle are going to have to wait for their screen time, no matter how fast your server can send them out the door.) Let me also preemptively address the obvious caveat here that what doesn't matter to the *client* might still matter to the *server.* These differences add up fast when your app is serving thousands of requests per second. If it takes 3000ms before a thread can move on, instead of 30ms, that's a clear bottleneck. But this, too, becomes less relevant over time. When extra instances are cheap, this kind of bottleneck can often be addressed by growing the size of your app server pool, rather than by changing programming languages. And as instances get cheaper and cheaper and cloud computing becomes more and more commoditized, fixing server-side bottlenecks by increasing parallelism will become more and more feasible. Sooner or later (probably sooner), that 100x difference in render times is going to be just as irrelevant on the server side as it is on the client side. Are these differences worth considering *today?* Yes, for sure. Large system architecture must keep them in mind; anything less would be irresponsible. But they're NOT worth uprooting your entire development ecosystem to try to fix them, because every day they get less and less relevant.
There was a really big debate at a start-up I worked at between me and a Perl guy about what to write the test framework in. Ruby has massive community support. It's also extremely easy to pick up the basics, and at the same time abstract away the heavier stuff, so that less experienced people can quickly come up to speed and work in the implementations, while more experienced Ruby coders can work deeper down in the classes/modules, interfaces, and metaprogramming bits. Perl syntax to me is unforgivably obtuse. The Perl "OO" support is perplexing, and with a less active community, half-cooked bdd/tdd frameworks, and varying architecture support, to me Ruby was a no-brainer. The Perl guy and myself absolutely could not agree, so the company put it to a vote, where neither myself or the other guy were allowed to vote. It was unanimously voted to go with Ruby. The test coverage has spread like wildfire, with everyone (from manual testers to senior developers/architects) all writing tests and contributing. I think we made the right choice.
It sounds like you package your app up as a single .jar (or .war) with the jruby runtime included, no need to install jruby on the host separately? I'd be interested in hearing more about what packaging/release tools you use to make this so. 
i do agree as well, with only 1 day perl experience the only reason i wrote it in perl because i had to choose between sed, awk, bash, c and perl
There can be no "isolation" from solr. The very nature of it is that data gets transformed during ingest into solr by a variety of analyzing filters, tokenizers, etc. Dynamic fields are created based on the name of the field passed in, and data are copied to other fields, often with different tokenizing/mutating code. Solr is a complex enough beast, with enough edge cases and just plain bugs, that it's easier for me to write tests to determine behavior than to try to read the Solr code. Example: I index a phrase; I expect it to tokenize to five tokens. Which it will, unless there happens to be a zero-width space in it, which might make Solr guess it's Korean, which will change the tokenization process. Or unless a pre-tokenization filter matches against something and (perhaps mistakenly) removes an apostrophe *before* tokenization occurs. Or any of about a zillion other things. You're right that ideally all the transformations would happen in either solr or ruby, but for many things it makes sense to do heavy-duty transformations during indexing time, but basic normalization within solr because then it transforms *query* text in exactly the same way, no matter which of a collection of heterogenous consuming applications is querying the data. Not the average "I'm building a little gem/website" problem, of course. I don't claim that it would be useful, or even a good idea for everyone. But it is for *me*. And every time I bring it up, I get told, "No, you don't want that, you're an idiot" which just makes me tired.
I like OP's article because it covers DSLs while the ones you linked don't. As a Python programmer, I am used to things like: with obj.context() as c: c.do_something() c.do_something_else() It's nice to see uses of Ruby's flexible `self` which allow code like that to omit referencing of the temporary variable over and over. This is not the work of hacked-in syntactic sugar but is due to the fact that *everything* is a method (a message sent to an implicit `self`) in Ruby, which separates it from many other languages.
"Oh, you've redecorated. I don't like it." - The Doctor 😁
I'm really disliking this flashy, in-your-face-ness of these new designs. But that's only for the color scheme. I much preferred the subtle, laid-back-ness of the previous version. But that's only for the color scheme. I much prefer the newer version's gem page layout. What's jarring is that not all the pages have been converted to this new style yet. Please excuse my on-the-fly-adjectives. :)
I appreciate that you use the oxford comma.
https://github.com/jruby/warbler is the one I most often hear cited. There are others (not all jruby) for different OSes and use-cases that may be of interest. monkeybars ocra packager
This is cool, I can't wait for the next part of the series! 
😱
Docco led me to Groc (http://nevir.github.io/groc/), which looks like it has a few more features. I particularly like the "Table of Contents". Seems like it'd be helpful in a big Rails project or more complicated gem.
The fact that the search field is automatically focused on page load is a small thing but it's so much more convenient.
is the documentation show in a more prominent way then the painfully obvious boilerplate of "gem install packagename"
It's an interesting idea, but I'm not entirely sure why the debugger needs to be tightly coupled with the testing framework. I do something similar with Cucumber and pry-rescue. I monkey patched [cucumber_run_with_backtrace_filtering](https://www.omniref.com/ruby/gems/cucumber/1.3.3/symbols/Object/cucumber_run_with_backtrace_filtering) to yield inside [Pry.rescue{}](https://github.com/ConradIrwin/pry-rescue) so whenever a test fails and raises an exception, pry automatically invokes at the point of exception. The same could be done with other testing frameworks. I believe [plymouth](https://github.com/banister/plymouth) set out to achieve this, but it hasn't been maintained in a couple years :/
Wait...I see it as orange. It would make a lot more sense if it were red. Do I need to recalibrate my corneas?
I agree - I actually just submitted a pull request to do the same for the site-wide search input in the header.
No, that is a burnt orange fading into red.
&gt; Other good options include scrypt, and PBKDF2. However, bcrypt is considered superior Are you able to elaborate on how you actually managed to mention scrypt, then claim bcrypt is superior? How did you come to this conclusion? It's false.
As I noted in your xpost: &gt; http://blog.ircmaxell.com/2014/03/why-i-dont-recommend-scrypt.html does a fantastic job of explaining this.
&gt; http://blog.ircmaxell.com/2014/03/why-i-dont-recommend-scrypt.html tl;dr: don't use scrypt with &lt;= 4MB of RAM? scrypt is sequential memory-hard. bcrypt is not. scrypt represents the state-of-the-art, and one of the common themes of the Password Hashing Competition has been improving on scrypt is difficult. (I'm also on the PHC judges panel)
Why do people insist on shoehorning static typing into Ruby? I feel like they're missing the point. If I want to operate on a string, I don't care if the object given to me is a string, float, array, or jukebox controller, as long as it responds to .to_s. Quack quack, baby.
Nice, but I don't like how it wastes so much space on margins and paddings. Now I have to scroll to see a gem's dependencies and version release dates, even on a 1920x1080 display. E.g. here's the overview page for selenium-webdriver with a lot of padding: http://i.imgur.com/PWOUPE0.png I would prefer it with a lot less whitespace, like this: http://i.imgur.com/os3FUgK.png. 
“Ooh yeah, look at me. I'm wearing *sand-shoes*!” - The Doctor
i am interested in where perl shines, in _your_ oppinion
Hey, IT'S Ruby. It's supposed to be red! :)
Great, the search field (basically the only valuable element of the interface) is almost invisible.
Agreed, what a waste of space.
It has focus and the only animated element on the page; the cursor. 
The cucumber_run_with_backtrace_filtering seems pretty cool. I wasn't aware of it; though, I'm not much of a cucumber fan.
'Oh look, the round thing!' 'I love the round things!' 'What are the round things?' 'No idea'
Too orange, make it more **red**.
I don't think you can call Ruby and Perl "conceptually similar". There is some overlap (dynamic, GCed) but otherwise concepts and syntax differ dramatically. The best I would say in favor of Perl is the large existing codebase and especially CPAN - and it's probably faster for some problems, too. For the majority of aspects that matter to me (OO, clean syntax, readable code, sane regex) Ruby wins hands down.
Thank you for the insight. I really did not imply that you are an idiot, but I did want to see the use case. In all my time testing -- and this is time spent on far more complex and nuanced applications than "little gem/website" type problems -- I have never needed the feature you're asking for. So it's natural to be curious about your use case. If you need to rig up something to help you test solr, the minitest way is to solve the problem with ruby. Because minitest test framework is implemented as human-decipherable objects, it's not challenging to extend it to meet your needs. With a tool like rspec, on the other hand, pretty much every testing problem you might need solved must be explicitly supported by the framework. I'd rather solve problems like the one you describe directly -- certainly `before :all` and `after :all` are very *rarely* useful.
Most of the projects I've tested with pry-test have been small libs, so I haven't run into the reload problem yet. Having said that, I'd be happy to help find a solution to the reload problem if you will help me setup a test case for it.
Clever but looks very tacky. Instead of castrating Ruby I'd use https://github.com/manastech/crystal which has optional, *built-in* type checking. 
&gt; almost burned my retinas out Yeah that red is really strong!
'Oh my...' The actual gem pages look cleaner, though the padding is rather obnoxious.
The graph behind it looks like a lot of cursors.
Ah. This is where it turns out I *am* an idiot. I've gone through the minitest code and can't find a good place to hook into it for the before/after stuff. Ideally a `describe` block would run something before any of its tests and something after, exactly once, but as near as I can tell I'd have to do *major* surgery to make that happen, if I personally could do it at all. So I keep hoping someone smarter than me will take up the case :-)
Yeah, "scrypt isn't designed for password storage" is a completely disingenuous argument. The reality is much closer to "bcrypt isn't designed to be a KDF". That doesn't make bcrypt bad, but that line of reasoning makes it sound like scrypt is worse off for being a KDF (when, in fact, most other password hashing functions in the world also double as KDFs) There are valid arguments against scrypt, like DoS potential on high-volume sites where too many authentication attempts would exceed available system memory. That blog post had surprisingly few of them.
In creating job security for people tasked with maintaining Perl code. Perl is the COBOL of our time. Don't get me wrong. Perl was my first scripting language. I loved Perl. But it's dead now. You'd be crazy to start a new project in Perl.
I don't really understand the copy on the front page -- "Find your gems easier, publish them faster, and have fun.". It's like they are trying to sell a product? Also it's still kind of weird to see hamburger menus, since it's such a mobile-centric design pattern. Other than that, it's always nice to try something new!
I'd start with something like this: # test/support/shared_setup.rb class SharedSetup &lt; Module attr :block def initialize &amp;block @block = block @complete = false end def complete? @complete end def complete! @complete = true end def included test_class # Make e.g. MySolrTest.shared_setup return this instance test_class.singleton_class.class_exec self do |shared_setup| define_method :shared_setup do shared_setup end end test_class.send :include, InstanceMethods end module InstanceMethods def run_shared_setup instance_eval &amp;self.class.shared_setup.block self.class.shared_setup.complete! end def before_setup super run_shared_setup unless self.class.shared_setup.complete? end end end # the test class MySolrTest &lt; Minitest::Test include SharedSetup.new do # setup solr here end def test_something end def test_something_else end end # if spec syntaxes are your jam describe MySolr do include SharedSetup.new do # setup solr here end it "something" do end it "something else" do end end This is designed to be very generic. You could cut down on the code by making it solr specific. The only part of minitest's api I'm actually hooking into is `Minitest::Test#before_setup`. This allows the solr setup to not interfere with your test's setup code.
but I want 100% of it, not just the first quarter :(
&gt; as long as it responds to .to_s That's what interfaces/type classes are for (e.g. `.to_s` would correspond to Haskell's `Show` type class). You combine the freedom of duck typing with compiler enforced correctness that way.
How about 100% of the first quarter?
Read this and then come back to the thread. http://www.reddit.com/r/getdisciplined/comments/1q96b5/i_just_dont_care_about_myself/cdah4af?context=3 A few things to remember. 1. Everyone was in your shoes at some point. You just have to start. 2. You will have days you wont understand programming or get frustrated. Recognize that this is hard. This is not easy. If it was easy, everyone would do it. They don't. It's hard. 3. On those bad days, forgive yourself. Appreciate the effort, not the failure. TLDR: Just start. 
Oke thank you :) Do you have any tipps for me.how to learn programming? With books, websites (like codecademy) or any programm? Or somehow else? I'd like to do anything with games when im better at programming some day :) Sry for my english it isnt the best 
What time stamp is it at?
How does it work!? Did he release the source code anywhere?
I was at this talk - 99% sure it was a joke. The code produced after those dilutions isn't valid syntax.
Ahaha tenderlove! &lt;3
x2
100%?
Is monkey patching `Object` really the traditional way to make DSLs? I thought the traditional way was to put methods onto something and `instance_exec` a block with it. Something like this: module ZooDSL def self.monkey puts 'Screech!' end def self.lion puts 'Roar!' end end def zoo(&amp;block) ZooDSL.instance_exec(&amp;block) end zoo do monkey monkey lion end
https://m.youtube.com/watch?v=yL_-1d9OSdk
Actually, yeah. You can check out the [annotator_store gem][1]. I'm currently working on it so it's pre-release but slowly working on it towards a v1.0 release. I'd advise you get it working on a test Rails app and see how it works. I'm open to guiding you through the process and and sorting out any reasonable issues that you may have with it. The [source code is available too][2] if you wanna have a peek. Oh, and you can [raise the issues on the bug tracker here][3]. [1]: https://rubygems.org/gems/annotator_store [2]: https://github.com/itsmrwave/annotator_store-gem [3]: https://github.com/itsmrwave/annotator_store-gem/issues
What do your logs say?
I saw him give a long form version of this talk at Keep Ruby Weird in Austin last month. It was pretty hilarious then too.
I have repetitive warnings like the one from below in the mail log, however these seem to be from when I was trying to manually send an email via ssh to test, not from testing the app. Mailgun logs are completely empty. Nov 20 04:55:20 cloud-server-01 postfix/smtp[26811]: warning: /etc/postfix/main.cf, line 42: overriding earlier entry: relayhost= Nov 20 04:55:20 cloud-server-01 postfix/smtp[26811]: warning: database /etc/postfix/sasl_passwd.db is older than source file /etc/postfix/sasl_passwd Nov 20 04:55:20 cloud-server-01 postfix/smtp[26812]: warning: /etc/postfix/main.cf, line 42: overriding earlier entry: relayhost= Nov 20 04:55:20 cloud-server-01 postfix/smtp[26812]: warning: database /etc/postfix/sasl_passwd.db is older than source file /etc/postfix/sasl_passwd Nov 20 04:55:22 cloud-server-01 postfix/bounce[26813]: warning: /etc/postfix/main.cf, line 42: overriding earlier entry: relayhost= Nov 20 04:55:22 cloud-server-01 postfix/smtp[26811]: 993DB102ECD: to=&lt;redacted&gt;, relay=secure.emailsrvr.com[166.78.79.129]:587, delay=21386, delays=21384/0.01/1.8/0, dsn=4.7.8, status=deferred (SASL authentication failed; server secure.emailsrvr.com[166.78.79.129] said: 535 5.7.8 Error: authentication failed: UGFzc3dvcmQ6) **Edited for add'l log** LOG FROM DEVELOPMENT ENVIRO Started POST "/users/create" for 66.87.117.101 at 2014-11-20 06:08:03 +0000 Processing by UsersController#create as HTML Parameters: {"utf8"=&gt;"✓", "authenticity_token"=&gt;"WQXeJuBFxtDvamuMU/ukx/pAlb1XCcF4NcH8NU/zZik=", "user"=&gt;{"email"=&gt;"laserboy@gmail.com"}, "commit"=&gt;"Step Inside"} [1m[36mUser Load (0.2ms)[0m [1mSELECT "users".* FROM "users" WHERE "users"."email" = 'laserboy@gmail.com' LIMIT 1[0m [1m[35mIpAddress Load (0.1ms)[0m SELECT "ip_addresses".* FROM "ip_addresses" WHERE "ip_addresses"."address" IS NULL LIMIT 1 Redirected to http://signup.URL.com/ Completed 302 Found in 2ms (ActiveRecord: 0.3ms)
Seeing that reminds me of this Mitchell and Webb sketch. That Mitchell and Webb Look: Homeopathic A&amp;E: http://youtu.be/HMGIbOGu8q0
You are accessing the keywords instance variable directly. Instead do `keywords.select`. Ruby does not have any sense of properties. When you see something like `attr_accessor :keywords` that is actually doing the following: def keywords @keywords end def keywords=(new_keywords) @keywords = new_keywords end So when you write `keywords` that looks for a local variable or method with that name and tries to call it. It only ends up referring to `@keywords` if you define a method similar to the one above
Sorry you hate laughing :[
Hi there! Sorry should have made that clearer in the post and will update when I got time, hopefully soon. I'm totally with you that there should be some sort of instance_exec/instance_eval there. The post is about the top level "entry point" to the DSL. In your case, your *zoo* method, it pollutes the Object name space as you use "def method_name" See what happens: def dsl_method puts "Nice dsl you got" end dsl_method # =&gt; Nice dsl you got Object.send :dsl_method # =&gt; Nice dsl you got Object.new.send :dsl_method # =&gt; Nice dsl you got edit: also, thanks for your comment :)
am I missing something? why do people link presentation slides? Am I the only one that feels they are pretty damn useless without the presentation to go with them? Aren't these posts just shameless self propagation trying to hide as content?
For this situation even Sinatra might be slow. I would look at the Cuba framework which came top in a massive comparison of ruby frameworks http://www.madebymarket.com/blog/dev/ruby-web-benchmark-report.html
This is the result of my 5 minutes hacking: https://gist.github.com/radarek/011f4bb39f9f35952274
You're right, I would add that instance variables automatically start at nil and select is a private method of nil.
Looks like there are two questions here: 1. How to fix this code to avoid the error you are getting. 2. Why this specific error is reported. Let's address each in turn. 1) To fix your code, instead of this: scanned = @keywords.select { |key| key.match(word) } write this: scanned = keywords.select { |key| key.match(word) } Explanation: @keywords is referring to an instance variable directly, whereas keywords without the @ is calling a method that you have defined. Your keywords method works as is, but you really don't need to assign to an instance variable there. I.e. your: def keywords @keywords = @entries.keys.sort end could as well be written simply as: def keywords @entries.keys.sort end (Unless you are trying to memoize (remember) the result, so that @entries.keys.sort gets executed only the first time the keywords method get called, and uses the cached result on subsequent calls. In that case @keywords ||= @entries.keys.sort is what you want.) 2) Why the "`select' called for nil:NilClass (NoMethodError)" error? That's because the @keywords instance variable you are referencing is nil. So, you are calling 'select' method on a nil object. It so happens that 'select' method is defined for all objects (including nil), but it is a private method. You can see this for yourself in irb or pry: &gt; [8] pry(main)&gt; method :select &gt; =&gt; #&lt;Method: Object(Kernel)#select&gt; 
*headsmash* That's really unexpected and dangerous behaviour. 
`Hash.new(obj)` really doesn't keep with the principle of least surprise philosophy.
I'm still surprised on how ppl already don't know this performance difference.
Yeah, I almost wonder if he was being sarcastic
very nice! hope you post this to /r/ruby soon. this is the link i wish i would have found first!
Also, as your DSL picks up state, you can transition towards using an object: class ZooDSL attr :animals def initialize @animals = [] end def zebra @animals &lt;&lt; :zebra end def giraffe @animals &lt;&lt; :giraffe end end def zoo &amp;block instance = ZooDSL.new instance.instance_eval &amp;block instance end zoo do zebra zebra giraffe end
Why would it be done like that? I can't see any benefit from a developer's point of view - is it just easier to implement?
or [Padrino](http://www.padrinorb.com/)
What is Cuba not doing that Sinatra is doing? Or what in particular does it do in a better way?
Ah, no that's obviously true. That being said, I did test "my" solution (based on a suggestion by someone else), and it does work too (and more in line with the "memory" still being there).
This post has nothing to do with Windows.. Windows uses completely different design for its processes. With that beings said, Windows has a POSIX layer and forking is possible.. (even done in cygwin and such) 
This was posted to ruby and rails a while ago. I cannot post again due to dupe detection [EDIT] Just to make it clear, this is not my work, just damn good work by someone else.
It's highly ironic that the fork model is considered a good thing in Unicorn, when it's basically the main reason Nginx came in over Apache's ground.
I'm curious as to what you'd expect `Hash.new(obj)` to do that wouldn't be as surprising as, if not more so than reusing the object. Should it clone it? Deep clone? Would it make more sense if it expected a `Class` to be passed in? But then that would assume `initialize` didn't require any parameters.
oh too bad -- i bet many like me missed it somehow the first time. great resource, so thanks again.
As described in POODR, duck type interfaces in Ruby are virtual/implied and documented through tests.
Cloud 9... Cloud based IDE. Don't have to update your ruby version on your computer sense it's all in the browser. Access your work from any computer as well. It's the best!
I use rbenv and rubymine. 
You don't want to use system ruby for development because you will run into all kinds of permission issues as soon as you try to install a gem. You're going to want to use a ruby version manager. Rbenv is what I use. At the very least, Ruby on Rails development requires a terminal and a web browser. You can use GUI text editors like textmate or sublime text. There are IDE's like RubyMine, as well. It's all user preference.
follow this and afterward, download RubyMine: http://www.moncefbelyamani.com/how-to-install-xcode-homebrew-git-rvm-ruby-on-mac/
since
Credentials: 15 year veteran developer here. If it's used on the web, I've at least dabbled in it. Ruby /rails developer for the last 5. Here's what you want. 1. Homebrew 2. Rbenv 3. Sublime. But you could try Vim or Emacs if you are brave. There are many advantages to the portability that brings. There are tons of tutorials on how to install and set these up. Finding a good one is part of your education. Google will guide you. Do NOT use the native Ruby on OSX. It was out of date the day the os shipped. If you're working as an indie, or have pet projects, getting set up with Heroku is a good idea. Have fun! 
In addition to what /u/jodm mentioned. The Ruby that came with OSX was outdated the day it shipped and is a bitch to upgrade. Use rbenv and be free. 
[I used this site for OSX and Linux, worked well for me.] (https://gorails.com/setup/osx/10.10-yosemite) The closest thing I've used to an IDE, compared to Eclipse and Visual Studio, is RubyMine. That said, I would recommend trying a text editor. My choice there is Sublime. 
Hey that's cool, I used to explicitly write all the layers out when I need a nested default hash. Very nice.
The talk: http://www.confreaks.com/videos/4798-arrrrcamp2014-unicorn-unix-magic-tricks
I use rvm + bbedit, but any text editor will do. EDIT: I recommend the free textWrangler over bbedit.
I haven't used rbenv, only rvm. I know I could use Google to see the differences, but could you tell me based on your experience the good points of rbenv? Thanks. 
And what if you're working offline, or their server is inaccessible for any other reason?
Oh my god, yes, `tmux` is a requirement for terminal-based anything. I've stopped bothering mentioning it in my posts because I just consider it essential.
Honestly the issue is "mostly" religious. However what it comes down to is that rbenv works great and "stays out of the way". RVM is a little more heavy-handed and overrides the cd and gem commands on the terminal. (That's right, with RVM, any time you type cd /to/some/path you are invoking RVM's override of cd which then passes the command to your terminal) [This link pretty well discusses the difference](http://jonathan-jackson.net/rvm-and-rbenv). The bottom line is that rbenv gives all the functionality most folks will need without overriding system commands.
Your productivity will drop precipitously that day. 
Those threads won't ever join. Each of them are stuck in that infinite loop. The join method just blocks the main thread until all children are finished, but those children will never be finished.
Can you share "your" solution or be at least a more specific ? I think radarek just hit the point, ie. dilute.rb simply won't mangle file contents if the output is not a tty (performs "zero dilution").
Just learn Ruby the language first. Focus on the programming part. Rails and other frameworks are great and will help you build applications but getting to know the language and how to program is key. Check out: tryruby.org
see http://raubarede.wordpress.com/2014/07/17/thread-pool-ith-minimum-of-code/
I really like Padrino. It's built on Sinatra and gives you _just enough_ to get started and its pretty easy to add what you want to it. I think I might actually end up preferring it to Rails eventually.
I recently started using Vim and its awesome, but don't do that. Either use Atom or Sublime Text as your editor. This will require you to learn Ruby/Rails a bit more than if you have RubyMine. Once you get the basics down you can switch to RubyMine or Vim, but there is no reason to learn a thousand things at once. Both Atom and Sublime Text have a plugin architecture so you can probably find things you want for those editors. (Sublime's is actually called Package Control which you have to first install, Atom's is built in). As far as Ruby itself goes you should be using Rbenv or RVM. I personally use rbenv but I don't really know the main difference between the two. Also I would recommend using pry instead of irb. It's a much better devving experience. Edit: Oh and use homebrew if you aren't.
Hey, I know this is an old post, but I am running into the exact same issue. What did you end up doing?
Honestly I think it's fine to go rails first (assuming you've done programming before). I learned through Hartl's tutorial and have been picking up the finer bits of Ruby afterwards. My job is in Ruby on Rails so I would say it worked out.
I won't go as far as recommending against RubyMine, but if you go that way you should take the time to understand what it does for you, particularly if you use all the Rails helpers in the IDE. Look at the files it modifies and generates and make sure you understand what it has done.
All good. A tip I could give would be to start small. Make sure to keep your expectations in check. You will not build the next Facebook tomorrow. Start with: "Print some text" "Click a Button and display a javascript alert" "Create a Form" "Update the form so submit will send the form parameters to another page" "Make the next page javascript alert with the parameters from the previous page form" Stuff like this gets you moving in the right direction. For resource, I reccomend Ruby Koans (Free) and CodeSchool (paid). I posted the resources last because they will not make you a programmer. Only doing will make it happen. Just do.
Yeah I kinda meant ruby.. I added rails because i didn't exactly what it meant. Its ruby but for building websites (very crude description)?
I made an error in my original comment, it should be a CR character, that's \^M, not \^U My method in detail: * Add a comment after every line. * That comment starts with a carriage return (\^M, in vi you can enter a literal carriage return with ctl+v ctl+m in insert mode). A CR not followed by a LF character will just return to the beginning of the line (on a terminal) and everything following the carriage return will overwrite already written characters to the existing line. Because everything between the carriage return and the normal end of line character is a comment ruby will ignore it. If the added comment is at least as long as the code before the comment that means that nothing of the original code is visible. This is also how curl prints a progress bar to the terminal.
Check out Celluloid and pools - https://github.com/celluloid/celluloid/wiki/Pools. This is what Sidekiq and Sucker Punch use under the covers for multi-threading
Ruby throws a following warning when using this technique, not seen in the demonstration: warning: encountered \r in middle of line, treated as a mere space
rvm and vim with vim-ruby and vim-rails plugin, all the IDE you need. 
I just tried it out on Mac OS X (which is what tenderlove uses), with 2.0 and 2.1, neither shows this warning, not even when I turn on warnings. I don't have 1.8 or 1.9 installed, so I couldn't test that. On linux it's the same with 1.9 or 2.1 (don't have 2.0 or 1.8 installed), no warnings, flawless execution of the code. Did you forget to put the CR *after* the comment (#)? Because if I don't do that I get the same warning. The comment is crucial, because nothing in there can change the meaning of the code
Here is my fork https://gist.github.com/joerixaop/efa82223127f8f55dd4c, I got the basic idea from the person who proposed using "0x08" (backspace), using a carriage return is simpler (but I guess it dilutes the code less, so mine is a worse solution)
So was the benchmark the authors posted with microcaching turned on? While it's a legit way to reduce the load in real-world situations, it feels a little like cheating when used in a benchmark.
JIM GAY IS SO NICE RAAAAAAAAAAWR
Store them in environment variables. Read with a gem like dotenv or figaro.
So.. ask the user to add them to environment variables? I'm not understanding. Or, have the user add it to the config then when runs for the first time sets it in the env and deletes it from the config? Wouldn't a user that logs in and does an 'env' be able to see all the system variables set?
These claims are all cool but I have a hard time not thinking all the secrecy surrounding this product is very shady. Maybe it'll make sense when it's released -- maybe it's a high-profile company with a bad rep that wants to be taken seriously -- but right now, I'm more suspicious about this product and the people involved than excited, which is a shame because it sounds awesome.
The whole point of bcrypt is that it's not reversible. If you actually need to access the credentials, that won't help. One of the better ways, as you've said, would require a prompt on startup, so at the end of the day there's a compromise to be made. Do you need actual credentials? Many services let you obtain an API key - it's valid for that user on that API but it's not actually their user password.
Yeah actually do, no API keys on some systems. Followup: wouldn't also leaking an API key allow people to issue commands on said system?
Rain puns are best puns.
Glad it was helpful!
So, I'll address this in two parts: an overview of what environment variables are, and then a description of how they're generally used. So, in [the Wikipedia article on environment variables](http://en.wikipedia.org/wiki/Environment_variable), there are some important points to note. First, every process has its own set of environment variables. The main purpose of these is to convey information from "outside the program" (i.e. from the program's environment) into the program itself. For instance, a command-line program often needs to know what type of terminal is interacting with it, so that it can correctly understand the input coming from the terminal and correctly format the output going to the terminal. Luckily, an assumption that a *command-line* application can make is that it's probably being invoked from a shell program. Now, when you connect to the OS on a terminal, the terminal will indicate its type to the OS, which will then start a shell program (bash, zsh, etc.) with an environment variable indicating the type of terminal its STDOUT/STDERR/STDIN is "hooked up" to. When you start a program with that terminal, it's actually fork()ing off a child process with a copy of its environment variables. So now the child process knows what terminal it's "hooked up" to as well! I think a point of confusion here for you (same as it was for me) is that environment variables are related to the shell itself. They're not- even though you can set them in, say, .bashrc- that's something the writers of bash implemented so you can set *bash-specific* environment variables. Additionally, when the parent process fork()s off its child process, it has the option to set environment variables for that child process as well. Hopefully this is starting to "click". Environment variables are more or less a way to transmit information about the operating *environment* from parent processes to child processes. --- So, now to explain where this comes into play for your stuff. When sysadmins are setting up systems that have automatic functions, they often create a custom user account for those functions, and then heavily restrict access to that user account. (at least, that's best practice.) When invoking programs and passing sensitive information in via environment variables, they will generally write a script owned by that user account. Within this script, they'll invoke another program with several environment variables set. For instance, I'm a web developer, and by default, Rails tests don't write to a log. However, if I set the RAILS_LOG_LEVEL environment variable to 1, it will. So, I have a little script that invokes my tests with that environment variable set (so I don't have to type it every time). The ideal case is that sysadmins can decide how best to get this sensitive information *into* the environment by the time your code is run. That way, it's not your responsibility to secure the **storage** of that information. --- Anyways, I'm rambling. Hope that helps a bit. One good example I could point you to is the [fog](https://github.com/fog/fog) gem (although it's kinda huge). Any of its options can be configured through environment variables, and it's *incredibly* widely used. Why don't you link me to your gem? Maybe I'll submit a pull request! :)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Environment variable**](https://en.wikipedia.org/wiki/Environment%20variable): [](#sfw) --- &gt; &gt;__Environment variables__ are a set of dynamic named [values](https://en.wikipedia.org/wiki/Value_(computer_science\)) that can affect the way running [processes](https://en.wikipedia.org/wiki/Computer_process) will behave on a computer. &gt;They are part of the [operating environment](https://en.wikipedia.org/wiki/Operating_environment) in which a process runs. For example, a running process can query the value of the TEMP environment variable to discover a suitable location to store [temporary files](https://en.wikipedia.org/wiki/Temporary_file), or the HOME or USERPROFILE variable to find the directory structure owned by the user running the process. &gt;They were introduced in their modern form in 1979 with [Version 7 Unix](https://en.wikipedia.org/wiki/Version_7_Unix), so are included in all [Unix](https://en.wikipedia.org/wiki/Unix) [operating system](https://en.wikipedia.org/wiki/Operating_system) flavors and variants from that point onward including [Linux](https://en.wikipedia.org/wiki/Linux) and [OS X](https://en.wikipedia.org/wiki/OS_X). From [PC DOS 2.0](https://en.wikipedia.org/wiki/PC_DOS_2.0) in 1982, all succeeding Microsoft operating systems including [Microsoft Windows](https://en.wikipedia.org/wiki/Microsoft_Windows), and [OS/2](https://en.wikipedia.org/wiki/OS/2) also have included them as a feature, although with somewhat different syntax, usage and standard variable names. &gt; --- ^Interesting: [^PATH ^\(variable)](https://en.wikipedia.org/wiki/PATH_\(variable\)) ^| [^COMSPEC](https://en.wikipedia.org/wiki/COMSPEC) ^| [^Env](https://en.wikipedia.org/wiki/Env) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cm9i5ur) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cm9i5ur)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
.....
It's kind of funny though. He only has -13 karma. Gotta give him a little credit for somehow managing that. ;) 
Yeah, API keys are still sensitive. The difference is usually just down to the fact that: * The API key will be unique and useless elsewhere * You can revoke an API key without even involving the user
Hey thanks, this feedback is really really valuable. Maybe I should point out better that the AR model just acts as a namespace here? I actually do discuss that in the following chapter a bit more. Let me see how I can make that easier to understand. Thanks so much for that!!!
Volt is another option for those who wish to stay in rubyland although it is less mature at the moment.
This is awesome information. Further inquiring: I've seen applications written in compiled language (at least to bytecode) that 'bake' in say a private key/public key, then during first startup they set encryption keys etc and use the first set to validate (chaining) the keys (or something similar) Then in a class they have something like private getCertificate(xyz) { check xyz cert = "PRIVATE KEY" return cert; } Or something similar. That's baked into code and compiled. Ruby isn't really compiled and when providing a gem or an utility gem all of my source code is available for anyone to peruse. Is the method used in those applications, 'proper' ? when talking about security that is.
Hmm. I'm not familiar with this pattern, but for what it's worth, it's not like compiling the program makes that any more secure. Even in a compiled program, that private key can be identified in the compiled code. After all, the compiled code isn't encrypted- it's just compiled. Any string literals in the source are gonna be in the compiled code as well. That said, I'm not the guy to talk to about code signing. 😅 I'm very quickly reaching the extent of my knowledge!
Well, regardless of the source, this post was pretty enlightening.
Whoever they are, they sure write like smart people. Looking forward to the unveiling, I hope it's as good as they claim.
Yep, that was the cause.
&gt; "Too long to read in the browser. Why don't people publish this stuff as epub?" *scroll down* "Oh, they did". That's a first. *Major* kudos to these people for making an ebook of their book, *and* not using PDF.
I use rubymine but I don't use the rails helpers, what they do for you is not worth the cruft IMO. 
RVM is fine but rbenv is more stable. That said I thought using the system ruby is bad because if something gets corrupted you have to do a fresh install. I don't know as I have never done it but this is just what I have been told. 
This looks cool. Do you guys need any volunteers to help run the program? 
python would be better if you don't have any programming experience 
I'd recommend going through the rubygems guide on making a gem: http://guides.rubygems.org/make-your-own-gem/ It'll walk you through the basic ideas of setting up a ruby project(it shouldn't take more than an hour). There's a lot of reasoning behind the application structure here. There's basically three driving forces behind it: the need to separate concerns within the application, the need to instruct tools like rake and rspec how to interact with the project, (EDIT:) and specifying the initialization process for the code when it's actually run in a web server context. I'll try to annotate most of the important files here: file | notes --- | --- app | stores most of the application specific logic config | Sets configurable variables in the project's dependencies and environment data. A lot of gems let you specify their behavior through configurable class variables so this is usually where you want to set those options. db | ActiveRecord uses this to keep track of the schema and migrations. public | Store public static assets served by rack. See application.rb where this is loaded to understand how it gets into rack's hands. spec | stores spec/test files .rspec | This and most of the other dotfiles store project-specific metadata for utilities to use. In this case it stores data that rspec needs to run specs for this project. .ruby-gemset | RVM's gemset specification .ruby-version | RVM's ruby version specification Gemfile | Lists the project's dependencies for rubygems to manage Gemfile.lock | Lists the specific version/commit for each gem(and their dependencies). README.md | A brief overview of the project Rakefile | Instructs rake what commands are available and where to find them. Loads application.rb and db/migrate files along with helper tasks from other gems(like ActiveRecord's rake db: tasks). application.rb | Requires pretty much all of the files necessary for the project. I would recommend reading this file in detail to understand exactly what's happening in the initialization process. config.ru | The rackup file for rack to use. environment.rb | The environment specific counterpart of application.rb. Loads stuff like the database configuration and sets configuration data like the project's root directory. I would recommend reading the Rakefile, application.rb, and environment.rb files to understand how the project's structure is actually loaded at runtime. Another good resource for understanding how Rails uses its structure is "The Rails Initialization Process": http://guides.rubyonrails.org/initialization.html Finally, basically all of this structure and configuration is done to get the code ready to be used by Rack, so it's important to understand how rack works as well: http://guides.rubyonrails.org/rails_on_rack.html As I mentioned a lot of this stuff is just for the initialization process of the project. _In general_ most library-focused gems you encounter(i.e. gems that aren't also command line utilities) won't have anything resembling all of this initialization/configuration cruft and have just "pure code".
It's the latter. It's a gem that makes issuing API commands with application X, easy. You download the gem (rubygems) then edit a config file and run it, and the gem bin will perform certain operations on your application X. Unfortunately the user has to add a username/password in the config file and the config is in clear text. 
Ha, I didn't mean to give two options so not sure which one is 'the latter', but I think I follow. I would run the config file through ERB. config_text = ERB.new(File.open(config_file_path).read).result # maybe it's yaml, I dunno hash = YAML::load config_text Now users in situations where they don't mind or prefer putting the credentials in plain text in the text file still can. But if users don't want to put their credentials in the config file directly, they can use ERB to get it from ENV. Let's say it's a YAML file... something: username: "&lt;%= ENV['SOME_API_USERNAME'] %&gt;" password: "&lt;%= ENV['SOME_API_PASSWORD'] %&gt;" I think this solution offers maximum flexibility for whatever your users want to do. If you aren't already dependent on Rails or something else that uses ERB, you might need to add ERB as a dependency to your gem. (And there might be a simpler/lighter way to add this kind of interpolation to a config file than ERB, if you don't already have ERB as a dependency. It's the pattern of allowing executable code in a config file like this, that I like, personally. It is, for instance, basically what Rails does). It's up to the users to decide how to get the values in ENV -- especially if they have a requirement of never storing them in a text file _anywhere_ (including not in a .bashrc or whatever), that could be tricky. But that's up to them. Somehow your app needs access to the actual values (not just hashed/encrypted values), there's no getting around that. Storing encrypted values when the key that can be used to decrypt them is in your app's sourcecode does not provide any real security advantage. Storing such credentials in ENV is the standard solution. You could also skip the config file (and ERB) and just say "You must provide credentials in ENV keys named X and Y". But I like the flexibility of the config file (with ERB or other interpolation), that lets them do it however it is most convenient for them, in the file, from ENV, I suppose they could even write code to get it from a database or other store if they wanted. Although I guess they could do that if you just required it to be in ENV too, write code to set it in ENV from whatever source they want. Either way, config file with interpolation; or just require it to be in certain ENV variables: is reasonable I think. 
Now, okay, it would be _secure_ if your users encrypted the values using public key crypto, and the _public key_ was baked into your source code, but the _private key_ held only by your users. But the public key for _every single user_ would need to be baked into source code. This isn't really feasible or a good design for code shared by many different entities. It is theoretically secure, but I don't think I've ever seen anything do this, at least not open source otherwise shared code. I mean, I guess you could provide a config file generator that generates a public key/private key pair, tells them to keep the private key in a safe place (or even just throws it out after using it), encrypts all the values with the private key, stores the public key in the config file itself to decrypt them.... ...I guess that would work and be secure? I haven't seen anything ever do this, but maybe this pattern is done places and I just haven't seen it. But ENV is the standard solution. 
I would recommend chruby over rbenv. rvm is a heavyweight solution -- which also does things for you that a lighter weight solution doesn't, which some people like. But if you want a lighter weight solution, I think chruby achieves what rbenv is trying to do, more successfully. I realize all these differences of opinion make it harder for the newbie trying to get started. I wish there was widespread consensus on exactly what to do (and it was the way _I_ prefer! :) ), but that's not how ruby is right now, for better and worse.
I have never heard of 'something getting corrupted' in a ruby install, system or otherwise. I think the main reason not to use the system install is simply because it tends to be an older version of ruby. Depending on what you are doing and what version it is your system has, that may or may not be a problem. 
I'm working on it. I'll have a sample on the site soon. I've got content on my blog that is _similar_ to some things in the book http://www.saturnflyer.com/blog/archives
glad you liked it! I've got other articles about Forwardable and SimpleDelegator here http://www.saturnflyer.com/blog/archives
This is a bit of a long term thing, but it'd be neat to see some stats over time alongside dumb comparisons. Like, how does the change in subscriber numbers compare to the number of losses each season, per team? How do the change during the playoffs? How do they change if a team is in the playoffs vs. a team not in the playoffs? How do they change after the entire season?
Are you using my [snoo](http://rubygems.org/gems/snoo) gem? If so, its pretty simple. require 'snoo' client = Snoo::Client.new subscribers = client.subreddit_info('ruby')['data']['subscribers'] replace ruby with whatever subreddit you want. This gem is a little rough, it was my first gem and I haven't been able to work on the rewrite i've been meaning to, but it still gets the job done nicely
That'd be fun to see.
Never heard of Ruby Encoder. You might want to look into http://www.ruby-doc.org/core-2.0/RubyVM/InstructionSequence.html and search for details about YARV. This is probably what Ruby Encoder uses but that's just a guess.
Also the [mail](http://www.rubydoc.info/gems/mail) gem is very useful for parsing emails.
Eh, Ruby Encoder sounds like snake oil: &gt; The RubyEncoder protects Ruby scripts by compiling Ruby source code into a bytecode format and this is followed by encryption. This protects your scripts from reverse engineering. Any reverse engineer should be able to load the compiled byte-code and step through it. Considering there are multiple Java and Flash de-compilers, it should be possible to de-compile any Ruby bytecode. I would focus more on the security of your application and infrastructure.
GitHub uses a slightly modified version of RubyEncoder to deploy GitHub for the enterprise. That puts the entire encoded GitHub source in the hands of its customers. I'm pretty sure it's decently secure.
We can already get things like gitlab if its source code we're after. I think it would be easier to build Github from that code than reverse engineering a binary. I'm guessing Ruby encoder is moderately secure against naive attackers but probably not a whole lot more than a plain executable. After all, most other enterprise software (ERP systems and such) and office software are just plain executables and libraries, probably with no encryption at all.
Don't confuse security with obscurity. Ruby Encode may prevent lazy attackers from reading your source code, but it will not prevent determined attackers who know their way around Ruby.
Now there's a project. 
What a horribly confusing operator.
Jesus.
@Schrockwell, is that a fact? Do you have a source/reference? I would love to look into this subject more, so I'd appreciate any pointers...
I knew about this Class but just thought of it as a low level debugging tool never thought about using it for creating compiled Ruby code. Just out of curiosity ... any idea how one would go about that?
The flip-flop operator isn't confusing, it just isn't plain English like we expect from Ruby. There's always going to be someone waving a usecase for it, so it'll never go away. I just wish it could be clearer to someone who hasn't done a two-minute, "oh, that's right" refresh within the last 24 hours.
Apparently an ArgumentError in Ruby 2.1 (not that I would have known that on my own.)
&gt; This article about it that got it wrong. OP here. Could you let me know where I went wrong in the article? Were you referring to the lack of parentheses in one of the examples? I added parentheses just now to make it less confusing - relatively ;) - because it's even more confusing without them, as you've demonstrated.
 I assumed it was because of operator precedence: irb(main):039:0&gt; true..true =&gt; true..true irb(main):040:0&gt; false..false =&gt; false..false irb(main):041:0&gt; true..false ArgumentError: bad value for range from (irb):41 from /usr/local/opt/ruby/bin/irb:11:in `&lt;main&gt;' irb(main):042:0&gt; false..true ArgumentError: bad value for range from (irb):42 from /usr/local/opt/ruby/bin/irb:11:in `&lt;main&gt;' irb(main):037:0&gt; 5==5..10==10 =&gt; true..true irb(main):038:0&gt; 5==5..10==11 ArgumentError: bad value for range from (irb):38 from /usr/local/opt/ruby/bin/irb:11:in `&lt;main&gt;' but add an 'if' in front of it and it goes berserk: irb(main):049:0&gt; 10==5..10==10 ArgumentError: bad value for range from (irb):49 from /usr/local/opt/ruby/bin/irb:11:in `&lt;main&gt;' irb(main):050:0&gt; puts 'this is not intuitive' if 10==5..10==10 =&gt; nil I'd be fucked if I know why, but I'm not a ruby programmer so I can't be bothered to look it up. 
I'm not a ruby programmer so I don't know the answer myself but I thing you should at least explain this: irb(main):049:0&gt; 10==5..10==10 ArgumentError: bad value for range from (irb):49 from /usr/local/opt/ruby/bin/irb:11:in `&lt;main&gt;' irb(main):050:0&gt; puts 'this is not intuitive' if 10==5..10==10 =&gt; nil First seems to be a regular case of operator precedence but why is it not a problem when it comes after an 'if'. I thought you had it all wrong and called it an operator when it's only a matter of precedence between the two operators `==` and `..`. But then I saw that it behaved differently in different context(above) so now I don't know anymore and your article is not helping. Edit: Also see my reply somewhere else in this post.
I mean, it's confusing because we're all new to the operator (those of us who haven't used it). Introduce it into your programming practice regularly and I think it probably starts making sense immediately when you recognize it. After reading the article, I think it could be pretty awesome. People might even discover it in my code from time to time. Not a big deal to me.
Lots of things are confusing when you are new to them. Nothing wrong with furthering our education.
There's no point learning something this obscure, cryptic, and un-googlable. You'll never be able to use it in any project that you'll expect anyone else to read or use.
&gt; You'll never be able to use it in any project that you'll expect anyone else to read or use. I don't agree.
Why's that?
[Source](https://github.com/holman/feedback/issues/345). Unfortunately they don't divulge any details that I can find.
It can do something succinctly that is often cumbersome. `Enumerable#include?` is often useful in loops: loop do if my_enumerable.include? something # do it end end However, sometimes you want that "BETWEEN x AND y" type behavior but you're not dealing with numbers, sets, arrays, etc. You can construct that kind of "before, but not after" type of conditional with the flip flop operator. The blog post includes an example with text parsing.
But you could just as easily `select` your elements first, then iterate over them. Tons of data types include methods available in `Enumerable`.
this is just something Matz copied from perl along with all the $ globals.
I've never tried. Looked around for some info but don't have anything that made me say "aha!" :-/
What's confusing about it is not that it's an operator. What's confusing is that it is an operator that is rarely used, reads exactly like the expression, `x==min..max==x` and(according to OP) only works in if, unless and ternary statements. On top of that it doesn't really add anything of value, it has to store its previous values somewhere and is hard to reason about: a = 0 for x in [1] * 4 a = a+1 if x==1..x==1 end puts a Which value does `a` have after this? 1? 2? 4? 
You could, but you could do it more succinctly with the flip flop operator. I don't buy that you shouldn't do something just because it's unpopular.
Let's say you have a multi dimension array that's [[1,2,3],[4,5,6],[7,8,9],[10,11,12]] As a table, that would look like this: 1 2 3 4 5 6 7 8 9 10 11 12 Transpose swaps the rows and columns. So that would look this: 1 4 7 10 2 5 8 11 3 6 9 12 or in array notation [[1,4,7,10],[2,5,8,11],[3,6,9,12]]
Nothing wrong with obscure. I just don't like how opaque the functionality of the loop becomes. I find it odd how there's this essentially some variable that stores the state of the flip/flop but you can't inspect it. It's instantiated within the loop but its state persists outside the iterations. I mean, a method like `cycle` has the same quality, but that's easy to parse mentally whereas `..` is a headscratcher.
Note that this also means you should only use it when all the nested arrays have the same length (it sort of works even when that isn't the case, but it's definitely not the intended use case).
Please explain.
It's definitely still a little funny to my brain. I plan on trying it out for a bit and seeing if I like it -- which is how I prefer to approach new things. Mostly, I was dismayed in this thread by how quickly the feature was dismissed. When I started ruby not too long ago (2008), it seems like there was a spirit of trying new things and being open minded. Nowadays the culture seems more focused on getting everyone to write similar looking code. I'm looking at how popular rubocop has become, style guides, etc. Maybe I'm extrapolating too much.
I have heard good things about chruby, but haven't played with it myself yet. Rbenv is working fine for me in my environment, and I haven't had a reason to go looking for another solution just yet. My dev environment is stable right now, and that's a good way for me to stay productive. :) Perhaps the next time I set up a dev machine, I'll try chruby.
Thank you everyone! This really helps!
New horribly unfair interview question!
This can be used for a simple tokenizer. Combine with recursion and you might be able to handle nested open and close tokens. I had to break out parslet for a similar problem recently and there was a pretty bad performance impact. Wondering if something quick and dirty using flip flop might be more performant and help me get rid of external dependencies for my gem. I'll give it a try. Thanks.
http://i.imgur.com/VXFYe3J.jpg
Thank you for sharing this OP. I didn't know about this operator. Now that I do, I hope I never encounter it in the wild haha
Yep, there's no reason to change if what you have is working (who likes messing with this system setup stuff that's just a pre-req to getting your work done? hardly anyone). But I think most people starting out (or switching from rvm) would be better served by chruby, but I still see the Internets mostly recommending rbenv. 
It's funny, I looked at the /r/#{team}.json return and didn't see it. I didn't think to look in /r/#{team}/about.json. Thankfully nokogiri allows you to do CSS selectors and subscribers are in a unique field. But I'm glad to know the information I want is in the about json page.
yeah, that's what they mean. 
So you actually use this in code you write? You've used it regularly, or just once? Or never, you're just arguing for the sake of argument?
~~For those who don't want to dig, it's $3600~~ PWYW. My bad.
This is so cool! Thought I'd seen everything, someone needs to organize an obfuscated ruby contest!
i would HIGHLY recommend against this. first and foremost, if you use the system ruby, you have to sudo install every gem you want to use which installs the gem to the root folder. which gives the gem root access to your computer. using chruby or rvm will keep each ruby environment siloed and allows for easy upgrading and reinstalling of the environment.
Wondering why it took it so long to get published here.
From the article: "Under the current plan, I am not going to remove flip-flop from 2.0, since we are not going to made incompatible changes anytime soon. We have to wait until 3.0. (–Matz)" So look like it will be removed in Ruby 3.0 then. I really love the Ruby philosophy of 'there are many ways to do one thing' but those artifacts from the old Perl's day should eventually be cleaned. Also, from the discussion on bugs.ruby-lang.com (#5400), another proposal is to introduce a class to do the same thing. Not sure what Matz think of that, could be a nice compromise IMO.
 This exactly how the range operator in Perl works. I remember when I first discovered it, and thought it was beautiful. Then I looked at it the next day... **EDIT** Note: The range operator in Perl (^http://perldoc.perl.org/perlop.html#Range-Operators) defaults to acting as as you would expect it to ( for(1..100) {} ), in list context. In scalar context is where you get the flip-flop magic. I suspect that's where Matz got it from? Sans context that is.
OCRA may be your best bet. What issues are you having? When you go to compile the scripts, it should list any errors.
The output is pretty large, so I pasted it into a PiratePad document: http://piratepad.net/51vkqMBYOl My script files can be found here, in case there is anything you might need to check on: https://github.com/Shwheelz/watchlist_sniper
I abandoned tmux after installing iTerm. iTerm gave me the functionality of tmux without the unnecessary baggage.
Depending on your goals, [something like this](https://groups.google.com/d/msg/comp.lang.ruby/qk0aChxZZ2M/10YzWr30wjEJ) could be a starting point for rolling your own obfuscator. Each .rb file in your source code would become a .c file, then compiled into a .so extension. Keep in mind that this can easily be subverted by anyone with knowledge of ruby internals and ability to make a custom build of ruby to get at the source code (example of modifying parse.c is provided in that email thread). Again, this may or may not be a problem for you, depending on what you are trying to achieve.
Tmux has a lot more functionality than just split screens. To name a few: 1. You can remote pair with it 1. You can kick off unit tests or other command line tasks directly from vim 1. The same config will work on OSX and Linux boxes 1. You can write scripts that load different processes in different panes I don't use iTerm, so I don't really know what unnecessary baggage you're talking about.
Interesting. So basically it's an XOR operator?
Nope, XOR is idempotent, this flips behaviour every time it is evalled (plus they don't really do similar things anyway)
Let me be clear: this is one of my less firmly-held opinions. There are plenty of arguments both ways. With that said, you can give confusing instances of pretty much any programming element that's more complicated than &lt; and &gt;. I would suggest that because your above example isn't clear that it's not a good use of the operator. To that end, I think there's a better way to implement the flip-flop operator, as in my comment above.
 begin a=b=c=(1..100).each do |num| print num, ?\r, ("Fizz" unless (a = !a) .. (a = !a)), ("Buzz" unless (b = !b) ... !((c = !c) .. (c = !c))), ?\n end rescue HeadExplodedError =&gt; _e log.fatal "Cannot clean up; excessive Perlism" raise end
This is awesome. As a ruby newbie, I wonder what the common applications are for the .transpose method??
It looks like you've never studied Object-Oriented Programming (OOP). If your instructions are to use classes, then your teacher certainly wants you composing an Object-Oriented (O-O) program. Have a look at one of these pages to get you started: https://www.google.com/search?q=oop+ruby EDIT: If you're as new as you seem to programming, I highly recommend starting out by learning about and using Test-Driven Development (TDD) before you develop bad habits! Some people use the term Behaviour-Driven Development (BDD) to emphasize that they're using TDD as it was originally intended -- but *don't use cucumber*! Have a look at: https://www.google.com/search?q=(tdd+OR+bdd)+ruby+-rails+-cucumber EDIT 2: Also... it's potentially unwise to use your real name (with a middle initial, no less!) in such a public online place like reddit! Most people use a pseudonym for a reason.
You should probably take it all out of that class. Classes are generally for encapsulation, or combining functions (methods) with commonly used variables (member variables). In your case, you don't have any member variables or methods, so it doesn't really fit the typical use for a class. Just remove the `class Question` at the top, and the `end` at the bottom. It's such a small program that it probably doesn't need to be broken up. If you wanted to, you could move some parts into separate functions, but I don't think that's really necessary. There is also room to simplify the whole thing down to less code, which makes it even less necessary to split it up. Edit: Whoops! I missed the part where you said you are required to use three classes. I don't think it requires three classes, but you gotta do what you gotta do.
I'd be perfectly happy to have no classes, but the assignment specifically states that there should be at least three classes! So I'm afraid I don't have a choice with this one. Thanks for the advice though! Can you explain to me how I could split it up into different functions? 
Ah, okay Mr. Higgins. :-P Have another look at the tutorials, because what you've got is a procedural program surrounded by the keywords 'class' and 'end', which is not a real class as classes are intended. For example, here is a *proper* Rectangle class which also calculates area: ---- class Rectangle def initialize length, width @length = length @width = width end def area @length * @width end end puts 'Length?' length_input = gets.chomp puts 'Width?' width_input = gets.chomp rectangle = Rectangle.new length_input, width_input puts "The area is #{length_input} x #{width_input} = #{rectangle.area}" ---- And here is the way you would have written it if you used the same method as the code you shared: ---- class Square puts 'Length?' length_input = gets.chomp puts 'Width?' width_input = gets.chomp puts "The area is #{length_input} x #{width_input} = #{length_input * width_input}" end ---- Better would be: ---- class Square def area length, width length * width end puts 'Length?' length_input = gets.chomp puts 'Width?' width_input = gets.chomp area = length_input * width_input puts "The area is #{length_input} x #{width_input} = #{area}" end ---- See the differences? The second example is really just a procedural program. The third example at least breaks out a reusable method/function. The first example uses an actual Rectangle class, which makes the rectangle itself reusable as well. In these examples, the advantages aren't super obvious. But imagine if you started doing all sorts of other operations, like perimeter, and rotate, and perhaps giving it a position on the screen to display, and so on. OOP helps you keep it all organized and will be smaller, cleaner, easier-to-maintain and debug.
Thanks for the detailed reply, I really do appreciate it! Looking at your comment, it makes complete sense and I understand exactly what's going on. But then when I go back to RubyMine to write my pogram in a similar way, I'm just hitting a brick wall, I have no idea what to do! I guess I just need to keep at the online tutorials until something clicks! 
I'm afraid that what you've written isn't really a class. It's simply a procedural program contained inside a class definition. If you eliminated the class definition (i.e., removed the first and last lines of the program), it would function in exactly the same way. The “purely” object-oriented way to implement this program would be to write all of the class definitions for your various objects, and then have the program execute a short loop that is responsible for retrieving and displaying questions, storing answers, printing the final results, and so on. But let's start even more simply than that. Let's start with a class that is basically a fancy data container: class Question attr_accessor :value end Now, you can instantiate a new question with ques = Question.new and then store a value in it with ques.value = "6 + 7" Then, you could store the correct/incorrect status in that value with ques.value += " CORRECT" Then store each Question in an array, and when you're done, iterate over the array with each, and print the value of the array: question_array.each { |q| puts q.value } But wait—why store the value in the same string? Why not do this? class Question attr_accessor :question, :result end Then you could do the same thing, but instead of storing the result by appending it to the value, you could store the result in ques.result, and when you display results, you can do this: question_array.each { |q| puts "#{q.question}: #{q.result}" } Why is that better? Well, then you can retrieve the question separately. You may not care about that right now, but it will be important as you refine the program, and it allows you more flexibility in terms of formatting outputs and such. As a first step, try rewriting your program to simply use the latter Question class I defined above. After that, you can move on to fancier tricks, like having the question automatically create itself when you instantiate it (by adding an initialize method and having it set up the question, rather than creating a blank question and putting the logic to initialize it in your procedural program).
Yeah, sorry, I missed the part where you said you are required to use classes. The two potential functions that stand out to me would be `ask_question` and `print_results`. The `ask_question` function would basically be everything inside the loop, and `print_results` would be everything after the loop. But, like I said, they don't really _need_ to be extracted into separate functions. Now that I know you can't submit an answer without classes, here is how I wrote it: https://gist.github.com/tomdalling/47fa98b426eb19914f3f
I agree. I've updated the gist for any future readers.
Awesome! For those of us still before Ruby version 2.0, change line 7 in lib/conway_deathmatch/shapes.rb from @@known ||= YAML.load_file(File.join(__dir__, 'data', 'shapes.yaml')) to @@known ||= YAML.load_file(File.join(File.dirname(File.realpath(__FILE__)), 'data', 'shapes.yaml'))
you can package it as a gem and have them install it that way?
jruby, package it as a jar.
The least involved approach would be to simply `#join` them all up into a string and then split it into `#chars`.
thank you!
Rolling restarts seems to be an enterprise only feature as well as multithreading support. Given that, is the open source version still up to 4x faster than Unicorn? The no rolling restarts is brutal for me. I dont think I want to swing $30/mo per server.
Yes. The open source version is still up to 4x faster than Unicorn. The performance optimizations are open source. If you are on a tight budget then maybe you are eligible for the startup discount. Phusion offers this discount as a genuine effort to help cash-strapped startups and students. The Phusion Passenger website has more info. But even the open source version has tons of stuff that others don't have. For example, tools for identifying and fixing production problems.
 array.map{|value| value &gt; 9 ? value.divmod(10) : value }.flatten This only works for values less than 100. 
yep, super simple. array.join.chars.to_a
Do you have a link to the tests that you ran so I can do my own testing on it? The only reason we would switch is for the speed increase. We have plenty of dev ops tools to solve the production problems especially before they become production problems. 
`gem install --user-install` or add that to `~/.gemrc`.
So is this just an iteration / evolution of the existing Passenger codebase? Or is it a brand-new, clean-slate design, which is what the Raptor project was originally promising? I'm a little disappointed to find out that "new kid on the block" Raptor was secretly just "old kid on the block" Passenger all along.
It is both. It reuses a large part of the Phusion Passenger 4 codebase, because there is just too much good stuff in there to throw away completely. However, the HTTP server and request handling layer was completely rewritten with optimizations and high performance in mind. Many other major architectural changes have also been made. For example, every component is now accessible through an HTTP JSON API, making introspection and scripting much easier and making everything more transparent.
Does version 5 still support Jruby ?
So does rolling restarts being Enterprise only mean that in the Open Source version, zero downtime deployment isn't possible?
You can speed it up by many, many more orders of magnitude by avoiding capybara outside of smoke tests altogether. It is not all that difficult to keep a ruby application working just fine without automated browser tests, if you practice isolation and good design. In fact, projects that drive all feature development through outside in browser tests often have some of the worst isolation I've come across -- the programmers get so excited they got a green dot to show up they skip out on the refactoring step. For teams that insist on outside-in browser based testing, it's still often a good practice to delete your browser tests after you've got a well tested object API that hides the implementation of the feature behind it. However, this is a good post for teams that are already swimming in 10+ minute test suites.
Rolling restarts don't really help if you have restarted apache.
True. Makes it unusable.
It is possible if you build it yourself. We just don't provide a convenient and robust way to do it for you. For example you can rolling restart on a server basis. Or you can write a script that kills processes every minute, as a crude way to restarting things. Or you can put two Passenger instances behind a reverse proxy and switch things around with a config change. Lots of possibilities, but like rolling restarting in Unicorn it requires effort on your part. Passenger Enterprise's value proposal lies in the fact that it takes care of those things for you, in an already efficiently and robustly implemented way, with good administration tools that take care of you when things go wrong.
Enterprise edition claims to have a concurrency and multithreading support. Does this means that the open source edition is single process? If not, what's the difference?
The open source edition is single-threaded multi-process.
Makes sense. Have a huge amount of respect for the work you've done getting these performance gains and looking forward to benchmarking it on some of my own apps to see the difference. Not sure the comparison with Unicorn is entirely fair though. One of the reasons I often use it and see a lot of other people starting off with it is that zero downtime is very simple to setup out of the box, even for small apps. It looks like with now with Passenger, rolling restarts is out of reach for simple applications (e.g. where you don't want to roll your own solution and aren't at a scale when enterprise makes sense) which means I'm guessing a lot of people will start off with Unicorn and then stick with it because it's what they know.
Try rubymotion. I'm using it for iOS, but works for OSX and AndroidOS
I would use jruby and swing... some people prefer to use swt. with jruby and swing you can build pretty decent UI.
But you can't use normal gems right?
...huh? I never tried it because of that reason.. http://www.rubymotion.com/support/ "***Can I use Ruby gems?*** Because RubyMotion implements a dialect of Ruby that is statically compiled, regular Ruby gems will not work in RubyMotion. We provide documentation which describes how to architect gems to work with RubyMotion."
What do you mean by normal gem?
How does performance compare to Passenger 4?
That's a little dramatic, don't you think? There are ways to handle rolling restarts gracefully in production with this version, they're just not built in. Is this one feature, one that you could replicate on your own, so important that you'd eschew all the other features Passenger 5 offers? 
Wow, you really write some non-idiomatic ruby, explicit returns, non-reliance on Enumerable, tab-based indentation, and so on: https://github.com/phusion/passenger/blob/master/lib/phusion_passenger/common_library.rb But i respect your work, well done! :)
This would only apply to gems that need to compile extensions or libraries, I believe. 
EDIT OF SHAME: I have failed! /user/judofyr proved I made a totally dumb mistake in the benchmark that was here. Sorry/thanks!
Is it faster when serving real rails apps? If so how much? I don't know about you guys but my rails apps spend almost all of their time waiting on I/O, database, or on Jason serialization. I would have preferred more useful features than shaving nanoseconds from the http stack.
Some sly marketing by Phusion. Quite disappointed it's just another iteration of Passenger, but I'll give it a whirl.
So you seem kind of comfortable being the kid looking for the shiny new toy.
&gt; The service does one thing Most of the time (including your example) that's not true. But breaking SRP isn't necessarily a bad thing: At one point you need to orchestrate between the different components of your app and it's better to do this at one point then scatter the responsibilities of a use-case across the system. btw. Service objects (as commonly used in the Rails world) are also know as [Transaction Scripts](http://martinfowler.com/eaaCatalog/transactionScript.html).
Very happy to see this. I remember being excited by the idea of ROM when I first came across it *nearly two years ago now*. Piotr gives every appearance of a guy who Gets Shtuff Done&amp;trade;; if anyone can pull ROM out of the ivory-tower, hobby-project aura it's gathered to itself over time, he and his team are likely our best shot. If you like the [DataMapper pattern](http://martinfowler.com/eaaCatalog/dataMapper.html) and think it'd be a great alternative to ActiveRecord (and/or if [Minimapper](https://github.com/joakimk/minimapper) doesn't float your boat for any of several reasons), at least [follow along](https://github.com/rom-rb/rom/). There's also a friendly [room on Gitter](https://gitter.im/rom-rb/chat) to lurk in and learn from until you're ready to participate.
It's really hard to define "one thing". I should have written "one thing on one level of abstraction". Thanks for the link! 
Get familiar with the ecosystem, gems, bundler, rvm/rbenv/chruby usage. Read books like POODR, Exceptional Ruby and Confident ruby so that you start writing well-designed and idiomatic ruby apps. You might be interested in jruby with your background so have a look at that. The rest largely depends on what kind of ruby programming you will be doing (web? CLI? sysadmin style stuff?) And keep in practice with the old languages, they do come in handy.
You didn't think about this before "ditching Python and Java"? I guess to answer more productively, it would be important to understand your motivation for switching and the domain you're working in....
Try the sidebar: Learning Ruby?
The rolling restarts with this software is a hack, and is more error-prone than alternatives like Unicron. $29 per month per server is more than we are currently paying per server, and their pricing scheme isn't built for small instances or Docker. If you are paying anything "per server" you would much rather scale horizontally rather than vertically.
It depends on the app. A Passenger 4 user has observed 70% performance improvement by switching to version 5: https://news.ycombinator.com/item?id=8658232. Every app is different so everyone should do their own benchmarking.
Your product is exciting, you are active everywhere, and I like your honest and detailed answers. But your pricing model doesn't work for us. And I don't want to be at your sales-teams mercy and beg for a better or cheaper option. 
No, it doesn't. The difference between explicit and implicit is far lower than the error margin (~22%).
You can get the message in the rescue block: rescue Exception =&gt; message
Can I ask you what your purpose was in building this tool, compared to considering using MiniTest::Spec? Did you have any specific idea in mind that you wanted to fulfill? Rather curious, do share.
Just to be complete: `raise` itself does not terminate the program. If the exception gets to the top without being caught (`rescue Exception =&gt; message`, where `message` is optional) the runtime receives the exception, prints it and exits.
http://robots.thoughtbot.com/rescue-standarderror-not-exception
This is basic stuff man, you should be able to google it. http://blog.rubybestpractices.com/posts/rklemme/003-The_Universe_between_begin_and_end.html 10.times do begin foo rescue =&gt; e p e.message end end
indeed, thanks!
Probably one of the best articles on service objects. I have struggled to understand this concept. Thank you! Bookmarked.
First off -- thank you for not only releasing code, but for such incredibly detailed documentation. It's rare to see that kind of effort put forth. I, too, would love to see a section looking at why one would want to use minispec instead of MiniTest::Spec. The `before_all`/`after_all` hooks are one obvious difference; are there other reasons you decided to roll your own?
Right now we don't have a sales team, we're all developers. If you negotiate, there's a large chance that I am personally involved with that. In any case, the guy you're negotiating with will be a developer first and salesperson second. How about giving it a try? The worst thing that can happen is that we both move on.
Dependency injection is fine and dandy until you end up with code like: CreateEventService.new(self, geocoding_adapter, notifications_center, method(:short_event_url), tracker).tap do |service| return service.(current_user, current_organization, params[:event], publish_event?, request.remote_ip, I18n.locale) end
Even that seems like a completely unnecessary extra chunk of code to me. You shouldn't contort your application code only to accommodate tests. Your tests are not the primary use case. All of these indirections make the code harder to read and maintain, and they're not necessary. The bit in the article "You are not able to easily provide mock implementation of GenerateToken inside your tests..." is simply untrue: it's extremely easy and common to mock a class whose use has been hard-coded in another class. The only other reason for this kind of indirection is to support swapping out those dependencies with other implementations, but in the initial implementation I'd say YAGNI and defer that to later revisions.
That's always in the back of my mind, too. Burdening the call site with implementation details for an action for a presumed improvement in testability strikes me as wrong.
OP here. I disagree. I think acceptance (end-to-end) tests are really important for ensuring application functionality. I also write isolated unit tests too, I think both are important. I think the best thing about end-to-end tests are their efficiency in terms of lines of test versus lines of code. Rewriting your isolated unit tests to refactor code doesn't provide a safety net, but end-to-end tests do. If you'd like to learn more about my hybrid process focusing on code coverage and test efficiency, here's my talk from Wicked Good Ruby Conf: https://www.youtube.com/watch?v=JDgOuKvRaf4 -Nick
The Raptor trick was in part designed to encourage some self-reflection on the part of the Ruby community about how we evaluate technology. The passenger team had to spend a huge about of time and effort to overcome our novelty bias. Rather than thanking them for showing us our cognitive bias, some seem not to be reflective at all. 
Well that certainly sounds a lot less like a personal attack than your original comment. Thanks, you made me think.
As others have said, you can resuce, but Exceptional Ruby deserves a mention (and purchase) http://exceptionalruby.com Great book
I agree with a lot of what Uncle Bob advocates for, though I often find his professional brand rather tiresome.
Almost on a regular schedule now, certain consulting firms are constantly spitting out these Java-Architect mentally articles. Ruby and RoR don't need these enterprise patterns or indirections.
It depends on the application you are developing. How can you tell that NO RoR app needs it? Maybe your app doesn't need it, but mine does.
Was looking through this tutorial, Vagrant seems to be really close to what I'm looking for: https://gorails.com/guides/using-vagrant-for-rails-development --edit-- For the cloud development, I ran across this site. https://www.nitrous.io/ Here's a small marketing video: https://www.youtube.com/watch?v=KURUreulOh4
Having so many direct dependencies may be a sign of bad design. Maybe it's time to... extract a service :)
You're right that the first comment did not convey the sentiment properly.
Ah gotcha, yeah a cloud IDE is different from what I was imagining you were talking about. I'd still seriously suggest you use Vagrant. You can probably go to vagrantboxes and find a pre-made vm you could use in 5 minutes. 
How are these different than Thor tasks?
Sounds a bit like sweeping the problem under the rug to me.
You can develop on hosted development plenty of shops do it that way, the only issue that makes me shy away from it is network latency issues because I don't always have a reliable internet connection. The root problem though is that if you can't properly setup a local dev environment then you're not really going to overcome "noob" status.
Work locally and use git. I HATE touching the production environment. 
What's your opinion on gems that implement similar behaviours like interactor?
That's a pretty fair criticism, it's definitely something that I'll continue working on. I've been using sites like codeschool and working through their tutorials, I've also been trying to work on the Lynda.com tutorials. In my mind, I have a pretty good idea of the components, the standard of integrating with Git and Heroku, but want to get to the process of writing more code/working on a project. I realize, should I actually get anywhere with development, that I'm going to have to learn how to setup a dev environment; it's just not something I want to deal with right now. Judging by the tone of many articles, I'm not the only one. 
lol, this seems to be the standard response, so it's what I'll do. 
I see no particular advantage of the described approach over encapsulating the dependency in a method. It's a matter of style.
Why? Sometimes the problem domain is just complex. If it's complex you have to write significant amount of code anyway. What you can do is to organize this code better.
I haven't used any of them. The approach I presented works for me, is simple and fast to implement. If you need some features of interactor gem then you can try it.
a simple revision array.join.chars.map(&amp;:to_i) 
Yes, this is better. Stupid of me not to transform back to integers! Thanks! 
&gt; You perceive the "Raptor trick" as some kind of grand social experiment, in which a group of engineers spent "a huge [amount] of time and effort" attempting to deceive the community into becoming excited about a new product, only to reveal that it was not a new product at all. I think that those parts are pretty much undisputed. &gt; ... You believe their intent was to force people to confront their own bias I think that was a secondary goal. The primary goal was to get some attention for Phusion 5. &gt; ... -- to whatever extent wanting the rails ecosystem to move forward and not backward can be considered a "novelty bias" -- I don't even know why we are talking about the possibility of the rails ecosystem moving backwards. Do you think it HAS moved backwards now that Raptor is gone ad Phusion Passenger 5 is here? &gt; ... and reflect on the fact that not everything new is always good. Right? New is not always better. Yeah. &gt; .... And you think that for someone to be upset about being deceived represents some kind of intellectual failure on their part?? I think that preferring a "clean-slate design" to an "iteration" is objectively an intellectual failure. You seem to believe that the more working code they threw away, the better the resulting product would be. That makes no sense. You should look at the feature set and the benchmarks and say: "is this what I was hoping for?" If yes, then be happy. If no, then list what you were hoping for that you've lost. "I was hoping that Raptor would &lt;X&gt; and Phusion Passenger 5 does not &lt;X&gt; so I'm disappointed." If you can get something with the "performance and features of Raptor" and yet the "tested code based of Phusion Passenger", that is objectively a good thing from a software engineering point of view. New products have a lot of bug. The more code they threw away, the more bugs it would have. &gt; ... You think that, if I was being appropriately "reflective," I would feel no disappointment in having been lied to? You think that the emotion of disappointment prevents any and all reflection? Your comment did not reflect reflection. You continued to convey the idea that the more novel lines of code in the product, the happier you would be. &gt; If Apple posted lots of ads claiming to be unveiling a radically-new technology product, unlike anything ever seen before, and then when the big day came it turned out that the product was merely an iPhone 7 with an upgraded processor, you're saying you don't think disappointment is an appropriate emotion to feel or express in that situation?! It would be a very normal emotion to have. But this is precisely the reflection that we should be having. Should we choose technology platforms for our professional lives as software engineers using the same emotional triggers that we do for consumer products? It would scare the hell out of me if I heard an aerospace engineer talking about his components using the same emotional consumer-talk as a smartphone customer. "I was really looking forward to using a new, cool building material but it turned out that aluminum had exactly the qualities I needed. Bummer." &gt; ... I guess that's certainly a valid opinion, but you're essentially asking people to not feel normal, healthy human emotions. You might want to consider that. Not at all: I'm asking people to reflect on them. Like I said in the first comment: I want people (including myself) to be uncomfortable with their counter-productive biases. (the bias I am probably most prone to, for the record, is the sunk cost fallacy) The way to turn this into a productive software engineering conversation is for you to explain what it is about Passenger that you are unhappy with and why you were so excited for an alternative. The passenger team is here reading: you might influence their product plan. 
Pretty cool, thanks for sharing it.
It's not complex if you can describe it in one sentence. What if you just break the words/components from that sentence into methods, and enclose them in one ore more dependent classes (pure-ruby has_one or has_many)? Otherwise, I'm all about better code organization. I hate app/services though. Put them in models, so I don't have to go all the way back to the app/ folder to find them. app/models/user/create_user_accounts.rb EDIT: I wouldn't name them CreateUserAccounts, but probably user/class_methods.rb (since create or build [with sane defaults] is kind of a class method)
Usually you try to mimic your production environment locally, but it's not a normal practice to develop in your production environment.
You can catch it, in a higher up rescue block. But you really shouldn't be using `raise`, at least not if you're following the ruby style guide. You should use `fail`
You're right about the variance but if that was the only reason for the difference, I'd expect that if I ran it enough times, it would sometimes come out with implicit faster than explicit. No matter how many times I run it or how long I let it run for, implicit is always 1.01-1.02x slower. Of course, we're talking... what, nanoseconds here? So it does't really matter.
Looks interesting. Do you have any examples of it in use? Integrated with a rails/rack request or something?
If you refer to the link above, I'm not exactly trying to develop within a production environment. Nitrous.io sells hosted development environments, but it looks like Vagrant is capable of speeding up the process greatly and could save me the $10 a month. 
Your benchmark is really not about explicit vs implicit though. The first one uses a local variable, the other doesn't. There's no difference between explicit and implicit: [4] pry(main)&gt; puts RubyVM::InstructionSequence.compile("def f; return 1 end").disasm == disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;========== 0000 trace 1 ( 1) 0002 putspecialobject 1 0004 putspecialobject 2 0006 putobject :f 0008 putiseq f 0010 opt_send_simple &lt;callinfo!mid:core#define_method, argc:3, ARGS_SKIP&gt; 0012 leave == disasm: &lt;RubyVM::InstructionSequence:f@&lt;compiled&gt;&gt;=================== 0000 trace 8 ( 1) 0002 trace 1 0004 putobject_OP_INT2FIX_O_1_C_ 0005 trace 16 0007 leave =&gt; nil [5] pry(main)&gt; puts RubyVM::InstructionSequence.compile("def f; 1 end").disasm == disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;========== 0000 trace 1 ( 1) 0002 putspecialobject 1 0004 putspecialobject 2 0006 putobject :f 0008 putiseq f 0010 opt_send_simple &lt;callinfo!mid:core#define_method, argc:3, ARGS_SKIP&gt; 0012 leave == disasm: &lt;RubyVM::InstructionSequence:f@&lt;compiled&gt;&gt;=================== 0000 trace 8 ( 1) 0002 trace 1 0004 putobject_OP_INT2FIX_O_1_C_ 0005 trace 16 0007 leave
&gt; Otherwise, I'm all about better code organization. I hate app/services though. Put them in models, so I don't have to go all the way back to the app/ folder to find them. I've heard that argument before and it turned out the guy didn't know how to properly use his editor. Use fuzzy searching in Sublime or ctags in Vim or ... There's definitely an easy way to find that file.
Yeah, it might be "one thing" depending on how you look at it. It's *one* use case after all. The Rails community seems to be pretty good at reinventing common software patterns. So, I made it a pet peeve of mine to annoy people by referencing similar (and older) concepts.
It goes against "Don't mock the object under test", so I wouldn't do it. Making methods public just for using them in tests is also not a good idea. If your project is large enough, someone will end up depending on this code and you can't change it anymore.
Middleman is great. I use it to build the site hosted on my [Raspberry Pi](http://pi.tafkas.net/)
I appreciate "older patterns", so I'm not annoyed at all. On the other hand, sometimes you need an example of certain concept which is shown exactly in your framework to show where it fits.
[**@myronmarston**](https://twitter.com/myronmarston): &gt;[2014-11-26 19:20:42 UTC](https://twitter.com/myronmarston/status/537687409295912962) &gt;Want to help maintain a well\-used gem with over 2 million downloads? VCR's in need of new maintainers: [*github.com*](https://github.com/vcr/vcr#new-maintainers-needed) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2nifw2%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
I can tell you only about my experience with Rake tasks, but the idea is the same. The task is responsible only for parsing input from command line. Then, it passes this input to a dedicated service object.
Jeez, I can't believe I goofed that up. Should have caught that. Thank you! :-)
People didn't invent patterns/abstractions just because they were bored. They had (and still have) real benefits, no matter which language or framework you use.
Well, it doesn't look too bad. Is there a reason you can't use the hosted version on http://loomio.org? Most of your issues with setting it up are system admin issues not really programmer issues. Their guide on setting it up doesn't look too bad if you are already technically inclined https://github.com/loomio/loomio/wiki/Setup-Loomio-production. They also have a support group you can ask for help https://www.loomio.org/g/C7I2YAPN/loomio-community-installing-loomio. Unfortunately I don't have the free time to just do it myself, but feel free to PM me if you have specific questions.
I personally wouldn't see this as very helpful at all. It's not like the minecraft player will have an in-game interpreter to play with either. Wouldn't it be like me printing out a a bunch of ruby docs and taping pages up on the walls and rooms of a real building, and then telling someone to learn by reading these scattered pieces of paper?
What is the non profit about?
Huh... why did you guys decide on Loomio? Doesn't seem to provide much more than any basic forum system.
&gt; It would be a very normal emotion to have. But this is precisely the reflection that we should be having. Gotcha, so you're upset that I'm having the emotions, and the experience of processing them, that you think we should be having. &gt; The way to turn this into a productive software engineering conversation is for you to explain what it is about Passenger that you are unhappy with I'm unhappy with the fact that they felt *deceit* was an appropriate method for marketing their product to me, regardless of how much of an improvement their product might be over what we're using now. &gt; You should look at the feature set and the benchmarks and say: "is this what I was hoping for?" If yes, then be happy. If no, then list what you were hoping for that you've lost. Benchmarks are not the only criteria on which software choices are made. A lot of developers, myself included, tend to have a bias toward assuming that the specs tell the whole story. It took me longer than I'm proud to admit to learn that to be successful in the professional world you have to consider the human element, and I don't just mean UI/UX design. Humans are not just very slow I/O devices. Consider that, if me and my team are going to choose to run on Passenger 5, we're going to be having a relationship with Phusion both as a company and as technical collaborators and colleagues. That kind of a relationship starts with trust -- not only trust that your team knows how to code something fast and stable, but that you're collectively going to interact with us as human beings and treat us with the honesty and good faith that you would expect us to extend to you. So, since you asked, here's a list of what I've lost: I've lost faith that the team behind this product is being fully forthright with me as a possible consumer. I've lost trust that their representatives will communicate with me honestly and truthfully. I've lost the sense that I don't have to wonder what else they might be lying to me about. Maybe because we can't *benchmark* that, some would say it shouldn't count for anything, but I disagree. &gt; The passenger team is here reading: you might influence their product plan. Unfortunately, their marketing team has basically guaranteed that I'm less interested in ever seeing what their product team has been working on. That doesn't mean I'll never try it out, or that we could never be their customers, but it does mean I'm probably going to look at other products first to see if they adequately meet my needs and are from companies I feel I can trust.
For me personally, a little prank is not sufficient to make me lose trust in a company on issues of actual product delivery. But in any case, this question of trustworthiness was not really emphasized in your original comment. You just seemed to really want a new, cool thing and be disappointed not to get it. Now that I understand it better, you are certainly entitled to your feeling.
Cheers mate! /u/changetip 1000 bits 
The Bitcoin tip for 1000 bits ($0.37) has been collected by *mordocai058*. [ChangeTip info](https://www.changetip.com/tip-online/reddit) | [ChangeTip video](https://www.youtube.com/watch?v=_AnfKpypMNw) | /r/Bitcoin
Seems just what we need. Any better suggestion?
This doesn't seem to offer any benefit that can't be obtained from existing means (online documentation, IRC channels, etc), and would in many cases I think actually be worse (organization sounds like hell, even on a modded server with an easy means of teleporting to specific places instantaneously, and the format's far from ideal).
Fantastic article. We use service objects in our large Rails app, and it's the one thing that I believe has kept us sane. There are plenty of places where service objects don't make sense and you can risk overuse. However, when you begin writing objects with many dependencies which may also have many dependencies, as is quite common with larger Rails apps, service objects can really shine. Two immediate benefits we saw were simpler, faster tests (we didn't need to include objects down the dependency tree that already had test coverage), and reusability. Huge wins all around.
Assertions should make a claim that needs to be satisfied. is(a) == b asks a question, but makes no claim about it. if a != b, then is(a) == b should be false, but that makes no claim that it's bad. It'd be like if I asked someone, "Is it raining outside?", and when they answer, I flip a table.
Interesting, thanks for the explanation!:)
You should prepare yourself that Ruby is more, not less complicated than Java. Are you comfortable with ant/ivy/maven/gradle? Junit/mokito/...? Apache commons? Forget all that, ruby has its own versions of that, and you will have to learn all of that. Any specific reason to drop all your two years experience and start everyhing over?
I had the same thought. I don't get what problem this gem solves other than the author doesn't like minitest assertions. Why not just use the `minitest/spec` assertions like `must_raise` and `wont_be_nil`?
Isn't this article talking about the command pattern, not service objects?
The abuse of the term "service objects" is a big head scratcher to me. It's like we can't accept that our domain model consist of a objects that make use of a heterogeneous mix of patterns. We are so stuck on `app/models` being ActiveRecord objects that we need a new drawer -- `app/services`. It's a domain object. Ususally following the command pattern.
Lol this conversation is so passive aggressive.
I'm swapping to ruby because I was talking to one of my friends and we were talking about flaws in programming languages, he is a long time ruby lover from the get go he used ruby and just doesn't get frustrated at all when ever he is programming, but me and all my team and workmates it always seems to be yelling and screaming at the screen for hours on end. So really it's me being sick of getting angry at python and java! And I like learning new things so it's really a win win. And yes I'm comfortable with ant,iviy and maven.
&gt; Loomio. Why is there this increasing trend to see travis-ci badges on every Github repository, which only advertise that "build failed".
I don't know, either. I'm rather fond of minitest/spec—it's simple and clean.
Find, but not discover. You have to know that it exists in order to use fuzzy-search. In either case, app/services is just poor organization. You should put related things together.
It seems to me that these 'service objects' are just a way to bring scripting back into an OO-language. But it brings with it all the problems of duplication that the OO-class system is mean to alleviate. Why not just have the task parse the input and pass it to a method that does what you want it to do, User.create? I know that if I stumbled upon one of these, I would immediately start breaking them into collections of smaller pieces. `CreateUserAccount` is really a class method, not a class.
Services definitely belong in the services folder. How can you not find it via fuzzy search? If you have `CreateUserAccount.new` somewhere just fuzzy find for create_user_account and you're good to go.
1. Create a new array of length max+1 where every value is true 2. Set the first two values (0,1) to false 3. `2..max` block: For the values 2 to max (100) loop through (value stored in "i") 3a. if the value of the sieve at position "i" is currently true 3b. start at double the value and loop through by adding "i" until you hit max (all multiples of the number of current focus: "i", that are less than max) and mark those as false 4. for each value in the sieve, loop through and "select" the value and the index of the value within the sieve. That is what the block "|prime, number|" is doing, where prime is the value at that index, and number is the index itself. If the value is true then print the index. In a more meta sense you creating an array where each position in the array represents a number between 0 and a 100. Initially all are true, then we move through the array and mark any number that is a multiple of a currently true number as false (but not the number itself). Finally, we simply print any index, therefore number, whose value is still true. Also I used a lot of "for" loop terminology here that doesn't really carry over to Ruby, but might help understanding if you have experience in other languages where for loops are common.
What if a service object is a class that implements command pattern?
Check out Avdi Grimm's [Confident Ruby talk](http://youtu.be/T8J0j2xJFgQ) where he covers this subject among other things. There's also [the book](http://www.confidentruby.com/) that was inspired by that talk. To answer your question, neither one is encouraged. Duck typing means you don't ask these questions, you tell the object what you want done.
I've dealt with the same issue, and basically retorted to manually watching my tests execute to find places where the expectation and finder need to be negated. Going forward, I will definitely be using the capybara-slow_finder_errors gem to find them instead.
Well, it kind of depends on what purpose. If you're trying to write a polymorphic method, I can see using respond_to? or is_a? in order to determine what to do with a passed object. I'd probably use is_a? if you're expecting only “primitive” types (i.e., types included in the core library) to be passed, and respond_to? if you're expecting custom objects. And if you do use is_a?, make sure to test for the broadest class of object possible (e.g., test for Numeric rather than Fixnum). On the other hand, if you're using it for validation of incoming data (as in, you expect it all to be of a certain type, and need to deal with cases where it's not), you're probably better off using exception handling.
Nice article. I found the last sentence a little off-putting (unless it was meant as a compliment): &gt; It never ceases to amaze me how easy it is to break Ruby programs. Ruby works this way by design. Without static compilation, the only way to see problems with your code is to run it. And when you do, you want it to fail fast, fix the code, and run it again. If it was not "easy to break Ruby programs", bugs would be more difficult to detect and the software would fail in more subtle ways downstream. Just think about JavaScript's implicit conversion between strings and numbers for example. I could say that it never ceases to amaze me how difficult it is to break JavaScript programs (and I don't mean it as a compliment).
I really don't like the Hash-based API. It just fucks with my sense of ruby aesthetics. 
 title.sub! /as Ruby are$/, "as Ruby"
We do. We have user records, which have a number of children (there are dozens and dozens of types). When I flag records as suspended, or deactivated it needs to cascade to its children. It's easier and more concise to see if the record responds to suspension or deactivation instead of defining it in every possible child object. In this way, I only define it in the objects that it makes sense to define it in. I think there are definitely use cases, and there's no "one size fits all" answer.
"Practical Object Oriented Design with Ruby", "Confident Ruby" and "Exceptional Ruby" should be required reading for everyone who wants to code ruby well.
I think you didn't understand. Why would I search for create_user_account presuming I have no idea that it exists because I didn't write it. It's most definitely not conventional. CreateUser is related to User. They should be found together.
As Rails is currently designed it organizes files by its "kind" and not by the bounded context they actually belong to. Usually I would agree to put everything related to profiles into a `profiles` bounded context (which then has its own models which it doesn't share with other bounded contexts), but as you mentioned `app/models` I assumed you talked about the structure of a default Rails application.
&gt; They invent those patterns to work around problems with the language. This might be true for some of the GoF design patterns (not for many, though), but it's not true for enterprise patterns (which we talk about here). E.g. Gateways serve a specific purpose which is independent of the language used - heck, it's even useful in functional languages: Encapsulate the external service. You should read "Patterns of Enterprise Application Architecture", you'll be amazed at how many of these made it into Rails... &gt; Ruby doesn't have these problems. Except for meta programming Ruby is very close to Java's or C#'s semantics. So, you suggest to replace patterns with meta programming? &gt; In Ruby, scripts should be broken into methods so that code can be re-used, instead of duplicated. That's exactly what OP did here. Btw. please define "scripts" and "objects", your rant about these made no sense to me.
It's true, but they do that because they are high level differentiations. Oftentimes in teams the dev assigned to a story is going to be working on only one of these sections at a time. That isn't the case in these examples, because they are all under the domain of the model. (Eg model = data/database/data-api, controller = interaction/http/integration, and view = designer/ux)
Does nokogiri fall into that category?
What, exactly, is failing? glob returns an array, so no issues there... 
OP, this was just at the top of /r/ruby a week ago.
How do you feel about `assert(a)==b` and `check(a)==b` notation instead?
You could find out what class/module it's called from with method(:system).owner
That returns `Kernel`, which brings me back to where I am now. What now?
Thank you for the explanation! Very helpful.
Thanks! I think I get it now.
In your script, do: p dirs You will see that it is an array, and you will see that all directory paths in that array are relative paths, not absolute. That is what your problem most likely is, as you are changing to a different directory, then try to use those relative paths. You can convert relative to absolute paths like this: dirs.map{|s| File.expand_path(s)} Do that between your Dir.glob and your Dir.chdir to another directory.
BL? Is NO am acronym too?
I have a challenge. Find me one popular api-integration gem that uses 'Gateways' - in Rails we use 'clients'. Why because communication with an API is state-ful. I definitely see what that other user was saying about Java-isms. Gateways are an interesting metaphor that fails fantastically in practical use. In Ruby we communicate to APIs using plain-old methods, because we can. A recent project we had the task of tearing a large number of gateways out and replacing them with clients which is a more accurate metaphor. These patterns are incredibly dated, and bloated. I'd love to read that book, but it sounds more like a historical documentary. Also copying a 'script' (eg an often large chunk of procedural code) into another file is not fixing the problem or making it reusable. It is sweeping the semantic problem with scrips under a rug. There is literally no need for a CreateUserAccount class when you can override UserAccount.create to do anything you want. It's not meta-programming. And meta-programming is not relevant at all to the discussion. Name your classes as Nouns. It's almost like people who code like this consider programming like building a building instead of an act of communication, which is an indicator of a much bigger problem in an Agile environment where things change and these patterns fall over with rigidity. Anyway, find me a popular gem that uses gateways, and get back to me.
Can anyone provide their experience using it? Really curious to know how well this works.
BusinessLogic NO is a NOO!!!
I guess it strongly depends on what goes wrong. In general - I would rescue the exception as soons in the call chain as I can handle it. Sometimes it may be inside service itself and sometimes in the controller. If you are asking about rollback strategies - I have no generic solution for them.
I use it every time I have to write a unit test on a new class. Every other day in the company I work for. It all depends on the complexity of your code. The worst thing it can give to you is a nice scaffold of test file, with all public methods and arguments pre-filled. I'm thinking of implementing an option just to scaffold a model spec without even trying to use arguments prediction. It is a task that it can do with absolute proficiency. On the simpler classes, it usually generates you a template that has most of the spec done. You just tweak it by hand and decide which methods are most important. For those, you might probably have to test multiple multiple argument combinations. There are many ways in which this tool can go, but at the moment its heading to a place, where you leave all the monkey-job to the tool and do all the additional testing by hand. I think it shines the most in legacy environments where there are no tests at all and writing them by hand would cost too much. Tests that at least do smoke testing are much better than no tests at all.
Thanks for your input - I get your point and I think it is valid. It all comes down to your development style. I personally stopped writing in TDD because that I do not always know what API is best for the class until the prototype is ready. Then I start writing integration tests to ensure that I won't break anything major. Only then, I start writing unit tests and refactor along the way. This is where automatic generation helps. It does few things: 1. Writes me a scaffold of public class API so that I don't have to copy all the RSpec blocks while changing method names all the time. 2. Generates a smoke test. I instantly see which methods break with common values or when tested individualy. 3. It inlines me the args on which the method depends. After that I start writing additional tests which are not smoke testing anymore. Those are specific situations where I expect my code to break. Those are the tests that you are talking about and I agree that those are the most important ones. But everytime you have to write those from scratch in a new *_spec file, you have to do all the scaffolding by hand and even those few minutes of your precious life could be wasted on more important things. Thanks again for checking it out. 
Sorry, I'm a little confused, why do you need to test a system method? The call should not fail and you are testing something you have no control over. Sorry if I'm missing the context. I think the correct way would be to stub the wrapper you're using for the system call and make sure the right parameters are being passed.
I'm not testing the system method. In my script I'm testing the caller method by 1. Ensuring the system method is called 1. Ensuring the system method is called with the right args while not actually calling the system method. Testing the system method would be a hell of a lot more complex, I'm just going to assume it works, which I think is very reasonable.
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: http://www.reddit.com/r/Serendipity/comments/2nlm3f/using_respond_to_and_is_a_xpost_from_rruby/
I'm not completely clear what this does, actually. For example, I'm not sure what it means for Bookshelf with ID 1 to be permitted. Permitted where or to do what? I'm also not sure how it interacts with the user objects, because I didn't see a reference to anything like that. It seems like the permissions here are properties of the resources themselves, instead of properties of the relationship between the resources and users. Normally in a permissions system, I'd want the api to look something like: &gt; current_user.can? :browse, Bookshelf Or you could add a little magic like &gt; current_user.can_browse? Bookshelf But that may not apply to your library, I can't tell.
Ok that's what I was thinking you should be doing. That's why I'm confused as to why you care to stub kernel. I think you should use "expect" and "receive().with" on the wrapper. That way you can test that the wrapper is called with the right parameters and the correct number of times. No need to even care about the kernel at that point. I hope that helps! 
You're not understanding the problem- I was unable to identify which object to pass to expect. :)
https://github.com/octokit/octokit.rb (it doesn't "use" it, it is a [Gateway](http://martinfowler.com/eaaCatalog/gateway.html). Your application would "use" it) I don't understand your distinction between client and gateway. What's the difference? Usually a gateway uses a (e.g. HTTP) client to access the external resource. Try to be as concrete as possible (I want to see code), because I believe our definitions of most things differ quite a bit. I also don't get what you mean by "plain-old methods" - what else would you use in e.g. Java? I'm also puzzled about how using `UserAccount.create` instead of `CreateUserAccount#call` would be any different in terms of maintainability of an application.
Qtruby? (Qtbindings?) Be prepared - ui stuff like this is usually a mess
https://github.com/octokit/octokit.rb/tree/master/lib/octokit/client It is a client object. A gateway, as you already mentioned is a functional (stateless) translation layer between the programming language and the api interface. An interface nobody needs, especially with modern RESTful/JSON APIs. Even in a functional language, I would implement these as monads, because I have session state, authentication, and caching to worry about when interacting with a third party service. It is connotative that the word gateway is merely something that a message passes through, like a filter - but that is a poor metaphor. These services need to be *modeled*, like you would with a database, not merely 'translated' and manipulated as masses of string data. I don't see any app/gateways folder in octokit. I do however see Octokit::Organization which is a model for an Github Organization, for example. &gt; using UserAccount.create instead of CreateUserAccount#call would be any different I think the answer here is pretty obvious. It's a matter of convention and semantics. It goes back to working on teams. If you want to make a coherent application, every should be speaking the same language. Rails has conventions, and these 'enterprise' dinosaurs fly in the face of sensible grammar. Can you honestly say you don't see how CreateUserAccount.call is completely outside the realm of readable code? What about FetchAndExportAllUsersAsCSV.call - versus say User.all.to_csv Anyway, I'm bored of this conversation. I won't be responding any further.
why is that?
You can add the `./` before the Dir.glob, it'll return the directories with `./` before it. &gt;&gt; Dir.glob("./*/") =&gt; ["./Applications/", "./Desktop/", "./Documents/", "./Downloads/", "./Dropbox/", "./Library/", "./Movies/", "./Music/", "./Pictures/", "./Public/", "./src/"]
Because `CreateUser` is a class, and you should probably only have one class per file?
Why do you have to understand how it's implemented to use it?
 [1, 18, 12, 3, 4].flat_map { |v| v.divmod(10).select(&amp;:nonzero?) } #=&gt; [1, 1, 8, 1, 2, 3, 4] 
This shouldn't be downvoted, it's the best solution here so far, but perhaps you could use `flat_map` insted of `map { }.flatten`
&gt; I made stupid mistake. I thought you call your method from global scope, but you don't. You call your method from "it do ... end" context. In this context "self" referes to instance of class which inherits from RSpec::Core::ExampleGroup. *clap* *clap* well done :)
This is a decent way to do it
I guess he meant to say something like "building *control flow* through exception handling is a no go". At least that is a common position.
Thanks for the insight. We started thinking about how deep should the method arg should be tracked to provide information of value. At the version of 0.1.3 it does not follow more than one level. SO: When were predicting a value for 'shop' we used to do this: shop = method_to_get_shop def method_to_get_shop another_method end def another_method "H&amp;M" end And we would track it is "H&amp;M". I dropped it cause it does usually provide something untrackable by developer. It currently returns 'Missing "method_to_get_shop"'. But thats not optimal and not what I think it can handle. In the future, it might handle clever method following techniques, but we need to implement a stack before that to not get into infinite loops, because it is currently not tracked.
I think this problem deserves it's own binstubs - spec/bin and add it to the PATH during test execution, so you can stub out executables. Write them to exit with 0 if the parameters are valid. Or better, set them up as simulators that behave like the real thing, but without any side effects.
Yeah, its a balance really. But this is a particular grim example. Services really makes sense, sometimes they just grow and needs to be helped :-)
That's a nice idea. Thanks! :)
Before everyone chimes in with "This could be way simpler by....", I probably agree with you in most cases. In the case where we used this strategy, however, simpler solutions just didn't give us the flexibility we needed.
Ruby changes **FAST.** Focus on what version of Ruby the book utilizes and buy it based on that. I mean, you can use it for a lot of things but be keenly aware that a lot of things will be different when you actually write code or go through exercises. You can still get the general gist of Ruby, especially with a programmer background.
You're taking a collection of one type and returning a collection of another type. This is a map operation, so use that instead.
 def create_array(json) json["thingies"].map do |thingy| x = ObjectName.new x.id = ... x.desc = .... ........ code ...... x end end 
ObjectName should probably have a method that consumes a thingy so your map has a smaller body. 
Yeah, I agree with this. There were definitely big new features in 2.0, but a well-written book from 1.8 or so wouldn't steer you wrong or anything.
&gt; Now that I understand it better, you are certainly entitled to your feeling. Pro tip: People are entitled to their feelings regardless of *your* understanding of them.
 def create_array(json) json["thingies"].map do |thingy| ObjectName.new.tap do |x| x.id = ... x.desc = .... ........ code ...... end end end 
&gt;Ruby changes FAST. I'm not really sure about that. * Ruby 0.95: December 1995 * Ruby 1.0: December 1996 * Ruby 1.2: December 1998 * Ruby 1.4: August 1999 * Ruby 1.6: September 2000 * Ruby 1.8: August 2003 * Ruby 1.9: December 2007 * Ruby 2.0: February 2013 * Ruby 2.1: December 2013 Seems like some fairly significant gaps between some versions.
An additional remark regarding the method name: neither 'create' nor 'array' feel like good parts of a method name to me. I'd rather call it after the things it is returning, not /how/ it does it (create) nor /what kind/ of thing it returns (array). Assuming the things it is returning are called Thingy, then either like that: def thingies(json) json["thingies"].map do |thingy| Thingy.new ... end end or even better, getting slightly offtopic, if the method is part of a class that has internal access to its json: class Something def initialize(json) @json = json end def thingies @json["thingies"].map do |thingy| Thingy.new ... end end end 
This. 
You got me there! I started at 2.0 and had no idea it reached back to 1995 so I'm clearly ignorant.
Learn Ruby but don't ditch Python and Java. There are Libraries in Python that have no equivalent in Ruby(SciPy for one). Also, look into Jruby: Ruby on the JVM which gives you easy access to native threads and a vast array of Java libraries. Ruby is a great language but you may need to exercise your Python and Java chops on some project in the future. Keep your options open. I recommend starting with "Design Patterns in Ruby" by Russ Olsen. I think that it's a great way to introduce yourself to Ruby and Design Patterns at once and in an enjoyable way. Follow that with POODR by Sandi Metz. You can refer back to Olsen when Metz introduces some practical uses of design patterns. All of these languages are Object Oriented and Sandi Metz is the first author I know of to write a book explaining the basics of this approach in plain language. So her lessons also apply to Java, Python and Javascript as well. Good luck.
A constructor?
I would usually expect something like: class Thingy def self.create_from_json json json["thingies"].inject([]) {|arr, thingy_hash| new thingy_hash } end end Even that leaves a lot to be desired, though. (For example, that method isn't really accepting json.) *edit: formatting
I love tap. Maybe too much...
I actually hate variable assignment sometimes in blocks, so I have a similar function Object#as, i.e. class Object; def as(&amp;block); yield self; end; end ...which I use as (generally in iterators)... Nokogiri.parse(HTTParty.get("http://www.reddit.com")).as { |html_parse| html_parse.at("#header-img").content } #=&gt; "reddit.com"
Well, I suppose I ought to. :) Your understanding of those two lines is correct. valid = Hash[words.zip [1].cycle] The goal of this line is to create a faster means by which to determine if a given string constitutes a word. I could have just done `words.include?(string)`, but that's an O(n) approach; it would iterate through as many elements of the array as necessary to find, or fail to find, the given `string`. Since we're going to be doing this many, many times, it makes sense to optimize it. Hash table lookups are (essentially) O(1), so we just need a table whose keys are the valid words; the values are irrelevant, so long as they're not `false` or `nil`. `Array#cycle(n)` creates an `Enumerator` whose values are those of the calling object repeated `n` times, or indefinitely if no `n` is provided. Thus, `[1].cycle` creates an "infinite" array of 1s. `Array#zip(other)` creates "pairs" from the constituents like so: pairs = [:one, :two].zip [1, 2] #=&gt; [[:one, 1], [:two, 2]] `Hash#[]` is a convenience method for creating Hashes from just this sort of collection of pairs: Hash[pairs] #=&gt; {:one=&gt;1, :two=&gt;2} Thus, `valid = Hash[words.zip [1].cycle]` gives us: {"aa"=&gt;1, "aah"=&gt;1, "aahed"=&gt;1, ...} Again, only the keys are of interest in this case. puts long.max_by { |w| ... } As per the challenge description, we want to output the word which contains the most inner words, so we're only interested in *the* element in `long` (those `words` of length greater than 12) which returns the greatest value when supplied to some procedure; this is `Array#max_by`'s *raison d'être*. n = 0 (0..w.size - 2).each do |s| (2..w.size - s).each do |e| n += 1 if valid[w[s, e]] end end n We start out with zero discovered inner words, naturally enough. Then, we iterate over every subsequence of length 2 or greater and increment the count if that subsequence is one of the keys in our `valid` Hash (that is, a valid word). Finally, we "yield" `n` to the `#max_by` block so that it can determine the winner. I named them `s` and `e` for "start" and "end", but the latter is a misnomer used for the sake of symmetry. The outer loop's purpose is fairly clear; we want to start checking the subsequences for each position in the string (except the last, since it couldn't, by virtue of being the end of the string, result in a subsequence of length 2 or greater. The inner loop is where the subsequences are actually constructed and validated. `String#[index, length]` returns the substring of the provided length beginning at the supplied index. Thus, "bacon"[2, 3] is "con". In this case, `index` is just whatever `s` happens to be. `length` takes on all the values necessary to walk the whole string. As an example, when `w` is "rubynew", `s` needs to receive the values 0 through 5 (`0..w.size - 2`). When `s` is, say, 3, we're checking the subsequences starting at the 'y'. The subsequences in that case are "yn", "yne", and "ynew", so `e` will need to receive the values 2 through 4 (`2..w.size - s` = `2..7 - 3`).
I'd tap that.
You can use `#inject` def create_array(json) json["thingies"].inject([]) do |arr, thingy| x = ObjectName.new x.id = ... x.desc = .... ........ code ...... arr &lt;&lt; x arr end end `#inject` is probably more idiomatic ruby than having an array scoped outside the iterating function. For more uses on inject, see [this article](http://blog.jayfields.com/2008/03/ruby-inject.html)
If you're passing an empty array to `#inject/reduce` you may as well use `#map`. edit: unless you're worried about `nil` values.
Hm, yeah, good point.
Hmm, I don't like how `message` and `list` magically point back to the elements with those ids. What if you wanted to use a variable of some name, but there was an element with that id already that you were unaware of?
Yeah, that was unexpected magic for me too. I'm not sure if it's intended or not. I found it by accident then simply kept it in the example.
Looking at the `Native` object now, I guess it comes from the fact that it wraps the desired element, in this case `window`. Seems that browsers expose elements with ids as properties of `window`, and the wrapped window object is implicit in your `do` block, therefore `window.message` and `window.list` resolve back to the DOM objects. Pretty crazy though that *that* works, but other names don't try to map back, e.g. `adjectives` or `li`?! I'd much prefer it being more explicit to get ahold of a dom node. 
It's used to expand a single instance of a class. So if you wanted to add a method to a single Array object, rather than every Array, you could use: x = [] class &lt;&lt; x def foo do_something end end In this case, it actually adds an accessor to the Presentation class itself, rather than any given instance of Presentation. So you could set a default font by calling Presentation.default_font=, and then any subsequently instantiated Presentation objects will choose that font as their default. 
I agree. Here's an updated example. http://jsfiddle.net/m5351vmu/4/
honest question, why do you like it so much? It always read as unclear to me.
Think of it as a context switch. Normally, calling `attr_accessor` inside a class definition will make it so that **objects** of that class will have the specified accessor method (e.g. `Presentation.new.default_font`). Putting `attr_accessor` into a `class &lt;&lt; self` construct switches the definition context to the **class** itself, making it so that the class itself will have the specified accessor method (e.g. `Presentation.default_font`).
The root cause of your issue is elsewhere in your code, but it's basically to do with how Ruby handles file streams. Being more explicit (`$stdin.gets`) will solve this particular case, and is generally a good idea anyway.
Those 3 lines are my entire program, which makes me even more confused as to what the error could be. I've just started with Ruby today actually, so I'm not entirely sure what threeifbywhiskey meant exactly. So it's likely that the problem isn't my code but something in the background? I'm using the pre-installed version of Ruby if that makes any difference, I didn't install anything whatsoever. 
Strange indeed. Can you show how you are running the program? Are you doing this in Terminal? If so, what is the complete command you are typing into the Terminal? What threeifbywhiskey means is you are using bare-word `gets`, which is actually `Kernel#gets`, and is a bit too magic in that how it works depends on whether there are any arguments passed to the script on the command line (see [this stackoverflow question](http://stackoverflow.com/questions/12041492/ruby-whats-the-difference-between-stdin-gets-and-gets-chomp)). He is suggesting that you replace the bare-word `gets` in your script with `$stdin.gets` or `STDIN.gets`, and see if that makes a difference.
I'm writing the code Sublime Text, I also tried it in TextMate and TextWrangler. And then once I "build" it I get that error. And should I be replacing all of "gets.chomp" with either "$stdin.gets" or "STDIN.gets" or should I be doing something like this for example, "STDIN.gets.chomp"? Because I have tried all of those and none of them worked. When I write "gets.chomp" I get that error, but once I replace it with "$stdin.gets" or "STDIN.gets" I don't get any errors, except I also don't get an option to input the name... Since this came pre-installed on my Mac, do you think restoring my OS could fix it? Because I've also been using the pre-installed Python and had issues with it and that's actually why I switched to Ruby, I was learning Python for about a month but I was getting so frustrated with all the unknown errors... So I switched to Ruby but the same sort of stuff is happening now... 
Not all gems are pushed to a public repo and/or are linked to the source. However, I do agree that if a readme file is available then it should be presented as a tab. This, along with a license and change log.
I would wager this is something that differs based on the version of ruby you are running. You can either accept it or dive a bit deeper and install [homebrew](http://brew.sh/) and [rbenv](https://github.com/sstephenson/rbenv) so that you can easily switch to a more recent ruby. As it stands the explanations given here regarding STDIN make sense. 
I thought all the gems are public. This is why you can simply download them and use it, or checkout their source code..
&gt; I'm writing the code Sublime Text (...) then once I "build" it I get that error. This is your problem. Sublime Text doesn't actually have a terminal in it; when you build in ST, it runs the program to completion in the background, saves up all of the output, and at completion puts the entire output into a text file that gets its own little panel at the bottom. Because of this there is no way to have the program ask for input from the standard input stream -- which is what `gets` attempts to do. Basically, you can't run a program that asks for input in ST. Write it in ST, save it, and then run it from the terminal. Assuming that Mac OS works the same way as Windows, you could also add the the additional line `gets` to the very end of your program, save it somewhere, and then doubleclick it in Finder to run it. The `gets` I suggest is irrelevant to the fact that you're trying to run `gets` yourself; it's just there so that at the end of the program, it pauses and waits for more input, rather than closing the window so quickly you can't see what happened. 
Read about the eigenclass or metaclass: http://madebydna.com/all/code/2011/06/24/eigenclasses-demystified.html 
Can't you just rename .gem to .zip and unzip for the source? It's worked for me whenever I've tried.
use `to_i`.
Yep, you can. But even then, visible source does not imply open source.
Why didn't you try googling? there's like a billion answers on this exact question, and they're all very good.
Hey, thanks for taking the time to explain the program. Still scratching my head over this as I am very new to programming in general. I'm going to revisit this in the future.
I've known about this in webkit for a while, but I've never been able to find out about the compatibility... Does this work the same cross-browser?
Sweet man. I tried. Find me some on this exact question and I'll be forever grateful. I found a lot similar but none exact. 
1. Try to name methods after what they do, this also helps you to know when one method does too many things. 2. Don't do too much in each methods, it will make the code harder to test and harder to understand (because you have to read every single line to figure out what a piece of code does) 3. Usually it is preferable to combine logicand data, in other words to have methods on objects instead of having loose methods that takes objects as input, Not perfect in any way but: def thingies_to_foos(thingies) thingies.map do |thingy| build_object(thingy) end end def foo_from_thingie(thingy) Foo.new.tap do |foo| foo.id = thingy['id'] foo.desc = thingy['desc'] ........ code ...... end end foos = thingies_to_foos(json["thingies"])
I think it's a problem with "rake". I just forget what to type into the command prompt, when I'm in the dir for my spec file.
Really ? this was second on the list on the first page, and it's a fine explanation: http://stackoverflow.com/questions/2505067/class-self-idiom-in-ruby
Hmm seems less than exact to me. One in a billion. 
bundle exec rspec spec/program_spec.rb
Hey so I have way more information for you. I have a main folder called "main", which contains two folders: "spec" and "lib". In the lib folder, I have a lib.rb file, and in the spec folder, I have a spec.rb file that contains " require 'lib.rb' " in it. When I try to run the spec.rb file in "command prompt with Ruby," it keeps giving me a LoadError message, telling me it could not load the file. I have tried using require_relative, and I'm wondering what's going on here? Should I have installed a gem prior to this? When I straight up type in "bundle exec rspec spec/spec.rb" it tells me it couldn't locate Gem file.
What? It's perfectly clear, and certainly no less clear than any of the answers you've received on this thread.
this makes me wish Andrea Singh was still using social media and writing blog posts :c
First, use require 'lib' not require 'lib.rb' Also, lib.rb is maybe not an ideal, descriptive name. Rather name it after whatever it actually contains, e.g. if it defines a Person class, call it 'person.rb'. require searches for the name you specified, eg. 'person', below every directory that is in the load path. You can print the current value of your load path by doing something like p $LOAD_PATH Maybe you lib directory is not part of it yet. You can add it by doing something like $LOAD_PATH &lt;&lt; 'lib' before calling require. But I think rspec adds it automatically, so when you run your spec file not with ruby but with the rspec executable, it might just work: rspec spec/spec.rb (again, maybe rename spec.rb to something more meaningful, such as person_spec.rb)
Check out these awesome ascii-cinema-clips for a good intro to rspec: http://rspec.github.io/
Not anymore, you can use the `singleton_class` method :)
Hm... I'm a little confused. I'm not sure if you know python as well but when I was working with python I was perfectly able to ask for user input, why is it so different in Ruby? But I tried to run the program in the terminal like you said, I just saved the file then drag/dropped it into the terminal and ran it, but it said "Permission denied"? EDIT: I tried it in TextWrangler again, because I just remembered that it has an option to "run in terminal" so I tried that and it worked perfect! I'm still really confused as to why it wasn't working before but i'm sure I'll learn all that once I have a better understanding of Ruby... Now I'm starting to wonder if this is why I was also getting all of my weird Python errors too... I'm just going to stick with TextWrangler from now on.
Nope that is exactly what you should be doing. A lot of people are awful at creating good OO.
Thank you very much. It turns out that I can run it using rspec spec/spec.rb but I am very unfamiliar with LOAD_PATH What does that mean? Is it in the cinema clips that you posted just after this as well?
You are the fucking boss. Thank you so much. First of all, it works to use rspec spec/spec.rb, which is awesome. I have spent so much time on this only to fail over and over again. Second, even though it works, I think I do need to use the bundler, because the practice problems I am doing state that I can run the specs for a problem by doing this: bundle exec rspec spec/spec.rb How do I do this? Do I need to install a Gemfile? Also, I start to get lost when you mention that rspec automatically includes '.../lib' in my load path, because I'm unfamiliar with what a load path is. I'm kind of lost about those options at the end of that paragraph. Although, I think this is different than what I am trying to accomplish, since rspec spec/spec.rb works well, I would still like to know what it all means. Does it refer to the different folders that the files are contained in?
Very true. I frequently forget that exists. Old dog. New tricks.
Oops, my b
But it's amazing, even though it's still in quite early states, it seems to be promising language.
Surely "repositories" should be a hash, and "star" should be "star!" since it's mutating the object. client.repositories[repo_name].star!(options)
If this could read and use actual ruby libraries, it would be amazing.
If your application is small scale, you'll probably just want to use a PaaS like Heroku. If your application is medium-large scale, you'll probably want to use something like Chef or Puppet. (Chef works great on Amazon OpsWorks - formerly scalarium). I don't have much to weigh in on other then that.
[10] results in [1] instead of [1,0].
I'm a rubyist and I find ansible superior to chef/puppet. It's clear, uncluttered and useful for even minimal deploys.
Chef complicates simple tasks into a task of building a centralized infrastructure or applying DevOps as a service. Oh, there's chef-solo, but it strips chef of some useful bits (i.e. attributes), crippling some of the useful recipes. And don't get me started about stuck agents or trying to push changes ASAP. Chef made my life easier, don't doubt it, but it brought its own problems to the party. Ansible, on the other hand, let me describe a server and deploy it when I wanted to.
I have used Chef (a whle ago) more than Ansible but I remember when I dug into Ansible a little bit, I was pretty happy with it. I definitely liked it a lot more than Puppet. From what I remember, (I could be wrong about this), you need a puppet agent installed in each of your hosts...While Ansible just does things through SSH and runs command for you.
How about &gt; arr = json["thingies"].map { | thingy | x = ..... } Basically you are applying that block to each element inside `json["thingies"]` 
My advice to you if you are planning to stick with Ruby (or Python or Node or Go or anything, really) is to get familiar and comfortable with the command line. No clicking buttons, no dragging-and-dropping stuff. Open the Terminal, `cd` into your script's directory, and type in `ruby your_script.rb` and press `Enter`. Now, if you want your code to run automatically when you save the file in your text editor, there are solutions for that (check out [guard](https://github.com/guard/guard), [rerun](https://github.com/alexch/rerun), or [restart](https://github.com/vais/restart)).
Yes, that is the approach I would have taken.
Hmm the second probably. Why?
I have no idea what the original use-case was, but it's been in ruby [since the beginning](https://github.com/ruby/ruby/blob/3db12e8b236ac8f88db8eb4690d10e4a3b8dbcd4/string.c#L1383). It seems to be [rarely used outside test suites](http://codesearch.debian.net/search?q=swapcase+filetype%3Aruby) though..
this is not subset: array = [] of String array &lt;&lt; "aa" puts array
I prefer to build/work with API wrappers that follow the ActiveRecord terminology - it is relatively familiar for a lot of Ruby developers also. 
Ask for the elements of the array in a loop.
Please post more of your code so we can help you. As it stands now, the question makes no sense at all. Why are you trying to use `gets.chomp` to work with arrays of integers? (`gets` is for working with IO and returns a string, and `chomp` is a string method) &gt; i need to change all of Theis values with one command. What kind of a requirement is that? Why only one command? If you are looking for the shortest way to do something, first do it the long way, post that, and people will suggest shorter/more idiomatic alternatives. Like many here, I would love to help you if you ask a better question. Your English is not the problem - post Ruby :)
I've been looking over http://stackoverflow.com/questions/25555468/ruby-loop-through-array-and-extract-elements for the past 30 minutes, but as i understand asking for the elements of the array will only print the value, and not replace? Edit: btw thank you for taking your time trying to help a greenie like me
I suppose it helps being super specific in this kind of subforum ^^^ Bit of clarification. I'm working with 3d coordinates, and the vectors between them. I'm tasked to changing the coordinate sets using manual input, but being a bit of perfectionist i'd like to cook it all down into an .each statement or something simular to make it nicer to look at. require 'matrix.rb' coordinateOne = [6,1,3] puts "Please enter your new X coordinate" coordinateOne[0] = gets.chomp.to_i puts "Please enter your new Y coordinate" coordinateOne[1] = gets.chomp.to_i puts "Please enter your new Z coordinate" coordinateOne[2] = gets.chomp.to_i v0 = Vector.elements(coordinateOne) puts v0.inspect So far i made this work, but for each set of coordinates i'd need 6 lines, and if i have, say 100 that'd be bit messy. In the ideal world i'd like to write something along the lines of coordinateOne = "Please enter your new coordinates: " + gets.chom.to_i Though such statement would mess with my vector element :/ 
You're thinking of data bags rather than attributes -- Chef-solo has always supported attributes, and these days it also supports data bags. It's being merged into the regular Chef client now, but that appears to be a good thing instead of a bad thing for now.
I like the idea of Ansible. But Chef makes it easy to customize a fair bit in Ruby. In Ansible, your choice of programming language is custom-lang-on-top-of-YAML, falling back to Python, falling back to Bash. It's really awesome for tiny deploys. But for larger deploys... Well, have a look at this example: "https://github.com/radar/ansible-rails-app/tree/master/roles". The individual steps are still simple, and overall it doesn't look bad. However, it's completely unable to fix a botched deploy, or an existing server with customizations. Now think about how to fix the Ansible playbooks to make that happen... Basically, Ansible is a great idea if you'll always be deploying cleanly and from scratch. I love that idea. I have never worked at a place where things work that way, nor been in that position for my own personal projects. 
Count me out on that one. Here's my alternative: `client.fetch_repository(repo_name).star(options)` There are problems with mimicking AR's api. Namely, ActiveRecord generally runs on top of a database connection, where `SELECT`, `INSERT`, `REPLACE`, and `DELETE` statements are all generally available. That's basically nothing like an API gateway, unless the API itself is a thin veneer over a database (which I suppose is often the case for `rails-api` projects, sadly). Just think about what you have to do to make `repositories.find` work. Is `repositories` going to return something similar to an `ActiveRecord::Relation`? Is there any type of entity in an HTTP API that is anything like an `ActiveRecord::Relation`? It takes a lot of syntactic sugar to implement `ActiveRecord::Base`'s duck type -- and even then you'll only implement a small subset. I can't imagine any scenario where that is worth it. Programmers who don't feel comfortable without AR's API need to adjust, not the APIs, imo.
He's just looking for people to play minecraft with.
use `irb`. There also is [pry](http://pryrepl.org/), which is more powerful.
I can agree with that. This is, however, not really related to the issue I'm talking about in my first post but more of a question of personal preferences. EDIT: Also, it wouldn't be that hard to implement, right? `client.repositories` could return a `Repositories` class which has the #find and #create methods. Some methods would be used in all resources so the shared functionality could be put in a Base class which the resource classes inherits from. class Repositories &lt; ... def initialize(client) @client = client end def find(repo_name) repo = @client.get("/repositories/#{repo_name}") Repository.new(client: @client, repo: repo) # Or whatever you want to do end def create(args) # ... end end class Repository &lt; ... def star! # Star the thing... end # ... end Also, I don't think /u/lcpriest meant that you should make a complete duck typed interface and implement the entire AR API, just make use of some shared terminology.
&gt; Surely "repositories" should be a hash Not really, most APIs have show and index endpoints, so setting it as a hash assumes an index, which isn't necessarily correct. I agree with the star! though.
That makes sense. I think it's best to throw my analogy out of the window. I tend to implement a find, where, and an all. The JSON response is parsed into individual objects in an array, not a collection class. Each object would have a new, create, update and destroy action.
When I wrote the [ZbxZPI](https://www.github.com/red-tux/zbxapi) Ruby Wrapper for Zabix, I went a slightly different approach. I created a set of base classes to take care of the connection portion and define a base DSL. Then using the DSL I defined the interface to the API, but also gave it versioning information, meaning that you may go down different code paths based on the version of Zabbix you are connecting to. In addition I wanted to have a "pure" object interface to multiple Zabbix servers, such as server1=ZBXAPI.new and server2=ZBXAPI.new unlike active record which requires you to inherit the AR class into a new class and in that new class define the connection parameters. In addition because of the DSL the library will throw back a Ruby no method error if you call an API method which does not exist, rather than waiting for the connection to occur and an obscure error to come back which at the time did not tell you it was an undefined method call, just a general error. Either way, it's another way to consider.
And you would put the new, find and where as class methods on the, in this case, Repository class? That would probably work, I guess you don't actually need a collection class as in my example above.
Heroku doesn't scale down to personal projects. I want PostGIS and SSL. That's at least $250/month on Heroku (assuming 2 dynos). And if I want a staging environment, it's double. And I have 3 or 4 personal projects like this. These are small apps (some are just APIs for an SPA) with practically no traffic, so it really doesn't add up.
&gt; So far i made this work, but for each set of coordinates i'd need 6 lines, and if i have, say 100 that'd be bit messy. What you have is technically fine. Now put this code you have for getting a single set of coordinates into a method, then call that method as many times as needed. But again, you would not make a user input 100 coordinates this way, would you? I imagine in the real world you would be reading the coordinates in from some sort of a data file. So, I guess I still don't get the real business problem you are trying to solve. &gt; In the ideal world i'd like to write something along the lines of coordinateOne = "Please enter your new coordinates: " + gets.chom.to_i def ask(msg) puts msg print 'X: ' x = gets.chomp.to_i print 'Y: ' y = gets.chomp.to_i print 'Z: ' z = gets.chomp.to_i [x, y, z] end coordinate_one = ask('Please enter your new coordinates:') 
Happy to answer any questions about it. :)
for me it stops when $droneOneP[0] = 8 if you make it $droneZeroP[0] &gt; $droneOneP[0] it'll stop at 7
If you are interested in this, you may be interested in [topaz](http://docs.topazruby.com/en/latest/) Basically it is pypy for ruby.
You could use String#swapcase to match passwords even if Caps Lock is on (but without being completely case-insensitive as #downcase or #upcase would be): password = [password, password.swapcase].min [InfraRuby, a compiler and runtime for Ruby on the JVM](http://infraruby.com/live), also implements String#swapcase. 
The print in the else statement won't be true ever since it'll only trigger once `droneOneP` increases to be greater than `droneZeroP`. If you want it increase only to 6 (meaning 1 less than `droneZeroP`), then the if statement should read like this: if $droneOneP[0] &gt;= $droneZeroP[0] - 1 Although, if you do this, then the else statement won't be true. So you've got a bit of a conflict there -- do you want it to be 6 when it exits the recursive callbacks or do you want it to be 7 (i.e., the same as each other). In terms of looping, you can/should use the `loop` construct since your version recursively calls itself. There's a limit to the number of recursive calls you can do in ruby. Using the `loop` construct has no such problem. You can rewrite it like this: $droneZeroP = [7,1,1] $droneOneP = [1,2,1] def droneRadar puts "A new new location of our main drone have been detected. Scanning and adjusting position of swarm.. Standby" loop do sleep(3) if $droneZeroP[0] &gt;= $droneOneP[0] puts "They are not even. Hightening droneOneP" $droneOneP[0] = $droneOneP[0]+1 puts $droneOneP.inspect else break end end puts "they are even -1" end droneRadar edit: You can read about different ruby loops in the pickaxe book (highly recommended): http://ruby-doc.com/docs/ProgrammingRuby/
Thanks for the input :) I went with "if $droneZeroP[0]-1 &gt; $droneOneP[0]" This way i can keep it at 6 :)
I think this reveals one of the key points of API wrapper design. Namely, you need to figure out what the key elements of the system you're interfacing are and then present them in the idioms of your language. In this case, the server makes perfect sense as the top-level abstraction of the API, and hiding all of the connection details under it is clearly the appropriate thing to do.
Thank for the info on loop. I'll definately keep that in mind for future programming. I did not know there was a limit on the recursive calls :) I'll check out the link as well ^^
Yeah, it's called a stack overflow. You can trigger one like this: def test test end test
Thanks, it's also worth pointing out that the API had an object/method grouping as well, which my library follwed as well. Thus when you want to get a particular item history by id you would do (using the above instantiated servers), server1.history.get({'itemids'=&gt;[1234,5678]}) or server2.history.get({'itemids'=&gt;[9876,5432]}). One of the biggest challenges initially was that the Zabbix UI is written in PHP, and the person who wrote the API didn't care about how PHP handled arrays and hashes. Thus when php would output a JSON representation of an array, it looked to Ruby like a Hash. One goal initially, but never fully realized was to normalize this data when received, especially since the output from the API would have been rather version specific.
Ha - I guess I've always had the fortune of dealing with clean deploys. What sort of issues have you run into fixing deploys - Ansible tasks are supposed to be idempotent, so usually re-running the the deploy fixes things for me. As for a server with customizations, although its ugly, one could conceivably just drop down to a shell/ruby script?
His strongly depends on the person, not language. What causes frustration and provokes yelling? Lack of knowledge usually. And moving to other camp won't do much help here. Improve what you know well already. Things are moving too fast, you can never tell if you're doing the right bet be it Ruby or Scala or Go or Rust or whatever comes to mind.
For future references these things are called [REPLs](http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop) (read-evaluate-print loop).
Since you're in a Ruby/Rails bootcamp, I would suspect you'll pick up a lot of knowledge about application development, but not a lot of CS fundamentals. I'd pick up an introductory algorithms/data structures book, and try implementing some things from it. I believe even web developers should have a solid grounding in CS, since it *does* end up affecting us in ways you might not expect. Especially when learning new languages- the syntax may change, but the fundamentals won't. Past that, also consider learning some sysadmin stuff. I've been called on to actually set up servers before, and it's not always as fun or easy as actual feature development, but being able to actually put together an environment for your software to run in seems to be an oft-overlooked skill. I'm on mobile right now, but I'll post some links to reading material when I get back to my computer.
Challenge yourself to level up on the things you already know well, for example CSS and HTML. Learn about best practices and the debates about what "semantic" means for markup and styling. A fun exercise: Code up a multipage site with forms using a SASS adapter between bootstrap and your view code. Mastery is achieved when you can swap out bootstrap for foundation (with two different wrappers) **without ever touching your view code**. Have fun!
Yeah, that whole last paragraph went way over my head, lol. 
This is true. We might break into these the next few days, but I can't say for sure. I've seen most of this mentioned in a few books that I've been thumbing through. 
You're talking about languages, /u/mhink is talking about data structures and algorithms - not necessarily "programming" but CS fundamentals. For example, runtime complexity is something I use almost every day and is crucial for working on web at scale - a sub-optimal bit of code in your controller may balloon into a huge issue as you throw more and more users at it. This is also crucial for interviewing - you'll often run into a situation where you're asked to defend your choices of algorithm, and a big part of it is knowing the runtime complexity in Big O notation. Another suggestion if you're looking to get into web...what about databases? I know a lot of otherwise good devs that lean far too heavily on ActiveRecord, and wouldn't know how to do some of the same queries in raw SQL, which is a shame because there's generally quite a bit of room for optimization in the persistence layer of your average app.
Totally worth exploring. Understand these is the difference between using Sinatra, and being able to write your own Sinatra :)
Totally worth exploring. Understand these is the difference between using Sinatra, and being able to write your own Sinatra :)
Thanks for that clarification. As for databases, we're going to learn postgresql in due time. 
nice.
Railstutorial.com is the best way to get some solid hours into web development and develop something useful. Not only that, but the way it teachers goes over a lot of basic work environment processes that are used by many companies and make good talking points in interviews. (git, autotesting, rspec, etc).
Oh! Yeah, I completely forgot about SQL. (Which is funny because I've recently been working very hard to get my SQL skills back up to snuff!) Yeah, a solid knowledge of SQL is a must- once you start working with systems larger than just tutorial-size apps, queries WILL come back to bite you if you're not cautious about selecting indices, avoiding N+1 queries, and figuring out how to join tables correctly. Honestly, building database interactions and managing a database is one of the trickier parts of web development, and one that isn't nearly as conducive to "picking it up as you go along"- since most of the serious considerations of DB code only come into play once you have a bunch of, well, data.
Basically the only advice you'll get on this sub is to learn CS fundamentals, which comprise of algorithms, time complexity, data structures, discrete structures, etc - I've been a full time rails dev for a year now and I've done everything from rescue projects for ivy league school departments to run of the mill websites from start to finish by myself. I did start off freelancing so I've actually done more like 2-3 years of webdev, but my point would be that if you want to be an amazing junior webdev. Don't touch any of the crap I've just mentioned. Get to know your tools and learn how people use them. Follow conventions and stay simple and well within the lines of doing exactly what everyone else is doing. You'll be an amazing asset to your team and then on down the line you'll start to make your own preferences and have your own opinions. Then you can tackle these more advanced principles to try and hone your craft down to a science, but for now, that junk isn't helping anyone in webdev and it doesn't affect you in ways you might not expect. I spend half of my time fixing programs from geniuses that instead of learning their tools, they learned 'the basics' and try to implement EVERYTHING themselves. They get so damn clever that they back themselves into a corner and abandon the project all together. These aren't idiots that are making the projects either, these are people working on their masters at ivy league colleges that think they are too good to use other peoples tools so they recreate the wheel any chance they get. My advice is to start off getting comfortable in linux and the command line. If that's not what you want to do, start building an actual app in rails and tinkering around with popular gems. Read through some api wrappers, maybe play around with a reddit api wrapper and make a script that pulls some data from reddit. If you're a webdev a huge tool you'll need to understand is the browser. Understand how sessions work. Understand the difference between a session based authentication and a token based authentication. Get to know an authentication library. I'd say start with something less complex like sorcery, but devise is a great choice too, it's just much more complex. Really you'll just want to get comfortable answering your own questions with the docs provided. That means you'll need to go out and build something creating your own problems.
nah, it's just an off day and i'm bored. i could reach out to them, but wanted to see what reddit said. 
Nothing will be more useful to you than to go directly to the official site and pour over the documentation. Honestly, any tutorial will be a hit-and-miss compared to having a solid understanding of the framework. But if you must, just go to youtube and search "sinatra tutorials", sort by view count. That way you'll probably find the most user-friendly one out there.
Right now http://24pullrequests.com/ is going on. There's also codetriage.com, codemontage.com, and contribhub.com ( haven't tried it ). There are others if you search. All these work via github. 
Code for America's [Civic Tech Issue Finder](http://www.codeforamerica.org/geeks/civicissues).
I have read both. While they seem like the topics are the same the focus of each book is very different. Sandi talks about object oriented design through the use of the S.O.L.I.D. principals. Russ talks more about common design patterns and how they are implemented in Ruby. Such patterns are built using the SOLID principals. In my opinion understanding SOLID will help you more than knowing any of the established common patterns. http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**SOLID (object-oriented design)**](https://en.wikipedia.org/wiki/SOLID%20%28object-oriented%20design%29): [](#sfw) --- &gt;In [computer programming](https://en.wikipedia.org/wiki/Computer_programming), __SOLID__ (__Single responsibility, Open-closed, Liskov substitution, Interface segregation and Dependency inversion__) is a [mnemonic](https://en.wikipedia.org/wiki/Mnemonic) [acronym](https://en.wikipedia.org/wiki/Acronym) introduced by Michael Feathers for the "first five principles" named by [Robert C. Martin](https://en.wikipedia.org/wiki/Robert_C._Martin) in the early 2000s that stands for five basic principles of [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming) and [design](https://en.wikipedia.org/wiki/Object-oriented_design). The principles, when applied together, intend to make it more likely that a [programmer](https://en.wikipedia.org/wiki/Computer_programmer) will create a system that is easy to [maintain](https://en.wikipedia.org/wiki/Software_maintenance) and extend over time. The principles of SOLID are guidelines that can be applied while working on software to remove [code smells](https://en.wikipedia.org/wiki/Code_smell) by causing the programmer to [refactor](https://en.wikipedia.org/wiki/Code_refactoring) the software's [source code](https://en.wikipedia.org/wiki/Source_code) until it is both legible and extensible. It is part of an overall strategy of [agile](https://en.wikipedia.org/wiki/Agile_software_development) and [adaptive programming](https://en.wikipedia.org/wiki/Adaptive_Software_Development). &gt; --- ^Interesting: [^Robert ^Cecil ^Martin](https://en.wikipedia.org/wiki/Robert_Cecil_Martin) ^| [^No ^Silver ^Bullet](https://en.wikipedia.org/wiki/No_Silver_Bullet) ^| [^GRASP ^\(object-oriented ^design)](https://en.wikipedia.org/wiki/GRASP_\(object-oriented_design\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmhmtny) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmhmtny)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I read "Object Oriented Design in Ruby" prior to reading "Eloquent Ruby". While I enjoyed them both, I think Metz's book is a little more accessible and interesting to someone who had no experience with design principles. I would recommend reading them both, but for me the order of reading Metz, then Olsen worked out pretty well.
Yeah, off by one error. fixed, thanks.
heh. *all* open source projects are short of contributers! just find something you're interested in and send a patch / pull request
24pullrequests is awesome! Looks like I have a December hobby :)
In that case I'd probably do something like this: @cards = case arg when Enumerable arg.to_a when String arg.scan(/.../).map {|m| ... } else raise sprintf("Unknown argument %p", arg) end Of course, this evaluates the type under the hood but a bit more elegant.
Hey GOODLUCK! I plan on attending a nyc boot camp soon once I become more familiar with the fundamentals of ruby. I hope you get the most out of your experience! 
That commit is from a migration from svn though. It's also dated 1998 while the file contains a copyright notice with 1993 as a date.
Many open source projects, especially high profile ones, are downright hostile to contributions coming from outside the clique. 
$LOADPATH is similar to $PATH in the command line. Doing a `require 'shortpath'` will look for a file called 'shortpath.rb' in every directory in $LOADPATH. As for bundler, check out http://bundler.io for more instructions
Sorry for replying so late. Thanks a lot @CaptainKabob
POODR is great if you have no exposure to OOP. It's not really essential reading if you have a decent grasp of it already, though. It's still a fun read, though, if you're into that sort of thing. Sandi as a very good writer.
I still disagree with you pretty strongly. That stuff is great and all, but I've been a jr. dev for 3 (two shops I freelanced for part time, current job is remote full time salaried position) shops now and 99% of the stuff I've been asked to do was very boilerplate + learning gem DSLs. You make an interesting point for the interview. Yes, most companies will ask you ridiculous (of course this is only my opinion) trivia questions, but not all of them. If there is a reason to learn the science basics, it's because you'll need it for most interviews. I went through 15 interviews in just over a month and had 3 offers (two were just long contracts) with no tech interview. The one I ended up taking was a two week paid contract as tryouts. It isn't necessary to know 'the basics' for a loooooong time in a webdev career. That's just a myth perpetuated by the majority of computer science graduates who have been told that the whole time they were in college. I dropped out as a junior, but all I gained in college were bad coding habits and fundamentals I've long since forgotten about. The things I hear from people I know graduated with a CS degree are things like "Learn the fundamentals and it doesn't matter what tools you're using, you'll be a good programmer". This isn't necessarily untrue information, but it does not prepare you in the least for a jr. position. In this line of work you can never stop learning and therefore you should always be learning things that will be useful in your immediate future. I can't even begin to recount how many C tutorials I went through because people told me I needed to learn low level crap or I would never be able to make a program. I was so deeply invested into that low level crap that I actually believed it would take me years to make a simple useful app, because it takes about that long to make useful stuff in low level languages. I do want to correct myself earlier, though, as I thought I was in the /r/cscareerquestions sub when I said &gt; Basically the only advice you'll get on this sub is to learn CS fundamentals I don't expect that's true in a ruby community where we know the most valuable metric in programming is speed of development, while the most important metric in college seemed to be saving CPU cycles at all cost. This technical field is seeing a large shift where it's becoming easier and easier to make webapps which are the most desired apps at the moment. (I'm including mobile apps as they are often just webapps themselves) With that abstraction and ease of plug 'n play I think many older devs are afraid they won't be seen as an intellectual and they are doing whatever they can to convince themselves and everyone else that you have to be smart to do what we do. That just isn't true. Anyone can do webdev if they have the patience to learn the tools and learning the tools is just reading docs, it's not studying complex theory or even low level data structures.
It's usually more of a case that text is bad for first impressions and otherwise well thought out opinions come across as harsh criticisms. I understand your sentiment though, it can be really frustrating.
That's indeed an excellent point to make!
SciRuby could use contributors. =) http://sciruby.com
Cool, was thinking of starting tot write tests for my own code, but I keep putting it off. Good work on helping another project!
&gt; I've been a jr. dev Just FYI, once you get past junior dev you WILL have to be familiar with Data Structures or you are pretty likely to crash and burn if asked to start a complicated (not cookie cutter) application from scratch. Note I'm talking about something with actual business logic, not something implementing a simple "Get data from database, display to user, take input" website(which are the vast majority of websites).
I don't think we're disagreeing as strongly as you might think, but this is all going to vary widely depending on your definition of "jr webdev" or even really "webdev". For a bit of background on myself, I'm a pretty senior web engineer, I specialize in data and analytics - BI and otherwise - and outside of web, I'd say my strengths are systems design and big data (ETL pipelines, map reduce, storage, etc), so hopefully that adds a bit of context to what I'm saying. Here's the thing - I don't think I necessarily disagree with a lot of what you're saying in the context of what OP should focus on in the short-term, but I do think it's short-sighted, and is riddled with bias ("a myth perpetuated by the majority of computer science graduates", the bit about "older devs" etc). I think you're taking your experiences and applying them as gospel, which is unfortunate - just because you found you learned bad programming habits in college doesn't mean it's the same for everyone else. What you said isn't necessarily wrong - a lot of web development *is* reading docs and learning tools - and yes, you absolutely should always be learning things that are useful to you on the job. It is becoming easier to create web applications, and there's a vast amount of OSS (gems, frameworks, etc) to help you. However, I really wasn't exaggerating when I said I use runtime complexity almost every single day. The attitude of "it's all plug-and-play! Just find a gem that already does the thing you want to do" will stop working when a) there isn't a gem out there that does what you want or b) you're working at scale. We've got around 20k unique users on our app on any given day, and while that's not crazy huge by any means, it's enough to where a choice of, say, looping through an array instead of using a hash could cause enough of an impact on performance to the point of it affecting conversion...you could literally measure a sub-optimal choice in dollars, and that example is a simple choice I would be expecting a junior guy on our team to be able to make. I think you're correct in that OP should focus on tools and on-the-job training over fundamentals in the short term. I think you're very wrong that the importance of fundamentals is overstated. Ultimately, what it comes down to is this: I might hire the guy or gal that has on the job knowledge of agile development, TDD, CI/CD, and amazing git skills over someone with an MS but no practical training, but they'll both lose to someone that has all of the above. 
Oh yeah, I agree. I don't think the apps' the average web developer deals with would be considered "at scale" though.
Oh yeah, just pointing out that even simple apps can get tricky, mainly as another point against /u/dangsos's argument. 
If you want to be able to input them in the form of "x,y,z" you could use split on the input first: x,y,x = gets.chomp.split(',')
Can you give me an example of a project that will need this low level understanding? I'm currently on the tail end of a project for a company that has massive csv files they want processed for errors and then uploaded to a website routinely. I guess I had to make a few cleverish decisions about how I should handle making sure I only grabbed new files and grabbing the appropriate md5s, etc. I built the entire thing from scratch with no framework, nothing. It wasn't that hard either really. I just followed some tutorials and used some api wrapper gems plus the csv stdlib docs. Don't get me wrong, I did a lot of work to make this happen, but nothing I did required more than a few minutes of consideration, it just took a lot of docs reading.
Again, it's going to depend widely on your definition of junior dev, which in turn depends on where you're working. I expect junior devs that I'm interviewing to have a basic working knowledge of data structures and algorithms. YMMV.
Right, many of the companies I applied for expected as much, too. My whole soapbox is that none of that is needed to be a junior dev and there are going to be companies out there that realize that and make successful business choices because they open up their talent pool immensely by judging candidates based on what they need to know to do the job today and not on what they might need to know to do a job you might put them on in two years.
And rvm.io as well.
And my point is that you're using your own (limited) experiences as gospel - like I mentioned, I have a large number of users on my app and I need people that think about performance at even a junior level. That's a successful business choice to me - there's no one-size-fits-all in the industry.
I'm glad that's been successful for you, but I think you're really trying to stretch for a reason to say jrs need 'the basics'. You might as well say that marketing is a key 'basic' jr's need, because they'll be responsible for as much performance critical code as they will marketing strategies.
We're talking megabytes, so you're correct in presuming I'm not dealing with lowish level things like reading inline and processing segments at a time, although if I had to do that it would just be a tutorial and some documentation reading away. It's not like those things haven't been solved by someone else.
this was posted about a year and a half ago, but i just now stumbled across it and noticed it had never been posted to /r/ruby. it's an absolutely fascinating read, although i must say the final chapter hasn't quite clicked for me yet.
It wasn't targeting rubygems.org specifically, it was an attack against DNSimple, so anyone using them has been affected.
It seems there has been an outage on DNSimple. Perhaps it's associated to it?
Yes, [DNSimple](http://dnsimplestatus.com/)'s network provider has been DDoS-ed. [This](http://map.ipviking.com/) is a great visualization of it. Many other services have been affected, like Semaphore, Dribbble, RubyGems.org etc.
I expected ansible VS puppet vs chef, but why doesn't anyone talk about saltstack
 Find a project that interests you, then find and squash bugs, add needed test units or suites, update or add to documentation, and of course add new features. If you find a project that interest you but don't know where to begin, ask an active maintainer or contributor. If you look at the issue tracker on a projects github page you can usually find something to do from there. See this post from yesterday : https://www.reddit.com/r/ruby/comments/2nwnrt/open_source_projects_that_need_ruby_programmer/
If I had to guess, Cyber Monday related.
bummer :c any chance it could be run locally with those permissions?
I have a Github project with a reputation for operating that way. The thing is, I see pull requests for that disable compiler warnings (we're talking C here) because "this commit creates warnings". I see PRs with comments that state "I know this is insecure, but we are not a target so it's OK", where I'm expected to inflict that on every other user. Sometimes you genuinely don't want it. There's a free kick in the head to the next person to email me the helpful suggestion that I could improve performance by rewriting in JavaScript (it's happened twice.. yes.. from a starting point of C).
What an awesome reply. It's really great to see an author more interested in spreading knowledge than the bottom line. Thanks for being active in this sub!
Familiarize yourself with a particular gem. Contribute to gems that use the gem, or contribute to the gem itself. Start with projects where your pull request is more likely to be excepted. For example, READMEs, example code, gems with smaller user bases are easier to contribute to than say, rails.
They are both great books, but I think that Sandi's book is a good choice because it's easy to follow and best of all, it's a fun read as realntl said
And it's back.
An example the author gives: # ary.should be_an_instance_of(Array) is(ary).instance_of?(Array) My thoughts: &gt; the assertion "is" is shorter than "should be" &gt;the method "instance_of?" is just Ruby and not additional DSL you have to learn/remember. &gt; *ary.is.instance_of(Array)* seems assertive to me and his slightly different syntax reads OK I think. One just has to get past the idea that asking a question using "is" and a question mark is just asserting truth.
For me, its not just a matter of getting over the syntax. Using `is(ary)` and ending in question mark seems to conflate with idiomatic ruby ways of checking a condition in order to do something else (if/unless conditions). But the author provides easy alternatives: using `check(ary)` and `assert(ary)` both resolve any confusion for me because they suggest action over question. That said, I'm watching minispec on Github and will adopt it once i see it gains more traction, that there is some more consensus by adopters on choice of syntax, and that it doesn't get abandoned for some reason. I'm rooting for it.
&gt; In a nutshell: Trailblazer makes you write **logicless models** that purely act as data objects, don't contain callbacks, nested attributes, validations or domain logic. This seems either poorly worded or undesirable. Maintainable apps need a rich domain model. Sounds like a lot of the goal of Trailblazer is to put domain logic in "operations" -- which is, at least in theory, a win, imo. But mixing in CRUD semantics doesn't seem ideal: &gt; You can make Trailblazer find and create models for you using the CRUD module. If CRUD is what you want, then stock rails is likely fine. Trailblazer seems ideal for building web apps where CRUD limits the expressiveness of the domain model.
Because it sucks being unable to bundle all night long I prepared myself now... Feel free to bookmark in case of emergency ;) Updates every hour. https://gems.bmonkeys.net
i'm in a similar boat as you. i just created my first gem and put the source on github. it's a simple library of poker hands. if you'd like to practice, feel free to try and submit a pull request: https://github.com/Jberczel/holdem 
I don't trust you.
I have a future post which talks more about alternative options for sharing knowledge about the data to be used. In the case where "they'll want to use the address lines to populate individual textboxes on a web form" then that form object can act as the template. The address object is passed to the template as a value, but you could provide setters instead and the address would control what data to send. Returning an array of line strings could work too, but maybe you want individual bits of data and don't want the city and province joined already. There are many ways to attack the problem but in the least, by sending commands and passing values to the object you can push the responsibility into the place you deem correct.
Cool! I'll look at this and give you some feedback.
Thanks -- I think I get where you're going with this. I'll keep reading your posts and playing with these ideas. The idea of passing templates is neat, and not one I would have instinctively reached for. Another example where I can see it being very useful in a case where we want to pass such 'templates' to handle (display/print/parse) documents that might be in different markup languages.
I may be picking at your example too much, but there's an escaping issue with `HtmlTemplate#display_address`: Where do you call `html_escape` and/or `html_safe`? You should html_escape the address attributes before joining `&lt;br/&gt;`. Personally, I would avoid doing anything with HTML in these classes and just use [simple_format](http://api.rubyonrails.org/classes/ActionView/Helpers/TextHelper.html#method-i-simple_format) in the view.
You forgot to 'codeify' your first block of code with four spaces. It all got maashed into one.
I have no idea how to 'Codeify' anything. Though I edited it to put spaces in there. It's still mashing together with the regular text. I'm so new at this its ridiculous 
start each line with 4 spaces or enclose each line in backticks (the symbol next to 1). You can also install Reddit Enhancement Suite if using chrome/firefox and it has a bunch of auto format buttons.
Try [Reddit Enhancement Suite](http://redditenhancementsuite.com/). It has live preview.
Also, see http://www.reddit.com/wiki/commenting for general formatting help.
Assume it's not rails... Or that it doesn't matter. For the point of the article that might be distracting information, but it's a good point to address. Thanks!
So what are you having problems with?
Well for starters, can you suggest/recommend any good environments? I haven't been able to find one that isn't just command line. They suggested repl.it(a browser-based compiler) but it crashes all the fucking time. So its hard to just brute-force trial and error the problems. 
I hope youre working on a *nix environment; its a lot easier than windows. Install [pry](http://pryrepl.org/) locally to test out your code. Also, get sublime text or ruby mine to help you code. They have awesome tools.
appreciate that. as a beginner programmer, really just wanted somebody to do a quick glance and make sure everything looked tidy.
Formatting this to how I think OP intended: def players puts "I invite you both or...if being alone is your thing. You! To Battle in the ancient game of the gods, TIC TAC TOE! LET THE BATTLE BEGIN!!!" print "First I will need the first Player's name....for records...yeah thats the ticket?" @player1 = gets.chomp print "Ahh #{@player1} tis a silly name. And you player two? " @player2 = gets.chomp puts "" puts "So heres the board ladies and gents. Check out the grid below and pick the number that where you want to move move: " puts " 1 | 2 | 3 " puts "---+---+---" puts " 4 | 5 | 6 " puts "---+---+---" puts " 7 | 8 | 9 " puts "Okay, you got that? Good, now heres the deal i'm going to have to randomly assign you guys your piece's because as I hope you can tell by now this isn't Farcry 4, this is a text based Tic Tac Toe game. So you take what you can get right?" puts "" puts "So with some random computer magic " if rand(2) == 0 @player1Piece = 'X' @player2Piece = 'O' puts "Boom! #{@player1} is #{@player1Piece} and #{@player2} is #{@player2Piece}." else @player1Piece = 'O' @player2Piece = 'X' end puts "Boom! #{@player1} is #{@player1Piece} and #{@player2} is #{@player2Piece}." end # I store user info in a instance variables so I can use them across the game. I was thinking of using a hash but kept getting compiling errors for some odd reason. #Next I create two new methods and another instance variables to create the grid and then have display inherate it. So it can be displayed to the user. def create_grid @grid = { '1' =&gt; ' ', '2' =&gt; ' ', '3' =&gt; ' ', '4' =&gt; ' ', '5' =&gt; ' ', '6' =&gt; ' ', '7' =&gt; ' ', '8' =&gt; ' ', '9' =&gt; ' ' } end def display puts "" puts " #{@grid['1']} | #{@grid['2']} | #{@grid['3']}" puts " #{@grid['4']} | #{@grid['5']} | #{@grid['6']}" puts " #{@grid['7']} | #{@grid['8']} | #{@grid['9']}" puts "" end #Next I make a loop to set players turns. I decided to use even and odd numbers since there are only nine possible moves before a draw is decided. So that no matter what it will stop at 10. def play number_turns=1 while number_turns &lt; 10 if number_turns.odd puts "It's #{@player1} turn!" else puts "It's #{@player2} turn!" end number_turns+=1 end end #After that I create the players turns. I put a conditional in there so the app knows who goes when. def player_turn(player) if @player1 cell = gets.chomp else cell = gets.chomp end unless @grid.include?(cell) #I check to see if the user has entered a number for the grid. puts "" puts "it has to be a number from 1 to 9" end if @grid[cell] == ' ' # I also check to make sure the cell is empty. If not I alert the user and make him choice again. @grid[cell] = player else puts "" puts "That cell's taken, buddy. Try again!" player_turn(player) end show_grid end def game_checker # From there I create a game checker to check all possible winning combination using if/elseif conditionals and logic statements to control flow. I set the condition to whether cells are equal to each other and not empty. end_game = false if ((@grid['1'] == @grid['2'] &amp;&amp; @grid['1'] == @grid['3']) &amp;&amp; (@grid['1'] != ' ' &amp;&amp; @grid['2'] != ' ' &amp;&amp; @grid['3'] != ' ')) end_game=true victory=@grid['1'] elsif ((@grid['4'] == @grid['5'] &amp;&amp; @grid['4'] == @grid['6']) &amp;&amp; (@grid['4'] != ' ' &amp;&amp; @grid['5'] != ' ' &amp;&amp; @grid['6'] != ' ')) end_game=true victory=@grid['4'] elsif ((@grid['7'] == @grid['8'] &amp;&amp; @grid['7'] == @grid['9']) &amp;&amp; (@grid['7'] != ' ' &amp;&amp; @grid['8'] != ' ' &amp;&amp; @grid['9'] != ' ')) end_game=true victory=@grid['7'] elsif ((@grid['1'] == @grid['4'] &amp;&amp; @grid['1'] == @grid['7']) &amp;&amp; (@grid['1'] != ' ' &amp;&amp; @grid['4'] != ' ' &amp;&amp; @grid['7'] != ' ')) end_game=true victory=@grid['1'] elsif ((@grid['2'] == @grid['5'] &amp;&amp; @grid['2'] == @grid['8']) &amp;&amp; (@grid['2'] != ' ' &amp;&amp; @grid['5'] != ' ' &amp;&amp; @grid['8'] != ' ')) end_game=true victory=@grid['2'] elsif ((@grid['3'] == @grid['6'] &amp;&amp; @grid['3'] == @grid['9']) &amp;&amp; (@grid['3'] != ' ' &amp;&amp; @grid['6'] != ' ' &amp;&amp; @grid['9'] != ' ')) end_game=true victory=@grid['3'] elsif ((@grid['1'] == @grid['5'] &amp;&amp; @grid['1'] == @grid['9']) &amp;&amp; (@grid['1'] != ' ' &amp;&amp; @grid['5'] != ' ' &amp;&amp; @grid['9'] != ' ')) end_game=true victory=@grid['1'] elsif ((@grid['7'] == @grid['5'] &amp;&amp; @grid['7'] == @grid['3']) &amp;&amp; (@grid['7'] != ' ' &amp;&amp; @grid['5'] != ' ' &amp;&amp; @grid['3'] != ' ')) end_game=true victory=@grid['7'] else end_game=false end # I was honestly not sure how to structure this bit of code with the rest but I figure if the victory grid was equal to X than the below conditional would excecute and if not the else statement would cover when 'O' won. if victory == 'X' puts "Victory belongs to #{@player1}" return end_game = true else puts "Victory belongs to #{@player2}" return end_game = true end end
twitch is going nuts I'ma give it an hour and stream again 7pm CDT
Interesting. Has anyone here ever used IRuby Notebook?
I worked with a group of guys that used the "presenter" pattern to deal with this sort of thing. Basically the presenter is a wrapper for a model instance that can encapsulate display logic. So you might have a UserPresenter#html_address method that you call from your ERB template. 
My guess is the bootcamp is looking for an Object Oriented approach. I see you are using instance variables, but there doesn't appear to be any classes in your code? I would do some basic work with Object Oriented Programming first. For Tic Tac Toe: An easy way to organize the code is to have the following classes: -Board -&gt; any method related to reading/writing to the board will go here. -Player -&gt; any I/O between the game and the player will go here. I made a subclass for a HumanPlayer and a subclass for a CPUPlayer. - Game -&gt; This is where the actual game logic goes (whose turn is it, turn changing, starting/ending a game) Basically, your code looks rough because its just one super long block. You are trying to decouple your methods a bit, but really they should be EVEN MORE DECOUPLED. The mantra that helps me is "One method does ONE THING" Source: A current student at one of the more "well known" bootcamps 
Look into regular expressions and Ruby regex literals
gsub takes two args: 1) A pattern or string to look for 2) Something to replace that pattern or string /u/threeifbywhiskey explained the first arg. The second arg is just an empty string so this gsub is replacing all non-word characters with an empty string. Reference for RegExen in Ruby: http://www.zenspider.com/Languages/Ruby/QuickRef.html#regexen If you look on confreaks Nell Shamrell has done many talks on regexs in Ruby. Any one of the early ones should give you more details. 
Use the latest ruby 2.1 which at the moment is 2.1.5 That supports new and old hash syntax
- by "pre Ruby 4" I'm pretty sure you mean pre Rails 4. Current Ruby version is 2.1.5 or something close to that. If you're not sure of the difference and linkage between Ruby and Ruby on Rails, I would look into it more. - RVM is a 3rd party Ruby Version Manager. It will allow you to change (upgrade or downgrade) what version of Ruby you have installed on your computer. This doesn't really alter the syntax of Ruby unless the update contains changes to Ruby's Syntax. 
This is nice post. Though this isn't an OOP thing, I would propose to further replace all the "if empty then nil" checks with a single operation at the bottom: [street, city_province_postal_code].reject(&amp;:empty?).compact.join("\n") This saves us some lines and code duplication, but some might say the amount of operations compressed on a single line makes the intent difficult to grasp. A compromise to better explain through code might be: non_empty_fields = [street, city_provience_postal_code].reject(&amp;:empty?) non_empty_fields.compact.join("\n") Personally I'm a big fan of removing conditionals as much as possible(within reason). I find that having less branching logic means I can think more about programming as data transformations. What do you guys think?
What tutorial are you using? Maybe give [Hartl's tutorial](https://www.railstutorial.org/) a try (free to read online). It's written for Rails 4 and I think it would be best to learn the newest version and not going for 3.x. RVM only allows you to install several versions of Ruby and Rails and manually switch between them. A nice thing if you have several projects and not the time to update them all, but not really what you want to do if you just want to learn. Personally I prefer to use Linux containers or VMs if I need different versions. 
Incidentally, [here](http://ruby-doc.org/core-2.1.5/Regexp.html) is the ruby regular expression documentation.
I'll take a look :)
Haven't gone through it all yet but: In lib/holdem/poker_hand.rb you have the following code block: def_delegators :@poker_rank, :rank, :score rank_methods = [ :straight_flush?, :quads?, :four_of_a_kind?, :boat?, :full_house?, :flush?, :straight?, :three_of_a_kind?, :trips?, :two_pairs?, :two_pair?, :pair? ] def_delegators :@poker_rank, *rank_methods Why not put :rank and :score into the rank_methods array? 
Please upload it in Youtube it will be much easier for many.
Trying again tonight, twitch is owned by google and auto uploads to youtube, unfortunately I forgot copyrighted music gets auto-muted by them so I have to make the video again tonight
Given that you have template objects that can render person as a formatted address, why does Person (or Address) need to have any knowledge of the template at all? Any caller needs access to both the template and the Person anyway. There are a few benefits to not putting render methods on Person. Suppose some of your rendering concerns change. For example, you add a render_email method to the template. Then your Person needs to be modified implement render_email, even though nothing about Person has actually changed. This is needless boilerplate. More generally, it's not clear design for the Person class to know anything about displaying itself. At the very least, these display methods could be extracted into a separate module so that they do not pollute the model class. This module would be mixed into Person: module PersonDisplay def display_address(template) address.display(template) end end class Person include PersonDisplay end But PersonDisplay does nothing here, always just delegating. So, let's go a step further and make the templates into modules, only mixing them in when needed. module HtmlPersonRenderer def self.decorate(person) person.extend(self) end def display_address # whatever end end HtmlPersonRenderer.decorate(person).display_address Now there is no need to pass templates around and Person has no rendering methods. An important additional benefit (as the rendering code becomes more complicated) is that there is no single template class assumed. The implementation of display_address could be decorate the address with an HtmlAddressRenderer. 
I took everything out of classes to run through the code and see where things were going wrong. I originally had it in a single God class but that seemed to not be working so I just did away with it. In terms of class/subclass, I'm iffy on classes. Can i have multiple classes in one program or would i have to create multiple files with single classes with methods in them and somehow merge them later on? Any help is greatly greatly appreciated. 
Cool, I guess I need to start using that twitter thing to let people know I'm streaming. @danandbeard
I'm sure I'll be flamed for this, but really? Ezra was pretty wildly successful, and his death was not a surprise to his family. Do you think he didn't plan already for this or that he had no insurance? Commence downvoting.